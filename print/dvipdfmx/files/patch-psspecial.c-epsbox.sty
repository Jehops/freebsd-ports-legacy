Origin: http://cvs.ktug.or.kr/viewcvs/dvipdfmx/src/psspecial.c.diff?r1=1.3&r2=1.4&diff_format=u

This patch enables to handle dvifile using epsbox.sty.  The epsbox.sty
embeds EPS files with "postscriptbox" directive, but original dvipdfmx
doesn't know what postscriptbox is, showing "Unrecognized special ignored"
and exit abnormally.

See also: http://www.matsusaka-u.ac.jp/~okumura/texfaq/qa/23745.html
(in Japanese)

--- contents below --
===================================================================
RCS file: /home/cvsroot/dvipdfmx/src/psspecial.c,v
retrieving revision 1.3
retrieving revision 1.4
diff -u -r1.3 -r1.4
--- dvipdfmx/src/psspecial.c	2002/10/30 02:27:16	1.3
+++ dvipdfmx/src/psspecial.c	2003/11/28 23:57:51	1.4
@@ -1,4 +1,4 @@
-/*  $Header: /home/cvsroot/dvipdfmx/src/psspecial.c,v 1.3 2002/10/30 02:27:16 chofchof Exp $
+/*  $Header: /home/cvsroot/dvipdfmx/src/psspecial.c,v 1.4 2003/11/28 23:57:51 hirata Exp $
     
     This is dvipdfmx, an eXtended version of dvipdfm by Mark A. Wicks.
 
@@ -260,6 +260,55 @@
     result = 1; /* Likewise */
     do_raw_ps_special (&start, end, 1,
 		       block_pending?pending_x:x_user, block_pending?pending_y:y_user);
+  } else if (!strncmp (start, "postscriptbox", strlen("postscriptbox"))) {
+    char filename[256];
+    double width, height;
+
+    if (sscanf (start+13, "{%lfpt}{%lfpt}{%256[^}]}",
+		&width, &height, filename) == 3) {
+      struct xform_info *p = new_xform_info();
+
+      p -> width = width*72/72.27;
+      p -> height = height*72/72.27;
+
+      {
+	FILE *image_file;
+	char *kpse_file_name;
+	char buf[256], *pos;
+	if ((kpse_file_name = kpse_find_pict (filename)) &&
+	    (image_file = MFOPEN (kpse_file_name, FOPEN_R_MODE))) {
+	  while (fgets (buf, 256, image_file)) {
+	    if ((pos = strstr(buf, "%%BoundingBox:" )) != NULL){
+	      double llx, lly, urx, ury;
+
+	      while (*pos++ != ':' );
+	      if (sscanf (pos, "%lf %lf %lf %lf",
+			  &llx, &lly, &urx, &ury) == 4) {
+		p -> u_llx = llx;
+		p -> u_lly = lly;
+		p -> u_urx = urx;
+		p -> u_ury = ury;
+		p -> user_bbox = 1;
+		break;
+	      }
+	    }
+	  }
+	  MFCLOSE (image_file);
+	}
+      }
+             
+      if(p -> user_bbox && validate_image_xform_info (p)) {
+	pdf_obj *embeded;
+	embeded = embed_image (filename, p, x_user, y_user, NULL);
+	if (embeded)
+	  pdf_release_obj (embeded);
+	result = 1;
+      }
+      
+      release_xform_info (p);
+    }
   }
+
   return result;
 }
+
