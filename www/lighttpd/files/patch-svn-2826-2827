Index: src/network_backends.h
===================================================================
--- src/network_backends.h	(revision 2825)
+++ src/network_backends.h	(revision 2827)
@@ -31,7 +31,7 @@
 # include <sys/uio.h>
 #endif
 
-#if defined HAVE_SYS_MMAN_H && defined HAVE_MMAP
+#if defined HAVE_SYS_MMAN_H && defined HAVE_MMAP && defined ENABLE_MMAP
 # define USE_MMAP
 # include <sys/mman.h>
 /* NetBSD 1.3.x needs it */
Index: src/mod_compress.c
===================================================================
--- src/mod_compress.c	(revision 2825)
+++ src/mod_compress.c	(revision 2827)
@@ -485,7 +485,7 @@
 		return -1;
 	}
 
-
+#ifdef USE_MMAP
 	if (MAP_FAILED == (start = mmap(NULL, sce->st.st_size, PROT_READ, MAP_SHARED, ifd, 0))) {
 		log_error_write(srv, __FILE__, __LINE__, "sbss", "mmaping", fn, "failed", strerror(errno));
 
@@ -499,7 +499,24 @@
 
 		return -1;
 	}
+#else
+	start = malloc(sce->st.st_size);
+	if (NULL == start || sce->st.st_size != read(ifd, start, sce->st.st_size)) {
+		log_error_write(srv, __FILE__, __LINE__, "sbss", "reading", fn, "failed", strerror(errno));
 
+		close(ofd);
+		close(ifd);
+		free(start);
+
+		/* Remove the incomplete cache file, so that later hits aren't served from it */
+		if (-1 == unlink(p->ofn->ptr)) {
+			log_error_write(srv, __FILE__, __LINE__, "sbss", "unlinking incomplete cachefile", p->ofn, "failed:", strerror(errno));
+		}
+
+		return -1;
+	}
+#endif
+
 	switch(type) {
 #ifdef USE_ZLIB
 	case HTTP_ACCEPT_ENCODING_GZIP:
@@ -530,7 +547,12 @@
 		}
 	}
 
+#ifdef USE_MMAP
 	munmap(start, sce->st.st_size);
+#else
+	free(start);
+#endif
+
 	close(ofd);
 	close(ifd);
 
@@ -571,14 +593,24 @@
 		return -1;
 	}
 
-
+#ifdef USE_MMAP
 	if (MAP_FAILED == (start = mmap(NULL, sce->st.st_size, PROT_READ, MAP_SHARED, ifd, 0))) {
 		log_error_write(srv, __FILE__, __LINE__, "sbss", "mmaping", fn, "failed", strerror(errno));
 
 		close(ifd);
 		return -1;
 	}
+#else
+	start = malloc(sce->st.st_size);
+	if (NULL == start || sce->st.st_size != read(ifd, start, sce->st.st_size)) {
+		log_error_write(srv, __FILE__, __LINE__, "sbss", "reading", fn, "failed", strerror(errno));
 
+		close(ifd);
+		free(start);
+		return -1;
+	}
+#endif
+
 	switch(type) {
 #ifdef USE_ZLIB
 	case HTTP_ACCEPT_ENCODING_GZIP:
@@ -598,7 +630,11 @@
 		break;
 	}
 
+#ifdef USE_MMAP
 	munmap(start, sce->st.st_size);
+#else
+	free(start);
+#endif
 	close(ifd);
 
 	if (ret != 0) return -1;
@@ -826,7 +862,7 @@
 					}
 					response_header_overwrite(srv, con, CONST_STR_LEN("Content-Type"), CONST_BUF_LEN(sce->content_type));
 					/* let mod_staticfile handle the cached compressed files, physical path was modified */
-					return p->conf.compress_cache_dir->used ? HANDLER_GO_ON : HANDLER_FINISHED;
+					return (use_etag && p->conf.compress_cache_dir->used) ? HANDLER_GO_ON : HANDLER_FINISHED;
 				}
 			}
 		}
Index: configure.ac
===================================================================
--- configure.ac	(revision 2825)
+++ configure.ac	(revision 2827)
@@ -569,7 +569,22 @@
   fi
 fi
 
+# disable mmap by default; if a mmapped file gets truncated, the process gets a SIGBUS signal
+# on reading the truncated area which we can't handle (yet).
+# lighttpd may always use mmap with files it owns (created tmp files)
+AC_ARG_ENABLE(mmap,
+  AC_HELP_STRING([--enable-mmap],[use mmap if available (DANGEROUS, allows local users to trigger SIGBUS crashes)]),
+  [case "${enableval}" in
+   yes) mmap=true ;;
+    no) mmap=false ;;
+     *) AC_MSG_ERROR(bad value ${enableval} for --enable-mmap) ;;
+  esac],[mmap=false])
 
+if teest x$mmap = xtrue; then
+  AC_DEFINE(ENABLE_MMAP, [1], [Use mmap if available])
+fi
+
+
 AM_CONDITIONAL(CROSS_COMPILING, test "x$cross_compiling" = xyes)
 
 dnl check for fastcgi lib, for the tests only
