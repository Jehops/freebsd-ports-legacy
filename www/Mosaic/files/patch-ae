*** src/pixmaps.c.orig	Thu Feb  2 17:56:46 1995
--- src/pixmaps.c	Fri Nov 17 12:21:32 1995
***************
*** 397,412 ****
  	     * TrueColor displays.  I have no access to such displays, so I
  	     * can't really test it.
  	     * Donated by - andrew@icarus.demon.co.uk
  	     */
  	    case 16:
  		bit_data = (unsigned char *)malloc(size * 2);
  		bitp = bit_data;
  		datap = data;
  		for (w = size; w > 0; w--)
  		{
! 			temp = (((colrs[(int)*datap].red   >> 1) & 0x7c00) |
! 				((colrs[(int)*datap].green >> 6) & 0x03e0) |
! 				((colrs[(int)*datap].blue  >> 11) & 0x001f));
  
  			if (BitmapBitOrder(XtDisplay(wid)) == MSBFirst)
  			{
--- 397,429 ----
  	     * TrueColor displays.  I have no access to such displays, so I
  	     * can't really test it.
  	     * Donated by - andrew@icarus.demon.co.uk
+ 	     * modified by smp@csn.net for XFree86-3.1.x
  	     */
+ 	    case 15:
  	    case 16:
  		bit_data = (unsigned char *)malloc(size * 2);
  		bitp = bit_data;
  		datap = data;
  		for (w = size; w > 0; w--)
  		{
! 			if (depth == 15) /* weight == 555 */
! 			{
! 				temp = (((colrs[(int)*datap].red   >> 1)
! 					 & 0x7c00) |
! 					((colrs[(int)*datap].green >> 6)
! 					 & 0x03e0) |
! 					((colrs[(int)*datap].blue  >> 11)
! 					 & 0x001f));
! 		    	}
! 			else /* depth == 16, weight == 565 */
! 			{
! 				temp = ( (colrs[(int)*datap].red
! 					  & 0xf800) |
! 					((colrs[(int)*datap].green >>  5)
! 					 & 0x07e0) |
! 					((colrs[(int)*datap].blue  >> 11)
! 					 & 0x001f));
! 			}
  
  			if (BitmapBitOrder(XtDisplay(wid)) == MSBFirst)
  			{
*** libhtmlw/HTMLimages.c.orig	Tue Jan 10 17:03:32 1995
--- libhtmlw/HTMLimages.c	Fri Nov 17 12:27:58 1995
***************
*** 356,371 ****
  	     * TrueColor displays.  I have no access to such displays, so I
  	     * can't really test it.
  	     * Donated by - andrew@icarus.demon.co.uk
  	     */
  	    case 16:
  		bit_data = (unsigned char *)malloc(width * height * 2);
  		bitp = bit_data;
  		datap = data;
  		for (w = (width * height); w > 0; w--)
  		{
! 			temp = (((img_info->reds[(int)*datap] >> 1)& 0x7c00) |
! 				((img_info->greens[(int)*datap] >> 6)& 0x03e0) |
! 				((img_info->blues[(int)*datap] >> 11)& 0x001f));
  
  			if (BitmapBitOrder(dsp) == MSBFirst)
  			{
--- 356,388 ----
  	     * TrueColor displays.  I have no access to such displays, so I
  	     * can't really test it.
  	     * Donated by - andrew@icarus.demon.co.uk
+ 	     * modified by smp@csn.net for XFree86-3.1.x
  	     */
+ 	    case 15:
  	    case 16:
  		bit_data = (unsigned char *)malloc(width * height * 2);
  		bitp = bit_data;
  		datap = data;
  		for (w = (width * height); w > 0; w--)
  		{
! 			if (depth == 15) /* weight == 555 */
! 			{
! 				temp = (((img_info->reds[(int)*datap] >> 1)
! 					 & 0x7c00) |
! 					((img_info->greens[(int)*datap] >> 6)
! 					 & 0x03e0) |
! 					((img_info->blues[(int)*datap] >> 11)
! 					 & 0x001f));
! 		    	}
! 			else /* depth == 16, weight == 565 */
! 			{
! 				temp = ((img_info->reds[(int)*datap]
! 					 & 0xf800) |
! 					((img_info->greens[(int)*datap] >> 5)
! 					 & 0x07e0) |
! 					((img_info->blues[(int)*datap] >> 11)
! 					 & 0x001f));
! 			}
  
  			if (BitmapBitOrder(dsp) == MSBFirst)
  			{
