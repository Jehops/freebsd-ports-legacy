diff --git config/system-headers config/system-headers
index 9bd1efa..1095a01 100644
--- config/system-headers
+++ config/system-headers
@@ -1121,8 +1121,10 @@ gst/app/gstappsink.h
 gst/app/gstappsrc.h
 gst/video/video.h
 sys/msg.h
 sys/ipc.h
 sys/thr.h
 sys/user.h
 kvm.h
 spawn.h
+err.h
+xlocale.h
diff --git configure.in configure.in
index c167461..8346c11 100644
--- configure.in
+++ configure.in
@@ -5246,17 +5246,17 @@ if test "$NS_PRINTING"; then
     AC_DEFINE(NS_PRINT_PREVIEW)
 fi
 
 dnl Turn off webrtc for OS's we don't handle yet, but allow 
 dnl --enable-webrtc to override.  Can disable for everything in
 dnl the master list above.
 if test -n "$MOZ_WEBRTC"; then
     case "$target" in
-    *-linux*|*-mingw*|*-darwin*|*-android*|*-linuxandroid*)
+    *-linux*|*-mingw*|*-darwin*|*-android*|*-linuxandroid*|*-dragonfly*|*-freebsd*|*-netbsd*|*-openbsd*)
         dnl Leave enabled
         ;;
     *)
         dnl default to disabled for all others
         MOZ_WEBRTC=
         ;;
     esac
 fi
diff --git js/src/config/system-headers js/src/config/system-headers
index 9bd1efa..1095a01 100644
--- js/src/config/system-headers
+++ js/src/config/system-headers
@@ -1121,8 +1121,10 @@ gst/app/gstappsink.h
 gst/app/gstappsrc.h
 gst/video/video.h
 sys/msg.h
 sys/ipc.h
 sys/thr.h
 sys/user.h
 kvm.h
 spawn.h
+err.h
+xlocale.h
diff --git media/mtransport/objs.mk media/mtransport/objs.mk
index f1fc85f..141e8ca 100644
--- media/mtransport/objs.mk
+++ media/mtransport/objs.mk
@@ -18,22 +18,26 @@ LOCAL_INCLUDES += \
  -I$(topsrcdir)/media/mtransport/third_party/nrappkit/src/util/libekr \
  -I$(topsrcdir)/media/mtransport/third_party/nrappkit/src/log \
  -I$(topsrcdir)/media/mtransport/third_party/nrappkit/src/registry \
  -I$(topsrcdir)/media/mtransport/third_party/nrappkit/src/stats \
  -I$(topsrcdir)/media/mtransport/third_party/nrappkit/src/plugin \
  -I$(topsrcdir)/media/mtransport/third_party/nrappkit/src/event \
  $(NULL)
 
-ifeq ($(OS_TARGET), Darwin)
+ifneq (,$(filter Darwin DragonFly FreeBSD NetBSD OpenBSD,$(OS_TARGET)))
 LOCAL_INCLUDES += \
   -I$(topsrcdir)/media/mtransport/third_party/nrappkit/src/port/darwin/include \
   -I$(topsrcdir)/media/mtransport/third_party/nrappkit/src/port/generic/include \
   $(NULL)
+ifeq ($(OS_TARGET), Darwin)
 DEFINES += -DDARWIN
+else
+DEFINES += -DBSD
+endif
 endif
 
 ifeq ($(OS_TARGET), Linux)
 LOCAL_INCLUDES += \
   -I$(topsrcdir)/media/mtransport/third_party/nrappkit/src/port/linux/include \
   -I$(topsrcdir)/media/mtransport/third_party/nrappkit/src/port/generic/include \
   $(NULL)
 DEFINES += -DLINUX
diff --git media/mtransport/test/Makefile.in media/mtransport/test/Makefile.in
index c1d5bf4..2ecf2c7 100644
--- media/mtransport/test/Makefile.in
+++ media/mtransport/test/Makefile.in
@@ -73,22 +73,24 @@ DEFINES += -D__Userspace_os_FreeBSD=1
 else
 #default_fallback; probably doesn't work
 DEFINES += -D__Userspace_os_$(OS_TARGET)=1
 endif
 endif
 endif
 endif
 
-ifeq ($(OS_TARGET), Darwin)
+ifneq (,$(filter Darwin DragonFly FreeBSD NetBSD OpenBSD,$(OS_TARGET)))
 LOCAL_INCLUDES +=  -I$(topsrcdir)/media/mtransport/third_party/nrappkit/src/port/darwin/include
+ifeq ($(OS_TARGET), Darwin)
 DEFINES += \
   -DGTEST_USE_OWN_TR1_TUPLE=1 \
   $(NULL)
 endif
+endif
 
 ifeq ($(OS_TARGET), Linux)
 LOCAL_INCLUDES +=  -I$(topsrcdir)/media/mtransport/third_party/nrappkit/src/port/linux/include
 endif
 
 ifeq ($(OS_TARGET), Android)
 LOCAL_INCLUDES +=  -I$(topsrcdir)/media/mtransport/third_party/nrappkit/src/port/android/include
 
diff --git media/mtransport/third_party/nICEr/nicer.gyp media/mtransport/third_party/nICEr/nicer.gyp
index 0e1f8b4..9a4b995 100644
--- media/mtransport/third_party/nICEr/nicer.gyp
+++ media/mtransport/third_party/nICEr/nicer.gyp
@@ -126,26 +126,36 @@
 	      'R_DEFINED_UINT2=uint16_t',
 	      'R_DEFINED_INT4=int32_t',
 	      'R_DEFINED_UINT4=uint32_t',
 	      'R_DEFINED_INT8=int64_t',
 	      'R_DEFINED_UINT8=uint64_t',
           ],
           
           'conditions' : [
-              ## Mac
+              ## Mac and BSDs
               [ 'OS == "mac"', {
+                'defines' : [
+                    'DARWIN',
+                    'HAVE_XLOCALE',
+                ],
+              }],
+              [ 'os_bsd == 1', {
+                'defines' : [
+                    'BSD',
+                ],
+              }],
+              [ 'OS == "mac" or os_bsd == 1', {
                 'cflags_mozilla': [
                     '-Wall',
                     '-Wno-parentheses',
                     '-Wno-strict-prototypes',
                     '-Wmissing-prototypes',
                  ],
                  'defines' : [
-                     'DARWIN',
                      'HAVE_LIBM=1',
                      'HAVE_STRDUP=1',
                      'HAVE_STRLCPY=1',
                      'HAVE_SYS_TIME_H=1',
                      'HAVE_VFPRINTF=1',
                      'NEW_STDIO'
                      'RETSIGTYPE=void',
                      'TIME_WITH_SYS_TIME_H=1',
diff --git media/mtransport/third_party/nICEr/src/stun/addrs.c media/mtransport/third_party/nICEr/src/stun/addrs.c
index b0b66b2..04fea94 100644
--- media/mtransport/third_party/nICEr/src/stun/addrs.c
+++ media/mtransport/third_party/nICEr/src/stun/addrs.c
@@ -50,17 +50,19 @@ static char *RCSSTRING __UNUSED__="$Id: addrs.c,v 1.2 2008/04/28 18:21:30 ekr Ex
 #else
 #include <syslog.h>
 /* Work around an Android NDK < r8c bug */
 #undef __unused
 #include <linux/sysctl.h>
 #endif
 #include <net/if.h>
 #ifndef LINUX
+#if !defined(__OpenBSD__) && !defined(__NetBSD__)
 #include <net/if_var.h>
+#endif
 #include <net/if_dl.h>
 #include <net/if_types.h>
 #include <sys/sockio.h>
 #else
 #include <linux/if.h>
 #endif
 #include <net/route.h>
 
@@ -75,17 +77,17 @@ static char *RCSSTRING __UNUSED__="$Id: addrs.c,v 1.2 2008/04/28 18:21:30 ekr Ex
 #include <netdb.h>
 #endif  /* UNIX */
 
 #include "stun.h"
 #include "addrs.h"
 
 
 
-#ifdef DARWIN
+#if defined(BSD) || defined(DARWIN)
 /*
  * Copyright (c) 1983, 1993
  *    The Regents of the University of California.  All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
@@ -685,17 +687,17 @@ nr_stun_remove_duplicate_addrs(nr_transport_addr addrs[], int remove_loopback, i
 }
 
 int
 nr_stun_get_addrs(nr_transport_addr addrs[], int maxaddrs, int drop_loopback, int *count)
 {
     int _status=0;
     int i;
 
-#ifdef DARWIN
+#if defined(BSD) || defined(DARWIN)
     _status = stun_get_mib_addrs(addrs, maxaddrs, count);
 #elif defined(WIN32)
     _status = stun_get_win32_addrs(addrs, maxaddrs, count);
 #elif defined(__sparc__)
     _status = stun_get_sparc_addrs(addrs, maxaddrs, count);
 #else
     _status = stun_get_siocgifconf_addrs(addrs, maxaddrs, count);
 #endif
diff --git media/mtransport/third_party/nICEr/src/stun/stun.h media/mtransport/third_party/nICEr/src/stun/stun.h
index a3c51f9..eb65ac8 100644
--- media/mtransport/third_party/nICEr/src/stun/stun.h
+++ media/mtransport/third_party/nICEr/src/stun/stun.h
@@ -36,21 +36,25 @@ OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 #ifdef WIN32
 #include <winsock2.h>
 #else
 #include <sys/param.h>
 #include <sys/socket.h>
 #include <net/if.h>
 #ifndef LINUX
+#if !defined(__OpenBSD__) && !defined(__NetBSD__)
 #include <net/if_var.h>
+#endif
 #include <net/if_dl.h>
 #include <net/if_types.h>
 #endif
+#ifndef BSD
 #include <net/route.h>
+#endif
 #include <netinet/in.h>
 #ifndef LINUX
 #include <netinet/in_var.h>
 #endif
 #include <arpa/inet.h>
 #include <netdb.h>
 #endif
 #include <time.h>
diff --git media/mtransport/third_party/nICEr/src/util/mbslen.c media/mtransport/third_party/nICEr/src/util/mbslen.c
index cc260b7..66af2d7 100644
--- media/mtransport/third_party/nICEr/src/util/mbslen.c
+++ media/mtransport/third_party/nICEr/src/util/mbslen.c
@@ -38,50 +38,58 @@ OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 #include <errno.h>
 #include <csi_platform.h>
 
 #include <assert.h>
 #include <locale.h>
 #include <stdlib.h>
 #include <wchar.h>
-#ifdef DARWIN
+
+#ifdef __FreeBSD__
+#include <osreldate.h>
+# if __FreeBSD_version > 900505
+#  define HAVE_XLOCALE
+# endif
+#endif
+
+#ifdef HAVE_XLOCALE
 #include <xlocale.h>
-#endif /* DARWIN */
+#endif /* HAVE_XLOCALE */
 
 #include "nr_api.h"
 #include "mbslen.h"
 
 /* get number of characters in a mult-byte character string */
 int
 mbslen(const char *s, size_t *ncharsp)
 {
-#ifdef DARWIN
+#ifdef HAVE_XLOCALE
     static locale_t loc = 0;
     static int initialized = 0;
-#endif /* DARWIN */
+#endif /* HAVE_XLOCALE */
 #ifdef WIN32
     char *my_locale=0;
     unsigned int i;
 #endif  /* WIN32 */
     int _status;
     size_t nbytes;
     int nchars;
     mbstate_t mbs;
 
-#ifdef DARWIN
+#ifdef HAVE_XLOCALE
     if (! initialized) {
         initialized = 1;
         loc = newlocale(LC_CTYPE_MASK, "UTF-8", LC_GLOBAL_LOCALE);
     }
 
     if (loc == 0) {
         /* unable to create the UTF-8 locale */
         assert(loc != 0);  /* should never happen */
-#endif /* DARWIN */
+#endif /* HAVE_XLOCALE */
 
 #ifdef WIN32
     if (!setlocale(LC_CTYPE, 0))
         ABORT(R_INTERNAL);
 
     if (!(my_locale = r_strdup(setlocale(LC_CTYPE, 0))))
         ABORT(R_NO_MEMORY);
 
@@ -94,28 +102,28 @@ mbslen(const char *s, size_t *ncharsp)
     /* can't count UTF-8 characters with mbrlen if the locale isn't UTF-8 */
     /* null-checking setlocale is required because Android */
     char *locale = setlocale(LC_CTYPE, 0);
     /* some systems use "utf8" instead of "UTF-8" like Fedora 17 */
     if (!locale || (!strcasestr(locale, "UTF-8") && !strcasestr(locale, "UTF8")))
         ABORT(R_NOT_FOUND);
 #endif
 
-#ifdef DARWIN
+#ifdef HAVE_XLOCALE
     }
-#endif /* DARWIN */
+#endif /* HAVE_XLOCALE */
 
     memset(&mbs, 0, sizeof(mbs));
     nchars = 0;
 
-#ifdef DARWIN
+#ifdef HAVE_XLOCALE
     while (*s != '\0' && (nbytes = mbrlen_l(s, strlen(s), &mbs, loc)) != 0)
 #else
     while (*s != '\0' && (nbytes = mbrlen(s, strlen(s), &mbs)) != 0)
-#endif /* DARWIN */
+#endif /* HAVE_XLOCALE */
     {
         if (nbytes == (size_t)-1)   /* should never happen */ {
             ABORT(R_INTERNAL);
         }
         if (nbytes == (size_t)-2)   /* encoding error */ {
             ABORT(R_BAD_DATA);
         }
 
diff --git media/mtransport/third_party/nrappkit/nrappkit.gyp media/mtransport/third_party/nrappkit/nrappkit.gyp
index 3cc8e1c..74016c6 100644
--- media/mtransport/third_party/nrappkit/nrappkit.gyp
+++ media/mtransport/third_party/nrappkit/nrappkit.gyp
@@ -142,26 +142,35 @@
 	      'R_DEFINED_UINT2=uint16_t',
 	      'R_DEFINED_INT4=int32_t',
 	      'R_DEFINED_UINT4=uint32_t',
 	      'R_DEFINED_INT8=int64_t',
 	      'R_DEFINED_UINT8=uint64_t',
           ],
           
           'conditions' : [
-              ## Mac
+              ## Mac and BSDs
               [ 'OS == "mac"', {
+                'defines' : [
+                    'DARWIN',
+                ],
+              }],
+              [ 'os_bsd == 1', {
+                'defines' : [
+                    'BSD',
+                ],
+              }],
+              [ 'OS == "mac" or os_bsd == 1', {
                 'cflags_mozilla': [
                     '-Wall',
                     '-Wno-parentheses',
                     '-Wno-strict-prototypes',
                     '-Wmissing-prototypes',
                  ],
                  'defines' : [
-                     'DARWIN',
                      'HAVE_LIBM=1',
                      'HAVE_STRDUP=1',
                      'HAVE_STRLCPY=1',
                      'HAVE_SYS_TIME_H=1',
                      'HAVE_VFPRINTF=1',
                      'NEW_STDIO'
                      'RETSIGTYPE=void',
                      'TIME_WITH_SYS_TIME_H=1',
diff --git media/mtransport/third_party/nrappkit/src/log/r_log.c media/mtransport/third_party/nrappkit/src/log/r_log.c
index efb7ef2..aebf578 100644
--- media/mtransport/third_party/nrappkit/src/log/r_log.c
+++ media/mtransport/third_party/nrappkit/src/log/r_log.c
@@ -43,16 +43,17 @@ static char *RCSSTRING __UNUSED__ ="$Id: r_log.c,v 1.10 2008/11/25 22:25:18 adam
 #ifdef LINUX
 #define _BSD_SOURCE
 #endif
 
 #include "r_log.h"
 #include "hex.h"
 
 #include <string.h>
+#include <errno.h>
 #ifndef _MSC_VER
 #include <strings.h>
 #include <syslog.h>
 #endif
 #include <registry.h>
 #include <time.h>
 
 
diff --git media/mtransport/third_party/nrappkit/src/port/generic/include/sys/queue.h media/mtransport/third_party/nrappkit/src/port/generic/include/sys/queue.h
index bcb1ec0..bb73591 100644
--- media/mtransport/third_party/nrappkit/src/port/generic/include/sys/queue.h
+++ media/mtransport/third_party/nrappkit/src/port/generic/include/sys/queue.h
@@ -33,7 +33,7 @@
 #ifndef _SYS_QUEUE_H_
 #define	_SYS_QUEUE_H_
 
-#ifndef DARWIN
+#if !defined(__FreeBSD__) && !defined(DARWIN)
 #include <stddef.h>
 #define __offsetof offsetof
 #endif
diff --git media/mtransport/third_party/nrappkit/src/util/util.c media/mtransport/third_party/nrappkit/src/util/util.c
index a7d4ff1..ff11a60 100644
--- media/mtransport/third_party/nrappkit/src/util/util.c
+++ media/mtransport/third_party/nrappkit/src/util/util.c
@@ -40,16 +40,17 @@
 static char *RCSSTRING __UNUSED__ ="$Id: util.c,v 1.5 2007/11/21 00:09:13 adamcain Exp $";
 
 #ifndef WIN32
 #include <sys/uio.h>
 #include <pwd.h>
 #include <dirent.h>
 #endif
 #include <string.h>
+#include <errno.h>
 #include <ctype.h>
 #include <sys/stat.h>
 #ifdef OPENSSL
 #include <openssl/evp.h>
 #endif
 #include "nr_common.h"
 #include "r_common.h"
 #include "registry.h"
diff --git media/webrtc/signaling/signaling.gyp media/webrtc/signaling/signaling.gyp
index 2a91e3d..31de641 100644
--- media/webrtc/signaling/signaling.gyp
+++ media/webrtc/signaling/signaling.gyp
@@ -212,16 +212,29 @@
             'SIPCC_BUILD',
             'HAVE_WINSOCK2_H',
             'CPR_STDINT_INCLUDE=\\"mozilla/StandardInteger.h\\"'
           ],
 
           'cflags_mozilla': [
           ],
         }],
+        ['os_bsd==1', {
+          'include_dirs': [
+          ],
+          'defines': [
+            # avoiding pointless ifdef churn
+            'SIP_OS_OSX',
+            'OSX',
+            'SECLIB_OPENSSL',
+          ],
+
+          'cflags_mozilla': [
+          ],
+        }],
         ['OS=="mac"', {
           'include_dirs': [
           ],
           'defines': [
             'SIP_OS_OSX',
             'OSX',
             '_FORTIFY_SOURCE=2',
           ],
@@ -747,17 +760,17 @@
             'EXTERNAL_TICK_REQUIRED',
             'GIPS_VER=3480',
           ],
 
           'cflags_mozilla': [
           ],
 
         }],
-        ['OS=="mac"', {
+        ['OS=="mac" or os_bsd==1', {
 
           'include_dirs': [
           ],
 
           'sources': [
             # SIPSTACK
             './src/sipcc/core/sipstack/sip_platform_task.c',
 
@@ -792,24 +805,23 @@
             './src/sipcc/cpr/darwin/cpr_darwin_timers_using_select.c',
             './src/sipcc/cpr/darwin/cpr_darwin_tst.h',
             './src/sipcc/cpr/darwin/cpr_darwin_types.h',
           ],
 
 
           'defines' : [
             'SIP_OS_OSX',
-            '_POSIX_SOURCE',
+            # using BSD extensions, leave _POSIX_SOURCE undefined
             'CPR_MEMORY_LITTLE_ENDIAN',
             'NO_SOCKET_POLLING',
             'USE_TIMER_SELECT_BASED',
             'FULL_BUILD',
             'STUBBED_OUT',
             'USE_PRINTF',
-            '_DARWIN_C_SOURCE',
             'NO_NSPR_10_SUPPORT',
           ],
 
           'cflags_mozilla': [
           ],
         }],
       ],
 
diff --git media/webrtc/signaling/src/sipcc/cpr/darwin/cpr_darwin_ipc.c media/webrtc/signaling/src/sipcc/cpr/darwin/cpr_darwin_ipc.c
index a7c47e1..4f191de 100644
--- media/webrtc/signaling/src/sipcc/cpr/darwin/cpr_darwin_ipc.c
+++ media/webrtc/signaling/src/sipcc/cpr/darwin/cpr_darwin_ipc.c
@@ -317,21 +317,25 @@ cprGetMessage (cprMsgQueue_t msgQueue, boolean waitForever, void **ppUserData)
 {
     static const char fname[] = "cprGetMessage";
 
     void *buffer = 0;
     cpr_msg_queue_t *msgq;
     cpr_msgq_node_t *node;
 	struct timespec timeout;
 	struct timeval tv;
+#ifndef __APPLE__
+	struct timezone tz;
+#else
 	// On the iPhone, there is a DarwinAlias problem with "timezone"
 	struct _timezone {
 		int     tz_minuteswest; /* of Greenwich */
 		int     tz_dsttime;     /* type of dst correction to apply */
 	} tz;
+#endif
 
     /* Initialize ppUserData */
     if (ppUserData) {
         *ppUserData = NULL;
     }
 
     msgq = (cpr_msg_queue_t *) msgQueue;
     if (msgq == NULL) {
diff --git media/webrtc/signaling/test/Makefile.in media/webrtc/signaling/test/Makefile.in
index a30e330..cfbd8a3 100644
--- media/webrtc/signaling/test/Makefile.in
+++ media/webrtc/signaling/test/Makefile.in
@@ -81,17 +81,17 @@ endif
 ifeq (qt,$(MOZ_WIDGET_TOOLKIT))
 LIBS += \
   $(XLIBS) \
   $(TK_LIBS) \
   $(MOZ_PANGO_LIBS) \
   $(NULL)
 endif
 
-ifeq ($(OS_TARGET),Linux)
+ifneq (,$(filter Linux DragonFly FreeBSD NetBSD OpenBSD,$(OS_TARGET)))
 LIBS += \
   $(MOZ_CAIRO_OSLIBS) \
   $(NULL)
 endif
 
 ifeq ($(OS_TARGET),Darwin)
 LIBS += \
   -framework AudioToolbox \
diff --git media/webrtc/trunk/webrtc/build/common.gypi media/webrtc/trunk/webrtc/build/common.gypi
index 9ca9f7c..d5c4ab9 100644
--- media/webrtc/trunk/webrtc/build/common.gypi
+++ media/webrtc/trunk/webrtc/build/common.gypi
@@ -119,16 +119,21 @@
         # flood of chromium-style warnings. Investigate enabling them:
         # http://code.google.com/p/webrtc/issues/detail?id=163
         'clang_use_chrome_plugins%': 0,
 
         # Switch between Android audio device OpenSL ES implementation
         # and Java Implementation
         'enable_android_opensl%': 0,
       }],
+      ['OS=="linux" or OS=="solaris" or os_bsd==1', {
+        'include_v4l2_video_capture%': 1,
+      }, {
+        'include_v4l2_video_capture%': 0,
+      }],
       ['OS=="ios"', {
         'enable_video%': 0,
         'enable_protobuf%': 0,
         'build_libjpeg%': 0,
         'build_libyuv%': 0,
         'build_libvpx%': 0,
         'include_tests%': 0,
       }],
@@ -205,16 +210,28 @@
                 'defines': ['WEBRTC_ARCH_ARM_NEON',
                             'WEBRTC_BUILD_NEON_LIBS',
                             'WEBRTC_DETECT_ARM_NEON'],
               }],
             ],
           }],
         ],
       }],
+      ['os_bsd==1', {
+        'defines': [
+          'WEBRTC_BSD',
+          'WEBRTC_THREAD_RR',
+        ],
+      }],
+      ['OS=="dragonfly" or OS=="netbsd"', {
+        'defines': [
+          # doesn't support pthread_condattr_setclock
+          'WEBRTC_CLOCK_TYPE_REALTIME',
+        ],
+      }],
       ['OS=="ios"', {
         'defines': [
           'WEBRTC_MAC',
           'WEBRTC_IOS',
           'WEBRTC_THREAD_RR',
           'WEBRTC_CLOCK_TYPE_REALTIME',
         ],
       }],
diff --git media/webrtc/trunk/webrtc/modules/audio_device/audio_device_utility.cc media/webrtc/trunk/webrtc/modules/audio_device/audio_device_utility.cc
index 203f09a..0b0b70e 100644
--- media/webrtc/trunk/webrtc/modules/audio_device/audio_device_utility.cc
+++ media/webrtc/trunk/webrtc/modules/audio_device/audio_device_utility.cc
@@ -41,17 +41,17 @@ bool AudioDeviceUtility::StringCompare(
     const char* str1 , const char* str2,
     const WebRtc_UWord32 length)
 {
 	return ((_strnicmp(str1, str2, length) == 0) ? true : false);
 }
 
 }  // namespace webrtc
 
-#elif defined(WEBRTC_LINUX) || defined(WEBRTC_MAC)
+#elif defined(WEBRTC_LINUX) || defined(WEBRTC_BSD) || defined(WEBRTC_MAC)
 
 // ============================================================================
 //                                 Linux & Mac
 // ============================================================================
 
 #include <sys/time.h>   // gettimeofday
 #include <time.h>       // gettimeofday
 #include <string.h>     // strncasecmp
@@ -104,11 +104,11 @@ WebRtc_UWord32 AudioDeviceUtility::GetTimeInMS()
 bool AudioDeviceUtility::StringCompare(
     const char* str1 , const char* str2, const WebRtc_UWord32 length)
 {
     return (strncasecmp(str1, str2, length) == 0)?true: false;
 }
 
 }  // namespace webrtc
 
-#endif  // defined(WEBRTC_LINUX) || defined(WEBRTC_MAC)
+#endif  // defined(WEBRTC_LINUX) || defined(WEBRTC_BSD) || defined(WEBRTC_MAC)
 
 
diff --git media/webrtc/trunk/webrtc/modules/rtp_rtcp/source/forward_error_correction.cc media/webrtc/trunk/webrtc/modules/rtp_rtcp/source/forward_error_correction.cc
index bdad224..39e1132 100644
--- media/webrtc/trunk/webrtc/modules/rtp_rtcp/source/forward_error_correction.cc
+++ media/webrtc/trunk/webrtc/modules/rtp_rtcp/source/forward_error_correction.cc
@@ -7,16 +7,17 @@
  *  in the file PATENTS.  All contributing project authors may
  *  be found in the AUTHORS file in the root of the source tree.
  */
 
 #include "modules/rtp_rtcp/source/forward_error_correction.h"
 
 #include <algorithm>
 #include <cassert>
+#include <cstdlib> // for abs()
 #include <cstring>
 #include <iterator>
 
 #include "modules/rtp_rtcp/source/forward_error_correction_internal.h"
 #include "modules/rtp_rtcp/source/rtp_utility.h"
 #include "system_wrappers/interface/trace.h"
 
 namespace webrtc {
diff --git media/webrtc/trunk/webrtc/modules/rtp_rtcp/source/rtp_utility.cc media/webrtc/trunk/webrtc/modules/rtp_rtcp/source/rtp_utility.cc
index 298d479..37b70c9 100644
--- media/webrtc/trunk/webrtc/modules/rtp_rtcp/source/rtp_utility.cc
+++ media/webrtc/trunk/webrtc/modules/rtp_rtcp/source/rtp_utility.cc
@@ -13,17 +13,17 @@
 #include <cassert>
 #include <cmath>  // ceil
 #include <cstring>  // memcpy
 
 #if defined(_WIN32)
 #include <Windows.h>  // FILETIME
 #include <WinSock.h>  // timeval
 #include <MMSystem.h>  // timeGetTime
-#elif ((defined WEBRTC_LINUX) || (defined WEBRTC_MAC))
+#elif ((defined WEBRTC_LINUX) || (defined WEBRTC_BSD) || (defined WEBRTC_MAC))
 #include <sys/time.h>  // gettimeofday
 #include <time.h>
 #endif
 #if (defined(_DEBUG) && defined(_WIN32) && (_MSC_VER >= 1400))
 #include <stdio.h>
 #endif
 
 #include "system_wrappers/interface/tick_util.h"
@@ -151,17 +151,17 @@ void get_time(WindowsHelpTimer* help_timer, FILETIME& current_time) {
     virtual WebRtc_Word64 GetTimeInMS();
 
     virtual void CurrentNTP(WebRtc_UWord32& secs, WebRtc_UWord32& frac);
 
   private:
     WindowsHelpTimer* _helpTimer;
 };
 
-#elif defined(WEBRTC_LINUX) || defined(WEBRTC_MAC)
+#elif defined(WEBRTC_LINUX) || defined(WEBRTC_BSD) || defined(WEBRTC_MAC)
 
 // A clock reading times from the POSIX API.
 class UnixSystemClock : public RtpRtcpClock {
 public:
   UnixSystemClock() {}
   virtual ~UnixSystemClock() {}
 
   virtual WebRtc_Word64 GetTimeInMS();
@@ -209,17 +209,17 @@ void WindowsSystemClock::CurrentNTP(WebRtc_UWord32& secs,
   } else if (dtemp < -1) {
     dtemp += 1;
     secs--;
   }
   dtemp *= NTP_FRAC;
   frac = (WebRtc_UWord32)dtemp;
 }
 
-#elif ((defined WEBRTC_LINUX) || (defined WEBRTC_MAC))
+#elif ((defined WEBRTC_LINUX) || (defined WEBRTC_BSD) || (defined WEBRTC_MAC))
 
 WebRtc_Word64 UnixSystemClock::GetTimeInMS() {
   return TickTime::MillisecondTimestamp();
 }
 
 // Use the system time.
 void UnixSystemClock::CurrentNTP(WebRtc_UWord32& secs, WebRtc_UWord32& frac) {
   double dtemp;
@@ -248,17 +248,17 @@ void UnixSystemClock::CurrentNTP(WebRtc_UWord32& secs, WebRtc_UWord32& frac) {
 // Note that this is a POD. Only PODs are allowed to have static storage
 // duration according to the Google Style guide.
 static WindowsHelpTimer global_help_timer = {0, 0, {{ 0, 0}, 0}, 0};
 #endif
 
 RtpRtcpClock* GetSystemClock() {
 #if defined(_WIN32)
   return new WindowsSystemClock(&global_help_timer);
-#elif defined(WEBRTC_LINUX) || defined(WEBRTC_MAC)
+#elif defined(WEBRTC_LINUX) || defined(WEBRTC_BSD) || defined(WEBRTC_MAC)
   return new UnixSystemClock();
 #else
   return NULL;
 #endif
 }
 
 WebRtc_UWord32 GetCurrentRTP(RtpRtcpClock* clock, WebRtc_UWord32 freq) {
   const bool use_global_clock = (clock == NULL);
@@ -325,17 +325,17 @@ WebRtc_UWord16 GetPayloadDataLength(const WebRtcRTPHeader* rtp_header,
   return static_cast<WebRtc_UWord16>(length);
 }
 
 #if defined(_WIN32)
 bool StringCompare(const char* str1, const char* str2,
                    const WebRtc_UWord32 length) {
   return (_strnicmp(str1, str2, length) == 0) ? true : false;
 }
-#elif defined(WEBRTC_LINUX) || defined(WEBRTC_MAC)
+#elif defined(WEBRTC_LINUX) || defined(WEBRTC_BSD) || defined(WEBRTC_MAC)
 bool StringCompare(const char* str1, const char* str2,
                    const WebRtc_UWord32 length) {
   return (strncasecmp(str1, str2, length) == 0) ? true : false;
 }
 #endif
 
 #if !defined(WEBRTC_LITTLE_ENDIAN) && !defined(WEBRTC_BIG_ENDIAN)
 #error Either WEBRTC_LITTLE_ENDIAN or WEBRTC_BIG_ENDIAN must be defined
diff --git media/webrtc/trunk/webrtc/modules/udp_transport/source/udp_transport_impl.cc media/webrtc/trunk/webrtc/modules/udp_transport/source/udp_transport_impl.cc
index e50db5d..70ad8a8 100644
--- media/webrtc/trunk/webrtc/modules/udp_transport/source/udp_transport_impl.cc
+++ media/webrtc/trunk/webrtc/modules/udp_transport/source/udp_transport_impl.cc
@@ -13,60 +13,62 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <time.h>
 
 #if defined(_WIN32)
 #include <winsock2.h>
 #include <ws2tcpip.h>
-#elif defined(WEBRTC_LINUX) || defined(WEBRTC_MAC)
+#elif defined(WEBRTC_LINUX) || defined(WEBRTC_BSD) || defined(WEBRTC_MAC)
 #include <arpa/inet.h>
 #include <ctype.h>
 #include <fcntl.h>
 #include <netdb.h>
+#include <sys/socket.h>
 #include <net/if.h>
 #include <netinet/in.h>
 #include <stdlib.h>
 #include <sys/ioctl.h>
-#include <sys/socket.h>
 #include <sys/time.h>
 #include <unistd.h>
 #ifndef WEBRTC_IOS
 #include <net/if_arp.h>
 #endif
 #endif // defined(WEBRTC_LINUX) || defined(WEBRTC_MAC)
 
 #if defined(WEBRTC_MAC)
-#include <ifaddrs.h>
 #include <machine/types.h>
 #endif
+#if defined(WEBRTC_BSD) || defined(WEBRTC_MAC)
+#include <ifaddrs.h>
+#endif
 #if defined(WEBRTC_LINUX)
 #include <linux/netlink.h>
 #include <linux/rtnetlink.h>
 #endif
 
 #include "common_types.h"
 #include "critical_section_wrapper.h"
 #include "rw_lock_wrapper.h"
 #include "trace.h"
 #include "typedefs.h"
 #include "udp_socket_manager_wrapper.h"
 
-#if defined(WEBRTC_LINUX) || defined(WEBRTC_MAC)
+#if defined(WEBRTC_LINUX) || defined(WEBRTC_BSD) || defined(WEBRTC_MAC)
 #define GetLastError() errno
 
 #define IFRSIZE ((int)(size * sizeof (struct ifreq)))
 
 #define NLMSG_OK_NO_WARNING(nlh,len)                                    \
   ((len) >= (int)sizeof(struct nlmsghdr) &&                             \
    (int)(nlh)->nlmsg_len >= (int)sizeof(struct nlmsghdr) &&             \
    (int)(nlh)->nlmsg_len <= (len))
 
-#endif // defined(WEBRTC_LINUX) || defined(WEBRTC_MAC)
+#endif // defined(WEBRTC_LINUX) || defined(WEBRTC_BSD) || defined(WEBRTC_MAC)
 
 namespace webrtc {
 
 class SocketFactory : public UdpTransportImpl::SocketFactoryInterface {
  public:
   UdpSocketWrapper* CreateSocket(const WebRtc_Word32 id,
                                  UdpSocketManager* mgr,
                                  CallbackObj obj,
@@ -2366,17 +2368,17 @@ WebRtc_UWord32 UdpTransport::InetAddrIPV4(const char* ip)
 {
     return ::inet_addr(ip);
 }
 
 WebRtc_Word32 UdpTransport::InetPresentationToNumeric(WebRtc_Word32 af,
                                                       const char* src,
                                                       void* dst)
 {
-#if defined(WEBRTC_LINUX) || defined(WEBRTC_MAC)
+#if defined(WEBRTC_LINUX) || defined(WEBRTC_BSD) || defined(WEBRTC_MAC)
     const WebRtc_Word32 result = inet_pton(af, src, dst);
     return result > 0 ? 0 : -1;
 
 #elif defined(_WIN32)
     SocketAddress temp;
     int length=sizeof(SocketAddress);
 
     if(af == AF_INET)
@@ -2488,17 +2490,17 @@ WebRtc_Word32 UdpTransport::LocalHostAddressIPV6(char n_localIP[16])
                 break;
         };
     }
     freeaddrinfo(result);
     WEBRTC_TRACE(kTraceWarning, kTraceTransport, -1,
                  "getaddrinfo failed to find address");
     return -1;
 
-#elif defined(WEBRTC_MAC)
+#elif defined(WEBRTC_BSD) || defined(WEBRTC_MAC)
     struct ifaddrs* ptrIfAddrs = NULL;
     struct ifaddrs* ptrIfAddrsStart = NULL;
 
     getifaddrs(&ptrIfAddrsStart);
     ptrIfAddrs = ptrIfAddrsStart;
     while(ptrIfAddrs)
     {
         if(ptrIfAddrs->ifa_addr->sa_family == AF_INET6)
@@ -2680,17 +2682,17 @@ WebRtc_Word32 UdpTransport::LocalHostAddress(WebRtc_UWord32& localIP)
     }
     else
     {
         WebRtc_Word32 error = WSAGetLastError();
         WEBRTC_TRACE(kTraceWarning, kTraceTransport, -1,
                      "gethostbyname failed, error:%d", error);
         return -1;
     }
-#elif (defined(WEBRTC_MAC))
+#elif (defined(WEBRTC_BSD) || defined(WEBRTC_MAC))
     char localname[255];
     if (gethostname(localname, 255) != -1)
     {
         hostent* localHost;
         localHost = gethostbyname(localname);
         if(localHost)
         {
             if(localHost->h_addrtype != AF_INET)
@@ -2819,17 +2821,17 @@ WebRtc_Word32 UdpTransport::IPAddress(const SocketAddress& address,
         }
 
         source_port = address._sockaddr_in6.sin6_port;
     }
     // Convert port number to network byte order.
     sourcePort = htons(source_port);
     return 0;
 
- #elif defined(WEBRTC_LINUX) || defined(WEBRTC_MAC)
+ #elif defined(WEBRTC_LINUX) || defined(WEBRTC_BSD) || defined(WEBRTC_MAC)
     WebRtc_Word32 ipFamily = address._sockaddr_storage.sin_family;
     const void* ptrNumericIP = NULL;
 
     if(ipFamily == AF_INET)
     {
         ptrNumericIP = &(address._sockaddr_in.sin_addr);
     }
     else if(ipFamily == AF_INET6)
diff --git media/webrtc/trunk/webrtc/modules/utility/source/rtp_dump_impl.cc media/webrtc/trunk/webrtc/modules/utility/source/rtp_dump_impl.cc
index 69a52ec..7ac226c 100644
--- media/webrtc/trunk/webrtc/modules/utility/source/rtp_dump_impl.cc
+++ media/webrtc/trunk/webrtc/modules/utility/source/rtp_dump_impl.cc
@@ -14,17 +14,17 @@
 #include <stdio.h>
 
 #include "critical_section_wrapper.h"
 #include "trace.h"
 
 #if defined(_WIN32)
 #include <Windows.h>
 #include <mmsystem.h>
-#elif defined(WEBRTC_LINUX) || defined(WEBRTC_MAC)
+#elif defined(WEBRTC_LINUX) || defined(WEBRTC_BSD) || defined(WEBRTC_MAC)
 #include <string.h>
 #include <sys/time.h>
 #include <time.h>
 #endif
 
 #if (defined(_DEBUG) && defined(_WIN32))
 #define DEBUG_PRINT(expr)   OutputDebugString(##expr)
 #define DEBUG_PRINTP(expr, p)   \
@@ -233,17 +233,17 @@ bool RtpDumpImpl::RTCP(const WebRtc_UWord8* packet) const
     return is_rtcp;
 }
 
 // TODO (hellner): why is TickUtil not used here?
 inline WebRtc_UWord32 RtpDumpImpl::GetTimeInMS() const
 {
 #if defined(_WIN32)
     return timeGetTime();
-#elif defined(WEBRTC_LINUX) || defined(WEBRTC_MAC)
+#elif defined(WEBRTC_LINUX) || defined(WEBRTC_BSD) || defined(WEBRTC_MAC)
     struct timeval tv;
     struct timezone tz;
     unsigned long val;
 
     gettimeofday(&tv, &tz);
     val = tv.tv_sec * 1000 + tv.tv_usec / 1000;
     return val;
 #else
diff --git media/webrtc/trunk/webrtc/modules/video_capture/linux/device_info_linux.cc media/webrtc/trunk/webrtc/modules/video_capture/linux/device_info_linux.cc
index 653ee16..8d6fd68 100644
--- media/webrtc/trunk/webrtc/modules/video_capture/linux/device_info_linux.cc
+++ media/webrtc/trunk/webrtc/modules/video_capture/linux/device_info_linux.cc
@@ -14,17 +14,23 @@
 #include <unistd.h>
 #include <sys/ioctl.h>
 #include <sys/stat.h>
 #include <fcntl.h>
 #include <stdio.h>
 #include <stdlib.h>
 
 //v4l includes
+#if defined(__DragonFly__) || defined(__NetBSD__) || defined(__OpenBSD__)
+#include <sys/videoio.h>
+#elif defined(__sun)
+#include <sys/videodev2.h>
+#else
 #include <linux/videodev2.h>
+#endif
 
 #include "ref_count.h"
 #include "trace.h"
 
 
 namespace webrtc
 {
 namespace videocapturemodule
diff --git media/webrtc/trunk/webrtc/modules/video_capture/linux/video_capture_linux.cc media/webrtc/trunk/webrtc/modules/video_capture/linux/video_capture_linux.cc
index 12df1b3..424ea0a 100644
--- media/webrtc/trunk/webrtc/modules/video_capture/linux/video_capture_linux.cc
+++ media/webrtc/trunk/webrtc/modules/video_capture/linux/video_capture_linux.cc
@@ -7,22 +7,30 @@
  *  in the file PATENTS.  All contributing project authors may
  *  be found in the AUTHORS file in the root of the source tree.
  */
 
 #include <sys/ioctl.h>
 #include <unistd.h>
 #include <sys/stat.h>
 #include <fcntl.h>
-#include <linux/videodev2.h>
 #include <errno.h>
 #include <stdio.h>
 #include <sys/mman.h>
 #include <string.h>
 
+//v4l includes
+#if defined(__DragonFly__) || defined(__NetBSD__) || defined(__OpenBSD__)
+#include <sys/videoio.h>
+#elif defined(__sun)
+#include <sys/videodev2.h>
+#else
+#include <linux/videodev2.h>
+#endif
+
 #include <new>
 
 #include "ref_count.h"
 #include "trace.h"
 #include "thread_wrapper.h"
 #include "critical_section_wrapper.h"
 #include "video_capture_linux.h"
 
diff --git media/webrtc/trunk/webrtc/modules/video_capture/device_info_impl.cc media/webrtc/trunk/webrtc/modules/video_capture/device_info_impl.cc
index e3f7bb5..882cede 100644
--- media/webrtc/trunk/webrtc/modules/video_capture/device_info_impl.cc
+++ media/webrtc/trunk/webrtc/modules/video_capture/device_info_impl.cc
@@ -49,17 +49,17 @@ WebRtc_Word32 DeviceInfoImpl::NumberOfCapabilities(
     if (!deviceUniqueIdUTF8)
         return -1;
 
     _apiLock.AcquireLockShared();
 
     if (_lastUsedDeviceNameLength == strlen((char*) deviceUniqueIdUTF8))
     {
         // Is it the same device that is asked for again.
-#if defined(WEBRTC_MAC) || defined(WEBRTC_LINUX)
+#if defined(WEBRTC_MAC) || defined(WEBRTC_LINUX) || defined(WEBRTC_BSD)
         if(strncasecmp((char*)_lastUsedDeviceName,
                        (char*) deviceUniqueIdUTF8,
                        _lastUsedDeviceNameLength)==0)
 #else
         if (_strnicmp((char*) _lastUsedDeviceName,
                       (char*) deviceUniqueIdUTF8,
                       _lastUsedDeviceNameLength) == 0)
 #endif
@@ -86,17 +86,17 @@ WebRtc_Word32 DeviceInfoImpl::GetCapability(const char* deviceUniqueIdUTF8,
     {
         WEBRTC_TRACE(webrtc::kTraceError, webrtc::kTraceVideoCapture, _id,
                    "deviceUniqueIdUTF8 parameter not set in call to GetCapability");
         return -1;
     }
     ReadLockScoped cs(_apiLock);
 
     if ((_lastUsedDeviceNameLength != strlen((char*) deviceUniqueIdUTF8))
-#if defined(WEBRTC_MAC) || defined(WEBRTC_LINUX)
+#if defined(WEBRTC_MAC) || defined(WEBRTC_LINUX) || defined(WEBRTC_BSD)
         || (strncasecmp((char*)_lastUsedDeviceName,
                         (char*) deviceUniqueIdUTF8,
                         _lastUsedDeviceNameLength)!=0))
 #else
         || (_strnicmp((char*) _lastUsedDeviceName,
                       (char*) deviceUniqueIdUTF8,
                       _lastUsedDeviceNameLength) != 0))
 #endif
@@ -150,17 +150,17 @@ WebRtc_Word32 DeviceInfoImpl::GetBestMatchedCapability(
 {
 
 
     if (!deviceUniqueIdUTF8)
         return -1;
 
     ReadLockScoped cs(_apiLock);
     if ((_lastUsedDeviceNameLength != strlen((char*) deviceUniqueIdUTF8))
-#if defined(WEBRTC_MAC) || defined(WEBRTC_LINUX)
+#if defined(WEBRTC_MAC) || defined(WEBRTC_LINUX) || defined(WEBRTC_BSD)
         || (strncasecmp((char*)_lastUsedDeviceName,
                         (char*) deviceUniqueIdUTF8,
                         _lastUsedDeviceNameLength)!=0))
 #else
         || (_strnicmp((char*) _lastUsedDeviceName,
                       (char*) deviceUniqueIdUTF8,
                       _lastUsedDeviceNameLength) != 0))
 #endif
diff --git media/webrtc/trunk/webrtc/modules/video_capture/video_capture.gypi media/webrtc/trunk/webrtc/modules/video_capture/video_capture.gypi
index 0a9765e..8d4bbf4 100644
--- media/webrtc/trunk/webrtc/modules/video_capture/video_capture.gypi
+++ media/webrtc/trunk/webrtc/modules/video_capture/video_capture.gypi
@@ -43,17 +43,17 @@
       'conditions': [
         ['include_internal_video_capture==0', {
           'sources': [
             'external/device_info_external.cc',
             'external/video_capture_external.cc',
           ],
         }, {  # include_internal_video_capture == 1
           'conditions': [
-            ['OS=="linux"', {
+            ['include_v4l2_video_capture==1', {
               'include_dirs': [
                 'linux',
               ],
               'sources': [
                 'linux/device_info_linux.cc',
                 'linux/device_info_linux.h',
                 'linux/video_capture_linux.cc',
                 'linux/video_capture_linux.h',
@@ -152,31 +152,35 @@
           'include_dirs': [
             'include',
           ],
           'sources': [
             'test/video_capture_unittest.cc',
             'test/video_capture_main_mac.mm',
           ],
           'conditions': [
-            ['OS=="mac" or OS=="linux"', {
+            ['OS!="win" and OS!="android"', {
               'cflags': [
                 '-Wno-write-strings',
               ],
               'ldflags': [
                 '-lpthread -lm',
               ],
             }],
-            ['OS=="linux"', {
+            ['include_v4l2_video_capture==1', {
               'libraries': [
-                '-lrt',
                 '-lXext',
                 '-lX11',
               ],
             }],
+            ['OS=="linux"', {
+              'libraries': [
+                '-lrt',
+              ],
+            }],
             ['OS=="mac"', {
               'dependencies': [
                 # Link with a special main for mac so we can use the webcam.
                 '<(webrtc_root)/test/test.gyp:test_support_main_threaded_mac',
               ],
               'xcode_settings': {
                 # TODO(andrew): CoreAudio and AudioToolbox shouldn't be needed.
                 'OTHER_LDFLAGS': [
diff --git media/webrtc/trunk/webrtc/system_wrappers/interface/asm_defines.h media/webrtc/trunk/webrtc/system_wrappers/interface/asm_defines.h
index 0cd85d0..45591be 100644
--- media/webrtc/trunk/webrtc/system_wrappers/interface/asm_defines.h
+++ media/webrtc/trunk/webrtc/system_wrappers/interface/asm_defines.h
@@ -6,17 +6,17 @@
  *  tree. An additional intellectual property rights grant can be found
  *  in the file PATENTS.  All contributing project authors may
  *  be found in the AUTHORS file in the root of the source tree.
  */
 
 #ifndef WEBRTC_SYSTEM_WRAPPERS_INTERFACE_ASM_DEFINES_H_
 #define WEBRTC_SYSTEM_WRAPPERS_INTERFACE_ASM_DEFINES_H_
 
-#if defined(__linux__) && defined(__ELF__)
+#if (defined(__linux__) || defined(__FreeBSD__)) && defined(__ELF__)
 .section .note.GNU-stack,"",%progbits
 #endif
 
 // Define the macros used in ARM assembly code, so that for Mac or iOS builds
 // we add leading underscores for the function names.
 #ifdef __APPLE__
 .macro GLOBAL_FUNCTION name
 .global _\name
diff --git media/webrtc/trunk/webrtc/system_wrappers/interface/tick_util.h media/webrtc/trunk/webrtc/system_wrappers/interface/tick_util.h
index 0cd85d0..45591be 100644
--- media/webrtc/trunk/webrtc/system_wrappers/interface/tick_util.h
+++ media/webrtc/trunk/webrtc/system_wrappers/interface/tick_util.h
@@ -189,17 +189,17 @@ inline WebRtc_Word64 TickTime::QueryOsForTicks() {
     // 0x0fffffff ~3.1 days, the code will not take that long to execute
     // so it must have been a wrap around.
     if (old > 0xf0000000 && now < 0x0fffffff) {
       num_wrap_time_get_time++;
     }
   }
   result.ticks_ = now + (num_wrap_time_get_time << 32);
 #endif
-#elif defined(WEBRTC_LINUX)
+#elif defined(WEBRTC_LINUX) || defined(WEBRTC_BSD)
   struct timespec ts;
   // TODO(wu): Remove CLOCK_REALTIME implementation.
 #ifdef WEBRTC_CLOCK_TYPE_REALTIME
   clock_gettime(CLOCK_REALTIME, &ts);
 #else
   clock_gettime(CLOCK_MONOTONIC, &ts);
 #endif
   result.ticks_ = 1000000000LL * static_cast<WebRtc_Word64>(ts.tv_sec) +
@@ -236,34 +236,34 @@ inline WebRtc_Word64 TickTime::MillisecondTimestamp() {
 #if _WIN32
 #ifdef USE_QUERY_PERFORMANCE_COUNTER
   LARGE_INTEGER qpfreq;
   QueryPerformanceFrequency(&qpfreq);
   return (ticks * 1000) / qpfreq.QuadPart;
 #else
   return ticks;
 #endif
-#elif defined(WEBRTC_LINUX) || defined(WEBRTC_MAC)
+#elif defined(WEBRTC_LINUX) || defined(WEBRTC_BSD) || defined(WEBRTC_MAC)
   return ticks / 1000000LL;
 #else
   return ticks / 1000LL;
 #endif
 }
 
 inline WebRtc_Word64 TickTime::MicrosecondTimestamp() {
   WebRtc_Word64 ticks = TickTime::Now().Ticks();
 #if _WIN32
 #ifdef USE_QUERY_PERFORMANCE_COUNTER
   LARGE_INTEGER qpfreq;
   QueryPerformanceFrequency(&qpfreq);
   return (ticks * 1000) / (qpfreq.QuadPart / 1000);
 #else
   return ticks * 1000LL;
 #endif
-#elif defined(WEBRTC_LINUX) || defined(WEBRTC_MAC)
+#elif defined(WEBRTC_LINUX) || defined(WEBRTC_BSD) || defined(WEBRTC_MAC)
   return ticks / 1000LL;
 #else
   return ticks;
 #endif
 }
 
 inline WebRtc_Word64 TickTime::Ticks() const {
   return ticks_;
@@ -273,33 +273,33 @@ inline WebRtc_Word64 TickTime::MillisecondsToTicks(const WebRtc_Word64 ms) {
 #if _WIN32
 #ifdef USE_QUERY_PERFORMANCE_COUNTER
   LARGE_INTEGER qpfreq;
   QueryPerformanceFrequency(&qpfreq);
   return (qpfreq.QuadPart * ms) / 1000;
 #else
   return ms;
 #endif
-#elif defined(WEBRTC_LINUX) || defined(WEBRTC_MAC)
+#elif defined(WEBRTC_LINUX) || defined(WEBRTC_BSD) || defined(WEBRTC_MAC)
   return ms * 1000000LL;
 #else
   return ms * 1000LL;
 #endif
 }
 
 inline WebRtc_Word64 TickTime::TicksToMilliseconds(const WebRtc_Word64 ticks) {
 #if _WIN32
 #ifdef USE_QUERY_PERFORMANCE_COUNTER
   LARGE_INTEGER qpfreq;
   QueryPerformanceFrequency(&qpfreq);
   return (ticks * 1000) / qpfreq.QuadPart;
 #else
   return ticks;
 #endif
-#elif defined(WEBRTC_LINUX) || defined(WEBRTC_MAC)
+#elif defined(WEBRTC_LINUX) || defined(WEBRTC_BSD) || defined(WEBRTC_MAC)
   return ticks / 1000000LL;
 #else
   return ticks / 1000LL;
 #endif
 }
 
 inline TickTime& TickTime::operator+=(const WebRtc_Word64& ticks) {
   ticks_ += ticks;
@@ -318,17 +318,17 @@ inline WebRtc_Word64 TickInterval::Milliseconds() const {
 #ifdef USE_QUERY_PERFORMANCE_COUNTER
   LARGE_INTEGER qpfreq;
   QueryPerformanceFrequency(&qpfreq);
   return (interval_ * 1000) / qpfreq.QuadPart;
 #else
   // interval_ is in ms
   return interval_;
 #endif
-#elif defined(WEBRTC_LINUX) || defined(WEBRTC_MAC)
+#elif defined(WEBRTC_LINUX) || defined(WEBRTC_BSD) || defined(WEBRTC_MAC)
   // interval_ is in ns
   return interval_ / 1000000;
 #else
   // interval_ is usecs
   return interval_ / 1000;
 #endif
 }
 
@@ -337,17 +337,17 @@ inline WebRtc_Word64 TickInterval::Microseconds() const {
 #ifdef USE_QUERY_PERFORMANCE_COUNTER
   LARGE_INTEGER qpfreq;
   QueryPerformanceFrequency(&qpfreq);
   return (interval_ * 1000000) / qpfreq.QuadPart;
 #else
   // interval_ is in ms
   return interval_ * 1000LL;
 #endif
-#elif defined(WEBRTC_LINUX) || defined(WEBRTC_MAC)
+#elif defined(WEBRTC_LINUX) || defined(WEBRTC_BSD) || defined(WEBRTC_MAC)
   // interval_ is in ns
   return interval_ / 1000;
 #else
   // interval_ is usecs
   return interval_;
 #endif
 }
 
diff --git media/webrtc/trunk/webrtc/system_wrappers/source/atomic32_posix.cc media/webrtc/trunk/webrtc/system_wrappers/source/atomic32_posix.cc
index 05b0e57..993456c 100644
--- media/webrtc/trunk/webrtc/system_wrappers/source/atomic32_posix.cc
+++ media/webrtc/trunk/webrtc/system_wrappers/source/atomic32_posix.cc
@@ -7,17 +7,16 @@
  *  in the file PATENTS.  All contributing project authors may
  *  be found in the AUTHORS file in the root of the source tree.
  */
 
 #include "atomic32.h"
 
 #include <assert.h>
 #include <inttypes.h>
-#include <malloc.h>
 
 #include "common_types.h"
 
 namespace webrtc {
 
 Atomic32::Atomic32(WebRtc_Word32 initial_value)
     : value_(initial_value) {
   assert(Is32bitAligned());
diff --git media/webrtc/trunk/webrtc/system_wrappers/source/condition_variable.cc media/webrtc/trunk/webrtc/system_wrappers/source/condition_variable.cc
index b37d037..fcea221 100644
--- media/webrtc/trunk/webrtc/system_wrappers/source/condition_variable.cc
+++ media/webrtc/trunk/webrtc/system_wrappers/source/condition_variable.cc
@@ -3,31 +3,33 @@
  *
  *  Use of this source code is governed by a BSD-style license
  *  that can be found in the LICENSE file in the root of the source
  *  tree. An additional intellectual property rights grant can be found
  *  in the file PATENTS.  All contributing project authors may
  *  be found in the AUTHORS file in the root of the source tree.
  */
 
+#include "condition_variable_wrapper.h"
+
 #if defined(_WIN32)
 #include <windows.h>
 #include "condition_variable_win.h"
-#include "condition_variable_wrapper.h"
-#elif defined(WEBRTC_LINUX) || defined(WEBRTC_MAC)
+#elif defined(WEBRTC_LINUX) || defined(WEBRTC_BSD) || defined(WEBRTC_MAC)
 #include <pthread.h>
 #include "condition_variable_posix.h"
-#include "condition_variable_wrapper.h"
+#else
+#include <stddef.h>  // for NULL
 #endif
 
 namespace webrtc {
 
 ConditionVariableWrapper* ConditionVariableWrapper::CreateConditionVariable() {
 #if defined(_WIN32)
   return new ConditionVariableWindows;
-#elif defined(WEBRTC_LINUX) || defined(WEBRTC_MAC)
+#elif defined(WEBRTC_LINUX) || defined(WEBRTC_BSD) || defined(WEBRTC_MAC)
   return ConditionVariablePosix::Create();
 #else
   return NULL;
 #endif
 }
 
 } // namespace webrtc
diff --git media/webrtc/trunk/webrtc/system_wrappers/source/condition_variable_posix.cc media/webrtc/trunk/webrtc/system_wrappers/source/condition_variable_posix.cc
index 48835ab..16c6033 100644
--- media/webrtc/trunk/webrtc/system_wrappers/source/condition_variable_posix.cc
+++ media/webrtc/trunk/webrtc/system_wrappers/source/condition_variable_posix.cc
@@ -74,17 +74,17 @@ void ConditionVariablePosix::SleepCS(CriticalSectionWrapper& crit_sect) {
       &crit_sect);
   pthread_cond_wait(&cond_, &cs->mutex_);
 }
 
 bool ConditionVariablePosix::SleepCS(CriticalSectionWrapper& crit_sect,
                                      unsigned long max_time_inMS) {
   const unsigned long INFINITE =  0xFFFFFFFF;
   const int MILLISECONDS_PER_SECOND = 1000;
-#ifndef WEBRTC_LINUX
+#if !defined(WEBRTC_LINUX) && !defined(WEBRTC_BSD)
   const int MICROSECONDS_PER_MILLISECOND = 1000;
 #endif
   const int NANOSECONDS_PER_SECOND = 1000000000;
   const int NANOSECONDS_PER_MILLISECOND  = 1000000;
 
   CriticalSectionPosix* cs = reinterpret_cast<CriticalSectionPosix*>(
       &crit_sect);
 
diff --git media/webrtc/trunk/webrtc/system_wrappers/source/cpu.cc media/webrtc/trunk/webrtc/system_wrappers/source/cpu.cc
index 3df5d18..4cd3ddf 100644
--- media/webrtc/trunk/webrtc/system_wrappers/source/cpu.cc
+++ media/webrtc/trunk/webrtc/system_wrappers/source/cpu.cc
@@ -9,28 +9,28 @@
  */
 
 #include "system_wrappers/interface/cpu_wrapper.h"
 
 #if defined(_WIN32)
 #include "cpu_win.h"
 #elif defined(WEBRTC_MAC)
 #include "cpu_mac.h"
-#elif defined(WEBRTC_ANDROID)
+#elif defined(WEBRTC_ANDROID) || defined(WEBRTC_BSD)
 // Not implemented yet, might be possible to use Linux implementation
 #else // defined(WEBRTC_LINUX)
 #include "cpu_linux.h"
 #endif
 
 namespace webrtc {
 CpuWrapper* CpuWrapper::CreateCpu() {
 #if defined(_WIN32)
   return new CpuWindows();
 #elif defined(WEBRTC_MAC)
   return new CpuWrapperMac();
-#elif defined(WEBRTC_ANDROID)
+#elif defined(WEBRTC_ANDROID) || defined(WEBRTC_BSD)
   return 0;
 #else
   return new CpuLinux();
 #endif
 }
 
 }  // namespace webrtc
diff --git media/webrtc/trunk/webrtc/system_wrappers/source/cpu_info.cc media/webrtc/trunk/webrtc/system_wrappers/source/cpu_info.cc
index e367abf..e14d7af 100644
--- media/webrtc/trunk/webrtc/system_wrappers/source/cpu_info.cc
+++ media/webrtc/trunk/webrtc/system_wrappers/source/cpu_info.cc
@@ -7,23 +7,25 @@
  *  in the file PATENTS.  All contributing project authors may
  *  be found in the AUTHORS file in the root of the source tree.
  */
 
 #include "system_wrappers/interface/cpu_info.h"
 
 #if defined(_WIN32)
 #include <Windows.h>
-#elif defined(WEBRTC_MAC)
-#include <sys/sysctl.h>
+#elif defined(WEBRTC_BSD) || defined(WEBRTC_MAC)
 #include <sys/types.h>
+#include <sys/sysctl.h>
 #elif defined(WEBRTC_ANDROID)
 // Not implemented yet, might be possible to use Linux implementation
-#else // defined(WEBRTC_LINUX)
+#elif defined(WEBRTC_LINUX)
 #include <sys/sysinfo.h>
+#else // defined(_SC_NPROCESSORS_ONLN)
+#include <unistd.h>
 #endif
 
 #include "trace.h"
 
 namespace webrtc {
 
 WebRtc_UWord32 CpuInfo::number_of_cores_ = 0;
 
@@ -36,29 +38,38 @@ WebRtc_UWord32 CpuInfo::DetectNumberOfCores() {
     WEBRTC_TRACE(kTraceStateInfo, kTraceUtility, -1,
                  "Available number of cores:%d", number_of_cores_);
 
 #elif defined(WEBRTC_LINUX) && !defined(WEBRTC_ANDROID) && !defined(WEBRTC_GONK)
     number_of_cores_ = get_nprocs();
     WEBRTC_TRACE(kTraceStateInfo, kTraceUtility, -1,
                  "Available number of cores:%d", number_of_cores_);
 
-#elif defined(WEBRTC_MAC)
-    int name[] = {CTL_HW, HW_AVAILCPU};
+#elif defined(WEBRTC_BSD) || defined(WEBRTC_MAC)
+    int name[] = {
+      CTL_HW,
+#ifdef HW_AVAILCPU
+      HW_AVAILCPU,
+#else
+      HW_NCPU,
+#endif
+    };
     int ncpu;
     size_t size = sizeof(ncpu);
     if (0 == sysctl(name, 2, &ncpu, &size, NULL, 0)) {
       number_of_cores_ = static_cast<WebRtc_UWord32>(ncpu);
       WEBRTC_TRACE(kTraceStateInfo, kTraceUtility, -1,
                    "Available number of cores:%d", number_of_cores_);
     } else {
       WEBRTC_TRACE(kTraceError, kTraceUtility, -1,
                    "Failed to get number of cores");
       number_of_cores_ = 1;
     }
+#elif defined(_SC_NPROCESSORS_ONLN)
+    _numberOfCores = sysconf(_SC_NPROCESSORS_ONLN);
 #else
     WEBRTC_TRACE(kTraceWarning, kTraceUtility, -1,
                  "No function to get number of cores");
     number_of_cores_ = 1;
 #endif
   }
   return number_of_cores_;
 }
diff --git media/webrtc/trunk/webrtc/system_wrappers/source/thread_posix.cc media/webrtc/trunk/webrtc/system_wrappers/source/thread_posix.cc
index 6334490..852ebaa 100644
--- media/webrtc/trunk/webrtc/system_wrappers/source/thread_posix.cc
+++ media/webrtc/trunk/webrtc/system_wrappers/source/thread_posix.cc
@@ -54,16 +54,27 @@
 #ifdef WEBRTC_LINUX
 #include <sys/types.h>
 #include <sched.h>
 #include <sys/syscall.h>
 #include <linux/unistd.h>
 #include <sys/prctl.h>
 #endif
 
+#if defined(__NetBSD__)
+#include <lwp.h>
+#elif defined(__FreeBSD__)
+#include <sys/param.h>
+#include <sys/thr.h>
+#endif
+
+#if defined(WEBRTC_BSD) && !defined(__NetBSD__)
+#include <pthread_np.h>
+#endif
+
 #include "webrtc/system_wrappers/interface/critical_section_wrapper.h"
 #include "webrtc/system_wrappers/interface/event_wrapper.h"
 #include "webrtc/system_wrappers/interface/trace.h"
 
 namespace webrtc {
 
 int ConvertToSystemPriority(ThreadPriority priority, int min_prio,
                             int max_prio) {
@@ -136,16 +147,30 @@ ThreadPosix::ThreadPosix(ThreadRunFunction func, ThreadObj obj,
   }
 }
 
 uint32_t ThreadWrapper::GetThreadId() {
 #if defined(WEBRTC_ANDROID) || defined(WEBRTC_LINUX) || defined(WEBRTC_GONK)
   return static_cast<uint32_t>(syscall(__NR_gettid));
 #elif defined(WEBRTC_MAC) || defined(WEBRTC_IOS)
   return pthread_mach_thread_np(pthread_self());
+#elif defined(__NetBSD__)
+  return _lwp_self();
+#elif defined(__DragonFly__)
+  return lwp_gettid();
+#elif defined(__OpenBSD__)
+  return reinterpret_cast<uintptr_t> (pthread_self());
+#elif defined(__FreeBSD__)
+#  if __FreeBSD_version > 900030
+    return pthread_getthreadid_np();
+#  else
+    long lwpid;
+    thr_self(&lwpid);
+    return lwpid;
+#  endif
 #else
   return reinterpret_cast<uint32_t>(pthread_self());
 #endif
 }
 
 int ThreadPosix::Construct() {
   int result = 0;
 #if !defined(WEBRTC_ANDROID) && !defined(WEBRTC_GONK)
@@ -167,17 +192,17 @@ int ThreadPosix::Construct() {
 }
 
 ThreadPosix::~ThreadPosix() {
   pthread_attr_destroy(&attr_);
   delete event_;
   delete crit_state_;
 }
 
-#define HAS_THREAD_ID !defined(WEBRTC_IOS) && !defined(WEBRTC_MAC)
+#define HAS_THREAD_ID !defined(WEBRTC_IOS) && !defined(WEBRTC_MAC) && !defined(WEBRTC_BSD)
 
 bool ThreadPosix::Start(unsigned int& thread_id)
 {
   if (!run_function_) {
     return false;
   }
   int result = pthread_attr_setdetachstate(&attr_, PTHREAD_CREATE_DETACHED);
   // Set the stack stack size to 1M.
@@ -232,31 +257,40 @@ bool ThreadPosix::Start(unsigned int& thread_id)
     WEBRTC_TRACE(kTraceError, kTraceUtility, -1,
                  "unable to set thread priority");
   }
   return true;
 }
 
 // CPU_ZERO and CPU_SET are not available in NDK r7, so disable
 // SetAffinity on Android for now.
-#if (defined(WEBRTC_LINUX) && (!defined(WEBRTC_ANDROID)) && (!defined(WEBRTC_GONK)))
+#if defined(__FreeBSD__) || (defined(WEBRTC_LINUX) && \
+  (!defined(WEBRTC_ANDROID)) && (!defined(WEBRTC_GONK)))
 bool ThreadPosix::SetAffinity(const int* processor_numbers,
                               const unsigned int amount_of_processors) {
   if (!processor_numbers || (amount_of_processors == 0)) {
     return false;
   }
+#if defined(__FreeBSD__)
+  cpuset_t mask;
+#else
   cpu_set_t mask;
+#endif
   CPU_ZERO(&mask);
 
   for (unsigned int processor = 0;
        processor < amount_of_processors;
        ++processor) {
     CPU_SET(processor_numbers[processor], &mask);
   }
-#if defined(WEBRTC_ANDROID) || defined(WEBRTC_GONK)
+#if defined(__FreeBSD__)
+  const int result = pthread_setaffinity_np(thread_,
+                             sizeof(mask),
+                             &mask);
+#elif defined(WEBRTC_ANDROID) || defined(WEBRTC_GONK)
   // Android.
   const int result = syscall(__NR_sched_setaffinity,
                              pid_,
                              sizeof(mask),
                              &mask);
 #else
   // "Normal" Linux.
   const int result = sched_setaffinity(pid_,
@@ -320,16 +353,20 @@ void ThreadPosix::Run() {
   pid_ = GetThreadId();
 #endif
   // The event the Start() is waiting for.
   event_->Set();
 
   if (set_thread_name_) {
 #ifdef WEBRTC_LINUX
     prctl(PR_SET_NAME, (unsigned long)name_, 0, 0, 0);
+#elif defined(__NetBSD__)
+        pthread_setname_np(pthread_self(), "%s", (void *)name_);
+#elif defined(WEBRTC_BSD)
+        pthread_set_name_np(pthread_self(), name_);
 #endif
     WEBRTC_TRACE(kTraceStateInfo, kTraceUtility, -1,
                  "Thread with name:%s started ", name_);
   } else {
     WEBRTC_TRACE(kTraceStateInfo, kTraceUtility, -1,
                  "Thread without name started");
   }
   bool alive = true;
diff --git media/webrtc/trunk/webrtc/system_wrappers/source/trace_posix.cc media/webrtc/trunk/webrtc/system_wrappers/source/trace_posix.cc
index 2c7e59a..6f23fcb 100644
--- media/webrtc/trunk/webrtc/system_wrappers/source/trace_posix.cc
+++ media/webrtc/trunk/webrtc/system_wrappers/source/trace_posix.cc
@@ -49,17 +49,17 @@ TracePosix::~TracePosix() {
 WebRtc_Word32 TracePosix::AddTime(char* trace_message,
                                   const TraceLevel level) const {
   struct timeval system_time_high_res;
   if (gettimeofday(&system_time_high_res, 0) == -1) {
     return -1;
   }
   struct tm buffer;
   const struct tm* system_time =
-    localtime_r(&system_time_high_res.tv_sec, &buffer);
+    localtime_r((const time_t *)(&system_time_high_res.tv_sec), &buffer);
 
   const WebRtc_UWord32 ms_time = system_time_high_res.tv_usec / 1000;
   WebRtc_UWord32 prev_tickCount = 0;
   if (level == kTraceApiCall) {
     prev_tickCount = prev_tick_count_;
     prev_tick_count_ = ms_time;
   } else {
     prev_tickCount = prev_api_tick_count_;
diff --git media/webrtc/trunk/webrtc/typedefs.h media/webrtc/trunk/webrtc/typedefs.h
index 6334490..852ebaa 100644
--- media/webrtc/trunk/webrtc/typedefs.h
+++ media/webrtc/trunk/webrtc/typedefs.h
@@ -16,17 +16,17 @@
 
 // Reserved words definitions
 // TODO(andrew): Remove this.
 #define G_CONST const
 
 // For access to standard POSIXish features, use WEBRTC_POSIX instead of a
 // more specific macro.
 #if defined(WEBRTC_MAC) || defined(WEBRTC_LINUX) || \
-    defined(WEBRTC_ANDROID)
+    defined(WEBRTC_ANDROID) || defined(WEBRTC_BSD)
 #define WEBRTC_POSIX
 #endif
 
 // Processor architecture detection.  For more info on what's defined, see:
 //   http://msdn.microsoft.com/en-us/library/b0084kay.aspx
 //   http://www.agner.org/optimize/calling_conventions.pdf
 //   or with gcc, run: "echo | gcc -E -dM -"
 // TODO(andrew): replace WEBRTC_LITTLE_ENDIAN with WEBRTC_ARCH_LITTLE_ENDIAN.
diff --git media/webrtc/trunk/webrtc/video_engine/vie_defines.h media/webrtc/trunk/webrtc/video_engine/vie_defines.h
index 2cc18cc7..2c042a0 100644
--- media/webrtc/trunk/webrtc/video_engine/vie_defines.h
+++ media/webrtc/trunk/webrtc/video_engine/vie_defines.h
@@ -168,17 +168,17 @@ inline int ChannelId(const int moduleId) {
 
   // Example: "Oct 10 2002 12:05:30 r".
   #define BUILDINFO BUILDDATE TEXT(" ") BUILDTIME TEXT(" ") BUILDMODE
   #define RENDER_MODULE_TYPE kRenderWindows
 #endif
 
 // Linux specific.
 #ifndef WEBRTC_ANDROID
-#ifdef WEBRTC_LINUX
+#if defined(WEBRTC_LINUX) || defined(WEBRTC_BSD)
   //  Build information macros.
   #if defined(_DEBUG)
   #define BUILDMODE "d"
   #elif defined(DEBUG)
   #define BUILDMODE "d"
   #elif defined(NDEBUG)
   #define BUILDMODE "r"
   #else
diff --git media/webrtc/trunk/webrtc/voice_engine/voe_network_impl.cc media/webrtc/trunk/webrtc/voice_engine/voe_network_impl.cc
index 174abca..f8a2b2d 100644
--- media/webrtc/trunk/webrtc/voice_engine/voe_network_impl.cc
+++ media/webrtc/trunk/webrtc/voice_engine/voe_network_impl.cc
@@ -467,17 +467,17 @@ int VoENetworkImpl::SetSendTOS(int channel,
                                int DSCP,
                                int priority,
                                bool useSetSockopt)
 {
     WEBRTC_TRACE(kTraceApiCall, kTraceVoice, VoEId(_shared->instance_id(), -1),
                  "SetSendTOS(channel=%d, DSCP=%d, useSetSockopt=%d)",
                  channel, DSCP, useSetSockopt);
 
-#if !defined(_WIN32) && !defined(WEBRTC_LINUX) && !defined(WEBRTC_MAC)
+#if !defined(_WIN32) && !defined(WEBRTC_LINUX) && !defined(WEBRTC_BSD) && !defined(WEBRTC_MAC)
     _shared->SetLastError(VE_FUNC_NOT_SUPPORTED, kTraceWarning,
         "SetSendTOS() is not supported on this platform");
     return -1;
 #endif
 
 #ifndef WEBRTC_EXTERNAL_TRANSPORT
     if (!_shared->statistics().Initialized())
     {
@@ -523,17 +523,17 @@ int VoENetworkImpl::SetSendTOS(int channel,
         return -1;
     }
     if (channelPtr->ExternalTransport())
     {
         _shared->SetLastError(VE_EXTERNAL_TRANSPORT_ENABLED, kTraceError,
             "SetSendTOS() external transport is enabled");
         return -1;
     }
-#if defined(WEBRTC_LINUX) || defined(WEBRTC_MAC)
+#if defined(WEBRTC_LINUX) || defined(WEBRTC_BSD) || defined(WEBRTC_MAC)
     useSetSockopt = true;
     WEBRTC_TRACE(kTraceInfo, kTraceVoice, VoEId(_shared->instance_id(), -1),
                  "   force useSetSockopt=true since there is no alternative"
                  " implementation");
 #endif
 
     return channelPtr->SetSendTOS(DSCP, priority, useSetSockopt);
 #else
@@ -546,17 +546,17 @@ int VoENetworkImpl::SetSendTOS(int channel,
 int VoENetworkImpl::GetSendTOS(int channel,
                                int& DSCP,
                                int& priority,
                                bool& useSetSockopt)
 {
     WEBRTC_TRACE(kTraceApiCall, kTraceVoice, VoEId(_shared->instance_id(), -1),
                  "GetSendTOS(channel=%d)", channel);
 
-#if !defined(_WIN32) && !defined(WEBRTC_LINUX) && !defined(WEBRTC_MAC)
+#if !defined(_WIN32) && !defined(WEBRTC_LINUX) && !defined(WEBRTC_BSD) && !defined(WEBRTC_MAC)
     _shared->SetLastError(VE_FUNC_NOT_SUPPORTED, kTraceWarning,
         "GetSendTOS() is not supported on this platform");
     return -1;
 #endif
 #ifndef WEBRTC_EXTERNAL_TRANSPORT
     if (!_shared->statistics().Initialized())
     {
         _shared->SetLastError(VE_NOT_INITED, kTraceError);
diff --git media/webrtc/trunk/webrtc/voice_engine/voice_engine_defines.h media/webrtc/trunk/webrtc/voice_engine/voice_engine_defines.h
index 7d4c729..4104719 100644
--- media/webrtc/trunk/webrtc/voice_engine/voice_engine_defines.h
+++ media/webrtc/trunk/webrtc/voice_engine/voice_engine_defines.h
@@ -409,41 +409,43 @@ namespace webrtc
 
 #else
 #define ANDROID_NOT_SUPPORTED(stat)
 #endif  // #ifdef WEBRTC_LINUX
 
 // *** WEBRTC_MAC ***
 // including iPhone
 
-#ifdef WEBRTC_MAC
+#if defined(WEBRTC_BSD) || defined(WEBRTC_MAC)
 
 #include <pthread.h>
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <netinet/in.h>
 #include <arpa/inet.h>
 #include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
 #include <errno.h>
 #include <sys/stat.h>
 #include <unistd.h>
 #include <fcntl.h>
 #include <sched.h>
 #include <sys/time.h>
 #include <time.h>
+#if !defined(WEBRTC_BSD)
 #include <AudioUnit/AudioUnit.h>
 #if !defined(WEBRTC_IOS)
   #include <CoreServices/CoreServices.h>
   #include <CoreAudio/CoreAudio.h>
   #include <AudioToolbox/DefaultAudioOutput.h>
   #include <AudioToolbox/AudioConverter.h>
   #include <CoreAudio/HostTime.h>
 #endif
+#endif
 
 #define DWORD unsigned long int
 #define WINAPI
 #define LPVOID void *
 #define FALSE 0
 #define TRUE 1
 #define SOCKADDR_IN struct sockaddr_in
 #define UINT unsigned int
@@ -526,13 +528,13 @@ namespace webrtc
 //  Defines
 // ----------------------------------------------------------------------------
 
   #define IPHONE_NOT_SUPPORTED(stat)
 #endif
 
 #else
 #define IPHONE_NOT_SUPPORTED(stat)
-#endif  // #ifdef WEBRTC_MAC
+#endif  // #if defined(WEBRTC_BSD) || defined(WEBRTC_MAC)
 
 
 
 #endif // WEBRTC_VOICE_ENGINE_VOICE_ENGINE_DEFINES_H
diff --git media/webrtc/trunk/tools/gyp/pylib/gyp/generator/mozmake.py media/webrtc/trunk/tools/gyp/pylib/gyp/generator/mozmake.py
index 338d0b7..2241d41 100644
--- media/webrtc/trunk/tools/gyp/pylib/gyp/generator/mozmake.py
+++ media/webrtc/trunk/tools/gyp/pylib/gyp/generator/mozmake.py
@@ -1,16 +1,17 @@
 # Copyright (c) 2012 Mozilla Foundation. All rights reserved.
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
 import collections
 import gyp
 import gyp.common
 import sys
+import platform
 import os
 import re
 import shlex
 
 generator_wants_sorted_dependencies = True
 
 generator_default_variables = {
 }
@@ -107,30 +108,44 @@ endif
 
 def ensure_directory_exists(path):
   dir = os.path.dirname(path)
   if dir and not os.path.exists(dir):
     os.makedirs(dir)
 
 def GetFlavor(params):
   """Returns |params.flavor| if it's set, the system's default flavor else."""
+  system = platform.system().lower()
   flavors = {
-    'win32': 'win',
-    'darwin': 'mac',
-    'sunos5': 'solaris',
-    'freebsd7': 'freebsd',
-    'freebsd8': 'freebsd',
+    'microsoft': 'win',
+    'windows'  : 'win',
+    'darwin'   : 'mac',
+    'sunos'    : 'solaris',
+    'dragonfly': 'bsd',
+    'freebsd'  : 'bsd',
+    'netbsd'   : 'bsd',
+    'openbsd'  : 'bsd',
   }
-  flavor = flavors.get(sys.platform, 'linux')
-  return params.get('flavor', flavor)
+
+  if 'flavor' in params:
+    return params['flavor']
+  if system.startswith('cygwin'):
+    return 'win'
+  if system in flavors:
+    return flavors[system]
+
+  return 'linux'
 
 
 def CalculateVariables(default_variables, params):
+  flavor = GetFlavor(params)
+  if flavor == 'bsd':
+    flavor = platform.system().lower()
   generator_flags = params.get('generator_flags', {})
-  default_variables['OS'] = generator_flags.get('os', GetFlavor(params))
+  default_variables['OS'] = generator_flags.get('os', flavor)
 
 
 def CalculateGeneratorInputInfo(params):
   """Calculate the generator specific info that gets fed to input (called by
   gyp)."""
   generator_flags = params.get('generator_flags', {})
   if generator_flags.get('adjust_static_libraries', False):
     global generator_wants_static_library_dependencies_adjusted
