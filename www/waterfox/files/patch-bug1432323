commit 694ff7ca4925
Author: Eric Rahm <erahm@mozilla.com>
Date:   Thu Feb 22 12:38:15 2018 -0800

    Bug 1432323 - Refactor operator new in nsArrayEnumerator. r=froydnj
    
    --HG--
    extra : rebase_source : 9df6db9f17e14eff2f79cd29599b03619068cef3
---
 xpcom/ds/nsArrayEnumerator.cpp | 44 ++++++++++++++++++++++++++++--------------
 1 file changed, 29 insertions(+), 15 deletions(-)

diff --git xpcom/ds/nsArrayEnumerator.cpp xpcom/ds/nsArrayEnumerator.cpp
index 54951222ae954..2e7d1f9af43a5 100644
--- xpcom/ds/nsArrayEnumerator.cpp
+++ xpcom/ds/nsArrayEnumerator.cpp
@@ -13,6 +13,7 @@
 
 #include "nsCOMArray.h"
 #include "nsCOMPtr.h"
+#include "mozilla/OperatorNewExtensions.h"
 #include "mozilla/RefPtr.h"
 
 class nsSimpleArrayEnumerator final : public nsISimpleEnumerator
@@ -112,14 +113,21 @@ public:
   // nsISimpleEnumerator interface
   NS_DECL_NSISIMPLEENUMERATOR
 
-  // nsSimpleArrayEnumerator methods
-  nsCOMArrayEnumerator() : mIndex(0) {}
+  // Use this instead of `new`.
+  static nsCOMArrayEnumerator* Allocate(const nsCOMArray_base& aArray);
 
   // specialized operator to make sure we make room for mValues
-  void* operator new(size_t aSize, const nsCOMArray_base& aArray) CPP_THROW_NEW;
-  void operator delete(void* aPtr) { ::operator delete(aPtr); }
+  void operator delete(void* aPtr) { free(aPtr); }
 
 private:
+  // nsSimpleArrayEnumerator methods
+  nsCOMArrayEnumerator()
+    : mIndex(0)
+    , mArraySize(0)
+  {
+    mValueArray[0] = nullptr;
+  }
+
   ~nsCOMArrayEnumerator(void);
 
 protected:
@@ -176,26 +184,32 @@ nsCOMArrayEnumerator::GetNext(nsISupports** aResult)
   return NS_OK;
 }
 
-void*
-nsCOMArrayEnumerator::operator new(size_t aSize,
-                                   const nsCOMArray_base& aArray) CPP_THROW_NEW
+nsCOMArrayEnumerator*
+nsCOMArrayEnumerator::Allocate(const nsCOMArray_base& aArray)
 {
   // create enough space such that mValueArray points to a large
   // enough value. Note that the initial value of aSize gives us
   // space for mValueArray[0], so we must subtract
-  aSize += (aArray.Count() - 1) * sizeof(aArray[0]);
+  size_t size = sizeof(nsCOMArrayEnumerator);
+  uint32_t count;
+  if (aArray.Count() > 0) {
+    count = static_cast<uint32_t>(aArray.Count());
+    size += (count - 1) * sizeof(aArray[0]);
+  } else {
+    count = 0;
+  }
+
+  // Allocate a buffer large enough to contain our object and its array.
+  void* mem = moz_xmalloc(size);
+  auto result = new (mozilla::KnownNotNull, mem) nsCOMArrayEnumerator();
 
-  // do the actual allocation
-  nsCOMArrayEnumerator* result =
-    static_cast<nsCOMArrayEnumerator*>(::operator new(aSize));
+  result->mArraySize = count;
 
   // now need to copy over the values, and addref each one
   // now this might seem like a lot of work, but we're actually just
   // doing all our AddRef's ahead of time since GetNext() doesn't
   // need to AddRef() on the way out
-  uint32_t i;
-  uint32_t max = result->mArraySize = aArray.Count();
-  for (i = 0; i < max; ++i) {
+  for (uint32_t i = 0; i < count; ++i) {
     result->mValueArray[i] = aArray[i];
     NS_IF_ADDREF(result->mValueArray[i]);
   }
@@ -207,7 +221,7 @@ nsresult
 NS_NewArrayEnumerator(nsISimpleEnumerator** aResult,
                       const nsCOMArray_base& aArray)
 {
-  RefPtr<nsCOMArrayEnumerator> enumerator = new (aArray) nsCOMArrayEnumerator();
+  RefPtr<nsCOMArrayEnumerator> enumerator = nsCOMArrayEnumerator::Allocate(aArray);
   enumerator.forget(aResult);
   return NS_OK;
 }
