diff -ru ../silgraphite-2.3.1.orig/engine/include/graphite/GrCommon.h ./engine/include/graphite/GrCommon.h
--- ../silgraphite-2.3.1.orig/engine/include/graphite/GrCommon.h	2012-02-27 21:39:57.000000000 -0500
+++ ./engine/include/graphite/GrCommon.h	2012-02-27 21:40:30.000000000 -0500
@@ -18,6 +18,8 @@
 #ifndef GRCOMMON_INCLUDED
 #define GRCOMMON_INCLUDED
 
+#define _SECURE_SCL 0	// to allow GlyphSetIterator to work, which points off the end of a vector
+#define _HAS_ITERATOR_DEBUGGING 0
 
 // Standard Headers.
 
@@ -33,6 +35,7 @@
 #include <vector>
 #include <algorithm>
 #include <string>
+///#include <stdexcept> -- possibly needed for std::string Xran and Xlen functions??
 
 // Uncomment this to allow multiple versions of gr to coexist
 // in the same program e.g. pangographite with gtk uses namespace gr
@@ -41,7 +44,7 @@
 // Provided the client includes GrClient.h first this #define is
 // picked up by all files.
 
-//#define gr gr2
+#define gr gr3ooo
 
 // Project headers
 #include "GrPlatform.h"
diff -ru ../silgraphite-2.3.1.orig/engine/include/graphite/GrMstypes.h ./engine/include/graphite/GrMstypes.h
--- ../silgraphite-2.3.1.orig/engine/include/graphite/GrMstypes.h	2012-02-27 21:39:57.000000000 -0500
+++ ./engine/include/graphite/GrMstypes.h	2012-02-27 21:40:30.000000000 -0500
@@ -24,11 +24,11 @@
 
 typedef signed long	    HRESULT;
 
-inline const long InterlockedIncrement(long *const intr_lck) {
+inline long InterlockedIncrement(long *const intr_lck) {
 	return ++*intr_lck;
 }
 
-inline const long InterlockedDecrement(long *const intr_lck) {
+inline long InterlockedDecrement(long *const intr_lck) {
 	return --*intr_lck;
 }
 
diff -ru ../silgraphite-2.3.1.orig/engine/makefile.vc7 ./engine/makefile.vc7
--- ../silgraphite-2.3.1.orig/engine/makefile.vc7	2012-02-27 21:39:57.000000000 -0500
+++ ./engine/makefile.vc7	2012-02-27 21:40:30.000000000 -0500
@@ -48,11 +48,7 @@
 CPP_DEBUG=/D "TRACING" $(CPP_DEBUG)
 !ENDIF
 
-!IF "$(OS)" == "Windows_NT"
 NULL=
-!ELSE 
-NULL=nul
-!ENDIF
 
 clean :
     @- rd /s/q .\release_temp
Only in ./engine: makefile.vc8.orig
Only in ./engine: makefile.vc8.rej
diff -ru ../silgraphite-2.3.1.orig/engine/src/font/FileFont.cpp ./engine/src/font/FileFont.cpp
--- ../silgraphite-2.3.1.orig/engine/src/font/FileFont.cpp	2012-02-27 21:39:57.000000000 -0500
+++ ./engine/src/font/FileFont.cpp	2012-02-27 21:40:30.000000000 -0500
@@ -207,11 +207,11 @@
 				cch16 += cch16Used;
 			}
 //		}
-#else
+#elif 1
 		m_stuFaceName.assign(rgchwFace);
-		// VS 2005 needs this:
-		//for (int cch16 = 0; cch16 < cchw; cch16++)
-		//	m_stuFaceName.push_back(rgchwFace[cch16]);
+#else	// VS 2005 needs this:
+		for (int cch16 = 0; cch16 < cchw; cch16++)
+			m_stuFaceName.push_back(rgchwFace[cch16]);
 #endif
 		pTable = readTable(ktiHead, lSize);
 		if (!m_fIsValid || !pTable) 
@@ -233,7 +233,7 @@
 FileFont::readTable(int /*TableId*/ tid, size_t & size)
 {
 	const TableId tableId = TableId(tid);
-	bool isValid = true;
+	bool isTableValid = true;
 	size_t lOffset = 0, lSize = 0;
 	if (!m_pTableCache)
 	{
@@ -245,9 +245,9 @@
 	size = m_pTableCache->getTableSize(tableId);
 	// check whether it is already in the cache
 	if (pTable) return pTable;
-	isValid &= TtfUtil::GetTableInfo(tableId, m_pHeader, m_pTableDir, 
+	isTableValid &= TtfUtil::GetTableInfo(tableId, m_pHeader, m_pTableDir, 
 			lOffset, lSize);
-	if (!isValid) 
+	if (!isTableValid) 
 		return NULL;
 	fseek(m_pfile, lOffset, SEEK_SET);
 	// only allocate if needed
@@ -255,16 +255,16 @@
 	
 	if (!pTable) 
 	{
-		isValid = false;
+		isTableValid = false;
 		return NULL;
 	}
 	size_t bytesRead = fread(pTable, 1, lSize, m_pfile);
-	isValid = bytesRead == lSize;
-	if (isValid)
+	isTableValid = bytesRead == lSize;
+	if (isTableValid)
 	{
-		isValid &= TtfUtil::CheckTable(tableId, pTable, lSize);
+		isTableValid &= TtfUtil::CheckTable(tableId, pTable, lSize);
 	}
-	if (!isValid) 
+	if (!isTableValid) 
 	{
 		return 0;
 	}
diff -ru ../silgraphite-2.3.1.orig/engine/src/font/Font.cpp ./engine/src/font/Font.cpp
--- ../silgraphite-2.3.1.orig/engine/src/font/Font.cpp	2012-02-27 21:39:57.000000000 -0500
+++ ./engine/src/font/Font.cpp	2012-02-27 21:40:30.000000000 -0500
@@ -626,7 +626,7 @@
 		Assert(false);
 		m_ifeat = m_cfeat;
 	}
-	else if (m_ifeat + n < 0)
+	else if (static_cast<int>(m_ifeat) + n < 0)
 	{
 		// Can't decrement.
 		Assert(false);
@@ -727,7 +727,7 @@
 		Assert(false);
 		m_ifset = m_cfset;
 	}
-	if (m_ifset + n < 0)
+	if (static_cast<int>(m_ifset) + n < 0)
 	{
 		// Can't decrement.
 		Assert(false);
@@ -820,7 +820,7 @@
 		Assert(false);
 		m_ilang = m_clang;
 	}
-	else if (m_ilang + n < 0)
+	else if (static_cast<int>(m_ilang) + n < 0)
 	{
 		// Can't decrement.
 		Assert(false);
@@ -906,7 +906,7 @@
 		Assert(false);
 		m_ilang = m_clang;
 	}
-	else if (m_ilang + n < 0)
+	else if (static_cast<int>(m_ilang) + n < 0)
 	{
 		// Can't decrement.
 		Assert(false);
diff -ru ../silgraphite-2.3.1.orig/engine/src/font/TtfUtil.cpp ./engine/src/font/TtfUtil.cpp
--- ../silgraphite-2.3.1.orig/engine/src/font/TtfUtil.cpp	2012-02-27 21:39:57.000000000 -0500
+++ ./engine/src/font/TtfUtil.cpp	2012-02-27 21:40:30.000000000 -0500
@@ -492,7 +492,7 @@
 	const Sfnt::FontHeader * pTable = 
 			reinterpret_cast<const Sfnt::FontHeader *>(pHead);
 	
-	return read(((pTable->mac_style) & 0x00000002) != 0);
+	return ((read(pTable->mac_style) & 0x00000002) != 0);
 }
 
 /*----------------------------------------------------------------------------------------------
@@ -1108,8 +1108,8 @@
 	{ // loca entries are two bytes and have been divided by two
 		if (nGlyphId <= (lLocaSize >> 1) - 1) // allow sentinel value to be accessed
 		{
-			const uint16 * pTable = reinterpret_cast<const uint16 *>(pLoca);
-			return (read(pTable[nGlyphId]) << 1);
+			const uint16 * pTableLoca = reinterpret_cast<const uint16 *>(pLoca);
+			return (read(pTableLoca[nGlyphId]) << 1);
 		}
 	}
 	
@@ -1117,8 +1117,8 @@
 	{ // loca entries are four bytes
 		if (nGlyphId <= (lLocaSize >> 2) - 1)
 		{
-			const uint32 * pTable = reinterpret_cast<const uint32 *>(pLoca);
-			return read(pTable[nGlyphId]);
+			const uint32 * pTableLoca = reinterpret_cast<const uint32 *>(pLoca);
+			return read(pTableLoca[nGlyphId]);
 		}
 	}
 
@@ -1586,7 +1586,7 @@
 
 	for (size_t i = 0; i < cCompId; i++)
 	{
-		void * pSimpleGlyf = GlyfLookup(static_cast<gr::gid16>(rgnCompId[i]), 
+		pSimpleGlyf = GlyfLookup(static_cast<gr::gid16>(rgnCompId[i]), 
 										pGlyf, pLoca, lLocaSize, pHead);
 		if (pSimpleGlyf == NULL) {return false;}
 
@@ -1748,7 +1748,7 @@
 ----------------------------------------------------------------------------------------------*/
 bool GlyfPoints(gr::gid16 nGlyphId, const void * pGlyf, 
 		const void * pLoca, size_t lLocaSize, const void * pHead, 
-		const int * prgnContourEndPoint, size_t cnEndPoints, 
+		const int * /*prgnContourEndPoint*/, size_t /*cnEndPoints*/, 
 		int * prgnX, int * prgnY, bool * prgfOnCurve, size_t cnPoints)
 {
 	std::fill_n(prgnX, cnPoints, INT_MAX);
diff -ru ../silgraphite-2.3.1.orig/engine/src/painter/SegmentPainter.cpp ./engine/src/painter/SegmentPainter.cpp
--- ../silgraphite-2.3.1.orig/engine/src/painter/SegmentPainter.cpp	2012-02-27 21:39:57.000000000 -0500
+++ ./engine/src/painter/SegmentPainter.cpp	2012-02-27 21:40:30.000000000 -0500
@@ -353,7 +353,7 @@
 	@param bOn				- true if we are turning on (ignored in this implementation)
 ----------------------------------------------------------------------------------------------*/
 bool SegmentPainter::drawSelectionRange(int ichwAnchor, int ichwEnd,
-	float ydLineTop, float ydLineBottom, bool bOn)
+	float ydLineTop, float ydLineBottom, bool /*bOn*/)
 {
 	if (g_fDrawing)
 		return true;
@@ -993,7 +993,7 @@
 								an I-beam (std selection)
 ----------------------------------------------------------------------------------------------*/
 void SegmentPainter::CalcOrDrawInsertionPoint(
-	int ichwIP, bool fAssocPrev, bool bOn, bool fForceSplit,
+	int ichwIP, bool fAssocPrev, bool /*bOn*/, bool fForceSplit,
 	Rect * prdPrimary, Rect * prdSecondary)
 {
 	GrResult res = kresOk;
@@ -1277,7 +1277,7 @@
 							if NULL, do the drawing
 ----------------------------------------------------------------------------------------------*/
 void SegmentPainter::InvertIBeam(float xs, float ysTop, float ysBottom,
-	bool fAssocPrev, Rect * prdRet)
+	bool /*fAssocPrev*/, Rect * prdRet)
 {
 	float xd = ScaleXToDest(xs);
 	float ydTop = ScaleYToDest(ysTop);
@@ -1675,7 +1675,7 @@
 }
 
 bool SegmentPainter::AtEdgeOfCluster(GrSlotOutput * psloutBase, int isloutBase,
-	GrSlotOutput * pslout, int islout, bool fBefore)
+	GrSlotOutput * /*pslout*/, int islout, bool fBefore)
 {
 	//	Compare pslout to all the members of the cluster. If it is the minimum or maximum, it
 	//	is at an edge.
@@ -1778,12 +1778,12 @@
 			}
 			for (icomp = 0; icomp < pslout->NumberOfComponents(); icomp++)
 			{
-				for (int ichw = pslout->FirstUnderlyingComponent(icomp) ; 
-					ichw <= pslout->LastUnderlyingComponent(icomp) ;
-					ichw++)
+				for (int ichwTemp = pslout->FirstUnderlyingComponent(icomp) ; 
+					ichwTemp <= pslout->LastUnderlyingComponent(icomp) ;
+					ichwTemp++)
 				{
-					if (m_pseg->m_prgiComponent[ichw - m_pseg->m_ichwAssocsMin] == icomp)
-						prgfAllSelected[ichw] = fAll;
+					if (m_pseg->m_prgiComponent[ichwTemp - m_pseg->m_ichwAssocsMin] == icomp)
+						prgfAllSelected[ichwTemp] = fAll;
 				}
 			}
 		}
@@ -2304,7 +2304,11 @@
 	Assert that there are no overlaps among all the rectangles in the array, which should
 	be the case if AdjustRectsToNotOverlap is working properly.
 ----------------------------------------------------------------------------------------------*/
+#ifdef _DEBUG
 void SegmentPainter::AssertNoOverlaps(std::vector<Rect> & vrect)
+#else
+void SegmentPainter::AssertNoOverlaps(std::vector<Rect> & /*vrect*/)
+#endif
 {
 #ifdef _DEBUG
 	for (int irect1 = 0; irect1 < signed(vrect.size() - 1); irect1++)
@@ -2452,7 +2456,11 @@
 	Assert that there are no overlaps among all the rectangles in the array, which should
 	be the case if AdjustRectsToNotOverlap is working properly.
 ----------------------------------------------------------------------------------------------*/
+#ifdef _DEBUG
 void SegmentPainter::AssertNoOverlaps(std::vector<LineSeg> & vls)
+#else
+void SegmentPainter::AssertNoOverlaps(std::vector<LineSeg> & /*vls*/)
+#endif
 {
 #ifdef _DEBUG
 	for (int ils1 = 0; ils1 < (int)vls.size() - 1; ils1++)
@@ -2884,7 +2892,7 @@
 	{
 		if (icompNext != icompCurr)
 		{
-			float xsHorizNext = (fIPOnRight) ? vxsRights[icompNext] : vxsLefts[icompNext];
+			xsHorizNext = (fIPOnRight) ? vxsRights[icompNext] : vxsLefts[icompNext];
 			if (fMovingRight && xsHorizNext > xsHorizCurr)
 				break;
 			else if (!fMovingRight && xsHorizNext < xsHorizCurr)
@@ -2996,7 +3004,7 @@
 /*----------------------------------------------------------------------------------------------
 	Make sure the font is set to use the character properties required by this segment.
 ----------------------------------------------------------------------------------------------*/
-void SegmentPainter::SetFontProps(unsigned long clrFore, unsigned long clrBack)
+void SegmentPainter::SetFontProps(unsigned long /*clrFore*/, unsigned long /*clrBack*/)
 {
 	return;
 }
diff -ru ../silgraphite-2.3.1.orig/engine/src/segment/FileInput.cpp ./engine/src/segment/FileInput.cpp
--- ../silgraphite-2.3.1.orig/engine/src/segment/FileInput.cpp	2012-02-27 21:39:57.000000000 -0500
+++ ./engine/src/segment/FileInput.cpp	2012-02-27 21:40:30.000000000 -0500
@@ -80,7 +80,7 @@
 #ifdef GR_FW
 bool GrBufferIStream::Open(std::wstring stuFileName, int kMode)
 #else
-bool GrBufferIStream::Open(const char * pcFileName, std::ios::openmode kMode)
+bool GrBufferIStream::Open(const char * /*pcFileName*/, std::ios::openmode /*kMode*/)
 #endif
 {
 	Assert(false); // use OpenBuffer
diff -ru ../silgraphite-2.3.1.orig/engine/src/segment/GrCharStream.cpp ./engine/src/segment/GrCharStream.cpp
--- ../silgraphite-2.3.1.orig/engine/src/segment/GrCharStream.cpp	2012-02-27 21:39:57.000000000 -0500
+++ ./engine/src/segment/GrCharStream.cpp	2012-02-27 21:40:30.000000000 -0500
@@ -417,8 +417,11 @@
 	return true;
 */
 }
-
+#ifdef NDEBUG
+bool GrCharStream::AtUnicodeCharBoundary(utf8 * prgchs, int cchs, int ichs, UtfType /*utf*/)
+#else
 bool GrCharStream::AtUnicodeCharBoundary(utf8 * prgchs, int cchs, int ichs, UtfType utf)
+#endif
 {
 	Assert(ichs >= 0);
 	Assert(ichs <= cchs);
diff -ru ../silgraphite-2.3.1.orig/engine/src/segment/GrClassTable.h ./engine/src/segment/GrClassTable.h
--- ../silgraphite-2.3.1.orig/engine/src/segment/GrClassTable.h	2012-02-27 21:39:57.000000000 -0500
+++ ./engine/src/segment/GrClassTable.h	2012-02-27 21:40:30.000000000 -0500
@@ -54,7 +54,11 @@
 	/*------------------------------------------------------------------------------------------
 		Copy the raw memory into the instance.
 	------------------------------------------------------------------------------------------*/
+#ifdef NDEBUG
+	void CopyFrom(data16 * pchwStart, int /*cchw*/)
+#else
 	void CopyFrom(data16 * pchwStart, int cchw)
+#endif
 	{
 		m_cgixBIG = pchwStart[0];
 		m_digixBIGInit = pchwStart[1];
diff -ru ../silgraphite-2.3.1.orig/engine/src/segment/GrEngine.cpp ./engine/src/segment/GrEngine.cpp
--- ../silgraphite-2.3.1.orig/engine/src/segment/GrEngine.cpp	2012-02-27 21:39:57.000000000 -0500
+++ ./engine/src/segment/GrEngine.cpp	2012-02-27 21:40:30.000000000 -0500
@@ -159,12 +159,12 @@
 GrEngine::~GrEngine()
 {
 	DestroyEverything();
-	#ifdef _MSC_VER
-	if (!_CrtCheckMemory())
-	{
-		OutputDebugString(L"bad memory");
-	}
-	#endif
+//	#ifdef _MSC_VER
+//	if (!_CrtCheckMemory())
+//	{
+//		OutputDebugString(L"bad memory");
+//	}
+//	#endif
 }
 
 /*----------------------------------------------------------------------------------------------
@@ -173,12 +173,12 @@
 void GrEngine::DestroyEverything()
 {
 	DestroyContents();
-	#ifdef _MSC_VER
-	if (!_CrtCheckMemory())
-	{
-		OutputDebugString(L"bad memory");
-	}
-	#endif
+//	#ifdef _MSC_VER
+//	if (!_CrtCheckMemory())
+//	{
+//		OutputDebugString(L"bad memory");
+//	}
+//	#endif
 
 	m_strCtrlFileReg.erase();
 	m_strCtrlFileBold.erase();
@@ -417,7 +417,11 @@
 	@return The supported script direction(s). If more than one, the application is
 	responsible for choosing the most appropriate.
 ----------------------------------------------------------------------------------------------*/
+#ifdef NDEBUG
+GrResult GrEngine::get_ScriptDirection(unsigned int * pgrfsdc, OLECHAR * /*prgchwErrMsg*/, int /*cchMaxErrMsg*/)
+#else
 GrResult GrEngine::get_ScriptDirection(unsigned int * pgrfsdc, OLECHAR * prgchwErrMsg, int cchMaxErrMsg)
+#endif
 {
 	ChkGrOutPtr(pgrfsdc);
 	ChkGrArrayArg(prgchwErrMsg, cchMaxErrMsg);
@@ -789,7 +793,7 @@
 	Record a system error indicating a bad error in rendering using a supposedly valid font.
 	OBSOLETE
 ----------------------------------------------------------------------------------------------*/
-void GrEngine::RecordFontRunError(OLECHAR * prgchwErrMsg, int cchMax, GrResult res)
+void GrEngine::RecordFontRunError(OLECHAR * prgchwErrMsg, int cchMax, GrResult /*res*/)
 {
 	if (prgchwErrMsg == NULL || cchMax == 0)
 		return;
@@ -970,7 +974,7 @@
 /*----------------------------------------------------------------------------------------------
 	Return whether the text is asking for bold and/or italic text.
 ----------------------------------------------------------------------------------------------*/
-void GrEngine::GetStyles(Font * pfont, int ichwMin, bool * pfBold, bool * pfItalic)
+void GrEngine::GetStyles(Font * pfont, int /*ichwMin*/, bool * pfBold, bool * pfItalic)
 {
 	*pfBold = pfont->bold();
 	*pfItalic = pfont->italic();
@@ -981,7 +985,11 @@
 	Should only be called when we know we are using a base font, or when we are reading
 	the base font to see if it is valid.
 ----------------------------------------------------------------------------------------------*/
+#ifdef NDEBUG
+void GrEngine::SwitchGraphicsFont(bool /*fBase*/)
+#else
 void GrEngine::SwitchGraphicsFont(bool fBase)
+#endif
 {
 	Assert(!fBase || m_stuBaseFaceName.size() > 0);
 
@@ -1135,7 +1143,7 @@
 		m_chwJShrink0 = 0xffff;
 		m_chwJStep0 = 0xffff;
 		m_chwJWeight0 = 0xffff;
-		for (int i = 0; i < m_cJLevels; i++)
+		for (i = 0; i < m_cJLevels; i++)
 		{
 			//	justification glyph attribute IDs
 			bTmp = grstrm.ReadByteFromFont();
@@ -1210,10 +1218,12 @@
 
 	//	rendering behaviors--ignore for now
 	byte cBehaviors = grstrm.ReadByteFromFont();
-	unsigned int nBehaviors[kMaxRenderingBehavior];
+	int nTmp;
+	//unsigned int nBehaviors[kMaxRenderingBehavior]; -- this big buffer causes a stack overflow in Multiscribe; rework eventually
 	for (i = 0; i < cBehaviors; i++)
 	{
-		nBehaviors[i] = unsigned(grstrm.ReadIntFromFont());
+		//nBehaviors[i] = unsigned(grstrm.ReadIntFromFont());
+		nTmp = unsigned(grstrm.ReadIntFromFont());
 	}
 
 	//	linebreak glyph ID
diff -ru ../silgraphite-2.3.1.orig/engine/src/segment/GrFSM.cpp ./engine/src/segment/GrFSM.cpp
--- ../silgraphite-2.3.1.orig/engine/src/segment/GrFSM.cpp	2012-02-27 21:39:57.000000000 -0500
+++ ./engine/src/segment/GrFSM.cpp	2012-02-27 21:40:30.000000000 -0500
@@ -46,7 +46,7 @@
 	Fill in the FSM by reading from the font stream.
 	Assumes the stream is in the correct position.
 ----------------------------------------------------------------------------------------------*/
-bool GrFSM::ReadFromFont(GrIStream & grstrm, int fxdVersion)
+bool GrFSM::ReadFromFont(GrIStream & grstrm, int /*fxdVersion*/)
 {
 	short snTmp;
 	
@@ -138,7 +138,7 @@
 	Fill in the FSM's state table by reading from the font stream.
 	Assumes the stream is in the correct position.
 ----------------------------------------------------------------------------------------------*/
-bool GrFSM::ReadStateTableFromFont(GrIStream & grstrm, int fxdVersion)
+bool GrFSM::ReadStateTableFromFont(GrIStream & grstrm, int /*fxdVersion*/)
 {
 	int cCells = ((m_crow - m_crowFinal) * m_ccol);
 	m_prgrowTransitions = new short[cCells];
diff -ru ../silgraphite-2.3.1.orig/engine/src/segment/GrFeature.cpp ./engine/src/segment/GrFeature.cpp
--- ../silgraphite-2.3.1.orig/engine/src/segment/GrFeature.cpp	2012-02-27 21:39:57.000000000 -0500
+++ ./engine/src/segment/GrFeature.cpp	2012-02-27 21:40:30.000000000 -0500
@@ -186,7 +186,7 @@
 /*----------------------------------------------------------------------------------------------
 	Read the languages from the font.
 ----------------------------------------------------------------------------------------------*/
-bool GrLangTable::ReadFromFont(GrIStream * pgrstrm, int fxdVersion)
+bool GrLangTable::ReadFromFont(GrIStream * pgrstrm, int /*fxdVersion*/)
 {
 	GrIStream & grstrm = *pgrstrm;
 	
@@ -206,13 +206,22 @@
 
 	m_cbOffset0 = (lsbf)(m_prglang[0].cbOffsetBIG);
 
-	Assert((lsbf)(m_prglang[m_clang].cFeaturesBIG) == 0); // bogus entry has no settings
+	if ((lsbf)(m_prglang[m_clang].cFeaturesBIG) == 0) // bogus entry has no settings
+	{
 	cb = (lsbf)(m_prglang[m_clang].cbOffsetBIG) - m_cbOffset0;
-	Assert(cb % sizeof(FeatSet) == 0); // # of bytes fits nicely into FeatSet class
+		if (cb % sizeof(FeatSet) == 0) // # of bytes fits nicely into FeatSet class
+		{
 	int cfset = cb / sizeof(FeatSet);
 	m_prgfset = new FeatSet[cfset];
 	m_cfset = cfset;
 	grstrm.ReadBlockFromFont(m_prgfset, cb);
+		}
+		else return false;
+	}
+	else
+	{
+		return false;
+	}
 
 	return true;
 }
diff -ru ../silgraphite-2.3.1.orig/engine/src/segment/GrPass.cpp ./engine/src/segment/GrPass.cpp
--- ../silgraphite-2.3.1.orig/engine/src/segment/GrPass.cpp	2012-02-27 21:39:57.000000000 -0500
+++ ./engine/src/segment/GrPass.cpp	2012-02-27 21:40:30.000000000 -0500
@@ -279,9 +279,10 @@
 	@param twsh					- how we are handling trailing white-space
 	@param pnRet				- return value
 	@param pcslotGot			- return the number of slots gotten
-	@param pislotFinalBreak		- return the index of the final slot, when we are removing
-									the trailing white-space and so the end of the segment
-									will be before the any actual line-break slot
+	@param pislotFinalBreak		- index of the final slot (LB or actual glyph), or -1;
+									adjusted when we are removing the trailing white-space and
+									so the end of the segment will be before the any actual
+									line-break slot
 
 	@return kNextPass if we were able to generated the number requested, or processing is
 		complete; otherwise return the number of slots needed from the previous pass.
@@ -465,7 +466,7 @@
 void GrBidiPass::ExtendOutput(GrTableManager * ptman,
 	GrSlotStream* psstrmIn, GrSlotStream* psstrmOut,
 	int cslotNeededByNext, TrWsHandling twsh,
-	int * pnRet, int * pcslotGot, int * pislotFinalBreak)
+	int * pnRet, int * pcslotGot, int * /*pislotFinalBreak*/)
 {
 	Assert(psstrmIn->SlotsToReprocess() == 0);
 
@@ -776,7 +777,7 @@
 int GrPass::ExtendFinalOutput(GrTableManager * ptman,
 	GrSlotStream * psstrmInput, GrSlotStream * psstrmOutput,
 	float xsSpaceAllotted, bool fWidthIsCharCount, bool fInfiniteWidth,
-	bool fHaveLineBreak, bool fMustBacktrack, LineBrk lbMax, TrWsHandling twsh,
+	bool fHaveLineBreak, bool fMustBacktrack, LineBrk /*lbMax*/, TrWsHandling twsh,
 	int * pislotLB, float * pxsWidth)
 {
 	EngineState * pengst = ptman->State();
@@ -897,7 +898,11 @@
 	Remove undesirable trailing white-space.
 ----------------------------------------------------------------------------------------------*/
 int GrPass::RemoveTrailingWhiteSpace(GrTableManager * ptman, GrSlotStream * psstrmOut,
+#ifdef NDEBUG
+	TrWsHandling /*twsh*/, int * pislotFinalBreak)
+#else
 	TrWsHandling twsh, int * pislotFinalBreak)
+#endif
 {
 	EngineState * pengst = ptman->State();
 
@@ -944,7 +949,7 @@
 	should never be necessary if they've set up their tables right.
 ----------------------------------------------------------------------------------------------*/
 void GrPass::CheckInputProgress(GrSlotStream * psstrmInput, GrSlotStream * psstrmOutput,
-	int islotOrigInput)
+	int /*islotOrigInput*/)
 {
 	int islotInput = psstrmInput->ReadPosForNextGet();
 //	Assert(islotInput >= islotOrigInput); -- no longer true now that we can back up
@@ -1752,7 +1757,7 @@
 ----------------------------------------------------------------------------------------------*/
 int GrPass::Unwind(GrTableManager * ptman,
 	int islotChanged, GrSlotStream * psstrmIn, GrSlotStream * psstrmOut,
-	bool fFirst)
+	bool /*fFirst*/)
 {
 	//	Back up the number of slots required for the longest rule context,
 	//	but if we land in the middle of a chunk, go forward to its boundary.
@@ -1824,7 +1829,7 @@
 ----------------------------------------------------------------------------------------------*/
 int GrBidiPass::Unwind(GrTableManager * ptman,
 	int islotChanged, GrSlotStream * psstrmIn, GrSlotStream * psstrmOut,
-	bool fFirst)
+	bool /*fFirst*/)
 {
 	int islotIn;
 	int islotOut;
@@ -1901,8 +1906,8 @@
 	OBSOLETE
 ----------------------------------------------------------------------------------------------*/
 //:Ignore
-void GrPosPass::Unattach(GrSlotStream * psstrmIn, int islotIn,
-	GrSlotStream * psstrmOut, int islotOut, int islotLB)
+void GrPosPass::Unattach(GrSlotStream * /*psstrmIn*/, int /*islotIn*/,
+	GrSlotStream * /*psstrmOut*/, int /*islotOut*/, int /*islotLB*/)
 {
 	//	Because this is a positioning pass, there is a one-to-one correspondence between
 	//	the slots in the input and the slots in the output. Thus we can make simplifying
diff -ru ../silgraphite-2.3.1.orig/engine/src/segment/GrPass.h ./engine/src/segment/GrPass.h
--- ../silgraphite-2.3.1.orig/engine/src/segment/GrPass.h	2012-02-27 21:39:57.000000000 -0500
+++ ./engine/src/segment/GrPass.h	2012-02-27 21:40:30.000000000 -0500
@@ -197,7 +197,7 @@
 	bool ReadFromFont(GrIStream & grstrm, int fxdSilfVersion, int fxdRuleVersion, int nOffset);
 	void InitializeWithNoRules();
 
-	virtual void SetTopDirLevel(int n)
+	virtual void SetTopDirLevel(int /*n*/)
 	{	// only GrBidiPass does anything interesting
 	}
 
@@ -253,13 +253,13 @@
 		m_pzpst->SetResyncSkip(n);
 	}
 
-	virtual void DoCleanUpSegMin(GrTableManager * ptman,
-		GrSlotStream * psstrmIn, int islotInitReadPos, GrSlotStream * psstrmOut)
+	virtual void DoCleanUpSegMin(GrTableManager * /*ptman*/,
+		GrSlotStream * /*psstrmIn*/, int /*islotInitReadPos*/, GrSlotStream * /*psstrmOut*/)
 	{
 	}
 
-	virtual void DoCleanUpSegLim(GrTableManager * ptman, GrSlotStream * psstrmOut,
-		TrWsHandling twsh)
+	virtual void DoCleanUpSegLim(GrTableManager * /*ptman*/, GrSlotStream * /*psstrmOut*/,
+		TrWsHandling /*twsh*/)
 	{
 	}
 
@@ -383,8 +383,8 @@
 	void MapChunks(GrSlotStream * psstrmIn, GrSlotStream * psstrmOut,
 		int islotChunkI, int islotChunkO, int cslotReprocessed);
 
-	virtual void Unattach(GrSlotStream * psstrmIn, int islotIn,	// GrPosPass overrides
-		GrSlotStream * psstrmOut, int islotOut, int islotLB)
+	virtual void Unattach(GrSlotStream * /*psstrmIn*/, int /*islotIn*/,	// GrPosPass overrides
+		GrSlotStream * /*psstrmOut*/, int /*islotOut*/, int /*islotLB*/)
 	{
 	}
 
@@ -500,8 +500,8 @@
 
 protected:
 	//	Irrelevant when generating glyphs.
-	virtual void RunRule(GrTableManager *, int ruln,
-		GrSlotStream * psstrmInput, GrSlotStream * psstrmOutput)
+	virtual void RunRule(GrTableManager *, int /*ruln*/,
+		GrSlotStream * /*psstrmInput*/, GrSlotStream * /*psstrmOutput*/)
 	{
 		Assert(false);
 	}
diff -ru ../silgraphite-2.3.1.orig/engine/src/segment/GrPassActionCode.cpp ./engine/src/segment/GrPassActionCode.cpp
--- ../silgraphite-2.3.1.orig/engine/src/segment/GrPassActionCode.cpp	2012-02-27 21:39:57.000000000 -0500
+++ ./engine/src/segment/GrPassActionCode.cpp	2012-02-27 21:40:30.000000000 -0500
@@ -632,8 +632,13 @@
 /*----------------------------------------------------------------------------------------------
 	We are finished processing a slot; go on to the next slot, or possibly go backwards.
 ----------------------------------------------------------------------------------------------*/
-void GrPass::DoNext(GrTableManager * ptman,
-	int cslot, GrSlotStream * psstrmIn, GrSlotStream * psstrmOut)
+#ifdef NDEBUG
+void GrPass::DoNext(GrTableManager * /*ptman*/,
+	int /*cslot*/, GrSlotStream * /*psstrmIn*/, GrSlotStream * /*psstrmOut*/)
+#else
+void GrPass::DoNext(GrTableManager * /*ptman*/,
+	int cslot, GrSlotStream * /*psstrmIn*/, GrSlotStream * /*psstrmOut*/)
+#endif
 {
 	gAssert(cslot == 1);	// for now anyway
 }
@@ -690,6 +695,7 @@
 		psstrmOut->SetSegMinToWritePos(false);
 	if (fSetSegLim)
 		psstrmOut->SetSegLimToWritePos(false);
+	//gid16 chw; chw = pslotNew->GlyphID();
 	psstrmOut->NextPut(pslotNew);
 }
 
@@ -729,6 +735,7 @@
 		psstrmOut->SetSegMinToWritePos(false);
 	if (fSetSegLim)
 		psstrmOut->SetSegLimToWritePos(false);
+	//gid16 chw; chw = pslotNew->GlyphID();
 	psstrmOut->NextPut(pslotNew);
 }
 
@@ -825,7 +832,7 @@
 	@param psstrmIn / Out		- input/output streams
 ----------------------------------------------------------------------------------------------*/
 void GrPass::DoPutSubs3(GrTableManager * ptman, bool fInserting,
-	int cslotSel1, int nSelClass1, int cslotSel2, int nSelClass2, int cslotSel3, int nSelClass3,
+	int cslotSel1, int nSelClass1, int cslotSel2, int nSelClass2, int /*cslotSel3*/, int nSelClass3,
 	int nReplacementClass,
 	GrSlotStream * psstrmIn, GrSlotStream * psstrmOut)
 {
@@ -888,7 +895,7 @@
 	Common part of all the DoPutSubs... methods.
 ----------------------------------------------------------------------------------------------*/
 void GrPass::DoPutSubsAux(GrTableManager * ptman, bool fInserting, gid16 nGlyphReplacement,
-	GrSlotStream * psstrmIn, GrSlotStream * psstrmOut, GrSlotState * pslotNextInput,
+	GrSlotStream * /*psstrmIn*/, GrSlotStream * psstrmOut, GrSlotState * pslotNextInput,
 	bool fAtSegMin, bool fAtSegLim)
 {
 	EngineState * pengst = ptman->State();
@@ -915,6 +922,7 @@
 		psstrmOut->SetSegMinToWritePos(false);
 	if (fSetSegLim)
 		psstrmOut->SetSegLimToWritePos(false);
+	//gid16 chw; chw = pslotNew->GlyphID();
 	psstrmOut->NextPut(pslotNew);
 }
 
@@ -924,7 +932,7 @@
 	and its after-assoc to the slot before it. This makes it basically unselectable.
 	OBSOLETE - handled by slot initialization code
 ----------------------------------------------------------------------------------------------*/
-void GrPass::SetNeutralAssocs(GrSlotState * pslotNew, GrSlotStream * psstrmIn)
+void GrPass::SetNeutralAssocs(GrSlotState * pslotNew, GrSlotStream * /*psstrmIn*/)
 {
 	pslotNew->ClearAssocs();
 }
@@ -943,6 +951,7 @@
 		psstrmOut->SetSegLimToWritePos();
 
 	GrSlotState * pslot = psstrmIn->NextGet();
+	//gid16 chw; chw = pslotNew->GlyphID();
 	pslot->MarkDeleted();
 
 	if (ptman->LoggingTransduction())
@@ -957,7 +966,7 @@
 	@param fInserting			- whether current slot was inserted
 	@param psstrmIn / Out		- input/output streams
 ----------------------------------------------------------------------------------------------*/
-void GrPass::DoAssoc(int cnAssocs, std::vector<int> & vnAssocs, bool fInserting,
+void GrPass::DoAssoc(int cnAssocs, std::vector<int> & vnAssocs, bool /*fInserting*/,
 	GrSlotStream * psstrmIn, GrSlotStream * psstrmOut)
 {
 	gAssert((unsigned)cnAssocs == vnAssocs.size());
@@ -997,7 +1006,11 @@
 	@param vnStack				- stack to read value from
 	@param psstrmIn / Out		- input/output streams
 ----------------------------------------------------------------------------------------------*/
+#ifdef NDEBUG
+void GrPass::DoSetAttr(GrTableManager * ptman, ActionCommand op, bool /*fInserting*/,
+#else
 void GrPass::DoSetAttr(GrTableManager * ptman, ActionCommand op, bool fInserting,
+#endif
 	SlotAttrName slat, int slati, std::vector<int> & vnStack,
 	GrSlotStream * psstrmIn, GrSlotStream * psstrmOut)
 {
@@ -1192,7 +1205,7 @@
 	@param psstrmIn				- input stream
 ----------------------------------------------------------------------------------------------*/
 void GrPass::DoPushSlotAttr(GrTableManager * ptman,
-	int nSlotRef, bool fInserting,
+	int nSlotRef, bool /*fInserting*/,
 	SlotAttrName slat, int slati, std::vector<int> & vnStack,
 	GrSlotStream * psstrmIn, GrSlotStream * psstrmOut)
 {
@@ -1236,16 +1249,16 @@
 
 	case kslatAttTo:		nVal = pslot->AttachTo();			break;
 	case kslatAttLevel:		nVal = pslot->AttachLevel();		break;
-	case kslatAttAtX:		nVal = pslot->AttachAtX(ptman, psstrmIn); break;
 	case kslatAttAtY:		nVal = pslot->AttachAtY();			break;
 	case kslatAttAtGpt:		nVal = pslot->AttachAtGpoint();		break;
 	case kslatAttAtXoff:	nVal = pslot->AttachAtXOffset();	break;
 	case kslatAttAtYoff:	nVal = pslot->AttachAtYOffset();	break;
-	case kslatAttWithX:		nVal = pslot->AttachWithX(ptman, psstrmIn); break;
 	case kslatAttWithY:		nVal = pslot->AttachWithY();		break;
 	case kslatAttWithGpt:	nVal = pslot->AttachWithGpoint();	break;
 	case kslatAttWithXoff:	nVal = pslot->AttachWithXOffset();	break;
 	case kslatAttWithYoff:	nVal = pslot->AttachWithYOffset();	break;
+	case kslatAttAtX:		nVal = pslot->AttachAtX(ptman, psstrmIn);	break;
+	case kslatAttWithX:		nVal = pslot->AttachWithX(ptman, psstrmIn);	break;
 
 	case kslatMeasureSol:	nVal = pslot->MeasureSol();			break;
 	case kslatMeasureEol:	nVal = pslot->MeasureEol();			break;
@@ -1282,7 +1295,7 @@
 	@param vnStack				- stack to push onto
 	@param psstrmIn				- input stream
 ----------------------------------------------------------------------------------------------*/
-void GrPass::DoPushGlyphAttr(GrTableManager * ptman, int nSlotRef, bool fInserting,
+void GrPass::DoPushGlyphAttr(GrTableManager * ptman, int nSlotRef, bool /*fInserting*/,
 	int nGlyphAttr,
 	std::vector<int> & vnStack, GrSlotStream * psstrmIn, GrSlotStream * psstrmOut)
 {
@@ -1307,7 +1320,7 @@
 	@param vnStack				- stack to push onto
 	@param psstrmIn				- input stream
 ----------------------------------------------------------------------------------------------*/
-void GrPass::DoPushAttToGlyphAttr(GrTableManager * ptman, int nSlotRef, bool fInserting,
+void GrPass::DoPushAttToGlyphAttr(GrTableManager * ptman, int nSlotRef, bool /*fInserting*/,
 	int nGlyphAttr, std::vector<int> & vnStack,
 	GrSlotStream * psstrmIn, GrSlotStream * psstrmOut)
 {
@@ -1337,7 +1350,7 @@
 	@param vnStack				- stack to push onto
 	@param psstrmIn				- input stream
 ----------------------------------------------------------------------------------------------*/
-void GrPass::DoPushGlyphMetric(GrTableManager * ptman, int nSlotRef, bool fInserting,
+void GrPass::DoPushGlyphMetric(GrTableManager * ptman, int nSlotRef, bool /*fInserting*/,
 	int nGlyphAttr, int nAttLevel,
 	std::vector<int> & vnStack, GrSlotStream * psstrmIn, GrSlotStream * psstrmOut)
 {
@@ -1364,7 +1377,7 @@
 	@param psstrmIn				- input stream
 	@param psstrmOut			- output stream
 ----------------------------------------------------------------------------------------------*/
-void GrPass::DoPushAttToGlyphMetric(GrTableManager * ptman, int nSlotRef, bool fInserting,
+void GrPass::DoPushAttToGlyphMetric(GrTableManager * ptman, int nSlotRef, bool /*fInserting*/,
 	int nGlyphAttr, int nAttLevel,
 	std::vector<int> & vnStack,
 	GrSlotStream * psstrmIn, GrSlotStream * psstrmOut)
@@ -1399,7 +1412,7 @@
 	}
 	else
 	{
-		pslot->CalcCompositeMetrics(ptman, psstrmIn, nAttLevel, true);
+		pslot->CalcCompositeMetrics(ptman, psstrmIn, NULL, nAttLevel, true);
 
 		float xy;
 		switch (gmet)
@@ -1435,7 +1448,11 @@
 	@param psstrmIn				- input stream
 	@param psstrmOut			- output stream
 ----------------------------------------------------------------------------------------------*/
-void GrPass::DoPushFeatValue(GrTableManager * ptman, int nSlotRef, bool fInserting,
+#ifdef NDEBUG
+void GrPass::DoPushFeatValue(GrTableManager * /*ptman*/, int nSlotRef, bool /*fInserting*/,
+#else
+void GrPass::DoPushFeatValue(GrTableManager * /*ptman*/, int nSlotRef, bool fInserting,
+#endif
 	int nFeat, std::vector<int> & vnStack, GrSlotStream * psstrmIn, GrSlotStream * psstrmOut)
 {
 	gAssert(!fInserting);
diff -ru ../silgraphite-2.3.1.orig/engine/src/segment/GrSlotState.cpp ./engine/src/segment/GrSlotState.cpp
--- ../silgraphite-2.3.1.orig/engine/src/segment/GrSlotState.cpp	2012-02-27 21:39:57.000000000 -0500
+++ ./engine/src/segment/GrSlotState.cpp	2012-02-27 21:40:30.000000000 -0500
@@ -261,7 +261,7 @@
 	root or attached leaf slots.
 	OBSOLETE
 ----------------------------------------------------------------------------------------------*/
-void GrSlotState::FixAttachmentTree(GrSlotState * pslotOld)
+void GrSlotState::FixAttachmentTree(GrSlotState * /*pslotOld*/)
 {
 #if 0
 	pslotOld->m_vpslotAttLeaves.CopyTo(m_vpslotAttLeaves);
@@ -524,13 +524,13 @@
 		GrSlotState * pslot;
 		if (HasComponents())
 		{
-			for (int iComponent = 0; iComponent < m_cnCompPerLig; iComponent++)
+			for (int iLigComponent = 0; iLigComponent < m_cnCompPerLig; iLigComponent++)
 			{
-				pslot = CompRefSlot(iComponent);
+				pslot = CompRefSlot(iLigComponent);
 				if (pslot)
 				{
 					Assert(PassModified() >= pslot->PassModified());
-					pslot->AllComponentRefs(vichw, vicomp, iComponent);
+					pslot->AllComponentRefs(vichw, vicomp, iLigComponent);
 				}
 			}
 		}
@@ -1024,7 +1024,7 @@
 	NOTE: the caller is responsible to zap the cached positions of following glyphs
 	in the stream.
 ----------------------------------------------------------------------------------------------*/
-void GrSlotState::AttachToRoot(GrTableManager * ptman, GrSlotStream * psstrm,
+void GrSlotState::AttachToRoot(GrTableManager * /*ptman*/, GrSlotStream * psstrm,
 	GrSlotState * pslotNewRoot)
 {
 	GrSlotState * pslotOldRoot = (m_dislotRootFixed == 0) ?
@@ -1063,7 +1063,7 @@
 
 	float xsWidth, xsVisWidth;
 	if (m_xsPositionX == kNegInfFloat || m_ysPositionY == kNegInfFloat)
-		ptman->CalcPositionsUpTo(psstrmOut->m_ipass, this, &xsWidth, &xsVisWidth);
+		ptman->CalcPositionsUpTo(psstrmOut->m_ipass, this, true, &xsWidth, &xsVisWidth);
 
 	*pmXPos = ptman->LogToEmUnits(m_xsPositionX);
 	*pmYPos = ptman->LogToEmUnits(m_ysPositionY);
@@ -1077,7 +1077,7 @@
 {
 	Assert(m_dislotRootFixed == m_srAttachTo);
 	GrSlotState * pslotRoot = AttachRoot(psstrm);
-	CalcRootMetrics(ptman, psstrm, kPosInfinity);
+	CalcRootMetrics(ptman, psstrm, NULL, kPosInfinity);
 	if (pslotRoot)
 		pslotRoot->AdjustRootMetrics(ptman, psstrm);
 }
@@ -1086,13 +1086,15 @@
 	Calculate the composite metrics for this slot.
 
 	@param psstrm			- stream for which we are calculating it
+	@param psstrmNext		- because when processing in the middle of a pass, we may need to
+								get the slot from the following (output) stream
 	@param nLevel			- attachment level we are asking for; kPosInifinity means all levels
 	@param fThorough		- true: do a thorough recalculation; false: don't recalculate
 								metrics for leaves (are they assumed to be accurate???)
 								--currently not used
 ----------------------------------------------------------------------------------------------*/
 void GrSlotState::CalcCompositeMetrics(GrTableManager * ptman, GrSlotStream * psstrm,
-	int nLevel, bool fThorough)
+	GrSlotStream * psstrmNext, int nLevel, bool fThorough)
 {
 	if (m_nCompositeLevel == nLevel)
 		return;
@@ -1101,19 +1103,38 @@
 	{
 		Assert(m_dislotRootFixed == m_srAttachTo);
 		GrSlotState * pslotRoot = AttachRoot(psstrm);
+		// Kludge to handle the fact that we might have gotten the root from the wrong stream.
+		// Calling MidPassSlotAt finds the right one.
+		if (psstrmNext && pslotRoot)
+		{
+			int islotRoot = pslotRoot->PosPassIndex();
+			pslotRoot = psstrm->MidPassSlotAt(islotRoot, psstrmNext);
+		}
 
 		InitMetrics(ptman, pslotRoot);
 
 		for (size_t islot = 0; islot < m_vdislotAttLeaves.size(); islot++)
 		{
-			GrSlotState * pslotLeaf = SlotAtOffset(psstrm, m_vdislotAttLeaves[islot]);
+			GrSlotState * pslotLeaf;
+			if (psstrmNext)
+			{
+				// Calculating a position in the middle of processing a pass.
+				pslotLeaf = psstrm->MidPassSlotAt(PosPassIndex() + m_vdislotAttLeaves[islot],
+					psstrmNext);
+			}
+			else
+			{
+				// Calculating the final position.
+				pslotLeaf = SlotAtOffset(psstrm, m_vdislotAttLeaves[islot]);
+			}
+
 			if (pslotLeaf->AttachLevel() <= nLevel)
-				pslotLeaf->CalcCompositeMetrics(ptman, psstrm, nLevel, fThorough);
+				pslotLeaf->CalcCompositeMetrics(ptman, psstrm, psstrmNext, nLevel, fThorough);
 			else
 				//	this slot will be ignored in the composite metrics
 				pslotLeaf->ZapRootMetrics();
 		}
-		CalcRootMetrics(ptman, psstrm, nLevel);
+		CalcRootMetrics(ptman, psstrm, psstrmNext, nLevel);
 
 		m_nCompositeLevel = nLevel;
 	}
@@ -1129,25 +1150,33 @@
 /*----------------------------------------------------------------------------------------------
 	Calculate the metrics for this node and all its leaf nodes.
 ----------------------------------------------------------------------------------------------*/
-void GrSlotState::CalcRootMetrics(GrTableManager * ptman, GrSlotStream * psstrm, int nLevel)
+void GrSlotState::CalcRootMetrics(GrTableManager * /*ptman*/, GrSlotStream * psstrm,
+	GrSlotStream * psstrmNext, int nLevel)
 {
 	for (size_t idislot = 0; idislot < m_vdislotAttLeaves.size(); idislot++)
 	{
-		GrSlotState * pslot = SlotAtOffset(psstrm, m_vdislotAttLeaves[idislot]);
-		if (pslot->AttachLevel() > nLevel)
+		GrSlotState * pslotLeaf = SlotAtOffset(psstrm, m_vdislotAttLeaves[idislot]);
+		// Kludge to handle the fact that we might have gotten the leaf from the wrong stream.
+		// Calling MidPassSlotAt finds the right one.
+		if (psstrmNext)
+		{
+			int islot = pslotLeaf->PosPassIndex();
+			pslotLeaf = psstrm->MidPassSlotAt(islot, psstrmNext);
+		}
+		if (pslotLeaf->AttachLevel() > nLevel)
 			continue;
 
-		m_xsClusterXOffset = min(m_xsClusterXOffset, pslot->m_xsClusterXOffset);
-		if (!pslot->m_fIgnoreAdvance)
+		m_xsClusterXOffset = min(m_xsClusterXOffset, pslotLeaf->m_xsClusterXOffset);
+		if (!pslotLeaf->m_fIgnoreAdvance)
 		{
 			m_xsClusterAdv = max(
 				m_xsClusterAdv,
-				pslot->m_xsClusterAdv + m_xsRootShiftX);
+				pslotLeaf->m_xsClusterAdv + m_xsRootShiftX);
 		}
-		m_xsClusterBbLeft = min(m_xsClusterBbLeft, pslot->m_xsClusterBbLeft);
-		m_xsClusterBbRight = max(m_xsClusterBbRight, pslot->m_xsClusterBbRight);
-		m_ysClusterBbTop = max(m_ysClusterBbTop, pslot->m_ysClusterBbTop);
-		m_ysClusterBbBottom = min(m_ysClusterBbBottom, pslot->m_ysClusterBbBottom);
+		m_xsClusterBbLeft = min(m_xsClusterBbLeft, pslotLeaf->m_xsClusterBbLeft);
+		m_xsClusterBbRight = max(m_xsClusterBbRight, pslotLeaf->m_xsClusterBbRight);
+		m_ysClusterBbTop = max(m_ysClusterBbTop, pslotLeaf->m_ysClusterBbTop);
+		m_ysClusterBbBottom = min(m_ysClusterBbBottom, pslotLeaf->m_ysClusterBbBottom);
 	}
 }
 
@@ -1263,7 +1292,7 @@
 /*----------------------------------------------------------------------------------------------
 	Y-offsets of a single glyph relative to the previous advance position.
 ----------------------------------------------------------------------------------------------*/
-float GrSlotState::GlyphYOffset(GrSlotStream * psstrm)
+float GrSlotState::GlyphYOffset(GrSlotStream * /*psstrm*/)
 {
 	return m_ysOffsetY;
 }
diff -ru ../silgraphite-2.3.1.orig/engine/src/segment/GrSlotState.h ./engine/src/segment/GrSlotState.h
--- ../silgraphite-2.3.1.orig/engine/src/segment/GrSlotState.h	2012-02-27 21:39:57.000000000 -0500
+++ ./engine/src/segment/GrSlotState.h	2012-02-27 21:40:30.000000000 -0500
@@ -48,7 +48,7 @@
 	{
 	}
 
-	~GrSlotAbstract()
+	virtual ~GrSlotAbstract()
 	{
 		// the table manager is responsible for destroying the contents of m_prgnVarLenBuf
 	}
@@ -231,7 +231,7 @@
 		ZapCompositeMetrics();
 	}
 
-	~GrSlotState()
+	virtual ~GrSlotState()
 	{
 	}
 
@@ -308,7 +308,11 @@
 	{
 		return m_islotPosPass;
 	}
+#ifdef NDEBUG
+	void SetPosPassIndex(int islot, bool /*fInputToPosPass1*/)
+#else
 	void SetPosPassIndex(int islot, bool fInputToPosPass1)
+#endif
 	{
 		// If we're resetting it, it should be to the same value as before:
 		Assert(fInputToPosPass1 || m_islotPosPass == kNotYetSet || m_islotPosPass == islot);
@@ -386,12 +390,12 @@
 		return (IsInitialLineBreak(chwLB) || IsFinalLineBreak(chwLB));
 		//return (m_chwGlyphID == chwLB); // TODO: remove
 	}
-	bool IsInitialLineBreak(gid16 chwLB)
+	bool IsInitialLineBreak(gid16 /*chwLB*/)
 	{
 		return (m_spsl == kspslLbInitial);
 		//return (IsLineBreak(chwLB) && m_fInitialLB == true); // TODO: remove
 	}
-	bool IsFinalLineBreak(gid16 chwLB)
+	bool IsFinalLineBreak(gid16 /*chwLB*/)
 	{
 		return (m_spsl == kspslLbFinal);
 		//return (IsLineBreak(chwLB) && m_fInitialLB == false); // TODO: remove
@@ -475,7 +479,7 @@
 		return m_mAttachAtX;
 	}
 
-	int AttachWithX(GrTableManager * ptman, GrSlotStream * psstrm)
+	int AttachWithX(GrTableManager * /*ptman*/, GrSlotStream * /*psstrm*/)
 	{
 		if (m_mAttachAtX == kNotYetSet)
 		{
@@ -615,7 +619,7 @@
 		GrSlotStream * psstrmIn, GrSlotStream * psstrmOut, int islotThis);
 
 	void CalcCompositeMetrics(GrTableManager * ptman, GrSlotStream * psstrm,
-		int nLevel, bool fThorough = false);
+		GrSlotStream * psstrmNext, int nLevel, bool fThorough = false);
 
 	void Position(GrTableManager * ptman,
 		GrSlotStream * psstrmOut, int * pmXPos, int * pmYPos);
@@ -646,7 +650,7 @@
 	{
 		return ClusterBbLeft(psstrm) + xs;
 	}
-	float ClusterRsb(GrSlotStream * psstrm, float xs)
+	float ClusterRsb(GrSlotStream * /*psstrm*/, float xs)
 	{
 		return ClusterAdvWidthFrom(xs) - ClusterBbRightFrom(xs);
 	}
@@ -668,19 +672,19 @@
 	{
 		return ClusterBbRightFrom(Base(psstrm)->ClusterRootOffset());
 	}
-	float ClusterBbTop(GrSlotStream * psstrm)
+	float ClusterBbTop(GrSlotStream * /*psstrm*/)
 	{
 		return m_ysClusterBbTop;
 	}
-	float ClusterBbBottom(GrSlotStream * psstrm)
+	float ClusterBbBottom(GrSlotStream * /*psstrm*/)
 	{
 		return m_ysClusterBbBottom;
 	}
-	float ClusterBbWidth(GrSlotStream * psstrm)
+	float ClusterBbWidth(GrSlotStream * /*psstrm*/)
 	{
 		return m_xsClusterBbRight - m_xsClusterBbLeft + 1;
 	}
-	float ClusterBbHeight(GrSlotStream * psstrm)
+	float ClusterBbHeight(GrSlotStream * /*psstrm*/)
 	{
 		return m_ysClusterBbTop - m_ysClusterBbBottom + 1;
 	}
@@ -990,7 +994,8 @@
 	void InitMetrics(GrTableManager * ptman, GrSlotState * pslotRoot);
 	void InitLeafMetrics(GrTableManager * ptman, GrSlotState * pslotRoot);
 	void InitRootMetrics(GrTableManager * ptman);
-	void CalcRootMetrics(GrTableManager * ptman, GrSlotStream *, int nLevel);
+	void CalcRootMetrics(GrTableManager * ptman, GrSlotStream * psstrm,
+		GrSlotStream * psstrmNext, int nLevel);
 	void AttachToRoot(GrTableManager * ptman, GrSlotStream *, GrSlotState * pslotNewRoot);
 	void AttachLogUnits(GrTableManager * ptman,
 		GrSlotState * pslotRoot,
diff -ru ../silgraphite-2.3.1.orig/engine/src/segment/GrSlotStream.cpp ./engine/src/segment/GrSlotStream.cpp
--- ../silgraphite-2.3.1.orig/engine/src/segment/GrSlotStream.cpp	2012-02-27 21:39:57.000000000 -0500
+++ ./engine/src/segment/GrSlotStream.cpp	2012-02-27 21:40:30.000000000 -0500
@@ -189,12 +189,16 @@
 	stream position when the rule is being run.
 
 	@param dislot		- how far back to peek before the write position
-							when the rule started; a negative number
+							WHEN THE RULE STARTED; a negative number
 							(NOTE: the current write position is irrelevant)
 	@param fNullOkay	- true if it's okay to return NULL in the situation where we're asking
 							for something before the beginning of the stream
 ----------------------------------------------------------------------------------------------*/
+#ifdef NDEBUG
+GrSlotState * GrSlotStream::PeekBack(int dislot, bool /*fNullOkay*/)
+#else
 GrSlotState * GrSlotStream::PeekBack(int dislot, bool fNullOkay)
+#endif
 {
 	Assert(dislot < 0);
 	if (dislot < m_islotRuleStartWrite * -1)
@@ -1104,6 +1108,7 @@
 	case kdircRLO:
 	case kdircRLE:
 	case kdircPdfR:
+	case kdircRlb:
 		return true;
 
 	case kdircNeutral:
@@ -1212,7 +1217,7 @@
 			return true;
 
 		float xsWidth, xsVisWidth;
-		ptman->CalcPositionsUpTo(m_ipass, NULL, &xsWidth, &xsVisWidth);
+		ptman->CalcPositionsUpTo(m_ipass, NULL, false, &xsWidth, &xsVisWidth);
 
 		*pxsWidth = (fIgnoreTrailingWS || twsh == ktwshOnlyWs) ? xsVisWidth : xsWidth;
         return (*pxsWidth < xsSpaceAllotted);
@@ -1322,7 +1327,7 @@
 	@param islotMin			- first slot that is officially part of the segment (after initial LB)
 ----------------------------------------------------------------------------------------------*/
 int GrSlotStream::MakeSegmentBreak(GrTableManager * ptman,
-	int islotPrevBreak, bool fInsertedLB, int islotStartTry,
+	int /*islotPrevBreak*/, bool /*fInsertedLB*/, int islotStartTry,
 	LineBrk lb, TrWsHandling twsh, int islotMin,
 	LineBrk * plbNextToTry)
 {
@@ -1576,7 +1581,11 @@
 	Return the break weight of the given slot, which should be a line-break.
 	OBSOLETE??
 ----------------------------------------------------------------------------------------------*/
+#ifdef NDEBUG
+LineBrk GrSlotStream::BreakWeightAt(gid16 /*chwLB*/, int islot)
+#else
 LineBrk GrSlotStream::BreakWeightAt(gid16 chwLB, int islot)
+#endif
 {	
 	GrSlotState * pslot = GetSlotAt(islot);
 	Assert(pslot->IsLineBreak(chwLB));
@@ -1769,7 +1778,7 @@
 	@param fBackingUp		- this chunk results in the stream position moving backwards,
 								so clear anything we're backing over
 ----------------------------------------------------------------------------------------------*/
-void GrSlotStream::MapInputChunk(int islotInputMin, int islotOutputMin, int islotInputLim,
+void GrSlotStream::MapInputChunk(int islotInputMin, int islotOutputMin, int /*islotInputLim*/,
 	bool fSkipChunkStart, bool fBackingUp)
 {
 	Assert(AssertValid());
@@ -1828,7 +1837,7 @@
 	@param fBackingUp		- this chunk results in the stream position moving backwards,
 								so clear anything we're backing over
 ----------------------------------------------------------------------------------------------*/
-void GrSlotStream::MapOutputChunk(int islotOutputMin, int islotInputMin, int islotOutputLim,
+void GrSlotStream::MapOutputChunk(int islotOutputMin, int islotInputMin, int /*islotOutputLim*/,
 	bool fSkipChunkStart, int cslotReprocess, bool fBackingUp)
 {
 	Assert(AssertValid());
@@ -1863,7 +1872,11 @@
 	Ensure that the chunk maps for a pair of streams match properly. The recipient is
 	the input stream.
 ----------------------------------------------------------------------------------------------*/
+#ifdef _DEBUG
 void GrSlotStream::AssertChunkMapsValid(GrSlotStream * psstrmOut)
+#else
+void GrSlotStream::AssertChunkMapsValid(GrSlotStream * )
+#endif
 {
 #ifdef _DEBUG
 	GrSlotStream * psstrmIn = this;
@@ -1915,7 +1928,11 @@
 	Ensure that corresponding items in the streams of a positioning pass have matching
 	stream indices. The recipient is the output stream.
 ----------------------------------------------------------------------------------------------*/
+#ifdef _DEBUG
 void GrSlotStream::AssertStreamIndicesValid(GrSlotStream * psstrmIn)
+#else
+void GrSlotStream::AssertStreamIndicesValid(GrSlotStream * )
+#endif
 {
 #ifdef _DEBUG
 	if (!GotIndexOffset())
@@ -1939,7 +1956,11 @@
 	in the output stream. (Currently the compiler ensures this by making it an error
 	to write rules that don't do this.)
 ----------------------------------------------------------------------------------------------*/
+#ifdef _DEBUG
 void GrSlotStream::AssertAttachmentsInOutput(int islotMin, int islotLim)
+#else
+void GrSlotStream::AssertAttachmentsInOutput(int , int )
+#endif
 {
 #ifdef _DEBUG
 	for (int islot = islotMin; islot < islotLim; islot++)
@@ -2007,7 +2028,11 @@
 	Record the number of slots in the stream that are previous to the official start of the
 	segment.
 ----------------------------------------------------------------------------------------------*/
+#ifdef _DEBUG
 void GrSlotStream::CalcIndexOffset(GrTableManager * ptman)
+#else
+void GrSlotStream::CalcIndexOffset(GrTableManager * )
+#endif
 {
 	if (GotIndexOffset())
 		return; // already figured it
@@ -2203,6 +2228,21 @@
 }
 
 /*----------------------------------------------------------------------------------------------
+	In the middle of running a pass, return the given slot to use in processing.
+	Read it from the reprocess buffer if appropriate, or for slots previous to the current
+	position, read from the output stream (psstrmNext).
+
+	psstrmNext may be NULL when processing is complete, therefore we only have one stream to
+	deal with.
+----------------------------------------------------------------------------------------------*/
+GrSlotState * GrSlotStream::MidPassSlotAt(int islot, GrSlotStream * psstrmNext)
+{
+	int islotInput = islot - ReadPosForNextGet() + 1; // +1 because RuleInputSlot takes 0 to mean the previously read slot
+	GrSlotState * pslot = RuleInputSlot(islotInput, psstrmNext);
+	return pslot;
+}
+
+/*----------------------------------------------------------------------------------------------
 	Return the "current" input item from the rule's perspective, ie, the last slot read.
 	So dislotOffset = 0 means not the slot at the read position but one slot earlier.
 
@@ -2214,7 +2254,6 @@
 	@param fNullOkay	- true if it's okay to return NULL in the situation where we're asking
 							for something before the beginning of the stream
 ----------------------------------------------------------------------------------------------*/
-
 GrSlotState * GrSlotStream::RuleInputSlot(int dislotOffset, GrSlotStream * psstrmOutput,
 	bool fNullOkay)
 {
@@ -2244,8 +2283,10 @@
 
 			if (cslotOffsetBack >= cslotPostReproc + cslotValidReproc)
 			{
-				// Read from the output stream.
-				int dislotTmp = dislotOffset - 1 + cslotPostReproc + cslotValidReproc;
+				// Read from the output stream. (Remember that PeekBack works relative to
+				// the rule-start write position, not the current write position.)
+				int dislotTmp = dislotOffset - 1 + cslotPostReproc
+					+ cslotValidReproc - SlotsToReprocess();
 				Assert(dislotTmp < 0);
 				return psstrmOutput->PeekBack(dislotTmp);
 			}
@@ -2253,7 +2294,7 @@
 			{
 				if (m_islotReprocPos > -1)
 				{
-					//	Current read pos is inside reprocess buffer.
+					//	Current read pos could be inside reprocess buffer.
 					Assert(cslotPostReproc == 0);
 					int islotStartReadReprocBuf = m_vpslotReproc.size() - cslotValidReproc;
 					Assert(islotStartReadReprocBuf >= 0);
@@ -2342,9 +2383,10 @@
 			else if (pslotAfter)
 				pslot->Associate(pslotAfter);
 			else
+			{
 				// Weird, but can happen with an empty segment.
 				Warn("No assocations");
-
+			}
 //			Assert(pslot->m_vpslotAssoc.Size() > 0);
 			pslot->m_fNeutralAssocs = true;
 		}
diff -ru ../silgraphite-2.3.1.orig/engine/src/segment/GrSlotStream.h ./engine/src/segment/GrSlotStream.h
--- ../silgraphite-2.3.1.orig/engine/src/segment/GrSlotStream.h	2012-02-27 21:39:57.000000000 -0500
+++ ./engine/src/segment/GrSlotStream.h	2012-02-27 21:40:30.000000000 -0500
@@ -107,7 +107,7 @@
 		ReleaseSlots(0, m_vpslot.size());
 	}
 
-	void ReleaseSlots(int islotMin, int islotLim)
+	void ReleaseSlots(int /*islotMin*/, int /*islotLim*/)
 	{
 		//	A slot stream is responsible for deleting the slot states that it created,
 		//	that is, the ones whose modified tag equals this stream's pass index.
@@ -182,6 +182,7 @@
 		return Peek(islot - ReadPosForNextGet());
 	}
 
+	//	Return the functional read position, taking into account the reprocess buffer.
 	int ReadPosForNextGet()
 	{
 		return ReadPos() - SlotsToReprocess();
@@ -260,12 +261,16 @@
 
 	void MarkFullyWritten();
 
+#ifdef NDEBUG
+	void SetSegMin(int islot, bool /*fAdjusting*/ = false)
+#else
 	void SetSegMin(int islot, bool fAdjusting = false)
+#endif
 	{
 		Assert(fAdjusting || m_islotSegMin == -1 || m_islotSegMin == islot);
 		m_islotSegMin = islot;
 	}
-	void SetSegMinToWritePos(bool fMod = true)
+	void SetSegMinToWritePos(bool /*fMod*/ = true)
 	{
 		if (m_islotSegMin == -1)
 			m_islotSegMin = m_islotWritePos;
@@ -456,6 +461,7 @@
 		}
 	}
 
+	GrSlotState * MidPassSlotAt(int islot, GrSlotStream * psstrmNext = NULL);
 	GrSlotState * RuleInputSlot(int dislot = 0, GrSlotStream * psstrmOut = NULL,
 		bool fNullOkay = false);
 	GrSlotState * RuleOutputSlot(int dislot = 0);
diff -ru ../silgraphite-2.3.1.orig/engine/src/segment/GrTableManager.cpp ./engine/src/segment/GrTableManager.cpp
--- ../silgraphite-2.3.1.orig/engine/src/segment/GrTableManager.cpp	2012-02-27 21:39:57.000000000 -0500
+++ ./engine/src/segment/GrTableManager.cpp	2012-02-27 21:40:30.000000000 -0500
@@ -25,8 +25,8 @@
 DEFINE_THIS_FILE
 #ifndef _WIN32
 #include <stdlib.h>
-#include <math.h>
 #endif
+#include <math.h>
 
 //:>********************************************************************************************
 //:>	Forward declarations
@@ -572,7 +572,7 @@
 		else
 		{
 			Assert(!m_engst.m_fInsertedLB);
-			Assert(islotUnderBreak == -1 || m_engst.m_fFinalLB);
+			//Assert(islotUnderBreak == -1 || m_engst.m_fFinalLB); -- no, ExtendGlyphIDOutput clearly sets islotUnderBreak regardless
 		}
 		int islotTmp = OutputStream(m_cpass - 1)->WritePos();
 		GrSlotState * pslotTmp;
@@ -931,7 +931,7 @@
 	@param plbFound			- kind of line-break created
 ----------------------------------------------------------------------------------------------*/
 bool GrTableManager::Backtrack(int * pislotPrevBreak,
-	LineBrk * plbMin, LineBrk lbMax, TrWsHandling twsh, bool fMoreText,
+	LineBrk * plbMin, LineBrk lbMax, TrWsHandling twsh, bool /*fMoreText*/,
 	int ichwCallerBtLim, bool fEndLine,
 	LineBrk * plbFound)
 {
@@ -1343,7 +1343,7 @@
 	Calculate the associations, and record the output slots in the segment.
 ----------------------------------------------------------------------------------------------*/
 void GrTableManager::RecordAssocsAndOutput(Font * pfont,
-	Segment * pseg, bool fWidthIsCharCount,
+	Segment * pseg, bool /*fWidthIsCharCount*/,
 	TrWsHandling twsh, bool fParaRtl, int nDirDepth)
 {
 	int cchwUnderlying = pseg->stopCharacter() - pseg->startCharacter();
@@ -1362,7 +1362,7 @@
 #endif // OLD_TEST_STUFF
 
 	//	Make sure the final positions are set for every glyph.
-	CalcPositionsUpTo(m_cpass-1, reinterpret_cast<GrSlotState *>(NULL),
+	CalcPositionsUpTo(m_cpass-1, reinterpret_cast<GrSlotState *>(NULL), false,
 		&xsTotalWidth, &xsVisWidth); 
 	pseg->SetWidths(xsVisWidth, xsTotalWidth);
 
@@ -1377,7 +1377,7 @@
 	Calculate the underlying-to-surface associations and ligature mappings.
 	Assumes the arrays have been properly initialized.
 ----------------------------------------------------------------------------------------------*/
-void GrTableManager::CalculateAssociations(Segment * pseg, int csloutSurface)
+void GrTableManager::CalculateAssociations(Segment * pseg, int /*csloutSurface*/)
 {
 	GrSlotStream * psstrmFinal = OutputStream(m_cpass-1);
 
@@ -2350,18 +2350,20 @@
 								final pass, but it could be another if positions are
 								requested by the rules themselves
 	@param pslotLast		- last slot that needs to be positioned, or NULL
+	@param fMidPass			- calculating the position of some slot in the middle of the pass
 	@param pxsWidth			- return the total width used so far
 	@param psxVisibleWidth	- return the visible width so far
 
 	MOVE to EngineState
 ----------------------------------------------------------------------------------------------*/
-void GrTableManager::CalcPositionsUpTo(int ipass, GrSlotState * pslotLast,
+void GrTableManager::CalcPositionsUpTo(int ipass, GrSlotState * pslotLast, bool fMidPass,
 	float * pxsWidth, float * pxsVisibleWidth)
 {
 	Assert(ipass >= m_ipassPos1 - 1);
 
 	int isstrm = ipass;
 	GrSlotStream * psstrm = OutputStream(isstrm);
+	GrSlotStream * psstrmNext = (isstrm >= m_cpass - 1) ? NULL : OutputStream(isstrm + 1);
 	Assert(psstrm->GotIndexOffset());
 	if (psstrm->WritePos() <= psstrm->IndexOffset())
 	{
@@ -2399,7 +2401,9 @@
 	//	to be later in the stream than the last actual slot passed in.
 	if (!psstrm->HasSlotAtPosPassIndex(pslotLast->AttachRootPosPassIndex()))
 		return;
-	GrSlotState * pslotLastBase = pslotLast->Base(psstrm);
+	GrSlotState * pslotLastBase = (fMidPass && pslotLast->PosPassIndex() < psstrm->WritePos())
+		? pslotLast->Base(psstrmNext)
+		: pslotLast->Base(psstrm);
 
 	if (ipass == m_cpass - 1 && m_engst.m_islotPosNext > -1)
 	{
@@ -2428,6 +2432,7 @@
 	}
 
 	std::vector<GrSlotState *> vpslotAttached;
+	std::vector<GrSlotStream *> vpsstrmAttached;
 
 	bool fRtl = RightToLeft();
 
@@ -2435,13 +2440,24 @@
 	{
 		Assert(islot < psstrm->SlotsPresent());
 
-		pslot = (isstrm == ipass) ?	psstrm->SlotAt(islot) :	psstrm->OutputSlotAt(islot);
+		GrSlotStream * psstrmThis = psstrm;
+		if (fMidPass && islot < psstrm->WritePos())
+		{
+			pslot = psstrm->MidPassSlotAt(islot, psstrmNext);
+			psstrmThis = psstrmNext;
+		}
+		else
+		{
+			//pslot = (isstrm == ipass) ?	psstrm->SlotAt(islot) :	psstrm->OutputSlotAt(islot);
+			pslot = psstrm->SlotAt(islot);
+		}
 
 		if (!pslot->IsBase())
 		{
 			//	This slot is attached to another; it will be positioned strictly
 			//	relative to that one. This happens in the loop below.
 			vpslotAttached.push_back(pslot);
+			vpsstrmAttached.push_back(psstrmThis);
 		}
 		else
 		{
@@ -2455,7 +2471,7 @@
 			}
 
 			//	Make sure the metrics are the complete ones.
-			pslot->CalcCompositeMetrics(this, psstrm, kPosInfinity, true);
+			pslot->CalcCompositeMetrics(this, psstrm, psstrmNext, kPosInfinity, true);
 
 			float xsInc = pslot->GlyphXOffset(psstrm, fakeItalicRatio);
 			float ysInc = pslot->GlyphYOffset(psstrm);
@@ -2514,8 +2530,9 @@
 
 	for (size_t ipslot = 0; ipslot < vpslotAttached.size(); ipslot++)
 	{
-		GrSlotState * pslot = vpslotAttached[ipslot];
-		GrSlotState * pslotBase = pslot->Base(psstrm);
+		GrSlotState * pslotAtt = vpslotAttached[ipslot];
+		GrSlotStream * psstrmAtt = vpsstrmAttached[ipslot];
+		GrSlotState * pslotBase = pslotAtt->Base(psstrmAtt);
 		if (pslotBase->XPosition() == kNegInfinity || pslotBase->YPosition() == kNegInfinity)
 		{
 			Assert(false);
@@ -2523,10 +2540,10 @@
 		}
 		float xsCluster = pslotBase->XPosition() - pslotBase->GlyphXOffset(psstrm, fakeItalicRatio);
 		float ysCluster = pslotBase->YPosition() - pslotBase->GlyphYOffset(psstrm);
-		float xsInc = pslot->GlyphXOffset(psstrm, fakeItalicRatio);
-		float ysInc = pslot->GlyphYOffset(psstrm);
-		pslot->SetXPos(xsCluster + xsInc);
-		pslot->SetYPos(ysCluster + ysInc);
+		float xsInc = pslotAtt->GlyphXOffset(psstrm, fakeItalicRatio);
+		float ysInc = pslotAtt->GlyphYOffset(psstrm);
+		pslotAtt->SetXPos(xsCluster + xsInc);
+		pslotAtt->SetYPos(ysCluster + ysInc);
 
 		//	My theory is that we don't need to adjust *pxsWidth here, because the width of
 		//	any non-base slots should be factored into the advance width of their cluster
diff -ru ../silgraphite-2.3.1.orig/engine/src/segment/GrTableManager.h ./engine/src/segment/GrTableManager.h
--- ../silgraphite-2.3.1.orig/engine/src/segment/GrTableManager.h	2012-02-27 21:39:57.000000000 -0500
+++ ./engine/src/segment/GrTableManager.h	2012-02-27 21:40:30.000000000 -0500
@@ -442,7 +442,7 @@
 	int LogToEmUnits(float xys);
 	bool GPointToXY(gid16 chwGlyphID, int nGPoint, float * xs, float * ys);
 
-	void CalcPositionsUpTo(int ipass, GrSlotState * pslotLast,
+	void CalcPositionsUpTo(int ipass, GrSlotState * pslotLast, bool fMidPass,
 		float * pxsWidth, float * pxsVisibleWidth);
 
 	void InitPosCache()
diff -ru ../silgraphite-2.3.1.orig/engine/src/segment/MemoryUsage.cpp ./engine/src/segment/MemoryUsage.cpp
--- ../silgraphite-2.3.1.orig/engine/src/segment/MemoryUsage.cpp	2012-02-27 21:39:57.000000000 -0500
+++ ./engine/src/segment/MemoryUsage.cpp	2012-02-27 21:40:30.000000000 -0500
@@ -11,10 +11,10 @@
 Description:
     Calculates memory usage for the engine and segments.
 ----------------------------------------------------------------------------------------------*/
-
+#ifdef _MSC_VER
 #pragma warning(disable: 4244)	// conversion from wchar_t to char
 #pragma warning(disable: 4702)	// unreachable code
-
+#endif
 //:>********************************************************************************************
 //:>	Include files
 //:>********************************************************************************************
@@ -54,8 +54,6 @@
 #ifdef _MSC_VER
 #pragma hdrstop
 #endif
-#undef THIS_FILE
-DEFINE_THIS_FILE
 
 //:End Ignore
 
diff -ru ../silgraphite-2.3.1.orig/engine/src/segment/Platform.cpp ./engine/src/segment/Platform.cpp
--- ../silgraphite-2.3.1.orig/engine/src/segment/Platform.cpp	2012-02-27 21:39:57.000000000 -0500
+++ ./engine/src/segment/Platform.cpp	2012-02-27 21:40:30.000000000 -0500
@@ -103,7 +103,7 @@
 {
 	// assumes NULL terminated strings
 	const utf16 *start = s;
-	for (; *s; ++s);
+	for (; *s; ++s) {};
 	
 	return s - start;
 }
diff -ru ../silgraphite-2.3.1.orig/engine/src/segment/Segment.cpp ./engine/src/segment/Segment.cpp
--- ../silgraphite-2.3.1.orig/engine/src/segment/Segment.cpp	2012-02-27 21:39:57.000000000 -0500
+++ ./engine/src/segment/Segment.cpp	2012-02-27 21:40:30.000000000 -0500
@@ -246,6 +246,8 @@
 
 	m_dxsVisibleWidth = -1;
 	m_dxsTotalWidth = -1;
+	m_ichwAssocsMin = 0;
+	m_ichwAssocsLim = 0;
 
 //	m_psstrm = NULL;
 	m_prgslout = NULL;
@@ -1178,7 +1180,7 @@
 	part of the segment.
 ----------------------------------------------------------------------------------------------*/
 float Segment::getRangeWidth(int ichMin, int ichLim,
-	bool fStartLine, bool fEndLine, bool fSkipSpace)
+	bool /*fStartLine*/, bool /*fEndLine*/, bool fSkipSpace)
 {
 	if (m_dxsWidth < 0)
 	{
@@ -1549,7 +1551,11 @@
 void Segment::SetUpOutputArrays(Font * pfont, GrTableManager * ptman,
 	GrSlotStream * psstrmFinal,
 	int cchwInThisSeg, int csloutSurface, gid16 chwLB,
+#ifdef NDEBUG
+	TrWsHandling twsh, bool fParaRtl, int nDirDepth, bool /*fEmpty*/)
+#else
 	TrWsHandling twsh, bool fParaRtl, int nDirDepth, bool fEmpty)
+#endif
 {
 	m_mFontEmUnits = EngineImpl()->GetFontEmUnits();
 
@@ -1725,7 +1731,7 @@
 	Set up the data structures that represent the actual rendered glyphs for the new segment.
 ----------------------------------------------------------------------------------------------*/
 void Segment::SetUpGlyphInfo(GrTableManager * ptman, GrSlotStream * psstrmFinal,
-	gid16 chwLB, int nDirDepth, int islotMin, int cslot)
+	gid16 chwLB, int /*nDirDepth*/, int islotMin, int cslot)
 {
 	//int paraDirLevel = (ptman->State()->ParaRightToLeft()) ? 1 : 0;
 
@@ -1751,7 +1757,7 @@
 
 	m_isloutGinf0 = -1;
 	int iginf = 0;
-	for (int islot = islotMin; islot < cslot; islot++)
+	for (islot = islotMin; islot < cslot; islot++)
 	{
 		GrSlotState * pslot = psstrmFinal->SlotAt(islot);
 
@@ -2160,7 +2166,7 @@
 	@param ichwUnder		- character index relative to the official beginning of the segment
 	@param islot			- processed glyph it maps to
 ----------------------------------------------------------------------------------------------*/
-void Segment::MarkSlotInPrevSeg(int ichwUnder, int islot)
+void Segment::MarkSlotInPrevSeg(int ichwUnder, int /*islot*/)
 {
 	if (ichwUnder >= m_ichwAssocsMin)
 		m_prgisloutBefore[ichwUnder - m_ichwAssocsMin] = kNegInfinity;
@@ -2174,7 +2180,7 @@
 	@param ichwUnder		- character index relative to the official beginning of the segment
 	@param islot			- processed glyph it maps to
 ----------------------------------------------------------------------------------------------*/
-void Segment::MarkSlotInNextSeg(int ichwUnder, int islot)
+void Segment::MarkSlotInNextSeg(int ichwUnder, int /*islot*/)
 {
 	if (ichwUnder < m_ichwAssocsLim)
 		m_prgisloutAfter[ichwUnder - m_ichwAssocsMin] = kPosInfinity;
@@ -2351,7 +2357,7 @@
 	@param pfAfter			- return true if they clicked on trailing side; possibly NULL
 ----------------------------------------------------------------------------------------------*/
 int Segment::LogicalSurfaceToUnderlying(int islout, float xsOffset, float ysClick,
-	float dxsGlyphWidth, float dysGlyphHeight, bool * pfAfter)
+	float dxsGlyphWidth, float /*dysGlyphHeight*/, bool * pfAfter)
 {
 	Assert(islout >= 0);
 	Assert(islout < m_cslout);
@@ -2529,31 +2535,31 @@
 	else if (fBefore)
 	{
 		int isloutRet;
-		int ichw = ichwSegOffset;
+		int ichwTemp = ichwSegOffset;
 		//	If no association has been made, loop forward to the next slot
 		//	we are before. As a last resort, answer kPosInfinity, meaning we
 		//	aren't before anything.
 		do
 		{
-			isloutRet = m_prgisloutBefore[ichw - m_ichwAssocsMin];
-			do { ++ichw; }
-			while (!GrCharStream::AtUnicodeCharBoundary(m_pgts, ichw));
-		} while (isloutRet == kPosInfinity && ichw < m_ichwAssocsLim);
+			isloutRet = m_prgisloutBefore[ichwTemp - m_ichwAssocsMin];
+			do { ++ichwTemp; }
+			while (!GrCharStream::AtUnicodeCharBoundary(m_pgts, ichwTemp));
+		} while (isloutRet == kPosInfinity && ichwTemp < m_ichwAssocsLim);
 		return isloutRet;
 	}
 	else
 	{
 		int isloutRet;
-		int ichw = ichwSegOffset;
+		int ichwTemp = ichwSegOffset;
 		//	If no association has been made, loop backward to the previous slot
 		//	we are after. As a last resort, answer kNegInfinity, meaning we
 		//	aren't after anything.
 		do
 		{
-			isloutRet = m_prgisloutAfter[ichw - m_ichwAssocsMin];
-			do { --ichw; }
-			while (!GrCharStream::AtUnicodeCharBoundary(m_pgts, ichw));
-		} while (isloutRet == kNegInfinity && ichw >= 0);
+			isloutRet = m_prgisloutAfter[ichwTemp - m_ichwAssocsMin];
+			do { --ichwTemp; }
+			while (!GrCharStream::AtUnicodeCharBoundary(m_pgts, ichwTemp));
+		} while (isloutRet == kNegInfinity && ichwTemp >= 0);
 		return isloutRet;
 	}
 	Assert(false); // should never reach here
@@ -2748,7 +2754,11 @@
 	that root glyph as one of its roots.
 	OBSOLETE
 ----------------------------------------------------------------------------------------------*/
+#ifdef _DEBUG
 void Segment::AssertValidClusters(GrSlotStream * psstrm)
+#else
+void Segment::AssertValidClusters(GrSlotStream * /*psstrm*/)
+#endif
 {
 #ifdef _DEBUG
 	for (int islot = 0; islot < psstrm->WritePos(); islot++)
@@ -2980,9 +2990,10 @@
 	return kresOk;
 }
 
-
+#ifdef __GNUC__
 // suppress GCC 4.3 warning for optimized min()/max() when called with (ich, ich+1) or similar
 #pragma GCC diagnostic ignored "-Wstrict-overflow"
+#endif
 
 /*----------------------------------------------------------------------------------------------
 	Merge the given characters into the same Uniscribe cluster. This means merging any
diff -ru ../silgraphite-2.3.1.orig/engine/src/segment/TransductionLog.cpp ./engine/src/segment/TransductionLog.cpp
--- ../silgraphite-2.3.1.orig/engine/src/segment/TransductionLog.cpp	2012-02-27 21:39:57.000000000 -0500
+++ ./engine/src/segment/TransductionLog.cpp	2012-02-27 21:40:30.000000000 -0500
@@ -175,7 +175,7 @@
 	Output a file showing a log of the transduction process and the resulting segment.
 ----------------------------------------------------------------------------------------------*/
 void GrTableManager::WriteXductnLog(std::ostream & strmOut,
-	GrCharStream * pchstrm, Segment * psegRet,
+	GrCharStream * pchstrm, Segment * /*psegRet*/,
 	int cbPrevSegDat, byte * pbPrevSegDat)
 {
 	if (cbPrevSegDat == 0)
@@ -416,8 +416,8 @@
 	the raw (UTF-16 or UTF-8) chars for display. To do this we get the raw characters
 	directly from the text source.
 ----------------------------------------------------------------------------------------------*/
-void GrCharStream::GetLogDataRaw(GrTableManager * ptman, int cchl, int cchrBackup,
-	int cchrMaxRaw, int * prgchl,
+void GrCharStream::GetLogDataRaw(GrTableManager * /*ptman*/, int cchl, int cchrBackup,
+	int /*cchrMaxRaw*/, int * prgchl,
 	utf16 * prgchw2, utf16 * prgchw3, utf16 * prgchw4, utf16 * prgchw5, utf16 * prgchw6, 
 	int * prgcchr)
 {
@@ -441,7 +441,7 @@
 	case kutf8:
 		prgchsRunText8 = new utf8[cchrRange];
 		m_pgts->fetch(ichrMin, cchrRange, prgchsRunText8);
-		for (int ichr = 0; ichr < cchrRange; ichr++)
+		for (ichr = 0; ichr < cchrRange; ichr++)
 			prgchwRunText[ichr] = (utf16)prgchsRunText8[ichr];	// zero-extend into UTF-16 buffer
 		break;
 	case kutf16:
@@ -634,7 +634,7 @@
 	m_pzpst->LogRulesFiredAndFailed(strmOut, psstrmIn);
 }
 
-void PassState::LogRulesFiredAndFailed(std::ostream & strmOut, GrSlotStream * psstrmIn)
+void PassState::LogRulesFiredAndFailed(std::ostream & strmOut, GrSlotStream * /*psstrmIn*/)
 {
 
 	strmOut << "PASS " << m_ipass << "\n\n" << "Rules matched: ";
@@ -1193,7 +1193,7 @@
 	if (fAnyPseudos)
 	{
 		strmOut << "Actual glyphs: ";
-		for (int islout = 0; islout < m_cslout; islout++)
+		for (islout = 0; islout < m_cslout; islout++)
 		{
 			GrSlotOutput * psloutTmp = m_prgslout + islout;
 			if (psloutTmp->GlyphID() != psloutTmp->ActualGlyphForOutput(ptman))
@@ -1319,7 +1319,7 @@
 	Write out the header lines for the slot contents.
 ----------------------------------------------------------------------------------------------*/
 void GrTableManager::LogSlotHeader(std::ostream & strmOut, int islotLim,
-	int cspPerSlot, int cspLeading, int islotMin)
+	int /*cspPerSlot*/, int cspLeading, int islotMin)
 {
 	islotLim = min(islotLim, MAX_SLOTS);
 
@@ -1721,7 +1721,7 @@
 
 	case kslatAttAtX:	// always do these in pairs
 	case kslatAttAtY:
-		if (m_mAttachAtX != (pslotPrev ? pslotPrev->m_mAttachAtX : kNotYetSet) ||
+		if (m_mAttachAtX != (pslotPrev ? pslotPrev->m_mAttachAtX : static_cast<short>(kNotYetSet)) ||
 			m_mAttachAtY != (pslotPrev ? pslotPrev->m_mAttachAtY : 0))
 		{
 			ptman->LogInTable(strmOut,
@@ -1730,7 +1730,7 @@
 		}
 		break;
 	case kslatAttAtGpt:
-		if (m_nAttachAtGpoint != (pslotPrev ? pslotPrev->m_nAttachAtGpoint : kNotYetSet))
+		if (m_nAttachAtGpoint != (pslotPrev ? pslotPrev->m_nAttachAtGpoint : static_cast<short>(kNotYetSet)))
 		{
 			ptman->LogInTable(strmOut,
 				((m_nAttachAtGpoint == kGpointZero) ? 0 : m_nAttachAtGpoint));
@@ -1750,7 +1750,7 @@
 
 	case kslatAttWithX:	// always do these in pairs
 	case kslatAttWithY:
-		if (m_mAttachWithX != (pslotPrev ? pslotPrev->m_mAttachWithX : kNotYetSet) ||
+		if (m_mAttachWithX != (pslotPrev ? pslotPrev->m_mAttachWithX : static_cast<short>(kNotYetSet)) ||
 			m_mAttachWithY != (pslotPrev ? pslotPrev->m_mAttachWithY : 0))
 		{
 			ptman->LogInTable(strmOut,
@@ -1759,7 +1759,7 @@
 		}
 		break;
 	case kslatAttWithGpt:
-		if (m_nAttachWithGpoint != (pslotPrev ? pslotPrev->m_nAttachWithGpoint : kNotYetSet))
+		if (m_nAttachWithGpoint != (pslotPrev ? pslotPrev->m_nAttachWithGpoint : static_cast<short>(kNotYetSet)))
 		{
 			ptman->LogInTable(strmOut,
 				((m_nAttachWithGpoint == kGpointZero) ? 0 : m_nAttachWithGpoint));
@@ -1786,14 +1786,14 @@
 		break;
 
 	case kslatBreak:
-		if (m_lb != (pslotPrev ? pslotPrev->m_lb : kNotYetSet8))
+		if (m_lb != (pslotPrev ? pslotPrev->m_lb : static_cast<sdata8>(kNotYetSet8)))
 		{
 			ptman->LogBreakWeightInTable(strmOut, m_lb);
 			return;
 		}
 		break;
 	case kslatDir:
-		if (m_dirc != (pslotPrev ? pslotPrev->m_dirc : kNotYetSet8))
+		if (m_dirc != (pslotPrev ? pslotPrev->m_dirc : static_cast<sdata8>(kNotYetSet8)))
 		{
 			ptman->LogDirCodeInTable(strmOut, m_dirc);
 			return;
diff -ru ../silgraphite-2.3.1.orig/engine/test/ProfileHarness/GrUtfTextSrc.cpp ./engine/test/ProfileHarness/GrUtfTextSrc.cpp
--- ../silgraphite-2.3.1.orig/engine/test/ProfileHarness/GrUtfTextSrc.cpp	2012-02-27 21:39:56.000000000 -0500
+++ ./engine/test/ProfileHarness/GrUtfTextSrc.cpp	2012-02-27 21:40:30.000000000 -0500
@@ -210,12 +210,12 @@
 }
 
 
-bool GrUtfTextSrc::getRightToLeft(gr::toffset ich)
+bool GrUtfTextSrc::getRightToLeft(gr::toffset /*ich*/)
 {
 	return mRtl; // assumes src only contains one direction
 }
 
-unsigned int GrUtfTextSrc::getDirectionDepth(gr::toffset ich)
+unsigned int GrUtfTextSrc::getDirectionDepth(gr::toffset /*ich*/)
 {
 	return (mRtl) ? 1 : 0; // TBD
 }
@@ -254,7 +254,7 @@
 	return range;
 }
 	
-size_t GrUtfTextSrc::getFontFeatures(gr::toffset ich, gr::FeatureSetting * prgfset)
+size_t GrUtfTextSrc::getFontFeatures(gr::toffset /*ich*/, gr::FeatureSetting * /*prgfset*/)
 {
 	return 0;
 }
@@ -277,14 +277,14 @@
 
 // these should be called I hope
 float
-GrUtfTextSrc::getFontSize(gr::toffset ich)
+GrUtfTextSrc::getFontSize(gr::toffset /*ich*/)
 {
 	assert(mFont);
 	return mPointSize;
 }
 
 bool
-GrUtfTextSrc::getBold(gr::toffset ich)
+GrUtfTextSrc::getBold(gr::toffset /*ich*/)
 {
 	assert(mFont);
 //	NS_ASSERTION(false, "unexpected call to getBold");
@@ -293,7 +293,7 @@
 }
 
 bool
-GrUtfTextSrc::getItalic(gr::toffset ich)
+GrUtfTextSrc::getItalic(gr::toffset /*ich*/)
 {
 	assert(mFont);
 	//NS_ASSERTION(false, "unexpected call to getItalic");
@@ -301,7 +301,7 @@
 	return mFont->italic();
 }
 
-gr::isocode GrUtfTextSrc::getLanguage(gr::toffset ich)
+gr::isocode GrUtfTextSrc::getLanguage(gr::toffset /*ich*/)
 {
   gr::isocode unknown;
   std::fill_n(unknown.rgch, 4, '\0');
diff -ru ../silgraphite-2.3.1.orig/engine/test/ProfileHarness/GrUtfTextSrc.h ./engine/test/ProfileHarness/GrUtfTextSrc.h
--- ../silgraphite-2.3.1.orig/engine/test/ProfileHarness/GrUtfTextSrc.h	2012-02-27 21:39:56.000000000 -0500
+++ ./engine/test/ProfileHarness/GrUtfTextSrc.h	2012-02-27 21:40:30.000000000 -0500
@@ -79,7 +79,7 @@
   virtual size_t fetch(gr::toffset ichMin, size_t cch, gr::utf32 * prgchBuffer);
   virtual size_t fetch(gr::toffset ichMin, size_t cch, gr::utf16 * prgchwBuffer);
   virtual size_t fetch(gr::toffset ichMin, size_t cch, gr::utf8  * prgchsBuffer);
-  virtual gr::GrResult getFaceName(int ich, unsigned int cchMax,
+  virtual gr::GrResult getFaceName(int /*ich*/, unsigned int /*cchMax*/,
     gr::utf16 * prgchFaceName, unsigned int * pcchLen) 
   {
     prgchFaceName[0] = 0;
@@ -92,12 +92,12 @@
   virtual bool getItalic(gr::toffset ich);
   virtual bool getRightToLeft(gr::toffset ich);
   virtual unsigned int getDirectionDepth(gr::toffset ich);
-  virtual float getVerticalOffset(gr::toffset ich) { return 0;};
+  virtual float getVerticalOffset(gr::toffset /*ich*/) { return 0;};
   virtual gr::isocode getLanguage(gr::toffset ich);
 
   virtual std::pair<gr::toffset, gr::toffset> propertyRange(gr::toffset ich);
   virtual size_t getFontFeatures(gr::toffset ich, gr::FeatureSetting * prgfset);
-  virtual bool sameSegment(gr::toffset ich1, gr::toffset ich2) { return true; };
+  virtual bool sameSegment(gr::toffset /*ich1*/, gr::toffset /*ich2*/) { return true; };
 
 protected:
   bool checkBuffer8();
@@ -129,11 +129,11 @@
   virtual void getColors(gr::toffset ich, int * pclrFore, int * pclrBack);
 
   // Shouldn't be here!  
-  virtual gr::GrResult Fetch(int ichMin, int ichLim, gr::utf16 * prgchBuf) { return gr::kresNotImpl; };
-  virtual gr::GrResult get_Length(int * pcch) { return gr::kresNotImpl; };
-  virtual gr::GrResult GetFontVariations(int ich,
-    wchar_t * prgchFontVar, int ichMax, int * pich,
-    int * pichMin, int * pichLim) { return gr::kresNotImpl; };
+  virtual gr::GrResult Fetch(int /*ichMin*/, int /*ichLim*/, gr::utf16 * /*prgchBuf*/) { return gr::kresNotImpl; };
+  virtual gr::GrResult get_Length(int * /*pcch*/) { return gr::kresNotImpl; };
+  virtual gr::GrResult GetFontVariations(int /*ich*/,
+    wchar_t * /*prgchFontVar*/, int /*ichMax*/, int * /*pich*/,
+    int * /*pichMin*/, int * /*pichLim*/) { return gr::kresNotImpl; };
 
 };
 
diff -ru ../silgraphite-2.3.1.orig/engine/test/ProfileHarness/ProfileHarness.cpp ./engine/test/ProfileHarness/ProfileHarness.cpp
--- ../silgraphite-2.3.1.orig/engine/test/ProfileHarness/ProfileHarness.cpp	2012-02-27 21:39:56.000000000 -0500
+++ ./engine/test/ProfileHarness/ProfileHarness.cpp	2012-02-27 21:40:30.000000000 -0500
@@ -39,14 +39,14 @@
 typedef std::pair< gr::GlyphIterator, gr::GlyphIterator > GlyphRange;
 
 #ifndef HAVE_STRTOF
-float strtof(char * text, char ** ignore)
+float strtof(char * text, char ** /*ignore*/)
 {
   return static_cast<float>(atof(text));
 }
 #endif
 
 #ifndef HAVE_STRTOL
-long strtol(char * text, char ** ignore)
+long strtol(char * text, char ** /*ignore*/)
 {
   return atol(text);
 }
diff -ru ../silgraphite-2.3.1.orig/engine/test/RegressionTest/GrJustifier.cpp ./engine/test/RegressionTest/GrJustifier.cpp
--- ../silgraphite-2.3.1.orig/engine/test/RegressionTest/GrJustifier.cpp	2012-02-27 21:39:56.000000000 -0500
+++ ./engine/test/RegressionTest/GrJustifier.cpp	2012-02-27 21:40:30.000000000 -0500
@@ -16,8 +16,9 @@
 //:>	Include files
 //:>********************************************************************************************
 //#include "main.h" // This is used by clients, so main.h is not available
-
+#ifdef _MSC_VER
 #pragma hdrstop
+#endif
 // any other headers (not precompiled)
 #include "GrClient.h"
 #include "ITextSource.h"
@@ -31,9 +32,6 @@
 #include <string>
 #endif
 
-#undef THIS_FILE
-DEFINE_THIS_FILE
-
 //:>********************************************************************************************
 //:>	Global constants
 //:>********************************************************************************************
@@ -327,9 +325,9 @@
 					&dxStretchAchieved);
 				for (int iiiGlyph = 0; iiiGlyph < cStretchable; iiiGlyph++)
 				{
-					int iiGlyph = viiGlyphsRem[iiiGlyph];
-					vdxStretchLeft[iiGlyph] = vdxStretchRem[iiiGlyph];
-					vdxWidth[iiGlyph] = vdxWidthRem[iiiGlyph];
+					int ivGlyph = viiGlyphsRem[iiiGlyph];
+					vdxStretchLeft[ivGlyph] = vdxStretchRem[iiiGlyph];
+					vdxWidth[ivGlyph] = vdxWidthRem[iiiGlyph];
 				}
 			}
 			else
@@ -366,12 +364,12 @@
 	{
 #ifdef WIN32
 		wchar_t rgchw[20];
-		std::fill_n(rgchw, 20, 0);
+		std::fill_n(rgchw, 20, L'\0');
 		_itow(dxStretchNeeded - dxStretchAchieved, rgchw, 10);
 		std::wstring strTmp(L"justification failed by ");
 		strTmp += rgchw;
 		strTmp += L" units (width needed = ";
-		std::fill_n(rgchw, 10, 0);
+		std::fill_n(rgchw, 10, L'\0');
 		_itow(dxDesiredWidth, rgchw, 10);
 		strTmp += rgchw;
 		strTmp += L")\n";
diff -ru ../silgraphite-2.3.1.orig/engine/test/RegressionTest/GrJustifier.h ./engine/test/RegressionTest/GrJustifier.h
--- ../silgraphite-2.3.1.orig/engine/test/RegressionTest/GrJustifier.h	2012-02-27 21:39:57.000000000 -0500
+++ ./engine/test/RegressionTest/GrJustifier.h	2012-02-27 21:40:30.000000000 -0500
@@ -11,7 +11,9 @@
 Description:
 	A default justification agent for Graphite.
 -------------------------------------------------------------------------------*//*:End Ignore*/
+#ifdef _MSC_VER
 #pragma once
+#endif
 #ifndef GRJUSTIFIER_INCLUDED
 #define GRJUSTIFIER_INCLUDED
 
diff -ru ../silgraphite-2.3.1.orig/engine/test/RegressionTest/RegressionTest.cpp ./engine/test/RegressionTest/RegressionTest.cpp
--- ../silgraphite-2.3.1.orig/engine/test/RegressionTest/RegressionTest.cpp	2012-02-27 21:39:57.000000000 -0500
+++ ./engine/test/RegressionTest/RegressionTest.cpp	2012-02-27 21:40:30.000000000 -0500
@@ -675,7 +675,7 @@
 	OutputErrorAux(ptcase, strErr, i, true, valueFound, valueExpected);
 }
 
-void OutputErrorAux(TestCase * ptcase, std::string strErr, int i,
+void OutputErrorAux(TestCase * /*ptcase*/, std::string strErr, int i,
 	bool showValues, int valueFound, int valueExpected)
 {
 //	if (g_debugMode)
Only in ./engine/test/RegressionTest: RtTextSrc.h.orig
Only in ./engine/test/RegressionTest: RtTextSrc.h.rej
diff -ru ../silgraphite-2.3.1.orig/engine/test/RegressionTest/SimpleTextSrc.cpp ./engine/test/RegressionTest/SimpleTextSrc.cpp
--- ../silgraphite-2.3.1.orig/engine/test/RegressionTest/SimpleTextSrc.cpp	2012-02-27 21:39:56.000000000 -0500
+++ ./engine/test/RegressionTest/SimpleTextSrc.cpp	2012-02-27 21:40:30.000000000 -0500
@@ -15,7 +15,9 @@
 //:>********************************************************************************************
 //:>	Include files
 //:>********************************************************************************************
+#ifdef _MSC_VER
 #pragma hdrstop
+#endif
 // any other headers (not precompiled)
 
 #include "GrClient.h"
@@ -23,9 +25,6 @@
 #include "ITextSource.h"
 #include "SimpleTextSrc.h"
 
-#undef THIS_FILE
-DEFINE_THIS_FILE
-
 //:>********************************************************************************************
 //:>	Initialization and destruction
 //:>********************************************************************************************
@@ -70,7 +69,7 @@
 /*----------------------------------------------------------------------------------------------
 	Return true if the text uses a right-to-left writing system.
 ----------------------------------------------------------------------------------------------*/
-bool SimpleTextSrc::getRightToLeft(toffset ich)
+bool SimpleTextSrc::getRightToLeft(toffset /*ich*/)
 {
 	return false;
 }
@@ -78,7 +77,7 @@
 /*----------------------------------------------------------------------------------------------
 	Return the depth of embedding of the writing system.
 ----------------------------------------------------------------------------------------------*/
-unsigned int SimpleTextSrc::getDirectionDepth(toffset ich)
+unsigned int SimpleTextSrc::getDirectionDepth(toffset /*ich*/)
 {
 	return 0;
 }
@@ -87,7 +86,7 @@
 	Return the vertical offset of the text. This simple implementation provides no
 	vertical offset.
 ----------------------------------------------------------------------------------------------*/
-float SimpleTextSrc::getVerticalOffset(toffset ich)
+float SimpleTextSrc::getVerticalOffset(toffset /*ich*/)
 {
 	return 0;
 }
diff -ru ../silgraphite-2.3.1.orig/engine/test/RegressionTest/SimpleTextSrc.h ./engine/test/RegressionTest/SimpleTextSrc.h
--- ../silgraphite-2.3.1.orig/engine/test/RegressionTest/SimpleTextSrc.h	2012-02-27 21:39:57.000000000 -0500
+++ ./engine/test/RegressionTest/SimpleTextSrc.h	2012-02-27 21:40:30.000000000 -0500
@@ -11,7 +11,9 @@
 Description:
 	A simple text source that shows how to use this interface within Graphite.
 -------------------------------------------------------------------------------*//*:End Ignore*/
+#ifdef _MSC_VER
 #pragma once
+#endif
 #ifndef GRTXTSRC_INCLUDED
 #define GRTXTSRC_INCLUDED
 
@@ -59,12 +61,12 @@
 	{
 		return m_cchLength;
 	}
-	virtual size_t fetch(toffset ichMin, size_t cch, utf32 * prgchBuffer)
+	virtual size_t fetch(toffset /*ichMin*/, size_t /*cch*/, utf32 * /*prgchBuffer*/)
 	{
 		throw;
 	}
 	virtual size_t fetch(toffset ichMin, size_t cch, gr::utf16 * prgchwBuffer);
-	virtual size_t fetch(toffset ichMin, size_t cch, utf8  * prgchsBuffer)
+	virtual size_t fetch(toffset /*ichMin*/, size_t /*cch*/, utf8  * /*prgchsBuffer*/)
 	{
 		throw;
 	};
@@ -73,14 +75,14 @@
 	virtual unsigned int getDirectionDepth(toffset ich);
 	virtual float getVerticalOffset(toffset ich);
 
-	virtual isocode getLanguage(toffset ich)
+	virtual isocode getLanguage(toffset /*ich*/)
 	{
 		isocode ret;
 		ret.rgch[0] = 'e'; ret.rgch[1] = 'n'; ret.rgch[2] = 0; ret.rgch[3] = 0;
 		return ret;
 	}
 
-	virtual std::pair<toffset, toffset> propertyRange(toffset ich)
+	virtual std::pair<toffset, toffset> propertyRange(toffset /*ich*/)
 	{
 		std::pair<toffset, toffset> pairRet;
 		pairRet.first = 0;
@@ -88,16 +90,16 @@
 		return pairRet;
 	}
 
-	virtual size_t getFontFeatures(toffset ich, FeatureSetting * prgfset)
+	virtual size_t getFontFeatures(toffset /*ich*/, FeatureSetting * /*prgfset*/)
 	{
 		return 0; // no features in this simple implementation
 	}
-	virtual bool sameSegment(toffset ich1, toffset ich2)
+	virtual bool sameSegment(toffset /*ich1*/, toffset /*ich2*/)
 	{
 		return true;
 	}
 
-	virtual void getColors(toffset ich, int * pclrFore, int * pclrBack)
+	virtual void getColors(toffset /*ich*/, int * pclrFore, int * pclrBack)
 	{
 		*pclrFore = kclrBlack;
 		*pclrBack = kclrTransparent;
diff -ru ../silgraphite-2.3.1.orig/wrappers/win32/WinFont.cpp ./wrappers/win32/WinFont.cpp
--- ../silgraphite-2.3.1.orig/wrappers/win32/WinFont.cpp	2012-02-27 21:39:57.000000000 -0500
+++ ./wrappers/win32/WinFont.cpp	2012-02-27 21:40:30.000000000 -0500
@@ -70,6 +70,7 @@
 	// But don't store m_hfont, because we don't really "own" it; the client is
 	// responsible for releasing it.
 	m_hfont = 0;
+    m_pGlyphMetricMap = NULL;
 	memset(&m_fpropSet, 0, sizeof(m_fpropSet));
 
 	m_pbCmapTbl = NULL;
@@ -196,6 +197,7 @@
 	m_hdc = 0;
 	m_hfont = 0;
 	m_hfontClient = 0;
+    m_pGlyphMetricMap = NULL;
 	memset(&m_fpropSet, 0, sizeof(FontProps));
 
 	m_pbCmapTbl = NULL;
@@ -408,7 +410,7 @@
 					if (pPolyCurve->wType == TT_PRIM_QSPLINE &&
 						// test if this is the last curve
 						pPolyHdr->cb - (int)((byte *)(&pPolyCurve->apfx[j]) - (byte *)(pPolyHdr))
-							== sizeof POINTFX &&
+							== sizeof (POINTFX) &&
 						// and the two points are identical
 						CompareFixed(pPolyCurve->apfx[j].x, pPolyHdr->pfxStart.x) &&
 						CompareFixed(pPolyCurve->apfx[j].y, pPolyHdr->pfxStart.y))
@@ -457,6 +459,16 @@
 ----------------------------------------------------------------------------------------------*/
 void WinFont::getGlyphMetrics(gid16 chw, gr::Rect & boundingBox, gr::Point & advances)
 {
+    if (m_pGlyphMetricMap)
+    {
+        GlyphMetricMap::iterator i = m_pGlyphMetricMap->find(chw);
+        if (i != m_pGlyphMetricMap->end())
+        {
+            boundingBox = i->second.first;
+            advances = i->second.second;
+            return;
+        }
+    }
 	GLYPHMETRICS gm;
 	const MAT2 mat2 = {{0,1}, {0,0}, {0,0}, {0,1}};
 	if (GDI_ERROR == ::GetGlyphOutline(m_hdc, chw, GGO_GLYPH_INDEX | GGO_METRICS,
@@ -474,6 +486,10 @@
 	boundingBox.bottom = (float)gm.gmptGlyphOrigin.y - gm.gmBlackBoxY;
 	advances.x = gm.gmCellIncX;
 	advances.y = gm.gmCellIncY;
+    if (m_pGlyphMetricMap)
+    {
+        (*m_pGlyphMetricMap)[chw] = std::pair<gr::Rect,gr::Point>(boundingBox, advances);
+    }
 }
 
 /*----------------------------------------------------------------------------------------------
@@ -618,7 +634,10 @@
 
 		static int cCreateFontCalls = 0;
 		static int cCreateFontZero = 0;
-		HFONT hfont = g_fhc.GetFont(lf);
+        FontHandleCache::FontCacheValue cache = g_fhc.GetCache(lf);
+        HFONT hfont = cache.hfont;
+        m_pGlyphMetricMap = cache.pGlyphMetricMap;
+		//HFONT hfont = g_fhc.GetFont(lf);
 		//char ch1[200];
 		//if (hfont == 0)
 		//{
@@ -731,7 +750,7 @@
 	@param lf LOGFONT value that describes the desired font
 	@return Font handle
 ----------------------------------------------------------------------------------------------*/
-HFONT WinFont::FontHandleCache::GetFont(LOGFONT & lf)
+WinFont::FontHandleCache::FontCacheValue WinFont::FontHandleCache::GetCache(LOGFONT & lf)
 {
 	FontCacheValue fcv;
 	FontHandleHashMap::iterator itFound = m_hmlffcv.find(lf);
@@ -752,11 +771,12 @@
 			THROW(kresFail);
 
 		fcv.nRefs = 1;
+        fcv.pGlyphMetricMap = new GlyphMetricMap();
 
 		m_hmlffcv.insert(std::pair<LOGFONT, FontCacheValue>(lf, fcv));
 	}
 
-	return fcv.hfont;
+	return fcv;
 }
 
 /*----------------------------------------------------------------------------------------------
@@ -767,7 +787,7 @@
 ----------------------------------------------------------------------------------------------*/
 void WinFont::FontHandleCache::DeleteFont(HFONT hfont)
 {
-	if (!hfont || !m_bValid)
+	if (!hfont || !m_bValid || m_hmlffcv.size() == 0)
 		return;
 
 	// find the font in the hash map
@@ -782,6 +802,8 @@
 			{
 				// delete font
 				::DeleteObject(hfont);
+                if (fcv.pGlyphMetricMap)
+                    delete fcv.pGlyphMetricMap;
 				m_hmlffcv.erase(it);
 			}
 			else
@@ -832,7 +854,8 @@
 bool WinFont::LogFontHashFuncs::operator() (const WinFont::LogFontWrapper & key1,
 	const WinFont::LogFontWrapper & key2) const
 {
-	return (key1 == key2);
+    // return true if key1 should be ordered before key2
+    return (operator()(key1) < operator()(key2));
 }
 
 /*--------------------------------------------------------------------------------------
diff -ru ../silgraphite-2.3.1.orig/wrappers/win32/WinFont.h ./wrappers/win32/WinFont.h
--- ../silgraphite-2.3.1.orig/wrappers/win32/WinFont.h	2012-02-27 21:39:57.000000000 -0500
+++ ./wrappers/win32/WinFont.h	2012-02-27 21:40:30.000000000 -0500
@@ -26,9 +26,15 @@
 #include "GrDebug.h"
 #include "GrClient.h"
 #include "Font.h"
+#include <map>
+
+#ifdef _STLPORT_VERSION
+namespace stdext = _STLP_STD;
+#endif
 
 namespace gr
 {
+typedef std::map<gid16, std::pair<gr::Rect, gr::Point> > GlyphMetricMap;
 
 class FontFace;
 
@@ -100,6 +106,7 @@
 	HFONT m_hfontClient;	// need to replace this HFONT into the DC when we are finished
 							// with it
 
+    GlyphMetricMap * m_pGlyphMetricMap;
 	// Debugging:
 	//OLECHAR m_rgchTemp[32];
 
@@ -185,11 +192,13 @@
 	class FontHandleCache // hungarian: fhc
 	{
 	public:
-		struct FontCacheValue
+        struct FontCacheValue
 		{
 			int nRefs;   // reference count
 			HFONT hfont; // font handle
 
+            GlyphMetricMap * pGlyphMetricMap; // glyph metrics
+
 			bool operator==(const FontCacheValue & val) const
 			{
 				return (hfont == val.hfont);
@@ -199,7 +208,8 @@
         FontHandleCache() : m_bValid(true) {};
 		~FontHandleCache();
 
-		HFONT GetFont(LOGFONT & lf);
+		//HFONT GetFont(LOGFONT & lf);
+        FontCacheValue GetCache(LOGFONT & lf);
 		void DeleteFont(HFONT hfont);
 
 		typedef stdext::hash_map<LogFontWrapper, FontCacheValue, LogFontHashFuncs> FontHandleHashMap;
diff -ru ../silgraphite-2.3.1.orig/wrappers/win32/win32_dll.cpp ./wrappers/win32/win32_dll.cpp
--- ../silgraphite-2.3.1.orig/wrappers/win32/win32_dll.cpp	2012-02-27 21:39:57.000000000 -0500
+++ ./wrappers/win32/win32_dll.cpp	2012-02-27 21:40:30.000000000 -0500
@@ -14,7 +14,7 @@
 	DllMain. This is the main DLL entry point for a non-MFC DLL. For an MFC DLL, DllMain is
 		in DllModul.cpp. Both DllMains call ModuleEntry::DllMain.
 ----------------------------------------------------------------------------------------------*/
-extern "C" BOOL WINAPI DllMain(HMODULE hmod, DWORD dwReason, PVOID pvReserved)
+extern "C" BOOL WINAPI DllMain(HMODULE hmod, DWORD dwReason, PVOID /*pvReserved*/)
 {
 	bool fRet = true;
 
