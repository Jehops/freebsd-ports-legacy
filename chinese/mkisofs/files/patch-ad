--- joliet.c.orig	Fri Mar  3 15:33:48 2000
+++ joliet.c	Fri Mar  3 15:54:48 2000
@@ -78,6 +78,9 @@
 #include <stdlib.h>
 #include <time.h>
 
+/* Big5 to Unicode mapping table */
+#include "big52uni.h"
+
 static int jpath_table_index;
 static struct directory ** jpathlist;
 static int next_jpath_index  = 1;
@@ -88,6 +91,9 @@
 static void DECL(assign_joliet_directory_addresses, (struct directory * node));
 static int jroot_gen	__PR((void));
 
+static u_int16_t unicode_table[] = CHINESE_UNICODE;
+static u_int16_t big5_table[] = CHINESE_BIG5;
+
 /* 
  * Function:		convert_to_unicode
  *
@@ -101,6 +107,8 @@
   unsigned char * tmpbuf;
   int i;
   int j;
+  int p;
+  u_int16_t code, unicode;
 
   /*
    * If we get a NULL pointer for the source, it means we have an inplace
@@ -156,6 +164,31 @@
 	      break;
 	    }
 	}
+	/******//* big5 to unicode patch*/
+
+	  if( tmpbuf[j] >= 0xA1 ){
+
+	    /* **** 00 A4 00 A4 00 A4 00 E5 **** */
+	    /* ****          中          文 **** */
+	    /* ***j=A4 A4 A4 E5 --> code=0xa4a4 ->find unicode **** */
+	    /* **** 4E 2D 65 87 <--- result **** */
+
+	    code = tmpbuf[j];
+	    code = code << 8;
+	    code += tmpbuf[j+1];
+	    for (p=0;p<BIG5_TABLE_SIZE;p++) {
+	      if (big5_table[p] == code){
+		unicode = unicode_table[p];
+		buffer[i] = unicode >> 8;
+		buffer[i+1] = unicode ;
+		j++;
+		break;
+	      }
+	      /*else {
+		return (u_int16_t)'?';
+		}*/
+	    }
+	  }
     }
 
   if( source == NULL )
@@ -176,8 +209,48 @@
 static int FDECL1(joliet_strlen, const char *, string)
 {
   int rtn;
+  unsigned char * tmpbuf;
+  int i;
+  int j;
+
+  int p;
+  u_int16_t code, unicode;
+  int tmpsize ;
 
   rtn = strlen(string) << 1;
+  tmpsize = rtn;
+
+  tmpbuf = (u_char *)string;
+  tmpsize = rtn;
+  j=0;
+  for(i=0; i < tmpsize ; i += 2, j++)
+    {
+      /******//* big5 to unicode patch*/
+
+      if( tmpbuf[j] >= 0xA1 ){
+
+	/* **** 00 A4 00 A4 00 A4 00 E5 **** */
+	/* ****          中          文 **** */
+	/* ***j=A4 A4 A4 E5 --> code=0xa4a4 ->find unicode **** */
+	/* **** 4E 2D 65 87 <--- result **** */
+
+	code = tmpbuf[j];
+	code = code << 8;
+	code += tmpbuf[j+1];
+	for (p=0;p<BIG5_TABLE_SIZE;p++) {
+	  if (big5_table[p] == code){
+	    tmpsize -= 2;
+	    unicode = unicode_table[p];
+	    j++;
+	    break;
+	  }
+	  /*else {
+	    return (u_int16_t)'?';
+	    }
+	  */
+	}
+      }
+    }
 
   /* 
    * We do clamp the maximum length of a Joliet string to be the
@@ -185,11 +258,11 @@
    * bolix things up with very long paths.    The Joliet specs say
    * that the maximum length is 128 bytes, or 64 unicode characters.
    */
-  if( rtn > 0x80)
+  if( tmpsize > 0x80)
     {
-      rtn = 0x80;
+      tmpsize = 0x80;
     }
-  return rtn;
+  return tmpsize;
 }
 
 /* 
