diff -ruN /dev/null ../bridges/source/cpp_uno/gcc2_freebsd_intel-sjlj/cpp2uno.cxx
--- /dev/null	Thu Jan  1 01:00:00 1970
+++ ../bridges/source/cpp_uno/gcc2_freebsd_intel-sjlj/cpp2uno.cxx	Tue Jun  4 10:49:43 2002
@@ -0,0 +1,615 @@
+/*************************************************************************
+ *
+ *  $RCSfile: cpp2uno.cxx,v $
+ *
+ *  $Revision: 1.1 $
+ *
+ *  last change: $Author: svesik $ $Date: 2001/11/12 22:43:04 $
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#define LEAK_STATIC_DATA
+//  #define TRACE(x) OSL_TRACE(x)
+#define TRACE(x)
+
+#include <stdlib.h>
+#if STLPORT_VERSION<321
+#include <list.h>
+#include <map.h>
+#else
+#include <list>
+#include <map>
+#endif
+#include <typeinfo>
+#ifndef _RTL_ALLOC_H_
+#include <rtl/alloc.h>
+#endif
+#ifndef _OSL_MUTEX_HXX_
+#include <osl/mutex.hxx>
+#endif
+
+#ifndef _TYPELIB_TYPEDESCRIPTION_HXX_
+#include <typelib/typedescription.hxx>
+#endif
+#ifndef _UNO_DATA_H_
+#include <uno/data.h>
+#endif
+#ifndef _BRIDGES_CPP_UNO_BRIDGE_HXX_
+#include <bridges/cpp_uno/bridge.hxx>
+#endif
+#ifndef _BRIDGES_CPP_UNO_TYPE_MISC_HXX_
+#include <bridges/cpp_uno/type_misc.hxx>
+#endif
+
+#include "gcc2_freebsd_intel.hxx"
+
+using namespace com::sun::star::uno;
+using namespace std;
+using namespace osl;
+using namespace rtl;
+
+namespace CPPU_CURRENT_NAMESPACE
+{
+
+//==================================================================================================
+rtl_StandardModuleCount g_moduleCount = MODULE_COUNT_INIT;
+
+//==================================================================================================
+static typelib_TypeClass cpp2uno_call(
+	cppu_cppInterfaceProxy * pThis,
+	const typelib_TypeDescription * pMemberTypeDescr,
+	typelib_TypeDescriptionReference * pReturnTypeRef, // 0 indicates void return
+	sal_Int32 nParams, typelib_MethodParameter * pParams,
+	void ** pCallStack,
+	sal_Int64 * pRegisterReturn /* space for register return */ )
+{
+	// pCallStack: ret, [return ptr], this, params
+	char * pCppStack = (char *)(pCallStack +1);
+
+	// return
+	typelib_TypeDescription * pReturnTypeDescr = 0;
+	if (pReturnTypeRef)
+		TYPELIB_DANGER_GET( &pReturnTypeDescr, pReturnTypeRef );
+	
+	void * pUnoReturn = 0;
+	void * pCppReturn = 0; // complex return ptr: if != 0 && != pUnoReturn, reconversion need
+	
+	if (pReturnTypeDescr)
+	{
+		if (cppu_isSimpleType( pReturnTypeDescr ))
+		{
+			pUnoReturn = pRegisterReturn; // direct way for simple types
+		}
+		else // complex return via ptr (pCppReturn)
+		{
+			pCppReturn = *(void **)pCppStack;
+			pCppStack += sizeof(void *);
+			
+			pUnoReturn = (cppu_relatesToInterface( pReturnTypeDescr )
+						  ? alloca( pReturnTypeDescr->nSize )
+						  : pCppReturn); // direct way
+		}
+	}
+	// pop this
+	pCppStack += sizeof( void* );
+
+	// stack space
+	OSL_ENSURE( sizeof(void *) == sizeof(sal_Int32), "### unexpected size!" );
+	// parameters
+	void ** pUnoArgs = (void **)alloca( 4 * sizeof(void *) * nParams );
+	void ** pCppArgs = pUnoArgs + nParams;
+	// indizes of values this have to be converted (interface conversion cpp<=>uno)
+	sal_Int32 * pTempIndizes = (sal_Int32 *)(pUnoArgs + (2 * nParams));
+	// type descriptions for reconversions
+	typelib_TypeDescription ** ppTempParamTypeDescr = (typelib_TypeDescription **)(pUnoArgs + (3 * nParams));
+	
+	sal_Int32 nTempIndizes   = 0;
+	
+	for ( sal_Int32 nPos = 0; nPos < nParams; ++nPos )
+	{
+		const typelib_MethodParameter & rParam = pParams[nPos];
+		typelib_TypeDescription * pParamTypeDescr = 0;
+		TYPELIB_DANGER_GET( &pParamTypeDescr, rParam.pTypeRef );
+
+		if (!rParam.bOut && cppu_isSimpleType( pParamTypeDescr )) // value
+		{
+			pCppArgs[nPos] = pCppStack;
+			pUnoArgs[nPos] = pCppStack;
+			switch (pParamTypeDescr->eTypeClass)
+			{
+			case typelib_TypeClass_HYPER:
+			case typelib_TypeClass_UNSIGNED_HYPER:
+			case typelib_TypeClass_DOUBLE:
+				pCppStack += sizeof(sal_Int32); // extra long
+			}
+			// no longer needed
+			TYPELIB_DANGER_RELEASE( pParamTypeDescr );
+		}
+		else // ptr to complex value | ref
+		{
+			pCppArgs[nPos] = *(void **)pCppStack;
+
+			if (! rParam.bIn) // is pure out
+			{
+				// uno out is unconstructed mem!
+				pUnoArgs[nPos] = alloca( pParamTypeDescr->nSize );
+				pTempIndizes[nTempIndizes] = nPos;
+				// will be released at reconversion
+				ppTempParamTypeDescr[nTempIndizes++] = pParamTypeDescr;
+			}
+			// is in/inout
+			else if (cppu_relatesToInterface( pParamTypeDescr ))
+			{
+				uno_copyAndConvertData( pUnoArgs[nPos] = alloca( pParamTypeDescr->nSize ),
+										*(void **)pCppStack, pParamTypeDescr,
+										&pThis->pBridge->aCpp2Uno );
+				pTempIndizes[nTempIndizes] = nPos; // has to be reconverted
+				// will be released at reconversion
+				ppTempParamTypeDescr[nTempIndizes++] = pParamTypeDescr;
+			}
+			else // direct way
+			{
+				pUnoArgs[nPos] = *(void **)pCppStack;
+				// no longer needed
+				TYPELIB_DANGER_RELEASE( pParamTypeDescr );
+			}
+		}
+		pCppStack += sizeof(sal_Int32); // standard parameter length
+	}
+	
+	// ExceptionHolder
+	uno_Any aUnoExc; // Any will be constructed by callee
+	uno_Any * pUnoExc = &aUnoExc;
+
+	// invoke uno dispatch call
+	(*pThis->pUnoI->pDispatcher)( pThis->pUnoI, pMemberTypeDescr, pUnoReturn, pUnoArgs, &pUnoExc );
+	
+	// in case an exception occured...
+	if (pUnoExc)
+	{
+		// destruct temporary in/inout params
+		for ( ; nTempIndizes--; )
+		{
+			sal_Int32 nIndex = pTempIndizes[nTempIndizes];
+			
+			if (pParams[nIndex].bIn) // is in/inout => was constructed
+				uno_destructData( pUnoArgs[nIndex], ppTempParamTypeDescr[nTempIndizes], 0 );
+			TYPELIB_DANGER_RELEASE( ppTempParamTypeDescr[nTempIndizes] );
+		}
+		if (pReturnTypeDescr)
+			TYPELIB_DANGER_RELEASE( pReturnTypeDescr );
+		
+		gcc291_freebsd_intel_raiseException( &aUnoExc, &pThis->pBridge->aUno2Cpp ); // has to destruct the any
+		// is here for dummy
+		return typelib_TypeClass_VOID;
+	}
+	else // else no exception occured...
+	{
+		// temporary params
+		for ( ; nTempIndizes--; )
+		{
+			sal_Int32 nIndex = pTempIndizes[nTempIndizes];
+			typelib_TypeDescription * pParamTypeDescr = ppTempParamTypeDescr[nTempIndizes];
+			
+			if (pParams[nIndex].bOut) // inout/out
+			{
+				// convert and assign
+				uno_destructData( pCppArgs[nIndex], pParamTypeDescr, cpp_release );
+				uno_copyAndConvertData( pCppArgs[nIndex], pUnoArgs[nIndex], pParamTypeDescr,
+										&pThis->pBridge->aUno2Cpp );
+			}
+			// destroy temp uno param
+			uno_destructData( pUnoArgs[nIndex], pParamTypeDescr, 0 );
+			
+			TYPELIB_DANGER_RELEASE( pParamTypeDescr );
+		}
+		// return
+		if (pCppReturn) // has complex return
+		{
+			if (pUnoReturn != pCppReturn) // needs reconversion
+			{
+				uno_copyAndConvertData( pCppReturn, pUnoReturn, pReturnTypeDescr,
+										&pThis->pBridge->aUno2Cpp );
+				// destroy temp uno return
+				uno_destructData( pUnoReturn, pReturnTypeDescr, 0 );
+			}
+			// complex return ptr is set to eax
+			*(void **)pRegisterReturn = pCppReturn;
+		}
+		if (pReturnTypeDescr)
+		{
+			typelib_TypeClass eRet = (typelib_TypeClass)pReturnTypeDescr->eTypeClass;
+			TYPELIB_DANGER_RELEASE( pReturnTypeDescr );
+			return eRet;
+		}
+		else
+			return typelib_TypeClass_VOID;
+	}
+}
+
+
+//==================================================================================================
+static typelib_TypeClass cpp_mediate(
+	sal_Int32 nVtableCall,
+	void ** pCallStack,
+	sal_Int64 * pRegisterReturn /* space for register return */ )
+{
+	OSL_ENSURE( sizeof(sal_Int32)==sizeof(void *), "### unexpected!" );
+	
+	// pCallStack: ret adr, [ret *], this, params
+	// _this_ ptr is patched cppu_XInterfaceProxy object
+	cppu_cppInterfaceProxy * pCppI = NULL;
+	if( nVtableCall & 0x80000000 )
+	{
+		nVtableCall &= 0x7fffffff;
+		pCppI = (cppu_cppInterfaceProxy *)(XInterface *)*(pCallStack +2);
+	}
+	else
+		pCppI = (cppu_cppInterfaceProxy *)(XInterface *)*(pCallStack +1);
+
+	typelib_InterfaceTypeDescription * pTypeDescr = pCppI->pTypeDescr;
+	
+	OSL_ENSURE( nVtableCall < pTypeDescr->nMapFunctionIndexToMemberIndex,
+				 "### illegal vtable index!" );
+	if (nVtableCall >= pTypeDescr->nMapFunctionIndexToMemberIndex)
+	{
+		throw RuntimeException( OUString::createFromAscii("illegal vtable index!"), (XInterface *)pCppI );
+	}
+	
+	// determine called method
+	OSL_ENSURE( nVtableCall < pTypeDescr->nMapFunctionIndexToMemberIndex, "### illegal vtable index!" );
+	sal_Int32 nMemberPos = pTypeDescr->pMapFunctionIndexToMemberIndex[nVtableCall];
+	OSL_ENSURE( nMemberPos < pTypeDescr->nAllMembers, "### illegal member index!" );
+
+	TypeDescription aMemberDescr( pTypeDescr->ppAllMembers[nMemberPos] );
+
+	typelib_TypeClass eRet;
+	switch (aMemberDescr.get()->eTypeClass)
+	{
+	case typelib_TypeClass_INTERFACE_ATTRIBUTE:
+	{
+		if (pTypeDescr->pMapMemberIndexToFunctionIndex[nMemberPos] == nVtableCall)
+		{
+			// is GET method
+			eRet = cpp2uno_call(
+				pCppI, aMemberDescr.get(),
+				((typelib_InterfaceAttributeTypeDescription *)aMemberDescr.get())->pAttributeTypeRef,
+				0, 0, // no params
+				pCallStack, pRegisterReturn );
+		}
+		else
+		{
+			// is SET method
+			typelib_MethodParameter aParam;
+			aParam.pTypeRef =
+				((typelib_InterfaceAttributeTypeDescription *)aMemberDescr.get())->pAttributeTypeRef;
+			aParam.bIn		= sal_True;
+			aParam.bOut		= sal_False;
+			
+			eRet = cpp2uno_call(
+				pCppI, aMemberDescr.get(),
+				0, // indicates void return
+				1, &aParam,
+				pCallStack, pRegisterReturn );
+		}
+		break;
+	}
+	case typelib_TypeClass_INTERFACE_METHOD:
+	{
+		// is METHOD
+		switch (nVtableCall)
+		{
+		case 1: // acquire()
+			pCppI->acquireProxy(); // non virtual call!
+			eRet = typelib_TypeClass_VOID;
+			break;
+		case 2: // release()
+			pCppI->releaseProxy(); // non virtual call!
+			eRet = typelib_TypeClass_VOID;
+			break;
+		case 0: // queryInterface() opt
+		{
+			typelib_TypeDescription * pTD = 0;
+			TYPELIB_DANGER_GET( &pTD, reinterpret_cast< Type * >( pCallStack[3] )->getTypeLibType() );
+			if (pTD)
+			{
+                XInterface * pInterface = 0;
+                (*pCppI->pBridge->pCppEnv->getRegisteredInterface)(
+                    pCppI->pBridge->pCppEnv,
+                    (void **)&pInterface, pCppI->oid.pData, (typelib_InterfaceTypeDescription *)pTD );
+			
+                if (pInterface)
+                {
+                    ::uno_any_construct(
+                        reinterpret_cast< uno_Any * >( pCallStack[1] ),
+                        &pInterface, pTD, cpp_acquire );
+                    pInterface->release();
+                    TYPELIB_DANGER_RELEASE( pTD );
+                    *(void **)pRegisterReturn = pCallStack[1];
+                    eRet = typelib_TypeClass_ANY;
+                    break;
+                }
+                TYPELIB_DANGER_RELEASE( pTD );
+            }
+		} // else perform queryInterface()
+		default:
+			eRet = cpp2uno_call(
+				pCppI, aMemberDescr.get(),
+				((typelib_InterfaceMethodTypeDescription *)aMemberDescr.get())->pReturnTypeRef,
+				((typelib_InterfaceMethodTypeDescription *)aMemberDescr.get())->nParams,
+				((typelib_InterfaceMethodTypeDescription *)aMemberDescr.get())->pParams,
+				pCallStack, pRegisterReturn );
+		}
+		break;
+	}
+	default:
+	{
+		throw RuntimeException( OUString::createFromAscii("no member description found!"), (XInterface *)pCppI );
+		// is here for dummy
+		eRet = typelib_TypeClass_VOID;
+	}
+	}
+
+	return eRet;
+}
+
+//==================================================================================================
+class MediateClassData
+{
+public:
+	struct ClassDataBuffer
+	{
+		void*			m_pVTable;
+
+		~ClassDataBuffer();
+	};
+private:
+
+	map< OUString, ClassDataBuffer* >		m_aClassData;
+	Mutex									m_aMutex;
+
+	void createVTable( ClassDataBuffer*, typelib_InterfaceTypeDescription* );
+public:
+	const ClassDataBuffer* getClassData( typelib_InterfaceTypeDescription* );
+	
+	MediateClassData() {}
+	~MediateClassData();
+};
+//__________________________________________________________________________________________________
+MediateClassData::ClassDataBuffer::~ClassDataBuffer()
+{
+	delete m_pVTable;
+}
+
+//__________________________________________________________________________________________________
+MediateClassData::~MediateClassData()
+{
+	TRACE( "> calling ~MediateClassData(): freeing mediate vtables... <\n" );
+	
+	// this MUST be the absolute last one which is called!
+	for ( map< OUString, ClassDataBuffer* >::iterator iPos( m_aClassData.begin() ); iPos != m_aClassData.end(); ++iPos )
+	{
+		// todo
+//  		delete (*iPos).second;
+	}
+}
+
+//__________________________________________________________________________________________________
+
+const MediateClassData::ClassDataBuffer* MediateClassData::getClassData( typelib_InterfaceTypeDescription* pType )
+{
+	MutexGuard aGuard( m_aMutex );
+
+	map< OUString, ClassDataBuffer* >::iterator element = m_aClassData.find( pType->aBase.pTypeName );
+	if( element != m_aClassData.end() )
+		return (*element).second;
+
+	ClassDataBuffer* pBuffer = new ClassDataBuffer();
+	createVTable( pBuffer, pType );
+	m_aClassData[ pType->aBase.pTypeName ] = pBuffer;
+	return pBuffer;
+}
+
+
+//==================================================================================================
+/**
+ * is called on incoming vtable calls
+ * (called by asm snippets)
+ */
+static void cpp_vtable_call( int nTableEntry, void** pCallStack ) __attribute__((regparm(2)));
+
+void cpp_vtable_call( int nTableEntry, void** pCallStack )
+{
+	volatile long nRegReturn[2];
+
+	typelib_TypeClass aType =
+		cpp_mediate( nTableEntry, pCallStack, (sal_Int64*)nRegReturn );
+
+	switch( aType )
+	{
+		case typelib_TypeClass_HYPER:
+		case typelib_TypeClass_UNSIGNED_HYPER:
+			__asm__( "movl %1, %%edx\n\t"
+					 "movl %0, %%eax\n"
+					 : : "m"(nRegReturn[0]), "m"(nRegReturn[1]) );
+			break;
+		case typelib_TypeClass_FLOAT:
+			__asm__( "flds %0\n\t"
+					 "fstp %%st(0)\n\t"
+					 "flds %0\n"
+					 : : "m"(*(float *)nRegReturn) );
+			break;
+		case typelib_TypeClass_DOUBLE:
+			__asm__( "fldl %0\n\t"
+					 "fstp %%st(0)\n\t"
+					 "fldl %0\n"
+					 : : "m"(*(double *)nRegReturn) );
+			break;
+// 		case typelib_TypeClass_UNSIGNED_SHORT:
+// 		case typelib_TypeClass_SHORT:
+// 			__asm__( "movswl %0, %%eax\n"
+// 					 : : "m"(nRegReturn) );
+// 		break;
+		default:
+			__asm__( "movl %0, %%eax\n"
+					 : : "m"(nRegReturn[0]) );
+			break;
+	}
+}
+//__________________________________________________________________________________________________
+
+void MediateClassData::createVTable( ClassDataBuffer* pBuffer, typelib_InterfaceTypeDescription* pType )
+{
+	// get all member functions
+	list< sal_Bool > aComplexReturn;
+
+	for( int n = 0; n < pType->nAllMembers; n++ )
+	{
+		typelib_TypeDescription* pMember = NULL;
+		TYPELIB_DANGER_GET( &pMember, pType->ppAllMembers[n] );
+		if( pMember->eTypeClass == typelib_TypeClass_INTERFACE_ATTRIBUTE )
+		{
+			typelib_TypeDescription * pRetTD = 0;
+			TYPELIB_DANGER_GET( &pRetTD, ((typelib_InterfaceAttributeTypeDescription *)pMember)->pAttributeTypeRef );
+			// get method
+			aComplexReturn.push_back( !cppu_isSimpleType( pRetTD ) );
+			// set method
+			if( ! ((typelib_InterfaceAttributeTypeDescription*)pMember)->bReadOnly )
+				aComplexReturn.push_back( sal_False );
+			TYPELIB_DANGER_RELEASE( pRetTD );
+		}
+		else
+		{
+			typelib_TypeDescription * pRetTD = 0;
+			TYPELIB_DANGER_GET( &pRetTD, ((typelib_InterfaceMethodTypeDescription *)pMember)->pReturnTypeRef );
+			aComplexReturn.push_back( !cppu_isSimpleType( pRetTD ) );
+			TYPELIB_DANGER_RELEASE( pRetTD );
+		}
+		TYPELIB_DANGER_RELEASE( pMember );
+	}
+
+	int nSize = aComplexReturn.size();
+	char * pSpace = (char *)rtl_allocateMemory( (2*(nSize+1)*sizeof(void *)) + (nSize*20) );
+	pBuffer->m_pVTable = (void*)pSpace;
+	
+	char * pCode	= pSpace + (2*(nSize+1)*sizeof(void *));
+	void ** pvft	= (void **)pSpace;
+	pvft[0] = NULL;
+	pvft[1] = NULL;
+
+	// setup vft and code
+	for ( sal_Int32 nPos = 0; nPos < nSize; ++nPos )
+	{
+		unsigned char * codeSnip = (unsigned char *)pCode + (nPos*20);
+		pvft[(nPos << 1) + 2 ] = NULL;
+		pvft[(nPos << 1) + 3 ] = codeSnip;
+		
+		// mov $nPos, %eax
+		*codeSnip++ = 0xb8;
+		*(sal_Int32 *)codeSnip = nPos | ( aComplexReturn.front() ? 0x80000000 : 0 );
+		codeSnip += sizeof(sal_Int32);
+		aComplexReturn.pop_front();
+		// mov %esp, %edx
+		*codeSnip++ = 0x89;
+		*codeSnip++ = 0xe2;
+		// jmp  cpp_vtable_call
+		*codeSnip++ = 0xe9;
+		*(sal_Int32 *)codeSnip = ((unsigned char *)cpp_vtable_call) - codeSnip - sizeof(sal_Int32);
+		codeSnip += sizeof(sal_Int32);
+	}
+}
+
+//==================================================================================================
+void SAL_CALL cppu_cppInterfaceProxy_patchVtable(
+	XInterface * pCppI, typelib_InterfaceTypeDescription * pTypeDescr ) throw ()
+{
+	static MediateClassData * s_pMediateClassData = 0;
+	if (! s_pMediateClassData)
+	{
+		MutexGuard aGuard( Mutex::getGlobalMutex() );
+		if (! s_pMediateClassData)
+		{
+#ifdef LEAK_STATIC_DATA
+			s_pMediateClassData = new MediateClassData();
+#else
+			static MediateClassData s_aMediateClassData;
+			s_pMediateClassData = &s_aMediateClassData;
+#endif
+		}
+	}
+	*(const void **)pCppI = s_pMediateClassData->getClassData( pTypeDescr )->m_pVTable;
+}
+
+}
+
+//##################################################################################################
+extern "C" SAL_DLLEXPORT sal_Bool SAL_CALL component_canUnload( TimeValue * pTime )
+	SAL_THROW_EXTERN_C()
+{
+	return CPPU_CURRENT_NAMESPACE::g_moduleCount.canUnload( &CPPU_CURRENT_NAMESPACE::g_moduleCount, pTime );
+}
+//##################################################################################################
+extern "C" SAL_DLLEXPORT void SAL_CALL uno_initEnvironment( uno_Environment * pCppEnv )
+	SAL_THROW_EXTERN_C()
+{
+	CPPU_CURRENT_NAMESPACE::cppu_cppenv_initEnvironment( pCppEnv );
+}
+//##################################################################################################
+extern "C" SAL_DLLEXPORT void SAL_CALL uno_ext_getMapping(
+	uno_Mapping ** ppMapping, uno_Environment * pFrom, uno_Environment * pTo )
+	SAL_THROW_EXTERN_C()
+{
+	CPPU_CURRENT_NAMESPACE::cppu_ext_getMapping( ppMapping, pFrom, pTo );
+}
+
diff -ruN /dev/null ../bridges/source/cpp_uno/gcc2_freebsd_intel-sjlj/except.cxx
--- /dev/null	Thu Jan  1 01:00:00 1970
+++ ../bridges/source/cpp_uno/gcc2_freebsd_intel-sjlj/except.cxx	Tue Jun  4 10:49:44 2002
@@ -0,0 +1,365 @@
+/*************************************************************************
+ *
+ *  $RCSfile: except.cxx,v $
+ *
+ *  $Revision: 1.1 $
+ *
+ *  last change: $Author: svesik $ $Date: 2001/11/12 22:43:04 $
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+#include <dlfcn.h>
+#include <new.h>
+#include <typeinfo>
+#if STLPORT_VERSION<321
+#include <map.h>
+#else
+#include <map>
+#endif
+#ifndef _RTL_ALLOC_H_
+#include <rtl/alloc.h>
+#endif
+#ifndef _OSL_DIAGNOSE_H_
+#include <osl/diagnose.h>
+#endif
+
+#ifndef _BRIDGES_CPP_UNO_BRIDGE_HXX_
+#include <bridges/cpp_uno/bridge.hxx>
+#endif
+#ifndef _TYPELIB_TYPEDESCRIPTION_HXX_
+#include <typelib/typedescription.hxx>
+#endif
+#ifndef _COM_SUN_STAR_UNO_ANY_HXX_
+#include <com/sun/star/uno/Any.hxx>
+#endif
+
+#include <rtl/strbuf.hxx>
+
+#include "gcc2_freebsd_intel.hxx"
+
+#ifdef DEBUG
+#include <stdio.h>
+#endif
+
+using namespace std;
+using namespace osl;
+using namespace rtl;
+using namespace com::sun::star::uno;
+
+namespace CPPU_CURRENT_NAMESPACE
+{
+	
+//==================================================================================================
+static OString toUNOname( const OString & rRTTIname )
+{
+	OString aRet;
+	
+	sal_Char* pStr = rRTTIname.getStr();
+	sal_Char* pOrg = pStr;
+
+	// check for namespace
+	if( *pStr == '_' )
+		pStr++;
+	if( *pStr == 'Q' )
+	{
+		pStr++;
+		if( *pStr++ == '_' )
+		{
+			while( *pStr++ != '_' )
+				;
+		}
+	}
+
+	while( *pStr )
+	{
+		int nCharsToCopy = 0;
+		while( *pStr >= '0' && *pStr <= '9' )
+			nCharsToCopy = 10*nCharsToCopy + (int)(*pStr++ - '0');
+		if( aRet.getLength() )
+			aRet += ".";
+		aRet += rRTTIname.copy( pStr - pOrg, nCharsToCopy );
+		pStr += nCharsToCopy;
+	}
+	
+	return aRet;
+}
+//==================================================================================================
+static OString toRTTIname( const OString & rUNOname )
+{
+	if( ! rUNOname.getLength() )
+		return OString();
+    
+	OStringBuffer aRet( 64 );
+    
+    sal_Int32 nIndex = 0;
+    sal_Int32 nToken = 0;
+	do
+    {
+		OString aToken( rUNOname.getToken( 0, '.', nIndex ) );
+        aRet.append( OString::valueOf( (sal_Int32)aToken.getLength() ) );
+		aRet.append( aToken );
+        ++nToken;
+	}
+    while (nIndex >= 0);
+
+    OString ret( aRet.makeStringAndClear() );
+    
+	if( nToken >= 2 )
+	{
+        OStringBuffer buf( 64 );
+		buf.append( 'Q' );
+		if( nToken > 9 )
+            aRet.append( '_' );
+        buf.append( OString::valueOf( (sal_Int32)nToken ) );
+		if( nToken > 9 )
+            aRet.append( '_' );
+        buf.append( ret );
+        ret = buf.makeStringAndClear();
+	}
+    
+    return ret;
+}
+
+ 
+//##################################################################################################
+//#### RTTI simulation #############################################################################
+//##################################################################################################
+
+class RTTIHolder
+{
+	static std::map< OString, void* > aAllRTTI;
+public:
+	static void* getRTTI( const OString& rTypename );
+	static void* getRTTI_UnoName( const OString& rUnoTypename )
+		{ return getRTTI( toRTTIname( rUnoTypename ) ); }
+
+	static void* insertRTTI( const OString& rTypename );
+	static void* insertRTTI_UnoName( const OString& rTypename )
+		{ return insertRTTI( toRTTIname( rTypename ) ); }
+
+	// rSuperTypename MUST exist !!!
+	static void* insertRTTI( const OString& rTypename, const OString& rSuperTypename );
+	static void* insertRTTI_UnoNames( const OString& rTypename, const OString& rSuperTypename )
+		{ return insertRTTI( toRTTIname( rTypename ), toRTTIname( rSuperTypename ) ); }
+
+	// for complex RTTI
+	static void* insertRTTI( const OString& rTypename, void* pRTTI );
+	static void* insertRTTI_UnoName( const OString&rTypename, void* pRTTI )
+		{ return insertRTTI( toRTTIname( rTypename ), pRTTI ); }
+};
+
+std::map< OString, void* > RTTIHolder::aAllRTTI;
+
+void* RTTIHolder::getRTTI( const OString& rTypename )
+{
+	std::map< OString, void* >::iterator element;
+
+	element = aAllRTTI.find( rTypename );
+	return element != aAllRTTI.end() ? (*element).second : NULL;
+}
+
+void* RTTIHolder::insertRTTI( const OString& rTypename )
+{
+#ifdef DEBUG
+	fprintf( stderr, "generating  base RTTI: %s\n", rTypename.getStr() );
+#endif
+	void* pRTTI = new __user_type_info( strdup( rTypename.getStr() ) );
+	aAllRTTI[ rTypename ] = pRTTI;
+	return pRTTI;
+}
+
+void* RTTIHolder::insertRTTI( const OString& rTypename, const OString& rSuperTypename )
+{
+#ifdef DEBUG
+	fprintf( stderr, "generating subclass RTTI: %s %s\n", rTypename.getStr(), rSuperTypename.getStr() );
+#endif
+	OSL_ENSURE( ! getRTTI( rTypename ), "insert RTTI called on already existing type" );
+	void* pRTTI = new __si_type_info( strdup( rTypename.getStr() ), *(__user_type_info*)getRTTI( rSuperTypename ) );
+	aAllRTTI[ rTypename ] = pRTTI;
+	return pRTTI;
+}
+
+void* RTTIHolder::insertRTTI( const OString& rTypename, void* pRTTI )
+{
+	aAllRTTI[ rTypename ] = pRTTI;
+	return pRTTI;
+}
+
+//--------------------------------------------------------------------------------------------------
+
+static void* generateRTTI( typelib_CompoundTypeDescription * pCompTypeDescr )
+{
+	OString aCompTypeName( OUStringToOString( pCompTypeDescr->aBase.pTypeName, RTL_TEXTENCODING_ASCII_US ) );
+	void* pRTTI = RTTIHolder::getRTTI_UnoName( aCompTypeName );
+	if( pRTTI )
+		return pRTTI;
+	
+	if( ! pCompTypeDescr->pBaseTypeDescription )
+		// this is a base type
+		return RTTIHolder::insertRTTI_UnoName( aCompTypeName );
+	if( ! pCompTypeDescr->pBaseTypeDescription->pBaseTypeDescription )
+	{
+		OString aBasename(
+						  OUStringToOString( pCompTypeDescr->pBaseTypeDescription->aBase.pTypeName, RTL_TEXTENCODING_ASCII_US )
+		);
+		if( ! RTTIHolder::getRTTI_UnoName( aBasename ) )
+			RTTIHolder::insertRTTI_UnoName( aBasename );
+
+		// this type has only one supertype
+		return RTTIHolder::insertRTTI_UnoNames( aCompTypeName, aBasename );
+	}
+	
+	// create __si_type_info
+	void* pSuperRTTI = generateRTTI( pCompTypeDescr->pBaseTypeDescription );
+	OString aCompTypeRTTIname( toRTTIname( aCompTypeName ) );
+#ifdef DEBUG
+	fprintf( stderr, "generating RTTI: %s\n", aCompTypeRTTIname.getStr() );
+#endif
+	pRTTI = new __si_type_info( strdup( aCompTypeRTTIname.getStr() ),
+								*(__user_type_info*)pSuperRTTI );
+#if 0
+	__class_type_info::base_info* pBaseInfo = new __class_type_info::base_info;
+	pBaseInfo->base = (__user_type_info*)pSuperRTTI;
+	pBaseInfo->offset = 0;
+	pBaseInfo->is_virtual = 0;
+	pBaseInfo->access1 = __class_type_info::PUBLIC;
+
+	OString aCompTypeRTTIname( toRTTIname( aCompTypeName ) );
+	pRTTI = new __class_type_info(
+		strdup( aCompTypeRTTIname.getStr() ),
+		pBaseInfo,
+		1
+		);
+#endif
+	return RTTIHolder::insertRTTI_UnoName( aCompTypeName, pRTTI );
+}
+
+//--------------------------------------------------------------------------------------------------
+
+static Mutex s_aMutex;
+static std::map< void*, typelib_TypeDescription* > aExceptionMap;
+
+static void deleteException( void* pExc, int nDummy )
+{
+	MutexGuard aGuard( s_aMutex );
+	std::map< void*, typelib_TypeDescription* >::iterator element =
+		aExceptionMap.find( pExc );
+	OSL_ASSERT( element != aExceptionMap.end() );
+	if( element != aExceptionMap.end() )
+	{
+		typelib_TypeDescription* pType = (*element).second;
+		aExceptionMap.erase( pExc );
+		uno_destructData( pExc, pType, cpp_release );
+		typelib_typedescription_release( pType );
+	}
+}
+
+//__________________________________________________________________________________________________
+
+//##################################################################################################
+//#### exported ####################################################################################
+//##################################################################################################
+
+
+void gcc291_freebsd_intel_raiseException( uno_Any * pUnoExc, uno_Mapping * pUno2Cpp )
+{
+	// construct cpp exception object
+	typelib_TypeDescription * pTypeDescr = 0;
+	typelib_typedescriptionreference_getDescription( &pTypeDescr, pUnoExc->pType );
+	
+	void * pCppExc = __eh_alloc( pTypeDescr->nSize ); // will be released in generated dtor
+	uno_copyAndConvertData( pCppExc, pUnoExc->pData, pTypeDescr, pUno2Cpp );
+	
+	// destruct uno exception
+	uno_any_destruct( pUnoExc, 0 );
+	
+	// a must be
+	OSL_ENSURE( sizeof(sal_Int32) == sizeof(void *), "### pointer size differs from sal_Int32!" );
+
+	typelib_CompoundTypeDescription * pCompTypeDescr = (typelib_CompoundTypeDescription *)pTypeDescr;
+	void* pRTTI = generateRTTI( pCompTypeDescr );
+
+	{
+	MutexGuard aGuard( s_aMutex );
+	aExceptionMap[ pCppExc ] = pTypeDescr;
+	}
+	
+	__cp_push_exception( pCppExc, pRTTI, deleteException );
+	__sjthrow();
+}
+
+void gcc291_freebsd_intel_fillUnoException( cp_eh_info* pInfo, uno_Any* pExc, uno_Mapping * pCpp2Uno )
+{
+	OUString aName( OStringToOUString(
+		toUNOname( ((__user_type_info*)(pInfo->type))->name() ), RTL_TEXTENCODING_ASCII_US ) );
+	
+	typelib_TypeDescription * pExcTypeDescr = 0;
+	typelib_typedescription_getByName(
+		&pExcTypeDescr,
+		aName.pData );
+	OSL_ENSURE( pExcTypeDescr, "could not get type description for exception" );
+	if (pExcTypeDescr)
+	{
+		// construct cpp exception any
+		Any aAny( pInfo->value, pExcTypeDescr ); // const_cast
+		typelib_typedescription_release( pExcTypeDescr );
+		// construct uno exception any
+		typelib_TypeDescription* pAnyDescr = 0;
+		getCppuType( (const Any *)0 ).getDescription( &pAnyDescr );
+		uno_copyAndConvertData( pExc, &aAny, pAnyDescr, pCpp2Uno );
+		typelib_typedescription_release( pAnyDescr );
+	}
+}
+
+}
+
diff -ruN /dev/null ../bridges/source/cpp_uno/gcc2_freebsd_intel-sjlj/gcc2_freebsd_intel.hxx
--- /dev/null	Thu Jan  1 01:00:00 1970
+++ ../bridges/source/cpp_uno/gcc2_freebsd_intel-sjlj/gcc2_freebsd_intel.hxx	Tue Jun  4 10:49:36 2002
@@ -0,0 +1,153 @@
+/*************************************************************************
+ *
+ *  $RCSfile: gcc2_freebsd_intel.hxx,v $
+ *
+ *  $Revision: 1.1 $
+ *
+ *  last change: $Author: svesik $ $Date: 2001/11/12 22:43:04 $
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#ifndef _RTL_STRING_HXX_
+#include <rtl/string.hxx>
+#endif
+#include <typeinfo>
+
+typedef struct _uno_Any uno_Any;
+typedef struct _uno_Mapping uno_Mapping;
+
+// private egcs type info structs
+
+// type_info for a simple class ( no base classes or an enum )
+struct __user_type_info : public std::type_info {
+	__user_type_info (const char *n) : type_info (n) {}
+	
+	//	 dynamic cast. built by gcc
+	virtual void* dcast (const type_info &, int, void *,
+						 const type_info * = 0, void * = 0) const;
+};
+// type_info for a class with one public, nonvirtual base class.
+
+class __si_type_info : public __user_type_info {
+	const __user_type_info &base;
+	
+public:
+	__si_type_info (const char *n, const __user_type_info &b)
+			: __user_type_info (n), base (b) { }
+	
+	//	 dynamic cast. built by gcc
+	virtual void *dcast (const type_info &, int, void *,
+						 const type_info * = 0, void * = 0) const;
+};
+
+// type_info for a general class.
+
+typedef unsigned int USItype    __attribute__ ((mode (SI)));
+
+struct __class_type_info : public __user_type_info {
+	enum access { PUBLIC = 1, PROTECTED = 2, PRIVATE = 3 };
+	
+	struct base_info {
+		const __user_type_info *base;
+		USItype offset: 29;
+		bool is_virtual: 1;
+		access access1: 2;
+	};
+	
+	const base_info *base_list;
+	size_t n_bases;
+	
+	__class_type_info (const char *name, const base_info *bl, size_t bn)
+			: __user_type_info (name), base_list (bl), n_bases (bn) {}
+	
+	//	 dynamic cast. built by gcc
+	virtual void* dcast (const type_info &, int, void *,
+						 const type_info * = 0, void * = 0) const;
+};
+
+struct cp_eh_info
+{
+	struct __eh_info 
+	{
+		void* match_function;
+		short language;
+		short version;
+	};
+	__eh_info eh_info;
+	void *value;
+	void *type;
+	void (*cleanup)(void *, int);
+	bool caught;
+	cp_eh_info *next;
+	long handlers;
+	void *original_value;
+};
+
+extern "C" {
+	void __cp_push_exception( void*, void*, void(*)(void*, int) );
+	void __sjthrow(void) __attribute__ ((__noreturn__));
+}
+
+//##################################################################################################
+//#### exceptions ##################################################################################
+//##################################################################################################
+
+namespace CPPU_CURRENT_NAMESPACE
+{
+	
+void gcc291_freebsd_intel_raiseException( uno_Any * pUnoExc, uno_Mapping * pUno2Cpp );
+void gcc291_freebsd_intel_fillUnoException( cp_eh_info*, uno_Any*, uno_Mapping * pCpp2Uno );
+
+} 
+
diff -ruN /dev/null ../bridges/source/cpp_uno/gcc2_freebsd_intel-sjlj/makefile.mk
--- /dev/null	Thu Jan  1 01:00:00 1970
+++ ../bridges/source/cpp_uno/gcc2_freebsd_intel-sjlj/makefile.mk	Tue Jun  4 12:20:58 2002
@@ -0,0 +1,109 @@
+#*************************************************************************
+#
+#   $RCSfile: makefile.mk,v $
+#
+#   $Revision: 1.1 $
+#
+#   last change: $Author: svesik $ $Date: 2001/11/12 22:43:04 $
+#
+#   The Contents of this file are made available subject to the terms of
+#   either of the following licenses
+#
+#          - GNU Lesser General Public License Version 2.1
+#          - Sun Industry Standards Source License Version 1.1
+#
+#   Sun Microsystems Inc., October, 2000
+#
+#   GNU Lesser General Public License Version 2.1
+#   =============================================
+#   Copyright 2000 by Sun Microsystems, Inc.
+#   901 San Antonio Road, Palo Alto, CA 94303, USA
+#
+#   This library is free software; you can redistribute it and/or
+#   modify it under the terms of the GNU Lesser General Public
+#   License version 2.1, as published by the Free Software Foundation.
+#
+#   This library is distributed in the hope that it will be useful,
+#   but WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#   Lesser General Public License for more details.
+#
+#   You should have received a copy of the GNU Lesser General Public
+#   License along with this library; if not, write to the Free Software
+#   Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+#   MA  02111-1307  USA
+#
+#
+#   Sun Industry Standards Source License Version 1.1
+#   =================================================
+#   The contents of this file are subject to the Sun Industry Standards
+#   Source License Version 1.1 (the "License"); You may not use this file
+#   except in compliance with the License. You may obtain a copy of the
+#   License at http://www.openoffice.org/license.html.
+#
+#   Software provided under this License is provided on an "AS IS" basis,
+#   WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+#   WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+#   MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+#   See the License for the specific provisions governing your rights and
+#   obligations concerning the Software.
+#
+#   The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+#
+#   Copyright: 2000 by Sun Microsystems, Inc.
+#
+#   All Rights Reserved.
+#
+#   Contributor(s): _______________________________________
+#
+#
+#
+#*************************************************************************
+
+PRJ=..$/..$/..
+
+PRJNAME=bridges
+TARGET=gcc2_uno
+LIBTARGET=no
+ENABLE_EXCEPTIONS=TRUE
+NO_BSYMBOLIC=TRUE
+
+# --- Settings -----------------------------------------------------
+
+.INCLUDE :  svpre.mk
+.INCLUDE :  settings.mk
+.INCLUDE :  sv.mk
+
+# --- Files --------------------------------------------------------
+
+.IF "$(COM)$(OS)$(CPU)$(COMNAME)-$(EXCEPTIONS)" == "GCCFREEBSDIgcc2-sjlj"
+
+CFLAGSNOOPT=-O0
+NOOPTFILES=$(SLO)$/uno2cpp.obj
+
+SLOFILES= \
+	$(SLO)$/except.obj		\
+	$(SLO)$/cpp2uno.obj		\
+	$(SLO)$/uno2cpp.obj
+
+SHL1TARGET= $(TARGET)
+
+SHL1DEF=    $(MISC)$/$(SHL1TARGET).def
+SHL1IMPLIB= i$(TARGET)
+SHL1VERSIONMAP=..$/..$/bridge_exports.map
+
+SHL1OBJS= \
+	$(SLO)$/except.obj		\
+	$(SLO)$/cpp2uno.obj		\
+	$(SLO)$/uno2cpp.obj
+
+SHL1STDLIBS= \
+	$(CPPULIB) \
+	$(SALLIB)
+
+.ENDIF
+
+# --- Targets ------------------------------------------------------
+
+.INCLUDE :  target.mk
+
diff -ruN /dev/null ../bridges/source/cpp_uno/gcc2_freebsd_intel-sjlj/uno2cpp.cxx
--- /dev/null	Thu Jan  1 01:00:00 1970
+++ ../bridges/source/cpp_uno/gcc2_freebsd_intel-sjlj/uno2cpp.cxx	Tue Jun  4 10:49:44 2002
@@ -0,0 +1,473 @@
+/*************************************************************************
+ *
+ *  $RCSfile: uno2cpp.cxx,v $
+ *
+ *  $Revision: 1.1 $
+ *
+ *  last change: $Author: svesik $ $Date: 2001/11/12 22:43:04 $
+ *
+ *  The Contents of this file are made available subject to the terms of
+ *  either of the following licenses
+ *
+ *         - GNU Lesser General Public License Version 2.1
+ *         - Sun Industry Standards Source License Version 1.1
+ *
+ *  Sun Microsystems Inc., October, 2000
+ *
+ *  GNU Lesser General Public License Version 2.1
+ *  =============================================
+ *  Copyright 2000 by Sun Microsystems, Inc.
+ *  901 San Antonio Road, Palo Alto, CA 94303, USA
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License version 2.1, as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ *
+ *
+ *  Sun Industry Standards Source License Version 1.1
+ *  =================================================
+ *  The contents of this file are subject to the Sun Industry Standards
+ *  Source License Version 1.1 (the "License"); You may not use this file
+ *  except in compliance with the License. You may obtain a copy of the
+ *  License at http://www.openoffice.org/license.html.
+ *
+ *  Software provided under this License is provided on an "AS IS" basis,
+ *  WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING,
+ *  WITHOUT LIMITATION, WARRANTIES THAT THE SOFTWARE IS FREE OF DEFECTS,
+ *  MERCHANTABLE, FIT FOR A PARTICULAR PURPOSE, OR NON-INFRINGING.
+ *  See the License for the specific provisions governing your rights and
+ *  obligations concerning the Software.
+ *
+ *  The Initial Developer of the Original Code is: Sun Microsystems, Inc.
+ *
+ *  Copyright: 2000 by Sun Microsystems, Inc.
+ *
+ *  All Rights Reserved.
+ *
+ *  Contributor(s): _______________________________________
+ *
+ *
+ ************************************************************************/
+
+#include <stdlib.h>
+#ifndef _RTL_ALLOC_H_
+#include <rtl/alloc.h>
+#endif
+
+#ifndef _UNO_DATA_H_
+#include <uno/data.h>
+#endif
+#ifndef _BRIDGES_CPP_UNO_BRIDGE_HXX_
+#include <bridges/cpp_uno/bridge.hxx>
+#endif
+#ifndef _BRIDGES_CPP_UNO_TYPE_MISC_HXX_
+#include <bridges/cpp_uno/type_misc.hxx>
+#endif
+
+#include "gcc2_freebsd_intel.hxx"
+
+using namespace rtl;
+using namespace com::sun::star::uno;
+
+namespace CPPU_CURRENT_NAMESPACE
+{
+
+//==================================================================================================
+static void callVirtualMethod( void * pThis,
+									  sal_Int32 nVtableIndex,
+									  void * pRegisterReturn,
+									  typelib_TypeClass eReturnType,
+									  sal_Int32 * pStackLongs,
+									  sal_Int32 nStackLongs,
+									  sal_Int32 nThisOffset )
+{
+	// parameter list is mixed list of * and values
+	// reference parameters are pointers
+
+	OSL_ENSURE( pStackLongs && pThis, "### null ptr!" );
+	OSL_ENSURE( (sizeof(void *) == 4) &&
+				 (sizeof(sal_Int32) == 4), "### unexpected size of int!" );
+	OSL_ENSURE( nStackLongs && pStackLongs, "### no stack in callVirtualMethod !" );
+
+	volatile long edx = 0, eax = 0; // for register returns
+	__asm__ (
+		// copy values
+		"pushl %%edx\n\t"
+		"pushl %%ecx\n\t"
+		"pushl %%eax\n\t"
+		"mov  %0, %%eax\n\t"
+		"mov  %%eax, %%edx\n\t"
+		"dec  %%edx\n\t"
+		"shl  $2, %%edx\n\t"
+		"add  %1, %%edx\n"
+		"Lcopy:\n\t"
+		"mov  0(%%edx), %%ecx\n\t"
+		"sub  $4, %%edx\n\t"
+		"push %%ecx\n\t"
+		"dec  %%eax\n\t"
+		"jne  Lcopy\n"
+		"Lcall:\n\t"
+		// do the actual call
+		"mov  %2, %%edx\n\t"
+		"mov  0(%%edx), %%edx\n\t"
+		"mov  %3, %%eax\n\t"
+		"add  $1, %%eax\n\t" // first entry is reserved
+		"shl  $3, %%eax\n\t"
+		"add  %%eax, %%edx\n\t"
+		"mov %4, %%eax\n\t"
+		"movswl (%%edx), %%ecx\n\t"
+                "add  %%esp, %%eax\n\t"
+                "add  %%ecx, (%%eax)\n\t"
+		"mov  4(%%edx), %%edx\n\t"
+		"call *%%edx\n\t"
+		// save return registers
+ 		"mov  %%eax, %5\n\t"
+ 		"mov  %%edx, %6\n\t"
+		// cleanup stack
+ 		"mov  %0, %%eax\n\t"
+ 		"shl  $2, %%eax\n\t"
+ 		"add  %%eax, %%esp\n\t"
+		"popl %%eax\n\t"
+		"popl %%ecx\n\t"
+		"popl %%edx\n\t"
+		: : "m"(nStackLongs), "m"(pStackLongs), "m"(pThis), "m"(nVtableIndex),
+                    "m"(nThisOffset), "m"(eax), "m"(edx) );
+	switch( eReturnType )
+	{
+		case typelib_TypeClass_HYPER:
+		case typelib_TypeClass_UNSIGNED_HYPER:
+			((long*)pRegisterReturn)[1] = edx;
+		case typelib_TypeClass_LONG:
+		case typelib_TypeClass_UNSIGNED_LONG:
+		case typelib_TypeClass_CHAR:
+		case typelib_TypeClass_ENUM:
+			((long*)pRegisterReturn)[0] = eax;
+			break;
+		case typelib_TypeClass_SHORT:
+		case typelib_TypeClass_UNSIGNED_SHORT:
+			*(unsigned short*)pRegisterReturn = eax;
+			break;
+		case typelib_TypeClass_BOOLEAN:
+		case typelib_TypeClass_BYTE:
+			*(unsigned char*)pRegisterReturn = eax;
+			break;
+		case typelib_TypeClass_FLOAT:
+			__asm__ (
+				"fstps %0\n\t"
+				: : "m"(*(char *)pRegisterReturn) );
+			break;
+		case typelib_TypeClass_DOUBLE:
+			__asm__ (
+				"fstpl %0\n\t"
+				: : "m"(*(char *)pRegisterReturn) );
+			break;
+	}
+}
+
+//================================================================================================== 
+static void cpp_call(
+	cppu_unoInterfaceProxy * pThis,
+	sal_Int32 nVtableCall,
+	typelib_TypeDescriptionReference * pReturnTypeRef,
+	sal_Int32 nParams, typelib_MethodParameter * pParams,
+	void * pUnoReturn, void * pUnoArgs[], uno_Any ** ppUnoExc )
+{
+  	// max space for: [complex ret ptr], values|ptr ...
+  	char * pCppStack		=
+  		(char *)alloca( sizeof(sal_Int32) + ((nParams+2) * sizeof(sal_Int64)) );
+  	char * pCppStackStart	= pCppStack;
+	
+	// return
+	typelib_TypeDescription * pReturnTypeDescr = 0;
+	TYPELIB_DANGER_GET( &pReturnTypeDescr, pReturnTypeRef );
+	OSL_ENSURE( pReturnTypeDescr, "### expected return type description!" );
+	
+	void * pCppReturn = 0; // if != 0 && != pUnoReturn, needs reconversion
+
+        sal_Int32 nThisOffset = 0;
+	
+	if (pReturnTypeDescr)
+	{
+		if (cppu_isSimpleType( pReturnTypeDescr ))
+		{
+			pCppReturn = pUnoReturn; // direct way for simple types
+		}
+		else
+		{
+			// complex return via ptr
+			pCppReturn = *(void **)pCppStack = (cppu_relatesToInterface( pReturnTypeDescr )
+												? alloca( pReturnTypeDescr->nSize )
+												: pUnoReturn); // direct way
+			pCppStack  += sizeof(void *);
+                        nThisOffset = sizeof(void *);
+		}
+	}
+	// push this
+	*(void**)pCppStack = pThis->pCppI;
+	pCppStack += sizeof( void* );
+
+	// stack space
+	OSL_ENSURE( sizeof(void *) == sizeof(sal_Int32), "### unexpected size!" );
+	// args
+	void ** pCppArgs  = (void **)alloca( 3 * sizeof(void *) * nParams );
+	// indizes of values this have to be converted (interface conversion cpp<=>uno)
+	sal_Int32 * pTempIndizes = (sal_Int32 *)(pCppArgs + nParams);
+	// type descriptions for reconversions
+	typelib_TypeDescription ** ppTempParamTypeDescr = (typelib_TypeDescription **)(pCppArgs + (2 * nParams));
+	
+	sal_Int32 nTempIndizes   = 0;
+	
+	for ( sal_Int32 nPos = 0; nPos < nParams; ++nPos )
+	{
+		const typelib_MethodParameter & rParam = pParams[nPos];
+		typelib_TypeDescription * pParamTypeDescr = 0;
+		TYPELIB_DANGER_GET( &pParamTypeDescr, rParam.pTypeRef );
+		
+		if (!rParam.bOut && cppu_isSimpleType( pParamTypeDescr ))
+		{
+			uno_copyAndConvertData( pCppArgs[nPos] = pCppStack, pUnoArgs[nPos], pParamTypeDescr,
+									&pThis->pBridge->aUno2Cpp );
+			
+			switch (pParamTypeDescr->eTypeClass)
+			{
+			case typelib_TypeClass_HYPER:
+			case typelib_TypeClass_UNSIGNED_HYPER:
+			case typelib_TypeClass_DOUBLE:
+				pCppStack += sizeof(sal_Int32); // extra long
+			}
+			// no longer needed
+			TYPELIB_DANGER_RELEASE( pParamTypeDescr );
+		}
+		else // ptr to complex value | ref
+		{
+			if (! rParam.bIn) // is pure out
+			{
+				// cpp out is constructed mem, uno out is not!
+				uno_constructData(
+					*(void **)pCppStack = pCppArgs[nPos] = alloca( pParamTypeDescr->nSize ),
+					pParamTypeDescr );
+				pTempIndizes[nTempIndizes] = nPos; // default constructed for cpp call
+				// will be released at reconversion
+				ppTempParamTypeDescr[nTempIndizes++] = pParamTypeDescr;
+			}
+			// is in/inout
+			else if (cppu_relatesToInterface( pParamTypeDescr ))
+			{
+				uno_copyAndConvertData(
+					*(void **)pCppStack = pCppArgs[nPos] = alloca( pParamTypeDescr->nSize ),
+					pUnoArgs[nPos], pParamTypeDescr, &pThis->pBridge->aUno2Cpp );
+				
+				pTempIndizes[nTempIndizes] = nPos; // has to be reconverted
+				// will be released at reconversion
+				ppTempParamTypeDescr[nTempIndizes++] = pParamTypeDescr;
+			}
+			else // direct way
+			{
+				*(void **)pCppStack = pCppArgs[nPos] = pUnoArgs[nPos];
+				// no longer needed
+				TYPELIB_DANGER_RELEASE( pParamTypeDescr );
+			}
+		}
+		pCppStack += sizeof(sal_Int32); // standard parameter length
+	}
+
+	try
+	{
+		OSL_ENSURE( !( (pCppStack - pCppStackStart ) & 3), "UNALIGNED STACK !!! (Please DO panic" );
+		callVirtualMethod(
+			pThis->pCppI, nVtableCall,
+			pCppReturn, pReturnTypeDescr->eTypeClass,
+			(sal_Int32 *)pCppStackStart, (pCppStack - pCppStackStart) / sizeof(sal_Int32),
+			nThisOffset);
+		// NO exception occured...
+		*ppUnoExc = 0;
+		
+		// reconvert temporary params
+		for ( ; nTempIndizes--; )
+		{
+			sal_Int32 nIndex = pTempIndizes[nTempIndizes];
+			typelib_TypeDescription * pParamTypeDescr = ppTempParamTypeDescr[nTempIndizes];
+			
+			if (pParams[nIndex].bIn)
+			{
+				if (pParams[nIndex].bOut) // inout
+				{
+					uno_destructData( pUnoArgs[nIndex], pParamTypeDescr, 0 ); // destroy uno value
+					uno_copyAndConvertData( pUnoArgs[nIndex], pCppArgs[nIndex], pParamTypeDescr,
+											&pThis->pBridge->aCpp2Uno );
+				}
+			}
+			else // pure out
+			{
+				uno_copyAndConvertData( pUnoArgs[nIndex], pCppArgs[nIndex], pParamTypeDescr,
+										&pThis->pBridge->aCpp2Uno );
+			}
+			// destroy temp cpp param => cpp: every param was constructed
+			uno_destructData( pCppArgs[nIndex], pParamTypeDescr, cpp_release );
+			
+			TYPELIB_DANGER_RELEASE( pParamTypeDescr );
+		}
+		// return value
+		if (pCppReturn && pUnoReturn != pCppReturn)
+		{
+			uno_copyAndConvertData( pUnoReturn, pCppReturn, pReturnTypeDescr,
+									&pThis->pBridge->aCpp2Uno );
+			uno_destructData( pCppReturn, pReturnTypeDescr, cpp_release );
+		}
+	}
+ 	catch( ... )
+ 	{
+  		// get exception
+  		cp_eh_info* pEHInfo = (cp_eh_info*)__cp_eh_info();
+		gcc291_freebsd_intel_fillUnoException( pEHInfo, *ppUnoExc, &pThis->pBridge->aCpp2Uno );
+
+		// temporary params
+		for ( ; nTempIndizes--; )
+		{
+			sal_Int32 nIndex = pTempIndizes[nTempIndizes];
+			// destroy temp cpp param => cpp: every param was constructed
+			uno_destructData( pCppArgs[nIndex], ppTempParamTypeDescr[nTempIndizes], cpp_release );
+			TYPELIB_DANGER_RELEASE( ppTempParamTypeDescr[nTempIndizes] );
+		}
+		// return type
+		if (pReturnTypeDescr)
+			TYPELIB_DANGER_RELEASE( pReturnTypeDescr );
+	}
+}
+
+
+//==================================================================================================
+void SAL_CALL cppu_unoInterfaceProxy_dispatch(
+	uno_Interface * pUnoI, const typelib_TypeDescription * pMemberDescr,
+	void * pReturn, void * pArgs[], uno_Any ** ppException ) throw ()
+{
+	// is my surrogate
+	cppu_unoInterfaceProxy * pThis = (cppu_unoInterfaceProxy *)pUnoI;
+	typelib_InterfaceTypeDescription * pTypeDescr = pThis->pTypeDescr;
+	
+	switch (pMemberDescr->eTypeClass)
+	{
+	case typelib_TypeClass_INTERFACE_ATTRIBUTE:
+	{
+		// determine vtable call index
+		sal_Int32 nMemberPos = ((typelib_InterfaceMemberTypeDescription *)pMemberDescr)->nPosition;
+		OSL_ENSURE( nMemberPos < pTypeDescr->nAllMembers, "### member pos out of range!" );
+		
+		sal_Int32 nVtableCall = pTypeDescr->pMapMemberIndexToFunctionIndex[nMemberPos];
+		OSL_ENSURE( nVtableCall < pTypeDescr->nMapFunctionIndexToMemberIndex, "### illegal vtable index!" );
+		
+		if (pReturn)
+		{
+			// dependent dispatch
+			cpp_call(
+				pThis, nVtableCall,
+				((typelib_InterfaceAttributeTypeDescription *)pMemberDescr)->pAttributeTypeRef,
+				0, 0, // no params
+				pReturn, pArgs, ppException );
+		}
+		else
+		{
+			// is SET
+			typelib_MethodParameter aParam;
+			aParam.pTypeRef =
+				((typelib_InterfaceAttributeTypeDescription *)pMemberDescr)->pAttributeTypeRef;
+			aParam.bIn		= sal_True;
+			aParam.bOut		= sal_False;
+
+			typelib_TypeDescriptionReference * pReturnTypeRef = 0;
+			OUString aVoidName( RTL_CONSTASCII_USTRINGPARAM("void") );
+			typelib_typedescriptionreference_new(
+				&pReturnTypeRef, typelib_TypeClass_VOID, aVoidName.pData );
+			
+			// dependent dispatch
+			cpp_call(
+				pThis, nVtableCall +1, // get, then set method
+				pReturnTypeRef,
+				1, &aParam,
+				pReturn, pArgs, ppException );
+			
+			typelib_typedescriptionreference_release( pReturnTypeRef );
+		}
+		
+		break;
+	}
+	case typelib_TypeClass_INTERFACE_METHOD:
+	{
+		// determine vtable call index
+		sal_Int32 nMemberPos = ((typelib_InterfaceMemberTypeDescription *)pMemberDescr)->nPosition;
+		OSL_ENSURE( nMemberPos < pTypeDescr->nAllMembers, "### member pos out of range!" );
+		
+		sal_Int32 nVtableCall = pTypeDescr->pMapMemberIndexToFunctionIndex[nMemberPos];
+		OSL_ENSURE( nVtableCall < pTypeDescr->nMapFunctionIndexToMemberIndex, "### illegal vtable index!" );
+		
+		switch (nVtableCall)
+		{
+			// standard calls
+		case 1: // acquire uno interface
+			(*pUnoI->acquire)( pUnoI );
+			*ppException = 0;
+			break;
+		case 2: // release uno interface
+			(*pUnoI->release)( pUnoI );
+			*ppException = 0;
+			break;
+		case 0: // queryInterface() opt
+		{
+			typelib_TypeDescription * pTD = 0;
+			TYPELIB_DANGER_GET( &pTD, reinterpret_cast< Type * >( pArgs[0] )->getTypeLibType() );
+			if (pTD)
+			{
+                uno_Interface * pInterface = 0;
+                (*pThis->pBridge->pUnoEnv->getRegisteredInterface)(
+                    pThis->pBridge->pUnoEnv,
+                    (void **)&pInterface, pThis->oid.pData, (typelib_InterfaceTypeDescription *)pTD );
+			
+                if (pInterface)
+                {
+                    ::uno_any_construct(
+                        reinterpret_cast< uno_Any * >( pReturn ),
+                        &pInterface, pTD, 0 );
+                    (*pInterface->release)( pInterface );
+                    TYPELIB_DANGER_RELEASE( pTD );
+                    *ppException = 0;
+                    break;
+                }
+                TYPELIB_DANGER_RELEASE( pTD );
+            }
+		} // else perform queryInterface()
+		default:
+			// dependent dispatch
+			cpp_call(
+				pThis, nVtableCall,
+				((typelib_InterfaceMethodTypeDescription *)pMemberDescr)->pReturnTypeRef,
+				((typelib_InterfaceMethodTypeDescription *)pMemberDescr)->nParams,
+				((typelib_InterfaceMethodTypeDescription *)pMemberDescr)->pParams,
+				pReturn, pArgs, ppException );
+		}
+		break;
+	}
+	default:
+	{
+		::com::sun::star::uno::RuntimeException aExc(
+			OUString( RTL_CONSTASCII_USTRINGPARAM("illegal member type description!") ),
+			::com::sun::star::uno::Reference< ::com::sun::star::uno::XInterface >() );
+		
+		Type const & rExcType = ::getCppuType( &aExc );
+		// binary identical null reference
+		::uno_type_any_construct( *ppException, &aExc, rExcType.getTypeLibType(), 0 );
+	}
+	}
+}
+
+}
+
