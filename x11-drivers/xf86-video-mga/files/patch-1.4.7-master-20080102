diff --git src/mga_driver.c src/mga_driver.c
index d9b786f..be26e89 100644
--- src/mga_driver.c
+++ src/mga_driver.c
@@ -2775,30 +2775,31 @@ MGAMapMem(ScrnInfoPtr pScrn)
     MGAPtr pMga = MGAPTR(pScrn);
 #ifdef XSERVER_LIBPCIACCESS
     struct pci_device *const dev = pMga->PciInfo;
-    int err;
+    struct pci_mem_region *region;
+    void **memory[2];
+    int i, err;
 #endif
 
 
     if (!pMga->FBDev) {
 #ifdef XSERVER_LIBPCIACCESS
-	err = pci_device_map_region(dev, 0, TRUE);
-	if (err) {
-	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-		       "Unable to map BAR 0.  %s (%d)\n",
-		       strerror(err), err);
-	    return FALSE;
-	}
+        memory[pMga->io_bar] = &pMga->IOBase;
+        memory[pMga->framebuffer_bar] = &pMga->FbBase;
 
-	err = pci_device_map_region(dev, 1, TRUE);
-	if (err) {
-	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-		       "Unable to map BAR 1.  %s (%d)\n",
-		       strerror(err), err);
-	    return FALSE;
-	}
+        for (i = 0; i < 2; i++) {
+            region = &dev->regions[i];
+            err = pci_device_map_range(dev,
+                                       region->base_addr, region->size,
+                                       PCI_DEV_MAP_FLAG_WRITABLE,
+                                       memory[i]);
 
-	pMga->IOBase = dev->regions[ pMga->io_bar ].memory;
-	pMga->FbBase = dev->regions[ pMga->framebuffer_bar ].memory;
+            if (err) {
+                xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
+                           "Unable to map BAR %i.  %s (%d)\n",
+                           i, strerror(err), err);
+                return FALSE;
+            }
+        }
 #else
 	/*
 	 * For Alpha, we need to map SPARSE memory, since we need
@@ -2839,15 +2840,17 @@ MGAMapMem(ScrnInfoPtr pScrn)
     pMga->ILOADBase = NULL;
     if (pMga->iload_bar != -1) {
 #ifdef XSERVER_LIBPCIACCESS
-	err = pci_device_map_region(dev, pMga->iload_bar, TRUE);
+        region = &dev->regions[pMga->iload_bar];
+        err = pci_device_map_range(dev,
+                                   region->base_addr, region->size,
+                                   PCI_DEV_MAP_FLAG_WRITABLE,
+                                   (void *) &pMga->ILOADBase);
 	if (err) {
 	    xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
 		       "Unable to map BAR 2 (ILOAD region).  %s (%d)\n",
 		       strerror(err), err);
 	    return FALSE;
 	}
-
-	pMga->ILOADBase = dev->regions[pMga->iload_bar].memory;
 #else
 	pMga->ILOADBase = xf86MapPciMem(pScrn->scrnIndex,
 					VIDMEM_MMIO | VIDMEM_MMIO_32BIT |
@@ -2877,8 +2880,10 @@ MGAUnmapMem(ScrnInfoPtr pScrn)
     
     if (!pMga->FBDev) {
 #ifdef XSERVER_LIBPCIACCESS
-	pci_device_unmap_region(dev, 0);
-	pci_device_unmap_region(dev, 1);
+        pci_device_unmap_range(dev, pMga->IOBase, 
+			       dev->regions[pMga->io_bar].size);
+        pci_device_unmap_range(dev, pMga->FbBase, 
+			       dev->regions[pMga->framebuffer_bar].size);
 #else
 	xf86UnMapVidMem(pScrn->scrnIndex, (pointer)pMga->IOBase, 0x4000);
 	xf86UnMapVidMem(pScrn->scrnIndex, (pointer)pMga->FbBase, pMga->FbMapSize);
@@ -2889,15 +2894,10 @@ MGAUnmapMem(ScrnInfoPtr pScrn)
 	fbdevHWUnmapMMIO(pScrn);
     }
 
-    if ((pMga->iload_bar != -1)
+    if ((pMga->iload_bar != -1) && (pMga->ILOADBase != NULL)) {
 #ifdef XSERVER_LIBPCIACCESS
-	 && (dev->regions[pMga->iload_bar].memory != NULL)
-#else
-	 && (pMga->ILOADBase != NULL)
-#endif
-	) {
-#ifdef XSERVER_LIBPCIACCESS
-	pci_device_unmap_region(dev, pMga->iload_bar);
+        pci_device_unmap_range(dev, pMga->ILOADBase,
+			       dev->regions[pMga->iload_bar].size);
 #else
 	xf86UnMapVidMem(pScrn->scrnIndex, (pointer)pMga->ILOADBase, 0x800000);
 #endif
@@ -4286,6 +4286,13 @@ MGAValidMode(int scrnIndex, DisplayModePtr mode, Bool verbose, int flags)
     ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
     MGAPtr pMga = MGAPTR(pScrn);
 
+    if (pMga->Chipset == PCI_CHIP_MGAG200_SE_A_PCI) {
+	if (mode->HDisplay > 1600)
+	    return MODE_VIRTUAL_X;
+	if (mode->VDisplay > 1200)
+	    return MODE_VIRTUAL_Y;
+    }
+
     lace = 1 + ((mode->Flags & V_INTERLACE) != 0);
 
     if ((mode->CrtcHDisplay <= 2048) &&
diff --git src/mga_exa.c src/mga_exa.c
index bfb78e7..9321452 100644
--- src/mga_exa.c
+++ src/mga_exa.c
@@ -758,6 +758,7 @@ mgaWaitMarker(ScreenPtr pScreen, int marker)
     while (INREG (MGAREG_Status) & 0x10000);
 }
 
+#ifdef XF86DRI
 static void
 init_dri(ScrnInfoPtr pScrn)
 {
@@ -831,6 +832,7 @@ init_dri(ScrnInfoPtr pScrn)
                        MGA_BUFFER_ALIGN) & ~MGA_BUFFER_ALIGN;
     dri->backPitch = widthBytes;
 }
+#endif /* XF86DRI */
 
 Bool
 mgaExaInit(ScreenPtr pScreen)
@@ -891,8 +893,10 @@ mgaExaInit(ScreenPtr pScreen)
     pExa->UploadToScreen = mgaUploadToScreen;
     pExa->DownloadFromScreen = mgaDownloadFromScreen;
 
+#ifdef XF86DRI
     if (pMga->directRenderingEnabled)
         init_dri(pScrn);
+#endif
 
     return exaDriverInit(pScreen, pExa);
 }
