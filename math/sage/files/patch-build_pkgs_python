diff -urN build/pkgs/python/checksums.ini build/pkgs/python/checksums.ini
--- build/pkgs/python/checksums.ini	2014-05-30 23:04:24.000000000 +0000
+++ build/pkgs/python/checksums.ini	2014-05-30 22:51:28.000000000 +0000
@@ -1,4 +1,4 @@
-tarball=python-VERSION.tar.bz2
-sha1=6b901ace46a66ea4ea01380cb7dd00d9ac9c5deb
-md5=30b74f145e3d94923f79fd10a0f64490
-cksum=3699497017
+tarball=Python-VERSION.tar.xz
+sha1=8321636af2acbeaa68fc635d7dda7369ed446a80
+md5=bcf93efa8eaf383c98ed3ce40b763497
+cksum=3044260985
diff -urN build/pkgs/python/package-version.txt build/pkgs/python/package-version.txt
--- build/pkgs/python/package-version.txt	2014-05-30 23:04:24.000000000 +0000
+++ build/pkgs/python/package-version.txt	2014-05-30 22:51:43.000000000 +0000
@@ -1 +1 @@
-2.7.5.p2
+2.7.6.p0
diff -urN build/pkgs/python/patches/inc_lib_dirs-issue_17990.patch build/pkgs/python/patches/inc_lib_dirs-issue_17990.patch
--- build/pkgs/python/patches/inc_lib_dirs-issue_17990.patch	2014-05-30 23:04:24.000000000 +0000
+++ build/pkgs/python/patches/inc_lib_dirs-issue_17990.patch	1970-01-01 00:00:00.000000000 +0000
@@ -1,18 +0,0 @@
-diff --git a/setup.py b/setup.py
---- a/setup.py
-+++ b/setup.py
-@@ -437,9 +437,11 @@
- 
-     def detect_modules(self):
-         # Ensure that /usr/local is always used
--        add_dir_to_list(self.compiler.library_dirs, '/usr/local/lib')
--        add_dir_to_list(self.compiler.include_dirs, '/usr/local/include')
--        self.add_gcc_paths()
-+        if not cross_compiling:
-+            add_dir_to_list(self.compiler.library_dirs, '/usr/local/lib')
-+            add_dir_to_list(self.compiler.include_dirs, '/usr/local/include')
-+        if cross_compiling:
-+            self.add_gcc_paths()
-         self.add_multiarch_paths()
- 
-         # Add paths specified in the environment variables LDFLAGS and
diff -urN build/pkgs/python/patches/re_unsigned_ptrdiff-issue_17016.patch build/pkgs/python/patches/re_unsigned_ptrdiff-issue_17016.patch
--- build/pkgs/python/patches/re_unsigned_ptrdiff-issue_17016.patch	2014-05-30 23:04:24.000000000 +0000
+++ build/pkgs/python/patches/re_unsigned_ptrdiff-issue_17016.patch	1970-01-01 00:00:00.000000000 +0000
@@ -1,21 +0,0 @@
-diff -r d91da96a55bf Modules/_sre.c
---- src/Modules/_sre.c	Thu May 16 22:47:47 2013 +0100
-+++ src/Modules/_sre.c	Fri May 17 21:02:48 2013 +0300
-@@ -1028,7 +1028,7 @@
-             TRACE(("|%p|%p|REPEAT_ONE %d %d\n", ctx->pattern, ctx->ptr,
-                    ctx->pattern[1], ctx->pattern[2]));
- 
--            if (ctx->pattern[1] > end - ctx->ptr)
-+            if ((Py_ssize_t) ctx->pattern[1] > end - ctx->ptr)
-                 RETURN_FAILURE; /* cannot match */
- 
-             state->ptr = ctx->ptr;
-@@ -1111,7 +1111,7 @@
-             TRACE(("|%p|%p|MIN_REPEAT_ONE %d %d\n", ctx->pattern, ctx->ptr,
-                    ctx->pattern[1], ctx->pattern[2]));
- 
--            if (ctx->pattern[1] > end - ctx->ptr)
-+            if ((Py_ssize_t) ctx->pattern[1] > end - ctx->ptr)
-                 RETURN_FAILURE; /* cannot match */
- 
-             state->ptr = ctx->ptr;
diff -urN build/pkgs/python/patches/uuid.patch build/pkgs/python/patches/uuid.patch
--- build/pkgs/python/patches/uuid.patch	2014-05-30 23:04:24.000000000 +0000
+++ build/pkgs/python/patches/uuid.patch	1970-01-01 00:00:00.000000000 +0000
@@ -1,677 +0,0 @@
-diff -druN python-2.7.5.orig/Lib/test/test_uuid.py python-2.7.5/Lib/test/test_uuid.py
---- python-2.7.5.orig/Lib/test/test_uuid.py	2013-05-12 05:32:48.000000000 +0200
-+++ python-2.7.5/Lib/test/test_uuid.py	2014-04-10 10:35:52.009367700 +0200
-@@ -365,6 +365,7 @@
- 
-         # Make sure the generated UUIDs are actually unique.
-         uuids = {}
-+
-         for u in [uuid.uuid1() for i in range(1000)]:
-             uuids[u] = 1
-         equal(len(uuids.keys()), 1000)
-diff -druN python-2.7.5.orig/Lib/test/test_uuid.py.orig python-2.7.5/Lib/test/test_uuid.py.orig
---- python-2.7.5.orig/Lib/test/test_uuid.py.orig	1970-01-01 01:00:00.000000000 +0100
-+++ python-2.7.5/Lib/test/test_uuid.py.orig	2013-05-12 05:32:48.000000000 +0200
-@@ -0,0 +1,482 @@
-+from unittest import TestCase
-+from test import test_support
-+import uuid
-+
-+def importable(name):
-+    try:
-+        __import__(name)
-+        return True
-+    except:
-+        return False
-+
-+class TestUUID(TestCase):
-+    last_node = None
-+    source2node = {}
-+
-+    def test_UUID(self):
-+        equal = self.assertEqual
-+        ascending = []
-+        for (string, curly, hex, bytes, bytes_le, fields, integer, urn,
-+             time, clock_seq, variant, version) in [
-+            ('00000000-0000-0000-0000-000000000000',
-+             '{00000000-0000-0000-0000-000000000000}',
-+             '00000000000000000000000000000000',
-+             '\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0',
-+             '\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0',
-+             (0, 0, 0, 0, 0, 0),
-+             0,
-+             'urn:uuid:00000000-0000-0000-0000-000000000000',
-+             0, 0, uuid.RESERVED_NCS, None),
-+            ('00010203-0405-0607-0809-0a0b0c0d0e0f',
-+             '{00010203-0405-0607-0809-0a0b0c0d0e0f}',
-+             '000102030405060708090a0b0c0d0e0f',
-+             '\0\x01\x02\x03\x04\x05\x06\x07\x08\t\n\x0b\x0c\x0d\x0e\x0f',
-+             '\x03\x02\x01\0\x05\x04\x07\x06\x08\t\n\x0b\x0c\x0d\x0e\x0f',
-+             (0x00010203L, 0x0405, 0x0607, 8, 9, 0x0a0b0c0d0e0fL),
-+             0x000102030405060708090a0b0c0d0e0fL,
-+             'urn:uuid:00010203-0405-0607-0809-0a0b0c0d0e0f',
-+             0x607040500010203L, 0x809, uuid.RESERVED_NCS, None),
-+            ('02d9e6d5-9467-382e-8f9b-9300a64ac3cd',
-+             '{02d9e6d5-9467-382e-8f9b-9300a64ac3cd}',
-+             '02d9e6d59467382e8f9b9300a64ac3cd',
-+             '\x02\xd9\xe6\xd5\x94\x67\x38\x2e\x8f\x9b\x93\x00\xa6\x4a\xc3\xcd',
-+             '\xd5\xe6\xd9\x02\x67\x94\x2e\x38\x8f\x9b\x93\x00\xa6\x4a\xc3\xcd',
-+             (0x02d9e6d5L, 0x9467, 0x382e, 0x8f, 0x9b, 0x9300a64ac3cdL),
-+             0x02d9e6d59467382e8f9b9300a64ac3cdL,
-+             'urn:uuid:02d9e6d5-9467-382e-8f9b-9300a64ac3cd',
-+             0x82e946702d9e6d5L, 0xf9b, uuid.RFC_4122, 3),
-+            ('12345678-1234-5678-1234-567812345678',
-+             '{12345678-1234-5678-1234-567812345678}',
-+             '12345678123456781234567812345678',
-+             '\x12\x34\x56\x78'*4,
-+             '\x78\x56\x34\x12\x34\x12\x78\x56\x12\x34\x56\x78\x12\x34\x56\x78',
-+             (0x12345678, 0x1234, 0x5678, 0x12, 0x34, 0x567812345678),
-+             0x12345678123456781234567812345678,
-+             'urn:uuid:12345678-1234-5678-1234-567812345678',
-+             0x678123412345678L, 0x1234, uuid.RESERVED_NCS, None),
-+            ('6ba7b810-9dad-11d1-80b4-00c04fd430c8',
-+             '{6ba7b810-9dad-11d1-80b4-00c04fd430c8}',
-+             '6ba7b8109dad11d180b400c04fd430c8',
-+             '\x6b\xa7\xb8\x10\x9d\xad\x11\xd1\x80\xb4\x00\xc0\x4f\xd4\x30\xc8',
-+             '\x10\xb8\xa7\x6b\xad\x9d\xd1\x11\x80\xb4\x00\xc0\x4f\xd4\x30\xc8',
-+             (0x6ba7b810L, 0x9dad, 0x11d1, 0x80, 0xb4, 0x00c04fd430c8L),
-+             0x6ba7b8109dad11d180b400c04fd430c8L,
-+             'urn:uuid:6ba7b810-9dad-11d1-80b4-00c04fd430c8',
-+             0x1d19dad6ba7b810L, 0xb4, uuid.RFC_4122, 1),
-+            ('6ba7b811-9dad-11d1-80b4-00c04fd430c8',
-+             '{6ba7b811-9dad-11d1-80b4-00c04fd430c8}',
-+             '6ba7b8119dad11d180b400c04fd430c8',
-+             '\x6b\xa7\xb8\x11\x9d\xad\x11\xd1\x80\xb4\x00\xc0\x4f\xd4\x30\xc8',
-+             '\x11\xb8\xa7\x6b\xad\x9d\xd1\x11\x80\xb4\x00\xc0\x4f\xd4\x30\xc8',
-+             (0x6ba7b811L, 0x9dad, 0x11d1, 0x80, 0xb4, 0x00c04fd430c8L),
-+             0x6ba7b8119dad11d180b400c04fd430c8L,
-+             'urn:uuid:6ba7b811-9dad-11d1-80b4-00c04fd430c8',
-+             0x1d19dad6ba7b811L, 0xb4, uuid.RFC_4122, 1),
-+            ('6ba7b812-9dad-11d1-80b4-00c04fd430c8',
-+             '{6ba7b812-9dad-11d1-80b4-00c04fd430c8}',
-+             '6ba7b8129dad11d180b400c04fd430c8',
-+             '\x6b\xa7\xb8\x12\x9d\xad\x11\xd1\x80\xb4\x00\xc0\x4f\xd4\x30\xc8',
-+             '\x12\xb8\xa7\x6b\xad\x9d\xd1\x11\x80\xb4\x00\xc0\x4f\xd4\x30\xc8',
-+             (0x6ba7b812L, 0x9dad, 0x11d1, 0x80, 0xb4, 0x00c04fd430c8L),
-+             0x6ba7b8129dad11d180b400c04fd430c8L,
-+             'urn:uuid:6ba7b812-9dad-11d1-80b4-00c04fd430c8',
-+             0x1d19dad6ba7b812L, 0xb4, uuid.RFC_4122, 1),
-+            ('6ba7b814-9dad-11d1-80b4-00c04fd430c8',
-+             '{6ba7b814-9dad-11d1-80b4-00c04fd430c8}',
-+             '6ba7b8149dad11d180b400c04fd430c8',
-+             '\x6b\xa7\xb8\x14\x9d\xad\x11\xd1\x80\xb4\x00\xc0\x4f\xd4\x30\xc8',
-+             '\x14\xb8\xa7\x6b\xad\x9d\xd1\x11\x80\xb4\x00\xc0\x4f\xd4\x30\xc8',
-+             (0x6ba7b814L, 0x9dad, 0x11d1, 0x80, 0xb4, 0x00c04fd430c8L),
-+             0x6ba7b8149dad11d180b400c04fd430c8L,
-+             'urn:uuid:6ba7b814-9dad-11d1-80b4-00c04fd430c8',
-+             0x1d19dad6ba7b814L, 0xb4, uuid.RFC_4122, 1),
-+            ('7d444840-9dc0-11d1-b245-5ffdce74fad2',
-+             '{7d444840-9dc0-11d1-b245-5ffdce74fad2}',
-+             '7d4448409dc011d1b2455ffdce74fad2',
-+             '\x7d\x44\x48\x40\x9d\xc0\x11\xd1\xb2\x45\x5f\xfd\xce\x74\xfa\xd2',
-+             '\x40\x48\x44\x7d\xc0\x9d\xd1\x11\xb2\x45\x5f\xfd\xce\x74\xfa\xd2',
-+             (0x7d444840L, 0x9dc0, 0x11d1, 0xb2, 0x45, 0x5ffdce74fad2L),
-+             0x7d4448409dc011d1b2455ffdce74fad2L,
-+             'urn:uuid:7d444840-9dc0-11d1-b245-5ffdce74fad2',
-+             0x1d19dc07d444840L, 0x3245, uuid.RFC_4122, 1),
-+            ('e902893a-9d22-3c7e-a7b8-d6e313b71d9f',
-+             '{e902893a-9d22-3c7e-a7b8-d6e313b71d9f}',
-+             'e902893a9d223c7ea7b8d6e313b71d9f',
-+             '\xe9\x02\x89\x3a\x9d\x22\x3c\x7e\xa7\xb8\xd6\xe3\x13\xb7\x1d\x9f',
-+             '\x3a\x89\x02\xe9\x22\x9d\x7e\x3c\xa7\xb8\xd6\xe3\x13\xb7\x1d\x9f',
-+             (0xe902893aL, 0x9d22, 0x3c7e, 0xa7, 0xb8, 0xd6e313b71d9fL),
-+             0xe902893a9d223c7ea7b8d6e313b71d9fL,
-+             'urn:uuid:e902893a-9d22-3c7e-a7b8-d6e313b71d9f',
-+             0xc7e9d22e902893aL, 0x27b8, uuid.RFC_4122, 3),
-+            ('eb424026-6f54-4ef8-a4d0-bb658a1fc6cf',
-+             '{eb424026-6f54-4ef8-a4d0-bb658a1fc6cf}',
-+             'eb4240266f544ef8a4d0bb658a1fc6cf',
-+             '\xeb\x42\x40\x26\x6f\x54\x4e\xf8\xa4\xd0\xbb\x65\x8a\x1f\xc6\xcf',
-+             '\x26\x40\x42\xeb\x54\x6f\xf8\x4e\xa4\xd0\xbb\x65\x8a\x1f\xc6\xcf',
-+             (0xeb424026L, 0x6f54, 0x4ef8, 0xa4, 0xd0, 0xbb658a1fc6cfL),
-+             0xeb4240266f544ef8a4d0bb658a1fc6cfL,
-+             'urn:uuid:eb424026-6f54-4ef8-a4d0-bb658a1fc6cf',
-+             0xef86f54eb424026L, 0x24d0, uuid.RFC_4122, 4),
-+            ('f81d4fae-7dec-11d0-a765-00a0c91e6bf6',
-+             '{f81d4fae-7dec-11d0-a765-00a0c91e6bf6}',
-+             'f81d4fae7dec11d0a76500a0c91e6bf6',
-+             '\xf8\x1d\x4f\xae\x7d\xec\x11\xd0\xa7\x65\x00\xa0\xc9\x1e\x6b\xf6',
-+             '\xae\x4f\x1d\xf8\xec\x7d\xd0\x11\xa7\x65\x00\xa0\xc9\x1e\x6b\xf6',
-+             (0xf81d4faeL, 0x7dec, 0x11d0, 0xa7, 0x65, 0x00a0c91e6bf6L),
-+             0xf81d4fae7dec11d0a76500a0c91e6bf6L,
-+             'urn:uuid:f81d4fae-7dec-11d0-a765-00a0c91e6bf6',
-+             0x1d07decf81d4faeL, 0x2765, uuid.RFC_4122, 1),
-+            ('fffefdfc-fffe-fffe-fffe-fffefdfcfbfa',
-+             '{fffefdfc-fffe-fffe-fffe-fffefdfcfbfa}',
-+             'fffefdfcfffefffefffefffefdfcfbfa',
-+             '\xff\xfe\xfd\xfc\xff\xfe\xff\xfe\xff\xfe\xff\xfe\xfd\xfc\xfb\xfa',
-+             '\xfc\xfd\xfe\xff\xfe\xff\xfe\xff\xff\xfe\xff\xfe\xfd\xfc\xfb\xfa',
-+             (0xfffefdfcL, 0xfffe, 0xfffe, 0xff, 0xfe, 0xfffefdfcfbfaL),
-+             0xfffefdfcfffefffefffefffefdfcfbfaL,
-+             'urn:uuid:fffefdfc-fffe-fffe-fffe-fffefdfcfbfa',
-+             0xffefffefffefdfcL, 0x3ffe, uuid.RESERVED_FUTURE, None),
-+            ('ffffffff-ffff-ffff-ffff-ffffffffffff',
-+             '{ffffffff-ffff-ffff-ffff-ffffffffffff}',
-+             'ffffffffffffffffffffffffffffffff',
-+             '\xff'*16,
-+             '\xff'*16,
-+             (0xffffffffL, 0xffffL, 0xffffL, 0xff, 0xff, 0xffffffffffffL),
-+             0xffffffffffffffffffffffffffffffffL,
-+             'urn:uuid:ffffffff-ffff-ffff-ffff-ffffffffffff',
-+             0xfffffffffffffffL, 0x3fff, uuid.RESERVED_FUTURE, None),
-+            ]:
-+            equivalents = []
-+            # Construct each UUID in several different ways.
-+            for u in [uuid.UUID(string), uuid.UUID(curly), uuid.UUID(hex),
-+                      uuid.UUID(bytes=bytes), uuid.UUID(bytes_le=bytes_le),
-+                      uuid.UUID(fields=fields), uuid.UUID(int=integer),
-+                      uuid.UUID(urn)]:
-+                # Test all conversions and properties of the UUID object.
-+                equal(str(u), string)
-+                equal(int(u), integer)
-+                equal(u.bytes, bytes)
-+                equal(u.bytes_le, bytes_le)
-+                equal(u.fields, fields)
-+                equal(u.time_low, fields[0])
-+                equal(u.time_mid, fields[1])
-+                equal(u.time_hi_version, fields[2])
-+                equal(u.clock_seq_hi_variant, fields[3])
-+                equal(u.clock_seq_low, fields[4])
-+                equal(u.node, fields[5])
-+                equal(u.hex, hex)
-+                equal(u.int, integer)
-+                equal(u.urn, urn)
-+                equal(u.time, time)
-+                equal(u.clock_seq, clock_seq)
-+                equal(u.variant, variant)
-+                equal(u.version, version)
-+                equivalents.append(u)
-+
-+            # Different construction methods should give the same UUID.
-+            for u in equivalents:
-+                for v in equivalents:
-+                    equal(u, v)
-+            ascending.append(u)
-+
-+        # Test comparison of UUIDs.
-+        for i in range(len(ascending)):
-+            for j in range(len(ascending)):
-+                equal(cmp(i, j), cmp(ascending[i], ascending[j]))
-+
-+        # Test sorting of UUIDs (above list is in ascending order).
-+        resorted = ascending[:]
-+        resorted.reverse()
-+        resorted.sort()
-+        equal(ascending, resorted)
-+
-+    def test_exceptions(self):
-+        badvalue = lambda f: self.assertRaises(ValueError, f)
-+        badtype = lambda f: self.assertRaises(TypeError, f)
-+
-+        # Badly formed hex strings.
-+        badvalue(lambda: uuid.UUID(''))
-+        badvalue(lambda: uuid.UUID('abc'))
-+        badvalue(lambda: uuid.UUID('1234567812345678123456781234567'))
-+        badvalue(lambda: uuid.UUID('123456781234567812345678123456789'))
-+        badvalue(lambda: uuid.UUID('123456781234567812345678z2345678'))
-+
-+        # Badly formed bytes.
-+        badvalue(lambda: uuid.UUID(bytes='abc'))
-+        badvalue(lambda: uuid.UUID(bytes='\0'*15))
-+        badvalue(lambda: uuid.UUID(bytes='\0'*17))
-+
-+        # Badly formed bytes_le.
-+        badvalue(lambda: uuid.UUID(bytes_le='abc'))
-+        badvalue(lambda: uuid.UUID(bytes_le='\0'*15))
-+        badvalue(lambda: uuid.UUID(bytes_le='\0'*17))
-+
-+        # Badly formed fields.
-+        badvalue(lambda: uuid.UUID(fields=(1,)))
-+        badvalue(lambda: uuid.UUID(fields=(1, 2, 3, 4, 5)))
-+        badvalue(lambda: uuid.UUID(fields=(1, 2, 3, 4, 5, 6, 7)))
-+
-+        # Field values out of range.
-+        badvalue(lambda: uuid.UUID(fields=(-1, 0, 0, 0, 0, 0)))
-+        badvalue(lambda: uuid.UUID(fields=(0x100000000L, 0, 0, 0, 0, 0)))
-+        badvalue(lambda: uuid.UUID(fields=(0, -1, 0, 0, 0, 0)))
-+        badvalue(lambda: uuid.UUID(fields=(0, 0x10000L, 0, 0, 0, 0)))
-+        badvalue(lambda: uuid.UUID(fields=(0, 0, -1, 0, 0, 0)))
-+        badvalue(lambda: uuid.UUID(fields=(0, 0, 0x10000L, 0, 0, 0)))
-+        badvalue(lambda: uuid.UUID(fields=(0, 0, 0, -1, 0, 0)))
-+        badvalue(lambda: uuid.UUID(fields=(0, 0, 0, 0x100L, 0, 0)))
-+        badvalue(lambda: uuid.UUID(fields=(0, 0, 0, 0, -1, 0)))
-+        badvalue(lambda: uuid.UUID(fields=(0, 0, 0, 0, 0x100L, 0)))
-+        badvalue(lambda: uuid.UUID(fields=(0, 0, 0, 0, 0, -1)))
-+        badvalue(lambda: uuid.UUID(fields=(0, 0, 0, 0, 0, 0x1000000000000L)))
-+
-+        # Version number out of range.
-+        badvalue(lambda: uuid.UUID('00'*16, version=0))
-+        badvalue(lambda: uuid.UUID('00'*16, version=6))
-+
-+        # Integer value out of range.
-+        badvalue(lambda: uuid.UUID(int=-1))
-+        badvalue(lambda: uuid.UUID(int=1<<128L))
-+
-+        # Must supply exactly one of hex, bytes, fields, int.
-+        h, b, f, i = '00'*16, '\0'*16, (0, 0, 0, 0, 0, 0), 0
-+        uuid.UUID(h)
-+        uuid.UUID(hex=h)
-+        uuid.UUID(bytes=b)
-+        uuid.UUID(bytes_le=b)
-+        uuid.UUID(fields=f)
-+        uuid.UUID(int=i)
-+
-+        # Wrong number of arguments (positional).
-+        badtype(lambda: uuid.UUID())
-+        badtype(lambda: uuid.UUID(h, b))
-+        badtype(lambda: uuid.UUID(h, b, b))
-+        badtype(lambda: uuid.UUID(h, b, b, f))
-+        badtype(lambda: uuid.UUID(h, b, b, f, i))
-+
-+        # Duplicate arguments.
-+        for hh in [[], [('hex', h)]]:
-+            for bb in [[], [('bytes', b)]]:
-+                for bble in [[], [('bytes_le', b)]]:
-+                    for ii in [[], [('int', i)]]:
-+                        for ff in [[], [('fields', f)]]:
-+                            args = dict(hh + bb + bble + ii + ff)
-+                            if len(args) != 0:
-+                                badtype(lambda: uuid.UUID(h, **args))
-+                            if len(args) != 1:
-+                                badtype(lambda: uuid.UUID(**args))
-+
-+        # Immutability.
-+        u = uuid.UUID(h)
-+        badtype(lambda: setattr(u, 'hex', h))
-+        badtype(lambda: setattr(u, 'bytes', b))
-+        badtype(lambda: setattr(u, 'bytes_le', b))
-+        badtype(lambda: setattr(u, 'fields', f))
-+        badtype(lambda: setattr(u, 'int', i))
-+        badtype(lambda: setattr(u, 'time_low', 0))
-+        badtype(lambda: setattr(u, 'time_mid', 0))
-+        badtype(lambda: setattr(u, 'time_hi_version', 0))
-+        badtype(lambda: setattr(u, 'time_hi_version', 0))
-+        badtype(lambda: setattr(u, 'clock_seq_hi_variant', 0))
-+        badtype(lambda: setattr(u, 'clock_seq_low', 0))
-+        badtype(lambda: setattr(u, 'node', 0))
-+
-+    def check_node(self, node, source):
-+        message = "%012x is not an RFC 4122 node ID" % node
-+        self.assertTrue(0 < node, message)
-+        self.assertTrue(node < (1L << 48), message)
-+
-+        TestUUID.source2node[source] = node
-+        if TestUUID.last_node:
-+            if TestUUID.last_node != node:
-+                msg = "different sources disagree on node:\n"
-+                for s, n in TestUUID.source2node.iteritems():
-+                    msg += "    from source %r, node was %012x\n" % (s, n)
-+                # There's actually no reason to expect the MAC addresses
-+                # to agree across various methods -- e.g., a box may have
-+                # multiple network interfaces, and different ways of getting
-+                # a MAC address may favor different HW.
-+                ##self.fail(msg)
-+        else:
-+            TestUUID.last_node = node
-+
-+    def test_ifconfig_getnode(self):
-+        import sys
-+        import os
-+        if os.name == 'posix':
-+            node = uuid._ifconfig_getnode()
-+            if node is not None:
-+                self.check_node(node, 'ifconfig')
-+
-+    def test_ipconfig_getnode(self):
-+        import os
-+        if os.name == 'nt':
-+            node = uuid._ipconfig_getnode()
-+            if node is not None:
-+                self.check_node(node, 'ipconfig')
-+
-+    def test_netbios_getnode(self):
-+        if importable('win32wnet') and importable('netbios'):
-+            self.check_node(uuid._netbios_getnode(), 'netbios')
-+
-+    def test_random_getnode(self):
-+        node = uuid._random_getnode()
-+        # Least significant bit of first octet must be set.
-+        self.assertTrue(node & 0x010000000000)
-+        self.assertTrue(node < (1L << 48))
-+
-+    def test_unixdll_getnode(self):
-+        import sys
-+        import os
-+        if importable('ctypes') and os.name == 'posix':
-+            try: # Issues 1481, 3581: _uuid_generate_time() might be None.
-+                self.check_node(uuid._unixdll_getnode(), 'unixdll')
-+            except TypeError:
-+                pass
-+
-+    def test_windll_getnode(self):
-+        import os
-+        if importable('ctypes') and os.name == 'nt':
-+            self.check_node(uuid._windll_getnode(), 'windll')
-+
-+    def test_getnode(self):
-+        import sys
-+        node1 = uuid.getnode()
-+        self.check_node(node1, "getnode1")
-+
-+        # Test it again to ensure consistency.
-+        node2 = uuid.getnode()
-+        self.check_node(node2, "getnode2")
-+
-+        self.assertEqual(node1, node2)
-+
-+    def test_uuid1(self):
-+        # uuid1 requires ctypes.
-+        try:
-+            import ctypes
-+        except ImportError:
-+            return
-+
-+        equal = self.assertEqual
-+
-+        # Make sure uuid1() generates UUIDs that are actually version 1.
-+        for u in [uuid.uuid1() for i in range(10)]:
-+            equal(u.variant, uuid.RFC_4122)
-+            equal(u.version, 1)
-+
-+        # Make sure the generated UUIDs are actually unique.
-+        uuids = {}
-+        for u in [uuid.uuid1() for i in range(1000)]:
-+            uuids[u] = 1
-+        equal(len(uuids.keys()), 1000)
-+
-+        # Make sure the supplied node ID appears in the UUID.
-+        u = uuid.uuid1(0)
-+        equal(u.node, 0)
-+        u = uuid.uuid1(0x123456789abc)
-+        equal(u.node, 0x123456789abc)
-+        u = uuid.uuid1(0xffffffffffff)
-+        equal(u.node, 0xffffffffffff)
-+
-+        # Make sure the supplied clock sequence appears in the UUID.
-+        u = uuid.uuid1(0x123456789abc, 0)
-+        equal(u.node, 0x123456789abc)
-+        equal(((u.clock_seq_hi_variant & 0x3f) << 8) | u.clock_seq_low, 0)
-+        u = uuid.uuid1(0x123456789abc, 0x1234)
-+        equal(u.node, 0x123456789abc)
-+        equal(((u.clock_seq_hi_variant & 0x3f) << 8) |
-+                         u.clock_seq_low, 0x1234)
-+        u = uuid.uuid1(0x123456789abc, 0x3fff)
-+        equal(u.node, 0x123456789abc)
-+        equal(((u.clock_seq_hi_variant & 0x3f) << 8) |
-+                         u.clock_seq_low, 0x3fff)
-+
-+    def test_uuid3(self):
-+        equal = self.assertEqual
-+
-+        # Test some known version-3 UUIDs.
-+        for u, v in [(uuid.uuid3(uuid.NAMESPACE_DNS, 'python.org'),
-+                      '6fa459ea-ee8a-3ca4-894e-db77e160355e'),
-+                     (uuid.uuid3(uuid.NAMESPACE_URL, 'http://python.org/'),
-+                      '9fe8e8c4-aaa8-32a9-a55c-4535a88b748d'),
-+                     (uuid.uuid3(uuid.NAMESPACE_OID, '1.3.6.1'),
-+                      'dd1a1cef-13d5-368a-ad82-eca71acd4cd1'),
-+                     (uuid.uuid3(uuid.NAMESPACE_X500, 'c=ca'),
-+                      '658d3002-db6b-3040-a1d1-8ddd7d189a4d'),
-+                    ]:
-+            equal(u.variant, uuid.RFC_4122)
-+            equal(u.version, 3)
-+            equal(u, uuid.UUID(v))
-+            equal(str(u), v)
-+
-+    def test_uuid4(self):
-+        # uuid4 requires ctypes.
-+        try:
-+            import ctypes
-+        except ImportError:
-+            return
-+
-+        equal = self.assertEqual
-+
-+        # Make sure uuid4() generates UUIDs that are actually version 4.
-+        for u in [uuid.uuid4() for i in range(10)]:
-+            equal(u.variant, uuid.RFC_4122)
-+            equal(u.version, 4)
-+
-+        # Make sure the generated UUIDs are actually unique.
-+        uuids = {}
-+        for u in [uuid.uuid4() for i in range(1000)]:
-+            uuids[u] = 1
-+        equal(len(uuids.keys()), 1000)
-+
-+    def test_uuid5(self):
-+        equal = self.assertEqual
-+
-+        # Test some known version-5 UUIDs.
-+        for u, v in [(uuid.uuid5(uuid.NAMESPACE_DNS, 'python.org'),
-+                      '886313e1-3b8a-5372-9b90-0c9aee199e5d'),
-+                     (uuid.uuid5(uuid.NAMESPACE_URL, 'http://python.org/'),
-+                      '4c565f0d-3f5a-5890-b41b-20cf47701c5e'),
-+                     (uuid.uuid5(uuid.NAMESPACE_OID, '1.3.6.1'),
-+                      '1447fa61-5277-5fef-a9b3-fbc6e44f4af3'),
-+                     (uuid.uuid5(uuid.NAMESPACE_X500, 'c=ca'),
-+                      'cc957dd1-a972-5349-98cd-874190002798'),
-+                    ]:
-+            equal(u.variant, uuid.RFC_4122)
-+            equal(u.version, 5)
-+            equal(u, uuid.UUID(v))
-+            equal(str(u), v)
-+
-+    def testIssue8621(self):
-+        import os
-+        import sys
-+        if os.name != 'posix':
-+            return
-+
-+        # On at least some versions of OSX uuid.uuid4 generates
-+        # the same sequence of UUIDs in the parent and any
-+        # children started using fork.
-+        fds = os.pipe()
-+        pid = os.fork()
-+        if pid == 0:
-+            os.close(fds[0])
-+            value = uuid.uuid4()
-+            os.write(fds[1], value.hex)
-+            os._exit(0)
-+
-+        else:
-+            os.close(fds[1])
-+            parent_value = uuid.uuid4().hex
-+            os.waitpid(pid, 0)
-+            child_value = os.read(fds[0], 100)
-+
-+            self.assertNotEqual(parent_value, child_value)
-+
-+
-+
-+
-+
-+def test_main():
-+    test_support.run_unittest(TestUUID)
-+
-+if __name__ == '__main__':
-+    test_main()
-diff -druN python-2.7.5.orig/Lib/uuid.py python-2.7.5/Lib/uuid.py
---- python-2.7.5.orig/Lib/uuid.py	2013-05-12 05:32:48.000000000 +0200
-+++ python-2.7.5/Lib/uuid.py	2014-04-10 10:46:45.556242700 +0200
-@@ -50,6 +50,7 @@
-     'reserved for NCS compatibility', 'specified in RFC 4122',
-     'reserved for Microsoft compatibility', 'reserved for future definition']
- 
-+
- class UUID(object):
-     """Instances of the UUID class represent UUIDs as specified in RFC 4122.
-     UUID objects are immutable, hashable, and usable as dictionary keys.
-@@ -291,6 +292,7 @@
- 
-     version = property(get_version)
- 
-+
- def _find_mac(command, args, hw_identifiers, get_index):
-     import os
-     for dir in ['', '/sbin/', '/usr/sbin']:
-@@ -390,65 +392,87 @@
-         return ((bytes[0]<<40L) + (bytes[1]<<32L) + (bytes[2]<<24L) +
-                 (bytes[3]<<16L) + (bytes[4]<<8L) + bytes[5])
- 
--# Thanks to Thomas Heller for ctypes and for his help with its use here.
- 
--# If ctypes is available, use it to find system routines for UUID generation.
--_uuid_generate_random = _uuid_generate_time = _UuidCreate = None
--try:
--    import ctypes, ctypes.util
-+_ctypes_lib = None
- 
--    # The uuid_generate_* routines are provided by libuuid on at least
--    # Linux and FreeBSD, and provided by libc on Mac OS X.
--    for libname in ['uuid', 'c']:
--        try:
--            lib = ctypes.CDLL(ctypes.util.find_library(libname))
--        except:
--            continue
--        if hasattr(lib, 'uuid_generate_random'):
--            _uuid_generate_random = lib.uuid_generate_random
--        if hasattr(lib, 'uuid_generate_time'):
--            _uuid_generate_time = lib.uuid_generate_time
- 
--    # The uuid_generate_* functions are broken on MacOS X 10.5, as noted
--    # in issue #8621 the function generates the same sequence of values
--    # in the parent process and all children created using fork (unless
--    # those children use exec as well).
--    #
--    # Assume that the uuid_generate functions are broken from 10.5 onward,
--    # the test can be adjusted when a later version is fixed.
--    import sys
--    if sys.platform == 'darwin':
--        import os
--        if int(os.uname()[2].split('.')[0]) >= 9:
--            _uuid_generate_random = _uuid_generate_time = None
-+def _uuid_generate(attr):
-+    """Find system routines for UUID generation"""
- 
--    # On Windows prior to 2000, UuidCreate gives a UUID containing the
--    # hardware address.  On Windows 2000 and later, UuidCreate makes a
--    # random UUID and UuidCreateSequential gives a UUID containing the
--    # hardware address.  These routines are provided by the RPC runtime.
--    # NOTE:  at least on Tim's WinXP Pro SP2 desktop box, while the last
--    # 6 bytes returned by UuidCreateSequential are fixed, they don't appear
--    # to bear any relationship to the MAC address of any network device
--    # on the box.
-+    # Thanks to Thomas Heller for ctypes and for his help with its use here.
-     try:
--        lib = ctypes.windll.rpcrt4
-+        import ctypes
-+        import ctypes.util
-+
-+        global _ctypes_lib
-+
-+        uuid = None
-+        # The uuid_generate_* routines are provided by libuuid on at least
-+        # Linux and FreeBSD, and provided by libc on Mac OS X.
-+        for libname in ['uuid', 'c']:
-+            try:
-+                if _ctypes_lib is None:
-+                    _ctypes_lib = ctypes.CDLL(ctypes.util.find_library(libname))
-+                lib = _ctypes_lib
-+            except:
-+                continue
-+            if hasattr(lib, attr):
-+                uuid = getattr(lib, attr)
-+
-+        # The uuid_generate_* functions are broken on MacOS X 10.5, as noted
-+        # in issue #8621 the function generates the same sequence of values
-+        # in the parent process and all children created using fork (unless
-+        # those children use exec as well).
-+        #
-+        # Assume that the uuid_generate functions are broken from 10.5 onward,
-+        # the test can be adjusted when a later version is fixed.
-+        import sys
-+        if sys.platform == 'darwin':
-+            import os
-+            if int(os.uname()[2].split('.')[0]) >= 9:
-+                uuid = None
-+        return uuid
-     except:
--        lib = None
--    _UuidCreate = getattr(lib, 'UuidCreateSequential',
--                          getattr(lib, 'UuidCreate', None))
--except:
--    pass
-+        pass
-+
-+
-+def _uuid_create():
-+    """Get random UUID on Windows platform."""
-+
-+    try:
-+        # On Windows prior to 2000, UuidCreate gives a UUID containing the
-+        # hardware address.  On Windows 2000 and later, UuidCreate makes a
-+        # random UUID and UuidCreateSequential gives a UUID containing the
-+        # hardware address.  These routines are provided by the RPC runtime.
-+        # NOTE:  at least on Tim's WinXP Pro SP2 desktop box, while the last
-+        # 6 bytes returned by UuidCreateSequential are fixed, they don't appear
-+        # to bear any relationship to the MAC address of any network device
-+        # on the box.
-+        try:
-+            import ctypes
-+            lib = ctypes.windll.rpcrt4
-+        except:
-+            lib = None
-+        uuid = getattr(lib, 'UuidCreateSequential',
-+                       getattr(lib, 'UuidCreate', None))
-+        return uuid
-+    except:
-+        pass
- 
- def _unixdll_getnode():
-     """Get the hardware address on Unix using ctypes."""
-+    import ctypes
-     _buffer = ctypes.create_string_buffer(16)
--    _uuid_generate_time(_buffer)
-+    uuid_generate_time = _uuid_generate("uuid_generate_time")
-+    uuid_generate_time(_buffer)
-     return UUID(bytes=_buffer.raw).node
- 
- def _windll_getnode():
-     """Get the hardware address on Windows using ctypes."""
-+    import ctypes
-     _buffer = ctypes.create_string_buffer(16)
--    if _UuidCreate(_buffer) == 0:
-+    UuidCreate = _uuid_create()
-+    if UuidCreate(_buffer) == 0:
-         return UUID(bytes=_buffer.raw).node
- 
- def _random_getnode():
-@@ -495,9 +519,12 @@
- 
-     # When the system provides a version-1 UUID generator, use it (but don't
-     # use UuidCreate here because its UUIDs don't conform to RFC 4122).
--    if _uuid_generate_time and node is clock_seq is None:
-+    uuid_generate_time = _uuid_generate("uuid_generate_time")
-+
-+    if uuid_generate_time and node is clock_seq is None:
-+        import ctypes
-         _buffer = ctypes.create_string_buffer(16)
--        _uuid_generate_time(_buffer)
-+        uuid_generate_time(_buffer)
-         return UUID(bytes=_buffer.raw)
- 
-     global _last_timestamp
-@@ -532,9 +559,11 @@
-     """Generate a random UUID."""
- 
-     # When the system provides a version-4 UUID generator, use it.
--    if _uuid_generate_random:
-+    uuid_generate_random = _uuid_generate("uuid_generate_random")
-+    if uuid_generate_random:
-+        import ctypes
-         _buffer = ctypes.create_string_buffer(16)
--        _uuid_generate_random(_buffer)
-+        uuid_generate_random(_buffer)
-         return UUID(bytes=_buffer.raw)
- 
-     # Otherwise, get randomness from urandom or the 'random' module.
--- build/pkgs/python/patches/hashlibfallbacks-issue_18000.patch.orig	2014-05-06 11:21:42.000000000 +0000
+++ build/pkgs/python/patches/hashlibfallbacks-issue_18000.patch	2014-05-31 02:14:09.000000000 +0000
@@ -1,69 +0,0 @@
-diff -ur src/Lib/test/test_hashlib.py new/Lib/test/test_hashlib.py
---- a/Lib/test/test_hashlib.py	2013-05-12 04:32:46.000000000 +0100
-+++ b/Lib/test/test_hashlib.py	2013-05-18 12:24:04.055336404 +0100
-@@ -19,9 +19,6 @@
- from test import test_support
- from test.test_support import _4G, precisionbigmemtest
- 
--# Were we compiled --with-pydebug or with #define Py_DEBUG?
--COMPILED_WITH_PYDEBUG = hasattr(sys, 'gettotalrefcount')
--
- 
- def hexstr(s):
-     import string
-@@ -38,7 +35,7 @@
-                              'sha224', 'SHA224', 'sha256', 'SHA256',
-                              'sha384', 'SHA384', 'sha512', 'SHA512' )
- 
--    _warn_on_extension_import = COMPILED_WITH_PYDEBUG
-+    _warn_on_extension_import = True
- 
-     def _conditional_import_module(self, module_name):
-         """Import a module and return a reference to it or None on failure."""
-diff -ur src/setup.py new/setup.py
---- a/setup.py	2013-05-12 04:32:54.000000000 +0100
-+++ b/setup.py	2013-05-18 12:22:04.417057535 +0100
-@@ -29,9 +29,6 @@
-     return sys.platform
- host_platform = get_platform()
- 
--# Were we compiled --with-pydebug or with #define Py_DEBUG?
--COMPILED_WITH_PYDEBUG = ('--with-pydebug' in sysconfig.get_config_var("CONFIG_ARGS"))
--
- # This global variable is used to hold the list of modules to be disabled.
- disabled_module_list = []
- 
-@@ -848,21 +845,18 @@
-                 print ("warning: openssl 0x%08x is too old for _hashlib" %
-                        openssl_ver)
-                 missing.append('_hashlib')
--        if COMPILED_WITH_PYDEBUG or not have_usable_openssl:
--            # The _sha module implements the SHA1 hash algorithm.
--            exts.append( Extension('_sha', ['shamodule.c']) )
--            # The _md5 module implements the RSA Data Security, Inc. MD5
--            # Message-Digest Algorithm, described in RFC 1321.  The
--            # necessary files md5.c and md5.h are included here.
--            exts.append( Extension('_md5',
--                            sources = ['md5module.c', 'md5.c'],
--                            depends = ['md5.h']) )
--
--        min_sha2_openssl_ver = 0x00908000
--        if COMPILED_WITH_PYDEBUG or openssl_ver < min_sha2_openssl_ver:
--            # OpenSSL doesn't do these until 0.9.8 so we'll bring our own hash
--            exts.append( Extension('_sha256', ['sha256module.c']) )
--            exts.append( Extension('_sha512', ['sha512module.c']) )
-+
-+        # We always compile these even when OpenSSL is available (issue #14693).
-+        # It's harmless and the object code is tiny (40-50 KB per module,
-+        # only loaded when actually used).
-+        exts.append( Extension('_sha256', ['sha256module.c'],
-+                               depends=['hashlib.h']) )
-+        exts.append( Extension('_sha512', ['sha512module.c'],
-+                               depends=['hashlib.h']) )
-+        exts.append( Extension('_md5', ['md5module.c', 'md5.c'],
-+                               depends=['hashlib.h']) )
-+        exts.append( Extension('_sha', ['shamodule.c'],
-+                               depends=['hashlib.h']) )
- 
-         # Modules that provide persistent dictionary-like semantics.  You will
-         # probably want to arrange for at least one of them to be available on
