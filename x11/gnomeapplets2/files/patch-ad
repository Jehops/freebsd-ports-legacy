--- cdplayer/cdplayer.c.orig     Tue Apr 16 16:42:54 2002
+++ cdplayer/cdplayer.c  Tue Apr 30 17:31:41 2002
@@ -671,6 +671,12 @@
                     description = TRUE;
                     break;
                 case DISC_COMPLETED:
+                       led_time(cd->panel.time,
+                               stat.relative_address.minute,
+                               stat.relative_address.second,
+                               cd->panel.track_control.display,
+                               stat.track);
+                       break;
                 case DISC_STOP:
                 case DISC_ERROR:
                     led_stop(cd->panel.time, cd->panel.track_control.display);
--- /dev/null	Mon May 29 02:15:42 2000
+++ cdplayer/cdrom-freebsd.c	Mon May 29 10:37:28 2000
@@ -0,0 +1,336 @@
+#include <stdlib.h>
+#include <string.h>
+#include <fcntl.h>
+#include <glib.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+
+#include <sys/types.h>
+#include <sys/cdio.h>
+#include "cdrom-interface.h"
+
+
+#define ASSIGN_MSF(dest, src) \
+{ \
+  (dest).minute = (src).minute; \
+  (dest).second = (src).second; \
+  (dest).frame = (src).frame; \
+}
+
+int
+cdrom_play(cdrom_device_t cdp, int start, int stop)
+{
+	struct ioc_play_track ti;
+
+	ti.start_track = start;
+	ti.start_index = 1;
+	ti.end_track = stop;
+	ti.end_index = 1;
+
+	if ((ioctl(cdp->device, CDIOCPREVENT) == -1) ||
+	    (ioctl(cdp->device, CDIOCPLAYTRACKS, &ti) == -1)) {
+		cdp->my_errno = errno;
+		ioctl(cdp->device, CDIOCALLOW);
+		return DISC_IO_ERROR;
+	}
+	return DISC_NO_ERROR;
+}
+
+int
+cdrom_play_msf(cdrom_device_t cdp, cdrom_msf_t * start)
+{
+	struct ioc_play_msf msf;
+
+	if (cdrom_read_track_info(cdp) == DISC_IO_ERROR)
+		return DISC_IO_ERROR;
+	msf.start_m = start->minute;
+	msf.start_s = start->second;
+	msf.start_f = start->frame;
+
+	msf.end_m = cdp->track_info[cdp->nr_track].address.minute;
+	msf.end_s = cdp->track_info[cdp->nr_track].address.second;
+	msf.end_f = cdp->track_info[cdp->nr_track].address.frame;
+
+	if ((ioctl(cdp->device, CDIOCPREVENT) == -1) ||
+	    (ioctl(cdp->device, CDIOCPLAYMSF, &msf) == -1)) {
+		cdp->my_errno = errno;
+		ioctl(cdp->device, CDIOCALLOW);
+		return DISC_IO_ERROR;
+	}
+	return DISC_NO_ERROR;
+}
+
+int
+cdrom_pause(cdrom_device_t cdp)
+{
+	if (ioctl(cdp->device, CDIOCPAUSE) == -1) {
+		cdp->my_errno = errno;
+		ioctl(cdp->device, CDIOCALLOW);
+		return DISC_IO_ERROR;
+	}
+	return DISC_IO_ERROR;
+}
+
+int
+cdrom_resume(cdrom_device_t cdp)
+{
+	if (ioctl(cdp->device, CDIOCRESUME) == -1) {
+		cdp->my_errno = errno;
+		ioctl(cdp->device, CDIOCALLOW);
+		return DISC_IO_ERROR;
+	}
+	return DISC_NO_ERROR;
+}
+
+
+int
+cdrom_stop(cdrom_device_t cdp)
+{
+	if ((ioctl(cdp->device, CDIOCSTOP) == -1) ||
+	    (ioctl(cdp->device, CDIOCALLOW) == -1)) {
+		cdp->my_errno = errno;
+		return DISC_IO_ERROR;
+	}
+	return DISC_NO_ERROR;
+}
+
+int
+cdrom_read_track_info(cdrom_device_t cdp)
+{
+	struct ioc_toc_header toc;
+	struct ioc_read_toc_single_entry tocentry;
+
+	int i, j, nr_track;
+
+	if (ioctl(cdp->device, CDIOREADTOCHEADER, &toc) == -1) {
+		cdp->my_errno = errno;
+		ioctl(cdp->device, CDIOCALLOW);
+		return DISC_IO_ERROR;
+	}
+	cdp->track0 = toc.starting_track;
+	cdp->track1 = toc.ending_track;
+	nr_track = cdp->track1 - cdp->track0 + 1;
+	if (nr_track <= 0)
+		return DISC_IO_ERROR;
+
+	if (nr_track != cdp->nr_track) {
+		if (cdp->track_info)
+			g_free(cdp->track_info);
+		cdp->nr_track = nr_track;
+		cdp->track_info = g_malloc((cdp->nr_track + 1) * sizeof(track_info_t));
+	}
+	for (i = 0, j = cdp->track0; i < cdp->nr_track; i++, j++) {
+		tocentry.track = j;
+		tocentry.address_format = CD_MSF_FORMAT;
+
+		if (ioctl(cdp->device, CDIOREADTOCENTRY, &tocentry) == -1) {
+			cdp->my_errno = errno;
+			ioctl(cdp->device, CDIOCALLOW);
+			return DISC_IO_ERROR;
+		}
+		/* fill the trackinfo field */
+		cdp->track_info[i].track = j;
+		cdp->track_info[i].audio_track = tocentry.entry.control !=
+		    0x04 ? 1 : 0;
+		ASSIGN_MSF(cdp->track_info[i].address, tocentry.entry.addr.msf);
+	}
+
+	tocentry.track = 0xAA;
+	tocentry.address_format = CD_MSF_FORMAT;
+	if (ioctl(cdp->device, CDIOREADTOCENTRY, &tocentry) == -1) {
+		cdp->my_errno = errno;
+		ioctl(cdp->device, CDIOCALLOW);
+		return DISC_IO_ERROR;
+	}
+	cdp->track_info[i].track = j;
+	cdp->track_info[i].audio_track = 0;
+	ASSIGN_MSF(cdp->track_info[i].address, tocentry.entry.addr.msf);
+
+	return DISC_NO_ERROR;
+}
+
+int
+cdrom_get_status(cdrom_device_t cdp, cdrom_device_status_t * stat)
+{
+	struct ioc_read_subchannel subchnl;
+	struct cd_sub_channel_info subchnlinfo;
+	
+	subchnl.address_format = CD_MSF_FORMAT;
+	subchnl.data_format = CD_CURRENT_POSITION;
+	subchnl.track = 0;
+	subchnl.data_len = sizeof(subchnlinfo);
+	subchnl.data = &subchnlinfo;
+	if (ioctl(cdp->device, CDIOCREADSUBCHANNEL, &subchnl) == -1) {
+		cdp->my_errno = errno;
+		ioctl(cdp->device, CDIOCALLOW);
+		return DISC_IO_ERROR;
+	}
+	stat->track = subchnlinfo.what.position.track_number;
+     	ASSIGN_MSF(stat->relative_address, subchnlinfo.what.position.reladdr.msf);
+     	ASSIGN_MSF(stat->absolute_address, subchnlinfo.what.position.absaddr.msf);
+	switch (subchnlinfo.header.audio_status) {
+	case CD_AS_PLAY_IN_PROGRESS:
+		ioctl(cdp->device, CDIOCPREVENT);
+		stat->audio_status = DISC_PLAY;
+		break;
+	case CD_AS_PLAY_PAUSED:
+		ioctl(cdp->device, CDIOCPREVENT);
+		stat->audio_status = DISC_PAUSED;
+		break;
+	case CD_AS_PLAY_COMPLETED:
+		if (cdrom_read_track_info(cdp) == DISC_IO_ERROR)
+			return DISC_IO_ERROR;
+		stat->track = cdp->nr_track;
+	     	ASSIGN_MSF(stat->relative_address, 
+		     		cdp->track_info[cdp->nr_track].address);
+	     	ASSIGN_MSF(stat->absolute_address,
+		     		cdp->track_info[cdp->nr_track].address);
+		ioctl(cdp->device, CDIOCALLOW);
+		stat->audio_status = DISC_COMPLETED;
+		break;
+	case CD_AS_AUDIO_INVALID:
+	case CD_AS_NO_STATUS:
+	case CD_AS_PLAY_ERROR:
+		ioctl(cdp->device, CDIOCALLOW);
+		stat->audio_status = DISC_STOP;
+		break;
+	default:
+		ioctl(cdp->device, CDIOCALLOW);
+		stat->audio_status = DISC_ERROR;
+	}
+	return (stat->audio_status == DISC_ERROR ?
+			DISC_IO_ERROR : DISC_NO_ERROR);
+}
+
+cdrom_device_t
+cdrom_open(char *device, int *errcode)
+{
+	cdrom_device_t cdp;
+
+	cdp = g_malloc(sizeof(struct cdrom_device));
+
+	cdp->device = open(device, O_RDONLY);
+	if (cdp->device == -1) {
+		*errcode = errno;
+		g_free(cdp);
+		return NULL;
+	}
+	cdp->nr_track = 0;
+	cdp->track_info = NULL;
+	return cdp;
+}
+
+void
+cdrom_close(cdrom_device_t cdp)
+{
+	if (cdp->nr_track)
+		g_free(cdp->track_info);
+	close(cdp->device);
+	g_free(cdp);
+}
+
+int
+cdrom_load(cdrom_device_t cdp)
+{
+	if ((ioctl(cdp->device, CDIOCCLOSE) == -1) ||
+	    (ioctl(cdp->device, CDIOCALLOW) == -1)) {
+		cdp->my_errno = errno;
+		return DISC_IO_ERROR;
+	}
+	return DISC_NO_ERROR;
+}
+
+int
+cdrom_eject(cdrom_device_t cdp)
+{
+	if ((ioctl(cdp->device, CDIOCEJECT) == -1) ||
+	    (ioctl(cdp->device, CDIOCALLOW) == -1)) {
+		cdp->my_errno = errno;
+		return DISC_IO_ERROR;
+	}
+	return DISC_NO_ERROR;
+}
+
+int 
+cdrom_next(cdrom_device_t cdp)
+{
+	cdrom_device_status_t stat;
+
+	if ((cdrom_read_track_info(cdp) == DISC_IO_ERROR) ||
+	    (cdrom_get_status(cdp, &stat) == DISC_IO_ERROR))
+		return DISC_IO_ERROR;
+	return cdrom_play(cdp, stat.track + 1, cdp->track1);
+}
+
+int 
+cdrom_prev(cdrom_device_t cdp)
+{
+	cdrom_device_status_t stat;
+
+	if ((cdrom_read_track_info(cdp) == DISC_IO_ERROR) ||
+	    (cdrom_get_status(cdp, &stat) == DISC_IO_ERROR))
+		return DISC_IO_ERROR;
+	return cdrom_play(cdp, stat.track - 1, cdp->track1);
+}
+
+int
+cdrom_rewind(cdrom_device_t cdp)
+{
+	cdrom_device_status_t stat;
+	int track;
+
+	if ((cdrom_read_track_info(cdp) == DISC_IO_ERROR) ||
+	    (cdrom_get_status(cdp, &stat) == DISC_IO_ERROR))
+		return DISC_IO_ERROR;
+	if (stat.absolute_address.second != 0)
+		stat.absolute_address.second--;
+	else {
+		stat.absolute_address.second = 0;
+		if (stat.absolute_address.minute > 0)
+			stat.absolute_address.minute--;
+	}
+	stat.absolute_address.frame = 0;
+	return cdrom_play_msf(cdp, &stat.absolute_address);
+}
+
+int
+cdrom_ff(cdrom_device_t cdp)
+{
+	cdrom_device_status_t stat;
+	int track;
+
+	if ((cdrom_read_track_info(cdp) == DISC_IO_ERROR) ||
+	    (cdrom_get_status(cdp, &stat) == DISC_IO_ERROR))
+		return DISC_IO_ERROR;
+	stat.absolute_address.second++;
+	if (stat.absolute_address.second >= 60) {
+		stat.absolute_address.minute++;
+		stat.absolute_address.second = 0;
+	}
+	stat.absolute_address.frame = 0;
+	return cdrom_play_msf(cdp, &stat.absolute_address);
+}
+
+int
+cdrom_track_length(cdrom_device_t cdp, int track, cdrom_msf_t * length)
+{
+	int index, s1, s2, i;
+
+	if ((track < cdp->track0) || (track > cdp->track1))
+		return DISC_INDEX_OUT_OF_RANGE;
+	index = track - cdp->track0;
+
+	s1 = cdp->track_info[index + 1].address.second;
+	s2 = cdp->track_info[index].address.second;
+	length->second = s1 = s1 - s2;
+	if (s1 < 0) {
+		i = 1;
+		length->second = s1 + 60;
+	} else
+		i = 0;
+
+	length->minute = cdp->track_info[index + 1].address.minute -
+	    cdp->track_info[index].address.minute - i;
+
+	return 0;
+}
