--- battstat/Makefile.in.orig	Mon Sep 27 18:39:44 2004
+++ battstat/Makefile.in	Mon Sep 27 18:40:56 2004
@@ -173,6 +173,8 @@
 pixmapsdir = $(datadir)/pixmaps
 pixmaps_DATA = battstat.png
 
+ACPIINC = @ACPIINC@
+
 @HAVE_LIBAPM_FALSE@@NEED_LIBAPM_TRUE@APMLIB = apmlib/libapm.a
 @HAVE_LIBAPM_TRUE@@NEED_LIBAPM_TRUE@APMLIB = -lapm
 @NEED_LIBAPM_FALSE@APMLIB = 
@@ -191,6 +193,7 @@
 	$(GNOME_APPLETS_CFLAGS) \
 	$(LIBGLADE_CFLAGS) \
 	$(APMINC) \
+	$(ACPIINC) \
 	-DDATA_DIR=\"$(datadir)\" \
 	-DGLADE_DIR=\"$(gladedir)\" \
 	-DG_LOG_DOMAIN=\"battstat_applet\" \
@@ -205,7 +208,9 @@
 	properties.c \
 	battstat_applet.c \
 	acpi-linux.c \
-	acpi-linux.h
+	acpi-linux.h \
+	acpi-freebsd.c \
+	acpi-freebsd.h
 
 
 battstat_applet_2_LDADD = \
@@ -242,7 +247,7 @@
 PROGRAMS = $(libexec_PROGRAMS)
 
 am_battstat_applet_2_OBJECTS = properties.$(OBJEXT) \
-	battstat_applet.$(OBJEXT) acpi-linux.$(OBJEXT)
+	battstat_applet.$(OBJEXT) acpi-freebsd.$(OBJEXT) acpi-linux.$(OBJEXT)
 battstat_applet_2_OBJECTS = $(am_battstat_applet_2_OBJECTS)
 @HAVE_LIBAPM_FALSE@@NEED_LIBAPM_TRUE@battstat_applet_2_DEPENDENCIES = \
 @HAVE_LIBAPM_FALSE@@NEED_LIBAPM_TRUE@	apmlib/libapm.a
@@ -259,6 +264,7 @@
 depcomp = $(SHELL) $(top_srcdir)/depcomp
 am__depfiles_maybe = depfiles
 @AMDEP_TRUE@DEP_FILES = ./$(DEPDIR)/acpi-linux.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/acpi-freebsd.Po \
 @AMDEP_TRUE@	./$(DEPDIR)/battstat_applet.Po \
 @AMDEP_TRUE@	./$(DEPDIR)/properties.Po
 COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
@@ -330,6 +336,7 @@
 	-rm -f *.tab.c
 
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/acpi-linux.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/acpi-freebsd.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/battstat_applet.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/properties.Po@am__quote@
 
--- battstat/acpi-freebsd.h.orig	Mon Sep 27 18:39:30 2004
+++ battstat/acpi-freebsd.h	Mon Sep 27 18:39:30 2004
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2004 by Joe Marcus Clarke <marcus@FreeBSD.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Street #330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __ACPI_FREEBSD_H__
+#define __ACPI_FREEBSD_H__
+
+#define ACPIDEV "/dev/acpi"
+
+#define BATT_MIN 0
+#define BATT_MAX 64
+
+#define ACPI_ACLINE "hw.acpi.acline"
+#define ACPI_TIME "hw.acpi.battery.time"
+#define ACPI_LIFE "hw.acpi.battery.life"
+#define ACPI_STATE "hw.acpi.battery.state"
+
+struct acpi_info {
+  gboolean  ac_online;
+  int       acpifd;
+  int       max_capacity;
+  int       low_capacity;
+  int       critical_capacity;
+};
+
+gboolean acpi_freebsd_read(struct apm_info *apminfo, struct acpi_info * acpiinfo);
+gboolean acpi_process_event(struct acpi_info * acpiinfo);
+gboolean acpi_freebsd_init(struct acpi_info * acpiinfo);
+void acpi_freebsd_cleanup(struct acpi_info * acpiinfo);
+
+#endif /* __ACPI_FREEBSD_H__ */
--- battstat/acpi-freebsd.c.orig	Tue Sep 28 16:55:52 2004
+++ battstat/acpi-freebsd.c	Tue Sep 28 17:00:32 2004
@@ -0,0 +1,213 @@
+/* battstat        A GNOME battery meter for laptops.
+ * Copyright (C) 2000 by Jörgen Pehrson <jp@spektr.eu.org>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Street #330, Boston, MA 02111-1307, USA.
+ *
+ $Id: patch-battstat-acpi,v 1.3 2004/10/01 20:45:45 marcus Exp $
+ */
+
+/*
+ * ACPI battery functions for FreeBSD >= 5.2.
+ * September 2004 by Joe Marcus Clarke <marcus@FreeBSD.org>
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#ifdef __FreeBSD__
+
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/sysctl.h>
+#include <sys/ioctl.h>
+#include <machine/apm_bios.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <glib.h>
+
+#include <dev/acpica/acpiio.h>
+#include <contrib/dev/acpica/acpi.h>
+
+#include "acpi-freebsd.h"
+
+static gboolean
+update_ac_info(struct acpi_info * acpiinfo)
+{
+  int acline;
+  size_t len = sizeof(acline);
+
+  acpiinfo->ac_online = FALSE;
+
+  if (sysctlbyname(ACPI_ACLINE, &acline, &len, NULL, 0) == -1) {
+    return FALSE;
+  }
+
+  acpiinfo->ac_online = acline ? TRUE : FALSE;
+
+  return TRUE;
+}
+
+static gboolean
+update_battery_info(struct acpi_info * acpiinfo)
+{
+  union acpi_battery_ioctl_arg battio;
+  int i;
+
+  /* We really don't have to do this here.  All of the relevant battery
+   * info can be obtained through sysctl.  However, one day, the rate
+   * may be useful to get time left to full charge.
+   */
+
+  for(i = BATT_MIN; i < BATT_MAX; i++) {
+    battio.unit = i;
+    if (ioctl(acpiinfo->acpifd, ACPIIO_CMBAT_GET_BIF, &battio) == -1) {
+      continue;
+    }
+
+    acpiinfo->max_capacity += battio.bif.lfcap;
+    acpiinfo->low_capacity += battio.bif.wcap;
+    acpiinfo->critical_capacity += battio.bif.lcap;
+  }
+
+  return TRUE;
+}
+
+gboolean
+acpi_freebsd_init(struct acpi_info * acpiinfo)
+{
+  int acpi_fd;
+
+  g_assert(acpiinfo);
+
+  acpi_fd = open(ACPIDEV, O_RDONLY);
+  if (acpi_fd >= 0) {
+    acpiinfo->acpifd = acpi_fd;
+  }
+  else {
+    acpiinfo->acpifd = -1;
+    return FALSE;
+  }
+
+  update_battery_info(acpiinfo);
+  update_ac_info(acpiinfo);
+
+  return TRUE;
+}
+
+void
+acpi_freebsd_cleanup(struct acpi_info * acpiinfo)
+{
+  g_assert(acpiinfo);
+
+  if (acpiinfo->acpifd >= 0) {
+    close(acpiinfo->acpifd);
+    acpiinfo->acpifd = -1;
+  }
+}
+
+/* XXX This is a hack since user-land applications can't get ACPI events yet.
+ * Devd provides this (or supposedly provides this), but you need to be
+ * root to access devd.
+ */
+gboolean
+acpi_process_event(struct acpi_info * acpiinfo)
+{
+  g_assert(acpiinfo);
+
+  update_ac_info(acpiinfo);
+  update_battery_info(acpiinfo);
+
+  return TRUE;
+}
+
+gboolean
+acpi_freebsd_read(struct apm_info *apminfo, struct acpi_info * acpiinfo)
+{
+  int time;
+  int life;
+  int acline;
+  int state;
+  size_t len;
+  int rate;
+  int remain;
+  union acpi_battery_ioctl_arg battio;
+  gboolean charging;
+  int i;
+
+  g_assert(acpiinfo);
+
+  charging = FALSE;
+
+  for(i = BATT_MIN; i < BATT_MAX; i++) {
+    battio.unit = i;
+    if (ioctl(acpiinfo->acpifd, ACPIIO_CMBAT_GET_BST, &battio) == -1) {
+      continue;
+    }
+
+    remain += battio.bst.cap;
+    rate += battio.bst.rate;
+  }
+
+  len = sizeof(time);
+  if (sysctlbyname(ACPI_TIME, &time, &len, NULL, 0) == -1) {
+    return FALSE;
+  }
+
+  len = sizeof(life);
+  if (sysctlbyname(ACPI_LIFE, &life, &len, NULL, 0) == -1) {
+    return FALSE;
+  }
+
+  len = sizeof(state);
+  if (sysctlbyname(ACPI_STATE, &state, &len, NULL, 0) == -1) {
+    return FALSE;
+  }
+
+  apminfo->ai_acline = acpiinfo->ac_online ? 1 : 0;
+  if (state & ACPI_BATT_STAT_CHARGING) {
+    apminfo->ai_batt_stat = 3;
+    charging = TRUE;
+  }
+  else if (state & ACPI_BATT_STAT_CRITICAL) {
+    /* Add a special check here since FreeBSD's ACPI interface will tell us
+     * when the battery is critical.
+     */
+    apminfo->ai_batt_stat = 2;
+  }
+  else {
+    apminfo->ai_batt_stat = remain < acpiinfo->low_capacity ? 1 : remain < acpiinfo->critical_capacity ? 2 : 0;
+  }
+  apminfo->ai_batt_life = life;
+  if (!charging) {
+    apminfo->ai_batt_time = time * 60;
+  }
+  else if (charging && rate > 0) {
+    apminfo->ai_batt_time = (int) ((acpiinfo->max_capacity-remain)/(float)rate * 60);
+  }
+  else
+    /* This multiplication is a hack to make sure the -1 survives so the applet
+     * can process it.  Battstat wants the remaining time in minutes, but
+     * ai_batt_time is in seconds.  In order to make both ACPI and APM work
+     * with the fewest amount of hacks, we will just assume everything is
+     * in seconds.
+     */
+    apminfo->ai_batt_time = -1 * 60;
+
+  return TRUE;
+}
+#endif
--- battstat/battstat_applet.c.orig	Mon Sep 13 04:33:31 2004
+++ battstat/battstat_applet.c	Fri Oct  1 16:46:01 2004
@@ -62,6 +62,9 @@
 #ifdef __linux__
 #include "acpi-linux.h"
 #endif
+#ifdef __FreeBSD__
+#include "acpi-freebsd.h"
+#endif
 
 #ifndef gettext_noop
 #define gettext_noop(String) (String)
@@ -237,6 +240,24 @@
 #endif
 
 #ifdef __FreeBSD__
+struct acpi_info acpiinfo;
+gboolean using_acpi;
+int acpi_count;
+
+gboolean acpi_freebsd_read(struct apm_info *apminfo, struct acpi_info *acpiinfo);
+
+gboolean acpi_callback (gpointer data)
+{
+  ProgressData * battstat = (ProgressData *) data;
+
+  if (acpi_process_event(&acpiinfo)) {
+    acpi_freebsd_read(&apminfo, &acpiinfo);
+    pixmap_timeout(data);
+  }
+
+  return TRUE;
+}
+
 void
 apm_readinfo (PanelApplet *applet, ProgressData * battstat)
 {
@@ -247,13 +268,22 @@
   int fd;
   if (DEBUG) g_print("apm_readinfo() (FreeBSD)\n");
 
-  fd = open(APMDEVICE, O_RDONLY);
-  if (fd == -1) cleanup (applet, 1);
+  if (using_acpi) {
+    if (acpi_count <= 0) {
+      acpi_count = 30;
+      acpi_freebsd_read(&apminfo, &acpiinfo);
+    }
+    acpi_count--;
+  }
+  else {
+    fd = open(APMDEVICE, O_RDONLY);
+    if (fd == -1) cleanup (applet, 1);
 
-  if (ioctl(fd, APMIO_GETINFO, &apminfo) == -1)
-    err(1, "ioctl(APMIO_GETINFO)");
+    if (ioctl(fd, APMIO_GETINFO, &apminfo) == -1)
+      err(1, "ioctl(APMIO_GETINFO)");
 
-  close(fd);
+    close(fd);
+  }
 }
 #elif defined(__NetBSD__) || defined(__OpenBSD__)
 void
@@ -361,7 +391,7 @@
 
 #ifdef __FreeBSD__
 	acline_status = apminfo.ai_acline ? 1 : 0;
-	time = apminfo.ai_batt_time;
+	time = (int) (apminfo.ai_batt_time / 60);
 	batt_life = apminfo.ai_batt_life;
 #elif defined (__NetBSD__) || defined(__OpenBSD__)
 	acline_status = apminfo.ac_state ? 1 : 0;
@@ -375,8 +405,10 @@
 
 	if (batt_life > 100) batt_life = 100;
 
-	hours = time / 60;
-	mins = time % 60;
+	if (time >= 0) {
+		hours = time / 60;
+		mins = time % 60;
+	}
 
 	if (acline_status && batt_life == 100)
 		return g_strdup_printf (_("Battery charged (%d%%)"), batt_life);
@@ -912,6 +944,13 @@
      pdata->acpiwatch = 0;
      acpi_linux_cleanup(&acpiinfo);
    }
+#elif defined(__FreeBSD__)
+   if (using_acpi) {
+     if (pdata->acpiwatch != 0)
+       g_source_remove(pdata->acpiwatch);
+     pdata->acpiwatch = 0;
+     acpi_freebsd_cleanup(&acpiinfo);
+   }
 #endif
 
    if (pdata->suspend_cmd)
@@ -1052,6 +1091,7 @@
 	"Lennart Poettering <lennart@poettering.de> (Linux ACPI support)",
 	"Seth Nickell <snickell@stanford.edu> (GNOME2 port)",
 	"Davyd Madeley <davyd@ucc.asn.au>",
+	"Joe Marcus Clarke <marcus@FreeBSD.org> (FreeBSD ACPI support)",
 	NULL
    };
 
@@ -1760,11 +1800,18 @@
       using_acpi = TRUE;
       acpi_count = 0;
   }
+#elif defined(__FreeBSD__)
+  if (acpi_freebsd_init(&acpiinfo)) {
+    using_acpi = TRUE;
+    acpi_count = 0;
+  }
+  else
+    using_acpi = FALSE;
 #endif
   apm_readinfo (applet, NULL);
 
 #ifdef __FreeBSD__
-  if(apminfo.ai_status == 0) cleanup (applet, 2);
+  if(!using_acpi && apminfo.ai_status == 0) cleanup (applet, 2);
 #endif
   
   battstat = g_new0 (ProgressData, 1);
@@ -1803,6 +1850,10 @@
     battstat->acpiwatch = g_io_add_watch (acpiinfo.channel,
         G_IO_IN | G_IO_ERR | G_IO_HUP,
         acpi_callback, battstat);
+  }
+#elif defined(__FreeBSD__)
+  if (using_acpi) {
+    battstat->acpiwatch = g_timeout_add (2000, acpi_callback, battstat);
   }
 #endif
 
