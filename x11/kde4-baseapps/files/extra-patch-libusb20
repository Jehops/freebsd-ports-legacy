diff -u -r ./apps/kinfocenter/usbview/CMakeLists.txt ./apps/kinfocenter/usbview/CMakeLists.txt
--- ./apps/kinfocenter/usbview/CMakeLists.txt	2009-06-07 10:54:55.000000000 +0200
+++ ./apps/kinfocenter/usbview/CMakeLists.txt	2009-06-07 10:55:58.000000000 +0200
@@ -9,7 +9,7 @@
 kde4_add_plugin(kcm_usb ${kcm_usb_PART_SRCS})
 
 
-target_link_libraries(kcm_usb  ${KDE4_KDEUI_LIBS} ${QT_QTGUI_LIBRARY})
+target_link_libraries(kcm_usb  ${KDE4_KDEUI_LIBS} ${QT_QTGUI_LIBRARY} -lusb)
 
 install(TARGETS kcm_usb  DESTINATION ${PLUGIN_INSTALL_DIR} )
 
diff -u -r ./apps/kinfocenter/usbview/usbdevices.cpp ./apps/kinfocenter/usbview/usbdevices.cpp
--- ./apps/kinfocenter/usbview/usbdevices.cpp	2009-06-07 10:54:55.000000000 +0200
+++ ./apps/kinfocenter/usbview/usbdevices.cpp	2009-06-07 10:55:58.000000000 +0200
@@ -294,17 +294,25 @@
 
 /*
  * FreeBSD support by Markus Brueffer <markus@brueffer.de>
+ * libusb20 support by Hans Petter Selasky <hselasky@freebsd.org>
  *
  * Basic idea and some code fragments were taken from FreeBSD's usbdevs(8),
  * originally developed for NetBSD, so this code should work with no or
  * only little modification on NetBSD.
  */
 
-void USBDevice::collectData( int fd, int level, usb_device_info &di, int parent)
+void USBDevice::collectData(struct libusb20_backend *pbe,
+    struct libusb20_device *pdev)
 {
+	char tempbuf[32];
+	struct usb_device_info di;
+
+	if (libusb20_dev_get_info(pdev, &di))
+		memset(&di, 0, sizeof(di));
+
 	// determine data for this device
-	_level = level;
-	_parent = parent;
+	_level = 0;
+	_parent = 0;
 
 	_bus = di.udi_bus;
 	_device = di.udi_addr;
@@ -320,88 +328,47 @@
 	_power = di.udi_power;
 	_channels = di.udi_nports;
 
-	// determine the speed
-#if defined(__DragonFly__) || (defined(Q_OS_FREEBSD) && __FreeBSD_version > 490102) || defined(Q_OS_NETBSD)
 	switch (di.udi_speed) {
 		case USB_SPEED_LOW: _speed = 1.5; break;
 		case USB_SPEED_FULL: _speed = 12.0; break;
 		case USB_SPEED_HIGH: _speed = 480.0; break;
+		case USB_SPEED_VARIABLE: _speed = 480.0; break;
+		case USB_SPEED_SUPER: _speed = 4800.0; break;
+		default: _speed = 480.0; break;
 	}
-#else
-	_speed = di.udi_lowspeed ? 1.5 : 12.0;
-#endif
 
 	// Get all attached devicenodes
-	for ( int i = 0; i < USB_MAX_DEVNAMES; ++i )
-	if ( di.udi_devnames[i][0] )
-	_devnodes << di.udi_devnames[i];
+	for ( int i = 0; i < 32; ++i ) {
+	  if (libusb20_dev_get_iface_desc(
+	      pdev, i, tempbuf, sizeof(tempbuf)) == 0) {
+		_devnodes << tempbuf;
+	  } else {
+	      break;
+	  }
+	}
 
 	// For compatibility, split the revision number
 	sscanf( di.udi_release, "%x.%x", &_revMajor, &_revMinor );
-
-	// Cycle through the attached devices if there are any
-	for ( int p = 0; p < di.udi_nports; ++p ) {
-		// Get data for device
-		struct usb_device_info di2;
-
-		di2.udi_addr = di.udi_ports[p];
-
-		if ( di2.udi_addr >= USB_MAX_DEVICES )
-		continue;
-
-		if ( ioctl(fd, USB_DEVICEINFO, &di2) == -1 )
-		continue;
-
-		// Only add the device if we didn't detect it, yet
-		if (!find( di2.udi_bus, di2.udi_addr ) )
-		{
-			USBDevice *device = new USBDevice();
-			device->collectData( fd, level + 1, di2, di.udi_addr );
-		}
-	}
 }
 
 bool USBDevice::parse(const QString &fname)
 {
 	static bool showErrorMessage = true;
-	bool error = false;
+	struct libusb20_backend *pbe;
+	struct libusb20_device *pdev;
 	_devices.clear();
 
-	QFile controller("/dev/usb0");
-	int i = 1;
-	while ( controller.exists() )
-	{
-		// If the devicenode exists, continue with further inspection
-		if ( controller.open(QIODevice::ReadOnly) )
-		{
-			for ( int addr = 1; addr < USB_MAX_DEVICES; ++addr )
-			{
-				struct usb_device_info di;
-
-				di.udi_addr = addr;
-				if ( ioctl(controller.handle(), USB_DEVICEINFO, &di) != -1 )
-				{
-					if (!find( di.udi_bus, di.udi_addr ) )
-					{
-						USBDevice *device = new USBDevice();
-						device->collectData( controller.handle(), 0, di, 0);
-					}
-				}
-			}
-			controller.close();
-#ifndef Q_OS_NETBSD
-		} else {
-			error = true;
-#endif
-		}
-		controller.setFileName( QString::fromLocal8Bit("/dev/usb%1").arg(i++) );
+	pbe = libusb20_be_alloc_default();
+	if (pbe == NULL)
+		return (false);
+
+	pdev = NULL;
+
+	while ((pdev = libusb20_be_device_foreach(pbe, pdev))) {
+		USBDevice *device = new USBDevice();
+		device->collectData(pbe, pdev);
 	}
-
-	if ( showErrorMessage && error ) {
-		showErrorMessage = false;
-		KMessageBox::error( 0, i18n("Could not open one or more USB controller. Make sure, you have read access to all USB controllers that should be listed here."));
-	}
-
+	libusb20_be_free(pbe);
 	return true;
 }
 #endif
diff -u -r ./apps/kinfocenter/usbview/usbdevices.h ./apps/kinfocenter/usbview/usbdevices.h
--- ./apps/kinfocenter/usbview/usbdevices.h	2009-06-07 10:54:55.000000000 +0200
+++ ./apps/kinfocenter/usbview/usbdevices.h	2009-06-07 10:59:11.000000000 +0200
@@ -14,18 +14,11 @@
 #include <QList>
 #include <QString>
 
-#if defined(__DragonFly__)
-#include <bus/usb/usb.h>
-#include <QStringList>
-#elif defined(Q_OS_FREEBSD) || defined(Q_OS_NETBSD)
 #include <sys/param.h>
-#if __FreeBSD_version >= 800061
-#include <legacy/dev/usb/usb.h>
-#else
-#include <dev/usb/usb.h>
-#endif
+#include <libusb20.h>
+#include <dev/usb/usb_ioctl.h>
+#include <dev/usb/usb_revision.h>
 #include <QStringList>
-#endif
 
 class USBDB;
 
@@ -81,10 +74,8 @@
 
 	unsigned int _vendorID, _prodID, _revMajor, _revMinor;
 
-#if defined(Q_OS_FREEBSD) || defined(Q_OS_NETBSD)
-	void collectData( int fd, int level, usb_device_info &di, int parent );
+	void collectData(struct libusb20_backend *, struct libusb20_device *);
 	QStringList _devnodes;
-#endif
 };
 
 #endif
