--- applets/cdplayer/cdrom-freebsd.c.orig	Thu Oct 15 04:04:38 1998
+++ applets/cdplayer/cdrom-freebsd.c	Thu Oct 15 04:18:21 1998
@@ -0,0 +1,297 @@
+#include <stdlib.h>
+#include <string.h>
+#include <fcntl.h>
+#include <glib.h>
+
+#include <sys/types.h>
+#include <sys/cdio.h>
+#include "cdrom-interface.h"
+
+
+#define ASSIGN_MSF(dest, src) \
+{ \
+  (dest).minute = (src).minute; \
+  (dest).second = (src).second; \
+  (dest).frame = (src).frame; \
+}
+
+int
+cdrom_play(cdrom_device_t cdp, int start, int stop)
+{
+	struct ioc_play_track ti;
+
+	ti.start_track = start;
+	ti.start_index = 1;
+	ti.end_track = stop;
+	ti.end_index = 1;
+	if(ioctl(cdp->device, CDIOCPLAYTRACKS, &ti) == -1) {
+		cdp->my_errno = errno;
+		return DISC_IO_ERROR;
+	}
+	return DISC_NO_ERROR;
+}
+
+int
+cdrom_play_msf(cdrom_device_t cdp, cdrom_msf_t * start)
+{
+	struct ioc_play_msf msf;
+
+	if (cdrom_read_track_info(cdp) == DISC_IO_ERROR)
+		return DISC_IO_ERROR;
+	msf.start_m = start->minute;
+	msf.start_s = start->second;
+	msf.start_f = start->frame;
+
+	msf.end_m = cdp->track_info[cdp->nr_track].address.minute;
+	msf.end_s = cdp->track_info[cdp->nr_track].address.second;
+	msf.end_f = cdp->track_info[cdp->nr_track].address.frame;
+
+	if (ioctl(cdp->device, CDIOCPLAYMSF, &msf) == -1) {
+		cdp->my_errno = errno;
+		return DISC_IO_ERROR;
+	}
+	return DISC_NO_ERROR;
+}
+
+int
+cdrom_pause(cdrom_device_t cdp)
+{
+	if (ioctl(cdp->device, CDIOCPAUSE, 0) == -1) {
+		cdp->my_errno = errno;
+		return DISC_IO_ERROR;
+	}
+	return DISC_NO_ERROR;
+}
+
+int
+cdrom_resume(cdrom_device_t cdp)
+{
+	if (ioctl(cdp->device, CDIOCRESUME, 0) == -1) {
+		cdp->my_errno = errno;
+		return DISC_IO_ERROR;
+	}
+	return DISC_NO_ERROR;
+}
+
+int
+cdrom_stop(cdrom_device_t cdp)
+{
+	if (ioctl(cdp->device, CDIOCSTOP, 0) == -1) {
+		cdp->my_errno = errno;
+		return DISC_IO_ERROR;
+	}
+	return DISC_NO_ERROR;
+}
+
+int
+cdrom_read_track_info(cdrom_device_t cdp)
+{
+	struct ioc_toc_header hdr;
+	struct ioc_read_toc_entry toc;
+	struct cd_toc_entry tocentry;
+
+	int i, j, nr_track;
+
+	if (ioctl(cdp->device, CDIOREADTOCHEADER, &hdr) == -1) {
+		cdp->my_errno = errno;
+		return DISC_IO_ERROR;
+	}
+	cdp->track0 = hdr.starting_track;
+	cdp->track1 = hdr.ending_track;
+	nr_track = hdr.ending_track - hdr.starting_track + 1;
+	if (nr_track <= 0)
+		return DISC_IO_ERROR;
+
+	if(nr_track != cdp->nr_track) {
+		if (cdp->track_info)
+			g_free(cdp->track_info);
+		cdp->nr_track = nr_track;
+		cdp->track_info = g_malloc((cdp->nr_track + 1) * sizeof(track_info_t));
+	}
+	for (i = 0, j = cdp->track0; i < cdp->nr_track; i++, j++) {
+		toc.starting_track = j;
+		toc.address_format = CD_MSF_FORMAT;
+
+		if (ioctl(cdp->device, CDIOREADTOCENTRY, &toc) == -1) {
+			cdp->my_errno = errno;
+			return DISC_IO_ERROR;
+		}
+		cdp->track_info[i].track = j;
+		cdp->track_info[i].audio_track = tocentry.control !=
+			0 ? 1 : 0;
+		ASSIGN_MSF(cdp->track_info[i].address, tocentry.addr.msf);
+	}
+
+#if 0
+#define	LEADOUT = 0xaa
+	toc.starting_track = LEADOUT;
+	toc.address_format = CD_MSF_FORMAT;
+	if (ioctl(cdp->device, CDROMREADTOENTRY, &toc) == -1) {
+		cdp->my_errno = errno;
+		return DISC_IO_ERROR;
+	}
+#endif
+	cdp->track_info[i].track = j;
+	cdp->track_info[i].audio_track = 0;
+	ASSIGN_MSF(cdp->track_info[i].address, tocentry.addr.msf);
+
+	return DISC_NO_ERROR;
+}
+
+int
+cdrom_get_status(cdrom_device_t cdp, cdrom_device_status_t * stat)
+{
+	struct ioc_read_subchannel sc;
+	struct cd_sub_channel_info scd;
+
+	sc.address_format = CD_MSF_FORMAT;
+	if (ioctl(cdp->device, CDIOCREADSUBCHANNEL, &sc) == -1) {
+		cdp->my_errno = errno;
+		return DISC_IO_ERROR;
+	}
+	switch (scd.header.audio_status) {
+		case CD_AS_PLAY_IN_PROGRESS:
+			stat->audio_status = DISC_PLAY;
+			break;
+		case CD_AS_PLAY_PAUSED:
+			stat->audio_status = DISC_PAUSED;
+			break;
+		case CD_AS_PLAY_COMPLETED:
+			stat->audio_status = DISC_COMPLETED;
+			break;
+		case CD_AS_AUDIO_INVALID:
+		case CD_AS_PLAY_ERROR:
+		case CD_AS_NO_STATUS:
+			stat->audio_status = DISC_STOP;
+			break;
+		default:
+			stat->audio_status = DISC_ERROR;
+	}
+	stat->track = scd.what.position.track_number;
+	ASSIGN_MSF(stat->relative_address, scd.what.position.reladdr.msf);
+	ASSIGN_MSF(stat->absolute_address, scd.what.position.absaddr.msf);
+	return DISC_NO_ERROR;
+}
+
+cdrom_device_t
+cdrom_open(char *device, int *errcode)
+{
+	cdrom_device_t cdp;
+
+	cdp = g_malloc(sizeof(struct cdrom_device));
+
+	cdp->device = open(device, O_RDONLY);
+	if (cdp->device == -1) {
+		*errcode = errno;
+		g_free(cdp);
+		return NULL;
+	}
+	cdp->nr_track = 0;
+	cdp->track_info = NULL;
+	return cdp;
+}
+
+void
+cdrom_close(cdrom_device_t cdp)
+{
+	if (cdp->nr_track)
+		g_free(cdp->track_info);
+	close(cdp->device);
+	g_free(cdp);
+}
+
+int
+cdrom_eject(cdrom_device_t cdp)
+{
+	if (ioctl(cdp->device, CDIOCEJECT, 0) == -1 ) {
+		cdp->my_errno = errno;
+		return DISC_IO_ERROR;
+	}
+	return DISC_NO_ERROR;
+}
+
+int
+cdrom_next(cdrom_device_t cdp)
+{
+	cdrom_device_status_t stat;
+	int track;
+
+	if ((cdrom_read_track_info(cdp) == DISC_IO_ERROR) ||
+	    (cdrom_get_status(cdp, &stat) == DISC_IO_ERROR))
+		return DISC_IO_ERROR;
+	track = stat.track + 1;
+	return cdrom_play(cdp, track, cdp->track1);
+}
+
+int
+cdrom_prev(cdrom_device_t cdp)
+{
+	cdrom_device_status_t stat;
+	int track;
+
+	if ((cdrom_read_track_info(cdp) == DISC_IO_ERROR) ||
+	    (cdrom_get_status(cdp, &stat) == DISC_IO_ERROR))
+		return DISC_IO_ERROR;
+	track = stat.track - 1;
+	return cdrom_play(cdp, track, cdp->track1);
+}
+
+int
+cdrom_rewind(cdrom_device_t cdp)
+{
+	cdrom_device_status_t stat;
+	int track;
+
+	if ((cdrom_read_track_info(cdp) == DISC_IO_ERROR) ||
+	    (cdrom_get_status(cdp, &stat) == DISC_IO_ERROR))
+		return DISC_IO_ERROR;
+	if (stat.absolute_address.second != 0)
+		stat.absolute_address.second--;
+	else {
+		stat.absolute_address.second = 0;
+		if (stat.absolute_address.minute > 0)
+			stat.absolute_address.minute--;
+	}
+	stat.absolute_address.frame = 0;
+	return cdrom_play_msf(cdp, &stat.absolute_address);
+}
+
+int
+cdrom_ff(cdrom_device_t cdp)
+{
+	cdrom_device_status_t stat;
+	int track;
+
+	if ((cdrom_read_track_info(cdp) == DISC_IO_ERROR) ||
+	    (cdrom_get_status(cdp, &stat) == DISC_IO_ERROR))
+		return DISC_IO_ERROR;
+	stat.absolute_address.second++;
+	if (stat.absolute_address.second >= 60) {
+		stat.absolute_address.minute++;
+		stat.absolute_address.second = 0;
+	}
+	stat.absolute_address.frame = 0;
+	return cdrom_play_msf(cdp, &stat.absolute_address);
+}
+
+int
+cdrom_track_length(cdrom_device_t cdp, int track, cdrom_msf_t * length)
+{
+	int index, s1, s2, i;
+
+	if ((track < cdp->track0) || (track > cdp->track1))
+		return DISC_INDEX_OUT_OF_RANGE;
+	index = track - cdp->track0;
+
+	s1 = cdp->track_info[index + 1].address.second;
+	s2 = cdp->track_info[index].address.second;
+	length->second = s1 = s1 - s2;
+	if (s1 < 0) {
+		i = 1;
+		length->second = s1 + 60;
+	} else
+		i = 0;
+
+	length->minute = cdp->track_info[index + 1].address.minute -
+	    cdp->track_info[index].address.minute - i;
+}
