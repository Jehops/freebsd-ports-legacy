--- src/smpeg-xmms.c	2000/12/19 16:41:23	1.1
+++ src/smpeg-xmms.c	2000/12/19 16:48:55
@@ -269,6 +269,7 @@
 								smpeg_seek(MIN((gint)info.total_time,
 									       (gint)info.current_time + 5));
 							}
+#ifdef __linux
 							else
 							{
 								SDL_mutexP(vcd_mutex);
@@ -278,6 +279,7 @@
 									vcdpos = vcdpos_max;
 								SDL_mutexV(vcd_mutex);
 							}
+#endif
 							break;
 						case SDLK_LEFT:
 							if (!is_vcd)
@@ -287,6 +289,7 @@
 								SDL_mutexV(mpeg_mutex);
 								smpeg_seek(MAX(0, (gint)info.current_time - 5));
 							}
+#ifdef __linux
 							else
 							{
 								SDL_mutexP(vcd_mutex);
@@ -296,6 +299,7 @@
 									vcdpos = 0;
 								SDL_mutexV(vcd_mutex);
 							}
+#endif
 							break;
 						case SDLK_UP:
 							i = xmms_remote_get_main_volume(ctrlsocket_get_session_id());
@@ -748,9 +752,11 @@
 	}
 	if(is_vcd)
 	{
+#ifdef __linux
 	    set_track_number(CDROM_LEADOUT, &m, &s, &f);
 	    vcdpos_max = (((m * CD_SECS) + s) * CD_FRAMES) + f;
 	    smpeg_ip.set_info(name, (1000 * vcdpos_max) / CD_FRAMES, bitrate * 1000, srate, nch);
+#endif
 	}
 	else
 	{
@@ -869,12 +875,14 @@
 	  SMPEG_seek(mpeg, (gint) (((gdouble) time / info.total_time) *
 				   info.total_size));
 	}
+#ifdef __linux
 	else
 	{
 	  SDL_mutexP(vcd_mutex);
 	  vcdpos = msf_to_lba(0, (int) time, 0);
 	  SDL_mutexV(vcd_mutex);
 	}
+#endif
 	SDL_mutexV(mpeg_mutex);
 }
 
@@ -900,9 +908,14 @@
 
 	return (info.current_time * 1000);
     }
+#ifdef __linux
+    else
+    {
 	SDL_mutexV(mpeg_mutex);
         lba_to_msf(vcdpos, &m, &s, &f);
         return (1000 * ((m * CD_SECS) + s) + (f * 1000 / 75));
+    }
+#endif
 }
 
 static void smpeg_get_song_info(gchar * filename, gchar ** title, gint * length)
