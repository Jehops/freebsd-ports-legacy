--- contrib/x265/P01-freebsd-ppc.patch.orig	2019-11-12 19:13:27 UTC
+++ contrib/x265/P01-freebsd-ppc.patch
@@ -0,0 +1,50 @@
+--- x265_2.9/source/common/cpu.cpp.orig	2019-11-12 20:19:28.629150000 +0100
++++ x265_2.9/source/common/cpu.cpp
+@@ -127,6 +127,7 @@
+ {
+     return(enable512);
+ }
++
+ uint32_t cpu_detect(bool benableavx512 )
+ {
+ 
+--- x265_2.9/source/common/quant.cpp.orig	2019-11-12 20:19:34.848807000 +0100
++++ x265_2.9/source/common/quant.cpp
+@@ -723,6 +723,7 @@
+             X265_CHECK(coeffNum[cgScanPos] == 0, "count of coeff failure\n");
+             uint32_t scanPosBase = (cgScanPos << MLS_CG_SIZE);
+             uint32_t blkPos      = codeParams.scan[scanPosBase];
++#if X265_ARCH_X86
+             bool enable512 = detect512();
+             if (enable512)
+                 primitives.cu[log2TrSize - 2].psyRdoQuant(m_resiDctCoeff, m_fencDctCoeff, costUncoded, &totalUncodedCost, &totalRdCost, &psyScale, blkPos);
+@@ -731,6 +732,10 @@
+                 primitives.cu[log2TrSize - 2].psyRdoQuant_1p(m_resiDctCoeff,  costUncoded, &totalUncodedCost, &totalRdCost,blkPos);
+                 primitives.cu[log2TrSize - 2].psyRdoQuant_2p(m_resiDctCoeff, m_fencDctCoeff, costUncoded, &totalUncodedCost, &totalRdCost, &psyScale, blkPos);
+             }
++#else
++		primitives.cu[log2TrSize - 2].psyRdoQuant_1p(m_resiDctCoeff, costUncoded, &totalUncodedCost, &totalRdCost, blkPos);
++		primitives.cu[log2TrSize - 2].psyRdoQuant_2p(m_resiDctCoeff, m_fencDctCoeff, costUncoded, &totalUncodedCost, &totalRdCost, &psyScale, blkPos);
++#endif
+         }
+     }
+     else
+@@ -805,6 +810,7 @@
+             uint32_t blkPos = codeParams.scan[scanPosBase];
+             if (usePsyMask)
+             {
++#if X265_ARCH_X86
+                 bool enable512 = detect512();
+ 
+                 if (enable512)
+@@ -814,6 +820,10 @@
+                     primitives.cu[log2TrSize - 2].psyRdoQuant_1p(m_resiDctCoeff, costUncoded, &totalUncodedCost, &totalRdCost, blkPos);
+                     primitives.cu[log2TrSize - 2].psyRdoQuant_2p(m_resiDctCoeff, m_fencDctCoeff, costUncoded, &totalUncodedCost, &totalRdCost, &psyScale, blkPos);
+                 }
++#else
++                    primitives.cu[log2TrSize - 2].psyRdoQuant_1p(m_resiDctCoeff, costUncoded, &totalUncodedCost, &totalRdCost, blkPos);
++                    primitives.cu[log2TrSize - 2].psyRdoQuant_2p(m_resiDctCoeff, m_fencDctCoeff, costUncoded, &totalUncodedCost, &totalRdCost, &psyScale, blkPos);
++#endif
+                 blkPos = codeParams.scan[scanPosBase];
+                 for (int y = 0; y < MLS_CG_SIZE; y++)
+                 {
