libc++ < 5 doesn't support std::byte, so use previous version

--- Utilities/BEType.h.orig	2018-08-27 18:53:45 UTC
+++ Utilities/BEType.h
@@ -334,10 +334,14 @@ inline v128 operator~(const v128& other)
 template <typename T, std::size_t Align, std::size_t Size>
 struct se_storage
 {
+#if defined(_LIBCPP_VERSION) && _LIBCPP_VERSION < 5000
+	using type = std::aligned_storage_t<Size, Align>;
+#else
 	struct type
 	{
 		alignas(Align) std::byte data[Size];
 	};
+#endif
 
 	// Unoptimized generic byteswap for unaligned data
 	static void reverse(u8* dst, const u8* src)
--- Utilities/types.h.orig	2018-08-27 18:53:45 UTC
+++ Utilities/types.h
@@ -91,7 +91,11 @@ using steady_clock = std::conditional<
 
 namespace gsl
 {
+#if defined(_LIBCPP_VERSION) && _LIBCPP_VERSION < 5000
+	enum class byte : u8;
+#else
 	using std::byte;
+#endif
 }
 
 // Formatting helper, type-specific preprocessing for improving safety and functionality
@@ -770,7 +776,11 @@ struct value_hash
 template <template <typename> class TT, std::size_t S, std::size_t A = S>
 struct alignas(A) any_pod
 {
+#if defined(_LIBCPP_VERSION) && _LIBCPP_VERSION < 5000
+	std::aligned_storage_t<S, A> data;
+#else
 	alignas(A) std::byte data[S];
+#endif
 
 	any_pod() = default;
 
