diff -urd --exclude=CVS ../cvs/qemu/Makefile qemu-0.5.5/Makefile
--- ../cvs/qemu/Makefile	Mon May 17 21:06:42 2004
+++ qemu-0.5.5/Makefile	Sun May 30 05:26:19 2004
@@ -70,7 +70,7 @@
 
 # documentation
 %.html: %.texi
-	texi2html -monolithic -number $<
+	-texi2html -monolithic -number $<
 
 qemu.1: qemu-doc.texi
 	./texi2pod.pl $< qemu.pod
Only in qemu-0.5.5: qemu.1
diff -urd --exclude=CVS ../cvs/qemu/target-i386/cpu.h qemu-0.5.5/target-i386/cpu.h
--- ../cvs/qemu/target-i386/cpu.h	Thu May 20 15:01:56 2004
+++ qemu-0.5.5/target-i386/cpu.h	Sun May 30 05:16:10 2004
@@ -259,7 +259,7 @@
     CC_OP_NB,
 };
 
-#if (defined(__i386__) || defined(__x86_64__)) && !defined(_BSD)
+#if defined(__i386__) || defined(__x86_64__)
 #define USE_X86LDOUBLE
 #endif
 
diff -urd --exclude=CVS ../cvs/qemu/target-i386/exec.h qemu-0.5.5/target-i386/exec.h
--- ../cvs/qemu/target-i386/exec.h	Sat May 29 12:08:52 2004
+++ qemu-0.5.5/target-i386/exec.h	Sun May 30 05:19:43 2004
@@ -293,6 +293,22 @@
 
 #endif /* !defined(CONFIG_USER_ONLY) */
 
+#if defined(_BSD) && defined(USE_X86LDOUBLE)
+#include <math.h>
+/*int rintl(long double __x);
+long int lrintl(long double __x);
+long long int llrintl(long double __x);
+long double powl(long double __x, long double __y);
+long double logl(long double __x);
+long double tanl(long double __x);
+long double atan2l(long double __y, long double __x);
+long double ceill(long double __x);
+long double floorl(long double __x);
+long double sqrtl(long double __x);
+long double sinl(long double __x);
+long double cosl(long double __x);*/
+#endif
+
 #ifdef USE_X86LDOUBLE
 /* use long double functions */
 #define lrint lrintl
@@ -310,7 +326,7 @@
 #define rint rintl
 #endif
 
-#if !defined(_BSD)
+#if !defined(_BSD) || defined(USE_X86LDOUBLE)
 extern int lrint(CPU86_LDouble x);
 extern int64_t llrint(CPU86_LDouble x);
 #else
diff -urd --exclude=CVS ../cvs/qemu/target-i386/op.c qemu-0.5.5/target-i386/op.c
--- ../cvs/qemu/target-i386/op.c	Sat May 29 12:08:52 2004
+++ qemu-0.5.5/target-i386/op.c	Sun May 30 05:40:54 2004
@@ -1304,6 +1304,149 @@
    functions comes from the LGPL'ed x86 emulator found in the Willows
    TWIN windows emulator. */
 
+#if defined(_BSD) && defined(USE_X86LDOUBLE)
+
+CPU86_LDouble rintl(CPU86_LDouble __x) {
+  CPU86_LDouble __rintres;
+  __asm__ __volatile__
+    ("fistp %0"
+     : "=m" (__rintres) : "t" (__x) : "st");
+  return __rintres;
+}
+
+int lrintl(CPU86_LDouble __x) {
+  int __lrintres;
+  __asm__ __volatile__
+    ("fistpl %0"
+     : "=m" (__lrintres) : "t" (__x) : "st");
+  return __lrintres;
+}
+
+
+int64_t llrintl(CPU86_LDouble __x) {
+  int64_t __llrintres;
+  __asm__ __volatile__
+    ("fistpll %0"
+     : "=m" (__llrintres) : "t" (__x) : "st");
+  return __llrintres;
+}
+
+CPU86_LDouble powl(CPU86_LDouble __x, CPU86_LDouble __y) {
+  register CPU86_LDouble __value;
+  register long double __exponent;
+  __extension__ long long int __p = (long long int) __y;
+  if (__x == 0.0)
+    {
+       if (__y > 0.0)
+         return __y == (double) __p && (__p & 1) != 0 ? __x : 0.0;
+       else if (__y < 0.0)
+         return (__y == (double) __p && (-__p & 1) != 0
+                 ? 1.0 / __x : 1.0 / fabs (__x));
+    }
+  if (__y == (double) __p)
+    {
+      long double __r = 1.0;
+      if (__p == 0)
+        return 1.0;
+      if (__p < 0)
+        {
+          __p = -__p;
+          __x = 1.0 / __x;
+        }
+      while (1)
+        {
+          if (__p & 1)
+            __r *= __x;
+          __p >>= 1;
+          if (__p == 0)
+            return __r;
+          __x *= __x;
+        }
+      /* NOTREACHED */
+    }
+  __asm __volatile__
+    ("fyl2x" : "=t" (__value) : "0" (__x), "u" (1.0) : "st(1)");
+  __asm __volatile__
+    ("fmul      %%st(1)         # y * log2(x)\n\t"
+     "fst       %%st(1)\n\t"
+     "frndint                   # int(y * log2(x))\n\t"
+     "fxch\n\t"
+     "fsub      %%st(1)         # fract(y * log2(x))\n\t"
+     "f2xm1                     # 2^(fract(y * log2(x))) - 1\n\t"
+     : "=t" (__value), "=u" (__exponent) : "0" (__y), "1" (__value));
+  __value += 1.0;
+  __asm __volatile__
+    ("fscale"
+     : "=t" (__value) : "0" (__value), "u" (__exponent));
+  return __value;
+}
+
+CPU86_LDouble logl(CPU86_LDouble __x) {
+  register CPU86_LDouble __result;
+  __asm __volatile__ ("fldln2; fxch; fyl2x" : "=t" (__result) : "0" (__x) : "st(1)");
+  return __result;
+}
+
+CPU86_LDouble tanl(CPU86_LDouble __x) {
+  register CPU86_LDouble __value;
+  register CPU86_LDouble __value2 __attribute__ ((__unused__));
+  __asm __volatile__
+    ("fptan"
+     : "=t" (__value2), "=u" (__value) : "0" (__x));
+  return __value;
+}
+
+CPU86_LDouble atan2l(CPU86_LDouble __y, CPU86_LDouble __x) {
+  register CPU86_LDouble __value;
+  __asm __volatile__
+    ("fpatan"
+     : "=t" (__value) : "0" (__x), "u" (__y) : "st(1)");
+  return __value;
+}
+
+CPU86_LDouble ceill(CPU86_LDouble __x) {
+  register CPU86_LDouble __value;
+  __volatile unsigned short int __cw;
+  __volatile unsigned short int __cwtmp;
+  __asm __volatile ("fnstcw %0" : "=m" (__cw));
+  __cwtmp = (__cw & 0xf3ff) | 0x0800; /* rounding up */
+  __asm __volatile ("fldcw %0" : : "m" (__cwtmp));
+  __asm __volatile ("frndint" : "=t" (__value) : "0" (__x));
+  __asm __volatile ("fldcw %0" : : "m" (__cw));
+  return __value;
+}
+
+CPU86_LDouble floorl(CPU86_LDouble __x) {
+  register CPU86_LDouble __value;
+  __volatile unsigned short int __cw;
+  __volatile unsigned short int __cwtmp;
+  __asm __volatile ("fnstcw %0" : "=m" (__cw));
+  __cwtmp = (__cw & 0xf3ff) | 0x0400; /* rounding down */
+  __asm __volatile ("fldcw %0" : : "m" (__cwtmp));
+  __asm __volatile ("frndint" : "=t" (__value) : "0" (__x));
+  __asm __volatile ("fldcw %0" : : "m" (__cw));
+  return __value;
+}
+
+CPU86_LDouble sqrtl(CPU86_LDouble __x) {
+  register CPU86_LDouble __result;
+  __asm __volatile__ ("fsqrt" : "=t" (__result) : "0" (__x));
+  return __result;
+}
+
+CPU86_LDouble sinl(CPU86_LDouble __x) {
+  register CPU86_LDouble __result;
+  __asm __volatile__ ("fsin" : "=t" (__result) : "0" (__x));
+  return __result;
+}
+
+CPU86_LDouble cosl(CPU86_LDouble __x) {
+  register CPU86_LDouble __result;
+  __asm __volatile__ ("fcos" : "=t" (__result) : "0" (__x));
+  return __result;
+}
+#endif
+
 #if defined(__powerpc__)
 extern CPU86_LDouble copysign(CPU86_LDouble, CPU86_LDouble);
 
diff -urd --exclude=CVS ../cvs/qemu/vl.c qemu-0.5.5/vl.c
--- ../cvs/qemu/vl.c	Wed May 26 23:12:06 2004
+++ qemu-0.5.5/vl.c	Sun May 30 05:30:56 2004
@@ -662,6 +662,14 @@
     case QEMU_TIMER_REALTIME:
 #ifdef _WIN32
         return GetTickCount();
+#elif defined(_BSD)
+        {
+            struct timeval r;
+            if (!gettimeofday(&r, NULL)) {
+                return ((CLK_TCK * 1000LL) * (int64_t)r.tv_sec 
+                      + ((int64_t)r.tv_usec * CLK_TCK) / 1000) / timer_freq;
+            }
+        }        
 #else
         {
             struct tms tp;
