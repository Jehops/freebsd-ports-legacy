diff -uNr tapedev.c
--- tapedev.c	Tue Nov 20 17:39:47 2001
+++ tapedev.c	Thu Jan 17 15:07:35 2002
@@ -194,6 +194,7 @@
 /*-------------------------------------------------------------------*/
 /* Static data areas                                                 */
 /*-------------------------------------------------------------------*/
+#ifdef GNU_MTIO_SUPPORT
 static struct mt_tape_info tapeinfo[] = MT_TAPE_INFO;
 static struct mt_tape_info densinfo[] = {
     {0x01, "NRZI (800 bpi)"},
@@ -221,6 +222,7 @@
     {0x8C, "EXB-8505 compressed"},
     {0x90, "EXB-8205 compressed"},
     {0, NULL}};
+#endif
 
 static PARSER ptab[] =
 {
@@ -1142,6 +1144,7 @@
 /*-------------------------------------------------------------------*/
 static U32 status_scsitape (DEVBLK *dev)
 {
+#ifdef HAVE_MTIO_H
 U32             stat;                   /* Tape status bits          */
 int             rc;                     /* Return code               */
 struct mtget    stblk;                  /* Area for MTIOCGET ioctl   */
@@ -1158,6 +1161,7 @@
                 dev->filename, strerror(errno));
         return 0;
     }
+#ifdef GNU_MTIO_SUPPORT
     stat = stblk.mt_gstat;
 
     /* Display tape status */
@@ -1190,10 +1194,14 @@
         dev->prvblkpos = -1;
         dev->blockid = 0;
     }
+#else
+	stat = 0;
+#endif
 
     /* Return tape status */
     return stat;
 
+#endif
 } /* end function status_scsitape */
 
 /*-------------------------------------------------------------------*/
@@ -1204,6 +1212,7 @@
 /*-------------------------------------------------------------------*/
 static int open_scsitape (DEVBLK *dev, BYTE *unitstat)
 {
+#ifdef HAVE_MTIO_H
 int             rc;                     /* Return code               */
 int             i;                      /* Array subscript           */
 struct mtop     opblk;                  /* Area for MTIOCTOP ioctl   */
@@ -1248,6 +1257,7 @@
         return -1;
     }
 
+#ifdef GNU_MTIO_SUPPORT
     /* Intervention required if no tape is mounted */
     if (GMT_DR_OPEN(stblk.mt_gstat))
     {
@@ -1283,6 +1293,7 @@
 
     /* Set the tape device to process variable length blocks */
     opblk.mt_op = MTSETBLK;
+#endif
     opblk.mt_count = 0;
     rc = ioctl (dev->fd, MTIOCTOP, (char*)&opblk);
     if (rc < 0)
@@ -1311,6 +1322,12 @@
 
     return 0;
 
+#else
+
+	logmsg ("HHC286I SCSI Support is disabled\n");
+	return -1;
+
+#endif
 } /* end function open_scsitape */
 
 /*-------------------------------------------------------------------*/
@@ -1323,6 +1340,7 @@
 /*-------------------------------------------------------------------*/
 static int read_scsitape (DEVBLK *dev, BYTE *buf, BYTE *unitstat)
 {
+#ifdef HAVE_MTIO_H
 int             rc;                     /* Return code               */
 
     /* Read data block from SCSI tape device */
@@ -1346,6 +1364,12 @@
     /* Return block length or zero if tapemark  */
     return rc;
 
+#else
+
+	logmsg ("HHC286I SCSI Support is disabled\n");
+	return -1;
+
+#endif
 } /* end function read_scsitape */
 
 /*-------------------------------------------------------------------*/
@@ -1357,6 +1381,7 @@
 static int write_scsitape (DEVBLK *dev, BYTE *buf, U16 len,
                         BYTE *unitstat)
 {
+#ifdef HAVE_MTIO_H
 int             rc;                     /* Return code               */
 
     /* Write data block to SCSI tape device */
@@ -1376,6 +1401,12 @@
     /* Return normal status */
     return 0;
 
+#else
+
+	logmsg ("HHC286I SCSI Support is disabled\n");
+	return -1;
+
+#endif
 } /* end function write_scsitape */
 
 /*-------------------------------------------------------------------*/
@@ -1386,6 +1417,7 @@
 /*-------------------------------------------------------------------*/
 static int write_scsimark (DEVBLK *dev, BYTE *unitstat)
 {
+#ifdef HAVE_MTIO_H
 int             rc;                     /* Return code               */
 struct mtop     opblk;                  /* Area for MTIOCTOP ioctl   */
 
@@ -1408,6 +1440,12 @@
     /* Return normal status */
     return 0;
 
+#else
+
+	logmsg ("HHC286I SCSI Support is disabled\n");
+	return -1;
+
+#endif
 } /* end function write_scsimark */
 
 /*-------------------------------------------------------------------*/
@@ -1420,6 +1458,7 @@
 /*-------------------------------------------------------------------*/
 static int fsb_scsitape (DEVBLK *dev, BYTE *unitstat)
 {
+#ifdef HAVE_MTIO_H
 int             rc;                     /* Return code               */
 int             fsrerrno;               /* Value of errno after MTFSR*/
 U32             stat;                   /* Tape status bits          */
@@ -1434,6 +1473,7 @@
     /* Obtain tape status after forward space */
     stat = status_scsitape (dev);
 
+#ifdef GNU_MTIO_SUPPORT
     /* If I/O error and status indicates EOF, then a tapemark
        was detected, so increment the file number and return 0 */
     if (rc < 0 && fsrerrno == EIO && GMT_EOF(stat))
@@ -1442,6 +1482,7 @@
         dev->blockid++;
         return 0;
     }
+#endif
 
     /* Handle MTFSR error condition */
     if (rc < 0)
@@ -1460,6 +1501,12 @@
     /* Return +1 to indicate forward space successful */
     return +1;
 
+#else
+
+	logmsg ("HHC286I SCSI Support is disabled\n");
+	return -1;
+
+#endif
 } /* end function fsb_scsitape */
 
 /*-------------------------------------------------------------------*/
@@ -1472,6 +1519,7 @@
 /*-------------------------------------------------------------------*/
 static int bsb_scsitape (DEVBLK *dev, BYTE *unitstat)
 {
+#ifdef HAVE_MTIO_H
 int             rc;                     /* Return code               */
 int             bsrerrno;               /* Value of errno after MTBSR*/
 U32             stat;                   /* Tape status bits          */
@@ -1480,6 +1528,7 @@
     /* Obtain tape status before backward space */
     stat = status_scsitape (dev);
 
+#ifdef GNU_MTIO_SUPPORT
     /* Unit check if already at start of tape */
     if (GMT_BOT(stat))
     {
@@ -1488,6 +1537,7 @@
         *unitstat = CSW_CE | CSW_DE | CSW_UC;
         return -1;
     }
+#endif
 
     /* Backspace block on SCSI tape */
     opblk.mt_op = MTBSR;
@@ -1526,6 +1576,12 @@
     /* Return +1 to indicate backspace successful */
     return +1;
 
+#else
+
+	logmsg ("HHC286I SCSI Support is disabled\n");
+	return -1;
+
+#endif
 } /* end function bsb_scsitape */
 
 /*-------------------------------------------------------------------*/
@@ -1537,6 +1593,7 @@
 /*-------------------------------------------------------------------*/
 static int fsf_scsitape (DEVBLK *dev, BYTE *unitstat)
 {
+#ifdef HAVE_MTIO_H
 int             rc;                     /* Return code               */
 struct mtop     opblk;                  /* Area for MTIOCTOP ioctl   */
 
@@ -1562,6 +1619,12 @@
     /* Return normal status */
     return 0;
 
+#else
+
+	logmsg ("HHC286I SCSI Support is disabled\n");
+	return -1;
+
+#endif
 } /* end function fsf_scsitape */
 
 /*-------------------------------------------------------------------*/
@@ -1573,6 +1636,7 @@
 /*-------------------------------------------------------------------*/
 static int bsf_scsitape (DEVBLK *dev, BYTE *unitstat)
 {
+#ifdef HAVE_MTIO_H
 int             rc;                     /* Return code               */
 struct mtop     opblk;                  /* Area for MTIOCTOP ioctl   */
 
@@ -1599,6 +1663,12 @@
     /* Return normal status */
     return 0;
 
+#else
+
+	logmsg ("HHC286I SCSI Support is disabled\n");
+	return -1;
+
+#endif
 } /* end function bsf_scsitape */
 
 /*-------------------------------------------------------------------*/
@@ -2725,7 +2795,9 @@
 
         case TAPEDEVT_SCSITAPE:
             stat = status_scsitape (dev);
+#ifdef GNU_MTIO_SUPPORT
             if (GMT_BOT(stat)) dev->sense[1] |= SENSE1_TAPE_LOADPT;
+#endif
             break;
 
         case TAPEDEVT_OMATAPE:
