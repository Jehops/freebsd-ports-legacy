--- modules/freebsd/vmblock/vfsops.c	2008-03-31 12:17:24.000000000 +0200
+++ modules/freebsd/vmblock/vfsops.c	2008-03-31 12:28:18.000000000 +0200
@@ -187,7 +187,11 @@
     * Make sure the node alias worked
     */
    if (error) {
-      VOP_UNLOCK(vp, 0, td);
+#if __FreeBSD_version > 800001
+      VOP_UNLOCK(vp, 0);
+#else
+      VOP_UNLOCK(vp, 0,td);
+#endif
       vrele(lowerrootvp);
       free(xmp, M_VMBLOCKFSMNT);   /* XXX */
       return error;
@@ -209,7 +213,11 @@
    /*
     * Unlock the node (either the lower or the alias)
     */
-   VOP_UNLOCK(vp, 0, td);
+#if __FreeBSD_version > 800001
+   VOP_UNLOCK(vp, 0);
+#else
+   VOP_UNLOCK(vp, 0,td);
+#endif
 
    /*
     * If the staging area is a local filesystem, reflect that here, too.  (We
@@ -288,14 +296,22 @@
     * transfer will happen atomically.  (Er, at least within the scope of
     * the vnode subsystem.)
     */
+#if __FreeBSD_version > 800001
+   VOP_LOCK(vp, LK_EXCLUSIVE|LK_RETRY|LK_INTERLOCK);
+#else
    VOP_LOCK(vp, LK_EXCLUSIVE|LK_RETRY|LK_INTERLOCK, td);
+#endif
 
    removed = BlockRemoveAllBlocks(OS_UNKNOWN_BLOCKER);
 
    VI_LOCK(vp);
    vp->v_usecount -= removed;
    VI_UNLOCK(vp);
+#if __FreeBSD_version > 800001
+   VOP_UNLOCK(vp, 0);
+#else
    VOP_UNLOCK(vp, 0, td);
+#endif
 
    if (mntflags & MNT_FORCE) {
       flags |= FORCECLOSE;
@@ -346,7 +362,11 @@
     */
    vp = MNTTOVMBLOCKMNT(mp)->rootVnode;
    VREF(vp);
+#if __FreeBSD_version > 800001
+   vn_lock(vp, flags | LK_RETRY);
+#else
    vn_lock(vp, flags | LK_RETRY, td);
+#endif
    *vpp = vp;
    return 0;
 }
--- modules/freebsd/vmhgfs/os.c	2008-03-19 08:49:45.000000000 +0100
+++ modules/freebsd/vmhgfs/os.c	2008-03-31 12:08:34.000000000 +0200
@@ -38,6 +38,13 @@
 #include "os.h"
 #include "debug.h"
 
+#if __FreeBSD_version > 800001
+#define kthread_create(func, farg, proc_ptr, flags, stackpgs, fmtstr) \
+        kproc_create(func, farg, proc_ptr, flags, stackpgs, fmtstr)
+#define kthread_exit(int) \
+	kproc_exit(int)
+#endif
+
 /*
  * Malloc tag for statistics, debugging, etc.
  */
--- modules/freebsd/vmhgfs/state.c	2008-03-19 08:49:45.000000000 +0100
+++ modules/freebsd/vmhgfs/state.c	2008-03-31 12:40:21.000000000 +0200
@@ -1064,7 +1064,11 @@
    /*
     * Return a locked vnode to the caller.
     */
+#if __FreeBSD_version > 800001
+   lockmgr(vp->v_vnlock, LK_EXCLUSIVE, NULL);
+#else
    lockmgr(vp->v_vnlock, LK_EXCLUSIVE, NULL, curthread);
+#endif
 
    /*
     * Now we'll initialize the vnode.  We need to set the file type, vnode
--- modules/freebsd/vmhgfs/vfsops.c	2008-03-31 12:17:24.000000000 +0200
+++ modules/freebsd/vmhgfs/vfsops.c	2008-03-31 12:40:50.000000000 +0200
@@ -169,7 +169,11 @@
    sip->rootVnode = vp;
 
    /* We're finished with the root vnode, so unlock it. */
+#if __FreeBSD_version > 800001
+   VOP_UNLOCK(vp, 0);
+#else
    VOP_UNLOCK(vp, 0, td);
+#endif
 
    /*
     * Initialize this file system's Hgfs requests container.
--- modules/freebsd/vmblock/vnops.c.orig	2008-03-31 14:39:16.000000000 +0200
+++ modules/freebsd/vmblock/vnops.c	2008-03-31 14:42:46.000000000 +0200
@@ -573,7 +573,9 @@
 */
 {
    struct componentname *cnp = ap->a_cnp;
+#if __FreeBSD_version <= 800001
    struct thread *td = cnp->cn_thread;
+#endif
    struct vnode *dvp = ap->a_dvp;
    struct vnode *vp, *ldvp, *lvp;
    BlockHandle blockCookie;
@@ -612,15 +614,27 @@
    }
 
    if ((blockCookie = BlockLookup(pathname, OS_UNKNOWN_BLOCKER)) != NULL) {
+#if __FreeBSD_version > 800001
+      int lkflags = lockstatus(dvp->v_vnlock) & LK_TYPE_MASK;
+#else
       int lkflags = lockstatus(dvp->v_vnlock, td) & LK_TYPE_MASK;
+#endif
       lvp = VPTOVMB(dvp)->lowerVnode;
       vhold(dvp);
       vhold(lvp);
+#if __FreeBSD_version > 800001
+      VOP_UNLOCK(dvp, 0);
+#else
       VOP_UNLOCK(dvp, 0, td);
+#endif
 
       error = BlockWaitOnFile(pathname, blockCookie);
 
-      VOP_LOCK(dvp, lkflags, td);
+#if __FreeBSD_version > 800001
+      VOP_LOCK(dvp, lkflags);
+#else
+      VOP_UNLOCK(dvp, lkflags, td);
+#endif
       vdrop(lvp);
       vdrop(dvp);
       if (dvp->v_op != &VMBlockVnodeOps) {
@@ -835,7 +849,9 @@
 {
    VMBlockIoctlArgs *ioctlArgs = (VMBlockIoctlArgs *)ap->a_data;
    VMBlockMount *mp;
+#if __FreeBSD_version <= 800001
    struct thread *td = ap->a_td;
+#endif
    struct vnode *vp = ap->a_vp;
    char *pathbuf = NULL;
    int ret = 0, pathlen;
@@ -850,10 +866,18 @@
     *       may be invalid.
     *   2.  Make sure the filesystem isn't being unmounted.
     */
+#if __FreeBSD_version > 800001
+   VOP_LOCK(vp, LK_EXCLUSIVE|LK_RETRY);
+#else
    VOP_LOCK(vp, LK_EXCLUSIVE|LK_RETRY, td);
+#endif
    if (vp->v_op != &VMBlockVnodeOps ||
        vp->v_mount->mnt_kern_flag & MNTK_UNMOUNT) {
+#if __FreeBSD_version > 800001
+      VOP_UNLOCK(vp, 0);
+#else
       VOP_UNLOCK(vp, 0, td);
+#endif
       return EBADF;
    }
 
@@ -870,7 +894,11 @@
        * argument before passing to the lower layer.
        */
       ap->a_data = ioctlArgs->data;
+#if __FreeBSD_version > 800001
+      VOP_UNLOCK(vp, 0);
+#else
       VOP_UNLOCK(vp, 0, td);
+#endif
       return VMBlockVopBypass((struct vop_generic_args *)ap);
    }
 
@@ -938,7 +966,11 @@
       ret = EOPNOTSUPP;
    }
 
+#if __FreeBSD_version > 800001
+   VOP_UNLOCK(vp, 0);
+#else
    VOP_UNLOCK(vp, 0, td);
+#endif
    if (pathbuf) {
       uma_zfree(VMBlockPathnameZone, pathbuf);
    }
@@ -1132,7 +1164,9 @@
 {
    struct vnode *vp = ap->a_vp;
    int flags = ap->a_flags;
+#if __FreeBSD_version <= 800001
    struct thread *td = ap->a_td;
+#endif
    struct VMBlockNode *nn;
    struct vnode *lvp;
    int error;
@@ -1160,7 +1194,11 @@
        * We prevent it from being recycled by holding the vnode here.
        */
       vholdl(lvp);
+#if __FreeBSD_version > 800001
+      error = VOP_LOCK(lvp, flags);
+#else
       error = VOP_LOCK(lvp, flags, td);
+#endif
 
       /*
        * We might have slept to get the lock and someone might have clean
@@ -1182,7 +1220,11 @@
             panic("Unsupported lock request %d\n",
                 ap->a_flags);
          }
+#if __FreeBSD_version > 800001
+         VOP_UNLOCK(lvp, 0);
+#else
          VOP_UNLOCK(lvp, 0, td);
+#endif
          error = vop_stdlock(ap);
       }
       vdrop(lvp);
@@ -1226,7 +1268,9 @@
 {
    struct vnode *vp = ap->a_vp;
    int flags = ap->a_flags;
+#if __FreeBSD_version <= 800001
    struct thread *td = ap->a_td;
+#endif
    struct VMBlockNode *nn;
    struct vnode *lvp;
    int error;
@@ -1241,7 +1285,11 @@
    }
    nn = VPTOVMB(vp);
    if (nn != NULL && (lvp = VMBVPTOLOWERVP(vp)) != NULL) {
+#if __FreeBSD_version > 800001
+      error = VOP_UNLOCK(lvp, flags);
+#else
       error = VOP_UNLOCK(lvp, flags, td);
+#endif
    } else {
       error = vop_stdunlock(ap);
    }
@@ -1276,9 +1324,15 @@
 */
 {
    struct vnode *vp = ap->a_vp;
+#if __FreeBSD_version <= 800001
    struct thread *td = ap->a_td;
 
    return lockstatus(vp->v_vnlock, td);
+#else
+
+   return lockstatus(vp->v_vnlock);
+#endif
+
 }
 
 
@@ -1392,7 +1446,11 @@
     * to the lower layer's lock.)
     */
    vp->v_vnlock = &vp->v_lock;
+#if __FreeBSD_version > 800001
+   lockmgr(vp->v_vnlock, LK_EXCLUSIVE|LK_INTERLOCK, VI_MTX(vp));
+#else
    lockmgr(vp->v_vnlock, LK_EXCLUSIVE|LK_INTERLOCK, VI_MTX(vp), curthread);
+#endif
    vput(lowervp);
 
    /*
