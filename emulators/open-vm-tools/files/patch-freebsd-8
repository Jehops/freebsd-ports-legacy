--- modules/freebsd/vmhgfs/vnops.c.orig	2009-02-18 17:02:35.000000000 +0900
+++ modules/freebsd/vmhgfs/vnops.c	2009-03-01 17:47:10.000000000 +0900
@@ -325,7 +325,11 @@
 */
 {
    struct vnode *vp = ap->a_vp;
+#if __FreeBSD_version >= 800001
+   int mode = ap->a_accmode;
+#else
    int mode = ap->a_mode;
+#endif
    HgfsAccessMode accessMode = 0;
    Bool isDir = vp->v_type == VDIR;
    if (mode & VREAD) {
--- modules/freebsd/vmblock/vnops.c.orig	2009-03-18 03:03:21.000000000 -0400
+++ modules/freebsd/vmblock/vnops.c	2009-04-04 20:33:28.000000000 -0400
@@ -726,7 +726,11 @@
        * NB:  Allowing only the superuser to open this directory breaks
        *      readdir() of the filesystem root for non-privileged users.
        */
-      if ((retval = suser(ap->a_td)) == 0) {
+ #if __FreeBSD_version >= 800001
+       if ((retval = priv_check(ap->a_td, PRIV_VFS_GETFH)) == 0) {
+ #else
+        if ((retval = suser(ap->a_td)) == 0) {
+ #endif
 #if __FreeBSD_version >= 700055
          fp = ap->a_fp;
 #else
@@ -1010,7 +1014,11 @@
 */
 {
    struct vnode *vp = ap->a_vp;
+#if __FreeBSD_version >= 800001
+   mode_t mode = ap->a_accmode;
+#else
    mode_t mode = ap->a_mode;
+#endif
 
    /*
     * Disallow write attempts on read-only layers; unless the file is a
--- modules/freebsd/vmblock/vfsops.c.orig	2009-03-18 03:03:21.000000000 -0400
+++ modules/freebsd/vmblock/vfsops.c	2009-05-23 02:25:50.892549675 -0400
@@ -113,8 +113,12 @@
  */
 
 static int
+#if __FreeBSD_version >= 800087
+VMBlockVFSMount(struct mount *mp)
+#else
 VMBlockVFSMount(struct mount *mp,       // IN: mount(2) parameters
                 struct thread *td)      // IN: caller's kernel thread context
+#endif
 {
    struct VMBlockMount *xmp;
    struct nameidata nd, *ndp = &nd;
@@ -122,6 +126,11 @@
    char *target;
    int len, error = 0;
 
+#if __FreeBSD_version >= 800087
+   struct thread *td;
+   td = curthread;
+#endif
+
    VMBLOCKDEBUG("VMBlockVFSMount(mp = %p)\n", (void *)mp);
 
    /*
@@ -253,9 +262,14 @@
  */
 
 static int
+#if __FreeBSD_version >= 800087
+VMBlockVFSUnmount(struct mount *mp,
+                  int mntflags)
+#else
 VMBlockVFSUnmount(struct mount *mp,     // IN: filesystem to unmount
                   int mntflags,         // IN: unmount(2) flags (ex: MNT_FORCE)
                   struct thread *td)    // IN: caller's kernel thread context
+#endif
 {
    struct VMBlockMount *xmp;
    struct vnode *vp;
@@ -263,6 +277,11 @@
    int error;
    int flags = 0, removed = 0;
 
+#if __FreeBSD_version >= 800087
+   struct thread *td;
+   td = curthread;
+#endif
+
    VMBLOCKDEBUG("VMBlockVFSUnmount: mp = %p\n", (void *)mp);
 
    xmp = MNTTOVMBLOCKMNT(mp);
@@ -336,13 +355,24 @@
  */
 
 static int
+#if __FreeBSD_version >= 800087
+VMBlockVFSRoot(struct mount *mp,
+               int flags,
+	       struct vnode **vpp)
+#else
 VMBlockVFSRoot(struct mount *mp,        // IN: vmblock file system
                int flags,               // IN: lockmgr(9) flags
                struct vnode **vpp,      // OUT: root vnode
                struct thread *td)       // IN: caller's thread context
+#endif
 {
    struct vnode *vp;
 
+#if __FreeBSD_version >= 800087
+   struct thread *td;
+   td = curthread;
+#endif
+
    /*
     * Return locked reference to root.
     */
@@ -373,12 +403,21 @@
  */
 
 static int
+#if __FreeBSD_version >= 800087
+VMBlockVFSStatFS(struct mount *mp,
+                 struct statfs *sbp)
+#else
 VMBlockVFSStatFS(struct mount *mp,      // IN: vmblock file system
                  struct statfs *sbp,    // OUT: statfs(2) arg container
                  struct thread *td)     // IN: caller's thread context
+#endif
 {
    int error;
    struct statfs mstat;
+#if __FreeBSD_version >= 800087
+   struct thread *td;
+   td = curthread;
+#endif
 
    VMBLOCKDEBUG("VMBlockVFSStatFS(mp = %p, vp = %p->%p)\n", (void *)mp,
        (void *)MNTTOVMBLOCKMNT(mp)->rootVnode,
@@ -386,7 +425,11 @@
 
    bzero(&mstat, sizeof mstat);
 
+#if __FreeBSD_version >= 800087
+   error = VFS_STATFS(MNTTOVMBLOCKMNT(mp)->mountVFS, &mstat);
+#else
    error = VFS_STATFS(MNTTOVMBLOCKMNT(mp)->mountVFS, &mstat, td);
+#endif
    if (error) {
       return error;
    }
@@ -423,9 +466,14 @@
  */
 
 static int
+#if __FreeBSD_version >= 800087
+VMBlockVFSSync(struct mount *mp,
+               int waitfor)
+#else
 VMBlockVFSSync(struct mount *mp,        // Ignored
                int waitfor,             // Ignored
                struct thread *td)       // Ignored
+#endif
 {
    return 0;
 }
--- modules/freebsd/vmhgfs/vfsops.c.orig	2009-03-18 03:03:26.000000000 -0400
+++ modules/freebsd/vmhgfs/vfsops.c	2009-05-23 02:56:39.608109670 -0400
@@ -109,8 +109,12 @@
  */
 
 static int
+#if __FreeBSD_version >= 800087
+HgfsVfsMount(struct mount *mp)
+#else
 HgfsVfsMount(struct mount *mp,  // IN: structure representing the file system
              struct thread *td) // IN: thread which is mounting the file system
+#endif
 {
    HgfsSuperInfo *sip;
    struct vnode *vp;
@@ -122,6 +126,10 @@
    int *uid = NULL;
    Bool *gidSet = NULL;
    int *gid = NULL;
+#if __FreeBSD_version >= 800087
+   struct thread *td;
+   td = curthread;
+#endif
 
    /*
     * - Examine/validate mount flags from userland.
@@ -145,7 +153,11 @@
     * Since Hgfs requires the caller to be root, only allow mount attempts made
     * by the superuser.
     */
+#if __FreeBSD_version >= 800001
+   if ((ret = priv_check(td, PRIV_VFS_MOUNT)) != 0) {
+#else
    if ((ret = suser(td)) != 0) {
+#endif
       return ret;
    }
 
@@ -277,11 +289,19 @@
  */
 
 static int
+#if __FreeBSD_version >= 800087
+HgfsVfsUnmount(struct mount *mp, int mntflags)
+#else
 HgfsVfsUnmount(struct mount *mp, int mntflags, struct thread *td)
+#endif
 {
    HgfsSuperInfo *sip;
    int ret = 0;
    int flags = 0;
+#if __FreeBSD_version >= 800087
+   struct thread *td;
+   td = curthread;
+#endif
 
    sip = (HgfsSuperInfo *)mp->mnt_data;
 
@@ -348,10 +368,18 @@
  */
 
 static int
+#if __FreeBSD_version >= 800087
+HgfsVfsStatfs(struct mount *mp, struct statfs *sbp)
+#else
 HgfsVfsStatfs(struct mount *mp, struct statfs *sbp, struct thread *td)
+#endif
 {
    int ret = 0;
    struct vnode *vp;
+#if __FreeBSD_version >= 800087
+   struct thread *td;
+   td = curthread;
+#endif
 
    /* We always want HGFS_BLOCKSIZE to be a power of two */
    ASSERT_ON_COMPILE(HGFS_IS_POWER_OF_TWO(HGFS_BLOCKSIZE));
@@ -361,8 +389,11 @@
     * we got from a call to vfs_getnewfsid() in HgfsVfsMount()
     */
    bcopy(&mp->mnt_stat, sbp, sizeof mp->mnt_stat);
-
+#if __FreeBSD_version >= 800087
+   ret = HgfsVfsRoot(mp, LK_SHARED, &vp);
+#else
    ret = HgfsVfsRoot(mp, LK_SHARED, &vp, td);
+#endif
    if (ret) {
       DEBUG(VM_DEBUG_FAIL, "HgfsVfsRoot failed\n");
       return ret;
@@ -397,13 +428,23 @@
  */
 
 static int
+#if __FreeBSD_version >= 800087
+HgfsVfsRoot(struct mount *mp,
+            int flags,
+	    struct vnode **vpp)
+#else
 HgfsVfsRoot(struct mount *mp,   // IN: Filesystem structure
             int flags,          // IN: Flags to vget
             struct vnode **vpp, // OUT: Address of root vnode
             struct thread *td)  // IN: Thread structure
+#endif
 {
    HgfsSuperInfo *sip = (HgfsSuperInfo *)mp->mnt_data;
    int ret = 0;
+#if __FreeBSD_version >= 800087
+   struct thread *td;
+   td = curthread;
+#endif
 
    *vpp = NULL;
 
