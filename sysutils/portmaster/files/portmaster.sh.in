#!/bin/sh

# Local version: 1.101
# $FreeBSD$

# Copyright (c) 2005-2006 Douglas Barton, All rights reserved
# Please see detailed copyright below

trap trap_exit INT

# Keep track of the parent process
if [ -z "$PARENT_PID" ]; then
	PARENT_PID=$$
	export PARENT_PID
fi

# %%LOCALBASE%% and %%X11BASE%% are needed in path for make
PATH=/bin:/usr/bin:/sbin:/usr/sbin:%%LOCALBASE%%/bin:%%X11BASE%%/bin
if [ -n "$CCACHE_PATH" ]; then
	if [ -z "$NOCCACHE" ]; then
		PATH="%%LOCALBASE%%/libexec/ccache:$PATH"
	fi
fi
export PATH

umask 022

usage () {
	VERSION_NUMBER=`grep "[$]FreeBSD:" $0 | cut -d ' ' -f 4`
	echo "portmaster version $VERSION_NUMBER"
	echo ''
	echo 'Usage:'
	echo "Common flags: [-CGbgnv uf|i D|d] [-m <arguments for make>]"
	echo "${0##*/} [Common flags] <full name of port directory in $pdb>"
	echo "${0##*/} [Common flags] <glob pattern of directory in $pdb>"
	echo "${0##*/} [Common flags] -p <port directory in $pd>"
	echo "${0##*/} [Common flags] <full path to $pd/foo/bar>"
	echo "${0##*/} [Common flags] -o <new port dir in $pd> <installed port>"
	echo "${0##*/} [Common flags] -r <name/glob of port directory in $pdb>"
	echo "${0##*/} -a [Common flags]"
	echo "${0##*/} -[l|L]"
	echo "${0##*/} -s"
	echo "${0##*/} -h"
	echo ''
	echo "-C prevents 'make clean' being run in port directory"
	echo "-G prevents recursive 'make config'"
	echo '-b create a backup package of the installed port (if any)'
	echo '-g create a package of the new port'
	echo '-n do not actually make or install any ports'
	echo '-v verbose output'
	echo "-u unattended mode -- accept defaults for all but 'make config'"
	echo '-f always rebuild ports (overrides -i)'
	echo '-i interactive update mode'
	echo '-D prevents cleaning of distfiles'
	echo '-d always clean distfiles'
	echo "-m <arguments for the 'make' command line>"
	echo ''
	echo '-o Replace the installed port with a port from a different origin'
	echo '-r rebuild port, and all ports that depend on it'
	echo '-a check all ports, update as necessary'
	echo ''
	echo '-l list installed ports by category'
	echo '-L list installed ports by category, and search for updates'
	echo '-s clean out stale ports that used to be depended on'
	echo ''
	echo '-h display this help file'
	echo ''
	exit 1
}

fail () {
	echo ''
	echo "===>>> $1"
	echo "===>>> Aborting update"
	exit 1
}

trap_exit () {
	local pid

	if [ -n "$portdir" ]; then
		echo "===>>> Upgrade for $portdir exiting due to signal"
	else
		echo "===>>> Exiting due to signal"
	fi

	if [ "$$" -eq "$PARENT_PID" ]; then
		for file in ${TMPDIR:-/tmp}/fetchlog-${PARENT_PID}-*; do
			pid=`awk '/^MCS_CHILD_PID / {print $2}' $file 2>/dev/null`
			test -n "$pid" || continue
			echo -n "===>>> Child process $pid: "
			if kill $pid >/dev/null 2>&1; then
				echo Terminated
			else
				if ps -p $pid >/dev/null; then
					echo "Did not die!"
				else
					echo Terminated
				fi
			fi
			rm -f $file
		done
	fi

	safe_exit
}

safe_exit () {
	echo ''
	test -n "$grep_deps" && rm -f $grep_deps
	test -n "$req_deps" && rm -f $req_deps

	if [ "$$" -eq "$PARENT_PID" ]; then
		test -n "$NO_DEP_UPDATES" && rm -f $NO_DEP_UPDATES
		test -n "$IPC_SAVE" && rm -f $IPC_SAVE
	else
		# Save state for the parent process to read back in
		echo "CURRENT_DEPS_O='$CURRENT_DEPS_O'" >> $IPC_SAVE
		echo "CURRENT_DEPS_I='$CURRENT_DEPS_I'" >> $IPC_SAVE

		if [ -n "$INTERACTIVE_UPDATE" ]; then
			echo "INTERACTIVE_YES='$INTERACTIVE_YES'" >> $IPC_SAVE
		fi
		if [ -n "$FORCE" ]; then
			echo "FORCE_DONE_LIST='$FORCE_DONE_LIST'" >> $IPC_SAVE
		fi
	fi

	exit 0
}

update_contents () {
	local tempfile

	tempfile=`mktemp -t tempfile-${new_port}`

	sed "s/@pkgdep $1/@pkgdep $2/" $dep_port_contents > $tempfile &&
	    mv $tempfile $pdb/$dep_port/+CONTENTS
	    chmod 644 $pdb/$dep_port/+CONTENTS

	if [ -n "$oldportdir" ]; then
		sed "s%N:${oldportdir}\$%N:${newportdir}%" $dep_port_contents > $tempfile &&
		    mv $tempfile $pdb/$dep_port/+CONTENTS
		    chmod 644 $pdb/$dep_port/+CONTENTS

	fi
}

dep_warn () {
	local num_ports1

	echo ''
	echo "===>>> Warning! Potential unrecorded dependencies on $new_port"
	echo "===>>> From existing +CONTENTS files:"
	grep -B1 DEPORIGIN:$upg_origin$ $pdb/*/+CONTENTS |
	    sort -u | sed -e "s#$pdb/##" -e 1d
	num_ports1=`grep DEPORIGIN:$upg_origin$ $pdb/*/+CONTENTS |
	    sort -u | wc -l | awk '{print $1}'`
	echo "===>>> $num_ports1 ports"
	echo ''
}

update_reqfile () {
	local num_ports2 sdiff_deps

	dep_warn
	num_ports2=`wc -l $req_deps | awk '{print $1}'`
	echo "===>>> From $pdb/$upg_port/+REQUIRED_BY:"
	cat $req_deps
	echo "===>>> $num_ports2 ports"
	echo ''
	echo "===>>> Use dependencies from existing +CONTENTS files	[c]"
	echo "===>>> Use dependencies from existing +REQUIRED_BY file	[r]"
	echo "===>>> Use sdiff to edit both files into a new file	[s]"
	echo ''
	if [ -z "$UNATTENDED" ]; then
		echo -n "===>>> Update dependency list? [r] "
		read DEPUPDATE

		case "$DEPUPDATE" in
		[cC])	mv $grep_deps $req_deps ; unset grep_deps ;;
		[sS])	sdiff_deps=`mktemp -t sdiff-deps-${short_port}`
			sdiff -o $sdiff_deps --text --suppress-common-lines \
			    --width=`tput columns` $req_deps $grep_deps
			mv $sdiff_deps $req_deps
			;;
		esac
	else
		echo "===>>> Default (use +REQUIRED_BY file) in unattended mode"
	fi
}

update_port () {
	local upd

	if [ -n "$NO_DEP_UPDATES" ]; then
		rm -f $NO_DEP_UPDATES
		unset NO_DEP_UPDATES
	fi

	case "$1" in
	-p)	upd=$2 ;;
	*)	upd=$1 ;;
	esac

	echo "===>>> Launching child to update ${upd#$pd/}"
	echo ''
	if [ -z "$NO_ACTION" ]; then
		($0 $ARGS $@) || fail "Update for $upd failed"
		. $IPC_SAVE
	else
		test -n "$VERBOSE" &&
		    echo "===>>> Build canceled due to -n flag"
	fi

	if [ -n "$UPDATE_ALL" ]; then
		echo "===>>> Returning to update check of installed ports"
	elif [ -n "$UPDATE_REQ_BYS" ]; then
		return 0
	elif [ -n "$CONFIG_ONLY" ]; then
		echo "===>>> Continuing 'make config' dependency check for $portdir"
	else
		echo "===>>> Returning to dependency check for $portdir"
	fi

	return 0
}

check_interactive () {
	local UPD_OR_NOT

	if [ -n "$INTERACTIVE_UPDATE" ]; then
		case "$INTERACTIVE_YES" in
		*:${1}:*)	return 0 ;;
		esac

		test -n "$INTERACTIVE_BUILDING" && return 1

		echo -n "===>>> Update ${1}? [y] "
		read UPD_OR_NOT
		case "$UPD_OR_NOT" in
		[nN]*)	return 1 ;;
		esac

		INTERACTIVE_YES="${INTERACTIVE_YES}${1}:"
	fi

	return 0
}

iport_from_origin () {
	local dir

	dir=`grep -l "@comment ORIGIN:${1}$" $pdb/*/+CONTENTS`
	dir="${dir%/+CONTENTS}"
	dir="${dir#$pdb/}"

	echo $dir
}

origin_from_pdb () {
	grep '@comment ORIGIN' ${1}/+CONTENTS 2>/dev/null | cut -f2 -d':'
}

check_for_updates () {
	local upd_port port_ver do_update

	upd_port=`origin_from_pdb $pdb/$1`
	if [ -z "$upd_port" ]; then
		if [ -n "$VERBOSE" ]; then
			echo "===>>> No ORIGIN in $pdb/$1/+CONTENTS"
			echo ''
		fi
		return 0
	fi

	if [ -d "$pd/$upd_port" ]; then
		cd $pd/$upd_port ||
		    fail "Cannot cd to port directory: $pd/$upd_port"
		port_ver=`make $MAKE_ARGS -V PKGNAME`

		if [ "$1" = "$port_ver" ]; then
			if [ -z "$LIST" -a -z "$LIST_PLUS" ]; then
				# Keep list both ways to increase performance
				CURRENT_DEPS_O="${CURRENT_DEPS_O}${upd_port}:"
				CURRENT_DEPS_I="${CURRENT_DEPS_I}${1}:"
			fi
			return 0
		fi

		case `pkg_version -t $1 $port_ver` in
		\<)	do_update=yes ;;
		*)	if [ -n "$VERBOSE" ]; then
				echo ''
				echo "	===>>> Port version $port_ver does not"
				echo "	===>>> seem newer than installed $1"
				echo ''
			fi
			;;
		esac
	else
		# This will fail if it doesn't exist anymore
		# It will return 1 if we know nothing about the port
		find_moved_port $upd_port || return 0

		# If the port has moved, we have to update it
		do_update=yes
	fi

	if [ -n "$do_update" ]; then
		case "$2" in
		list)	if [ -z "$newportdir" ]; then
				echo "	===>>> New version available: $port_ver"
				num_updates=$(( $num_updates + 1 ))
			else
				unset newportdir
			fi
			return 0
			;;
		esac

		if ! check_interactive $1 ; then
			return 0
		fi

		update_port $1 || return 1
	fi

	return 0
}

find_moved_port () {
	# newportdir and oldportdir are used globally
	local m

	newportdir=`sed -ne "s#^${1}|\([^|]*\)|.*#\1#p" $pd/MOVED`
	if [ ! -n "$newportdir" ]; then
		m=`sed -ne "s#^${1}||.*|\(.*\)#\1#p" $pd/MOVED`
		if [ -n "$m" ]; then
			fail "The $1 port has been deleted: $m"
		else
			echo ''
			echo "===>>> No $pd/$1 exists, and no information"
			echo "===>>> about $1 can be found in $pd/MOVED"
			echo ''
			return 1
		fi
	fi

	m=`sed -ne "s#^${1}|.*|.*|\(.*\)#\1#p" $pd/MOVED`
	oldportdir=$1
	# Just in case there was more than one match, use the last one
	newportdir=`echo $newportdir | sed 's/.* //'`
	echo ''
	echo "===>>> The $1 port has moved to $newportdir"
	echo "===>>> Reason: $m"
	echo ''

	return 0
}

ports_by_category () {
	local pkg

	for pkg in $pdb/*; do
		if [ -s "$pkg/+REQUIRED_BY" ]; then
			if grep -q '^@pkgdep ' $pkg/+CONTENTS 2>/dev/null; then
				branches="$branches $pkg"
			else
				trunks="$trunks $pkg"
			fi
		else
			if grep -q '^@pkgdep ' $pkg/+CONTENTS 2>/dev/null; then
				leaves="$leaves $pkg"
			else
				test -s $pkg/+CONTENTS && roots="$roots $pkg"
			fi
		fi
	done
}

dependency_check () {
	# Re-use dep_port_list for efficiency
	local dep_port ign_p cur_p upd_args p op old_p

	# Print a message here because sometimes all-depends-list takes
	# a long time to return.
	if [ -z "$dep_port_check_done" ]; then
		echo "===>>> Gathering dependency list for $portdir from ports"
		dep_port_list=`make $MAKE_ARGS all-depends-list`
		dep_port_check_done=yes
	fi

	if [ -z "$dep_port_list" ]; then
		echo "===>>> No dependencies for $portdir"
		return 0
	else
		if [ -n "$CONFIG_ONLY" ]; then
			echo "===>>> Starting recursive 'make config' check"
		else
			echo "===>>> Starting dependency check"
		fi
	fi

	for dep_port in $dep_port_list; do
		test -n "$VERBOSE" &&
		    echo "===>>> Checking dependency: $dep_port"

		# Do this first to catch out of date dependencies
		if [ -n "$CONFIG_ONLY" ]; then
			case "$CONFIG_SEEN_LIST" in
			*:${dep_port#$pd/}:*)	continue ;;
			esac
			CONFIG_SEEN_LIST="${CONFIG_SEEN_LIST}${dep_port#$pd/}:"
		fi

		case "$CURRENT_DEPS_O" in
		*:${dep_port#$pd/}:*)	continue ;;
		esac

		case "$FORCE_DONE_LIST" in
		*:${dep_port#$pd/}:*)	continue ;;
		esac

		cur_p=`iport_from_origin ${dep_port#$pd/}`
		if [ -n "$cur_p" ]; then
			upd_args=$cur_p
			ign_p=$cur_p
		else
			upd_args="-p $dep_port"		# Sensible default
			# Check to see if the dependency has moved because
			# if so, we need to update the old port to fix it
			p=${dep_port#$pd/}
			op=`sed -ne "s#\([^|]*\)|$p|.*#\1#p" $pd/MOVED`
			# In case there is more than one match, use the latest
			op=`echo $op | sed 's/.* //'`

			if [ -n "$op" ]; then
				old_p=`iport_from_origin ${op}`
				if [ -n "$old_p" ]; then
					upd_args=$old_p
					ign_p=$old_p
				fi
			fi
		fi

		if [ -e "$pdb/$ign_p/+IGNOREME" ]; then
			if [ -n "$VERBOSE" ]; then
				echo ''
				echo "===>>> Skipping $ign_p due to +IGNOREME file"
				echo ''
			fi
			continue
		fi

		if [ -n "$FORCE" ]; then
			echo "===>>> Forcing update for $dep_port"
			update_port $upd_args
			continue
		fi

		# If not forcing the update
		if [ -n "$cur_p" ]; then
			check_for_updates $cur_p
		elif [ -n "$old_p" ]; then
			check_for_updates $old_p
		else
			if ! check_interactive $dep_port ; then
				continue
			fi

			update_port -p $dep_port
		fi
	done
	if [ -n "$CONFIG_ONLY" ]; then
		echo "===>>> Recursive 'make config' check complete for $portdir"
	else
		echo "===>>> Dependency check complete for $portdir"
	fi
}

unset_recursive_config () {
	unset CONFIG_SEEN_LIST CONFIG_ONLY

	# Overload this variable to simplify the code
	NO_RECURSIVE_CONFIG=yes
	export NO_RECURSIVE_CONFIG
}

req_by_error () {
	local DISCARD

	echo "===>>> WARNING! $pdb/$1/+REQUIRED_BY "
	echo "===>>> shows that $2 requires $1, but "
	echo "===>>> $2 does not seem to be installed"
	echo -n "===>>> Press Enter to proceed "
	read DISCARD
}

pd=`make $MAKE_ARGS -f/dev/null -V PORTSDIR 2>/dev/null`
pdb=`make $MAKE_ARGS -f/dev/null -V PKG_DBDIR 2>/dev/null`

# Read a global rc file first
if [ -r /etc/portmaster.rc ]; then
	. /etc/portmaster.rc
fi

# Read a local one next, and allow the command line to override
if [ -r "$HOME/.portmasterrc" ]; then
	. $HOME/.portmasterrc
fi

# Set default values here so that they can be overriden above
: ${pd:=/usr/ports}
: ${pdb:=/var/db/pkg}

# Save switches for potential child processes
while getopts 'CDGLabdfghilm:nop:r:suv' COMMAND_LINE_ARGUMENT ; do
	case "${COMMAND_LINE_ARGUMENT}" in
	C)	DONT_PRE_CLEAN=yes; ARGS="-C $ARGS" ;;
	D)	DONT_SCRUB_DISTFILES=yes; ARGS="-D $ARGS" ;;
	G)	NO_RECURSIVE_CONFIG=yes; ARGS="-G $ARGS" ;;
	L)	LIST_PLUS=yes ;;
	a)	UPDATE_ALL=yes ;;
	b)	BACKUP=yes; ARGS="-b $ARGS" ;;
	d)	ALWAYS_SCRUB_DISTFILES=yes; ARGS="-d $ARGS" ;;
	f)	FORCE=yes
		FORCE_DONE_LIST=':'
		export FORCE FORCE_DONE_LIST
		;;
	g)	MAKE_PACKAGE=yes; ARGS="-g $ARGS" ;;
	h)	usage ;;
	i)	INTERACTIVE_UPDATE=yes; ARGS="-i $ARGS" ;;
	l)	LIST=yes ;;
	m)	MAKE_ARGS=$OPTARG; ARGS="-m $MAKE_ARGS $ARGS" ;;
	n)	NO_ACTION=yes ;;
	o)	REPLACE_ORIGIN=yes ;;
	p)	portdir="${OPTARG#$pd/}" ;;
	r)	UPDATE_REQ_BYS=yes; upg_port=$OPTARG ;;
	s)	CLEAN_STALE=yes ;;
	u)	UNATTENDED=yes; ARGS="-u $ARGS" ;;
	v)	VERBOSE=yes; ARGS="-v $ARGS" ;;
	*)	usage ;;
	esac
done
shift $(( $OPTIND - 1 ))

if [ -n "$LIST" -o -n "$LIST_PLUS" ]; then
	ports_by_category

	num_roots=0
	num_trunks=0
	num_branches=0
	num_leaves=0
	num_updates=0

	echo "===>>> Root ports (No dependencies, not depended on)"
	for port in $roots; do
		echo "===>>> ${port##*/}"
		[ -n "$LIST_PLUS" ] && check_for_updates ${port##*/} list
		num_roots=$(( $num_roots + 1 ))
	done
	echo "===>>> $num_roots root ports"
	echo ''
	echo "===>>> Trunk ports (No dependencies, are depended on)"
	for port in $trunks; do
		echo "===>>> ${port##*/}"
		[ -n "$LIST_PLUS" ] && check_for_updates ${port##*/} list
		num_trunks=$(( $num_trunks + 1 ))
	done
	echo "===>>> $num_trunks trunk ports"
	echo ''
	echo "===>>> Branch ports (Have dependencies, are depended on)"
	for port in $branches; do
		echo "===>>> ${port##*/}"
		[ -n "$LIST_PLUS" ] && check_for_updates ${port##*/} list
		num_branches=$(( $num_branches + 1 ))
	done
	echo "===>>> $num_branches branch ports"
	echo ''
	echo "===>>> Leaf ports (Have dependencies, not depended on)"
	for port in $leaves; do
		echo "===>>> ${port##*/}"
		[ -n "$LIST_PLUS" ] && check_for_updates ${port##*/} list
		num_leaves=$(( $num_leaves + 1 ))
	done
	echo "===>>> $num_leaves leaf ports"
	echo ''
	num_ports=$(( $num_roots + $num_trunks + $num_branches + $num_leaves ))
	echo "===>>> $num_ports total installed ports"

	if [ "$num_updates" -gt 1 ]; then
		echo "	===>>> $num_updates have new versions available"
	elif [ "$num_updates" -eq 1 ]; then
		echo "	===>>> 1 has a new version available"
	fi

	exit 0
fi

if [ -n "$CLEAN_STALE" ]; then
	if [ -z "$do_not_delete" ]; then
		do_not_delete=':'
		export do_not_delete
	fi

	for file in `find $pdb/ -name \+REQUIRED_BY -empty` ; do
		dir="${file%/+REQUIRED_BY}"

		case "$do_not_delete" in
		*:${dir#$pdb/}:*)	continue ;;
		esac

		origin=`origin_from_pdb $dir`
		deplist=`grep DEPORIGIN:$origin$ $pdb/*/+CONTENTS`
		if [ -z "$deplist" ]; then
			echo -n "===>>> ${dir#$pdb/} is no longer depended on, delete? [n] "
			read YESNO

			case "$YESNO" in
			[yY])	pkg_delete -f ${dir#$pdb/}
				exec $0 -s
				;;
			*)	do_not_delete="${do_not_delete}${dir#$pdb/}:" ;;
			esac
		else
			echo "===>>> Warning: unrecorded dependencies on ${dir#$pdb/}:"
			echo $deplist
		fi
	done

	exit 0
fi

test -n "$FORCE" && unset INTERACTIVE_UPDATE
if [ -n "$UNATTENDED" ]; then
	unset INTERACTIVE_UPDATE

	if [ -z "$DONT_SCRUB_DISTFILES" -a -z "$ALWAYS_SCRUB_DISTFILES" ]; then
		ALWAYS_SCRUB_DISTFILES=yes
		ARGS="-d $ARGS"
	fi
fi

if [ "$$" -eq "$PARENT_PID" ]; then
	NO_DEP_UPDATES=`mktemp -t no_dep_updates-$PARENT_PID`

	CURRENT_DEPS_O=':'
	CURRENT_DEPS_I=':'
	IPC_SAVE=`mktemp -t ipc_save-$PARENT_PID`
	export CURRENT_DEPS_O CURRENT_DEPS_I IPC_SAVE

	if [ -n "$INTERACTIVE_UPDATE" ]; then
		INTERACTIVE_YES=':'
		export INTERACTIVE_YES
	fi

	if [ -z "$CONFIG_ONLY" -a -z "$NO_RECURSIVE_CONFIG" ]; then
		CONFIG_SEEN_LIST=':'
		CONFIG_ONLY=yes
		export CONFIG_SEEN_LIST CONFIG_ONLY
	fi
else
	# Zero out this file so that we can save our data to it safely
	> $IPC_SAVE
fi

if [ -n "$UPDATE_ALL" ]; then
	echo "===>>> Starting check of installed ports for available updates"
	ports_by_category

	if [ -n "$CONFIG_ONLY" ]; then
		echo "===>>> Checking ports for recursive 'make config'"
		for pkg in $roots $trunks $branches $leaves; do
			test -n "$VERBOSE" &&
			    echo "===>>> Checking installed port: ${pkg#$pdb/}"

			case "$CURRENT_DEPS_I" in
			*:${pkg#$pdb/}:*)	continue ;;
			esac

			orig=`origin_from_pdb $pkg`
			case "$CONFIG_SEEN_LIST" in
			*:${orig}:*)	continue ;;
			esac
			CONFIG_SEEN_LIST="${CONFIG_SEEN_LIST}${orig}:"
			check_for_updates ${pkg#$pdb/} || fail 'Update failed'
		done

		if [ -e "$NO_DEP_UPDATES" -a -z "$NO_RECURSIVE_CONFIG" ]; then
			echo "===>>> The 'make config' check revealed no ports to update"
			safe_exit
		fi

		unset_recursive_config
		echo ''
		echo "===>>> Starting build for ports that need updating <<<==="
		echo ''
		if [ -n "$INTERACTIVE_UPDATE" ]; then
			INTERACTIVE_BUILDING=yes
			export INTERACTIVE_BUILDING
		fi
	fi

	for pkg in $roots $trunks $branches $leaves; do
		if [ ! -d "$pkg" ]; then
			# This port probably got updated as a dependency
			# for something else
			continue
		fi
		if [ -n "$FORCE" ]; then
			p=`origin_from_pdb $pkg`
			case "$FORCE_DONE_LIST" in
			*:${p}:*) test -n "$VERBOSE" &&
				    echo "===>>> Update for $p already done"
				  continue
				  ;;
			esac
			echo "===>>> Forcing update for ${pkg#$pdb/}"
			update_port ${pkg#$pdb/}
			continue
		else
			test -n "$VERBOSE" &&
			    echo "===>>> Checking installed port: ${pkg#$pdb/}"
		fi

		case "$CURRENT_DEPS_I" in
		*:${pkg#$pdb/}:*)	continue ;;
		esac
		check_for_updates ${pkg#$pdb/} || fail 'Update failed'
	done
	echo "===>>> Update check of installed ports complete"
	safe_exit
fi

if [ -n "$REPLACE_ORIGIN" ]; then
	portdir="${1#$pd/}"
	newportdir=$portdir

	if [ -d "$pdb/$2" ]; then
		# Handle the portmaster'ish way to specify the port
		upg_port=$2
	else
		# Handle existing portupgrade syntax
		upg_port=`grep -l " ORIGIN:${2#$pd/}$" $pdb/*/+CONTENTS`
		[ -n "$upg_port" ] ||
		    upg_port=`grep -l " ORIGIN:${2#$pd/}" $pdb/*/+CONTENTS`
		[ -n "$upg_port" ] ||
		    fail "Cannot find an installed port with ORIGIN $2"
		upg_port="${upg_port%/+CONTENTS}"
		upg_port="${upg_port#$pdb/}"
	fi

	oldportdir=`origin_from_pdb $pdb/$upg_port`
fi

# Exercised in the common case of not using -p option
case "$portdir" in
'')	case "$1" in
	'')	test -z "$UPDATE_REQ_BYS" && usage ;;
	${pd}/*)	portdir="${1#$pd/}" ;;
	/*)	upg_port="${1##*/}" ;;
	*)	upg_port=$1 ;;
	esac
esac

case "$upg_port" in
'')	test -n "$portdir" || usage
	old_port_dir=`iport_from_origin ${portdir}`
	if [ -n "$old_port_dir" ]; then
		upg_port="${old_port_dir}"
	fi
	;;
*)	if [ ! -d "$pdb/$upg_port" ]; then
		glob_dirs=`find $pdb -type d -name ${upg_port}\*`
		case "$glob_dirs" in
		*\*)	fail "$upg_port did not match an installed port" ;;
		*)	for dir in $glob_dirs; do
				echo -n "===>>> Update ${dir#$pdb/}? [n] "
				read GLOB_DIR
				case "$GLOB_DIR" in
				[yY])	upg_port=${dir#$pdb/}
					selected=yes
					break
					;;
				esac
			done
			test -n "$selected" || usage
			;;
		esac
	fi
	echo "===>>> Port to upgrade: $upg_port"
	if [ -z "$portdir" ]; then
		portdir=`origin_from_pdb $pdb/$upg_port`
		[ -n "$portdir" ] ||
		    fail "No ORIGIN in $pdb/$upg_port/+CONTENTS"
	fi
	;;
esac

if [ -e "$pdb/$upg_port/+IGNOREME" ]; then
	echo ''
	if [ -z "$UNATTENDED" ]; then
		echo "===>>> $upg_port has an +IGNOREME file"
		echo -n "===>>> Update anyway? [n] "
		read UPD_OR_NOT
		case "$UPD_OR_NOT" in
		[yY]*)  ;;
		*)	safe_exit ;;
		esac
	else
		echo "===>>> $upg_port has an +IGNOREME file, ignoring"
		safe_exit
	fi
fi

if [ -d "$pd/$portdir" ]; then
	echo "===>>> Port directory: $pd/$portdir"
else
	find_moved_port $portdir
	portdir=$newportdir
fi

cd $pd/$portdir || usage

if [ -n "$CONFIG_ONLY" ]; then
	echo "===>>> Launching 'make checksum' for $portdir in background"
	fetchlog=`mktemp -t fetchlog-${PARENT_PID}-${portdir##*/}`
	(make $MAKE_ARGS checksum >> $fetchlog 2>&1 &&
	    { rm -f $fetchlog; exit 0;}
	    dists=`make $MAKE_ARGS -V DISTFILES`
	    patches=`make $MAKE_ARGS -V PATCHFILES`
	    make $MAKE_ARGS delete-distfiles \
		RESTRICTED_FILES="${dists%:[0-9]} ${patches%:[0-9]}" \
		>> $fetchlog 2>&1 &&
	    echo "===>>> RE-STARTING FETCH <<<===" >> $fetchlog
	    make $MAKE_ARGS checksum >> $fetchlog 2>&1 ; rm -f $fetchlog)&
	echo "MCS_CHILD_PID $!" >> $fetchlog
fi

# Do this here so that the dependency list is accurate
# But only if we have not done it recursively first
test -z "$NO_RECURSIVE_CONFIG" && make $MAKE_ARGS config

if [ -n "$CONFIG_ONLY" ]; then
	TESTINT=`make -V IS_INTERACTIVE`
	if [ -n "$TESTINT" ]; then
		echo ''
		echo "===>>> Warning: $portdir is interactive, and will likely"
		echo "       reqire attenton during the build"
		echo ''
		echo -n "===>>> Press the [Enter] or [Return] key to continue "
		read DISCARD
		echo ''
	fi

	dependency_check

	if [ ! "$$" -eq "$PARENT_PID" ]; then
		# Save state for the parent process to read back in
		echo "CONFIG_SEEN_LIST='$CONFIG_SEEN_LIST'" > $IPC_SAVE
		safe_exit
	else
		if [ -n "$UPDATE_REQ_BYS" -a \
		    -s "$pdb/$upg_port/+REQUIRED_BY" ]; then
			CONFIG_SEEN_LIST="${CONFIG_SEEN_LIST}${portdir}:"

			echo ''
			echo "===>>> Checking ports that depend on $upg_port"
			for req_by in `cat $pdb/$upg_port/+REQUIRED_BY`; do
				test -n "$VERBOSE" &&
				  echo "===>>> $upg_port is required by $req_by"
				if [ ! -d "$pdb/$req_by" ]; then
					req_by_error $upg_port $req_by
					continue
				fi
				if ! check_interactive ${req_by} ; then
					continue
				fi

				update_port $req_by
			done
			echo "===>>> Done checking ports that depend on $upg_port"
		fi

		unset_recursive_config
	fi
	echo ''
	echo "===>>> Starting build for $portdir <<<==="
	echo ''

	if [ -n "$INTERACTIVE_UPDATE" ]; then
		INTERACTIVE_BUILDING=yes
		export INTERACTIVE_BUILDING
	fi
fi

cd $pd/$portdir

if [ ! -e "$NO_DEP_UPDATES" ]; then
	dependency_check
else
	if [ -z "$NO_RECURSIVE_CONFIG" ]; then
		echo "===>>> The 'make config' check revealed no dependencies to update"
		echo ''
	fi
fi

if [ -n "$NO_ACTION" ]; then
	test -n "$VERBOSE" &&
	    echo "===>>> Build canceled due to -n flag"
	safe_exit
fi

case "$DONT_PRE_CLEAN" in
'')	make $MAKE_ARGS clean NOCLEANDEPENDS=yes || fail 'make clean failed' ;;
esac

# In case we went elsewhere in the dependency check
cd $pd/$portdir

fl_read=`echo ${TMPDIR:-/tmp}/fetchlog-${PARENT_PID}-${portdir##*/}.*`
while [ -f "$fl_read" ]; do
	echo ''
	echo "===>>> Waiting on fetch/checksum for $portdir <<<==="
	tail -10 $fl_read 2>/dev/null | egrep -v '^$|MCS_CHILD_PID'
	echo ''
	echo "===>>> Waiting on fetch/checksum for $portdir <<<==="
	sleep 5
done

make $MAKE_ARGS || fail "make failed for $portdir"

new_port=`make $MAKE_ARGS -V PKGNAME`
prefix=`make $MAKE_ARGS -V PKGNAMEPREFIX`
portname=`make $MAKE_ARGS -V PORTNAME`
suffix=`make $MAKE_ARGS -V PKGNAMESUFFIX`
short_port="${prefix}${portname}${suffix}"

# Check for dependencies here in case +REQUIRED_BY is not up to date or missing
grep_deps=`mktemp -t grep-deps-${short_port}`

if [ -n "$upg_port" ]; then
	upg_origin=`origin_from_pdb $pdb/$upg_port`
	grep -l DEPORIGIN:$upg_origin$ $pdb/*/+CONTENTS | cut -f 5 -d '/' |
	    sort -u > $grep_deps
fi

if [ -s "$pdb/$upg_port/+REQUIRED_BY" ]; then
	req_deps=`mktemp -t req-deps-${short_port}`
	sort -u $pdb/$upg_port/+REQUIRED_BY > $req_deps
fi

if [ ! -s "$grep_deps" -a ! -s "$req_deps" ]; then
	if [ -n "$upg_port" ]; then
		echo "===>>> $upg_port is not depended on by any other ports"
	fi
elif [ -s "$grep_deps" -a -s "$req_deps" ]; then
	if ! cmp -s $grep_deps $req_deps; then
		update_reqfile
	fi
elif [ -s "$grep_deps" -a ! -s "$req_deps" ]; then
	dep_warn
	echo -n "===>>> Install these as the new +REQUIRED_BY file? [n] "
	if [ -z "$UNATTENDED" ]; then
		read INSTALLDEPS

		case "$INSTALLDEPS" in
		[yY])	req_deps=`mktemp -t req-deps-${short_port}`
			mv $grep_deps $req_deps ; unset grep_deps
			;;
		esac
	else
		echo "===>>> Default (no) in unattended mode"
	fi
else
	# It should not happen that req_deps exist but grep_deps does not
	fail "$pdb/$upg_port/+REQUIRED_BY indicates a dependency on this port, but no other ports have this dependency recorded"
fi

# Ignore if no old port exists
if [ -n "$upg_port" ]; then
	if [ -n "$BACKUP" ]; then
		echo "===>>> Creating a backup package for $upg_port in $HOME"
		pkg_create -b $upg_port ||
		    fail "Backup package creation failed for $upg_port"
		mv ${upg_port}.* $HOME/
	fi
	pkg_delete -f $upg_port || fail 'pkg_delete failed'

	if [ -n "$REPLACE_ORIGIN" ]; then
		installed_newport=`iport_from_origin ${newportdir}`
		if [ -n "$installed_newport" ]; then
			pkg_delete -f $installed_newport
		fi
	fi
fi

aw=install
fw=Installation
if [ -n "$MAKE_PACKAGE" ]; then
	aw=package
	fw=Packaging
	echo "===>>> Creating a package for $new_port in $HOME"
fi
make $MAKE_ARGS $aw clean NOCLEANDEPENDS=yes || fail "$fw of new port failed"

if [ -n "$MAKE_PACKAGE" ]; then
	mv ${new_port}.* $HOME/
fi

# By now, if this file exists, it should be authoritative
if [ -s "$req_deps" ]; then

update_dep_entries () {
	local upg_port

	test -n "$1" && upg_port=$1

	echo "===>>> Updating package dependency entry for each dependent port"
	while read dep_port; do
		dep_port_contents="$pdb/$dep_port/+CONTENTS"
		if grep -q "@pkgdep $upg_port" $dep_port_contents; then
			update_contents $upg_port $new_port
		else
			echo -n "===>>> In ${dep_port}"
			echo " no entry for $upg_port, trying $short_port"
			update_contents "$short_port.*" $new_port
		fi
	done < $req_deps
}
	update_dep_entries
	mv $req_deps $pdb/$new_port/+REQUIRED_BY
	unset req_deps
	chmod 644 $pdb/$new_port/+REQUIRED_BY

	if [ -n "$REPLACE_ORIGIN" ]; then
		req_deps=`mktemp -t req-deps-${short_port}`

		grep -l DEPORIGIN:$newportdir$ $pdb/*/+CONTENTS |
		    cut -f 5 -d '/' | sort -u > $req_deps
		update_dep_entries $new_port
		cat $req_deps >> $pdb/$new_port/+REQUIRED_BY
	fi
fi

echo ''
test -z "$upg_port" && upg_port=$portdir
echo "===>>> Upgrade for $upg_port to $new_port succeeded"

test -n "$FORCE" && FORCE_DONE_LIST="${FORCE_DONE_LIST}${portdir}:"

find_distdir () {
	distdir=`make $MAKE_ARGS -V DISTDIR`
	dist_subdir=`make $MAKE_ARGS -V DIST_SUBDIR`
	test -n "$dist_subdir" && distdir="${distdir}/${dist_subdir}"
}

find_and_delete_distfiles () {
	local distpattern file DELORNOT

	distpattern=${1%[_-]*}
	[ "$distpattern" = "$old_distpattern" ] && return 0
	for file in ${distpattern}*; do
		# This generally means the pattern did not match
		case "$file" in
		*\*)	old_distpattern=$distpattern
			find_and_delete_distfiles ${distpattern}
			continue
			;;
		esac

		case "$distfiles" in
		*${file}*)
			test -n "$VERBOSE" &&
			    echo "===>>> Keeping new distfile: $file"
			continue	# Do not delete current version
			;;
		*)	[ ! -d "$file" ] || continue
			if [ -n "$ALWAYS_SCRUB_DISTFILES" ]; then
				echo "===>>> Deleting stale distfile: $file"
				rm -f $file
				continue
			fi

			echo -n "===>>> Delete $file? [n] "
			read DELORNOT
			case "$DELORNOT" in
			[yY])	rm -f $file ;;
			esac
			;;
		esac
	done
}

delete_stale_distfiles () {
	# distfiles is used below
	local distfile file DELORNOT

	find_distdir

	distfiles=`make $MAKE_ARGS -V DISTFILES`
	distfiles="$distfiles `make $MAKE_ARGS -V PATCHFILES`"
	cd $distdir || fail "cd to $distdir failed!"
	for distfile in $distfiles; do
		find_and_delete_distfiles $distfile
	done
}

if [ -z "$DONT_SCRUB_DISTFILES" ]; then
	if [ -z "$oldportdir" ]; then
		delete_stale_distfiles
	else
		if ! cd $pd/$oldportdir; then
			echo "===>>> No $oldportdir to cd to in order to delete"
			echo "       old distfiles, remove by hand if desired"
		else
		echo -n "===>>> Delete all distfiles for ${oldportdir#*/}? [n] "
			read DELORNOT
			case "$DELORNOT" in
			[yY])	find_distdir
				if [ -n "$dist_subdir" ]; then
					cd $distdir && rm -r *
				else
					delete_stale_distfiles
					rm $distfiles
				fi
			echo "===>>> Deleting empty directories (if any)"
				find $pd/distfiles -type d -empty -print -delete
				;;
			*)	delete_stale_distfiles ;;
			esac
		fi

		cd $pd/$newportdir && delete_stale_distfiles
	fi
fi

if [ -n "$UPDATE_REQ_BYS" -a -s "$pdb/$new_port/+REQUIRED_BY" ]; then
	echo ''
	echo "===>>> Updating ports that depend on $new_port"
	for req_by in `cat $pdb/$new_port/+REQUIRED_BY`; do
		test -n "$VERBOSE" &&
		    echo "===>>> $new_port is required by $req_by"
		if [ ! -d "$pdb/$req_by" ]; then
			req_by_error $new_port $req_by
			continue
		fi
		if ! check_interactive ${req_by} ; then
			continue
		fi

		update_port $req_by
	done
	echo "===>>> Done updating ports that depend on $new_port"
fi

safe_exit

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#  Copyright (c) 2005-2006 Douglas Barton
#  All rights reserved.
#
#  Redistribution and use in source and binary forms, with or without
#  modification, are permitted provided that the following conditions
#  are met:
#  1. Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
#  2. Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
#  THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
#  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
#  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
#  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
#  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
#  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
#  OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
#  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
#  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
#  OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
#  SUCH DAMAGE.
