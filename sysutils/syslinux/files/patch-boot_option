diff -ubwr ../../work.2/syslinux-3.72/mtools/syslinux.c ./mtools/syslinux.c
--- ../../work.2/syslinux-3.72/mtools/syslinux.c	2008-11-26 13:32:57.000000000 +0100
+++ ./mtools/syslinux.c	2008-11-26 14:07:05.000000000 +0100
@@ -123,6 +123,52 @@
   return xpread(pp, buf, secsize, offset);
 }
 
+/*
+ * load a file to be used as boot image
+ */
+static int load_boot_image(const char *name)
+{
+  int l, fd;
+  struct stat sb;
+  unsigned char *buf;
+
+  memset(&sb, 0, sizeof(sb));
+  fd = open(name, O_RDONLY);
+  if (fd < 0) {
+    fprintf(stderr, "cannot open boot image %s\n", name);
+    return 1;
+  }
+  if (fstat(fd, &sb)) {
+    fprintf(stderr, "cannot stat boot image %s\n", name);
+    return 1;
+  }
+  if ( (sb.st_mode & S_IFREG) == 0) {
+    fprintf(stderr, "boot image %s is not a file 0x%x\n", name, sb.st_mode);
+    return 1;
+  }
+  if (sb.st_size < 1024 || sb.st_size > 0x8000) {
+    fprintf(stderr, "boot image %s bad size %lld\n", name, sb.st_size);
+    return 1;
+  }
+  buf = calloc(1, sb.st_size);
+  if (buf == NULL) {
+    fprintf(stderr, "malloc failed for boot image %s\n", name);
+    return 1;
+  }
+  l = read(fd, buf, sb.st_size);
+  if (l != sb.st_size) {
+    fprintf(stderr, "read failed for boot image %s got %d\n", name, l);
+    return 1;
+  }
+  if (buf[0] != 0xeb || buf[0x200] != 0x0d) {
+    fprintf(stderr, "bad content for boot image %s\n", name);
+    return 1;
+  }
+  syslinux_bootsect = buf;
+  syslinux_ldlinux = buf + 512;
+  syslinux_ldlinux_len = sb.st_size - 512;
+  return 0;
+}
 
 int main(int argc, char *argv[])
 {
@@ -163,6 +209,8 @@
 	  stupid = 1;
 	} else if ( *opt == 'v' ) {
 	  verbose++;
+	} else if ( *opt == 'b' && argp[1] ) {
+	   load_boot_image(*++argp);
 	} else if ( *opt == 'r' ) {
 	  raid_mode = 1;
 	} else if ( *opt == 'f' ) {
