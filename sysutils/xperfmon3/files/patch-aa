*** ../xperfmon++/StripChart.c	Wed Jul 27 22:29:30 1994
--- ./StripChart.c	Sun Jan 10 21:14:40 1999
***************
*** 1,4 ****
! /* $XConsortium: StripChart.c,v 1.20 91/05/24 17:20:42 converse Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
--- 1,9 ----
! /*
!  * Enhancement and error correction for FreeBSD-3.X
!  * COPYRIGHT 1998 by Lars Köller <Lars.Koeller@Uni-Bielefeld.de>
!  *
!  *      $Id: StripChart.c,v 3.8 1999/01/10 20:14:30 lkoeller Exp lkoeller $
!  */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
***************
*** 6,18 ****
  
                          All Rights Reserved
  
! Permission to use, copy, modify, and distribute this software and its 
! documentation for any purpose and without fee is hereby granted, 
  provided that the above copyright notice appear in all copies and that
! both that copyright notice and this permission notice appear in 
  supporting documentation, and that the names of Digital or MIT not be
  used in advertising or publicity pertaining to distribution of the
! software without specific, written prior permission.  
  
  DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
  ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
--- 11,23 ----
  
                          All Rights Reserved
  
! Permission to use, copy, modify, and distribute this software and its
! documentation for any purpose and without fee is hereby granted,
  provided that the above copyright notice appear in all copies and that
! both that copyright notice and this permission notice appear in
  supporting documentation, and that the names of Digital or MIT not be
  used in advertising or publicity pertaining to distribution of the
! software without specific, written prior permission.
  
  DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
  ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
***************
*** 28,34 ****
   * documentation for any purpose and without fee is hereby granted, provided that
   * the above copyright notice appear in all copies and that both that
   * copyright notice and this permission notice appear in supporting
!  * documentation, and that the name of NASA and Sterling Software (collectively 
   * or individually) are not be used in advertising or
   * publicity pertaining to distribution of the software without specific,
   * written prior permission.  NASA and Sterling Software makes no representations about the
--- 33,39 ----
   * documentation for any purpose and without fee is hereby granted, provided that
   * the above copyright notice appear in all copies and that both that
   * copyright notice and this permission notice appear in supporting
!  * documentation, and that the name of NASA and Sterling Software (collectively
   * or individually) are not be used in advertising or
   * publicity pertaining to distribution of the software without specific,
   * written prior permission.  NASA and Sterling Software makes no representations about the
***************
*** 39,45 ****
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL NASA & STERLING SOFTWARE
   * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
   * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
!  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN 
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   *
   * 1994 Revision
--- 44,50 ----
   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL NASA & STERLING SOFTWARE
   * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
   * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
!  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
   * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
   *
   * 1994 Revision
***************
*** 48,58 ****
--- 53,71 ----
  
  ******************************************************************/
  
+ #ifndef LINT
+ static char rcsid[] = "$Id: StripChart.c,v 3.8 1999/01/10 20:14:30 lkoeller Exp lkoeller $";
+ #endif
+ 
+ #include "fbsd_vers.h"
+ 
  #include <stdio.h>
  #include <X11/IntrinsicP.h>
  #include <X11/StringDefs.h>
  #include <X11/Xaw/XawInit.h>
  #include "StripCharP.h"
+ 
+ #include "system.h"
  #include <X11/Xfuncs.h>
  
  #define MS_PER_SEC 100
***************
*** 109,114 ****
--- 122,128 ----
  
  #undef offset
  #define LABEL_ROOM 100
+ 
  static void Initialize(), Destroy(), Redisplay(), MoveChart(), SetPoints();
  static Boolean SetValues();
  static int repaint_window();
***************
*** 204,213 ****
  PerfChartWidget w;
  unsigned int which;
  {
!   if (which & FOREGROUND) 
      XtReleaseGC((Widget) w, w->strip_chart.fgGC);
  
!   if (which & HIGHLIGHT) 
      XtReleaseGC((Widget) w, w->strip_chart.hiGC);
  }
  
--- 218,227 ----
  PerfChartWidget w;
  unsigned int which;
  {
!   if (which & FOREGROUND)
      XtReleaseGC((Widget) w, w->strip_chart.fgGC);
  
!   if (which & HIGHLIGHT)
      XtReleaseGC((Widget) w, w->strip_chart.hiGC);
  }
  
***************
*** 215,222 ****
--- 229,251 ----
  static void Initialize (greq, gnew)
      Widget greq, gnew;
  {
+     int i;
+ 
      PerfChartWidget w = (PerfChartWidget)gnew;
  
+     /*
+      * XXX The missing initializations have been made obvious by FreeBSD 2.2's
+      * new (`phk') malloc that doesn't initialize the malloc'ed areas to 0.
+      * Perhaps more bogons will lurk around, but the floating arithmetic ones
+      * have been the most annoying ones since they most likely cause a trap
+      * at startup time.
+      *
+      * Strange that people in the 90's still rely on malloc()
+      * returning an initialized region.
+      */
+     for ( i = 0; i < NUM_VALUES; i++ )
+         w->strip_chart.valuedata[i] = 0.0;
+ 
  /* if we are working with a mono screen then turn off all warnings and alarms */
  
      if ( mono_screen ) {
***************
*** 247,257 ****
      w->strip_chart.currentBG = w->core.background_pixel;
      w->strip_chart.interval = LABEL_ROOM;
      w->strip_chart.max_value = 0.0;
!     w->strip_chart.min_value = 99999.99;
      w->strip_chart.points = NULL;
      SetPoints(w);
  }
!  
  static void Destroy (gw)
       Widget gw;
  {
--- 276,286 ----
      w->strip_chart.currentBG = w->core.background_pixel;
      w->strip_chart.interval = LABEL_ROOM;
      w->strip_chart.max_value = 0.0;
!     w->strip_chart.min_value = 99999;
      w->strip_chart.points = NULL;
      SetPoints(w);
  }
! 
  static void Destroy (gw)
       Widget gw;
  {
***************
*** 265,271 ****
  }
  
  /*
!  * NOTE: This function really needs to recieve graphics exposure 
   *       events, but since this is not easily supported until R4 I am
   *       going to hold off until then.
   */
--- 294,300 ----
  }
  
  /*
!  * NOTE: This function really needs to recieve graphics exposure
   *       events, but since this is not easily supported until R4 I am
   *       going to hold off until then.
   */
***************
*** 295,301 ****
     double value, checkValue;
     Display *dpy = XtDisplay(w);
     Window win = XtWindow(w);
!    
  /*   if (w->strip_chart.update > 0)
         w->strip_chart.interval_id =
         XtAppAddTimeOut(XtWidgetToApplicationContext( (Widget) w),
--- 324,330 ----
     double value, checkValue;
     Display *dpy = XtDisplay(w);
     Window win = XtWindow(w);
! 
  /*   if (w->strip_chart.update > 0)
         w->strip_chart.interval_id =
         XtAppAddTimeOut(XtWidgetToApplicationContext( (Widget) w),
***************
*** 311,321 ****
  
     XtCallCallbacks( (Widget)w, XtNgetValue, (XtPointer)&value );
  
!    /* 
!     * Keep w->strip_chart.max_value up to date, and if this data 
!     * point is off the graph, change the scale to make it fit. 
      */
!    
     if (value > w->strip_chart.max_value) {
         w->strip_chart.max_value = value;
         if (w->strip_chart.max_value > w->strip_chart.scale) {
--- 340,350 ----
  
     XtCallCallbacks( (Widget)w, XtNgetValue, (XtPointer)&value );
  
!    /*
!     * Keep w->strip_chart.max_value up to date, and if this data
!     * point is off the graph, change the scale to make it fit.
      */
! 
     if (value > w->strip_chart.max_value) {
         w->strip_chart.max_value = value;
         if (w->strip_chart.max_value > w->strip_chart.scale) {
***************
*** 323,330 ****
  	   w->strip_chart.interval = repaint_window(w, 0, (int) w->core.width);
         }
     }
!    if (value < w->strip_chart.min_value) 
!        w->strip_chart.min_value = value;
  
     w->strip_chart.valuedata[w->strip_chart.interval] = value;
     if (XtIsRealized((Widget)w)) {
--- 352,359 ----
  	   w->strip_chart.interval = repaint_window(w, 0, (int) w->core.width);
         }
     }
!    if (value < w->strip_chart.min_value)
!      w->strip_chart.min_value = value;
  
     w->strip_chart.valuedata[w->strip_chart.interval] = value;
     if (XtIsRealized((Widget)w)) {
***************
*** 332,391 ****
  		       (int)(w->core.height * value) / w->strip_chart.scale);
  
  /* Check for high warnings and alarms */
!    
         if ( w->strip_chart.highWarn != 99999 ||
  	   w->strip_chart.highAlarm != 99999 ) {
  
  	   if ( w->strip_chart.immediate )
! 	       checkValue = value;
  	   else
! 	       checkValue = w->strip_chart.max_value;
  
  	   if ( checkValue >= w->strip_chart.highAlarm ) { /* check for high alarm */
  	       if ( w->strip_chart.currentBG != w->strip_chart.alarmColor ) {
! 		   XtVaSetValues(w, XtNbackground, w->strip_chart.alarmColor, NULL );
  		   w->strip_chart.currentBG = w->strip_chart.alarmColor;
  	       }
  	   }
  	   else if ( checkValue >= w->strip_chart.highWarn ) { /* check for high warning */
  	       if ( w->strip_chart.currentBG != w->strip_chart.warnColor ) {
! 		   XtVaSetValues(w, XtNbackground, w->strip_chart.warnColor, NULL );
  		   w->strip_chart.currentBG = w->strip_chart.warnColor;
  	       }
  	   }
  	   else {
  	       if ( w->strip_chart.currentBG != w->strip_chart.okColor ) { /* reset to okColor? */
! 		   XtVaSetValues(w, XtNbackground, w->strip_chart.okColor, NULL );
  		   w->strip_chart.currentBG = w->strip_chart.okColor;
  	       }
  	   }
         }
! 	   
  /* Check for low warnings and alarms */
!    
         else if ( w->strip_chart.lowWarn != 0 ||
  	   w->strip_chart.lowAlarm != 0 ) {
  
  	   if ( w->strip_chart.immediate )
! 	       checkValue = value;
  	   else
! 	       checkValue = w->strip_chart.min_value;
  
  	   if ( checkValue <= w->strip_chart.lowAlarm ) { /* check for low alarm */
  	       if ( w->strip_chart.currentBG != w->strip_chart.alarmColor ) {
! 		   XtVaSetValues(w, XtNbackground, w->strip_chart.alarmColor, NULL );
  		   w->strip_chart.currentBG = w->strip_chart.alarmColor;
  	       }
  	   }
  	   else if ( checkValue <= w->strip_chart.lowWarn ) { /* check for low warning */
  	       if ( w->strip_chart.currentBG != w->strip_chart.warnColor ) {
! 		   XtVaSetValues(w, XtNbackground, w->strip_chart.warnColor, NULL );
  		   w->strip_chart.currentBG = w->strip_chart.warnColor;
  	       }
  	   }
  	   else {
  	       if ( w->strip_chart.currentBG != w->strip_chart.okColor ) { /* reset to okColor? */
! 		   XtVaSetValues(w, XtNbackground, w->strip_chart.okColor, NULL );
  		   w->strip_chart.currentBG = w->strip_chart.okColor;
  	       }
  	   }
--- 361,420 ----
  		       (int)(w->core.height * value) / w->strip_chart.scale);
  
  /* Check for high warnings and alarms */
! 
         if ( w->strip_chart.highWarn != 99999 ||
  	   w->strip_chart.highAlarm != 99999 ) {
  
  	   if ( w->strip_chart.immediate )
! 	       checkValue = value / SCALE_HACK;
  	   else
! 	       checkValue = w->strip_chart.max_value / SCALE_HACK;
  
  	   if ( checkValue >= w->strip_chart.highAlarm ) { /* check for high alarm */
  	       if ( w->strip_chart.currentBG != w->strip_chart.alarmColor ) {
! 		   XtVaSetValues((Widget)w, XtNbackground, w->strip_chart.alarmColor, NULL );
  		   w->strip_chart.currentBG = w->strip_chart.alarmColor;
  	       }
  	   }
  	   else if ( checkValue >= w->strip_chart.highWarn ) { /* check for high warning */
  	       if ( w->strip_chart.currentBG != w->strip_chart.warnColor ) {
! 		   XtVaSetValues((Widget)w, XtNbackground, w->strip_chart.warnColor, NULL );
  		   w->strip_chart.currentBG = w->strip_chart.warnColor;
  	       }
  	   }
  	   else {
  	       if ( w->strip_chart.currentBG != w->strip_chart.okColor ) { /* reset to okColor? */
! 		   XtVaSetValues((Widget)w, XtNbackground, w->strip_chart.okColor, NULL );
  		   w->strip_chart.currentBG = w->strip_chart.okColor;
  	       }
  	   }
         }
! 
  /* Check for low warnings and alarms */
! 
         else if ( w->strip_chart.lowWarn != 0 ||
  	   w->strip_chart.lowAlarm != 0 ) {
  
  	   if ( w->strip_chart.immediate )
! 	       checkValue = value / SCALE_HACK;
  	   else
! 	       checkValue = w->strip_chart.min_value / SCALE_HACK;
  
  	   if ( checkValue <= w->strip_chart.lowAlarm ) { /* check for low alarm */
  	       if ( w->strip_chart.currentBG != w->strip_chart.alarmColor ) {
! 		   XtVaSetValues((Widget)w, XtNbackground, w->strip_chart.alarmColor, NULL );
  		   w->strip_chart.currentBG = w->strip_chart.alarmColor;
  	       }
  	   }
  	   else if ( checkValue <= w->strip_chart.lowWarn ) { /* check for low warning */
  	       if ( w->strip_chart.currentBG != w->strip_chart.warnColor ) {
! 		   XtVaSetValues((Widget)w, XtNbackground, w->strip_chart.warnColor, NULL );
  		   w->strip_chart.currentBG = w->strip_chart.warnColor;
  	       }
  	   }
  	   else {
  	       if ( w->strip_chart.currentBG != w->strip_chart.okColor ) { /* reset to okColor? */
! 		   XtVaSetValues((Widget)w, XtNbackground, w->strip_chart.okColor, NULL );
  		   w->strip_chart.currentBG = w->strip_chart.okColor;
  	       }
  	   }
***************
*** 393,413 ****
  
         if ( !w->strip_chart.fillRect ) {			  /* draw line graph */
  	   int y = (int) (w->core.height -
! 			  (int)(w->core.height * 
! 				w->strip_chart.valuedata[w->strip_chart.interval-1] ) / 
  			  w->strip_chart.scale);
  	   XDrawLine(dpy, win, w->strip_chart.fgGC,
! 		     w->strip_chart.interval-1, y, 
  		     w->strip_chart.interval, y1);
         }
         else							  /* draw filled graph */
  	   XFillRectangle(dpy, win, w->strip_chart.fgGC,
! 			  w->strip_chart.interval, y1, 
  			  (unsigned int) 1, w->core.height - y1);
  
         /*
  	* Fill in the graph lines we just painted over.
! 	
  
  	if (w->strip_chart.points != NULL) {
  	w->strip_chart.points[0].x = w->strip_chart.interval;
--- 422,442 ----
  
         if ( !w->strip_chart.fillRect ) {			  /* draw line graph */
  	   int y = (int) (w->core.height -
! 			  (int)(w->core.height *
! 				w->strip_chart.valuedata[w->strip_chart.interval-1] ) /
  			  w->strip_chart.scale);
  	   XDrawLine(dpy, win, w->strip_chart.fgGC,
! 		     w->strip_chart.interval-1, y,
  		     w->strip_chart.interval, y1);
         }
         else							  /* draw filled graph */
  	   XFillRectangle(dpy, win, w->strip_chart.fgGC,
! 			  w->strip_chart.interval, y1,
  			  (unsigned int) 1, w->core.height - y1);
  
         /*
  	* Fill in the graph lines we just painted over.
! 
  
  	if (w->strip_chart.points != NULL) {
  	w->strip_chart.points[0].x = w->strip_chart.interval;
***************
*** 434,440 ****
  #define XDS(s) XDrawString(XtDisplay(w), XtWindow(w), \
  			   w->strip_chart.hiGC, x, y, s, strlen(s))
  
! static int 
  repaint_window(w, left, width)
  PerfChartWidget w;
  int left, width;
--- 463,469 ----
  #define XDS(s) XDrawString(XtDisplay(w), XtWindow(w), \
  			   w->strip_chart.hiGC, x, y, s, strlen(s))
  
! static int
  repaint_window(w, left, width)
  PerfChartWidget w;
  int left, width;
***************
*** 448,455 ****
  
      /* Compute the minimum scale required to graph the data, but don't go
         lower than min_scale. */
!     if (w->strip_chart.interval != 0 || scale <= (int)w->strip_chart.max_value)
        scale = ((int) (w->strip_chart.max_value)) + 1;
      if (scale < w->strip_chart.min_scale)
        scale = w->strip_chart.min_scale;
  
--- 477,486 ----
  
      /* Compute the minimum scale required to graph the data, but don't go
         lower than min_scale. */
! 
!     if (w->strip_chart.interval != 0 || scale <= (int)w->strip_chart.max_value) {
        scale = ((int) (w->strip_chart.max_value)) + 1;
+     }
      if (scale < w->strip_chart.min_scale)
        scale = w->strip_chart.min_scale;
  
***************
*** 461,467 ****
  
        SetPoints(w);
  
!       if (XtIsRealized ((Widget) w)) 
  	XClearWindow (XtDisplay (w), XtWindow (w));
  
      }
--- 492,498 ----
  
        SetPoints(w);
  
!       if (XtIsRealized ((Widget) w))
  	XClearWindow (XtDisplay (w), XtWindow (w));
  
      }
***************
*** 479,502 ****
  /* draw titles */
  
  	if ( w->strip_chart.topLabel ) {
! 	    y = w->core.height/2;
  	    x = 4;
  	    XDS(w->strip_chart.topLabel);
  	}
  	if ( w->strip_chart.botLabel ) {
! 	    y = (w->core.height/2) + w->strip_chart.font_height;
  	    x = 4;
  	    XDS(w->strip_chart.botLabel);
  	}
  
  /* draw scale labels */
! 
  	(void) sprintf(numstring, "%d ", 0);
  	x = LABEL_ROOM - XTW(numstring);
  	y = w->core.height - 1;
  	XDS(numstring);		/* draw min value */
  
  	(void) sprintf(numstring, "%d ", (int)w->strip_chart.max_value );
  	x = LABEL_ROOM - XTW(numstring);
  	y = w->strip_chart.font_height - 4;
  	XDS(numstring);		/* draw max value */
--- 510,540 ----
  /* draw titles */
  
  	if ( w->strip_chart.topLabel ) {
! 	    y = w->core.height/2 - 2;
  	    x = 4;
  	    XDS(w->strip_chart.topLabel);
  	}
  	if ( w->strip_chart.botLabel ) {
! 	    y = (w->core.height/2 - 2) + w->strip_chart.font_height;
  	    x = 4;
  	    XDS(w->strip_chart.botLabel);
  	}
  
  /* draw scale labels */
! #ifdef __FreeBSD__
! 	(void) sprintf(numstring, "%1.1f ", 0.0);
! #else
  	(void) sprintf(numstring, "%d ", 0);
+ #endif
  	x = LABEL_ROOM - XTW(numstring);
  	y = w->core.height - 1;
  	XDS(numstring);		/* draw min value */
  
+ #ifdef __FreeBSD__
+ 	(void) sprintf(numstring, "%01.1f ", w->strip_chart.max_value / SCALE_HACK );
+ #else
  	(void) sprintf(numstring, "%d ", (int)w->strip_chart.max_value );
+ #endif
  	x = LABEL_ROOM - XTW(numstring);
  	y = w->strip_chart.font_height - 4;
  	XDS(numstring);		/* draw max value */
***************
*** 511,525 ****
  
  		if ( i == left && left + 1 == width && width != next ) {
  		    y1 = (int) (w->core.height -
! 				(int)(w->core.height * w->strip_chart.valuedata[i-1]) /
! 				w->strip_chart.scale);
  		    XDrawLine(dpy, win, w->strip_chart.fgGC,
  			      i-1, y1, i, y);
  		}
  		else if ( i == left )	{ /* If this is the leftmost point, then just plot it. */
! 		    
  		    XDrawPoint(dpy, win, w->strip_chart.fgGC, i, y);
! 		} 
  		else	{
  		    /* If this is not the left most point, then draw a line
  		     * connecting this point with the one to its left.
--- 549,562 ----
  
  		if ( i == left && left + 1 == width && width != next ) {
  		    y1 = (int) (w->core.height -
! 				(int)(w->core.height * w->strip_chart.valuedata[i-1]) /	w->strip_chart.scale);
  		    XDrawLine(dpy, win, w->strip_chart.fgGC,
  			      i-1, y1, i, y);
  		}
  		else if ( i == left )	{ /* If this is the leftmost point, then just plot it. */
! 
  		    XDrawPoint(dpy, win, w->strip_chart.fgGC, i, y);
! 		}
  		else	{
  		    /* If this is not the left most point, then draw a line
  		     * connecting this point with the one to its left.
***************
*** 536,542 ****
  		int y = (int) (w->core.height -
  				(int)(w->core.height * w->strip_chart.valuedata[i]) /
  				w->strip_chart.scale);
! 		XFillRectangle(dpy, win, w->strip_chart.fgGC, 
  			       i,	                                  /* x */
  			       y,					  /* y */
  			       (unsigned int) 1,			  /* width */
--- 573,579 ----
  		int y = (int) (w->core.height -
  				(int)(w->core.height * w->strip_chart.valuedata[i]) /
  				w->strip_chart.scale);
! 		XFillRectangle(dpy, win, w->strip_chart.fgGC,
  			       i,	                                  /* x */
  			       y,					  /* y */
  			       (unsigned int) 1,			  /* width */
***************
*** 545,551 ****
  
  	}
  
! 	/************** Draw graph reference lines 
  	for (i = 1; i < w->strip_chart.scale; i++) {
  	    j = i * ((int)w->core.height / w->strip_chart.scale);
  	    XDrawLine(dpy, win, w->strip_chart.hiGC, left , j, scalewidth, j);
--- 582,588 ----
  
  	}
  
! 	/************** Draw graph reference lines
  	for (i = 1; i < w->strip_chart.scale; i++) {
  	    j = i * ((int)w->core.height / w->strip_chart.scale);
  	    XDrawLine(dpy, win, w->strip_chart.hiGC, left , j, scalewidth, j);
***************
*** 582,598 ****
      bcopy((char *)(w->strip_chart.valuedata + next - j),
  	  (char *)(w->strip_chart.valuedata), j * sizeof(double));
      next = w->strip_chart.interval = j;
! 	
      /*
!      * Since we just lost some data, recompute the 
!      * w->strip_chart.max_value, and min_value. 
       */
  
      old_max = w->strip_chart.max_value;
      w->strip_chart.max_value = 0.0;
!     w->strip_chart.min_value = 99999.99;
      for (i = LABEL_ROOM; i < next; i++) {
!       if (w->strip_chart.valuedata[i] > w->strip_chart.max_value) 
  	w->strip_chart.max_value = w->strip_chart.valuedata[i];
        if ( w->strip_chart.valuedata[i] < w->strip_chart.min_value )
  	  w->strip_chart.min_value = w->strip_chart.valuedata[i];
--- 619,645 ----
      bcopy((char *)(w->strip_chart.valuedata + next - j),
  	  (char *)(w->strip_chart.valuedata), j * sizeof(double));
      next = w->strip_chart.interval = j;
! 
      /*
!      * Since we just lost some data, recompute the
!      * w->strip_chart.max_value, and min_value.
       */
  
      old_max = w->strip_chart.max_value;
+     /*
+      * To avoid scaling of Free Swap cause it changes so slow, it's
+      * better to not change the max value of 100%
+      */
+ #ifdef __FreeBSD__
+     if ( strcmp(w->strip_chart.botLabel, botNames[FRE_MEM]) != 0 )
+ 	w->strip_chart.max_value = 0.0;
+ #else
      w->strip_chart.max_value = 0.0;
! #endif
! 
!     w->strip_chart.min_value = 99999;
      for (i = LABEL_ROOM; i < next; i++) {
!       if (w->strip_chart.valuedata[i] > w->strip_chart.max_value)
  	w->strip_chart.max_value = w->strip_chart.valuedata[i];
        if ( w->strip_chart.valuedata[i] < w->strip_chart.min_value )
  	  w->strip_chart.min_value = w->strip_chart.valuedata[i];
***************
*** 611,622 ****
  	      (unsigned int) j-LABEL_ROOM, (unsigned int) w->core.height,
  	      LABEL_ROOM, 0);
  
!     XClearArea(XtDisplay((Widget)w), XtWindow((Widget)w), 
! 	       (int) j, 0, 
  	       (unsigned int) w->core.width - j, (unsigned int)w->core.height,
  	       FALSE);
  
!     /* Draw graph reference lines 
      left = j;
      for (i = 1; i < w->strip_chart.scale; i++) {
        j = i * ((int)w->core.height / w->strip_chart.scale);
--- 658,669 ----
  	      (unsigned int) j-LABEL_ROOM, (unsigned int) w->core.height,
  	      LABEL_ROOM, 0);
  
!     XClearArea(XtDisplay((Widget)w), XtWindow((Widget)w),
! 	       (int) j, 0,
  	       (unsigned int) w->core.width - j, (unsigned int)w->core.height,
  	       FALSE);
  
!     /* Draw graph reference lines
      left = j;
      for (i = 1; i < w->strip_chart.scale; i++) {
        j = i * ((int)w->core.height / w->strip_chart.scale);
***************
*** 645,663 ****
  				draw_graph, (XtPointer)w);
      }
  */
      if ( w->strip_chart.min_scale > (int) ((w->strip_chart.max_value) + 1) )
        ret_val = TRUE;
!      
      if ( w->strip_chart.fgpixel != old->strip_chart.fgpixel ) {
        new_gc |= FOREGROUND;
        ret_val = True;
      }
!     
      if ( w->strip_chart.hipixel != old->strip_chart.hipixel ) {
        new_gc |= HIGHLIGHT;
        ret_val = True;
      }
!     
      DestroyGC(old, new_gc);
      CreateGC(w, new_gc);
  
--- 692,714 ----
  				draw_graph, (XtPointer)w);
      }
  */
+ #ifdef __FreeBSD__
+     if ( w->strip_chart.min_scale > ((w->strip_chart.max_value)) )
+ #else
      if ( w->strip_chart.min_scale > (int) ((w->strip_chart.max_value) + 1) )
+ #endif
        ret_val = TRUE;
! 
      if ( w->strip_chart.fgpixel != old->strip_chart.fgpixel ) {
        new_gc |= FOREGROUND;
        ret_val = True;
      }
! 
      if ( w->strip_chart.hipixel != old->strip_chart.hipixel ) {
        new_gc |= HIGHLIGHT;
        ret_val = True;
      }
! 
      DestroyGC(old, new_gc);
      CreateGC(w, new_gc);
  
***************
*** 686,701 ****
  	w->strip_chart.points = NULL;
  	return;
      }
!     
!     size = sizeof(XPoint) * (w->strip_chart.scale - 1);
  
      points = (XPoint *) XtRealloc( (XtPointer) w->strip_chart.points, size);
      w->strip_chart.points = points;
  
      /* Draw graph reference lines into clip mask */
  
!     for (i = 1; i < w->strip_chart.scale; i++) {
  	points[i - 1].x = 0;
  	points[i - 1].y = HEIGHT / w->strip_chart.scale;
      }
  }
--- 737,753 ----
  	w->strip_chart.points = NULL;
  	return;
      }
! 
!     size = sizeof(XPoint) * (w->strip_chart.scale - 1) / SCALE_HACK;
  
      points = (XPoint *) XtRealloc( (XtPointer) w->strip_chart.points, size);
      w->strip_chart.points = points;
  
      /* Draw graph reference lines into clip mask */
  
!     for (i = 1; i < w->strip_chart.scale / SCALE_HACK; i++) {
  	points[i - 1].x = 0;
  	points[i - 1].y = HEIGHT / w->strip_chart.scale;
      }
+ 
  }
