diff -c -N ../xperfmon++/DEADJOE ./DEADJOE
*** ../xperfmon++/DEADJOE	Thu Jan  1 00:00:00 1970
--- ./DEADJOE	Tue Mar 14 21:09:19 1995
***************
*** 0 ****
--- 1,9 ----
+ 
+ *** Modified files in JOE when it aborted on Tue Mar 14 21:09:19 1995
+ *** JOE was aborted by signal 15
+ 
+ *** File '(Unnamed)'
+ bsd_system.c
+ 
+ *** File '(Unnamed)'
+ nfs
diff -c -N ../xperfmon++/Imakefile ./Imakefile
*** ../xperfmon++/Imakefile	Wed Jul 27 20:29:29 1994
--- ./Imakefile	Wed Mar 15 12:47:26 1995
***************
*** 17,31 ****
  SYS_MODULE=	sgi_system
  #endif
  
! EXTRA_LIBRARIES =     $(SUNFLAGS) $(MIPSFLAGS) $(SGIFLAGS)
  
     INSTPGMFLAGS =  $(INSTKMEMFLAGS)
  LOCAL_LIBRARIES = $(XAWLIB) $(XTOOLLIB) $(XMULIB) $(XLIB)
         INCLUDES = -I. -I$(TOOLKITSRC) -I$(TOP) -I$(TOP)/X11
! #       INCLUDES = -I. -I$(TOOLKITSRC) -I$(TOP) -I$(TOP)/X11 -I/usr/include/bsd
!      CDEBUGFLAGS = -O
!            SRCS = TimeChart.c StripChart.c misc.c $(SYS_MODULE).c xperfmon.c nfs.c
!            OBJS = TimeChart.o StripChart.o misc.o $(SYS_MODULE).o xperfmon.o nfs.o
  
  ComplexProgramTarget(xperfmon++)
  
--- 17,37 ----
  SYS_MODULE=	sgi_system
  #endif
  
! #if defined (i386BsdArchitecture)
! BSDFLAGS=	-lkvm
! SYS_MODULE=     bsd_system
! CC=		gcc
! #endif
! 
! EXTRA_LIBRARIES =     $(SUNFLAGS) $(MIPSFLAGS) $(SGIFLAGS) $(BSDFLAGS)
  
     INSTPGMFLAGS =  $(INSTKMEMFLAGS)
  LOCAL_LIBRARIES = $(XAWLIB) $(XTOOLLIB) $(XMULIB) $(XLIB)
         INCLUDES = -I. -I$(TOOLKITSRC) -I$(TOP) -I$(TOP)/X11
! #      SRCS = TimeChart.c StripChart.c misc.c $(SYS_MODULE).c xperfmon.c nfs.c
! #      OBJS = TimeChart.o StripChart.o misc.o $(SYS_MODULE).o xperfmon.o nfs.o
!        SRCS = TimeChart.c StripChart.c misc.c $(SYS_MODULE).c xperfmon.c
!        OBJS = TimeChart.o StripChart.o misc.o $(SYS_MODULE).o xperfmon.o
  
  ComplexProgramTarget(xperfmon++)
  
diff -c -N ../xperfmon++/README ./README
*** ../xperfmon++/README	Wed Jul 27 20:29:30 1994
--- ./README	Wed Mar 15 12:42:44 1995
***************
*** 18,20 ****
--- 18,24 ----
  		Research Center, rsmith@proteus.arc.nasa.gov. Imake will build for correct
  		O/S if x11r5 is fully installed in all the right places.
  
+ 
+ 3-15-95		Completely new port of systemdependent file (bsd_system.c) for FreeBSD-2.X
+ 		by Lars Köller @University of Rostock, Germany.
+ 		E-Mail: <lars.koeller@odie.physik2.uni-rostock.de>
diff -c -N ../xperfmon++/TimeChart.h ./TimeChart.h
*** ../xperfmon++/TimeChart.h	Wed Jul 27 20:29:31 1994
--- ./TimeChart.h	Thu Mar  9 15:59:28 1995
***************
*** 88,99 ****
  #define XtCFillRect "FillRect"
  
  #define XtNgetValue "getValue"
! #define XtNhighlight "highlight"
  #define XtNjumpScroll "jumpScroll"
  #define XtNminScale "minScale"
  #define XtNscale "scale"
  #define XtNfillRect "fillRect"
! #define XtNupdate "update"
  #define XtNvmunix "vmunix"
   
  typedef struct _TimeChartRec *TimeChartWidget;
--- 88,99 ----
  #define XtCFillRect "FillRect"
  
  #define XtNgetValue "getValue"
! /* #define XtNhighlight "highlight" */
  #define XtNjumpScroll "jumpScroll"
  #define XtNminScale "minScale"
  #define XtNscale "scale"
  #define XtNfillRect "fillRect"
! /* #define XtNupdate "update" */
  #define XtNvmunix "vmunix"
   
  typedef struct _TimeChartRec *TimeChartWidget;
diff -c -N ../xperfmon++/XPerfmon++.ad.FreeBSD ./XPerfmon++.ad.FreeBSD
*** ../xperfmon++/XPerfmon++.ad.FreeBSD	Thu Jan  1 00:00:00 1970
--- ./XPerfmon++.ad.FreeBSD	Wed Mar 15 10:26:56 1995
***************
*** 0 ****
--- 1,37 ----
+ ! the following specification would set all highAlarm values to 99998.
+ ! this will turn on a green color background for all graphs, even if no other
+ ! resources are set for that graph. Note that if this specification is 
+ ! commented out, the "NFS Server" graph background will be the application
+ ! default color, unless some other resource file has specified it.
+ ! *PerfChart.highAlarm:		99998
+ *perfChartUser.highAlarm:	95
+ *perfChartUser.highWarn:	75
+ 
+ *perfChartSystem.highAlarm:	40
+ *perfChartSystem.highWarn:	25
+ 
+ *perfChartIdle.lowWarn:		10
+ *perfChartIdle.lowAlarm:	5
+ 
+ *perfChartFree.lowWarn:		400
+ *perfChartFree.lowAlarm:	150
+ 
+ *perfChartDisk.highWarn:	50
+ *perfChartDisk.highAlarm:	100
+ 
+ *perfChartIntrpts.highWarn:	500
+ *perfChartIntrpts.highAlarm:	1000
+ 
+ *perfChartInput.highWarn:	500
+ *perfChartInput.highAlarm:	1000
+ 
+ *perfChartOutput.highWarn:	500
+ *perfChartOutput.highAlarm:	1000
+ 
+ *perfChartCollision.highWarn:	20
+ *perfChartCollision.highAlarm:	50
+ 
+ *perfChartNFSClient.highWarn:	100
+ *perfChartNFSClient.highAlarm:	200
+ *font:				6x13
+ 
diff -c -N ../xperfmon++/bsd_system.c ./bsd_system.c
*** ../xperfmon++/bsd_system.c	Thu Jan  1 00:00:00 1970
--- ./bsd_system.c	Thu Mar 23 09:32:02 1995
***************
*** 0 ****
--- 1,412 ----
+ /*
+  * Perfmon Performance Monitor
+  *
+  * Copyright 1985, Massachusetts Institute of Technology
+  * Copyright 1989, PCS Computer Systeme GmbH, West Germany
+  * Copyright 1994, Sterling Software @ NASA-Ames Research Center
+  * Copyright 1995, Regents of the University of California,
+  *                 Lars Köller <lars.koeller@odie.physik2.uni-rostock.de
+  *
+  * Permission to use, copy, modify, distribute, and sell this software and its
+  * documentation for any purpose is hereby granted without fee, provided that
+  * the above copyright notice appear in all copies and that both that
+  * copyright notice and this permission notice appear in supporting
+  * documentation, and that the name of PCS and Sterling Software not be used in advertising or
+  * publicity pertaining to distribution of the software without specific,
+  * written prior permission.  PCS and Sterling Software makes no representations about the
+  * suitability of this software for any purpose.  It is provided "as is"
+  * without express or implied warranty.
+  *
+  * PCS & STERLING SOFTWARE DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
+  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL PCS & STERLING SOFTWARE
+  * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN 
+  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  *
+  * Original Author:  Emanuel Jay Berkenbilt, MIT Project Athena
+  * Author:           Thomas A. Baghli, PCS Computer Systeme GmbH, West Germany
+  *                   tom@meepmeep.pcs.com
+  * 1994 Revision
+  * Author:           Roger Smith, Sterling Software @ NASA-Ames Research Center
+  *                   Moffett Field, California, rsmith@proteus.arc.nasa.gov
+  * 1995 FreeBSD 2.x Version
+  * Author:           Lars Koeller, Univerity of Rostock, Germany
+  *                   lars.koeller@odie.physik2.uni-rostock.de
+  */
+ 
+ /* This file contains only system functions - that is the functions that
+  * get the information the performance monitor is monitoring.  No calls
+  * to any X routines should be made here.  The reason for doing this is
+  * so that as the X toolkit becomes available and the X window system 
+  * improves no changes will have to be made to this file, and as this
+  * program is made available for a new type of machine, only this file
+  * will need to be changed.
+  */
+ #include <X11/IntrinsicP.h>
+ 
+ #include "system.h"
+ 
+ #include <stdio.h>
+ #include <strings.h>
+ #include <unistd.h>
+ #include <paths.h>
+ #include <kvm.h>
+ #include <nlist.h>
+ #include <limits.h>
+ #include <errno.h>
+ 
+ #include <sys/file.h>
+ #include <sys/param.h>
+ #include <sys/socket.h>
+ #include <sys/sysctl.h>
+ #include <sys/dkstat.h>
+ #include <sys/buf.h>
+ #include <sys/vmmeter.h>
+ #include <vm/vm.h>
+ #include <net/if.h>
+ #include <netinet/in.h>
+ 
+ #include <sys/mount.h>
+ #include <nfs/nfsv2.h>
+ #include <nfs/nfs.h>
+ 
+ #include "is.h"
+ 
+ #ifndef TRUE
+ #define TRUE 1
+ #define FALSE 0
+ #endif
+ 
+ #define WANT_STAT(x) (poss_stats[(x)] != NO_STAT)
+ 
+ /*
+     Function Prototypes
+ */    
+ static void kread(int, void *, size_t);
+ 
+ /*
+     Variables & Structs
+ */
+ static unsigned long *intrcnt;
+ static int nintr, hz;
+ static kvm_t *kd;
+ static char errbuf[_POSIX2_LINE_MAX];
+ static char dr_name[DK_NDRIVE][DK_NAMELEN];
+ static double etime;
+ static char *defdrives[] = { "wd0", "wd1", "sd0", "sd1" };
+ static int num_stats, poss_stats[NUM_POSSIBLE_STATS];
+ 
+ int current_values[NUM_GRAPHS];
+ stat_type stats;
+ 
+ extern Widget perfmon[NUM_GRAPHS];
+ 
+ static struct packet {
+     int input, output, collisions;
+ } packets, old_packets;
+ 
+ static struct nfsstats nfsstats;
+ static struct _nfsStats {
+     int nfsServer, nfsClient;
+ } nfsStats, old_nfsStats;
+ 
+ struct nlist nl[] = {
+ #define X_CPTIME	0
+ 	{ "_cp_time" },
+ #define X_TOTAL	 	1
+ 	{ "_total" },
+ #define X_SUM	   	2
+ 	{ "_cnt" },
+ #define X_BOOTTIME      3
+ 	{ "_boottime" },
+ #define X_DKXFER	4
+ 	{ "_dk_xfer" },
+ #define X_HZ	    	5
+ 	{ "_hz" },
+ #define N_IFNET       	6
+ 	{ "_ifnet" },
+ #define X_DK_NAMES	7
+ 	{ "_dk_names"},
+ #define X_DK_NDRIVE     8
+         { "_dk_ndrive" },
+ #define X_INTRCNT 	9
+         { "_intrcnt" },
+ #define X_EINTRCNT 	10
+         { "_eintrcnt" },
+         { "" },
+ };
+ 
+ struct {
+ 	long    time[CPUSTATES];
+ 	long    xfer[DK_NDRIVE];
+ 	struct  vmtotal Total;
+ 	struct  vmmeter Sum;
+ 	struct  vmmeter Rate;
+ 	int interrupts;
+ } s, s1;
+ 
+ #define total s.Total
+ #define rate s.Rate
+ #define sum  s.Sum
+ #define pgtok(a) ((a) * sum.v_page_size >> 10)
+ 
+ 
+ /*
+     This routine does all necessary setting up of structures
+     that will handle system calls.
+ */
+ void sys_setup()
+ {
+     get_namelist("/kernel", _PATH_KMEM);
+     collect_stats();
+     etime = 1.0;
+ }
+ 
+ 
+ /*
+     Update the data structures
+ */
+ void update_stats()
+ {
+     int state;
+     double pct, tot;;
+ 
+     collect_stats();
+ 
+     tot = 0;
+     for (state = 0; state < CPUSTATES; ++state)
+         tot += s.time[state];
+     if (tot)
+         pct = 100 / tot;
+     else
+         pct = 0;
+     current_values[USER_CPU_PERCENTAGE] = (s.time[CP_USER] + s.time[CP_NICE]) * pct;
+     current_values[SYSTEM_CPU_PERCENTAGE] = (s.time[CP_SYS] + s.time[CP_INTR]) * pct;;
+     current_values[IDLE_CPU_PERCENTAGE] = s.time[CP_IDLE] * pct;
+ 
+     if (perfmon[FREE_MEM])
+ 	current_values[FREE_MEM] = pgtok(total.t_free);
+     if (perfmon[DISK_TRANSFERS])
+ 	current_values[DISK_TRANSFERS] = total_disk_transfers();
+     if (perfmon[INTERRUPTS])
+         current_values[INTERRUPTS] = s.interrupts - s1.interrupts;
+     if (perfmon[INPUT_PACKETS])
+ 	current_values[INPUT_PACKETS] = packets.input - old_packets.input;
+     if (perfmon[OUTPUT_PACKETS])
+ 	current_values[OUTPUT_PACKETS] = packets.output - old_packets.output;
+     if (perfmon[COLLISION_PACKETS])
+ 	current_values[COLLISION_PACKETS] = packets.collisions - old_packets.collisions;
+     if (perfmon[NFS_CLIENT_CALLS])
+ 	current_values[NFS_CLIENT_CALLS] = nfsStats.nfsClient - old_nfsStats.nfsClient;
+     if (perfmon[NFS_SERVER_CALLS])
+ 	current_values[NFS_SERVER_CALLS] = nfsStats.nfsServer - old_nfsStats.nfsServer;
+ }
+ 
+ 
+ /*
+     Collect the overall disk transfer rates
+ */
+ int
+ total_disk_transfers()
+ {
+     register int i, total_xfers = 0;
+ 
+     for(i=0; i < DK_NDRIVE; i++)
+ 	total_xfers += s.xfer[i];
+     return(total_xfers/etime);
+ }
+ 
+ 
+ /*
+     Collect all the data
+ */
+ collect_stats()
+ {
+     off_t ifnetaddr;
+     register int i, tmp;
+     int mib[3], size, state;
+ 
+     kread(X_CPTIME, s.time, sizeof(s.time));
+     kread(X_DKXFER, s.xfer, sizeof(s.xfer));
+     kread(X_SUM, &sum, sizeof(sum) );
+     size = sizeof(total);
+     mib[0] = CTL_VM;
+     mib[1] = VM_METER;
+     if (sysctl(mib, 2, &total, &size, NULL, 0) < 0) {
+         printf("Can't get kerninfo: %s\n", strerror(errno));
+         bzero(&total, sizeof(total));
+     }
+ 
+     nintr = nl[X_EINTRCNT].n_value - nl[X_INTRCNT].n_value;
+     intrcnt = (unsigned long *) malloc((size_t) nintr);
+     nintr /= sizeof(long);    
+     kread(X_INTRCNT, intrcnt, (size_t) nintr*sizeof(long));
+     s1.interrupts = s.interrupts;
+     s.interrupts = 0;
+     for (i = 0; i < nintr; i++)
+         s.interrupts += *(intrcnt + i);
+     
+     etime = 0;
+     for (i=0; i < DK_NDRIVE; i++) {
+ 	tmp = s.xfer[i];
+ 	s.xfer[i] -= s1.xfer[i];
+ 	s1.xfer[i] = tmp;
+     }
+     for (i=0; i < CPUSTATES; i++) {
+ 	tmp = s.time[i];
+ 	s.time[i] -= s1.time[i];
+ 	s1.time[i] = tmp;
+ 	etime += s.time[i];
+     }
+     if(etime == 0.)
+ 	etime = 1.;
+     etime /= hz;
+ 
+ /*
+     Collect the Network-Traffic
+ */
+ 
+     if (nl[N_IFNET].n_value != 0) {
+ 	struct ifnet ifnet;
+ 	kread(N_IFNET, &ifnetaddr, sizeof(ifnetaddr));
+ 	old_packets = packets;
+ 	packets.input = packets.output = packets.collisions = 0;
+ 	while (ifnetaddr) {
+ 	    kvm_read(kd, ifnetaddr, &ifnet, sizeof ifnet );
+ 	    packets.input += ifnet.if_ipackets;
+ 	    packets.output += ifnet.if_opackets;
+ 	    packets.collisions += ifnet.if_collisions;
+ 	    ifnetaddr = (u_long) ifnet.if_next;
+ 	}
+     }
+ 
+ /*
+     Collect the NFS and RPC Calls
+ */
+ 
+     size = sizeof(nfsstats);
+     mib[0] = CTL_FS;
+     mib[1] = MOUNT_NFS;
+     mib[2] = NFS_NFSSTATS;
+ 
+     if (sysctl( mib, 3, &nfsstats, &size, NULL, 0) < 0)
+         return;
+     else {
+         old_nfsStats = nfsStats;
+ 
+         nfsStats.nfsClient = nfsstats.rpccnt[NFSPROC_GETATTR] + 
+                              nfsstats.rpccnt[NFSPROC_SETATTR] +
+                              nfsstats.rpccnt[NFSPROC_LOOKUP] +
+                              nfsstats.rpccnt[NFSPROC_READLINK] +
+                              nfsstats.rpccnt[NFSPROC_READ] +
+                              nfsstats.rpccnt[NFSPROC_WRITE] +
+                              nfsstats.rpccnt[NFSPROC_CREATE] +
+                              nfsstats.rpccnt[NFSPROC_REMOVE] +
+                              nfsstats.rpccnt[NFSPROC_RENAME] +
+                              nfsstats.rpccnt[NFSPROC_LINK] +
+                              nfsstats.rpccnt[NFSPROC_SYMLINK] +
+                              nfsstats.rpccnt[NFSPROC_MKDIR] +
+                              nfsstats.rpccnt[NFSPROC_RMDIR] + 
+                              nfsstats.rpccnt[NFSPROC_READDIR] +
+                              nfsstats.rpccnt[NFSPROC_STATFS] +
+                              nfsstats.rpccnt[NQNFSPROC_READDIRLOOK] +
+                              nfsstats.rpccnt[NQNFSPROC_GETLEASE] +
+                              nfsstats.rpccnt[NQNFSPROC_VACATED] +
+                              nfsstats.rpccnt[NQNFSPROC_EVICTED];
+ 
+         nfsStats.nfsServer = nfsstats.srvrpccnt[NFSPROC_GETATTR] + 
+                              nfsstats.srvrpccnt[NFSPROC_SETATTR] +
+                              nfsstats.srvrpccnt[NFSPROC_LOOKUP] +
+                              nfsstats.srvrpccnt[NFSPROC_READLINK] +
+                              nfsstats.srvrpccnt[NFSPROC_READ] +
+                              nfsstats.srvrpccnt[NFSPROC_WRITE] +
+                              nfsstats.srvrpccnt[NFSPROC_CREATE] +
+                              nfsstats.srvrpccnt[NFSPROC_REMOVE] +
+                              nfsstats.srvrpccnt[NFSPROC_RENAME] +
+                              nfsstats.srvrpccnt[NFSPROC_LINK] +
+                              nfsstats.srvrpccnt[NFSPROC_SYMLINK] +
+                              nfsstats.srvrpccnt[NFSPROC_MKDIR] +
+                              nfsstats.srvrpccnt[NFSPROC_RMDIR] + 
+                              nfsstats.srvrpccnt[NFSPROC_READDIR] +
+                              nfsstats.srvrpccnt[NFSPROC_STATFS] +
+                              nfsstats.srvrpccnt[NQNFSPROC_READDIRLOOK] +
+                              nfsstats.srvrpccnt[NQNFSPROC_GETLEASE] +
+                              nfsstats.srvrpccnt[NQNFSPROC_VACATED] +
+                              nfsstats.srvrpccnt[NQNFSPROC_EVICTED];
+     }
+ }
+ 
+ 
+ /*
+     Reads the nlist from the kernel
+ */
+ int
+ get_namelist(kernel_name, memory_name)
+     char *kernel_name, *memory_name;
+ {
+     time_t now;
+     time_t boottime;
+     register int i, c;
+     int nintv;
+ 
+     kd = kvm_openfiles(NULL, NULL, NULL, O_RDONLY, errbuf);
+     if (kd == 0) {
+         (void)fprintf(stderr, "xperfmon++: kvm_openfiles: %s\n", errbuf);
+         exit(1);
+     }
+ 
+     if ((c = kvm_nlist(kd, nl)) != 0) {
+         if (c > 0) {
+             (void)fprintf(stderr,"xperfmon++: undefined symbols:");
+             for (c = 0; c < sizeof(nl)/sizeof(nl[0]); c++)
+                 if (nl[c].n_type == 0)
+                     fprintf(stderr, " %s", nl[c].n_name);
+             (void)fputc('\n', stderr);
+         } else
+             (void)fprintf(stderr, "xperfmon++: kvm_nlist: %s\n", kvm_geterr(kd));            exit(1);
+     }
+ 
+     kread(X_BOOTTIME, &boottime, sizeof(boottime));
+     kread(X_HZ, &hz, sizeof(hz));
+     for (i = 0; i < DK_NDRIVE; i++) {
+ 	strcpy(dr_name[i], "xx");
+     }
+     time(&now);
+     nintv = now - boottime;
+     if (nintv <= 0 || nintv > 60*60*24*365*10) {
+ 	fprintf(stderr,
+ 	    "Time makes no sense... namelist must be wrong.\n");
+ 	exit(1);
+     }
+     return(nintv);
+ }
+ 
+ 
+ /*
+     Kread reads something from the kernel, given its nlist index.
+ */
+ static void
+ kread(nlx, addr, size)
+         int nlx;
+         void *addr;
+         size_t size;
+ {
+         char *sym;
+         
+         if (nl[nlx].n_type == 0 || nl[nlx].n_value == 0) {
+                 sym = nl[nlx].n_name;
+                 if (*sym == '_')
+                         ++sym;
+                 (void)fprintf(stderr,
+                     "xpermon++: symbol %s not defined\n", sym);
+                 exit(1);
+         }
+         if (kvm_read(kd, nl[nlx].n_value, addr, size) != size) {
+                 sym = nl[nlx].n_name;
+                 if (*sym == '_')
+                        ++sym;
+                 (void)fprintf(stderr, "xperfmon++: %s: %s\n", sym, kvm_geterr(kd));
+                 exit(1);
+         }
+ }
