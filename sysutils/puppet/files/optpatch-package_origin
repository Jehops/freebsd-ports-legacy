diff --git a/lib/puppet/provider/package/freebsd.rb b/lib/puppet/provider/package/freebsd.rb
index e10a20b..fbda52d 100755
--- lib/puppet/provider/package/freebsd.rb
+++ lib/puppet/provider/package/freebsd.rb
@@ -1,36 +1,79 @@
 Puppet::Type.type(:package).provide :freebsd, :parent => :openbsd do
-  desc "The specific form of package management on FreeBSD.  This is an
-    extremely quirky packaging system, in that it freely mixes between
-    ports and packages.  Apparently all of the tools are written in Ruby,
-    so there are plans to rewrite this support to directly use those
-    libraries."
+  include Puppet::Util::Execution
 
-  commands :pkginfo => "/usr/sbin/pkg_info",
-    :pkgadd => "/usr/sbin/pkg_add",
-    :pkgdelete => "/usr/sbin/pkg_delete"
+  desc "The specific form of package management on FreeBSD. Resource names must be
+  specified as the port origin: <port_category>/<port_name>."
+
+  commands :pkginfo    => "/usr/sbin/pkg_info",
+           :pkgadd     => "/usr/sbin/pkg_add",
+           :pkgdelete  => "/usr/sbin/pkg_delete"
 
   confine :operatingsystem => :freebsd
+  defaultfor :operatingsystem => :freebsd
+
+  def self.instances
+    packages = []
+    
+    output = pkginfo "-aoQ"
+    output.split("\n").each do |data|
+      lhs, pkg_origin = data.split(":")
+      pkg_name = lhs.split("-").slice(0..-2).join("-")
+      pkg_version = lhs.split("-")[-1]
+
+      packages << new({
+        :provider => self.name,
+        :name     => pkg_origin,
+        :ensure   => pkg_version,
+      })
+    end
 
-  def self.listcmd
-    command(:pkginfo)
+    packages
   end
 
   def install
     should = @resource.should(:ensure)
+  
+    origin = {}
+    [:category, :name].zip(@resource[:name].split("/")).each { |a,b| origin[a] = b }
+    Puppet.debug "origin => #{origin.inspect}"
+    if origin[:name] == nil
+      raise Puppet::Error.new "package name must be in origin format: <category>/<name>"
+    end
+
+    # source parameter is set
+    if @resource[:source]
+      source = URI.parse(@resource[:source])
+      Puppet.debug "source => #{source.inspect}"
 
-    if @resource[:source] =~ /\/$/
-      if @resource[:source] =~ /^(ftp|https?):/
-        Puppet::Util::Execution::withenv :PACKAGESITE => @resource[:source] do
-          pkgadd "-r", @resource[:name]
+      # URI is for local file path.
+      if (source.scheme == "file" || source.scheme == nil) && source.path
+        # Pass pkg_add only the URI path.
+        pkgadd source.path
+
+      # URI scheme is something other than 'file'.
+      elsif source.scheme && source.host && source.path
+        if source.path.end_with?(".tbz") # URI references a package.
+          # Pass pkg_add the entire URI.
+          pkgadd source.to_s
+        else # Assume URI references a directory.
+          # Set PACKAGESITE in execution environment to source URI.
+          # Pass pkg_add the origin name.
+          withenv :PACKAGESITE => source.path.end_with?("/") ? source.to_s : source.to_s << "/" do
+            Puppet.debug "ENV['PACKAGESITE'] => #{ENV['PACKAGESITE']}"
+            pkgadd "-rf", origin[:name]
+          end
         end
+
+      # URI is not usable by pkg_add
       else
-        Puppet::Util::Execution::withenv :PKG_PATH => @resource[:source] do
-          pkgadd @resource[:name]
-        end
+        raise Puppet::Error.new "source URI is inappropriate: #{source.inspect}"
       end
+
+    # source parameter is not set.
     else
-      Puppet.warning "source is defined but does not have trailing slash, ignoring #{@resource[:source]}" if @resource[:source]
-      pkgadd "-r", @resource[:name]
+      # fetch package using default PACKAGESITE directory logic.
+      # Pass pkg_add the origin name.
+      pkgadd "-rf", origin[:name]
     end
   end
 
@@ -44,7 +87,7 @@ Puppet::Type.type(:package).provide :freebsd, :parent => :openbsd do
   end
 
   def uninstall
-    pkgdelete "#{@resource[:name]}-#{@resource.should(:ensure)}"
+    output = pkginfo "-qO", @resource[:name]
+    output.split("\n").each { |pkg_name| pkgdelete([pkg_name]) }
   end
 end
-
