--- main.c.orig	Tue Mar 30 01:40:15 1999
+++ main.c	Tue Mar 30 01:47:25 1999
@@ -15,6 +15,27 @@
 #include <gdk/gdkx.h>
 #include <X11/Xlib.h>
 
+#ifdef __FreeBSD__
+#include <kvm.h>
+#include <fcntl.h>
+#include <sys/user.h>
+#include <sys/proc.h>
+#include <sys/param.h>
+#include <sys/sysctl.h>
+
+#ifdef FSCALE
+#define FIXED_PCTCPU FSCALE
+#endif
+
+#ifdef FIXED_PCTCPU
+typedef long pctcpu;
+#define pctdouble(p) ((double)(p) / FIXED_PCTCPU)
+#else
+typedef double pctcpu;
+#define pctdouble(p) (p)
+#endif
+#endif
+
 static gint fast_advance = FALSE;
 static gint advance_max_frame;
 static gint advance_max_sec;
@@ -99,6 +120,36 @@
 #define HZ 100 /* for FreeBSD? */
 #endif
 
+#ifdef __FreeBSD__
+static gfloat check_child_cpu_usage(int childs_pid)
+{
+        static gfloat percent_of_cpu = 0.0;
+
+        static kvm_t *kd;
+        kd = kvm_open(NULL, NULL, NULL, O_RDONLY, "kvm_open");
+        if (kd == NULL) return percent_of_cpu;
+
+        {
+        static struct kinfo_proc *ki;
+        static int nproc;
+        ki = kvm_getprocs(kd, KERN_PROC_PID, childs_pid, &nproc);
+        if (nproc != 1) {
+                percent_of_cpu = 0.0;
+        } else {
+                percent_of_cpu = 100.0 * pctdouble(ki->kp_proc.p_pctcpu);
+        }
+        }
+
+        kvm_close(kd);
+
+        if (percent_of_cpu > 99.0) {
+                percent_of_cpu = 99;
+       }
+
+        return percent_of_cpu;
+}
+
+#else
 static gfloat check_child_cpu_usage(int childs_pid)
 {
 /* needed for SGI IRIX 5.3 and 6.5 */
@@ -197,6 +248,7 @@
 
 	return percent_of_cpu;
 }
+#endif
 
 void set_song_info(gint n)
 {
