diff -ru ../linuxthreads/Examples/Makefile ./Examples/Makefile
--- ../linuxthreads/Examples/Makefile	Wed Mar 11 04:42:23 1998
+++ ./Examples/Makefile	Tue Jan 25 13:59:17 2000
@@ -1,8 +1,12 @@
 CC=gcc
-CFLAGS=-g -O -Wall -I.. -D_REENTRANT
-LIBPTHREAD=../libpthread.a
+CFLAGS := -g -O -Wall 
+CFLAGS += -I/usr/local/include/pthread/linuxthreads
+CFLAGS += -D_REENTRANT -D_THREAD_SAFE
 
-PROGS=ex1 ex2 ex3 ex4 ex5 proxy
+#LIBPTHREAD=../liblthread.a ../libgcc_r/liblgcc_r.a
+LIBPTHREAD=-L/usr/local/lib -llthread -llgcc_r
+
+PROGS=ex1 ex2 ex3 ex4 ex5 ex6
 
 all: $(PROGS)
 
diff -ru ../linuxthreads/Makefile ./Makefile
--- ../linuxthreads/Makefile	Fri Jul  9 21:00:32 1999
+++ ./Makefile	Tue Jan 25 13:59:17 2000
@@ -1,68 +1,72 @@
-# Copyright (C) 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
-# This file is part of the GNU C Library.
+LIB=lthread
+SHLIB_MAJOR= 2
+SHLIB_MINOR= 1
+
+.if !defined(MACHINE_ARCH)
+MACHINE_ARCH != /usr/bin/uname -m
+.endif
+
+.if !defined(LIBSRC_BASE)
+LIBSRC_BASE = /usr/src/lib
+.endif
+
+.if !defined(PREFIX)
+PREFIX = /usr/local
+.endif
+
+LIBDIR = ${PREFIX}/lib
+
+CFLAGS +=-g -O2 -Wall
+#CFLAGS +=-g -O0 -Wall -DDEBUG 
+CFLAGS +=-DCOMPILING_LINUXTHREADS
+#CFLAGS += -D__NO_WEAK_PTHREAD_ALIASES
+
+CFLAGS += -I${.CURDIR} 
+CFLAGS += -I${.CURDIR}/sysdeps/${MACHINE_ARCH}
+CFLAGS += -I${.CURDIR}/sysdeps/pthread
+CFLAGS += -I${.CURDIR}/sysdeps/unix/sysv/linux
+CFLAGS += -I${LIBSRC_BASE}/libc/stdtime
+#CFLAGS += -I${LIBSRC_BASE}/libc/${MACHINE_ARCH}
+CFLAGS += -DLIBC_RCS
+CFLAGS += -DLINUXTHREADS 
+CFLAGS += -D__USE_UNIX98
+
+AINC = -I${LIBSRC_BASE}/libc/${MACHINE_ARCH} -I${.CURDIR}/sysdeps/${MACHINE_ARCH}
+
+# Contents of the library.
+SRCS := _atomic_lock.S attr.c cancel.c clone.S condvar.c errno.c getgr_r.c \
+	gethostby_r.c getnetby_r.c getprotoby_r.c getpw_r.c getservby_r.c \
+	join.c lclone.c libc_calls.c libc_thread.c lockfile.c manager.c \
+	mutex.c pt-machine.c ptfork.c pthread.c ptlongjmp.c rwlock.c sched.c \
+	semaphore.c signals.c specific.c spinlock.c uthread_file.c wrapsyscall.c
+
+beforeinstall:
+	${INSTALL} -d -o ${BINOWN} -g ${BINGRP} -m 0755 \
+		${PREFIX}/include/pthread/linuxthreads
+	${INSTALL} -C -o ${BINOWN} -g ${BINGRP} -m 444 \
+		${.CURDIR}/sysdeps/pthread/pthread.h \
+		${PREFIX}/include/pthread/linuxthreads/pthread.h
+	${INSTALL} -C -o ${BINOWN} -g ${BINGRP} -m 444 \
+		${.CURDIR}/semaphore.h \
+		${PREFIX}/include/pthread/linuxthreads/semaphore.h
+	${INSTALL} -d -o ${BINOWN} -g ${BINGRP} -m 0755 \
+		${PREFIX}/include/pthread/linuxthreads/bits
+.for hdr in libc-lock.h libc-tsd.h pthreadtypes.h stdio-lock.h
+	${INSTALL} -C -o ${BINOWN} -g ${BINGRP} -m 444 \
+		${.CURDIR}/sysdeps/pthread/bits/$(hdr) \
+		${PREFIX}/include/pthread/linuxthreads/bits/$(hdr)
+.endfor
+.for hdr in local_lim.h posix_opt.h sigthread.h
+	${INSTALL} -C -o ${BINOWN} -g ${BINGRP} -m 444 \
+		${.CURDIR}/sysdeps/unix/sysv/linux/bits/$(hdr) \
+		${PREFIX}/include/pthread/linuxthreads/bits/$(hdr)
+.endfor
+.for hdr in pt-machine.h useldt.h
+	${INSTALL} -C -o ${BINOWN} -g ${BINGRP} -m 444 \
+		${.CURDIR}/sysdeps/i386/$(hdr) \
+		${PREFIX}/include/pthread/linuxthreads/$(hdr)
+.endfor
+	${INSTALL} -d -o ${BINOWN} -g ${BINGRP} -m 0755 ${PREFIX}/lib
 
-# The GNU C Library is free software; you can redistribute it and/or
-# modify it under the terms of the GNU Library General Public License as
-# published by the Free Software Foundation; either version 2 of the
-# License, or (at your option) any later version.
-
-# The GNU C Library is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-# Library General Public License for more details.
-
-# You should have received a copy of the GNU Library General Public
-# License along with the GNU C Library; see the file COPYING.LIB.  If not,
-# write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
-# Boston, MA 02111-1307, USA.
-
-#
-#	Sub-makefile for linuxthreads portion of the library.
-#
-subdir	:= linuxthreads
-
-linuxthreads-version := $(shell sed -n 's/^.*$(subdir)-\([0-9.]*\).*$$/\1/p' \
-				    Banner)
-
-headers := pthread.h semaphore.h
-distribute := internals.h queue.h restart.h spinlock.h
-
-routines := weaks no-tsd
-
-extra-libs := libpthread
-extra-libs-others := $(extra-libs)
-
-libpthread-routines := attr cancel condvar join manager mutex ptfork \
-		       ptlongjmp pthread signals specific errno lockfile \
-		       semaphore spinlock wrapsyscall rwlock pt-machine \
-		       oldsemaphore
-
-vpath %.c Examples
-tests = ex1 ex2 ex3 ex4 ex5 ex6
-
-include ../Rules
-
-CFLAGS-mutex.c += -D__NO_WEAK_PTHREAD_ALIASES
-CFLAGS-specific.c += -D__NO_WEAK_PTHREAD_ALIASES
-CFLAGS-pthread.c += -D__NO_WEAK_PTHREAD_ALIASES
-CFLAGS-ptfork.c += -D__NO_WEAK_PTHREAD_ALIASES
-CFLAGS-cancel.c += -D__NO_WEAK_PTHREAD_ALIASES
-
-# Depend on libc.so so a DT_NEEDED is generated in the shared objects.
-# This ensures they will load libc.so for needed symbols if loaded by
-# a statically-linked program that hasn't already loaded it.
-$(objpfx)libpthread.so: $(common-objpfx)libc.so
-
-# Make sure we link with the thread library.
-ifeq ($(build-shared),yes)
-libpthread = $(objpfx)libpthread.so
-else
-libpthread = $(objpfx)libpthread.a
-endif
-
-$(objpfx)ex1: $(libpthread)
-$(objpfx)ex2: $(libpthread)
-$(objpfx)ex3: $(libpthread)
-$(objpfx)ex4: $(libpthread)
-$(objpfx)ex5: $(libpthread)
-$(objpfx)ex6: $(libpthread)
+
+.include <bsd.lib.mk>
Only in .: README.FreeBSD
Only in .: _atomic_lock.S
diff -ru ../linuxthreads/attr.c ./attr.c
--- ../linuxthreads/attr.c	Tue Oct 27 05:51:54 1998
+++ ./attr.c	Tue Jan 25 13:59:17 2000
@@ -27,7 +27,7 @@
 
   attr->__detachstate = PTHREAD_CREATE_JOINABLE;
   attr->__schedpolicy = SCHED_OTHER;
-  attr->__schedparam.sched_priority = 0;
+  attr->__schedparam.sched_priority = DEFAULT_PRIORITY;
   attr->__inheritsched = PTHREAD_EXPLICIT_SCHED;
   attr->__scope = PTHREAD_SCOPE_SYSTEM;
   attr->__guardsize = ps;
Only in .: clone.S
Only in .: clone.h
diff -ru ../linuxthreads/errno.c ./errno.c
--- ../linuxthreads/errno.c	Wed Aug 26 08:57:28 1998
+++ ./errno.c	Tue Jan 25 13:59:17 2000
@@ -19,6 +19,12 @@
 #include "pthread.h"
 #include "internals.h"
 
+int * __error()
+{
+  pthread_descr self = thread_self();
+  return &(self->p_errno);
+}
+
 int * __errno_location()
 {
   pthread_descr self = thread_self();
Only in .: freebsd-compat.h
Only in .: getgr_r.c
Only in .: gethostby_r.c
Only in .: getnetby_r.c
Only in .: getprotoby_r.c
Only in .: getpw_r.c
Only in .: getservby_r.c
diff -ru ../linuxthreads/internals.h ./internals.h
--- ../linuxthreads/internals.h	Fri Jul 16 16:18:19 1999
+++ ./internals.h	Tue Jan 25 13:59:17 2000
@@ -22,8 +22,10 @@
 #include <signal.h>
 #include <unistd.h>
 #include <sys/types.h>
+#include <sys/queue.h>
 
 #include "pt-machine.h"
+#include "freebsd-compat.h"
 
 #ifndef THREAD_GETMEM
 # define THREAD_GETMEM(descr, member) descr->member
@@ -100,6 +102,9 @@
   char p_sigwaiting;            /* true if a sigwait() is in progress */
   struct pthread_start_args p_start_args; /* arguments for thread creation */
   void ** p_specific[PTHREAD_KEY_1STLEVEL_SIZE]; /* thread-specific data */
+  TAILQ_ENTRY(_pthread_descr_struct) qe;
+  char time_buf[26];
+  struct tm local_tm;
   void * p_libc_specific[_LIBC_TSD_KEY_N]; /* thread-specific data for libc */
   int p_userstack;		/* nonzero if the user provided the stack */
   void *p_guardaddr;		/* address of guard area or NULL */
Only in .: lclone.c
Only in .: libc_calls.c
Only in .: libc_thread.c
Only in .: libgcc_r
diff -ru ../linuxthreads/lockfile.c ./lockfile.c
--- ../linuxthreads/lockfile.c	Thu Jul  9 06:41:28 1998
+++ ./lockfile.c	Tue Jan 25 13:59:17 2000
@@ -20,6 +20,7 @@
 #include <bits/libc-lock.h>
 #include <stdio.h>
 #include <pthread.h>
+#include "internals.h"
 
 #ifdef USE_IN_LIBIO
 #include "../libio/libioP.h"
@@ -61,6 +62,7 @@
 #ifdef USE_IN_LIBIO
   return __pthread_mutex_trylock (stream->_lock);
 #else
+  return 0;
 #endif
 }
 #ifdef USE_IN_LIBIO
@@ -68,7 +70,7 @@
 #endif
 weak_alias (__ftrylockfile, ftrylockfile);
 
-
+#if (0)
 void
 __fresetlockfiles (void)
 {
@@ -85,3 +87,4 @@
   __pthread_mutexattr_destroy (&attr);
 #endif
 }
+#endif
diff -ru ../linuxthreads/manager.c ./manager.c
--- ../linuxthreads/manager.c	Wed Jul 28 23:42:42 1999
+++ ./manager.c	Tue Jan 25 13:59:18 2000
@@ -115,7 +115,7 @@
   /* Enter server loop */
   while(1) {
     n = __poll(&ufd, 1, 2000);
-
+    
     /* Check for termination of the main thread */
     if (getppid() == 1) {
       pthread_kill_all_threads(SIGKILL, 0);
@@ -176,6 +176,7 @@
   pthread_descr self = (pthread_descr) arg;
   struct pthread_request request;
   void * outcome;
+
   /* Initialize special thread_self processing, if any.  */
 #ifdef INIT_THREAD_SELF
   INIT_THREAD_SELF(self, self->p_nr);
@@ -191,15 +192,15 @@
     /* Explicit scheduling attributes were provided: apply them */
     __sched_setscheduler(THREAD_GETMEM(self, p_pid),
 			 THREAD_GETMEM(self, p_start_args.schedpolicy),
-                         &self->p_start_args.schedparam);
-  else if (__pthread_manager_thread.p_priority > 0)
+			 &self->p_start_args.schedparam);
+  else if (__pthread_manager_thread.p_priority > DEFAULT_PRIORITY)
     /* Default scheduling required, but thread manager runs in realtime
        scheduling: switch new thread to SCHED_OTHER policy */
     {
       struct sched_param default_params;
-      default_params.sched_priority = 0;
+      default_params.sched_priority = DEFAULT_PRIORITY;
       __sched_setscheduler(THREAD_GETMEM(self, p_pid),
-                           SCHED_OTHER, &default_params);
+			   SCHED_OTHER, &default_params);
     }
   /* Make gdb aware of new thread */
   if (__pthread_threads_debug && __pthread_sig_debug > 0) {
@@ -247,7 +248,7 @@
       new_thread_bottom = (char *) new_thread - STACK_SIZE;
       if (mmap((caddr_t)((char *)(new_thread + 1) - INITIAL_STACK_SIZE),
                INITIAL_STACK_SIZE, PROT_READ | PROT_WRITE | PROT_EXEC,
-               MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED | MAP_GROWSDOWN,
+               MAP_PRIVATE | MAP_STACK | MAP_FIXED,
                -1, 0) == MAP_FAILED)
         /* Bad luck, this segment is already mapped. */
         return -1;
@@ -371,7 +372,7 @@
   __pthread_manager_adjust_prio(new_thread->p_priority);
   /* Do the cloning */
   pid = __clone(pthread_start_thread, (void **) new_thread,
-                CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND |
+		CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND |
 		__pthread_sig_cancel, new_thread);
   /* Check if cloning succeeded */
   if (pid == -1) {
diff -ru ../linuxthreads/mutex.c ./mutex.c
--- ../linuxthreads/mutex.c	Wed Nov 18 08:59:53 1998
+++ ./mutex.c	Tue Jan 25 13:59:18 2000
@@ -24,7 +24,7 @@
 #include "restart.h"
 
 int __pthread_mutex_init(pthread_mutex_t * mutex,
-                       const pthread_mutexattr_t * mutex_attr)
+			 const pthread_mutexattr_t * mutex_attr)
 {
   __pthread_init_lock(&mutex->__m_lock);
   mutex->__m_kind =
Only in ../linuxthreads: no-tsd.c
Only in .: no-tsd.c.unused
Only in ../linuxthreads: oldsemaphore.c
Only in .: oldsemaphore.c.unused
diff -ru ../linuxthreads/ptfork.c ./ptfork.c
--- ../linuxthreads/ptfork.c	Mon Sep  6 12:32:07 1999
+++ ./ptfork.c	Tue Jan 25 13:59:18 2000
@@ -75,7 +75,7 @@
 
 extern int __libc_fork(void);
 
-pid_t __fork(void)
+pid_t fork(void)
 {
   pid_t pid;
   struct handler_list * prepare, * child, * parent;
@@ -96,10 +96,8 @@
   }
   return pid;
 }
-weak_alias (__fork, fork);
 
-pid_t __vfork(void)
+pid_t vfork(void)
 {
-  return __fork();
+  return fork();
 }
-weak_alias (__vfork, vfork);
diff -ru ../linuxthreads/pthread.c ./pthread.c
--- ../linuxthreads/pthread.c	Fri Aug 20 12:00:47 1999
+++ ./pthread.c	Tue Jan 25 13:59:18 2000
@@ -19,7 +19,10 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <sys/types.h>
+#include <sys/time.h>
 #include <unistd.h>
+#include <signal.h>
 #include <fcntl.h>
 #include <sys/wait.h>
 #include <sys/resource.h>
@@ -37,7 +40,7 @@
   NULL,			      /* pthread_descr p_nextlock */
   PTHREAD_THREADS_MAX,        /* pthread_t p_tid */
   0,                          /* int p_pid */
-  0,                          /* int p_priority */
+  DEFAULT_PRIORITY,           /* int p_priority */
   &__pthread_handles[0].h_lock, /* struct _pthread_fastlock * p_lock */
   0,                          /* int p_signal */
   NULL,                       /* sigjmp_buf * p_signal_buf */
@@ -59,7 +62,11 @@
   NULL,                       /* char * p_in_sighandler */
   0,                          /* char p_sigwaiting */
   PTHREAD_START_ARGS_INITIALIZER, /* struct pthread_start_args p_start_args */
-  {NULL},                     /* void ** p_specific[PTHREAD_KEY_1STLEVEL_SIZE] */
+  {NULL},                     /* void ** p_specific[PTHREAD_KEY_1STLEVEL_SIZE]
+			       * */
+  {NULL, NULL},               /* TAILQ_ENTRY(_pthread_descr_struct) qe */
+  {NULL},                     /* char timebuf[26] */
+  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL}, /* struct tm local_tm */
   {NULL},                     /* void * p_libc_specific[_LIBC_TSD_KEY_N] */
   0,                          /* int p_userstack */
   NULL,                       /* void * p_guardaddr */
@@ -79,7 +86,7 @@
   NULL,			      /* pthread_descr p_nextlock */
   0,                          /* int p_tid */
   0,                          /* int p_pid */
-  0,                          /* int p_priority */
+  DEFAULT_PRIORITY,           /* int p_priority */
   NULL,                       /* struct _pthread_fastlock * p_lock */
   0,                          /* int p_signal */
   NULL,                       /* sigjmp_buf * p_signal_buf */
@@ -101,7 +108,11 @@
   NULL,                       /* char * p_in_sighandler */
   0,                          /* char p_sigwaiting */
   PTHREAD_START_ARGS_INITIALIZER, /* struct pthread_start_args p_start_args */
-  {NULL},                     /* void ** p_specific[PTHREAD_KEY_1STLEVEL_SIZE] */
+  {NULL},                     /* void ** p_specific[PTHREAD_KEY_1STLEVEL_SIZE]
+			       * */
+  {NULL, NULL},               /* TAILQ_ENTRY(_pthread_descr_struct) qe */
+  {NULL},                     /* char timebuf[26] */
+  {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, NULL}, /* struct tm local_tm */
   {NULL},                     /* void * p_libc_specific[_LIBC_TSD_KEY_N] */
   0,                          /* int p_userstack */
   NULL,                       /* void * p_guardaddr */
@@ -154,13 +165,15 @@
 
 /* Forward declarations */
 
-static void pthread_exit_process(int retcode, void *arg);
+static void pthread_exit_process(void);
 #ifndef __i386__
 static void pthread_handle_sigcancel(int sig);
 static void pthread_handle_sigrestart(int sig);
 #else
-static void pthread_handle_sigcancel(int sig, struct sigcontext ctx);
-static void pthread_handle_sigrestart(int sig, struct sigcontext ctx);
+static void pthread_handle_sigcancel(int sig, int code,
+				     struct sigcontext * ctx);
+static void pthread_handle_sigrestart(int sig, int code,
+				      struct sigcontext * ctx);
 #endif
 static void pthread_handle_sigdebug(int sig);
 
@@ -172,8 +185,8 @@
 #ifndef __SIGRTMIN
 static int current_rtmin = -1;
 static int current_rtmax = -1;
-int __pthread_sig_restart = SIGUSR1;
-int __pthread_sig_cancel = SIGUSR2;
+int __pthread_sig_restart = SIGUSR2;
+int __pthread_sig_cancel = SIGUSR1;
 int __pthread_sig_debug = 0;
 #else
 static int current_rtmin;
@@ -184,8 +197,8 @@
 int __pthread_sig_cancel = __SIGRTMIN + 1;
 int __pthread_sig_debug = __SIGRTMIN + 2;
 #else
-int __pthread_sig_restart = SIGUSR1;
-int __pthread_sig_cancel = SIGUSR2;
+int __pthread_sig_restart = SIGUSR2;
+int __pthread_sig_cancel = SIGUSR1;
 int __pthread_sig_debug = 0;
 #endif
 
@@ -201,8 +214,8 @@
       current_rtmin = -1;
       current_rtmax = -1;
 #if __SIGRTMAX - __SIGRTMIN >= 3
-      __pthread_sig_restart = SIGUSR1;
-      __pthread_sig_cancel = SIGUSR2;
+      __pthread_sig_restart = SIGUSR2;
+      __pthread_sig_cancel = SIGUSR1;
       __pthread_sig_debug = 0;
 #endif
     }
@@ -318,7 +331,7 @@
 #ifndef __i386__
   sa.sa_handler = pthread_handle_sigrestart;
 #else
-  sa.sa_handler = (__sighandler_t) pthread_handle_sigrestart;
+  sa.sa_handler = (__sighandler_t *) pthread_handle_sigrestart;
 #endif
   sigemptyset(&sa.sa_mask);
   sa.sa_flags = 0;
@@ -326,7 +339,7 @@
 #ifndef __i386__
   sa.sa_handler = pthread_handle_sigcancel;
 #else
-  sa.sa_handler = (__sighandler_t) pthread_handle_sigcancel;
+  sa.sa_handler = (__sighandler_t *) pthread_handle_sigcancel;
 #endif
   sa.sa_flags = 0;
   __sigaction(__pthread_sig_cancel, &sa, NULL);
@@ -343,7 +356,7 @@
   /* Register an exit function to kill all other threads. */
   /* Do it early so that user-registered atexit functions are called
      before pthread_exit_process. */
-  __on_exit(pthread_exit_process, NULL);
+  atexit(pthread_exit_process);
 }
 
 void __pthread_initialize(void)
@@ -372,7 +385,8 @@
   }
   /* Start the thread manager */
   pid = __clone(__pthread_manager, (void **) __pthread_manager_thread_tos,
-                CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND
+                CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND |
+		__pthread_sig_cancel
 		, (void *)(long)manager_pipe[0]);
   if (pid == -1) {
     free(__pthread_manager_thread_bos);
@@ -500,7 +514,7 @@
     __pthread_unlock(&handle->h_lock);
     return errno;
   }
-  th->p_priority = policy == SCHED_OTHER ? 0 : param->sched_priority;
+  th->p_priority = param->sched_priority;
   __pthread_unlock(&handle->h_lock);
   if (__pthread_manager_request >= 0)
     __pthread_manager_adjust_prio(th->p_priority);
@@ -529,7 +543,7 @@
 
 /* Process-wide exit() request */
 
-static void pthread_exit_process(int retcode, void *arg)
+static void pthread_exit_process(void)
 {
   struct pthread_request request;
   pthread_descr self = thread_self();
@@ -537,7 +551,7 @@
   if (__pthread_manager_request >= 0) {
     request.req_thread = self;
     request.req_kind = REQ_PROCESS_EXIT;
-    request.req_args.exit.code = retcode;
+    request.req_args.exit.code = 0;
     __libc_write(__pthread_manager_request,
 		 (char *) &request, sizeof(request));
     suspend(self);
@@ -557,10 +571,11 @@
 {
   pthread_descr self = thread_self();
 #else
-static void pthread_handle_sigrestart(int sig, struct sigcontext ctx)
+static void pthread_handle_sigrestart(int sig, int code,
+				      struct sigcontext * ctx)
 {
   pthread_descr self;
-  asm volatile ("movw %w0,%%gs" : : "r" (ctx.gs));
+  asm volatile ("movw %w0,%%gs" : : "r" (ctx->sc_gs));
   self = thread_self();
 #endif
   THREAD_SETMEM(self, p_signal, sig);
@@ -579,11 +594,11 @@
   pthread_descr self = thread_self();
   sigjmp_buf * jmpbuf;
 #else
-static void pthread_handle_sigcancel(int sig, struct sigcontext ctx)
+static void pthread_handle_sigcancel(int sig, int code, struct sigcontext * ctx)
 {
   pthread_descr self;
   sigjmp_buf * jmpbuf;
-  asm volatile ("movw %w0,%%gs" : : "r" (ctx.gs));
+  asm volatile ("movw %w0,%%gs" : : "r" (ctx->sc_gs));
   self = thread_self();
 #endif
 
@@ -663,7 +678,7 @@
 {
   struct sigaction sa;
   /* Terminate all other threads and thread manager */
-  pthread_exit_process(0, NULL);
+  pthread_exit_process();
   /* Make current thread the main thread in case the calling thread
      changes its mind, does not exec(), and creates new threads instead. */
   __pthread_reset_main_thread();
diff -ru ../linuxthreads/ptlongjmp.c ./ptlongjmp.c
--- ../linuxthreads/ptlongjmp.c	Tue Oct 27 05:52:00 1998
+++ ./ptlongjmp.c	Tue Jan 25 13:59:18 2000
@@ -19,13 +19,6 @@
 #include "pthread.h"
 #include "internals.h"
 
-/* These functions are not declared anywhere since they shouldn't be
-   used at another place but here.  */
-extern void __libc_siglongjmp (sigjmp_buf env, int val)
-     __attribute__ ((noreturn));
-extern void __libc_longjmp (sigjmp_buf env, int val)
-     __attribute__ ((noreturn));
-
 
 static void pthread_cleanup_upto(__jmp_buf target)
 {
@@ -44,12 +37,12 @@
 
 void siglongjmp(sigjmp_buf env, int val)
 {
-  pthread_cleanup_upto(env->__jmpbuf);
+  pthread_cleanup_upto((void *) env);
   __libc_siglongjmp(env, val);
 }
 
 void longjmp(jmp_buf env, int val)
 {
-  pthread_cleanup_upto(env->__jmpbuf);
+  pthread_cleanup_upto((void *) env);
   __libc_longjmp(env, val);
 }
Only in .: sched.c
diff -ru ../linuxthreads/semaphore.h ./semaphore.h
--- ../linuxthreads/semaphore.h	Thu Apr 15 06:50:56 1999
+++ ./semaphore.h	Tue Jan 25 13:59:18 2000
@@ -15,7 +15,7 @@
 #ifndef _SEMAPHORE_H
 #define _SEMAPHORE_H    1
 
-#include <features.h>
+/*  #include <features.h> */
 #include <sys/types.h>
 
 #ifndef _PTHREAD_DESCR_DEFINED
diff -ru ../linuxthreads/signals.c ./signals.c
--- ../linuxthreads/signals.c	Mon Aug 23 10:46:35 1999
+++ ./signals.c	Tue Jan 25 13:59:18 2000
@@ -19,7 +19,6 @@
 #include "pthread.h"
 #include "internals.h"
 #include "spinlock.h"
-#include <sigcontextinfo.h>
 
 int pthread_sigmask(int how, const sigset_t * newmask, sigset_t * oldmask)
 {
@@ -68,11 +67,11 @@
 }
 
 /* User-provided signal handlers */
-typedef void (*arch_sighandler_t) __PMT ((int, SIGCONTEXT));
+typedef void (*arch_sighandler_t) __PMT ((int, int, SIGCONTEXT));
 static arch_sighandler_t sighandler[NSIG];
 
 /* The wrapper around user-provided signal handlers */
-static void pthread_sighandler(int signo, SIGCONTEXT ctx)
+static void pthread_sighandler(int signo, int code, SIGCONTEXT ctx)
 {
   pthread_descr self = thread_self();
   char * in_sighandler;
@@ -88,7 +87,7 @@
   in_sighandler = THREAD_GETMEM(self, p_in_sighandler);
   if (in_sighandler == NULL)
     THREAD_SETMEM(self, p_in_sighandler, CURRENT_STACK_FRAME);
-  sighandler[signo](signo, SIGCONTEXT_EXTRA_ARGS ctx);
+  sighandler[signo](signo, code, ctx);
   if (in_sighandler == NULL)
     THREAD_SETMEM(self, p_in_sighandler, NULL);
 }
@@ -110,7 +109,7 @@
       newact = *act;
       if (act->sa_handler != SIG_IGN && act->sa_handler != SIG_DFL
 	  && sig > 0 && sig < NSIG)
-	newact.sa_handler = (__sighandler_t) pthread_sighandler;
+	newact.sa_handler = (__sighandler_t *) pthread_sighandler;
       newactp = &newact;
     }
   else
@@ -120,7 +119,7 @@
   if (sig > 0 && sig < NSIG)
     {
       if (oact != NULL)
-	oact->sa_handler = (__sighandler_t) sighandler[sig];
+	oact->sa_handler = (__sighandler_t *) sighandler[sig];
       if (act)
 	sighandler[sig] = (arch_sighandler_t) act->sa_handler;
     }
diff -ru ../linuxthreads/spinlock.c ./spinlock.c
--- ../linuxthreads/spinlock.c	Fri Jul  9 13:56:04 1999
+++ ./spinlock.c	Tue Jan 25 13:59:18 2000
@@ -17,6 +17,7 @@
 #include <errno.h>
 #include <sched.h>
 #include <time.h>
+#include <stdio.h>
 #include "pthread.h"
 #include "internals.h"
 #include "spinlock.h"
@@ -115,8 +116,6 @@
 
 #if !defined HAS_COMPARE_AND_SWAP || defined TEST_FOR_COMPARE_AND_SWAP
 
-static void __pthread_acquire(int * spinlock);
-
 int __pthread_compare_and_swap(long * ptr, long oldval, long newval,
                                int * spinlock)
 {
@@ -152,7 +151,7 @@
    - When nanosleep() returns, we try again, doing MAX_SPIN_COUNT
      sched_yield(), then sleeping again if needed. */
 
-static void __pthread_acquire(int * spinlock)
+void __pthread_acquire(int * spinlock)
 {
   int cnt = 0;
   struct timespec tm;
diff -ru ../linuxthreads/spinlock.h ./spinlock.h
--- ../linuxthreads/spinlock.h	Thu Oct 29 06:31:12 1998
+++ ./spinlock.h	Tue Jan 25 13:59:18 2000
@@ -71,4 +71,6 @@
   return 0;
 }
 
+void __pthread_acquire(int * spinlock);
+
 #define LOCK_INITIALIZER {0, 0}
diff -ru ../linuxthreads/sysdeps/pthread/bits/pthreadtypes.h ./sysdeps/pthread/bits/pthreadtypes.h
--- ../linuxthreads/sysdeps/pthread/bits/pthreadtypes.h	Thu Apr 15 06:52:26 1999
+++ ./sysdeps/pthread/bits/pthreadtypes.h	Tue Jan 25 13:59:18 2000
@@ -20,7 +20,6 @@
 #define _BITS_PTHREADTYPES_H	1
 
 #define __need_schedparam
-#include <bits/sched.h>
 
 /* Fast locks (not abstract because mutexes and conditions aren't abstract). */
 struct _pthread_fastlock
@@ -41,7 +40,7 @@
 {
   int __detachstate;
   int __schedpolicy;
-  struct __sched_param __schedparam;
+  struct sched_param __schedparam;
   int __inheritsched;
   int __scope;
   size_t __guardsize;
diff -ru ../linuxthreads/sysdeps/pthread/pthread.h ./sysdeps/pthread/pthread.h
--- ../linuxthreads/sysdeps/pthread/pthread.h	Tue Dec  8 08:10:25 1998
+++ ./sysdeps/pthread/pthread.h	Tue Jan 25 13:59:19 2000
@@ -15,7 +15,7 @@
 #ifndef _PTHREAD_H
 #define _PTHREAD_H	1
 
-#include <features.h>
+/*  #include <features.h> */
 
 #include <sched.h>
 #include <time.h>
@@ -23,6 +23,7 @@
 #define __need_sigset_t
 #include <signal.h>
 #include <bits/pthreadtypes.h>
+#include <bits/local_lim.h>
 
 
 __BEGIN_DECLS
@@ -107,7 +108,7 @@
 
 struct _pthread_cleanup_buffer
 {
-  void (*__routine) __PMT ((void *));	  /* Function to call.  */
+  void (*__routine) __P ((void *));	  /* Function to call.  */
   void *__arg;				  /* Its argument.  */
   int __canceltype;			  /* Saved cancellation type. */
   struct _pthread_cleanup_buffer *__prev; /* Chaining of cleanup functions.  */
Only in ../linuxthreads/sysdeps/pthread: semaphore.h
Only in ./sysdeps/pthread: semaphore.h.unused
diff -ru ../linuxthreads/sysdeps/unix/sysv/linux/bits/local_lim.h ./sysdeps/unix/sysv/linux/bits/local_lim.h
--- ../linuxthreads/sysdeps/unix/sysv/linux/bits/local_lim.h	Thu Nov 12 10:03:14 1998
+++ ./sysdeps/unix/sysv/linux/bits/local_lim.h	Tue Jan 25 13:59:19 2000
@@ -24,7 +24,7 @@
 #endif
 
 /* The kernel sources contain a file with all the needed information.  */
-#include <linux/limits.h>
+#include <limits.h>
 
 /* Have to remove NR_OPEN?  */
 #ifdef __undef_NR_OPEN
diff -ru ../linuxthreads/sysdeps/unix/sysv/linux/bits/sigthread.h ./sysdeps/unix/sysv/linux/bits/sigthread.h
--- ../linuxthreads/sysdeps/unix/sysv/linux/bits/sigthread.h	Sat Sep 12 14:33:14 1998
+++ ./sysdeps/unix/sysv/linux/bits/sigthread.h	Tue Jan 25 13:59:19 2000
@@ -28,8 +28,8 @@
 
 /* Modify the signal mask for the calling thread.  The arguments have
    the same meaning as for sigprocmask(2). */
-extern int pthread_sigmask __P ((int __how, __const __sigset_t *__newmask,
-				 __sigset_t *__oldmask));
+extern int pthread_sigmask __P ((int __how, __const sigset_t *__newmask,
+				 sigset_t *__oldmask));
 
 /* Send signal SIGNO to the given thread. */
 extern int pthread_kill __P ((pthread_t __thread, int __signo));
Only in .: uthread_file.c
Only in ../linuxthreads: weaks.c
Only in .: weaks.c.unused
diff -ru ../linuxthreads/wrapsyscall.c ./wrapsyscall.c
--- ../linuxthreads/wrapsyscall.c	Tue Dec  1 11:34:20 1998
+++ ./wrapsyscall.c	Tue Jan 25 13:59:19 2000
@@ -30,6 +30,10 @@
 #include <sys/wait.h>
 #include <sys/socket.h>
 
+#define strong_alias(a, b)
+#define __SOCKADDR_ARG struct sockaddr *
+#define __CONST_SOCKADDR_ARG const struct sockaddr *
+#define __ptr_t void *
 
 #ifndef PIC
 /* We need a hook to force this file to be linked in when static
@@ -39,20 +43,20 @@
 
 
 #define CANCELABLE_SYSCALL(res_type, name, param_list, params) \
-res_type __libc_##name param_list;					      \
+res_type _##name param_list;						      \
 res_type								      \
 name param_list								      \
 {									      \
   res_type result;							      \
   int oldtype;								      \
   pthread_setcanceltype (PTHREAD_CANCEL_ASYNCHRONOUS, &oldtype);	      \
-  result = __libc_##name params;					      \
+  result = _##name params;						      \
   pthread_setcanceltype (oldtype, NULL);				      \
   return result;							      \
 }
 
 #define CANCELABLE_SYSCALL_VA(res_type, name, param_list, params, last_arg) \
-res_type __libc_##name param_list;					      \
+res_type _##name param_list;						      \
 res_type								      \
 name param_list								      \
 {									      \
@@ -61,7 +65,7 @@
   va_list ap;								      \
   pthread_setcanceltype (PTHREAD_CANCEL_ASYNCHRONOUS, &oldtype);	      \
   va_start (ap, last_arg);						      \
-  result = __libc_##name params;					      \
+  result = _##name params;						      \
   va_end (ap);								      \
   pthread_setcanceltype (oldtype, NULL);				      \
   return result;							      \
@@ -83,10 +87,12 @@
 CANCELABLE_SYSCALL (int, fsync, (int fd), (fd))
 
 
+#if (0)
 /* lseek(2).  */
 CANCELABLE_SYSCALL (off_t, lseek, (int fd, off_t offset, int whence),
 		    (fd, offset, whence))
 strong_alias (lseek, __lseek)
+#endif
 
 
 /* msync(2).  */
@@ -107,7 +113,7 @@
 
 
 /* pause(2).  */
-CANCELABLE_SYSCALL (int, pause, (void), ())
+CANCELABLE_SYSCALL (int, _pause, (void), ())
 
 
 /* read(2).  */
@@ -117,20 +123,22 @@
 
 
 /* system(3).  */
-CANCELABLE_SYSCALL (int, system, (const char *line), (line))
+CANCELABLE_SYSCALL (int, _system, (const char *line), (line))
 
 
+#if (0)
 /* tcdrain(2).  */
 CANCELABLE_SYSCALL (int, tcdrain, (int fd), (fd))
+#endif
 
 
 /* wait(2).  */
-CANCELABLE_SYSCALL (__pid_t, wait, (__WAIT_STATUS_DEFN stat_loc), (stat_loc))
+CANCELABLE_SYSCALL (pid_t, _wait, (int * stat_loc), (stat_loc))
 strong_alias (wait, __wait)
 
 
 /* waitpid(2).  */
-CANCELABLE_SYSCALL (__pid_t, waitpid, (__pid_t pid, int *stat_loc,
+CANCELABLE_SYSCALL (pid_t, _waitpid, (pid_t pid, int *stat_loc,
 				       int options),
 		    (pid, stat_loc, options))
 
@@ -155,9 +163,11 @@
 		    (fd, addr, len))
 strong_alias (connect, __connect)
 
+#if (0)
 /* recv(2).  */
 CANCELABLE_SYSCALL (int, recv, (int fd, __ptr_t buf, size_t n, int flags),
 		    (fd, buf, n, flags))
+#endif
 
 /* recvfrom(2).  */
 CANCELABLE_SYSCALL (int, recvfrom, (int fd, __ptr_t buf, size_t n, int flags,
@@ -168,11 +178,13 @@
 CANCELABLE_SYSCALL (int, recvmsg, (int fd, struct msghdr *message, int flags),
 		    (fd, message, flags))
 
+#if (0)
 /* send(2).  */
 CANCELABLE_SYSCALL (int, send, (int fd, const __ptr_t buf, size_t n,
 				int flags),
 		    (fd, buf, n, flags))
 strong_alias (send, __send)
+#endif
 
 /* sendmsg(2).  */
 CANCELABLE_SYSCALL (int, sendmsg, (int fd, const struct msghdr *message,
