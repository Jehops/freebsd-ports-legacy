This patch has been extracted from the changes in Atmel's AVR Toolchain
3.4.5, compared to stock binutils 2.24.

diff -Nur ./bfd/archures.c ../avr-binutils-2.24/bfd/archures.c
--- binutils-2.24.orig/bfd/archures.c	2014-12-02 17:48:34.784919055 +0100
+++ bfd/archures.c	2014-12-02 17:31:35.760899508 +0100
@@ -398,6 +398,7 @@
 .#define bfd_mach_avr5		5
 .#define bfd_mach_avr51		51
 .#define bfd_mach_avr6		6
+.#define bfd_mach_avrtiny   100
 .#define bfd_mach_avrxmega1 101
 .#define bfd_mach_avrxmega2 102
 .#define bfd_mach_avrxmega3 103
diff -Nur ./bfd/bfd-in2.h ../avr-binutils-2.24/bfd/bfd-in2.h
--- binutils-2.24.orig/bfd/bfd-in2.h	2014-12-02 17:48:34.784919055 +0100
+++ bfd/bfd-in2.h	2014-12-02 17:31:35.760899508 +0100
@@ -2153,6 +2153,7 @@
 #define bfd_mach_avr5          5
 #define bfd_mach_avr51         51
 #define bfd_mach_avr6          6
+#define bfd_mach_avrtiny   100
 #define bfd_mach_avrxmega1 101
 #define bfd_mach_avrxmega2 102
 #define bfd_mach_avrxmega3 103
@@ -4251,6 +4252,20 @@
 in .byte hlo8(symbol)  */
   BFD_RELOC_AVR_8_HLO,
 
+/* AVR relocations to mark the difference of two local symbols.
+These are only needed to support linker relaxation and can be ignored
+when not relaxing.  The field is set to the value of the difference
+assuming no relaxation.  The relocation encodes the position of the
+second symbol so the linker can determine whether to adjust the field
+value.  */
+  BFD_RELOC_AVR_DIFF8,
+  BFD_RELOC_AVR_DIFF16,
+  BFD_RELOC_AVR_DIFF32,
+
+/* This is a 7 bit reloc for the AVR that stores SRAM address for 16bit
+lds and sts instructions supported only tiny core.  */
+  BFD_RELOC_AVR_LDS_STS_16,
+
 /* Renesas RL78 Relocations.  */
   BFD_RELOC_RL78_NEG8,
   BFD_RELOC_RL78_NEG16,
diff -Nur ./bfd/cpu-avr.c ../avr-binutils-2.24/bfd/cpu-avr.c
--- binutils-2.24.orig/bfd/cpu-avr.c	2014-12-02 17:48:34.784919055 +0100
+++ bfd/cpu-avr.c	2014-12-02 17:31:35.764899508 +0100
@@ -1,6 +1,5 @@
 /* BFD library support routines for the AVR architecture.
-   Copyright 1999, 2000, 2002, 2005, 2006, 2007, 2008
-   Free Software Foundation, Inc.
+   Copyright (C) 1999-2014 Free Software Foundation, Inc.
    Contributed by Denis Chertykov <denisc@overta.ru>
 
    This file is part of BFD, the Binary File Descriptor library.
@@ -68,7 +67,6 @@
     return a;
   if (a->mach == bfd_mach_avr31 && b->mach == bfd_mach_avr3)
     return b;
-
   if (a->mach == bfd_mach_avr3 && b->mach == bfd_mach_avr35)
     return a;
   if (a->mach == bfd_mach_avr35 && b->mach == bfd_mach_avr3)
@@ -79,7 +77,6 @@
   if (a->mach == bfd_mach_avr51 && b->mach == bfd_mach_avr5)
     return b;
 
-
   return NULL;
 }
 
@@ -136,25 +133,28 @@
   /* 3-Byte PC.  */
   N (22, bfd_mach_avr6, "avr:6", FALSE, & arch_info_struct[10]),
 
-  /* Xmega 1 */
-  N (24, bfd_mach_avrxmega1, "avr:101", FALSE, & arch_info_struct[11]),
-
-  /* Xmega 2 */
-  N (24, bfd_mach_avrxmega2, "avr:102", FALSE, & arch_info_struct[12]),
-
-  /* Xmega 3 */
-  N (24, bfd_mach_avrxmega3, "avr:103", FALSE, & arch_info_struct[13]),
-
-  /* Xmega 4 */
-  N (24, bfd_mach_avrxmega4, "avr:104", FALSE, & arch_info_struct[14]),
-
-  /* Xmega 5 */
-  N (24, bfd_mach_avrxmega5, "avr:105", FALSE, & arch_info_struct[15]),
+  /* Tiny core (AVR Tiny).  */
+  N (16, bfd_mach_avrtiny, "avr:100", FALSE, & arch_info_struct[11]),
 
-  /* Xmega 6 */
-  N (24, bfd_mach_avrxmega6, "avr:106", FALSE, & arch_info_struct[16]),
+  /* Xmega 1.  */
+  N (24, bfd_mach_avrxmega1, "avr:101", FALSE, & arch_info_struct[12]),
 
-  /* Xmega 7 */
+  /* Xmega 2.  */
+  N (24, bfd_mach_avrxmega2, "avr:102", FALSE, & arch_info_struct[13]),
+  
+  /* Xmega 3.  */
+  N (24, bfd_mach_avrxmega3, "avr:103", FALSE, & arch_info_struct[14]),
+  
+  /* Xmega 4.  */
+  N (24, bfd_mach_avrxmega4, "avr:104", FALSE, & arch_info_struct[15]),
+  
+  /* Xmega 5.  */
+  N (24, bfd_mach_avrxmega5, "avr:105", FALSE, & arch_info_struct[16]),
+  
+  /* Xmega 6.  */
+  N (24, bfd_mach_avrxmega6, "avr:106", FALSE, & arch_info_struct[17]),
+  
+  /* Xmega 7.  */
   N (24, bfd_mach_avrxmega7, "avr:107", FALSE, NULL)
 
 };
diff -Nur ./bfd/doc/archures.texi ../avr-binutils-2.24/bfd/doc/archures.texi
--- binutils-2.24.orig/bfd/doc/archures.texi	2014-12-02 17:48:34.784919055 +0100
+++ bfd/doc/archures.texi	2014-12-02 17:33:33.048901758 +0100
@@ -365,6 +365,7 @@
 #define bfd_mach_avr5          5
 #define bfd_mach_avr51         51
 #define bfd_mach_avr6          6
+#define bfd_mach_avrtiny   100
 #define bfd_mach_avrxmega1 101
 #define bfd_mach_avrxmega2 102
 #define bfd_mach_avrxmega3 103
diff -Nur ./bfd/doc/reloc.texi ../avr-binutils-2.24/bfd/doc/reloc.texi
--- binutils-2.24.orig/bfd/doc/reloc.texi	2014-12-02 17:48:34.792919056 +0100
+++ bfd/doc/reloc.texi	2014-12-02 17:33:33.100901759 +0100
@@ -2233,6 +2233,20 @@
 This is a 8 bit reloc for the AVR that stores bits 16..23 of a symbol
 in .byte hlo8(symbol)
 @end deffn
+@deffn {} BFD_RELOC_AVR_DIFF8
+@deffnx {} BFD_RELOC_AVR_DIFF16
+@deffnx {} BFD_RELOC_AVR_DIFF32
+AVR relocations to mark the difference of two local symbols.
+These are only needed to support linker relaxation and can be ignored
+when not relaxing.  The field is set to the value of the difference
+assuming no relaxation.  The relocation encodes the position of the
+second symbol so the linker can determine whether to adjust the field
+value.
+@end deffn
+@deffn {} BFD_RELOC_AVR_LDS_STS_16
+This is a 7 bit reloc for the AVR that stores SRAM address for 16bit
+lds and sts instructions supported only tiny core.
+@end deffn
 @deffn {} BFD_RELOC_RL78_NEG8
 @deffnx {} BFD_RELOC_RL78_NEG16
 @deffnx {} BFD_RELOC_RL78_NEG24
diff -Nur ./bfd/elf32-avr.c ../avr-binutils-2.24/bfd/elf32-avr.c
--- binutils-2.24.orig/bfd/elf32-avr.c	2014-12-02 17:48:34.792919056 +0100
+++ bfd/elf32-avr.c	2014-12-02 17:31:35.764899508 +0100
@@ -1,5 +1,5 @@
 /* AVR-specific support for 32-bit ELF
-   Copyright 1999-2013 Free Software Foundation, Inc.
+   Copyright (C) 1999-2014 Free Software Foundation, Inc.
    Contributed by Denis Chertykov <denisc@overta.ru>
 
    This file is part of BFD, the Binary File Descriptor library.
@@ -32,6 +32,10 @@
 /* Enable debugging printout at stdout with this variable.  */
 static bfd_boolean debug_stubs = FALSE;
 
+static bfd_reloc_status_type
+bfd_elf_avr_diff_reloc (bfd *, arelent *, asymbol *, void *,
+			asection *, bfd *, char **);
+
 /* Hash table initialization and handling.  Code is taken from the hppa port
    and adapted to the needs of AVR.  */
 
@@ -557,6 +561,59 @@
 	 0xffffff,		/* src_mask */
 	 0xffffff,		/* dst_mask */
 	 FALSE),		/* pcrel_offset */
+  HOWTO (R_AVR_DIFF8,		/* type */
+	 0,             	/* rightshift */
+	 0, 			/* size (0 = byte, 1 = short, 2 = long) */
+	 8, 			/* bitsize */
+	 FALSE,         	/* pc_relative */
+	 0,             	/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_avr_diff_reloc, /* special_function */
+	 "R_AVR_DIFF8",     	/* name */
+	 FALSE,         	/* partial_inplace */
+	 0,             	/* src_mask */
+	 0xff,          	/* dst_mask */
+	 FALSE),        	/* pcrel_offset */
+  HOWTO (R_AVR_DIFF16,  	/* type */
+	 0,             	/* rightshift */
+	 1,			/* size (0 = byte, 1 = short, 2 = long) */
+	 16,			/* bitsize */
+	 FALSE,         	/* pc_relative */
+	 0,             	/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_avr_diff_reloc,/* special_function */
+	 "R_AVR_DIFF16",     	/* name */
+	 FALSE,         	/* partial_inplace */
+	 0,             	/* src_mask */
+	 0xffff,        	/* dst_mask */
+	 FALSE),        	/* pcrel_offset */
+  HOWTO (R_AVR_DIFF32,  	/* type */
+	 0,             	/* rightshift */
+	 2,         		/* size (0 = byte, 1 = short, 2 = long) */
+	 32,        		/* bitsize */
+	 FALSE,         	/* pc_relative */
+	 0,             	/* bitpos */
+	 complain_overflow_bitfield, /* complain_on_overflow */
+	 bfd_elf_avr_diff_reloc,/* special_function */
+	 "R_AVR_DIFF32",     	/* name */
+	 FALSE,         	/* partial_inplace */
+	 0,             	/* src_mask */
+	 0xffffffff,    	/* dst_mask */
+	 FALSE),        	/* pcrel_offset */
+  /* 7 bit immediate for LDS/STS in Tiny core.  */
+  HOWTO (R_AVR_LDS_STS_16,  /* type */
+	 0,                     /* rightshift */
+	 1,                     /* size (0 = byte, 1 = short, 2 = long) */
+	 7,                     /* bitsize */
+	 FALSE,                 /* pc_relative */
+	 0,                     /* bitpos */
+	 complain_overflow_dont,/* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_AVR_LDS_STS_16",    /* name */
+	 FALSE,                 /* partial_inplace */
+	 0xffff,                /* src_mask */
+	 0xffff,                /* dst_mask */
+	 FALSE)		/* pcrel_offset */
 };
 
 /* Map BFD reloc types to AVR ELF reloc types.  */
@@ -598,7 +655,11 @@
   { BFD_RELOC_8,                    R_AVR_8 },
   { BFD_RELOC_AVR_8_LO,             R_AVR_8_LO8 },
   { BFD_RELOC_AVR_8_HI,             R_AVR_8_HI8 },
-  { BFD_RELOC_AVR_8_HLO,            R_AVR_8_HLO8 }
+  { BFD_RELOC_AVR_8_HLO,            R_AVR_8_HLO8 },
+  { BFD_RELOC_AVR_DIFF8,            R_AVR_DIFF8 },
+  { BFD_RELOC_AVR_DIFF16,           R_AVR_DIFF16 },
+  { BFD_RELOC_AVR_DIFF32,           R_AVR_DIFF32 },
+  { BFD_RELOC_AVR_LDS_STS_16,       R_AVR_LDS_STS_16}
 };
 
 /* Meant to be filled one day with the wrap around address for the
@@ -797,6 +858,22 @@
   return 0x020000;
 }
 
+/* Perform a diff relocation. Nothing to do, as the difference value is already
+   written into the section's contents. */
+
+static bfd_reloc_status_type
+bfd_elf_avr_diff_reloc (bfd *abfd ATTRIBUTE_UNUSED,
+		      arelent *reloc_entry ATTRIBUTE_UNUSED,
+              asymbol *symbol ATTRIBUTE_UNUSED,
+              void *data ATTRIBUTE_UNUSED,
+              asection *input_section ATTRIBUTE_UNUSED,
+              bfd *output_bfd ATTRIBUTE_UNUSED,
+              char **error_message ATTRIBUTE_UNUSED)
+{
+  return bfd_reloc_ok;
+}
+
+
 /* Perform a single relocation.  By default we use the standard BFD
    routines, but a few relocs, we have to do them ourselves.  */
 
@@ -1149,6 +1226,24 @@
       bfd_put_16 (input_bfd, (bfd_vma) srel &0x00ffff, contents);
       break;
 
+    case R_AVR_DIFF8:
+    case R_AVR_DIFF16:
+    case R_AVR_DIFF32:
+      /* Nothing to do here, as contents already contains the diff value. */
+      r = bfd_reloc_ok;
+      break;
+
+    case R_AVR_LDS_STS_16:
+      contents += rel->r_offset;
+      srel = (bfd_signed_vma) relocation + rel->r_addend;
+      if ((srel & 0xFFFF) < 0x40 || (srel & 0xFFFF) > 0xbf)
+        return bfd_reloc_outofrange;
+      srel = srel & 0x7f;
+      x = bfd_get_16 (input_bfd, contents);
+      x |= (srel & 0x0f) | ((srel & 0x30) << 5) | ((srel & 0x40) << 2);
+      bfd_put_16 (input_bfd, x, contents);
+      break;
+
     default:
       r = _bfd_final_link_relocate (howto, input_bfd, input_section,
 				    contents, rel->r_offset,
@@ -1361,6 +1456,10 @@
     case bfd_mach_avrxmega7:
       val = E_AVR_MACH_XMEGA7;
       break;
+
+   case bfd_mach_avrtiny:
+      val = E_AVR_MACH_AVRTINY;
+      break;
     }
 
   elf_elfheader (abfd)->e_machine = EM_AVR;
@@ -1451,12 +1550,112 @@
 	case E_AVR_MACH_XMEGA7:
 	  e_set = bfd_mach_avrxmega7;
 	  break;
+
+    case E_AVR_MACH_AVRTINY:
+      e_set = bfd_mach_avrtiny;
+      break;
 	}
     }
   return bfd_default_set_arch_mach (abfd, bfd_arch_avr,
 				    e_set);
 }
 
+/* Returns whether the relocation type passed is a diff reloc. */
+
+static bfd_boolean
+elf32_avr_is_diff_reloc (Elf_Internal_Rela *irel)
+{
+  return (ELF32_R_TYPE (irel->r_info) == R_AVR_DIFF8
+          ||ELF32_R_TYPE (irel->r_info) == R_AVR_DIFF16
+          || ELF32_R_TYPE (irel->r_info) == R_AVR_DIFF32);
+}
+
+/* Reduce the diff value written in the section by count if the shrinked
+   insn address happens to fall between the two symbols for which this
+   diff reloc was emitted.  */
+
+static void
+elf32_avr_adjust_diff_reloc_value (bfd *abfd,
+                                   struct bfd_section *isec,
+                                   Elf_Internal_Rela *irel,
+                                   bfd_vma symval,
+                                   bfd_vma shrinked_insn_address,
+                                   int count)
+{
+  unsigned char *isec_contents = elf_section_data (isec)->this_hdr.contents;
+  if (isec_contents == NULL)
+  {
+    if (! bfd_malloc_and_get_section (abfd, isec, &isec_contents))
+      return;
+  }
+
+  isec_contents += irel->r_offset;
+
+  /* Read value written in object file. */
+ bfd_vma x = 0;
+  switch (ELF32_R_TYPE (irel->r_info))
+  {
+  case R_AVR_DIFF8:
+    {
+      x = *isec_contents;
+      break;
+    }
+  case R_AVR_DIFF16:
+    {
+      x = bfd_get_16 (abfd, isec_contents);
+      break;
+    }
+  case R_AVR_DIFF32:
+    {
+      x = bfd_get_32 (abfd, isec_contents);
+      break;
+    }
+  default:
+    {
+      BFD_FAIL();
+    }
+  }
+
+  /* For a diff reloc sym1 - sym2 the diff at assembly time (x) is written
+     into the object file. sym2's value is represented as 
+     <start_of_section> + addend. Check if the shrinked insn falls between 
+     sym1 and sym2. */
+
+  bfd_vma end_address = symval + irel->r_addend;
+  bfd_vma start_address = end_address - x;
+
+  /* Reduce the diff value by count bytes and write it back into section
+    contents. */
+
+  if (shrinked_insn_address >= start_address
+      && shrinked_insn_address <= end_address)
+  {
+    switch (ELF32_R_TYPE (irel->r_info))
+    {
+    case R_AVR_DIFF8:
+      {
+        *isec_contents = (x - count);
+        break;
+      }
+    case R_AVR_DIFF16:
+      {
+        bfd_put_16 (abfd, (x - count) & 0xFFFF, isec_contents);
+        break;
+      }
+    case R_AVR_DIFF32:
+      {
+        bfd_put_32 (abfd, (x - count) & 0xFFFFFFFF, isec_contents);
+        break;
+      }
+    default:
+      {
+        BFD_FAIL();
+      }
+    }
+
+    elf_section_data (isec)->this_hdr.contents = isec_contents - irel->r_offset;
+  }
+}
 
 /* Delete some bytes from a section while changing the size of an instruction.
    The parameter "addr" denotes the section-relative offset pointing just
@@ -1595,6 +1794,14 @@
                    if (symval <= shrinked_insn_address
                        && (symval + irel->r_addend) > shrinked_insn_address)
                      {
+                       if (elf32_avr_is_diff_reloc (irel))
+                         {
+                           elf32_avr_adjust_diff_reloc_value (abfd, isec, irel,
+                                                         symval, 
+                                                         shrinked_insn_address,
+                                                        count);
+                         }
+
                        irel->r_addend -= count;
 
                        if (debug_relax)
@@ -1765,8 +1972,8 @@
       bfd_vma symval;
 
       if (   ELF32_R_TYPE (irel->r_info) != R_AVR_13_PCREL
-	     && ELF32_R_TYPE (irel->r_info) != R_AVR_7_PCREL
-	     && ELF32_R_TYPE (irel->r_info) != R_AVR_CALL)
+	  && ELF32_R_TYPE (irel->r_info) != R_AVR_7_PCREL
+	  && ELF32_R_TYPE (irel->r_info) != R_AVR_CALL)
         continue;
 
       /* Get the section contents if we haven't done so already.  */
diff -Nur ./bfd/libbfd.h ../avr-binutils-2.24/bfd/libbfd.h
--- binutils-2.24.orig/bfd/libbfd.h	2014-12-02 17:48:34.792919056 +0100
+++ bfd/libbfd.h	2014-12-02 17:31:35.764899508 +0100
@@ -1947,6 +1947,10 @@
   "BFD_RELOC_AVR_8_LO",
   "BFD_RELOC_AVR_8_HI",
   "BFD_RELOC_AVR_8_HLO",
+  "BFD_RELOC_AVR_DIFF8",
+  "BFD_RELOC_AVR_DIFF16",
+  "BFD_RELOC_AVR_DIFF32",
+  "BFD_RELOC_AVR_LDS_STS_16",
   "BFD_RELOC_RL78_NEG8",
   "BFD_RELOC_RL78_NEG16",
   "BFD_RELOC_RL78_NEG24",
diff -Nur ./bfd/reloc.c ../avr-binutils-2.24/bfd/reloc.c
--- binutils-2.24.orig/bfd/reloc.c	2014-12-02 17:48:34.792919056 +0100
+++ bfd/reloc.c	2014-12-02 17:31:35.764899508 +0100
@@ -4510,7 +4510,24 @@
 ENUMDOC
   This is a 8 bit reloc for the AVR that stores bits 16..23 of a symbol
   in .byte hlo8(symbol)
-
+ENUM
+  BFD_RELOC_AVR_DIFF8
+ENUMX
+  BFD_RELOC_AVR_DIFF16
+ENUMX
+  BFD_RELOC_AVR_DIFF32
+ENUMDOC
+  AVR relocations to mark the difference of two local symbols.
+  These are only needed to support linker relaxation and can be ignored
+  when not relaxing.  The field is set to the value of the difference
+  assuming no relaxation.  The relocation encodes the position of the
+  second symbol so the linker can determine whether to adjust the field
+  value.
+ENUM
+  BFD_RELOC_AVR_LDS_STS_16
+ENUMDOC
+  This is a 7 bit reloc for the AVR that stores SRAM address for 16bit
+  lds and sts instructions supported only tiny core.
 ENUM
   BFD_RELOC_RL78_NEG8
 ENUMX
diff -Nur ./gas/config/tc-avr.c ../avr-binutils-2.24/gas/config/tc-avr.c
--- binutils-2.24.orig/gas/config/tc-avr.c	2014-12-02 17:48:34.792919056 +0100
+++ gas/config/tc-avr.c	2014-12-02 17:31:35.788899509 +0100
@@ -89,6 +89,7 @@
   {"avrxmega5",  AVR_ISA_XMEGA,   bfd_mach_avrxmega5},
   {"avrxmega6",  AVR_ISA_XMEGA,   bfd_mach_avrxmega6},
   {"avrxmega7",  AVR_ISA_XMEGA,   bfd_mach_avrxmega7},
+  {"avrtiny",    AVR_ISA_AVRTINY, bfd_mach_avrtiny},
   {"at90s1200",  AVR_ISA_1200,    bfd_mach_avr1},
   {"attiny11",   AVR_ISA_AVR1,    bfd_mach_avr1},
   {"attiny12",   AVR_ISA_AVR1,    bfd_mach_avr1},
@@ -280,11 +281,19 @@
   {"atxmega256d3", AVR_ISA_XMEGA, bfd_mach_avrxmega6},
   {"atxmega128a1", AVR_ISA_XMEGA, bfd_mach_avrxmega7},
   {"atxmega128a1u", AVR_ISA_XMEGAU, bfd_mach_avrxmega7},
+  {"attiny4",      AVR_ISA_AVRTINY, bfd_mach_avrtiny},
+  {"attiny5",      AVR_ISA_AVRTINY, bfd_mach_avrtiny},
+  {"attiny9",      AVR_ISA_AVRTINY, bfd_mach_avrtiny},
+  {"attiny10",     AVR_ISA_AVRTINY, bfd_mach_avrtiny},
+  {"attiny20",     AVR_ISA_AVRTINY, bfd_mach_avrtiny},
+  {"attiny40",     AVR_ISA_AVRTINY, bfd_mach_avrtiny},
   {NULL, 0, 0}
 };
 
+
 /* Current MCU type.  */
 static struct mcu_type_s   default_mcu = {"avr2", AVR_ISA_AVR2, bfd_mach_avr2};
+static struct mcu_type_s   specified_mcu;
 static struct mcu_type_s * avr_mcu = & default_mcu;
 
 /* AVR target-specific switches.  */
@@ -293,9 +302,11 @@
   int all_opcodes;  /* -mall-opcodes: accept all known AVR opcodes.  */
   int no_skip_bug;  /* -mno-skip-bug: no warnings for skipping 2-word insns.  */
   int no_wrap;      /* -mno-wrap: reject rjmp/rcall with 8K wrap-around.  */
+  int link_relax;   /* -mlink-relax: generate relocations for linker
+                       relaxation.  */
 };
 
-static struct avr_opt_s avr_opt = { 0, 0, 0 };
+static struct avr_opt_s avr_opt = { 0, 0, 0, 0 };
 
 const char EXP_CHARS[] = "eE";
 const char FLT_CHARS[] = "dD";
@@ -353,17 +364,23 @@
 #define OPTION_MMCU 'm'
 enum options
 {
-  OPTION_ALL_OPCODES = OPTION_MD_BASE + 1,
+  OPTION_MLIST_DEVICES = OPTION_MD_BASE + 1,
+  OPTION_ALL_OPCODES,
   OPTION_NO_SKIP_BUG,
-  OPTION_NO_WRAP
+  OPTION_NO_WRAP,
+  OPTION_LINK_RELAX,
+  OPTION_RMW_ISA
 };
 
 struct option md_longopts[] =
 {
   { "mmcu",   required_argument, NULL, OPTION_MMCU        },
+  { "mlist-devices", no_argument, NULL, OPTION_MLIST_DEVICES },
   { "mall-opcodes", no_argument, NULL, OPTION_ALL_OPCODES },
   { "mno-skip-bug", no_argument, NULL, OPTION_NO_SKIP_BUG },
   { "mno-wrap",     no_argument, NULL, OPTION_NO_WRAP     },
+  { "mlink-relax",  no_argument, NULL, OPTION_LINK_RELAX  },
+  { "mrmw",         no_argument, NULL, OPTION_RMW_ISA     },
   { NULL, no_argument, NULL, 0 }
 };
 
@@ -462,14 +479,17 @@
 	"                   avrxmega5 - XMEGA, > 64K, <= 128K FLASH, > 64K RAM\n"
 	"                   avrxmega6 - XMEGA, > 128K, <= 256K FLASH, <= 64K RAM\n"
 	"                   avrxmega7 - XMEGA, > 128K, <= 256K FLASH, > 64K RAM\n"
-	"                   or immediate microcontroller name.\n"));
+	"                   avrtiny   - AVR Tiny core with 16 gp registers\n"));
   fprintf (stream,
-      _("  -mall-opcodes    accept all AVR opcodes, even if not supported by MCU\n"
+       _("  -mlist-devices   list all supported devices\n"
+    "  -mall-opcodes    accept all AVR opcodes, even if not supported by MCU\n"
 	"  -mno-skip-bug    disable warnings for skipping two-word instructions\n"
 	"                   (default for avr4, avr5)\n"
 	"  -mno-wrap        reject rjmp/rcall instructions with 8K wrap-around\n"
-	"                   (default for avr3, avr5)\n"));
-  show_mcu_list (stream);
+	"                   (default for avr3, avr5)\n"
+    "  -mlink-relax     generate relocations for linker relaxation\n"
+    "  -mrmw            accept RMW instructions\n"
+    ));
 }
 
 static void
@@ -515,12 +535,20 @@
 	   type - this for allows passing -mmcu=... via gcc ASM_SPEC as well
 	   as .arch ... in the asm output at the same time.  */
 	if (avr_mcu == &default_mcu || avr_mcu->mach == mcu_types[i].mach)
-	  avr_mcu = &mcu_types[i];
+      {
+        specified_mcu.name = mcu_types[i].name;
+        specified_mcu.isa  |= mcu_types[i].isa;
+        specified_mcu.mach = mcu_types[i].mach;
+        avr_mcu = &specified_mcu;
+      }
 	else
 	  as_fatal (_("redefinition of mcu type `%s' to `%s'"),
 		    avr_mcu->name, mcu_types[i].name);
 	return 1;
       }
+    case OPTION_MLIST_DEVICES:
+      show_mcu_list(stdout);
+      exit (EXIT_SUCCESS);
     case OPTION_ALL_OPCODES:
       avr_opt.all_opcodes = 1;
       return 1;
@@ -530,6 +558,12 @@
     case OPTION_NO_WRAP:
       avr_opt.no_wrap = 1;
       return 1;
+    case OPTION_LINK_RELAX:
+      avr_opt.link_relax = 1;
+      return 1;
+    case OPTION_RMW_ISA:
+      specified_mcu.isa |= AVR_ISA_RMW;
+      return 1;
     }
 
   return 0;
@@ -580,6 +614,7 @@
     }
 
   bfd_set_arch_mach (stdoutput, TARGET_ARCH, avr_mcu->mach);
+  linkrelax = avr_opt.link_relax;
 }
 
 /* Resolve STR as a constant expression and return the result.
@@ -789,29 +824,40 @@
     case 'a':
     case 'v':
       if (*str == 'r' || *str == 'R')
-	{
-	  char r_name[20];
-
-	  str = extract_word (str, r_name, sizeof (r_name));
-	  op_mask = 0xff;
-	  if (ISDIGIT (r_name[1]))
-	    {
-	      if (r_name[2] == '\0')
-		op_mask = r_name[1] - '0';
-	      else if (r_name[1] != '0'
-		       && ISDIGIT (r_name[2])
-		       && r_name[3] == '\0')
-		op_mask = (r_name[1] - '0') * 10 + r_name[2] - '0';
-	    }
-	}
+        {
+          char r_name[20];
+          str = extract_word (str, r_name, sizeof (r_name));
+          op_mask = 0xff;
+          if (ISDIGIT (r_name[1]))
+            {
+              if (r_name[2] == '\0')
+                op_mask = r_name[1] - '0';
+              else if (r_name[1] != '0'
+                       && ISDIGIT (r_name[2])
+                       && r_name[3] == '\0')
+                op_mask = (r_name[1] - '0') * 10 + r_name[2] - '0';
+            }
+        }
       else
-	{
-	  op_mask = avr_get_constant (str, 31);
-	  str = input_line_pointer;
-	}
+        {
+          op_mask = avr_get_constant (str, 31);
+          str = input_line_pointer;
+        }
+
+      if (avr_mcu->mach == bfd_mach_avrtiny)
+        {
+          if (op_mask < 16 || op_mask > 31)
+            {
+              as_bad (_("register name or number from 16 to 31 required"));
+              break;
+            }
+        }
+      else if (op_mask > 31)
+        {
+          as_bad (_("register name or number from 0 to 31 required"));
+          break;
+        }
 
-      if (op_mask <= 31)
-	{
 	  switch (*op)
 	    {
 	    case 'a':
@@ -839,9 +885,6 @@
 	      break;
 	    }
 	  break;
-	}
-      as_bad (_("register name or number from 0 to 31 required"));
-      break;
 
     case 'e':
       {
@@ -948,6 +991,12 @@
 		   &op_expr, FALSE, BFD_RELOC_16);
       break;
 
+    case 'j':
+      str = parse_exp (str, &op_expr);
+      fix_new_exp (frag_now, where, opcode->insn_size * 2,
+		   &op_expr, FALSE, BFD_RELOC_AVR_LDS_STS_16);
+      break;
+
     case 'M':
       {
 	bfd_reloc_code_real_type r_type;
@@ -1143,6 +1192,53 @@
   return fixp->fx_frag->fr_address + fixp->fx_where;
 }
 
+static bfd_boolean
+relaxable_section (asection *sec)
+{
+  return (sec->flags & SEC_DEBUGGING) == 0;
+}
+
+/* Does whatever the xtensa port does. */
+int
+avr_validate_fix_sub (fixS *fix)
+{
+  segT add_symbol_segment, sub_symbol_segment;
+
+  /* The difference of two symbols should be resolved by the assembler when
+     linkrelax is not set.  If the linker may relax the section containing
+     the symbols, then an Xtensa DIFF relocation must be generated so that
+     the linker knows to adjust the difference value.  */
+  if (!linkrelax || fix->fx_addsy == NULL)
+    return 0;
+
+  /* Make sure both symbols are in the same segment, and that segment is
+     "normal" and relaxable.  If the segment is not "normal", then the
+     fix is not valid.  If the segment is not "relaxable", then the fix
+     should have been handled earlier.  */
+  add_symbol_segment = S_GET_SEGMENT (fix->fx_addsy);
+  if (! SEG_NORMAL (add_symbol_segment) ||
+      ! relaxable_section (add_symbol_segment))
+    return 0;
+
+  sub_symbol_segment = S_GET_SEGMENT (fix->fx_subsy);
+  return (sub_symbol_segment == add_symbol_segment);
+}
+
+/* TC_FORCE_RELOCATION hook */
+
+/* If linkrelax is turned on, and the symbol to relocate
+   against is in a relaxable segment, don't compute the value -
+   generate a relocation instead. */
+int
+avr_force_relocation (fixS *fix)
+{
+  if (linkrelax && fix->fx_addsy
+      && relaxable_section (S_GET_SEGMENT (fix->fx_addsy)))
+    return 1;
+
+  return generic_force_reloc (fix);
+}
+
 /* GAS will call this for each fixup.  It should store the correct
    value in the object file.  */
 
@@ -1166,11 +1262,46 @@
 	  fixP->fx_done = 1;
 	}
     }
+  else if (linkrelax && fixP->fx_subsy)
+    {
+      /* For a subtraction relocation expression, generate one
+         of the DIFF relocs, with the value being the difference.
+         Note that a sym1 - sym2 expression is adjusted into a 
+         section_start_sym + sym2_offset_from_section_start - sym1
+         expression. fixP->fx_addsy holds the section start symbol,
+         fixP->fx_offset holds sym2's offset, and fixP->fx_subsy
+         holds sym1. Calculate and write value, but leave fx_offset
+         as is - during relaxation, fx_offset - value gives sym1's value */
+
+       switch (fixP->fx_r_type)
+         {
+           case BFD_RELOC_8:
+             fixP->fx_r_type = BFD_RELOC_AVR_DIFF8;
+             break;
+           case BFD_RELOC_16:
+             fixP->fx_r_type = BFD_RELOC_AVR_DIFF16;
+             break;
+           case BFD_RELOC_32:
+             fixP->fx_r_type = BFD_RELOC_AVR_DIFF32;
+             break;
+           default:
+             as_bad_where (fixP->fx_file, fixP->fx_line, _("expression too complex"));
+             break;
+         }
 
+      value = S_GET_VALUE (fixP->fx_addsy) + 
+          fixP->fx_offset - S_GET_VALUE (fixP->fx_subsy);
+
+      fixP->fx_subsy = NULL;
+  }
   /* We don't actually support subtracting a symbol.  */
   if (fixP->fx_subsy != (symbolS *) NULL)
     as_bad_where (fixP->fx_file, fixP->fx_line, _("expression too complex"));
 
+  /* For the DIFF relocs, write the value into the object file while still
+     keeping fx_done FALSE, as both the difference (recorded in the object file)
+     and the sym offset (part of fixP) are needed at link relax time */
+  where = (unsigned char *) fixP->fx_frag->fr_literal + fixP->fx_where;
   switch (fixP->fx_r_type)
     {
     default:
@@ -1180,6 +1311,19 @@
     case BFD_RELOC_AVR_13_PCREL:
     case BFD_RELOC_32:
     case BFD_RELOC_16:
+      break;
+    case BFD_RELOC_AVR_DIFF8:
+      if (value > 255 || value < -128)
+        as_warn_where (fixP->fx_file, fixP->fx_line,
+                           _("operand out of range: %ld"), value);
+      *where = value;
+	  break;
+    case BFD_RELOC_AVR_DIFF16:
+      bfd_putl16 ((bfd_vma) value, where);
+      break;
+    case BFD_RELOC_AVR_DIFF32:
+      bfd_putl16 ((bfd_vma) value, where);
+      break;
     case BFD_RELOC_AVR_CALL:
       break;
     }
@@ -1256,11 +1400,21 @@
 	  bfd_putl16 ((bfd_vma) insn | LDI_IMMEDIATE (value), where);
 	  break;
 
+	case BFD_RELOC_AVR_LDS_STS_16:
+	  if ((value < 0x40) || (value > 0xBF))
+	    as_warn_where (fixP->fx_file, fixP->fx_line,
+			   _("operand out of range: 0x%lx"),
+			   (unsigned long)value);
+	  insn |= ((value & 0xF) | ((value & 0x30) << 5) | ((value & 0x40) << 2));
+	  bfd_putl16 ((bfd_vma) insn, where);
+	  break;
+
 	case BFD_RELOC_AVR_6:
 	  if ((value > 63) || (value < 0))
 	    as_bad_where (fixP->fx_file, fixP->fx_line,
 			  _("operand out of range: %ld"), value);
-	  bfd_putl16 ((bfd_vma) insn | ((value & 7) | ((value & (3 << 3)) << 7) | ((value & (1 << 5)) << 8)), where);
+	  bfd_putl16 ((bfd_vma) insn | ((value & 7) | ((value & (3 << 3)) << 7)
+					| ((value & (1 << 5)) << 8)), where);
 	  break;
 
 	case BFD_RELOC_AVR_6_ADIW:
@@ -1435,6 +1589,28 @@
 
   opcode = (struct avr_opcodes_s *) hash_find (avr_hash, op);
 
+  if (opcode && !avr_opt.all_opcodes)
+    {
+      /* Check if the instruction's ISA bit is ON in the ISA bits of the part 
+         specified by the user. If not look for other instructions
+         specifications with same mnemonic who's ISA bits matches.
+
+         This requires include/opcode/avr.h to have the instructions with
+         same mnenomic to be specified in sequence.  */
+
+      while ((opcode->isa & avr_mcu->isa) != opcode->isa)
+        {
+          opcode++;
+     
+          if (opcode->name && strcmp(op, opcode->name))
+            {
+              as_bad (_("illegal opcode %s for mcu %s"), 
+                      opcode->name, avr_mcu->name);
+              return;
+            }
+        }
+    } 
+
   if (opcode == NULL)
     {
       as_bad (_("unknown opcode `%s'"), op);
@@ -1447,9 +1623,6 @@
   if (*str && *opcode->constraints == '?')
     ++opcode;
 
-  if (!avr_opt.all_opcodes && (opcode->isa & avr_mcu->isa) != opcode->isa)
-    as_bad (_("illegal opcode %s for mcu %s"), opcode->name, avr_mcu->name);
-
   dwarf2_emit_insn (0);
 
   /* We used to set input_line_pointer to the result of get_operands,
diff -Nur ./gas/config/tc-avr.h ../avr-binutils-2.24/gas/config/tc-avr.h
--- binutils-2.24.orig/gas/config/tc-avr.h	2014-12-02 17:48:34.796919056 +0100
+++ gas/config/tc-avr.h	2014-12-02 17:31:35.788899509 +0100
@@ -93,6 +93,18 @@
    visible symbols can be overridden.  */
 #define EXTERN_FORCE_RELOC 0
 
+/* If defined, this macro allows control over whether fixups for a
+   given section will be processed when the linkrelax variable is
+   set. Define it to zero and handle things in md_apply_fix instead.*/
+#define TC_LINKRELAX_FIXUP(SEG) 0
+
+/* If this macro returns non-zero, it guarantees that a relocation will be emitted
+   even when the value can be resolved locally. Do that if linkrelax is turned on */
+#define TC_FORCE_RELOCATION(fix)	avr_force_relocation (fix)
+#define TC_FORCE_RELOCATION_SUB_SAME(fix, seg) \
+  (! SEG_NORMAL (seg) || avr_force_relocation (fix))
+extern int avr_force_relocation (struct fix *);
+
 /* Values passed to md_apply_fix don't include the symbol value.  */
 #define MD_APPLY_SYM_VALUE(FIX) 0
 
@@ -150,6 +162,12 @@
       goto SKIP;					     \
     }
 
+/* This macro is evaluated for any fixup with a fx_subsy that
+   fixup_segment cannot reduce to a number.  If the macro returns
+   false an error will be reported. */
+#define TC_VALIDATE_FIX_SUB(fix, seg)   avr_validate_fix_sub (fix)                                                                    
+extern int avr_validate_fix_sub (struct fix *);
+
 /* This target is buggy, and sets fix size too large.  */
 #define TC_FX_SIZE_SLACK(FIX) 2
 
diff -Nur ./gas/doc/as.1 ../avr-binutils-2.24/gas/doc/as.1
--- binutils-2.24.orig/gas/doc/as.1	2014-12-02 17:48:34.796919056 +0100
+++ gas/doc/as.1	2014-12-02 17:34:14.660902556 +0100
@@ -1,4 +1,4 @@
-.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
+.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
 .\"
 .\" Standard preamble:
 .\" ========================================================================
@@ -38,6 +38,8 @@
 .    ds PI \(*p
 .    ds L" ``
 .    ds R" ''
+.    ds C`
+.    ds C'
 'br\}
 .\"
 .\" Escape single quotes in literal strings from groff's Unicode transform.
@@ -48,17 +50,24 @@
 .\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
 .\" entries marked with X<> in POD.  Of course, you'll have to process the
 .\" output yourself in some meaningful fashion.
-.ie \nF \{\
-.    de IX
-.    tm Index:\\$1\t\\n%\t"\\$2"
+.\"
+.\" Avoid warning from groff about undefined register 'F'.
+.de IX
 ..
-.    nr % 0
-.    rr F
-.\}
-.el \{\
-.    de IX
+.nr rF 0
+.if \n(.g .if rF .nr rF 1
+.if (\n(rF:(\n(.g==0)) \{
+.    if \nF \{
+.        de IX
+.        tm Index:\\$1\t\\n%\t"\\$2"
 ..
+.        if !\nF==2 \{
+.            nr % 0
+.            nr F 2
+.        \}
+.    \}
 .\}
+.rr rF
 .\"
 .\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
 .\" Fear.  Run.  Save yourself.  No user-serviceable parts.
@@ -124,7 +133,7 @@
 .\" ========================================================================
 .\"
 .IX Title "AS 1"
-.TH AS 1 "2013-11-26" "binutils-2.23.92" "GNU Development Tools"
+.TH AS 1 "2014-12-02" "binutils-2.24" "GNU Development Tools"
 .\" For nroff, turn off justification.  Always turn off hyphenation; it makes
 .\" way too many mistakes in technical documents.
 .if n .ad l
@@ -361,7 +370,7 @@
   [ \fB\-forbid\-unportable\-instructions\fR] [\fB\-Fup\fR]
 .SH "DESCRIPTION"
 .IX Header "DESCRIPTION"
-\&\s-1GNU\s0 \fBas\fR is really a family of assemblers.
+\&\s-1GNU \s0\fBas\fR is really a family of assemblers.
 If you use (or have used) the \s-1GNU\s0 assembler on one architecture, you
 should find a fairly similar environment when you use it on another
 architecture.  Each version has much in common with the others,
@@ -369,7 +378,7 @@
 \&\fIpseudo-ops\fR) and assembler syntax.
 .PP
 \&\fBas\fR is primarily intended to assemble the output of the
-\&\s-1GNU\s0 C compiler \f(CW\*(C`gcc\*(C'\fR for use by the linker
+\&\s-1GNU C\s0 compiler \f(CW\*(C`gcc\*(C'\fR for use by the linker
 \&\f(CW\*(C`ld\*(C'\fR.  Nevertheless, we've tried to make \fBas\fR
 assemble correctly everything that other assemblers for the same
 machine would assemble.
@@ -404,7 +413,7 @@
 that \fBas\fR could keep assembling a flawed program; errors report a
 grave problem that stops the assembly.
 .PP
-If you are invoking \fBas\fR via the \s-1GNU\s0 C compiler,
+If you are invoking \fBas\fR via the \s-1GNU C\s0 compiler,
 you can use the \fB\-Wa\fR option to pass arguments through to the assembler.
 The assembler arguments must be separated from each other (and the \fB\-Wa\fR)
 by commas.  For example:
@@ -512,8 +521,8 @@
 .IX Item "--gen-debug"
 .PD
 Generate debugging information for each assembler source line using whichever
-debug format is preferred by the target.  This currently means either \s-1STABS\s0,
-\&\s-1ECOFF\s0 or \s-1DWARF2\s0.
+debug format is preferred by the target.  This currently means either \s-1STABS,
+ECOFF\s0 or \s-1DWARF2.\s0
 .IP "\fB\-\-gstabs\fR" 4
 .IX Item "--gstabs"
 Generate stabs debugging information for each assembler line.  This
@@ -545,7 +554,7 @@
 .IP "\fB\-\-size\-check=warning\fR" 4
 .IX Item "--size-check=warning"
 .PD
-Issue an error or warning for invalid \s-1ELF\s0 .size directive.
+Issue an error or warning for invalid \s-1ELF \s0.size directive.
 .IP "\fB\-\-help\fR" 4
 .IX Item "--help"
 Print a summary of the command line options and exit.
@@ -728,7 +737,7 @@
 .IX Item "-g"
 This option is used when the compiler generates debug information.  When
 \&\fBgcc\fR is using \fBmips-tfile\fR to generate debug
-information for \s-1ECOFF\s0, local labels must be passed through to the object
+information for \s-1ECOFF,\s0 local labels must be passed through to the object
 file.  Otherwise this option has no effect.
 .IP "\fB\-G\fR\fIsize\fR" 4
 .IX Item "-Gsize"
@@ -828,7 +837,7 @@
 \&\f(CW\*(C`bf592\*(C'\fR.
 .IP "\fB\-mfdpic\fR" 4
 .IX Item "-mfdpic"
-Assemble for the \s-1FDPIC\s0 \s-1ABI\s0.
+Assemble for the \s-1FDPIC ABI.\s0
 .IP "\fB\-mno\-fdpic\fR" 4
 .IX Item "-mno-fdpic"
 .PD 0
@@ -1057,10 +1066,10 @@
 .IX Item "-mevexlig=512"
 .PD
 These options control how the assembler should encode length-ignored
-(\s-1LIG\s0) \s-1EVEX\s0 instructions.  \fB\-mevexlig=\fR\fI128\fR will encode \s-1LIG\s0
-\&\s-1EVEX\s0 instructions with 128bit vector length, which is the default.
+(\s-1LIG\s0) \s-1EVEX\s0 instructions.  \fB\-mevexlig=\fR\fI128\fR will encode \s-1LIG
+EVEX\s0 instructions with 128bit vector length, which is the default.
 \&\fB\-mevexlig=\fR\fI256\fR and \fB\-mevexlig=\fR\fI512\fR will
-encode \s-1LIG\s0 \s-1EVEX\s0 instructions with 256bit and 512bit vector length,
+encode \s-1LIG EVEX\s0 instructions with 256bit and 512bit vector length,
 respectively.
 .IP "\fB\-mevexwig=\fR\fI0\fR" 4
 .IX Item "-mevexwig=0"
@@ -1069,9 +1078,9 @@
 .IX Item "-mevexwig=1"
 .PD
 These options control how the assembler should encode w\-ignored (\s-1WIG\s0)
-\&\s-1EVEX\s0 instructions.  \fB\-mevexwig=\fR\fI0\fR will encode \s-1WIG\s0
-\&\s-1EVEX\s0 instructions with evex.w = 0, which is the default.
-\&\fB\-mevexwig=\fR\fI1\fR will encode \s-1WIG\s0 \s-1EVEX\s0 instructions with
+\&\s-1EVEX\s0 instructions.  \fB\-mevexwig=\fR\fI0\fR will encode \s-1WIG
+EVEX\s0 instructions with evex.w = 0, which is the default.
+\&\fB\-mevexwig=\fR\fI1\fR will encode \s-1WIG EVEX\s0 instructions with
 evex.w = 1.
 .IP "\fB\-mmnemonic=\fR\fIatt\fR" 4
 .IX Item "-mmnemonic=att"
@@ -1230,19 +1239,19 @@
 PowerPC processor.
 .IP "\fB\-a32\fR" 4
 .IX Item "-a32"
-Generate \s-1ELF32\s0 or \s-1XCOFF32\s0.
+Generate \s-1ELF32\s0 or \s-1XCOFF32.\s0
 .IP "\fB\-a64\fR" 4
 .IX Item "-a64"
-Generate \s-1ELF64\s0 or \s-1XCOFF64\s0.
+Generate \s-1ELF64\s0 or \s-1XCOFF64.\s0
 .IP "\fB\-K \s-1PIC\s0\fR" 4
 .IX Item "-K PIC"
 Set \s-1EF_PPC_RELOCATABLE_LIB\s0 in \s-1ELF\s0 flags.
 .IP "\fB\-mpwrx | \-mpwr2\fR" 4
 .IX Item "-mpwrx | -mpwr2"
-Generate code for \s-1POWER/2\s0 (\s-1RIOS2\s0).
+Generate code for \s-1POWER/2 \s0(\s-1RIOS2\s0).
 .IP "\fB\-mpwr\fR" 4
 .IX Item "-mpwr"
-Generate code for \s-1POWER\s0 (\s-1RIOS1\s0)
+Generate code for \s-1POWER \s0(\s-1RIOS1\s0)
 .IP "\fB\-m601\fR" 4
 .IX Item "-m601"
 Generate code for PowerPC 601.
@@ -1487,7 +1496,7 @@
 Control the treatment of literal pools.  The default is
 \&\fB\-\-no\-text\-section\-literals\fR, which places literals in
 separate sections in the output file.  This allows the literal pool to be
-placed in a data \s-1RAM/ROM\s0.  With \fB\-\-text\-section\-literals\fR, the
+placed in a data \s-1RAM/ROM. \s0 With \fB\-\-text\-section\-literals\fR, the
 literals are interspersed in the text section in order to keep them as
 close as possible to their references.  This may be necessary for large
 assembly files, where the literals would otherwise be out of range of the
diff -Nur ./gas/doc/c-avr.texi ../avr-binutils-2.24/gas/doc/c-avr.texi
--- binutils-2.24.orig/gas/doc/c-avr.texi	2014-12-02 17:48:34.796919056 +0100
+++ gas/doc/c-avr.texi	2014-12-02 17:31:35.788899509 +0100
@@ -112,6 +112,8 @@
 Instruction set avrxmega7 is for the XMEGA AVR core with up to 256K program
 memory space and greater than 64K data space (MCU types: atxmega128a1,
 atxmega128a1u).
+Instruction set avrtiny is for the ATtiny4/5/9/10/20/40
+microcontrollers.
 
 @cindex @code{-mall-opcodes} command line option, AVR
 @item -mall-opcodes
@@ -125,6 +127,10 @@
 @item -mno-wrap
 This option reject @code{rjmp/rcall} instructions with 8K wrap-around.
 
+@cindex @code{-mrmw} command line option, AVR
+@item -mrmw
+Accept RMW (@code{XCH,LAC,LAS,LAT}) instructions.
+
 @end table
 
 
diff -Nur ./gas/dwarf2dbg.c ../avr-binutils-2.24/gas/dwarf2dbg.c
--- binutils-2.24.orig/gas/dwarf2dbg.c	2014-12-02 17:48:34.796919056 +0100
+++ gas/dwarf2dbg.c	2014-12-02 17:31:35.788899509 +0100
@@ -125,8 +125,11 @@
    Note: If you want to change this, you'll have to update the
    "standard_opcode_lengths" table that is emitted below in
    out_debug_line().  */
+#ifndef TC_AVR
 #define DWARF2_LINE_OPCODE_BASE		13
-
+#else
+#define DWARF2_LINE_OPCODE_BASE		10
+#endif
 #ifndef DWARF2_LINE_BASE
   /* Minimum line offset in a special line info. opcode.  This value
      was chosen to give a reasonable range of values.  */
@@ -1549,9 +1552,11 @@
   out_byte (0);			/* DW_LNS_set_basic_block */
   out_byte (0);			/* DW_LNS_const_add_pc */
   out_byte (1);			/* DW_LNS_fixed_advance_pc */
+#ifndef TC_AVR
   out_byte (0);			/* DW_LNS_set_prologue_end */
   out_byte (0);			/* DW_LNS_set_epilogue_begin */
   out_byte (1);			/* DW_LNS_set_isa */
+#endif
 
   out_file_list ();
 
diff -Nur ./include/elf/avr.h ../avr-binutils-2.24/include/elf/avr.h
--- binutils-2.24.orig/include/elf/avr.h	2014-12-02 17:48:34.796919056 +0100
+++ include/elf/avr.h	2014-12-02 17:31:35.788899509 +0100
@@ -41,13 +41,14 @@
 #define E_AVR_MACH_AVR5     5
 #define E_AVR_MACH_AVR51   51
 #define E_AVR_MACH_AVR6     6 
-#define E_AVR_MACH_XMEGA1 101
-#define E_AVR_MACH_XMEGA2 102
-#define E_AVR_MACH_XMEGA3 103
-#define E_AVR_MACH_XMEGA4 104
-#define E_AVR_MACH_XMEGA5 105
-#define E_AVR_MACH_XMEGA6 106
-#define E_AVR_MACH_XMEGA7 107
+#define E_AVR_MACH_AVRTINY 100
+#define E_AVR_MACH_XMEGA1  101
+#define E_AVR_MACH_XMEGA2  102
+#define E_AVR_MACH_XMEGA3  103
+#define E_AVR_MACH_XMEGA4  104
+#define E_AVR_MACH_XMEGA5  105
+#define E_AVR_MACH_XMEGA6  106
+#define E_AVR_MACH_XMEGA7  107
 
 /* Relocations.  */
 START_RELOC_NUMBERS (elf_avr_reloc_type)
@@ -81,6 +82,10 @@
      RELOC_NUMBER (R_AVR_8_LO8,                27)
      RELOC_NUMBER (R_AVR_8_HI8,                28)
      RELOC_NUMBER (R_AVR_8_HLO8,               29)
+     RELOC_NUMBER (R_AVR_DIFF8,                30)
+     RELOC_NUMBER (R_AVR_DIFF16,               31)
+     RELOC_NUMBER (R_AVR_DIFF32,               32)
+     RELOC_NUMBER (R_AVR_LDS_STS_16,           33)
 END_RELOC_NUMBERS (R_AVR_max)
 
 #endif /* _ELF_AVR_H */
diff -Nur ./include/opcode/avr.h ../avr-binutils-2.24/include/opcode/avr.h
--- binutils-2.24.orig/include/opcode/avr.h	2014-12-02 17:48:34.796919056 +0100
+++ include/opcode/avr.h	2014-12-02 17:31:35.788899509 +0100
@@ -1,6 +1,6 @@
 /* Opcode table for the Atmel AVR micro controllers.
 
-   Copyright 2000, 2001, 2004, 2006, 2008, 2010, 2012 Free Software Foundation, Inc.
+   Copyright (C) 2000-2014 Free Software Foundation, Inc.
    Contributed by Denis Chertykov <denisc@overta.ru>
    
    This program is free software; you can redistribute it and/or modify
@@ -22,6 +22,7 @@
 #define AVR_ISA_LPM   0x0002 /* device has LPM */
 #define AVR_ISA_LPMX  0x0004 /* device has LPM Rd,Z[+] */
 #define AVR_ISA_SRAM  0x0008 /* device has SRAM (LD, ST, PUSH, POP, ...) */
+#define AVR_ISA_TINY  0x0010 /* device has Tiny core specific encodings */
 #define AVR_ISA_MEGA  0x0020 /* device has >8K program memory (JMP and CALL
 				supported, no 8K wrap on RJMP and RCALL) */
 #define AVR_ISA_MUL   0x0040 /* device has new core (MUL, FMUL, ...) */
@@ -37,6 +38,7 @@
 
 #define AVR_ISA_TINY1 (AVR_ISA_1200 | AVR_ISA_LPM)
 #define AVR_ISA_2xxx  (AVR_ISA_TINY1 | AVR_ISA_SRAM)
+#define AVR_ISA_2xxxa (AVR_ISA_1200 | AVR_ISA_SRAM)
 /* For the attiny26 which is missing LPM Rd,Z+.  */
 #define AVR_ISA_2xxe  (AVR_ISA_2xxx | AVR_ISA_LPMX)
 #define AVR_ISA_RF401 (AVR_ISA_2xxx | AVR_ISA_MOVW | AVR_ISA_LPMX)
@@ -72,6 +74,9 @@
                         AVR_ISA_ELPM | AVR_ISA_ELPMX | AVR_ISA_SPM | \
                         AVR_ISA_BRK | AVR_ISA_EIND | AVR_ISA_MOVW)
 
+#define AVR_ISA_AVRTINY (AVR_ISA_1200 | AVR_ISA_BRK | AVR_ISA_SRAM | \
+                         AVR_ISA_TINY)
+
 #define REGISTER_P(x) ((x) == 'r'		\
 		       || (x) == 'd'		\
 		       || (x) == 'w'		\
@@ -94,7 +99,7 @@
    `ld r,b' or `st b,r' respectively - next opcode entry)?  */
 #define AVR_DISP0_P(x) (((x) & 0xFC07) == 0x8000)
 
-/* constraint letters
+/* Constraint letters:
    r - any register
    d - `ldi' register (r16-r31)
    v - `movw' even register (r0, r2, ..., r28, r30)
@@ -110,6 +115,7 @@
    p - Port address value from 0 to 31. (cbi, sbi, sbic, sbis)
    K - immediate value from 0 to 63 (used in `adiw', `sbiw')
    i - immediate value
+   j - 7 bit immediate value from 0x40 to 0xBF (for 16-bit 'lds'/'sts')
    l - signed pc relative offset from -64 to 63
    L - signed pc relative offset from -2048 to 2047
    h - absolute code address (call, jmp)
@@ -156,12 +162,12 @@
 AVR_INSN (sev,  "",    "1001010000111000", 1, AVR_ISA_1200, 0x9438)
 AVR_INSN (sez,  "",    "1001010000011000", 1, AVR_ISA_1200, 0x9418)
 
-   /* Same as {cl,se}[chinstvz] above.  */
+/* Same as {cl,se}[chinstvz] above.  */
 AVR_INSN (bclr, "S",   "100101001SSS1000", 1, AVR_ISA_1200, 0x9488)
 AVR_INSN (bset, "S",   "100101000SSS1000", 1, AVR_ISA_1200, 0x9408)
 
-AVR_INSN (icall,"",    "1001010100001001", 1, AVR_ISA_2xxx, 0x9509)
-AVR_INSN (ijmp, "",    "1001010000001001", 1, AVR_ISA_2xxx, 0x9409)
+AVR_INSN (icall,"",    "1001010100001001", 1, AVR_ISA_2xxxa,0x9509)
+AVR_INSN (ijmp, "",    "1001010000001001", 1, AVR_ISA_2xxxa,0x9409)
 
 AVR_INSN (lpm,  "?",   "1001010111001000", 1, AVR_ISA_TINY1,0x95c8)
 AVR_INSN (lpm,  "r,z", "1001000ddddd010+", 1, AVR_ISA_LPMX, 0x9004)
@@ -190,7 +196,7 @@
 AVR_INSN (sbc,  "r,r", "000010rdddddrrrr", 1, AVR_ISA_1200, 0x0800)
 AVR_INSN (sub,  "r,r", "000110rdddddrrrr", 1, AVR_ISA_1200, 0x1800)
 
-   /* Shorthand for {eor,add,adc,and} r,r above.  */
+/* Shorthand for {eor,add,adc,and} r,r above.  */
 AVR_INSN (clr,  "r=r", "001001rdddddrrrr", 1, AVR_ISA_1200, 0x2400)
 AVR_INSN (lsl,  "r=r", "000011rdddddrrrr", 1, AVR_ISA_1200, 0x0c00)
 AVR_INSN (rol,  "r=r", "000111rdddddrrrr", 1, AVR_ISA_1200, 0x1c00)
@@ -245,7 +251,7 @@
 AVR_INSN (brvc, "l",   "111101lllllll011", 1, AVR_ISA_1200, 0xf403)
 AVR_INSN (brvs, "l",   "111100lllllll011", 1, AVR_ISA_1200, 0xf003)
 
-   /* Same as br?? above.  */
+/* Same as br?? above.  */
 AVR_INSN (brbc, "s,l", "111101lllllllsss", 1, AVR_ISA_1200, 0xf400)
 AVR_INSN (brbs, "s,l", "111100lllllllsss", 1, AVR_ISA_1200, 0xf000)
 
@@ -261,18 +267,18 @@
 AVR_INSN (inc,  "r",   "1001010rrrrr0011", 1, AVR_ISA_1200, 0x9403)
 AVR_INSN (lsr,  "r",   "1001010rrrrr0110", 1, AVR_ISA_1200, 0x9406)
 AVR_INSN (neg,  "r",   "1001010rrrrr0001", 1, AVR_ISA_1200, 0x9401)
-AVR_INSN (pop,  "r",   "1001000rrrrr1111", 1, AVR_ISA_2xxx, 0x900f)
-AVR_INSN (push, "r",   "1001001rrrrr1111", 1, AVR_ISA_2xxx, 0x920f)
+AVR_INSN (pop,  "r",   "1001000rrrrr1111", 1, AVR_ISA_2xxxa,0x900f)
+AVR_INSN (push, "r",   "1001001rrrrr1111", 1, AVR_ISA_2xxxa,0x920f)
 AVR_INSN (ror,  "r",   "1001010rrrrr0111", 1, AVR_ISA_1200, 0x9407)
 AVR_INSN (swap, "r",   "1001010rrrrr0010", 1, AVR_ISA_1200, 0x9402)
 
-   /* Atomic memory operations for XMEGA.  List before `sts'.  */
+/* Atomic memory operations for XMEGA.  List before `sts'.  */
 AVR_INSN (xch,  "z,r",   "1001001rrrrr0100", 1, AVR_ISA_RMW, 0x9204)
 AVR_INSN (las,  "z,r",   "1001001rrrrr0101", 1, AVR_ISA_RMW, 0x9205)
 AVR_INSN (lac,  "z,r",   "1001001rrrrr0110", 1, AVR_ISA_RMW, 0x9206)
 AVR_INSN (lat,  "z,r",   "1001001rrrrr0111", 1, AVR_ISA_RMW, 0x9207)
 
-   /* Known to be decoded as `nop' by the old core.  */
+/* Known to be decoded as `nop' by the old core.  */
 AVR_INSN (movw, "v,v", "00000001ddddrrrr", 1, AVR_ISA_MOVW, 0x0100)
 AVR_INSN (muls, "d,d", "00000010ddddrrrr", 1, AVR_ISA_MUL,  0x0200)
 AVR_INSN (mulsu,"a,a", "000000110ddd0rrr", 1, AVR_ISA_MUL,  0x0300)
@@ -280,21 +286,23 @@
 AVR_INSN (fmuls,"a,a", "000000111ddd0rrr", 1, AVR_ISA_MUL,  0x0380)
 AVR_INSN (fmulsu,"a,a","000000111ddd1rrr", 1, AVR_ISA_MUL,  0x0388)
 
-AVR_INSN (sts,  "i,r", "1001001ddddd0000", 2, AVR_ISA_2xxx, 0x9200)
-AVR_INSN (lds,  "r,i", "1001000ddddd0000", 2, AVR_ISA_2xxx, 0x9000)
+AVR_INSN (sts, "j,d", "10101kkkddddkkkk", 1, AVR_ISA_TINY, 0xA800)
+AVR_INSN (sts, "i,r", "1001001ddddd0000", 2, AVR_ISA_2xxx, 0x9200)
+AVR_INSN (lds, "d,j", "10100kkkddddkkkk", 1, AVR_ISA_TINY, 0xA000)
+AVR_INSN (lds, "r,i", "1001000ddddd0000", 2, AVR_ISA_2xxx, 0x9000)
 
-   /* Special case for b+0, `e' must be next entry after `b',
-      b={Y=1,Z=0}, ee={X=11,Y=10,Z=00}, !=1 if -e or e+ or X.  */
+/* Special case for b+0, `e' must be next entry after `b',
+   b={Y=1,Z=0}, ee={X=11,Y=10,Z=00}, !=1 if -e or e+ or X.  */
 AVR_INSN (ldd,  "r,b", "10o0oo0dddddbooo", 1, AVR_ISA_2xxx, 0x8000)
 AVR_INSN (ld,   "r,e", "100!000dddddee-+", 1, AVR_ISA_1200, 0x8000)
 AVR_INSN (std,  "b,r", "10o0oo1rrrrrbooo", 1, AVR_ISA_2xxx, 0x8200)
 AVR_INSN (st,   "e,r", "100!001rrrrree-+", 1, AVR_ISA_1200, 0x8200)
 
-   /* These are for devices that don't exist yet
-      (>128K program memory, PC = EIND:Z).  */
+/* These are for devices that don't exist yet
+   (>128K program memory, PC = EIND:Z).  */
 AVR_INSN (eicall, "",  "1001010100011001", 1, AVR_ISA_EIND, 0x9519)
 AVR_INSN (eijmp, "",   "1001010000011001", 1, AVR_ISA_EIND, 0x9419)
 
-/* DES instruction for encryption and decryption */
+/* DES instruction for encryption and decryption.  */
 AVR_INSN (des,  "E",   "10010100EEEE1011", 1, AVR_ISA_DES,  0x940B)
 
diff -Nur ./ld/configure.tgt ../avr-binutils-2.24/ld/configure.tgt
--- binutils-2.24.orig/ld/configure.tgt	2014-12-02 17:48:34.796919056 +0100
+++ ld/configure.tgt	2014-12-02 17:31:35.788899509 +0100
@@ -138,7 +138,7 @@
 arm-*-vxworks)		targ_emul=armelf_vxworks ;;
 arm*-*-conix*)		targ_emul=armelf ;;
 avr-*-*)		targ_emul=avr2
-			targ_extra_emuls="avr1 avr25 avr3 avr31 avr35 avr4 avr5 avr51 avr6 avrxmega1 avrxmega2 avrxmega3 avrxmega4 avrxmega5 avrxmega6 avrxmega7"
+			targ_extra_emuls="avr1 avr25 avr3 avr31 avr35 avr4 avr5 avr51 avr6 avrxmega1 avrxmega2 avrxmega3 avrxmega4 avrxmega5 avrxmega6 avrxmega7 avrtiny"
 			;;
 bfin-*-elf)		targ_emul=elf32bfin;
 			targ_extra_emuls="elf32bfinfd"
diff -Nur ./ld/emulparams/avrtiny.sh ../avr-binutils-2.24/ld/emulparams/avrtiny.sh
--- /dev/null	1970-01-01 01:00:00.000000000 +0100
+++ ld/emulparams/avrtiny.sh	2014-12-02 17:43:32.212913251 +0100
@@ -0,0 +1,13 @@
+ARCH=avr:100
+MACHINE=
+SCRIPT_NAME=avrtiny
+OUTPUT_FORMAT="elf32-avr"
+MAXPAGESIZE=1
+EMBEDDED=yes
+TEMPLATE_NAME=elf32
+
+TEXT_ORIGIN=0x0
+TEXT_LENGTH=4K
+DATA_ORIGIN=0x0800040
+DATA_LENGTH=0x100
+EXTRA_EM_FILE=avrelf
diff -Nur ./ld/Makefile.am ../avr-binutils-2.24/ld/Makefile.am
--- binutils-2.24.orig/ld/Makefile.am	2014-12-02 17:48:34.796919056 +0100
+++ ld/Makefile.am	2014-12-02 17:31:35.788899509 +0100
@@ -190,6 +190,7 @@
 	eavrxmega5.c \
 	eavrxmega6.c \
 	eavrxmega7.c \
+	eavrtiny.c   \
 	ecoff_i860.c \
 	ecoff_sparc.c \
 	ecrisaout.c \
@@ -873,6 +874,10 @@
   $(srcdir)/emultempl/avrelf.em $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
   ${GEN_DEPENDS}
 	${GENSCRIPTS} avrxmega7 "$(tdir_avr2)"
+eavrtiny.c: $(srcdir)/emulparams/avrtiny.sh \
+  $(srcdir)/emultempl/avrelf.em $(ELF_DEPS) $(srcdir)/scripttempl/avrtiny.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} avrtiny "$(tdir_avr2)"
 ecoff_i860.c: $(srcdir)/emulparams/coff_i860.sh \
   $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/i860coff.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} coff_i860 "$(tdir_coff_i860)"
diff -Nur ./ld/Makefile.in ../avr-binutils-2.24/ld/Makefile.in
--- binutils-2.24.orig/ld/Makefile.in	2014-12-02 17:48:34.796919056 +0100
+++ ld/Makefile.in	2014-12-02 17:31:35.792899509 +0100
@@ -498,6 +498,7 @@
 	eavrxmega5.c \
 	eavrxmega6.c \
 	eavrxmega7.c \
+	eavrtiny.c   \
 	ecoff_i860.c \
 	ecoff_sparc.c \
 	ecrisaout.c \
@@ -1127,6 +1128,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eavr5.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eavr51.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eavr6.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eavrtiny.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eavrxmega1.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eavrxmega2.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eavrxmega3.Po@am__quote@
@@ -2357,6 +2359,10 @@
   $(srcdir)/emultempl/avrelf.em $(ELF_DEPS) $(srcdir)/scripttempl/avr.sc \
   ${GEN_DEPENDS}
 	${GENSCRIPTS} avrxmega7 "$(tdir_avr2)"
+eavrtiny.c: $(srcdir)/emulparams/avrtiny.sh \
+  $(srcdir)/emultempl/avrelf.em $(ELF_DEPS) $(srcdir)/scripttempl/avrtiny.sc \
+  ${GEN_DEPENDS}
+	${GENSCRIPTS} avrtiny "$(tdir_avr2)"
 ecoff_i860.c: $(srcdir)/emulparams/coff_i860.sh \
   $(srcdir)/emultempl/generic.em $(srcdir)/scripttempl/i860coff.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} coff_i860 "$(tdir_coff_i860)"
diff -Nur ./ld/scripttempl/avr.sc ../avr-binutils-2.24/ld/scripttempl/avr.sc
--- binutils-2.24.orig/ld/scripttempl/avr.sc	2014-12-02 17:48:34.796919056 +0100
+++ ld/scripttempl/avr.sc	2014-12-02 17:31:35.792899509 +0100
@@ -10,6 +10,7 @@
   fuse      (rw!x) : ORIGIN = 0x820000, LENGTH = 1K
   lock      (rw!x) : ORIGIN = 0x830000, LENGTH = 1K
   signature (rw!x) : ORIGIN = 0x840000, LENGTH = 1K
+  user_signatures (rw!x) : ORIGIN = 0x850000, LENGTH = 1K
 }
 
 SECTIONS
@@ -163,13 +164,10 @@
     ${RELOCATING+ _etext = . ; }
   } ${RELOCATING+ > text}
 
-  .data	${RELOCATING-0} : ${RELOCATING+AT (ADDR (.text) + SIZEOF (.text))}
+  .data        ${RELOCATING-0} :
   {
     ${RELOCATING+ PROVIDE (__data_start = .) ; }
-    /* --gc-sections will delete empty .data. This leads to wrong start
-       addresses for subsequent sections because -Tdata= from the command
-       line will have no effect, see PR13697.  Thus, keep .data  */
-    KEEP (*(.data))    
+    *(.data)
     ${RELOCATING+ *(.data*)}
     *(.rodata)  /* We need to include .rodata here if gcc is used */
     ${RELOCATING+ *(.rodata*)} /* with -fdata-sections.  */
@@ -177,9 +175,9 @@
     ${RELOCATING+. = ALIGN(2);}
     ${RELOCATING+ _edata = . ; }
     ${RELOCATING+ PROVIDE (__data_end = .) ; }
-  } ${RELOCATING+ > data}
+  } ${RELOCATING+ > data ${RELOCATING+AT> text}}
 
-  .bss ${RELOCATING-0} :${RELOCATING+ AT (ADDR (.bss))}
+  .bss ${RELOCATING+ ADDR(.data) + SIZEOF (.data)} ${RELOCATING-0} :${RELOCATING+ AT (ADDR (.bss))}
   {
     ${RELOCATING+ PROVIDE (__bss_start = .) ; }
     *(.bss)
@@ -226,6 +224,11 @@
     KEEP(*(.signature*))
   } ${RELOCATING+ > signature}
 
+  .user_signatures ${RELOCATING-0}:
+  {
+    KEEP(*(.user_signatures*))
+  } ${RELOCATING+ > user_signatures}
+
   /* Stabs debugging sections.  */
   .stab 0 : { *(.stab) }
   .stabstr 0 : { *(.stabstr) }
diff -Nur ./ld/scripttempl/avrtiny.sc ../avr-binutils-2.24/ld/scripttempl/avrtiny.sc
--- /dev/null	1970-01-01 01:00:00.000000000 +0100
+++ ld/scripttempl/avrtiny.sc	2014-12-02 17:43:55.580913700 +0100
@@ -0,0 +1,255 @@
+cat <<EOF
+OUTPUT_FORMAT("${OUTPUT_FORMAT}","${OUTPUT_FORMAT}","${OUTPUT_FORMAT}")
+OUTPUT_ARCH(${ARCH})
+
+MEMORY
+{
+  text   (rx)   : ORIGIN = $TEXT_ORIGIN, LENGTH = $TEXT_LENGTH
+  data   (rw!x) : ORIGIN = $DATA_ORIGIN, LENGTH = $DATA_LENGTH
+
+  /* Provide offsets for config, lock and signature to match
+     production file format. Ignore offsets in datasheet.  */
+
+  config    (rw!x) : ORIGIN = 0x820000, LENGTH = 2
+  lock      (rw!x) : ORIGIN = 0x830000, LENGTH = 2
+  signature (rw!x) : ORIGIN = 0x840000, LENGTH = 4
+}
+
+SECTIONS
+{
+  /* Read-only sections, merged into text segment: */
+  ${TEXT_DYNAMIC+${DYNAMIC}}
+  .hash        ${RELOCATING-0} : { *(.hash)		}
+  .dynsym      ${RELOCATING-0} : { *(.dynsym)		}
+  .dynstr      ${RELOCATING-0} : { *(.dynstr)		}
+  .gnu.version ${RELOCATING-0} : { *(.gnu.version)	}
+  .gnu.version_d ${RELOCATING-0} : { *(.gnu.version_d)	}
+  .gnu.version_r ${RELOCATING-0} : { *(.gnu.version_r)	}
+
+  .rel.init    ${RELOCATING-0} : { *(.rel.init)	}
+  .rela.init   ${RELOCATING-0} : { *(.rela.init)	}
+  .rel.text    ${RELOCATING-0} :
+    {
+      *(.rel.text)
+      ${RELOCATING+*(.rel.text.*)}
+      ${RELOCATING+*(.rel.gnu.linkonce.t*)}
+    }
+  .rela.text   ${RELOCATING-0} :
+    {
+      *(.rela.text)
+      ${RELOCATING+*(.rela.text.*)}
+      ${RELOCATING+*(.rela.gnu.linkonce.t*)}
+    }
+  .rel.fini    ${RELOCATING-0} : { *(.rel.fini)	}
+  .rela.fini   ${RELOCATING-0} : { *(.rela.fini)	}
+  .rel.rodata  ${RELOCATING-0} :
+    {
+      *(.rel.rodata)
+      ${RELOCATING+*(.rel.rodata.*)}
+      ${RELOCATING+*(.rel.gnu.linkonce.r*)}
+    }
+  .rela.rodata ${RELOCATING-0} :
+    {
+      *(.rela.rodata)
+      ${RELOCATING+*(.rela.rodata.*)}
+      ${RELOCATING+*(.rela.gnu.linkonce.r*)}
+    }
+  .rel.data    ${RELOCATING-0} :
+    {
+      *(.rel.data)
+      ${RELOCATING+*(.rel.data.*)}
+      ${RELOCATING+*(.rel.gnu.linkonce.d*)}
+    }
+  .rela.data   ${RELOCATING-0} :
+    {
+      *(.rela.data)
+      ${RELOCATING+*(.rela.data.*)}
+      ${RELOCATING+*(.rela.gnu.linkonce.d*)}
+    }
+  .rel.ctors   ${RELOCATING-0} : { *(.rel.ctors)	}
+  .rela.ctors  ${RELOCATING-0} : { *(.rela.ctors)	}
+  .rel.dtors   ${RELOCATING-0} : { *(.rel.dtors)	}
+  .rela.dtors  ${RELOCATING-0} : { *(.rela.dtors)	}
+  .rel.got     ${RELOCATING-0} : { *(.rel.got)		}
+  .rela.got    ${RELOCATING-0} : { *(.rela.got)	}
+  .rel.bss     ${RELOCATING-0} : { *(.rel.bss)		}
+  .rela.bss    ${RELOCATING-0} : { *(.rela.bss)	}
+  .rel.plt     ${RELOCATING-0} : { *(.rel.plt)		}
+  .rela.plt    ${RELOCATING-0} : { *(.rela.plt)	}
+
+  /* Internal text space or external memory.  */
+  .text ${RELOCATING-0} : ${RELOCATING+ AT (0x0)}
+  {
+    *(.vectors)
+    KEEP(*(.vectors))
+
+    /* For data that needs to reside in the lower 64k of progmem.  */
+    *(.progmem.gcc*)
+
+    /* PR 13812: Placing the trampolines here gives a better chance
+       that they will be in range of the code that uses them.  */
+    ${RELOCATING+. = ALIGN(2);}
+    ${CONSTRUCTING+ __trampolines_start = . ; }
+    /* The jump trampolines for the 16-bit limited relocs will reside here.  */
+    *(.trampolines)
+    *(.trampolines*)
+    ${CONSTRUCTING+ __trampolines_end = . ; }
+
+    *(.progmem*)
+    
+    ${RELOCATING+. = ALIGN(2);}
+
+    /* For future tablejump instruction arrays for 3 byte pc devices.
+       We don't relax jump/call instructions within these sections.  */
+    *(.jumptables) 
+    *(.jumptables*) 
+
+    /* For code that needs to reside in the lower 128k progmem.  */
+    *(.lowtext)
+    *(.lowtext*)
+
+    ${CONSTRUCTING+ __ctors_start = . ; }
+    ${CONSTRUCTING+ *(.ctors) }
+    ${CONSTRUCTING+ __ctors_end = . ; }
+    ${CONSTRUCTING+ __dtors_start = . ; }
+    ${CONSTRUCTING+ *(.dtors) }
+    ${CONSTRUCTING+ __dtors_end = . ; }
+    KEEP(SORT(*)(.ctors))
+    KEEP(SORT(*)(.dtors))
+
+    /* From this point on, we don't bother about wether the insns are
+       below or above the 16 bits boundary.  */
+    *(.init0)  /* Start here after reset.  */
+    KEEP (*(.init0))
+    *(.init1)
+    KEEP (*(.init1))
+    *(.init2)  /* Clear __zero_reg__, set up stack pointer.  */
+    KEEP (*(.init2))
+    *(.init3)
+    KEEP (*(.init3))
+    *(.init4)  /* Initialize data and BSS.  */
+    KEEP (*(.init4))
+    *(.init5)
+    KEEP (*(.init5))
+    *(.init6)  /* C++ constructors.  */
+    KEEP (*(.init6))
+    *(.init7)
+    KEEP (*(.init7))
+    *(.init8)
+    KEEP (*(.init8))
+    *(.init9)  /* Call main().  */
+    KEEP (*(.init9))
+    *(.text)
+    ${RELOCATING+. = ALIGN(2);}
+    *(.text.*)
+    ${RELOCATING+. = ALIGN(2);}
+    *(.fini9)  /* _exit() starts here.  */
+    KEEP (*(.fini9))
+    *(.fini8)
+    KEEP (*(.fini8))
+    *(.fini7)
+    KEEP (*(.fini7))
+    *(.fini6)  /* C++ destructors.  */
+    KEEP (*(.fini6))
+    *(.fini5)
+    KEEP (*(.fini5))
+    *(.fini4)
+    KEEP (*(.fini4))
+    *(.fini3)
+    KEEP (*(.fini3))
+    *(.fini2)
+    KEEP (*(.fini2))
+    *(.fini1)
+    KEEP (*(.fini1))
+    *(.fini0)  /* Infinite loop after program termination.  */
+    KEEP (*(.fini0))
+    ${RELOCATING+ _etext = . ; }
+  } ${RELOCATING+ > text}
+
+  .data        ${RELOCATING-0} :
+  {
+    ${RELOCATING+ PROVIDE (__data_start = .) ; }
+    *(.data)
+    KEEP (*(.data))
+    *(.data*)
+    *(.rodata)  /* We need to include .rodata here if gcc is used */
+    *(.rodata*) /* with -fdata-sections.  */
+    *(.gnu.linkonce.d*)
+    ${RELOCATING+. = ALIGN(2);}
+    ${RELOCATING+ _edata = . ; }
+    ${RELOCATING+ PROVIDE (__data_end = .) ; }
+  } ${RELOCATING+ > data ${RELOCATING+AT> text}}
+
+  .bss ${RELOCATING+ ADDR(.data) + SIZEOF (.data)} ${RELOCATING-0} :${RELOCATING+ AT (ADDR (.bss))}
+  {
+    ${RELOCATING+ PROVIDE (__bss_start = .) ; }
+    *(.bss)
+    *(.bss*)
+    *(COMMON)
+    ${RELOCATING+ PROVIDE (__bss_end = .) ; }
+  } ${RELOCATING+ > data}
+
+  ${RELOCATING+ __data_load_start = LOADADDR(.data); }
+  ${RELOCATING+ __data_load_end = __data_load_start + SIZEOF(.data); }
+
+  /* Global data not cleared after reset.  */
+  .noinit ${RELOCATING-0}:
+  {
+    ${RELOCATING+ PROVIDE (__noinit_start = .) ; }
+    *(.noinit*)
+    ${RELOCATING+ PROVIDE (__noinit_end = .) ; }
+    ${RELOCATING+ _end = . ;  }
+    ${RELOCATING+ PROVIDE (__heap_start = .) ; }
+  } ${RELOCATING+ > data}
+
+  .lock ${RELOCATING-0}:
+  {
+    KEEP(*(.lock*))
+  } ${RELOCATING+ > lock}
+
+  .signature ${RELOCATING-0}:
+  {
+    KEEP(*(.signature*))
+  } ${RELOCATING+ > signature}
+
+  .config ${RELOCATING-0}:
+  {
+    KEEP(*(.config*))
+  } ${RELOCATING+ > config}
+
+  /* Stabs debugging sections.  */
+  .stab 0 : { *(.stab) }
+  .stabstr 0 : { *(.stabstr) }
+  .stab.excl 0 : { *(.stab.excl) }
+  .stab.exclstr 0 : { *(.stab.exclstr) }
+  .stab.index 0 : { *(.stab.index) }
+  .stab.indexstr 0 : { *(.stab.indexstr) }
+  .comment 0 : { *(.comment) }
+ 
+  /* DWARF debug sections.
+     Symbols in the DWARF debugging sections are relative to the beginning
+     of the section so we begin them at 0.  */
+
+  /* DWARF 1 */
+  .debug          0 : { *(.debug) }
+  .line           0 : { *(.line) }
+
+  /* GNU DWARF 1 extensions */
+  .debug_srcinfo  0 : { *(.debug_srcinfo) }
+  .debug_sfnames  0 : { *(.debug_sfnames) }
+
+  /* DWARF 1.1 and DWARF 2 */
+  .debug_aranges  0 : { *(.debug_aranges) }
+  .debug_pubnames 0 : { *(.debug_pubnames) }
+
+  /* DWARF 2 */
+  .debug_info     0 : { *(.debug_info) *(.gnu.linkonce.wi.*) }
+  .debug_abbrev   0 : { *(.debug_abbrev) }
+  .debug_line     0 : { *(.debug_line) }
+  .debug_frame    0 : { *(.debug_frame) }
+  .debug_str      0 : { *(.debug_str) }
+  .debug_loc      0 : { *(.debug_loc) }
+  .debug_macinfo  0 : { *(.debug_macinfo) }
+}
+EOF
+
diff -Nur ./opcodes/avr-dis.c ../avr-binutils-2.24/opcodes/avr-dis.c
--- binutils-2.24.orig/opcodes/avr-dis.c	2014-12-02 17:48:34.796919056 +0100
+++ opcodes/avr-dis.c	2014-12-02 17:31:35.792899509 +0100
@@ -187,6 +187,16 @@
     case 'i':
       sprintf (buf, "0x%04X", insn2);
       break;
+
+    case 'j':
+      {
+        unsigned int val = ((insn & 0xf) | ((insn & 0x600) >> 5)
+                                         | ((insn & 0x100) >> 2));
+        if (val > 0 && !(insn & 0x100))
+          val |= 0x80;
+        sprintf (buf, "0x%02x", val);
+      }
+      break;
       
     case 'M':
       sprintf (buf, "0x%02X", ((insn & 0xf00) >> 4) | (insn & 0xf));
@@ -330,8 +340,12 @@
   for (opcode = avr_opcodes, maskptr = avr_bin_masks;
        opcode->name;
        opcode++, maskptr++)
-    if ((insn & *maskptr) == opcode->bin_opcode)
-      break;
+    {
+      if ((opcode->isa == AVR_ISA_TINY) && (info->mach != bfd_mach_avrtiny))
+        continue;
+      if ((insn & *maskptr) == opcode->bin_opcode)
+        break;
+    }
   
   /* Special case: disassemble `ldd r,b+0' as `ld r,b', and
      `std b+0,r' as `st b,r' (next entry in the table).  */
