--- kjbucketsmodule.c.orig	Thu Jun 26 16:06:40 1997
+++ kjbucketsmodule.c	Wed Sep 13 19:45:45 2000
@@ -90,7 +90,6 @@
 /* include a bunch of stuff */
 
 #include "Python.h"
-#include "rename2.h"
 /* #include "allobjects.h" */
 /* #include "modsupport.h" */
 /* #include "ceval.h" */
@@ -157,7 +156,7 @@
      ( (tp->entries * RESIZEFACTOR) < (tp->size * GSIZE) ) )
 
 /* group states */
-enum GState { UNKNOWN, FREE, ROOT, OVERFLOW };
+enum GState { UNKNOWN, FREE, ROOT, OVERFLOW_ };
 
 /* bucket behaviors, smaller is less general! */
 enum BucketFlag { SETFLAG=0, DICTFLAG=1, GRAPHFLAG=2 };
@@ -172,11 +171,11 @@
 
 #ifdef CACHE_HASH 
 #define GETHASH(hashvalue, object) \
-     if (!is_stringobject(object) || \
-         (hashvalue = ((stringobject *) object)->ob_shash) == -1)\
-        hashvalue = hashobject(object)
+     if (!PyString_Check(object) || \
+         (hashvalue = ((PyStringObject *) object)->ob_shash) == -1)\
+        hashvalue = PyObject_Hash(object)
 #else
-#define GETHASH(hashvalue, object) hashvalue = hashobject(object)
+#define GETHASH(hashvalue, object) hashvalue = PyObject_Hash(object)
 #endif
 
 /*********************************************************/
@@ -185,14 +184,14 @@
 /* set bucket structure */
 typedef struct {
   long hash;
-  object * member;
+  PyObject * member;
 } SetBucket;
 
 /* graph and dict bucket structure */
 typedef struct {
   long hash;
-  object * member;
-  object * map;
+  PyObject * member;
+  PyObject * map;
 } DiBucket;
 
 /* for passing general buckets around, with external flags */
@@ -203,7 +202,7 @@
 
 /* destructuring a bucket (macroized) */
 #define BPtrDestructure(/*Bucketptr*/ Bp, /*enum BucketFlag*/ flag,\
-			   /*long*/ hp, /*object*/ memp, /*object*/ mapp)\
+			   /*long*/ hp, /*PyObject*/ memp, /*PyObject*/ mapp)\
 {\
   switch (flag) {\
   case SETFLAG:\
@@ -225,17 +224,17 @@
 static long BPtrDump(Bucketptr Bp, enum BucketFlag flag, FILE *fp)
 {
   long h;
-  object *mem, *map;
+  PyObject *mem, *map;
   BPtrDestructure(Bp, flag, h, mem, map);
   fprintf(fp, "Bkt[%ld, ",h);
   if (mem == 0) { fprintf(fp, "NULL"); }
   /*else {
-    if (printobject(mem, fp, 0) != 0) { return -1; }
+    if (PyObject_Print(mem, fp, 0) != 0) { return -1; }
   }*/
   fprintf(fp, "%ld, ",mem);
   if (map == 0) { fprintf(fp, "NULL"); }
   /*else {
-    if (printobject(map, fp, 0) != 0) { return -1; }
+    if (PyObject_Print(map, fp, 0) != 0) { return -1; }
   }*/
   fprintf(fp, "%ld] ",map);
   return 0;
@@ -243,13 +242,13 @@
 #endif
 
 /* setting a bucket
-   INCREFs handled here.
+   Py_INCREFs handled here.
    assumes initial contents are null or garbage. (macroized)
 */
 /* static long */
 #define BPtrSet( \
 	    /* Bucketptr */ Bp, /* enum BucketFlag */ flag,\
-	    /* long */ h, /* object * */mem1, /* object * */map1)\
+	    /* long */ h, /* PyObject * */mem1, /* PyObject * */map1)\
 {\
   switch(flag) {\
   case SETFLAG:\
@@ -257,15 +256,15 @@
     /* ignore map */\
     Bp.SBucketp->hash = h;\
     Bp.SBucketp->member = mem1;\
-    if (mem1 != 0) { XINCREF (mem1); }\
+    if (mem1 != 0) { Py_XINCREF (mem1); }\
     break;\
   case DICTFLAG:\
   case GRAPHFLAG:\
     Bp.DBucketp->hash = h;\
     Bp.DBucketp->member = mem1;\
-    if (mem1 != 0) { XINCREF (mem1); }\
+    if (mem1 != 0) { Py_XINCREF (mem1); }\
     Bp.DBucketp->map = map1;\
-    if (map1 != 0) { XINCREF (map1); }\
+    if (map1 != 0) { Py_XINCREF (map1); }\
     break;\
   }\
 }
@@ -275,13 +274,13 @@
 */
 /*static long BPtrInit( Bucketptr Bp, enum BucketFlag flag )
 {
-  object *dummy;
+  PyObject *dummy;
   dummy = 0;
   BPtrSet( Bp, flag, NOHASH, dummy, dummy );
 }*/
 
 /* re-initialization assuming valid value 
-   DECREFs handled here.
+   Py_DECREFs handled here.
    to save values in the bucket for use after reinitialization,
    incref them first and decref after...
    (macroized)
@@ -290,11 +289,11 @@
 #define BPtrReInit( /*Bucketptr*/ Bp, /*enum BucketFlag*/ flag )\
 {\
   long hashBBB;\
-  object *MemberBBB, *MapBBB, *dummyBBB;\
+  PyObject *MemberBBB, *MapBBB, *dummyBBB;\
   BPtrDestructure( Bp, flag, hashBBB, MemberBBB, MapBBB );\
-  if ( MemberBBB != 0 ) { XDECREF(MemberBBB); }\
+  if ( MemberBBB != 0 ) { Py_XDECREF(MemberBBB); }\
   /* don't decref map for sets!! */\
-  if ( (MapBBB != 0) && (flag != SETFLAG) ) { XDECREF(MapBBB); }\
+  if ( (MapBBB != 0) && (flag != SETFLAG) ) { Py_XDECREF(MapBBB); }\
   dummyBBB = 0;\
   BPtrSet( Bp, flag, NOHASH, dummyBBB, dummyBBB );\
 }
@@ -308,14 +307,14 @@
 		  /*Bucketptr*/ Bp, \
 		  /*enum BucketFlag*/ flag,\
 		  /*long*/ h, \
-		  /*object * */ Mm, \
-		  /*object * */ Mp, \
+		  /*PyObject * */ Mm, \
+		  /*PyObject * */ Mp, \
 		  /*enum ForceFlag*/ Force,\
 		  /*long * */ newflag, \
 		  /*long * */ dirtyflag) \
 {\
   long hashAAA;\
-  object *MemberAAA, *MapAAA, *dummyAAA;\
+  PyObject *MemberAAA, *MapAAA, *dummyAAA;\
   newflag = 0; /* default assumption */\
   result = 0; /* default: fail */\
   BPtrDestructure( Bp, flag, hashAAA, MemberAAA, MapAAA );\
@@ -336,7 +335,7 @@
 	if (h == NOHASH)\
 	  { result = 1; }  /* bucket full, hash null == null match */\
 	else { /* fully defined match */\
-	  if ((h == hashAAA) && (cmpobject(Mm, MemberAAA)==0))\
+	  if ((h == hashAAA) && (PyObject_Compare(Mm, MemberAAA)==0))\
 	    { result = 1; } /* hash defined, all eq == match */\
 	}\
       }\
@@ -349,12 +348,12 @@
       /* Forced match succeeds if bucket is empty or members match */\
       if ((Force == FORCE) &&\
 	  ( (hashAAA == NOHASH) || \
-	  ((h == hashAAA)&&(cmpobject(Mm, MemberAAA)==0)) ) ) {\
+	  ((h == hashAAA)&&(PyObject_Compare(Mm, MemberAAA)==0)) ) ) {\
 	if ((Mm == 0) || (Mp == 0)) { result = -1; } /* error */\
 	else {\
 	  if (hashAAA == NOHASH) { newflag = 1; } /* new if old was empty */\
 	  else {\
-	    if (cmpobject(MapAAA,Mp)!=0) { /* overwriting: dirty */\
+	    if (PyObject_Compare(MapAAA,Mp)!=0) { /* overwriting: dirty */\
 	      dirtyflag = 1;\
 	    }\
 	  }\
@@ -364,8 +363,8 @@
 	}\
       } else {\
 	if ( (h!=NOHASH) && (h==hashAAA) &&\
-	     (Mm != 0) && (cmpobject(Mm, MemberAAA)==0) &&\
-	     ( ( Mp == 0 ) || (cmpobject(MapAAA,Mp)==0) ) )\
+	     (Mm != 0) && (PyObject_Compare(Mm, MemberAAA)==0) &&\
+	     ( ( Mp == 0 ) || (PyObject_Compare(MapAAA,Mp)==0) ) )\
 	  { result = 1; } /* successful unforced match */\
       }\
     }\
@@ -390,8 +389,8 @@
       } else {\
 	/* unforced match, can match if Mm is null */\
 	if (( hashAAA != NOHASH ) && ( hashAAA == h ) &&\
-	    (Mm != 0) && ( cmpobject(Mm,MemberAAA)==0 ) && \
-	    ( (Mp == 0) || ( cmpobject(MapAAA,Mp)==0 ))) {\
+	    (Mm != 0) && ( PyObject_Compare(Mm,MemberAAA)==0 ) && \
+	    ( (Mp == 0) || ( PyObject_Compare(MapAAA,Mp)==0 ))) {\
           Dprint(("graph unforced match\n")); \
 	  result = 1; /* successful unforced match */\
 	}\
@@ -483,7 +482,7 @@
                    /*Groupptr*/ Eg, /*enum BucketFlag*/ Eflag)\
 {\
   long Eh;\
-  object *EMm, *EMp;\
+  PyObject *EMm, *EMp;\
   Bucketptr EBp;\
   GetBucket(EBp, Eg, Eflag, 0);\
   BPtrDestructure(EBp, Eflag, Eh, EMm, EMp);\
@@ -498,7 +497,7 @@
 #define Groupinit(/*Groupptr*/ Dg, /*enum BucketFlag*/ Dflag)\
 {\
   Bucketptr DBp;\
-  object *Ddummy;\
+  PyObject *Ddummy;\
   long Di;\
   Ddummy = 0;\
   for  (Di=0; Di<GSIZE; Di++) {\
@@ -551,8 +550,8 @@
                       /* Groupptr */ g, \
 		      /* enum BucketFlag */ flag,\
 		      /* long */ hash1, \
-		      /* object * */ Member1, \
-		      /* object * */ Map1, \
+		      /* PyObject * */ Member1, \
+		      /* PyObject * */ Map1, \
 		      /* enum ForceFlag */ Force, \
 		      /* long */ StartAfter,\
 		      /* long * */ index, /* use literal */\
@@ -607,7 +606,7 @@
       Nextptr = &(SGptr->mem.free.Next);\
       break;\
     case ROOT:\
-    case OVERFLOW:\
+    case OVERFLOW_:\
     case UNKNOWN:\
       templateptr.sbp = &(SGptr->mem.group);\
       Nextptr = &(SGptr->mem.group.Next);\
@@ -623,7 +622,7 @@
       Nextptr = &(DGptr->mem.free.Next);\
       break;\
     case ROOT:\
-    case OVERFLOW:\
+    case OVERFLOW_:\
     case UNKNOWN:\
       templateptr.dbp = &(DGptr->mem.group);\
       Nextptr = &(DGptr->mem.group.Next);\
@@ -739,7 +738,7 @@
   GArrayRef(Jarray,Jflag,Jprevious, Jgprev, JPrevState, JNextOfPrev);\
   GArrayRef(Jarray,Jflag,Jtoindex, Jgother, JOtherState, JNextOfOther);\
   *JNextOfOther = *JNext;\
-  *JOtherState = OVERFLOW;\
+  *JOtherState = OVERFLOW_;\
   GroupCopy(Jgother, Jg, Jflag);\
   *JNextOfPrev = Jtoindex;\
   Groupinit(Jg, Jflag);\
@@ -822,11 +821,11 @@
       (DiGroup *) calloc(sizeof(DiGroup), size);
     break;
   default: 
-    err_setstr(SystemError, "invalid internal table behavior flag");
+    PyErr_SetString(PyExc_SystemError, "invalid internal table behavior flag");
     return 0; /* error */
   }
   if (groups.Dgroups == NULL) {
-    err_nomem();
+    PyErr_NoMemory();
     return 0; /* error */
   }
   /* initialize all states to unknown */
@@ -879,7 +878,7 @@
       fprintf(fp, "ROOT(next=%ld)",*Next);
       if (GroupDump(g,flag,fp)!=0) { return -1; }
       break;
-    case OVERFLOW:
+    case OVERFLOW_:
       fprintf(fp, "OVFLW(next=%ld)",*Next);
       if (GroupDump(g,flag,fp)!=0) { return -1; }
       break;
@@ -903,7 +902,7 @@
   for (i=0; i<size; i++) {
     Dprint(("greinit at %ld\n",i));
     GArrayRef(g, flag, i, groupp, State, d);
-    if ((*State == ROOT) || (*State == OVERFLOW)) {
+    if ((*State == ROOT) || (*State == OVERFLOW_)) {
       for (j=0; j<GSIZE; j++) {
 	GetBucket(Bp,groupp,flag,j);
 	BPtrReInit(Bp, flag);
@@ -921,7 +920,7 @@
   /* reinitialize all buckets */
   groupsReinit(g, flag, size);
   /* now delete the array */
-  DEL(g.Sgroups);
+  PyMem_DEL(g.Sgroups);
 }
 
 /* unfreeing a group in the Table *assumed free with garbage contents* */
@@ -1001,7 +1000,7 @@
 */
 /* crazy idea: macroize this monster, and use stub only for recursive
                calls... */
-static long tableMatch( Table *tp, object *member1, object *map1,
+static long tableMatch( Table *tp, PyObject *member1, PyObject *map1,
 	      enum ForceFlag Force,
 	      long rootgroupI, long lastgroupI, long lastbucketI, long hsh,
   /*outputs*/ long *rtgrp, long *nxtgrp, long *nxtbkt, Bucketptr *Bp,
@@ -1021,7 +1020,7 @@
 
   /* sanity checks (comment out later?) */
   if ( (member1 == 0) && ( (rootgroupI < 0) || (Force == FORCE) ) ) {
-    err_setstr(SystemError, "bug in kjbuckets implementation (tableMatch)");
+    PyErr_SetString(PyExc_SystemError, "bug in kjbuckets implementation (tableMatch)");
     return -1;
   }
 
@@ -1036,7 +1035,7 @@
   /*if (tp->Free != -1) {
      GArrayRef(groups, flag, tp->Free, root, state, rNext);
      if (*state != FREE) {
-        err_setstr(SystemError, "free index not free in table");
+        PyErr_SetString(PyExc_SystemError, "free index not free in table");
         return -1;
       }
    }*/
@@ -1056,7 +1055,7 @@
       /* lastgroup and lastbucket must be none */
       lastgroupI = lastbucketI = -1;
       /* otherwise must force an insert, need root group... */
-      if (*state == OVERFLOW) {
+      if (*state == OVERFLOW_) {
 	/* swap out the overflow group */
         Dprint(("root is overflow %ld\n",rootgroupI));
 	if (tp->Free == -1) {
@@ -1076,7 +1075,7 @@
 	  Dprint(("unfreeing rootgroup %ld\n", rootgroupI));
 	  UnFreeTableIndex(rootgroupI, tp, rootgroupI);
 	} else {
-	  err_setstr(SystemError, "bad rootgroup state in tablematch");
+	  PyErr_SetString(PyExc_SystemError, "bad rootgroup state in tablematch");
 	  return -1; /* error */
 	}
       }
@@ -1107,7 +1106,7 @@
   if (found != 0) {
     Dprint(("tm: found = %ld\n",found));
     if (found<0) {
-      err_setstr(SystemError, "groupmatch abnormal return");
+      PyErr_SetString(PyExc_SystemError, "groupmatch abnormal return");
       return -1;
     }
     if (*isnew != 0) { tp->entries++; }
@@ -1130,13 +1129,13 @@
     }
     UnFreeTableIndex(AvailableI, tp, tp->Free);
     GArrayRef(groups, flag, AvailableI, avail, availState, availNext);
-    *availState = OVERFLOW;
+    *availState = OVERFLOW_;
     *availNext = rootgroupI;
     *Next = AvailableI;
     groupmatch(found, avail,flag,hsh,member1,map1,
 		       Force, -1, (*nxtbkt), (*Bp), (*isnew), (*dirtyptr));
     if (found<0) {
-      err_setstr(SystemError, "groupmatch abnormal return");
+      PyErr_SetString(PyExc_SystemError, "groupmatch abnormal return");
       return -1;
     }
     *nxtgrp = AvailableI;
@@ -1149,16 +1148,16 @@
 /* some simple uses of table matching */
 
 /* find (or set) a matching pair */
-static long TableGet1( Table *tp, object *member1, object *map1, long hash,
+static long TableGet1( Table *tp, PyObject *member1, PyObject *map1, long hash,
 	       enum ForceFlag Force,
-	       object **memout, object **mapout)
+	       PyObject **memout, PyObject **mapout)
 {
   long hashout;
   long rt, nxt, nxtb, isnew, found;
   Bucketptr Bp;
   enum BucketFlag flag = tp->flag;
   if (member1 == NULL) {
-    err_setstr(SystemError, "TableGet1 called with NULL??");
+    PyErr_SetString(PyExc_SystemError, "TableGet1 called with NULL??");
     return -1;
   }
   Dprint(("tg1: calling tablematch\n"));
@@ -1167,7 +1166,7 @@
 		     &rt, &nxt, &nxtb, &Bp, &hashout, &isnew);
   if (found == -1) { return -1; }
   if (found == 0) {
-    err_setval(KeyError, member1);
+    PyErr_SetObject(PyExc_KeyError, member1);
     return -1;
   }
   BPtrDestructure(Bp, flag, hashout, *memout, *mapout);
@@ -1178,7 +1177,7 @@
 /* could macroize */
 long ReInsertGroup( Groupptr g, enum BucketFlag flag, Table *tp)
 {
-  object *Member, *Map;
+  PyObject *Member, *Map;
   long i, rt, nxt, nxtb, isnew, test;
   long hash, h;
   Bucketptr Bp, Bpdummy;
@@ -1189,7 +1188,7 @@
       test = tableMatch(tp, Member, Map, FORCE, -1, -1, -1, hash,
 		      &rt, &nxt, &nxtb, &Bpdummy, &h, &isnew);
       if (test != 1) {
-	err_setstr(SystemError, "unable to resize table");
+	PyErr_SetString(PyExc_SystemError, "unable to resize table");
 	return 0;
       }
     }
@@ -1228,14 +1227,14 @@
      if (*State != FREE) {
        Dprint(("free ptr %ld corrupted in resize/alloc, State=%ld not %ld\n",\
 	      tp->Free,*State,FREE));
-       err_setstr(SystemError, "resize fail (1)");
+       PyErr_SetString(PyExc_SystemError, "resize fail (1)");
        return 0;
      }
    }*/
   /* now reinsert all former contents */
   for (i=0; i<size; i++) {
     GArrayRef(oldgroups, flag, i, g, State, Next);
-    if ( (*State == OVERFLOW) || (*State == ROOT) ) {
+    if ( (*State == OVERFLOW_) || (*State == ROOT) ) {
       if (ReInsertGroup(g, flag, tp) == 0) {
 	success = 0;
 	break;
@@ -1247,7 +1246,7 @@
 	  Dprint((\
             "free ptr %ld corrupted in resize/reinsert %ld, State=%ld not %ld\n",\
 		 tp->Free,i,*State,FREE));
-	  err_setstr(SystemError, "resize fail (2)");
+	  PyErr_SetString(PyExc_SystemError, "resize fail (2)");
 	  return 0;
 	}*/
     }
@@ -1261,7 +1260,7 @@
      if (*State != FREE) {
        Dprint(("free ptr %ld corrupted in resize, State=%ld not %ld\n",tp->Free,\
 	      *State,FREE)); 
-       err_setstr(SystemError, "resize fail (3)");
+       PyErr_SetString(PyExc_SystemError, "resize fail (3)");
        return 0;
      }*/
   if (success==0) Dprint(("failing in tableresize\n"));
@@ -1269,9 +1268,9 @@
 }
 
 /* deleting a member from a group, deletes *all* matching members */
-long deleteFromTable(Table *tp, object *member1, object *map1)
+long deleteFromTable(Table *tp, PyObject *member1, PyObject *map1)
 {
-  object *M, *Mp;
+  PyObject *M, *Mp;
   enum BucketFlag flag = tp->flag;
   GroupArray groups = tp->groups;
   long hash, bhash;
@@ -1286,7 +1285,7 @@
 		     &rtgrp, &nxtgrp, &nxtbkt, &Bp, &hash, &isnew);
   if (found == -1) { return 0; } /* external error */
   if (found == 0) {
-    err_setval(KeyError, member1);
+    PyErr_SetObject(PyExc_KeyError, member1);
     return 0;
   }
   /* mark the table as dirty */
@@ -1310,20 +1309,20 @@
   while (found) {
     BPtrDestructure(Bp, flag, hash, M, Mp);
     tp->entries--;
-    /*  !!! NOTE: since BPtrReInit DECREFs the contents, must
-	INCREF contents here to prevent deallocation of the
+    /*  !!! NOTE: since BPtrReInit Py_DECREFs the contents, must
+	Py_INCREF contents here to prevent deallocation of the
 	members and decref after reinstallation in the table
 	!!! (kinda subtle python thing!) !!! */
-    XINCREF(M);
-    XINCREF(Mp);
+    Py_XINCREF(M);
+    Py_XINCREF(Mp);
     BPtrReInit(Bp,flag);
     bfound = tableMatch(tp, M, Mp,
 			FORCE, brt, bnxtgrp, bnxtbkt, hash,
 			&brt, &bnxtgrp, &bnxtbkt, &bBp, &bhash, &bisnew);
-    XDECREF(M);
-    XDECREF(Mp);
+    Py_XDECREF(M);
+    Py_XDECREF(Mp);
     if (found != 1) {
-      err_setstr(SystemError, "?? cannot backfill on delete");
+      PyErr_SetString(PyExc_SystemError, "?? cannot backfill on delete");
       return 0;
     }
     found = tableMatch(tp, 0, 0,
@@ -1370,8 +1369,8 @@
   long root;
   long lastgroup;
   long lastbucket;
-  object *key;
-  object *map;
+  PyObject *key;
+  PyObject *map;
   long hash;
 } TableWalker;
 
@@ -1386,7 +1385,7 @@
   enum BucketFlag flag;
   enum GState *State;
   long *Next, size, found, isnew, dirtyptr;
-  object *dummy;
+  PyObject *dummy;
   Table *tp = twp->tp;
   size = tp->size;
   flag = tp->flag;
@@ -1401,7 +1400,7 @@
   found = 0;
   do {
     GArrayRef(tp->groups, flag, twp->lastgroup, g, State, Next);
-    if ((*State==ROOT) || (*State==OVERFLOW)) {
+    if ((*State==ROOT) || (*State==OVERFLOW_)) {
       dummy = 0;
       groupmatch(found, g, flag, NOHASH, dummy, dummy, NOFORCE,\
 			 (twp->lastbucket), (twp->lastbucket), \
@@ -1438,7 +1437,7 @@
 static long Nextbykey(TableWalker *twp)
 {
   Bucketptr Bp;
-  object *dummyk;
+  PyObject *dummyk;
   long dummyh;
   long isnew;
   Dprint(("Nextbykey\n"));
@@ -1454,7 +1453,7 @@
 }
 
 /* could macroize */
-static void Initbykey(TableWalker *twp, Table *tp, object *key, long hash)
+static void Initbykey(TableWalker *twp, Table *tp, PyObject *key, long hash)
 {
   Dprint(("Initbykey\n"));
   twp->tp = tp;
@@ -1475,7 +1474,7 @@
 {
   long test;
   TableWalker tw;
-  object *d1, *d2;
+  PyObject *d1, *d2;
   /* walk through the source */
   (void) InitAll(&tw, source);
   while (tw.valid == 1) {
@@ -1496,11 +1495,11 @@
 {
   long test;
   TableWalker tw;
-  object *d1, *d2;
+  PyObject *d1, *d2;
   enum BucketFlag tflag = target->flag;
   /* source flag cannot be set */
   if (source->flag == SETFLAG) { 
-    err_setstr(TypeError, "Cannot transpose set");
+    PyErr_SetString(PyExc_TypeError, "Cannot transpose set");
     return -1;  /* error return */
   }
   /* walk through the source */
@@ -1535,7 +1534,7 @@
 		    long prelim)
 {
   TableWalker lwalker, rwalker;
-  object *d1, *d2;
+  PyObject *d1, *d2;
   long test, count, exclude, rt, nxt, nxtb, isnew;
   Bucketptr Bp;
   long hashout;
@@ -1592,7 +1591,7 @@
   long test, rt, nxt, nxtb, isnew, found, count;
   Bucketptr Bp;
   TableWalker tw;
-  object *d1, *d2;
+  PyObject *d1, *d2;
   /* walk through left */
   (void) InitAll(&tw, left);
   count = 0;
@@ -1622,7 +1621,7 @@
    return 1 if found, else 0 (-1 on error).
    */
 static long Tmindiff(Table *left, Table *right, 
-		    object **mem, object **map, long *hash)
+		    PyObject **mem, PyObject **map, long *hash)
 {
   long hashout;
   long gotit, rt, nxt, nxtb, isnew, found, cmp;
@@ -1646,9 +1645,9 @@
 	gotit = 1;
       } else {
 	cmp = *hash - tw.hash;
-	if (cmp == 0) { cmp = cmpobject( tw.key, *mem ); }
+	if (cmp == 0) { cmp = PyObject_Compare( tw.key, *mem ); }
 	if ((cmp>0) || 
-	    ((cmp==0) && (tw.map!=0) && (cmpobject( tw.map, *map )>0))) {
+	    ((cmp==0) && (tw.map!=0) && (PyObject_Compare( tw.map, *map )>0))) {
 	  *mem = tw.key;
 	  *map = tw.map;
 	  *hash = tw.hash;
@@ -1683,7 +1682,7 @@
 /* general structure for all table behaviors */
 
 typedef struct {
-  OB_VARHEAD
+  PyObject_VAR_HEAD
     /* the hash flag */
     /* IF THIS IS NOT NOHASH THE TABLE SHOULD BE IMMUTABLE */
     long hashvalue;
@@ -1692,9 +1691,9 @@
 } TableWrapper;
 
 /* predeclarations of type objects */
-staticforward typeobject kjSettype;
-staticforward typeobject kjDicttype;
-staticforward typeobject kjGraphtype;
+staticforward PyTypeObject kjSettype;
+staticforward PyTypeObject kjDicttype;
+staticforward PyTypeObject kjGraphtype;
 
 /* type test macros */
 #define is_kjSetobject(op) ((op)->ob_type == &kjSettype)
@@ -1710,14 +1709,14 @@
    if (in->rep.Dirty!=0) out->rep.Dirty = 1
 
 /* internal allocation function for table wrappers */
-static object * newWrapper(long expectedsize, enum BucketFlag flag)
+static PyObject * newWrapper(long expectedsize, enum BucketFlag flag)
 {
   /* allocate one wrapper */
   TableWrapper *wp;
   Dprint(("WnewWrapper\n"));
-  wp = NEW(TableWrapper, 1);
+  wp = PyMem_NEW(TableWrapper, 1);
   if (wp == NULL) {
-    return err_nomem(); /* allocation failure */
+    return PyErr_NoMemory(); /* allocation failure */
   }
   switch (flag) {
   case SETFLAG:
@@ -1727,28 +1726,28 @@
   case GRAPHFLAG:
     wp->ob_type = &kjGraphtype; break;
   default:
-    err_setstr(SystemError, "invalid internal table flag");
+    PyErr_SetString(PyExc_SystemError, "invalid internal table flag");
     return NULL;
   }
   /* initialize the internal table */
   if (initTable(&(wp->rep), flag, expectedsize) == 0) {
     /* initialization failed, assume an appropriate error is set */
-    DEL(wp);
+    PyMem_DEL(wp);
     return NULL;
   }
   Dprint(("WnewWrapper: table initialized\n"));
   wp->hashvalue = NOHASH;
   /* INITIALIZE THE REFERENCE COUNT FOR THE NEW OBJECT */
-  NEWREF(wp);
-  return (object *) wp;
+  _Py_NewReference(wp);
+  return (PyObject *) wp;
 }
 
 /* *almost* an external python constructor for wrappers */
-static object * makeWrapper(object *module, object *args,
+static PyObject * makeWrapper(PyObject *module, PyObject *args,
 			    enum BucketFlag flag)
 {
   TableWrapper *result, *initWrapper;
-  object *initlist, *pair, *key, *map, *d1, *d2;
+  PyObject *initlist, *pair, *key, *map, *d1, *d2;
   long len, members, valid, index, islist, iskjtable, istuple;
   Table *tp;
   islist = 0;
@@ -1761,15 +1760,15 @@
   if (args == NULL) {
     members = 0;
   } else {  /* some args: check it and determine its length */
-    valid = getargs(args, "i", &members);
+    valid = PyArg_Parse(args, "i", &members);
     if (!valid) {
-      err_clear();
-      valid = getargs(args, "O", &initlist);
+      PyErr_Clear();
+      valid = PyArg_Parse(args, "O", &initlist);
       if (valid) { 
-	islist = is_listobject(initlist);
+	islist = PyList_Check(initlist);
 	if (islist) {
           Dprint(("makeWrapper from list\n"));
-	  len = getlistsize(initlist);
+	  len = PyList_Size(initlist);
 	} else {
 	  iskjtable = is_kjTable(initlist);
 	  if (iskjtable) {
@@ -1777,10 +1776,10 @@
 	    initWrapper = (TableWrapper *) initlist;
 	    len = initWrapper->rep.entries;
 	  } else {
-	    istuple = is_tupleobject(initlist);
+	    istuple = PyTuple_Check(initlist);
 	    if (istuple) {
               Dprint(("makeWrapper from tuple\n"));
-	      len = gettuplesize(initlist);
+	      len = PyTuple_Size(initlist);
 	    } else {
 	      valid = 0;
 	    }
@@ -1788,7 +1787,7 @@
 	}
       }
       if (!valid) { 
-	err_setstr(TypeError, 
+	PyErr_SetString(PyExc_TypeError, 
          "initializer must be integer or list or tuple or kj-Table");
 	return NULL; 
       }
@@ -1806,24 +1805,24 @@
       tp = &(result->rep);
       for (index = 0; index<len; index++) {
 	if ( islist ) {
-	  pair = getlistitem(initlist, index);
+	  pair = PyList_GetItem(initlist, index);
 	} else {
-	  pair = gettupleitem(initlist, index);
+	  pair = PyTuple_GetItem(initlist, index);
 	}
 	if (flag == SETFLAG) {
 	  valid = TableGet1(tp, pair, 0, NOHASH, FORCE, &d1, &d2);
 	  if (valid == -1) {
-	    DECREF(result);
+	    Py_DECREF(result);
 	    return NULL;
 	  }
 	} else {
-	  if (!getargs(pair, "(OO)", &key, &map)) {
-	    DECREF(result);
+	  if (!PyArg_Parse(pair, "(OO)", &key, &map)) {
+	    Py_DECREF(result);
 	    return NULL;
 	  }
 	  valid = TableGet1(tp, key, map, NOHASH, FORCE, &d1, &d2);
 	  if (valid == -1) {
-	    DECREF(result);
+	    Py_DECREF(result);
 	    return NULL;
 	  }
 	}
@@ -1833,39 +1832,39 @@
       /* initWrapper = (TableWrapper *) initlist; already done... */
       valid = Taugment( &(result->rep), &(initWrapper->rep) );
       if (valid!=0) {
-	DECREF(result);
+	Py_DECREF(result);
 	return NULL;
       }
     }
   }
-  return (object *) result;
+  return (PyObject *) result;
 }
 
 /* specialization for sets */
-static object * makekjSet(object *module, object *args)
+static PyObject * makekjSet(PyObject *module, PyObject *args)
 {
   return makeWrapper(module, args, SETFLAG);
 }
 
 /* specialization for graphs */
-static object * makekjGraph(object *module, object *args)
+static PyObject * makekjGraph(PyObject *module, PyObject *args)
 {
   return makeWrapper(module, args, GRAPHFLAG);
 }
 
 /* specialization for dicts */
-static object * makekjDict(object *module, object *args)
+static PyObject * makekjDict(PyObject *module, PyObject *args)
 {
   return makeWrapper(module, args, DICTFLAG);
 }
 
 #ifdef KJBDEBUG
-static object * Wdebug( object *m, object *a)
+static PyObject * Wdebug( PyObject *m, PyObject *a)
 {
    if (DebugLevel) { DebugLevel = 0; }
    else { DebugLevel = 1; }
-   INCREF(None);
-   return None;
+   Py_INCREF(Py_None);
+   return Py_None;
  }
 #endif
 
@@ -1873,7 +1872,7 @@
 {
   /* must properly decref references... */
   groupsDealloc( wp->rep.groups, wp->rep.flag, wp->rep.size );
-  DEL(wp);
+  PyMem_DEL(wp);
 }
 
 /* hash value: symmetrical on members, a symmetrical within pairs */
@@ -1898,7 +1897,7 @@
        to keep this of "fix" it.  Hmmm.  */
     if (  (flag != SETFLAG)   &&(tw.map != 0)) { 
       GETHASH(that,tw.map);
-      if (that == -1) { err_clear(); }
+      if (that == -1) { PyErr_Clear(); }
       this += (that*23); 
     }
     result ^= this;
@@ -1910,18 +1909,18 @@
   return result;
 }
 
-static object * WrapperItems1(TableWrapper *wp, object *args, 
+static PyObject * WrapperItems1(TableWrapper *wp, PyObject *args, 
 			      long dokey, long domap)
 {
-  object *resultlist, *membertuple;
+  PyObject *resultlist, *membertuple;
   TableWalker tw;
   long index, entries;
   Dprint(("WItems1\n"));
   
-  if (!getnoarg(args)) { return NULL; } /* error */
+  if (!PyArg_Parse(args, "")) { return NULL; } /* error */
   entries = wp->rep.entries;
   /* make a list for all entries */
-  resultlist = newlistobject( entries );
+  resultlist = PyList_New( entries );
   if (resultlist == NULL) { return NULL; } /* error */
   /* walk through the table */
   (void) InitAll(&tw, &(wp->rep));
@@ -1929,44 +1928,44 @@
   while (tw.valid == 1) {
     /* sanity check */
     if (index >= entries) {
-      DECREF(resultlist);
-      err_setstr(SystemError, "loop overflowing in WrapperItems");
+      Py_DECREF(resultlist);
+      PyErr_SetString(PyExc_SystemError, "loop overflowing in WrapperItems");
       return NULL; /* error */
     }
     /* get only the key, if requested */
     if ((dokey != 0) && (domap == 0)) {
-      XINCREF(tw.key);
-      setlistitem(resultlist, index, tw.key);
+      Py_XINCREF(tw.key);
+      PyList_SetItem(resultlist, index, tw.key);
     } else {
       /* get only the map, if requested */
       if ((domap != 0) && (dokey == 0)) {
-	XINCREF(tw.map);
-	setlistitem(resultlist, index, tw.map);
+	Py_XINCREF(tw.map);
+	PyList_SetItem(resultlist, index, tw.map);
       } else {
 	/* otherwise get both */
-	membertuple = newtupleobject(2);
+	membertuple = PyTuple_New(2);
 	if (membertuple == NULL) {
-	  DECREF(resultlist);
+	  Py_DECREF(resultlist);
 	  return NULL;   /* error */
 	}
-	XINCREF(tw.key);
-	settupleitem(membertuple, 0, tw.key);
-	XINCREF(tw.map);
-	settupleitem(membertuple, 1, tw.map);
-	setlistitem(resultlist, index, membertuple);
+	Py_XINCREF(tw.key);
+	PyTuple_SetItem(membertuple, 0, tw.key);
+	Py_XINCREF(tw.map);
+	PyTuple_SetItem(membertuple, 1, tw.map);
+	PyList_SetItem(resultlist, index, membertuple);
       }
     }
     index++;
     (void) NextAll(&tw);
   }
   if (tw.valid == -1) {
-    DECREF(resultlist);
+    Py_DECREF(resultlist);
     return NULL; /* error */
   }
   return resultlist;
 }
 
-static object * WrapperItems(TableWrapper *wp, object *args)
+static PyObject * WrapperItems(TableWrapper *wp, PyObject *args)
 {
   Dprint(("WItems\n"));
   if (wp->rep.flag == SETFLAG) {
@@ -1981,7 +1980,7 @@
 /* prlong function with debug option */
 static long WrapperPrint(TableWrapper *wp, FILE *fp, long flags)
 {
-  object * items;
+  PyObject * items;
 #ifdef WDEBUGPRINT
   if (WDEBUGPRINT) {
     return TableDump((wp->rep), fp);
@@ -2002,15 +2001,15 @@
     fprintf(fp, "??couldn't allocate items??\n");
     return -1;
   }
-  if (printobject(items, fp, 0) != 0) { return -1; }
-  DECREF(items);
+  if (PyObject_Print(items, fp, 0) != 0) { return -1; }
+  Py_DECREF(items);
   fprintf(fp, ")");
   return 0;
 }
 
-static object* WrapperRepr(TableWrapper *wp)
+static PyObject* WrapperRepr(TableWrapper *wp)
 {
-  object *items, *result, *itemstring;
+  PyObject *items, *result, *itemstring;
   char buf[256];
   switch (wp->rep.flag) {
   case SETFLAG:
@@ -2020,18 +2019,18 @@
   case GRAPHFLAG:
     sprintf(buf, "kjGraph("); break;
   default:
-    err_setstr(SystemError, "Bad flag in table");
+    PyErr_SetString(PyExc_SystemError, "Bad flag in table");
     return NULL;
   }
-  result = newstringobject(buf);
+  result = PyString_FromString(buf);
   items = WrapperItems(wp, NULL);
   if (items == NULL) {
     return NULL;
   }
-  itemstring = reprobject(items);
-  DECREF(items);
-  joinstring_decref(&result, itemstring);
-  joinstring_decref(&result, newstringobject(")"));
+  itemstring = PyObject_Repr(items);
+  Py_DECREF(items);
+  PyString_ConcatAndDel(&result, itemstring);
+  PyString_ConcatAndDel(&result, PyString_FromString(")"));
   return result;
 }
 
@@ -2053,7 +2052,7 @@
    */
 static long Wcompare(TableWrapper *left, TableWrapper *right)
 {
-  object *lmem, *lmap, *rmem, *rmap;
+  PyObject *lmem, *lmap, *rmem, *rmap;
   long lhash, rhash;
   long lentries, rentries, lfound, rfound, cmp;
   Table *ltable, *rtable;
@@ -2078,54 +2077,54 @@
   if ((lfound == 0) && (rfound == 0)) { return 0; }
   /* otherwise compare min differences */
   cmp = lhash - rhash;
-  if (cmp == 0) { cmp = cmpobject( lmem, rmem ); }
+  if (cmp == 0) { cmp = PyObject_Compare( lmem, rmem ); }
   if (cmp < 0) { return -1; }
   if (cmp > 0) { return 1; }
   /* mems are identical, try maps */
   if ( (lmap != 0) && (rmap != 0) ) {
     /* if we get this far the following shouldn't return 0, ever. */
-    return cmpobject(lmap,rmap);
+    return PyObject_Compare(lmap,rmap);
   }
   /* this should be an error, but it can't be done?? */
   return 0;
 }
 
 
-static object * Whas_key(TableWrapper *wp, object *args)
+static PyObject * Whas_key(TableWrapper *wp, PyObject *args)
 {
   long test, rt, nxt, nxtb, isnew;
   long hashout;
   Bucketptr Bp;
-  object *key;
+  PyObject *key;
   Dprint(("Whas_key\n"));
-  if ((args == NULL) || !getargs(args, "O", &key)) { 
-    err_setstr(TypeError, "table method has_key requires an argument");
+  if ((args == NULL) || !PyArg_Parse(args, "O", &key)) { 
+    PyErr_SetString(PyExc_TypeError, "table method has_key requires an argument");
     return NULL; 
   }
   test = tableMatch(&(wp->rep), key, 0, NOFORCE,
 		    -1, -1, -1, NOHASH,
 		    &rt, &nxt, &nxtb, &Bp, &hashout, &isnew);
   if (test == -1) { return NULL; } /* error */
-  return newintobject((long) test);
+  return PyInt_FromLong((long) test);
 }
 
 /*
   Get the neighbors of a node in a graph.
   */
-static object *Gneighbors(TableWrapper *wp, object *args)
+static PyObject *Gneighbors(TableWrapper *wp, PyObject *args)
 {
-  object *key, *resultlist;
+  PyObject *key, *resultlist;
   Table *tp; 
   TableWalker tw;
   long count, index;
   Dprint(("Gneighbors\n"));
-  if ((args == NULL) || !getargs(args, "O", &key)) { 
-    err_setstr(TypeError, "table method neighbors requires an argument");
+  if ((args == NULL) || !PyArg_Parse(args, "O", &key)) { 
+    PyErr_SetString(PyExc_TypeError, "table method neighbors requires an argument");
     return NULL; 
   }
   tp = &(wp->rep);
   if ( tp->flag == SETFLAG ) {
-    err_setstr(TypeError, "neighbors not defined for table of this type");
+    PyErr_SetString(PyExc_TypeError, "neighbors not defined for table of this type");
     return NULL;
   }
   /* find out how many neighbors there are */
@@ -2139,7 +2138,7 @@
   if (tw.valid == -1) { return NULL; } /* error */
   /* make a list large enough */
   Dprint(("Gneighbors: making resultlist\n"));
-  resultlist = newlistobject( count );
+  resultlist = PyList_New( count );
   if (resultlist == NULL) { return NULL; } /* failure to allocate */
   /* record neighbors in list */
   (void) Initbykey(&tw, tp, key, NOHASH);
@@ -2147,17 +2146,17 @@
   Dprint(("Gneighbors: storing results\n"));
   while (tw.valid == 1) {
     if (index >= count) {
-      DECREF(resultlist);
-      err_setstr(SystemError, "loop overflow in neighbors calculation");
+      Py_DECREF(resultlist);
+      PyErr_SetString(PyExc_SystemError, "loop overflow in neighbors calculation");
       return NULL;
     }
-    XINCREF(tw.map);
-    setlistitem(resultlist, index, tw.map);
+    Py_XINCREF(tw.map);
+    PyList_SetItem(resultlist, index, tw.map);
     index++;
     (void) Nextbykey(&tw);
   }
   if (tw.valid == -1) {
-    DECREF(resultlist);
+    Py_DECREF(resultlist);
     return NULL;
   }
   return resultlist;
@@ -2167,18 +2166,18 @@
    if domaps is set this will get maps uniquely *only if
    all maps are hashable!* 
    */
-static object *Wparts(TableWrapper *wp, object *args, long domaps)
+static PyObject *Wparts(TableWrapper *wp, PyObject *args, long domaps)
 {
   TableWalker tw;
   Table *tp, *Settp;
   TableWrapper *tempSet;
-  object *mem, *map, *items;
+  PyObject *mem, *map, *items;
   long test;
   Dprint(("Wparts\n"));
-  if (!getnoarg(args)) { return NULL; } /* error */
+  if (!PyArg_Parse(args, "")) { return NULL; } /* error */
   tp = &(wp->rep);
   if (tp->flag == SETFLAG) {
-    err_setstr(TypeError, "keys/values not defined for sets");
+    PyErr_SetString(PyExc_TypeError, "keys/values not defined for sets");
     return NULL;
   }
   /* initialize a temp set to hold the keys */
@@ -2198,21 +2197,21 @@
     (void) NextAll(&tw);
   }
   if ((test == -1) || (tw.valid == -1)) {
-    XDECREF(tempSet);
+    Py_XDECREF(tempSet);
     return NULL;
   }
   items = WrapperItems(tempSet, NULL);
-  XDECREF(tempSet);
+  Py_XDECREF(tempSet);
   return items;
 }
 
-static object *Wkeys(TableWrapper *wp, object *args)
+static PyObject *Wkeys(TableWrapper *wp, PyObject *args)
 {
   Dprint(("Wkeys\n"));
   return Wparts(wp, args, 0);
 }
 
-static object *Wvalues(TableWrapper *wp, object *args)
+static PyObject *Wvalues(TableWrapper *wp, PyObject *args)
 {
   Dprint(("Wvalues\n"));
   /*  return Wparts(wp, args, 1); -- wrong! */
@@ -2220,25 +2219,25 @@
 }
 
 /* choose an arbitrary key from the table or raise an indexerror if none */
-static object *Wchoose_key(TableWrapper *wp, object *args)
+static PyObject *Wchoose_key(TableWrapper *wp, PyObject *args)
 {
   TableWalker tw;
   Dprint(("Wchoose_key\n"));
-  if (!getnoarg(args)) { return NULL; } /* error */
+  if (!PyArg_Parse(args, "")) { return NULL; } /* error */
   (void) InitAll(&tw, &(wp->rep));
   if (tw.valid == 1) {
-    XINCREF(tw.key);
+    Py_XINCREF(tw.key);
     return tw.key;
   }
   if (tw.valid == 0) {
-    err_setstr(IndexError, "table is empty");
+    PyErr_SetString(PyExc_IndexError, "table is empty");
     return NULL;
   }
   /* external error otherwise (tw.valid == -1) */
   return NULL;
 }
 
-static object *WSubset(TableWrapper *subset, object *args)
+static PyObject *WSubset(TableWrapper *subset, PyObject *args)
 {
   TableWrapper *superset;
   long hashout;
@@ -2249,12 +2248,12 @@
   Dprint(("WSubset\n"));
   /* verify argument */
   if (args == NULL) {
-    err_setstr(TypeError, "Subset test requires argument");
+    PyErr_SetString(PyExc_TypeError, "Subset test requires argument");
     return NULL;
   }
-  if (!getargs(args, "O", &superset)) { return NULL; }
+  if (!PyArg_Parse(args, "O", &superset)) { return NULL; }
   if ( !is_kjTable(superset)) {
-    err_setstr(TypeError, "Subset defined only between kj-tables");
+    PyErr_SetString(PyExc_TypeError, "Subset defined only between kj-tables");
     return NULL;
   }
   /* walk through subset, test for membership of all members */
@@ -2267,18 +2266,18 @@
     if (found == -1) { return NULL; } /* error */
     if (found == 0) {
       /* subset test fails */
-      return newintobject((long) 0);
+      return PyInt_FromLong((long) 0);
     }
     (void) NextAll(&tw);
   }
   if (tw.valid == -1) { return NULL; } /* error */
   /* otherwise, success */
-  return newintobject((long) 1);
+  return PyInt_FromLong((long) 1);
 }
 
 /* transitive closure of a graph */
 /* algorithm could be made faster, KISS for now. */
-static object *Wtransclose(TableWrapper *wp, object *args)
+static PyObject *Wtransclose(TableWrapper *wp, PyObject *args)
 {
   Table *source, *target, Delta;
   TableWrapper *closure;
@@ -2286,11 +2285,11 @@
   long count, test, abort;
   
   Dprint(("Wtransclose\n"));
-  if (!getnoarg(args)) { return NULL; } /* error */
+  if (!PyArg_Parse(args, "")) { return NULL; } /* error */
   source = &(wp->rep);
   flag = source->flag;
   if (flag != GRAPHFLAG) {
-    err_setstr(TypeError, 
+    PyErr_SetString(PyExc_TypeError, 
 	       "transitive closure not defined for this table type");
     return NULL;
   }
@@ -2303,7 +2302,7 @@
   Dprint(("tc: augmenting closure\n"));
   test = Taugment( target, source );
   if (test != 0) {
-    DECREF(closure);
+    Py_DECREF(closure);
     return NULL;
   }
   /* initialize temp table Delta for transitive arcs */
@@ -2330,27 +2329,27 @@
   Dprint(("tc: deallocating Delta\n"));
   groupsDealloc(Delta.groups, flag, Delta.size);
   if (abort != 0) {
-    DECREF(closure);
+    Py_DECREF(closure);
     return NULL;
   }
-  return (object *) closure;
+  return (PyObject *) closure;
 }
 
 static void Wset_hash_error()
 {
-  err_setstr(TypeError, "table has been hashed, it is now immutable");
+  PyErr_SetString(PyExc_TypeError, "table has been hashed, it is now immutable");
 }
 
-static object * Wdelete_arc(TableWrapper *wp, object *args)
+static PyObject * Wdelete_arc(TableWrapper *wp, PyObject *args)
 {
-  object *key, *map;
+  PyObject *key, *map;
   Dprint(("Wdelete_arc\n"));
-  if ((args == NULL) || !getargs(args, "(OO)", &key, &map)) {
-    err_setstr(TypeError, "delete_arc requires two arguments");
+  if ((args == NULL) || !PyArg_Parse(args, "(OO)", &key, &map)) {
+    PyErr_SetString(PyExc_TypeError, "delete_arc requires two arguments");
     return NULL;
   }
   if (wp->rep.flag == SETFLAG) {
-    err_setstr(TypeError, "delete_arc not defined on sets");
+    PyErr_SetString(PyExc_TypeError, "delete_arc not defined on sets");
     return NULL;
   }
   if (wp->hashvalue != NOHASH) {
@@ -2358,14 +2357,14 @@
     return NULL;
   }
   if (deleteFromTable(&(wp->rep), key, map) == 0) { return NULL; }
-  INCREF(None);
-  return None;
+  Py_INCREF(Py_None);
+  return Py_None;
 }
 
 /* simple membership test */
-static object * Wmember1(TableWrapper *wp, object *args, long insert)
+static PyObject * Wmember1(TableWrapper *wp, PyObject *args, long insert)
 {
-  object *key, *map;
+  PyObject *key, *map;
   Table *tp;
   enum BucketFlag flag;
   long hashout;
@@ -2376,7 +2375,7 @@
   flag = tp->flag;
   /* determine key and map */
   if (args == NULL) {
-    err_setstr(TypeError, "membership test requires argument(s)");
+    PyErr_SetString(PyExc_TypeError, "membership test requires argument(s)");
     return NULL;
   }
   if ((insert!=0) & (wp->hashvalue!=NOHASH)) {
@@ -2384,48 +2383,48 @@
     return NULL;
   }
   if (flag == SETFLAG) {
-    if (!getargs(args, "O", &key)) { return NULL; }
+    if (!PyArg_Parse(args, "O", &key)) { return NULL; }
     map = 0;
   } else {
-    if (!getargs(args, "(OO)", &key, &map)) { return NULL; }
+    if (!PyArg_Parse(args, "(OO)", &key, &map)) { return NULL; }
   }
   if (insert == 0) {
     found = tableMatch(tp, key, map, NOFORCE,
 		       -1, -1, -1, NOHASH,
 		       &rt, &nxt, &nxtb, &Bp, &hashout, &isnew);
-    return newintobject((long) found);
+    return PyInt_FromLong((long) found);
   } else {
     found = TableGet1(tp, key, map, NOHASH, FORCE, &key, &map);
     if (found == -1) { return NULL; }
-    INCREF(None);
-    return None;
+    Py_INCREF(Py_None);
+    return Py_None;
   }
 }
 
-static object * Wmember(TableWrapper *wp, object *args)
+static PyObject * Wmember(TableWrapper *wp, PyObject *args)
 {
   Dprint(("Wmember\n"));
   return Wmember1(wp, args, 0);
 }
 
-static object * Waddmember(TableWrapper *wp, object *args)
+static PyObject * Waddmember(TableWrapper *wp, PyObject *args)
 {
   Dprint(("Waddmember\n"));
   return Wmember1(wp, args, 1);
 }
 
 /* generate identity graph from a set */
-static object * Gidentity(TableWrapper *SourceSet, object *args)
+static PyObject * Gidentity(TableWrapper *SourceSet, PyObject *args)
 {
   TableWrapper *resultGraph;
   Table *Graphtp;
   TableWalker tw;
   long test;
-  object *d1, *d2;
+  PyObject *d1, *d2;
   Dprint(("Gidentity\n"));
-  if (!getnoarg(args)) { return NULL; }
+  if (!PyArg_Parse(args, "")) { return NULL; }
   if (SourceSet->rep.flag != SETFLAG) {
-    err_setstr(TypeError, "graph identity not defined for table of this type");
+    PyErr_SetString(PyExc_TypeError, "graph identity not defined for table of this type");
     return NULL;
   }
   /* make a new DICTIONARY for result, may waste space for graphs */
@@ -2441,26 +2440,26 @@
     (void) NextAll(&tw);
   }
   if ((test == -1) || (tw.valid == -1)) {
-    DECREF(resultGraph);
+    Py_DECREF(resultGraph);
     return NULL;
   }
-  return (object *) resultGraph;
+  return (PyObject *) resultGraph;
 }
 
-static object * Greachable(TableWrapper *graph, object *args)
+static PyObject * Greachable(TableWrapper *graph, PyObject *args)
 {
-  object *key, *d1, *d2;
+  PyObject *key, *d1, *d2;
   TableWrapper *resultSet, *tempSet, *deltaSet;
   Table *resulttp, *temptp, *deltatp, *graphtp;
   TableWalker deltaW, graphW;
   long test, fail;
   Dprint(("Greachable\n"));
   if (graph->rep.flag == SETFLAG) {
-    err_setstr(TypeError, "reachable not defined for this table type");
+    PyErr_SetString(PyExc_TypeError, "reachable not defined for this table type");
     return NULL;
   }
-  if ((args == NULL) || (!getargs(args, "O", &key))) {
-    err_setstr(TypeError, "reachable requires key argument");
+  if ((args == NULL) || (!PyArg_Parse(args, "O", &key))) {
+    PyErr_SetString(PyExc_TypeError, "reachable requires key argument");
     return NULL;
   }
   /* make result and temporary sets for computation */
@@ -2468,9 +2467,9 @@
   tempSet = (TableWrapper *) newWrapper(0, SETFLAG);
   deltaSet = (TableWrapper *) newWrapper(0, SETFLAG);
   if ((deltaSet == NULL) || (resultSet == NULL) || (tempSet == NULL)) { 
-    XDECREF(deltaSet);
-    XDECREF(resultSet);
-    XDECREF(tempSet);
+    Py_XDECREF(deltaSet);
+    Py_XDECREF(resultSet);
+    Py_XDECREF(tempSet);
     return NULL; 
   }
   propagateDirt(graph, resultSet);
@@ -2513,48 +2512,48 @@
     }
   } /* endwhile delta has entries... */
   /* get rid of temporaries */
-  DECREF(tempSet);
-  DECREF(deltaSet);
+  Py_DECREF(tempSet);
+  Py_DECREF(deltaSet);
   if (fail != 0) {
-    DECREF(resultSet);
+    Py_DECREF(resultSet);
     return NULL;
   }
-  return (object *) resultSet;
+  return (PyObject *) resultSet;
 }
 
 /* Clean filter: returns argument if the table
    is clean, otherwise NULL */
-static object * WClean(TableWrapper *wp, object *args)
+static PyObject * WClean(TableWrapper *wp, PyObject *args)
 {
   Dprint(("WClean\n"));
-  if (!getnoarg(args)) { return NULL; }
+  if (!PyArg_Parse(args, "")) { return NULL; }
   if (wp->rep.Dirty) {
-    INCREF(None);
-    return None;
+    Py_INCREF(Py_None);
+    return Py_None;
   } else {
-    INCREF(wp);
-    return (object *) wp;
+    Py_INCREF(wp);
+    return (PyObject *) wp;
   }
 }
 
 /* force a table to be dirty */
-static object * WSoil(TableWrapper *wp, object *args)
+static PyObject * WSoil(TableWrapper *wp, PyObject *args)
 {
   Dprint(("WSoil\n"));
-  if (!getnoarg(args)) { return NULL; }
+  if (!PyArg_Parse(args, "")) { return NULL; }
   wp->rep.Dirty = 1;
-  INCREF(None);
-  return None;
+  Py_INCREF(Py_None);
+  return Py_None;
 }
 
 /* force a table to be clean */
-static object * WWash(TableWrapper *wp, object *args)
+static PyObject * WWash(TableWrapper *wp, PyObject *args)
 {
   Dprint(("WWash\n"));
-  if (!getnoarg(args)) { return NULL; }
+  if (!PyArg_Parse(args, "")) { return NULL; }
   wp->rep.Dirty = 0;
-  INCREF(None);
-  return None;
+  Py_INCREF(Py_None);
+  return Py_None;
 }
 
 /* remap remaps a dictionary using a table which represents
@@ -2563,22 +2562,22 @@
    If the result is "dirty" (ie, if name/value collisions)
    None is returned.
 */
-static object * Dremap(TableWrapper *wp, object *args)
+static PyObject * Dremap(TableWrapper *wp, PyObject *args)
 {
   TableWrapper *remapper, *result;
   long count;
   Dprint(("Dremap\n"));
   if (!is_kjDictobject(wp)) {
-    err_setstr(TypeError, "remap only defined for kjDicts");
+    PyErr_SetString(PyExc_TypeError, "remap only defined for kjDicts");
     return NULL;
   }
   if (args == NULL) {
-    err_setstr(TypeError, "remap requires equality table argument");
+    PyErr_SetString(PyExc_TypeError, "remap requires equality table argument");
     return NULL;
   }
-  if (!getargs(args, "O", &remapper)) { return NULL; }
+  if (!PyArg_Parse(args, "O", &remapper)) { return NULL; }
   if ( !is_kjTable(remapper)) {
-    err_setstr(TypeError, "remap defined only between kj-tables");
+    PyErr_SetString(PyExc_TypeError, "remap defined only between kj-tables");
     return NULL;
   }
   /* don't assume anything about size of result */
@@ -2588,75 +2587,75 @@
   propagateDirt(remapper, result);
   /* return NONE if result is dirty (save some work) */
   if (result->rep.Dirty != 0) {
-    DECREF(result);
-    INCREF(None);
-    return None;
+    Py_DECREF(result);
+    Py_INCREF(Py_None);
+    return Py_None;
   }
   count = Tcompose( &(result->rep), &(remapper->rep), &(wp->rep), 0, 0);
   if (count<0) {
-    DECREF(result);
+    Py_DECREF(result);
     return NULL; /* error */
   }
   /* return NONE if result is dirty after composition */
   if (result->rep.Dirty != 0) {
-    DECREF(result);
-    INCREF(None);
-    return None;
+    Py_DECREF(result);
+    Py_INCREF(Py_None);
+    return Py_None;
   }
-  return (object *) result;
+  return (PyObject *) result;
 }
 
 /* forward declarations needed below */
-static object * kjDict_subscript(TableWrapper *Set, object *key);
-static long kjDict_ass_subscript(object *Set, object *key, object *thing);
+static PyObject * kjDict_subscript(TableWrapper *Set, PyObject *key);
+static long kjDict_ass_subscript(PyObject *Set, PyObject *key, PyObject *thing);
 
 /* for dumping a dictionary to a tuple */
 /* D.dump(tup) produces D[tup[0]] if tup of len 1
       or (D[tup[0]], D[tup[1]],...) if tup of len > 1
       or keyerror if keys aren't present.
 */
-static object * kjDictDump(TableWrapper *wp, object *args)
+static PyObject * kjDictDump(TableWrapper *wp, PyObject *args)
 {
-  object *result, *input, *key, *map;
+  PyObject *result, *input, *key, *map;
   long valid, index, length;
   Dprint(("kjDictDump\n"));
   if (!is_kjDictobject(wp) && !is_kjGraphobject(wp)) {
-    err_setstr(TypeError, "dump only defined for kjDicts");
+    PyErr_SetString(PyExc_TypeError, "dump only defined for kjDicts");
     return NULL;
   }
   if (args == NULL) {
-    err_setstr(TypeError, "dictionary dump requires tuple argument");
+    PyErr_SetString(PyExc_TypeError, "dictionary dump requires tuple argument");
     return NULL;
   }
-  valid = getargs(args, "O", &input);
-  if (valid && (is_tupleobject(input))) {
-    length = gettuplesize(input);
+  valid = PyArg_Parse(args, "O", &input);
+  if (valid && (PyTuple_Check(input))) {
+    length = PyTuple_Size(input);
     if (length < 1) {
-      err_setstr(TypeError, "dictionary dump requires nonempty tuple arg");
+      PyErr_SetString(PyExc_TypeError, "dictionary dump requires nonempty tuple arg");
       return NULL;
     }
     if (length == 1) {
       /* return D[input[0]] */
-      key = gettupleitem(input, 0);
+      key = PyTuple_GetItem(input, 0);
       return kjDict_subscript(wp, key); /* incref done by function */
     } else {
       /* return ( D[input[0]], D[input[1]], ..., D[input[n]] ) */
-      result = newtupleobject(length);
+      result = PyTuple_New(length);
       if (result == NULL) { return NULL; } /* failure to allocate */
       for (index = 0; index<length; index++) {
-	key = gettupleitem(input, index);
+	key = PyTuple_GetItem(input, index);
 	map = kjDict_subscript(wp, key); /* incref done by function */
 	if (map == NULL) { 
-	  DECREF(result);
+	  Py_DECREF(result);
 	  return NULL;  /* keyerror, normally */
 	}
         /* map was increfed by kjDict_subscript already */
-	settupleitem(result, index, map);
+	PyTuple_SetItem(result, index, map);
       }
       return result;
     }
   } else {
-    err_setstr(TypeError, "dictionary dump arg must be tuple");
+    PyErr_SetString(PyExc_TypeError, "dictionary dump arg must be tuple");
     return NULL;
   }
 }
@@ -2667,24 +2666,24 @@
        kjDict( [ (tup[0], thing[0]), (tup[1], thing[1]) ] )
      if tup of len>1 and thing of same len, or error
 */  
-static object * kjUndumpToDict(object *self, object *args)
+static PyObject * kjUndumpToDict(PyObject *self, PyObject *args)
 {
   TableWrapper *result;
-  object *tup, *thing, *key, *map;
+  PyObject *tup, *thing, *key, *map;
   long valid, index, length;
   Dprint(("kjUndump\n"));
   if (args == NULL) {
-    err_setstr(TypeError, "kjUndump called with no args");
+    PyErr_SetString(PyExc_TypeError, "kjUndump called with no args");
     return NULL;
   }
-  valid = getargs(args, "(OO)", &tup, &thing);
+  valid = PyArg_Parse(args, "(OO)", &tup, &thing);
   if (valid) {
-    valid = is_tupleobject(tup);
+    valid = PyTuple_Check(tup);
   }
   if (valid) {
-    length = gettuplesize(tup);
+    length = PyTuple_Size(tup);
     if (length<1) {
-      err_setstr(ValueError, "kjUndump: tuple must be non-empty");
+      PyErr_SetString(PyExc_ValueError, "kjUndump: tuple must be non-empty");
       return NULL;
     }
     /* try to save a little space */
@@ -2692,39 +2691,39 @@
     if (result == NULL) { return NULL; } /* allocation failure */
     if (length == 1) {
       /* return D[tup[0]] = thing */
-      key = gettupleitem(tup, 0);
-      valid = kjDict_ass_subscript((object *) result, key, thing);
+      key = PyTuple_GetItem(tup, 0);
+      valid = kjDict_ass_subscript((PyObject *) result, key, thing);
       if (valid == -1) {
-	DECREF(result);
+	Py_DECREF(result);
 	return NULL;
       }
-      return (object *) result;
+      return (PyObject *) result;
     } else {
       /* return for i in len(tup): 
                   D[tup[i]] = thing[i]
       */
-      if (is_tupleobject(thing)) {
-	if (gettuplesize(thing) != length) {
-	  err_setstr(TypeError,"kjUndump -- tuple lengths don't match");
+      if (PyTuple_Check(thing)) {
+	if (PyTuple_Size(thing) != length) {
+	  PyErr_SetString(PyExc_TypeError,"kjUndump -- tuple lengths don't match");
 	  return NULL;
 	}
 	for (index = 0; index<length; index++) {
-	  key = gettupleitem(tup, index);
-	  map = gettupleitem(thing, index);
-	  valid = kjDict_ass_subscript((object *) result, key, map);
+	  key = PyTuple_GetItem(tup, index);
+	  map = PyTuple_GetItem(thing, index);
+	  valid = kjDict_ass_subscript((PyObject *) result, key, map);
 	  if (valid == -1){
-	    DECREF(result);
+	    Py_DECREF(result);
 	    return NULL;
 	  }
 	}
-	return (object *) result;
+	return (PyObject *) result;
       } else {
-	err_setstr(TypeError,"kjUndump -- nonunary tuple with non-tuple");
+	PyErr_SetString(PyExc_TypeError,"kjUndump -- nonunary tuple with non-tuple");
 	return NULL;
       }
     }
   } else {
-    err_setstr(TypeError,"kjUndump requires 2 args, first must be tuple");
+    PyErr_SetString(PyExc_TypeError,"kjUndump requires 2 args, first must be tuple");
     return NULL;
   }
 }
@@ -2737,21 +2736,21 @@
 
    but faster, doesn't allocate unneeded set
 */
-static object * kjWRestrict(TableWrapper *wp, object *args)
+static PyObject * kjWRestrict(TableWrapper *wp, PyObject *args)
 {
   long test;
   TableWrapper *result, *compare;
-  object *d1, *d2; /* dummies */
+  PyObject *d1, *d2; /* dummies */
   enum BucketFlag flag;
   TableWalker compareWalker, wpWalker;
   Table *tp, *resulttp, *comparetp;
-  if ((args == NULL) || (!getargs(args, "O", &compare))) {
-    err_setstr(TypeError, 
+  if ((args == NULL) || (!PyArg_Parse(args, "O", &compare))) {
+    PyErr_SetString(PyExc_TypeError, 
                "restriction function requires one kjTable argument");
     return NULL;
   }
   if (!is_kjTable(compare)) {
-    err_setstr(TypeError, "restrict function requires kjTable argument");
+    PyErr_SetString(PyExc_TypeError, "restrict function requires kjTable argument");
     return NULL;
   }
   flag = wp->rep.flag;
@@ -2807,11 +2806,11 @@
   }
   /* test for error cases */
   if (test == -1) {
-    XDECREF(result);
+    Py_XDECREF(result);
     return NULL;
   }
   /* otherwise just return result */
-  return (object *) result;
+  return (PyObject *) result;
 }
 
 /* special function for retrieving from dict-dumped indices
@@ -2831,7 +2830,7 @@
     (may retrieve "too many neighbors" for key of None or (None,)
 
 defined benieth following utility function as
-  static object * kjWdget(TableWrapper *wp, object *args)
+  static PyObject * kjWdget(TableWrapper *wp, PyObject *args)
 
 */
 
@@ -2839,27 +2838,27 @@
    return 1 if neighbors set is nonempty, else, 0
 */
 /* #ifndef PYTHON1DOT2 */
-static object * kjWdget1(TableWrapper *wp, object *args, long testonly)
+static PyObject * kjWdget1(TableWrapper *wp, PyObject *args, long testonly)
 {
-  object *d, *dumper, *result, *err_type /*, *err_value */;
+  PyObject *d, *dumper, *result, *err_type /*, *err_value */;
   TableWrapper *dict;
   /* get and verify args */
   if (args == NULL) {
-    err_setstr(TypeError, "dget requires 2 arguments");
+    PyErr_SetString(PyExc_TypeError, "dget requires 2 arguments");
     return NULL;
   }
-  if (!getargs(args, "(OO)", &dict, &dumper)) {
-    err_setstr(TypeError,
+  if (!PyArg_Parse(args, "(OO)", &dict, &dumper)) {
+    PyErr_SetString(PyExc_TypeError,
 	       "dget requires dict, dumper");
     return NULL;
   }
   if (!((is_kjDictobject(dict)) || (is_kjGraphobject(dict)))) {
-    err_setstr(TypeError,
+    PyErr_SetString(PyExc_TypeError,
 	       "first arg of dget must be kjDict or kjGraph");
     return NULL;
   }
-  if (!is_tupleobject(dumper)) {
-    err_setstr(TypeError,
+  if (!PyTuple_Check(dumper)) {
+    PyErr_SetString(PyExc_TypeError,
 	       "second arg of dget must be tuple");
     return NULL;
   }
@@ -2869,16 +2868,16 @@
     /* unable to dump */
     /* check that error was a keyerror ??? */
     /* err_get(&err_type, &err_value); */
-    err_type = err_occurred();
-    if (err_type != KeyError) {
+    err_type = PyErr_Occurred();
+    if (err_type != PyExc_KeyError) {
       /* some other error... abort */
-      /* err_setval(err_type, err_value); */
+      /* PyErr_SetObject(err_type, err_value); */
       return NULL;
     }
-    err_clear();
-    /* in case of KeyError, just return None */
-    INCREF(None);
-    return None;
+    PyErr_Clear();
+    /* in case of PyExc_KeyError, just return None */
+    Py_INCREF(Py_None);
+    return Py_None;
   }
   /* if dump was successful, return neighbors */
   /* ??? should return d also ??? */
@@ -2887,7 +2886,7 @@
   } else {
     result = Whas_key(wp, d);
   }
-  XDECREF(d);
+  Py_XDECREF(d);
   return result;
 }
 /* #endif */
@@ -2903,13 +2902,13 @@
          except KeyError: return None
 */
 /* #ifndef PYTHON1DOT2 */
-static object * kjWdtest(TableWrapper *wp, object *args)
+static PyObject * kjWdtest(TableWrapper *wp, PyObject *args)
 {
   return kjWdget1(wp, args, 1); /* test only */
 }
 /* #endif
    #ifndef PYTHON1DOT2 */
-static object * kjWdget(TableWrapper *wp, object *args)
+static PyObject * kjWdget(TableWrapper *wp, PyObject *args)
 {
   return kjWdget1(wp, args, 0); /* don't test only */
 }
@@ -2918,67 +2917,67 @@
 /*
    miscellaneous methods for these types 
 */
-static struct methodlist Wrapper_methods[] = {
-        {"member",      (method)Wmember},
-        {"add",         (method)Waddmember},
-        {"delete_arc",  (method)Wdelete_arc},
-        {"has_key",     (method)Whas_key},
-	{"choose_key",  (method)Wchoose_key},
-        {"Clean",       (method)WClean},
-	{"neighbors",   (method)Gneighbors},
-	{"dump",        (method)kjDictDump},
+static struct PyMethodDef Wrapper_methods[] = {
+        {"member",      (PyCFunction)Wmember},
+        {"add",         (PyCFunction)Waddmember},
+        {"delete_arc",  (PyCFunction)Wdelete_arc},
+        {"has_key",     (PyCFunction)Whas_key},
+	{"choose_key",  (PyCFunction)Wchoose_key},
+        {"Clean",       (PyCFunction)WClean},
+	{"neighbors",   (PyCFunction)Gneighbors},
+	{"dump",        (PyCFunction)kjDictDump},
 /* #ifndef PYTHON1DOT2 */
-        {"dget",        (method)kjWdget},
-        {"dtest",       (method)kjWdtest},
+        {"dget",        (PyCFunction)kjWdget},
+        {"dtest",       (PyCFunction)kjWdtest},
 /* #endif */
-	{"reachable",   (method)Greachable},
-	{"subset",      (method)WSubset},
-        {"items",       (method)WrapperItems},
-        {"keys",        (method)Wkeys},
-        {"values",      (method)Wvalues},
-        {"ident",       (method)Gidentity},
-        {"remap",       (method)Dremap},
-	{"restrict",    (method)kjWRestrict},
-	{"tclosure",    (method)Wtransclose},
-	{"Soil",        (method)WSoil},
-	{"Wash",        (method)WWash},
+	{"reachable",   (PyCFunction)Greachable},
+	{"subset",      (PyCFunction)WSubset},
+        {"items",       (PyCFunction)WrapperItems},
+        {"keys",        (PyCFunction)Wkeys},
+        {"values",      (PyCFunction)Wvalues},
+        {"ident",       (PyCFunction)Gidentity},
+        {"remap",       (PyCFunction)Dremap},
+	{"restrict",    (PyCFunction)kjWRestrict},
+	{"tclosure",    (PyCFunction)Wtransclose},
+	{"Soil",        (PyCFunction)WSoil},
+	{"Wash",        (PyCFunction)WWash},
         {NULL,          NULL}           /* sentinel */
 };
 
 /* getattr snarfed from mappingobject.c */
-static object * Wrapper_getattr(object *mp, char *name)
+static PyObject * Wrapper_getattr(PyObject *mp, char *name)
 {
-  return findmethod(Wrapper_methods, (object *)mp, name);
+  return Py_FindMethod(Wrapper_methods, (PyObject *)mp, name);
 }
 
 
 /* methods for special behaviors as number and mapping */
 
 /* undefined operations */
-static object * undefbin(object *v, object *w)
+static PyObject * undefbin(PyObject *v, PyObject *w)
 {
-  err_setstr(TypeError, "op not valid for table of this type");
+  PyErr_SetString(PyExc_TypeError, "op not valid for table of this type");
   return NULL;
 }
-static object * undefter(object *v, object *w, object *z)
+static PyObject * undefter(PyObject *v, PyObject *w, PyObject *z)
 {
-  err_setstr(TypeError, "op not valid for table of this type");
+  PyErr_SetString(PyExc_TypeError, "op not valid for table of this type");
   return NULL;
 }
-static object * undefun(object *v)
+static PyObject * undefun(PyObject *v)
 {
-  err_setstr(TypeError, "op not valid for table of this type");
+  PyErr_SetString(PyExc_TypeError, "op not valid for table of this type");
   return NULL;
 }
 
 /* transpose of non 1:1 dict will have nondeterministic results */
-static object *Wtranspose(TableWrapper *source)
+static PyObject *Wtranspose(TableWrapper *source)
 {
   TableWrapper *result;
   long size, test;
   Dprint(("Wtranspose\n"));
   if (source->rep.flag == SETFLAG) {
-    err_setstr(TypeError, "Cannot transpose set");
+    PyErr_SetString(PyExc_TypeError, "Cannot transpose set");
     return NULL;
   }
   /* conservative estimate of size (may save space, maybe not) */
@@ -2989,22 +2988,22 @@
   propagateDirt(source, result);
   test = Ttranspose( &(result->rep), &(source->rep) );
   if (test!=0) {
-    DECREF(result);
+    Py_DECREF(result);
     return NULL;
   }
-  return (object *) result;
+  return (PyObject *) result;
 }
   
-static object *Wunion(TableWrapper *left, TableWrapper *right)
+static PyObject *Wunion(TableWrapper *left, TableWrapper *right)
 {
   enum BucketFlag flag;
   TableWrapper *result;
   long size, test;
   Dprint(("Wunion\n"));
   /* None unioned with anything returns None (universal set) */
-  if (((object *) left == None) || ((object *) right == None)) {
-    INCREF(None);
-    return None;
+  if (((PyObject *) left == Py_None) || ((PyObject *) right == Py_None)) {
+    Py_INCREF(Py_None);
+    return Py_None;
   }
   /* arbitrary size heuristic */
   if (left->rep.entries > right->rep.entries) 
@@ -3015,7 +3014,7 @@
   /* determine coercion if possible, default=more general */
   test = FlagCoercion(left->rep.flag, right->rep.flag, &flag, 1);
   if (test != 1) {
-    err_setstr(TypeError, "incompatible types for table union");
+    PyErr_SetString(PyExc_TypeError, "incompatible types for table union");
     return NULL;
   }
   /* allocate a wrapper and augment it with both inputs */
@@ -3028,14 +3027,14 @@
     test = Taugment( &(result->rep), &(right->rep) );
   }
   if (test!=0) {
-    DECREF(result);
+    Py_DECREF(result);
     return NULL;
   }
-  return (object *) result;
+  return (PyObject *) result;
 }
 
 /* utility function for intersection and difference */
-static object * Wintdiff(TableWrapper *left, TableWrapper *right,
+static PyObject * Wintdiff(TableWrapper *left, TableWrapper *right,
 			 long include, enum BucketFlag flagout)
 {
   TableWrapper *result;
@@ -3053,23 +3052,23 @@
   propagateDirt( right, result );
   count = Tintdiff(&(result->rep), &(left->rep), &(right->rep), include, 0);
   if (count < 0) {
-    DECREF(result);
+    Py_DECREF(result);
     return NULL;
   }
-  return (object *) result;
+  return (PyObject *) result;
 }
 
 /* intersection */
-static object * Wintersect(TableWrapper *left, TableWrapper *right)
+static PyObject * Wintersect(TableWrapper *left, TableWrapper *right)
 {
   long test;
   enum BucketFlag flag, lflag, rflag;
   Dprint(("Wintersect\n"));
   /* None intersected with anything returns copy of anything... */
-  if ((object *)left == None) {
+  if ((PyObject *)left == Py_None) {
      return Wunion(right, right);
   }
-  if ((object *)right == None) {
+  if ((PyObject *)right == Py_None) {
      return Wunion(left, left);
   }
   /* determine flag: default to less general */
@@ -3078,12 +3077,12 @@
   /* coerce to more general, unless one arg is a set,
      in which case coerce to set */
   if ( (rflag != lflag) && ((rflag == SETFLAG)||(lflag == SETFLAG)) ) {
-    err_setstr(TypeError, "mixed intersection not allowed with kjSet");
+    PyErr_SetString(PyExc_TypeError, "mixed intersection not allowed with kjSet");
     return NULL;
   }
   test = FlagCoercion(left->rep.flag, right->rep.flag, &flag, -1);
   if (test!=1) {
-    err_setstr(TypeError, "unable to coerce for intersection");
+    PyErr_SetString(PyExc_TypeError, "unable to coerce for intersection");
     return NULL;
   }
   /* iterate over the smaller argument */
@@ -3095,32 +3094,32 @@
 }
 
 /* difference */
-static object * Wdifference(TableWrapper *left, TableWrapper *right)
+static PyObject * Wdifference(TableWrapper *left, TableWrapper *right)
 {
   enum BucketFlag lflag, rflag;
   /* left cannot be None */
   Dprint(("Wdifference\n"));
-  if ((object *)left == None) {
-    err_setstr(TypeError, "cannot difference from None");
+  if ((PyObject *)left == Py_None) {
+    PyErr_SetString(PyExc_TypeError, "cannot difference from None");
     return NULL;
   }
   /* if right is None return empty */
-  if ((object *)right == None) {
-    return (object *) newWrapper(0, left->rep.flag);
+  if ((PyObject *)right == Py_None) {
+    return (PyObject *) newWrapper(0, left->rep.flag);
   }
   rflag = right->rep.flag;
   lflag = left->rep.flag;
    /* diff default coerce to whatever left is, unless one arg is a
       set, in which case raise an error */
   if ( (rflag != lflag) && ((rflag == SETFLAG)||(lflag == SETFLAG)) ) {
-    err_setstr(TypeError, "mixed difference not allowed with kjSet");
+    PyErr_SetString(PyExc_TypeError, "mixed difference not allowed with kjSet");
     return NULL;
   }
   return Wintdiff(left, right, 0, lflag);
 }
 
 /* composition of two tables */
-static object * Wcompose(TableWrapper *left, TableWrapper *right)
+static PyObject * Wcompose(TableWrapper *left, TableWrapper *right)
 {
   enum BucketFlag flag;
   TableWrapper *result;
@@ -3128,8 +3127,8 @@
   Table *Ltable, *Rtable;
   Dprint(("Wcompose\n"));
   /* neither arg may be None */
-  if (((object *)left == None) || ((object *)right == None)) {
-    err_setstr(TypeError, "cannot compose None");
+  if (((PyObject *)left == Py_None) || ((PyObject *)right == Py_None)) {
+    PyErr_SetString(PyExc_TypeError, "cannot compose None");
     return NULL;
   }
   Ltable = &(left->rep);
@@ -3137,7 +3136,7 @@
   /* find coercion, prefer more general */
   test = FlagCoercion(Ltable->flag, Rtable->flag, &flag, 1);
   if (test!=1) {
-    err_setstr(TypeError, "incompatible types for composition");
+    PyErr_SetString(PyExc_TypeError, "incompatible types for composition");
     return NULL;
   }
   /* DON'T determine required table size, (not easily done correctly) */
@@ -3154,10 +3153,10 @@
   propagateDirt( right, result );
   count = Tcompose(&(result->rep), Ltable, Rtable, 0, 0);
   if (count < 0) {
-    DECREF(result);
+    Py_DECREF(result);
     return NULL;  /* error */
   }
-  return (object *) result;
+  return (PyObject *) result;
 }
 
 /* coercion:
@@ -3165,16 +3164,16 @@
     all other logic is at the function level
   (None == universal set)
 */
-static long Wrapper_coerce(object **pv, object **pw)
+static long Wrapper_coerce(PyObject **pv, PyObject **pw)
 {
-  object *w;
+  PyObject *w;
   w = *pw;
   Dprint(("Wcoerce\n"));
-  if ( (w == None) || 
+  if ( (w == Py_None) || 
        is_kjTable(w) ) {
     /* both w and *pv are "returned", hence must be increfed */
-    INCREF(w);
-    INCREF(*pv);
+    Py_INCREF(w);
+    Py_INCREF(*pv);
     return 0; /* okay */
   }
   return 1; /* Nope! */
@@ -3183,7 +3182,7 @@
 
 
 /* the number methods structure for all kjSets, kjDicts, kjGraphs */
-static number_methods kjSet_as_number = {
+static PyNumberMethods kjSet_as_number = {
         (binaryfunc)Wunion,  /*nb_add*/
         (binaryfunc)Wdifference, /*nb_subtract*/
         (binaryfunc)Wcompose, /*nb_multiply*/
@@ -3209,19 +3208,19 @@
         (unaryfunc)undefun,             /*nb_hex*/
 };
 
-static object * kjSet_subscript(TableWrapper *Set, object *key)
+static PyObject * kjSet_subscript(TableWrapper *Set, PyObject *key)
 {
-  object *mem, *map;
+  PyObject *mem, *map;
   long test;
   Dprint(("kjSet_subscript\n"));
   test = TableGet1(&(Set->rep), key, 0, NOHASH, NOFORCE, &mem, &map);
   if (test == -1) { return NULL; } 
-  return newintobject((long) 1); 
+  return PyInt_FromLong((long) 1); 
 }
 
-static long kjSet_ass_subscript(object *Set, object *key, object *thing)
+static long kjSet_ass_subscript(PyObject *Set, PyObject *key, PyObject *thing)
 {
-  object *mem, *map;
+  PyObject *mem, *map;
   TableWrapper *S;
   Dprint(("kjSet_ass_subscript\n"));
   S = (TableWrapper *) Set;
@@ -3239,20 +3238,20 @@
   }
 }
 
-static object * kjDict_subscript(TableWrapper *Set, object *key)
+static PyObject * kjDict_subscript(TableWrapper *Set, PyObject *key)
 {
-  object *mem, *map;
+  PyObject *mem, *map;
   long test;
   Dprint(("kjDict_subscript\n"));
   test = TableGet1(&(Set->rep), key, 0, NOHASH, NOFORCE, &mem, &map);
   if (test == -1) { return NULL; } 
-  XINCREF(map);
+  Py_XINCREF(map);
   return map;
 }
 
-static long kjDict_ass_subscript(object *Set, object *key, object *thing)
+static long kjDict_ass_subscript(PyObject *Set, PyObject *key, PyObject *thing)
 {
-  object *mem, *map;
+  PyObject *mem, *map;
   TableWrapper *S;
   Dprint(("kjDict_ass_subscript\n"));
   S = (TableWrapper *) Set;
@@ -3276,7 +3275,7 @@
 }
 
 /* mapping methods for jkSets */
-static mapping_methods kjSet_as_mapping = {
+static PyMappingMethods kjSet_as_mapping = {
         (inquiry)Wrapper_length, /*mp_length*/
         (binaryfunc)kjSet_subscript, /*mp_subscript*/
         (objobjargproc)kjSet_ass_subscript, /*mp_ass_subscript*/
@@ -3284,15 +3283,15 @@
 
 
 /* mapping methods for kjDicts AND kjGraphs */
-static mapping_methods kjDict_as_mapping = {
+static PyMappingMethods kjDict_as_mapping = {
         (inquiry)Wrapper_length, /*mp_length*/
         (binaryfunc)kjDict_subscript, /*mp_subscript*/
         (objobjargproc)kjDict_ass_subscript, /*mp_ass_subscript*/
 };
 
 /* THE TYPE OBJECT FOR SETS */
-static typeobject kjSettype = {
-        OB_HEAD_INIT(&Typetype)
+static PyTypeObject kjSettype = {
+        PyObject_HEAD_INIT(&PyType_Type)
         0,
         (char *) "kjSet",               /*tp_name for printing */
         (unsigned int) sizeof(TableWrapper),   /*tp_basicsize */
@@ -3303,16 +3302,16 @@
         (setattrfunc)NULL,                        /*tp_setattr*/
         (cmpfunc)Wcompare,               /*tp_compare*/
         (reprfunc)WrapperRepr,                  /*tp_repr*/
-        (number_methods *)&kjSet_as_number,    /*tp_as_number*/
-        (sequence_methods *)NULL,                 /*tp_as_sequence*/
-        (mapping_methods *)&kjSet_as_mapping,  /*tp_as_mapping*/
+        (PyNumberMethods *)&kjSet_as_number,    /*tp_as_number*/
+        (PySequenceMethods *)NULL,                 /*tp_as_sequence*/
+        (PyMappingMethods *)&kjSet_as_mapping,  /*tp_as_mapping*/
         (hashfunc)Wrapper_hash,                 /*tp_hash*/
-        (binaryfunc)NULL,                         /*tp_call*/
+        (ternaryfunc)NULL,                         /*tp_call*/
 };
 
 /* THE TYPE OBJECT FOR DICTS */
-static typeobject kjDicttype = {
-        OB_HEAD_INIT(&Typetype)
+static PyTypeObject kjDicttype = {
+        PyObject_HEAD_INIT(&PyType_Type)
         0,
         (char *) "kjDict",               /*tp_name for printing */
         (unsigned int) sizeof(TableWrapper),   /*tp_basicsize */
@@ -3323,16 +3322,16 @@
         (setattrfunc)0,                        /*tp_setattr*/
         (cmpfunc)Wcompare,               /*tp_compare*/
         (reprfunc)WrapperRepr,                  /*tp_repr*/
-        (number_methods *)&kjSet_as_number,    /*tp_as_number*/
-        (sequence_methods *)0,                 /*tp_as_sequence*/
-        (mapping_methods *)&kjDict_as_mapping,  /*tp_as_mapping*/
+        (PyNumberMethods *)&kjSet_as_number,    /*tp_as_number*/
+        (PySequenceMethods *)0,                 /*tp_as_sequence*/
+        (PyMappingMethods *)&kjDict_as_mapping,  /*tp_as_mapping*/
         (hashfunc)Wrapper_hash,                 /*tp_hash*/
-        (binaryfunc)0,                         /*tp_call*/
+        (ternaryfunc)0,                         /*tp_call*/
 };
 
 /* THE TYPE OBJECT FOR GRAPHSS */
-static typeobject kjGraphtype = {
-        OB_HEAD_INIT(&Typetype)
+static PyTypeObject kjGraphtype = {
+        PyObject_HEAD_INIT(&PyType_Type)
         0,
         (char *) "kjGraph",               /*tp_name for printing */
         (unsigned int) sizeof(TableWrapper),   /*tp_basicsize */
@@ -3343,11 +3342,11 @@
         (setattrfunc)0,                        /*tp_setattr*/
         (cmpfunc)Wcompare,               /*tp_compare*/
         (reprfunc)WrapperRepr,                  /*tp_repr*/
-        (number_methods *)&kjSet_as_number,    /*tp_as_number*/
-        (sequence_methods *)0,                 /*tp_as_sequence*/
-        (mapping_methods *)&kjDict_as_mapping,  /*tp_as_mapping*/
+        (PyNumberMethods *)&kjSet_as_number,    /*tp_as_number*/
+        (PySequenceMethods *)0,                 /*tp_as_sequence*/
+        (PyMappingMethods *)&kjDict_as_mapping,  /*tp_as_mapping*/
         (hashfunc)Wrapper_hash,                 /*tp_hash*/
-        (binaryfunc)0,                         /*tp_call*/
+        (ternaryfunc)0,                         /*tp_call*/
 };
 
 /* special method for adding to a "dumped index"
@@ -3376,39 +3375,39 @@
    nullbag is kjDict or kjGraph
 */
 /* #ifndef PYTHON1DOT2 */
-static object * kjKeyPut(object *self, object *args)
+static PyObject * kjKeyPut(PyObject *self, PyObject *args)
 {
   long valid;
   TableWrapper *dict, *index, *nullbag;
-  object *dumper, *psuedokey, *d, *pair, *err_type /*,  *err_value */;
+  PyObject *dumper, *psuedokey, *d, *pair, *err_type /*,  *err_value */;
   /* get and verify args */
   if (args == NULL) {
-    err_setstr(TypeError, "KeyPut requires 5 arguments");
+    PyErr_SetString(PyExc_TypeError, "KeyPut requires 5 arguments");
     return NULL;
   }
-  if (!getargs(args, "(OOOOO)",
+  if (!PyArg_Parse(args, "(OOOOO)",
 	       &dict, &dumper, &index, &psuedokey, &nullbag)) {
-    err_setstr(TypeError,
+    PyErr_SetString(PyExc_TypeError,
 	       "KeyPut requires dict, dumper, index, psuedokey, nullbag");
     return NULL;
   }
   if (!((is_kjDictobject(dict)) || (is_kjGraphobject(dict)))) {
-    err_setstr(TypeError,
+    PyErr_SetString(PyExc_TypeError,
 	       "first arg of KeyPut must be kjDict or kjGraph");
     return NULL;
   }
   if (!((is_kjDictobject(index)) || (is_kjGraphobject(index)))) {
-    err_setstr(TypeError,
+    PyErr_SetString(PyExc_TypeError,
 	       "third arg of KeyPut must be kjDict or kjGraph");
     return NULL;
   }
   if (!((is_kjDictobject(nullbag)) || (is_kjGraphobject(nullbag)))) {
-    err_setstr(TypeError,
+    PyErr_SetString(PyExc_TypeError,
 	       "fifth arg of KeyPut must be kjDict or kjGraph");
     return NULL;
   }
-  if (!is_tupleobject(dumper)) {
-    err_setstr(TypeError,
+  if (!PyTuple_Check(dumper)) {
+    PyErr_SetString(PyExc_TypeError,
 	       "second arg of KeyPut must be tuple");
     return NULL;
   }
@@ -3418,43 +3417,43 @@
     /* unable to dump */
     /* check that error was a keyerror ??? */
     /* err_get(&err_type, &err_value); */
-    err_type = err_occurred();
-    if (err_type != KeyError) {
+    err_type = PyErr_Occurred();
+    if (err_type != PyExc_KeyError) {
       /* some other error... abort */
-      /* err_setval(err_type, err_value); */
+      /* PyErr_SetObject(err_type, err_value); */
       return NULL;
     }
-    /* in case of KeyError, augment the Nullbag, return None */
-    err_clear();
-    valid = kjDict_ass_subscript((object *) nullbag, 
-                                   psuedokey, (object *) dict);
+    /* in case of PyExc_KeyError, augment the Nullbag, return None */
+    PyErr_Clear();
+    valid = kjDict_ass_subscript((PyObject *) nullbag, 
+                                   psuedokey, (PyObject *) dict);
     if (valid == -1) {
       return NULL;
     }
-    INCREF(None);
-    return None;
+    Py_INCREF(Py_None);
+    return Py_None;
   }
   /* if dump succeeded... */
-  /* initialize pair, INCREF components */
-  pair = newtupleobject(2);
+  /* initialize pair, Py_INCREF components */
+  pair = PyTuple_New(2);
   if (pair == NULL) { return NULL; }
-  settupleitem(pair, 0, psuedokey);
-  INCREF(psuedokey);
-  settupleitem(pair, 1, (object *) dict);
-  INCREF(dict);
+  PyTuple_SetItem(pair, 0, psuedokey);
+  Py_INCREF(psuedokey);
+  PyTuple_SetItem(pair, 1, (PyObject *) dict);
+  Py_INCREF(dict);
   /* remap None to (None,) if needed */
-  if (d == None) {
+  if (d == Py_None) {
     /* preserve extra reference to None... */
-    d = newtupleobject(1);
-    settupleitem(d, 0, None);
+    d = PyTuple_New(1);
+    PyTuple_SetItem(d, 0, Py_None);
   }
   /* set index[d] = pair, creates an extra ref to pair */
-  valid = kjDict_ass_subscript((object *) index, d, pair);
+  valid = kjDict_ass_subscript((PyObject *) index, d, pair);
   if (valid == -1) {
-    XDECREF(pair);
+    Py_XDECREF(pair);
     return NULL;
   }
-  XDECREF(pair); /* dispose of extra ref to pair */
+  Py_XDECREF(pair); /* dispose of extra ref to pair */
   return d;
 }
 /* #endif */
@@ -3462,16 +3461,16 @@
 /* THE "METHODS" FOR THIS MODULE */
 /* These are the basic external interfaces for python to
    access this module. */
-static struct methodlist kjbuckets_methods[] = {
-  {"kjSet",     (method)makekjSet},
-  {"kjDict",    (method)makekjDict},
-  {"kjGraph",    (method)makekjGraph},
-  {"kjUndump",  (method)kjUndumpToDict},
+static struct PyMethodDef kjbuckets_methods[] = {
+  {"kjSet",     (PyCFunction)makekjSet},
+  {"kjDict",    (PyCFunction)makekjDict},
+  {"kjGraph",    (PyCFunction)makekjGraph},
+  {"kjUndump",  (PyCFunction)kjUndumpToDict},
 /* #ifndef PYTHON1DOT2 */
-  {"kjKeyPut",  (method)kjKeyPut},
+  {"kjKeyPut",  (PyCFunction)kjKeyPut},
 /* #endif */
 #ifdef KJBDEBUG
-  {"debug",      (method)Wdebug},
+  {"debug",      (PyCFunction)Wdebug},
 #endif
   {NULL, NULL}            /* sentinel */
 };
@@ -3479,7 +3478,7 @@
 void
 initkjbuckets()
 {
-  initmodule("kjbuckets", kjbuckets_methods);
+  Py_InitModule("kjbuckets", kjbuckets_methods);
 }
 
 /* end of kjbuckets module by Aaron Watters */
