--- Sources/Core/Input/TTY/keyboard_tty.cpp.orig	Wed Apr 26 00:40:16 2000
+++ Sources/Core/Input/TTY/keyboard_tty.cpp	Mon Sep 25 00:44:59 2000
@@ -40,8 +40,9 @@
 #endif
 #ifdef HAVE_SYS_VT_H
 #include <sys/vt.h>
-#else
-#include <linux/vt.h>
+#else /* FreeBSD :-P */
+#include <vgakeyboard.h>
+#include <sys/consio.h>
 #endif
 
 #include <linux/keyboard.h>
@@ -72,56 +73,14 @@
 //	CL_System_Generic::keep_alives.add(this);
 
 	/* open the tty */
-	fd = open("/dev/tty", O_RDWR | O_NONBLOCK);
+	fd = keyboard_init_return_fd();
 
 	if (fd < 0)
 	{
 		throw CL_Error("Couldn't open /dev/tty.");
 	}
 
-	/* put tty into "straight through" mode. */
-	struct termios newterm;
-
-	if (tcgetattr(fd, &old_termios) < 0)
-	{
-		perror("tcgetattr failed");
-	}
-
-	memcpy ( &newterm, &old_termios, sizeof(termios) );
-
-	newterm.c_lflag &= ~(ICANON | ECHO  | ISIG);
-	newterm.c_iflag &= ~(ISTRIP | IGNCR | ICRNL | INLCR | IXOFF | IXON);
-	newterm.c_iflag |= IGNBRK;
-	newterm.c_cc[VMIN]  = 0;
-	newterm.c_cc[VTIME] = 0;
-
-	if (tcsetattr(fd, TCSANOW, &newterm) < 0)
-	{
-		perror("tcsetattr failed");
-	}
-
-	/* save old mode and set to mediumraw */
-	if (ioctl(fd, KDGKBMODE, &old_mode) < 0)
-	{
-		perror("Couldn't get keyboard mode");
-		old_mode = K_XLATE;
-	}
-	if (ioctl(fd, KDSKBMODE, K_MEDIUMRAW) < 0)
-	{
-		perror("Couldn't set keyboard mode to K_MEDIUMRAW");
-	}
-	
-	/* save old kd mode and set to graphics */
-	if (ioctl(fd, KDGETMODE, &old_kd) < 0)
-	{
-		perror("Couldn't get kd mode");
-		old_kd = KD_TEXT;
-	}
-	if (ioctl(fd, KDSETMODE, KD_GRAPHICS) < 0)
-	{
-		perror("Couldn't set kd mode to KD_GRAPHICS");
-	}
-	
+	ioctl(fd, GIO_KEYMAP, &vga_keymap);
 	buttons = new CL_InputButton_TTYKeyboard*[CL_NUM_KEYS];
 	for (int i=0; i<CL_NUM_KEYS; i++) buttons[i] = NULL;
 }
@@ -144,13 +103,7 @@
 {
 	if (fd>=0)
 	{
-		ioctl(fd, KDSKBMODE, old_mode);
-		ioctl(fd, KDSETMODE, old_kd);
-		if (tcsetattr(fd, TCSANOW, &old_termios) < 0)
-		{
-			std::cerr << "Could not restore old terminal input settings! Please run 'reset'!" << std::endl;
-			perror( "System error message" );
-		}
+		keyboard_close();
 		close(fd);
 	}
 }
@@ -172,8 +125,8 @@
 void CL_TTYKeyboard::handle_code(char code)
 {
 	bool keydown;
-	kbentry entry;
-	
+	struct keyent_t entry;
+
 	if (code & 0x80)
 	{
 		code &= 0x7f;
@@ -183,109 +136,115 @@
 		keydown = true;
 	}
 			
+	// Simple belt against out-of-range codes
+	if (code >= vga_keymap.n_keys)
+		return;
+
 	//fetch the keycode
-	entry.kb_table = 0;
-	entry.kb_index = code;
-	ioctl(fd,KDGKBENT,&entry);
+	entry = vga_keymap.key[code];
 	
 	CL_Key key;
-	key.id = translate(entry.kb_value);
+	key.id = translate(entry);
 	key.ascii = -1;
 	key.state = keydown ? CL_Key::Pressed : CL_Key::Released;
 	
 	if (keydown) CL_Input::chain_button_press.on_button_press(this, key);
 	else CL_Input::chain_button_release.on_button_release(this, key);
 
-	keymap[translate(entry.kb_value)] = keydown;
+	keymap[translate(entry)] = keydown;
 }
 
-char CL_TTYKeyboard::translate(int kb_value)
+char CL_TTYKeyboard::translate(struct keyent_t kb_value)
 {
-	switch (kb_value)
-	{
-	case K_F1:	return CL_KEY_F1;
-	case K_F2:	return CL_KEY_F2;
-	case K_F3:	return CL_KEY_F3;
-	case K_F4:	return CL_KEY_F4;
-	case K_F5:	return CL_KEY_F5;
-	case K_F6:	return CL_KEY_F6;
-	case K_F7:	return CL_KEY_F7;
-	case K_F8:	return CL_KEY_F8;
-	case K_F9:	return CL_KEY_F9;
-	case K_F10:	return CL_KEY_F10;
-	case K_F11:	return CL_KEY_F11;
-	case K_F12:	return CL_KEY_F12;
-	
-	case 2816+'a':	return CL_KEY_A;
-	case 2816+'b':	return CL_KEY_B;
-	case 2816+'c':	return CL_KEY_C;
-	case 2816+'d':	return CL_KEY_D;
-	case 2816+'e':	return CL_KEY_E;
-	case 2816+'f':	return CL_KEY_F;
-	case 2816+'g':	return CL_KEY_G;
-	case 2816+'h':	return CL_KEY_H;
-	case 2816+'i':	return CL_KEY_I;
-	case 2816+'j':	return CL_KEY_J;
-	case 2816+'k':	return CL_KEY_K;
-	case 2816+'l':	return CL_KEY_L;
-	case 2816+'m':	return CL_KEY_M;
-	case 2816+'n':	return CL_KEY_N;
-	case 2816+'o':	return CL_KEY_O;
-	case 2816+'p':	return CL_KEY_P;
-	case 2816+'q':	return CL_KEY_Q;
-	case 2816+'r':	return CL_KEY_R;
-	case 2816+'s':	return CL_KEY_S;
-	case 2816+'t':	return CL_KEY_T;
-	case 2816+'u':	return CL_KEY_U;
-	case 2816+'v':	return CL_KEY_V;
-	case 2816+'w':	return CL_KEY_W;
-	case 2816+'x':	return CL_KEY_X;
-	case 2816+'y':	return CL_KEY_Y;
-	case 2816+'z':	return CL_KEY_Z;
+	if (kb_value.spcl & 0x80)
+		switch (kb_value.map[0])
+		{
+		case F(1):	return CL_KEY_F1;
+		case F(2):	return CL_KEY_F2;
+		case F(3):	return CL_KEY_F3;
+		case F(4):	return CL_KEY_F4;
+		case F(5):	return CL_KEY_F5;
+		case F(6):	return CL_KEY_F6;
+		case F(7):	return CL_KEY_F7;
+		case F(8):	return CL_KEY_F8;
+		case F(9):	return CL_KEY_F9;
+		case F(10):	return CL_KEY_F10;
+		case F(11):	return CL_KEY_F11;
+		case F(12):	return CL_KEY_F12;
+
+		case RCTR:	return CL_KEY_LCTRL;
+		case LCTR:	return CL_KEY_RCTRL;
+		case LSH:	return CL_KEY_LSHIFT;
+		case RSH:	return CL_KEY_RSHIFT;
+		case LALT:	return CL_KEY_ALT;
+		case RALT:	return CL_KEY_ALTGR;
+
+		case CLK:	return CL_KEY_CAPSLOCK;
+		case NLK:	return CL_KEY_NUMLOCK;
+		case SLK:	return CL_KEY_SCRLOCK;
+
+		case F(49):	return CL_KEY_HOME;
+		case F(50):	return CL_KEY_UP;
+		case F(51):	return CL_KEY_PAGEUP;
+		case F(53):	return CL_KEY_LEFT;
+		case F(55):	return CL_KEY_RIGHT;
+		case F(57):	return CL_KEY_END;
+		case F(58):	return CL_KEY_DOWN;
+		case F(59):	return CL_KEY_PAGEDOWN;
+		case F(60):	return CL_KEY_INSERT;
+		case F(61):	return CL_KEY_DELETE;
+
+		case NEXT:	return CL_KEY_PRINT;
+		}
+	else switch (kb_value.map[0])
+		{
+		case 'a':	return CL_KEY_A;
+		case 'b':	return CL_KEY_B;
+		case 'c':	return CL_KEY_C;
+		case 'd':	return CL_KEY_D;
+		case 'e':	return CL_KEY_E;
+		case 'f':	return CL_KEY_F;
+		case 'g':	return CL_KEY_G;
+		case 'h':	return CL_KEY_H;
+		case 'i':	return CL_KEY_I;
+		case 'j':	return CL_KEY_J;
+		case 'k':	return CL_KEY_K;
+		case 'l':	return CL_KEY_L;
+		case 'm':	return CL_KEY_M;
+		case 'n':	return CL_KEY_N;
+		case 'o':	return CL_KEY_O;
+		case 'p':	return CL_KEY_P;
+		case 'q':	return CL_KEY_Q;
+		case 'r':	return CL_KEY_R;
+		case 's':	return CL_KEY_S;
+		case 't':	return CL_KEY_T;
+		case 'u':	return CL_KEY_U;
+		case 'v':	return CL_KEY_V;
+		case 'w':	return CL_KEY_W;
+		case 'x':	return CL_KEY_X;
+		case 'y':	return CL_KEY_Y;
+		case 'z':	return CL_KEY_Z;
+		case ' ':	return CL_KEY_SPACE;
 	
-	case 48:	return CL_KEY_0;
-	case 49:	return CL_KEY_1;
-	case 50:	return CL_KEY_2;
-	case 51:	return CL_KEY_3;
-	case 52:	return CL_KEY_4;
-	case 53:	return CL_KEY_5;
-	case 54:	return CL_KEY_6;
-	case 55:	return CL_KEY_7;
-	case 56:	return CL_KEY_8;
-	case 57:	return CL_KEY_9;
+		case '0':	return CL_KEY_0;
+		case '1':	return CL_KEY_1;
+		case '2':	return CL_KEY_2;
+		case '3':	return CL_KEY_3;
+		case '4':	return CL_KEY_4;
+		case '5':	return CL_KEY_5;
+		case '6':	return CL_KEY_6;
+		case '7':	return CL_KEY_7;
+		case '8':	return CL_KEY_8;
+		case '9':	return CL_KEY_9;
 	
-	case 27:	return CL_KEY_ESCAPE;
-	case K_LEFT:	return CL_KEY_LEFT;
-	case K_RIGHT:	return CL_KEY_RIGHT;
-	case K_UP:	return CL_KEY_UP;
-	case K_DOWN:	return CL_KEY_DOWN;
-	case K_ENTER:	return CL_KEY_ENTER;
-
-	case K_CTRLL:	return CL_KEY_LCTRL;
-	case K_CTRLR:	return CL_KEY_RCTRL;
-	case K_SHIFTL:	return CL_KEY_LSHIFT;
-	case K_SHIFTR:	return CL_KEY_RSHIFT;
-	case K_ALT:	return CL_KEY_ALT;
-	case K_ALTGR:	return CL_KEY_ALTGR;
-	case 9:		return CL_KEY_TAB;
-	case 32:	return CL_KEY_SPACE;
-	case 127:	return CL_KEY_BACKSPACE;
-	case K_INSERT:	return CL_KEY_INSERT;
-	case K_REMOVE:	return CL_KEY_DELETE;
-	case K_FIND:	return CL_KEY_HOME;
-	case K_SELECT:	return CL_KEY_END;
-	case K_PGUP:	return CL_KEY_PAGEUP;
-	case K_PGDN:	return CL_KEY_PAGEDOWN;
-	case K_CAPS:	return CL_KEY_CAPSLOCK;
-	case K_NUM:	return CL_KEY_NUMLOCK;
-	case K_HOLD:	return CL_KEY_SCRLOCK;
-	case 28:	return CL_KEY_PRINT;
-	case K(1,29):	return CL_KEY_PAUSE;
-	case K_PSLASH:	return CL_KEY_KP_DIV;
-	case K_PSTAR:	return CL_KEY_KP_MULT;
-	case K_PMINUS:	return CL_KEY_KP_MINUS;
-	case K_PPLUS:	return CL_KEY_KP_PLUS;
-	case K_PENTER:	return CL_KEY_KP_ENTER;
+		case 27:	return CL_KEY_ESCAPE;
+		case 13:	return CL_KEY_ENTER;
+		case 9:		return CL_KEY_TAB;
+		case 8:		return CL_KEY_BACKSPACE;
+		case '/':	return CL_KEY_KP_DIV;
+		case '*':	return CL_KEY_KP_MULT;
+		case '-':	return CL_KEY_KP_MINUS;
+		case '+':	return CL_KEY_KP_PLUS;
 	}
 	
 	return CL_KEY_NONE_OF_THE_ABOVE;
