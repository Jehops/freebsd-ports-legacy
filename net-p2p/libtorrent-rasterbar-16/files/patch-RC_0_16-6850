diff -ur ../libtorrent-rasterbar-0.16.0/ChangeLog ./ChangeLog
--- ../libtorrent-rasterbar-0.16.0/ChangeLog	2012-04-09 20:53:40.000000000 -0700
+++ ./ChangeLog	2012-05-07 14:02:44.000000000 -0700
@@ -1,4 +1,17 @@
 
+	* fixed semantics of rate_limit_utp to also ignore per-torrent limits
+	* fixed piece sorting bug of deadline pieces
+	* fixed python binding build on Mac OS and BSD
+	* fixed UNC path normalization (on windows, unless UNC paths are disabled)
+	* fixed possible crash when enabling multiple connections per IP
+	* fixed typo in win vista specific code, breaking the build
+	* change default of rate_limit_utp to true
+	* fixed DLL export issue on windows (when building a shared library linking statically against boost)
+	* fixed FreeBSD build
+	* fixed web seed performance issue whith pieces > 1 MiB
+	* fixed unchoke logic when using web seeds
+	* fixed compatibility with older versions of boost (down to boost 1.40)
+
 0.16 release
 
 	* support torrents with more than 262000 pieces
diff -ur ../libtorrent-rasterbar-0.16.0/Jamfile ./Jamfile
--- ../libtorrent-rasterbar-0.16.0/Jamfile	2012-03-26 19:03:12.000000000 -0700
+++ ./Jamfile	2012-05-07 14:02:34.000000000 -0700
@@ -138,7 +138,7 @@
 	if <toolset>gcc in $(properties)
 		&& <target-os>linux in $(properties)
 		&& (<variant>debug in $(properties)
-			|| <asserts>release in $(properties)
+			|| <asserts>on in $(properties)
 			|| <asserts>production in $(properties))
 	{
 		# for backtraces in assertion failures
@@ -587,6 +587,13 @@
 	<define>BOOST_THREAD_USE_LIB
 	<threading>multi
 	<link>shared:<define>TORRENT_BUILDING_SHARED
+
+	# on windows, when linking statically against asio
+	# but producing a DLL, everything inside the DLL needs
+	# to declare the symbol as being exported
+	<link>shared,<boost-link>static:<define>BOOST_ASIO_SOURCE
+	<link>shared,<boost-link>static:<define>BOOST_SYSTEM_SOURCE
+
 	<dht-support>on:<source>src/kademlia/$(KADEMLIA_SOURCES).cpp
 	<dht-support>logging:<source>src/kademlia/$(KADEMLIA_SOURCES).cpp
 	<conditional>@building
diff -ur ../libtorrent-rasterbar-0.16.0/bindings/python/src/session.cpp ./bindings/python/src/session.cpp
--- ../libtorrent-rasterbar-0.16.0/bindings/python/src/session.cpp	2012-03-26 19:03:04.000000000 -0700
+++ ./bindings/python/src/session.cpp	2012-05-07 14:02:28.000000000 -0700
@@ -2,11 +2,9 @@
 // subject to the Boost Software License, Version 1.0. (See accompanying
 // file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 
+#include <boost/python.hpp>
 #include <list>
 #include <string>
-#include "Python.h"
-#include <cctype>
-#include <boost/python.hpp>
 #include <libtorrent/session.hpp>
 #include <libtorrent/settings.hpp> // for bencode_map_entry
 #include <libtorrent/torrent.hpp>
@@ -153,7 +151,7 @@
         , std::vector<char>& rd, std::list<std::string>& string_storage)
     {
         // torrent_info objects are always held by an intrusive_ptr in the python binding
-        if (params.has_key("ti"))
+        if (params.has_key("ti") && !params.get("ti").is_none())
             p.ti = extract<intrusive_ptr<torrent_info> >(params["ti"]);
 
         if (params.has_key("info_hash"))
diff -ur ../libtorrent-rasterbar-0.16.0/docs/manual.rst ./docs/manual.rst
--- ../libtorrent-rasterbar-0.16.0/docs/manual.rst	2012-04-10 20:16:58.000000000 -0700
+++ ./docs/manual.rst	2012-05-07 14:02:26.000000000 -0700
@@ -5370,7 +5370,7 @@
 the global rate limiter (which they aren't by default).
 
 ``rate_limit_utp`` determines if uTP connections should be throttled by the global rate
-limiter or not. By default they are not, since uTP manages its own rate.
+limiter or not. By default they are.
 
 ``listen_queue_size`` is the value passed in to listen() for the listen socket.
 It is the number of outstanding incoming connections to queue up while we're not
diff -ur ../libtorrent-rasterbar-0.16.0/include/libtorrent/alloca.hpp ./include/libtorrent/alloca.hpp
--- ../libtorrent-rasterbar-0.16.0/include/libtorrent/alloca.hpp	2012-03-26 19:03:11.000000000 -0700
+++ ./include/libtorrent/alloca.hpp	2012-05-07 14:02:41.000000000 -0700
@@ -34,15 +34,19 @@
 
 #include "libtorrent/config.hpp"
 
-#ifdef TORRENT_WINDOWS
+#if defined TORRENT_WINDOWS
 
 #include <malloc.h>
 #define TORRENT_ALLOCA(t, n) static_cast<t*>(_alloca(sizeof(t) * (n)))
 
+#elif defined TORRENT_BSD
+
+#include <stdlib.h>
+#define TORRENT_ALLOCA(t, n) static_cast<t*>(alloca(sizeof(t) * (n)))
+
 #else
 
 #include <alloca.h>
-
 #define TORRENT_ALLOCA(t, n) static_cast<t*>(alloca(sizeof(t) * (n)))
 
 #endif
diff -ur ../libtorrent-rasterbar-0.16.0/include/libtorrent/config.hpp ./include/libtorrent/config.hpp
--- ../libtorrent-rasterbar-0.16.0/include/libtorrent/config.hpp	2012-04-04 16:26:39.000000000 -0700
+++ ./include/libtorrent/config.hpp	2012-05-07 14:02:41.000000000 -0700
@@ -67,6 +67,20 @@
 #endif
 #endif
 
+// backwards compatibility with older versions of boost
+#if !defined BOOST_SYMBOL_EXPORT && !defined BOOST_SYMBOL_IMPORT
+# if defined _MSC_VER || defined __MINGW32__
+#  define BOOST_SYMBOL_EXPORT __declspec(dllexport)
+#  define BOOST_SYMBOL_IMPORT __declspec(dllimport)
+# elif __GNU__ >= 4
+#  define BOOST_SYMBOL_EXPORT __attribute__((visibility("default")))
+#  define BOOST_SYMBOL_IMPORT __attribute__((visibility("default")))
+# else
+#  define BOOST_SYMBOL_EXPORT
+#  define BOOST_SYMBOL_IMPORT
+# endif
+#endif
+
 #if defined TORRENT_BUILDING_SHARED
 # define TORRENT_EXPORT BOOST_SYMBOL_EXPORT
 #elif defined TORRENT_LINKING_SHARED
@@ -158,6 +172,9 @@
 #define TORRENT_USE_LOCALE 0
 #define TORRENT_CLOSE_MAY_BLOCK 1
 #endif
+#else
+// FreeBSD has a reasonable iconv signature
+#define TORRENT_ICONV_ARG (const char**)
 #endif
 #define TORRENT_HAS_FALLOCATE 0
 #define TORRENT_USE_IFADDRS 1
@@ -186,7 +203,9 @@
 #define TORRENT_USE_GETADAPTERSADDRESSES 1
 #define TORRENT_HAS_SALEN 0
 #define TORRENT_USE_GETIPFORWARDTABLE 1
+#ifndef TORRENT_USE_UNC_PATHS
 #define TORRENT_USE_UNC_PATHS 1
+#endif
 
 // ==== WINDOWS ===
 #elif defined WIN32
@@ -203,7 +222,9 @@
 #endif
 #define TORRENT_USE_RLIMIT 0
 #define TORRENT_HAS_FALLOCATE 0
+#ifndef TORRENT_USE_UNC_PATHS
 #define TORRENT_USE_UNC_PATHS 1
+#endif
 
 // ==== SOLARIS ===
 #elif defined sun || defined __sun 
diff -ur ../libtorrent-rasterbar-0.16.0/include/libtorrent/disk_buffer_pool.hpp ./include/libtorrent/disk_buffer_pool.hpp
--- ../libtorrent-rasterbar-0.16.0/include/libtorrent/disk_buffer_pool.hpp	2012-03-26 19:03:11.000000000 -0700
+++ ./include/libtorrent/disk_buffer_pool.hpp	2012-05-07 14:02:37.000000000 -0700
@@ -42,6 +42,10 @@
 #include <boost/pool/pool.hpp>
 #endif
 
+#ifdef TORRENT_DISK_STATS
+#include <fstream>
+#endif
+
 #if defined TORRENT_DEBUG || TORRENT_RELEASE_ASSERTS
 #include <map>
 #endif
diff -ur ../libtorrent-rasterbar-0.16.0/include/libtorrent/escape_string.hpp ./include/libtorrent/escape_string.hpp
--- ../libtorrent-rasterbar-0.16.0/include/libtorrent/escape_string.hpp	2012-03-26 19:03:11.000000000 -0700
+++ ./include/libtorrent/escape_string.hpp	2012-05-07 14:02:41.000000000 -0700
@@ -44,7 +44,7 @@
 {
 	TORRENT_EXTRA_EXPORT boost::array<char, 3 + std::numeric_limits<size_type>::digits10> to_string(size_type n);
 	TORRENT_EXTRA_EXPORT bool is_alpha(char c);
-	TORRENT_EXTRA_EXPORT bool is_digit(char c);
+	TORRENT_EXPORT bool is_digit(char c);
 	TORRENT_EXTRA_EXPORT bool is_print(char c);
 	TORRENT_EXTRA_EXPORT bool is_space(char c);
 	TORRENT_EXTRA_EXPORT char to_lower(char c);
diff -ur ../libtorrent-rasterbar-0.16.0/include/libtorrent/file.hpp ./include/libtorrent/file.hpp
--- ../libtorrent-rasterbar-0.16.0/include/libtorrent/file.hpp	2012-03-26 19:03:11.000000000 -0700
+++ ./include/libtorrent/file.hpp	2012-05-07 14:02:41.000000000 -0700
@@ -140,6 +140,9 @@
 	TORRENT_EXPORT std::string complete(std::string const& f);
 	TORRENT_EXPORT bool is_complete(std::string const& f);
 	TORRENT_EXPORT std::string current_working_directory();
+#if TORRENT_USE_UNC_PATHS
+	TORRENT_EXTRA_EXPORT std::string canonicalize_path(std::string const& f);
+#endif
 
 	class TORRENT_EXPORT directory : public boost::noncopyable
 	{
diff -ur ../libtorrent-rasterbar-0.16.0/include/libtorrent/http_seed_connection.hpp ./include/libtorrent/http_seed_connection.hpp
--- ../libtorrent-rasterbar-0.16.0/include/libtorrent/http_seed_connection.hpp	2012-03-26 19:03:11.000000000 -0700
+++ ./include/libtorrent/http_seed_connection.hpp	2012-05-07 14:02:39.000000000 -0700
@@ -117,10 +117,10 @@
 		// this is const since it's used as a key in the web seed list in the torrent
 		// if it's changed referencing back into that list will fail
 		const std::string m_url;
-			
+
 		// the number of bytes left to receive of the response we're
 		// currently parsing
-		size_type m_response_left;		
+		size_type m_response_left;
 
 		// this is the offset inside the current receive
 		// buffer where the next chunk header will be.
diff -ur ../libtorrent-rasterbar-0.16.0/include/libtorrent/kademlia/node.hpp ./include/libtorrent/kademlia/node.hpp
--- ../libtorrent-rasterbar-0.16.0/include/libtorrent/kademlia/node.hpp	2012-03-26 19:03:07.000000000 -0700
+++ ./include/libtorrent/kademlia/node.hpp	2012-05-07 14:02:37.000000000 -0700
@@ -115,7 +115,7 @@
 
 struct dht_immutable_item
 {
-	dht_immutable_item() : value(0), num_announcers(0) {}
+	dht_immutable_item() : value(0), num_announcers(0), size(0) {}
 	// malloced space for the actual value
 	char* value;
 	// this counts the number of IPs we have seen
diff -ur ../libtorrent-rasterbar-0.16.0/include/libtorrent/piece_picker.hpp ./include/libtorrent/piece_picker.hpp
--- ../libtorrent-rasterbar-0.16.0/include/libtorrent/piece_picker.hpp	2012-04-03 21:24:36.000000000 -0700
+++ ./include/libtorrent/piece_picker.hpp	2012-05-07 14:02:39.000000000 -0700
@@ -117,6 +117,10 @@
 			// the state of this block
 			enum { state_none, state_requested, state_writing, state_finished };
 			unsigned state:2;
+#if defined TORRENT_DEBUG || TORRENT_RELEASE_ASSERTS
+			// to allow verifying the invariant of blocks belonging to the right piece
+			int piece_index;
+#endif
 		};
 
 		// the peers that are downloading this piece
diff -ur ../libtorrent-rasterbar-0.16.0/include/libtorrent/torrent.hpp ./include/libtorrent/torrent.hpp
--- ../libtorrent-rasterbar-0.16.0/include/libtorrent/torrent.hpp	2012-03-29 22:28:20.000000000 -0700
+++ ./include/libtorrent/torrent.hpp	2012-05-07 14:02:41.000000000 -0700
@@ -500,7 +500,9 @@
 		// returns true if we have downloaded the given piece
 		bool have_piece(int index) const
 		{
-			return has_picker()?m_picker->have_piece(index):true;
+			if (!valid_metadata()) return false;
+			if (!has_picker()) return true;
+			return m_picker->have_piece(index);
 		}
 
 		// called when we learn that we have a piece
diff -ur ../libtorrent-rasterbar-0.16.0/include/libtorrent/utp_stream.hpp ./include/libtorrent/utp_stream.hpp
--- ../libtorrent-rasterbar-0.16.0/include/libtorrent/utp_stream.hpp	2012-03-26 19:03:11.000000000 -0700
+++ ./include/libtorrent/utp_stream.hpp	2012-05-07 14:02:41.000000000 -0700
@@ -192,7 +192,7 @@
 	void io_control(IO_Control_Command& ioc, error_code& ec) {}
 
 #ifndef BOOST_NO_EXCEPTIONS
-	void bind(endpoint_type const& endpoint) {}
+	void bind(endpoint_type const& /*endpoint*/) {}
 #endif
 
 	void bind(endpoint_type const& endpoint, error_code& ec);
@@ -206,7 +206,7 @@
 	error_code set_option(SettableSocketOption const& opt, error_code& ec) { return ec; }
 
 	void close();
-	void close(error_code const& ec) { close(); }
+	void close(error_code const& /*ec*/) { close(); }
 	bool is_open() const { return m_open; }
 
 	int read_buffer_size() const;
@@ -245,7 +245,7 @@
 	endpoint_type remote_endpoint(error_code& ec) const;
 
 	std::size_t available() const;
-	std::size_t available(error_code& ec) const { return available(); }
+	std::size_t available(error_code& /*ec*/) const { return available(); }
 
 	asio::io_service& get_io_service() { return m_io_service; }
 
diff -ur ../libtorrent-rasterbar-0.16.0/src/asio.cpp ./src/asio.cpp
--- ../libtorrent-rasterbar-0.16.0/src/asio.cpp	2012-03-26 19:02:55.000000000 -0700
+++ ./src/asio.cpp	2012-05-07 14:01:55.000000000 -0700
@@ -1,3 +1,7 @@
 // builds all boost.asio source as a separate compilation unit
+#include <boost/version.hpp>
+
+#if BOOST_VERSION >= 104500
 #include <boost/asio/impl/src.hpp>
+#endif
 
diff -ur ../libtorrent-rasterbar-0.16.0/src/asio_ssl.cpp ./src/asio_ssl.cpp
--- ../libtorrent-rasterbar-0.16.0/src/asio_ssl.cpp	2012-03-26 19:02:55.000000000 -0700
+++ ./src/asio_ssl.cpp	2012-05-07 14:01:55.000000000 -0700
@@ -1,3 +1,7 @@
 // builds all boost.asio SSL source as a separate compilation unit
+#include <boost/version.hpp>
+
+#if BOOST_VERSION >= 104610
 #include <boost/asio/ssl/impl/src.hpp>
+#endif
 
diff -ur ../libtorrent-rasterbar-0.16.0/src/bandwidth_queue_entry.cpp ./src/bandwidth_queue_entry.cpp
--- ../libtorrent-rasterbar-0.16.0/src/bandwidth_queue_entry.cpp	2012-03-26 19:02:55.000000000 -0700
+++ ./src/bandwidth_queue_entry.cpp	2012-05-07 14:01:55.000000000 -0700
@@ -54,9 +54,13 @@
 		TORRENT_ASSERT(assigned < request_size);
 		int quota = request_size - assigned;
 		TORRENT_ASSERT(quota >= 0);
+		--ttl;
+		if (quota == 0) return quota;
+
 		for (int j = 0; j < 5 && channel[j]; ++j)
 		{
 			if (channel[j]->throttle() == 0) continue;
+			if (channel[j]->tmp == 0) continue;
 			quota = (std::min)(int(boost::int64_t(channel[j]->distribute_quota)
 				* priority / channel[j]->tmp), quota);
 		}
@@ -64,7 +68,6 @@
 		for (int j = 0; j < 5 && channel[j]; ++j)
 			channel[j]->use_quota(quota);
 		TORRENT_ASSERT(assigned <= request_size);
-		--ttl;
 		return quota;
 	}
 }
diff -ur ../libtorrent-rasterbar-0.16.0/src/create_torrent.cpp ./src/create_torrent.cpp
--- ../libtorrent-rasterbar-0.16.0/src/create_torrent.cpp	2012-03-26 19:02:55.000000000 -0700
+++ ./src/create_torrent.cpp	2012-05-07 14:01:48.000000000 -0700
@@ -167,6 +167,9 @@
 		file_pool fp;
 		std::string utf8;
 		wchar_utf8(p, utf8);
+#if TORRENT_USE_UNC_PATHS
+		utf8 = canonicalize_path(utf8);
+#endif
 		boost::scoped_ptr<storage_interface> st(
 			default_storage_constructor(const_cast<file_storage&>(t.files()), 0, utf8, fp
 			, std::vector<boost::uint8_t>()));
@@ -195,8 +198,13 @@
 		, boost::function<void(int)> f, error_code& ec)
 	{
 		file_pool fp;
+#if TORRENT_USE_UNC_PATHS
+		std::string path = canonicalize_path(p);
+#else
+		std::string const& path = p;
+#endif
 		boost::scoped_ptr<storage_interface> st(
-			default_storage_constructor(const_cast<file_storage&>(t.files()), 0, p, fp
+			default_storage_constructor(const_cast<file_storage&>(t.files()), 0, path, fp
 			, std::vector<boost::uint8_t>()));
 
 		// if we're calculating file hashes as well, use this hasher
diff -ur ../libtorrent-rasterbar-0.16.0/src/disk_buffer_pool.cpp ./src/disk_buffer_pool.cpp
--- ../libtorrent-rasterbar-0.16.0/src/disk_buffer_pool.cpp	2012-03-26 19:02:55.000000000 -0700
+++ ./src/disk_buffer_pool.cpp	2012-05-07 14:01:55.000000000 -0700
@@ -38,6 +38,10 @@
 #include <sys/mman.h>
 #endif
 
+#ifdef TORRENT_DISK_STATS
+#include "libtorrent/time.hpp"
+#endif
+
 namespace libtorrent
 {
 	disk_buffer_pool::disk_buffer_pool(int block_size)
diff -ur ../libtorrent-rasterbar-0.16.0/src/disk_io_thread.cpp ./src/disk_io_thread.cpp
--- ../libtorrent-rasterbar-0.16.0/src/disk_io_thread.cpp	2012-04-09 20:53:39.000000000 -0700
+++ ./src/disk_io_thread.cpp	2012-05-07 14:01:55.000000000 -0700
@@ -1452,7 +1452,14 @@
 		// sizing the disk cache size when it's set to
 		// automatic.
 #ifdef TORRENT_BSD
+#ifdef HW_MEMSIZE
 		int mib[2] = { CTL_HW, HW_MEMSIZE };
+#else
+		// not entirely sure this sysctl supports 64
+		// bit return values, but it's probably better
+		// than not building
+		int mib[2] = { CTL_HW, HW_PHYSMEM };
+#endif
 		size_t len = sizeof(m_physical_ram);
 		if (sysctl(mib, 2, &m_physical_ram, &len, NULL, 0) != 0)
 			m_physical_ram = 0;
diff -ur ../libtorrent-rasterbar-0.16.0/src/file.cpp ./src/file.cpp
--- ../libtorrent-rasterbar-0.16.0/src/file.cpp	2012-03-26 19:02:55.000000000 -0700
+++ ./src/file.cpp	2012-05-07 14:01:48.000000000 -0700
@@ -536,6 +536,69 @@
 #endif
 	}
 
+#if TORRENT_USE_UNC_PATHS
+	std::string canonicalize_path(std::string const& f)
+	{
+		std::string ret;
+		ret.resize(f.size());
+		char* write_cur = &ret[0];
+		char* last_write_sep = write_cur;
+
+		char const* read_cur = f.c_str();
+		char const* last_read_sep = read_cur;
+
+		// the last_*_sep pointers point to one past
+		// the last path separator encountered and is
+		// initializes to the first character in the path
+		while (*read_cur)
+		{
+			if (*read_cur != '\\')
+			{
+				*write_cur++ = *read_cur++;
+				continue;
+			}
+			int element_len = read_cur - last_read_sep;
+			if (element_len == 1 && memcmp(last_read_sep, ".", 1) == 0)
+			{
+				--write_cur;
+				++read_cur;
+				last_read_sep = read_cur;
+				continue;
+			}
+			if (element_len == 2 && memcmp(last_read_sep, "..", 2) == 0)
+			{
+				// find the previous path separator
+				if (last_write_sep > &ret[0])
+				{
+					--last_write_sep;
+					while (last_write_sep > &ret[0]
+						&& last_write_sep[-1] != '\\')
+						--last_write_sep;
+				}
+				write_cur = last_write_sep;
+				// find the previous path separator
+				if (last_write_sep > &ret[0])
+				{
+					--last_write_sep;
+					while (last_write_sep > &ret[0]
+						&& last_write_sep[-1] != '\\')
+						--last_write_sep;
+				}
+				++read_cur;
+				last_read_sep = read_cur;
+				continue;
+			}
+			*write_cur++ = *read_cur++;
+			last_write_sep = write_cur;
+			last_read_sep = read_cur;
+		}
+		// terminate destination string
+		*write_cur = 0;
+		ret.resize(write_cur - &ret[0]);
+		return ret;
+	}
+#endif	
+
 	size_type file_size(std::string const& f)
 	{
 		error_code ec;
@@ -811,14 +874,12 @@
 			FILE_SHARE_READ,
 		};
 
+		std::string p = convert_separators(path);
 #if TORRENT_USE_UNC_PATHS
 		// UNC paths must be absolute
-		std::string p = convert_separators(path);
-		// network paths are not supported by UNC paths
+		// network paths are already UNC paths
 		if (path.substr(0,2) == "\\\\") p = path;
 		else p = "\\\\?\\" + (is_complete(p) ? p : combine_path(current_working_directory(), p));
-#else
-		std::string p = convert_separators(path);
 #endif
 
 #if TORRENT_USE_WSTRING
@@ -1407,7 +1468,6 @@
 			if (GetLastError() != ERROR_IO_PENDING)
 			{
 				TORRENT_ASSERT(GetLastError() != ERROR_BAD_ARGUMENTS);
-				TORRENT_ASSERT(GetLastError() != ERROR_BAD_ARGUMENTS);
 				ec.assign(GetLastError(), get_system_category());
 				CloseHandle(ol.hEvent);
 				return -1;
diff -ur ../libtorrent-rasterbar-0.16.0/src/file_pool.cpp ./src/file_pool.cpp
--- ../libtorrent-rasterbar-0.16.0/src/file_pool.cpp	2012-03-26 19:02:55.000000000 -0700
+++ ./src/file_pool.cpp	2012-05-07 14:01:55.000000000 -0700
@@ -162,7 +162,7 @@
 					FILE_IO_PRIORITY_HINT_INFO priorityHint;
 					priorityHint.PriorityHint = IoPriorityHintLow;
 					SetFileInformationByHandle(e.file_ptr->native_handle(),
-						FileIoPriorityHintInfo, &priorityHint, sizeof(PriorityHint));
+						FileIoPriorityHintInfo, &priorityHint, sizeof(priorityHint));
 				}
 #endif
 #endif
diff -ur ../libtorrent-rasterbar-0.16.0/src/http_seed_connection.cpp ./src/http_seed_connection.cpp
--- ../libtorrent-rasterbar-0.16.0/src/http_seed_connection.cpp	2012-03-26 19:02:55.000000000 -0700
+++ ./src/http_seed_connection.cpp	2012-05-07 14:01:55.000000000 -0700
@@ -65,6 +65,7 @@
 		, web_seed_entry::headers_t const& extra_headers)
 		: web_connection_base(ses, t, s, remote, url, peerinfo, auth, extra_headers)
 		, m_url(url)
+		, m_response_left(0)
 		, m_chunk_pos(0)
 		, m_partial_chunk_header(0)
 	{
diff -ur ../libtorrent-rasterbar-0.16.0/src/i2p_stream.cpp ./src/i2p_stream.cpp
--- ../libtorrent-rasterbar-0.16.0/src/i2p_stream.cpp	2012-03-26 19:02:55.000000000 -0700
+++ ./src/i2p_stream.cpp	2012-05-07 14:01:55.000000000 -0700
@@ -288,9 +288,9 @@
 		}
 
 		ptr = string_tokenize(next, ' ', &next);
-		if (ptr == 0 || strcmp(expect1, ptr)) { handle_error(invalid_response, h); return; }
+		if (ptr == 0 || expect1 == 0 || strcmp(expect1, ptr)) { handle_error(invalid_response, h); return; }
 		ptr = string_tokenize(next, ' ', &next);
-		if (ptr == 0 || strcmp(expect2, ptr)) { handle_error(invalid_response, h); return; }
+		if (ptr == 0 || expect2 == 0 || strcmp(expect2, ptr)) { handle_error(invalid_response, h); return; }
 
 		int result = 0;
 		char const* message = 0;
diff -ur ../libtorrent-rasterbar-0.16.0/src/kademlia/routing_table.cpp ./src/kademlia/routing_table.cpp
--- ../libtorrent-rasterbar-0.16.0/src/kademlia/routing_table.cpp	2012-03-26 19:02:50.000000000 -0700
+++ ./src/kademlia/routing_table.cpp	2012-05-07 14:01:48.000000000 -0700
@@ -113,8 +113,8 @@
 
 	if (deepest_bucket == 0) return 1 + deepest_size;
 
-	if (deepest_size < m_bucket_size / 2) return (1 << deepest_bucket) * m_bucket_size;
-	else return (2 << deepest_bucket) * deepest_size;
+	if (deepest_size < m_bucket_size / 2) return (size_type(1) << deepest_bucket) * m_bucket_size;
+	else return (size_type(2) << deepest_bucket) * deepest_size;
 }
 
 #if (defined TORRENT_DHT_VERBOSE_LOGGING || defined TORRENT_DEBUG) && TORRENT_USE_IOSTREAM
diff -ur ../libtorrent-rasterbar-0.16.0/src/peer_connection.cpp ./src/peer_connection.cpp
--- ../libtorrent-rasterbar-0.16.0/src/peer_connection.cpp	2012-04-04 20:41:21.000000000 -0700
+++ ./src/peer_connection.cpp	2012-05-07 14:01:55.000000000 -0700
@@ -346,6 +346,7 @@
 		, m_holepunch_mode(false)
 		, m_ignore_stats(false)
 		, m_corked(false)
+		, m_has_metadata(true)
 #if defined TORRENT_DEBUG || TORRENT_RELEASE_ASSERTS
 		, m_in_constructor(true)
 		, m_disconnect_started(false)
@@ -3286,6 +3287,13 @@
 			return;
 		}
 
+		// we can't download pieces in these states
+		if (t->state() == torrent_status::checking_files
+			|| t->state() == torrent_status::checking_resume_data
+			|| t->state() == torrent_status::downloading_metadata
+			|| t->state() == torrent_status::allocating)
+			return;
+
 		if ((int)m_download_queue.size() >= m_desired_queue_size
 			|| t->upload_mode()) return;
 
@@ -3869,13 +3877,14 @@
 		if (peer_info_struct())
 		{
 			policy::peer* pi = peer_info_struct();
+			TORRENT_ASSERT(pi->in_use);
 			p.source = pi->source;
 			p.failcount = pi->failcount;
 			p.num_hashfails = pi->hashfails;
 			p.flags |= pi->on_parole ? peer_info::on_parole : 0;
 			p.flags |= pi->optimistically_unchoked ? peer_info::optimistic_unchoke : 0;
 #ifndef TORRENT_DISABLE_GEO_IP
-			p.inet_as = pi->inet_as->first;
+			p.inet_as = pi->inet_as ? pi->inet_as->first : 0xffff;
 #endif
 		}
 		else
@@ -4677,7 +4686,13 @@
 				// assume 20 kB/s
 				upload_capacity = (std::max)(20000, m_ses.m_peak_up_rate + 10000);
 			}
-			priority = (boost::uint64_t(m_est_reciprocation_rate) << 10) / upload_capacity;
+			int estimated_reciprocation_rate = m_est_reciprocation_rate;
+			// we cannot send faster than our upload rate anyway
+			if (estimated_reciprocation_rate < upload_capacity)
+				estimated_reciprocation_rate = upload_capacity;
+
+			priority = (boost::uint64_t(estimated_reciprocation_rate) << 14) / upload_capacity;
+			if (priority > 0xffff) priority = 0xffff;
 		}
 		else
 		{
@@ -4685,7 +4700,7 @@
 			if (priority > 255) priority = 255;
 			priority += t->priority() << 8;
 		}
-		TORRENT_ASSERT(priority < 0xffff);
+		TORRENT_ASSERT(priority <= 0xffff);
 
 		// peers that we are not interested in are non-prioritized
 		TORRENT_ASSERT((m_channel_state[upload_channel] & peer_info::bw_limit) == 0);
@@ -4760,15 +4775,16 @@
 			&& t)
 		{
 			int ret = 0;
-			if (!m_ignore_bandwidth_limits)
+			bool utp = m_socket->get<utp_stream>() != 0;
+			bool ignore_limits = m_ignore_bandwidth_limits
+				|| (!m_ses.m_settings.rate_limit_utp && utp);
+			if (!ignore_limits)
 			{
-				bool utp = m_socket->get<utp_stream>() != 0;
-
 				// in this case, we have data to send, but no
 				// bandwidth. So, we simply request bandwidth
 				// from the bandwidth manager
 				ret = request_upload_bandwidth(
-					(m_ses.m_settings.rate_limit_utp || !utp) ? &m_ses.m_upload_channel : 0
+					&m_ses.m_upload_channel
 					, &t->m_bandwidth_channel[upload_channel]
 					, &m_bandwidth_channel[upload_channel]
 					, !utp ? &m_ses.m_tcp_upload_channel : 0);
@@ -4913,15 +4929,16 @@
 			&& t)
 		{
 			int ret = 0;
-			if (!m_ignore_bandwidth_limits)
+			bool utp = m_socket->get<utp_stream>() != 0;
+			bool ignore_limits = m_ignore_bandwidth_limits
+				|| (!m_ses.m_settings.rate_limit_utp && utp);
+			if (!ignore_limits)
 			{
-				bool utp = m_socket->get<utp_stream>() != 0;
-
 				// in this case, we have outstanding data to
 				// receive, but no bandwidth quota. So, we simply
 				// request bandwidth from the bandwidth manager
 				ret = request_download_bandwidth(
-					(m_ses.m_settings.rate_limit_utp || !utp) ? &m_ses.m_download_channel : 0
+					&m_ses.m_download_channel
 					, &t->m_bandwidth_channel[download_channel]
 					, &m_bandwidth_channel[download_channel]
 					, !utp ? &m_ses.m_tcp_download_channel : 0);
diff -ur ../libtorrent-rasterbar-0.16.0/src/piece_picker.cpp ./src/piece_picker.cpp
--- ../libtorrent-rasterbar-0.16.0/src/piece_picker.cpp	2012-04-03 21:24:17.000000000 -0700
+++ ./src/piece_picker.cpp	2012-05-07 14:01:55.000000000 -0700
@@ -44,9 +44,10 @@
 #include "libtorrent/bitfield.hpp"
 #include "libtorrent/random.hpp"
 
-#ifdef TORRENT_DEBUG
+#if defined TORRENT_DEBUG || TORRENT_RELEASE_ASSERTS
 #include "libtorrent/peer_connection.hpp"
 #include "libtorrent/torrent.hpp"
+#include "libtorrent/policy.hpp" // for policy::peer
 #endif
 
 #include "libtorrent/invariant_check.hpp"
@@ -189,6 +190,9 @@
 			ret.info[i].num_peers = 0;
 			ret.info[i].state = block_info::state_none;
 			ret.info[i].peer = 0;
+#if defined TORRENT_DEBUG || TORRENT_RELEASE_ASSERTS
+			ret.info[i].piece_index = piece;
+#endif
 		}
 		return ret;
 	}
@@ -304,6 +308,8 @@
 			int num_writing = 0;
 			for (int k = 0; k < num_blocks; ++k)
 			{
+				TORRENT_ASSERT(i->info[k].piece_index == i->index);
+				TORRENT_ASSERT(i->info[k].peer == 0 || static_cast<policy::peer*>(i->info[k].peer)->in_use);
 				if (i->info[k].state == block_info::state_finished)
 				{
 					++num_finished;
@@ -827,6 +833,7 @@
 		int num_blocks = blocks_in_piece(i->index);
 		for (int k = 0; k < num_blocks; ++k)
 		{
+			TORRENT_ASSERT(i->info[k].piece_index == index);
 			TORRENT_ASSERT(i->info[k].state == block_info::state_finished);
 			TORRENT_ASSERT(i->info[k].num_peers == 0);
 		}
@@ -1367,6 +1374,8 @@
 		, int options, std::vector<int> const& suggested_pieces
 		, int num_peers) const
 	{
+		TORRENT_ASSERT(peer == 0 || static_cast<policy::peer*>(peer)->in_use);
+
 		// prevent the number of partial pieces to grow indefinitely
 		// make this scale by the number of peers we have. For large
 		// scale clients, we would have more peers, and allow a higher
@@ -1613,6 +1622,8 @@
 			for (int j = 0; j < num_blocks_in_piece; ++j)
 			{
 				block_info const& info = i->info[j];
+				TORRENT_ASSERT(info.peer == 0 || static_cast<policy::peer*>(info.peer)->in_use);
+				TORRENT_ASSERT(info.piece_index == i->index);
 				if (info.state != block_info::state_requested
 					|| info.peer == peer)
 					continue;
@@ -1650,6 +1661,7 @@
 			for (int j = 0; j < num_blocks_in_piece; ++j)
 			{
 				block_info const& info = i->info[j];
+				TORRENT_ASSERT(info.piece_index == i->index);
 				if (info.state != block_info::state_none) continue;
 				std::vector<piece_block>::iterator k = std::find(
 					interesting_blocks.begin(), interesting_blocks.end()
@@ -1695,6 +1707,7 @@
 				for (int j = 0; j < num_blocks_in_piece; ++j)
 				{
 					block_info const& info = k->info[j];
+					TORRENT_ASSERT(info.piece_index == k->index);
 					if (info.state == block_info::state_finished) continue;
 					TORRENT_ASSERT(info.peer != 0);
 				}
@@ -1736,7 +1749,10 @@
 	{
 		for (std::vector<block_info>::iterator i = m_block_info.begin()
 			, end(m_block_info.end()); i != end; ++i)
+		{
+			TORRENT_ASSERT(i->peer == 0 || static_cast<policy::peer*>(i->peer)->in_use);
 			if (i->peer == peer) i->peer = 0;
+		}
 	}
 
 	namespace
@@ -1753,6 +1769,8 @@
 			for (int j = 0; j < num_blocks_in_piece; ++j)
 			{
 				piece_picker::block_info const& info = p.info[j];
+				TORRENT_ASSERT(info.peer == 0 || static_cast<policy::peer*>(info.peer)->in_use);
+				TORRENT_ASSERT(info.piece_index == p.index);
 				if (info.state != piece_picker::block_info::state_none
 					&& info.peer != peer)
 				{
@@ -1882,6 +1900,7 @@
 			{
 				// ignore completed blocks and already requested blocks
 				block_info const& info = dp.info[j];
+				TORRENT_ASSERT(info.piece_index == dp.index);
 				if (info.state != block_info::state_none) continue;
 				backup_blocks2.push_back(piece_block(dp.index, j));
 			}
@@ -1892,6 +1911,7 @@
 		{
 			// ignore completed blocks and already requested blocks
 			block_info const& info = dp.info[j];
+			TORRENT_ASSERT(info.piece_index == dp.index);
 			if (info.state != block_info::state_none) continue;
 
 			// if the piece is fast and the peer is slow, or vice versa,
@@ -1985,6 +2005,7 @@
 #ifdef TORRENT_DEBUG
 		for (int k = 0; k < max_blocks; ++k)
 		{
+			TORRENT_ASSERT(i->info[k].piece_index == index);
 			TORRENT_ASSERT(i->info[k].state == block_info::state_finished
 				|| i->info[k].state == block_info::state_writing);
 		}
@@ -2033,6 +2054,7 @@
 		std::vector<downloading_piece>::const_iterator i = find_dl_piece(block.piece_index);
 
 		TORRENT_ASSERT(i != m_downloads.end());
+		TORRENT_ASSERT(i->info[block.block_index].piece_index == block.piece_index);
 		return i->info[block.block_index].state == block_info::state_requested;
 	}
 
@@ -2046,6 +2068,7 @@
 		if (m_piece_map[block.piece_index].downloading == 0) return false;
 		std::vector<downloading_piece>::const_iterator i = find_dl_piece(block.piece_index);
 		TORRENT_ASSERT(i != m_downloads.end());
+		TORRENT_ASSERT(i->info[block.block_index].piece_index == block.piece_index);
 		return i->info[block.block_index].state == block_info::state_finished
 			|| i->info[block.block_index].state == block_info::state_writing;
 	}
@@ -2060,12 +2083,14 @@
 		if (m_piece_map[block.piece_index].downloading == 0) return false;
 		std::vector<downloading_piece>::const_iterator i = find_dl_piece(block.piece_index);
 		TORRENT_ASSERT(i != m_downloads.end());
+		TORRENT_ASSERT(i->info[block.block_index].piece_index == block.piece_index);
 		return i->info[block.block_index].state == block_info::state_finished;
 	}
 
 	bool piece_picker::mark_as_downloading(piece_block block
 		, void* peer, piece_state_t state)
 	{
+		TORRENT_ASSERT(peer == 0 || static_cast<policy::peer*>(peer)->in_use);
 		TORRENT_ASSERT(state != piece_picker::none);
 		TORRENT_ASSERT(block.piece_index >= 0);
 		TORRENT_ASSERT(block.block_index >= 0);
@@ -2088,6 +2113,7 @@
 			downloading_piece& dp = add_download_piece(block.piece_index);
 			dp.state = state;
 			block_info& info = dp.info[block.block_index];
+			TORRENT_ASSERT(info.piece_index == block.piece_index);
 			info.state = block_info::state_requested;
 			info.peer = peer;
 			info.num_peers = 1;
@@ -2102,6 +2128,7 @@
 			std::vector<downloading_piece>::iterator i = find_dl_piece(block.piece_index);
 			TORRENT_ASSERT(i != m_downloads.end());
 			block_info& info = i->info[block.block_index];
+			TORRENT_ASSERT(info.piece_index == block.piece_index);
 			if (info.state == block_info::state_writing
 				|| info.state == block_info::state_finished)
 				return false;
@@ -2135,6 +2162,7 @@
 		TORRENT_ASSERT(i != m_downloads.end());
 
 		block_info const& info = i->info[block.block_index];
+		TORRENT_ASSERT(info.piece_index == block.piece_index);
 		return info.num_peers;
 	}
 
@@ -2156,6 +2184,8 @@
 		TORRENT_PIECE_PICKER_INVARIANT_CHECK;
 #endif
 
+		TORRENT_ASSERT(peer == 0 || static_cast<policy::peer*>(peer)->in_use);
+
 		TORRENT_ASSERT(block.piece_index >= 0);
 		TORRENT_ASSERT(block.block_index >= 0);
 		TORRENT_ASSERT(block.piece_index < m_piece_map.size());
@@ -2181,6 +2211,7 @@
 			downloading_piece& dp = add_download_piece(block.piece_index);
 			dp.state = none;
 			block_info& info = dp.info[block.block_index];
+			TORRENT_ASSERT(info.piece_index == block.piece_index);
 			info.state = block_info::state_writing;
 			info.peer = peer;
 			info.num_peers = 0;
@@ -2194,6 +2225,8 @@
 			TORRENT_ASSERT(i != m_downloads.end());
 			block_info& info = i->info[block.block_index];
 
+			TORRENT_ASSERT(info.piece_index == block.piece_index);
+
 			info.peer = peer;
 			if (info.state == block_info::state_requested) --i->requested;
 			TORRENT_ASSERT(i->requested >= 0);
@@ -2203,6 +2236,7 @@
 
 			++i->writing;
 			info.state = block_info::state_writing;
+			TORRENT_ASSERT(info.piece_index == block.piece_index);
 
 			// all other requests for this block should have been
 			// cancelled now
@@ -2228,6 +2262,7 @@
 		if (i == m_downloads.end()) return;
 
 		block_info& info = i->info[block.block_index];
+		TORRENT_ASSERT(info.piece_index == block.piece_index);
 		TORRENT_ASSERT(info.state == block_info::state_writing);
 		TORRENT_ASSERT(info.num_peers == 0);
 
@@ -2263,6 +2298,7 @@
 
 	void piece_picker::mark_as_finished(piece_block block, void* peer)
 	{
+		TORRENT_ASSERT(peer == 0 || static_cast<policy::peer*>(peer)->in_use);
 		TORRENT_ASSERT(block.piece_index >= 0);
 		TORRENT_ASSERT(block.block_index >= 0);
 		TORRENT_ASSERT(block.piece_index < m_piece_map.size());
@@ -2289,6 +2325,7 @@
 			downloading_piece& dp = add_download_piece(block.piece_index);
 			dp.state = none;
 			block_info& info = dp.info[block.block_index];
+			TORRENT_ASSERT(info.piece_index == block.piece_index);
 			info.peer = peer;
 			TORRENT_ASSERT(info.state == block_info::state_none);
 			TORRENT_ASSERT(info.num_peers == 0);
@@ -2308,6 +2345,7 @@
 			std::vector<downloading_piece>::iterator i = find_dl_piece(block.piece_index);
 			TORRENT_ASSERT(i != m_downloads.end());
 			block_info& info = i->info[block.block_index];
+			TORRENT_ASSERT(info.piece_index == block.piece_index);
 
 			if (info.state == block_info::state_finished) return;
 
@@ -2340,6 +2378,7 @@
 		d.clear();
 		for (int j = 0, end(blocks_in_piece(index)); j != end; ++j)
 		{
+			TORRENT_ASSERT(i->info[j].peer == 0 || static_cast<policy::peer*>(i->info[j].peer)->in_use);
 			d.push_back(i->info[j].peer);
 		}
 	}
@@ -2352,10 +2391,13 @@
 
 		TORRENT_ASSERT(block.block_index >= 0);
 
+		TORRENT_ASSERT(i->info[block.block_index].piece_index == block.piece_index);
 		if (i->info[block.block_index].state == block_info::state_none)
 			return 0;
 
-		return i->info[block.block_index].peer;
+		void* peer = i->info[block.block_index].peer;
+		TORRENT_ASSERT(peer == 0 || static_cast<policy::peer*>(peer)->in_use);
+		return peer;
 	}
 
 	// this is called when a request is rejected or when
@@ -2366,6 +2408,8 @@
 		TORRENT_PIECE_PICKER_INVARIANT_CHECK;
 #endif
 
+		TORRENT_ASSERT(peer == 0 || static_cast<policy::peer*>(peer)->in_use);
+
 		TORRENT_ASSERT(block.piece_index >= 0);
 		TORRENT_ASSERT(block.block_index >= 0);
 		TORRENT_ASSERT(block.piece_index < m_piece_map.size());
@@ -2381,6 +2425,8 @@
 		TORRENT_ASSERT(i != m_downloads.end());
 
 		block_info& info = i->info[block.block_index];
+		TORRENT_ASSERT(info.peer == 0 || static_cast<policy::peer*>(info.peer)->in_use);
+		TORRENT_ASSERT(info.piece_index == block.piece_index);
 
 		TORRENT_ASSERT(info.state != block_info::state_none);
 
@@ -2407,7 +2453,7 @@
 			info.state = block_info::state_none;
 			--i->requested;
 			update_full(*i);
-		}	
+		}
 
 		// if there are no other blocks in this piece
 		// that's being downloaded, remove it from the list
diff -ur ../libtorrent-rasterbar-0.16.0/src/policy.cpp ./src/policy.cpp
--- ../libtorrent-rasterbar-0.16.0/src/policy.cpp	2012-04-10 20:14:39.000000000 -0700
+++ ./src/policy.cpp	2012-05-07 14:01:55.000000000 -0700
@@ -1029,6 +1029,14 @@
 					pp.source |= src;
 					if (!was_conn_cand && is_connect_candidate(pp, m_finished))
 						++m_num_connect_candidates;
+					// calling disconnect() on a peer, may actually end
+					// up "garbage collecting" its policy::peer entry
+					// as well, if it's considered useless (which this specific)
+					// case will, since it was an incoming peer that just disconnected
+					// and we allow multiple connections per IP. Because of that,
+					// we need to make sure we don't let it do that, by unlinking
+					// the peer_connection from the policy::peer first.
+					p->connection->set_peer_info(0);
 					p->connection->disconnect(errors::duplicate_peer_id);
 					erase_peer(p);
 					return false;
diff -ur ../libtorrent-rasterbar-0.16.0/src/session.cpp ./src/session.cpp
--- ../libtorrent-rasterbar-0.16.0/src/session.cpp	2012-04-10 20:18:57.000000000 -0700
+++ ./src/session.cpp	2012-05-07 14:01:48.000000000 -0700
@@ -1261,7 +1261,7 @@
 		, utp_dynamic_sock_buf(true)
 		, utp_loss_multiplier(50) // specified in percent
 		, mixed_mode_algorithm(peer_proportional)
-		, rate_limit_utp(false)
+		, rate_limit_utp(true)
 		, listen_queue_size(5)
 		, announce_double_nat(false)
 		, torrent_connect_boost(10)
diff -ur ../libtorrent-rasterbar-0.16.0/src/session_impl.cpp ./src/session_impl.cpp
--- ../libtorrent-rasterbar-0.16.0/src/session_impl.cpp	2012-04-05 21:39:49.000000000 -0700
+++ ./src/session_impl.cpp	2012-05-07 14:01:55.000000000 -0700
@@ -4310,6 +4310,7 @@
 			TORRENT_ASSERT(p);
 			policy::peer* pi = p->peer_info_struct();
 			if (!pi) continue;
+			if (pi->web_seed) continue;
 			torrent* t = p->associated_torrent().lock().get();
 			if (!t) continue;
 			if (t->is_paused()) continue;
@@ -4408,7 +4409,8 @@
 			torrent* t = p->associated_torrent().lock().get();
 			policy::peer* pi = p->peer_info_struct();
 
-			if (p->ignore_unchoke_slots() || t == 0 || pi == 0 || t->is_paused()) continue;
+			if (p->ignore_unchoke_slots() || t == 0 || pi == 0 || pi->web_seed || t->is_paused())
+				continue;
 
 			if (m_settings.choking_algorithm == session_settings::bittyrant_choker)
 			{
diff -ur ../libtorrent-rasterbar-0.16.0/src/torrent.cpp ./src/torrent.cpp
--- ../libtorrent-rasterbar-0.16.0/src/torrent.cpp	2012-04-11 00:20:14.000000000 -0700
+++ ./src/torrent.cpp	2012-05-07 14:01:55.000000000 -0700
@@ -433,6 +433,10 @@
 #if defined TORRENT_DEBUG || TORRENT_RELEASE_ASSERTS
 		m_resume_data_loaded = false;
 #endif
+#if TORRENT_USE_UNC_PATHS
+		m_save_path = canonicalize_path(m_save_path);
+#endif
+
 		if (!m_apply_ip_filter) ++m_ses.m_non_filtered_torrents;
 
 		if (!p.ti || !p.ti->is_valid())
@@ -2048,14 +2052,15 @@
 		m_net_interfaces.clear();
 
 		char* str = strdup(net_interfaces.c_str());
+		char* ptr = str;
 
-		while (str)
+		while (ptr)
 		{
-			char* space = strchr(str, ',');
+			char* space = strchr(ptr, ',');
 			if (space) *space++ = 0;
 			error_code ec;
-			address a(address::from_string(str, ec));
-			str = space;
+			address a(address::from_string(ptr, ec));
+			ptr = space;
 			if (ec) continue;
 			m_net_interfaces.push_back(tcp::endpoint(a, 0));
 		}
@@ -3633,7 +3638,7 @@
 			}
 			while (i != m_time_critical_pieces.begin() && i->deadline < boost::prior(i)->deadline)
 			{
-				std::iter_swap(i, boost::next(i));
+				std::iter_swap(i, boost::prior(i));
 				--i;
 			}
 			return;
@@ -3687,21 +3692,26 @@
 					read_piece(i->piece);
 				}
 
-				// update the average download time and average
-				// download time deviation
-				int dl_time = total_milliseconds(time_now() - i->first_requested);
-
-				if (m_average_piece_time == 0)
-				{
-					m_average_piece_time = dl_time;
-				}
-				else
-				{
-					int diff = abs(int(dl_time - m_average_piece_time));
-					if (m_piece_time_deviation == 0) m_piece_time_deviation = diff;
-					else m_piece_time_deviation = (m_piece_time_deviation * 6 + diff * 4) / 10;
-
-					m_average_piece_time = (m_average_piece_time * 6 + dl_time * 4) / 10;
+				// if first_requested is min_time(), it wasn't requested as a critical piece
+				// and we shouldn't adjust any average download times
+				if (i->first_requested != min_time())
+				{
+					// update the average download time and average
+					// download time deviation
+					int dl_time = total_milliseconds(time_now() - i->first_requested);
+   
+					if (m_average_piece_time == 0)
+					{
+						m_average_piece_time = dl_time;
+					}
+					else
+					{
+						int diff = abs(int(dl_time - m_average_piece_time));
+						if (m_piece_time_deviation == 0) m_piece_time_deviation = diff;
+						else m_piece_time_deviation = (m_piece_time_deviation * 6 + diff * 4) / 10;
+   
+						m_average_piece_time = (m_average_piece_time * 6 + dl_time * 4) / 10;
+					}
 				}
 			}
 			m_time_critical_pieces.erase(i);
@@ -4317,7 +4327,14 @@
 			web->removed = true;
 			return;
 		}
+		peer_connection * peer = web->peer_info.connection;
+		if (peer) {
+			TORRENT_ASSERT(peer->m_in_use == 1337);
+			peer->set_peer_info(0);
+		}
 		if (has_picker()) picker().clear_peer(&web->peer_info);
+					
+
 		m_web_seeds.erase(web);
 	}
 
@@ -4503,6 +4520,14 @@
 
 		if (m_ses.is_aborted()) return;
 
+#ifndef TORRENT_DISABLE_GEO_IP
+		int as = m_ses.as_for_ip(host->endpoint().address());
+#ifdef TORRENT_DEBUG
+		web->peer_info.inet_as_num = as;
+#endif
+		web->peer_info.inet_as = m_ses.lookup_as(as);
+#endif
+
 		if (int(m_connections.size()) >= m_max_connections
 			|| m_ses.num_connections() >= m_ses.settings().connections_limit)
 			return;
@@ -5351,6 +5376,7 @@
 			i != end(); ++i)
 		{
 			peer_connection* peer = *i;
+			TORRENT_ASSERT(peer->m_in_use == 1337);
 
 			// incoming peers that haven't finished the handshake should
 			// not be included in this list
@@ -5792,9 +5818,9 @@
 			for (std::set<peer_connection*>::iterator i = m_connections.begin()
 				, end(m_connections.end()); i != end; ++i)
 			{
-				peer_connection* p = *i;
-				if (!p->is_connecting()) continue;
-				p->disconnect(errors::too_many_connections);
+				peer_connection* peer = *i;
+				if (!peer->is_connecting()) continue;
+				peer->disconnect(errors::too_many_connections);
 				break;
 			}
 		}
@@ -6221,12 +6247,22 @@
 
 		if (m_owning_storage.get())
 		{
-			m_owning_storage->async_move_storage(save_path
+#if TORRENT_USE_UNC_PATHS
+			std::string path = canonicalize_path(save_path);
+#else
+			std::string const& path = save_path;
+#endif
+			m_owning_storage->async_move_storage(path
 				, boost::bind(&torrent::on_storage_moved, shared_from_this(), _1, _2));
 		}
 		else
 		{
+#if TORRENT_USE_UNC_PATHS
+			m_save_path = canonicalize_path(save_path);
+#else
+
 			m_save_path = save_path;
+#endif
 			if (alerts().should_post<storage_moved_alert>())
 			{
 				alerts().post_alert(storage_moved_alert(get_handle(), m_save_path));
@@ -7858,6 +7894,7 @@
 			, (boost::bind(&policy::peer::connection, boost::bind(&web_seed_entry::peer_info, _1)) == p));
 		TORRENT_ASSERT(i != m_web_seeds.end());
 		if (i == m_web_seeds.end()) return;
+		p->set_peer_info(0);
 		if (has_picker()) picker().clear_peer(&i->peer_info);
 		m_web_seeds.erase(i);
 	}
diff -ur ../libtorrent-rasterbar-0.16.0/src/torrent_info.cpp ./src/torrent_info.cpp
--- ../libtorrent-rasterbar-0.16.0/src/torrent_info.cpp	2012-03-29 21:09:02.000000000 -0700
+++ ./src/torrent_info.cpp	2012-05-07 14:01:48.000000000 -0700
@@ -643,7 +643,8 @@
 	}
 
 	torrent_info::torrent_info(std::string const& filename, int flags)
-		: m_piece_hashes(0)
+		: m_merkle_first_leaf(0)
+		, m_piece_hashes(0)
 		, m_creation_date(0)
 		, m_info_section_size(0)
 		, m_multifile(false)
@@ -695,7 +696,8 @@
 #endif
 
 	torrent_info::torrent_info(lazy_entry const& torrent_file, error_code& ec, int flags)
-		: m_piece_hashes(0)
+		: m_merkle_first_leaf(0)
+		, m_piece_hashes(0)
 		, m_creation_date(0)
 		, m_info_section_size(0)
 		, m_multifile(false)
diff -ur ../libtorrent-rasterbar-0.16.0/src/utp_stream.cpp ./src/utp_stream.cpp
--- ../libtorrent-rasterbar-0.16.0/src/utp_stream.cpp	2012-03-26 19:02:55.000000000 -0700
+++ ./src/utp_stream.cpp	2012-05-07 14:01:48.000000000 -0700
@@ -2882,6 +2882,16 @@
 
 		m_cwnd = boost::int64_t(m_mtu) << 16;
 		if (m_outbuf.size()) ++m_num_timeouts;
+
+		if (m_num_timeouts > m_sm->num_resends())
+		{
+			// the connection is dead
+			m_error = asio::error::timed_out;
+			m_state = UTP_STATE_ERROR_WAIT;
+			test_socket_state();
+			return;
+		}
+
 		m_timeout = now + milliseconds(packet_timeout());
 	
 		UTP_LOGV("%8p: timeout resetting cwnd:%d\n"
diff -ur ../libtorrent-rasterbar-0.16.0/src/web_peer_connection.cpp ./src/web_peer_connection.cpp
--- ../libtorrent-rasterbar-0.16.0/src/web_peer_connection.cpp	2012-04-09 20:53:39.000000000 -0700
+++ ./src/web_peer_connection.cpp	2012-05-07 14:01:55.000000000 -0700
@@ -71,6 +71,7 @@
 		, web_seed_entry::headers_t const& extra_headers)
 		: web_connection_base(ses, t, s, remote, url, peerinfo, auth, extra_headers)
 		, m_url(url)
+		, m_received_body(0)
 		, m_range_pos(0)
 		, m_block_pos(0)
 		, m_chunk_pos(0)
@@ -84,9 +85,10 @@
 		shared_ptr<torrent> tor = t.lock();
 		TORRENT_ASSERT(tor);
 
-		// we always prefer downloading 1 MB chunks
-		// from web seeds
-		prefer_whole_pieces((1024 * 1024) / tor->torrent_file().piece_length());
+		// we always prefer downloading 1 MiB chunks
+		// from web seeds, or whole pieces if pieces
+		// are larger than a MiB
+		prefer_whole_pieces((std::min)((1024 * 1024) / tor->torrent_file().piece_length(), 1));
 		
 		// we want large blocks as well, so
 		// we can request more bytes at once
diff -ur ../libtorrent-rasterbar-0.16.0/test/test_piece_picker.cpp ./test/test_piece_picker.cpp
--- ../libtorrent-rasterbar-0.16.0/test/test_piece_picker.cpp	2012-04-09 20:53:39.000000000 -0700
+++ ./test/test_piece_picker.cpp	2012-05-07 14:02:34.000000000 -0700
@@ -221,13 +221,18 @@
 
 int test_main()
 {
-
-	int tmp1;
-	int tmp2;
-	int tmp3;
 	tcp::endpoint endp;
 	piece_picker::downloading_piece st;
+	policy::ipv4_peer tmp1(endp, false, 0);
+	policy::ipv4_peer tmp2(endp, false, 0);
+	policy::ipv4_peer tmp3(endp, false, 0);
 	policy::ipv4_peer peer_struct(endp, true, 0);
+#if defined TORRENT_DEBUG || TORRENT_RELEASE_ASSERTS
+	tmp1.in_use = true;
+	tmp2.in_use = true;
+	tmp3.in_use = true;
+	peer_struct.in_use = true;
+#endif
 	std::vector<piece_block> picked;
 	boost::shared_ptr<piece_picker> p;
 	const std::vector<int> empty_vector;
@@ -303,23 +308,23 @@
 	TEST_CHECK(p->is_requested(piece_block(0, 0)) == false);
 	TEST_CHECK(std::find(picked.begin(), picked.end(), piece_block(0,0)) != picked.end());
 
-	p->mark_as_downloading(piece_block(0, 2), (void*)1337, piece_picker::fast);
-	p->mark_as_writing(piece_block(0, 2), (void*)1337);
-	p->abort_download(piece_block(0, 2), (void*)1337);
-	p->mark_as_downloading(piece_block(0, 2), (void*)7, piece_picker::fast);
-	p->mark_as_writing(piece_block(0, 2), (void*)7);
+	p->mark_as_downloading(piece_block(0, 2), &tmp1, piece_picker::fast);
+	p->mark_as_writing(piece_block(0, 2), &tmp1);
+	p->abort_download(piece_block(0, 2), &tmp1);
+	p->mark_as_downloading(piece_block(0, 2), &tmp2, piece_picker::fast);
+	p->mark_as_writing(piece_block(0, 2), &tmp2);
 
 	std::vector<void*> d;
 	p->get_downloaders(d, 0);
-	TEST_CHECK(d[2] == (void*)7);
+	TEST_CHECK(d[2] == &tmp2);
 
-	p->mark_as_downloading(piece_block(0, 3), (void*)1337, piece_picker::fast);
-	p->abort_download(piece_block(0, 3), (void*)1337);
-	p->mark_as_downloading(piece_block(0, 3), (void*)7, piece_picker::fast);
-	p->mark_as_writing(piece_block(0, 3), (void*)7);
+	p->mark_as_downloading(piece_block(0, 3), &tmp1, piece_picker::fast);
+	p->abort_download(piece_block(0, 3), &tmp1);
+	p->mark_as_downloading(piece_block(0, 3), &tmp2, piece_picker::fast);
+	p->mark_as_writing(piece_block(0, 3), &tmp2);
 
 	p->get_downloaders(d, 0);
-	TEST_CHECK(d[3] == (void*)7);
+	TEST_CHECK(d[3] == &tmp2);
 
 // ========================================================
 
diff -ur ../libtorrent-rasterbar-0.16.0/test/test_primitives.cpp ./test/test_primitives.cpp
--- ../libtorrent-rasterbar-0.16.0/test/test_primitives.cpp	2012-03-29 21:09:02.000000000 -0700
+++ ./test/test_primitives.cpp	2012-05-07 14:02:34.000000000 -0700
@@ -871,6 +871,15 @@
 	TEST_EQUAL(combine_path("test1", "test2"), "test1/test2");
 #endif
 
+#if TORRENT_USE_UNC_PATHS
+	TEST_EQUAL(canonicalize_path("c:\\a\\..\\b"), "c:\\b");
+	TEST_EQUAL(canonicalize_path("a\\..\\b"), "b");
+	TEST_EQUAL(canonicalize_path("a\\..\\.\\b"), "b");
+	TEST_EQUAL(canonicalize_path("\\.\\a"), "\\a");
+	TEST_EQUAL(canonicalize_path("\\\\bla\\.\\a"), "\\\\bla\\a");
+	TEST_EQUAL(canonicalize_path("c:\\bla\\a"), "c:\\bla\\a");
+#endif
+
 	TEST_EQUAL(extension("blah"), "");
 	TEST_EQUAL(extension("blah.exe"), ".exe");
 	TEST_EQUAL(extension("blah.foo.bar"), ".bar");
