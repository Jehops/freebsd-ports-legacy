Index: config/Makefile.in
===================================================================
RCS file: /sources/mldonkey/mldonkey/config/Makefile.in,v
retrieving revision 1.173
retrieving revision 1.174
diff -u -r1.173 -r1.174
--- config/Makefile.in	21 Nov 2006 22:29:58 -0000	1.173
+++ config/Makefile.in	28 Nov 2006 23:58:01 -0000	1.174
@@ -148,7 +148,7 @@
   $(CDK)/filepath.ml $(CDK)/string2.ml \
   $(CDK)/filename2.ml $(CDK)/list2.ml $(CDK)/hashtbl2.ml \
   $(CDK)/unix2.ml $(CDK)/file.ml \
-  $(CDK)/heap_c.c $(CDK)/array2.ml $(CDK)/sort2.ml
+  $(CDK)/heap_c.c $(CDK)/array2.ml
   
 ifneq ("$(PTHREAD_CFLAGS)" , "")
   CFLAGS += $(PTHREAD_CFLAGS)
Index: distrib/ChangeLog
===================================================================
RCS file: /sources/mldonkey/mldonkey/distrib/ChangeLog,v
retrieving revision 1.1118
retrieving revision 1.1133
diff -u -r1.1118 -r1.1133
--- distrib/ChangeLog	28 Nov 2006 23:17:31 -0000	1.1118
+++ distrib/ChangeLog	8 Dec 2006 12:26:24 -0000	1.1133
@@ -14,6 +14,45 @@
 ChangeLog
 =========
 
+2006/12/08
+5617: New option share_scan_interval
+- how often (in minutes) should MLDonkey scan all shared directories
+  for new/removed files, default one minute
+- on slow machines raise the interval to a higher value to reduce CPU load
+- to force a re-scan of shared directories use command "reshare"
+
+2006/12/06
+5613: Another longhelp cleanup (anhi)
+5615: EDK: Parse more fields from server.met files
+
+2006/12/04
+5612: EDK: OP_HELLO tag 0x75, print os_info in logfile
+
+2006/12/03
+5602: HTML: Display share status in upstats
+5609: New field type Field_KNOWN, EDK: recognize more HELLO/EmuleInfo tags
+5610: CommonSources: Cleanups and reformatting the code (pango)
+
+2006/12/02
+5608: Multiuser, chgrp: Prevent change of file_group to None
+      if the user is not file_owner
+5607: Multiuser, chown: Change file_group to user_default_group
+      if the new user is not member of file_group
+5606: Introduce display of session transfer values
+- new columns for session up-/download
+- send session values to GUIs
+
+2006/12/01
+5605: HTML: Fix search list display when html_checkbox_search_file_list = true
+
+2006/11/29
+5598: Remove use of deprecated sort module, remove unused sort2.ml* (pango)
+5589: New option create_file_mode,
+      rename create_dir_mask to create_dir_mode (pango)
+5595: EDK: Fully parse emule_miscoptions1/2
+5594: EDK: If update_server_list_client true, add yet unknown server
+      of lowid clients
+-------------------------------------------------------------------------------
 2006/11/29 version 2.8.2 = tag release-2-8-2
 5597: GD: New option html_mods_vd_gfx_h_intervall
       (compute values for hourly graph every x minutes) (skeeve)
Index: src/daemon/common/commonClient.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/daemon/common/commonClient.ml,v
retrieving revision 1.33
retrieving revision 1.34
diff -u -r1.33 -r1.34
--- src/daemon/common/commonClient.ml	5 Nov 2006 14:09:38 -0000	1.33
+++ src/daemon/common/commonClient.ml	2 Dec 2006 12:35:45 -0000	1.34
@@ -467,16 +467,15 @@
     try
       let i = client_info c in
       let ctime = ((BasicSocket.last_time ()) - i.GuiTypes.client_connect_time) / 60 in
-      if i.GuiTypes.client_uploaded = Int64.zero && ctime > 1 then
+      if i.GuiTypes.client_session_uploaded = Int64.zero && ctime > 1 then
         begin
 	  client_disconnect c;
-          if !verbose then lprintf_nl "disconnected client %d: [%s %s] %s after %d %s of silence."
+          if !verbose then lprintf_nl "disconnected client %d: [%s %s] %s after %d minute%s of silence."
 	    (client_num c)
 	    (GuiTypes.client_software i.GuiTypes.client_software i.GuiTypes.client_os)
 	    i.GuiTypes.client_release
 	    i.GuiTypes.client_name
-	    ctime
-	    (if ctime = 1 then "minute" else "minutes")
+	    ctime (Printf2.print_plural_s ctime)
 	end
     with _ -> ()
   ) !uploaders
@@ -500,8 +499,10 @@
      T.client_os = None;
      T.client_release = "";
      T.client_emulemod = "";
-     T.client_downloaded = 0L;
-     T.client_uploaded = 0L;
+     T.client_total_downloaded = 0L;
+     T.client_total_uploaded = 0L;
+     T.client_session_downloaded = 0L;
+     T.client_session_uploaded = 0L;
      T.client_upload = None;
      T.client_sui_verified = None;
   }
Index: src/daemon/common/commonFile.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/daemon/common/commonFile.ml,v
retrieving revision 1.70
retrieving revision 1.71
diff -u -r1.70 -r1.71
--- src/daemon/common/commonFile.ml	15 Nov 2006 12:37:13 -0000	1.70
+++ src/daemon/common/commonFile.ml	2 Dec 2006 12:35:45 -0000	1.71
@@ -399,8 +399,8 @@
           ("", "sr br", addr);
           (GuiTypes.client_software cinfo.GuiTypes.client_software cinfo.GuiTypes.client_os,
 	   "sr br", GuiTypes.client_software_short cinfo.GuiTypes.client_software cinfo.GuiTypes.client_os);
-          ("", "sr ar", (size_of_int64 cinfo.GuiTypes.client_uploaded));
-          ("", "sr ar br", (size_of_int64 cinfo.GuiTypes.client_downloaded)); ];
+          ("", "sr ar", (size_of_int64 cinfo.GuiTypes.client_total_uploaded));
+          ("", "sr ar br", (size_of_int64 cinfo.GuiTypes.client_total_downloaded)); ];
 
         Printf.bprintf buf "\\</tr\\>";
 
Index: src/daemon/common/commonFile.mli
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/daemon/common/commonFile.mli,v
retrieving revision 1.30
retrieving revision 1.31
diff -u -r1.30 -r1.31
--- src/daemon/common/commonFile.mli	12 Nov 2006 12:44:24 -0000	1.30
+++ src/daemon/common/commonFile.mli	3 Dec 2006 20:57:56 -0000	1.31
@@ -129,7 +129,6 @@
 val set_file_comment : CommonTypes.file -> string -> unit
 val file_comment : CommonTypes.file -> string
 val file_magic : CommonTypes.file -> string option
-val set_file_magic : CommonTypes.file -> string option -> unit
 val check_magic : CommonTypes.file -> unit  
 val recover_bytes : CommonTypes.file -> (int64 * int64) list
 val file_write : CommonTypes.file -> int64 -> string -> int -> int -> unit
Index: src/daemon/common/commonGlobals.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/daemon/common/commonGlobals.ml,v
retrieving revision 1.77
retrieving revision 1.78
diff -u -r1.77 -r1.78
--- src/daemon/common/commonGlobals.ml	28 Nov 2006 23:15:21 -0000	1.77
+++ src/daemon/common/commonGlobals.ml	3 Dec 2006 20:49:42 -0000	1.78
@@ -405,6 +405,7 @@
   | Field_Lastseencomplete -> "lastcompl"
   | Field_Medialength -> "mlen"
   | Field_Mediacodec -> "mediacodec"
+  | Field_KNOWN s -> s
   | Field_UNKNOWN s -> s
 
 let field_of_string t =
@@ -426,10 +427,11 @@
   | "lastcompl" -> Field_Lastseencomplete 
   | "mlen" -> Field_Medialength
   | "mediacodec" -> Field_Mediacodec
-  | _ -> Field_UNKNOWN t
+  | _ -> Field_KNOWN t
 
 let escaped_string_of_field tag =
   match tag.tag_name with
+  | Field_KNOWN s -> String.escaped s
   | Field_UNKNOWN s -> String.escaped s
   | t -> string_of_field t
 
@@ -438,6 +440,10 @@
   Printf.sprintf "  \"%s\" = %s" (escaped_string_of_field tag)
   (string_of_tag_value tag.tag_value)
 
+let hexstring_of_tag tag =
+  Printf.sprintf "  \"%s\" = %s" (String2.hex_string_of_string (escaped_string_of_field tag))
+  (string_of_tag_value tag.tag_value)
+
 let rec print_tags tags =
   match tags with
     [] -> ()
Index: src/daemon/common/commonInteractive.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/daemon/common/commonInteractive.ml,v
retrieving revision 1.85
retrieving revision 1.87
diff -u -r1.85 -r1.87
--- src/daemon/common/commonInteractive.ml	26 Nov 2006 13:54:09 -0000	1.85
+++ src/daemon/common/commonInteractive.ml	3 Dec 2006 20:49:42 -0000	1.87
@@ -222,7 +222,7 @@
 	  let new_name = file_commited_name incoming.shdir_dirname file in
 	    if Unix2.is_directory file_name then begin
 	      Unix2.safe_mkdir new_name;
-	      Unix2.chmod new_name (Misc.int_of_octal_string !!create_dir_mask)
+	      Unix2.chmod new_name !Unix32.create_dir_mode;
 	    end;
 
 (*          the next line really moves the file *)
@@ -714,7 +714,7 @@
       | Q_MP3_BITRATE _ ->
           let bitrate = get_arg "bitrate" in
           if bitrate = "" then raise Not_found;
-          QHasMinVal(Field_UNKNOWN "bitrate", Int64.of_string bitrate)
+          QHasMinVal(Field_KNOWN "bitrate", Int64.of_string bitrate)
 
     in
     try
@@ -874,14 +874,14 @@
     | QHasMinVal (field, value) ->
         begin
           match field with
-            Field_UNKNOWN "bitrate"
+            Field_KNOWN "bitrate"
           | Field_Size
           | _ -> ()
         end
     | QHasMaxVal (field, value) ->
         begin
           match field with
-            Field_UNKNOWN "bitrate"
+            Field_KNOWN "bitrate"
           | Field_Size
           | _ -> ()
         end
Index: src/daemon/common/commonOptions.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/daemon/common/commonOptions.ml,v
retrieving revision 1.190
retrieving revision 1.193
diff -u -r1.190 -r1.193
--- src/daemon/common/commonOptions.ml	28 Nov 2006 23:15:21 -0000	1.190
+++ src/daemon/common/commonOptions.ml	8 Dec 2006 12:26:24 -0000	1.193
@@ -1267,8 +1267,16 @@
   "The directory where temporary files should be put"
     string_option "temp"
 
-let create_dir_mask = define_option current_section ["create_dir_mask"]
-  "New directories in incoming_directories are created with these rights"
+let share_scan_interval = define_option current_section ["share_scan_interval"]
+  "How often (in minutes) should MLDonkey scan all shared directories for new/removed files"
+    int_option 1
+
+let create_file_mode = define_option current_section ["create_file_mode"]
+  "New download files are created with these rights (in octal)"
+    string_option "664"
+
+let create_dir_mode = define_option current_section ["create_dir_mode"]
+  "New directories in incoming_directories are created with these rights (in octal)"
     string_option "755"
 
 let create_file_sparse = define_option current_section ["create_file_sparse"]
@@ -1497,9 +1505,12 @@
       TcpBufferedSocket.copy_read_buffer := !!copy_read_buffer
   )
 
-let _ =
-  option_hook create_dir_mask (fun _ ->
-      Unix32.create_dir_mask := !!create_dir_mask
+let () =
+  option_hook create_file_mode (fun _ ->
+      Unix32.create_file_mode := Misc.int_of_octal_string !!create_file_mode
+  );
+  option_hook create_dir_mode (fun _ ->
+      Unix32.create_dir_mode := Misc.int_of_octal_string !!create_dir_mode
   )
 
 let create_mlsubmit = define_expert_option current_section ["create_mlsubmit"]
@@ -1558,7 +1569,7 @@
 
 let compaction_overhead = define_expert_option current_section ["compaction_overhead"]
   "The percentage of free memory before a compaction is triggered"
-    percent_option 25
+    int_option 25
 
 let space_overhead = define_expert_option current_section ["space_overhead"]
   "The major GC speed is computed from this parameter. This is the memory
@@ -1708,6 +1719,9 @@
   option_hook min_reask_delay (fun _ ->
     if !!min_reask_delay < 600 then min_reask_delay =:= 600
   );
+  option_hook share_scan_interval (fun _ ->
+    if !!share_scan_interval < 1 then share_scan_interval =:= 1
+  );
   option_hook global_login (fun _ ->
       let len = String.length !!global_login in
       let prefix = "mldonkey_" in
Index: src/daemon/common/commonSearch.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/daemon/common/commonSearch.ml,v
retrieving revision 1.19
retrieving revision 1.20
diff -u -r1.19 -r1.20
--- src/daemon/common/commonSearch.ml	26 Nov 2006 13:54:09 -0000	1.19
+++ src/daemon/common/commonSearch.ml	3 Dec 2006 20:49:42 -0000	1.20
@@ -113,7 +113,7 @@
     | "-album"  :: format :: args ->
         iter args ((QHasField(Field_Album, format)) :: q)
     | "-field"  :: field :: format :: args ->
-        iter args ((QHasField(Field_UNKNOWN field, format)) :: q)
+        iter args ((QHasField(Field_KNOWN field, format)) :: q)
     | "-network" :: name :: args ->
         net := (network_find_by_name name).network_num;
         iter args q
@@ -892,7 +892,7 @@
         try
           let bitrate =  Int64.of_string s
           in
-          QHasMinVal(Field_UNKNOWN "bitrate", bitrate)
+          QHasMinVal(Field_KNOWN "bitrate", bitrate)
         with _ -> QNone
       end
 
Index: src/daemon/common/commonServer.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/daemon/common/commonServer.ml,v
retrieving revision 1.39
retrieving revision 1.40
diff -u -r1.39 -r1.40
--- src/daemon/common/commonServer.ml	26 Nov 2006 16:36:29 -0000	1.39
+++ src/daemon/common/commonServer.ml	28 Nov 2006 23:58:02 -0000	1.40
@@ -306,8 +306,8 @@
             (try impl.impl_server_ops.op_server_sort impl.impl_server_val
             with _ -> 0);
   ) servers_by_num;
-  Sort.list (fun s1 s2 ->
-      (as_server_impl s1).impl_server_sort >= (as_server_impl s2).impl_server_sort
+  List.sort (fun s1 s2 ->
+    compare (as_server_impl s2).impl_server_sort (as_server_impl s1).impl_server_sort
   ) !list
 
 let server_iter f =
Index: src/daemon/common/commonShared.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/daemon/common/commonShared.ml,v
retrieving revision 1.37
retrieving revision 1.38
diff -u -r1.37 -r1.38
--- src/daemon/common/commonShared.ml	29 Oct 2006 18:58:59 -0000	1.37
+++ src/daemon/common/commonShared.ml	3 Dec 2006 20:57:56 -0000	1.38
@@ -43,13 +43,14 @@
     mutable impl_shared_size : int64;
     mutable impl_shared_id : Md4.t;
     mutable impl_shared_requests : int;
-    mutable impl_shared_magic : string option;
+    mutable impl_shared_file : CommonTypes.file option;
     mutable impl_shared_servers : CommonTypes.server list;
   }
   
 and 'a shared_ops = {
     mutable op_shared_info : ('a -> GuiTypes.shared_info);
     mutable op_shared_unshare : ('a -> unit);
+    mutable op_shared_state : (CommonTypes.file -> CommonTypes.ui_conn -> string);
   }
   
 let as_shared  (shared : 'a shared_impl) =
@@ -180,6 +181,14 @@
   shared_remove impl;
   try impl.impl_shared_ops.op_shared_unshare impl.impl_shared_val with _ -> ()
 
+let shared_state s o =
+  let impl = as_shared_impl s in
+  try
+    match impl.impl_shared_file with
+    | None -> ""
+    | Some f -> impl.impl_shared_ops.op_shared_state f o
+  with _ -> ""
+
 let shared_dir = function
   | None	-> ""
   | Some sh	-> 
@@ -198,6 +207,7 @@
 let new_shared_ops network = {
     op_shared_unshare = (fun _ -> ni_ok network "shared_unshare");
     op_shared_info = (fun _ -> fni network "shared_info");
+    op_shared_state = (fun _ _ -> fni network "shared_state");
   }
 
 let dummy_shared = {
@@ -209,12 +219,13 @@
     impl_shared_ops = {
       op_shared_unshare = (fun _ -> raise Not_found);
       op_shared_info = (fun _ -> raise Not_found);
+      op_shared_state = (fun _ _ -> raise Not_found);
     };
     impl_shared_uploaded = zero;
     impl_shared_size = zero;
     impl_shared_id = Md4.null;
     impl_shared_requests = 0;
-    impl_shared_magic = None;
+    impl_shared_file = None;
     impl_shared_servers = []
   }
   
@@ -354,7 +365,10 @@
     T.shared_requests = impl.impl_shared_requests; 
     T.shared_uids = [];
     T.shared_sub_files = [];
-    T.shared_magic = impl.impl_shared_magic;
+    T.shared_magic =
+      match impl.impl_shared_file with
+      | None -> None
+      | Some f -> CommonFile.file_magic f;
   }
   
 let shared_info s =
Index: src/daemon/common/commonShared.mli
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/daemon/common/commonShared.mli,v
retrieving revision 1.8
retrieving revision 1.9
diff -u -r1.8 -r1.9
--- src/daemon/common/commonShared.mli	8 Oct 2006 14:20:21 -0000	1.8
+++ src/daemon/common/commonShared.mli	3 Dec 2006 20:57:56 -0000	1.9
@@ -9,12 +9,13 @@
   mutable impl_shared_size : int64;
   mutable impl_shared_id : Md4.Md4.t;
   mutable impl_shared_requests : int;
-  mutable impl_shared_magic : string option;
+  mutable impl_shared_file : CommonTypes.file option;
   mutable impl_shared_servers : CommonTypes.server list;
 } 
 and 'a shared_ops = {
   mutable op_shared_info : 'a -> GuiTypes.shared_info;
   mutable op_shared_unshare : 'a -> unit;
+  mutable op_shared_state : CommonTypes.file -> CommonTypes.ui_conn -> string;
 } 
 
 val dirnames_prio : (string * int) list ref
@@ -50,5 +51,4 @@
 val shared_check_files : unit -> unit
 val impl_shared_info : 'a shared_impl -> GuiTypes.shared_info
 val shared_info : CommonTypes.shared -> GuiTypes.shared_info
-
-  
+val shared_state : CommonTypes.shared -> CommonTypes.ui_conn -> string
Index: src/daemon/common/commonSources.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/daemon/common/commonSources.ml,v
retrieving revision 1.39
retrieving revision 1.41
diff -u -r1.39 -r1.41
--- src/daemon/common/commonSources.ml	21 Nov 2006 22:34:33 -0000	1.39
+++ src/daemon/common/commonSources.ml	3 Dec 2006 20:47:12 -0000	1.41
@@ -99,25 +99,25 @@
 let busy_sources_queue = 10
 
 let queue_name = [|
-    "new_sources";
-    "good_sources";
-    "ready_saved_sources";
-    "waiting_saved_sources";
-    "old_sources1";
-    "old_sources2";
-    "old_sources3";
-    "do_not_try_queue";
-    "connected_sources";
-    "connecting_sources";
-    "busy_sources";
-  |]
+  "new_sources";
+  "good_sources";
+  "ready_saved_sources";
+  "waiting_saved_sources";
+  "old_sources1";
+  "old_sources2";
+  "old_sources3";
+  "do_not_try_queue";
+  "connected_sources";
+  "connecting_sources";
+  "busy_sources";
+|]
 
 
 let nqueues = Array.length queue_name
 
 let queue_period = Array.create nqueues 600
 
-let _ =
+let () =
   queue_period.(new_sources_queue) <- 0;
   queue_period.(connected_sources_queue) <- 0;
   queue_period.(connecting_sources_queue) <- 0;
@@ -178,57 +178,57 @@
 (*                                                                       *)
 (*************************************************************************)
 
-      type source = {
-          source_uid : M.source_uid;
-          mutable source_files : file_request list;
+     type source = {
+       source_uid : M.source_uid;
+       mutable source_files : file_request list;
 
 (* the 'source_score' increases with failures in connections *)
-          mutable source_score : int;
+       mutable source_score : int;
 
 (* the 'source_num' that should be used to create the client corresponding to
   this source *)
-          mutable source_num : int;
+       mutable source_num : int;
 
 (* the 'source_age' is the time of the last successful connection *)
-          mutable source_age : int;
+       mutable source_age : int;
 
 (* the 'source_connecting' indicates that this source is currently in the
   process of being connected. *)
-          mutable source_last_attempt : int;
-          mutable source_sock : tcp_connection;
+       mutable source_last_attempt : int;
+       mutable source_sock : tcp_connection;
 
-          mutable source_brand : M.source_brand;
-        }
+       mutable source_brand : M.source_brand;
+     }
 
-      and file_request = {
-          request_file : file_sources_manager;
-          mutable request_queue : int;
-          mutable request_time : int;
-          mutable request_score : int;
-        }
-
-      and file_sources_manager = {
-          manager_uid : string;
-          mutable manager_sources : source Queues.Queue.t array;
-          mutable manager_active_sources : int;
-          mutable manager_all_sources : int;
-          mutable manager_file : (unit -> file);
-        }
-
-      and functions = {
-          mutable function_connect: (M.source_uid -> unit);
-          mutable function_query: (M.source_uid -> string -> unit);
-
-          mutable function_string_to_manager: (string -> file_sources_manager);
-
-          mutable function_max_connections_per_second : (unit -> int);
-          mutable function_max_sources_per_file : (unit -> int);
-
-          mutable function_add_location :
-          (M.source_uid -> string -> unit);
-          mutable function_remove_location :
-          (M.source_uid -> string -> unit);
-        }
+     and file_request = {
+       request_file : file_sources_manager;
+       mutable request_queue : int;
+       mutable request_time : int;
+       mutable request_score : int;
+     }
+
+     and file_sources_manager = {
+       manager_uid : string;
+       mutable manager_sources : source Queues.Queue.t array;
+       mutable manager_active_sources : int;
+       mutable manager_all_sources : int;
+       mutable manager_file : (unit -> file);
+     }
+	 
+     and functions = {
+       mutable function_connect: (M.source_uid -> unit);
+       mutable function_query: (M.source_uid -> string -> unit);
+       
+       mutable function_string_to_manager: (string -> file_sources_manager);
+       
+       mutable function_max_connections_per_second : (unit -> int);
+       mutable function_max_sources_per_file : (unit -> int);
+       
+       mutable function_add_location :
+         (M.source_uid -> string -> unit);
+       mutable function_remove_location :
+         (M.source_uid -> string -> unit);
+     }
 
 (*************************************************************************)
 (*                                                                       *)
@@ -236,24 +236,22 @@
 (*                                                                       *)
 (*************************************************************************)
 
-      module HS = Weak.Make(struct
-            type t = source
-            let hash s = Hashtbl.hash s.source_uid
-
-            let equal x y = x.source_uid = y.source_uid
-          end)
-
-      module H = Weak.Make(struct
-            type t = source
-            let hash s = Hashtbl.hash s.source_num
-
-            let equal x y = x.source_num = y.source_num
-          end)
-
-      module SourcesQueueCreate = Queues.Make(struct
-            type t = source
-            let compare s1 s2 = compare s1.source_uid s2.source_uid
-          end)
+     module HS = Weak.Make(struct
+       type t = source
+       let hash s = Hashtbl.hash s.source_uid
+       let equal x y = x.source_uid = y.source_uid
+     end)
+
+     module H = Weak.Make(struct
+       type t = source
+       let hash s = Hashtbl.hash s.source_num
+       let equal x y = x.source_num = y.source_num
+     end)
+
+     module SourcesQueueCreate = Queues.Make(struct
+       type t = source
+       let compare s1 s2 = compare s1.source_uid s2.source_uid
+     end)
 
 (*************************************************************************)
 (*                                                                       *)
@@ -261,40 +259,39 @@
 (*                                                                       *)
 (*************************************************************************)
 
-      let dummy_source = {
-          source_uid = M.dummy_source_uid;
-          source_files = [];
+     let dummy_source = {
+       source_uid = M.dummy_source_uid;
+       source_files = [];
+
+       source_num = 0;
+       source_score = 0;
+       source_age = 0;
+       source_last_attempt = 0;
+       source_sock = NoConnection;
+
+       source_brand = M.dummy_source_brand;
+     }
+
+     let last_refill = ref 0
+
+     let not_implemented s _ =
+       failwith (Printf.sprintf "CommonSources.%s not implemented" s)
+
+     let functions = {
+       function_connect = not_implemented "function_connect";
+       function_query = not_implemented "function_query";
+       function_string_to_manager = not_implemented
+         "function_string_to_manager";
+
+       function_max_connections_per_second = (fun _ ->
+						!!max_connections_per_second);
+       function_max_sources_per_file = (fun _ -> 10);
+
+       function_add_location = not_implemented "function_add_location";
+       function_remove_location = not_implemented "function_remove_location";
+     }
 
-          source_num = 0;
-          source_score = 0;
-          source_age = 0;
-          source_last_attempt = 0;
-          source_sock = NoConnection;
-
-          source_brand = M.dummy_source_brand;
-        }
-
-      let last_refill = ref 0
-
-      let not_implemented s _ =
-        failwith (Printf.sprintf "CommonSources.%s not implemented" s)
-
-      let functions = {
-          function_connect = not_implemented "function_connect";
-          function_query = not_implemented "function_query";
-          function_string_to_manager = not_implemented
-            "function_string_to_manager";
-
-          function_max_connections_per_second = (fun _ ->
-              !!max_connections_per_second);
-          function_max_sources_per_file = (fun _ -> 10);
-
-          function_add_location = not_implemented "function_add_location";
-          function_remove_location = not_implemented "function_remove_location";
-
-        }
-
-      let indirect_connections = ref 0
+     let indirect_connections = ref 0
 
 (*************************************************************************)
 (*                                                                       *)
@@ -302,19 +299,19 @@
 (*                                                                       *)
 (*************************************************************************)
 
-      let sources_by_uid = HS.create 13557
-      let sources_by_num = H.create 13557
-
-      let file_sources_managers = ref []
+     let sources_by_uid = HS.create 13557
+     let sources_by_num = H.create 13557
 
-      let connecting_sources = Fifo.create ()
+     let file_sources_managers = ref []
 
-      let next_direct_sources = Fifo.create ()
-      let next_indirect_sources = ref []
+     let connecting_sources = Fifo.create ()
 
+     let next_direct_sources = Fifo.create ()
+     let next_indirect_sources = ref []
+	
 
-      let active_queue q =
-        q >= connected_sources_queue && q <= busy_sources_queue
+     let active_queue q =
+       q >= connected_sources_queue && q <= busy_sources_queue
 
 (*************************************************************************)
 (*                                                                       *)
@@ -322,10 +319,10 @@
 (*                                                                       *)
 (*************************************************************************)
 
-      let request_score r = r.request_score
+     let request_score r = r.request_score
 
-      let set_score_part r score =
-        r.request_score <- score
+     let set_score_part r score =
+       r.request_score <- score
 
 
 (*************************************************************************)
@@ -334,20 +331,20 @@
 (*                                                                       *)
 (*************************************************************************)
 
-let rec find_throttled_queue queue =
-  if queue_period.(queue) > 0 || queue = old_sources3_queue then
-      queue
-  else
-      find_throttled_queue (queue + 1)
-
-let get_throttle_delay m q throttled =
-  if throttled then
-    (max 0    
-        (queue_period.(q) 
-          - (file_priority (m.manager_file ())) 
-          + Queue.length m.manager_sources.(connected_sources_queue))
-    )
-    else 0
+     let rec find_throttled_queue queue =
+       if queue_period.(queue) > 0 || queue = old_sources3_queue then
+	 queue
+       else
+	 find_throttled_queue (queue + 1)
+
+     let get_throttle_delay m q throttled =
+       if throttled then
+	 (max 0    
+            (queue_period.(q) 
+             - (file_priority (m.manager_file ())) 
+             + Queue.length m.manager_sources.(connected_sources_queue))
+	 )
+       else 0
   
 (*
  * determine the number of (throttled) ready sources for a manager queue
@@ -357,49 +354,45 @@
    But that function really needs to be fast.
    Also, this works because Queues are based on Sets, and that Set.iter
    gives elements in increasing keys order *)
-exception BreakOutOfLoop
+     exception BreakOutOfLoop
 
-let count_file_ready_sources m q throttled =
-  let ready_count = ref 0 in
-  let throttle_delay = get_throttle_delay m q throttled in
-  let ready_threshold = last_time () - !!min_reask_delay - throttle_delay in
-  (try
-    Queue.iter
-      (fun ( time, s ) ->
-        if time >= ready_threshold then
-	  raise BreakOutOfLoop;
-        incr ready_count
-      ) m.manager_sources.( q )
-  with BreakOutOfLoop -> ());
-  !ready_count
+     let count_file_ready_sources m q throttled =
+       let ready_count = ref 0 in
+       let throttle_delay = get_throttle_delay m q throttled in
+       let ready_threshold = 
+	 last_time () - !!min_reask_delay - throttle_delay in
+       (try
+	  Queue.iter
+	    (fun (time, s) ->
+               if time >= ready_threshold then raise BreakOutOfLoop;
+               incr ready_count
+	    ) m.manager_sources.(q)
+	with BreakOutOfLoop -> ());
+       !ready_count
 
 (*
  * determine the total number of ready sources for all downloading files per queue
  *)
-let count_ready_sources queue throttled =
-  let ready_count = ref 0 in
-  List.iter
-    (fun m ->
-      let f = m.manager_file () in
-      if file_state f = FileDownloading then
-        ready_count := !ready_count + count_file_ready_sources m queue throttled
-    ) !file_sources_managers;
-  !ready_count
-
-
-let rec find_max_overloaded q managers =
-  let current_max = ref (-1) in
-  let remaining_managers = ref [] in
-  List.iter
-    (fun m ->
-       let ready_sources = count_file_ready_sources m q true in
-       if ready_sources > !current_max then begin
-	 current_max := ready_sources;
-	 remaining_managers := [m]
-       end else if ready_sources = !current_max then
-	 remaining_managers := m :: !remaining_managers
-      ) managers;
-  !remaining_managers
+     let count_ready_sources queue throttled =
+       List.fold_left (fun ready_count m ->
+	    let f = m.manager_file () in
+	    if file_state f = FileDownloading then
+              ready_count + count_file_ready_sources m queue throttled
+	    else ready_count
+	 ) 0 !file_sources_managers
+
+
+     let rec find_max_overloaded q managers =
+       let _, remaining_managers =
+	 List.fold_left (fun ((current_max, remaining_managers) as acc) m ->
+	    let ready_sources = count_file_ready_sources m q true in
+	    if ready_sources > current_max then
+	      (ready_sources, [m])
+	    else if ready_sources = current_max then
+	      (current_max, m :: remaining_managers)
+	    else acc
+	 ) (-1, []) managers in
+       remaining_managers
 
 
 (*************************************************************************)
@@ -408,19 +401,20 @@
 (*                                                                       *)
 (*************************************************************************)
 
-      let print_source buf s =
-        Printf.bprintf buf "Source %d:\n" s.source_num;
-        Printf.bprintf buf "   score: %d\n" s.source_score;
-        if s.source_age <> 0 then
-          Printf.bprintf buf "   age: %d\n" s.source_age;
-        if s.source_last_attempt <> 0 then
-          Printf.bprintf buf "   last_attemps: %d" s.source_last_attempt;
-        List.iter (fun r ->
-            Printf.bprintf buf "     File %s\n" (file_best_name (r.request_file.manager_file ()));
-            Printf.bprintf buf "       Score: %d\n" r.request_score;
-            if r.request_time <> 0 then
-              Printf.bprintf buf "       Time: %d\n" r.request_time;
-        ) s.source_files
+     let print_source buf s =
+       Printf.bprintf buf "Source %d:\n" s.source_num;
+       Printf.bprintf buf "   score: %d\n" s.source_score;
+       if s.source_age <> 0 then
+         Printf.bprintf buf "   age: %d\n" s.source_age;
+       if s.source_last_attempt <> 0 then
+         Printf.bprintf buf "   last_attemps: %d" s.source_last_attempt;
+       List.iter (fun r ->
+         Printf.bprintf buf "     File %s\n" 
+	   (file_best_name (r.request_file.manager_file ()));
+         Printf.bprintf buf "       Score: %d\n" r.request_score;
+         if r.request_time <> 0 then
+           Printf.bprintf buf "       Time: %d\n" r.request_time;
+       ) s.source_files
 
 
 (*
@@ -429,33 +423,34 @@
  *
  *)
 
-    let need_new_sources file =
-        let ready_count = ref 0 in
-        for i = good_sources_queue to old_sources1_queue do
-          let lookin = file.manager_sources.( i ) in
-	  let ready_threshold = last_time () - !!min_reask_delay in
-          Queue.iter
-            (fun (time, s) ->
-              if time < ready_threshold then
-                incr ready_count
-            ) lookin
-        done;
-        (* let work_count = !ready_count +
-            (Queue.length ( file.manager_sources.( new_sources_queue ) )) +
-                (Queue.length ( file.manager_sources.( connected_sources_queue ) ))
-        in *)
-        let f = file.manager_file () in
-        (* lprintf "commonSources: need_new_source: ready= %d new= %d con= %d prio= %d %s\n"
-                !readyCount
-                (Queue.length ( file.manager_sources.( new_sources_queue ) ) )
-                (Queue.length ( file.manager_sources.( connected_sources_queue ) ) )
-                (file_priority f)
-                (if (file_priority f) + 20 > workCount then "we need" else "have enough");
-         *)
-        (* (file_priority f) + 20 > work_count *)
-        (* let max_s = functions.function_max_sources_per_file () in
-        (file_priority f)*(max_s/20) + max_s > !all_ready_s + new_s *)
-        (file_priority f) + 20 > !ready_count
+     let need_new_sources file =
+       let ready_threshold = last_time () - !!min_reask_delay in
+       let ready_count = ref 0 in
+       for i = good_sources_queue to old_sources1_queue do
+         let lookin = file.manager_sources.(i) in
+	 try
+           Queue.iter (fun (time, s) ->
+	      if time >= ready_threshold then raise BreakOutOfLoop;
+	      incr ready_count
+           ) lookin
+	 with BreakOutOfLoop -> ()
+       done;
+       (* let work_count = !ready_count +
+          (Queue.length ( file.manager_sources.( new_sources_queue ) )) +
+          (Queue.length ( file.manager_sources.( connected_sources_queue ) ))
+          in *)
+       let f = file.manager_file () in
+       (* lprintf "commonSources: need_new_source: ready= %d new= %d con= %d prio= %d %s\n"
+          !readyCount
+          (Queue.length ( file.manager_sources.( new_sources_queue ) ) )
+          (Queue.length ( file.manager_sources.( connected_sources_queue ) ) )
+          (file_priority f)
+          (if (file_priority f) + 20 > workCount then "we need" else "have enough");
+       *)
+       (* (file_priority f) + 20 > work_count *)
+       (* let max_s = functions.function_max_sources_per_file () in
+          (file_priority f)*(max_s/20) + max_s > !all_ready_s + new_s *)
+       (file_priority f) + 20 > !ready_count
 
 
 (*************************************************************************)
@@ -465,444 +460,405 @@
 (*************************************************************************)
 
 
-       let print buf output_type =
-        let pos_to_string v =
-          (if v > 0 then string_of_int(v) else "-")
-        in
-
-        html_mods_cntr_init();
-        let mycntr = ref 1 in
-
-        let html_tr () = begin
-              mycntr := html_mods_cntr();
-              Printf.bprintf buf "\\<tr class=\\\"dl-%d\\\"\\>" (!mycntr) 
-            end 
-        in
-        let html_tr_same () = Printf.bprintf buf "\\<tr class=\\\"dl-%d\\\"\\>" (!mycntr) in
-
-        (* Header *)
-        if output_type = HTML then
-          begin
-
-            let header = Printf.sprintf "File sources per manager queue (%d)" (List.length !file_sources_managers) in
-
-            Printf.bprintf buf "\\<div class=results\\>";
-            html_mods_table_header buf "sourcesTable" "sources" [];
-            Printf.bprintf buf "\\<tr\\>";
-            html_mods_td buf [
-              ("", "srh", "Statistics on sources ");
-              ("", "srh", "@ " ^ log_time ());
-              ("", "srh", header); ];
-            Printf.bprintf buf "\\</tr\\>\\</table\\>\\</div\\>\n";
-
-            html_mods_table_header buf "sourcesTable" "sources" [
-              ( "0", "srh br", "New sources", Printf.sprintf "New(%d)" new_sources_queue );
-              ( "0", "srh br", "Good sources", Printf.sprintf "Good(%d)" good_sources_queue );
-              ( "0", "srh br", "Ready saved sources", Printf.sprintf "Ready(%d)" ready_saved_sources_queue);
-              ( "0", "srh br", "Waiting saved sources", Printf.sprintf "Wait(%d)" waiting_saved_sources_queue);
-              ( "0", "srh br", "Old sources 1", Printf.sprintf "Old1(%d)" old_sources1_queue );
-              ( "0", "srh br", "Old sources 2", Printf.sprintf "Old2(%d)" old_sources2_queue );
-              ( "0", "srh br", "Old sources 3", Printf.sprintf "Old3(%d)" old_sources3_queue );
-              ( "0", "srh br", "Do not try sources", Printf.sprintf "nTry(%d)" do_not_try_queue );
-              ( "0", "srh br", "Connected sources", Printf.sprintf "Conn(%d)" connected_sources_queue );
-              ( "0", "srh br", "Connecting sources", Printf.sprintf "Cing(%d)" connecting_sources_queue );
-              ( "0", "srh br", "Busy sources", Printf.sprintf "Busy(%d)" busy_sources_queue );
-              ( "0", "srh br", "Total sources", "All" );
-              ( "0", "srh br", "Filename", "Name" ); ];
-          end
-        else
-          begin
-            Printf.bprintf buf "Statistics on sources: time %d\n" (last_time ());
-            Printf.bprintf buf "File sources per manager queue(%d):\n" (List.length !file_sources_managers);
-            Printf.bprintf buf "new  good redy wait old1 old2 old3 ntry conn cing busy all\n";
-                        (* "9999 9999 9999 9999 9999 9999 9999 9999 9999 9999 9999 9999"
-                           11*5 chars
-                           one row each: all,indirect,ready*)
-          end;
-
-        let nsources_per_queue = Array.create nqueues 0 in
-        let nready_per_queue = Array.create nqueues 0 in
-        let nindirect_per_queue = Array.create nqueues 0 in
-        let ninvalid_per_queue = Array.create nqueues 0 in
-        let nall = ref 0 in
-        let naact = ref 0 in
-        let naneed = ref 0 in
-        let my_file_sources_managers =
-          Sort.list
-            (fun f1 f2 ->
-              file_best_name (f1.manager_file ()) < file_best_name (f2.manager_file ())
-            ) (List.filter (fun m -> file_state (m.manager_file ()) = FileDownloading) !file_sources_managers)
-        in
-        (* Files *)
-        List.iter (fun m ->
-            let name = file_best_name (m.manager_file ()) in
-            if m.manager_all_sources <> 0 then
-              begin
-                let anready = ref 0 in
-                let antready = ref 0 in
-                let anindirect = ref 0 in
-                let aninvalid = ref 0 in
-                let slist = ref [] in
-                let sreadylist = ref [] in
-                let streadylist = ref [] in
-                let sindirectlist = ref [] in
-                let sinvalidlist = ref [] in
-                let sready = ref "" in
-                let stready = ref "" in
-                let sindirect = ref "" in
-                let sinvalid = ref "" in
-                (* Queues *)
-                for i = 0 to nqueues -1 do
-                  let q = m.manager_sources.(i) in
-                  if output_type = HTML then
-                      slist := !slist @ [
-                        ("", "sr ar br", (pos_to_string (Queue.length q))); ]
-                  else
-                      Printf.bprintf buf "%4d " (Queue.length q);
-
-                  let nready = ref 0 in
-                  let nindirect = ref 0 in
-                  let ninvalid = ref 0 in
-                  let nsources = ref 0 in
-		  let ready_threshold = last_time () - !!min_reask_delay in
-                  (* Sources *)
-                  Queue.iter (fun (time, s) ->
-                    incr nsources;
-                    if M.indirect_source s.source_uid then
-                      incr nindirect
-                    else if not (M.direct_source s.source_uid) then
-                           incr ninvalid;
-                    if time < ready_threshold then
-                      incr nready
-                    else if i = new_sources_queue then
-                      begin
-                        Printf.bprintf buf "ERROR: Source is not ready in new_sources_queue !\n";
-                        print_source buf s
-                      end
-                  ) q;
-
-                  if output_type = HTML then
-                    begin
-                      sreadylist := !sreadylist @ [
-                        ("", "sr ar br", (pos_to_string (Queue.length q))); ] ;
-                      streadylist := !streadylist @ [
-                        ("", "sr ar br", (pos_to_string (count_file_ready_sources m i true))); ] ;
-                      sindirectlist := !sindirectlist @ [
-                        ("", "sr ar br", (pos_to_string !nindirect)); ] ;
-                      sinvalidlist := !sinvalidlist @ [
-                        ("", "sr ar br", (pos_to_string !ninvalid)); ] ;
-                    end
-                  else
-                    begin
-                      sready := Printf.sprintf "%s%4d " !sready !nready;
-                      stready := Printf.sprintf "%s%4d " !stready (count_file_ready_sources m i true);
-                      sindirect := Printf.sprintf "%s%4d " !sindirect !nindirect;
-                      sinvalid := Printf.sprintf "%s%4d " !sinvalid !ninvalid
-                    end;
-
-                  anready := !anready + !nready;
-                  antready := !antready + (count_file_ready_sources m i true);
-                  anindirect := !anindirect + !nindirect;
-                  aninvalid := !aninvalid + !ninvalid;
-                  nready_per_queue.(i) <- nready_per_queue.(i) + !nready;
-                  nindirect_per_queue.(i) <- nindirect_per_queue.(i) + !nindirect;
-                  ninvalid_per_queue.(i) <- ninvalid_per_queue.(i) + !ninvalid;
-                  nsources_per_queue.(i) <- nsources_per_queue.(i) + !nsources;
-
-                done; (* end Queues *)
-
-                if output_type = HTML then
-                  begin
-                    html_tr ();
-                    html_mods_td buf (
-                      !slist  
-                      @ [ ("", "sr ar br", Printf.sprintf "%d" m.manager_all_sources); ]
-                      @ [ ("Filename", "sr", (shorten name !!max_name_len)); ] );
-
-                    Printf.bprintf buf "\\</tr\\>\n";
-
-                    html_tr_same ();
-                    html_mods_td buf (
-                      !sreadylist
-                      @ [ ("", "sr ar br", Printf.sprintf "%d" !anready); ]
-                      @ [ ("", "sr", ((Printf.sprintf "ready with %d active" m.manager_active_sources) 
-                          ^ (if file_state (m.manager_file ()) = FileDownloading 
-                                && need_new_sources m then
-                          begin
-                            incr naneed;
-                            " and needs sources"
-                          end
-                            else "")  
-                          )); 
-                        ] 
-                    );
-                    Printf.bprintf buf "\\</tr\\>\n";
-
-                    html_tr_same ();
-
-                    html_mods_td buf (
-                      !streadylist 
-                      @ [ ("", "sr ar br", Printf.sprintf "%d" !antready); ]
-                      @ [("", "sr", "throttled ready"); ]
-                    );
-
-                    Printf.bprintf buf "\\</tr\\>\n";
-
-                    (if !anindirect <> 0 then
-                      begin
-                        html_tr_same ();
-                        html_mods_td buf (
-                          !sindirectlist 
-                          @ [ ("", "sr ar br", Printf.sprintf "%d" !anindirect); ]
-                          @ [ ("", "sr", "indirect"); ]
-                        );
-                        Printf.bprintf buf "\\</tr\\>\n";
-                      end
-                    );
-
-                    (if !aninvalid <> 0 then
-                      begin
-                        html_tr_same ();
-                        html_mods_td buf (
-                          !sinvalidlist 
-                          @ [ ("", "sr ar br", Printf.sprintf "%d" !aninvalid); ]
-                          @ [ ("", "sr", "invalid"); ]
-                        );
-                        Printf.bprintf buf "\\</tr\\>\n";
-                      end
-                    );
-                  end
-                else
-                  begin
-                    Printf.bprintf buf "%4d %s\n" m.manager_all_sources name;
-                    Printf.bprintf buf "%s%4d     ready  %d active%s\n" !sready !anready m.manager_active_sources
-                        (if file_state (m.manager_file ()) = FileDownloading && need_new_sources m then
-                           begin
-                             incr naneed;
-                             "  needs sources"
-                           end
-                         else
-                             ""
-                        );
-                    Printf.bprintf buf "%s%4d     throttled ready\n" !stready !antready;
-                    if !anindirect <> 0 then
-                      Printf.bprintf buf "%s%4d     indirect\n" !sindirect !anindirect;
-                    if !aninvalid <> 0 then
-                      Printf.bprintf buf "%s%4d     invalid\n" !sinvalid !aninvalid;
-                  end;
-
-                nall := !nall + m.manager_all_sources;
-                naact := !naact + m.manager_active_sources;
-              end
-            else
-              begin
-
-                if output_type = HTML then
-                  begin
-                    html_tr ();
-
-                    html_mods_td buf [
-                        ("", "sr ar br", "-"); ("", "sr ar br", ""); ("", "sr ar br", "");
-                        ("", "sr ar br", ""); ("", "sr ar br", ""); ("", "sr ar br", "");
-                        ("", "sr ar br", ""); ("", "sr ar br", ""); ("", "sr ar br", "");
-                        ("", "sr ar br", ""); ("", "sr ar br", ""); ("", "sr ar br", "");
-                        ("", "sr br", (shorten name !!max_name_len));
-                      ];
-                    Printf.bprintf buf "\\</tr\\>\n";
-                  end
-                else
-                  Printf.bprintf buf "None %55s%s\n" ("") name;
-                if file_state (m.manager_file ()) = FileDownloading && need_new_sources m then
-                  incr naneed;
-              end
-        ) my_file_sources_managers; (* end Files *)
-
-        (* next Header *)
-        if output_type = HTML then
-          begin
-            Printf.bprintf buf "\\</table\\>\\</div\\>\n";
-
-            html_mods_table_header buf "sourcesTable" "sources" [
-              ( "0", "srh", "New sources", "New" );
-              ( "0", "srh", "Good sources", "Good" );
-              ( "0", "srh", "Ready sources", "Ready" );
-              ( "0", "srh", "Waiting sources", "Wait" );
-              ( "0", "srh", "Old sources 1", "Old1" );
-              ( "0", "srh", "Old sources 2", "Old2" );
-              ( "0", "srh", "Old sources 3", "Old3" );
-              ( "0", "srh", "Do not try", "nTry" );
-              ( "0", "srh", "Connected sources", "Conn" );
-              ( "0", "srh", "Connecting sources", "Cing" );
-              ( "0", "srh", "Busy sources", "Busy" );
-              ( "0", "srh", "Total sources", "All" );
-              ( "0", "srh", "Type", "Type" ); ];
-
-          end
-        else
-          Printf.bprintf buf "new  good redy wait old1 old2 old3 ntry conn cing busy all\n";
-
-        let slist = ref [] in
-        let sreadylist = ref [] in
-        let streadylist = ref [] in
-        let sindirectlist = ref [] in
-        let sinvalidlist = ref [] in
-        let speriodlist = ref [] in
-        let sready = ref "" in
-        let stready = ref "" in
-        let sindirect = ref "" in
-        let sinvalid = ref "" in
-        let speriod = ref "" in
-        let anready = ref 0 in
-        let antready = ref 0 in
-        let anindirect = ref 0 in
-        let aninvalid = ref 0 in
-        (* Queues *)
-        for i = 0 to nqueues - 1 do
-          if output_type = HTML then
-            begin
-              slist := !slist @ [
-                ("", "sr ar", (pos_to_string nsources_per_queue.(i))); ] ;
-              sreadylist := !sreadylist @ [
-                ("", "sr ar", (pos_to_string nready_per_queue.(i))); ] ;
-              anready := !anready + nready_per_queue.(i);
-              streadylist := !streadylist @ [
-                ("", "sr ar", (pos_to_string (count_ready_sources i true))); ] ;
-              antready := !antready + (count_ready_sources i true);
-              sindirectlist := !sindirectlist @ [
-                ("", "sr ar", (pos_to_string nindirect_per_queue.(i))); ] ;
-              anindirect := !anindirect + nindirect_per_queue.(i);
-              sinvalidlist := !sinvalidlist @ [
-                ("", "sr ar", (pos_to_string ninvalid_per_queue.(i))); ] ;
-              aninvalid := !aninvalid + ninvalid_per_queue.(i);
-              speriodlist := !speriodlist @ [
-                ("", "sr ar", (pos_to_string queue_period.(i))); ] ;
-            end
-          else
-            begin
-              Printf.bprintf buf "%4d " nsources_per_queue.(i);
-              sready := Printf.sprintf "%s%4d " !sready nready_per_queue.(i);
-              anready := !anready + nready_per_queue.(i);
-              stready := Printf.sprintf "%s%4d " !stready (count_ready_sources i true);
-              antready := !antready + (count_ready_sources i true);
-              sindirect := Printf.sprintf "%s%4d " !sindirect nindirect_per_queue.(i);
-              anindirect := !anindirect + nindirect_per_queue.(i);
-              sinvalid := Printf.sprintf "%s%4d " !sinvalid ninvalid_per_queue.(i);
-              aninvalid := !aninvalid + ninvalid_per_queue.(i);
-              speriod := Printf.sprintf "%s%4d " !speriod queue_period.(i);
-            end;
-        done; (* end Queues *)
-
-        let nsources = ref 0 in
-        let nroq = ref 0 in
-        HS.iter (fun s ->
-          incr nsources;
-          List.iter (fun r ->
-            if r.request_queue = outside_queue then
-              incr nroq;
-          ) s.source_files;
-        ) sources_by_uid;
-
-        if output_type = HTML then
-          begin
-            html_tr();
-            html_mods_td buf (
-              !slist 
-              @ [ ("", "sr ar", Printf.sprintf "%d" !nall); ]
-              @ [("", "sr", Printf.sprintf "all source managers (%d by UID) (%d ROQ)" !nsources !nroq);]
-            );
-            Printf.bprintf buf "\\</tr\\>\n";
-
-            html_tr ();
-            html_mods_td buf (
-              !sreadylist
-              @ [ ("", "sr ar", Printf.sprintf "%d" !anready); ]
-              @ [ ("", "sr", Printf.sprintf "ready with %d active and %i need sources" !naact !naneed); ]
-            );
-            Printf.bprintf buf "\\</tr\\>\n";
-
-            html_tr();
-            html_mods_td buf (
-              !streadylist
-              @ [ ("", "sr ar", Printf.sprintf "%d" !antready); ]
-              @ [ ("", "sr", "throttled ready"); ]
-            );
-            Printf.bprintf buf "\\</tr\\>\n";
-
-            (if !anindirect <> 0 then
-              begin
-                html_tr ();
-                html_mods_td buf (
-                  !sindirectlist
-                  @ [ ("", "sr ar", Printf.sprintf "%d" !anindirect); ]
-                  @ [ ("", "sr", "indirect"); ]
-                );
-                Printf.bprintf buf "\\</tr\\>\n";
-              end
-            );
-
-            (if !aninvalid <> 0 then
-              begin
-                html_tr ();
-                html_mods_td buf (
-                  !sinvalidlist
-                  @ [ ("", "sr ar", Printf.sprintf "%d" !aninvalid); ]
-                  @ [ ("", "sr", "invalid"); ]
-                );
-                Printf.bprintf buf "\\</tr\\>\n";
-              end
-            );
-
-            html_tr ();
-            html_mods_td buf (
-              !speriodlist 
-              @ [ ("", "sr", "") ]
-              @ [("", "sr", "period"); ]
-            );
-            Printf.bprintf buf "\\</tr\\>\n";
-
-            Printf.bprintf buf "\\</table\\>\\</div\\>\n";
-          end
-        else
-          begin
-            Printf.bprintf buf "%4d all source managers (%d by UID) (%d ROQ)\n" !nall !nsources !nroq;
-            Printf.bprintf buf "%s%4d     ready  %d active  %i need sources\n" !sready !anready !naact !naneed;
-            Printf.bprintf buf "%s%4d     throttled ready\n" !stready !antready;
-            if !anindirect <> 0 then
-              Printf.bprintf buf "%s%4d     indirect\n" !sindirect !anindirect;
-            if !aninvalid <> 0 then
-              Printf.bprintf buf "%s%4d     invalid\n" !sinvalid !aninvalid;
-            Printf.bprintf buf "%s     period\n" !speriod;
-          end;
-        let nconnected = ref 0 in
-        Fifo.iter
-          (fun (_,s) ->
-            if s.source_last_attempt = 0 then incr nconnected;
-          ) connecting_sources;
-        if output_type = HTML then
-          begin
-            html_mods_table_header buf "sourcesTable" "sources" [
-              ( "0", "srh", "Connecting sources", "Connecting sources" );
-              ( "0", "srh", "Next direct sources", "Next direct sources" );
-              ( "0", "srh", "Next indirect sources", "Next indirect sources" ); ];
-            Printf.bprintf buf "\\<tr class=\\\"dl-1\\\"\\>";
-            html_mods_td buf [
-              ("", "sr", (Printf.sprintf "%d entries" (Fifo.length connecting_sources)) ^
-                (if !nconnected > 0 then Printf.sprintf " (connected: %d)" !nconnected else ("")));
-              ("", "sr", Printf.sprintf "%d entries" (Fifo.length next_direct_sources));
-              ("", "sr", Printf.sprintf "%d entries" (List.length !next_indirect_sources)); ];
-            Printf.bprintf buf "\\</tr\\>\\</table\\>\\</div\\>\n\\</div\\>"
-          end
-        else
-          begin
-            Printf.bprintf buf "Connecting Sources: %d entries"
-              (Fifo.length connecting_sources);
-            if !nconnected > 0 then Printf.bprintf buf " (connected: %d)" !nconnected;
-            Printf.bprintf buf "\n";
-            Printf.bprintf buf "Next Direct Sources: %d entries\n"
-              (Fifo.length next_direct_sources);
-            Printf.bprintf buf "Next Indirect Sources: %d entries\n"
-              (List.length !next_indirect_sources)
-          end
+     let print buf output_type =
+       let pos_to_string v =
+          if v > 0 then string_of_int v else "-" in
+
+       html_mods_cntr_init ();
+       let mycntr = ref 1 in
+
+       let html_tr () =
+         mycntr := html_mods_cntr ();
+         Printf.bprintf buf "\\<tr class=\\\"dl-%d\\\"\\>" !mycntr in
+
+       let html_tr_same () = 
+	 Printf.bprintf buf "\\<tr class=\\\"dl-%d\\\"\\>" !mycntr in
+
+       (* Header *)
+       if output_type = HTML then
+         let header = Printf.sprintf "File sources per manager queue (%d)" 
+	   (List.length !file_sources_managers) in
+	 
+         Printf.bprintf buf "\\<div class=results\\>";
+         html_mods_table_header buf "sourcesTable" "sources" [];
+         Printf.bprintf buf "\\<tr\\>";
+         html_mods_td buf [
+           ("", "srh", "Statistics on sources ");
+           ("", "srh", "@ " ^ log_time ());
+           ("", "srh", header); ];
+         Printf.bprintf buf "\\</tr\\>\\</table\\>\\</div\\>\n";
+	 
+         html_mods_table_header buf "sourcesTable" "sources" [
+           ( "0", "srh br", "New sources", 
+	     Printf.sprintf "New(%d)" new_sources_queue );
+           ( "0", "srh br", "Good sources", 
+	     Printf.sprintf "Good(%d)" good_sources_queue );
+           ( "0", "srh br", "Ready saved sources", 
+	     Printf.sprintf "Ready(%d)" ready_saved_sources_queue);
+           ( "0", "srh br", "Waiting saved sources", 
+	     Printf.sprintf "Wait(%d)" waiting_saved_sources_queue);
+           ( "0", "srh br", "Old sources 1", 
+	     Printf.sprintf "Old1(%d)" old_sources1_queue );
+           ( "0", "srh br", "Old sources 2", 
+	     Printf.sprintf "Old2(%d)" old_sources2_queue );
+           ( "0", "srh br", "Old sources 3", 
+	     Printf.sprintf "Old3(%d)" old_sources3_queue );
+           ( "0", "srh br", "Do not try sources", 
+	     Printf.sprintf "nTry(%d)" do_not_try_queue );
+           ( "0", "srh br", "Connected sources", 
+	     Printf.sprintf "Conn(%d)" connected_sources_queue );
+           ( "0", "srh br", "Connecting sources", 
+	     Printf.sprintf "Cing(%d)" connecting_sources_queue );
+           ( "0", "srh br", "Busy sources", 
+	     Printf.sprintf "Busy(%d)" busy_sources_queue );
+           ( "0", "srh br", "Total sources", "All" );
+           ( "0", "srh br", "Filename", "Name" ); ];
+       else begin
+         Printf.bprintf buf "Statistics on sources: time %d\n" (last_time ());
+         Printf.bprintf buf "File sources per manager queue(%d):\n" 
+	   (List.length !file_sources_managers);
+         Printf.bprintf buf "new  good redy wait old1 old2 old3 ntry conn cing busy all\n";
+         (* "9999 9999 9999 9999 9999 9999 9999 9999 9999 9999 9999 9999"
+            11*5 chars
+            one row each: all,indirect,ready *)
+       end;
+
+       let list_sum = List.fold_left (+) 0 in
+
+       let nsources_per_queue = Array.create nqueues 0 in
+       let nready_per_queue = Array.create nqueues 0 in
+       let nindirect_per_queue = Array.create nqueues 0 in
+       let ninvalid_per_queue = Array.create nqueues 0 in
+       let nall = ref 0 in
+       let naact = ref 0 in
+       let naneed = ref 0 in
+       let downloading_managers = 
+	 List.filter (fun m -> 
+	   file_state (m.manager_file ()) = FileDownloading
+	 ) !file_sources_managers in
+       let my_file_sources_managers =
+         List.sort (fun f1 f2 ->
+	   let best_name1 = file_best_name (f1.manager_file ()) in
+	   let best_name2 = file_best_name (f2.manager_file ()) in
+           String.compare best_name1 best_name2
+         ) downloading_managers in
+       (* Files *)
+       let ready_threshold = last_time () - !!min_reask_delay in
+       List.iter (fun m ->
+         let name = file_best_name (m.manager_file ()) in
+	 let need_sources = need_new_sources m in
+	 if need_sources then incr naneed;
+
+         if m.manager_all_sources <> 0 then begin
+           let slist = ref [] in
+           let sreadylist = ref [] in
+           let streadylist = ref [] in
+           let sindirectlist = ref [] in
+           let sinvalidlist = ref [] in
+           (* Queues *)
+	   Array.iteri (fun i q ->
+             let nready = ref 0 in
+	     let ntready = count_file_ready_sources m i true in
+             let nindirect = ref 0 in
+             let ninvalid = ref 0 in
+             let nsources = ref 0 in
+             (* Sources *)
+             Queue.iter (fun (time, s) ->
+               incr nsources;
+               if M.indirect_source s.source_uid then incr nindirect
+               else if not (M.direct_source s.source_uid) then incr ninvalid;
+               if time < ready_threshold then incr nready
+               else if i = new_sources_queue then begin
+                 Printf.bprintf buf "ERROR: Source is not ready in new_sources_queue !\n";
+                 print_source buf s
+               end
+	     ) q;
+
+	     slist := Queue.length q :: !slist;
+             sreadylist := !nready :: !sreadylist;
+	     streadylist := ntready :: !streadylist;
+	     sindirectlist := !nindirect :: !sindirectlist;
+	     sinvalidlist := !ninvalid :: !sinvalidlist;
+
+             nready_per_queue.(i) <- nready_per_queue.(i) + !nready;
+             nindirect_per_queue.(i) <- nindirect_per_queue.(i) + !nindirect;
+             ninvalid_per_queue.(i) <- ninvalid_per_queue.(i) + !ninvalid;
+             nsources_per_queue.(i) <- nsources_per_queue.(i) + !nsources;
+           ) m.manager_sources; (* end Queues *)
+
+	   let slist = List.rev !slist in
+	   let sreadylist = List.rev !sreadylist in
+	   let streadylist = List.rev !streadylist in
+	   let sindirectlist = List.rev !sindirectlist in
+	   let sinvalidlist = List.rev !sinvalidlist in
+
+           if output_type = HTML then begin
+             html_tr ();
+             html_mods_td buf (
+               (List.map (fun qlength -> 
+		  ("", "sr ar br", pos_to_string qlength)) slist) @
+		 [ ("", "sr ar br", string_of_int m.manager_all_sources);
+                   ("Filename", "sr", shorten name !!max_name_len); ] );
+
+             Printf.bprintf buf "\\</tr\\>\n";
+
+             html_tr_same ();
+             html_mods_td buf (
+	       (List.map (fun sready -> 
+		 ("", "sr ar br", pos_to_string sready)) sreadylist) @
+		 [ ("", "sr ar br", Printf.sprintf "%d" (list_sum sreadylist));
+                   ("", "sr", Printf.sprintf "ready with %d active%s" 
+		      m.manager_active_sources
+                      (if need_sources then " and needs sources"
+                       else "")) ] );
+	     Printf.bprintf buf "\\</tr\\>\n";
+
+             html_tr_same ();
+             html_mods_td buf (
+	       (List.map (fun sready ->
+		  ("", "sr ar br", pos_to_string sready)) streadylist) @
+		 [ ("", "sr ar br", string_of_int (list_sum streadylist)); 
+		   ("", "sr", "throttled ready"); ] );
+             Printf.bprintf buf "\\</tr\\>\n";
+
+	     let anindirect = list_sum sindirectlist in
+             if anindirect <> 0 then begin
+	       html_tr_same ();
+	       html_mods_td buf (
+		 (List.map (fun sready ->
+		    ("", "sr ar br", pos_to_string sready)) sindirectlist) @
+                   [ ("", "sr ar br", string_of_int anindirect); 
+                     ("", "sr", "indirect"); ] );
+	       Printf.bprintf buf "\\</tr\\>\n";
+             end;
+
+	     let aninvalid = list_sum sinvalidlist in
+             if aninvalid <> 0 then begin
+               html_tr_same ();
+               html_mods_td buf (
+		 (List.map (fun sready ->
+		    ("", "sr ar br", pos_to_string sready)) sinvalidlist) @
+                   [ ("", "sr ar br", string_of_int aninvalid);
+                     ("", "sr", "invalid"); ] );
+               Printf.bprintf buf "\\</tr\\>\n";
+             end;
+           end
+           else begin
+	     List.iter (Printf.bprintf buf "%4d ") slist;
+             Printf.bprintf buf "%4d %s\n" m.manager_all_sources name;
+	     List.iter (Printf.bprintf buf "%4d ") sreadylist;
+             Printf.bprintf buf "%4d     ready  %d active%s\n" 
+	       (list_sum sreadylist) m.manager_active_sources
+               (if need_sources then "  needs sources"
+                else "");
+	     List.iter (Printf.bprintf buf "%4d ") streadylist;
+             Printf.bprintf buf "%4d     throttled ready\n" 
+	       (list_sum streadylist);
+	     let anindirect = list_sum sindirectlist in
+             if anindirect <> 0 then begin
+	       List.iter (Printf.bprintf buf "%4d ") sindirectlist;
+               Printf.bprintf buf "%4d     indirect\n" anindirect;
+	     end;
+	     let aninvalid = list_sum sinvalidlist in
+             if aninvalid <> 0 then begin
+	       List.iter (Printf.bprintf buf "%4d ") sinvalidlist;
+               Printf.bprintf buf "%4d     invalid\n" aninvalid;
+	     end
+           end;
+
+           nall := !nall + m.manager_all_sources;
+           naact := !naact + m.manager_active_sources;
+         end
+         else begin (* m.manager_all_sources = 0 *)
+           if output_type = HTML then begin
+             html_tr ();
+
+             html_mods_td buf [
+               ("", "sr ar br", "-"); ("", "sr ar br", ""); 
+	       ("", "sr ar br", ""); ("", "sr ar br", ""); 
+	       ("", "sr ar br", ""); ("", "sr ar br", "");
+               ("", "sr ar br", ""); ("", "sr ar br", ""); 
+	       ("", "sr ar br", ""); ("", "sr ar br", ""); 
+	       ("", "sr ar br", ""); ("", "sr ar br", "");
+               ("", "sr br", shorten name !!max_name_len); ];
+             Printf.bprintf buf "\\</tr\\>\n";
+           end
+           else Printf.bprintf buf "None %55s%s\n" "" name;
+         end
+       ) my_file_sources_managers; (* end Files *)
+
+       (* next Header *)
+       if output_type = HTML then begin
+         Printf.bprintf buf "\\</table\\>\\</div\\>\n";
+
+         html_mods_table_header buf "sourcesTable" "sources" [
+           ( "0", "srh", "New sources", "New" );
+           ( "0", "srh", "Good sources", "Good" );
+           ( "0", "srh", "Ready sources", "Ready" );
+           ( "0", "srh", "Waiting sources", "Wait" );
+           ( "0", "srh", "Old sources 1", "Old1" );
+           ( "0", "srh", "Old sources 2", "Old2" );
+           ( "0", "srh", "Old sources 3", "Old3" );
+           ( "0", "srh", "Do not try", "nTry" );
+           ( "0", "srh", "Connected sources", "Conn" );
+           ( "0", "srh", "Connecting sources", "Cing" );
+           ( "0", "srh", "Busy sources", "Busy" );
+           ( "0", "srh", "Total sources", "All" );
+           ( "0", "srh", "Type", "Type" ); ];
+
+       end
+       else
+         Printf.bprintf buf "new  good redy wait old1 old2 old3 ntry conn cing busy all\n";
+
+       let slist = ref [] in
+       let sreadylist = ref [] in
+       let streadylist = ref [] in
+       let sindirectlist = ref [] in
+       let sinvalidlist = ref [] in
+       let speriodlist = ref [] in
+       (* Queues *)
+       for i = 0 to nqueues - 1 do
+	 slist := nsources_per_queue.(i) :: !slist;
+	 sreadylist := nready_per_queue.(i) :: !sreadylist;
+	 streadylist := count_ready_sources i true :: !streadylist;
+	 sindirectlist := nindirect_per_queue.(i) :: !sindirectlist;
+	 sinvalidlist := ninvalid_per_queue.(i) :: !sinvalidlist;
+	 speriodlist := queue_period.(i) :: !speriodlist;
+       done; (* end Queues *)
+
+       let nsources = ref 0 in
+       let nroq = ref 0 in
+       HS.iter (fun s ->
+         incr nsources;
+         List.iter (fun r ->
+           if r.request_queue = outside_queue then
+             incr nroq;
+         ) s.source_files;
+       ) sources_by_uid;
+
+       let slist = List.rev !slist in
+       let sreadylist = List.rev !sreadylist in
+       let streadylist = List.rev !streadylist in
+       let sindirectlist = List.rev !sindirectlist in
+       let sinvalidlist = List.rev !sinvalidlist in
+       let speriodlist = List.rev !speriodlist in
+
+       if output_type = HTML then begin
+         html_tr ();
+         html_mods_td buf (
+           (List.map (fun q ->
+	     ("", "sr ar", pos_to_string q)) slist) @
+             [ ("", "sr ar", Printf.sprintf "%d" !nall); 
+               ("", "sr", 
+		Printf.sprintf "all source managers (%d by UID) (%d ROQ)" 
+		  !nsources !nroq);] );
+         Printf.bprintf buf "\\</tr\\>\n";
+
+         html_tr ();
+         html_mods_td buf (
+	   (List.map (fun sready ->
+	     ("", "sr ar", pos_to_string sready)) sreadylist) @
+             [ ("", "sr ar", Printf.sprintf "%d" (list_sum sreadylist)); 
+               ("", "sr", 
+		Printf.sprintf "ready with %d active and %i need sources" 
+		  !naact !naneed); ] );
+         Printf.bprintf buf "\\</tr\\>\n";
+
+         html_tr ();
+         html_mods_td buf (
+	   (List.map (fun sready ->
+	     ("", "sr ar", pos_to_string sready)) streadylist) @
+           [ ("", "sr ar", Printf.sprintf "%d" (list_sum streadylist)); 
+             ("", "sr", "throttled ready"); ] );
+         Printf.bprintf buf "\\</tr\\>\n";
+
+	 let anindirect = list_sum sindirectlist in
+         if anindirect <> 0 then begin
+           html_tr ();
+           html_mods_td buf (
+             (List.map (fun sready ->
+	       ("", "sr ar", pos_to_string sready)) sindirectlist) @
+             [ ("", "sr ar", Printf.sprintf "%d" anindirect); 
+               ("", "sr", "indirect"); ] );
+           Printf.bprintf buf "\\</tr\\>\n";
+         end;
+
+	 let aninvalid = list_sum sinvalidlist in
+         if aninvalid <> 0 then begin
+           html_tr ();
+           html_mods_td buf (
+             (List.map (fun sready ->
+	       ("", "sr ar", pos_to_string sready)) sinvalidlist) @
+               [ ("", "sr ar", Printf.sprintf "%d" aninvalid); 
+                 ("", "sr", "invalid"); ] );
+           Printf.bprintf buf "\\</tr\\>\n";
+         end;
+
+         html_tr ();
+         html_mods_td buf (
+           (List.map (fun sready ->
+	     ("", "sr ar", pos_to_string sready)) speriodlist) @
+            [ ("", "sr", "");
+              ("", "sr", "period"); ] );
+         Printf.bprintf buf "\\</tr\\>\n";
+
+         Printf.bprintf buf "\\</table\\>\\</div\\>\n";
+       end
+       else begin
+	 List.iter (Printf.bprintf buf "%4d ") slist;
+         Printf.bprintf buf "%4d all source managers (%d by UID) (%d ROQ)\n" 
+	   !nall !nsources !nroq;
+	 List.iter (Printf.bprintf buf "%4d ") sreadylist;
+         Printf.bprintf buf "%4d     ready  %d active  %i need sources\n" 
+	   (list_sum sreadylist) !naact !naneed;
+	 List.iter (Printf.bprintf buf "%4d ") streadylist;
+         Printf.bprintf buf "%4d     throttled ready\n" (list_sum streadylist);
+	 let anindirect = list_sum sindirectlist in
+         if anindirect <> 0 then begin
+	   List.iter (Printf.bprintf buf "%4d ") sindirectlist;
+           Printf.bprintf buf "%4d     indirect\n" anindirect;
+	 end;
+	 let aninvalid = list_sum sinvalidlist in
+         if aninvalid <> 0 then begin
+	   List.iter (Printf.bprintf buf "%4d ") sinvalidlist;
+           Printf.bprintf buf "%4d     invalid\n" aninvalid;
+	 end;
+	 List.iter (Printf.bprintf buf "%4d ") speriodlist;
+         Printf.bprintf buf "     period\n";
+       end;
+
+       let nconnected = ref 0 in
+       Fifo.iter (fun (_, s) ->
+         if s.source_last_attempt = 0 then incr nconnected;
+       ) connecting_sources;
+       if output_type = HTML then begin
+         html_mods_table_header buf "sourcesTable" "sources" [
+           ( "0", "srh", "Connecting sources", "Connecting sources" );
+           ( "0", "srh", "Next direct sources", "Next direct sources" );
+           ( "0", "srh", "Next indirect sources", "Next indirect sources" ); ];
+         Printf.bprintf buf "\\<tr class=\\\"dl-1\\\"\\>";
+         html_mods_td buf [
+           ("", "sr", (Printf.sprintf "%d entries" 
+			 (Fifo.length connecting_sources)) ^
+              (if !nconnected > 0 then 
+		 Printf.sprintf " (connected: %d)" !nconnected else ""));
+           ("", "sr", Printf.sprintf "%d entries" 
+	      (Fifo.length next_direct_sources));
+           ("", "sr", Printf.sprintf "%d entries" 
+	      (List.length !next_indirect_sources)); ];
+         Printf.bprintf buf "\\</tr\\>\\</table\\>\\</div\\>\n\\</div\\>"
+       end
+       else begin
+         Printf.bprintf buf "Connecting Sources: %d entries"
+           (Fifo.length connecting_sources);
+         if !nconnected > 0 then 
+	   Printf.bprintf buf " (connected: %d)" !nconnected;
+         Printf.bprintf buf "\n";
+         Printf.bprintf buf "Next Direct Sources: %d entries\n"
+           (Fifo.length next_direct_sources);
+         Printf.bprintf buf "Next Indirect Sources: %d entries\n"
+           (List.length !next_indirect_sources)
+       end
 
 
 (*************************************************************************)
@@ -911,55 +867,41 @@
 (*                                                                       *)
 (*************************************************************************)
 
-      let reschedule_source_for_file saved s r =
-        if r.request_queue = outside_queue then
-          let queue =
-            if r.request_score = not_found_score then
-              do_not_try_queue
-            else if s.source_last_attempt <> 0 then
-              connecting_sources_queue
-            else
-              match s.source_sock with
-              | (NoConnection | ConnectionWaiting _)  ->
-                (* State (1) *)
-                  (* Two things matter: the global score and the local score *)
-                  if s.source_score < 1 then
-                    (* 2.5.25, replaced expected_score by
-                       found_score, so that sources which
-                       only have the file are not put in
-                       good_sources_queue, unless they have
-                       an interesting chunk AND not a bad
-                       rank. *)
-                    if r.request_score > found_score then
-                      if saved then
-                        if
-                          r.request_time + !!min_reask_delay < last_time ()
-                        then
-                          ready_saved_sources_queue
-                        else
-                          waiting_saved_sources_queue
-                      else
-                        if r.request_score = initial_new_source_score then
-                          new_sources_queue
-                        else
-                          good_sources_queue
-                    else
-                      if r.request_score >= new_source_score then 
-                        old_sources1_queue
-                      else
-                        old_sources2_queue
-                  else
-                    if s.source_score < 5 then
-                      old_sources3_queue
-                    else
-                      do_not_try_queue
-
-              | Connection _ ->
-                (* State (3) *)
-                  if r.request_time = 0 then
-                    busy_sources_queue
-                  else
-                    connected_sources_queue
+     let reschedule_source_for_file saved s r =
+       if r.request_queue = outside_queue then
+         let queue =
+           if r.request_score = not_found_score then do_not_try_queue
+           else if s.source_last_attempt <> 0 then connecting_sources_queue
+           else
+             match s.source_sock with
+             | (NoConnection | ConnectionWaiting _)  ->
+                 (* State (1) *)
+                 (* Two things matter: the global score and the local score *)
+                 if s.source_score < 1 then
+                   (* 2.5.25, replaced expected_score by
+                      found_score, so that sources which
+                      only have the file are not put in
+                      good_sources_queue, unless they have
+                      an interesting chunk AND not a bad
+                      rank. *)
+                   if r.request_score > found_score then
+                     if saved then
+                       if r.request_time + !!min_reask_delay < last_time () then
+                         ready_saved_sources_queue
+                       else waiting_saved_sources_queue
+                     else if r.request_score = initial_new_source_score then
+                       new_sources_queue
+                     else good_sources_queue
+                   else if r.request_score >= new_source_score then 
+                     old_sources1_queue
+                   else old_sources2_queue
+                 else if s.source_score < 5 then old_sources3_queue
+                 else do_not_try_queue
+
+             | Connection _ ->
+                 (* State (3) *)
+                 if r.request_time = 0 then busy_sources_queue
+                 else connected_sources_queue
             in
             let m = r.request_file in
             if !verbose_sources > 1 then
@@ -977,18 +919,18 @@
 (*                                                                       *)
 (*************************************************************************)
 
-      let iter_all_sources f m =
-        Array.iter (fun q ->
-            Queue.iter (fun (_,s) -> f s)  q
-        ) m.manager_sources
+     let iter_all_sources f m =
+       Array.iter (fun q ->
+         Queue.iter (fun (_, s) -> f s) q
+       ) m.manager_sources
 
 (*************************************************************************)
 (*                         iter_qualified_sources                        *)
 (*            Only these sources should be used in sourceexchage         *)
 (*************************************************************************)
-      let iter_qualified_sources f m =
-          let q = m.manager_sources.(good_sources_queue) in
-              Queue.iter (fun (_,s) -> f s)  q
+     let iter_qualified_sources f m =
+       let q = m.manager_sources.(good_sources_queue) in
+       Queue.iter (fun (_, s) -> f s) q
 
 (*************************************************************************)
 (*                                                                       *)
@@ -996,23 +938,23 @@
 (*                                                                       *)
 (*************************************************************************)
 
-      let iter_active_sources f m =
-        for i = connected_sources_queue to busy_sources_queue do
-          let q = m.manager_sources.(i) in
-          Queue.iter (fun (_,s) -> f s)  q
-        done
+     let iter_active_sources f m =
+       for i = connected_sources_queue to busy_sources_queue do
+         let q = m.manager_sources.(i) in
+         Queue.iter (fun (_, s) -> f s) q
+       done
 
 (*************************************************************************)
 (*                                                                       *)
 (*                         iter_relevant_sources                         *)
 (*                                                                       *)
 (*************************************************************************)
-      let iter_relevant_sources f m =
-        List.iter (fun i ->
-          if i < nqueues then
-            let q = m.manager_sources.(i) in
-            Queue.iter (fun (_,s) -> f s)  q
-        ) !!relevant_queues
+     let iter_relevant_sources f m =
+       List.iter (fun i ->
+         if i < nqueues then
+           let q = m.manager_sources.(i) in
+           Queue.iter (fun (_, s) -> f s) q
+       ) !!relevant_queues
 
 (*************************************************************************)
 (*                                                                       *)
@@ -1020,8 +962,8 @@
 (*                                                                       *)
 (*************************************************************************)
 
-      let set_source_brand s brand =
-        s.source_brand <- brand
+     let set_source_brand s brand =
+       s.source_brand <- brand
 
 (*************************************************************************)
 (*                                                                       *)
@@ -1029,7 +971,7 @@
 (*                                                                       *)
 (*************************************************************************)
 
-      let source_brand s = s.source_brand
+     let source_brand s = s.source_brand
 
 (*************************************************************************)
 (*                                                                       *)
@@ -1037,20 +979,20 @@
 (*                                                                       *)
 (*************************************************************************)
 
-      let remove_from_queue s r =
-        if r.request_queue <> outside_queue then begin
-            if !verbose_sources > 1 then
-              lprintf_nl "[cSrc] Remove source %d from queue %s" s.source_num
-                queue_name.(r.request_queue);
-
-            let m = r.request_file in
-            if active_queue r.request_queue then
-              m.manager_active_sources <- m.manager_active_sources - 1;
-            Queue.remove r.request_file.manager_sources.(r.request_queue)
-            (r.request_time, s);
-            r.request_queue <- outside_queue;
-            m.manager_all_sources <- m.manager_all_sources - 1
-          end
+     let remove_from_queue s r =
+       if r.request_queue <> outside_queue then begin
+         if !verbose_sources > 1 then
+           lprintf_nl "[cSrc] Remove source %d from queue %s" s.source_num
+             queue_name.(r.request_queue);
+
+         let m = r.request_file in
+         if active_queue r.request_queue then
+           m.manager_active_sources <- m.manager_active_sources - 1;
+         Queue.remove r.request_file.manager_sources.(r.request_queue)
+           (r.request_time, s);
+         r.request_queue <- outside_queue;
+         m.manager_all_sources <- m.manager_all_sources - 1
+       end
 
 (*************************************************************************)
 (*                                                                       *)
@@ -1059,15 +1001,15 @@
 (*************************************************************************)
 
 (* From state (1) to state (2) *)
-      let source_connecting s =
-        s.source_last_attempt <- last_time ();
-        Fifo.put connecting_sources (s.source_last_attempt, s);
-        List.iter (fun r ->
-            if r.request_queue <> outside_queue then begin
-                remove_from_queue s r;
-                reschedule_source_for_file false s r;
-              end
-        ) s.source_files
+     let source_connecting s =
+       s.source_last_attempt <- last_time ();
+       Fifo.put connecting_sources (s.source_last_attempt, s);
+       List.iter (fun r ->
+         if r.request_queue <> outside_queue then begin
+           remove_from_queue s r;
+           reschedule_source_for_file false s r;
+         end
+       ) s.source_files
 
 
 (*************************************************************************)
@@ -1076,18 +1018,17 @@
 (*                                                                       *)
 (*************************************************************************)
 
-      let source_query s r =
-        remove_from_queue s r;
-        if r.request_score > not_found_score then
-        (* query_files will query all files for a source, check that we are
-           realy downloading! example source s has file f1 and file f2,
-           file f2 is paused we connect because of f1 and then query both
-           files f1 and f2 ... and yes, we do a cleanup ... but a timed one,
-           so we can't be sure *)
-        if r.request_score > not_found_score
-           && file_state (r.request_file.manager_file ()) = FileDownloading
-          then
-          begin
+     let source_query s r =
+       remove_from_queue s r;
+       if r.request_score > not_found_score then
+         (* query_files will query all files for a source, check that we are
+            realy downloading! example source s has file f1 and file f2,
+            file f2 is paused we connect because of f1 and then query both
+            files f1 and f2 ... and yes, we do a cleanup ... but a timed one,
+            so we can't be sure *)
+         if r.request_score > not_found_score &&
+           file_state (r.request_file.manager_file ()) = FileDownloading
+          then begin
             r.request_time <- 0; (* The source is ready for this request *)
             reschedule_source_for_file false s r; (* put it in busy_sources_queue *)
             (try
@@ -1104,30 +1045,30 @@
 (*************************************************************************)
 
 (* From state (2) to state (3) *)
-      let source_connected s =
-        s.source_score <- 0;
-        s.source_age <- last_time ();
-        s.source_last_attempt <- 0;
-        List.iter (fun r ->
+     let source_connected s =
+       s.source_score <- 0;
+       s.source_age <- last_time ();
+       s.source_last_attempt <- 0;
+       List.iter (fun r ->
 (*            lprintf "SOURCE> request: "; *)
-            if r.request_queue <> outside_queue then begin
+         if r.request_queue <> outside_queue then begin
 (*                lprintf "score %d/%d last query %s\n"
                   r.request_score possible_score
                   (if r.request_time = 0 then "never" else
                     Printf.sprintf "%d secs"
                       (last_time () - r.request_time));                *)
-                remove_from_queue s r;
-                if r.request_score > possible_score &&
-                  r.request_time + !!min_reask_delay < last_time () then
-                  source_query s r;
-                (try
-                    let m = r.request_file in
-                    functions.function_add_location s.source_uid
-                      m.manager_uid with _ -> ());
-                reschedule_source_for_file false s r
-              end (* else
-              lprintf "outside queue\n" *)
-        ) s.source_files
+           remove_from_queue s r;
+           if r.request_score > possible_score &&
+             r.request_time + !!min_reask_delay < last_time () then
+               source_query s r;
+           (try
+              let m = r.request_file in
+              functions.function_add_location s.source_uid
+                m.manager_uid with _ -> ());
+           reschedule_source_for_file false s r
+         end 
+	   (* else lprintf "outside queue\n" *)
+       ) s.source_files
 
 (*************************************************************************)
 (*                                                                       *)
@@ -1136,53 +1077,49 @@
 (*************************************************************************)
 
 (* From states (1) or (2) to state (3) *)
-      let source_disconnected s =
-        (match s.source_sock with
-            NoConnection -> ()
-          | ConnectionWaiting token ->
-              cancel_token token;
-              s.source_sock <- NoConnection
-          | Connection sock ->
-              close sock Closed_for_timeout
-        );
-        let connecting = s.source_last_attempt <> 0 in
-        (* source_last_attempt set to time, on connect_reply set
-           to zero. if we never reached connect_reply, the ip is
-           dead. Then we think we were *not* trying to connect
-           later on ...
-           *)
-        s.source_last_attempt <- 0;
-        List.iter (fun r ->
-            if r.request_queue <> outside_queue then
-              begin
-                remove_from_queue s r;
-                if connecting then
-                  begin
-                    r.request_time <- last_time ();
-                    if r.request_score = initial_new_source_score then
-                      set_score_part r new_source_score
-                  end
-                else
-                  begin
-                    if r.request_time = 0 then
-                      (* we think we were not connecting,
-                         but in some cases we were! and
-                         now we imidiately reconnect for
-                         that file, on a dead IP??
-                      r.request_time <- last_time () - 600;
-                         try this instead:
-                      *)
-                      r.request_time <- last_time ();
-                    (try
-                        let m = r.request_file in
-                        functions.function_remove_location s.source_uid
-                          m.manager_uid
-                     with _ -> ()
-                    )
-                  end;
-                reschedule_source_for_file false s r;
-              end;
-        ) s.source_files
+     let source_disconnected s =
+       (match s.source_sock with
+        | NoConnection -> ()
+        | ConnectionWaiting token ->
+            cancel_token token;
+            s.source_sock <- NoConnection
+        | Connection sock ->
+            close sock Closed_for_timeout
+       );
+       let connecting = s.source_last_attempt <> 0 in
+       (* source_last_attempt set to time, on connect_reply set
+          to zero. if we never reached connect_reply, the ip is
+          dead. Then we think we were *not* trying to connect
+          later on ...
+       *)
+       s.source_last_attempt <- 0;
+       List.iter (fun r ->
+         if r.request_queue <> outside_queue then begin
+           remove_from_queue s r;
+           if connecting then begin
+             r.request_time <- last_time ();
+             if r.request_score = initial_new_source_score then
+               set_score_part r new_source_score
+           end
+           else begin
+             if r.request_time = 0 then
+               (* we think we were not connecting,
+                  but in some cases we were! and
+                  now we imidiately reconnect for
+                  that file, on a dead IP??
+                  r.request_time <- last_time () - 600;
+                  try this instead:
+               *)
+               r.request_time <- last_time ();
+             (try
+                let m = r.request_file in
+                functions.function_remove_location s.source_uid
+                  m.manager_uid
+              with _ -> ())
+           end;
+           reschedule_source_for_file false s r;
+         end;
+       ) s.source_files
 
 (*************************************************************************)
 (*                                                                       *)
@@ -1190,11 +1127,11 @@
 (*                                                                       *)
 (*************************************************************************)
 
-      let connect_source s =
-        if !verbose_sources > 1 then
-          lprintf_nl "[cSrc] connect_source";
-        s.source_score <- s.source_score + 1;
-        functions.function_connect s.source_uid
+     let connect_source s =
+       if !verbose_sources > 1 then
+         lprintf_nl "[cSrc] connect_source";
+       s.source_score <- s.source_score + 1;
+       functions.function_connect s.source_uid
 
 (*************************************************************************)
 (*                                                                       *)
@@ -1202,40 +1139,40 @@
 (*                                                                       *)
 (*************************************************************************)
 
-      let create_queues () =
-        let queues = [|
-            (* New sources *)
-            (* We should change this to 'oldest_last' to improve Queue.remove *)
-            (* instead of lifo *)
-            SourcesQueueCreate.oldest_last ();
-            (* Good sources *)
-            (* We should change this to 'oldest_first' to improve Queue.remove *)
-            (* instead of fifo *)
-            SourcesQueueCreate.oldest_first ();
-            (* Ready saved sources *)
-            SourcesQueueCreate.oldest_last ();
-            (* Waiting saved sources *)
-            SourcesQueueCreate.oldest_first ();
-            (* Old sources *)
-            (* We should change this to 'oldest_first' to improve Queue.remove *)
-            (* instead of fifo *)
-            SourcesQueueCreate.oldest_first ();
-            SourcesQueueCreate.oldest_first ();
-            SourcesQueueCreate.oldest_first ();
-            (* do_not_try *)
-            SourcesQueueCreate.oldest_first ();
-            (* Connected Sources *)
-            SourcesQueueCreate.oldest_first ();
-            (* Connecting Sources *)
-            SourcesQueueCreate.oldest_first ();
-            (* Busy Sources *)
-            SourcesQueueCreate.oldest_first ();
-          |] in
-        if Array.length queues <> Array.length queue_name then begin
-            lprintf_nl "[cSrc] Fatal error in CommonSources.create_queues";
-            exit 2;
-          end;
-        queues
+     let create_queues () =
+       let queues = [|
+         (* New sources *)
+         (* We should change this to 'oldest_last' to improve Queue.remove *)
+         (* instead of lifo *)
+         SourcesQueueCreate.oldest_last ();
+         (* Good sources *)
+         (* We should change this to 'oldest_first' to improve Queue.remove *)
+         (* instead of fifo *)
+         SourcesQueueCreate.oldest_first ();
+         (* Ready saved sources *)
+         SourcesQueueCreate.oldest_last ();
+         (* Waiting saved sources *)
+         SourcesQueueCreate.oldest_first ();
+         (* Old sources *)
+         (* We should change this to 'oldest_first' to improve Queue.remove *)
+         (* instead of fifo *)
+         SourcesQueueCreate.oldest_first ();
+         SourcesQueueCreate.oldest_first ();
+         SourcesQueueCreate.oldest_first ();
+         (* do_not_try *)
+         SourcesQueueCreate.oldest_first ();
+         (* Connected Sources *)
+         SourcesQueueCreate.oldest_first ();
+         (* Connecting Sources *)
+         SourcesQueueCreate.oldest_first ();
+         (* Busy Sources *)
+         SourcesQueueCreate.oldest_first ();
+       |] in
+       if Array.length queues <> Array.length queue_name then begin
+         lprintf_nl "[cSrc] Fatal error in CommonSources.create_queues";
+         exit 2;
+       end;
+       queues
 
 (*************************************************************************)
 (*                                                                       *)
@@ -1243,16 +1180,16 @@
 (*                                                                       *)
 (*************************************************************************)
 
-      let create_file_sources_manager file_uid =
-        let m = {
-            manager_uid = file_uid;
-            manager_file = not_implemented "manager_file";
-            manager_all_sources = 0;
-            manager_active_sources = 0;
-            manager_sources = create_queues ();
-          } in
-        file_sources_managers := m :: !file_sources_managers;
-        m
+     let create_file_sources_manager file_uid =
+       let m = {
+         manager_uid = file_uid;
+         manager_file = not_implemented "manager_file";
+         manager_all_sources = 0;
+         manager_active_sources = 0;
+         manager_sources = create_queues ();
+       } in
+       file_sources_managers := m :: !file_sources_managers;
+       m
 
 (*************************************************************************)
 (*                                                                       *)
@@ -1260,17 +1197,13 @@
 (*                                                                       *)
 (*************************************************************************)
 
-      let remove_file_sources_manager m =
-
-        iter_all_sources (fun s ->
-            s.source_files <- List.filter (fun r ->
-                r.request_file != m
-            ) s.source_files;
-        ) m;
-
-        m.manager_sources <- create_queues ();
-
-        file_sources_managers := List2.removeq m !file_sources_managers
+     let remove_file_sources_manager m =
+       iter_all_sources (fun s ->
+         s.source_files <- 
+	   List.filter (fun r -> r.request_file != m) s.source_files;
+       ) m;
+       m.manager_sources <- create_queues ();
+       file_sources_managers := List2.removeq m !file_sources_managers
 
 
 (*************************************************************************)
@@ -1278,9 +1211,9 @@
 (*                        number_of_sources                              *)
 (*                                                                       *)
 (*************************************************************************)
-(* get number of sources for a file*)
-      let number_of_sources f =
-        f.manager_all_sources
+     (* get number of sources for a file*)
+     let number_of_sources f =
+       f.manager_all_sources
 
 (*************************************************************************)
 (*                                                                       *)
@@ -1288,27 +1221,24 @@
 (*                                                                       *)
 (*************************************************************************)
 
-      let find_source_by_uid uid =
-        try
-          let finder =  { dummy_source with source_uid = uid } in
-          let s = HS.find sources_by_uid finder in
-          s
-
-        with _ ->
-            if !verbose_sources > 1 then
-              lprintf_nl "[cSrc] Creating new source";
-            let n = CommonClient.book_client_num () in
-            let s = { dummy_source with
-                source_uid = uid;
-                source_age = 0;
-                source_num = n;
-                source_files = [];
-              }  in
-
-            
-            HS.add sources_by_uid s;
-            H.add sources_by_num s;
-            s
+     let find_source_by_uid uid =
+       try
+         let finder =  { dummy_source with source_uid = uid } in
+         HS.find sources_by_uid finder
+
+       with Not_found ->
+         if !verbose_sources > 1 then
+           lprintf_nl "[cSrc] Creating new source";
+         let n = CommonClient.book_client_num () in
+         let s = { dummy_source with
+                     source_uid = uid;
+                     source_age = 0;
+                     source_num = n;
+                     source_files = [];
+		 }  in
+         HS.add sources_by_uid s;
+         H.add sources_by_num s;
+         s
 
 (*************************************************************************)
 (*                                                                       *)
@@ -1316,10 +1246,9 @@
 (*                                                                       *)
 (*************************************************************************)
 
-      let find_source_by_num num =
-        let finder =  { dummy_source with source_num = num } in
-        let s = H.find sources_by_num finder in
-        s
+     let find_source_by_num num =
+       let finder =  { dummy_source with source_num = num } in
+       H.find sources_by_num finder
 
 (*************************************************************************)
 (*                                                                       *)
@@ -1327,15 +1256,15 @@
 (*                                                                       *)
 (*************************************************************************)
 
-      let rec iter_has_request rs file =
-        match rs with
-          [] -> raise Not_found
-        | r :: tail ->
-            if r.request_file == file then r else
-              iter_has_request tail file
+     let rec iter_has_request rs file =
+       match rs with
+       | [] -> raise Not_found
+       | r :: tail ->
+           if r.request_file == file then r 
+	   else iter_has_request tail file
 
-      let find_request s file =
-        iter_has_request s.source_files file
+     let find_request s file =
+       iter_has_request s.source_files file
 
 (*************************************************************************)
 (*                                                                       *)
@@ -1343,15 +1272,15 @@
 (*                                                                       *)
 (*************************************************************************)
 
-      let find_request_result s file =
-        let r = find_request s file in
-        let score =  r.request_score in
-        if score <= not_found_score then File_not_found else
-        if score <= possible_score then File_possible else
-        if score <= found_score then File_found else
-        if score <= chunk_score then File_chunk else
-        if score <= initial_new_source_score then File_new_source else
-          assert false
+     let find_request_result s file =
+       let r = find_request s file in
+       let score =  r.request_score in
+       if score <= not_found_score then File_not_found 
+       else if score <= possible_score then File_possible 
+       else if score <= found_score then File_found 
+       else if score <= chunk_score then File_chunk 
+       else if score <= initial_new_source_score then File_new_source 
+       else assert false
 
 (*************************************************************************)
 (*                                                                       *)
@@ -1359,35 +1288,31 @@
 (*                                                                       *)
 (*************************************************************************)
 
-      let check_time time =
-        if time = 0 then
-          last_time () - 650
-        else
-          time (* changed 2.5.24 *)
-
-      let add_request s file time =
-        let r =
-          try
-            let r = find_request s file in
-            remove_from_queue s r;
-            set_score_part r (if r.request_score = initial_new_source_score then
-                new_source_score
-              else
-                r.request_score - 1);
-            r.request_time <- check_time time;
-            r
-          with Not_found ->
-              let r = {
-                  request_file = file;
-                  request_time = check_time time;
-                  request_score = possible_score;
-                  request_queue = outside_queue;
-                } in
-              s.source_files <- r :: s.source_files;
-              r
-        in
-        reschedule_source_for_file false s r;
-        r
+     let check_time time =
+       if time = 0 then last_time () - 650
+       else time (* changed 2.5.24 *)
+
+     let add_request s file time =
+       let r =
+         try
+           let r = find_request s file in
+           remove_from_queue s r;
+           set_score_part r (if r.request_score = initial_new_source_score then
+			       new_source_score
+			     else r.request_score - 1);
+           r.request_time <- check_time time;
+           r
+         with Not_found ->
+           let r = {
+             request_file = file;
+             request_time = check_time time;
+             request_score = possible_score;
+             request_queue = outside_queue;
+           } in
+           s.source_files <- r :: s.source_files;
+           r in
+       reschedule_source_for_file false s r;
+       r
 
 (*************************************************************************)
 (*                                                                       *)
@@ -1395,40 +1320,39 @@
 (*                                                                       *)
 (*************************************************************************)
 
-      let rec set_request_score s file score =
-        try
-          let r = find_request s file in
-          if (not (
+     let rec set_request_score s file score =
+       try
+         let r = find_request s file in
+         if (not (
 (* If a request has been done in the last half-hour, and the source is
   announced as new, just forget it.  : why half-hour? - trying min_reask_delay *)
-              score = initial_new_source_score &&
-              r.request_time + !!min_reask_delay > last_time ()
-            )) 
+               score = initial_new_source_score &&
+		 r.request_time + !!min_reask_delay > last_time ()
+             )) ||
 (* If a file has been paused, and resumed, it is flagged outside_queue / not_found_score in 
   clean_sources, but really should be re-added to the queues as soon as possible (while retaining 
   its request_time) or it is skipped for far too long (if it is even found again) - reschedule 
   now puts new_source_score in old1 *)
-            || (score = initial_new_source_score 
-                && r.request_queue = outside_queue) then
-            let score =
-              if score = initial_new_source_score 
-                then new_source_score
-              else score
-            in
-            if r.request_queue < connected_sources_queue then
-              remove_from_queue s r;
-            set_score_part r score;
-            reschedule_source_for_file false s r;
-        with Not_found ->
-            let r = {
-                request_file = file;
-                request_time = check_time 0;
-                request_score = possible_score;
-                request_queue = outside_queue;
-              } in
-            set_score_part r score;
-            s.source_files <- r :: s.source_files;
-            reschedule_source_for_file false s r
+           (score = initial_new_source_score &&
+               r.request_queue = outside_queue) then
+             let score =
+               if score = initial_new_source_score 
+               then new_source_score
+               else score in
+             if r.request_queue < connected_sources_queue then
+               remove_from_queue s r;
+             set_score_part r score;
+             reschedule_source_for_file false s r;
+       with Not_found ->
+         let r = {
+           request_file = file;
+           request_time = check_time 0;
+           request_score = possible_score;
+           request_queue = outside_queue;
+         } in
+         set_score_part r score;
+         s.source_files <- r :: s.source_files;
+         reschedule_source_for_file false s r
 
 (*************************************************************************)
 (*                                                                       *)
@@ -1436,9 +1360,10 @@
 (*                                                                       *)
 (*************************************************************************)
 
-      let set_request_result s file result =
-        set_request_score s file (match result with
-            File_not_found -> not_found_score
+     let set_request_result s file result =
+       set_request_score s file 
+	 (match result with
+	  | File_not_found -> not_found_score
           | File_found -> found_score
           | File_chunk -> chunk_score
           | File_upload -> upload_score
@@ -1451,29 +1376,27 @@
 (*                                                                       *)
 (*************************************************************************)
 
-      let source_to_value s assocs =
-        let requests = ref [] in
-        List.iter (fun r ->
-            if r.request_score > possible_score then
-
-              requests :=
-              (SmallList
-                  [once_value (string_to_value r.request_file.manager_uid);
-                  int_to_value r.request_score;
-                  int_to_value r.request_time]
-              ) ::
-              !requests
-        ) s.source_files;
-        if !requests = [] then raise Exit;
-        (
-          ("sscore", int_to_value s.source_score ) ::
-          ("addr", M.source_uid_to_value s.source_uid ) ::
-          ("brand", M.source_brand_to_value s.source_brand ) ::
-          ("files", smalllist_to_value (fun s -> s)
-            !requests) ::
-          ("age", int_to_value s.source_age ) ::
-          assocs
-        )
+     let source_to_value s assocs =
+       let requests = ref [] in
+       List.iter (fun r ->
+         if r.request_score > possible_score then
+           requests :=
+             (SmallList
+                [once_value (string_to_value r.request_file.manager_uid);
+                 int_to_value r.request_score;
+                 int_to_value r.request_time]
+             ) :: !requests
+       ) s.source_files;
+       if !requests = [] then raise Exit;
+       (
+         ("sscore", int_to_value s.source_score ) ::
+           ("addr", M.source_uid_to_value s.source_uid ) ::
+           ("brand", M.source_brand_to_value s.source_brand ) ::
+           ("files", smalllist_to_value (fun s -> s)
+              !requests) ::
+           ("age", int_to_value s.source_age ) ::
+           assocs
+       )
 
 
 (*************************************************************************)
@@ -1482,15 +1405,15 @@
 (*                                                                       *)
 (*************************************************************************)
 
-      let query_file s file =
-        if file_state (file.manager_file ()) = FileDownloading then
-          let r = find_request s file in
-          if r.request_time + !!min_reask_delay <= last_time () then
-
-            (* There is really no need to query a not found source again
-               for the file ... not even after an hour! *)
-            if r.request_score > not_found_score then
-              source_query s r
+     let query_file s file =
+       if file_state (file.manager_file ()) = FileDownloading then
+         let r = find_request s file in
+         if r.request_time + !!min_reask_delay <= last_time () then
+
+           (* There is really no need to query a not found source again
+              for the file ... not even after an hour! *)
+           if r.request_score > not_found_score then
+             source_query s r
 
 
 (*************************************************************************)
@@ -1498,11 +1421,11 @@
 (*                         query_files                                   *)
 (*                                                                       *)
 (*************************************************************************)
-(* Query a source for all of its known files*)
-      let query_files s =
-        List.iter (fun f ->
-                     query_file s f.request_file;
-                  ) s.source_files
+     (* Query a source for all of its known files*)
+     let query_files s =
+       List.iter (fun f ->
+         query_file s f.request_file;
+       ) s.source_files
 
 
 (*************************************************************************)
@@ -1511,23 +1434,23 @@
 (*                                                                       *)
 (*************************************************************************)
 
-      let add_saved_source_request s uid score time =
-        if !verbose_sources > 1 then
-          lprintf_nl "[cSrc] Request %s %d %d" uid score time;
-        let file =
-          try
-            functions.function_string_to_manager uid
-          with e ->
-              if !verbose_sources > 0 then
-                  lprintf_nl "[cSrc] CommonSources: add_saved_source_request -> %s not found" uid;
-              raise e
-        in
-        let r = add_request s file time in
-        set_score_part r score;
-        reschedule_source_for_file true s r;
-        if !verbose_sources > 1 then
-          lprintf_nl "[cSrc] Put saved source %d in queue %s" s.source_num
-            queue_name.(r.request_queue)
+     let add_saved_source_request s uid score time =
+       if !verbose_sources > 1 then
+         lprintf_nl "[cSrc] Request %s %d %d" uid score time;
+       let file =
+         try
+           functions.function_string_to_manager uid
+         with e ->
+           if !verbose_sources > 0 then
+             lprintf_nl "[cSrc] CommonSources: add_saved_source_request -> %s not found" uid;
+           raise e
+       in
+       let r = add_request s file time in
+       set_score_part r score;
+       reschedule_source_for_file true s r;
+       if !verbose_sources > 1 then
+         lprintf_nl "[cSrc] Put saved source %d in queue %s" s.source_num
+           queue_name.(r.request_queue)
 
 (*************************************************************************)
 (*                                                                       *)
@@ -1535,79 +1458,73 @@
 (*                                                                       *)
 (*************************************************************************)
 
-      let value_to_source assocs =
+     let value_to_source assocs =
 (*        lprintf "(1) value_to_source\n";  *)
-        let get_value name conv = conv (List.assoc name assocs) in
+       let get_value name conv = conv (List.assoc name assocs) in
 
-        let addr = get_value "addr" M.value_to_source_uid in
-        let files = get_value "files"
-            (value_to_list (fun s -> s)) in
-
-        let last_conn =
-          try get_value "age" value_to_int with _ -> 0
-        in
-
-        let score = try get_value "sscore" value_to_int with _ -> 0 in
-        let brand = try get_value "brand" M.value_to_source_brand with _ ->
-              M.dummy_source_brand in
-
-        if !verbose_sources > 1 then
-          lprintf_nl "[cSrc] New source from value";
-        let s = find_source_by_uid addr in
-        s.source_score <- score;
-        s.source_age <- last_conn;
-        s.source_brand <- brand;
+       let addr = get_value "addr" M.value_to_source_uid in
+       let files = get_value "files"
+         (value_to_list (fun s -> s)) in
+
+       let last_conn =
+         try get_value "age" value_to_int with _ -> 0 in
+
+       let score = try get_value "sscore" value_to_int with _ -> 0 in
+       let brand = try get_value "brand" M.value_to_source_brand with _ ->
+         M.dummy_source_brand in
+
+       if !verbose_sources > 1 then
+         lprintf_nl "[cSrc] New source from value";
+       let s = find_source_by_uid addr in
+       s.source_score <- score;
+       s.source_age <- last_conn;
+       s.source_brand <- brand;
 
 (*        lprintf "(2) value_to_source \n"; *)
 
-        let rec iter v =
-          match v with
-            OnceValue v -> iter v
-          | List [uid; score; time] | SmallList [uid; score; time] ->
-              (try
-                  let uid = value_to_string uid in
-                  let score = value_to_int score in
-                  let time = value_to_int time in
+       let rec iter v =
+         match v with
+         | OnceValue v -> iter v
+         | List [uid; score; time] | SmallList [uid; score; time] ->
+             (try
+                let uid = value_to_string uid in
+                let score = value_to_int score in
+                let time = value_to_int time in
 
 (* added in 2.5.27 to fix a bug introduced in 2.5.25 *)
-                  let score =
-                    if score land 0xffff = 0 then score asr 16 else score
-                  in
+                let score =
+                  if score land 0xffff = 0 then score asr 16 else score in
 
 (*                  lprintf "(3) value_to_source \n"; *)
 
-                  add_saved_source_request s uid score time
+                add_saved_source_request s uid score time
 
-                with e ->
-                    if !verbose_sources > 1 then begin
-                        lprintf_nl "[cSrc] CommonSources.value_to_source: exception %s in iter request"
-                          (Printexc2.to_string e);
-                      end
-              )
-          | (StringValue _) as uid ->
-              (try
-                  let uid = value_to_string uid in
+              with e ->
+                if !verbose_sources > 1 then
+                  lprintf_nl "[cSrc] CommonSources.value_to_source: exception %s in iter request"
+                    (Printexc2.to_string e))
+
+         | (StringValue _) as uid ->
+             (try
+                let uid = value_to_string uid in
 (*                  lprintf "(4) value_to_source \n"; *)
 
-                  let score = 0 in
-                  let time = 0 in
-                  add_saved_source_request s uid score time
-
-                with e ->
-                    if !verbose_sources > 1 then begin
-                        lprintf_nl "[cSrc] CommonSources.value_to_source: exception %s in iter request"
-                          (Printexc2.to_string e);
-                      end
-              )
-          | _ -> assert false
-
-        in
+                let score = 0 in
+                let time = 0 in
+                add_saved_source_request s uid score time
+
+              with e ->
+                if !verbose_sources > 1 then
+                  lprintf_nl "[cSrc] CommonSources.value_to_source: exception %s in iter request"
+                    (Printexc2.to_string e))
+
+         | _ -> assert false
+	     
+       in
 (*        lprintf "(5) value_to_source \n"; *)
-
-        List.iter iter files;
+       List.iter iter files;
 (*        lprintf "(6) value_to_source \n"; *)
-
-        raise SideEffectOption
+       raise SideEffectOption
 
 (*************************************************************************)
 (*                                                                       *)
@@ -1615,7 +1532,7 @@
 (*                                                                       *)
 (*************************************************************************)
 
-      let refill_sources () =
+     let refill_sources () =
 
 (* Wait for 9 seconds before refilling, since we put at least 10 seconds
   of clients in the previous bucket.
@@ -1624,279 +1541,257 @@
   we may have failed to fill the queue with what was available
         if !last_refill + 8 < last_time () then
 *)
-          try
-            last_refill := last_time ();
-            if !verbose_sources > 0 then begin
-                lprintf_nl "[cSrc] CommonSources.refill_sources BEFORE:";
-                let buf = Buffer.create 100 in
-                print buf TEXT;
-                lprintf "%s\n" (Buffer.contents buf);
-              end;
-
-          (*
-             how much consecutive sources in the queue a file can have
-             source_f1|source_f1|source_f1|source_f2...
-             <- - - - - - - 3 - - - - - ->
-             10 for finer priority scaling
-          *)
-          let max_consecutive = 10 in
-
-          (*
-            get at most nsources direct sources from a file
-            return number of sources found,new queue position
-          *)
-          let rec get_sources nsource m queue took =
-            (* do_not_try == avoid source bounceback, i.e. a dustbin *)
-            if queue >= do_not_try_queue || nsource <= 0 then
-              (* we tried all queue or found enough sources, good bye!*)
-              took
-            else
-              let q = m.manager_sources.(queue) in
-              if Queue.length q > 0 then
-                let (request_time, s) = Queue.head q in
-                let throttled = queue_period.(queue) > 0 && nsource > 1 in
-                let throttle_delay = get_throttle_delay m queue throttled in
-                if request_time + !!min_reask_delay + throttle_delay < last_time () then
-                  begin
-                    if !verbose_sources > 1 then
-                      lprintf_nl "[cSrc] Sources: take source from Queue[%s] for %s"
-                        queue_name.(queue)
-                          (file_best_name (m.manager_file ()));
-                    (* put in the connecting queue*)
-                    source_connecting s;
-                    if M.direct_source s.source_uid then
-                      begin
-                        Fifo.put next_direct_sources s;
-                        (* we found a direct source try again in the _same_ queue *)
-                        get_sources (nsource-1) m queue (took+1)
-                      end
-                    else
-                      begin
-                        next_indirect_sources := s :: !next_indirect_sources;
-                        (* we found an indirect source try again in the _same_
-                           queue. indirect sources are "for free". *)
-                        get_sources nsource m queue took
-                      end
-                  end
-                else
-                  begin
-                    if !verbose_sources > 1 then
-                      lprintf_nl "[cSrc] Source of queue %s is not ready for %s"
-                        queue_name.(queue) (file_best_name (m.manager_file ()));
-                    (* too early to take sources in this queue try again in the _next_ queue*)
-                    if queue_period.(queue) = 0 then
-                        (* queue not throttled, try next queue *)
-                        let to_take =
-                          (* a maximum of just one source from old3 queue *)
-                          if queue+1 >= old_sources3_queue then
-                            (min 1 nsource)
-                          else
-                            nsource
-                        in
-                        get_sources to_take m (queue+1) took
-                    else
-                        (* throttled queue, and no ready sources ... *)
-                        if nsource = 1 then
-                          (* nsource = 1 not even a ready source without throttle-delay *)
-                          get_sources 0 m (queue) took
-                          (* exit here *)
-                        else
-                          (* finaly try to take at least one source, regardless of throttles *)
-                          get_sources 1 m (queue) took
-                  end
-              else
-                begin
-                  if !verbose_sources > 1 then
-                    lprintf_nl "[cSrc] Queue %s is empty for %s"
-                      queue_name.(queue) (file_best_name (m.manager_file ()));
-                  (* no sources in this queue try again in the _next_ queue *)
-                  let to_take =
-                    (* a maximum of just one source from old3 queue *)
-                    if queue+1 >= old_sources3_queue then
-                      (min 1 nsource)
-                    else
-                      nsource
-                  in
-                  get_sources to_take m (queue+1) took
-                end
-            in
-
-            (* recalc list if there's no new file*)
-            (* Fill only with sources from files being downloaded *)
+       try
+         last_refill := last_time ();
+         if !verbose_sources > 0 then begin
+           lprintf_nl "[cSrc] CommonSources.refill_sources BEFORE:";
+           let buf = Buffer.create 100 in
+           print buf TEXT;
+           lprintf "%s\n" (Buffer.contents buf);
+         end;
+
+         (*
+           how much consecutive sources in the queue a file can have
+           source_f1|source_f1|source_f1|source_f2...
+           <- - - - - - - 3 - - - - - ->
+           10 for finer priority scaling
+         *)
+         let max_consecutive = 10 in
 
-            let nfiles = ref 0 in
-            let files = ref [] in
-            let min_priority = ref 0 in
-            let sum_priority = ref 0 in
-            List.iter (fun m ->
-                match file_state (m.manager_file ()) with
-                  FileDownloading ->
-                    let priority = file_priority (m.manager_file ()) in
-                    min_priority := min !min_priority priority;
-                    sum_priority := !sum_priority + priority;
-                    files := (priority, m ) :: !files;
-                    incr nfiles
-                | _ -> ()
-            ) !file_sources_managers;
-
-	    if !files <> [] then begin
-
-            (* 'normalize' to 0 priorities*)
-            sum_priority := !sum_priority + (!nfiles * (-(!min_priority)));
-            (* update priorities to be > 0 *)
-            files := List.map ( fun (p,f) ->
-             let np = p - (!min_priority) in
-               if np==0 then
-                 begin
-                   sum_priority := !sum_priority + 1;
-                   (1,f)
+         (*
+           get at most nsources direct sources from a file
+           return number of sources found,new queue position
+         *)
+         let rec get_sources nsource m queue took =
+           (* do_not_try == avoid source bounceback, i.e. a dustbin *)
+           if queue >= do_not_try_queue || nsource <= 0 then
+             (* we tried all queue or found enough sources, good bye!*)
+             took
+           else
+             let q = m.manager_sources.(queue) in
+             if Queue.length q > 0 then
+               let (request_time, s) = Queue.head q in
+               let throttled = queue_period.(queue) > 0 && nsource > 1 in
+               let throttle_delay = get_throttle_delay m queue throttled in
+               if request_time + !!min_reask_delay + throttle_delay < last_time () then begin
+                 if !verbose_sources > 1 then
+                   lprintf_nl "[cSrc] Sources: take source from Queue[%s] for %s"
+                     queue_name.(queue)
+                     (file_best_name (m.manager_file ()));
+                 (* put in the connecting queue*)
+                 source_connecting s;
+                 if M.direct_source s.source_uid then begin
+                   Fifo.put next_direct_sources s;
+                   (* we found a direct source try again in the _same_ queue *)
+                   get_sources (nsource-1) m queue (took+1)
                  end
-               else
-                 (np,f)
-              ) !files;
-
-            (*sort by highest priority*)
-            files := List.sort (fun (p1,_) (p2,_) -> compare p2 p1) !files;
-
-            (* calc sources queue size
-               at least 3 sources per file*)
-            let nsources = max (!nfiles*3)
-              (functions.function_max_connections_per_second () * 10) in
-
-            (* calc how much sources a file can get according to its priority*)
-            let sources_per_prio =  (float_of_int nsources) /. (float_of_int !sum_priority) in
-
-
-            (*
-               iter through files to queue sources
-               flist_todo : next files to test
-               assigned : number of sources already queued
-               looped : number of times we allow to loop try to fill queue of sources
+                 else begin
+                   next_indirect_sources := s :: !next_indirect_sources;
+                   (* we found an indirect source try again in the _same_
+                      queue. indirect sources are "for free". *)
+                   get_sources nsource m queue took
+                 end
+               end
+               else begin
+                 if !verbose_sources > 1 then
+                   lprintf_nl "[cSrc] Source of queue %s is not ready for %s"
+                     queue_name.(queue) (file_best_name (m.manager_file ()));
+                 (* too early to take sources in this queue try again in the _next_ queue*)
+                 if queue_period.(queue) = 0 then
+                   (* queue not throttled, try next queue *)
+                   let to_take =
+                     (* a maximum of just one source from old3 queue *)
+                     if queue+1 >= old_sources3_queue then min 1 nsource
+                     else nsource in
+                   get_sources to_take m (queue+1) took
+                 else
+                   (* throttled queue, and no ready sources ... *)
+                   if nsource = 1 then
+                     (* nsource = 1 not even a ready source without throttle-delay *)
+                     get_sources 0 m (queue) took
+                       (* exit here *)
+                   else
+                     (* finaly try to take at least one source, regardless of throttles *)
+                     get_sources 1 m (queue) took
+               end
+             else begin
+               if !verbose_sources > 1 then
+                 lprintf_nl "[cSrc] Queue %s is empty for %s"
+                   queue_name.(queue) (file_best_name (m.manager_file ()));
+               (* no sources in this queue try again in the _next_ queue *)
+               let to_take =
+                 (* a maximum of just one source from old3 queue *)
+                 if queue+1 >= old_sources3_queue then min 1 nsource
+                 else nsource in
+               get_sources to_take m (queue+1) took
+             end in
+
+         (* recalc list if there's no new file*)
+         (* Fill only with sources from files being downloaded *)
+
+         let nfiles = ref 0 in
+         let files = ref [] in
+         let min_priority = ref 0 in
+         let sum_priority = ref 0 in
+         List.iter (fun m ->
+           match file_state (m.manager_file ()) with
+           | FileDownloading ->
+               let priority = file_priority (m.manager_file ()) in
+               min_priority := min !min_priority priority;
+               sum_priority := !sum_priority + priority;
+               files := (priority, m ) :: !files;
+               incr nfiles
+           | _ -> () ) !file_sources_managers;
+
+	 if !files <> [] then begin
+
+           (* 'normalize' to 0 priorities*)
+           sum_priority := !sum_priority + (!nfiles * (-(!min_priority)));
+           (* update priorities to be > 0 *)
+           files := List.map (fun (p, f) ->
+             let np = p - (!min_priority) in
+             if np = 0 then begin
+               incr sum_priority;
+               (1, f)
+             end
+             else (np, f) ) !files;
+
+           (*sort by highest priority*)
+           files := List.sort (fun (p1,_) (p2,_) -> compare p2 p1) !files;
+
+           (* calc sources queue size
+              at least 3 sources per file*)
+           let nsources = max (!nfiles * 3)
+             (functions.function_max_connections_per_second () * 10) in
+
+           (* calc how much sources a file can get according to its priority*)
+           let sources_per_prio =  
+	     (float_of_int nsources) /. (float_of_int !sum_priority) in
+
+
+           (*
+             iter through files to queue sources
+             flist_todo : next files to test
+             assigned : number of sources already queued
+             looped : number of times we allow to loop try to fill queue of sources
                         (how hard we try to fill queue)
-            *)
-            let rec iter_files assigned looped =
+           *)
+           let rec iter_files assigned looped =
 
-	      (* throw in new sources at high pace and do not care
-                 about them in get_sources, this avoids "locking" a
-                 file's queue sources with thousands of new sources
-                 from SE *)
-	      let try_some_new_sources () =
-		let extr = ref 0 in
-		List.iter
-                  (fun m ->
-		     let f = m.manager_file () in
-		     let q = m.manager_sources.(new_sources_queue) in
-		     if file_state f = FileDownloading && Queue.length q > 0 then
+	     (* throw in new sources at high pace and do not care
+                about them in get_sources, this avoids "locking" a
+                file's queue sources with thousands of new sources
+                from SE *)
+	     let try_some_new_sources () =
+	       let extr = ref 0 in
+	       List.iter (fun m ->
+		 let f = m.manager_file () in
+		 let q = m.manager_sources.(new_sources_queue) in
+		 if file_state f = FileDownloading && Queue.length q > 0 then
+		   let (request_time, s) = Queue.head q in
+		   source_connecting s;
+		   if M.direct_source s.source_uid then begin
+		     incr extr;
+		     Fifo.put next_direct_sources s
+		   end
+		   else
+		     next_indirect_sources := s :: !next_indirect_sources
+               ) !file_sources_managers;
+	       !extr in
+
+	     let cleanup_some_old_sources () =
+               (* Cleanup some sources *)
+               List.iter (fun m ->
+		 let f = m.manager_file () in
+		 if file_state f = FileDownloading then
+		   let remove_old q t =
+                     if Queue.length q > 0 then
 		       let (request_time, s) = Queue.head q in
-		       source_connecting s;
-		       if M.direct_source s.source_uid then begin
-			 incr extr;
-			 Fifo.put next_direct_sources s
-		       end
-		       else
-			 next_indirect_sources := s :: !next_indirect_sources
-                  ) !file_sources_managers;
-		!extr in
-
-	      let cleanup_some_old_sources () =
-                (* Cleanup some sources *)
-                List.iter
-		  (fun m ->
-		     let f = m.manager_file () in
-		     if file_state f = FileDownloading then
-		       let remove_old q t =
-                         if Queue.length q > 0 then
-			   let (request_time, s) = Queue.head q in
-			   if request_time + t  < last_time () then
-			     remove_from_queue s (find_request s m) in
+		       if request_time + t  < last_time () then
+			 remove_from_queue s (find_request s m) in
 		       
-		       remove_old m.manager_sources.(do_not_try_queue) 14400;
-		       remove_old m.manager_sources.(old_sources3_queue) 2400;
-		       remove_old m.manager_sources.(old_sources2_queue) 1200
-		  ) !file_sources_managers in
-
-	      let rec aux flist_todo assigned =
-		if assigned >= nsources then 
-		  cleanup_some_old_sources ()
-		else
-		  match flist_todo with
-		  | (prio, file) :: t ->
-                      let tt = min (truncate (sources_per_prio *. (float_of_int prio)))
-			max_consecutive in
-                      let to_take = max tt 1 in
-                      (* allow at least one source per file :
-			 we will overflow a bit the expected next_direct_sources length
-			 but it's for the good cause : not 'starving' some files
-                      *)
-                      let took = get_sources to_take file good_sources_queue 0 in
-                      aux t (assigned + took)
+		   remove_old m.manager_sources.(do_not_try_queue) 14400;
+		   remove_old m.manager_sources.(old_sources3_queue) 2400;
+		   remove_old m.manager_sources.(old_sources2_queue) 1200
+	       ) !file_sources_managers in
+
+	     let rec aux flist_todo assigned =
+	       if assigned >= nsources then cleanup_some_old_sources ()
+	       else
+		 match flist_todo with
+		 | (prio, file) :: t ->
+                     let tt = 
+		       min (truncate (sources_per_prio *. (float_of_int prio)))
+			 max_consecutive in
+                     let to_take = max tt 1 in
+                     (* allow at least one source per file :
+			we will overflow a bit the expected next_direct_sources length
+			but it's for the good cause : not 'starving' some files
+                     *)
+                     let took = get_sources to_take file good_sources_queue 0 in
+                     aux t (assigned + took)
 			
-		  | [] ->
-		      cleanup_some_old_sources ();
+		 | [] ->
+		     cleanup_some_old_sources ();
 
-                      (* more power to the "runaway" (most overloaded) file, pick extra sources *)
-                      let em =
-			let q = find_throttled_queue good_sources_queue in
-			if queue_period.(q) > 0 then
-			  let max_overloaded = 
-			    List.hd (find_max_overloaded q !file_sources_managers) in
-			  let overhead = 
-			    count_file_ready_sources max_overloaded q  true in
-			  if overhead > 0 then
-			    get_sources max_consecutive max_overloaded good_sources_queue 0
-			  else 0
-			else 0 in
+                     (* more power to the "runaway" (most overloaded) file, pick extra sources *)
+                     let em =
+		       let q = find_throttled_queue good_sources_queue in
+		       if queue_period.(q) > 0 then
+			 let max_overloaded = 
+			   List.hd (find_max_overloaded q !file_sources_managers) in
+			 let overhead = 
+			   count_file_ready_sources max_overloaded q  true in
+			 if overhead > 0 then
+			   get_sources max_consecutive max_overloaded good_sources_queue 0
+			 else 0
+		       else 0 in
 		      
-                      if looped > 0 then
-			(* allow at most looped re-iter of list to not
-			   loop endlessly *)
-			iter_files (assigned + em) (looped - 1) 
-	      in 
-	      let extr = try_some_new_sources () in
-	      aux !files (assigned + extr)
-
-            in
-            iter_files 0 3;
-
-            (* adjust queue throttling *)
-            let all_ready = ref 0 in
-            List.iter
-              (fun q ->
-                let queue_throttled_ready = count_ready_sources q true in
-                let queue_ready = count_ready_sources q false in
-                all_ready := !all_ready + queue_throttled_ready;
-                if !all_ready > nsources && queue_throttled_ready > 0 then
-                  (* no need, to increase period on a queue without ready sources *)
-                  begin
-                    (* lprintf "commonSources: increasing queue throttling for (ar=%d rc=%d qr=%d) %s\n" !allReady nsources queueReady queue_name.(q); *)
-                    queue_period.( q ) <- queue_period.( q ) + 1
-                  end
-                else
-                  begin
-                    if queue_ready = 0 then
-                      begin
-                        (* lprintf "commonSources: resetting queue throttling to 0 (ar=%d rc=%d qr=%d) %s\n" !allReady nsources queueReady queue_name.(q); *)
-                        queue_period.( q ) <- 0
-                      end
-                    else
-                      begin
-                        (* lprintf "commonSources: decreasing queue throttling for (ar=%d rc=%d qr=%d) %s\n" !allReady nsources queueReady queue_name.(q); *)
-                        queue_period.( q ) <- max 0 (queue_period.( q ) - 1)
-                      end
-                  end
-              ) [ good_sources_queue; old_sources1_queue; old_sources2_queue; old_sources3_queue ];
-
-	    end;
-
-            if !verbose_sources > 0 then begin
-                lprintf_nl "[cSrc] CommonSources.refill_sources AFTER:";
-                let buf = Buffer.create 100 in
-                print buf TEXT;
-                lprintf "%s\n" (Buffer.contents buf);
-              end;
-          with e ->
-              lprintf_nl "[cSrc] Exception %s in refill_sources"
-                (Printexc2.to_string e)
+                     if looped > 0 then
+		       (* allow at most looped re-iter of list to not
+			  loop endlessly *)
+		       iter_files (assigned + em) (looped - 1) 
+	     in 
+	     let extr = try_some_new_sources () in
+	     aux !files (assigned + extr)
+
+           in
+           iter_files 0 3;
+
+           (* adjust queue throttling *)
+           let all_ready = ref 0 in
+           List.iter (fun q ->
+             let queue_throttled_ready = count_ready_sources q true in
+             let queue_ready = count_ready_sources q false in
+             all_ready := !all_ready + queue_throttled_ready;
+             if !all_ready > nsources && queue_throttled_ready > 0 then begin
+               (* no need, to increase period on a queue without ready sources *)
+               (* lprintf "commonSources: increasing queue throttling for (ar=%d rc=%d qr=%d) %s\n" !allReady nsources queueReady queue_name.(q); *)
+               queue_period.( q ) <- queue_period.( q ) + 1
+             end
+             else begin
+               if queue_ready = 0 then begin
+                 (* lprintf "commonSources: resetting queue throttling to 0 (ar=%d rc=%d qr=%d) %s\n" !allReady nsources queueReady queue_name.(q); *)
+                 queue_period.( q ) <- 0
+               end
+               else begin
+                 (* lprintf "commonSources: decreasing queue throttling for (ar=%d rc=%d qr=%d) %s\n" !allReady nsources queueReady queue_name.(q); *)
+                 queue_period.( q ) <- max 0 (queue_period.( q ) - 1)
+               end
+             end
+           ) [ good_sources_queue; old_sources1_queue; old_sources2_queue; old_sources3_queue ];
+
+	 end;
+
+         if !verbose_sources > 0 then begin
+           lprintf_nl "[cSrc] CommonSources.refill_sources AFTER:";
+           let buf = Buffer.create 100 in
+           print buf TEXT;
+           lprintf "%s\n" (Buffer.contents buf);
+         end;
+       with e ->
+         lprintf_nl "[cSrc] Exception %s in refill_sources"
+           (Printexc2.to_string e)
 
 
 (*************************************************************************)
@@ -1904,19 +1799,17 @@
 (*                         clean_sources helper                          *)
 (*                                                                       *)
 (*************************************************************************)
-let put_all_outside_queue m q queue =
-  let _, s = Queue.take q in
-  m.manager_all_sources <- m.manager_all_sources - 1;
-  if active_queue queue then
-    m.manager_active_sources <- m.manager_active_sources - 1;
-  List.iter
-    (fun r ->
-      if r.request_file == m then
-      begin
-        r.request_queue <- outside_queue;
-        set_score_part r not_found_score
-      end
-  ) s.source_files
+     let put_all_outside_queue m q queue =
+       let _, s = Queue.take q in
+       m.manager_all_sources <- m.manager_all_sources - 1;
+       if active_queue queue then
+	 m.manager_active_sources <- m.manager_active_sources - 1;
+       List.iter (fun r ->
+	 if r.request_file == m then begin
+           r.request_queue <- outside_queue;
+           set_score_part r not_found_score
+	 end
+       ) s.source_files
 
 (*************************************************************************)
 (*                                                                       *)
@@ -1924,48 +1817,44 @@
 (*                                                                       *)
 (*************************************************************************)
 
-      let clean_sources () =
-        (* Maybe this should be dependant on the file (priority, state,...) ? *)
-        let max_sources_per_file = functions.function_max_sources_per_file () in
-        List.iter
-        (fun m ->
-          match file_state (m.manager_file ()) with
-            FileDownloading ->
-                let nsources =  m.manager_all_sources in
-                if nsources > max_sources_per_file then
-                let rec iter nsources q queue =
-                  if nsources > 0 then
-                    if Queue.length q > 0
-                        && queue <> good_sources_queue
-                      then
-                      begin
-                        put_all_outside_queue m q queue;
-                        iter (nsources-1) q queue
-                      end
-                    else
-                      let do_iter q = iter nsources m.manager_sources.(q) q in
+     let clean_sources () =
+       (* Maybe this should be dependant on the file (priority, state,...) ? *)
+       let max_sources_per_file = functions.function_max_sources_per_file () in
+       List.iter (fun m ->
+         match file_state (m.manager_file ()) with
+         | FileDownloading ->
+             let nsources =  m.manager_all_sources in
+             if nsources > max_sources_per_file then
+               let rec iter nsources q queue =
+                 if nsources > 0 then
+                   if Queue.length q > 0 && 
+		     queue <> good_sources_queue then begin
+                       put_all_outside_queue m q queue;
+                       iter (nsources-1) q queue
+                     end
+                   else
+                     let do_iter q = iter nsources m.manager_sources.(q) q in
   
-                      if queue = old_sources1_queue then do_iter do_not_try_queue else
-                      if queue = do_not_try_queue then do_iter new_sources_queue else
-                      if queue = new_sources_queue then do_iter waiting_saved_sources_queue else
-                      if queue > good_sources_queue then do_iter (queue-1)
-
-                in
-                iter (nsources - max_sources_per_file) (m.manager_sources.(old_sources3_queue)) old_sources3_queue
-
-          | _ ->
-                let rec iter q queue =
-                  if Queue.length q > 0 then
-                    begin
-                      put_all_outside_queue m q queue;
-                      iter q queue
-                    end
-                  else
-                    if queue > 0 then
-                      iter m.manager_sources.(queue-1) (queue-1)
-                in
-                iter (m.manager_sources.(do_not_try_queue)) do_not_try_queue
-        ) !file_sources_managers
+                     if queue = old_sources1_queue then do_iter do_not_try_queue
+		     else if queue = do_not_try_queue then do_iter new_sources_queue 
+		     else if queue = new_sources_queue then do_iter waiting_saved_sources_queue 
+		     else if queue > good_sources_queue then do_iter (queue-1)
+
+               in
+               iter (nsources - max_sources_per_file) (m.manager_sources.(old_sources3_queue)) old_sources3_queue
+
+         | _ ->
+             let rec iter q queue =
+               if Queue.length q > 0 then begin
+                 put_all_outside_queue m q queue;
+                 iter q queue
+               end
+               else
+                 if queue > 0 then
+                   iter m.manager_sources.(queue-1) (queue-1)
+             in
+             iter (m.manager_sources.(do_not_try_queue)) do_not_try_queue
+       ) !file_sources_managers
 
 (*************************************************************************)
 (*                                                                       *)
@@ -1973,101 +1862,98 @@
 (*                                                                       *)
 (*************************************************************************)
 
-      let connect_sources connection_manager =
+     let connect_sources connection_manager =
 
-        if !verbose_sources > 1 then
-          lprintf_nl "[cSrc] connect_sources";
+       if !verbose_sources > 1 then
+         lprintf_nl "[cSrc] connect_sources";
 (* After 2 minutes, consider that connections attempted should be revoked. *)
 
-        if !verbose_sources > 1 then
-          lprintf_nl "[cSrc]   revoke connecting sources...";
-        let rec iter () =
-          if not (Fifo.empty connecting_sources) then
-            let (time, s) = Fifo.head connecting_sources in
-            if time <> s.source_last_attempt then begin
-                ignore (Fifo.take connecting_sources);
-                iter ()
-              end else
-            if time + 120 < last_time () then begin
-                ignore (Fifo.take connecting_sources);
-                if s.source_last_attempt <> 0 then source_disconnected s;
-                iter ()
-              end
-        in
-        iter ();
+       if !verbose_sources > 1 then
+         lprintf_nl "[cSrc]   revoke connecting sources...";
+       let rec iter () =
+         if not (Fifo.empty connecting_sources) then
+           let (time, s) = Fifo.head connecting_sources in
+           if time <> s.source_last_attempt then begin
+             ignore (Fifo.take connecting_sources);
+             iter ()
+           end 
+	   else if time + 120 < last_time () then begin
+             ignore (Fifo.take connecting_sources);
+             if s.source_last_attempt <> 0 then source_disconnected s;
+             iter ()
+           end
+       in
+       iter ();
 
 (* First, require !!max_connections_per_second sources to connect to us.
 The probability is very high they won't be able to connect to us. *)
 
-        if !verbose_sources > 1 then
-          lprintf_nl "[cSrc]   connect indirect sources...";
-        let (first_sources, last_sources) =
-          List2.cut !!max_connections_per_second !next_indirect_sources in
-        next_indirect_sources := last_sources;
-        List.iter (fun s ->
-            ignore (connect_source s)) first_sources;
+       if !verbose_sources > 1 then
+         lprintf_nl "[cSrc]   connect indirect sources...";
+       let (first_sources, last_sources) =
+         List2.cut !!max_connections_per_second !next_indirect_sources in
+       next_indirect_sources := last_sources;
+       List.iter (fun s ->
+         ignore (connect_source s)) first_sources;
 
 (* Second, for every file being downloaded, query sources that are already
 connected if needed *)
-        if !verbose_sources > 1 then
-          lprintf_nl "[cSrc]   query connected sources...";
-        List.iter (fun m ->
-            match file_state (m.manager_file ()) with
-              FileDownloading ->
-                let q = m.manager_sources.(connected_sources_queue) in
-                let rec iter () =
-                  if Queue.length q > 0 then
-                    let (time, s) = Queue.head q in
-                    if time + !!min_reask_delay < last_time () then begin
-
-                        let r = find_request s m in
-                        (* lprintf "commonSources: connect_sources: second place for source_query !?\n"; *)
-                        (* isn't that here pretty useless? *)
-                        source_query s r;
-                        (* After this step, the source is
-                           either in 'busy_sources_queue',
-                           if for some reason, the request
-                           could not be sent, or in
-                           'connected_sources_queue' at the
-                           tail if the request could be sent.
-                           This seems thus safe.
-                          *)
-                        iter ()
-                      end
-                in
-                iter ()
-            | _ -> ()
-        ) !file_sources_managers;
-
-        if !verbose_sources > 1 then
-          lprintf_nl "[cSrc]   connect to sources...";
-(* Finally, connect to available sources *)
-        try
-          let max_sources = functions.function_max_connections_per_second () in
-          if !verbose_sources > 1 then
-            lprintf_nl "[cSrc] max_sources: %d" max_sources;
-          let rec iter nsources refilled =
-            if nsources > 0 && can_open_connection connection_manager then
-              if Fifo.length next_direct_sources > 0 then
-                let s = Fifo.take next_direct_sources in
-                connect_source s;
-                let nsources = match s.source_sock with
-                    NoConnection ->
-                      if !verbose_sources > 1 then
-                        lprintf_nl "[cSrc] not connected"; nsources
-                  | _ -> nsources-1
-                in
-                iter nsources refilled
-              else
-              if not refilled then begin
-                  refill_sources ();
-                  iter nsources true
-                end
-          in
-          iter max_sources false;
-          if !verbose_sources > 1 then
-            lprintf_nl "[cSrc]   done connect_sources";
-        with Exit -> ()
+       if !verbose_sources > 1 then
+         lprintf_nl "[cSrc]   query connected sources...";
+       List.iter (fun m ->
+         match file_state (m.manager_file ()) with
+         | FileDownloading ->
+             let q = m.manager_sources.(connected_sources_queue) in
+             let rec iter () =
+               if Queue.length q > 0 then
+                 let (time, s) = Queue.head q in
+                 if time + !!min_reask_delay < last_time () then begin
+
+                   let r = find_request s m in
+                   (* lprintf "commonSources: connect_sources: second place for source_query !?\n"; *)
+                   (* isn't that here pretty useless? *)
+                   source_query s r;
+                   (* After this step, the source is
+                      either in 'busy_sources_queue',
+                      if for some reason, the request
+                      could not be sent, or in
+                      'connected_sources_queue' at the
+                      tail if the request could be sent.
+                      This seems thus safe.
+                   *)
+                   iter ()
+                 end in
+             iter ()
+         | _ -> () 
+       ) !file_sources_managers;
+
+       if !verbose_sources > 1 then
+         lprintf_nl "[cSrc]   connect to sources...";
+       (* Finally, connect to available sources *)
+       try
+         let max_sources = functions.function_max_connections_per_second () in
+         if !verbose_sources > 1 then
+           lprintf_nl "[cSrc] max_sources: %d" max_sources;
+         let rec iter nsources refilled =
+           if nsources > 0 && can_open_connection connection_manager then
+             if Fifo.length next_direct_sources > 0 then
+               let s = Fifo.take next_direct_sources in
+               connect_source s;
+               let nsources = 
+		 match s.source_sock with
+		 | NoConnection ->
+                     if !verbose_sources > 1 then
+                       lprintf_nl "[cSrc] not connected"; nsources
+                 | _ -> nsources - 1 in
+               iter nsources refilled
+             else if not refilled then begin
+               refill_sources ();
+               iter nsources true
+             end in
+         iter max_sources false;
+         if !verbose_sources > 1 then
+           lprintf_nl "[cSrc]   done connect_sources";
+       with Exit -> ()
 
 
 
@@ -2077,36 +1963,34 @@
 (*                                                                       *)
 (*************************************************************************)
 
-      let value_to_module f v =
-        match v with
-          Module list -> f list
-        | _ -> failwith "Option should be a module"
+     let value_to_module f v =
+       match v with
+       | Module list -> f list
+       | _ -> failwith "Option should be a module"
 
-      let option = define_option_class "Source"
-          (fun v ->
+     let option = define_option_class "Source"
+       (fun v ->
 (*            lprintf "(n) source !!\n"; *)
-            value_to_module value_to_source v)
-        (fun s -> Module (source_to_value s []))
+          value_to_module value_to_source v)
+       (fun s -> Module (source_to_value s []))
 
-      let file_sources_option = ref None
+     let file_sources_option = ref None
 
-      let attach_sources_to_file section =
+     let attach_sources_to_file section =
 (*        lprintf "attach_sources_to_file\n"; *)
-        let sources = match !file_sources_option with
-            None ->
+       let sources = match !file_sources_option with
+         | None ->
 (*              lprintf "attaching sources this time\n"; *)
-              let sources = define_option section
-                  ["sources"] ""  (listiter_option option) []
-              in
+             let sources = define_option section
+               ["sources"] ""  (listiter_option option) [] in
 (*              lprintf "done\n"; *)
-              file_sources_option := Some sources;
-              sources
-          | Some sources ->  sources
-        in
-        sources =:= [];
-        HS.iter (fun s -> sources =:= s :: !!sources) sources_by_uid;
+             file_sources_option := Some sources;
+             sources
+         | Some sources ->  sources in
+       sources =:= [];
+       HS.iter (fun s -> sources =:= s :: !!sources) sources_by_uid;
 
-        (fun _ -> sources =:= [])
+       (fun _ -> sources =:= [])
 
 
 (*************************************************************************)
@@ -2115,82 +1999,70 @@
 (*                                                                       *)
 (*************************************************************************)
 
-      let _ =
-        Heap.add_memstat M.module_name (fun level buf ->
+     let () =
+       Heap.add_memstat M.module_name (fun level buf ->
 
-            let nsources_per_queue = Array.create nqueues 0 in
-            let nready_per_queue = Array.create nqueues 0 in
-            List.iter (fun m ->
-                for i = 0 to nqueues -1 do
-                  let q = m.manager_sources.(i) in
-                  let nready = ref 0 in
-                  let nsources = ref 0 in
-		  let ready_threshold = last_time () - !!min_reask_delay in
-                  Queue.iter (fun (time, s) ->
-                      incr nsources;
-                      if time < ready_threshold then
-                        incr nready
-                      else
-                      if i = new_sources_queue then begin
-                          Printf.bprintf buf "ERROR: Source is not ready in new_sources_queue !\n";
-                          print_source buf s
-                        end
-                  ) q;
-                  nsources_per_queue.(i) <- nsources_per_queue.(i) + !nsources;
-                  nready_per_queue.(i) <- nready_per_queue.(i) + !nready;
-                done
-            ) !file_sources_managers;
-
-            Printf.bprintf buf  "\nFor all managers (%d):\n" (List.length !file_sources_managers);
-            for i = 0 to nqueues - 1 do
-              Printf.bprintf buf "   Queue[%s]: %d entries (%d ready)\n"
-                queue_name.(i) nsources_per_queue.(i) nready_per_queue.(i);
-
-            done;
-
-            let nsources = ref 0 in
-            HS.iter (fun _ -> incr nsources) sources_by_uid;
-            Printf.bprintf buf "Sources by UID table: %d entries\n" !nsources;
-            Printf.bprintf buf "Sources by UID table stats: %d %d %d %d %d %d\n" 
-               ((fun (n,_,_,_,_,_) -> n)(HS.stats sources_by_uid))
-               ((fun (_,n,_,_,_,_) -> n)(HS.stats sources_by_uid))
-               ((fun (_,_,n,_,_,_) -> n)(HS.stats sources_by_uid))
-               ((fun (_,_,_,n,_,_) -> n)(HS.stats sources_by_uid))
-               ((fun (_,_,_,_,n,_) -> n)(HS.stats sources_by_uid))
-               ((fun (_,_,_,_,_,n) -> n)(HS.stats sources_by_uid))
-               ;
+         let nsources_per_queue = Array.create nqueues 0 in
+         let nready_per_queue = Array.create nqueues 0 in
+         List.iter (fun m ->
+           for i = 0 to nqueues -1 do
+             let q = m.manager_sources.(i) in
+             let nready = ref 0 in
+             let nsources = ref 0 in
+	     let ready_threshold = last_time () - !!min_reask_delay in
+             Queue.iter (fun (time, s) ->
+	       incr nsources;
+               if time < ready_threshold then incr nready
+               else if i = new_sources_queue then begin
+                 Printf.bprintf buf "ERROR: Source is not ready in new_sources_queue !\n";
+                 print_source buf s
+               end
+             ) q;
+             nsources_per_queue.(i) <- nsources_per_queue.(i) + !nsources;
+             nready_per_queue.(i) <- nready_per_queue.(i) + !nready;
+           done
+	 ) !file_sources_managers;
+
+         Printf.bprintf buf  "\nFor all managers (%d):\n" (List.length !file_sources_managers);
+         for i = 0 to nqueues - 1 do
+           Printf.bprintf buf "   Queue[%s]: %d entries (%d ready)\n"
+             queue_name.(i) nsources_per_queue.(i) nready_per_queue.(i);
+         done;
+
+         let nsources = ref 0 in
+         HS.iter (fun _ -> incr nsources) sources_by_uid;
+         Printf.bprintf buf "Sources by UID table: %d entries\n" !nsources;
+	 let a1, a2, a3, a4, a5, a6 = HS.stats sources_by_uid in
+         Printf.bprintf buf "Sources by UID table stats: %d %d %d %d %d %d\n" 
+	   a1 a2 a3 a4 a5 a6;
             
-            nsources := 0;
-            H.iter (fun _ -> incr nsources) sources_by_num;
-            Printf.bprintf buf "Sources by NUM table: %d entries\n" !nsources;
-            Printf.bprintf buf "Sources by NUM table stats: %d %d %d %d %d %d\n" 
-               ((fun (n,_,_,_,_,_) -> n)(H.stats sources_by_num))
-               ((fun (_,n,_,_,_,_) -> n)(H.stats sources_by_num))
-               ((fun (_,_,n,_,_,_) -> n)(H.stats sources_by_num))
-               ((fun (_,_,_,n,_,_) -> n)(H.stats sources_by_num))
-               ((fun (_,_,_,_,n,_) -> n)(H.stats sources_by_num))
-               ((fun (_,_,_,_,_,n) -> n)(H.stats sources_by_num))
-               ;
-
-            Printf.bprintf buf "Used indirect connections: %d\n"
-              !indirect_connections;
-
-            let nconnected = ref 0 in
-            Fifo.iter (fun (_,s) ->
-                if s.source_last_attempt = 0 then incr nconnected;
-            ) connecting_sources;
-            Printf.bprintf buf "Connecting Sources: %d entries"
-              (Fifo.length connecting_sources);
-            if !nconnected > 0 then Printf.bprintf buf " (connected: %d)" !nconnected;
-            Printf.bprintf buf "\n";
-
-            Printf.bprintf buf "Next Direct Sources: %d entries\n"
-              (Fifo.length next_direct_sources);
-
-            Printf.bprintf buf "Next Indirect Sources: %d entries\n"
-              (List.length !next_indirect_sources)
-        )
+         nsources := 0;
+         H.iter (fun _ -> incr nsources) sources_by_num;
+         Printf.bprintf buf "Sources by NUM table: %d entries\n" !nsources;
+	 let a1, a2, a3, a4, a5, a6 = H.stats sources_by_num in
+         Printf.bprintf buf "Sources by NUM table stats: %d %d %d %d %d %d\n" 
+	   a1 a2 a3 a4 a5 a6;
+
+         Printf.bprintf buf "Used indirect connections: %d\n"
+	   !indirect_connections;
+
+         let nconnected = ref 0 in
+         Fifo.iter (fun (_, s) ->
+           if s.source_last_attempt = 0 then incr nconnected;
+         ) connecting_sources;
+         Printf.bprintf buf "Connecting Sources: %d entries"
+           (Fifo.length connecting_sources);
+         if !nconnected > 0 then 
+	   Printf.bprintf buf " (connected: %d)" !nconnected;
+         Printf.bprintf buf "\n";
+
+         Printf.bprintf buf "Next Direct Sources: %d entries\n"
+           (Fifo.length next_direct_sources);
+
+         Printf.bprintf buf "Next Indirect Sources: %d entries\n"
+           (List.length !next_indirect_sources)
+       )
 
-    end)
+   end)
 
 
Index: src/daemon/common/commonSources.mli
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/daemon/common/commonSources.mli,v
retrieving revision 1.10
retrieving revision 1.11
diff -u -r1.10 -r1.11
--- src/daemon/common/commonSources.mli	8 Apr 2006 02:16:21 -0000	1.10
+++ src/daemon/common/commonSources.mli	3 Dec 2006 20:47:12 -0000	1.11
@@ -16,18 +16,7 @@
     along with mldonkey; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *)
-
-open Queues
-open Printf2
-open Md4
-open Options
-open BasicSocket
-
-open TcpBufferedSocket
-open CommonFile
-open CommonOptions
 open CommonTypes
-  
 
 type request_result = 
 | File_possible   (* we asked, but didn't know *)
@@ -38,17 +27,16 @@
 | File_upload     (* we uploaded from this client *)
 (* | File_unknown     We don't know anything *)
 
-  (*
+(*
 val initial_new_source_score : int
 val new_source_score : int
 val not_found_score : int
-val possible_score : int
 val found_score : int
 val chunk_score : int
 val upload_score   : int
 *)
 val possible_score : int
-  
+
 module Make(M: 
 
 
@@ -62,24 +50,25 @@
 (*************************************************************************)
 (*************************************************************************)
     
-    sig
-        
-      val module_name : string
-        
-      type source_uid
-      val dummy_source_uid : source_uid
-      val source_uid_to_value: source_uid -> Options.option_value
-      val value_to_source_uid: Options.option_value -> source_uid
-
-      type source_brand
-      val dummy_source_brand : source_brand
-      val source_brand_to_value: source_brand -> Options.option_value
-      val value_to_source_brand: Options.option_value -> source_brand
+  sig
+    val module_name : string
+
+    type source_uid
+
+    val dummy_source_uid : source_uid
+    val source_uid_to_value: source_uid -> Options.option_value
+    val value_to_source_uid: Options.option_value -> source_uid
+
+    type source_brand
+
+    val dummy_source_brand : source_brand
+    val source_brand_to_value: source_brand -> Options.option_value
+    val value_to_source_brand: Options.option_value -> source_brand
       
-      val direct_source : source_uid -> bool    
-      val indirect_source : source_uid -> bool
-    end) : (
-    sig
+    val direct_source : source_uid -> bool    
+    val indirect_source : source_uid -> bool
+  end) : (
+  sig
 
 (*************************************************************************)
 (*************************************************************************)
@@ -91,95 +80,95 @@
 (*************************************************************************)
 (*************************************************************************)
       
-      type source = {
-          source_uid : M.source_uid;
-          mutable source_files : file_request list;
-          mutable source_score : int;
-          mutable source_num : int;
-          mutable source_age : int;
-          mutable source_last_attempt : int;
-          mutable source_sock : tcp_connection;
-          mutable source_brand : M.source_brand;
-        }
-      
-      and file_request = {
-          request_file : file_sources_manager;
-          mutable request_queue : int;
-          mutable request_time : int;
-          mutable  request_score : int;
-        }
-        
-      and file_sources_manager = {
-          manager_uid : string;
-          mutable manager_sources : source Queues.Queue.t array;
-          mutable manager_active_sources : int;
-          mutable manager_all_sources : int;
-          mutable manager_file : (unit -> file);
-        }
+    type source = {
+      source_uid : M.source_uid;
+      mutable source_files : file_request list;
+      mutable source_score : int;
+      mutable source_num : int;
+      mutable source_age : int;
+      mutable source_last_attempt : int;
+      mutable source_sock : tcp_connection;
+      mutable source_brand : M.source_brand;
+    }
+
+    and file_request = {
+      request_file : file_sources_manager;
+      mutable request_queue : int;
+      mutable request_time : int;
+      mutable  request_score : int;
+    }
+
+    and file_sources_manager = {
+      manager_uid : string;
+      mutable manager_sources : source Queues.Queue.t array;
+      mutable manager_active_sources : int;
+      mutable manager_all_sources : int;
+      mutable manager_file : (unit -> file);
+    }
+
+    and functions = {
+      mutable function_connect: (M.source_uid -> unit);
+      mutable function_query: (M.source_uid -> string -> unit);
+      mutable function_string_to_manager: (string -> file_sources_manager);
+      mutable function_max_connections_per_second : (unit -> int);
+      mutable function_max_sources_per_file : (unit -> int);
       
-      and functions = {
-          mutable function_connect: (M.source_uid -> unit);
-          mutable function_query: (M.source_uid -> string -> unit);
-          mutable function_string_to_manager: (string -> file_sources_manager);
-          mutable function_max_connections_per_second : (unit -> int);
-          mutable function_max_sources_per_file : (unit -> int);
-          
-          mutable function_add_location : 
-          (M.source_uid -> string -> unit);
-          mutable function_remove_location : 
-          (M.source_uid -> string -> unit);
-        }
-
-      val functions : functions
-        
-      val create_file_sources_manager : 
-        string -> file_sources_manager
-      val remove_file_sources_manager :
-        file_sources_manager -> unit
-      val number_of_sources : 
-        file_sources_manager -> int
-        
+      mutable function_add_location : 
+        (M.source_uid -> string -> unit);
+      mutable function_remove_location : 
+        (M.source_uid -> string -> unit);
+    }
+
+    val functions : functions
+
+    val create_file_sources_manager : string -> file_sources_manager
+    val remove_file_sources_manager : file_sources_manager -> unit
+(*
+    val number_of_sources : file_sources_manager -> int
+*)        
 (* Find a given source *)
-      val find_source_by_uid : M.source_uid -> source
-      val find_source_by_num : int -> source
 
+    val find_source_by_uid : M.source_uid -> source
+(*
+    val find_source_by_num : int -> source
+*)
 (* Feed-back on sources *)
-      val source_connected : source -> unit
-      val source_disconnected : source -> unit
-      val add_request : 
-        source -> file_sources_manager  -> int -> file_request
-        
-      val set_request_result : 
-        source -> file_sources_manager -> request_result -> unit
-      val find_request : 
-        source -> file_sources_manager -> file_request
-      val find_request_result : 
-        source -> file_sources_manager -> request_result
+    val source_connected : source -> unit
+    val source_disconnected : source -> unit
+
+    val add_request : source -> file_sources_manager  -> int -> file_request
+    val set_request_result : 
+      source -> file_sources_manager -> request_result -> unit
+    val find_request : source -> file_sources_manager -> file_request
+    val find_request_result : source -> file_sources_manager -> request_result
+
+    val need_new_sources : file_sources_manager -> bool 
 
-      val need_new_sources : file_sources_manager -> bool 
-        
 (* Connect sources every second *)
-      val connect_sources : TcpBufferedSocket.connection_manager -> unit
-        
-      val attach_sources_to_file : Options.options_section -> (unit -> unit)
-        
-      val print : Buffer.t -> CommonTypes.output_type -> unit
-        
-      val indirect_connections : int ref
-        
-      val dummy_source : source        
-  
-      val query_file : source -> file_sources_manager -> unit
-      val query_files : source -> unit
-        
-      val clean_sources : unit -> unit
-        
-      val iter_all_sources : (source -> unit) -> file_sources_manager -> unit
-      val iter_active_sources : (source -> unit) -> file_sources_manager -> unit
-      val iter_qualified_sources : (source -> unit) -> file_sources_manager -> unit
-			val iter_relevant_sources : (source -> unit) -> file_sources_manager -> unit
-
-      val source_brand : source -> M.source_brand
-      val set_source_brand : source -> M.source_brand -> unit
-    end)
-  
+    val connect_sources : TcpBufferedSocket.connection_manager -> unit
+
+    val attach_sources_to_file : Options.options_section -> (unit -> unit)
+
+    val print : Buffer.t -> CommonTypes.output_type -> unit
+
+    val indirect_connections : int ref
+
+    val dummy_source : source        
+(*  
+    val query_file : source -> file_sources_manager -> unit
+*)
+    val query_files : source -> unit
+
+    val clean_sources : unit -> unit
+
+    val iter_all_sources : (source -> unit) -> file_sources_manager -> unit
+    val iter_active_sources : (source -> unit) -> file_sources_manager -> unit
+    val iter_qualified_sources : 
+      (source -> unit) -> file_sources_manager -> unit
+    val iter_relevant_sources : 
+      (source -> unit) -> file_sources_manager -> unit
+
+    val source_brand : source -> M.source_brand
+    val set_source_brand : source -> M.source_brand -> unit
+  end)
+
Index: src/daemon/common/commonTypes.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/daemon/common/commonTypes.ml,v
retrieving revision 1.64
retrieving revision 1.65
diff -u -r1.64 -r1.65
--- src/daemon/common/commonTypes.ml	26 Nov 2006 16:36:29 -0000	1.64
+++ src/daemon/common/commonTypes.ml	3 Dec 2006 20:49:42 -0000	1.65
@@ -265,6 +265,7 @@
 | Field_Lastseencomplete
 | Field_Mediacodec
 | Field_Medialength
+| Field_KNOWN of string
 | Field_UNKNOWN of string
   
 type tag = {
Index: src/daemon/common/commonUploads.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/daemon/common/commonUploads.ml,v
retrieving revision 1.52
retrieving revision 1.53
diff -u -r1.52 -r1.53
--- src/daemon/common/commonUploads.ml	26 Nov 2006 13:54:09 -0000	1.52
+++ src/daemon/common/commonUploads.ml	3 Dec 2006 20:57:56 -0000	1.53
@@ -687,7 +687,7 @@
           impl_shared_ops = shared_ops;
           impl_shared_val = sh;
           impl_shared_requests = 0;
-          impl_shared_magic = None;
+          impl_shared_file = None;
           impl_shared_servers = [];
         }
       and sh = {
Index: src/daemon/common/guiDecoding.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/daemon/common/guiDecoding.ml,v
retrieving revision 1.66
retrieving revision 1.67
diff -u -r1.66 -r1.67
--- src/daemon/common/guiDecoding.ml	26 Nov 2006 13:54:09 -0000	1.66
+++ src/daemon/common/guiDecoding.ml	2 Dec 2006 12:35:45 -0000	1.67
@@ -816,8 +816,10 @@
       client_os = None;
       client_release = "";
       client_emulemod = "";
-      client_downloaded = zero;
-      client_uploaded = zero;
+      client_total_downloaded = zero;
+      client_total_uploaded = zero;
+      client_session_downloaded = zero;
+      client_session_uploaded = zero;
       client_upload = None;
       client_sui_verified = None;
 (*      client_sock_addr = ""; *)
@@ -875,8 +877,10 @@
     client_os = None;
     client_release = release;
     client_emulemod = emulemod;
-    client_downloaded = downloaded;
-    client_uploaded = uploaded;
+    client_total_downloaded = downloaded;
+    client_total_uploaded = uploaded;
+    client_session_downloaded = 0L;
+    client_session_uploaded = 0L;
     client_upload = upload;
     client_sui_verified = verified;
 (*    client_sock_addr = sock_addr; *)
Index: src/daemon/common/guiEncoding.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/daemon/common/guiEncoding.ml,v
retrieving revision 1.61
retrieving revision 1.62
diff -u -r1.61 -r1.62
--- src/daemon/common/guiEncoding.ml	26 Nov 2006 16:36:29 -0000	1.61
+++ src/daemon/common/guiEncoding.ml	2 Dec 2006 12:35:45 -0000	1.62
@@ -669,8 +669,8 @@
     end else 
     begin
       buf_string buf (client_software_short c.client_software c.client_os);
-      buf_int64 buf c.client_downloaded;
-      buf_int64 buf c.client_uploaded;
+      buf_int64 buf c.client_session_downloaded;
+      buf_int64 buf c.client_session_uploaded;
       (match c.client_upload with
           Some s -> buf_string buf s
         | None -> buf_string buf "");
Index: src/daemon/common/guiTypes.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/daemon/common/guiTypes.ml,v
retrieving revision 1.34
retrieving revision 1.35
diff -u -r1.34 -r1.35
--- src/daemon/common/guiTypes.ml	14 Nov 2006 18:42:59 -0000	1.34
+++ src/daemon/common/guiTypes.ml	2 Dec 2006 12:35:45 -0000	1.35
@@ -219,8 +219,10 @@
     mutable client_os : string option;
     mutable client_release : string;
     mutable client_emulemod : string;
-    mutable client_downloaded : int64;
-    mutable client_uploaded : int64;
+    mutable client_total_downloaded : int64;
+    mutable client_total_uploaded : int64;
+    mutable client_session_downloaded : int64;
+    mutable client_session_uploaded : int64;
     mutable client_upload : string option;
     mutable client_sui_verified : bool option;
 (*  mutable client_sock_addr : string;  *)
Index: src/daemon/driver/driverCommands.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/daemon/driver/driverCommands.ml,v
retrieving revision 1.202
retrieving revision 1.209
diff -u -r1.202 -r1.209
--- src/daemon/driver/driverCommands.ml	28 Nov 2006 23:15:21 -0000	1.202
+++ src/daemon/driver/driverCommands.ml	8 Dec 2006 12:26:24 -0000	1.209
@@ -343,7 +343,7 @@
 	web_infos_add kind period url;
 	CommonWeb.load_url true kind url;
         "url added to web_infos. downloading now"
-    ), "<kind> <url> [<period>]:\t\tload this file from the web\n"
+    ), "<kind> <url> [<period>] :\tload this file from the web\n"
        ^"\t\t\t\t\tkind is either server.met (if the downloaded file is a server.met)\n"
        ^"\t\t\t\t\tperiod is the period between updates (in hours, default 0 = only loaded at startup)";
 
@@ -390,7 +390,12 @@
                 ( "0", "srh", "Client brand", "CB" ) ;
                 ( "0", "srh", "Client release", "CR" ) ;
                 ] @
-                (if !!emule_mods_count then [( "0", "srh", "eMule MOD", "EM" )] else []));
+                (if !!emule_mods_count then [( "0", "srh", "eMule MOD", "EM" )] else [])
+                @ [
+                ( "1", "srh ar", "Total UL bytes to this client for all files", "tUL" ) ;
+                ( "1", "srh ar br", "Total DL bytes from this client for all files", "tDL" ) ;
+                ( "1", "srh ar", "Session UL bytes to this client for all files", "sUL" ) ;
+                ( "1", "srh ar", "Session DL bytes from this client for all files", "sDL" )]);
 
             let counter = ref 0 in
             let all_clients_list = clients_get_all () in
@@ -409,7 +414,12 @@
                      (client_software i.client_software i.client_os, "sr", client_software_short i.client_software i.client_os);
                      ("", "sr", i.client_release);
                      ] @
-                     (if !!emule_mods_count then [("", "sr", i.client_emulemod)] else []));
+                     (if !!emule_mods_count then [("", "sr", i.client_emulemod)] else [])
+                     @ [
+                     ("", "sr ar", (size_of_int64 i.client_total_uploaded));
+                     ("", "sr ar br", (size_of_int64 i.client_total_downloaded));
+                     ("", "sr ar", (size_of_int64 i.client_session_uploaded));
+                     ("", "sr ar", (size_of_int64 i.client_session_downloaded))]);
                 if use_html_mods o then Printf.bprintf buf "\\</tr\\>"
                 else Printf.bprintf buf "\n";
                 incr counter;
@@ -423,7 +433,7 @@
               client_print c o;
           ) args;
         ""
-    ), "<num> :\t\t\t\tview client (use arg 'all' for all clients)";
+    ), "<num|all> :\t\t\t\tview client (use arg 'all' for all clients)";
 
     "version", Arg_none (fun o ->
 	print_command_result o o.conn_buf (CommonGlobals.version ());
@@ -848,7 +858,7 @@
             ) args;
             print_result !counter;
         ""
-    ), "<server numbers|all> :\t\t\t\tdisconnect from server(s)";
+    ), "<server numbers|all> :\t\tdisconnect from server(s)";
 
   ]
 
@@ -896,7 +906,7 @@
             ) args;
             Printf.sprintf (_b "%d friends removed") (List.length args)
           end
-    ), "<client numbers> :\tremove friend (use arg 'all' for all friends)";
+    ), "<client numbers|all> :\tremove friend (use arg 'all' for all friends)";
 
     "friends", Arg_none (fun o ->
         let buf = o.conn_buf in
@@ -1362,7 +1372,7 @@
                 (if s.search_waiting = 0 then _s "done" else
                     string_of_int s.search_waiting)
                 s.search_nresults
-            ) (Sort.list (fun f1 f2 -> f1.search_num < f2.search_num)
+            ) (List.sort (fun f1 f2 -> compare f1.search_num f2.search_num)
             user.ui_user_searches)
           end;
         ""
@@ -1767,6 +1777,7 @@
                       [
 			strings_of_option previewer;
 			strings_of_option temp_directory;
+			strings_of_option share_scan_interval;
 			strings_of_option hdd_temp_minfree;
 			strings_of_option hdd_temp_stop_core;
 			strings_of_option hdd_coredir_minfree;
@@ -1777,7 +1788,8 @@
 			strings_of_option allow_browse_share;
 			strings_of_option auto_commit;
 			strings_of_option pause_new_downloads;
-			strings_of_option create_dir_mask;
+			strings_of_option create_file_mode;
+			strings_of_option create_dir_mode;
 			strings_of_option create_file_sparse;
 			strings_of_option log_file;
 			strings_of_option log_file_size;
@@ -2415,8 +2427,10 @@
                   ] @
                   (if !!emule_mods_count then [( "0", "srh", "eMule MOD", "EM" )] else [])
                   @ [
-                  ( "0", "srh ar", "Total DL bytes from this client for all files", "DL" ) ;
-                  ( "0", "srh ar", "Total UL bytes to this client for all files", "UL" ) ;
+                  ( "0", "srh ar", "Total DL bytes from this client for all files", "tDL" ) ;
+                  ( "0", "srh ar", "Total UL bytes to this client for all files", "tUL" ) ;
+                  ( "0", "srh ar", "Session DL bytes from this client for all files", "sDL" ) ;
+                  ( "0", "srh ar", "Session UL bytes to this client for all files", "sUL" ) ;
                   ( "0", "srh ar", "Slot kind", "Slot" ) ;
                   ( "0", "srh", "Filename", "Filename" ) ]);
 
@@ -2432,7 +2446,7 @@
                         onMouseOut=\\\"mOut(this);\\\"
                         onClick=\\\"parent.fstatus.location.href='submit?q=friend_add+%d'\\\"\\>"
                             ( if (!counter mod 2 == 0) then "dl-1" else "dl-2";) (client_num c)
-                          ( float_of_int (Int64.to_int i.client_uploaded / 1024) /.
+                          ( float_of_int (Int64.to_int i.client_session_uploaded / 1024) /.
                               float_of_int (max 1 ((last_time ()) - i.client_connect_time)) )
                           (client_num c);
 
@@ -2455,8 +2469,10 @@
                             ] @
                             (if !!emule_mods_count then [("", "sr", i.client_emulemod)] else [])
                             @ [
-                            ("", "sr ar", size_of_int64 i.client_downloaded);
-                            ("", "sr ar", size_of_int64 i.client_uploaded);
+                            ("", "sr ar", size_of_int64 i.client_total_downloaded);
+                            ("", "sr ar", size_of_int64 i.client_total_uploaded);
+                            ("", "sr ar", size_of_int64 i.client_session_downloaded);
+                            ("", "sr ar", size_of_int64 i.client_session_uploaded);
 			    (let text1, text2 =
 				match client_slot c with
 				| FriendSlot -> "Friend", "F"
@@ -2494,8 +2510,10 @@
                   ] @
                   (if !!emule_mods_count then [( "0", "srh", "eMule MOD", "EM" )] else [])
                   @ [
-                  ( "0", "srh ar", "Total DL bytes from this client for all files", "DL" ) ;
-                  ( "0", "srh ar", "Total UL bytes to this client for all files", "UL" ) ;
+                  ( "0", "srh ar", "Total DL bytes from this client for all files", "tDL" ) ;
+                  ( "0", "srh ar", "Total UL bytes to this client for all files", "tUL" ) ;
+                  ( "0", "srh ar", "Session DL bytes from this client for all files", "sDL" ) ;
+                  ( "0", "srh ar", "Session UL bytes to this client for all files", "sUL" ) ;
                   ( "0", "srh", "Filename", "Filename" ) ]);
 
                 Intmap.iter (fun cnum c ->
@@ -2527,8 +2545,10 @@
                         ] @
                         (if !!emule_mods_count then [("", "sr", i.client_emulemod )] else [])
                         @ [
-                        ("", "sr ar", size_of_int64 i.client_downloaded);
-                        ("", "sr ar", size_of_int64 i.client_uploaded);
+                        ("", "sr ar", size_of_int64 i.client_total_downloaded);
+                        ("", "sr ar", size_of_int64 i.client_total_uploaded);
+                        ("", "sr ar", size_of_int64 i.client_session_downloaded);
+                        ("", "sr ar", size_of_int64 i.client_session_uploaded);
                         ("", "sr", (match i.client_upload with
                     	      Some f -> shorten f !!max_name_len
                     	    | None -> "") ) ]);
@@ -2547,7 +2567,7 @@
                 try
                   let i = client_info c in
                   client_print c o;
-                  Printf.bprintf buf "client: %s downloaded: %s uploaded: %s\n" i.client_software (Int64.to_string i.client_downloaded) (Int64.to_string i.client_uploaded);
+                  Printf.bprintf buf "client: %s downloaded: %s uploaded: %s\n" i.client_software (Int64.to_string i.client_total_downloaded) (Int64.to_string i.client_total_uploaded);
                   match i.client_upload with
                     Some cu ->
                       Printf.bprintf buf "      filename: %s\n" cu
@@ -2658,7 +2678,7 @@
                     end
               ) !!files) args;
         files_to_cancel o
-    ), "<num> :\t\t\t\tcancel download (use arg 'all' for all files)";
+    ), "<num|all> :\t\t\tcancel download (use arg 'all' for all files)";
 
     "downloaders", Arg_none (fun o ->
         let buf = o.conn_buf in
@@ -2679,8 +2699,10 @@
               ( "0", "srh", "Secure User Identification [N]one, [P]assed, [F]ailed", "S" ) ;
               ( "0", "srh", "IP address", "IP address" ) ;
               ] @ (if !Geoip.active then [( "0", "srh", "Country Code/Name", "CC" )] else []) @ [ 
-              ( "1", "srh ar", "Total UL bytes to this client for all files", "UL" ) ;
-              ( "1", "srh ar", "Total DL bytes from this client for all files", "DL" ) ;
+              ( "1", "srh ar", "Total UL bytes to this client for all files", "tUL");
+              ( "1", "srh ar", "Total DL bytes from this client for all files", "tDL");
+              ( "1", "srh ar", "Session UL bytes to this client for all files", "sUL");
+              ( "1", "srh ar", "Session DL bytes from this client for all files", "sDL");
               ( "0", "srh", "Filename", "Filename" ) ]);
 
         let counter = ref 0 in
@@ -2725,7 +2747,7 @@
                   if (as_file_impl file).impl_file_num = num then
                       file_pause file o.conn_user.ui_user
               ) !!files) args; ""
-    ), "<num> :\t\t\t\tpause a download (use arg 'all' for all files)";
+    ), "<num|all> :\t\t\tpause a download (use arg 'all' for all files)";
 
     "resume", Arg_multiple (fun args o ->
         if args = ["all"] && user2_is_admin o.conn_user.ui_user then
@@ -2739,7 +2761,7 @@
                   if (as_file_impl file).impl_file_num = num then
                       file_resume file o.conn_user.ui_user
               ) !!files) args; ""
-    ), "<num> :\t\t\t\tresume a paused download (use arg 'all' for all files)";
+    ), "<num|all> :\t\t\tresume a paused download (use arg 'all' for all files)";
 
     "release", Arg_one (fun arg o ->
 	let num = int_of_string arg in
@@ -3080,7 +3102,7 @@
         else
 	  print_command_result o buf "You are not allowed to add a group";
 	_s ""
-    ), "<group> <admin: true | false>: add new mldonkey group";
+    ), "<group> <admin: true|false> :\tadd new mldonkey group";
 
     "groupdel", Arg_one (fun group o ->
         let buf = o.conn_buf in
@@ -3345,22 +3367,22 @@
           end
 	end else print_command_result o buf "You are not allowed to list users";
           _s ""
-    ), "\t\t\t\t\tprint users";
+    ), ":\t\t\t\t\tprint users";
 
     "whoami", Arg_none (fun o ->
 	print_command_result o o.conn_buf o.conn_user.ui_user.user_name;
         _s ""
-    ), "\t\t\t\t\tprint logged-in user name";
+    ), ":\t\t\t\tprint logged-in user name";
 
     "groups", Arg_none (fun o ->
 	print_command_result o o.conn_buf (user2_print_user_groups " " o.conn_user.ui_user);
         _s ""
-    ), "\t\t\t\t\tprint groups of logged-in user";
+    ), ":\t\t\t\tprint groups of logged-in user";
 
     "dgroup", Arg_none (fun o ->
 	print_command_result o o.conn_buf (user2_print_user_default_group o.conn_user.ui_user);
         _s ""
-    ), "\t\t\t\t\tprint default group of logged-in user";
+    ), ":\t\t\t\tprint default group of logged-in user";
 
     "chgrp", Arg_two (fun group filenum o ->
         let num = int_of_string filenum in
@@ -3368,8 +3390,13 @@
           let file = file_find num in
 	  if String.lowercase group = "none" then
 	    begin
-	      set_file_group file None;
-	      print_command_result o o.conn_buf (Printf.sprintf (_b "Changed group of download %d to %s") num group)
+              if user2_allow_file_admin file o.conn_user.ui_user then
+                begin
+                  set_file_group file None;
+                  print_command_result o o.conn_buf (Printf.sprintf (_b "Changed group of download %d to %s") num group)
+                end
+              else
+                print_command_result o o.conn_buf (Printf.sprintf (_b "You are not allowed to change group of download %d to %s") num group)
 	    end
 	  else
 	    begin
@@ -3401,7 +3428,19 @@
 		if user2_allow_file_admin file o.conn_user.ui_user then
 		  begin
 		    set_file_owner file u;
-		    print_command_result o o.conn_buf (Printf.sprintf (_b "Changed owner of download %d to %s") num user)
+                    match file_group file with
+                    | None ->
+                        print_command_result o o.conn_buf (Printf.sprintf (_b "Changed owner of download %d to %s") num user)
+                    | Some g ->
+                        if List.mem g u.user_groups then
+                          print_command_result o o.conn_buf (Printf.sprintf (_b "Changed owner of download %d to %s") num user)
+                        else
+                          begin
+                            set_file_group file u.user_default_group;
+                            print_command_result o o.conn_buf (Printf.sprintf
+                              (_b "owner %s is not member of file_group %s, changing file_group to user_default_group %s")
+                              user g.group_name (user2_print_user_default_group u))
+                          end
 		  end
 		else		  
 		  print_command_result o o.conn_buf (Printf.sprintf (_b "You are not allowed to change owner of download %d to %s") num user)
Index: src/daemon/driver/driverInteractive.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/daemon/driver/driverInteractive.ml,v
retrieving revision 1.118
retrieving revision 1.122
diff -u -r1.118 -r1.122
--- src/daemon/driver/driverInteractive.ml	28 Nov 2006 23:17:31 -0000	1.118
+++ src/daemon/driver/driverInteractive.ml	3 Dec 2006 20:57:56 -0000	1.122
@@ -1115,7 +1115,8 @@
 
   if o.conn_output <> HTML && !!improved_telnet then
   begin
-    let list = Sort.list (fun f1 f2 -> percent f1 >= percent f2) list in
+    let list = 
+      List.sort (fun f1 f2 -> compare (percent f2) (percent f1)) list in
     simple_print_file_list false buf list o
   end
   else
@@ -1124,29 +1125,37 @@
       let sorter =
         match o.conn_sortvd with
 
-        | BySize -> (fun f1 f2 -> f1.file_size >= f2.file_size)
+        | BySize -> (fun f1 f2 -> compare f2.file_size f1.file_size)
         | ByRate -> (fun f1 f2 ->
-                if stalled f1 then false else
-                if stalled f2 then true else
-                  f1.file_download_rate >= f2.file_download_rate
-            )
-        | ByName -> (fun f1 f2 -> String.lowercase f1.file_name <= String.lowercase f2.file_name)
-        | ByDone -> (fun f1 f2 -> f1.file_downloaded >= f2.file_downloaded)
-	| ByPriority -> (fun f1 f2 -> f1.file_priority >= f2.file_priority)
-		| BySources -> (fun f1 f2 -> (number_of_sources f1) >= (number_of_sources f2))
-		| ByASources -> (fun f1 f2 -> (number_of_active_sources f1) >= (number_of_active_sources f2))
-        | ByPercent -> (fun f1 f2 -> percent f1 >= percent f2)
-        | ByETA -> (fun f1 f2 -> calc_file_eta f1 <= calc_file_eta f2)
-        | ByAge -> (fun f1 f2 -> f1.file_age >= f2.file_age)
-        | ByLast -> (fun f1 f2 -> f1.file_last_seen >= f2.file_last_seen)
-        | ByNet -> (fun f1 f2 -> net_name f1 <= net_name f2)
-        | ByAvail -> (fun f1 f2 -> get_file_availability f1 >= get_file_availability f2)
-        | ByComments -> (fun f1 f2 -> (number_of_comments f1) >= (number_of_comments f2))
-        | ByUser -> (fun f1 f2 -> f1.file_user <= f2.file_user)
-        | ByGroup -> (fun f1 f2 -> f1.file_group <= f2.file_group)
+                if stalled f1 then 1 else
+                if stalled f2 then -1 else
+                  compare f2.file_download_rate f1.file_download_rate)
+        | ByName -> (fun f1 f2 -> String.compare 
+		       (String.lowercase f1.file_name) 
+		       (String.lowercase f2.file_name))
+        | ByDone -> (fun f1 f2 -> 
+		       compare f2.file_downloaded f1.file_downloaded)
+	| ByPriority -> (fun f1 f2 -> 
+			   compare f2.file_priority f1.file_priority)
+	| BySources -> (fun f1 f2 -> compare 
+			  (number_of_sources f2) (number_of_sources f1))
+	| ByASources -> (fun f1 f2 -> 
+			   compare (number_of_active_sources f2) 
+			           (number_of_active_sources f1))
+        | ByPercent -> (fun f1 f2 -> compare (percent f2) (percent f1))
+        | ByETA -> (fun f1 f2 -> compare (calc_file_eta f1) (calc_file_eta f2))
+        | ByAge -> (fun f1 f2 -> compare f2.file_age f1.file_age)
+        | ByLast -> (fun f1 f2 -> compare f2.file_last_seen f1.file_last_seen)
+        | ByNet -> (fun f1 f2 -> compare (net_name f1) (net_name f2))
+        | ByAvail -> (fun f1 f2 -> compare 
+			(get_file_availability f2) (get_file_availability f1))
+        | ByComments -> (fun f1 f2 -> compare 
+			   (number_of_comments f2) (number_of_comments f1))
+        | ByUser -> (fun f1 f2 -> compare f1.file_user f2.file_user)
+        | ByGroup -> (fun f1 f2 -> compare f1.file_group f2.file_group)
         | NotSorted -> raise Not_found
       in
-      Sort.list sorter list
+      List.sort sorter list
     with _ -> list
   in
   simple_print_file_list false buf list o
@@ -1259,7 +1268,7 @@
                       let nl = ref false in
                       List.iter (fun t ->
                           match t.tag_name with
-                          | Field_UNKNOWN "FTH" | Field_UNKNOWN "urn" -> ()
+                          | Field_KNOWN "FTH" | Field_KNOWN "urn" -> ()
                           | _ ->
                               Buffer.add_string buf ((if !nl then "<br>" else begin nl := true;"" end) ^
                                 escaped_string_of_field t ^ ": " ^ get_tag_value t);
@@ -1275,7 +1284,7 @@
                       let nl = ref false in
                       List.iter (fun t ->
                           match t.tag_name with
-                          | Field_UNKNOWN "FTH" | Field_UNKNOWN "urn" -> ()
+                          | Field_KNOWN "FTH" | Field_KNOWN "urn" -> ()
                           | _ ->
                               Buffer.add_string buf ((if !nl then "\n" else begin nl := true;"" end) ^
                                   "|| (" ^
@@ -1331,8 +1340,8 @@
 	      let cformat = ref "" in
               List.iter (fun t ->
                   (match t.tag_name with
-                    | Field_UNKNOWN "urn"
-                    | Field_UNKNOWN "FTH"  -> hash := get_tag_value t
+                    | Field_KNOWN "urn"
+                    | Field_KNOWN "FTH"  -> hash := get_tag_value t
                     | Field_Availability -> cavail := get_tag_value t
                     | Field_Completesources -> csource := get_tag_value t
                     | Field_Length -> clength := get_tag_value t
@@ -1383,9 +1392,9 @@
                         | Field_Format
                         | Field_Bitrate
 (* TODO : "urn" shouldn't be some kind of Field_Uid of Gnutella ? *)
-                        | Field_UNKNOWN "urn"
+                        | Field_KNOWN "urn"
 (* TODO : "FTH" shouldn't be some kind of Field_Uid of Fasttrack ? *)
-                        | Field_UNKNOWN "FTH"  -> ()
+                        | Field_KNOWN "FTH"  -> ()
                         | _ ->
                             Buffer.add_string buf ("\\<span title=\\\"" ^
                                 get_tag_value t ^ "\\\"\\>(" ^
@@ -1490,9 +1499,9 @@
               user.ui_last_results <- (!counter, rs) :: user.ui_last_results;
               files := [|
 
+                (Printf.sprintf "[%5d]\\<input name=d type=checkbox value=%d\\>" !counter r.result_num);
                 (Int64.to_string r.result_size);
                 (string_of_int avail);
-                (Printf.sprintf "[%5d]\\<input name=d type=checkbox value=%d\\>" !counter r.result_num);
 
                 (
                   let names = r.result_names in
@@ -1704,8 +1713,8 @@
   Intmap.iter (fun r_num (avail,rs) ->
       let r = IndexedResults.get_result rs in
       results := (rs, r, !avail) :: !results) s.search_results;
-  let results = Sort.list (fun (_, r1,_) (_, r2,_) ->
-        r1.result_size > r2.result_size
+  let results = List.sort (fun (_, r1,_) (_, r2,_) ->
+        compare r2.result_size r1.result_size
     ) !results in
 
   Printf.bprintf buf "Result of search %d\n" s.search_num;
@@ -2448,7 +2457,9 @@
       ( "0", "srh", "Preview", "P" ) ;
       ( "0", "srh", "Filename", "Filename" );
       ( "0", "srh", "Statistic links", "Stats" );
-      ( "0", "srh", "Published on servers", "Publ" ) ]
+      ( "0", "srh", "Published on servers", "Publ" );
+      ( "0", "srh", "Share status", "Status" )
+    ]
   else
     begin
       Printf.bprintf buf " Requests |  Bytes   | Uploaded | File\n";
@@ -2456,10 +2467,10 @@
     end;
 
   html_mods_cntr_init ();
-  let list = Sort.list (fun f1 f2 ->
-      (f1.impl_shared_requests = f2.impl_shared_requests &&
-       f1.impl_shared_uploaded > f2.impl_shared_uploaded) ||
-      (f1.impl_shared_requests > f2.impl_shared_requests )
+  let list = List.sort (fun f1 f2 ->
+    let c = compare f2.impl_shared_requests f1.impl_shared_requests in
+    if c <> 0 then c else
+    compare f2.impl_shared_uploaded f1.impl_shared_uploaded
     ) list in
 
   List.iter (fun impl ->
@@ -2474,8 +2485,9 @@
 	(if !!html_mods_use_js_tooltips then
 	   Printf.bprintf buf " onMouseOver=\\\"mOvr(this);setTimeout('popLayer(\\\\\'%s<br>%s%s\\\\\')',%d);setTimeout('hideLayer()',%d);return true;\\\" onMouseOut=\\\"mOut(this);hideLayer();setTimeout('hideLayer()',%d)\\\"\\>"
 	    (Http_server.html_real_escaped (Filename.basename (Charset.to_utf8 impl.impl_shared_codedname)))
-	    (match impl.impl_shared_magic with
-	       None -> ""
+	    (match impl.impl_shared_file with
+	       None -> "no file info"
+	     | Some file -> match file_magic file with | None -> "no magic"
 	     | Some magic -> "File type: " ^ (Http_server.html_real_escaped magic) ^ "<br>")
 	    (if impl.impl_shared_servers = [] then "" else
 	       Printf.sprintf "<br>Published on %d %s<br>%s"
@@ -2497,7 +2509,6 @@
 
 	let uploaded = Int64.to_float impl.impl_shared_uploaded in
 	let size = Int64.to_float impl.impl_shared_size in
-
 	html_mods_td buf [
 	  ("", "sr ar", Printf.sprintf "%d" impl.impl_shared_requests);
 	  ("", "sr ar", size_of_int64 impl.impl_shared_uploaded);
@@ -2515,7 +2526,9 @@
                       (Md4.to_string impl.impl_shared_id) "T1"
                       (Md4.to_string impl.impl_shared_id) "T2"
                       (Md4.to_string impl.impl_shared_id) "B"));
-	  ("", "sr ar", Printf.sprintf "%d" published ) ];
+	  ("", "sr ar", Printf.sprintf "%d" published);
+	  ("", "sr", shared_state (as_shared impl) o);
+        ];
 	Printf.bprintf buf "\\</tr\\>\n";
       end
     else
Index: src/daemon/driver/driverMain.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/daemon/driver/driverMain.ml,v
retrieving revision 1.133
retrieving revision 1.134
diff -u -r1.133 -r1.134
--- src/daemon/driver/driverMain.ml	28 Nov 2006 23:15:21 -0000	1.133
+++ src/daemon/driver/driverMain.ml	8 Dec 2006 12:26:25 -0000	1.134
@@ -54,7 +54,6 @@
 
 let minute_timer () =
   DriverInteractive.hdd_check ();
-  CommonShared.shared_check_files ();
   CommonUploads.upload_credit_timer ();
   CommonInteractive.force_download_quotas ();
   CommonResult.dummy_result.result_time <- last_time ();
@@ -446,6 +445,10 @@
   add_infinite_timer 0.1 CommonUploads.upload_download_timer;
   add_infinite_timer !!buffer_writes_delay (fun _ -> Unix32.flush ());
 
+  add_infinite_timer ((float_of_int !!share_scan_interval) *. 60.)
+    (fun _ -> CommonShared.shared_check_files ());
+  CommonShared.shared_check_files ();
+
   history_timeflag := (Unix.time()); 
   update_download_history (); 
   update_upload_history ();
Index: src/gtk/newgui/gui_downloads.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/gtk/newgui/gui_downloads.ml,v
retrieving revision 1.18
retrieving revision 1.19
diff -u -r1.18 -r1.19
--- src/gtk/newgui/gui_downloads.ml	28 Nov 2006 12:58:11 -0000	1.18
+++ src/gtk/newgui/gui_downloads.ml	2 Dec 2006 12:35:46 -0000	1.19
@@ -1389,8 +1389,8 @@
                                                      else (c.client_software ^ 
                                                            " - " ^
                                                            c.client_emulemod))];
-                        child.data.gfile_size <- c.client_uploaded;
-                        child.data.gfile_downloaded <- c.client_downloaded;
+                        child.data.gfile_size <- c.client_total_uploaded;
+                        child.data.gfile_downloaded <- c.client_total_downloaded;
                         child.data.gfile_state  <- client_to_general_state c.client_state (List.hd f.data.gfile_num);
                         child.data.gfile_chunks <- f.data.gfile_chunks;
                         child.data.gfile_name <- 
@@ -1412,8 +1412,8 @@
                                          " - " ^
                                          c.client_emulemod];
                   f.data.gfile_state <- client_to_general_state c.client_state file_num;
-                  f.data.gfile_size <- c.client_uploaded;
-                  f.data.gfile_downloaded <- c.client_downloaded;
+                  f.data.gfile_size <- c.client_total_uploaded;
+                  f.data.gfile_downloaded <- c.client_total_downloaded;
                   if f.data.gfile_type <> c.client_type then
                     begin
                       f.data.gfile_type <- c.client_type;                 
Index: src/gtk/newgui/gui_friends.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/gtk/newgui/gui_friends.ml,v
retrieving revision 1.20
retrieving revision 1.21
diff -u -r1.20 -r1.21
--- src/gtk/newgui/gui_friends.ml	28 Nov 2006 12:58:11 -0000	1.20
+++ src/gtk/newgui/gui_friends.ml	2 Dec 2006 12:35:46 -0000	1.21
@@ -435,8 +435,10 @@
         client_os = None;
         client_release = c.gclient_release;
         client_emulemod = c.gclient_emulemod;
-        client_downloaded = c.gclient_downloaded;
-        client_uploaded = c.gclient_uploaded;
+        client_total_downloaded = c.gclient_downloaded;
+        client_total_uploaded = c.gclient_uploaded;
+        client_session_downloaded = 0L;
+        client_session_uploaded = 0L;
         client_upload = c.gclient_upload;
 	client_sui_verified = None;
 (*        client_sock_addr = c.gclient_sock_addr;*)
@@ -457,8 +459,8 @@
         gclient_software = c.client_software;
         gclient_release = c.client_release;
         gclient_emulemod = c.client_emulemod;
-        gclient_downloaded = c.client_downloaded;
-        gclient_uploaded = c.client_uploaded;
+        gclient_downloaded = c.client_total_downloaded;
+        gclient_uploaded = c.client_total_uploaded;
         gclient_upload = c.client_upload;
         gclient_sock_addr = string_of_kind c.client_kind;
         gclient_net_pixmap =
@@ -494,8 +496,8 @@
           f.gclient_software <- f_new.client_software;
           f.gclient_release <- f_new.client_release;
           f.gclient_emulemod <- f_new.client_emulemod;
-          f.gclient_downloaded <- f_new.client_downloaded;
-          f.gclient_uploaded <- f_new.client_uploaded;
+          f.gclient_downloaded <- f_new.client_total_downloaded;
+          f.gclient_uploaded <- f_new.client_total_uploaded;
           f.gclient_upload <- f_new.client_upload;
           f.gclient_sock_addr <- string_of_kind f_new.client_kind;
           if box_friends_is_visible then self#update_row f row
@@ -643,8 +645,10 @@
         client_os = None;
         client_release = c.gclient_release;
         client_emulemod = c.gclient_emulemod;
-        client_downloaded = c.gclient_downloaded;
-        client_uploaded = c.gclient_uploaded;
+        client_total_downloaded = c.gclient_downloaded;
+        client_total_uploaded = c.gclient_uploaded;
+        client_session_downloaded = 0L;
+        client_session_uploaded = 0L;
         client_upload = c.gclient_upload;
 	client_sui_verified = None;
 (*        client_sock_addr = string_of_kind c.gclient_kind; *)
@@ -665,8 +669,8 @@
         gclient_software = c.client_software;
         gclient_release = c.client_release;
         gclient_emulemod = c.client_emulemod;
-        gclient_downloaded = c.client_downloaded;
-        gclient_uploaded = c.client_uploaded;
+        gclient_downloaded = c.client_total_downloaded;
+        gclient_uploaded = c.client_total_uploaded;
         gclient_upload = c.client_upload;
         gclient_sock_addr = string_of_kind c.client_kind;
         gclient_net_pixmap = 
@@ -711,9 +715,9 @@
                     c.gclient_kind <- c_new.client_kind;
                     c.gclient_tags <- c_new.client_tags;
                     c.gclient_software <- c_new.client_software;
-                    c.gclient_downloaded <- c_new.client_downloaded;
+                    c.gclient_downloaded <- c_new.client_total_downloaded;
                     c.gclient_emulemod <- c_new.client_emulemod;
-                    c.gclient_uploaded <- c_new.client_uploaded;
+                    c.gclient_uploaded <- c_new.client_total_uploaded;
                     c.gclient_upload <- c_new.client_upload;
                     c.gclient_sock_addr <- string_of_kind c_new.client_kind;
             (if icons_are_used && (c.gclient_type <> c_new.client_type) 
Index: src/gtk/newgui/gui_results.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/gtk/newgui/gui_results.ml,v
retrieving revision 1.10
retrieving revision 1.11
diff -u -r1.10 -r1.11
--- src/gtk/newgui/gui_results.ml	20 Jul 2006 16:56:42 -0000	1.10
+++ src/gtk/newgui/gui_results.ml	3 Dec 2006 20:49:42 -0000	1.11
@@ -289,7 +289,7 @@
   let value = ref "" in
   List.iter (fun t ->
     match t.tag_name with
-        Field_UNKNOWN "codec" -> value := string_of_tag_value t.tag_value
+        Field_KNOWN "codec" -> value := string_of_tag_value t.tag_value
       | _ -> ()
   ) tags;
   !value
@@ -298,7 +298,7 @@
   let value = ref 0 in
   List.iter (fun t ->
     match t.tag_name with
-        Field_UNKNOWN "bitrate" -> value := int_of_tag_value t.tag_value
+        Field_KNOWN "bitrate" -> value := int_of_tag_value t.tag_value
       | _ -> ()
   ) tags;
   !value
Index: src/gtk2/gui/guiMisc.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/gtk2/gui/guiMisc.ml,v
retrieving revision 1.20
retrieving revision 1.22
diff -u -r1.20 -r1.22
--- src/gtk2/gui/guiMisc.ml	28 Nov 2006 12:58:11 -0000	1.20
+++ src/gtk2/gui/guiMisc.ml	3 Dec 2006 20:49:42 -0000	1.22
@@ -1055,7 +1055,7 @@
     | Field_Mediacodec -> "codec"
     | Field_Lastseencomplete -> "lastseencompl"
     | Field_Filerating -> "rating"
-    | Field_UNKNOWN s -> U.simple_utf8_of s
+    | Field_KNOWN s -> U.simple_utf8_of s
   
 let tags_to_string tags =
   let s = ref "" in
@@ -1276,8 +1276,8 @@
      source_connect_time    = BasicSocket.last_time () - c.client_connect_time;
      source_last_seen       = BasicSocket.current_time ();
      source_software        = concat_strings c.client_software (concat_strings c.client_emulemod c.client_release);
-     source_downloaded      = c.client_downloaded;
-     source_uploaded        = c.client_uploaded;
+     source_downloaded      = c.client_total_downloaded;
+     source_uploaded        = c.client_total_uploaded;
      source_upload_rate     = 0.;
      source_download_rate   = 0.;
      source_upload          = c.client_upload;
Index: src/networks/bittorrent/bTClients.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/networks/bittorrent/bTClients.ml,v
retrieving revision 1.84
retrieving revision 1.85
diff -u -r1.84 -r1.85
--- src/networks/bittorrent/bTClients.ml	5 Nov 2006 14:09:38 -0000	1.84
+++ src/networks/bittorrent/bTClients.ml	2 Dec 2006 12:35:46 -0000	1.85
@@ -272,6 +272,8 @@
         try
 (*          List.iter (fun r -> CommonSwarming.free_range r) c.client_ranges; *)
           set_client_disconnected c reason;
+          c.client_session_downloaded <- 0L;
+          c.client_session_uploaded <- 0L;
           (try if c.client_good then count_seen c with _ -> ());
           (* this is not useful already done in the match
           (try close sock reason with _ -> ());   *)
Index: src/networks/bittorrent/bTGlobals.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/networks/bittorrent/bTGlobals.ml,v
retrieving revision 1.72
retrieving revision 1.74
diff -u -r1.72 -r1.74
--- src/networks/bittorrent/bTGlobals.ml	26 Nov 2006 13:19:31 -0000	1.72
+++ src/networks/bittorrent/bTGlobals.ml	3 Dec 2006 20:57:56 -0000	1.74
@@ -124,7 +124,7 @@
           impl_shared_ops = shared_ops;
           impl_shared_val = file;
           impl_shared_requests = 0;
-          impl_shared_magic = None;
+          impl_shared_file = Some (as_file file);
           impl_shared_servers = [];
         } in
         file.file_shared <- Some impl;
@@ -786,8 +786,10 @@
           client_release = release;
           client_bitmap = None;
           client_allowed_to_write = zero;
-          client_uploaded = zero;
-          client_downloaded = zero;
+          client_total_uploaded = zero;
+          client_total_downloaded = zero;
+          client_session_uploaded = zero;
+          client_session_downloaded = zero;
           client_upload_rate = Rate.new_rate ();
           client_downloaded_rate = Rate.new_rate ();
           client_connect_time = last_time ();
Index: src/networks/bittorrent/bTInteractive.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/networks/bittorrent/bTInteractive.ml,v
retrieving revision 1.123
retrieving revision 1.125
diff -u -r1.123 -r1.125
--- src/networks/bittorrent/bTInteractive.ml	12 Nov 2006 14:17:45 -0000	1.123
+++ src/networks/bittorrent/bTInteractive.ml	3 Dec 2006 20:57:56 -0000	1.125
@@ -406,8 +406,10 @@
         ( "0", "srh", "IP address", "IP address" ) ;
         ( "0", "srh br ar", "Port", "Port" ) ;
         ] @ (if !Geoip.active then [( "0", "srh br ar", "Country Code/Name", "CC" )] else []) @ [
-        ( "1", "srh ar", "Total UL bytes to this client for all files", "UL" ) ;
-        ( "1", "srh ar br", "Total DL bytes from this client for all files", "DL" ) ;
+        ( "1", "srh ar", "Total UL bytes to this client for all files", "tUL" ) ;
+        ( "1", "srh ar br", "Total DL bytes from this client for all files", "tDL" ) ;
+        ( "1", "srh ar", "Session UL bytes to this client for all files", "sUL" ) ;
+        ( "1", "srh ar br", "Session DL bytes from this client for all files", "sDL" ) ;
         ( "0", "srh ar", "Interested [T]rue, [F]alse", "I" ) ;
         ( "0", "srh ar", "Choked [T]rue, [F]alse", "C" ) ;
         ( "1", "srh br ar", "Allowed to write", "A" ) ;
@@ -458,8 +460,10 @@
             ("", "sr", (Ip.to_string (fst c.client_host)));
             ("", "sr br ar", Printf.sprintf "%d" (snd c.client_host));
             ] @ (if !Geoip.active then [( cn, "sr br", cc)] else []) @ [
-            ("", "sr ar", (size_of_int64 c.client_uploaded));
-            ("", "sr ar br", (size_of_int64 c.client_downloaded));
+            ("", "sr ar", (size_of_int64 c.client_total_uploaded));
+            ("", "sr ar br", (size_of_int64 c.client_total_downloaded));
+            ("", "sr ar", (size_of_int64 c.client_session_uploaded));
+            ("", "sr ar br", (size_of_int64 c.client_session_downloaded));
             ("", "sr", (btos c.client_interested));
             ("", "sr", (btos c.client_choked));
             ("", "sr br ar", (Int64.to_string c.client_allowed_to_write));
@@ -880,8 +884,10 @@
     P.client_name = (Printf.sprintf "%s:%d" (Ip.to_string ip) port);
     P.client_software = (brand_to_string c.client_brand);
     P.client_release = c.client_release;
-    P.client_downloaded = c.client_downloaded;
-    P.client_uploaded = c.client_uploaded;
+    P.client_total_downloaded = c.client_total_downloaded;
+    P.client_total_uploaded = c.client_total_uploaded;
+    P.client_session_downloaded = c.client_session_downloaded;
+    P.client_session_uploaded = c.client_session_uploaded;
     P.client_upload = Some (c.client_file.file_name);
     P.client_connect_time = c.client_connect_time;
 
@@ -906,11 +912,11 @@
   let cc = as_client c in
   client_print cc o;
   Printf.bprintf buf (_b "\n%18sDown  : %-10s                  Uploaded: %-10s  Ratio: %s%1.1f (%s)\n") ""
-    (Int64.to_string c.client_downloaded)
-  (Int64.to_string c.client_uploaded)
-  (if c.client_downloaded > c.client_uploaded then "-" else "+")
-  (if c.client_uploaded > Int64.zero then 
-     Int64.to_float (c.client_downloaded // c.client_uploaded) 
+    (Int64.to_string c.client_total_downloaded)
+  (Int64.to_string c.client_total_uploaded)
+  (if c.client_total_downloaded > c.client_total_uploaded then "-" else "+")
+  (if c.client_total_uploaded > Int64.zero then 
+     Int64.to_float (c.client_total_downloaded // c.client_total_uploaded) 
    else 1.)
   ("BT");
   (Printf.bprintf buf (_b "%18sFile  : %s\n") "" info.GuiTypes.file_name)
@@ -948,8 +954,10 @@
         ("", "sr", "N");
         ("", "sr", (Ip.to_string (fst c.client_host)));
         ] @ (if !Geoip.active then [(cn, "sr", cc)] else []) @ [
-        ("", "sr ar", (size_of_int64 c.client_uploaded));
-        ("", "sr ar", (size_of_int64 c.client_downloaded));
+        ("", "sr ar", (size_of_int64 c.client_total_uploaded));
+        ("", "sr ar", (size_of_int64 c.client_total_downloaded));
+        ("", "sr ar", (size_of_int64 c.client_session_uploaded));
+        ("", "sr ar", (size_of_int64 c.client_session_downloaded));
         ("", "sr", info.GuiTypes.file_name); ]);
     true
 
@@ -1263,6 +1271,9 @@
 
   CommonNetwork.register_commands commands;
 
+  shared_ops.op_shared_state <- (fun file o ->
+      "no BT data"
+  );
   shared_ops.op_shared_unshare <- (fun file ->
       (if !verbose_share then lprintf_file_nl (as_file file) "unshare file");
       BTGlobals.unshare_file file);
Index: src/networks/bittorrent/bTStats.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/networks/bittorrent/bTStats.ml,v
retrieving revision 1.8
retrieving revision 1.9
diff -u -r1.8 -r1.9
--- src/networks/bittorrent/bTStats.ml	23 Sep 2006 20:29:47 -0000	1.8
+++ src/networks/bittorrent/bTStats.ml	2 Dec 2006 12:35:46 -0000	1.9
@@ -57,7 +57,8 @@
   stats_array.(i).brand_download <- stats_array.(i).brand_download ++ v;
   !!gstats_array.(i).brand_download <- !!gstats_array.(i).brand_download ++ v;
 
-  c.client_downloaded <- c.client_downloaded ++ v;
+  c.client_total_downloaded <- c.client_total_downloaded ++ v;
+  c.client_session_downloaded <- c.client_session_downloaded ++ v;
   bt_download_counter := !bt_download_counter ++ v;
   global_count_download network v
 
@@ -66,7 +67,8 @@
   stats_array.(i).brand_upload <- stats_array.(i).brand_upload ++ v;
   !!gstats_array.(i).brand_upload <- !!gstats_array.(i).brand_upload ++ v;
 
-  c.client_uploaded <- c.client_uploaded ++ v;
+  c.client_total_uploaded <- c.client_total_uploaded ++ v;
+  c.client_session_uploaded <- c.client_session_uploaded ++ v;
   bt_upload_counter := !bt_upload_counter ++ v;
   global_count_upload network v
 
Index: src/networks/bittorrent/bTTypes.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/networks/bittorrent/bTTypes.ml,v
retrieving revision 1.40
retrieving revision 1.41
diff -u -r1.40 -r1.41
--- src/networks/bittorrent/bTTypes.ml	26 Nov 2006 13:19:31 -0000	1.40
+++ src/networks/bittorrent/bTTypes.ml	2 Dec 2006 12:35:46 -0000	1.41
@@ -227,8 +227,10 @@
     mutable client_allowed_to_write : int64;
     mutable client_upload_rate : Rate.t;
     mutable client_downloaded_rate :  Rate.t;
-    mutable client_downloaded : int64;
-    mutable client_uploaded : int64;
+    mutable client_total_downloaded : int64;
+    mutable client_total_uploaded : int64;
+    mutable client_session_downloaded : int64;
+    mutable client_session_uploaded : int64;
     mutable client_connect_time : int;
 
     mutable client_blocks_sent : int list;
Index: src/networks/direct_connect/dcInteractive.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/networks/direct_connect/dcInteractive.ml,v
retrieving revision 1.28
retrieving revision 1.29
diff -u -r1.28 -r1.29
--- src/networks/direct_connect/dcInteractive.ml	1 Oct 2006 17:54:00 -0000	1.28
+++ src/networks/direct_connect/dcInteractive.ml	3 Dec 2006 20:49:42 -0000	1.29
@@ -248,13 +248,13 @@
         P.user_tags = (
           let list = if user.user_data > 1. then 
               [ 
-                { tag_name =  Field_UNKNOWN "link"; tag_value = String user.user_link };
-                { tag_name =  Field_UNKNOWN "shared"; tag_value = String (
+                { tag_name =  Field_KNOWN "link"; tag_value = String user.user_link };
+                { tag_name =  Field_KNOWN "shared"; tag_value = String (
                     Printf.sprintf "%12.0f" user.user_data) }
               ]          else []
           in
           if user.user_admin then
-            { tag_name =  Field_UNKNOWN "admin"; tag_value = String "admin" } :: list
+            { tag_name =  Field_KNOWN "admin"; tag_value = String "admin" } :: list
           else list
         );
             
Index: src/networks/donkey/donkeyClient.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/networks/donkey/donkeyClient.ml,v
retrieving revision 1.110
retrieving revision 1.114
diff -u -r1.110 -r1.114
--- src/networks/donkey/donkeyClient.ml	26 Nov 2006 16:36:29 -0000	1.110
+++ src/networks/donkey/donkeyClient.ml	3 Dec 2006 20:49:42 -0000	1.114
@@ -68,40 +68,43 @@
 (*************************************************************************)
 (*              adding a source to the source-management                 *)
 (*************************************************************************)
-let add_source file ip port serverIP serverPort =
-    (* man, we are receiving sources from some clients even when we release *)
-    if (file_state file) = FileDownloading then
-        try
-            let uid = 
-                if low_id ip then
-                  (* indirect address *)
-                  begin
-                    try
-                        (* without server, we can't request a callback *)
-                        let s = Hashtbl.find servers_by_key serverIP in
-                        if serverPort = s.server_port then
-                            Indirect_address ( serverIP, serverPort, id_of_ip ip, 0, Ip.null )
-                        else
-                            raise Not_found
-                    with _ ->
-                        raise Not_found
-                  end
+let add_source file ip tcp_port serverIP serverPort =
+  (* man, we are receiving sources from some clients even when we release *)
+  if (file_state file) = FileDownloading then
+    try
+      let uid = 
+    	if low_id ip then
+          begin
+            try
+              (* without server, we can't request a callback *)
+              let s = Hashtbl.find servers_by_key serverIP in
+                if serverPort = s.server_port then
+                  Indirect_address (serverIP, serverPort, id_of_ip ip, 0, Ip.null)
                 else
-                  (* direct adsdess *)
-                  if Ip.usable ip then
-                    if not ( is_black_address ip port ) then
-                        if not ( Hashtbl.mem banned_ips ip) then
-                            Direct_address ( ip, port )
-                        else
-                            raise Not_found
-                    else
-                        raise Not_found
-                  else
-                    raise Not_found
-            in
-            let s = DonkeySources.find_source_by_uid uid in
-            DonkeySources.set_request_result s file.file_sources File_new_source;
-        with Not_found -> ()
+                  raise Not_found
+            with Not_found ->
+              if !!update_server_list_client then
+                begin
+                  ignore (check_add_server serverIP serverPort);
+                  Indirect_address (serverIP, serverPort, id_of_ip ip, 0, Ip.null)
+                end
+              else raise Not_found
+          end
+        else
+          if Ip.usable ip then
+            if not ( is_black_address ip tcp_port ) then
+              if not ( Hashtbl.mem banned_ips ip) then
+                Direct_address ( ip, tcp_port )
+              else
+                raise Not_found
+            else
+              raise Not_found
+          else
+            raise Not_found
+      in
+      let s = DonkeySources.find_source_by_uid uid in
+      DonkeySources.set_request_result s file.file_sources File_new_source;
+    with Not_found -> ()
 
 let is_banned c sock = 
   c.client_banned <- Hashtbl.mem banned_ips (fst (peer_addr sock))
@@ -245,18 +248,22 @@
       c.client_source.DonkeySources.source_sock <- NoConnection
   | Connection sock ->
       (try
-    let log_print cc =
-            lprintf_nl "Client[%d] %s disconnected, connected %s%s%s"
-        (client_num cc)
-        (full_client_identifier cc)
-        (Date.time_to_string (last_time () - cc.client_connect_time) "verbose")
-        (if cc.client_uploaded > 0L then
-    Printf.sprintf ", send %s" (size_of_int64 cc.client_uploaded) else "")
-        (if cc.client_downloaded > 0L then
-    Printf.sprintf ", rec %s" (size_of_int64 cc.client_downloaded) else "")
+    let log_print cc = lprintf_nl "Client[%d] %s disconnected, connected %s%s%s"
+      (client_num c) (full_client_identifier c)
+      (Date.time_to_string (last_time () - c.client_connect_time) "verbose")
+      (if c.client_total_uploaded > 0L then
+        Printf.sprintf ", send %s (%s)%s"
+          (size_of_int64 c.client_session_uploaded)
+          (size_of_int64 c.client_total_uploaded)
+          (match client_upload (as_client c) with | None -> ""
+           | Some f -> " of " ^ (CommonFile.file_best_name f)) else "")
+      (if c.client_total_downloaded > 0L then
+        Printf.sprintf ", rec %s (%s)"
+          (size_of_int64 c.client_session_downloaded)
+          (size_of_int64 c.client_total_downloaded) else "")
     in
     if c.client_debug ||
-      (!verbose && (c.client_uploaded > 0L || c.client_downloaded > 0L)) then
+      (!verbose && (c.client_session_uploaded > 0L || c.client_session_downloaded > 0L)) then
       log_print c;
 
           c.client_comp <- None;
@@ -599,7 +606,7 @@
       List.iter (fun tag ->
         let s = to_lowercase (string_of_tag_value tag.tag_value) in 
           match tag.tag_name with
-           Field_UNKNOWN "mod_version" ->
+           Field_KNOWN "mod_version" ->
                begin
                let rec iter i len =
                 if i < len then
@@ -661,33 +668,40 @@
    iter 0 (Array.length mod_array)
 
 let update_client_from_tags c tags =
+  let module M = DonkeyProtoClient in
   List.iter (fun tag ->
       match tag.tag_name with
-      | Field_UNKNOWN "name" -> ()
-      | Field_UNKNOWN "version" -> ()
-      | Field_UNKNOWN "emule_udpports" -> 
+      | Field_KNOWN "emule_udpports" -> 
           for_two_int16_tag tag (fun ed2k_port kad_port ->
 (* Kademlia: we should use this client to bootstrap Kademlia *)
             if kad_port <> 0 && !!enable_kademlia then
               DonkeyProtoKademlia.Kademlia.bootstrap 
                 c.client_ip kad_port
           )
-      | Field_UNKNOWN "emule_miscoptions1" ->
+      | Field_KNOWN "emule_miscoptions1" ->
           for_int64_tag tag (fun i ->
-            DonkeyProtoClient.update_emule_proto_from_miscoptions1
-            c.client_emule_proto i
+            M.update_emule_proto_from_miscoptions1
+            c.client_emule_proto i;
+            if !verbose_msg_clients || c.client_debug then
+              lprintf_nl "miscoptions1 from client %s\n%s"
+                (full_client_identifier c)
+                (M.print_emule_proto_miscoptions1 c.client_emule_proto)
           )
-      | Field_UNKNOWN "emule_miscoptions2" ->
+      | Field_KNOWN "emule_miscoptions2" ->
           for_int64_tag tag (fun i ->
-            DonkeyProtoClient.update_emule_proto_from_miscoptions2
-            c.client_emule_proto i
+            M.update_emule_proto_from_miscoptions2
+            c.client_emule_proto i;
+            if !verbose_msg_clients || c.client_debug then
+              lprintf_nl "miscoptions2 from client %s\n%s"
+                (full_client_identifier c)
+                (M.print_emule_proto_miscoptions2 c.client_emule_proto)
           )
-      | Field_UNKNOWN "emule_compatoptions" ->
+      | Field_KNOWN "emule_compatoptions" ->
           for_int_tag tag (fun i ->
-            DonkeyProtoClient.update_emule_proto_from_compatoptions
+            M.update_emule_proto_from_compatoptions
             c.client_emule_proto i
           )
-      | Field_UNKNOWN "emule_version" ->
+      | Field_KNOWN "emule_version" ->
           for_int_tag tag (fun i ->
             c.client_emule_proto.emule_version <- i;
             let compatibleclient = (i lsr 24) in
@@ -697,60 +711,62 @@
             if c.client_brand = Brand_unknown then
               lprintf_nl "[emule_version] Brand_unknown %s" (full_client_identifier c);
           )
-      | Field_UNKNOWN "mod_version" ->
+      | Field_KNOWN "mod_version" ->
           let s = to_lowercase (string_of_tag_value tag.tag_value) in 
           parse_mod_version s c
-      | _ -> 
-          if !verbose_msg_clienttags then
-            lprintf_nl "Unknown Emule tag: [%s] (update_client_from_tags)" (escaped_string_of_field tag)
+      | Field_KNOWN _ -> if !verbose_unknown_messages then
+            lprintf_nl "update_client_from_tags, known tag: [%s] (%s)" (string_of_tag tag) (full_client_identifier c)
+      | _ -> if not (DonkeySources.source_brand c.client_source) then
+            lprintf_nl "update_client_from_tags, unknown tag: [%s] (%s) %s"
+              (hexstring_of_tag tag) (full_client_identifier c) (string_of_tags_list tags)
   ) tags
     
 let update_emule_proto_from_tags c tags =
   List.iter (fun tag ->
       match tag.tag_name with
-        Field_UNKNOWN "compatibleclient" ->
+        Field_KNOWN "compatibleclient" ->
           for_int_tag tag (fun i ->
             c.client_brand <- parse_compatible_client i c.client_brand;
             if c.client_brand = Brand_unknown then
               lprintf_nl "unknown compatibleclient %d (%s) (please report to dev team)" i (full_client_identifier c)
           )
-      | Field_UNKNOWN "compression" ->
+      | Field_KNOWN "compression" ->
           for_int_tag tag (fun i ->
             c.client_emule_proto.emule_compression <- i
           )
-      | Field_UNKNOWN "udpver" ->
+      | Field_KNOWN "udpver" ->
           for_int_tag tag (fun i ->
             c.client_emule_proto.emule_udpver <- i
           )
-      | Field_UNKNOWN "udpport" -> ()
-      | Field_UNKNOWN "sourceexchange" ->
+      | Field_KNOWN "sourceexchange" ->
           for_int_tag tag (fun i ->
             c.client_emule_proto.emule_sourceexchange <- i
           ) 
-      | Field_UNKNOWN "comments" ->
+      | Field_KNOWN "comments" ->
           for_int_tag tag (fun i ->
             c.client_emule_proto.emule_comments <- i
           )
-      | Field_UNKNOWN "extendedrequest" ->
+      | Field_KNOWN "extendedrequest" ->
           for_int_tag tag (fun i ->
             c.client_emule_proto.emule_extendedrequest <- i
           )
-      | Field_UNKNOWN "features" ->
+      | Field_KNOWN "features" ->
           for_int_tag tag (fun i ->
             c.client_emule_proto.emule_secident <- i land 0x3
           )
-      | Field_UNKNOWN "mod_version" ->
-          let s = to_lowercase (string_of_tag_value tag.tag_value) in 
-          parse_mod_version s c;
+      | Field_KNOWN "mod_version" ->
+          parse_mod_version (to_lowercase (string_of_tag_value tag.tag_value)) c;
 
-      | Field_UNKNOWN "os_info" ->
+      | Field_KNOWN "os_info" ->
           let s = to_lowercase (string_of_tag_value tag.tag_value) in 
 	  (match c.client_osinfo with
 	    Some _ -> ()
 	  | _ ->  if s <> "" then c.client_osinfo <- Some s)
-      | _ -> 
-          if !verbose_msg_clienttags then
-            lprintf_nl "Unknown Emule tag: [%s] (update_emule_proto_from_tags)" (escaped_string_of_field tag)
+      | Field_KNOWN _ -> if !verbose_unknown_messages then
+            lprintf_nl "update_emule_proto_from_tags, known tag: [%s] (%s)" (string_of_tag tag) (full_client_identifier c)
+      | _ -> if not (DonkeySources.source_brand c.client_source) then
+            lprintf_nl "update_emule_proto_from_tags, unknown tag: [%s] (%s) %s"
+              (hexstring_of_tag tag) (full_client_identifier c) (string_of_tags_list tags)
   ) tags
 
 let fight_disguised_mods c =
@@ -771,7 +787,7 @@
 	emule_info with
 	DonkeyProtoClient.EmuleClientInfo.protversion = 255;
 	DonkeyProtoClient.EmuleClientInfo.tags = [
-	  string_tag (Field_UNKNOWN "os_info") (String2.upp_initial Autoconf.system);
+	  string_tag (Field_KNOWN "os_info") (String2.upp_initial Autoconf.system);
 	]} in
       client_send c (DonkeyProtoClient.EmuleClientInfoReq emule_osinfo);
       c.client_osinfo_sent <- true
@@ -1160,7 +1176,7 @@
 
       List.iter (fun tag ->
           match tag with
-            { tag_name = Field_UNKNOWN "name"; tag_value = String s } -> 
+            { tag_name = Field_KNOWN "name"; tag_value = String s } -> 
               set_client_name c s t.CR.md4
           | _ -> ()
       ) c.client_tags;
@@ -2018,13 +2034,13 @@
       begin
         
         if !!dynamic_upload_lifetime
-            && c.client_uploaded > c.client_downloaded
-            && c.client_uploaded > Int64.of_int !!dynamic_upload_threshold ** zone_size
+            && c.client_session_uploaded > c.client_session_downloaded
+            && c.client_session_uploaded > Int64.of_int !!dynamic_upload_threshold ** zone_size
         then
           client_upload_lifetime :=
           Int64.to_int 
             (Int64.of_int !client_upload_lifetime 
-              ** c.client_downloaded // c.client_uploaded);
+              ** c.client_session_downloaded // c.client_session_uploaded);
         if last_time() > c.client_connect_time + 
             !client_upload_lifetime + 5 * prio then
           begin
@@ -2193,7 +2209,7 @@
       let name = ref "" in
       List.iter (fun tag ->
           match tag with
-            { tag_name = Field_UNKNOWN "name"; tag_value = String s } -> name := s
+            { tag_name = Field_KNOWN "name"; tag_value = String s } -> name := s
           | _ ->  ()
       ) t.CR.tags;
 
Index: src/networks/donkey/donkeyGlobals.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/networks/donkey/donkeyGlobals.ml,v
retrieving revision 1.110
retrieving revision 1.112
diff -u -r1.110 -r1.112
--- src/networks/donkey/donkeyGlobals.ml	26 Nov 2006 16:36:29 -0000	1.110
+++ src/networks/donkey/donkeyGlobals.ml	4 Dec 2006 12:00:19 -0000	1.112
@@ -595,8 +595,10 @@
       client_osinfo = None;
       client_checked = false;
       client_connected = false;
-      client_downloaded = Int64.zero;
-      client_uploaded = Int64.zero;
+      client_session_downloaded = Int64.zero;
+      client_session_uploaded = Int64.zero;
+      client_total_downloaded = Int64.zero;
+      client_total_uploaded = Int64.zero;
       client_banned = false;
       client_score = 0;
       client_next_queue = 0;
@@ -650,8 +652,10 @@
       client_osinfo = None;
       client_checked = false;
       client_connected = false;
-      client_downloaded = Int64.zero;
-      client_uploaded = Int64.zero;
+      client_total_downloaded = Int64.zero;
+      client_total_uploaded = Int64.zero;
+      client_session_downloaded = Int64.zero;
+      client_session_uploaded = Int64.zero;
       client_banned = false;
       client_score = 0;
       client_next_queue = 0;
@@ -1018,6 +1022,6 @@
 let full_client_identifier c =
     Printf.sprintf "%s (%s%s) '%s'"
       (Ip.to_string c.client_ip)
-      (brand_to_string_short c.client_brand)
+      (GuiTypes.client_software_short (brand_to_string_short c.client_brand) c.client_osinfo)
       (if c.client_emule_proto.emule_release = "" then "" else " " ^ c.client_emule_proto.emule_release)
       (String.escaped c.client_name)
Index: src/networks/donkey/donkeyImport.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/networks/donkey/donkeyImport.ml,v
retrieving revision 1.10
retrieving revision 1.12
diff -u -r1.10 -r1.12
--- src/networks/donkey/donkeyImport.ml	14 Nov 2006 18:42:59 -0000	1.10
+++ src/networks/donkey/donkeyImport.ml	6 Dec 2006 00:49:14 -0000	1.12
@@ -56,26 +56,32 @@
     let names_of_tag =
 (* eMule sourcefile opcodes.h //server.met *)
       [
-        "\001", Field_UNKNOWN "name";                (* 0x01 string *)
-        "\011", Field_UNKNOWN "description";         (* 0x0B string *)
-        "\012", Field_UNKNOWN "ping";                (* 0x0C uint32 *)
-        "\013", Field_UNKNOWN "history";             (* 0x0D ST_FAIL *)
-        "\014", Field_UNKNOWN "prof";                (* 0x0E ST_PREFERENCE *)
-        "\015", Field_UNKNOWN "port";                (* 0x0F uint32 *)
-        "\016", Field_UNKNOWN "ip";                  (* 0x10 uint32 *)
-        "\133", Field_UNKNOWN "dynip";               (* 0x85 string *)
-        "\135", Field_UNKNOWN "maxusers";            (* 0x87 uint32 *)
-        "\136", Field_UNKNOWN "softfiles";           (* 0x88 uint32 *)
-        "\137", Field_UNKNOWN "hardfiles";           (* 0x89 uint32 *)
-        "\144", Field_UNKNOWN "lastping";            (* 0x90 uint32 *)
-        "\145", Field_UNKNOWN "version";             (* 0x91 string|uint32 *)
-        "\146", Field_UNKNOWN "udpflags";            (* 0x92 uint32 *)
-        "\147", Field_UNKNOWN "auxportslist";        (* 0x93 string *)
-        "\148", Field_UNKNOWN "lowidusers";          (* 0x94 uint32 *)
-        "\149", Field_UNKNOWN "udpkey";              (* 0x95 uint32 *)
-        "\150", Field_UNKNOWN "udpkeyip";            (* 0x96 uint32 *)
-        "\151", Field_UNKNOWN "tcpportobfuscation";  (* 0x97 uint16 *)
-        "\152", Field_UNKNOWN "udpportobfuscation";  (* 0x98 uint16 *)
+        "\001", Field_KNOWN "name";                (* 0x01 string *)
+        "\011", Field_KNOWN "description";         (* 0x0B string *)
+        "\012", Field_KNOWN "ping";                (* 0x0C uint32 *)
+        "\013", Field_KNOWN "history";             (* 0x0D ST_FAIL *)
+        "\014", Field_KNOWN "prof";                (* 0x0E ST_PREFERENCE *)
+        "\015", Field_KNOWN "port";                (* 0x0F uint32 *)
+        "\016", Field_KNOWN "ip";                  (* 0x10 uint32 *)
+        "\133", Field_KNOWN "dynip";               (* 0x85 string *)
+        "\135", Field_KNOWN "maxusers";            (* 0x87 uint32 *)
+        "maxusers", Field_KNOWN "maxusers";
+        "\136", Field_KNOWN "softfiles";           (* 0x88 uint32 *)
+        "\137", Field_KNOWN "hardfiles";           (* 0x89 uint32 *)
+        "\144", Field_KNOWN "lastping";            (* 0x90 uint32 *)
+        "\145", Field_KNOWN "version";             (* 0x91 string|uint32 *)
+        "\146", Field_KNOWN "udpflags";            (* 0x92 uint32 *)
+        "\147", Field_KNOWN "auxportslist";        (* 0x93 string *)
+        "\148", Field_KNOWN "lowusers";            (* 0x94 uint32 *)
+        "lowusers", Field_KNOWN "lowusers";
+        "\149", Field_KNOWN "udpkey";              (* 0x95 uint32 *)
+        "\150", Field_KNOWN "udpkeyip";            (* 0x96 uint32 *)
+        "\151", Field_KNOWN "tcpportobfuscation";  (* 0x97 uint16 *)
+        "\152", Field_KNOWN "udpportobfuscation";  (* 0x98 uint16 *)
+        "files", Field_KNOWN "files";
+        "users", Field_KNOWN "users";
+        "country", Field_KNOWN "country";
+        "refs", Field_KNOWN "refs";
       ]
     
     
@@ -204,12 +210,12 @@
     
     let names_of_tag =
       [
-        "\008", Field_UNKNOWN "downloaded";
-        "\018", Field_UNKNOWN "diskname";
-        "\019", Field_UNKNOWN "priority";
-        "\020", Field_UNKNOWN "status";
-        "\t", Field_UNKNOWN "start_pos";
-        "\n", Field_UNKNOWN "absent";
+        "\008", Field_KNOWN "downloaded";
+        "\018", Field_KNOWN "diskname";
+        "\019", Field_KNOWN "priority";
+        "\020", Field_KNOWN "status";
+        "\t", Field_KNOWN "start_pos";
+        "\n", Field_KNOWN "absent";
       ] @ file_common_tags
     
     
@@ -231,8 +237,8 @@
       List.iter (fun tag ->
           let s = tag.tag_name in
           match s, tag.tag_value with
-            Field_UNKNOWN "start_pos", Uint64 p -> start_pos := p;
-          | Field_UNKNOWN "absent", Uint64 p -> 
+            Field_KNOWN "start_pos", Uint64 p -> start_pos := p;
+          | Field_KNOWN "absent", Uint64 p -> 
                 absents := (!start_pos, p) :: !absents;
             | _ -> ()
       ) tags;
@@ -285,9 +291,9 @@
     
     let names_of_client_tag =
       [
-        "\001", Field_UNKNOWN  "name";
-        "\017", Field_UNKNOWN "version";
-        "\015", Field_UNKNOWN "port";
+        "\001", Field_KNOWN  "name";
+        "\017", Field_KNOWN "version";
+        "\015", Field_KNOWN "port";
       ]
       
     let names_of_option_tag = []
Index: src/networks/donkey/donkeyInteractive.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/networks/donkey/donkeyInteractive.ml,v
retrieving revision 1.140
retrieving revision 1.145
diff -u -r1.140 -r1.145
--- src/networks/donkey/donkeyInteractive.ml	26 Nov 2006 17:27:40 -0000	1.140
+++ src/networks/donkey/donkeyInteractive.ml	6 Dec 2006 22:33:05 -0000	1.145
@@ -113,44 +113,44 @@
           let server = check_add_server r.S.ip r.S.port in
           List.iter (fun tag ->
               match tag with
-              |  { tag_name = Field_UNKNOWN "name"; tag_value = String s } ->
+              |  { tag_name = Field_KNOWN "name"; tag_value = String s } ->
                   server.server_name <- s;
-              |  { tag_name = Field_UNKNOWN "description" ; tag_value = String s } ->
+              |  { tag_name = Field_KNOWN "description" ; tag_value = String s } ->
                   server.server_description <- s
-              |  { tag_name = Field_UNKNOWN "version" ; tag_value = Uint64 s } ->
+              |  { tag_name = Field_KNOWN "version" ; tag_value = Uint64 s } ->
                   server.server_version <- Printf.sprintf "%d.%d"
 					    ((Int64.to_int s) lsr 16) ((Int64.to_int s) land 0xFFFF)
-              |  { tag_name = Field_UNKNOWN "ping" ; tag_value = Uint64 s } ->
+              |  { tag_name = Field_KNOWN "ping" ; tag_value = Uint64 s } ->
                   server.server_ping <- (Int64.to_int s)
-              |  { tag_name = Field_UNKNOWN "dynip" ; tag_value = String s } ->
+              |  { tag_name = Field_KNOWN "dynip" ; tag_value = String s } ->
                   server.server_dynip <- s
-              |  { tag_name = Field_UNKNOWN "users" ; tag_value = Uint64 s } ->
+              |  { tag_name = Field_KNOWN "users" ; tag_value = Uint64 s } ->
                   (match server.server_nusers with
 		  | None -> server.server_nusers <- Some s | _ -> ())
-              |  { tag_name = Field_UNKNOWN "files" ; tag_value = Uint64 s } ->
+              |  { tag_name = Field_KNOWN "files" ; tag_value = Uint64 s } ->
                   (match server.server_nfiles with
 		  | None -> server.server_nfiles <- Some s | _ -> ())
-              |  { tag_name = Field_UNKNOWN "maxusers" ; tag_value = Uint64 s } ->
+              |  { tag_name = Field_KNOWN "maxusers" ; tag_value = Uint64 s } ->
                   (match server.server_max_users with
 		  | None -> server.server_max_users <- Some s | _ -> ())
-              |  { tag_name = Field_UNKNOWN "softfiles" ; tag_value = Uint64 s } ->
+              |  { tag_name = Field_KNOWN "softfiles" ; tag_value = Uint64 s } ->
                   (match server.server_soft_limit with
 		  | None -> server.server_soft_limit <- Some s | _ -> ())
-              |  { tag_name = Field_UNKNOWN "hardfiles" ; tag_value = Uint64 s } ->
+              |  { tag_name = Field_KNOWN "hardfiles" ; tag_value = Uint64 s } ->
                   (match server.server_hard_limit with
 		  | None -> server.server_hard_limit <- Some s | _ -> ())
-              |  { tag_name = Field_UNKNOWN "auxportslist" ; tag_value = String s } ->
+              |  { tag_name = Field_KNOWN "auxportslist" ; tag_value = String s } ->
                   server.server_auxportslist <- s
-              |  { tag_name = Field_UNKNOWN "lowusers" ; tag_value = Uint64 s } ->
+              |  { tag_name = Field_KNOWN "lowusers" ; tag_value = Uint64 s } ->
                   (match server.server_lowid_users with
 		  | None -> server.server_lowid_users <- Some s | _ -> ())
-              |  { tag_name = Field_UNKNOWN "tcpportobfuscation" ; tag_value = Uint64 s } ->
+              |  { tag_name = Field_KNOWN "tcpportobfuscation" ; tag_value = Uint64 s } ->
                   server.server_obfuscation_tcp <- Some (Int64.to_int s)
-              |  { tag_name = Field_UNKNOWN "udpportobfuscation" ; tag_value = Uint64 s } ->
+              |  { tag_name = Field_KNOWN "udpportobfuscation" ; tag_value = Uint64 s } ->
                   server.server_obfuscation_udp <- Some (Int64.to_int s)
-              |  { tag_name = Field_UNKNOWN "country" ; tag_value = String s } -> ()
-              |  { tag_name = Field_UNKNOWN "udpflags" ; tag_value = Uint64  s } -> ()
-              |  { tag_name = Field_UNKNOWN "refs" ; tag_value = Uint64  s } -> ()
+              |  { tag_name = Field_KNOWN "country" ; tag_value = String s } -> ()
+              |  { tag_name = Field_KNOWN "udpflags" ; tag_value = Uint64  s } -> ()
+              |  { tag_name = Field_KNOWN "refs" ; tag_value = Uint64  s } -> ()
               | _ -> lprintf_nl "parsing server.met, unknown field %s" (string_of_tag tag)
           ) r.S.tags;
 	  server_must_update server
@@ -275,7 +275,8 @@
         match file.file_swarmer with
           None -> assert false
         | Some swarmer ->
-            let absents = Sort.list (fun (p1,_) (p2,_) -> p1 <= p2) absents in
+            let absents = 
+	      List.sort (fun (p1, _) (p2, _) -> compare p1 p2) absents in
             CommonSwarming.set_absent swarmer absents
   end;
 
@@ -447,16 +448,16 @@
 
   List.iter (fun tag ->
       match tag with
-      | { tag_name = Field_UNKNOWN "name"; tag_value = String s } ->
+      | { tag_name = Field_KNOWN "name"; tag_value = String s } ->
           login =:=  s
-      | { tag_name = Field_UNKNOWN "port"; tag_value = Uint64 v } ->
+      | { tag_name = Field_KNOWN "port"; tag_value = Uint64 v } ->
           donkey_port =:=  Int64.to_int v
       | _ -> ()
   ) ct;
 
   List.iter (fun tag ->
       match tag with
-      | { tag_name = Field_UNKNOWN "temp"; tag_value = String s } ->
+      | { tag_name = Field_KNOWN "temp"; tag_value = String s } ->
           if Sys.file_exists s then (* be careful on that *)
             temp_dir := s
           else (lprintf_nl "Bad temp directory, using default";
@@ -797,7 +798,7 @@
             ) !current_files
         ) args;
         ""
-    ) , "<f1> < f2> ... :\t\ttry to recover these files at byte level";
+    ) , "<f1> <f2> ... :\t\ttry to recover these files at byte level";
 
     "preferred", Arg_two (fun arg1 arg2 o ->
         let preferred = bool_of_string arg1 in
@@ -809,7 +810,7 @@
             end
         ) servers_by_key;
         "ok"
-    ), "<true/false> <ip> :\t\tset the server with this IP as preferred";
+    ), "<true|false> <ip> :\t\tset the server with this IP as preferred";
 
     "bs", Arg_multiple (fun args o ->
         List.iter (fun arg ->
@@ -817,7 +818,7 @@
             server_black_list =:=  range :: !!server_black_list;
         ) args;
         "done"
-    ), "<range1> <range2> ... :\t\t\tadd these IPs to the servers black list (can be single IPs, CIDR ranges or begin-end ranges)";
+    ), "<range1> <range2> ... :\t\tadd these IPs to the servers black list (can be single IPs, CIDR ranges or begin-end ranges)";
 
     "port", Arg_one (fun arg o ->
         donkey_port =:= int_of_string arg;
@@ -1195,9 +1196,10 @@
         P.client_os = c.client_osinfo;
         P.client_release = c.client_emule_proto.emule_release;
         P.client_emulemod = brand_mod_to_string_short c.client_brand_mod;
-        P.client_downloaded = c.client_downloaded;
-        P.client_uploaded = c.client_uploaded;
-(*        P.client_source.source_sock_addr =    (); *)
+        P.client_total_downloaded = c.client_total_downloaded;
+        P.client_total_uploaded = c.client_total_uploaded;
+        P.client_session_downloaded = c.client_session_downloaded;
+        P.client_session_uploaded = c.client_session_uploaded;
         P.client_upload =
         (match client_upload (as_client c) with
             Some f -> Some (CommonFile.file_best_name f)
@@ -1396,8 +1398,10 @@
           ( "0", "srh", "Secure User Identification [N]one, [P]assed, [F]ailed", "S" ) ;
           ( "0", "srh br", "IP address", "IP address" ) ;
           ] @ (if !Geoip.active then [( "0", "srh br", "Country Code/Name", "CC" )] else []) @ [
-          ( "1", "srh ar", "Total UL bytes to this client for all files", "UL" ) ;
-          ( "1", "srh ar br", "Total DL bytes from this client for all files", "DL" ) ;
+          ( "1", "srh ar", "Total UL bytes to this client for all files", "tUL" ) ;
+          ( "1", "srh ar br", "Total DL bytes from this client for all files", "tDL" ) ;
+          ( "1", "srh ar", "Session UL bytes to this client for all files", "sUL" ) ;
+          ( "1", "srh ar br", "Session DL bytes from this client for all files", "sDL" ) ;
           ( "1", "srh ar", "Your queue rank on this client", "Rnk" ) ;
           ( "1", "srh ar br", "Source score", "Scr" ) ;
           ( "1", "srh ar br", "Last ok", "LO" ) ;
@@ -1476,8 +1480,10 @@
                 ));
             ("", "sr br", ip_string);
             ] @ (if !Geoip.active then [(cn, "sr br", cc)] else []) @ [
-            ("", "sr ar", (size_of_int64 c.client_uploaded));
-            ("", "sr ar br", (size_of_int64 c.client_downloaded));
+            ("", "sr ar", (size_of_int64 c.client_total_uploaded));
+            ("", "sr ar br", (size_of_int64 c.client_total_downloaded));
+            ("", "sr ar", (size_of_int64 c.client_session_uploaded));
+            ("", "sr ar br", (size_of_int64 c.client_session_downloaded));
             ("", "sr ar", Printf.sprintf "%d" c.client_rank);
             ("", "sr ar br", Printf.sprintf "%d" c.client_source.DonkeySources.source_score);
             ("", "sr ar br", (string_of_date (c.client_source.DonkeySources.source_age)));
@@ -1698,10 +1704,10 @@
                   Direct_address (ip,port) -> (Ip.to_string ip)
                   |  _ -> (string_of_client_addr c));
                     Printf.bprintf buf "\n%14sDown  : %-10s                  Uploaded: %-10s  Ratio: %s%1.1f (%s)\n" ""
-                    (Int64.to_string c.client_downloaded)
-                    (Int64.to_string c.client_uploaded)
-                    (if c.client_downloaded > c.client_uploaded then "-" else "+")
-                    (if c.client_uploaded > Int64.zero then (Int64.to_float (Int64.div c.client_downloaded c.client_uploaded)) else (1.))
+                    (Int64.to_string c.client_total_downloaded)
+                    (Int64.to_string c.client_total_uploaded)
+                    (if c.client_total_downloaded > c.client_total_uploaded then "-" else "+")
+                    (if c.client_total_uploaded > Int64.zero then (Int64.to_float (Int64.div c.client_total_downloaded c.client_total_uploaded)) else (1.))
                     (brand_to_string c.client_brand);
                     (Printf.bprintf buf "%14sFile  : %s\n" "" info.GuiTypes.file_name);
                   end;
@@ -1754,8 +1760,10 @@
                       )); 
                       ("", "sr", ip_string);
                       ] @ (if !Geoip.active then [(cn, "sr", cc)] else []) @ [
-                      ("", "sr ar", (size_of_int64 c.client_uploaded));
-                      ("", "sr ar", (size_of_int64 c.client_downloaded));
+                      ("", "sr ar", (size_of_int64 c.client_total_uploaded));
+                      ("", "sr ar", (size_of_int64 c.client_total_downloaded));
+                      ("", "sr ar", (size_of_int64 c.client_session_uploaded));
+                      ("", "sr ar", (size_of_int64 c.client_session_downloaded));
                       ("", "sr", info.GuiTypes.file_name) ]);
 
                     Printf.bprintf buf "\\</tr\\>";
@@ -1774,6 +1782,29 @@
   )
 
 let _ =
+  shared_ops.op_shared_state <- (fun f o ->
+    match CommonFile.file_state f with
+    | FileShared ->
+      (match file_shared f with
+      | None -> "no file_shared info"
+      | Some f ->
+            let pre_share1_dir =
+              String2.replace (Filename2.dirname (as_shared_impl f).impl_shared_fullname) '\\' "/" in
+            let pre_share2_dir =
+              try       
+                String2.after pre_share1_dir
+                (String2.search_from
+                (Filename2.dirname (as_shared_impl f).impl_shared_fullname) 0 (Sys.getcwd ()) +
+                String.length (Sys.getcwd ()))
+              with Not_found -> pre_share1_dir
+            in
+            let dir =
+              if String2.check_prefix pre_share2_dir "/" then String2.after pre_share2_dir 1 else pre_share2_dir in
+            if o.conn_output = HTML then
+              Printf.sprintf "\\<a href=\\\"submit?q=debug_dir+%s\\\"\\>%s\\</a\\>" (Http_server.html_real_escaped dir) (Http_server.html_real_escaped dir)
+            else Printf.sprintf "Shared in %s" dir)
+    | state -> string_of_state state
+  );
   shared_ops.op_shared_unshare <- (fun file ->
       unshare_file file;
 (* Should we or not ??? *)
Index: src/networks/donkey/donkeyMain.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/networks/donkey/donkeyMain.ml,v
retrieving revision 1.63
retrieving revision 1.64
diff -u -r1.63 -r1.64
--- src/networks/donkey/donkeyMain.ml	26 Nov 2006 16:36:29 -0000	1.63
+++ src/networks/donkey/donkeyMain.ml	3 Dec 2006 20:49:42 -0000	1.64
@@ -137,14 +137,14 @@
   let emule_compatoptions = D.emule_compatoptions m in
   client_to_client_tags :=
   [
-    string_tag (Field_UNKNOWN "name") (local_login ());
-    int_tag (Field_UNKNOWN "port") !!donkey_port;
-    int_tag (Field_UNKNOWN "version") protocol_version;
-    int_tag (Field_UNKNOWN "emule_udpports") (!!donkey_port+4);
-    int_tag (Field_UNKNOWN "emule_version") m.emule_version;
-    int64_tag (Field_UNKNOWN "emule_miscoptions1") emule_miscoptions1;
-    int64_tag (Field_UNKNOWN "emule_miscoptions2") emule_miscoptions2;
-    int_tag (Field_UNKNOWN "emule_compatoptions") emule_compatoptions;
+    string_tag (Field_KNOWN "name") (local_login ());
+    int_tag (Field_KNOWN "port") !!donkey_port;
+    int_tag (Field_KNOWN "version") protocol_version;
+    int_tag (Field_KNOWN "emule_udpports") (!!donkey_port+4);
+    int_tag (Field_KNOWN "emule_version") m.emule_version;
+    int64_tag (Field_KNOWN "emule_miscoptions1") emule_miscoptions1;
+    int64_tag (Field_KNOWN "emule_miscoptions2") emule_miscoptions2;
+    int_tag (Field_KNOWN "emule_compatoptions") emule_compatoptions;
   ];
 
 (* server capabilities *)
@@ -161,42 +161,42 @@
 
   client_to_server_tags :=
   [
-    string_tag (Field_UNKNOWN "name") (local_login ());
-    int_tag (Field_UNKNOWN "version") protocol_version;
-    int_tag (Field_UNKNOWN "extended") !extended;
-    int_tag (Field_UNKNOWN "emule_version") m.emule_version;
+    string_tag (Field_KNOWN "name") (local_login ());
+    int_tag (Field_KNOWN "version") protocol_version;
+    int_tag (Field_KNOWN "extended") !extended;
+    int_tag (Field_KNOWN "emule_version") m.emule_version;
   ];
 
   client_to_server_reply_tags :=
   [
-    string_tag (Field_UNKNOWN "name") (local_login ());
-    int_tag (Field_UNKNOWN "version") protocol_version;
-    int_tag (Field_UNKNOWN "emule_udpports") (!!donkey_port+4);
-    int64_tag (Field_UNKNOWN "emule_miscoptions1") emule_miscoptions1;
-    int64_tag (Field_UNKNOWN "emule_miscoptions2") emule_miscoptions2;
-    int_tag (Field_UNKNOWN "emule_version") m.emule_version;
+    string_tag (Field_KNOWN "name") (local_login ());
+    int_tag (Field_KNOWN "version") protocol_version;
+    int_tag (Field_KNOWN "emule_udpports") (!!donkey_port+4);
+    int64_tag (Field_KNOWN "emule_miscoptions1") emule_miscoptions1;
+    int64_tag (Field_KNOWN "emule_miscoptions2") emule_miscoptions2;
+    int_tag (Field_KNOWN "emule_version") m.emule_version;
   ];
 
   emule_info.DonkeyProtoClient.EmuleClientInfo.tags <- [
-    int_tag (Field_UNKNOWN "compression") m.emule_compression;
-    int_tag (Field_UNKNOWN "udpver") m.emule_udpver;
-    int_tag (Field_UNKNOWN "udpport") (!!donkey_port+4);
-    int_tag (Field_UNKNOWN "sourceexchange") m.emule_sourceexchange;
-    int_tag (Field_UNKNOWN "comments") m.emule_comments;
-    int_tag (Field_UNKNOWN "compatibleclient") !DonkeyProtoClient.compatibleclient; 
-    int_tag (Field_UNKNOWN "extendedrequest") m.emule_extendedrequest;
-    int_tag (Field_UNKNOWN "features") m.emule_features;
+    int_tag (Field_KNOWN "compression") m.emule_compression;
+    int_tag (Field_KNOWN "udpver") m.emule_udpver;
+    int_tag (Field_KNOWN "udpport") (!!donkey_port+4);
+    int_tag (Field_KNOWN "sourceexchange") m.emule_sourceexchange;
+    int_tag (Field_KNOWN "comments") m.emule_comments;
+    int_tag (Field_KNOWN "compatibleclient") !DonkeyProtoClient.compatibleclient; 
+    int_tag (Field_KNOWN "extendedrequest") m.emule_extendedrequest;
+    int_tag (Field_KNOWN "features") m.emule_features;
     
   ];
   overnet_connect_tags :=
   [
-    string_tag (Field_UNKNOWN "name") (local_login ());
-    int_tag (Field_UNKNOWN "version") !!DonkeyProtoOvernet.overnet_protocol_connect_version; 
+    string_tag (Field_KNOWN "name") (local_login ());
+    int_tag (Field_KNOWN "version") !!DonkeyProtoOvernet.overnet_protocol_connect_version; 
   ];
   overnet_connectreply_tags :=
   [
-    string_tag (Field_UNKNOWN "name") (local_login ());
-    int_tag (Field_UNKNOWN "version") !!DonkeyProtoOvernet.overnet_protocol_connectreply_version; 
+    string_tag (Field_KNOWN "name") (local_login ());
+    int_tag (Field_KNOWN "version") !!DonkeyProtoOvernet.overnet_protocol_connectreply_version; 
   ]
   
 let enable () =
Index: src/networks/donkey/donkeyMftp.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/networks/donkey/donkeyMftp.ml,v
retrieving revision 1.13
retrieving revision 1.15
diff -u -r1.13 -r1.15
--- src/networks/donkey/donkeyMftp.ml	9 Feb 2006 11:45:12 -0000	1.13
+++ src/networks/donkey/donkeyMftp.ml	4 Dec 2006 12:00:19 -0000	1.15
@@ -179,7 +179,9 @@
         List.assoc name names_of_tag
       with Not_found ->
 (*          lprintf "Unknown tag \"%s\"\n" (String.escaped name); *)
-          field_of_string name);
+          match field_of_string name with
+          | Field_KNOWN s -> Field_UNKNOWN s
+          | field -> field);
     tag_value = v
   }, pos
   
@@ -223,3 +225,75 @@
     "Album", Field_Album;
     "Title", Field_Title;
   ]
+
+let client_common_tags =
+      [
+        "\001", "name";
+        "\015", "port";
+        "\017", "version";
+        "\031", "udpport";
+        "\032", "compression";
+        "\033", "udpport";
+        "\034", "udpver";
+        "\035", "sourceexchange";
+        "\036", "comments";
+        "\037", "extendedrequest";
+        "\038", "compatibleclient";
+        "\039", "features";
+        "\059", "extrainfo";
+        "\060", "downloadtime";
+        "\061", "incompleteparts";
+        "\062", "l2hac";
+        "\063", "realparts";
+        "\065", "mod_unknown41";
+        "\066", "mod_unknown42";
+        "\067", "mod_unknown43";
+        "\078", "neo_features";
+        "\084", "mod_featureset";
+        "\085", "mod_version";
+        "\086", "mod_protocol";
+        "\090", "mod_bowlfish";
+        "\092", "mod_secure_community";
+        "\093", "mod_unknown0x5d";
+        "\096", "mod_unknown0x60";
+        "\102", "mod_fusion";
+        "\103", "mod_fusion_version";
+
+(* http://forums.shareaza.com/showthread.php?threadid=37323&perpage=15&pagenumber=2 *)
+        "\105", "edonkeyclc serverip?";
+        "\106", "edonkeyclc serverport?";
+
+        "\117", "mod_unknown0x75"; (* http://emule-project.net @ NewMule *)
+        "\118", "mod_unknown0x76";
+        "\119", "mod_tarod";
+        "\120", "mod_tarod_version";
+        "\121", "mod_morph";
+        "\128", "mod_morph_version";
+        "\130", "mod_mortillo";
+        "\131", "mod_mortillo_version";
+        "\132", "chanblard_version";
+        "\133", "signature";
+        "\134", "cache";
+        "\135", "mod_lsd";
+        "\136", "mod_lsd_version";
+        "\144", "mod_lovelace_version";
+        "\148", "os_info"; (* reused by aMule to transfer client OS type *)
+        "\153", "mod_plus";
+        "\160", "mod_wombat";
+        "\161", "dev_wombat";
+        "\170", "koizo"; (* http://sourceforge.net/projects/koizo *)
+        "\205", "mod_unknown0xcd";
+        "\224", "isp_bypass";
+        "\225", "nat_tunneling";
+        "\239", "emule_compatoptions";
+        "\240", "nat_security";
+        "\249", "emule_udpports";
+        "\250", "emule_miscoptions1";
+        "\251", "emule_version";
+        "\252", "buddy_ip";
+        "\253", "buddy_udp";
+        "\254", "emule_miscoptions2";
+        "pr",   "edonkeyclc horde";
+        "wombia", "wombat a";
+        "wombib", "wombat b";
+      ]
Index: src/networks/donkey/donkeyMftp.mli
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/networks/donkey/donkeyMftp.mli,v
retrieving revision 1.6
retrieving revision 1.7
diff -u -r1.6 -r1.7
--- src/networks/donkey/donkeyMftp.mli	19 Jan 2006 00:44:47 -0000	1.6
+++ src/networks/donkey/donkeyMftp.mli	3 Dec 2006 20:49:42 -0000	1.7
@@ -51,4 +51,5 @@
     val print : t -> unit
     val write : Buffer.t -> t -> unit
   end
-val file_common_tags : (string * CommonTypes.field) list
\ No newline at end of file
+val file_common_tags : (string * CommonTypes.field) list
+val client_common_tags : (string * string) list
Index: src/networks/donkey/donkeyPandora.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/networks/donkey/donkeyPandora.ml,v
retrieving revision 1.7
retrieving revision 1.8
diff -u -r1.7 -r1.8
--- src/networks/donkey/donkeyPandora.ml	3 Apr 2006 20:50:09 -0000	1.7
+++ src/networks/donkey/donkeyPandora.ml	3 Dec 2006 20:49:42 -0000	1.8
@@ -98,23 +98,23 @@
 let update_emule_proto_from_tags e tags = 
   List.iter (fun tag -> 
       match tag.tag_name with
-      | Field_UNKNOWN "compression" ->
+      | Field_KNOWN "compression" ->
           for_int_tag tag (fun i -> 
               e.emule_compression <- i)
-      | Field_UNKNOWN "udpver" ->
+      | Field_KNOWN "udpver" ->
           for_int_tag tag (fun i -> 
               e.emule_udpver <- i)          
-      | Field_UNKNOWN "udpport" -> ()
-      | Field_UNKNOWN "sourceexchange" ->
+      | Field_KNOWN "udpport" -> ()
+      | Field_KNOWN "sourceexchange" ->
           for_int_tag tag (fun i -> 
               e.emule_sourceexchange <- i)          
-      | Field_UNKNOWN "comments" ->
+      | Field_KNOWN "comments" ->
           for_int_tag tag (fun i -> 
               e.emule_comments <- i)          
-      | Field_UNKNOWN "extendedrequest" ->
+      | Field_KNOWN "extendedrequest" ->
           for_int_tag tag (fun i -> 
               e.emule_extendedrequest <- i)          
-      | Field_UNKNOWN "features" ->
+      | Field_KNOWN "features" ->
           for_int_tag tag (fun i -> 
               e.emule_secident <- i land 0x3)          
       | s -> 
@@ -138,7 +138,7 @@
             
             begin
               try
-                let options = find_tag (Field_UNKNOWN "emule_miscoptions1") tags in
+                let options = find_tag (Field_KNOWN "emule_miscoptions1") tags in
                 match options with
                   Uint64 v | Fint64 v ->
                     update_emule_proto_from_miscoptions1 emule v
Index: src/networks/donkey/donkeyProtoClient.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/networks/donkey/donkeyProtoClient.ml,v
retrieving revision 1.40
retrieving revision 1.42
diff -u -r1.40 -r1.42
--- src/networks/donkey/donkeyProtoClient.ml	26 Nov 2006 16:36:29 -0000	1.40
+++ src/networks/donkey/donkeyProtoClient.ml	3 Dec 2006 20:49:42 -0000	1.42
@@ -39,41 +39,84 @@
     (int_of_string(Autoconf.minor_version) lsl 10) lor
     (int_of_string(Autoconf.sub_version) lsl 7)
 
-(* TODO : update this
-I downgraded some of those to get better results :
-We don't use emule udp extension, client_md4 in sourceexchange or complete sources in
-file request *)
 let mldonkey_emule_proto = 
   {
-    emule_comments = 1;
     emule_version = get_emule_version (); 
     emule_release = "";
-    emule_secident = 3; (* Emule uses v1 if advertising both, v2 if only advertising 2 *)
-    emule_noviewshared = 0;
-    emule_supportpreview = 0;
     emule_osinfosupport = 1;
-    emule_compression = 1; (* 1 *)
+    emule_features = 3;
+
+(* emule_miscoptions1 *)
+    emule_aich = 0;
+    emule_unicode = 0;
+    emule_udpver = 0;
+    emule_compression = 1;
+    emule_secident = 3; (* Emule uses v1 if advertising both, v2 if only advertising 2 *)
     emule_sourceexchange = 2; (* 2 : +client_md4 3 : +IdHybrid (emule Kademlia?)*)
-    emule_multipacket = 0; (* 1 *)
     emule_extendedrequest = 1; (* 1: +file_status 2: +ncomplete_sources*)
-    emule_features = 3; (* 3 *)
-    emule_udpver = 0; (* 4 *)
+    emule_comments = 1;
+    emule_peercache = 0;
+    emule_noviewshared = 0;
+    emule_multipacket = 0;
+    emule_supportpreview = 0;
+
+(* emule_miscoptions2 *)
+    emule_require_crypt = 0;
+    emule_request_crypt = 0;
+    emule_support_crypt = 0;
+    emule_extmultipacket = 0;
+    emule_largefiles = 0;
+    emule_kad_version = 0;
   }
 
 let emule_miscoptions1 m =
   let o =
+    (m.emule_aich lsl 29) lor
+    (m.emule_unicode lsl 28) lor
     (m.emule_udpver lsl 24) lor
     (m.emule_compression lsl 20) lor
     (m.emule_secident lsl 16) lor
     (m.emule_sourceexchange lsl 12) lor
     (m.emule_extendedrequest lsl 8) lor
     (m.emule_comments lsl 4) lor
+    (m.emule_peercache lsl 3) lor
     (m.emule_noviewshared lsl 2) lor
     (m.emule_multipacket lsl 1) lor
     (m.emule_supportpreview lsl 0)
   in
   Int64.of_int o
 
+let update_emule_proto_from_miscoptions1 m o =
+  let o = Int64.to_int o in
+  m.emule_aich            <- (o lsr 29) land 0x7;
+  m.emule_unicode         <- (o lsr 28) land 0xf;
+  m.emule_udpver          <- (o lsr 24) land 0xf;
+  m.emule_compression     <- (o lsr 20) land 0xf;
+  m.emule_secident        <- (o lsr 16) land 0xf;
+  m.emule_sourceexchange  <- (o lsr 12) land 0xf;
+  m.emule_extendedrequest <- (o lsr  8) land 0xf;
+  m.emule_comments        <- (o lsr  4) land 0xf;
+  m.emule_peercache       <- (o lsr  3) land 0x1;
+  m.emule_noviewshared    <- (o lsr  2) land 0x1;
+  m.emule_multipacket     <- (o lsr  1) land 0x1;
+  m.emule_supportpreview  <- (o lsr  0) land 0x1
+
+let print_emule_proto_miscoptions1 m =
+  let buf = Buffer.create 50 in
+  if m.emule_aich <> 0 then Printf.bprintf buf " aich %d\n" m.emule_aich;
+  if m.emule_unicode <> 0 then Printf.bprintf buf " unicode %d\n" m.emule_unicode;
+  if m.emule_udpver <> 0 then Printf.bprintf buf " udpver %d\n" m.emule_udpver;
+  if m.emule_compression <> 0 then Printf.bprintf buf " compression %d\n" m.emule_compression;
+  if m.emule_secident <> 0 then Printf.bprintf buf " secident %d\n" m.emule_secident;
+  if m.emule_sourceexchange <> 0 then Printf.bprintf buf " sourceexchange %d\n" m.emule_sourceexchange;
+  if m.emule_extendedrequest <> 0 then Printf.bprintf buf " extendedrequest %d\n" m.emule_extendedrequest;
+  if m.emule_comments <> 0 then Printf.bprintf buf " comments %d\n" m.emule_comments;
+  if m.emule_peercache <> 0 then Printf.bprintf buf " peercache %d\n" m.emule_peercache;
+  if m.emule_noviewshared <> 0 then Printf.bprintf buf " noviewshared %d\n" m.emule_noviewshared;
+  if m.emule_multipacket <> 0 then Printf.bprintf buf " multipacket %d\n" m.emule_multipacket;
+  if m.emule_supportpreview <> 0 then Printf.bprintf buf " supportpreview %d\n" m.emule_supportpreview;
+  Buffer.contents buf
+
 let emule_miscoptions2 m =
 (*
   let o =
@@ -83,23 +126,24 @@
 *)
   Int64.zero
 
-let update_emule_proto_from_miscoptions1 m o =
-  let o = Int64.to_int o in
-  m.emule_udpver <- (o lsr 24) land 0xf;
-  m.emule_compression <- (o lsr 20) land 0xf;
-  m.emule_secident <- (o lsr 16) land 0xf;
-  m.emule_sourceexchange <- (o lsr 12) land 0xf;
-  m.emule_extendedrequest <- (o lsr 8) land 0xf;
-  m.emule_comments <- (o lsr 4) land 0xf;
-  m.emule_noviewshared <- (o lsr 2) land 0x1;
-  m.emule_multipacket <- (o lsr 1) land 0x1;
-  m.emule_supportpreview <- (o lsr 0) land 0x1
-
-let update_emule_proto_from_miscoptions2 m o = ()
-(*
+let update_emule_proto_from_miscoptions2 m o =
   let o = Int64.to_int o in
-  m.emule_largefiles <- (o lsr 4) land 0x1
-*)
+  m.emule_require_crypt  <- (o lsr 9) land 0x1;
+  m.emule_request_crypt  <- (o lsr 8) land 0x1;
+  m.emule_support_crypt  <- (o lsr 7) land 0x1;
+  m.emule_extmultipacket <- (o lsr 5) land 0x1;
+  m.emule_largefiles     <- (o lsr 4) land 0x1;
+  m.emule_kad_version    <- (o lsr 0) land 0xf
+
+let print_emule_proto_miscoptions2 m =
+  let buf = Buffer.create 50 in
+  if m.emule_require_crypt <> 0 then Printf.bprintf buf " require_crypt %d\n" m.emule_require_crypt;
+  if m.emule_request_crypt <> 0 then Printf.bprintf buf " request_crypt %d\n" m.emule_request_crypt;
+  if m.emule_support_crypt <> 0 then Printf.bprintf buf " support_crypt %d\n" m.emule_support_crypt;
+  if m.emule_extmultipacket <> 0 then Printf.bprintf buf " extmultipacket %d\n" m.emule_extmultipacket;
+  if m.emule_largefiles <> 0 then Printf.bprintf buf " largefiles %d\n" m.emule_largefiles;
+  if m.emule_kad_version <> 0 then Printf.bprintf buf " kad_version %d\n" m.emule_kad_version;
+  Buffer.contents buf
 
 let emule_compatoptions m =
   (m.emule_osinfosupport lsl 0)
@@ -146,23 +190,10 @@
         left_bytes : string;
       }
 
+    let names_of_tag = client_common_tags
+
     let names_of_tag =
-      [
-        "\001", Field_UNKNOWN "name";
-        "\015", Field_UNKNOWN "port";
-        "\017", Field_UNKNOWN "version";
-        "\031", Field_UNKNOWN "udpport";
-        "\060", Field_UNKNOWN "downloadtime";
-        "\061", Field_UNKNOWN "incompleteparts";
-        "\085", Field_UNKNOWN "mod_version";
-        "\239", Field_UNKNOWN "emule_compatoptions";
-        "\249", Field_UNKNOWN "emule_udpports";
-        "\250", Field_UNKNOWN "emule_miscoptions1";
-        "\251", Field_UNKNOWN "emule_version";
-        "\252", Field_UNKNOWN "buddy_ip";
-        "\253", Field_UNKNOWN "buddy_udp";
-        "\254", Field_UNKNOWN "emule_miscoptions2";
-      ]
+      List.map (fun (v, name) -> (v, Field_KNOWN name)) names_of_tag
 
     let parse reply len s =
       let hash_len, pos = if not reply then get_uint8 s 1, 2 else -1, 1 in
@@ -787,49 +818,10 @@
         mutable tags : tag list;
       }
 
-    let names_of_tag =
-      [
-        "\032", "compression";
-        "\033", "udpport";
-        "\034", "udpver";
-        "\035", "sourceexchange";
-        "\036", "comments";
-        "\037", "extendedrequest";
-        "\038", "compatibleclient";
-        "\039", "features";
-        "\060", "downloadtime";
-        "\061", "incompleteparts";
-        "\062", "l2hac";
-        "\065", "mod_unknown41";
-        "\066", "mod_unknown42";
-        "\067", "mod_unknown43";
-        "\084", "mod_featureset";
-        "\086", "mod_protocol";
-        "\085", "mod_version";
-        "\090", "mod_bowlfish";
-        "\092", "mod_secure_community";
-        "\102", "mod_fusion";
-        "\103", "mod_fusion_version";
-        "\119", "mod_tarod";
-        "\120", "mod_tarod_version";
-        "\121", "mod_morph";
-        "\128", "mod_morph_version";
-        "\130", "mod_mortillo";
-        "\131", "mod_mortillo_version";
-        "\132", "chanblard_version";
-        "\133", "signature";
-        "\134", "cache";
-        "\135", "mod_lsd";
-        "\136", "mod_lsd_version";
-        "\144", "mod_lovelace_version";
-        "\148", "os_info"; (* reused by aMule to transfer client OS type *)
-        "\153", "mod_plus";
-        "\160", "mod_wombat";
-        "\161", "dev_wombat";
-      ]
+    let names_of_tag = client_common_tags
 
     let names_of_tag =
-      List.map (fun (v, name) -> (v, Field_UNKNOWN name)) names_of_tag
+      List.map (fun (v, name) -> (v, Field_KNOWN name)) names_of_tag
 
     let parse len s =
       let version = get_uint8 s 1 in
Index: src/networks/donkey/donkeyProtoCom.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/networks/donkey/donkeyProtoCom.ml,v
retrieving revision 1.33
retrieving revision 1.34
diff -u -r1.33 -r1.34
--- src/networks/donkey/donkeyProtoCom.ml	8 Oct 2006 14:20:22 -0000	1.33
+++ src/networks/donkey/donkeyProtoCom.ml	2 Dec 2006 12:35:46 -0000	1.34
@@ -339,8 +339,8 @@
       str_int s 0 nfiles;
       let s = String.sub s 0 prev_len in
       if !verbose_share || !verbose then
-         lprintf_nl "Sending %d share(s) to server %s:%d%s"
-	   nfiles (Ip.to_string (peer_ip sock)) (peer_port sock)
+         lprintf_nl "Sending %d share%s to server %s:%d%s"
+	   nfiles (Printf2.print_plural_s nfiles) (Ip.to_string (peer_ip sock)) (peer_port sock)
 	   (if compressed then " (zlib)" else "");
       Buffer.reset buf;
       let s_c =
Index: src/networks/donkey/donkeyProtoKademlia.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/networks/donkey/donkeyProtoKademlia.ml,v
retrieving revision 1.21
retrieving revision 1.22
diff -u -r1.21 -r1.22
--- src/networks/donkey/donkeyProtoKademlia.ml	31 Oct 2006 15:42:48 -0000	1.21
+++ src/networks/donkey/donkeyProtoKademlia.ml	3 Dec 2006 20:49:42 -0000	1.22
@@ -45,15 +45,15 @@
 
     let names_of_tag =
       [
-        "\243", Field_UNKNOWN "encryption"; (* 0xF3 *)
-        "\248", Field_UNKNOWN "buddyhash"; (* 0xF8 *)
-        "\249", Field_UNKNOWN "clientlowid"; (* 0xF9 *)
-        "\250", Field_UNKNOWN "serverport"; (* 0xFA *)
-        "\251", Field_UNKNOWN "serverip";   (* 0xFB *)
-        "\252", Field_UNKNOWN "sourceuport"; (* 0xFC *)
-        "\253", Field_UNKNOWN "sourceport"; (* 0xFD *)
-        "\254", Field_UNKNOWN "sourceip"; (* 0xFE *)
-        "\255", Field_UNKNOWN "sourcetype";  (* 0xFF *)
+        "\243", Field_KNOWN "encryption"; (* 0xF3 *)
+        "\248", Field_KNOWN "buddyhash"; (* 0xF8 *)
+        "\249", Field_KNOWN "clientlowid"; (* 0xF9 *)
+        "\250", Field_KNOWN "serverport"; (* 0xFA *)
+        "\251", Field_KNOWN "serverip";   (* 0xFB *)
+        "\252", Field_KNOWN "sourceuport"; (* 0xFC *)
+        "\253", Field_KNOWN "sourceport"; (* 0xFD *)
+        "\254", Field_KNOWN "sourceip"; (* 0xFE *)
+        "\255", Field_KNOWN "sourcetype";  (* 0xFF *)
       ] @ file_common_tags
 
 (* This fucking Emule implementation uses 4 32-bits integers instead of
@@ -248,17 +248,17 @@
           let peer_kind = ref 0 in
           List.iter (fun tag ->
               match tag.tag_name with
-                Field_UNKNOWN "sourceport" ->
+                Field_KNOWN "sourceport" ->
                   for_int_tag tag (fun port ->
                       peer_tcpport := port)
-              | Field_UNKNOWN "sourceuport" ->
+              | Field_KNOWN "sourceuport" ->
                   for_int_tag tag (fun port ->
                       peer_udpport := port)
-              | Field_UNKNOWN "sourceip" ->
+              | Field_KNOWN "sourceip" ->
                   for_int64_tag tag (fun ip ->
                       peer_ip := Ip.of_int64 ip
                   )
-              | Field_UNKNOWN "sourcetype" ->
+              | Field_KNOWN "sourcetype" ->
                   for_int_tag tag (fun kind ->
                       peer_kind := 3)
               | _ ->
@@ -333,7 +333,7 @@
               (_, first_tags) :: _ ->
                 let sources = ref false in
                 List.iter (fun tag ->
-                    if tag.tag_name = Field_UNKNOWN "sourceport" then sources := true;
+                    if tag.tag_name = Field_KNOWN "sourceport" then sources := true;
                 ) first_tags;
                 if !sources then
                   let peers = get_peers_from_results Ip.null 0 answers in
@@ -359,7 +359,7 @@
               (_, first_tags) :: _ ->
                 let sources = ref false in
                 List.iter (fun tag ->
-                    if tag.tag_name = Field_UNKNOWN "sourceport" then sources := true;
+                    if tag.tag_name = Field_KNOWN "sourceport" then sources := true;
                 ) first_tags;
                 if !sources then
                   let peers = get_peers_from_results ip port answers in
Index: src/networks/donkey/donkeyProtoOvernet.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/networks/donkey/donkeyProtoOvernet.ml,v
retrieving revision 1.31
retrieving revision 1.32
diff -u -r1.31 -r1.32
--- src/networks/donkey/donkeyProtoOvernet.ml	5 Nov 2006 14:13:51 -0000	1.31
+++ src/networks/donkey/donkeyProtoOvernet.ml	3 Dec 2006 20:49:42 -0000	1.32
@@ -40,7 +40,9 @@
     let lprintf_n fmt =
       lprintf2 log_prefix fmt
 
-   let names_of_tag = file_common_tags
+   let names_of_tag = [
+      "loc", Field_KNOWN "loc";
+      ] @ file_common_tags
 
     let buf_peer buf p =
       buf_md4 buf p.peer_md4;
@@ -187,7 +189,7 @@
       let peer_tcpport = ref 0 in
       List.iter (fun tag ->
           match tag.tag_name with
-            Field_UNKNOWN "loc" ->
+            Field_KNOWN "loc" ->
               for_string_tag tag (fun bcp ->
                   if !verbose_overnet then lprintf_nl "loc tag : [%s]" bcp;
                   if String2.starts_with bcp "bcp://" then
@@ -295,7 +297,7 @@
             let r_tags, pos = get_tags s 32 names_of_tag in
             let sources = ref false in
             List.iter (fun tag ->
-                if tag.tag_name = Field_UNKNOWN "loc" then sources := true;
+                if tag.tag_name = Field_KNOWN "loc" then sources := true;
             ) r_tags;
             if !sources then
               let peer = get_peer_from_result ip port r_md4 r_tags in
@@ -311,7 +313,7 @@
             let r_tags, pos = get_tags s 32 names_of_tag in
             let sources = ref false in
             List.iter (fun tag ->
-                if tag.tag_name = Field_UNKNOWN "loc" then sources := true;
+                if tag.tag_name = Field_KNOWN "loc" then sources := true;
             ) r_tags;
             if !sources then
               let peer = get_peer_from_result ip port r_md4 r_tags in
Index: src/networks/donkey/donkeyProtoServer.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/networks/donkey/donkeyProtoServer.ml,v
retrieving revision 1.23
retrieving revision 1.25
diff -u -r1.23 -r1.25
--- src/networks/donkey/donkeyProtoServer.ml	26 Nov 2006 16:36:29 -0000	1.23
+++ src/networks/donkey/donkeyProtoServer.ml	3 Dec 2006 20:49:42 -0000	1.25
@@ -28,31 +28,6 @@
 open DonkeyTypes
 open DonkeyMftp
 
-(*
-let field_of_tagname s =
-  match s with
-  | "size" -> Field_Size
-  | "filename" -> Field_Filename
-  | "Artist" -> Field_Artist
-  | "Album" -> Field_Album
-  | "Title" -> Field_Title
-  | "format" -> Field_Format
-  | "type" -> Field_Type
-  | s -> Field_UNKNOWN s
-
-let tagname_of_field field =
-  match field with
-    Field_Size -> "size"
-  | Field_Filename -> "filename"
-  | Field_Artist -> "Artist"
-  | Field_Album -> "Album"
-  | Field_Title -> "Title"
-  | Field_Format -> "format"
-  | Field_Type -> "type"
-  | Field_Uid -> "uid"
-  | Field_unknown s -> s
-*)
-
 module Connect = struct
     type t = {
         md4 : Md4.t;
@@ -63,10 +38,10 @@
 
     let names_of_tag =
       [
-       "\001", Field_UNKNOWN "name";          (* CT_NAME          0x01 *)
-       "\017", Field_UNKNOWN "version";       (* CT_VERSION       0x11 *)
-       "\032", Field_UNKNOWN "extended";      (* CT_SERVER_FLAGS  0x20 *)
-       "\251", Field_UNKNOWN "emule_version"; (* CT_EMULE_VERSION 0xfb *)
+       "\001", Field_KNOWN "name";          (* CT_NAME          0x01 *)
+       "\017", Field_KNOWN "version";       (* CT_VERSION       0x11 *)
+       "\032", Field_KNOWN "extended";      (* CT_SERVER_FLAGS  0x20 *)
+       "\251", Field_KNOWN "emule_version"; (* CT_EMULE_VERSION 0xfb *)
       ]
 
     let parse len s =
@@ -388,8 +363,8 @@
 
     let names_of_tag =
       [
-        "\001", Field_UNKNOWN "name";
-        "\011", Field_UNKNOWN "description";
+        "\001", Field_KNOWN "name";
+        "\011", Field_KNOWN "description";
       ]
 
     let parse len s =
@@ -760,9 +735,9 @@
 
     let names_of_tag =
       [
-        "\001", Field_UNKNOWN "name";
-        "\017", Field_UNKNOWN "version";
-        "\015", Field_UNKNOWN "port";
+        "\001", Field_KNOWN "name";
+        "\017", Field_KNOWN "version";
+        "\015", Field_KNOWN "port";
       ]
 
     let rec parse_clients s pos nclients left =
Index: src/networks/donkey/donkeyProtoUdp.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/networks/donkey/donkeyProtoUdp.ml,v
retrieving revision 1.16
retrieving revision 1.17
diff -u -r1.16 -r1.17
--- src/networks/donkey/donkeyProtoUdp.ml	26 Nov 2006 16:36:29 -0000	1.16
+++ src/networks/donkey/donkeyProtoUdp.ml	3 Dec 2006 20:49:42 -0000	1.17
@@ -233,22 +233,22 @@
   }
 
   let names_of_tag = [
-    "\001", Field_UNKNOWN "servername";
-    "\011", Field_UNKNOWN "description";
-    "\012", Field_UNKNOWN "ping";
-    "\013", Field_UNKNOWN "fail";
-    "\014", Field_UNKNOWN "preference";
-    "\015", Field_UNKNOWN "port";
-    "\016", Field_UNKNOWN "ip";
-    "\133", Field_UNKNOWN "dynip";
-    "\135", Field_UNKNOWN "maxusers";
-    "\136", Field_UNKNOWN "softfiles";
-    "\137", Field_UNKNOWN "hardfiles";
-    "\144", Field_UNKNOWN "lastping";
-    "\145", Field_UNKNOWN "version";
-    "\146", Field_UNKNOWN "udpflags";
-    "\147", Field_UNKNOWN "auxportslist";
-    "\148", Field_UNKNOWN "lowidusers";
+    "\001", Field_KNOWN "servername";
+    "\011", Field_KNOWN "description";
+    "\012", Field_KNOWN "ping";
+    "\013", Field_KNOWN "fail";
+    "\014", Field_KNOWN "preference";
+    "\015", Field_KNOWN "port";
+    "\016", Field_KNOWN "ip";
+    "\133", Field_KNOWN "dynip";
+    "\135", Field_KNOWN "maxusers";
+    "\136", Field_KNOWN "softfiles";
+    "\137", Field_KNOWN "hardfiles";
+    "\144", Field_KNOWN "lastping";
+    "\145", Field_KNOWN "version";
+    "\146", Field_KNOWN "udpflags";
+    "\147", Field_KNOWN "auxportslist";
+    "\148", Field_KNOWN "lowidusers";
   ]
 
   let parse1 len s challenge =
@@ -267,9 +267,9 @@
     let desc = ref "" in
     List.iter (fun tag ->
       match tag with
-      | { tag_name = Field_UNKNOWN "servername"; tag_value = String v } ->
+      | { tag_name = Field_KNOWN "servername"; tag_value = String v } ->
             name := v
-      | { tag_name = Field_UNKNOWN "description"; tag_value = String v } ->
+      | { tag_name = Field_KNOWN "description"; tag_value = String v } ->
             desc := v
       | _ -> ()
     ) stags;
Index: src/networks/donkey/donkeyServers.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/networks/donkey/donkeyServers.ml,v
retrieving revision 1.68
retrieving revision 1.69
diff -u -r1.68 -r1.69
--- src/networks/donkey/donkeyServers.ml	26 Nov 2006 16:36:29 -0000	1.68
+++ src/networks/donkey/donkeyServers.ml	3 Dec 2006 20:49:42 -0000	1.69
@@ -399,9 +399,9 @@
       List.iter (
         fun tag ->
           match tag with
-              { tag_name = Field_UNKNOWN "name"; tag_value = String name } ->
+              { tag_name = Field_KNOWN "name"; tag_value = String name } ->
                 s.server_name <- name
-            | { tag_name = Field_UNKNOWN "description"; tag_value = String desc } ->
+            | { tag_name = Field_KNOWN "description"; tag_value = String desc } ->
                 s.server_description <- desc
             | _ -> lprintf_nl "parsing donkeyServers.ServerInfo, unknown field %s" (string_of_tag tag)
       ) s.server_tags
@@ -504,7 +504,7 @@
           user_add user_impl;
           List.iter (fun tag ->
               match tag with
-                { tag_name = Field_UNKNOWN "name"; tag_value = String s } ->
+                { tag_name = Field_KNOWN "name"; tag_value = String s } ->
                   user.user_name <- s
               | _ -> ()
           ) user.user_tags;
Index: src/networks/donkey/donkeyShare.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/networks/donkey/donkeyShare.ml,v
retrieving revision 1.55
retrieving revision 1.56
diff -u -r1.55 -r1.56
--- src/networks/donkey/donkeyShare.ml	9 Oct 2006 16:17:19 -0000	1.55
+++ src/networks/donkey/donkeyShare.ml	3 Dec 2006 20:57:56 -0000	1.56
@@ -44,12 +44,7 @@
   | Some _ -> ()
   | None ->
       let full_name = file_disk_name file in
-      let magic =
-        match Magic.M.magic_fileinfo full_name false with
-          None -> None
-        | Some magic -> Some (intern magic)
-      in
-
+      check_magic (as_file file);
       let impl = {
           impl_shared_update = 1;
           impl_shared_fullname = full_name;
@@ -61,7 +56,7 @@
           impl_shared_ops = shared_ops;
           impl_shared_val = file;
           impl_shared_requests = 0;
-          impl_shared_magic = magic;
+          impl_shared_file = Some (as_file file);
           impl_shared_servers = []
         } in
       file.file_shared <- Some impl;
@@ -333,12 +328,6 @@
     let found = ref false in
     List.iter (fun sh -> if sh.shared_name = fullname then found := true) !shared_files;
     if not !found then begin
-        let magic =
-          match Magic.M.magic_fileinfo fullname false with
-            None -> None
-          | Some magic -> Some (intern magic)
-        in
-
           let rec impl = {
               impl_shared_update = 1;
               impl_shared_fullname = fullname;
@@ -350,7 +339,7 @@
               impl_shared_id = Md4.null;
               impl_shared_val = pre_shared;
               impl_shared_requests = 0;
-              impl_shared_magic = magic;
+              impl_shared_file = None;
               impl_shared_servers = [];
             } and
             pre_shared = {
Index: src/networks/donkey/donkeyStats.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/networks/donkey/donkeyStats.ml,v
retrieving revision 1.25
retrieving revision 1.26
diff -u -r1.25 -r1.26
--- src/networks/donkey/donkeyStats.ml	23 Sep 2006 20:29:47 -0000	1.25
+++ src/networks/donkey/donkeyStats.ml	2 Dec 2006 12:35:46 -0000	1.26
@@ -85,7 +85,8 @@
     !!gstats_mod_array.(i).brand_download <- !!gstats_mod_array.(i).brand_download ++ v;
   end;
 
-  c.client_downloaded <- c.client_downloaded ++ v;
+  c.client_total_downloaded <- c.client_total_downloaded ++ v;
+  c.client_session_downloaded <- c.client_session_downloaded ++ v;
   donkey_download_counter := !donkey_download_counter ++ v;
   global_count_download network v
 
@@ -100,7 +101,8 @@
     !!gstats_mod_array.(i).brand_upload <- !!gstats_mod_array.(i).brand_upload ++ v;
   end;
 
-  c.client_uploaded <- c.client_uploaded ++ v;
+  c.client_total_uploaded <- c.client_total_uploaded ++ v;
+  c.client_session_uploaded <- c.client_session_uploaded ++ v;
   donkey_upload_counter := !donkey_upload_counter ++ v;
   global_count_upload network v
 
Index: src/networks/donkey/donkeyTypes.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/networks/donkey/donkeyTypes.ml,v
retrieving revision 1.52
retrieving revision 1.54
diff -u -r1.52 -r1.54
--- src/networks/donkey/donkeyTypes.ml	26 Nov 2006 16:36:29 -0000	1.52
+++ src/networks/donkey/donkeyTypes.ml	2 Dec 2006 12:35:46 -0000	1.54
@@ -33,20 +33,32 @@
   lprintf2 log_prefix fmt
 
 type emule_proto = {
-    mutable emule_comments : int;
     mutable emule_version : int;
     mutable emule_release : string;
-    mutable emule_secident : int;
-    mutable emule_noviewshared : int;
-    mutable emule_supportpreview : int;
     mutable emule_osinfosupport : int;
+    mutable emule_features : int;
 
+(* emule_miscoptions1 *)
+    mutable emule_aich : int;
+    mutable emule_unicode : int;
+    mutable emule_udpver : int;
     mutable emule_compression : int;
+    mutable emule_secident : int;
     mutable emule_sourceexchange : int;
-    mutable emule_multipacket : int;
     mutable emule_extendedrequest : int;
-    mutable emule_features : int;
-    mutable emule_udpver : int;
+    mutable emule_comments : int;
+    mutable emule_peercache : int;
+    mutable emule_noviewshared : int;
+    mutable emule_multipacket : int;
+    mutable emule_supportpreview : int;
+
+(* emule_miscoptions2 *)
+    mutable emule_require_crypt : int;
+    mutable emule_request_crypt : int;
+    mutable emule_support_crypt : int;
+    mutable emule_extmultipacket : int;
+    mutable emule_largefiles : int;
+    mutable emule_kad_version : int;
   }
 
 type emule_tag_name =
@@ -557,8 +569,10 @@
     mutable client_checked : bool;
     mutable client_connected : bool;
 (* statistics *)
-    mutable client_downloaded : Int64.t;
-    mutable client_uploaded : Int64.t;
+    mutable client_session_downloaded : Int64.t;
+    mutable client_session_uploaded : Int64.t;
+    mutable client_total_downloaded : Int64.t;
+    mutable client_total_uploaded : Int64.t;
     mutable client_brand : brand;
     mutable client_brand_mod : brand_mod;
     mutable client_osinfo_sent : bool;
@@ -688,20 +702,32 @@
   CommonServer.server_state (as_server server.server_server)
 
 let dummy_emule_proto = {
-    emule_comments = 0;
     emule_version = 0;
     emule_release = "";
-    emule_secident = 0;
-    emule_noviewshared = 0;
-    emule_supportpreview = 0;
     emule_osinfosupport = 0;
+    emule_features = 0;
 
+(* emule_miscoptions1 *)
+    emule_aich = 0;
+    emule_unicode = 0;
+    emule_udpver = 0;
     emule_compression = 0; (* 1 *)
+    emule_secident = 0;
     emule_sourceexchange = 0; (* 3 *)
-    emule_multipacket = 0; (* 1 *)
     emule_extendedrequest = 0; (* 2 *)
-    emule_features = 0; (* 3 *)
-    emule_udpver = 0; (* 4 *)
+    emule_comments = 0;
+    emule_peercache = 0;
+    emule_noviewshared = 0;
+    emule_multipacket = 0;
+    emule_supportpreview = 0;
+
+(* emule_miscoptions2 *)
+    emule_require_crypt = 0;
+    emule_request_crypt = 0;
+    emule_support_crypt = 0;
+    emule_extmultipacket = 0;
+    emule_largefiles = 0;
+    emule_kad_version = 0;
   }
 
 let emule_proto () =
Index: src/networks/donkey/donkeyUdp.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/networks/donkey/donkeyUdp.ml,v
retrieving revision 1.26
retrieving revision 1.27
diff -u -r1.26 -r1.27
--- src/networks/donkey/donkeyUdp.ml	26 Nov 2006 16:36:29 -0000	1.26
+++ src/networks/donkey/donkeyUdp.ml	3 Dec 2006 20:49:42 -0000	1.27
@@ -322,12 +322,12 @@
       s.server_udp_desc_challenge <- None;
       List.iter (fun tag ->
           match tag with
-              { tag_name = Field_UNKNOWN "version"; tag_value = Uint64 i } ->
+              { tag_name = Field_KNOWN "version"; tag_value = Uint64 i } ->
                 let i = Int64.to_int i in
                 s.server_version <- Printf.sprintf "%d.%d" (i lsr 16) (i land 0xFFFF);
-	    | { tag_name = Field_UNKNOWN "auxportslist" ; tag_value = String aux } ->
+	    | { tag_name = Field_KNOWN "auxportslist" ; tag_value = String aux } ->
 		s.server_auxportslist <- aux
-	    |  { tag_name = Field_UNKNOWN "dynip" ; tag_value = String dynip } ->
+	    |  { tag_name = Field_KNOWN "dynip" ; tag_value = String dynip } ->
 		s.server_dynip <- dynip
             | _ -> ()
       ) t.M.tags;
Index: src/networks/fasttrack/fasttrackNetwork.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/networks/fasttrack/fasttrackNetwork.ml,v
retrieving revision 1.2
retrieving revision 1.3
diff -u -r1.2 -r1.3
--- src/networks/fasttrack/fasttrackNetwork.ml	7 Aug 2005 12:57:22 -0000	1.2
+++ src/networks/fasttrack/fasttrackNetwork.ml	3 Dec 2006 20:49:42 -0000	1.3
@@ -34,30 +34,30 @@
 (* any = 0 *)
 let name_of_tag =
   [
-    Field_UNKNOWN "any", 0;
-    Field_UNKNOWN "year", 1;
+    Field_KNOWN "any", 0;
+    Field_KNOWN "year", 1;
     Field_Filename, 2;
     Field_Uid, 3;
     Field_Title, 4;
-    Field_UNKNOWN "time", 5;
+    Field_KNOWN "time", 5;
     Field_Artist, 6;
     Field_Album, 8;
-    Field_UNKNOWN "language", 0x0A;
-    Field_UNKNOWN "keywords", 0x0C;
-    Field_UNKNOWN "resolution", 0x0D;
-    Field_UNKNOWN "genre", 0x0E;
-    Field_UNKNOWN "OS", 0x10;
-    Field_UNKNOWN "bitdepth", 0x11;
+    Field_KNOWN "language", 0x0A;
+    Field_KNOWN "keywords", 0x0C;
+    Field_KNOWN "resolution", 0x0D;
+    Field_KNOWN "genre", 0x0E;
+    Field_KNOWN "OS", 0x10;
+    Field_KNOWN "bitdepth", 0x11;
     Field_Type, 0x12;
-    Field_UNKNOWN "quality", 0x15;
-    Field_UNKNOWN "version", 0x18;
-    Field_UNKNOWN "comment", 0x1A;
+    Field_KNOWN "quality", 0x15;
+    Field_KNOWN "version", 0x18;
+    Field_KNOWN "comment", 0x1A;
     Field_Codec, 0x1C; (* "divx" *)
-    Field_UNKNOWN "rating", 0x1D;
+    Field_KNOWN "rating", 0x1D;
     Field_Size, 0x21;
     Field_Type, 0x22; (* "movie", "video clip",... *)
-    Field_UNKNOWN "49", 49;
-    Field_UNKNOWN "53", 53;
+    Field_KNOWN "49", 49;
+    Field_KNOWN "53", 53;
   ]
 
 type cipher
Index: src/networks/fasttrack/fasttrackProto.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/networks/fasttrack/fasttrackProto.ml,v
retrieving revision 1.17
retrieving revision 1.18
diff -u -r1.17 -r1.18
--- src/networks/fasttrack/fasttrackProto.ml	28 Aug 2006 18:19:16 -0000	1.17
+++ src/networks/fasttrack/fasttrackProto.ml	3 Dec 2006 20:49:42 -0000	1.18
@@ -108,30 +108,30 @@
 
 let tag_of_tag tag s =
   match tag with
-  | Field_UNKNOWN "any"
+  | Field_KNOWN "any"
   | Field_Filename
   | Field_Uid
   | Field_Title
-  | Field_UNKNOWN "time"
+  | Field_KNOWN "time"
   | Field_Artist
   | Field_Album
-  | Field_UNKNOWN "language"
-  | Field_UNKNOWN "keywords"
-  | Field_UNKNOWN "genre"
-  | Field_UNKNOWN "OS"
+  | Field_KNOWN "language"
+  | Field_KNOWN "keywords"
+  | Field_KNOWN "genre"
+  | Field_KNOWN "OS"
   | Field_Type
-  | Field_UNKNOWN "version"
-  | Field_UNKNOWN "comment"
+  | Field_KNOWN "version"
+  | Field_KNOWN "comment"
   | Field_Codec ->
       string_tag tag s
-  | Field_UNKNOWN "bitdepth"
-  | Field_UNKNOWN "year"
-  | Field_UNKNOWN "rating"
-  | Field_UNKNOWN "quality"
+  | Field_KNOWN "bitdepth"
+  | Field_KNOWN "year"
+  | Field_KNOWN "rating"
+  | Field_KNOWN "quality"
   | Field_Size ->
       let s, _ = get_dynint s 0 in
       int64_tag tag s
-  | Field_UNKNOWN "resolution" ->
+  | Field_KNOWN "resolution" ->
       let n1, pos = get_dynint s 0 in
       let n2, pos = get_dynint s pos in
       { tag_name =  tag; tag_value = Pair (n1, n2) }
@@ -145,7 +145,8 @@
   | Field_Lastseencomplete
   | Field_Mediacodec
   | Field_Medialength
-  | Field_UNKNOWN _ ->
+  | Field_UNKNOWN _
+  | Field_KNOWN _ ->
       string_tag tag s
 
 
@@ -433,7 +434,7 @@
 
           let tags =
             if words <> "" then
-              (Substring, string_tag (Field_UNKNOWN "any") words) :: tags
+              (Substring, string_tag (Field_KNOWN "any") words) :: tags
             else tags in
           buf_int8 b (List.length tags);
 
@@ -458,7 +459,7 @@
               buf_int8 b (
                 try List.assoc tag name_of_tag with
                   _ -> match tag with
-                      Field_UNKNOWN n -> int_of_string n
+                      Field_KNOWN n -> int_of_string n
                     | _ -> assert false);
               buf_string b s;
           ) tags;
@@ -869,7 +870,7 @@
           let tag = try
               List2.assoc_inv tag name_of_tag
             with _ ->
-                Field_UNKNOWN (string_of_int tag)
+                Field_KNOWN (string_of_int tag)
           in
           iter_tags (pos + tag_len) (n-1)
           ((new_tag tag tagdata) :: tags)
@@ -916,7 +917,7 @@
                 List2.assoc_inv tag name_of_tag
               with Not_found ->
                   lprintf "WARNING Unknown tag %d\n" tag;
-                  Field_UNKNOWN (string_of_int tag)
+                  Field_KNOWN (string_of_int tag)
             in
             let v, pos = get_string m (pos+2) in
             let tag = tag_of_tag tag v in
@@ -1939,6 +1940,7 @@
           | Field_Artist
           | Field_Title
           | Field_Codec
+          | Field_KNOWN _
           | Field_UNKNOWN _
           | Field_Filename ->
               tags := (Substring, string_tag field w) :: !tags
@@ -1957,14 +1959,14 @@
         begin
           match field with
           | Field_Size
-          | Field_UNKNOWN _
+          | Field_KNOWN _
             -> tags := (AtLeast, int64_tag field value) :: !tags
           | _ -> ()
         end
     | QHasMaxVal (field, value) ->
         begin
           match field with
-          | Field_UNKNOWN _
+          | Field_KNOWN _
           | Field_Size ->
               tags := (AtMost, int64_tag field value) :: !tags
           | _ -> ()
Index: src/networks/fileTP/fileTPClients.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/networks/fileTP/fileTPClients.ml,v
retrieving revision 1.23
retrieving revision 1.24
diff -u -r1.23 -r1.24
--- src/networks/fileTP/fileTPClients.ml	19 Sep 2006 17:07:43 -0000	1.23
+++ src/networks/fileTP/fileTPClients.ml	2 Dec 2006 12:35:46 -0000	1.24
@@ -74,6 +74,7 @@
           if !verbose_msg_clients then
               lprintf_nl "Disconnected from source";
           c.client_requests <- [];
+          c.client_session_downloaded <- 0L;
           connection_failed c.client_connection_control;
           set_client_disconnected c r;
           close sock r;
Index: src/networks/fileTP/fileTPFTP.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/networks/fileTP/fileTPFTP.ml,v
retrieving revision 1.14
retrieving revision 1.15
diff -u -r1.14 -r1.15
--- src/networks/fileTP/fileTPFTP.ml	19 Sep 2006 17:07:43 -0000	1.14
+++ src/networks/fileTP/fileTPFTP.ml	2 Dec 2006 12:35:46 -0000	1.15
@@ -108,7 +108,8 @@
             CommonSwarming.received up !counter_pos b.buf b.pos to_read_int;
             let new_downloaded = CommonSwarming.downloaded swarmer in
 
-	    c.client_downloaded <- c.client_downloaded ++ (new_downloaded -- old_downloaded);
+	    c.client_total_downloaded <- c.client_total_downloaded ++ (new_downloaded -- old_downloaded);
+	    c.client_session_downloaded <- c.client_session_downloaded ++ (new_downloaded -- old_downloaded);
             client_must_update (as_client c);
 
             if new_downloaded = file_size file then
Index: src/networks/fileTP/fileTPGlobals.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/networks/fileTP/fileTPGlobals.ml,v
retrieving revision 1.30
retrieving revision 1.31
diff -u -r1.30 -r1.31
--- src/networks/fileTP/fileTPGlobals.ml	9 Nov 2006 21:32:27 -0000	1.30
+++ src/networks/fileTP/fileTPGlobals.ml	2 Dec 2006 12:35:46 -0000	1.31
@@ -192,7 +192,8 @@
           client_hostname = hostname;
           client_referer = referer;
           client_port = port;
-	  client_downloaded = zero;
+	  client_total_downloaded = zero;
+	  client_session_downloaded = zero;
           client_reconnect = false;
           client_in_queues = [];
           client_connected_for = None;
Index: src/networks/fileTP/fileTPHTTP.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/networks/fileTP/fileTPHTTP.ml,v
retrieving revision 1.26
retrieving revision 1.27
diff -u -r1.26 -r1.27
--- src/networks/fileTP/fileTPHTTP.ml	19 Sep 2006 17:07:43 -0000	1.26
+++ src/networks/fileTP/fileTPHTTP.ml	2 Dec 2006 12:35:46 -0000	1.27
@@ -288,7 +288,8 @@
             CommonSwarming.received up !counter_pos b.buf b.pos to_read_int;
             let new_downloaded = CommonSwarming.downloaded swarmer in
 
-            c.client_downloaded <- c.client_downloaded ++ (new_downloaded -- old_downloaded);
+            c.client_total_downloaded <- c.client_total_downloaded ++ (new_downloaded -- old_downloaded);
+            c.client_session_downloaded <- c.client_session_downloaded ++ (new_downloaded -- old_downloaded);
             client_must_update (as_client c);
 
             if new_downloaded = file_size file then
Index: src/networks/fileTP/fileTPInteractive.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/networks/fileTP/fileTPInteractive.ml,v
retrieving revision 1.52
retrieving revision 1.53
diff -u -r1.52 -r1.53
--- src/networks/fileTP/fileTPInteractive.ml	12 Nov 2006 12:44:24 -0000	1.52
+++ src/networks/fileTP/fileTPInteractive.ml	2 Dec 2006 12:35:46 -0000	1.53
@@ -123,7 +123,8 @@
         P.client_num = (client_num (as_client c));
         P.client_connect_time = BasicSocket.last_time ();
         P.client_software = c.client_software;
-        P.client_downloaded = c.client_downloaded;
+        P.client_total_downloaded = c.client_total_downloaded;
+        P.client_session_downloaded = c.client_session_downloaded;
       }
   );
     client_ops.op_client_bprint <- (fun c buf ->
@@ -141,8 +142,8 @@
         client_print cc o;
         Printf.bprintf buf "client: %s downloaded: %s uploaded: %s"
           cinfo.GuiTypes.client_software
-          (Int64.to_string cinfo.GuiTypes.client_downloaded)
-        (Int64.to_string cinfo.GuiTypes.client_uploaded);
+          (Int64.to_string cinfo.GuiTypes.client_total_downloaded)
+        (Int64.to_string cinfo.GuiTypes.client_total_uploaded);
         Printf.bprintf buf "\nfilename: %s\n\n" info.GuiTypes.file_name;
     );
     client_ops.op_client_dprint_html <- (fun c o file str ->
@@ -183,8 +184,10 @@
           ("", "sr", "N");
           ("", "sr", Printf.sprintf "%s:%d" (Ip.to_string client_ip) client_port);
           ] @ (if !Geoip.active then [(cname, "sr", ccode)] else []) @ [
-          ("", "sr ar", (size_of_int64 cinfo.GuiTypes.client_uploaded));
-          ("", "sr ar", (size_of_int64 cinfo.GuiTypes.client_downloaded));
+          ("", "sr ar", (size_of_int64 cinfo.GuiTypes.client_total_uploaded));
+          ("", "sr ar", (size_of_int64 cinfo.GuiTypes.client_total_downloaded));
+          ("", "sr ar", (size_of_int64 cinfo.GuiTypes.client_session_uploaded));
+          ("", "sr ar", (size_of_int64 cinfo.GuiTypes.client_session_downloaded));
           ("", "sr", info.GuiTypes.file_name); ]);
         true
     )
Index: src/networks/fileTP/fileTPSSH.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/networks/fileTP/fileTPSSH.ml,v
retrieving revision 1.10
retrieving revision 1.11
diff -u -r1.10 -r1.11
--- src/networks/fileTP/fileTPSSH.ml	30 May 2006 10:54:14 -0000	1.10
+++ src/networks/fileTP/fileTPSSH.ml	2 Dec 2006 12:35:46 -0000	1.11
@@ -103,7 +103,8 @@
             let new_downloaded =
               CommonSwarming.downloaded swarmer in
 
-	    c.client_downloaded <- c.client_downloaded ++ (new_downloaded -- old_downloaded);
+	    c.client_session_downloaded <- c.client_session_downloaded ++ (new_downloaded -- old_downloaded);
+	    c.client_total_downloaded <- c.client_total_downloaded ++ (new_downloaded -- old_downloaded);
             client_must_update (as_client c);
 
             if new_downloaded = file_size file then
Index: src/networks/fileTP/fileTPTypes.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/networks/fileTP/fileTPTypes.ml,v
retrieving revision 1.13
retrieving revision 1.14
diff -u -r1.13 -r1.14
--- src/networks/fileTP/fileTPTypes.ml	1 Sep 2006 16:22:15 -0000	1.13
+++ src/networks/fileTP/fileTPTypes.ml	2 Dec 2006 12:35:46 -0000	1.14
@@ -32,7 +32,8 @@
     mutable client_referer : string;
     mutable client_downloads : download list;
     mutable client_in_queues : file list;
-    mutable client_downloaded : int64;
+    mutable client_total_downloaded : int64;
+    mutable client_session_downloaded : int64;
     mutable client_connection_control : connection_control;
     mutable client_sock : tcp_connection;
     mutable client_requests : download list;
Index: src/networks/gnutella/gnutellaInteractive.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/networks/gnutella/gnutellaInteractive.ml,v
retrieving revision 1.67
retrieving revision 1.68
diff -u -r1.67 -r1.68
--- src/networks/gnutella/gnutellaInteractive.ml	12 Nov 2006 12:44:24 -0000	1.67
+++ src/networks/gnutella/gnutellaInteractive.ml	2 Dec 2006 12:35:46 -0000	1.68
@@ -442,8 +442,8 @@
         client_print cc o; 
         Printf.bprintf buf "client: %s downloaded: %s uploaded: %s"
           "gN" (* cinfo.GuiTypes.client_software *)
-          (Int64.to_string cinfo.GuiTypes.client_downloaded)
-        (Int64.to_string cinfo.GuiTypes.client_uploaded);
+          (Int64.to_string cinfo.GuiTypes.client_total_downloaded)
+        (Int64.to_string cinfo.GuiTypes.client_total_uploaded);
         Printf.bprintf buf "\nfilename: %s\n\n" info.GuiTypes.file_name;
     );    
     client_ops.op_client_dprint_html <- (fun c o file str ->
@@ -477,8 +477,10 @@
           ("", "sr", "N");
           ("", "sr", (string_of_kind cinfo.GuiTypes.client_kind));
           ] @ (if !Geoip.active then [("?", "sr", "?")] else []) @ [
-          ("", "sr ar", (size_of_int64 cinfo.GuiTypes.client_uploaded));
-          ("", "sr ar", (size_of_int64 cinfo.GuiTypes.client_downloaded));
+          ("", "sr ar", (size_of_int64 cinfo.GuiTypes.client_total_uploaded));
+          ("", "sr ar", (size_of_int64 cinfo.GuiTypes.client_total_downloaded));
+          ("", "sr ar", (size_of_int64 cinfo.GuiTypes.client_session_uploaded));
+          ("", "sr ar", (size_of_int64 cinfo.GuiTypes.client_session_downloaded));
           ("", "sr", info.GuiTypes.file_name); ]);
         true
     )     
Index: src/networks/opennap/opennapInteractive.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/networks/opennap/opennapInteractive.ml,v
retrieving revision 1.26
retrieving revision 1.27
diff -u -r1.26 -r1.27
--- src/networks/opennap/opennapInteractive.ml	1 Oct 2006 17:54:00 -0000	1.26
+++ src/networks/opennap/opennapInteractive.ml	3 Dec 2006 20:49:42 -0000	1.27
@@ -78,7 +78,7 @@
         | QHasMinVal (field, value) ->
             begin
               match field with
-                Field_UNKNOWN "bitrate" ->  
+                Field_KNOWN "bitrate" ->  
                   { t with S.bitrate = Some (Int64.to_int value, OP.AtLeast) };
               | Field_Size -> t
               | _ -> t
@@ -86,7 +86,7 @@
         | QHasMaxVal (field, value) ->
             begin
               match field with
-                Field_UNKNOWN "bitrate" -> 
+                Field_KNOWN "bitrate" -> 
                   { t with S.bitrate = Some (Int64.to_int value, OP.AtBest) };
               | Field_Size -> t
               | _ -> t
Index: src/networks/server/serverUdp.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/networks/server/serverUdp.ml,v
retrieving revision 1.2
retrieving revision 1.3
diff -u -r1.2 -r1.3
--- src/networks/server/serverUdp.ml	16 Oct 2005 20:42:54 -0000	1.2
+++ src/networks/server/serverUdp.ml	28 Nov 2006 23:58:02 -0000	1.3
@@ -431,7 +431,7 @@
             else
               dead_servers := s :: !dead_servers
         ) DonkeyGlobals.servers_by_key;
-        let alive_servers = Sort.list (fun s1 s2 ->
+        let alive_servers = List.sort (fun s1 s2 ->
             s1.DonkeyTypes.server_last_message >= 
             s2.DonkeyTypes.server_last_message
           ) !alive_servers in
Index: src/utils/cdk/sort2.ml
===================================================================
RCS file: src/utils/cdk/sort2.ml
diff -N src/utils/cdk/sort2.ml
--- src/utils/cdk/sort2.ml	22 Apr 2003 22:33:39 -0000	1.1
+++ /dev/null	1 Jan 1970 00:00:00 -0000
@@ -1,97 +0,0 @@
-(***********************************************************************)
-(*                                                                     *)
-(*                           Objective Caml                            *)
-(*                                                                     *)
-(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
-(*                                                                     *)
-(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
-(*  en Automatique.  All rights reserved.  This file is distributed    *)
-(*  under the terms of the GNU Library General Public License, with    *)
-(*  the special exception on linking described in file ../LICENSE.     *)
-(*                                                                     *)
-(***********************************************************************)
-
-(* Merging and sorting *)
-
-open Array
-
-  (*
-let rec merge order l1 l2 =
-  match l1 with
-    [] -> l2
-  | h1 :: t1 ->
-      match l2 with
-        [] -> l1
-      | h2 :: t2 ->
-          if order h1 h2
-          then h1 :: merge order t1 l2
-          else h2 :: merge order l1 t2
-
-let list order l =
-  let rec initlist = function
-      [] -> []
-    | [e] -> [[e]]
-    | e1::e2::rest ->
-        (if order e1 e2 then [e1;e2] else [e2;e1]) :: initlist rest in
-  let rec merge2 = function
-      l1::l2::rest -> merge order l1 l2 :: merge2 rest
-    | x -> x in
-  let rec mergeall = function
-      [] -> []
-    | [l] -> l
-    | llist -> mergeall (merge2 llist) in
-  mergeall(initlist l)
-  *)
-
-let swap arr i j =
-  let tmp = unsafe_get arr i in
-  unsafe_set arr i (unsafe_get arr j);
-  unsafe_set arr j tmp
-
-let subarray cmp arr pos len =
-  let rec qsort lo hi =
-    if hi - lo >= 6 then begin
-      let mid = (lo + hi) lsr 1 in
-      (* Select median value from among LO, MID, and HI. Rearrange
-         LO and HI so the three values are sorted. This lowers the
-         probability of picking a pathological pivot.  It also
-         avoids extra comparisons on i and j in the two tight "while"
-         loops below. *)
-      if cmp (unsafe_get arr mid) (unsafe_get arr lo) <= 0 then swap arr mid lo;
-      if cmp (unsafe_get arr hi) (unsafe_get arr mid) <= 0 then begin
-        swap arr mid hi;
-        if cmp (unsafe_get arr mid) (unsafe_get arr lo) <= 0 then swap arr mid lo
-      end;
-      let pivot = unsafe_get arr mid in
-      let i = ref (lo + 1) and j = ref (hi - 1) in
-      if not (cmp pivot (unsafe_get arr hi) <= 0)
-         || not (cmp (unsafe_get arr lo) pivot <= 0)
-      then raise (Invalid_argument "Sort.array");
-      while !i < !j do
-        while not (cmp pivot (unsafe_get arr !i) <= 0) do incr i done;
-        while not (cmp (unsafe_get arr !j) pivot <= 0) do decr j done;
-        if !i < !j then swap arr !i !j;
-        incr i; decr j
-      done;
-      (* Recursion on smaller half, tail-call on larger half *)
-      if !j - lo <= hi - !i then begin
-        qsort lo !j; qsort !i hi
-      end else begin
-        qsort !i hi; qsort lo !j
-      end
-    end in
-  qsort pos (pos+len-1);
-  (* Finish sorting by insertion sort *)
-  for i = pos+1 to pos+len - 1 do
-    let val_i = (unsafe_get arr i) in
-    if not (cmp (unsafe_get arr (i - 1)) val_i <= 0) then begin
-      unsafe_set arr i (unsafe_get arr (i - 1));
-      let j = ref (i - 1) in
-      while !j >= 1 && not (cmp (unsafe_get arr (!j - 1)) val_i <= 0) do
-        unsafe_set arr !j (unsafe_get arr (!j - 1));
-        decr j
-      done;
-      unsafe_set arr !j val_i
-    end
-  done
-
Index: src/utils/cdk/sort2.mli
===================================================================
RCS file: src/utils/cdk/sort2.mli
diff -N src/utils/cdk/sort2.mli
--- src/utils/cdk/sort2.mli	22 Apr 2003 22:33:39 -0000	1.1
+++ /dev/null	1 Jan 1970 00:00:00 -0000
@@ -1,43 +0,0 @@
-(***********************************************************************)
-(*                                                                     *)
-(*                           Objective Caml                            *)
-(*                                                                     *)
-(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
-(*                                                                     *)
-(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
-(*  en Automatique.  All rights reserved.  This file is distributed    *)
-(*  under the terms of the GNU Library General Public License, with    *)
-(*  the special exception on linking described in file ../LICENSE.     *)
-(*                                                                     *)
-(***********************************************************************)
-
-(** Sorting and merging lists.
-
-   @deprecated This module is obsolete and exists only for backward
-   compatibility.
-   The sorting functions in {!Array} and {!List} should be used instead.
-   The new functions are faster and use less memory.
-*)
-
-(*
-val list : ('a -> 'a -> bool) -> 'a list -> 'a list
-(** Sort a list in increasing order according to an ordering predicate.
-   The predicate should return [true] if its first argument is
-   less than or equal to its second argument. *)
-*)
-
-val subarray : ('a -> 'a -> int) -> 'a array -> int -> int -> unit
-(** Sort an array in increasing order according to an
-   ordering predicate.
-   The predicate should return [true] if its first argument is
-   less than or equal to its second argument.
-   The array is sorted in place. *)
-
-  (*
-val merge : ('a -> 'a -> bool) -> 'a list -> 'a list -> 'a list
-(** Merge two lists according to the given predicate.
-   Assuming the two argument lists are sorted according to the
-   predicate, [merge] returns a sorted list containing the elements
-   from the two lists. The behavior is undefined if the two
-   argument lists were not sorted. *)
-*)
Index: src/utils/cdk/string2.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/utils/cdk/string2.ml,v
retrieving revision 1.9
retrieving revision 1.10
diff -u -r1.9 -r1.10
--- src/utils/cdk/string2.ml	20 Jul 2006 15:30:21 -0000	1.9
+++ src/utils/cdk/string2.ml	3 Dec 2006 20:49:43 -0000	1.10
@@ -322,3 +322,9 @@
     i >= l || p s.[i] && aux (i+1) in
   aux 0
 
+let hex_string_of_string s =
+  let buf = Buffer.create 100 in
+  String.iter (fun c ->
+    Printf.bprintf buf "%02x " (int_of_char c)
+  ) s;
+  Buffer.contents buf
Index: src/utils/cdk/string2.mli
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/utils/cdk/string2.mli,v
retrieving revision 1.10
retrieving revision 1.11
diff -u -r1.10 -r1.11
--- src/utils/cdk/string2.mli	20 Jul 2006 15:30:21 -0000	1.10
+++ src/utils/cdk/string2.mli	3 Dec 2006 20:49:43 -0000	1.11
@@ -103,3 +103,4 @@
 val exists: (char -> bool) -> string -> bool
 val existsi: (int -> char -> bool) -> string -> bool
 val for_all: (char -> bool) -> string -> bool
+val hex_string_of_string : string -> string
Index: src/utils/cdk/unix2.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/utils/cdk/unix2.ml,v
retrieving revision 1.31
retrieving revision 1.32
diff -u -r1.31 -r1.32
--- src/utils/cdk/unix2.ml	12 Aug 2006 20:36:14 -0000	1.31
+++ src/utils/cdk/unix2.ml	28 Nov 2006 23:52:17 -0000	1.32
@@ -89,7 +89,7 @@
   with e -> 
     lprintf_nl "warning: chmod failed on %s: %s" f (Printexc2.to_string e)
 
-let rec safe_mkdir dir =  
+let rec safe_mkdir ?(mode = 0o775) dir =  
   if Sys.file_exists dir then begin
     if not (is_directory dir) then 
       failwith (Printf.sprintf "%s already exists but is not a directory" dir)
@@ -112,7 +112,7 @@
       let predir = Filename.dirname dir in
       if predir <> dir then safe_mkdir predir;
       try
-        Unix.mkdir dir 0o775
+        Unix.mkdir dir mode
       with
 	Unix.Unix_error (EEXIST, _, _) -> ()
       | e -> lprintf_nl "error %s for directory %s" (Printexc2.to_string e) dir; exit 73
@@ -136,7 +136,13 @@
 
 let copy oldname newname =
   tryopen_read_bin oldname (fun ic ->
+    let stats = Unix.fstat (Unix.descr_of_in_channel ic) in
     tryopen_write_bin newname (fun oc ->
+      let descr = Unix.descr_of_out_channel oc in
+      (try Unix.fchown descr stats.Unix.st_uid stats.Unix.st_gid 
+       with e -> lprintf_nl "copy: failed to preserve owner");
+      (try Unix.fchmod descr stats.Unix.st_perm 
+       with e -> lprintf_nl "copy: failed to preserve mode");
       let buffer_len = 8192 in
       let buffer = String.create buffer_len in
       let rec copy_file () =
Index: src/utils/lib/unix32.ml
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/utils/lib/unix32.ml,v
retrieving revision 1.65
retrieving revision 1.66
diff -u -r1.65 -r1.66
--- src/utils/lib/unix32.ml	15 Jul 2006 11:52:54 -0000	1.65
+++ src/utils/lib/unix32.ml	28 Nov 2006 23:52:18 -0000	1.66
@@ -31,15 +31,14 @@
   
 let max_buffered = ref (Int64.of_int (1024 * 1024))
   
-let create_dir_mask = ref "755"
+let create_file_mode = ref 0o664
+let create_dir_mode = ref 0o755
 let verbose = ref false
 let max_cache_size = ref 50
   
 let mini (x: int) (y: int) =
   if x > y then y else x
     
-let rights = 0o664
-  
 let ro_flag =  [Unix.O_RDONLY]
 let rw_flag =  [Unix.O_RDWR]
 let rw_creat_flag =  [Unix.O_CREAT; Unix.O_RDWR]
@@ -121,7 +120,8 @@
 		try
 		  if t.writable then
                     Unix.openfile t.filename 
-		      (if creat then rw_creat_flag else rw_flag) rights
+		      (if creat then rw_creat_flag else rw_flag) 
+		      !create_file_mode
 		  else
 		    Unix.openfile t.filename ro_flag 0o400
 		with e ->
@@ -254,9 +254,9 @@
       check_destroyed t;
       close t;
       (let d = (Filename.dirname (Filename.concat f file)) in
-        Unix2.safe_mkdir d;
-        Unix2.chmod d (Misc.int_of_octal_string !create_dir_mask);
-	Unix2.can_write_to_directory d);
+       Unix2.safe_mkdir d;
+       Unix2.chmod d !create_dir_mode;
+       Unix2.can_write_to_directory d);
       (try
         Unix2.rename t.filename (Filename.concat f file);
       with
Index: src/utils/lib/unix32.mli
===================================================================
RCS file: /sources/mldonkey/mldonkey/src/utils/lib/unix32.mli,v
retrieving revision 1.23
retrieving revision 1.24
diff -u -r1.23 -r1.24
--- src/utils/lib/unix32.mli	6 Mar 2006 18:02:16 -0000	1.23
+++ src/utils/lib/unix32.mli	28 Nov 2006 23:52:18 -0000	1.24
@@ -26,7 +26,8 @@
 val uname : unit -> string
 val os_supported : unit -> bool
 
-val create_dir_mask : string ref
+val create_file_mode : int ref
+val create_dir_mode : int ref
 val close : t -> unit
 (* val force_fd : t -> Unix.file_descr *)
   
