
$FreeBSD$

--- libnautilus-extensions/nautilus-volume-monitor.c.orig	Sat Feb 24 01:54:34 2001
+++ libnautilus-extensions/nautilus-volume-monitor.c	Sun Mar 11 15:46:11 2001
@@ -68,6 +68,12 @@
 #include <mntent.h>
 #endif
 
+#ifdef __FreeBSD__
+#include <sys/param.h>
+#include <sys/ucred.h>
+#include <sys/mount.h>
+#endif
+
 #ifdef HAVE_SYS_MNTTAB_H
 #define SOLARIS_MNT 1
 #include <sys/mnttab.h>
@@ -327,6 +333,12 @@
 has_removable_mntent_options (struct mnttab *ent)
 {
 
+#elif defined(__FreeBSD__)
+
+static gboolean
+has_removable_mntent_options (struct fstab *ent)
+{
+
 #else
 
 static gboolean
@@ -335,12 +347,18 @@
 
 #endif /* HAVE_SYS_MNTTAB_H */
 
+#ifndef __FreeBSD__
 	/* Use "owner" or "user" or "users" as our way of determining a removable volume */
 	if (hasmntopt (ent, "user") != NULL
 	    || hasmntopt (ent, "users") != NULL
 	    || hasmntopt (ent, "owner") != NULL) {
 	    return TRUE;
 	}
+#else
+	if (strstr (ent->fs_mntops, "noauto") != NULL) {
+		return TRUE;
+	}
+#endif
 
 #if SOLARIS_MNT && HAVE_VOL
        if (strstr (ent->mnt_special, "/vol/") == ent->mnt_special) {
@@ -360,23 +378,32 @@
 static GList *
 get_removable_volumes (void)
 {
+#ifndef __FreeBSD__
 	FILE *file;
-	GList *volumes;
 #if HAVE_SYS_MNTTAB_H
         struct mnttab dummy_ent;
         struct mnttab *ent = &dummy_ent;
 #else
 	struct mntent *ent;
 #endif /* HAVE_SYS_MNTTAB_H */
+#else  /* __FreeBSD__ */
+struct fstab *ent;
+#endif /* __FreeBSD__ */
+	GList *volumes;
 	NautilusVolume *volume;
 	
 	volumes = NULL;
 	
+#ifndef __FreeBSD__
 	file = setmntent (PATH_MOUNT_TABLE, "r");
 	if (file == NULL) {
 		return NULL;
 	}
+#else
+	setfsent();
+#endif /* __FreeBSD__ */
 	
+#ifndef __FreeBSD__
 #if HAVE_SYS_MNTTAB_H
 	while (! getmntent (file, ent)) {
 		/* On Solaris look for /vol/ for determining a removable volume */
@@ -396,12 +423,27 @@
 			volume->filesystem = g_strdup (ent->mnt_type);
 
 #endif /* HAVE_SYS_MNTTAB_H */
+#else  /* __FreeBSD__ */
+	while ((ent = getfsent ()) != NULL) {
+		/* Use noauto as our way of determining a removable volume */
+		if (strstr (ent->fs_mntops, "noauto") != NULL) {
+			volume = g_new0 (NautilusVolume, 1);
+			volume->device_path = g_strdup (ent->fs_spec);
+			volume->mount_path = g_strdup (ent->fs_file);
+			volume->filesystem = g_strdup (ent->fs_vfstype);
+			volume->is_removable = TRUE;
+			volume->is_read_only = (strstr (ent->fs_type, FSTAB_RO) !=NULL);
+#endif /* __FreeBSD__ */
 
 			volumes = mount_volume_add_filesystem (volume, volumes);
 		}	
 	}
 			
+#ifndef __FreeBSD__
 	fclose (file);
+#else
+	endfsent();
+#endif
 	
 #ifdef MOUNT_AUDIO_CD
 	volume = g_new0 (NautilusVolume, 1);
@@ -419,6 +461,7 @@
 static gboolean
 volume_is_removable (const NautilusVolume *volume)
 {
+#ifndef __FreeBSD__
 	FILE *file;
 #if HAVE_SYS_MNTTAB_H
 	struct mnttab dummy_ent;
@@ -426,13 +469,21 @@
 #else
      	struct mntent *ent;
 #endif /* HAVE_SYS_MNTTAB_H */
+#else  /* __FreeBSD__ */
+	struct fstab *ent;
+#endif /* __FreeBSD__ */
 	
+#ifndef __FreeBSD__
 	file = setmntent (PATH_MOUNT_TABLE, "r");
 	if (file == NULL) {
 		return FALSE;
 	}
+#else
+	setfsent();
+#endif /* __FreeBSD__ */
 	
 	/* Search for our device in the fstab */
+#ifndef __FreeBSD__
 #if HAVE_SYS_MNTTAB_H
 	while (!getmntent (file, ent)) {
 		if (strcmp (volume->device_path, ent->mnt_special) == 0) {
@@ -455,8 +506,23 @@
 	}
 
 #endif /* HAVE_SYS_MNTTAB_H */
-	
+#else  /* __FreeBSD__ */
+	while ((ent = getfsent ()) != NULL) {
+		/* Use noauto as our way of determining a removable volume */
+		if (strcmp (volume->device_path, ent->fs_spec) == 0
+		    && has_removable_mntent_options (ent)) {
+		    	endfsent();
+		    	return TRUE;
+		}
+	}
+#endif /* __FreeBSD__ */
+			
+
+#ifndef __FreeBSD__	
 	fclose (file);
+#else
+	endfsent();
+#endif
 	return FALSE;
 }
 
@@ -484,14 +550,23 @@
  		}
  	}
 #else
+#ifndef __FreeBSD__
 	struct mntent *ent;
-	
+#else
+	struct fstab *ent;
+#endif
+
+#ifndef __FreeBSD__
 	file = setmntent (PATH_MOUNT_TABLE, "r");
 	if (file == NULL) {
 		return FALSE;
 	}
-		
+#else
+	setfsent();
+#endif /* __FreeBSD__ */
+
 	/* Search for our device in the fstab */
+#ifndef __FreeBSD__
 	while ((ent = getmntent (file)) != NULL) {
 		if (strcmp (volume->device_path, ent->mnt_fsname) == 0) {
 			if (strstr (ent->mnt_opts, MNTOPT_RO) != NULL) {
@@ -500,9 +575,21 @@
 			}
         	 }
 	}
+#else  /* __FreeBSD__ */
+	while ((ent = getfsent ()) != NULL) {
+		if (strcmp (volume->device_path, ent->fs_spec) == 0
+		    && strstr (ent->fs_type, FSTAB_RO) != NULL) {
+		    	endfsent();
+		    	return TRUE;
+		}
+	}
+	endfsent();
+#endif
 #endif
 				
+#ifndef __FreeBSD__
 	fclose (file);
+#endif
 	return FALSE;
 }
 
@@ -975,14 +1062,26 @@
         
        
 #else
+#ifndef __FreeBSD__
 	char line[PATH_MAX * 3];
 	char device_name[sizeof (line)];
 	NautilusStringList *list;
+#else  /* __FreeBSD__ */
+	struct statfs *mounted;
+	int mounted_num;
+	int i;
+#endif /* __FreeBSD__ */
 
+#ifndef __FreeBSD__
 	/* Open /proc/mounts */
 	fh = fopen (PATH_PROC_MOUNTS, "r");
 	g_return_val_if_fail (fh != NULL, NULL);
+#else   /* __FreeBSD__ */
+	mounted_num = getmntinfo(&mounted, MNT_WAIT);
+	g_return_val_if_fail (mounted_num > 0, NULL);
+#endif  /* __FreeBSD__ */
 
+#ifndef __FreeBSD__
 	while (fgets (line, sizeof(line), fh)) {
 		if (sscanf (line, "%s", device_name) == 1) {
 			list = nautilus_string_list_new_from_tokens (line, PROC_MOUNTS_SEPARATOR, FALSE);			
@@ -995,11 +1094,20 @@
 					volume->device_path = nautilus_string_list_nth (list, 0);
 					volume->mount_path = nautilus_string_list_nth (list, 1);
 					volume->filesystem = nautilus_string_list_nth (list, 2);
+#else /* __FreeBSD__ */
+	for (i = 0; i < mounted_num; i++) {
+		volume = g_new0 (NautilusVolume, 1);
+		volume->device_path = g_strdup(mounted[i].f_mntfromname);
+		volume->mount_path = g_strdup(mounted[i].f_mntonname);
+		volume->filesystem = g_strdup(mounted[i].f_fstypename);
+#endif /* __FreeBSD__ */
 					current_mounts = mount_volume_add_filesystem (volume, current_mounts);
+#ifndef __FreeBSD__
 				}				
 				nautilus_string_list_free (list);
 			}			
 		}
+#endif /* __FreeBSD__ */
   	}
 
 #endif /* SOLARIS_MNT */
@@ -1019,7 +1127,9 @@
 	}
 #endif
 
+#ifndef __FreeBSD__
 	fclose (fh);
+#endif
 	
 	return current_mounts;
 
@@ -1375,6 +1485,14 @@
 			break;
 		}
 	}
+#ifdef __FreeBSD__
+	struct fstab *ent;
+
+	setfsent ();
+	while ((ent = getfsent ())) 
+		fstab_add_mount_volume (monitor, ent);
+	endfsent ();
+#endif	/* __FreeBSD__ */
 }
 #endif
 
@@ -1869,7 +1987,7 @@
 	}
 	
 	if (mounted) {
-#ifndef SOLARIS_MNT			
+#if !defined(SOLARIS_MNT) && !defined(__FreeBSD__)
 		volume->is_removable = volume_is_removable (volume);
 		volume->is_read_only = volume_is_read_only (volume);
 #endif /* SOLARIS_MNT */
