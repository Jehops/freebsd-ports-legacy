
$FreeBSD$

--- libnautilus-private/nautilus-volume-monitor.c.orig	Fri Apr 27 04:19:07 2001
+++ libnautilus-private/nautilus-volume-monitor.c	Mon May 14 18:36:00 2001
@@ -67,6 +67,12 @@
 #define MOUNT_TABLE_PATH _PATH_MNTTAB
 #endif
 
+#ifdef __FreeBSD__
+#include <sys/param.h>
+#include <sys/ucred.h>
+#include <sys/mount.h>
+#endif
+
 #ifdef HAVE_SYS_MNTTAB_H
 #define SOLARIS_MNT 1
 #include <sys/mnttab.h>
@@ -119,6 +125,8 @@
 
 #ifdef HAVE_SYS_MNTTAB_H
 typedef struct mnttab MountTableEntry;
+#elif defined __FreeBSD__
+typedef struct fstab MountTableEntry;
 #else
 typedef struct mntent MountTableEntry;
 #endif
@@ -349,12 +357,18 @@
 static gboolean
 has_removable_mntent_options (MountTableEntry *ent)
 {
+#ifndef __FreeBSD__
 	/* Use "owner" or "user" or "users" as our way of determining a removable volume */
 	if (hasmntopt (ent, "user") != NULL
 	    || hasmntopt (ent, "users") != NULL
 	    || hasmntopt (ent, "owner") != NULL) {
 		return TRUE;
 	}
+#else
+	if (strstr (ent->fs_mntops, "noauto") != NULL) {
+		return TRUE;
+	}
+#endif
 
 #ifdef SOLARIS_MNT
 	if (eel_str_has_prefix (ent->mnt_special, "/vol/")) {
@@ -377,6 +391,7 @@
 {
 	FILE *file;
 	GList *volumes;
+
 	MountTableEntry *ent;
 	NautilusVolume *volume;
 #ifdef HAVE_SYS_MNTTAB_H
@@ -385,11 +400,16 @@
 	
 	volumes = NULL;
 	
+#ifndef __FreeBSD__
 	file = setmntent (MOUNT_TABLE_PATH, "r");
 	if (file == NULL) {
 		return NULL;
 	}
+#else
+	setfsent();
+#endif /* __FreeBSD__ */
 	
+#ifndef __FreeBSD__
 #ifdef HAVE_SYS_MNTTAB_H
         ent = &ent_storage;
 	while (! getmntent (file, ent)) {
@@ -409,8 +429,20 @@
 		}
 	}
 #endif /* HAVE_SYS_MNTTAB_H */
-			
+
 	fclose (file);
+			
+#else	/* __FreeBSD__ */
+	while ((ent = getfsent ()) != NULL) {
+		/* Use noauto as our way of determining a removable volume */
+		if (strstr (ent->fs_mntops, "noauto") != NULL) {
+			volume = create_volume (ent->fs_spec, ent->fs_file, ent->fs_vfstype);
+			volumes = mount_volume_add_filesystem (volume, volumes);
+		}
+	}
+
+	endfsent();
+#endif /* __FreeBSD__ */
 	
 #ifdef HAVE_CDDA
 	volume = create_volume (CD_AUDIO_PATH, CD_AUDIO_PATH, CDDA_SCHEME);
@@ -427,18 +459,27 @@
 static gboolean
 volume_is_removable (const NautilusVolume *volume)
 {
+#ifndef	__FreeBSD__
 	FILE *file;
      	MountTableEntry *ent;
 #ifdef HAVE_SYS_MNTTAB_H
 	MountTableEntry ent_storage;
 #endif
+#else	/* __FreeBSD__ */
+	struct fstab *ent;
+#endif	/* __FreeBSD__ */
 
+#ifndef __FreeBSD__
 	file = setmntent (MOUNT_TABLE_PATH, "r");
 	if (file == NULL) {
 		return FALSE;
 	}
+#else
+	setfsent();
+#endif	/* __FreeBSD__ */
 	
 	/* Search for our device in the fstab */
+#ifndef __FreeBSD__
 #ifdef HAVE_SYS_MNTTAB_H
 	MountTableEntry *ent = &ent_storage;
 	while (!getmntent (file, ent)) {
@@ -460,8 +501,22 @@
 		}	
 	}
 #endif /* HAVE_SYS_MNTTAB_H */
+#else  /* __FreeBSD__ */
+	while ((ent = getfsent ()) != NULL) {
+		/* Use noauto as our way of determining a removable volume */
+		if (strcmp (volume->device_path, ent->fs_spec) == 0
+		    && has_removable_mntent_options (ent)) {
+			endfsent();
+			return TRUE;
+		}
+	}
+
+	endfsent();
+#endif	/* __FreeBSD__ */
 	
+#ifndef __FreeBSD__
 	fclose (file);
+#endif
 	return FALSE;
 }
 
@@ -490,12 +545,17 @@
  		}
  	}
 #else
+#ifndef __FreeBSD__
 	file = setmntent (MOUNT_TABLE_PATH, "r");
 	if (file == NULL) {
 		return FALSE;
 	}
+#else
+	setfsent();
+#endif	/* __FreeBSD__ */
 		
 	/* Search for our device in the fstab */
+#ifndef __FreeBSD__
 	while ((ent = getmntent (file)) != NULL) {
 		if (strcmp (volume->device_path, ent->mnt_fsname) == 0) {
 			if (strstr (ent->mnt_opts, MNTOPT_RO) != NULL) {
@@ -504,9 +564,22 @@
 			}
         	 }
 	}
+#else	/* __FreeBSD__ */
+	while ((ent = getfsent ()) != NULL) {
+		if (strcmp (volume->device_path, ent->fs_spec) == 0
+		    && strstr (ent->fs_type, FSTAB_RO) != NULL) {
+			endfsent();
+			return TRUE;
+		}
+	}
+
+	endfsent();
+#endif	/* __FreeBSD__ */
 #endif
 				
+#ifndef __FreeBSD__
 	fclose (file);
+#endif
 	return FALSE;
 }
 
@@ -948,13 +1021,20 @@
 		}
 	}
 #else
+#ifndef __FreeBSD__
 	const char *file_name;
 	const char *separator;
 	char line[PATH_MAX * 3];
 	char device_name[sizeof (line)];
 	EelStringList *list;
 	char *device_path, *mount_path, *filesystem;
+#else	/* __FreeBSD__ */
+	struct statfs *mounted;
+	int mounted_num;
+	int i;
+#endif	/* __FreeBSD__ */
 
+#ifndef __FreeBSD__
 	if (mnttab_exists) { 
 		file_name = "/etc/mnttab";
 		separator = "\t";
@@ -967,7 +1047,15 @@
 		g_warning ("Unable to open %s: %s", file_name, strerror (errno));
 		return NULL;
 	}
+#else	/* __FreeBSD__ */
+	mounted_num = getmntinfo(&mounted, MNT_WAIT);
+	if (mounted_num < 1) {
+		g_warning ("Unable to get info about mounted fs: %s", strerror (errno));
+		return NULL;
+	}
+#endif	/* __FreeBSD__ */
 
+#ifndef __FreeBSD__
 	while (fgets (line, sizeof(line), fh)) {
 		if (sscanf (line, "%s", device_name) == 1) {
 			list = eel_string_list_new_from_tokens (line, separator, FALSE);
@@ -983,17 +1071,28 @@
 					g_free (device_path);
 					g_free (mount_path);
 					g_free (filesystem);
+#else /* __FreeBSD__ */
+	for (i = 0; i < mounted_num; i++) {
+		volume = g_new0 (NautilusVolume, 1);
+		volume->device_path = g_strdup(mounted[i].f_mntfromname);
+		volume->mount_path = g_strdup(mounted[i].f_mntonname);
+		volume->filesystem = g_strdup(mounted[i].f_fstypename);
+#endif /* __FreeBSD__ */
 					current_mounts = mount_volume_add_filesystem (volume, current_mounts);
+#ifndef __FreeBSD__
 				}				
 				eel_string_list_free (list);
 			}			
 		}
+#endif /* __FreeBSD__ */
   	}
 #endif /* SOLARIS_MNT */
 
+#ifndef __FreeBSD__
 	if (fh != NULL) {
 		fclose (fh);
 	}
+#endif
 	
 #ifdef HAVE_CDDA
 	/* CD Audio tricks */
@@ -1888,7 +1987,7 @@
 	for (element = volume_list; element != NULL; element = element->next) {
 		volume = element->data;
 		
-#ifndef SOLARIS_MNT
+#if !defined(SOLARIS_MNT) && !defined(__FreeBSD__)
 		/* These are set up by get_current_mount_list for Solaris. */
 		volume->is_removable = volume_is_removable (volume);
 		volume->is_read_only = volume_is_read_only (volume);
