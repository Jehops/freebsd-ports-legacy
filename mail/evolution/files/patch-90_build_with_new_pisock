diff -Nur evolution-2.8.0/addressbook/conduit/address-conduit.c evolution-2.8.0.new/addressbook/conduit/address-conduit.c
--- addressbook/conduit/address-conduit.c.orig	2005-12-06 09:43:37.000000000 +0100
+++ addressbook/conduit/address-conduit.c	2006-09-20 18:47:49.000000000 +0200
@@ -462,6 +462,7 @@
 {
 	static char buff[ 4096 ];
 	struct Address addr;
+	pi_buffer_t piBuf;
 
 	if (remote == NULL) {
 		sprintf (buff, "[NULL]");
@@ -469,7 +470,10 @@
 	}
 
 	memset (&addr, 0, sizeof (struct Address));
-	unpack_Address (&addr, remote->record, remote->length);
+	piBuf.data = remote->record;
+	piBuf.allocated = remote->length;
+	piBuf.used = remote->length;
+	unpack_Address(&addr, &piBuf, address_v1);
 
 	g_snprintf (buff, 4096, "['%s' '%s' '%s']",
 		    addr.entry[entryLastname] ?
@@ -786,12 +790,23 @@
 	}
 }
 
+/* convert a local EAddrLocalRecord to a GnomePilotRecord for the PDA
+ * 
+ * @param local local Evolution address record
+ * @param ctxt conduit context
+ * @param record record to use for GnomePilotRecord. Allow the calling
+ *               function to determine if the record should be allocated
+ *               dynamically or statically.
+ * @param maxRecordLen size of *record (max amount of data that can be put
+ *                      into record)
+ */
 static GnomePilotRecord
 local_record_to_pilot_record (EAddrLocalRecord *local,
-			      EAddrConduitContext *ctxt)
+			      EAddrConduitContext *ctxt,
+			      unsigned char *record,
+			      int maxRecordLen)
 {
 	GnomePilotRecord p;
-	static char record[0xffff];
 	
 	g_assert (local->addr != NULL );
 	
@@ -802,10 +817,25 @@
 	p.attr = local->local.attr;
 	p.archived = local->local.archived;
 	p.secret = local->local.secret;
+	
+	memset(record, 0, maxRecordLen);
 
 	/* Generate pilot record structure */
-	p.record = record;
-	p.length = pack_Address (local->addr, p.record, 0xffff);
+	{
+		pi_buffer_t piBuf;
+		memset (&piBuf, 0, sizeof (piBuf));
+
+		pack_Address(local->addr, &piBuf, address_v1);
+		if(piBuf.used > 0) {
+			memcpy(record, piBuf.data, MIN(piBuf.used, maxRecordLen) );
+		}
+		
+		p.length = piBuf.used;
+		p.record = record;
+		if(piBuf.data) {
+			free(piBuf.data);
+		}
+	}
 
 	return p;	
 }
@@ -834,16 +864,26 @@
 	 */
 	if (local->local.ID != 0) {
 		struct Address addr;
-		char record[0xffff];
+		pi_buffer_t *piBuf;
 		int cat = 0;
+		int dlpReadRetval = 0;
+
 		
-		if (dlp_ReadRecordById (ctxt->dbi->pilot_socket, 
-					ctxt->dbi->db_handle,
-					local->local.ID, &record, 
-					NULL, NULL, NULL, &cat) > 0) {
+		piBuf = pi_buffer_new(0xffff);
+		if(piBuf == NULL) {
+			WARN( _("local_record_from_ecard: no more memory to allocate") );
+			return;
+		}
+		dlpReadRetval = dlp_ReadRecordById(ctxt->dbi->pilot_socket,
+		                                  ctxt->dbi->db_handle,
+		                                  local->local.ID, piBuf,
+		                                  NULL, NULL, &cat);
+
+
+		if (dlpReadRetval > 0) {
 			local->local.category = cat;
 			memset (&addr, 0, sizeof (struct Address));
-			unpack_Address (&addr, record, 0xffff);
+			unpack_Address(&addr, piBuf, address_v1);
 			for (i = 0; i < 5; i++) {
 				if (addr.entry[entryPhone1 + i])
 					local->addr->entry[entryPhone1 + i] = 
@@ -858,6 +898,8 @@
 			}
 			free_Address (&addr);
 		}
+		
+		pi_buffer_free(piBuf);
 	}
 
 	local->addr->entry[entryFirstname] = e_pilot_utf8_to_pchar (e_contact_get_const (contact, E_CONTACT_GIVEN_NAME));
@@ -1022,7 +1064,13 @@
 
 	g_return_val_if_fail(remote!=NULL,NULL);
 	memset (&address, 0, sizeof (struct Address));
-	unpack_Address (&address, remote->record, remote->length);
+	{
+		pi_buffer_t piBuf;
+		piBuf.data = remote->record;
+		piBuf.allocated = remote->length;
+		piBuf.used = remote->length;
+		unpack_Address(&address, &piBuf, address_v1);
+	}
 
 	if (in_contact == NULL)
 		contact = e_contact_new ();
@@ -1212,7 +1260,7 @@
 	EBookQuery *query;
     	GList *l;
 	int len;
-	unsigned char *buf;
+	pi_buffer_t *piBuf;
 	char *filename;
 	char *change_id;
 	char *auth;
@@ -1302,9 +1350,14 @@
   	gnome_pilot_conduit_sync_abs_set_num_updated_local_records (abs_conduit, mod_records);
   	gnome_pilot_conduit_sync_abs_set_num_deleted_local_records(abs_conduit, del_records);
 
-	buf = (unsigned char*)g_malloc (0xffff);
-	len = dlp_ReadAppBlock (dbi->pilot_socket, dbi->db_handle, 0,
-			      (unsigned char *)buf, 0xffff);
+	piBuf = pi_buffer_new(0xffff);
+	if(piBuf == NULL) {
+		WARN (_("pre_sync(): Error allocating pi_buffer_t memory"));
+		gnome_pilot_conduit_error (conduit,
+			_("pre_sync(): Error allocating pi_buffer_t memory"));
+		return -1;
+	}
+	len = dlp_ReadAppBlock (dbi->pilot_socket, dbi->db_handle, 0, -1, piBuf);
 	
 	if (len < 0) {
 		WARN (_("Could not read pilot's Address application block"));
@@ -1313,8 +1366,8 @@
 					   _("Could not read pilot's Address application block"));
 		return -1;
 	}
-	unpack_AddressAppInfo (&(ctxt->ai), buf, len);
-	g_free (buf);
+	unpack_AddressAppInfo (&(ctxt->ai), piBuf->data, len);
+	pi_buffer_free(piBuf);
 
   	check_for_slow_setting (conduit, ctxt);
 	if (ctxt->cfg->sync_type == GnomePilotConduitSyncTypeCopyToPilot
@@ -1494,6 +1547,7 @@
 {
 	GnomePilotRecord local_pilot;
 	int retval = 0;
+	static unsigned char record[0xffff];
 
 	LOG (g_message ("compare: local=%s remote=%s...\n",
 			print_local (local), print_remote (remote)));
@@ -1501,7 +1555,7 @@
 	g_return_val_if_fail (local != NULL, -1);
 	g_return_val_if_fail (remote != NULL, -1);
 
-	local_pilot = local_record_to_pilot_record (local, ctxt);
+	local_pilot = local_record_to_pilot_record (local, ctxt, record, sizeof(record));
 
 	if (remote->length != local_pilot.length
 	    || memcmp (local_pilot.record, remote->record, remote->length))
@@ -1693,9 +1747,11 @@
 	 GnomePilotRecord *remote,
 	 EAddrConduitContext *ctxt)
 {
+	static unsigned char record[0xffff];
+	
 	LOG (g_message ( "prepare: encoding local %s\n", print_local (local) ));
 	
-	*remote = local_record_to_pilot_record (local, ctxt);
+	*remote = local_record_to_pilot_record (local, ctxt, record, sizeof(record));
 	
 	return 0;
 }
diff -Nur evolution-2.8.0/calendar/conduits/calendar/calendar-conduit.c evolution-2.8.0.new/calendar/conduits/calendar/calendar-conduit.c
--- calendar/conduits/calendar/calendar-conduit.c.orig	2005-12-23 05:39:34.000000000 +0100
+++ calendar/conduits/calendar/calendar-conduit.c	2006-09-20 18:48:56.000000000 +0200
@@ -413,6 +413,7 @@
 {
 	static char buff[ 4096 ];
 	struct Appointment appt;
+	pi_buffer_t piBuf;
 
 	if (remote == NULL) {
 		sprintf (buff, "[NULL]");
@@ -420,7 +421,10 @@
 	}
 
 	memset (&appt, 0, sizeof (struct Appointment));
-	unpack_Appointment (&appt, remote->record, remote->length);
+	piBuf.data = remote->record;
+	piBuf.allocated = remote->length;
+	piBuf.used = remote->length;
+	unpack_Appointment(&appt, &piBuf, datebook_v1);
 
 	g_snprintf (buff, 4096, "[%ld %ld '%s' '%s']",
 		    mktime (&appt.begin),
@@ -813,12 +817,23 @@
 	return TRUE;
 }
 
+/* convert a local ECalLocalRecord to a GnomePilotRecord for the PDA
+ * 
+ * @param local local Evolution Calendar record
+ * @param ctxt conduit context
+ * @param record record to use for GnomePilotRecord. Allow the calling
+ *               function to determine if the record should be allocated
+ *               dynamically or statically.
+ * @param maxRecordLen size of *record (max amount of data that can be put
+ *                      into record)
+ */
 static GnomePilotRecord
 local_record_to_pilot_record (ECalLocalRecord *local,
-			      ECalConduitContext *ctxt)
+			      ECalConduitContext *ctxt,
+			      unsigned char *record,
+			      int maxRecordLen)
 {
 	GnomePilotRecord p;
-	static char record[0xffff];
 
 	g_assert (local->comp != NULL);
 	g_assert (local->appt != NULL );
@@ -829,9 +844,25 @@
 	p.archived = local->local.archived;
 	p.secret = local->local.secret;
 
+	memset(record, 0, maxRecordLen);
+
 	/* Generate pilot record structure */
-	p.record = record;
-	p.length = pack_Appointment (local->appt, p.record, 0xffff);
+	{
+
+		pi_buffer_t piBuf;
+		memset (&piBuf, 0, sizeof (piBuf));
+
+		pack_Appointment(local->appt, &piBuf, datebook_v1);
+		if(piBuf.used > 0) {
+			memcpy(record, piBuf.data, MIN(piBuf.used, maxRecordLen) );
+		}
+		
+		p.length = piBuf.used;
+		p.record = record;
+		if(piBuf.data) {
+			free(piBuf.data);
+		}
+	}
 
 	return p;	
 }
@@ -867,22 +898,31 @@
          * we don't overwrite them 
 	 */
 	if (local->local.ID != 0) {
-		struct Appointment appt;		
-		char record[0xffff];
+		struct Appointment appt;
+		pi_buffer_t *piBuf;
 		int cat = 0;
+		int dlpReadRetval = 0;
 		
-		if (dlp_ReadRecordById (ctxt->dbi->pilot_socket, 
-					ctxt->dbi->db_handle,
-					local->local.ID, &record, 
-					NULL, NULL, NULL, &cat) > 0) {
+		piBuf = pi_buffer_new(0xffff);
+		if(piBuf == NULL) {
+			WARN( _("local_record_from_comp: no more memory to allocate") );
+			return;
+		}
+		dlpReadRetval = dlp_ReadRecordById (ctxt->dbi->pilot_socket,
+						    ctxt->dbi->db_handle,
+						    local->local.ID, piBuf,
+						    NULL, NULL, &cat);
+		
+		if (dlpReadRetval > 0) {
 			local->local.category = cat;
 			memset (&appt, 0, sizeof (struct Appointment));
-			unpack_Appointment (&appt, record, 0xffff);
+			unpack_Appointment (&appt, piBuf, datebook_v1);
 			local->appt->alarm = appt.alarm;
 			local->appt->advance = appt.advance;
 			local->appt->advanceUnits = appt.advanceUnits;
 			free_Appointment (&appt);
 		}
+		pi_buffer_free(piBuf);
 	}
 
 	/* STOP: don't replace these with g_strdup, since free_Appointment
@@ -1144,7 +1184,13 @@
 	g_return_val_if_fail (remote != NULL, NULL);
 
 	memset (&appt, 0, sizeof (struct Appointment));
-	unpack_Appointment (&appt, remote->record, remote->length);
+	{
+		pi_buffer_t piBuf;
+		piBuf.data = remote->record;
+		piBuf.allocated = remote->length;
+		piBuf.used = remote->length;
+		unpack_Appointment(&appt, &piBuf, datebook_v1);
+	}
 
 	if (in_comp == NULL) {
 		comp = e_cal_component_new ();
@@ -1409,7 +1455,7 @@
 	GnomePilotConduitSyncAbs *abs_conduit;
 	GList *removed = NULL, *added = NULL, *l;
 	int len;
-	unsigned char *buf;
+	pi_buffer_t *piBuf;
 	char *filename, *change_id;
 	icalcomponent *icalcomp;
 	gint num_records, add_records = 0, mod_records = 0, del_records = 0;
@@ -1521,9 +1567,14 @@
 	gnome_pilot_conduit_sync_abs_set_num_updated_local_records (abs_conduit, mod_records);
 	gnome_pilot_conduit_sync_abs_set_num_deleted_local_records(abs_conduit, del_records);
 
-	buf = (unsigned char*)g_malloc (0xffff);
-	len = dlp_ReadAppBlock (dbi->pilot_socket, dbi->db_handle, 0,
-			      (unsigned char *)buf, 0xffff);
+	piBuf = pi_buffer_new(0xffff);
+	if(piBuf == NULL) {
+		WARN (_("pre_sync(): Error allocating pi_buffer_t memory"));
+		gnome_pilot_conduit_error (conduit,
+			_("pre_sync(): Error allocating pi_buffer_t memory"));
+		return -1;
+	}
+	len = dlp_ReadAppBlock(dbi->pilot_socket, dbi->db_handle, 0, -1, piBuf);
 	
 	if (len < 0) {
 		WARN (_("Could not read pilot's Calendar application block"));
@@ -1532,8 +1583,8 @@
 					   _("Could not read pilot's Calendar application block"));
 		return -1;
 	}
-	unpack_AppointmentAppInfo (&(ctxt->ai), buf, len);
-	g_free (buf);
+	unpack_AppointmentAppInfo (&(ctxt->ai), piBuf->data, len);
+	pi_buffer_free(piBuf);
 
 	check_for_slow_setting (conduit, ctxt);
 	if (ctxt->cfg->sync_type == GnomePilotConduitSyncTypeCopyToPilot
@@ -1715,6 +1766,7 @@
 	/* used by the quick compare */
 	GnomePilotRecord local_pilot;
 	int retval = 0;
+	static unsigned char record[0xffff];
 
 	LOG (g_message ("compare: local=%s remote=%s...\n",
 			print_local (local), print_remote (remote)));
@@ -1722,7 +1774,7 @@
 	g_return_val_if_fail (local!=NULL,-1);
 	g_return_val_if_fail (remote!=NULL,-1);
 
-	local_pilot = local_record_to_pilot_record (local, ctxt);
+	local_pilot = local_record_to_pilot_record (local, ctxt, record, sizeof(record));
 
 	if (remote->length != local_pilot.length
 	    || memcmp (local_pilot.record, remote->record, remote->length))
@@ -1883,9 +1935,11 @@
 	 GnomePilotRecord *remote,
 	 ECalConduitContext *ctxt)
 {
+	static unsigned char record[0xffff];
+	
 	LOG (g_message ( "prepare: encoding local %s\n", print_local (local) ));
 
-	*remote = local_record_to_pilot_record (local, ctxt);
+	*remote = local_record_to_pilot_record (local, ctxt, record, sizeof(record));
 
 	return 0;
 }
diff -Nur evolution-2.8.0/calendar/conduits/memo/memo-conduit.c evolution-2.8.0.new/calendar/conduits/memo/memo-conduit.c
--- calendar/conduits/memo/memo-conduit.c.orig	2005-10-19 13:39:35.000000000 +0200
+++ calendar/conduits/memo/memo-conduit.c	2006-09-20 18:49:46.000000000 +0200
@@ -331,6 +331,7 @@
 {
 	static char buff[ 64 ];
 	struct Memo memo;
+	pi_buffer_t piBuf;
 
 	if (remote == NULL) {
 		sprintf (buff, "[NULL]");
@@ -338,7 +339,10 @@
 	}
 
 	memset (&memo, 0, sizeof (struct Memo));
-	unpack_Memo (&memo, remote->record, remote->length);
+	piBuf.data = remote->record;
+	piBuf.allocated = remote->length;
+	piBuf.used = remote->length;
+	unpack_Memo(&memo, &piBuf, memo_v1);
 
 	g_snprintf (buff, 64, "['%s']",
 		    memo.text ?
@@ -446,12 +450,24 @@
 	}
 }
 
+/**
+ * convert a local EMemoLocalRecord to a GnomePilotRecord for the PDA
+ * 
+ * @param local local Evolution memo record
+ * @param ctxt conduit context
+ * @param record record to use for GnomePilotRecord. Allow the calling
+ *               function to determine if the record should be allocated
+ *               dynamically or statically.
+ * @param maxRecordLen size of *record (max amount of data that can be put
+ *                      into record)
+ */
 static GnomePilotRecord
 local_record_to_pilot_record (EMemoLocalRecord *local,
-			      EMemoConduitContext *ctxt)
+			      EMemoConduitContext *ctxt,
+			      unsigned char *record,
+			      int maxRecordLen)
 {
 	GnomePilotRecord p;
-	static char record[0xffff];
 
 	g_assert (local->comp != NULL);
 	g_assert (local->memo != NULL );
@@ -464,9 +480,25 @@
 	p.archived = local->local.archived;
 	p.secret = local->local.secret;
 
+	memset(record, 0, maxRecordLen);
+
 	/* Generate pilot record structure */
-	p.record = record;
-	p.length = pack_Memo (local->memo, p.record, 0xffff);
+	{
+
+		pi_buffer_t piBuf;
+		memset (&piBuf, 0, sizeof (piBuf));
+
+		pack_Memo(local->memo, &piBuf, memo_v1);
+		if(piBuf.used > 0) {
+			memcpy(record, piBuf.data, MIN(piBuf.used, maxRecordLen) );
+		}
+		
+		p.length = piBuf.used;
+		p.record = record;
+		if(piBuf.data) {
+			free(piBuf.data);
+		}
+	}
 
 	return p;	
 }
@@ -483,53 +515,39 @@
 {
 	int i, j;
 	int retval = 0; /* 0 is the Unfiled category */
-	LOG(fprintf(stderr, "add_category_if_possible: called\n"));
+	LOG(g_message("add_category_if_possible\n"));
 	
 	for(i=0; i<16; i++){
 		/* if strlen is 0, then the category is empty
 		   the PalmOS doesn't let 0-length strings for
 		   categories */
-		LOG(fprintf(stderr, "add_category_if_possible: calling strlen, i==%d\n", i));
 		if(strlen(category->name[i]) == 0){
 			int cat_to_add_len;
-			LOG(fprintf(stderr, "add_category_if_possible: strlen == 0\n"));
 			
 			cat_to_add_len = strlen(cat_to_add);
-			LOG(fprintf(stderr, "add_category_if_possible: cat_to_add_len: %d\n",
-					cat_to_add_len));
 			retval = i;
 			
 			/* only 15 characters for category, 16th is
 			 * '\0' can't do direct mem transfer due to
 			 * declaration type
 			 */
-			LOG(fprintf(stderr, "add_category_if_possible: copying first 15 of category\n"));
 			for(j=0; j<cat_to_add_len; j++){
 				category->name[i][j] = cat_to_add[j];
 			}
-			LOG(fprintf(stderr,
-				"add_category_if_possible: setting from %d to i==15 to \\0\n",
-				cat_to_add_len));
 
 			for(j=cat_to_add_len; j<16; j++)
 				category->name[i][j] = '\0';
 			
-			LOG(fprintf(stderr, "add_category_if_possible: setting ID[%d] to %d\n",
-				category->ID[i], lastDesktopUniqueID));
 			category->ID[i] = lastDesktopUniqueID;
 			lastDesktopUniqueID++;
-			
-			LOG(fprintf(stderr, "add_category_if_possible: setting renamed[%d] to TRUE\n", i));
 			category->renamed[i] = TRUE;
 			
-			LOG(g_message("*** adding category '%s', ID %d ***",
-				category->name[i], category->ID[i]));
 			break;
 		}
 	}
 	
 	if(retval == 0){
-		LOG(g_message("*** not adding category - category list already full ***"));
+		LOG(g_warning( _("*** not adding category - category list already full ***") ));
 	}
 	
 	return retval;
@@ -554,31 +572,35 @@
 	local->comp = comp;
 	g_object_ref (comp);
 
-	LOG(fprintf(stderr, "local_record_from_comp: calling e_cal_component_get_uid\n"));
 	e_cal_component_get_uid (local->comp, &uid);
-	LOG(fprintf(stderr, "local_record_from_comp: got UID - %s, calling e_pilot_map_lookup_pid\n", uid));
 	local->local.ID = e_pilot_map_lookup_pid (ctxt->map, uid, TRUE);
-	LOG(fprintf(stderr, "local_record_from_comp: local->local.ID == %lu\n", local->local.ID));
 
 	compute_status (ctxt, local, uid);
-	
-	LOG(fprintf(stderr, "local_record_from_comp: local->local.attr: %d\n", local->local.attr));
 
 	local->memo = g_new0 (struct Memo,1);
 
 	/* Don't overwrite the category */
 	if (local->local.ID != 0) {
-		char record[0xffff];
 		int cat = 0;
+		int dlpReadRetval = 0;
+		pi_buffer_t *piBuf;
+		piBuf = pi_buffer_new(0xffff);
+		if(piBuf == NULL) {
+			WARN( _("local_record_from_comp: no more memory to allocate") );
+			return;
+		}
 		
-		LOG(fprintf(stderr, "local_record_from_comp: calling dlp_ReadRecordById\n"));
-		if (dlp_ReadRecordById (ctxt->dbi->pilot_socket, 
-					ctxt->dbi->db_handle,
-					local->local.ID, &record, 
-					NULL, NULL, NULL, &cat) > 0) {
+		dlpReadRetval = dlp_ReadRecordById(ctxt->dbi->pilot_socket,
+						   ctxt->dbi->db_handle,
+						   local->local.ID, piBuf,
+						   NULL, NULL, &cat);
+
+		
+		if (dlpReadRetval > 0) {
 			local->local.category = cat;
 		}
-		LOG(fprintf(stderr, "local_record_from_comp: done calling dlp_ReadRecordById\n"));
+		
+		pi_buffer_free(piBuf);
 	}
 	
 	/*
@@ -589,34 +611,23 @@
 		int cat = -1;
 		int i;
 		
-		LOG(fprintf(stderr, "local_record_from_comp: trying to set category"));
-		LOG(fprintf(stderr, "local_record_from_comp: calling e_cal_component_get_categories_list\n"));
-		
 		e_cal_component_get_categories_list(comp, &categ_list_head);
-		LOG(fprintf(stderr, "local_record_from_comp: got list, setting categ_list_cur to head\n"));
 		
 		categ_list_cur = categ_list_head;
 		while (categ_list_cur && cat == -1)
 		{	
-			LOG(fprintf(stderr, "local_record_from_comp: iterating, data == %s",
-				(char *)categ_list_cur->data));
 			for(i=0; i<16; i++){
-				LOG(fprintf(stderr, "local_record_from_comp: i == %d\n", i));
 				if(strcmp((char *)categ_list_cur->data,
 					  ctxt->ai.category.name[i]) == 0){
 					cat = i;
-					LOG(fprintf(stderr, "local_record_from_comp: found category, name: %s\n",
-							ctxt->ai.category.name[i]));
 					break;
 				}
 			}
 			
-			LOG(fprintf(stderr, "local_record_from_comp: calling g_slist_next\n"));
 			categ_list_cur = g_slist_next(categ_list_cur);
 		}
 		
 		if(cat != -1){
-			LOG(fprintf(stderr, "local_record_from_comp: setting category\n"));
 			local->local.category = cat;
 		}
 		else if(categ_list_head != NULL){
@@ -708,7 +719,13 @@
 	g_return_val_if_fail (remote != NULL, NULL);
 
 	memset (&memo, 0, sizeof (struct Memo));
-	unpack_Memo (&memo, remote->record, remote->length);
+	{
+		pi_buffer_t piBuf;
+		piBuf.data = remote->record;
+		piBuf.allocated = remote->length;
+		piBuf.used = remote->length;
+		unpack_Memo(&memo, &piBuf, memo_v1);
+	}
 
 	utc_zone = icaltimezone_get_utc_timezone ();
 	now = icaltime_from_timet_with_zone (time (NULL), FALSE, 
@@ -836,7 +853,7 @@
 	GnomePilotConduitSyncAbs *abs_conduit;
 	GList *l;
 	int len;
-	unsigned char *buf;
+	pi_buffer_t *piBuf;
 	char *filename, *change_id;
 	icalcomponent *icalcomp;
 	gint num_records, add_records = 0, mod_records = 0, del_records = 0;
@@ -929,9 +946,14 @@
 	g_message("num_records: %d\nadd_records: %d\nmod_records: %d\ndel_records: %d\n",
 		num_records, add_records, mod_records, del_records);
 
-	buf = (unsigned char*)g_malloc (0xffff);
-	len = dlp_ReadAppBlock (dbi->pilot_socket, dbi->db_handle, 0,
-			      (unsigned char *)buf, 0xffff);
+	piBuf = pi_buffer_new(0xffff);
+	if(piBuf == NULL) {
+		WARN (_("pre_sync(): Error allocating pi_buffer_t memory"));
+		gnome_pilot_conduit_error (conduit,
+			_("pre_sync(): Error allocating pi_buffer_t memory"));
+		return -1;
+	}
+	len = dlp_ReadAppBlock (dbi->pilot_socket, dbi->db_handle, 0, -1, piBuf);
 	
 	if (len < 0) {
 		WARN (_("Could not read pilot's Memo application block"));
@@ -940,8 +962,9 @@
 					   _("Could not read pilot's Memo application block"));
 		return -1;
 	}
-	unpack_MemoAppInfo (&(ctxt->ai), buf, len);
-	g_free (buf);
+	
+	unpack_MemoAppInfo (&(ctxt->ai), piBuf->data, len);
+	pi_buffer_free(piBuf);
 	
 	lastDesktopUniqueID = 128;
 
@@ -963,6 +986,9 @@
 	unsigned char *buf;
 	int dlpRetVal, len;
 
+	/* Write AppBlock to PDA - updates categories */
+	/* NOTE: not changed for pilot-link 0.12 because the two
+	 * functions below didn't change */
 	buf = (unsigned char*)g_malloc (0xffff);
 	
 	len = pack_MemoAppInfo (&(ctxt->ai), buf, 0xffff);
@@ -1156,6 +1182,7 @@
 	/* used by the quick compare */
 	GnomePilotRecord local_pilot;
 	int retval = 0;
+	static unsigned char record[0xffff];
 
 	LOG (g_message ("compare: local=%s remote=%s...\n",
 			print_local (local), print_remote (remote)));
@@ -1163,7 +1190,7 @@
 	g_return_val_if_fail (local!=NULL,-1);
 	g_return_val_if_fail (remote!=NULL,-1);
 
-	local_pilot = local_record_to_pilot_record (local, ctxt);
+	local_pilot = local_record_to_pilot_record (local, ctxt, record, sizeof(record));
 
 	if (remote->length != local_pilot.length
 	    || memcmp (local_pilot.record, remote->record, remote->length))
@@ -1319,9 +1346,10 @@
 	 GnomePilotRecord *remote,
 	 EMemoConduitContext *ctxt)
 {
+	static unsigned char record[0xffff];
 	LOG (g_message ( "prepare: encoding local %s\n", print_local (local) ));
 
-	*remote = local_record_to_pilot_record (local, ctxt);
+	*remote = local_record_to_pilot_record (local, ctxt, record, sizeof(record));
 
 	return 0;
 }
diff -Nur evolution-2.8.0/calendar/conduits/todo/todo-conduit.c evolution-2.8.0.new/calendar/conduits/todo/todo-conduit.c
--- calendar/conduits/todo/todo-conduit.c.orig	2006-05-13 09:56:49.000000000 +0200
+++ calendar/conduits/todo/todo-conduit.c	2006-09-20 18:50:31.000000000 +0200
@@ -409,7 +409,13 @@
 	}
 
 	memset (&todo, 0, sizeof (struct ToDo));
-	unpack_ToDo (&todo, remote->record, remote->length);
+	{
+		pi_buffer_t piBuf;
+		piBuf.data = remote->record;
+		piBuf.allocated = remote->length;
+		piBuf.used = remote->length;
+		unpack_ToDo(&todo, &piBuf, todo_v1);
+	}
 
 	g_snprintf (buff, 4096, "[%d %ld %d %d '%s' '%s' %d]",
 		    todo.indefinite,
@@ -589,12 +595,24 @@
 	}
 }
 
+/**
+ * convert a local EMemoLocalRecord to a GnomePilotRecord for the PDA
+ * 
+ * @param local local Evolution memo record
+ * @param ctxt conduit context
+ * @param record record to use for GnomePilotRecord. Allow the calling
+ *               function to determine if the record should be allocated
+ *               dynamically or statically.
+ * @param maxRecordLen size of *record (max amount of data that can be put
+ *                      into record)
+ */
 static GnomePilotRecord
 local_record_to_pilot_record (EToDoLocalRecord *local,
-			      EToDoConduitContext *ctxt)
+			      EToDoConduitContext *ctxt,
+			      unsigned char *record,
+			      int maxRecordLen)
 {
 	GnomePilotRecord p;
-	static char record[0xffff];
 
 	g_assert (local->comp != NULL);
 	g_assert (local->todo != NULL );
@@ -607,9 +625,24 @@
 	p.archived = local->local.archived;
 	p.secret = local->local.secret;
 
+	memset(record, 0, maxRecordLen);
+
 	/* Generate pilot record structure */
-	p.record = record;
-	p.length = pack_ToDo (local->todo, p.record, 0xffff);
+	{
+		pi_buffer_t piBuf;
+		memset (&piBuf, 0, sizeof (piBuf));
+
+		pack_ToDo(local->todo, &piBuf, todo_v1);
+		if(piBuf.used > 0) {
+			memcpy(record, piBuf.data, MIN(piBuf.used, maxRecordLen) );
+		}
+		
+		p.length = piBuf.used;
+		p.record = record;
+		if(piBuf.data) {
+			free(piBuf.data);
+		}
+	}
 
 	return p;	
 }
@@ -696,15 +729,23 @@
 
 	/* Don't overwrite the category */
 	if (local->local.ID != 0) {
-		char record[0xffff];
 		int cat = 0;
-		
-		if (dlp_ReadRecordById (ctxt->dbi->pilot_socket, 
-					ctxt->dbi->db_handle,
-					local->local.ID, &record, 
-					NULL, NULL, NULL, &cat) > 0) {
+		int dlpReadRetval = 0;
+		pi_buffer_t *piBuf = pi_buffer_new(0xffff);
+		if(piBuf == NULL) {
+			WARN( _("local_record_from_comp: no more memory to allocate") );
+			return;
+		}
+		dlpReadRetval = dlp_ReadRecordById(ctxt->dbi->pilot_socket,
+						   ctxt->dbi->db_handle,
+						   local->local.ID, piBuf,
+						   NULL, NULL, &cat);
+
+		if (dlpReadRetval > 0) {
 			local->local.category = cat;
 		}
+		
+		pi_buffer_free(piBuf);
 	}
 	
 	/*
@@ -864,7 +905,13 @@
 	g_return_val_if_fail (remote != NULL, NULL);
 
 	memset (&todo, 0, sizeof (struct ToDo));
-	unpack_ToDo (&todo, remote->record, remote->length);
+	{
+		pi_buffer_t piBuf;
+		piBuf.data = remote->record;
+		piBuf.allocated = remote->length;
+		piBuf.used = remote->length;
+		unpack_ToDo(&todo, &piBuf, todo_v1);
+	}
 
 	utc_zone = icaltimezone_get_utc_timezone ();
 	now = icaltime_from_timet_with_zone (time (NULL), FALSE, 
@@ -1014,7 +1061,7 @@
 	GnomePilotConduitSyncAbs *abs_conduit;
 	GList *l;
 	int len;
-	unsigned char *buf;
+	pi_buffer_t *piBuf;
 	char *filename, *change_id;
 	icalcomponent *icalcomp;
 	gint num_records, add_records = 0, mod_records = 0, del_records = 0;
@@ -1104,9 +1151,14 @@
 	g_message("num_records: %d\nadd_records: %d\nmod_records: %d\ndel_records: %d\n",
 			num_records, add_records, mod_records, del_records);
 
-	buf = (unsigned char*)g_malloc (0xffff);
-	len = dlp_ReadAppBlock (dbi->pilot_socket, dbi->db_handle, 0,
-			      (unsigned char *)buf, 0xffff);
+	piBuf = pi_buffer_new(0xffff);
+	if(piBuf == NULL) {
+		WARN (_("pre_sync(): Error allocating pi_buffer_t memory"));
+		gnome_pilot_conduit_error (conduit,
+			_("pre_sync(): Error allocating pi_buffer_t memory"));
+		return -1;
+	}
+	len = dlp_ReadAppBlock (dbi->pilot_socket, dbi->db_handle, 0, -1, piBuf);
 	
 	if (len < 0) {
 		WARN (_("Could not read pilot's ToDo application block"));
@@ -1115,8 +1167,9 @@
 					   _("Could not read pilot's ToDo application block"));
 		return -1;
 	}
-	unpack_ToDoAppInfo (&(ctxt->ai), buf, len);
-	g_free (buf);
+
+	unpack_ToDoAppInfo (&(ctxt->ai), piBuf->data, len);
+	pi_buffer_free(piBuf);
 	
 	lastDesktopUniqueID = 128;
 
@@ -1138,6 +1191,9 @@
 	unsigned char *buf;
 	int dlpRetVal, len;
 
+	/* Write AppBlock to PDA - updates categories */
+	/* NOTE: not changed for pilot-link 0.12 because the two
+	 * functions below didn't change */
 	buf = (unsigned char*)g_malloc (0xffff);
 	
 	len = pack_ToDoAppInfo (&(ctxt->ai), buf, 0xffff);
@@ -1320,6 +1376,7 @@
 	/* used by the quick compare */
 	GnomePilotRecord local_pilot;
 	int retval = 0;
+	static unsigned char record[0xffff];
 
 	LOG (g_message ("compare: local=%s remote=%s...\n",
 			print_local (local), print_remote (remote)));
@@ -1327,7 +1384,7 @@
 	g_return_val_if_fail (local!=NULL,-1);
 	g_return_val_if_fail (remote!=NULL,-1);
 
-	local_pilot = local_record_to_pilot_record (local, ctxt);
+	local_pilot = local_record_to_pilot_record (local, ctxt, record, sizeof(record));
 
 	if (remote->length != local_pilot.length
 	    || memcmp (local_pilot.record, remote->record, remote->length))
@@ -1484,9 +1541,11 @@
 	 GnomePilotRecord *remote,
 	 EToDoConduitContext *ctxt)
 {
+	static unsigned char record[0xffff];
+
 	LOG (g_message ( "prepare: encoding local %s\n", print_local (local) ));
 
-	*remote = local_record_to_pilot_record (local, ctxt);
+	*remote = local_record_to_pilot_record (local, ctxt, record, sizeof(record));
 
 	return 0;
 }
