*** slocal.c.orig	Tue Nov 30 20:01:38 1993
--- uip/slocal.c	Tue Apr 23 10:57:56 1996
***************
*** 44,49 ****
--- 44,59 ----
  
  #ifdef	MSGID
  
+ #ifdef	BSD44
+ #define	MSGID_PAGFILE ".maildelivery.db"
+ #define	MSGID_PAGFNO	dbm_dirfno
+ #else
+ #define	MSGID_PAGFILE ".maildelivery.pag"
+ #define	MSGID_PAGFNO	dbm_pagfno
+ #endif
+ 
+ static int check_msgid (int, char *);
+ 
  #undef	DBM		/* used by ndbm.h */
  #include <ndbm.h>
  #include <stdio.h>
***************
*** 173,178 ****
--- 183,190 ----
      NULL
  };
  
+ static char *rcvstore;
+ 
  /*  */
  
  extern char **environ;
***************
*** 299,304 ****
--- 311,318 ----
  
  /*  */
  
+     rcvstore = getcpy(libpath("rcvstore"));
+ 
      if (addr == NULL)
  	addr = getusr ();
      if (user == NULL)
***************
*** 378,387 ****
  {
  #ifdef	MSGID
      struct stat st;
  
!     if (stat (".maildelivery.pag", &st) != NOTOK
! 	    && check_msgid (fd, ".maildelivery") == DONE)
! 	return OK;
  #endif
  
      if (usr_delivery (fd, mdlvr ? mdlvr : ".maildelivery", 0, from) != NOTOK)
--- 392,412 ----
  {
  #ifdef	MSGID
      struct stat st;
+     static int first = 1;
  
!     if (stat (MSGID_PAGFILE, &st) != NOTOK) {
! 	/*
! 	 * Allow a user to trigger the database by creating an
! 	 * empty database file.  That gets us here, now we need
! 	 * to remove it so DBM will create and initialize it properly.
! 	 */
! 	if (st.st_size == 0 && first) {
! 	    first = 0;
! 	    (void) unlink(MSGID_PAGFILE);
! 	}
! 	if (check_msgid (fd, ".maildelivery") == DONE)
! 	    return OK;
!     }
  #endif
  
      if (usr_delivery (fd, mdlvr ? mdlvr : ".maildelivery", 0, from) != NOTOK)
***************
*** 543,549 ****
--- 568,590 ----
  		status = usr_pipe (fd, tmpbuf, "/bin/sh", vec + 2);
  		break;
  
+ 	    case '+':
+ 	    dofolder:
+ 		if (*string == '+')
+ 		    strcpy(tmpbuf, string);
+ 		else
+ 		    sprintf(tmpbuf, "+%s", string);
+ 		vec[2] = "rcvstore";
+ 		vec[3] = tmpbuf;
+ 		vec[4] = NULL;
+ 		if (verbose)
+ 		    printf("rcvstore %s", vec[3]);
+ 		status = usr_pipe(fd, "rcvstore", rcvstore, vec + 2);
+ 		break;
+ 
  	    case 'f': 
+ 		if (uleq(action, "folder"))
+ 		    goto dofolder;
  		if (!uleq (action, "file"))
  		    continue;	/* else fall */
  	    case '>': 
***************
*** 1312,1330 ****
  		    fl.l_whence = 0;
  		    fl.l_start = 0;
  		    fl.l_len = 0;
! 		    if (fcntl (dbm_pagfno (db), F_SETLK, &fl) == -1) {
  			advise (file, "unable to perform flock on");
  			goto out;
  		    }
  		}
  #else
  #ifdef LOCKF
! 		if (lockf (dbm_pagfno (db), F_LOCK) == NOTOK) {
  		    advise (file, "unable to perform lockf on");
  		    goto out;
  		}
  #else
! 		if (flock (dbm_pagfno (db), LOCK_EX) == NOTOK) {
  		    advise (file, "unable to perform flock on");
  		    goto out;
  		}
--- 1353,1371 ----
  		    fl.l_whence = 0;
  		    fl.l_start = 0;
  		    fl.l_len = 0;
! 		    if (fcntl (MSGID_PAGFNO (db), F_SETLK, &fl) == -1) {
  			advise (file, "unable to perform flock on");
  			goto out;
  		    }
  		}
  #else
  #ifdef LOCKF
! 		if (lockf (MSGID_PAGFNO (db), F_LOCK) == NOTOK) {
  		    advise (file, "unable to perform lockf on");
  		    goto out;
  		}
  #else
! 		if (flock (MSGID_PAGFNO (db), LOCK_EX) == NOTOK) {
  		    advise (file, "unable to perform flock on");
  		    goto out;
  		}
*** popauth.c.orig	Tue Nov 30 20:01:34 1993
--- support/pop/popauth.c	Thu Feb 22 13:00:20 1996
***************
*** 18,23 ****
--- 18,28 ----
  #include "../zotnet/bboards.h"
  #include "../zotnet/mts.h"
  
+ #ifdef	dbm_pagfno
+ #undef	dbm_pagfno
+ #define	dbm_pagfno	dbm_dirfno
+ #endif
+ 
  /*  */
  
  static struct swit switches[] = {
***************
*** 130,137 ****
  	if ((db = dbm_open (APOP, O_RDWR | O_CREAT, 0600)) == NULL)
  	    adios (APOP, "unable to create POP authorization DB");
  	if (fchown (dbm_dirfno (db), pw -> pw_uid, pw -> pw_gid) == NOTOK
! 	        || fchown (dbm_pagfno (db), pw -> pw_uid, pw -> pw_gid)
! 	    		== NOTOK)
  	    advise (" ", "error setting ownership of POP authorization DB");
  
  	done (0);
--- 135,144 ----
  	if ((db = dbm_open (APOP, O_RDWR | O_CREAT, 0600)) == NULL)
  	    adios (APOP, "unable to create POP authorization DB");
  	if (fchown (dbm_dirfno (db), pw -> pw_uid, pw -> pw_gid) == NOTOK
! #ifndef	BSD44
! 	    || fchown (dbm_pagfno (db), pw -> pw_uid, pw -> pw_gid) == NOTOK
! #endif
! 	    )
  	    advise (" ", "error setting ownership of POP authorization DB");
  
  	done (0);
*** popser.c.orig	Tue Nov 30 20:01:34 1993
--- support/pop/popser.c	Thu Feb 22 12:58:31 1996
***************
*** 666,671 ****
--- 665,674 ----
  #include <fcntl.h>
  #endif
  
+ #ifdef	dbm_pagfno
+ #undef	dbm_pagfno
+ #define	dbm_pagfno	dbm_dirfno
+ #endif
  
  static int apop (vec)
  register char  **vec;
--- conf/config/mts.c	Mon Sep 22 10:44:37 1997
+++ conf/config/mts.c	Mon Sep 22 10:40:14 1997
@@ -13,6 +13,7 @@
 #include "../h/strings.h"
 #include <ctype.h>
 #include <stdio.h>
+#include <paths.h>
 #include "mts.h"
 #ifdef	NETWORK
 #if	defined(BSD42) || defined(SOCKETS)
@@ -119,7 +120,7 @@
 
 #ifdef	SENDMTS
 char   *hostable = "@(MHETCPATH)/hosts";
-char   *sendmail = "/usr/lib/sendmail";
+char   *sendmail = _PATH_SENDMAIL;
 #endif /* SENDMTS */
 
 
--- conf/doc/slocal.rf	Tue Nov 30 20:00:20 1993
+++ conf/doc/slocal.rf	Mon Sep 22 10:41:16 1997
@@ -294,9 +294,9 @@
 .Uh "Duplicate Message Suppression"
 \fIslocal\fR is able to detect and supress duplicate messages.
 To enable this,
-create two empty files in your $HOME directory:
-\&.maildelivery.pag and \&.maildelivery.dir.
-These are ndbm files which are used to store the Message-IDs of
+create an empty file in your $HOME directory:
+\&.maildelivery.db.
+These is a db files which are used to store the Message-IDs of
 incoming messages.
 @END: MSGID
 .Fi
