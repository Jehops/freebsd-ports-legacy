--- orig/buffy.c.orig	2010-09-18 14:12:40.000000000 +0200
+++ new/buffy.c	2010-09-18 14:17:36.000000000 +0200
@@ -161,6 +161,49 @@
   }
 }
 
+static int buffy_compare_name(const void *a, const void *b) {
+  const BUFFY *b1 = * (BUFFY * const *) a;
+  const BUFFY *b2 = * (BUFFY * const *) b;
+
+  return mutt_strcoll(b1->path, b2->path);
+}
+
+static BUFFY *buffy_sort(BUFFY *b)
+{
+  BUFFY *tmp = b;
+  int buffycount = 0;
+  BUFFY **ary;
+  int i;
+
+  if (!option(OPTSIDEBARSORT))
+    return b;
+
+  for (; tmp != NULL; tmp = tmp->next)
+    buffycount++;
+
+  ary = (BUFFY **) safe_calloc(buffycount, sizeof (*ary));
+
+  tmp = b;
+  for (i = 0; tmp != NULL; tmp = tmp->next, i++) {
+    ary[i] = tmp;
+  }
+
+  qsort(ary, buffycount, sizeof(*ary), buffy_compare_name);
+
+  for (i = 0; i < buffycount - 1; i++) {
+    ary[i]->next = ary[i+1];
+  }
+  ary[buffycount - 1]->next = NULL;
+  for (i = 1; i < buffycount; i++) {
+    ary[i]->prev = ary[i-1];
+  }
+  ary[0]->prev = NULL;
+
+  tmp = ary[0];
+  free(ary);
+  return tmp;
+}
+
 BUFFY *mutt_find_mailbox (const char *path)
 {
   BUFFY *tmp = NULL;
@@ -282,6 +325,7 @@
     else
       (*tmp)->size = 0;
   }
+  Incoming = buffy_sort(Incoming);
   return 0;
 }
 
@@ -371,12 +415,17 @@
   return rc;
 }
 
+#define STAT_CHECK_SIZE (sb.st_size > tmp->size)
+#define STAT_CHECK_TIME (sb.st_mtime > sb.st_atime || (tmp->newly_created && sb.st_ctime == sb.st_mtime && sb.st_ctime == sb.st_atime))
+#define STAT_CHECK (option(OPTCHECKMBOXSIZE) ? STAT_CHECK_SIZE : STAT_CHECK_TIME)
+
 int mutt_buffy_check (int force)
 {
   BUFFY *tmp;
   struct stat sb;
   struct stat contex_sb;
   time_t t;
+  CONTEXT *ctx;
 
   sb.st_size=0;
   contex_sb.st_dev=0;
@@ -416,6 +465,8 @@
   
   for (tmp = Incoming; tmp; tmp = tmp->next)
   {
+    if ( tmp->new == 1 )
+       tmp->has_new = 1;
     if (tmp->magic != M_IMAP)
     {
       tmp->new = 0;
@@ -455,18 +506,122 @@
       {
       case M_MBOX:
       case M_MMDF:
-	if (buffy_mbox_hasnew (tmp, &sb) > 0)
-	  BuffyCount++;
-	break;
+        {
+          if (STAT_CHECK || tmp->msgcount == 0)
+          {
+            BUFFY b = *tmp;
+            int msgcount = 0;
+            int msg_unread = 0;
+            /* parse the mailbox, to see how much mail there is */
+            ctx = mx_open_mailbox( tmp->path, M_READONLY | M_QUIET | M_NOSORT | M_PEEK, NULL);
+            if(ctx)
+            {
+              msgcount = ctx->msgcount;
+              msg_unread = ctx->unread;
+              mx_close_mailbox(ctx, 0);
+            }
+            *tmp = b;
+            tmp->msgcount = msgcount;
+            tmp->msg_unread = msg_unread;
+            if(STAT_CHECK) {
+              tmp->has_new = tmp->new = 1;
+              BuffyCount++;
+            }
+          }
+          else if (option(OPTCHECKMBOXSIZE))
+          {
+            /* some other program has deleted mail from the folder */
+            tmp->size = (off_t) sb.st_size;
+          }
+          if (tmp->newly_created &&
+              (sb.st_ctime != sb.st_mtime || sb.st_ctime != sb.st_atime))
+            tmp->newly_created = 0;
+        }
+        break;
+
 
       case M_MAILDIR:
-	if (buffy_maildir_hasnew (tmp) > 0)
-	  BuffyCount++;
+        { 
+        char path[_POSIX_PATH_MAX];
+        DIR *dirp;
+        struct dirent *de;
+        /* count new message */
+        snprintf (path, sizeof (path), "%s/new", tmp->path);
+        if ((dirp = opendir (path)) == NULL)
+        {
+          tmp->magic = 0;
+          break;
+        }
+        tmp->msgcount = 0;
+        tmp->msg_unread = 0;
+        tmp->msg_flagged = 0;
+        while ((de = readdir (dirp)) != NULL)
+        {
+          char *p;
+          if (*de->d_name != '.' &&
+              (!(p = strstr (de->d_name, ":2,")) || !strchr (p + 3, 'T')))
+          {
+            tmp->has_new = tmp->new = 1;
+            tmp->msgcount++;
+            tmp->msg_unread++;
+          }
+        }
+        if(tmp->msg_unread)
+          BuffyCount++;
+
+        closedir (dirp);
+
+        /*
+         * count read messages (for folderlist (sidebar) we also need to count
+         * messages in cur so that we the total number of messages
+         */
+        snprintf (path, sizeof (path), "%s/cur", tmp->path);
+        if ((dirp = opendir (path)) == NULL)
+        {
+          tmp->magic = 0;
+          break;
+        }
+        while ((de = readdir (dirp)) != NULL)
+        {
+          char *p;
+          if (*de->d_name != '.') {
+                  if ((p = strstr (de->d_name, ":2,"))) {
+                          if (!strchr (p + 3, 'T')) {
+                                  tmp->msgcount++;
+                                  if ( !strchr (p + 3, 'S'))
+                                          tmp->msg_unread++;
+                                  if (strchr(p + 3, 'F'))
+                                          tmp->msg_flagged++;
+                          }
+                  } else
+                          tmp->msgcount++;
+          }
+        }
+        closedir (dirp);
+        } 
 	break;
 
       case M_MH:
-	if ((tmp->new = mh_buffy (tmp->path)) > 0)
-	  BuffyCount++;
+        {
+        DIR *dp;
+        char path[_POSIX_PATH_MAX];
+        struct dirent *de;
+        if ((tmp->new = mh_buffy (tmp->path)) > 0)
+          BuffyCount++;
+
+        if ((dp = opendir (path)) == NULL)
+          break;
+        tmp->msgcount = 0;
+        while ((de = readdir (dp)))
+        {
+          if (mh_valid_message (de->d_name))
+          {
+            tmp->msgcount++;
+            tmp->has_new = tmp->new = 1;
+          }
+        }
+        closedir (dp);
+        }
 	break;
       }
     }
*** mutt-1.5.20-orig/buffy.h	2009-04-30 00:36:16.000000000 -0500
--- mutt-1.5.20-patched/buffy.h	2009-06-19 22:07:04.000000000 -0500
***************
*** 25,31 ****
--- 25,36 ----
    char path[_POSIX_PATH_MAX];
    off_t size;
    struct buffy_t *next;
+   struct buffy_t *prev;
    short new;			/* mailbox has new mail */
+   short has_new;		/* set it new if new and not read */
+   int msgcount;			/* total number of messages */
+   int msg_unread;		/* number of unread messages */
+   int msg_flagged;		/* number of flagged messages */
    short notified;		/* user has been notified */
    short magic;			/* mailbox type */
    short newly_created;		/* mbox or mmdf just popped into existence */
*** mutt-1.5.20-orig/color.c	2009-05-18 19:11:35.000000000 -0500
--- mutt-1.5.20-patched/color.c	2009-06-19 22:07:04.000000000 -0500
***************
*** 93,98 ****
--- 93,100 ----
    { "bold",		MT_COLOR_BOLD },
    { "underline",	MT_COLOR_UNDERLINE },
    { "index",		MT_COLOR_INDEX },
+   { "sidebar_new",	MT_COLOR_NEW },
+   { "sidebar_flagged",	MT_COLOR_FLAGGED },
    { NULL,		0 }
  };
  
*** mutt-1.5.20-orig/curs_main.c	2009-06-13 21:48:36.000000000 -0500
--- mutt-1.5.20-patched/curs_main.c	2009-06-19 22:07:04.000000000 -0500
***************
*** 26,32 ****
--- 26,34 ----
  #include "mailbox.h"
  #include "mapping.h"
  #include "sort.h"
+ #include "buffy.h"
  #include "mx.h"
+ #include "sidebar.h"
  
  #ifdef USE_POP
  #include "pop.h"
***************
*** 523,530 ****
         menu->redraw |= REDRAW_STATUS;
       if (do_buffy_notify)
       {
!        if (mutt_buffy_notify () && option (OPTBEEPNEW))
!  	beep ();
       }
       else
         do_buffy_notify = 1;
--- 525,536 ----
         menu->redraw |= REDRAW_STATUS;
       if (do_buffy_notify)
       {
!        if (mutt_buffy_notify ())
!        {
!          menu->redraw |= REDRAW_FULL;
!          if (option (OPTBEEPNEW))
!            beep ();
!        }
       }
       else
         do_buffy_notify = 1;
***************
*** 536,541 ****
--- 542,548 ----
      if (menu->redraw & REDRAW_FULL)
      {
        menu_redraw_full (menu);
+       draw_sidebar(menu->menu);
        mutt_show_error ();
      }
  
***************
*** 558,567 ****
--- 565,577 ----
  
        if (menu->redraw & REDRAW_STATUS)
        {
+         DrawFullLine = 1;
  	menu_status_line (buf, sizeof (buf), menu, NONULL (Status));
+         DrawFullLine = 0;
  	CLEARLINE (option (OPTSTATUSONTOP) ? 0 : LINES-2);
  	SETCOLOR (MT_COLOR_STATUS);
          BKGDSET (MT_COLOR_STATUS);
+         set_buffystats(Context);
  	mutt_paddstr (COLS, buf);
  	SETCOLOR (MT_COLOR_NORMAL);
          BKGDSET (MT_COLOR_NORMAL);
***************
*** 575,581 ****
  	menu->oldcurrent = -1;
  
        if (option (OPTARROWCURSOR))
! 	move (menu->current - menu->top + menu->offset, 2);
        else if (option (OPTBRAILLEFRIENDLY))
  	move (menu->current - menu->top + menu->offset, 0);
        else
--- 585,591 ----
  	menu->oldcurrent = -1;
  
        if (option (OPTARROWCURSOR))
! 	move (menu->current - menu->top + menu->offset, SidebarWidth + 2);
        else if (option (OPTBRAILLEFRIENDLY))
  	move (menu->current - menu->top + menu->offset, 0);
        else
***************
*** 1055,1060 ****
--- 1065,1071 ----
  	  menu->redraw = REDRAW_FULL;
  	break;
  
+       case OP_SIDEBAR_OPEN:
        case OP_MAIN_CHANGE_FOLDER:
        case OP_MAIN_NEXT_UNREAD_MAILBOX:
  
***************
*** 1086,1092 ****
  	{
  	  mutt_buffy (buf, sizeof (buf));
  
! 	  if (mutt_enter_fname (cp, buf, sizeof (buf), &menu->redraw, 1) == -1)
  	  {
  	    if (menu->menu == MENU_PAGER)
  	    {
--- 1097,1107 ----
  	{
  	  mutt_buffy (buf, sizeof (buf));
  
!           if ( op == OP_SIDEBAR_OPEN ) {
!               if(!CurBuffy)
!                 break;
!             strncpy( buf, CurBuffy->path, sizeof(buf) );  
! 	    } else if (mutt_enter_fname (cp, buf, sizeof (buf), &menu->redraw, 1) == -1)
  	  {
  	    if (menu->menu == MENU_PAGER)
  	    {
***************
*** 1104,1109 ****
--- 1119,1125 ----
  	}
  
  	mutt_expand_path (buf, sizeof (buf));
+         set_curbuffy(buf);
  	if (mx_get_magic (buf) <= 0)
  	{
  	  mutt_error (_("%s is not a mailbox."), buf);
***************
*** 2183,2188 ****
--- 2199,2210 ----
  	mutt_what_key();
  	break;
  
+       case OP_SIDEBAR_SCROLL_UP:
+       case OP_SIDEBAR_SCROLL_DOWN:
+       case OP_SIDEBAR_NEXT:
+       case OP_SIDEBAR_PREV:
+         scroll_sidebar(op, menu->menu);
+         break;
        default:
  	if (menu->menu == MENU_MAIN)
  	  km_error_key (MENU_MAIN);
*** mutt-1.5.20-orig/flags.c	2008-12-16 21:50:09.000000000 -0600
--- mutt-1.5.20-patched/flags.c	2009-06-19 22:07:04.000000000 -0500
***************
*** 22,29 ****
--- 22,31 ----
  
  #include "mutt.h"
  #include "mutt_curses.h"
+ #include "mutt_menu.h"
  #include "sort.h"
  #include "mx.h"
+ #include "sidebar.h"
  
  void _mutt_set_flag (CONTEXT *ctx, HEADER *h, int flag, int bf, int upd_ctx)
  {
***************
*** 263,268 ****
--- 265,271 ----
     */
    if (h->searched && (changed != h->changed || deleted != ctx->deleted || tagged != ctx->tagged || flagged != ctx->flagged))
      h->searched = 0;
+ 	draw_sidebar(0);
  }
  
  void mutt_tag_set_flag (int flag, int bf)
*** mutt-1.5.20-orig/functions.h	2009-04-30 00:36:17.000000000 -0500
--- mutt-1.5.20-patched/functions.h	2009-06-19 22:07:04.000000000 -0500
***************
*** 168,173 ****
--- 168,178 ----
    { "decrypt-save",		OP_DECRYPT_SAVE,		NULL },
  
  
+  { "sidebar-scroll-up",	OP_SIDEBAR_SCROLL_UP, NULL },
+  { "sidebar-scroll-down",	OP_SIDEBAR_SCROLL_DOWN, NULL },
+  { "sidebar-next",		OP_SIDEBAR_NEXT, NULL },
+  { "sidebar-prev",		OP_SIDEBAR_PREV, NULL },
+  { "sidebar-open",		OP_SIDEBAR_OPEN, NULL },
    { NULL,			0,				NULL }
  };
  
***************
*** 268,273 ****
--- 273,283 ----
  
    { "what-key",		OP_WHAT_KEY,		NULL },
  
+   { "sidebar-scroll-up",	OP_SIDEBAR_SCROLL_UP, NULL },
+   { "sidebar-scroll-down",	OP_SIDEBAR_SCROLL_DOWN, NULL },
+   { "sidebar-next",	OP_SIDEBAR_NEXT, NULL },
+   { "sidebar-prev",	OP_SIDEBAR_PREV, NULL },
+   { "sidebar-open", OP_SIDEBAR_OPEN, NULL },
    { NULL,		0,				NULL }
  };
  
*** mutt-1.5.20-orig/globals.h	2009-06-03 15:48:31.000000000 -0500
--- mutt-1.5.20-patched/globals.h	2009-06-19 22:07:04.000000000 -0500
***************
*** 117,122 ****
--- 117,123 ----
  WHERE char *SendCharset;
  WHERE char *Sendmail;
  WHERE char *Shell;
+ WHERE char *SidebarDelim;
  WHERE char *Signature;
  WHERE char *SimpleSearch;
  #if USE_SMTP
***************
*** 206,211 ****
--- 207,215 ----
  WHERE short ScoreThresholdRead;
  WHERE short ScoreThresholdFlag;
  
+ WHERE struct buffy_t *CurBuffy INITVAL(0);
+ WHERE short DrawFullLine INITVAL(0);
+ WHERE short SidebarWidth;
  #ifdef USE_IMAP
  WHERE short ImapKeepalive;
  WHERE short ImapPipelineDepth;
*** mutt-1.5.20-orig/init.h	2009-06-13 16:35:21.000000000 -0500
--- mutt-1.5.20-patched/init.h	2009-06-19 22:07:04.000000000 -0500
***************
*** 1941,1946 ****
--- 1941,1967 ----
    ** not used.
    ** (PGP only)
    */
+   {"sidebar_delim", DT_STR, R_BOTH, UL &SidebarDelim, "|"},
+   /*
+   ** .pp
+   ** This specifies the delimiter between the sidebar (if visible) and 
+   ** other screens.
+   */
+   { "sidebar_visible", DT_BOOL, R_BOTH, OPTSIDEBAR, 0 },
+   /*
+   ** .pp
+   ** This specifies whether or not to show sidebar (left-side list of folders).
+   */
+   { "sidebar_sort", DT_BOOL, R_BOTH, OPTSIDEBARSORT, 0 },
+   /*
+   ** .pp
+   ** This specifies whether or not to sort the sidebar alphabetically.
+   */
+   { "sidebar_width", DT_NUM, R_BOTH, UL &SidebarWidth, 0 },
+   /*
+   ** .pp
+   ** The width of the sidebar.
+   */
    { "pgp_use_gpg_agent", DT_BOOL, R_NONE, OPTUSEGPGAGENT, 0},
    /*
    ** .pp
*** mutt-1.5.20-orig/mailbox.h	2009-04-30 00:36:17.000000000 -0500
--- mutt-1.5.20-patched/mailbox.h	2009-06-19 22:07:04.000000000 -0500
***************
*** 27,32 ****
--- 27,33 ----
  #define M_NEWFOLDER	(1<<4) /* create a new folder - same as M_APPEND, but uses
  				* safe_fopen() for mbox-style folders.
  				*/
+ #define M_PEEK		(1<<5) /* revert atime back after taking a look (if applicable) */
  
  /* mx_open_new_message() */
  #define M_ADD_FROM	1	/* add a From_ line */
--- orig/Makefile.am.orig	2010-09-18 13:23:19.000000000 +0200
+++ new/Makefile.am	2010-09-18 13:25:19.000000000 +0200
@@ -34,7 +34,7 @@
 	score.c send.c sendlib.c signal.c sort.c \
 	status.c system.c thread.c charset.c history.c lib.c \
 	muttlib.c editmsg.c mbyte.c \
-	url.c ascii.c crypt-mod.c crypt-mod.h safe_asprintf.c
+	url.c ascii.c crypt-mod.c crypt-mod.h safe_asprintf.c sidebar.c
 
 nodist_mutt_SOURCES = $(BUILT_SOURCES)
 
--- orig/Makefile.in.orig	2010-09-18 13:23:19.000000000 +0200
+++ new/Makefile.in	2010-09-18 13:27:19.000000000 +0200
@@ -89,7 +89,7 @@
 	system.$(OBJEXT) thread.$(OBJEXT) charset.$(OBJEXT) \
 	history.$(OBJEXT) lib.$(OBJEXT) muttlib.$(OBJEXT) \
 	editmsg.$(OBJEXT) mbyte.$(OBJEXT) url.$(OBJEXT) \
-	ascii.$(OBJEXT) crypt-mod.$(OBJEXT) safe_asprintf.$(OBJEXT)
+	ascii.$(OBJEXT) crypt-mod.$(OBJEXT) safe_asprintf.$(OBJEXT) sidebar.$(OBJEXT)
 am__objects_1 =
 am__objects_2 = patchlist.$(OBJEXT) $(am__objects_1)
 nodist_mutt_OBJECTS = $(am__objects_2)
@@ -363,7 +363,7 @@
 	score.c send.c sendlib.c signal.c sort.c \
 	status.c system.c thread.c charset.c history.c lib.c \
 	muttlib.c editmsg.c mbyte.c \
-	url.c ascii.c crypt-mod.c crypt-mod.h safe_asprintf.c
+	url.c ascii.c crypt-mod.c crypt-mod.h safe_asprintf.c sidebar.c
 
 nodist_mutt_SOURCES = $(BUILT_SOURCES)
 mutt_LDADD = @MUTT_LIB_OBJECTS@ @LIBOBJS@ $(LIBIMAP) $(MUTTLIBS) \
@@ -397,7 +397,7 @@
 	README.SSL smime.h group.h \
 	muttbug pgppacket.h depcomp ascii.h BEWARE PATCHES patchlist.sh \
 	ChangeLog mkchangelog.sh mutt_idna.h \
-	snprintf.c regex.c crypt-gpgme.h hcachever.sh.in
+	snprintf.c regex.c crypt-gpgme.h sidebar.h hcachever.sh.in
 
 EXTRA_SCRIPTS = smime_keys
 mutt_dotlock_SOURCES = mutt_dotlock.c
*** mutt-1.5.20-orig/mbox.c	2009-06-10 23:29:41.000000000 -0500
--- mutt-1.5.20-patched/mbox.c	2009-06-19 22:07:04.000000000 -0500
***************
*** 100,105 ****
--- 100,106 ----
      mutt_perror (ctx->path);
      return (-1);
    }
+   ctx->atime = sb.st_atime;
    ctx->mtime = sb.st_mtime;
    ctx->size = sb.st_size;
  
***************
*** 255,260 ****
--- 256,262 ----
  
    ctx->size = sb.st_size;
    ctx->mtime = sb.st_mtime;
+   ctx->atime = sb.st_atime;
  
  #ifdef NFS_ATTRIBUTE_HACK
    if (sb.st_mtime > sb.st_atime)
*** mutt-1.5.20-orig/menu.c	2009-06-01 11:29:32.000000000 -0500
--- mutt-1.5.20-patched/menu.c	2009-06-19 22:07:04.000000000 -0500
***************
*** 24,29 ****
--- 24,30 ----
  #include "mutt_curses.h"
  #include "mutt_menu.h"
  #include "mbyte.h"
+ #include "sidebar.h"
  
  #include <string.h>
  #include <stdlib.h>
***************
*** 156,162 ****
  {
    char *scratch = safe_strdup (s);
    int shift = option (OPTARROWCURSOR) ? 3 : 0;
!   int cols = COLS - shift;
  
    mutt_format_string (s, n, cols, cols, FMT_LEFT, ' ', scratch, mutt_strlen (scratch), 1);
    s[n - 1] = 0;
--- 157,163 ----
  {
    char *scratch = safe_strdup (s);
    int shift = option (OPTARROWCURSOR) ? 3 : 0;
!   int cols = COLS - shift - SidebarWidth;
  
    mutt_format_string (s, n, cols, cols, FMT_LEFT, ' ', scratch, mutt_strlen (scratch), 1);
    s[n - 1] = 0;
***************
*** 207,212 ****
--- 208,214 ----
    char buf[LONG_STRING];
    int i;
  
+   draw_sidebar(1);
    for (i = menu->top; i < menu->top + menu->pagelen; i++)
    {
      if (i < menu->max)
***************
*** 217,223 ****
        if (option (OPTARROWCURSOR))
        {
          attrset (menu->color (i));
! 	CLEARLINE (i - menu->top + menu->offset);
  
  	if (i == menu->current)
  	{
--- 219,225 ----
        if (option (OPTARROWCURSOR))
        {
          attrset (menu->color (i));
! 	CLEARLINE_WIN (i - menu->top + menu->offset);
  
  	if (i == menu->current)
  	{
***************
*** 246,259 ****
  	  BKGDSET (MT_COLOR_INDICATOR);
  	}
  
! 	CLEARLINE (i - menu->top + menu->offset);
  	print_enriched_string (menu->color(i), (unsigned char *) buf, i != menu->current);
          SETCOLOR (MT_COLOR_NORMAL);
          BKGDSET (MT_COLOR_NORMAL);
        }
      }
      else
!       CLEARLINE (i - menu->top + menu->offset);
    }
    menu->redraw = 0;
  }
--- 248,261 ----
  	  BKGDSET (MT_COLOR_INDICATOR);
  	}
  
! 	CLEARLINE_WIN (i - menu->top + menu->offset);
  	print_enriched_string (menu->color(i), (unsigned char *) buf, i != menu->current);
          SETCOLOR (MT_COLOR_NORMAL);
          BKGDSET (MT_COLOR_NORMAL);
        }
      }
      else
!       CLEARLINE_WIN (i - menu->top + menu->offset);
    }
    menu->redraw = 0;
  }
***************
*** 268,274 ****
      return;
    }
    
!   move (menu->oldcurrent + menu->offset - menu->top, 0);
    SETCOLOR (MT_COLOR_NORMAL);
    BKGDSET (MT_COLOR_NORMAL);
  
--- 270,276 ----
      return;
    }
    
!   move (menu->oldcurrent + menu->offset - menu->top, SidebarWidth);
    SETCOLOR (MT_COLOR_NORMAL);
    BKGDSET (MT_COLOR_NORMAL);
  
***************
*** 283,295 ****
        clrtoeol ();
        menu_make_entry (buf, sizeof (buf), menu, menu->oldcurrent);
        menu_pad_string (buf, sizeof (buf));
!       move (menu->oldcurrent + menu->offset - menu->top, 3);
        print_enriched_string (menu->color(menu->oldcurrent), (unsigned char *) buf, 1);
        SETCOLOR (MT_COLOR_NORMAL);
      }
  
      /* now draw it in the new location */
!     move (menu->current + menu->offset - menu->top, 0);
      attrset (menu->color (menu->current));
      ADDCOLOR (MT_COLOR_INDICATOR);
      addstr ("->");
--- 285,297 ----
        clrtoeol ();
        menu_make_entry (buf, sizeof (buf), menu, menu->oldcurrent);
        menu_pad_string (buf, sizeof (buf));
!       move (menu->oldcurrent + menu->offset - menu->top, SidebarWidth + 3);
        print_enriched_string (menu->color(menu->oldcurrent), (unsigned char *) buf, 1);
        SETCOLOR (MT_COLOR_NORMAL);
      }
  
      /* now draw it in the new location */
!     move (menu->current + menu->offset - menu->top, SidebarWidth);
      attrset (menu->color (menu->current));
      ADDCOLOR (MT_COLOR_INDICATOR);
      addstr ("->");
***************
*** 310,316 ****
      attrset (menu->color (menu->current));
      ADDCOLOR (MT_COLOR_INDICATOR);
      BKGDSET (MT_COLOR_INDICATOR);
!     CLEARLINE (menu->current - menu->top + menu->offset);
      print_enriched_string (menu->color(menu->current), (unsigned char *) buf, 0);
      SETCOLOR (MT_COLOR_NORMAL);
      BKGDSET (MT_COLOR_NORMAL);
--- 312,318 ----
      attrset (menu->color (menu->current));
      ADDCOLOR (MT_COLOR_INDICATOR);
      BKGDSET (MT_COLOR_INDICATOR);
!     CLEARLINE_WIN (menu->current - menu->top + menu->offset);
      print_enriched_string (menu->color(menu->current), (unsigned char *) buf, 0);
      SETCOLOR (MT_COLOR_NORMAL);
      BKGDSET (MT_COLOR_NORMAL);
***************
*** 322,328 ****
  {
    char buf[LONG_STRING];
    
!   move (menu->current + menu->offset - menu->top, 0);
    menu_make_entry (buf, sizeof (buf), menu, menu->current);
    menu_pad_string (buf, sizeof (buf));
  
--- 324,330 ----
  {
    char buf[LONG_STRING];
    
!   move (menu->current + menu->offset - menu->top, SidebarWidth);
    menu_make_entry (buf, sizeof (buf), menu, menu->current);
    menu_pad_string (buf, sizeof (buf));
  
***************
*** 876,882 ****
      
      
      if (option (OPTARROWCURSOR))
!       move (menu->current - menu->top + menu->offset, 2);
      else if (option (OPTBRAILLEFRIENDLY))
        move (menu->current - menu->top + menu->offset, 0);
      else
--- 878,884 ----
      
      
      if (option (OPTARROWCURSOR))
!       move (menu->current - menu->top + menu->offset, SidebarWidth + 2);
      else if (option (OPTBRAILLEFRIENDLY))
        move (menu->current - menu->top + menu->offset, 0);
      else
*** mutt-1.5.20-orig/mutt_curses.h	2008-11-11 13:55:47.000000000 -0600
--- mutt-1.5.20-patched/mutt_curses.h	2009-06-19 22:07:04.000000000 -0500
***************
*** 64,69 ****
--- 64,70 ----
  #undef lines
  #endif /* lines */
  
+ #define CLEARLINE_WIN(x) move(x,SidebarWidth), clrtoeol()
  #define CLEARLINE(x) move(x,0), clrtoeol()
  #define CENTERLINE(x,y) move(y, (COLS-strlen(x))/2), addstr(x)
  #define BEEP() do { if (option (OPTBEEP)) beep(); } while (0)
***************
*** 126,131 ****
--- 127,134 ----
    MT_COLOR_BOLD,
    MT_COLOR_UNDERLINE,
    MT_COLOR_INDEX,
+   MT_COLOR_NEW,
+   MT_COLOR_FLAGGED,
    MT_COLOR_MAX
  };
  
*** mutt-1.5.20-orig/mutt.h	2009-06-12 17:15:42.000000000 -0500
--- mutt-1.5.20-patched/mutt.h	2009-06-19 22:07:04.000000000 -0500
***************
*** 418,423 ****
--- 418,425 ----
    OPTSAVEEMPTY,
    OPTSAVENAME,
    OPTSCORE,
+   OPTSIDEBAR,
+   OPTSIDEBARSORT,
    OPTSIGDASHES,
    OPTSIGONTOP,
    OPTSORTRE,
***************
*** 854,859 ****
--- 856,862 ----
  {
    char *path;
    FILE *fp;
+   time_t atime;
    time_t mtime;
    off_t size;
    off_t vsize;
***************
*** 888,893 ****
--- 891,897 ----
    unsigned int quiet : 1;	/* inhibit status messages? */
    unsigned int collapsed : 1;   /* are all threads collapsed? */
    unsigned int closing : 1;	/* mailbox is being closed */
+   unsigned int peekonly : 1;	/* just taking a glance, revert atime */
  
    /* driver hooks */
    void *data;			/* driver specific data */
*** mutt-1.5.20-orig/muttlib.c	2009-05-18 19:11:35.000000000 -0500
--- mutt-1.5.20-patched/muttlib.c	2009-06-19 22:07:04.000000000 -0500
***************
*** 1232,1237 ****
--- 1232,1239 ----
  	  pl = pw = 1;
  
  	/* see if there's room to add content, else ignore */
+         if ( DrawFullLine )
+         {
  	if ((col < COLS && wlen < destlen) || soft)
  	{
  	  int pad;
***************
*** 1274,1279 ****
--- 1276,1327 ----
  	  col += wid;
  	  src += pl;
  	}
+         }
+         else
+         {
+ 	if ((col < COLS-SidebarWidth && wlen < destlen) || soft)
+         {
+ 	  int pad;
+ 
+ 	  /* get contents after padding */
+ 	  mutt_FormatString (buf, sizeof (buf), 0, src + pl, callback, data, flags);
+ 	  len = mutt_strlen (buf);
+ 	  wid = mutt_strwidth (buf);
+ 
+ 	  /* try to consume as many columns as we can, if we don't have
+ 	   * memory for that, use as much memory as possible */
+ 	  pad = (COLS - SidebarWidth - col - wid) / pw;
+ 	  if (pad > 0 && wlen + (pad * pl) + len > destlen)
+ 	    pad = ((signed)(destlen - wlen - len)) / pl;
+ 	  if (pad > 0)
+ 	  {
+ 	    while (pad--)
+ 	    {
+ 	      memcpy (wptr, src, pl);
+ 	      wptr += pl;
+ 	      wlen += pl;
+ 	      col += pw;
+ 	    }
+ 	  }
+ 	  else if (soft && pad < 0)
+ 	  {
+ 	    /* \0-terminate dest for length computation in mutt_wstr_trunc() */
+ 	    *wptr = 0;
+ 	    /* make sure right part is at most as wide as display */
+ 	    len = mutt_wstr_trunc (buf, destlen, COLS, &wid);
+ 	    /* truncate left so that right part fits completely in */
+ 	    wlen = mutt_wstr_trunc (dest, destlen - len, col + pad, &col);
+ 	    wptr = dest + wlen;
+ 	  }
+ 	  if (len + wlen > destlen)
+ 	    len = mutt_wstr_trunc (buf, destlen - wlen, COLS - SidebarWidth - col, NULL);
+ 	  memcpy (wptr, buf, len);
+ 	  wptr += len;
+ 	  wlen += len;
+ 	  col += wid;
+ 	  src += pl;
+ 	}
+         }
  	break; /* skip rest of input */
        }
        else if (ch == '|')
*** mutt-1.5.20-orig/mx.c	2009-06-10 23:29:41.000000000 -0500
--- mutt-1.5.20-patched/mx.c	2009-06-19 22:07:04.000000000 -0500
***************
*** 581,586 ****
--- 581,587 ----
   *		M_APPEND	open mailbox for appending
   *		M_READONLY	open mailbox in read-only mode
   *		M_QUIET		only print error messages
+  *		M_PEEK		revert atime where applicable
   *	ctx	if non-null, context struct to use
   */
  CONTEXT *mx_open_mailbox (const char *path, int flags, CONTEXT *pctx)
***************
*** 603,608 ****
--- 604,611 ----
      ctx->quiet = 1;
    if (flags & M_READONLY)
      ctx->readonly = 1;
+   if (flags & M_PEEK)
+     ctx->peekonly = 1;
  
    if (flags & (M_APPEND|M_NEWFOLDER))
    {
***************
*** 702,710 ****
--- 705,725 ----
  void mx_fastclose_mailbox (CONTEXT *ctx)
  {
    int i;
+ #ifndef BUFFY_SIZE
+   struct utimbuf ut;
+ #endif
  
    if(!ctx) 
      return;
+ #ifndef BUFFY_SIZE
+   /* fix up the times so buffy won't get confused */
+   if (ctx->peekonly && ctx->path && ctx->mtime > ctx->atime)
+   {
+     ut.actime = ctx->atime;
+     ut.modtime = ctx->mtime;
+     utime (ctx->path, &ut); 
+   }
+ #endif
  
    if (ctx->mx_close)
      ctx->mx_close (ctx);
*** mutt-1.5.20-orig/OPS	2009-05-13 00:01:13.000000000 -0500
--- mutt-1.5.20-patched/OPS	2009-06-19 22:07:04.000000000 -0500
***************
*** 178,180 ****
--- 178,185 ----
  OP_MAIN_SHOW_LIMIT "show currently active limit pattern"
  OP_MAIN_COLLAPSE_THREAD "collapse/uncollapse current thread"
  OP_MAIN_COLLAPSE_ALL "collapse/uncollapse all threads"
+ OP_SIDEBAR_SCROLL_UP "scroll the mailbox pane up 1 page"
+ OP_SIDEBAR_SCROLL_DOWN "scroll the mailbox pane down 1 page"
+ OP_SIDEBAR_NEXT "go down to next mailbox"
+ OP_SIDEBAR_PREV "go to previous mailbox"
+ OP_SIDEBAR_OPEN "open hilighted mailbox"
--- orig/pager.c.orig	2010-09-18 13:23:19.000000000 +0200
+++ new/pager.c	2010-09-18 14:03:08.000000000 +0200
@@ -29,6 +29,7 @@
 #include "pager.h"
 #include "attach.h"
 #include "mbyte.h"
+#include "sidebar.h"
 
 #include "mutt_crypt.h"
 
@@ -1104,6 +1105,7 @@
   if (check_attachment_marker ((char *)buf) == 0)
     wrap_cols = COLS;
 
+  wrap_cols -= SidebarWidth;
   /* FIXME: this should come from lineInfo */
   memset(&mbstate, 0, sizeof(mbstate));
 
@@ -1778,7 +1780,7 @@
     if ((redraw & REDRAW_BODY) || topline != oldtopline)
     {
       do {
-	move (bodyoffset, 0);
+	move (bodyoffset, SidebarWidth);
 	curline = oldtopline = topline;
 	lines = 0;
 	force_redraw = 0;
@@ -1791,6 +1793,7 @@
 			    &QuoteList, &q_level, &force_redraw, &SearchRE) > 0)
 	    lines++;
 	  curline++;
+  	  move(lines + bodyoffset, SidebarWidth);
 	}
 	last_offset = lineInfo[curline].offset;
       } while (force_redraw);
@@ -1804,6 +1807,7 @@
 	  addch ('~');
 	addch ('\n');
 	lines++;
+  	move(lines + bodyoffset, SidebarWidth);
       }
       /* We are going to update the pager status bar, so it isn't
        * necessary to reset to normal color now. */
@@ -1827,21 +1831,21 @@
       /* print out the pager status bar */
       SETCOLOR (MT_COLOR_STATUS);
       BKGDSET (MT_COLOR_STATUS);
-      CLEARLINE (statusoffset);
+      CLEARLINE_WIN (statusoffset);
 
       if (IsHeader (extra) || IsMsgAttach (extra))
       {
-	size_t l1 = COLS * MB_LEN_MAX;
+	size_t l1 = (COLS-SidebarWidth) * MB_LEN_MAX;
 	size_t l2 = sizeof (buffer);
 	hfi.hdr = (IsHeader (extra)) ? extra->hdr : extra->bdy->hdr;
 	mutt_make_string_info (buffer, l1 < l2 ? l1 : l2, NONULL (PagerFmt), &hfi, M_FORMAT_MAKEPRINT);
-	mutt_paddstr (COLS, buffer);
+	mutt_paddstr (COLS-SidebarWidth, buffer);
       }
       else
       {
 	char bn[STRING];
 	snprintf (bn, sizeof (bn), "%s (%s)", banner, pager_progress_str);
-	mutt_paddstr (COLS, bn);
+	mutt_paddstr (COLS-SidebarWidth, bn);
       }
       BKGDSET (MT_COLOR_NORMAL);
       SETCOLOR (MT_COLOR_NORMAL);
@@ -1852,18 +1856,23 @@
       /* redraw the pager_index indicator, because the
        * flags for this message might have changed. */
       menu_redraw_current (index);
+      draw_sidebar(MENU_PAGER);
 
       /* print out the index status bar */
       menu_status_line (buffer, sizeof (buffer), index, NONULL(Status));
  
-      move (indexoffset + (option (OPTSTATUSONTOP) ? 0 : (indexlen - 1)), 0);
+      move (indexoffset + (option (OPTSTATUSONTOP) ? 0 : (indexlen - 1)), SidebarWidth);
       SETCOLOR (MT_COLOR_STATUS);
       BKGDSET (MT_COLOR_STATUS);
-      mutt_paddstr (COLS, buffer);
+      mutt_paddstr (COLS-SidebarWidth, buffer);
       SETCOLOR (MT_COLOR_NORMAL);
       BKGDSET (MT_COLOR_NORMAL);
     }
 
+    /* if we're not using the index, update every time */
+    if ( index == 0 )
+      draw_sidebar(MENU_PAGER);
+
     redraw = 0;
 
     if (option(OPTBRAILLEFRIENDLY)) {
@@ -2852,6 +2861,13 @@
 	mutt_what_key ();
 	break;
 
+      case OP_SIDEBAR_SCROLL_UP:
+      case OP_SIDEBAR_SCROLL_DOWN:
+      case OP_SIDEBAR_NEXT:
+      case OP_SIDEBAR_PREV:
+	scroll_sidebar(ch, MENU_PAGER);
+ 	break;
+
       default:
 	ch = -1;
 	break;
*** mutt-1.5.20-orig/PATCHES	2008-11-11 13:55:46.000000000 -0600
--- mutt-1.5.20-patched/PATCHES	2009-06-19 22:20:31.000000000 -0500
***************
*** 0 ****
--- 1 ----
+ patch-1.5.20.sidebar.20090619.txt
*** mutt-1.5.20-orig/sidebar.c	1969-12-31 18:00:00.000000000 -0600
--- mutt-1.5.20-patched/sidebar.c	2009-06-19 22:07:04.000000000 -0500
***************
*** 0 ****
--- 1,333 ----
+ /*
+  * Copyright (C) ????-2004 Justin Hibbits <jrh29@po.cwru.edu>
+  * Copyright (C) 2004 Thomer M. Gil <mutt@thomer.com>
+  * 
+  *     This program is free software; you can redistribute it and/or modify
+  *     it under the terms of the GNU General Public License as published by
+  *     the Free Software Foundation; either version 2 of the License, or
+  *     (at your option) any later version.
+  * 
+  *     This program is distributed in the hope that it will be useful,
+  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  *     GNU General Public License for more details.
+  * 
+  *     You should have received a copy of the GNU General Public License
+  *     along with this program; if not, write to the Free Software
+  *     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111, USA.
+  */ 
+ 
+ 
+ #if HAVE_CONFIG_H
+ # include "config.h"
+ #endif
+ 
+ #include "mutt.h"
+ #include "mutt_menu.h"
+ #include "mutt_curses.h"
+ #include "sidebar.h"
+ #include "buffy.h"
+ #include <libgen.h>
+ #include "keymap.h"
+ #include <stdbool.h>
+ 
+ /*BUFFY *CurBuffy = 0;*/
+ static BUFFY *TopBuffy = 0;
+ static BUFFY *BottomBuffy = 0;
+ static int known_lines = 0;
+ 
+ static int quick_log10(int n)
+ {
+         char string[32];
+         sprintf(string, "%d", n);
+         return strlen(string);
+ }
+ 
+ void calc_boundaries (int menu)
+ {
+ 	BUFFY *tmp = Incoming;
+ 
+ 	if ( known_lines != LINES ) {
+ 		TopBuffy = BottomBuffy = 0;
+ 		known_lines = LINES;
+ 	}
+ 	for ( ; tmp->next != 0; tmp = tmp->next )
+ 		tmp->next->prev = tmp;
+ 
+ 	if ( TopBuffy == 0 && BottomBuffy == 0 )
+ 		TopBuffy = Incoming;
+ 	if ( BottomBuffy == 0 ) {
+ 		int count = LINES - 2 - (menu != MENU_PAGER || option(OPTSTATUSONTOP));
+ 		BottomBuffy = TopBuffy;
+ 		while ( --count && BottomBuffy->next )
+ 			BottomBuffy = BottomBuffy->next;
+ 	}
+ 	else if ( TopBuffy == CurBuffy->next ) {
+ 		int count = LINES - 2 - (menu != MENU_PAGER);
+ 		BottomBuffy = CurBuffy;
+ 		tmp = BottomBuffy;
+ 		while ( --count && tmp->prev)
+ 			tmp = tmp->prev;
+ 		TopBuffy = tmp;
+ 	}
+ 	else if ( BottomBuffy == CurBuffy->prev ) {
+ 		int count = LINES - 2 - (menu != MENU_PAGER);
+ 		TopBuffy = CurBuffy;
+ 		tmp = TopBuffy;
+ 		while ( --count && tmp->next )
+ 			tmp = tmp->next;
+ 		BottomBuffy = tmp;
+ 	}
+ }
+ 
+ char *make_sidebar_entry(char *box, int size, int new, int flagged)
+ {
+ 	static char *entry = 0;
+ 	char *c;
+ 	int i = 0;
+ 	int delim_len = strlen(SidebarDelim);
+ 
+ 	c = realloc(entry, SidebarWidth - delim_len + 2);
+ 	if ( c ) entry = c;
+ 	entry[SidebarWidth - delim_len + 1] = 0;
+ 	for (; i < SidebarWidth - delim_len + 1; entry[i++] = ' ' );
+ 	i = strlen(box);
+ 	strncpy( entry, box, i < (SidebarWidth - delim_len + 1) ? i : (SidebarWidth - delim_len + 1) );
+ 
+         if (size == -1)
+                 sprintf(entry + SidebarWidth - delim_len - 3, "?");
+         else if ( new ) {
+           if (flagged > 0) {
+               sprintf(
+ 		        entry + SidebarWidth - delim_len - 5 - quick_log10(size) - quick_log10(new) - quick_log10(flagged),
+ 		        "% d(%d)[%d]", size, new, flagged);
+           } else {
+               sprintf(
+                       entry + SidebarWidth - delim_len - 3 - quick_log10(size) - quick_log10(new),
+                       "% d(%d)", size, new);
+           }
+         } else if (flagged > 0) {
+               sprintf( entry + SidebarWidth - delim_len - 3 - quick_log10(size) - quick_log10(flagged), "% d[%d]", size, flagged);
+         } else {
+               sprintf( entry + SidebarWidth - delim_len - 1 - quick_log10(size), "% d", size);
+         }
+ 	return entry;
+ }
+ 
+ void set_curbuffy(char buf[LONG_STRING])
+ {
+   BUFFY* tmp = CurBuffy = Incoming;
+ 
+   if (!Incoming)
+     return;
+ 
+   while(1) {
+     if(!strcmp(tmp->path, buf)) {
+       CurBuffy = tmp;
+       break;
+     }
+ 
+     if(tmp->next)
+       tmp = tmp->next;
+     else
+       break;
+   }
+ }
+ 
+ int draw_sidebar(int menu) {
+ 
+ 	int lines = option(OPTHELP) ? 1 : 0;
+ 	BUFFY *tmp;
+ #ifndef USE_SLANG_CURSES
+         attr_t attrs;
+ #endif
+         short delim_len = strlen(SidebarDelim);
+         short color_pair;
+ 
+         static bool initialized = false;
+         static int prev_show_value;
+         static short saveSidebarWidth;
+ 
+         /* initialize first time */
+         if(!initialized) {
+                 prev_show_value = option(OPTSIDEBAR);
+                 saveSidebarWidth = SidebarWidth;
+                 if(!option(OPTSIDEBAR)) SidebarWidth = 0;
+                 initialized = true;
+         }
+ 
+         /* save or restore the value SidebarWidth */
+         if(prev_show_value != option(OPTSIDEBAR)) {
+                 if(prev_show_value && !option(OPTSIDEBAR)) {
+                         saveSidebarWidth = SidebarWidth;
+                         SidebarWidth = 0;
+                 } else if(!prev_show_value && option(OPTSIDEBAR)) {
+                         SidebarWidth = saveSidebarWidth;
+                 }
+                 prev_show_value = option(OPTSIDEBAR);
+         }
+ 
+ 
+ //	if ( SidebarWidth == 0 ) return 0;
+        if (SidebarWidth > 0 && option (OPTSIDEBAR)
+            && delim_len >= SidebarWidth) {
+          unset_option (OPTSIDEBAR);
+          /* saveSidebarWidth = SidebarWidth; */
+          if (saveSidebarWidth > delim_len) {
+            SidebarWidth = saveSidebarWidth;
+            mutt_error (_("Value for sidebar_delim is too long. Disabling sidebar."));
+            sleep (2);
+          } else {
+            SidebarWidth = 0;
+            mutt_error (_("Value for sidebar_delim is too long. Disabling sidebar. Please set your sidebar_width to a sane value."));
+            sleep (4); /* the advise to set a sane value should be seen long enough */
+          }
+          saveSidebarWidth = 0;
+          return (0);
+        }
+ 
+     if ( SidebarWidth == 0 || !option(OPTSIDEBAR)) {
+       if (SidebarWidth > 0) {
+         saveSidebarWidth = SidebarWidth;
+         SidebarWidth = 0;
+       }
+       unset_option(OPTSIDEBAR);
+       return 0;
+     }
+ 
+         /* get attributes for divider */
+ 	SETCOLOR(MT_COLOR_STATUS);
+ #ifndef USE_SLANG_CURSES
+         attr_get(&attrs, &color_pair, 0);
+ #else
+         color_pair = attr_get();
+ #endif
+ 	SETCOLOR(MT_COLOR_NORMAL);
+ 
+ 	/* draw the divider */
+ 
+ 	for ( ; lines < LINES-1-(menu != MENU_PAGER || option(OPTSTATUSONTOP)); lines++ ) {
+ 		move(lines, SidebarWidth - delim_len);
+ 		addstr(NONULL(SidebarDelim));
+ #ifndef USE_SLANG_CURSES
+                 mvchgat(lines, SidebarWidth - delim_len, delim_len, 0, color_pair, NULL);
+ #endif
+ 	}
+ 
+ 	if ( Incoming == 0 ) return 0;
+ 	lines = option(OPTHELP) ? 1 : 0; /* go back to the top */
+ 
+ 	if ( known_lines != LINES || TopBuffy == 0 || BottomBuffy == 0 ) 
+ 		calc_boundaries(menu);
+ 	if ( CurBuffy == 0 ) CurBuffy = Incoming;
+ 
+ 	tmp = TopBuffy;
+ 
+ 	SETCOLOR(MT_COLOR_NORMAL);
+ 
+ 	for ( ; tmp && lines < LINES-1 - (menu != MENU_PAGER || option(OPTSTATUSONTOP)); tmp = tmp->next ) {
+ 		if ( tmp == CurBuffy )
+ 			SETCOLOR(MT_COLOR_INDICATOR);
+ 		else if ( tmp->msg_unread > 0 )
+ 			SETCOLOR(MT_COLOR_NEW);
+ 		else if ( tmp->msg_flagged > 0 )
+ 		        SETCOLOR(MT_COLOR_FLAGGED);
+ 		else
+ 			SETCOLOR(MT_COLOR_NORMAL);
+ 
+ 		move( lines, 0 );
+ 		if ( Context && !strcmp( tmp->path, Context->path ) ) {
+ 			tmp->msg_unread = Context->unread;
+ 			tmp->msgcount = Context->msgcount;
+ 			tmp->msg_flagged = Context->flagged;
+ 		}
+ 		// check whether Maildir is a prefix of the current folder's path
+ 		short maildir_is_prefix = 0;
+ 		if ( (strlen(tmp->path) > strlen(Maildir)) &&
+ 			(strncmp(Maildir, tmp->path, strlen(Maildir)) == 0) )
+         		maildir_is_prefix = 1;
+ 		// calculate depth of current folder and generate its display name with indented spaces
+ 		int sidebar_folder_depth = 0;
+ 		char *sidebar_folder_name;
+ 		sidebar_folder_name = basename(tmp->path);
+ 		if ( maildir_is_prefix ) {
+ 			char *tmp_folder_name;
+ 			int i;
+ 			tmp_folder_name = tmp->path + strlen(Maildir);
+ 			for (i = 0; i < strlen(tmp->path) - strlen(Maildir); i++) {
+ 				if (tmp_folder_name[i] == '/') sidebar_folder_depth++;
+ 			}   
+ 			if (sidebar_folder_depth > 0) {
+ 				sidebar_folder_name = malloc(strlen(basename(tmp->path)) + sidebar_folder_depth + 1);
+ 				for (i=0; i < sidebar_folder_depth; i++)
+ 					sidebar_folder_name[i]=' ';
+ 				sidebar_folder_name[i]=0;
+ 				strncat(sidebar_folder_name, basename(tmp->path), strlen(basename(tmp->path)) + sidebar_folder_depth);
+ 			}
+ 		}
+ 		printw( "%.*s", SidebarWidth - delim_len + 1,
+ 			make_sidebar_entry(sidebar_folder_name, tmp->msgcount,
+ 			tmp->msg_unread, tmp->msg_flagged));
+ 		if (sidebar_folder_depth > 0)
+ 		        free(sidebar_folder_name);
+ 		lines++;
+ 	}
+ 	SETCOLOR(MT_COLOR_NORMAL);
+ 	for ( ; lines < LINES-1 - (menu != MENU_PAGER || option(OPTSTATUSONTOP)); lines++ ) {
+ 		int i = 0;
+ 		move( lines, 0 );
+ 		for ( ; i < SidebarWidth - delim_len; i++ )
+ 			addch(' ');
+ 	}
+ 	return 0;
+ }
+ 
+ 
+ void set_buffystats(CONTEXT* Context)
+ {
+         BUFFY *tmp = Incoming;
+         while(tmp) {
+                 if(Context && !strcmp(tmp->path, Context->path)) {
+ 			tmp->msg_unread = Context->unread;
+ 			tmp->msgcount = Context->msgcount;
+                         break;
+                 }
+                 tmp = tmp->next;
+         }
+ }
+ 
+ void scroll_sidebar(int op, int menu)
+ {
+         if(!SidebarWidth) return;
+         if(!CurBuffy) return;
+ 
+ 	switch (op) {
+ 		case OP_SIDEBAR_NEXT:
+ 			if ( CurBuffy->next == NULL ) return;
+ 			CurBuffy = CurBuffy->next;
+ 			break;
+ 		case OP_SIDEBAR_PREV:
+ 			if ( CurBuffy->prev == NULL ) return;
+ 			CurBuffy = CurBuffy->prev;
+ 			break;
+ 		case OP_SIDEBAR_SCROLL_UP:
+ 			CurBuffy = TopBuffy;
+ 			if ( CurBuffy != Incoming ) {
+ 				calc_boundaries(menu);
+ 				CurBuffy = CurBuffy->prev;
+ 			}
+ 			break;
+ 		case OP_SIDEBAR_SCROLL_DOWN:
+ 			CurBuffy = BottomBuffy;
+ 			if ( CurBuffy->next ) {
+ 				calc_boundaries(menu);
+ 				CurBuffy = CurBuffy->next;
+ 			}
+ 			break;
+ 		default:
+ 			return;
+ 	}
+ 	calc_boundaries(menu);
+ 	draw_sidebar(menu);
+ }
+ 
*** mutt-1.5.20-orig/sidebar.h	1969-12-31 18:00:00.000000000 -0600
--- mutt-1.5.20-patched/sidebar.h	2009-06-19 22:07:04.000000000 -0500
***************
*** 0 ****
--- 1,36 ----
+ /*
+  * Copyright (C) ????-2004 Justin Hibbits <jrh29@po.cwru.edu>
+  * Copyright (C) 2004 Thomer M. Gil <mutt@thomer.com>
+  * 
+  *     This program is free software; you can redistribute it and/or modify
+  *     it under the terms of the GNU General Public License as published by
+  *     the Free Software Foundation; either version 2 of the License, or
+  *     (at your option) any later version.
+  * 
+  *     This program is distributed in the hope that it will be useful,
+  *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+  *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  *     GNU General Public License for more details.
+  * 
+  *     You should have received a copy of the GNU General Public License
+  *     along with this program; if not, write to the Free Software
+  *     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111, USA.
+  */ 
+ 
+ #ifndef SIDEBAR_H
+ #define SIDEBAR_H
+ 
+ struct MBOX_LIST {
+ 	char *path;
+ 	int msgcount;
+ 	int new;
+ } MBLIST;
+ 
+ /* parameter is whether or not to go to the status line */
+ /* used for omitting the last | that covers up the status bar in the index */
+ int draw_sidebar(int);
+ void scroll_sidebar(int, int);
+ void set_curbuffy(char*);
+ void set_buffystats(CONTEXT*);
+ 
+ #endif /* SIDEBAR_H */
*** mutt-1.5.20-orig/doc/Muttrc	2009-06-14 13:53:24.000000000 -0500
--- mutt-1.5.20-patched/doc/Muttrc	2009-06-19 22:07:04.000000000 -0500
***************
*** 657,662 ****
--- 657,682 ----
  # $crypt_autosign, $crypt_replysign and $smime_is_default.
  # 
  # 
+ # set sidebar_visible=no
+ #
+ # Name: sidebar_visible
+ # Type: boolean
+ # Default: no
+ # 
+ # 
+ # This specifies whether or not to show sidebar (left-side list of folders).
+ # 
+ # 
+ # set sidebar_width=0
+ #
+ # Name: sidebar_width
+ # Type: number
+ # Default: 0
+ # 
+ # 
+ # The width of the sidebar.
+ # 
+ # 
  # set crypt_autosign=no
  #
  # Name: crypt_autosign
*** mutt-1.5.20-orig/imap/imap.c	2009-06-14 12:19:16.000000000 -0500
--- mutt-1.5.20-patched/imap/imap.c	2009-06-19 22:07:04.000000000 -0500
***************
*** 1521,1527 ****
  
      imap_munge_mbox_name (munged, sizeof (munged), name);
      snprintf (command, sizeof (command),
! 	      "STATUS %s (UIDNEXT UIDVALIDITY UNSEEN RECENT)", munged);
  
      if (imap_exec (idata, command, IMAP_CMD_QUEUE) < 0)
      {
--- 1521,1527 ----
  
      imap_munge_mbox_name (munged, sizeof (munged), name);
      snprintf (command, sizeof (command),
! 	      "STATUS %s (UIDNEXT UIDVALIDITY UNSEEN RECENT MESSAGES)", munged);
  
      if (imap_exec (idata, command, IMAP_CMD_QUEUE) < 0)
      {
*** mutt-1.5.20-orig/imap/command.c	2009-01-05 20:58:31.000000000 -0600
--- mutt-1.5.20-patched/imap/command.c	2009-06-19 22:07:04.000000000 -0500
***************
*** 1009,1014 ****
--- 1009,1021 ----
  	     opened */
  	  status->uidnext = oldun;
  
+         /* Added to make the sidebar show the correct numbers */
+         if (status->messages)
+         {
+           inc->msgcount = status->messages;
+           inc->msg_unread = status->unseen;
+         }
+ 
          FREE (&value);
          return;
        }
--- orig/compose.c.orig	2010-09-18 13:23:18.000000000 +0200
+++ new/compose.c	2010-09-18 14:01:09.000000000 +0200
@@ -80,7 +80,7 @@
 
 #define HDR_XOFFSET 14
 #define TITLE_FMT "%14s" /* Used for Prompts, which are ASCII */
-#define W (COLS - HDR_XOFFSET)
+#define W (COLS - HDR_XOFFSET - SidebarWidth)
 
 static char *Prompts[] =
 {
@@ -143,7 +143,7 @@
 {
   int off = 0;
 
-  mvprintw (HDR_CRYPT, 0, TITLE_FMT, "Security: ");
+  mvprintw (HDR_CRYPT, SidebarWidth, TITLE_FMT, "Security: ");
 
   if ((WithCrypto & (APPLICATION_PGP | APPLICATION_SMIME)) == 0)
   {
@@ -175,7 +175,7 @@
   }
 
   clrtoeol ();
-  move (HDR_CRYPTINFO, 0);
+  move (HDR_CRYPTINFO, SidebarWidth);
   clrtoeol ();
 
   if ((WithCrypto & APPLICATION_PGP)
@@ -195,7 +195,7 @@
       && (msg->security & ENCRYPT)
       && SmimeCryptAlg
       && *SmimeCryptAlg) {
-      mvprintw (HDR_CRYPTINFO, 40, "%s%s", _("Encrypt with: "),
+      mvprintw (HDR_CRYPTINFO, SidebarWidth + 40, "%s%s", _("Encrypt with: "),
 		NONULL(SmimeCryptAlg));
       off = 20;
   }
@@ -224,7 +224,7 @@
     if (t && t[0] == '0' && t[1] == '\0')
       t = "<random>";
     
-    if (c + mutt_strlen (t) + 2 >= COLS)
+    if (c + mutt_strlen (t) + 2 >= COLS - SidebarWidth)
       break;
 
     addstr (NONULL(t));
@@ -276,7 +276,7 @@
 
   buf[0] = 0;
   rfc822_write_address (buf, sizeof (buf), addr, 1);
-  mvprintw (line, 0, TITLE_FMT, Prompts[line - 1]);
+  mvprintw (line, SidebarWidth, TITLE_FMT, Prompts[line - 1]);
   mutt_paddstr (W, buf);
 }
 
@@ -294,21 +294,21 @@
   }
   else
   {
-    mvprintw (HDR_TO, 0, TITLE_FMT , Prompts[HDR_NEWSGROUPS - 1]);
+    mvprintw (HDR_TO, SidebarWidth, TITLE_FMT , Prompts[HDR_NEWSGROUPS - 1]);
     mutt_paddstr (W, NONULL (msg->env->newsgroups));
-    mvprintw (HDR_CC, 0, TITLE_FMT , Prompts[HDR_FOLLOWUPTO - 1]);
+    mvprintw (HDR_CC, SidebarWidth, TITLE_FMT , Prompts[HDR_FOLLOWUPTO - 1]);
     mutt_paddstr (W, NONULL (msg->env->followup_to));
     if (option (OPTXCOMMENTTO))
     {
-      mvprintw (HDR_BCC, 0, TITLE_FMT , Prompts[HDR_XCOMMENTTO - 1]);
+      mvprintw (HDR_BCC, SidebarWidth, TITLE_FMT , Prompts[HDR_XCOMMENTTO - 1]);
       mutt_paddstr (W, NONULL (msg->env->x_comment_to));
     }
   }
 #endif
-  mvprintw (HDR_SUBJECT, 0, TITLE_FMT, Prompts[HDR_SUBJECT - 1]);
+  mvprintw (HDR_SUBJECT, SidebarWidth, TITLE_FMT, Prompts[HDR_SUBJECT - 1]);
   mutt_paddstr (W, NONULL (msg->env->subject));
   draw_envelope_addr (HDR_REPLYTO, msg->env->reply_to);
-  mvprintw (HDR_FCC, 0, TITLE_FMT, Prompts[HDR_FCC - 1]);
+  mvprintw (HDR_FCC, SidebarWidth, TITLE_FMT, Prompts[HDR_FCC - 1]);
   mutt_paddstr (W, fcc);
 
   if (WithCrypto)
@@ -319,7 +319,7 @@
 #endif
 
   SETCOLOR (MT_COLOR_STATUS);
-  mvaddstr (HDR_ATTACH - 1, 0, _("-- Attachments"));
+  mvaddstr (HDR_ATTACH - 1, SidebarWidth, _("-- Attachments"));
   BKGDSET (MT_COLOR_STATUS);
   clrtoeol ();
 
@@ -357,7 +357,7 @@
   /* redraw the expanded list so the user can see the result */
   buf[0] = 0;
   rfc822_write_address (buf, sizeof (buf), *addr, 1);
-  move (line, HDR_XOFFSET);
+  move (line, HDR_XOFFSET+SidebarWidth);
   mutt_paddstr (W, buf);
   
   return 0;
@@ -686,7 +686,7 @@
 	if (mutt_get_field ("Subject: ", buf, sizeof (buf), 0) == 0)
 	{
 	  mutt_str_replace (&msg->env->subject, buf);
-	  move (HDR_SUBJECT, HDR_XOFFSET);
+	  move (HDR_SUBJECT, HDR_XOFFSET + SidebarWidth);
 	  clrtoeol ();
 	  if (msg->env->subject)
 	    mutt_paddstr (W, msg->env->subject);
@@ -703,7 +703,7 @@
 	{
 	  strfcpy (fcc, buf, fcclen);
 	  mutt_pretty_mailbox (fcc, fcclen);
-	  move (HDR_FCC, HDR_XOFFSET);
+	  move (HDR_FCC, HDR_XOFFSET + SidebarWidth);
 	  mutt_paddstr (W, fcc);
 	  fccSet = 1;
