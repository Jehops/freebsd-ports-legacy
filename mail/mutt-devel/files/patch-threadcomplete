diff -Nru a/PATCHES b/PATCHES
--- PATCHES	2004-07-24 12:27:17 +02:00
+++ PATCHES	2004-08-22 02:01:52 +02:00
@@ -0,0 +1 @@
+patch-1.5.6.cb.thread_pattern.1
diff -Nru a/doc/manual.sgml.head b/doc/manual.sgml.head
--- doc/manual.sgml.head	2004-07-24 12:27:29 +02:00
+++ doc/manual.sgml.head	2004-08-25 14:54:08 +02:00
@@ -1771,6 +1771,8 @@
 messages:
 
 <tscreen><verb>
+~a              messages in threads that contain at least one tagged message;
+                this is the same as ~(~T) [see below for ~(..)]
 ~A              all messages
 ~b EXPR         messages which contain EXPR in the message body
 ~B EXPR         messages which contain EXPR in the whole message
@@ -1809,6 +1811,8 @@
 ~y EXPR         messages which contain EXPR in the `X-Label' field
 ~z [MIN]-[MAX]  messages with a size in the range MIN to MAX *)
 ~=              duplicated messages (see $duplicate_threads)
+~(PATTERN)      messages in threads containing messages matching a certain
+                pattern, e.g. all threads containing messages from you: ~(~P)
 </verb></tscreen>
 
 Where EXPR, USER, ID, and SUBJECT are 
diff -Nru a/mutt.h b/mutt.h
--- mutt.h	2004-07-24 12:27:21 +02:00
+++ mutt.h	2004-08-25 14:04:40 +02:00
@@ -207,10 +207,12 @@
   M_LIMIT,
   M_EXPIRED,
   M_SUPERSEDED,
+  M_THREADCOMPLETE,
 
   /* actions for mutt_pattern_comp/mutt_pattern_exec */
   M_AND,
   M_OR,
+  M_THREAD,
   M_TO,
   M_CC,
   M_COLLAPSED,
diff -Nru a/pattern.c b/pattern.c
--- pattern.c	2004-07-24 12:27:23 +02:00
+++ pattern.c	2004-08-25 15:37:51 +02:00
@@ -44,6 +44,7 @@
 }
 Flags[] =
 {
+  { 'a', M_THREADCOMPLETE,	0,		NULL },
   { 'A', M_ALL,			0,		NULL },
   { 'b', M_BODY,		M_FULL_MSG,	eat_regexp },
   { 'B', M_WHOLE_MSG,		M_FULL_MSG,	eat_regexp },
@@ -700,7 +701,7 @@
 pattern_t *mutt_pattern_comp (/* const */ char *s, int flags, BUFFER *err)
 {
   pattern_t *curlist = NULL;
-  pattern_t *tmp;
+  pattern_t *tmp, *tmp2;
   pattern_t *last = NULL;
   int not = 0;
   int alladdr = 0;
@@ -755,6 +756,39 @@
 	alladdr = 0;
 	break;
       case '~':
+	if (*(ps.dptr + 1) == '(') {
+		ps.dptr ++; /* skip ~ */
+		p = find_matching_paren (ps.dptr + 1);
+		if (*p != ')')
+		{
+		  snprintf (err->data, err->dsize, _("mismatched brackets: %s"), ps.dptr);
+		  mutt_pattern_free (&curlist);
+		  return NULL;
+		}
+		tmp = new_pattern ();
+		tmp->op = M_THREAD;
+		if (last)
+		  last->next = tmp;
+		else
+		  curlist = tmp;
+		last = tmp;
+		tmp->not ^= not;
+		tmp->alladdr |= alladdr;
+		not = 0;
+		alladdr = 0;
+		/* compile the sub-expression */
+		buf = mutt_substrdup (ps.dptr + 1, p);
+		if ((tmp2 = mutt_pattern_comp (buf, flags, err)) == NULL)
+		{
+		  FREE (&buf);
+		  mutt_pattern_free (&curlist);
+		  return NULL;
+		}
+		FREE (&buf);
+		tmp->child = tmp2;
+		ps.dptr = p + 1; /* restore location */
+		break;
+	}
 	if (implicit && or)
 	{
 	  /* A | B & C == (A | B) & C */
@@ -945,6 +979,30 @@
   return alladdr;
 }
 
+static int match_threadcomplete(struct pattern_t *pat, pattern_exec_flag flags, CONTEXT *ctx, THREAD *t,int left,int up,int right,int down)
+{
+  int a;
+  HEADER *h;
+
+  if(!t)
+    return 0;
+  h = t->message;
+  if(!h)
+    return 0;
+  if(mutt_pattern_exec(pat, flags, ctx, h))
+    return 1;
+
+  if(up && (a=match_threadcomplete(pat, flags, ctx, t->parent,1,1,1,0)))
+    return a;
+  if(right && t->parent && (a=match_threadcomplete(pat, flags, ctx, t->next,0,0,1,1)))
+    return a;
+  if(left && t->parent && (a=match_threadcomplete(pat, flags, ctx, t->prev,1,0,0,1)))
+    return a;
+  if(down && (a=match_threadcomplete(pat, flags, ctx, t->child,1,0,1,1)))
+    return a;
+  return 0;
+}
+
 /* flags
    	M_MATCH_FULL_ADDRESS	match both personal and machine address */
 int
@@ -958,6 +1016,8 @@
       return (pat->not ^ (perform_and (pat->child, flags, ctx, h) > 0));
     case M_OR:
       return (pat->not ^ (perform_or (pat->child, flags, ctx, h) > 0));
+    case M_THREAD:
+      return (pat->not ^ match_threadcomplete(pat->child, flags, ctx, h->thread, 1, 1, 1, 1));
     case M_ALL:
       return (!pat->not);
     case M_EXPIRED:
@@ -1023,6 +1083,16 @@
 					pat->alladdr, 2, h->env->to, h->env->cc));
     case M_LIST:
       return (pat->not ^ mutt_is_list_recipient (pat->alladdr, h->env->to, h->env->cc));
+    case M_THREADCOMPLETE:
+      { static pattern_t tmp;
+        static short pattern_set = 0;
+        if(! pattern_set) {
+          memset (&tmp, 0, sizeof (tmp));
+          tmp.op = M_TAG;
+          pattern_set = 1;
+        }
+        return (pat->not ^ match_threadcomplete(&tmp, flags, ctx, h->thread, 1, 1, 1, 1));
+      } 
     case M_PERSONAL_RECIP:
       return (pat->not ^ match_user (pat->alladdr, h->env->to, h->env->cc));
     case M_PERSONAL_FROM:
