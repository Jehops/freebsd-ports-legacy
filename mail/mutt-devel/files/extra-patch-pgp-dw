http://www.woolridge.ca/mutt/patches/p0-patch-1.5.x.dw.pgp-menu-traditional.2
--- PATCHES.old	Tue Apr 15 15:18:34 2003
+++ PATCHES	Fri Dec 19 15:00:56 2003
@@ -0,0 +1,3 @@
+patch-1.5.5.dw.multiple-crypt-hook.2
+patch-1.5.5.dw.crypt-autoselectkey.1
+patch-1.5.5.dw.confirm-crypt-hook.1
--- doc/manual.sgml.head.old	Wed Nov  5 10:41:34 2003
+++ doc/manual.sgml.head	Fri Dec 19 15:00:56 2003
@@ -1421,7 +1421,9 @@
 or because, for some reasons, you need to override the key Mutt would
 normally use.  The crypt-hook command provides a method by which you can
 specify the ID of the public key to be used when encrypting messages to
-a certain recipient.
+a certain recipient.  You may use multiple pgp-hook's with the same
+pattern; multiple matching pgp-hook's result in the use of multiple
+keyids for recipient.
 
 The meaning of "key id" is to be taken broadly in this context:  You
 can either put a numerical key ID here, an e-mail address, or even
--- doc/muttrc.man.head.orig	Fri Dec 19 15:14:55 2003
+++ doc/muttrc.man.head	Fri Dec 19 15:19:05 2003
@@ -290 +290,4 @@
-or even just an arbitrary search string.
+or even just an arbitrary search string.  You may use multiple
+\fBpgp-hook\fPs with the same \fIpattern\fP; multiple matching
+\fBpgp-hook\fPs result in the use of multiple \fIkey-id\fPs for
+recipient.
--- hook.c	Tue Jan 21 13:25:21 2003
+++ hook.c	Fri Dec 19 15:00:56 2003
@@ -117,7 +117,11 @@
 	ptr->rx.not == not &&
 	!mutt_strcmp (pattern.data, ptr->rx.pattern))
     {
+#ifdef M_CRYPTHOOK
+      if (data & (M_FOLDERHOOK | M_SENDHOOK | M_MESSAGEHOOK | M_ACCOUNTHOOK | M_REPLYHOOK | M_CRYPTHOOK))
+#else
       if (data & (M_FOLDERHOOK | M_SENDHOOK | M_MESSAGEHOOK | M_ACCOUNTHOOK | M_REPLYHOOK))
+#endif
       {
 	/* these hooks allow multiple commands with the same
 	 * pattern, so if we've already seen this pattern/command pair, just
@@ -443,9 +447,25 @@
   return _mutt_string_hook (chs, M_ICONVHOOK);
 }
 
-char *mutt_crypt_hook (ADDRESS *adr)
+LIST *mutt_crypt_hook (ADDRESS *adr)
 {
-  return _mutt_string_hook (adr->mailbox, M_CRYPTHOOK);
+  HOOK *hook;
+  LIST *key_list = NULL;
+
+  if (!adr && !adr->mailbox)
+    return (NULL);
+
+  for (hook = Hooks; hook; hook = hook->next)
+  {
+    if (!hook->command)
+      continue;
+    if (!(hook->type & M_CRYPTHOOK))
+      continue;
+
+    if ((regexec (hook->rx.rx, adr->mailbox, 0, NULL, 0) == 0) ^ hook->rx.not)
+      key_list = mutt_add_list (key_list, hook->command);
+  }
+  return (key_list);
 }
 
 #ifdef USE_SOCKET
--- init.h	Wed Nov  5 10:41:32 2003
+++ init.h	Fri Dec 19 15:00:46 2003
@@ -1209,6 +1209,16 @@
   ** when you are at the end of a message and invoke the \fInext-page\fP
   ** function.
   */
+  
+
+  { "pgp_autoselectkey",	DT_SYN,  R_NONE, UL "crypt_autoselectkey", 0 },
+  { "crypt_autoselectkey",	DT_BOOL, R_NONE, OPTCRYPTAUTOSELECT, 0 },
+  /*
+  ** .pp
+  ** If set, then a list of keys is not presented for selection when only
+  ** one matching key is available.  This may be useful in conjunction with
+  ** the \fIcrypt-hook\fP command.
+  */
   { "pgp_autosign", 	DT_SYN,  R_NONE, UL "crypt_autosign", 0 },
   { "crypt_autosign",	DT_BOOL, R_NONE, OPTCRYPTAUTOSIGN, 0 },
   /*
@@ -1233,6 +1243,15 @@
   ** then OpenSSL is used instead to create S/MIME messages and
   ** settings can be overridden by use of the \fIsmime-menu\fP.
   ** (Crypto only)
+  */
+  { "pgp_confirmhook",		DT_SYN, R_NONE, UL "crypt_confirmhook", 1 },
+  { "crypt_confirmhook",	DT_BOOL, R_NONE, OPTCRYPTCONFIRMHOOK, 1 },
+  /*
+  ** .pp
+  ** If set, then you will be prompted for confirmation of keys when using
+  ** the \fIcrypt-hook\fP command.  If unset, no such confirmation prompt will
+  ** be presented.  This is generally considered unsafe, especially where
+  ** typos are concerned.
   */
   { "pgp_ignore_subkeys", DT_BOOL, R_NONE, OPTPGPIGNORESUB, 1},
   /*
--- mutt.h	Wed Nov  5 10:41:32 2003
+++ mutt.h	Fri Dec 19 15:00:46 2003
@@ -427,6 +427,7 @@
 
   /* PGP options */
   
+  OPTCRYPTAUTOSELECT,
   OPTCRYPTAUTOSIGN,
   OPTCRYPTAUTOENCRYPT,
   OPTCRYPTAUTOPGP,
@@ -438,6 +439,7 @@
   OPTSMIMEISDEFAULT,
   OPTASKCERTLABEL,
   OPTSDEFAULTDECRYPTKEY,
+  OPTCRYPTCONFIRMHOOK,
   OPTPGPIGNORESUB,
   OPTPGPCHECKEXIT,
   OPTPGPLONGIDS,
--- pgp.c	Wed Nov  5 10:41:33 2003
+++ pgp.c	Fri Dec 19 15:00:56 2003
@@ -1016,6 +1016,8 @@
   char *keyID, *keylist = NULL, *t;
   size_t keylist_size = 0;
   size_t keylist_used = 0;
+  LIST *hook_list = NULL;
+  LIST *hook = NULL;
   ADDRESS *tmp = NULL, *addr = NULL;
   ADDRESS **last = &tmp;
   ADDRESS *p, *q;
@@ -1055,7 +1057,7 @@
     {
       int r;
       snprintf (buf, sizeof (buf), _("Use keyID = \"%s\" for %s?"), keyID, p->mailbox);
-      if ((r = mutt_yesorno (buf, M_YES)) == M_YES)
+      if (!option(OPTCRYPTCONFIRMHOOK) || (r = mutt_yesorno (buf, M_YES)) == M_YES)
       {
 	if (is_numerical_keyid (keyID))
 	{
--- pgpkey.c	Wed Nov  5 10:41:33 2003
+++ pgpkey.c	Fri Dec 19 15:00:46 2003
@@ -435,8 +435,13 @@
   return rv;
 }
 
+
+#define pgp_trusted_id(uid) (!option(OPTPGPCHECKTRUST) \
+			     || (pgp_id_is_valid((uid)) \
+				 && pgp_id_is_strong((uid))))
+
 static pgp_key_t pgp_select_key (pgp_key_t keys,
-                                 ADDRESS * p, const char *s)
+				  ADDRESS * p, const char *s)
 {
   int keymax;
   pgp_uid_t **KeyTable;
@@ -450,6 +455,7 @@
   pgp_uid_t *a;
   int (*f) (const void *, const void *);
 
+  int keymatch = 0;		/* count matching keys */
   int unusable = 0;
 
   keymax = 0;
@@ -479,6 +485,7 @@
       
       KeyTable[i++] = a;
     }
+    keymatch++;
   }
 
   if (!i && unusable)
@@ -487,6 +494,21 @@
     mutt_sleep (1);
     return NULL;
   }
+  else if (keymatch == 1 && option(OPTCRYPTAUTOSELECT))
+  {
+    /*
+     * Only one matching key...see if there's an id with enough trust to auto-select
+     */
+    kp = KeyTable[0]->parent;
+    for (a = kp->address; a; a = a->next)
+    {
+      if (pgp_trusted_id(a))
+      {
+	safe_free ((void **) &KeyTable);
+	return (kp);
+      }
+    }
+  }
 
   switch (PgpSortKeys & SORT_MASK)
   {
@@ -597,9 +619,7 @@
 	  break;
 	}
       
-      if (option (OPTPGPCHECKTRUST) &&
-	  (!pgp_id_is_valid (KeyTable[menu->current])
-	   || !pgp_id_is_strong (KeyTable[menu->current])))
+      if (!pgp_trusted_id(KeyTable[menu->current]))
       {
 	char *s = "";
 	char buff[LONG_STRING];
--- protos.h	Wed Nov  5 10:41:33 2003
+++ protos.h	Fri Dec 19 15:00:56 2003
@@ -129,7 +129,7 @@
 char *mutt_get_body_charset (char *, size_t, BODY *);
 const char *mutt_get_name (ADDRESS *);
 char *mutt_get_parameter (const char *, PARAMETER *);
-char *mutt_crypt_hook (ADDRESS *);
+LIST *mutt_crypt_hook (ADDRESS *);
 char *mutt_make_date (char *, size_t);
 
 const char *mutt_make_version (void);
