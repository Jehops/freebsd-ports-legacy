--- msdosfs_vnops.c.orig	Mon Apr 10 04:32:37 2000
+++ msdosfs_vnops.c	Mon Oct  9 23:15:12 2000
@@ -50,15 +50,13 @@
 
 #include "opt_msdosfs.h"
 
-/*
- * System include files.
- */
 #include <sys/param.h>
 #include <sys/systm.h>
 #include <sys/namei.h>
 #include <sys/resourcevar.h>	/* defines plimit structure in proc struct */
 #include <sys/kernel.h>
 #include <sys/stat.h>
+#include <sys/bio.h>
 #include <sys/buf.h>
 #include <sys/proc.h>
 #include <sys/mount.h>
@@ -70,12 +68,10 @@
 
 #include <vm/vm.h>
 #include <vm/vm_extern.h>
-#include <vm/vm_zone.h>
 #include <vm/vnode_pager.h>
 
-/*
- * MSDOSFS include files.
- */
+#include <machine/mutex.h>
+
 #include <msdosfs/bpb.h>
 #include <msdosfs/direntry.h>
 #include <msdosfs/denode.h>
@@ -239,12 +235,12 @@
 	struct denode *dep = VTODE(vp);
 	struct timespec ts;
 
-	simple_lock(&vp->v_interlock);
+	mtx_enter(&vp->v_interlock, MTX_DEF);
 	if (vp->v_usecount > 1) {
 		getnanotime(&ts);
 		DETIMES(dep, &ts, &ts, &ts);
 	}
-	simple_unlock(&vp->v_interlock);
+	mtx_exit(&vp->v_interlock, MTX_DEF);
 	return 0;
 }
 
@@ -260,10 +256,7 @@
 	struct vnode *vp = ap->a_vp;
 	struct denode *dep = VTODE(ap->a_vp);
 	struct msdosfsmount *pmp = dep->de_pmp;
-	struct ucred *cred = ap->a_cred;
-	mode_t mask, file_mode, mode = ap->a_mode;
-	register gid_t *gp;
-	int i;
+	mode_t file_mode, mode = ap->a_mode;
 
 	file_mode = (S_IXUSR|S_IXGRP|S_IXOTH) | (S_IRUSR|S_IRGRP|S_IROTH) |
 	    ((dep->de_Attributes & ATTR_READONLY) ? 0 : (S_IWUSR|S_IWGRP|S_IWOTH));
@@ -287,43 +280,8 @@
 		}
 	}
 
-	/* User id 0 always gets access. */
-	if (cred->cr_uid == 0)
-		return 0;
-
-	mask = 0;
-
-	/* Otherwise, check the owner. */
-	if (cred->cr_uid == pmp->pm_uid) {
-		if (mode & VEXEC)
-			mask |= S_IXUSR;
-		if (mode & VREAD)
-			mask |= S_IRUSR;
-		if (mode & VWRITE)
-			mask |= S_IWUSR;
-		return (file_mode & mask) == mask ? 0 : EACCES;
-	}
-
-	/* Otherwise, check the groups. */
-	for (i = 0, gp = cred->cr_groups; i < cred->cr_ngroups; i++, gp++)
-		if (pmp->pm_gid == *gp) {
-			if (mode & VEXEC)
-				mask |= S_IXGRP;
-			if (mode & VREAD)
-				mask |= S_IRGRP;
-			if (mode & VWRITE)
-				mask |= S_IWGRP;
-			return (file_mode & mask) == mask ? 0 : EACCES;
-		}
-
-	/* Otherwise, check everyone else. */
-	if (mode & VEXEC)
-		mask |= S_IXOTH;
-	if (mode & VREAD)
-		mask |= S_IROTH;
-	if (mode & VWRITE)
-		mask |= S_IWOTH;
-	return (file_mode & mask) == mask ? 0 : EACCES;
+	return (vaccess(vp->v_type, file_mode, pmp->pm_uid, pmp->pm_gid,
+	    ap->a_mode, ap->a_cred, NULL));
 }
 
 static int
@@ -974,11 +932,6 @@
  *
  * On exit:
  *	all denodes should be released
- *
- * Notes:
- * I'm not sure how the memory containing the pathnames pointed at by the
- * componentname structures is freed, there may be some memory bleeding
- * for each rename done.
  */
 static int
 msdosfs_rename(ap)
@@ -1108,7 +1061,6 @@
 	VOP_UNLOCK(fvp, 0, p);
 	if (VTODE(fdvp)->de_StartCluster != VTODE(tdvp)->de_StartCluster)
 		newparent = 1;
-	vrele(fdvp);
 	if (doingdirectory && newparent) {
 		if (error)	/* write access check above */
 			goto bad;
@@ -1176,7 +1128,8 @@
 		panic("msdosfs_rename: lost from startdir");
 	if (!newparent)
 		VOP_UNLOCK(tdvp, 0, p);
-	(void) relookup(fdvp, &fvp, fcnp);
+	if (relookup(fdvp, &fvp, fcnp) == 0)
+		vrele(fdvp);
 	if (fvp == NULL) {
 		/*
 		 * From name has disappeared.
@@ -1856,15 +1809,15 @@
 		error = pcbmap(dep, bp->b_lblkno, &bp->b_blkno, 0, 0);
 		if (error) {
 			bp->b_error = error;
-			bp->b_flags |= B_ERROR;
-			biodone(bp);
+			bp->b_ioflags |= BIO_ERROR;
+			bufdone(bp);
 			return (error);
 		}
 		if ((long)bp->b_blkno == -1)
 			vfs_bio_clrbuf(bp);
 	}
 	if (bp->b_blkno == -1) {
-		biodone(bp);
+		bufdone(bp);
 		return (0);
 	}
 	/*
