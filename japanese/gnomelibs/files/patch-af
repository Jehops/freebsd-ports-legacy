--- zvt/vt.c.zvtmb	Sun Nov 26 03:49:08 2000
+++ zvt/vt.c	Sun Jun 24 07:35:48 2001
@@ -109,6 +109,62 @@
 
 #endif
 
+#ifdef ZVT_MB
+/*
+  return multibyte character length in vt line
+*/
+int vt_line_mblen(int x, struct vt_line *l)
+{
+  unsigned char ctmp[MB_CUR_MAX];
+  int len = 1, i;
+
+  /* arranged selection columns (sx and ex) for multibyte character */
+  if (MB_CUR_MAX >= 2) {
+      for (i = 0; i < MB_CUR_MAX; i++)
+	  if (x+i <= l->width)
+	      ctmp[i] = l->data[x+i] & 0xff;
+	  else
+	      ctmp[i] = 0;
+      len = mblen(ctmp, MB_CUR_MAX);
+      if (len <= 0) len = 1;
+  }
+
+  return(len);
+}
+
+int vt_query_line_mbchar(int x, struct vt_line *l)
+{
+  unsigned char ctmp[MB_CUR_MAX];
+  int xx = x, len = 1, i;
+
+  if (x == 0 || x == l->width) return(x);
+
+  /* arranged selection columns (sx and ex) for multibyte character */
+  if (MB_CUR_MAX >= 2) {
+      if (x > l->width) x = l->width;
+      if (x < 0) x = 0;
+      for (xx = 0; xx < x; xx += len) {
+	  if ((l->data[xx] & VTATTR_DATAMASK) <= 0x1f)
+	      len = 1; 	    /* control code character */
+	  else {
+	      for (i = 0; i < MB_CUR_MAX && xx+i < x; i++)
+		  ctmp[i] = l->data[xx+i] & VTATTR_DATAMASK;
+	      for (     ; i < MB_CUR_MAX; i++)
+		  ctmp[i] = 0;
+	      len = mblen(ctmp, MB_CUR_MAX);
+	      if (len <= 0) {
+		  if (xx + 1 != x)
+		      len = 1;
+		  else
+		      break;
+	      }
+	  }
+      }
+  }
+  return(xx);
+}
+#endif
+ 
 /***********************************************************************
  * Update functions
  */
@@ -1444,6 +1500,10 @@
   struct vt_jump *modes = vtjumps;
   char *ptr_end;
   void (*process)(struct vt_em *vt);	/* process function */
+#ifdef ZVT_MB
+  unsigned char ctmp[MB_CUR_MAX];
+  int ctmp_num;
+#endif
 
   /* states:
    *   0: normal escape mode
@@ -1521,7 +1581,26 @@
     
     switch (state) {
       
+#if defined(ZVT_JIS) && defined(ZVT_MB)
+    case 100:                /* enter JIS mode */
+      state = (c == 'B')? 101: 0;
+      break;
+    case 110:                /* exit JIS mode */
+      state = 0;
+      break;
+    case 101:
+	if (c > 0x1f && c < 0x80 && MB_CUR_MAX >= 2)
+	    c += 0x80;
+#endif
     case 0:
+#ifdef ZVT_MB
+      /* prevent to be into alt mode for half katakana character in EUC-JP */
+      if ((mode & VT_CON) && process == vt_alt_start && (*ptr & 0xff) >= 0xa0) {
+	  mode = VT_LIT;
+	  process = NULL;
+      }
+#endif
+
       if (mode & VT_LIT) {
 	/* remap character? */
 	if (vt->remaptable && c<=0xff)
@@ -1531,17 +1610,43 @@
 	if (vt->mode & VTMODE_INSERT)
 	  vt_insert_chars(vt, 1);
 	
+#ifdef ZVT_MB
+	ctmp_num = 0;
+#endif
 	/* need to wrap? */
 	if (vt->cursorx>=vt->width) {
 	  if (vt->mode&VTMODE_WRAPOFF)
 	    vt->cursorx = vt->width-1;
 	  else {
+#ifdef ZVT_MB
+	      /* check of a boundary of multi byte character */
+	      int x = vt_query_line_mbchar(vt->width+1, vt->this_line);
+	      if (x < vt->width && vt->width - x < sizeof(ctmp) ) {
+		for(ctmp_num=0; ctmp_num < vt->width - x; ctmp_num++) {
+		  int i = vt->width - 1 - ctmp_num;
+		  ctmp[ctmp_num] = vt->this_line->data[i] & 0xff;
+		  vt->this_line->data[i] =
+		    ((vt->attr) & VTATTR_CLEARMASK) |VTATTR_MULTIBYTE;
+		  vt->this_line->modcount++;
+		}
+	      }
+#endif
 	    vt_lf(vt);
 	    vt->cursorx=0;
 	  }
 	}
 	
 	/* output character */
+#ifdef ZVT_MB
+	if (ctmp_num) {
+	    while(ctmp_num) {
+		vt->this_line->data[vt->cursorx++] =
+		    ((vt->attr) & VTATTR_MASK) | ctmp[ctmp_num-1];
+		ctmp_num--;
+		vt->this_line->modcount++;
+	    }
+	}
+#endif
 	vt->this_line->data[vt->cursorx] = ((vt->attr) & VTATTR_MASK) | c;
 	vt->this_line->modcount++;
 	/* d(printf("literal %c\n", c)); */
@@ -1571,6 +1676,12 @@
       } else if (c==']') {	/* set text parameters, read parameters */
 	state = 4;
 	vt->arg.txt.outptr = vt->arg.txt.args_mem;
+#if defined(ZVT_JIS) && defined(ZVT_MB)
+      } else if (c=='$') {	/* in JIS code */
+	state = 100;
+      } else if (c=='(') {	/* out JIS mode */
+	state = 110;
+#endif
       } else if (mode & VT_EXA) {
 	vt->arg.num.intargs[0] = c & 0x7f;
 	state = 5;
