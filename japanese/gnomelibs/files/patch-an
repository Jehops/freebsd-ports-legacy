--- ./gtk-xmhtml/layout.c.jp3	Fri Jul 30 02:59:51 1999
+++ ./gtk-xmhtml/layout.c	Sun Oct 29 18:32:21 2000
@@ -447,7 +447,7 @@
 	*****/
 	for(i = 0 ; i < html->html.anchor_words; i++)
 			html->html.anchors[i].x = html->html.anchors[i].self->x;
-	for(i = 0 ; i < html->html.anchor_words; i++)
+	for(i = 0 ; i < html->html.anchor_words - 1; i++)
 	{
 		if((html->html.anchors[i].owner == html->html.anchors[i+1].owner) &&
 			(html->html.anchors[i].line == html->html.anchors[i+1].line))
@@ -1173,19 +1173,30 @@
 		* which *does* have a trailing space. We then use the total width
 		* of this word to check against available line width.
 		*****/
-		if(!(words[i]->spacing & TEXT_SPACE_TRAIL) && 
-			i+1 < *nwords && !(words[i+1]->spacing & TEXT_SPACE_LEAD))
+		if(
+			!(words[i]->spacing & TEXT_SPACE_TRAIL) && 
+			!(words[i]->spacing & TEXT_SPACE_TRAIL_ZEROWIDTH) && 
+			i+1 < *nwords &&
+			!(words[i+1]->spacing & TEXT_SPACE_LEAD) &&
+			!(words[i+1]->spacing & TEXT_SPACE_LEAD_ZEROWIDTH)
+		)
 		{
 			int j = i+1;
 			word_width = words[i]->width;
 			while(j < *nwords)
 			{
-				if(!(words[j]->spacing & TEXT_SPACE_LEAD))
+				if(!(words[j]->spacing & TEXT_SPACE_LEAD) &&
+					!(words[j]->spacing & TEXT_SPACE_LEAD_ZEROWIDTH))
 					word_width += words[j]->width;
 
 				/* see if this word has a trail space and the next a leading */
-				if(!(words[j]->spacing & TEXT_SPACE_TRAIL) && 
-					j+1 < *nwords && !(words[j+1]->spacing & TEXT_SPACE_LEAD))
+				if(
+					!(words[j]->spacing & TEXT_SPACE_TRAIL) && 
+					!(words[j]->spacing & TEXT_SPACE_TRAIL_ZEROWIDTH) && 
+					j+1 < *nwords &&
+					!(words[j+1]->spacing & TEXT_SPACE_LEAD) &&
+					!(words[j+1]->spacing & TEXT_SPACE_LEAD_ZEROWIDTH)
+				)
 					j++;
 				else
 					break;
@@ -1395,8 +1406,13 @@
 		* save linenumber, x and y positions for this word or for
 		* multiple words needing to be ``glued'' together.
 		*****/
-		if(!(words[i]->spacing & TEXT_SPACE_TRAIL) && 
-			i+1 < *nwords && !(words[i+1]->spacing & TEXT_SPACE_LEAD))
+		if(
+			!(words[i]->spacing & TEXT_SPACE_TRAIL) && 
+			!(words[i]->spacing & TEXT_SPACE_TRAIL_ZEROWIDTH) && 
+			i+1 < *nwords &&
+			!(words[i+1]->spacing & TEXT_SPACE_LEAD) &&
+			!(words[i+1]->spacing & TEXT_SPACE_LEAD_ZEROWIDTH)
+		)
 		{
 			/* first word must take spacing into account */
 			UPDATE_WORD(words[i]);
@@ -1413,8 +1429,13 @@
 					UPDATE_WORD(words[i])
 
 				/* this word has a trailing and the next a leading space? */
-				if(!(words[i]->spacing & TEXT_SPACE_TRAIL) && 
-					i+1 < *nwords && !(words[i+1]->spacing & TEXT_SPACE_LEAD))
+				if(
+					!(words[i]->spacing & TEXT_SPACE_TRAIL) && 
+					!(words[i]->spacing & TEXT_SPACE_TRAIL_ZEROWIDTH) && 
+					i+1 < *nwords &&
+					!(words[i+1]->spacing & TEXT_SPACE_LEAD) &&
+					!(words[i+1]->spacing & TEXT_SPACE_LEAD_ZEROWIDTH)
+				)
 					i++;
 				else
 					break;
@@ -2972,8 +2993,7 @@
 
 	/* store return dimensions, box->x is not touched */
 	box->y += max_theight;
-	table->end->height = box->height = max_theight;
-	box->width = box->min_width = full_max_twidth;
+	table->end->height = max_theight;
 
 	/*****
 	* update x position of owning object, it might have shifted due to
