--- orig/nrpe-2.0/src/Makefile.in	Tue Aug  5 07:01:53 2003
+++ src/Makefile.in	Tue May 17 00:25:33 2005
@@ -9,7 +9,7 @@
 SRC_COMMON=../common
 
 CC=@CC@
-CFLAGS=@CFLAGS@ @DEFS@
+CFLAGS=@CFLAGS@ @DEFS@ -DPID_DIR=\"/var/run/\" 
 LDFLAGS=@LDFLAGS@ @LIBS@
 SOCKETLIBS=@SOCKETLIBS@
 
--- orig/nrpe-2.0/src/nrpe.c	Tue Sep  9 04:52:37 2003
+++ src/nrpe.c	Tue May 17 00:24:29 2005
@@ -23,6 +23,7 @@
 #include "nrpe.h"
 #include "utils.h"
 
+
 #ifdef HAVE_SSL
 #include "dh.h"
 #endif
@@ -83,7 +84,6 @@
 #endif
 
 
-
 int main(int argc, char **argv){
 	int result=OK;
 	int x;
@@ -219,7 +219,45 @@
 
 	/* else daemonize and start listening for requests... */
 	else if(fork()==0){
-
+#ifdef PID_DIR
+		int fd;
+		int pid_written = 0;
+		char *pid_fname;
+		char pbuf[16];
+		char *bname = strrchr(argv[0], '/'); /* basename from XPG4.2 would be nice */
+
+		bname = !bname ? argv[0] : ++bname;
+		pid_fname = malloc(strlen(PID_DIR) + strlen(bname) + sizeof(".pid"));
+		strcpy(pid_fname, PID_DIR);
+		strcat(pid_fname, bname); strcat(pid_fname, ".pid");
+		if ((fd = open (pid_fname, O_RDONLY)) >= 0) {
+			int status = read (fd, pbuf, (sizeof pbuf) - 1);
+			close (fd);
+			if (status > 0) {
+				int pid;
+				pbuf [status] = 0;
+				pid = atoi (pbuf);
+				/* If the previous server process is not still running,
+				   write a new pid file immediately. */
+				if (pid && (pid == getpid() || kill (pid, 0) < 0)) {
+					unlink (pid_fname);
+				} else {
+					syslog(LOG_ERR,"There's already a nrpe server running.");
+					free(pid_fname);
+					return STATE_CRITICAL;
+				}
+			}
+		} 
+		if ((fd = open (pid_fname, O_WRONLY | O_CREAT, 0644)) >= 0) {
+			sprintf (pbuf, "%d\n", (int)getpid ());
+			write (fd, pbuf, strlen (pbuf));
+			close (fd);
+		} else {
+			syslog(LOG_ERR,"Can not write the pidfile(%s).", pid_fname);
+		}
+		free(pid_fname);
+#endif
+		
 		/* we're a daemon - set up a new process group */
 		setsid();
 
