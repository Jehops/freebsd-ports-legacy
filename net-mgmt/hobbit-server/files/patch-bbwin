diff -Naur /home/etienne/hobbit-4.2/hobbitd/client/bbwin.c ./hobbitd/client/bbwin.c
--- /home/etienne/hobbit-4.2/hobbitd/client/bbwin.c	1970-01-01 01:00:00.000000000 +0100
+++ ./hobbitd/client/bbwin.c	2007-12-27 13:54:02.000000000 +0100
@@ -0,0 +1,316 @@
+/*----------------------------------------------------------------------------*/
+/* Hobbit message daemon.                                                     */
+/*                                                                            */
+/* Client backend module for BBWin/Windoes client                             */
+/*                                                                            */
+/* Copyright (C) 2006-2007 Henrik Storner <henrik@hswn.dk>                    */
+/* Copyright (C) 2007 Francois Lacroix					      */
+/* Copyright (C) 2007 Etienne Grignon <etienne.grignon@gmail.com>      */
+/*                                                                            */
+/* This program is released under the GNU General Public License (GPL),       */
+/* version 2. See the file "COPYING" for details.                             */
+/*                                                                            */
+/*----------------------------------------------------------------------------*/
+
+static char bbwin_rcsid[] = "$Id: bbwin.c,v 1.2 2007/07/18 21:20:15 henrik Exp $";
+
+static void bbwin_uptime_report(char *hostname, char *clientclass, enum ostype_t os,
+                     void *hinfo, char *fromline, char *timestr,
+                     char *uptimestr)
+{
+        char *p, *myuptimestr = NULL;
+	float loadyellow, loadred;
+        int recentlimit, ancientlimit, maxclockdiff;
+        long uptimesecs = -1;
+        int uptimecolor = COL_GREEN;
+        char msgline[4096];
+        strbuffer_t *upmsg;
+
+	if (!want_msgtype(hinfo, MSG_CPU)) return;
+        if (!uptimestr) return;
+
+	dbgprintf("Uptime check host %s\n", hostname);
+
+        uptimesecs = 0;
+
+	/* Parse to check data */
+        p = strstr(uptimestr, "sec:");
+        if (p) {
+		p += strcspn(p, "0123456789\r\n");
+                uptimesecs = atol(p);
+                dbgprintf("uptimestr [%d]\n", uptimesecs); /* DEBUG TODO REMOVE */
+	}
+	/* Parse to show a nice msg */
+        myuptimestr = strchr(uptimestr, '\n');
+        if (myuptimestr) {
+		++myuptimestr;
+        }
+	get_cpu_thresholds(hinfo, clientclass, &loadyellow, &loadred, &recentlimit, &ancientlimit, &maxclockdiff);
+	dbgprintf("DEBUG recentlimit: [%d] ancienlimit: [%d]\n", recentlimit, ancientlimit); /* DEBUG TODO REMOVE */
+
+        upmsg = newstrbuffer(0);
+        if ((uptimesecs != -1) && (recentlimit != -1) && (uptimesecs < recentlimit)) {
+                if (uptimecolor == COL_GREEN) uptimecolor = COL_YELLOW;
+                addtobuffer(upmsg, "&yellow Machine recently rebooted\n");
+        }
+        if ((uptimesecs != -1) && (ancientlimit != -1) && (uptimesecs > ancientlimit)) {
+                if (uptimecolor == COL_GREEN) uptimecolor = COL_YELLOW;
+                sprintf(msgline, "&yellow Machine has been up more than %d days\n", (ancientlimit / 86400));
+                addtobuffer(upmsg, msgline);
+        }
+
+        init_status(uptimecolor);
+        sprintf(msgline, "status %s.uptime %s %s %s\n",
+                commafy(hostname), colorname(uptimecolor),
+                (timestr ? timestr : "<No timestamp data>"),
+                ((uptimecolor == COL_GREEN) ? "OK" : "NOT ok"));
+
+        addtostatus(msgline);
+	/* And add the info if pb */
+        if (STRBUFLEN(upmsg)) {
+                addtostrstatus(upmsg);
+                addtostatus("\n");
+        }
+        /* And add the msg we recevied */
+        if (myuptimestr) {
+                addtostatus(myuptimestr);
+                addtostatus("\n");
+        }
+
+	dbgprintf("msgline %s", msgline); /* DEBUG TODO REMOVE */ 
+
+        if (fromline && !localmode) addtostatus(fromline);
+        finish_status();
+
+        freestrbuffer(upmsg);
+}
+
+
+static void bbwin_cpu_report(char *hostname, char *clientclass, enum ostype_t os,
+                     void *hinfo, char *fromline, char *timestr,
+                     char *cpuutilstr)
+{
+        char *p, *topstr;
+        float load1, loadyellow, loadred;
+        int recentlimit, ancientlimit, maxclockdiff;
+        int cpucolor = COL_GREEN;
+
+        char msgline[4096];
+        strbuffer_t *cpumsg;
+
+        if (!want_msgtype(hinfo, MSG_CPU)) return;
+        if (!cpuutilstr) return;
+
+	dbgprintf("CPU check host %s\n", hostname);	
+
+	load1 = 0;
+
+        p = strstr(cpuutilstr, "load=");
+        if (p) {
+                p += strcspn(p, "0123456789%\r\n");
+                load1 = atol(p);
+                dbgprintf("load1 [%d]\n", load1); /* DEBUG TODO REMOVE */ 
+        }
+	topstr = strstr(cpuutilstr, "CPU states");
+	if (topstr) {
+		*(topstr - 1) = '\0';
+	}
+	
+	get_cpu_thresholds(hinfo, clientclass, &loadyellow, &loadred, &recentlimit, &ancientlimit, &maxclockdiff);
+	dbgprintf("loadyellow: %d, loadred: %d\n", loadyellow, loadred);
+
+        cpumsg = newstrbuffer(0);
+        if (load1 > loadred) {
+                cpucolor = COL_RED;
+                addtobuffer(cpumsg, "&red Load is CRITICAL\n");
+        }
+        else if (load1 > loadyellow) {
+                cpucolor = COL_YELLOW;
+                addtobuffer(cpumsg, "&yellow Load is HIGH\n");
+        }
+        init_status(cpucolor);
+        sprintf(msgline, "status %s.cpu %s %s %s",
+                commafy(hostname), colorname(cpucolor),
+                (timestr ? timestr : "<No timestamp data>"),
+                cpuutilstr);
+
+        addtostatus(msgline);
+        /* And add the info if pb */
+        if (STRBUFLEN(cpumsg)) {
+                addtostrstatus(cpumsg);
+                addtostatus("\n");
+        }
+	/* And add the msg we recevied */
+        if (topstr) {
+                addtostatus(topstr);
+                addtostatus("\n");
+        }
+
+	dbgprintf("msgline %s", msgline); /* DEBUG TODO REMOVE */
+
+        if (fromline && !localmode) addtostatus(fromline);
+        finish_status();
+
+        freestrbuffer(cpumsg);
+}
+
+static void bbwin_clock_report(char *hostname, char *clientclass, enum ostype_t os,
+                     void *hinfo, char *fromline, char *timestr,
+                     char *clockstr, char *msgcachestr)
+{
+       	char *myclockstr;
+        int clockcolor = COL_GREEN;
+        float loadyellow, loadred;
+        int recentlimit, ancientlimit, maxclockdiff;
+        char msgline[4096];
+        strbuffer_t *clockmsg;
+
+        if (!want_msgtype(hinfo, MSG_CPU)) return;
+        if (!clockstr) return;
+
+	dbgprintf("Clock check host %s\n", hostname);
+
+	clockmsg = newstrbuffer(0);
+
+        myclockstr = strstr(clockstr, "local");
+        if (myclockstr) {
+                *(myclockstr - 1) = '\0';
+        }
+
+	get_cpu_thresholds(hinfo, clientclass, &loadyellow, &loadred, &recentlimit, &ancientlimit, &maxclockdiff);
+
+        if (clockstr) {
+                char *p;
+                struct timeval clockval;
+
+                p = strstr(clockstr, "epoch:");
+                if (p && (sscanf(p, "epoch: %ld.%ld", (long int *)&clockval.tv_sec, (long int *)&clockval.tv_usec) == 2)) {
+                        struct timeval clockdiff;
+                        struct timezone tz;
+                        int cachedelay = 0;
+
+                        if (msgcachestr) {
+                                /* Message passed through msgcache, so adjust for the cache delay */
+                                p = strstr(msgcachestr, "Cachedelay:");
+                                if (p) cachedelay = atoi(p+11);
+                        }
+
+                        gettimeofday(&clockdiff, &tz);
+                        clockdiff.tv_sec -= (clockval.tv_sec + cachedelay);
+                        clockdiff.tv_usec -= clockval.tv_usec;
+                        if (clockdiff.tv_usec < 0) {
+                                clockdiff.tv_usec += 1000000;
+                                clockdiff.tv_sec -= 1;
+                        }
+
+                        if ((maxclockdiff > 0) && (abs(clockdiff.tv_sec) > maxclockdiff)) {
+                                if (clockcolor == COL_GREEN) clockcolor = COL_YELLOW;
+                                sprintf(msgline, "&yellow System clock is %ld seconds off (max %ld)\n",
+                                        (long) clockdiff.tv_sec, (long) maxclockdiff);
+                                addtobuffer(clockmsg, msgline);
+                        }
+                        else {
+                                sprintf(msgline, "System clock is %ld seconds off\n", (long) clockdiff.tv_sec);
+                                addtobuffer(clockmsg, msgline);
+                        }
+                }
+        }
+
+        init_status(clockcolor);
+        sprintf(msgline, "status %s.timediff %s %s %s\n",
+                commafy(hostname), colorname(clockcolor),
+                (timestr ? timestr : "<No timestamp data>"),
+                ((clockcolor == COL_GREEN) ? "OK" : "NOT ok"));
+
+        addtostatus(msgline);
+        /* And add the info if pb */
+        if (STRBUFLEN(clockmsg)) {
+                addtostrstatus(clockmsg);
+                addtostatus("\n");
+        }
+        /* And add the msg we recevied */
+        if (myclockstr) {
+                addtostatus(myclockstr);
+                addtostatus("\n");
+        }
+
+        dbgprintf("msgline %s", msgline); /* DEBUG TODO REMOVE */
+
+        if (fromline && !localmode) addtostatus(fromline);
+        finish_status();
+
+        freestrbuffer(clockmsg);
+}
+
+void handle_win32_bbwin_client(char *hostname, char *clienttype, enum ostype_t os, 
+			 void *hinfo, char *sender, time_t timestamp,
+			 char *clientdata)
+{
+	char *timestr;
+	char *cpuutilstr;
+	char *uptimestr;
+	char *clockstr;
+	char *msgcachestr;
+	char *diskstr;
+	char *procsstr;	
+	char *msgsstr;
+	char *portsstr;
+	char *memorystr;
+	char *netstatstr;
+	char *ifstatstr;
+
+	char fromline[1024];
+
+	sprintf(fromline, "\nStatus message received from %s\n", sender);
+
+	splitmsg(clientdata);
+
+	/* Get all data by section timestr is the date time for all status */ 
+	timestr = getdata("date");
+	if (!timestr) return;	
+
+	uptimestr = getdata("uptime");
+	clockstr = getdata("clock");
+	msgcachestr = getdata("msgcache"); /* TODO check when it is usefull */
+	cpuutilstr = getdata("cpu");
+	procsstr = getdata("procs");
+	diskstr = getdata("disk");
+	portsstr = getdata("ports");
+	memorystr = getdata("memory");
+	msgsstr = getdata("msg");
+        netstatstr = getdata("netstat");
+        ifstatstr = getdata("ifstat");	
+
+	bbwin_uptime_report(hostname, clienttype, os, hinfo, fromline, timestr, uptimestr);
+	bbwin_clock_report(hostname, clienttype, os, hinfo, fromline, timestr, clockstr, msgcachestr); 
+	bbwin_cpu_report(hostname, clienttype, os, hinfo, fromline, timestr, cpuutilstr);
+        unix_procs_report(hostname, clienttype, os, hinfo, fromline, timestr, "Name", NULL, procsstr);
+	unix_ports_report(hostname, clienttype, os, hinfo, fromline, timestr, 1, 2, 3, portsstr);
+	unix_disk_report(hostname, clienttype, os, hinfo, fromline, timestr, "Avail", "Capacity", "Filesystem", diskstr);
+
+	msgs_report(hostname, clienttype, os, hinfo, fromline, timestr, msgsstr);
+        file_report(hostname, clienttype, os, hinfo, fromline, timestr);
+        linecount_report(hostname, clienttype, os, hinfo, fromline, timestr);
+
+	/* Data status */
+        unix_netstat_report(hostname, clienttype, os, hinfo, fromline, timestr, netstatstr);
+        unix_ifstat_report(hostname, clienttype, os, hinfo, fromline, timestr, ifstatstr);
+
+        if (memorystr) {
+                char *p;
+                long memphystotal, memphysused,
+                     memactused, memacttotal,
+                     memswaptotal, memswapused;
+
+                memphystotal = memswaptotal = memphysused = memswapused = memactused = memacttotal = -1;
+                p = strstr(memorystr, "\nphysical:");
+                if (p) sscanf(p, "\nphysical: %ld %ld", &memphystotal, &memphysused);
+		p = strstr(memorystr, "\npage:");
+                if (p) sscanf(p, "\npage: %ld %ld", &memswaptotal, &memswapused);
+                p = strstr(memorystr, "\nvirtual:");
+		if (p) sscanf(p, "\nvirtual: %ld %ld", &memacttotal, &memactused);
+		dbgprintf("DEBUG Memory %ld %ld %ld %ld %ld\n", memphystotal, memphysused, memactused, memswaptotal, memswapused); /* DEBUG TODO Remove*/
+                unix_memory_report(hostname, clienttype, os, hinfo, fromline, timestr,
+                                   memphystotal, memphysused, memactused, memswaptotal, memswapused);
+        }
+}
diff -Naur /home/etienne/hobbit-4.2/hobbitd/hobbitd_client.c ./hobbitd/hobbitd_client.c
--- /home/etienne/hobbit-4.2/hobbitd/hobbitd_client.c	2007-10-30 14:21:10.000000000 +0100
+++ ./hobbitd/hobbitd_client.c	2007-12-26 14:28:02.000000000 +0100
@@ -1402,6 +1402,7 @@
 #include "client/darwin.c"
 #include "client/irix.c"
 #include "client/sco_sv.c"
+#include "client/bbwin.c"
 
 static volatile int reloadconfig = 0;
 
@@ -1770,57 +1771,61 @@
 
 			combo_start();
 			switch (os) {
-			  case OS_FREEBSD: 
-				handle_freebsd_client(hostname, clientclass, os, hinfo, sender, timestamp, restofmsg);
-				break;
-
-			  case OS_NETBSD: 
-				handle_netbsd_client(hostname, clientclass, os, hinfo, sender, timestamp, restofmsg);
-				break;
-
-			  case OS_OPENBSD: 
-				handle_openbsd_client(hostname, clientclass, os, hinfo, sender, timestamp, restofmsg);
-				break;
-
-			  case OS_LINUX22: 
-			  case OS_LINUX: 
-			  case OS_RHEL3: 
-				handle_linux_client(hostname, clientclass, os, hinfo, sender, timestamp, restofmsg);
-				break;
-
-			  case OS_DARWIN:
-				handle_darwin_client(hostname, clientclass, os, hinfo, sender, timestamp, restofmsg);
-				break;
-
-			  case OS_SOLARIS: 
-				handle_solaris_client(hostname, clientclass, os, hinfo, sender, timestamp, restofmsg);
-				break;
-
-			  case OS_HPUX: 
-				handle_hpux_client(hostname, clientclass, os, hinfo, sender, timestamp, restofmsg);
-				break;
-
-			  case OS_OSF: 
-				handle_osf_client(hostname, clientclass, os, hinfo, sender, timestamp, restofmsg);
-				break;
-
-			  case OS_AIX: 
-				handle_aix_client(hostname, clientclass, os, hinfo, sender, timestamp, restofmsg);
-				break;
-
-			  case OS_IRIX:
-				handle_irix_client(hostname, clientclass, os, hinfo, sender, timestamp, restofmsg);
-				break;
-				
+                          case OS_FREEBSD:
+                                handle_freebsd_client(hostname, clientclass, os, hinfo, sender, timestamp, restofmsg);
+                                break;
+
+                          case OS_NETBSD:
+                                handle_netbsd_client(hostname, clientclass, os, hinfo, sender, timestamp, restofmsg);
+                                break;
+
+                          case OS_OPENBSD:
+                                handle_openbsd_client(hostname, clientclass, os, hinfo, sender, timestamp, restofmsg);
+                                break;
+
+                          case OS_LINUX22:
+                          case OS_LINUX:
+                          case OS_RHEL3:
+                                handle_linux_client(hostname, clientclass, os, hinfo, sender, timestamp, restofmsg);
+                                break;
+
+                          case OS_DARWIN:
+                                handle_darwin_client(hostname, clientclass, os, hinfo, sender, timestamp, restofmsg);
+                                break;
+
+                          case OS_SOLARIS:
+                                handle_solaris_client(hostname, clientclass, os, hinfo, sender, timestamp, restofmsg);
+                                break;
+
+                          case OS_HPUX:
+                                handle_hpux_client(hostname, clientclass, os, hinfo, sender, timestamp, restofmsg);
+                                break;
+
+                          case OS_OSF:
+                                handle_osf_client(hostname, clientclass, os, hinfo, sender, timestamp, restofmsg);
+                                break;
+
+                          case OS_AIX:
+                                handle_aix_client(hostname, clientclass, os, hinfo, sender, timestamp, restofmsg);
+                                break;
+
+                          case OS_IRIX:
+                                handle_irix_client(hostname, clientclass, os, hinfo, sender, timestamp, restofmsg);
+                                break;
+
                           case OS_SCO_SV:
-  			        handle_sco_sv_client(hostname, clientclass, os, hinfo, sender, timestamp, restofmsg);
-				break;
-				
-			  case OS_WIN32: 
-			  case OS_SNMP: 
-			  case OS_UNKNOWN:
-				errprintf("No client backend for OS '%s' sent by %s\n", clientos, sender);
-				break;
+                                handle_sco_sv_client(hostname, clientclass, os, hinfo, sender, timestamp, restofmsg);
+                                break;
+
+                          case OS_WIN32_BBWIN:
+                                handle_win32_bbwin_client(hostname, clientclass, os, hinfo, sender, timestamp, restofmsg);
+                                break;
+
+                          case OS_WIN32:
+                          case OS_SNMP:
+                          case OS_UNKNOWN:
+                                errprintf("No client backend for OS '%s' sent by %s\n", clientos, sender);
+                                break;
 			}
 			combo_end();
 		}
diff -Naur /home/etienne/hobbit-4.2/hobbitd/rrd/do_disk.c ./hobbitd/rrd/do_disk.c
--- /home/etienne/hobbit-4.2/hobbitd/rrd/do_disk.c	2007-10-30 14:21:04.000000000 +0100
+++ ./hobbitd/rrd/do_disk.c	2007-12-27 13:54:50.000000000 +0100
@@ -2,6 +2,7 @@
 /* Hobbit RRD handler module.                                                 */
 /*                                                                            */
 /* Copyright (C) 2004-2006 Henrik Storner <henrik@hswn.dk>                    */
+/* Copyright (C) 2007 Francois Lacroix					      */
 /*                                                                            */
 /* This program is released under the GNU General Public License (GPL),       */
 /* version 2. See the file "COPYING" for details.                             */
@@ -16,7 +17,7 @@
 					rra1, rra2, rra3, rra4, NULL };
 	static char *disk_tpl      = NULL;
 
-	enum { DT_IRIX, DT_AS400, DT_NT, DT_UNIX, DT_NETAPP, DT_NETWARE } dsystype;
+	enum { DT_IRIX, DT_AS400, DT_NT, DT_UNIX, DT_NETAPP, DT_NETWARE, DT_BBWIN } dsystype;
 	char *eoln, *curline;
 	static int ptnsetup = 0;
 	static pcre *inclpattern = NULL;
@@ -48,6 +49,7 @@
 	else if (strstr(msg, "DASD")) dsystype = DT_AS400;
 	else if (strstr(msg, "NetWare Volumes")) dsystype = DT_NETWARE;
 	else if (strstr(msg, "NetAPP")) dsystype = DT_NETAPP;
+	else if (strstr(msg, "Summary")) dsystype = DT_BBWIN; /* Make sur it is a bbwin client v > 0.10 */
 	else if (strstr(msg, "Filesystem")) dsystype = DT_NT;
 	else dsystype = DT_UNIX;
 
@@ -83,6 +85,8 @@
 		 * Some Unix filesystem reports contain the word "Filesystem".
 		 * So check if there's a slash in the NT filesystem letter - if yes,
 		 * then it's really a Unix system after all.
+		 * Not always has BBWIN > 0.10 not give the information also on mounted disk.
+		 * (IE more than one letter)
 		 */
 		if ( (dsystype == DT_NT) && (*(columns[5])) &&
 		     ((strchr(columns[0], '/')) || (strlen(columns[0]) > 1)) )
@@ -112,6 +116,7 @@
 			pused = atoi(columns[columncount-1]);
 			aused = 0; /* Not available */
 			break;
+		  case DT_BBWIN:
 		  case DT_NT:
 			diskname = xmalloc(strlen(columns[0])+2);
 			sprintf(diskname, "/%s", columns[0]);
diff -Naur /home/etienne/hobbit-4.2/hobbitd/rrd/do_ifstat.c ./hobbitd/rrd/do_ifstat.c
--- /home/etienne/hobbit-4.2/hobbitd/rrd/do_ifstat.c	2007-10-30 14:21:04.000000000 +0100
+++ ./hobbitd/rrd/do_ifstat.c	2007-12-27 13:55:02.000000000 +0100
@@ -2,6 +2,7 @@
 /* Hobbit RRD handler module.                                                 */
 /*                                                                            */
 /* Copyright (C) 2005-2006 Henrik Storner <henrik@hswn.dk>                    */
+/* Copyright (C) 2007 Francois Lacroix					      */
 /*                                                                            */
 /* This program is released under the GNU General Public License (GPL),       */
 /* version 2. See the file "COPYING" for details.                             */
@@ -247,6 +248,10 @@
 		        if (pickdata(bol, ifstat_sco_sv_pcres[0], 0, &ifname, &rxstr, &txstr)) dmatch = 7;
 			break;
 			
+		  case OS_WIN32_BBWIN:
+                        if (pickdata(bol, ifstat_openbsd_pcres[0], 0, &ifname, &rxstr, &txstr)) dmatch = 7;
+                        break;
+			
 		  case OS_OSF:
 		  case OS_IRIX:
 		  case OS_SNMP:
diff -Naur /home/etienne/hobbit-4.2/hobbitd/rrd/do_netstat.c ./hobbitd/rrd/do_netstat.c
--- /home/etienne/hobbit-4.2/hobbitd/rrd/do_netstat.c	2007-10-30 14:21:04.000000000 +0100
+++ ./hobbitd/rrd/do_netstat.c	2007-12-27 13:55:14.000000000 +0100
@@ -2,6 +2,7 @@
 /* Hobbit RRD handler module.                                                 */
 /*                                                                            */
 /* Copyright (C) 2004-2006 Henrik Storner <henrik@hswn.dk>                    */
+/* Copyright (C) 2007 Francois Lacroix					      */
 /*                                                                            */
 /* This program is released under the GNU General Public License (GPL),       */
 /* version 2. See the file "COPYING" for details.                             */
@@ -512,6 +513,7 @@
 		break;
 
 	  case OS_WIN32:
+	  case OS_WIN32_BBWIN:
 		havedata = do_valaftermarkerequal(netstat_win32_markers, datapart, outp);
 		break;
 
diff -Naur /home/etienne/hobbit-4.2/hobbitd/rrd/do_vmstat.c ./hobbitd/rrd/do_vmstat.c
--- /home/etienne/hobbit-4.2/hobbitd/rrd/do_vmstat.c	2007-10-30 14:21:04.000000000 +0100
+++ ./hobbitd/rrd/do_vmstat.c	2007-12-27 13:55:24.000000000 +0100
@@ -2,6 +2,7 @@
 /* Hobbit RRD handler module.                                                 */
 /*                                                                            */
 /* Copyright (C) 2004-2006 Henrik Storner <henrik@hswn.dk>                    */
+/* Copyright (C) 2007 Francois Lacroix					      */
 /*                                                                            */
 /* This program is released under the GNU General Public License (GPL),       */
 /* version 2. See the file "COPYING" for details.                             */
@@ -338,6 +339,7 @@
 	  case OS_HPUX: 
 		layout = vmstat_hpux_layout; break;
 	  case OS_WIN32:
+	  case OS_WIN32_BBWIN:
 		errprintf("Cannot handle Win32 vmstat from host '%s' \n", hostname);
 		return -1;
 	  case OS_FREEBSD:
diff -Naur /home/etienne/hobbit-4.2/lib/misc.c ./lib/misc.c
--- /home/etienne/hobbit-4.2/lib/misc.c	2007-10-30 14:21:02.000000000 +0100
+++ ./lib/misc.c	2007-12-18 10:09:00.000000000 +0100
@@ -69,6 +69,7 @@
 	else if (strcasecmp(osname, "macosx") == 0)      result = OS_DARWIN;
 	else if (strcasecmp(osname, "darwin") == 0)      result = OS_DARWIN;
 	else if (strcasecmp(osname, "sco_sv") == 0)      result = OS_SCO_SV;
+	else if (strcasecmp(osname, "bbwin") == 0)      result = OS_WIN32_BBWIN;
 
 	if (result == OS_UNKNOWN) dbgprintf("Unknown OS: '%s'\n", osname);
 
@@ -94,6 +95,7 @@
 		case OS_IRIX: return "irix";
 		case OS_DARWIN: return "darwin";
 	        case OS_SCO_SV: return "sco_sv";
+		case OS_WIN32_BBWIN: return "bbwin";
 		case OS_UNKNOWN: return "unknown";
 	}
 
diff -Naur /home/etienne/hobbit-4.2/lib/misc.h ./lib/misc.h
--- /home/etienne/hobbit-4.2/lib/misc.h	2007-10-30 14:21:02.000000000 +0100
+++ ./lib/misc.h	2007-12-12 11:34:06.000000000 +0100
@@ -13,7 +13,7 @@
 
 #include <stdio.h>
 
-enum ostype_t { OS_UNKNOWN, OS_SOLARIS, OS_OSF, OS_AIX, OS_HPUX, OS_WIN32, OS_FREEBSD, OS_NETBSD, OS_OPENBSD, OS_LINUX22, OS_LINUX, OS_RHEL3, OS_SNMP, OS_IRIX, OS_DARWIN, OS_SCO_SV } ;
+enum ostype_t { OS_UNKNOWN, OS_SOLARIS, OS_OSF, OS_AIX, OS_HPUX, OS_WIN32, OS_FREEBSD, OS_NETBSD, OS_OPENBSD, OS_LINUX22, OS_LINUX, OS_RHEL3, OS_SNMP, OS_IRIX, OS_DARWIN, OS_SCO_SV , OS_WIN32_BBWIN } ;
 
 extern enum ostype_t get_ostype(char *osname);
 extern char *osname(enum ostype_t os);
