--- bgpq.c.orig	2006-04-08 04:45:19.000000000 +0400
+++ bgpq.c	2009-10-23 14:11:00.000000000 +0400
@@ -39,7 +39,7 @@
 /* from unistd.h on *BSD */
 extern int optreset;
 
-int debug, allroutes, quiet, noheader, no_expand_as=0, no_finish_in_main=0;
+int debug, allroutes, quiet, noheader, no_expand_as=0, no_finish_in_main=0, show_bad=0;
 int Quiet=0, invertLogic=0, addLog=0;
 
 char commandstring[2048];
@@ -48,10 +48,11 @@
 int
 usage()
 { 
-	printf("Usage: bgpq [-l name] [-h host] [-p port] [-d] [-Pijosge]|[-f number]|[-F format]|[-G number] [-aq] [-S src] [-H] [-c] [-R masklen] objects [EXCEPT objects]\n");
+	printf("Usage: bgpq [-l name] [-h host] [-p port] [-d] [-Pijosge]|[-f number]|[-F format]|[-G number] [-aq] [-S src] [-H] [-c] [-R masklen] [-b] objects [EXCEPT objects]\n");
 	printf("\tbgpq -r filename\n");
 	printf("\t-A - try to aggregate routes\n");
 	printf("\t-a - print all routes uncommented\n");
+	printf("\t-b - show unresolved ASes\n");
 	printf("\t-c - include commandline in output\n");
 	printf("\t-d - debugging\n");
 	printf("\t-e - generate standard access-list\n");
@@ -159,11 +160,14 @@
 		strncat(commandstring," ",sizeof(commandstring)-1);
 	};
 		
-	while((c=getopt(argc,argv,"Aaqh:p:l:dPiIosgG:S:eNHcf:F:O:R:r:jJQL"))!=EOF){ 
+	while((c=getopt(argc,argv,"Aabqh:p:l:dPiIosgG:S:eNHcf:F:O:R:r:jJQL"))!=EOF){ 
 	switch(c) { 
 		case 'A': 
 			do_aggregate=1;
 			break;
+		case 'b':
+			show_bad=1;
+			break;
 		case 'l': 
 			listname=optarg;
 			if(!check_is_word(listname)) { 
@@ -401,12 +405,30 @@
 
 	if(!expand(ro,host,port,excp,source)) exit(1);
 
-	if(refine) 
+	if(refine)  {
+		if(!quiet)
+		    fprintf(stderr, "Refining...");
+
 		ro_refinery(ro,refine);
 
-	if(do_aggregate) 
+		if(!quiet)
+		    fprintf(stderr, " done\n");
+	}
+
+
+	if(do_aggregate) {
+		if(!quiet)
+		    fprintf(stderr, "Aggregating...");
+		
 		ro_aggregate(&ro,mode);
 
+		if(!quiet)
+		    fprintf(stderr, " done\n");
+	}
+
+	if(!quiet)
+	    fprintf(stderr, "Output results...\n");
+
 	if(!outfile) outfile=stdout;
 
 	if(debug>3) 
--- ro.c.orig	2007-10-05 14:01:29.000000000 +0400
+++ ro.c	2009-10-23 14:59:11.000000000 +0400
@@ -27,7 +27,7 @@
 int route2ro(struct ro* queue,char* text, struct ro* ra, char* as);
 
 /* struct ro* ro_head=NULL; */
-extern int debug, allroutes, quiet, no_expand_as, Quiet, invertLogic, addLog;
+extern int debug, allroutes, quiet, no_expand_as, Quiet, invertLogic, addLog, show_bad;
 
 static int ases=0, asmcs=0, routes=0;
 static struct irrdc* ir=NULL;
@@ -172,7 +172,7 @@
 	if(ntohl(ra->addr) <= ntohl(rb->addr) && 
 		ntohl(ra->lastaddr) >= ntohl(rb->lastaddr)) { 
 		rb->flag|=RO_OVL;
-		if(ra->as && rb->as && !strcasecmp(ra->as,rb->as)) 
+		if(ra->as && rb->as && !strcmp(ra->as,rb->as)) 
 			 return -2;
 		return -1;
 	};
@@ -180,7 +180,7 @@
 	if(ntohl(ra->addr) >= ntohl(rb->addr) && 
 		ntohl(ra->lastaddr) <= ntohl(rb->lastaddr)) {
 		ra->flag|=RO_OVL;
-		if(ra->as && rb->as && !strcasecmp(ra->as,rb->as)) 
+		if(ra->as && rb->as && !strcmp(ra->as,rb->as)) 
 			return 2;
 		return 1;
 	};
@@ -275,6 +275,7 @@
 	char* c;
 	int mle;
 	int needenq=0;
+	int i, n;
 	struct ro* rb, *rc;
 	char buffer[512];
 
@@ -285,7 +286,12 @@
 		bzero(ra,sizeof(struct ro));
 		ra->text=strdup(text);
 		ra->type=RO_RO;
-		if(as) ra->as=strdup(as);
+		if(as) {
+		    n = strlen(as);
+		    for(i=0; i<n; i++)
+			as[i] = tolower(as[i]);
+		    ra->as=strdup(as);
+		}
 		needenq=1;
 	};
 	c=text;
@@ -335,7 +341,7 @@
 				return 0;
 			case 2:
 				/* ra << rb */
-				if(((ra->as && rb->as && !strcasecmp(ra->as, rb->as)) 
+				if(((ra->as && rb->as && !strcmp(ra->as, rb->as)) 
 					|| (!ra->as && !rb->as)) && !ra->ovl) { 
 					snprintf(buffer,sizeof(buffer)-1,
 						"overlayed by %s in the same %s", rb->text, 
@@ -348,7 +354,7 @@
 				return 1;
 			case -2: 
 				
-				if(((ra->as && rb->as && !strcasecmp(ra->as, rb->as)) || 
+				if(((ra->as && rb->as && !strcmp(ra->as, rb->as)) || 
 					(!ra->as && !rb->as)) && !rb->ovl) { 
 					snprintf(buffer,sizeof(buffer)-1,
 						"overlayed by %s in the same %s", 
@@ -369,7 +375,7 @@
 				while(rc) { 
 					int cmpr=ro_sort(rc,ra);
 					if(cmpr!=2) return 1;
-					if(((ra->as && rc->as && !strcasecmp(ra->as, rc->as)) 
+					if(((ra->as && rc->as && !strcmp(ra->as, rc->as)) 
 						|| (!ra->as && !rc->as)) && !rc->ovl) { 
 						snprintf(buffer,sizeof(buffer)-1,
 							"overlayed by %s in the same %s", ra->text, 
@@ -407,7 +413,7 @@
 { 
 	struct irrdc* ir;
 
-	if(!(ir=irrd_init(host,port))) { 
+	if(!(ir=irrd_init(host,port,source))) { 
 		perror("!irrd_init");
 		return NULL;
 	};
@@ -416,12 +422,6 @@
 		return NULL;
 	};
 
-	if(source && strlen(source)) { 
-		if(!irrd_question(ir,"!s%s",source)) { 
-			perror("!Can't set source");
-			return NULL;
-		};
-	};
 	return ir;
 };
 
@@ -430,6 +430,8 @@
 { 
 	char* c,*d;
 	struct ro* ra;
+	char disp[] = "|/-\\";
+	unsigned int asn=0, i=0;
 
 	if(!ro_head) { 
 		if(debug) SX_TRACE2("Nothing to expand...\n");
@@ -439,6 +441,8 @@
 
 	ra=ro_head;
 
+	if(!debug && !quiet)
+	    fprintf(stderr, "Starting expansion...\n");
 	while(ra) { 
 		if(ra->type==RO_RO || ra->type==RO_RPSL) { 
 /*			route2ro(ra->text,ra,NULL); */
@@ -460,7 +464,19 @@
 			};
 			if(ir->answer) { 
 				c=ir->answer;
+				if(!debug && !quiet) {
+				    fprintf(stderr, "\rAS #%u of %u %c", ++asn, ases, disp[i++]);
+				    fflush(stderr);
+				    if(i == sizeof(disp)-1)
+					i=0;
+				}
 nextro:
+				if(!debug && !quiet) {
+				    fprintf(stderr, "\b%c", disp[i++]);
+				    fflush(stderr);
+				    if(i == sizeof(disp)-1)
+					i=0;
+				}
 				while(isspace((int)*c)) c++;
 				d=c;
 				while(!isspace((int)*c)) c++;
@@ -468,8 +484,17 @@
 				if(!excep || !ro_exists(excep,d)) 
 					route2ro(ro_head,d,NULL,ra->text);
 				if(*(c+1)!=0) { c++; goto nextro; };
+				if(!debug && !quiet) {
+				    fprintf(stderr, "\b ");
+				    fflush(stderr);
+				}
+			} else {
+				if(show_bad)
+				    fprintf(stderr, "%s - there is no such key in WHOIS database\n", ra->text);
 			};
 		} else if(ra->type==RO_MC) { 
+			if(!debug && !quiet)
+			    fprintf(stderr, "MC: %s\n", ra->text);
 			if(!ir) { 
 				ir=ir_init(host,port,source);
 				if(!ir) { 
@@ -515,6 +540,8 @@
 nextra:
 		ra=ra->next;
 	};
+	if(!debug && !quiet)
+	    fprintf(stderr, "\nFinished\n");
 	return 1;
 };
 
--- irrdi.h.orig	2005-06-23 11:53:56.000000000 +0400
+++ irrdi.h	2009-10-23 15:04:44.000000000 +0400
@@ -1,28 +1,22 @@
 #include <sys/types.h>
 #include <netinet/in.h>
 
-struct irrdcentry { 
-	char* qwes;
-	char* answer;
-	struct irrdcentry* next;
-};
-
 struct irrdc { 
 	char* host;
 	int port;
 	int s;
 	char* answer;
 	struct irrdcentry* cache;
-	FILE* f;
 #if HAVE_GETADDRINFO
 	struct addrinfo* res;
 #else
 	struct sockaddr_in sca;
 #endif
+	char* source;
 };
 
 
-struct irrdc* 	irrd_init(char* host,int port);
+struct irrdc* 	irrd_init(char* host,int port,char* source);
 int		irrd_connect(struct irrdc*);
 int		irrd_question(struct irrdc*, char* fmt, ...);
 int		irrd_disc(struct irrdc*);
--- irrdi.c.orig	2005-06-23 11:53:56.000000000 +0400
+++ irrdi.c	2009-10-23 15:26:21.000000000 +0400
@@ -65,13 +65,14 @@
 #endif
 
 struct irrdc* 
-irrd_init(char* host, int port)
+irrd_init(char* host, int port, char* source)
 { 
 	struct irrdc* ir=malloc(sizeof(struct irrdc));
 	if(!ir) return NULL;
 	bzero(ir,sizeof(struct irrdc));
 	if(host) ir->host=strdup(host);
 	if(port) ir->port=port;
+	if(source) ir->source=strdup(source);
 	ir->s=-1;
 
 	if(host&&port) { 
@@ -105,46 +106,6 @@
 	return ir;
 };
 
-struct irrdcentry*
-irrd_cache_find(struct irrdc* ir, char* q)
-{ 
-	struct irrdcentry* ic;
-	if(!ir||!q) return NULL;
-
-	ic=ir->cache;
-	while(ic) { 
-		if(ic->qwes && !strcmp(ic->qwes,q)) return ic;
-		ic=ic->next;
-	};
-	return NULL;
-};
-
-int
-irrd_cache_add(struct irrdc* ir, char* q, char* ans)
-{ 
-	struct irrdcentry* ic, *id;
-	if(!ir || !q || !ans) return 0;
-
-	ic=malloc(sizeof(struct irrdcentry));
-	if(!ic) return 0;
-
-	bzero(ic,sizeof(struct irrdcentry));
-	ic->qwes=strdup(q);
-	ic->answer=strdup(ans);
-
-	if(!ir->cache) { 
-		ir->cache=ic;
-		return 1;
-	};
-	
-	id=ir->cache;
-
-	while(id->next) id=id->next;
-
-	id->next=ic;
-	
-	return 1;
-};
 int
 irrd_connect(struct irrdc* ir)
 { 
@@ -191,24 +152,30 @@
 		};
 	};
 #endif
-	ir->f=fdopen(ir->s,"a+");
 	if(debug>2) { 
 		SX_TRACE2("sending !!");
 	};
-	fseek(ir->f,0,SEEK_END);
-	fwrite("!!\n",3,1,ir->f);
+	write(ir->s, "!!\n",3);
+
+	if(ir->source && strlen(ir->source)) {
+	    	if(!irrd_question(ir,"!s%s",ir->source)) {
+		    	perror("!Can't set source");
+			return 0;
+		};
+	};
 
 	return 1;
 };
 
 int
 irrd_question(struct irrdc* ir, char* quest, ...)
-{ 
+{
 	va_list ap;
 	char qbuff[512];
 	char rbuff[2048];
-	int len;
-	struct irrdcentry* ice;
+	char *p;
+	size_t len, n;
+	int need_copy=0, retries = 0, i, success;
 
 	memset(qbuff,0,sizeof(qbuff));
 	va_start(ap,quest);
@@ -217,79 +184,115 @@
 
 	va_end(ap);
 
-	if(ir->answer) free(ir->answer);
-	ir->answer=NULL;
-
-	if(debug>2)  
-		SX_TRACE2("checking cache for %s", qbuff);
-
-	if((ice=irrd_cache_find(ir,qbuff))) { 
-		if(debug>2) 
-			SX_TRACE2("oki, found cached entry");
-		
-		ir->answer=strdup(ice->answer);
-		return 1;
-	};
-
-	if(debug>2) 
-		SX_TRACE2("sending %s", qbuff);
-
-	fseek(ir->f,0,SEEK_END);
-	fwrite(qbuff,strlen(qbuff),1,ir->f);
-	fwrite("\n",1,1,ir->f);
-	fflush(ir->f);
-
-	if(!fgets(rbuff,sizeof(rbuff),ir->f)) { 
-		SX_TRACE2("error reading from socket: %i %s",errno,
-			strerror(errno));
-		if(ferror(ir->f)) { 
-			SX_ERROR("fgets ferror: %i",ferror(ir->f));
-		};
-		if(feof(ir->f)) { 
-			SX_ERROR("fgets feof: %i",ferror(ir->f));
-		};
+	while (1) {
+	    if(ir->answer) free(ir->answer);
+	    ir->answer=NULL;
+
+	    if(debug>2) 
+		    SX_TRACE2("sending %s", qbuff);
+
+	    if(!retries)
+		strcat(qbuff, "\n");
+	    if (write(ir->s, qbuff, strlen(qbuff)) != strlen(qbuff))
+		    goto errlab;
+
+	    if((n = read(ir->s, rbuff, sizeof(rbuff)))<=0)
+		    goto errlab;
+	    
+	    p = strchr(rbuff, '\n');
+
+	    if (!p) 
+		goto errlab;
+
+	    *p++ = '\0';
+	    if(n > strlen(rbuff)+1)
+		need_copy=1;
+
+	    if(debug>2) 
+		    SX_TRACE2("Answer is %s", rbuff);
+
+	    switch(rbuff[0]) { 
+		    case 'A': 
+			    len=atoi(rbuff+1);
+			    ir->answer=malloc(len+1);
+			    if(!ir->answer) { 
+				    return 0;
+			    };
+			    bzero(ir->answer,len+1);
+
+			    if(debug>2) 
+				    SX_TRACE2("Waiting for %i data bytes",len);
+
+			    if(need_copy) {
+				n -= strlen(rbuff)+1;
+				if(n > len) {
+				    need_copy = n - len;
+				    n = len;
+				} else
+				    need_copy=0;
+				bcopy(p, ir->answer, n);
+				p+=n;
+				if(debug>2)
+				    SX_TRACE2("Copy %d bytes", n);
+			    } else
+				n = 0;
+
+			    while(n < len) {
+				size_t nn;
+				nn = read(ir->s, ir->answer + n, len-n);
+				if (nn<=0)
+				    goto errlab;
+				n += nn;
+			    }
+			    
+			    if(debug>2) 
+				    SX_TRACE2("Got %s",ir->answer);
+
+			    if(need_copy) {
+				if(debug>2)
+				    SX_TRACE2("Copy %d bytes", need_copy);
+				bcopy(p, rbuff, need_copy);
+			    } else {
+				n = read(ir->s, rbuff, sizeof(rbuff));
+				if (n <= 0)
+				    goto errlab;
+			    }
+			    p = strchr(rbuff, '\n');
+			    *p = '\0';
+			    if(debug>2) 
+				    SX_TRACE2("And resulting control code is %s", rbuff);
+
+			    if(rbuff[0]!='C') { 
+				    /* smth strange.. :( */
+				    return 0;
+			    };
+			    break;
+		    case 'C': /* query successfull, no data */
+		    case 'D': /* no such key */
+			    break;
+		    case 'E': /* multiple keys */
+		    case 'F': /* another error.. */
+			    return 0;
+		    default:
+			    return 0;
+	    };
+
+	    break;
+errlab:
+	    if (retries++ > 3)
+		    break; 
+	    success=0;
+	    for(i=0; i<3; i++) {
+		SX_TRACE2("trying to reconnect");
+		sleep(3);
+		if(irrd_connect(ir)) {
+		    success=1;
+		    break;
+		}
+	    }
+	    if(!success)
 		return 0;
-	};
-
-	if(debug>2) 
-		SX_TRACE2("Answer is %s", rbuff);
-
-	switch(rbuff[0]) { 
-		case 'A': 
-			len=atoi(rbuff+1);
-			ir->answer=malloc(len+1);
-			if(!ir->answer) { 
-				return 0;
-			};
-			bzero(ir->answer,len+1);
-
-			if(debug>2) 
-				SX_TRACE2("Waiting for %i data bytes..",len);
-
-			fread(ir->answer,1,len,ir->f);
-			
-			if(debug>2) 
-				SX_TRACE2("Got %s",ir->answer);
-
-			fgets(rbuff,sizeof(rbuff),ir->f);
-			if(debug>2) 
-				SX_TRACE2("And resulting control code is %s", rbuff);
-
-			if(rbuff[0]!='C') { 
-				/* smth strange.. :( */
-				return 0;
-			};
-			irrd_cache_add(ir,qbuff,ir->answer);
-			break;
-		case 'C': /* query successfull, no data */
-		case 'D': /* no such key */
-			break;
-		case 'E': /* multiple keys */
-		case 'F': /* another error.. */
-			return 0;
-		default:
-			return 0;
-	};
+   	}
 	return 1;
 };
 
@@ -302,9 +305,7 @@
 	if(debug>2) { 
 		SX_TRACE2("sending !q");
 	};
-	fseek(ir->f,0,SEEK_END);
-	fprintf(ir->f,"!q\n");
-	fclose(ir->f);
+	write(ir->s, "!q\n", 3);
 	close(ir->s);
 	return 1;
 };
