--- gcc/c-format.c.orig	Sun Nov 25 10:54:11 2001
+++ gcc/c-format.c	Sat Feb  2 19:04:24 2002
@@ -82,12 +82,15 @@
   enum format_type format_type;	/* type of format (printf, scanf, etc.) */
   unsigned HOST_WIDE_INT format_num;	/* number of format argument */
   unsigned HOST_WIDE_INT first_arg_num;	/* number of first arg (zero for varargs) */
+  /* int null_format_ok; */	/* TRUE if the format string may be NULL */
 } function_format_info;
 
 static bool decode_format_attr		PARAMS ((tree,
 						 function_format_info *, int));
 static enum format_type decode_format_type	PARAMS ((const char *));
 
+/* inline static int get_null_fmt_ok	PARAMS ((enum format_type)); */
+
 /* Handle a "format" attribute; arguments as in
    struct attribute_spec.handler.  */
 tree
@@ -97,6 +100,7 @@
      tree args;
      int flags;
      bool *no_add_attrs;
+     /* int null_format_ok; */
 {
   tree type = *node;
   function_format_info info;
@@ -257,6 +261,7 @@
       const char *p = IDENTIFIER_POINTER (format_type_id);
 
       info->format_type = decode_format_type (p);
+      /* info->null_format_ok = get_null_fmt_ok (format_type); */
 
       if (info->format_type == format_type_error)
 	{
@@ -292,6 +297,7 @@
 
   info->format_num = TREE_INT_CST_LOW (format_num_expr);
   info->first_arg_num = TREE_INT_CST_LOW (first_arg_num_expr);
+  /* info->null_format_ok = TREE_INT_CST_LOW (null_format_ok); */
   if (info->first_arg_num != 0 && info->first_arg_num <= info->format_num)
     {
       if (validated_p)
@@ -540,6 +546,8 @@
   /* Pointer to type of argument expected if '*' is used for a precision,
      or NULL if '*' not used for precisions.  */
   tree *const precision_type;
+  /* Needed for FreeBSD kernel and the printf0() printf-like function.  */
+  /* int null_format_ok; */
 } format_kind_info;
 
 
@@ -765,6 +773,20 @@
 
 static const format_char_info print_char_table[] =
 {
+#warning The FreeBSD kernel extensions in print_char_table might not be done correctly.
+/* FreeBSD kernel extensions (src/sys/kern/subr_prf.c).  */
+/* The format %b is supported to decode error registers.
+   Its usage is:	printf("reg=%b\n", regval, "<base><arg>*");
+   which produces:	reg=3<BITTWO,BITONE>
+   The format %D provides a hexdump given a pointer and separator string:
+   ("%6D", ptr, ":")		-> XX:XX:XX:XX:XX:XX
+   ("%*D", len, ptr, " ")	-> XX XX XX XX ...
+   */
+  { "D",   1, STD_EXT, { T89_C,   T89_C,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, "-wp",      "c" },
+  { "b",   1, STD_EXT, { T89_C,   T89_C,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, "-wp",      "" },
+  { "rz",  0, STD_EXT, { BADLEN,  T89_I,   T89_I,   T89_L,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, "-wp0 +#",  "i" },
+#define unextended_print_char_table	(print_char_table + 3)
+#warning The FreeBSD kernel extensions in print_char_table might not be done correctly.
   /* C89 conversion specifiers.  */
   { "di",  0, STD_C89, { T89_I,   T99_SC,  T89_S,   T89_L,   T9L_LL,  TEX_LL,  T99_SST, T99_PD,  T99_IM  }, "-wp0 +'I", "i"  },
   { "oxX", 0, STD_C89, { T89_UI,  T99_UC,  T89_US,  T89_UL,  T9L_ULL, TEX_ULL, T99_ST,  T99_UPD, T99_UIM }, "-wp0#",    "i"  },
@@ -848,23 +870,36 @@
     FMT_FLAG_ARG_CONVERT|FMT_FLAG_DOLLAR_MULTIPLE|FMT_FLAG_USE_DOLLAR|FMT_FLAG_EMPTY_PREC_OK,
     'w', 0, 'p', 0, 'L',
     &integer_type_node, &integer_type_node
+    /* ,0 */
   },
   { "scanf",    scanf_length_specs,   scan_char_table,  "*'I", NULL, 
     scanf_flag_specs, scanf_flag_pairs,
     FMT_FLAG_ARG_CONVERT|FMT_FLAG_SCANF_A_KLUDGE|FMT_FLAG_USE_DOLLAR|FMT_FLAG_ZERO_WIDTH_BAD|FMT_FLAG_DOLLAR_GAP_POINTER_OK,
     'w', 0, 0, '*', 'L',
     NULL, NULL
+    /* ,0 */
   },
   { "strftime", NULL,                 time_char_table,  "_-0^#", "EO",
     strftime_flag_specs, strftime_flag_pairs,
     FMT_FLAG_FANCY_PERCENT_OK, 'w', 0, 0, 0, 0,
     NULL, NULL
+    /* ,0 */
   },
   { "strfmon",  strfmon_length_specs, monetary_char_table, "=^+(!-", NULL, 
     strfmon_flag_specs, strfmon_flag_pairs,
     FMT_FLAG_ARG_CONVERT, 'w', '#', 'p', 0, 'L',
     NULL, NULL
+    /* ,0 */
   }
+  /*
+  { "printf0",   printf_length_specs,  print_char_table, " +#0-'I", NULL, 
+    printf_flag_specs, printf_flag_pairs,
+    FMT_FLAG_ARG_CONVERT|FMT_FLAG_DOLLAR_MULTIPLE|FMT_FLAG_USE_DOLLAR|FMT_FLAG_EMPTY_PREC_OK,
+    'w', 0, 'p', 0, 'L',
+    &integer_type_node, &integer_type_node
+    ,1
+  },
+  */
 };
 
 
@@ -917,6 +952,16 @@
 
 static void check_format_types	PARAMS ((int *, format_wanted_type *));
 
+
+/*
+inline static int get_null_fmt_ok (fmttype)
+	enum format_type fmttype;
+{
+  return format_types[(int)fmttype].null_format_ok;
+}
+*/
+
+
 /* Decode a format type from a string, returning the type, or
    format_type_error if not valid, in which case the caller should print an
    error message.  */
@@ -1475,7 +1520,7 @@
 	 specially if info == NULL and add a res->number_null entry for
 	 that case, or maybe add a function pointer to be called at
 	 the end instead of hardcoding check_format_info_main.  */
-      status_warning (status, "null format string");
+      /*if (!info->null_format_ok)*/ status_warning (status, "null format string");
 
       /* Skip to first argument to check, so we can see if this format
 	 has any arguments (it shouldn't).  */
@@ -1710,6 +1755,54 @@
 	      main_arg_num = opnum + info->first_arg_num - 1;
 	    }
 	}
+      if (*format_chars == 'b')
+	{
+	  /* There should be an int arg to control the string arg.  */
+	  if (params == 0)
+	    {
+	      status_warning (status, "too few arguments for format");
+	      return;
+	    }
+	    if (info->first_arg_num != 0)
+	    {
+	      cur_param = TREE_VALUE (params);
+	      params = TREE_CHAIN (params);
+	      ++arg_num;
+	      if ((TYPE_MAIN_VARIANT (TREE_TYPE (cur_param))
+		   != integer_type_node)
+		  &&
+		  (TYPE_MAIN_VARIANT (TREE_TYPE (cur_param))
+		   != unsigned_type_node))
+		{
+		  status_warning (status, "bitmap is not type int (arg %d)", arg_num);
+		}
+	    }
+	}
+      if (*format_chars == 'D')
+	{
+	  /* There should be an unsigned char * arg before the string arg.  */
+	  if (params == 0)
+	    {
+	      status_warning (status, "too few arguments for format");
+	      return;
+	    }
+	    if (info->first_arg_num != 0)
+	    {
+	      tree cur_type;
+	      cur_param = TREE_VALUE (params);
+	      params = TREE_CHAIN (params);
+	      ++arg_num;
+	      cur_type = TREE_TYPE (cur_param);
+	      if (TREE_CODE (cur_type) != POINTER_TYPE
+		  || TYPE_MAIN_VARIANT (TREE_TYPE (cur_type))
+		     != unsigned_char_type_node)
+		{
+		  status_warning (status,
+			  "ethernet address is not type unsigned char * (arg %d)",
+			   arg_num);
+		}
+	    }
+	}
 
       /* Read any format flags, but do not yet validate them beyond removing
 	 duplicates, since in general validation depends on the rest of
@@ -2113,7 +2206,7 @@
 	  else if (strchr (fci->flags2, '2') != 0)
 	    y2k_level = 2;
 	  if (y2k_level == 3)
-	    status_warning (status, "`%%%c' yields only last 2 digits of year in some locales",
+	    status_warning (status, "`%%%c' yields only last 2 digits of year in some locales on non-BSD systems",
 			    format_char);
 	  else if (y2k_level == 2)
 	    status_warning (status, "`%%%c' yields only last 2 digits of year", format_char);
