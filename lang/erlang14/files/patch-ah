--- lib/os_mon/c_src/cpu_sup.c.orig	Sat Dec  2 22:12:38 2000
+++ lib/os_mon/c_src/cpu_sup.c	Sat Dec  2 22:47:11 2000
@@ -26,7 +26,14 @@
  */
 
 #include<stdio.h>
+#ifdef __FreeBSD__
+#include <sys/types.h>
+#include <sys/sysctl.h>
+#include <sys/param.h>
+#include <sys/user.h>
+#else
 #include<kstat.h>
+#endif
 
 #define FD_IN    0
 #define FD_OUT   1
@@ -45,20 +52,23 @@
 static void send(unsigned int data);
 static void error(char* err_msg);
 
+#ifndef __FreeBSD__
 static kstat_ctl_t *kc;
 static kstat_t *ks;
+#endif
 
 int main(int argc, char** argv) {
-  kid_t kid;
   char cmd;
   int rc;
+#ifndef __FreeBSD__
+  kid_t kid;
 
   kc = kstat_open();
   if(!kc) error("Can't open header kstat");
 
   ks = kstat_lookup(kc,"unix",0,"system_misc");
   if(!ks) error("Can't open system_misc kstat");
-
+#endif
 
   while(1) {
     rc = read(FD_IN, &cmd, sizeof(cmd));
@@ -79,6 +89,32 @@
 }
 
 static unsigned int measure(char* name) {
+#ifdef __FreeBSD__
+  size_t len;
+  int mib[3];
+  if (!strcmp (name, "nproc")) {
+    mib[0] = CTL_KERN;
+    mib[1] = KERN_PROC;
+    mib[2] = KERN_PROC_ALL;
+    sysctl(mib, 3, NULL, &len, NULL, 0);
+    return len/sizeof(struct kinfo_proc);
+  } else {
+    struct loadavg load;
+    mib[0] = CTL_VM;
+    mib[1] = VM_LOADAVG;
+    len = sizeof load;
+    sysctl(mib, 2, &load, &len, NULL, 0);
+    if (!strcmp (name, "avenrun_1min")) {
+      return load.ldavg[0] * 256 / load.fscale;
+    } else if (!strcmp (name, "avenrun_5min")) {
+      return load.ldavg[1] * 256 / load.fscale;
+    } else if (!strcmp (name, "avenrun_15min")) {
+      return load.ldavg[2] * 256 / load.fscale;
+    } else {
+      return -1;
+    }
+  }
+#else
   kstat_named_t* entry;
 
   kstat_read(kc,ks,NULL);
@@ -90,6 +126,7 @@
     return -1;
 
   return entry->value.ul;
+#endif
 }
 
 static void send(unsigned int data) {
