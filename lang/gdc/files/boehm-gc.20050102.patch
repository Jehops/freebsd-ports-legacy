--- doc/gc.man.orig	Mon Oct  8 10:23:01 2001
+++ doc/gc.man	Mon Oct  8 10:28:31 2001
@@ -9,7 +9,7 @@
 ... malloc(...) ...
 .br
 .sp
-cc ... gc.a
+cc ... -lgc
 .LP
 .SH DESCRIPTION
 .I GC_malloc
@@ -67,6 +67,48 @@
 This may temporarily write protect pages in the heap.  See the README file for more information on how this interacts with system calls that write to the heap.
 .LP
 Other facilities not discussed here include limited facilities to support incremental collection on machines without appropriate VM support, provisions for providing more explicit object layout information to the garbage collector, more direct support for ``weak'' pointers, support for ``abortable'' garbage collections during idle time, etc.
+.LP
+.SH "PORT INFORMATION"
+.LP
+In this (FreeBSD package) installation,
+.I gc.h
+and
+.I gc_cpp.h
+will probably be found in
+.I %%PREFIX%%/include,
+and the library in
+.I %%PREFIX%%/lib.
+.LP
+This library has been compiled as drop-in replacements
+for malloc and free (which is to say, all malloc
+calls will allocate garbage-collectable data).
+There is no need to include "gc.h" in your C files unless you want
+access to the debugging (and other) functions defined there,
+or unless you want to explicitly use
+.I GC_malloc_uncollectable
+for some allocations.
+Just link against them whenever you want either garbage
+collection or leak detection.
+.LP
+The C++ header file, "gc_cpp.h",
+.I is
+necessary for C++ programs, to obtain the appropriate
+definitions of the
+.I new
+and
+.I delete
+operators.
+The comments in both of these header files presently
+provide far better documentation
+for the package than this man page;
+look there for more information.
+.LP
+This library is compiled without (explicit) support
+for the experimental
+.I gc
+extension of
+.I g++.
+This may or may not make a difference.
 .LP
 .SH "SEE ALSO"
 The README and gc.h files in the distribution.  More detailed definitions of the functions exported by the collector are given there.  (The above list is not complete.)
--- dbg_mlc.c.orig	Tue May 13 16:59:49 2003
+++ dbg_mlc.c	Wed May 12 20:13:19 2004
@@ -414,6 +414,23 @@
     GC_register_displacement((word)sizeof(oh) + offset);
 }
 
+#if defined(__FreeBSD__)
+#include <dlfcn.h>
+static void GC_caller_func_offset(ad, symp, offp)
+const GC_word ad;
+const char **symp;
+int *offp;
+{
+    Dl_info caller;
+    if (dladdr((const void *)ad, &caller) && caller.dli_sname != NULL) {
+      *symp = caller.dli_sname;
+      *offp = (const char *)ad - (const char *)caller.dli_saddr;
+    }
+}
+#else
+#define GC_caller_func(ad, symp, offp)
+#endif
+
 # ifdef __STDC__
     GC_PTR GC_debug_malloc(size_t lb, GC_EXTRA_PARAMS)
 # else
@@ -428,6 +445,13 @@
 {
     GC_PTR result = GC_malloc(lb + DEBUG_BYTES);
     
+#ifdef GC_ADD_CALLER
+    if (s == NULL) {
+      GC_caller_func_offset(ra, &s, &i);
+      if (s == NULL)
+        s = "unknown";
+    }
+#endif
     if (result == 0) {
         GC_err_printf1("GC_debug_malloc(%ld) returning NIL (",
         	       (unsigned long) lb);
@@ -789,6 +813,13 @@
     register size_t old_sz;
     register hdr * hhdr;
     
+#ifdef GC_ADD_CALLER
+    if (s == NULL) {
+      GC_caller_func_offset(ra, &s, &i);
+      if (s == NULL)
+        s = "unknown";
+    }
+#endif
     if (p == 0) return(GC_debug_malloc(lb, OPT_RA s, i));
     if (base == 0) {
         GC_err_printf1(
@@ -1094,7 +1125,11 @@
 }
 
 #ifdef GC_ADD_CALLER
-# define RA GC_RETURN_ADDR,
+# ifdef GC_RETURN_ADDR_PARENT
+#  define RA GC_RETURN_ADDR_PARENT,
+# else
+#  define RA GC_RETURN_ADDR,
+# endif
 #else
 # define RA
 #endif
@@ -1102,12 +1137,12 @@
 GC_PTR GC_debug_malloc_replacement(lb)
 size_t lb;
 {
-    return GC_debug_malloc(lb, RA "unknown", 0);
+    return GC_debug_malloc(lb, RA NULL, 0);
 }
 
 GC_PTR GC_debug_realloc_replacement(p, lb)
 GC_PTR p;
 size_t lb;
 {
-    return GC_debug_realloc(p, lb, RA "unknown", 0);
+    return GC_debug_realloc(p, lb, RA NULL, 0);
 }
--- doc/Makefile.in.orig	Sun Apr 20 01:19:11 2003
+++ doc/Makefile.in	Sun Apr 20 01:19:15 2003
@@ -46,7 +46,7 @@
 mandir = @mandir@
 includedir = @includedir@
 oldincludedir = /usr/include
-pkgdatadir = $(datadir)/@PACKAGE@
+pkgdatadir = $(datadir)/doc/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 top_builddir = ..
--- dyn_load.c.orig	Thu May  6 08:03:06 2004
+++ dyn_load.c	Sun Oct 31 01:53:01 2004
@@ -97,6 +97,12 @@
 #      else
 #        define ElfW(type) Elf64_##type
 #      endif
+#    elif defined(__FreeBSD__)
+#      if __ELF_WORD_SIZE == 32
+#        define ElfW(type) Elf32_##type
+#      else
+#        define ElfW(type) Elf64_##type
+#      endif
 #    else
 #      if !defined(ELF_CLASS) || ELF_CLASS == ELFCLASS32
 #        define ElfW(type) Elf32_##type
--- include/gc.h.orig	Wed Jun  4 17:07:33 2003
+++ include/gc.h	Wed May 12 20:03:22 2004
@@ -487,6 +487,7 @@
     /* gcc knows how to retrieve return address, but we don't know */
     /* how to generate call stacks.				   */
 #   define GC_RETURN_ADDR (GC_word)__builtin_return_address(0)
+#   define GC_RETURN_ADDR_PARENT (GC_word)__builtin_return_address(1)
 # else
     /* Just pass 0 for gcc compatibility. */
 #   define GC_RETURN_ADDR 0
--- include/private/gcconfig.h.orig	Wed Dec 29 22:30:21 2004
+++ include/private/gcconfig.h	Wed Dec 29 22:30:39 2004
@@ -328,6 +328,10 @@
 #    define X86_64
 #    define mach_type_known
 # endif
+# if defined(__FreeBSD__) && defined(__amd64__)
+#    define X86_64
+#    define mach_type_known
+# endif
 # if defined(FREEBSD) && defined(__sparc__)
 #    define SPARC
 #    define mach_type_known
@@ -1942,6 +1946,12 @@
 #	define HEURISTIC2
 	extern char etext[];
 #	define SEARCH_FOR_DATA_START
+#   endif
+#   ifdef FREEBSD
+#     define OS_TYPE "FREEBSD"
+#     ifdef __ELF__
+#         define DYNAMIC_LOADING
+#     endif
 #   endif
 # endif
 
--- include/gc_cpp.h.orig	Thu Oct 14 12:19:56 2004
+++ include/gc_cpp.h	Thu Oct 14 12:20:15 2004
@@ -276,7 +276,7 @@
     else
         return GC_MALLOC_UNCOLLECTABLE( size );}
 
-inline void* gc::operator new( size_t size, void *p ) {
+inline void* gc::operator new( size_t, void *p ) {
     return p;}
 
 inline void gc::operator delete( void* obj ) {
@@ -294,7 +294,7 @@
 inline void* gc::operator new[]( size_t size, GCPlacement gcp ) {
     return gc::operator new( size, gcp );}
 
-inline void* gc::operator new[]( size_t size, void *p ) {
+inline void* gc::operator new[]( size_t, void *p ) {
     return p;}
 
 inline void gc::operator delete[]( void* obj ) {
--- os_dep.c.orig	Sat Dec 18 10:42:19 2004
+++ os_dep.c	Wed Dec 29 22:48:03 2004
@@ -699,7 +699,7 @@
     || defined(HURD) || defined(NETBSD)
 	static struct sigaction old_segv_act;
 #	if defined(_sigargs) /* !Irix6.x */ || defined(HPUX) \
-	|| defined(HURD) || defined(NETBSD)
+	|| defined(HURD) || defined(NETBSD) || defined(FREEBSD)
 	    static struct sigaction old_bus_act;
 #	endif
 #   else
@@ -714,7 +714,7 @@
 #   endif
     {
 #	if defined(SUNOS5SIGS) || defined(IRIX5)  \
-        || defined(OSF1) || defined(HURD) || defined(NETBSD)
+        || defined(OSF1) || defined(HURD) || defined(NETBSD) || defined(FREEBSD)
 	  struct sigaction	act;
 
 	  act.sa_handler	= h;
@@ -734,7 +734,7 @@
 #	  else
 	        (void) sigaction(SIGSEGV, &act, &old_segv_act);
 #		if defined(IRIX5) && defined(_sigargs) /* Irix 5.x, not 6.x */ \
-		   || defined(HPUX) || defined(HURD) || defined(NETBSD)
+		   || defined(HPUX) || defined(HURD) || defined(NETBSD) || defined(FREEBSD)
 		    /* Under Irix 5.x or HP/UX, we may get SIGBUS.	*/
 		    /* Pthreads doesn't exist under Irix 5.x, so we	*/
 		    /* don't have to worry in the threads case.		*/
