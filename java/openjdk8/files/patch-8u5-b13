--- .hgtags
+++ .hgtags
@@ -253,3 +253,16 @@
 1e5fe865491300cd0c63261ecf8d34e621e1345c jdk8-b129
 839546caab1285c7699a9c2aa1467f57c9ea7f30 jdk8-b130
 0c38dfecab2ad9f9b5b5edf54b991602147cd040 jdk8-b131
+2a8f4c022aa03e7916223f3291517dbcc38e07cd jdk8-b132
+c41935d79b8744af8b7b56cd4d4ab781027fb22e jdk8u5-b01
+6f3357d3dbf83c1ef0098bcb853e3aa3b26f4cb8 jdk8u5-b02
+794b4365b6884e9a15f0840792539f5821814127 jdk8u5-b03
+c200d6cb184056e44afe7102913004b717896aa3 jdk8u5-b04
+eb537d7c31e069ac10de0901727515743f7535d2 jdk8u5-b05
+75cdae18810a479cc3c0fe8eb9055d968ae31c63 jdk8u5-b06
+b1585984f29320737ca0da5af029b1225a75c476 jdk8u5-b07
+a445d4130af79027fd9d6675b1ad7a8990225749 jdk8u5-b08
+e5403ff707fbd828e56bf390931f236028f9617b jdk8u5-b09
+fae51c73a06d71304c9dbff22984ee501812b972 jdk8u5-b10
+dd3bd272ceedbd69fabafc531b6b1e056659f733 jdk8u5-b11
+3e05b6ae0a1e2bd7352462e9bf8e7262246fb77f jdk8u5-b12
--- .jcheck/conf
+++ .jcheck/conf
@@ -1 +1,2 @@
 project=jdk8
+bugids=dup
--- THIRD_PARTY_README
+++ THIRD_PARTY_README
@@ -1399,13 +1399,13 @@
 
 -------------------------------------------------------------------------------
 
-%% This notice is provided with respect to Little CMS 2.4, which may be 
+%% This notice is provided with respect to Little CMS 2.5, which may be 
 included with JRE 8, JDK 8, and OpenJDK 8.
 
 --- begin of LICENSE ---
 
 Little CMS
-Copyright (c) 1998-2010 Marti Maria Saguer
+Copyright (c) 1998-2011 Marti Maria Saguer
 
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
--- common/autoconf/generated-configure.sh
+++ common/autoconf/generated-configure.sh
@@ -3865,7 +3865,7 @@
 #CUSTOM_AUTOCONF_INCLUDE
 
 # Do not change or remove the following line, it is needed for consistency checks:
-DATE_WHEN_GENERATED=1389186094
+DATE_WHEN_GENERATED=1390334534
 
 ###############################################################################
 #
@@ -11156,6 +11156,12 @@
     as_fn_error $? "Update version must have a value" "$LINENO" 5
   elif test "x$with_update_version" != x; then
     JDK_UPDATE_VERSION="$with_update_version"
+    # On macosx 10.7, it's not possible to set --with-update-version=0X due
+    # to a bug in expr (which reduces it to just X). To work around this, we
+    # always add a 0 to one digit update versions.
+    if test "${#JDK_UPDATE_VERSION}" = "1"; then
+      JDK_UPDATE_VERSION="0${JDK_UPDATE_VERSION}"
+    fi
   fi
 
 
--- common/autoconf/jdk-options.m4
+++ common/autoconf/jdk-options.m4
@@ -423,6 +423,12 @@
     AC_MSG_ERROR([Update version must have a value])
   elif test "x$with_update_version" != x; then
     JDK_UPDATE_VERSION="$with_update_version"
+    # On macosx 10.7, it's not possible to set --with-update-version=0X due
+    # to a bug in expr (which reduces it to just X). To work around this, we
+    # always add a 0 to one digit update versions.
+    if test "${#JDK_UPDATE_VERSION}" = "1"; then
+      JDK_UPDATE_VERSION="0${JDK_UPDATE_VERSION}"
+    fi
   fi
 
   AC_ARG_WITH(user-release-suffix, [AS_HELP_STRING([--with-user-release-suffix],
--- corba/.hgtags
+++ corba/.hgtags
@@ -253,3 +253,16 @@
 5c72d74c6805d1b4f6192f7a3550d126acf37005 jdk8-b129
 0683ee308085785d0455f4153e764e062843f178 jdk8-b130
 5e5c8f0c45dd75a08089586ca50835393f00c2cb jdk8-b131
+84fed37bbe640666bfc022c2e8b9fde468de35d2 jdk8-b132
+5de8d42f9eb7ddcdc741445f3c21a63887d694b6 jdk8u5-b01
+c750098a3ef18de28a6d739666559f0333c76c78 jdk8u5-b02
+3d9b40a53134aa33031bf13581dff9fccade9048 jdk8u5-b03
+596f4e4c5587c29767345555c4e48a5be0a58b83 jdk8u5-b04
+1f95c888e5efe010550d95ef59020ddb15876463 jdk8u5-b05
+edfa8bc86fda1b2fd064abbafb4506c80a47587e jdk8u5-b06
+0a25d1c162bc046aa230577736429935716a2243 jdk8u5-b07
+df6e5fc3b585a6829c98bb91546b81dc28f8e2b4 jdk8u5-b08
+f5058197fa91153b7702214154d37b00f9714aaa jdk8u5-b09
+d9031b5525f777299554080d6beb8b077df0a614 jdk8u5-b10
+a2f7b36bfc1bc8df033fe5721b48fac1c3928a5b jdk8u5-b11
+475b96f6d8cecf720ca9fd6d332dd4bafb0f654c jdk8u5-b12
--- corba/.jcheck/conf
+++ corba/.jcheck/conf
@@ -1 +1,2 @@
 project=jdk8
+bugids=dup
--- corba/THIRD_PARTY_README
+++ corba/THIRD_PARTY_README
@@ -1399,13 +1399,13 @@
 
 -------------------------------------------------------------------------------
 
-%% This notice is provided with respect to Little CMS 2.4, which may be 
+%% This notice is provided with respect to Little CMS 2.5, which may be 
 included with JRE 8, JDK 8, and OpenJDK 8.
 
 --- begin of LICENSE ---
 
 Little CMS
-Copyright (c) 1998-2010 Marti Maria Saguer
+Copyright (c) 1998-2011 Marti Maria Saguer
 
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
--- corba/src/share/classes/com/sun/corba/se/impl/io/ObjectStreamClass.java
+++ corba/src/share/classes/com/sun/corba/se/impl/io/ObjectStreamClass.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1998, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -52,6 +52,7 @@
 import java.io.DataOutputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.InvalidClassException;
+import java.io.Externalizable;
 import java.io.Serializable;
 
 import java.util.Arrays;
@@ -80,15 +81,15 @@
     public static final long kDefaultUID = -1;
 
     private static Object noArgsList[] = {};
-    private static Class noTypesList[] = {};
+    private static Class<?> noTypesList[] = {};
 
     /** true if represents enum type */
     private boolean isEnum;
 
     private static final Bridge bridge =
-        (Bridge)AccessController.doPrivileged(
-            new PrivilegedAction() {
-                public Object run() {
+        AccessController.doPrivileged(
+            new PrivilegedAction<Bridge>() {
+                public Bridge run() {
                     return Bridge.get() ;
                 }
             }
@@ -98,7 +99,7 @@
      * is returned if the specified class does not implement
      * java.io.Serializable or java.io.Externalizable.
      */
-    static final ObjectStreamClass lookup(Class cl)
+    static final ObjectStreamClass lookup(Class<?> cl)
     {
         ObjectStreamClass desc = lookupInternal(cl);
         if (desc.isSerializable() || desc.isExternalizable())
@@ -110,7 +111,7 @@
      * Find the class descriptor for the specified class.
      * Package access only so it can be called from ObjectIn/OutStream.
      */
-    static ObjectStreamClass lookupInternal(Class cl)
+    static ObjectStreamClass lookupInternal(Class<?> cl)
     {
         /* Synchronize on the hashtable so no two threads will do
          * this at the same time.
@@ -121,14 +122,14 @@
             desc = findDescriptorFor(cl);
             if (desc == null) {
                 /* Check if it's serializable */
-                boolean serializable = classSerializable.isAssignableFrom(cl);
+                boolean serializable = Serializable.class.isAssignableFrom(cl);
 
                 /* If the class is only Serializable,
                  * lookup the descriptor for the superclass.
                  */
                 ObjectStreamClass superdesc = null;
                 if (serializable) {
-                    Class superclass = cl.getSuperclass();
+                    Class<?> superclass = cl.getSuperclass();
                     if (superclass != null)
                         superdesc = lookup(superclass);
                 }
@@ -141,7 +142,7 @@
                 if (serializable) {
                     externalizable =
                         ((superdesc != null) && superdesc.isExternalizable()) ||
-                        classExternalizable.isAssignableFrom(cl);
+                        Externalizable.class.isAssignableFrom(cl);
                     if (externalizable) {
                         serializable = false;
                     }
@@ -185,7 +186,7 @@
      * that have evolved from a common root class and agree to be serialized
      * and deserialized using a common format.
      */
-    public static final long getSerialVersionUID( java.lang.Class clazz) {
+    public static final long getSerialVersionUID( java.lang.Class<?> clazz) {
         ObjectStreamClass theosc = ObjectStreamClass.lookup( clazz );
         if( theosc != null )
         {
@@ -219,7 +220,7 @@
     /**
      * Return the actual (computed) serialVersionUID for this class.
      */
-    public static final long getActualSerialVersionUID( java.lang.Class clazz )
+    public static final long getActualSerialVersionUID( java.lang.Class<?> clazz )
     {
         ObjectStreamClass theosc = ObjectStreamClass.lookup( clazz );
         if( theosc != null )
@@ -249,7 +250,7 @@
      * Return the class in the local VM that this version is mapped to.
      * Null is returned if there is no corresponding local class.
      */
-    public final Class forClass() {
+    public final Class<?> forClass() {
         return ofClass;
     }
 
@@ -349,7 +350,7 @@
      * Create a new ObjectStreamClass from a loaded class.
      * Don't call this directly, call lookup instead.
      */
-    private ObjectStreamClass(java.lang.Class cl, ObjectStreamClass superdesc,
+    private ObjectStreamClass(java.lang.Class<?> cl, ObjectStreamClass superdesc,
                               boolean serial, boolean extern)
     {
         ofClass = cl;           /* created from this class */
@@ -433,7 +434,7 @@
         if (initialized)
             return;
 
-        final Class cl = ofClass;
+        final Class<?> cl = ofClass;
 
         if (!serializable ||
             externalizable ||
@@ -561,9 +562,9 @@
                      * will call it as necessary.
                      */
                     writeObjectMethod = getPrivateMethod( cl, "writeObject",
-                        new Class[] { java.io.ObjectOutputStream.class }, Void.TYPE ) ;
+                        new Class<?>[] { java.io.ObjectOutputStream.class }, Void.TYPE ) ;
                     readObjectMethod = getPrivateMethod( cl, "readObject",
-                        new Class[] { java.io.ObjectInputStream.class }, Void.TYPE ) ;
+                        new Class<?>[] { java.io.ObjectInputStream.class }, Void.TYPE ) ;
                 }
                 return null;
             }
@@ -589,9 +590,9 @@
      * class, or null if none found.  Access checks are disabled on the
      * returned method (if any).
      */
-    private static Method getPrivateMethod(Class cl, String name,
-                                           Class[] argTypes,
-                                           Class returnType)
+    private static Method getPrivateMethod(Class<?> cl, String name,
+                                           Class<?>[] argTypes,
+                                           Class<?> returnType)
     {
         try {
             Method meth = cl.getDeclaredMethod(name, argTypes);
@@ -653,7 +654,7 @@
      * Fill in the reflected Fields that will be used
      * for reading.
      */
-    final void setClass(Class cl) throws InvalidClassException {
+    final void setClass(Class<?> cl) throws InvalidClassException {
 
         if (cl == null) {
             localClassDesc = null;
@@ -920,9 +921,9 @@
      * Access checks are disabled on the returned constructor (if any), since
      * the defining class may still be non-public.
      */
-    private static Constructor getExternalizableConstructor(Class cl) {
+    private static Constructor getExternalizableConstructor(Class<?> cl) {
         try {
-            Constructor cons = cl.getDeclaredConstructor(new Class[0]);
+            Constructor cons = cl.getDeclaredConstructor(new Class<?>[0]);
             cons.setAccessible(true);
             return ((cons.getModifiers() & Modifier.PUBLIC) != 0) ?
                 cons : null;
@@ -936,15 +937,15 @@
      * superclass, or null if none found.  Access checks are disabled on the
      * returned constructor (if any).
      */
-    private static Constructor getSerializableConstructor(Class cl) {
-        Class initCl = cl;
+    private static Constructor getSerializableConstructor(Class<?> cl) {
+        Class<?> initCl = cl;
         while (Serializable.class.isAssignableFrom(initCl)) {
             if ((initCl = initCl.getSuperclass()) == null) {
                 return null;
             }
         }
         try {
-            Constructor cons = initCl.getDeclaredConstructor(new Class[0]);
+            Constructor cons = initCl.getDeclaredConstructor(new Class<?>[0]);
             int mods = cons.getModifiers();
             if ((mods & Modifier.PRIVATE) != 0 ||
                 ((mods & (Modifier.PUBLIC | Modifier.PROTECTED)) == 0 &&
@@ -1049,7 +1050,7 @@
      * items to the hash accumulating in the digest stream.
      * Fold the hash into a long.  Use the SHA secure hash function.
      */
-    private static long _computeSerialVersionUID(Class cl) {
+    private static long _computeSerialVersionUID(Class<?> cl) {
         if (DEBUG_SVUID)
             msg( "Computing SerialVersionUID for " + cl ) ;
         ByteArrayOutputStream devnull = new ByteArrayOutputStream(512);
@@ -1103,7 +1104,7 @@
                  * them from its computation.
                  */
 
-                Class interfaces[] = cl.getInterfaces();
+                Class<?> interfaces[] = cl.getInterfaces();
                 Arrays.sort(interfaces, compareClassByName);
 
                 for (int i = 0; i < interfaces.length; i++) {
@@ -1233,7 +1234,7 @@
         return h;
     }
 
-    private static long computeStructuralUID(com.sun.corba.se.impl.io.ObjectStreamClass osc, Class cl) {
+    private static long computeStructuralUID(com.sun.corba.se.impl.io.ObjectStreamClass osc, Class<?> cl) {
         ByteArrayOutputStream devnull = new ByteArrayOutputStream(512);
 
         long h = 0;
@@ -1253,7 +1254,7 @@
             DataOutputStream data = new DataOutputStream(mdo);
 
             // Get SUID of parent
-            Class parent = cl.getSuperclass();
+            Class<?> parent = cl.getSuperclass();
             if ((parent != null))
             // SerialBug 1; acc. to spec the one for
             // java.lang.object
@@ -1309,10 +1310,10 @@
     /**
      * Compute the JVM signature for the class.
      */
-    static String getSignature(Class clazz) {
+    static String getSignature(Class<?> clazz) {
         String type = null;
         if (clazz.isArray()) {
-            Class cl = clazz;
+            Class<?> cl = clazz;
             int dimensions = 0;
             while (cl.isArray()) {
                 dimensions++;
@@ -1358,7 +1359,7 @@
 
         sb.append("(");
 
-        Class[] params = meth.getParameterTypes(); // avoid clone
+        Class<?>[] params = meth.getParameterTypes(); // avoid clone
         for (int j = 0; j < params.length; j++) {
             sb.append(getSignature(params[j]));
         }
@@ -1375,7 +1376,7 @@
 
         sb.append("(");
 
-        Class[] params = cons.getParameterTypes(); // avoid clone
+        Class<?>[] params = cons.getParameterTypes(); // avoid clone
         for (int j = 0; j < params.length; j++) {
             sb.append(getSignature(params[j]));
         }
@@ -1395,7 +1396,7 @@
      * The entries are extended from java.lang.ref.SoftReference so the
      * gc will be able to free them if needed.
      */
-    private static ObjectStreamClass findDescriptorFor(Class cl) {
+    private static ObjectStreamClass findDescriptorFor(Class<?> cl) {
 
         int hash = cl.hashCode();
         int index = (hash & 0x7FFFFFFF) % descriptorFor.length;
@@ -1442,7 +1443,7 @@
         descriptorFor[index] = e;
     }
 
-    private static Field[] getDeclaredFields(final Class clz) {
+    private static Field[] getDeclaredFields(final Class<?> clz) {
         return (Field[]) AccessController.doPrivileged(new PrivilegedAction() {
             public Object run() {
                 return clz.getDeclaredFields();
@@ -1476,7 +1477,7 @@
     /*
      * Class that is a descriptor for in this virtual machine.
      */
-    private Class ofClass;
+    private Class<?> ofClass;
 
     /*
      * True if descriptor for a proxy class.
@@ -1548,30 +1549,17 @@
      * Returns true if the given class defines a static initializer method,
      * false otherwise.
      */
-    private static boolean hasStaticInitializer(Class cl) {
+    private static boolean hasStaticInitializer(Class<?> cl) {
         if (hasStaticInitializerMethod == null) {
-            Class classWithThisMethod = null;
+            Class<?> classWithThisMethod = null;
 
             try {
-                try {
-                    // When using rip-int with Merlin or when this is a Merlin
-                    // workspace, the method we want is in sun.misc.ClassReflector
-                    // and absent from java.io.ObjectStreamClass.
-                    //
-                    // When compiling rip-int with JDK 1.3.x, we have to get it
-                    // from java.io.ObjectStreamClass.
-                    classWithThisMethod = Class.forName("sun.misc.ClassReflector");
-                } catch (ClassNotFoundException cnfe) {
-                    // Do nothing.  This is either not a Merlin workspace,
-                    // or rip-int is being compiled with something other than
-                    // Merlin, probably JDK 1.3.  Fall back on java.io.ObjectStreaClass.
-                }
                 if (classWithThisMethod == null)
                     classWithThisMethod = java.io.ObjectStreamClass.class;
 
                 hasStaticInitializerMethod =
                     classWithThisMethod.getDeclaredMethod("hasStaticInitializer",
-                                                          new Class[] { Class.class });
+                                                          new Class<?>[] { Class.class });
             } catch (NoSuchMethodException ex) {
             }
 
@@ -1596,22 +1584,6 @@
     }
 
 
-    /* The Class Object for java.io.Serializable */
-    private static Class classSerializable = null;
-    private static Class classExternalizable = null;
-
-    /*
-     * Resolve java.io.Serializable at load time.
-     */
-    static {
-        try {
-            classSerializable = Class.forName("java.io.Serializable");
-            classExternalizable = Class.forName("java.io.Externalizable");
-        } catch (Throwable e) {
-            System.err.println("Could not load java.io.Serializable or java.io.Externalizable.");
-        }
-    }
-
     /** use serialVersionUID from JDK 1.1. for interoperability */
     private static final long serialVersionUID = -6120832682080437368L;
 
@@ -1649,8 +1621,8 @@
 
     private static class CompareClassByName implements Comparator {
         public int compare(Object o1, Object o2) {
-            Class c1 = (Class)o1;
-            Class c2 = (Class)o2;
+            Class<?> c1 = (Class)o1;
+            Class<?> c2 = (Class)o2;
             return (c1.getName()).compareTo(c2.getName());
         }
     }
@@ -1764,12 +1736,12 @@
      *
      * Copied from the Merlin java.io.ObjectStreamClass.
      */
-    private static Method getInheritableMethod(Class cl, String name,
-                                               Class[] argTypes,
-                                               Class returnType)
+    private static Method getInheritableMethod(Class<?> cl, String name,
+                                               Class<?>[] argTypes,
+                                               Class<?> returnType)
     {
         Method meth = null;
-        Class defCl = cl;
+        Class<?> defCl = cl;
         while (defCl != null) {
             try {
                 meth = defCl.getDeclaredMethod(name, argTypes);
@@ -1801,7 +1773,7 @@
      *
      * Copied from the Merlin java.io.ObjectStreamClass.
      */
-    private static boolean packageEquals(Class cl1, Class cl2) {
+    private static boolean packageEquals(Class<?> cl1, Class<?> cl2) {
         Package pkg1 = cl1.getPackage(), pkg2 = cl2.getPackage();
         return ((pkg1 == pkg2) || ((pkg1 != null) && (pkg1.equals(pkg2))));
     }
--- corba/src/share/classes/com/sun/corba/se/impl/orbutil/ObjectStreamClassUtil_1_3.java
+++ corba/src/share/classes/com/sun/corba/se/impl/orbutil/ObjectStreamClassUtil_1_3.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000, 2002, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -94,7 +94,7 @@
         });
     }
 
-    public static long computeStructuralUID(boolean hasWriteObject, Class cl) {
+    public static long computeStructuralUID(boolean hasWriteObject, Class<?> cl) {
         ByteArrayOutputStream devnull = new ByteArrayOutputStream(512);
 
         long h = 0;
@@ -119,7 +119,7 @@
             // Object method in there
 
             // Get SUID of parent
-            Class parent = cl.getSuperclass();
+            Class<?> parent = cl.getSuperclass();
             if ((parent != null) && (parent != java.lang.Object.class)) {
                 boolean hasWriteObjectFlag = false;
                 Class [] args = {java.io.ObjectOutputStream.class};
@@ -503,19 +503,6 @@
             Class classWithThisMethod = null;
 
             try {
-                try {
-                    // When using rip-int with Merlin or when this is a Merlin
-                    // workspace, the method we want is in sun.misc.ClassReflector
-                    // and absent from java.io.ObjectStreamClass.
-                    //
-                    // When compiling rip-int with JDK 1.3.x, we have to get it
-                    // from java.io.ObjectStreamClass.
-                    classWithThisMethod = Class.forName("sun.misc.ClassReflector");
-                } catch (ClassNotFoundException cnfe) {
-                    // Do nothing.  This is either not a Merlin workspace,
-                    // or rip-int is being compiled with something other than
-                    // Merlin, probably JDK 1.3.  Fall back on java.io.ObjectStreaClass.
-                }
                 if (classWithThisMethod == null)
                     classWithThisMethod = java.io.ObjectStreamClass.class;
 
--- corba/src/share/classes/com/sun/corba/se/impl/orbutil/ObjectStreamClass_1_3_1.java
+++ corba/src/share/classes/com/sun/corba/se/impl/orbutil/ObjectStreamClass_1_3_1.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -53,6 +53,7 @@
 import java.io.ByteArrayOutputStream;
 import java.io.InvalidClassException;
 import java.io.Serializable;
+import java.io.Externalizable;
 
 import java.util.Arrays;
 import java.util.Comparator;
@@ -88,7 +89,7 @@
     public static final long kDefaultUID = -1;
 
     private static Object noArgsList[] = {};
-    private static Class noTypesList[] = {};
+    private static Class<?> noTypesList[] = {};
 
     private static Hashtable translatedFields;
 
@@ -96,7 +97,7 @@
      * is returned if the specified class does not implement
      * java.io.Serializable or java.io.Externalizable.
      */
-    static final ObjectStreamClass_1_3_1 lookup(Class cl)
+    static final ObjectStreamClass_1_3_1 lookup(Class<?> cl)
     {
         ObjectStreamClass_1_3_1 desc = lookupInternal(cl);
         if (desc.isSerializable() || desc.isExternalizable())
@@ -108,7 +109,7 @@
      * Find the class descriptor for the specified class.
      * Package access only so it can be called from ObjectIn/OutStream.
      */
-    static ObjectStreamClass_1_3_1 lookupInternal(Class cl)
+    static ObjectStreamClass_1_3_1 lookupInternal(Class<?> cl)
     {
         /* Synchronize on the hashtable so no two threads will do
          * this at the same time.
@@ -122,13 +123,13 @@
             }
 
                 /* Check if it's serializable */
-                boolean serializable = classSerializable.isAssignableFrom(cl);
+                boolean serializable = Serializable.class.isAssignableFrom(cl);
                 /* If the class is only Serializable,
                  * lookup the descriptor for the superclass.
                  */
                 ObjectStreamClass_1_3_1 superdesc = null;
                 if (serializable) {
-                    Class superclass = cl.getSuperclass();
+                    Class<?> superclass = cl.getSuperclass();
                     if (superclass != null)
                         superdesc = lookup(superclass);
                 }
@@ -141,7 +142,7 @@
                 if (serializable) {
                     externalizable =
                         ((superdesc != null) && superdesc.isExternalizable()) ||
-                        classExternalizable.isAssignableFrom(cl);
+                        Externalizable.class.isAssignableFrom(cl);
                     if (externalizable) {
                         serializable = false;
                     }
@@ -170,7 +171,7 @@
      * that have evolved from a common root class and agree to be serialized
      * and deserialized using a common format.
      */
-    public static final long getSerialVersionUID( java.lang.Class clazz) {
+    public static final long getSerialVersionUID( java.lang.Class<?> clazz) {
         ObjectStreamClass_1_3_1 theosc = ObjectStreamClass_1_3_1.lookup( clazz );
         if( theosc != null )
         {
@@ -204,7 +205,7 @@
     /**
      * Return the actual (computed) serialVersionUID for this class.
      */
-    public static final long getActualSerialVersionUID( java.lang.Class clazz )
+    public static final long getActualSerialVersionUID( java.lang.Class<?> clazz )
     {
         ObjectStreamClass_1_3_1 theosc = ObjectStreamClass_1_3_1.lookup( clazz );
         if( theosc != null )
@@ -234,7 +235,7 @@
      * Return the class in the local VM that this version is mapped to.
      * Null is returned if there is no corresponding local class.
      */
-    public final Class forClass() {
+    public final Class<?> forClass() {
         return ofClass;
     }
 
@@ -333,7 +334,7 @@
      * Create a new ObjectStreamClass_1_3_1 from a loaded class.
      * Don't call this directly, call lookup instead.
      */
-    private ObjectStreamClass_1_3_1(java.lang.Class cl, ObjectStreamClass_1_3_1 superdesc,
+    private ObjectStreamClass_1_3_1(java.lang.Class<?> cl, ObjectStreamClass_1_3_1 superdesc,
                               boolean serial, boolean extern)
     {
         ofClass = cl;           /* created from this class */
@@ -376,7 +377,7 @@
     private void init() {
       synchronized (lock) {
 
-        final Class cl = ofClass;
+        final Class<?> cl = ofClass;
 
         if (fields != null) // already initialized
                 return;
@@ -558,7 +559,7 @@
                      * will call it as necessary.
                      */
                     try {
-                      Class[] args = {java.io.ObjectOutputStream.class};
+                      Class<?>[] args = {java.io.ObjectOutputStream.class};
                       writeObjectMethod = cl.getDeclaredMethod("writeObject", args);
                       hasWriteObjectMethod = true;
                       int mods = writeObjectMethod.getModifiers();
@@ -578,7 +579,7 @@
                      * ObjectInputStream so it can all the method directly.
                      */
                     try {
-                      Class[] args = {java.io.ObjectInputStream.class};
+                      Class<?>[] args = {java.io.ObjectInputStream.class};
                       readObjectMethod = cl.getDeclaredMethod("readObject", args);
                       int mods = readObjectMethod.getModifiers();
 
@@ -629,11 +630,11 @@
             if (translation != null)
                 return translation;
             else {
-                Class osfClass = com.sun.corba.se.impl.orbutil.ObjectStreamField.class;
+                Class<?> osfClass = com.sun.corba.se.impl.orbutil.ObjectStreamField.class;
 
                 translation = (Object[])java.lang.reflect.Array.newInstance(osfClass, objs.length);
                 Object arg[] = new Object[2];
-                Class types[] = {String.class, Class.class};
+                Class<?> types[] = {String.class, Class.class};
                 Constructor constructor = osfClass.getDeclaredConstructor(types);
                 for (int i = fields.length -1; i >= 0; i--){
                     arg[0] = fields[i].getName();
@@ -804,7 +805,7 @@
         }
     }
 
-    private static long computeStructuralUID(ObjectStreamClass_1_3_1 osc, Class cl) {
+    private static long computeStructuralUID(ObjectStreamClass_1_3_1 osc, Class<?> cl) {
         ByteArrayOutputStream devnull = new ByteArrayOutputStream(512);
 
         long h = 0;
@@ -824,7 +825,7 @@
             DataOutputStream data = new DataOutputStream(mdo);
 
             // Get SUID of parent
-            Class parent = cl.getSuperclass();
+            Class<?> parent = cl.getSuperclass();
             if ((parent != null))
             // SerialBug 1; acc. to spec the one for
             // java.lang.object
@@ -910,10 +911,10 @@
     /**
      * Compute the JVM signature for the class.
      */
-    static String getSignature(Class clazz) {
+    static String getSignature(Class<?> clazz) {
         String type = null;
         if (clazz.isArray()) {
-            Class cl = clazz;
+            Class<?> cl = clazz;
             int dimensions = 0;
             while (cl.isArray()) {
                 dimensions++;
@@ -959,7 +960,7 @@
 
         sb.append("(");
 
-        Class[] params = meth.getParameterTypes(); // avoid clone
+        Class<?>[] params = meth.getParameterTypes(); // avoid clone
         for (int j = 0; j < params.length; j++) {
             sb.append(getSignature(params[j]));
         }
@@ -976,7 +977,7 @@
 
         sb.append("(");
 
-        Class[] params = cons.getParameterTypes(); // avoid clone
+        Class<?>[] params = cons.getParameterTypes(); // avoid clone
         for (int j = 0; j < params.length; j++) {
             sb.append(getSignature(params[j]));
         }
@@ -996,7 +997,7 @@
      * The entries are extended from java.lang.ref.SoftReference so the
      * gc will be able to free them if needed.
      */
-    private static ObjectStreamClass_1_3_1 findDescriptorFor(Class cl) {
+    private static ObjectStreamClass_1_3_1 findDescriptorFor(Class<?> cl) {
 
         int hash = cl.hashCode();
         int index = (hash & 0x7FFFFFFF) % descriptorFor.length;
@@ -1077,7 +1078,7 @@
     /*
      * Class that is a descriptor for in this virtual machine.
      */
-    private Class ofClass;
+    private Class<?> ofClass;
 
     /*
      * True if descriptor for a proxy class.
@@ -1130,22 +1131,6 @@
     /* Get the private static final field for serial version UID */
     // private static native long getSerialVersionUIDField(Class cl);
 
-    /* The Class Object for java.io.Serializable */
-    private static Class classSerializable = null;
-    private static Class classExternalizable = null;
-
-    /*
-     * Resolve java.io.Serializable at load time.
-     */
-    static {
-        try {
-            classSerializable = Class.forName("java.io.Serializable");
-            classExternalizable = Class.forName("java.io.Externalizable");
-        } catch (Throwable e) {
-            System.err.println("Could not load java.io.Serializable or java.io.Externalizable.");
-        }
-    }
-
     /** use serialVersionUID from JDK 1.1. for interoperability */
     private static final long serialVersionUID = -6120832682080437368L;
 
@@ -1183,8 +1168,8 @@
 
     private static class CompareClassByName implements Comparator {
         public int compare(Object o1, Object o2) {
-            Class c1 = (Class)o1;
-            Class c2 = (Class)o2;
+            Class<?> c1 = (Class)o1;
+            Class<?> c2 = (Class)o2;
             return (c1.getName()).compareTo(c2.getName());
         }
     }
--- corba/src/share/classes/org/omg/CORBA/ORB.java
+++ corba/src/share/classes/org/omg/CORBA/ORB.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1995, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1995, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -36,6 +36,8 @@
 import java.security.AccessController;
 import java.security.PrivilegedAction;
 
+import sun.reflect.misc.ReflectUtil;
+
 /**
  * A class providing APIs for the CORBA Object Request Broker
  * features.  The <code>ORB</code> class also provides
@@ -289,20 +291,38 @@
                     (className.equals("com.sun.corba.se.impl.orb.ORBSingleton"))) {
                 singleton = new com.sun.corba.se.impl.orb.ORBSingleton();
             } else {
-                singleton = create_impl(className);
+                singleton = create_impl_with_systemclassloader(className);
             }
         }
         return singleton;
     }
 
-    private static ORB create_impl(String className) {
+   private static ORB create_impl_with_systemclassloader(String className) {
 
+        try {
+            ReflectUtil.checkPackageAccess(className);
+            ClassLoader cl = ClassLoader.getSystemClassLoader();
+            Class<org.omg.CORBA.ORB> orbBaseClass = org.omg.CORBA.ORB.class;
+            Class<?> singletonOrbClass = Class.forName(className, true, cl).asSubclass(orbBaseClass);
+            return (ORB)singletonOrbClass.newInstance();
+        } catch (Throwable ex) {
+            SystemException systemException = new INITIALIZE(
+                "can't instantiate default ORB implementation " + className);
+            systemException.initCause(ex);
+            throw systemException;
+        }
+    }
+
+    private static ORB create_impl(String className) {
         ClassLoader cl = Thread.currentThread().getContextClassLoader();
         if (cl == null)
             cl = ClassLoader.getSystemClassLoader();
 
         try {
-            return (ORB) Class.forName(className, true, cl).newInstance();
+            ReflectUtil.checkPackageAccess(className);
+            Class<org.omg.CORBA.ORB> orbBaseClass = org.omg.CORBA.ORB.class;
+            Class<?> orbClass = Class.forName(className, true, cl).asSubclass(orbBaseClass);
+            return (ORB)orbClass.newInstance();
         } catch (Throwable ex) {
             SystemException systemException = new INITIALIZE(
                "can't instantiate default ORB implementation " + className);
@@ -346,7 +366,6 @@
         } else {
             orb = create_impl(className);
         }
-
         orb.set_parameters(args, props);
         return orb;
     }
@@ -377,7 +396,6 @@
         } else {
             orb = create_impl(className);
         }
-
         orb.set_parameters(app, props);
         return orb;
     }
@@ -573,7 +591,7 @@
         try {
             // First try to load the OperationDef class
             String opDefClassName = "org.omg.CORBA.OperationDef";
-            Class opDefClass = null;
+            Class<?> opDefClass = null;
 
             ClassLoader cl = Thread.currentThread().getContextClassLoader();
             if ( cl == null )
@@ -583,7 +601,7 @@
 
             // OK, we loaded OperationDef. Now try to get the
             // create_operation_list(OperationDef oper) method.
-            Class[] argc = { opDefClass };
+            Class<?>[] argc = { opDefClass };
             java.lang.reflect.Method meth =
                 this.getClass().getMethod("create_operation_list", argc);
 
--- hotspot/.hgtags
+++ hotspot/.hgtags
@@ -421,3 +421,16 @@
 1dbaf664a611e5d9cab6d1be42537b67d0d05f94 jdk8-b130
 b5e7ebfe185cb4c2eeb8a919025fc6a26be2fcef jdk8-b131
 9f9179e8f0cfe74c08f3716cf3c38e21e1de4c4a hs25-b70
+0c94c41dcd70e9a9b4d96e31275afd5a73daa72d jdk8-b132
+4a35ef38e2a7bc64df20c7700ba69b37e3ddb8b5 jdk8u5-b01
+e5561d89fe8bfc79cd6c8fcc36d270cc6a49ec6e jdk8u5-b02
+2f9eb9fcab6c42c8c84ddb44170ea33235116d84 jdk8u5-b03
+5ac720d47ab83f8eb2f5fe3641667823a0298f41 jdk8u5-b04
+b90de55aca30678ab0fec05d6a61bb3468b783d2 jdk8u5-b05
+956c0e048ef29ee9a8026fb05858abe64b4e0ceb jdk8u5-b06
+46fa2940e6861df18a107b6b83a2df85239e5ec7 jdk8u5-b07
+21c1dfbed277791071947eed1c93806ccf48a7d8 jdk8u5-b08
+6af9ce1c56a6545ec6c992a5f61b2eec924be040 jdk8u5-b09
+629267e4f0b5155608edcd71922983be98786bd7 jdk8u5-b10
+17a75e692af397532e2b296b24f6b9b6c239c633 jdk8u5-b11
+9b289963cb9a14636fbe8faaa2dd6d3678464a7b jdk8u5-b12
--- hotspot/.jcheck/conf
+++ hotspot/.jcheck/conf
@@ -1 +1,2 @@
 project=jdk8
+bugids=dup
--- hotspot/THIRD_PARTY_README
+++ hotspot/THIRD_PARTY_README
@@ -1399,13 +1399,13 @@
 
 -------------------------------------------------------------------------------
 
-%% This notice is provided with respect to Little CMS 2.4, which may be 
+%% This notice is provided with respect to Little CMS 2.5, which may be 
 included with JRE 8, JDK 8, and OpenJDK 8.
 
 --- begin of LICENSE ---
 
 Little CMS
-Copyright (c) 1998-2010 Marti Maria Saguer
+Copyright (c) 1998-2011 Marti Maria Saguer
 
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
--- hotspot/make/hotspot_version
+++ hotspot/make/hotspot_version
@@ -34,8 +34,8 @@
 HOTSPOT_VM_COPYRIGHT=Copyright 2014
 
 HS_MAJOR_VER=25
-HS_MINOR_VER=0
-HS_BUILD_NUMBER=70
+HS_MINOR_VER=5
+HS_BUILD_NUMBER=02
 
 JDK_MAJOR_VER=1
 JDK_MINOR_VER=8
--- hotspot/src/share/vm/classfile/classFileParser.cpp
+++ hotspot/src/share/vm/classfile/classFileParser.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -2777,6 +2777,11 @@
                      "Short length on BootstrapMethods in class file %s",
                      CHECK);
 
+  guarantee_property(attribute_byte_length > sizeof(u2),
+                     "Invalid BootstrapMethods attribute length %u in class file %s",
+                     attribute_byte_length,
+                     CHECK);
+
   // The attribute contains a counted array of counted tuples of shorts,
   // represending bootstrap specifiers:
   //    length*{bootstrap_method_index, argument_count*{argument_index}}
--- hotspot/src/share/vm/oops/objArrayKlass.cpp
+++ hotspot/src/share/vm/oops/objArrayKlass.cpp
@@ -269,7 +269,7 @@
         if (element_is_null ||
             (new_val->klass())->is_subtype_of(bound)) {
           bs->write_ref_field_pre(p, new_val);
-          *p = *from;
+          *p = element;
         } else {
           // We must do a barrier to cover the partial copy.
           const size_t pd = pointer_delta(p, dst, (size_t)heapOopSize);
--- hotspot/src/share/vm/opto/output.cpp
+++ hotspot/src/share/vm/opto/output.cpp
@@ -344,6 +344,11 @@
   uint*      jmp_offset = NEW_RESOURCE_ARRAY(uint,nblocks);
   uint*      jmp_size   = NEW_RESOURCE_ARRAY(uint,nblocks);
   int*       jmp_nidx   = NEW_RESOURCE_ARRAY(int ,nblocks);
+
+  // Collect worst case block paddings
+  int* block_worst_case_pad = NEW_RESOURCE_ARRAY(int, nblocks);
+  memset(block_worst_case_pad, 0, nblocks * sizeof(int));
+
   DEBUG_ONLY( uint *jmp_target = NEW_RESOURCE_ARRAY(uint,nblocks); )
   DEBUG_ONLY( uint *jmp_rule = NEW_RESOURCE_ARRAY(uint,nblocks); )
 
@@ -460,6 +465,7 @@
           last_avoid_back_to_back_adr += max_loop_pad;
         }
         blk_size += max_loop_pad;
+        block_worst_case_pad[i + 1] = max_loop_pad;
       }
     }
 
@@ -499,9 +505,16 @@
         if (bnum > i) { // adjust following block's offset
           offset -= adjust_block_start;
         }
+
+        // This block can be a loop header, account for the padding
+        // in the previous block.
+        int block_padding = block_worst_case_pad[i];
+        assert(i == 0 || block_padding == 0 || br_offs >= block_padding, "Should have at least a padding on top");
         // In the following code a nop could be inserted before
         // the branch which will increase the backward distance.
-        bool needs_padding = ((uint)br_offs == last_may_be_short_branch_adr);
+        bool needs_padding = ((uint)(br_offs - block_padding) == last_may_be_short_branch_adr);
+        assert(!needs_padding || jmp_offset[i] == 0, "padding only branches at the beginning of block");
+
         if (needs_padding && offset <= 0)
           offset -= nop_size;
 
--- jaxp/.hgtags
+++ jaxp/.hgtags
@@ -253,3 +253,16 @@
 b7752cea7c813fb8b1d3bf2e05e8f93331cc7f1d jdk8-b129
 0cb0cd01521845c2d6f5172a9ef1783d4c8bd668 jdk8-b130
 79d8b7fac21d263db5e5ebd3b830a3cf98509541 jdk8-b131
+5993346020d14a1c2c7003588c584366db7921f5 jdk8-b132
+22b63601be6f04fcb2c3b563261f14869954b44a jdk8u5-b01
+bd97ff5f82588c627869218df02a9c2dbb9402d0 jdk8u5-b02
+195b74b3e57905b6d6c9ed9b32139c6781ba7d28 jdk8u5-b03
+106fdcde4b8a6981be13dac34a3de99d6fece97c jdk8u5-b04
+8f859b1b0f0b18ee7e231d6887b18b5721c2404e jdk8u5-b05
+e22bc548b58a695eede0304399777314ae473562 jdk8u5-b06
+0f96584b02b399df706bec2052a7fe48bdc6058b jdk8u5-b07
+bbe60534528d2e8118957aaa74a75bedc1c3819a jdk8u5-b08
+d9b3ef4511434cf55870d42b6caa6a5618bc47ce jdk8u5-b09
+4b32ee8d711251e90ade1d958a51e134c3d387c9 jdk8u5-b10
+c17a827bec287f4c7565c72c195667e52154772b jdk8u5-b11
+0e5317cbe451d57f9ffcbb835de07fe553a8aa34 jdk8u5-b12
--- jaxp/.jcheck/conf
+++ jaxp/.jcheck/conf
@@ -1 +1,2 @@
 project=jdk8
+bugids=dup
--- jaxp/THIRD_PARTY_README
+++ jaxp/THIRD_PARTY_README
@@ -1399,13 +1399,13 @@
 
 -------------------------------------------------------------------------------
 
-%% This notice is provided with respect to Little CMS 2.4, which may be 
+%% This notice is provided with respect to Little CMS 2.5, which may be 
 included with JRE 8, JDK 8, and OpenJDK 8.
 
 --- begin of LICENSE ---
 
 Little CMS
-Copyright (c) 1998-2010 Marti Maria Saguer
+Copyright (c) 1998-2011 Marti Maria Saguer
 
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
--- jaxp/src/com/sun/org/apache/xalan/internal/utils/ObjectFactory.java
+++ jaxp/src/com/sun/org/apache/xalan/internal/utils/ObjectFactory.java
@@ -39,8 +39,8 @@
     //
     // Constants
     //
-     private static final String XALAN_INTERNAL = "com.sun.org.apache.xalan.internal";
-     private static final String XERCES_INTERNAL = "com.sun.org.apache.xerces.internal";
+     private static final String JAXP_INTERNAL = "com.sun.org.apache";
+     private static final String STAX_INTERNAL = "com.sun.xml.internal";
 
     /** Set to true for debugging */
     private static final boolean DEBUG = false;
@@ -161,12 +161,8 @@
     public static Class<?> findProviderClass(String className, boolean doFallback)
         throws ClassNotFoundException, ConfigurationError
     {
-        if (System.getSecurityManager()!=null) {
-            return Class.forName(className);
-        } else {
-            return findProviderClass (className,
+        return findProviderClass (className,
                 findClassLoader (), doFallback);
-        }
     }
 
     /**
@@ -181,8 +177,8 @@
         SecurityManager security = System.getSecurityManager();
         try{
             if (security != null){
-                if (className.startsWith(XALAN_INTERNAL) ||
-                    className.startsWith(XERCES_INTERNAL)) {
+                if (className.startsWith(JAXP_INTERNAL) ||
+                    className.startsWith(STAX_INTERNAL)) {
                     cl = null;
                 } else {
                     final int lastDot = className.lastIndexOf(".");
@@ -197,16 +193,7 @@
 
         Class<?> providerClass;
         if (cl == null) {
-            // XXX Use the bootstrap ClassLoader.  There is no way to
-            // load a class using the bootstrap ClassLoader that works
-            // in both JDK 1.1 and Java 2.  However, this should still
-            // work b/c the following should be true:
-            //
-            // (cl == null) iff current ClassLoader == null
-            //
-            // Thus Class.forName(String) will use the current
-            // ClassLoader which will be the bootstrap ClassLoader.
-            providerClass = Class.forName(className);
+            providerClass = Class.forName(className, false, ObjectFactory.class.getClassLoader());
         } else {
             try {
                 providerClass = cl.loadClass(className);
--- jaxp/src/com/sun/org/apache/xalan/internal/utils/SecuritySupport.java
+++ jaxp/src/com/sun/org/apache/xalan/internal/utils/SecuritySupport.java
@@ -57,7 +57,7 @@
         return securitySupport;
     }
 
-    static ClassLoader getContextClassLoader() {
+    public static ClassLoader getContextClassLoader() {
         return (ClassLoader) AccessController.doPrivileged(new PrivilegedAction() {
             public Object run() {
                 ClassLoader cl = null;
--- jaxp/src/com/sun/org/apache/xerces/internal/utils/ObjectFactory.java
+++ jaxp/src/com/sun/org/apache/xerces/internal/utils/ObjectFactory.java
@@ -39,7 +39,8 @@
     //
     // Constants
     //
-    private static final String DEFAULT_INTERNAL_CLASSES = "com.sun.org.apache.";
+    private static final String JAXP_INTERNAL = "com.sun.org.apache";
+    private static final String STAX_INTERNAL = "com.sun.xml.internal";
 
     /** Set to true for debugging */
     private static final boolean DEBUG = isDebugEnabled();
@@ -175,12 +176,8 @@
     public static Class findProviderClass(String className, boolean doFallback)
         throws ClassNotFoundException, ConfigurationError
     {
-        if (System.getSecurityManager()!=null) {
-            return Class.forName(className);
-        } else {
-            return findProviderClass (className,
+        return findProviderClass (className,
                 findClassLoader (), doFallback);
-        }
     }
     /**
      * Find a Class using the specified ClassLoader
@@ -193,7 +190,8 @@
         //restrict the access to package as speicified in java.security policy
         SecurityManager security = System.getSecurityManager();
         if (security != null) {
-            if (className.startsWith(DEFAULT_INTERNAL_CLASSES)) {
+            if (className.startsWith(JAXP_INTERNAL) ||
+                    className.startsWith(STAX_INTERNAL)) {
                 cl = null;
             } else {
                 final int lastDot = className.lastIndexOf(".");
@@ -205,7 +203,7 @@
         Class providerClass;
         if (cl == null) {
             //use the bootstrap ClassLoader.
-            providerClass = Class.forName(className);
+            providerClass = Class.forName(className, false, ObjectFactory.class.getClassLoader());
         } else {
             try {
                 providerClass = cl.loadClass(className);
--- jaxp/src/com/sun/org/apache/xml/internal/serializer/CharInfo.java
+++ jaxp/src/com/sun/org/apache/xml/internal/serializer/CharInfo.java
@@ -22,6 +22,11 @@
  */
 package com.sun.org.apache.xml.internal.serializer;
 
+import com.sun.org.apache.xalan.internal.utils.SecuritySupport;
+import com.sun.org.apache.xml.internal.serializer.utils.MsgKey;
+import com.sun.org.apache.xml.internal.serializer.utils.SystemIDResolver;
+import com.sun.org.apache.xml.internal.serializer.utils.Utils;
+import com.sun.org.apache.xml.internal.serializer.utils.WrappedRuntimeException;
 import java.io.BufferedReader;
 import java.io.InputStream;
 import java.io.InputStreamReader;
@@ -29,19 +34,11 @@
 import java.net.URL;
 import java.util.Enumeration;
 import java.util.HashMap;
+import java.util.Locale;
 import java.util.PropertyResourceBundle;
 import java.util.ResourceBundle;
-import java.security.AccessController;
-import java.security.PrivilegedAction;
-
 import javax.xml.transform.TransformerException;
 
-import com.sun.org.apache.xml.internal.serializer.utils.MsgKey;
-import com.sun.org.apache.xml.internal.serializer.utils.SystemIDResolver;
-import com.sun.org.apache.xml.internal.serializer.utils.Utils;
-import com.sun.org.apache.xml.internal.serializer.utils.WrappedRuntimeException;
-import com.sun.org.apache.xalan.internal.utils.ObjectFactory;
-
 /**
  * This class provides services that tell if a character should have
  * special treatement, such as entity reference substitution or normalization
@@ -176,13 +173,19 @@
         //      file
         //   3) try treating the resource a URI
 
-        if (internal) {
-            try {
+        try {
+            if (internal) {
                 // Load entity property files by using PropertyResourceBundle,
                 // cause of security issure for applets
                 entities = PropertyResourceBundle.getBundle(entitiesResource);
-            } catch (Exception e) {}
-        }
+            } else {
+                ClassLoader cl = SecuritySupport.getContextClassLoader();
+                if (cl != null) {
+                    entities = PropertyResourceBundle.getBundle(entitiesResource,
+                            Locale.getDefault(), cl);
+                }
+            }
+        } catch (Exception e) {}
 
         if (entities != null) {
             Enumeration keys = entities.getKeys();
@@ -198,6 +201,7 @@
             set(S_CARRIAGERETURN);
         } else {
             InputStream is = null;
+            String err = null;
 
             // Load user specified resource file by using URL loading, it
             // requires a valid URI as parameter
@@ -205,18 +209,22 @@
                 if (internal) {
                     is = CharInfo.class.getResourceAsStream(entitiesResource);
                 } else {
-                    ClassLoader cl = ObjectFactory.findClassLoader();
-                    if (cl == null) {
-                        is = ClassLoader.getSystemResourceAsStream(entitiesResource);
-                    } else {
-                        is = cl.getResourceAsStream(entitiesResource);
+                    ClassLoader cl = SecuritySupport.getContextClassLoader();
+                    if (cl != null) {
+                        try {
+                            is = cl.getResourceAsStream(entitiesResource);
+                        } catch (Exception e) {
+                            err = e.getMessage();
+                        }
                     }
 
                     if (is == null) {
                         try {
                             URL url = new URL(entitiesResource);
                             is = url.openStream();
-                        } catch (Exception e) {}
+                        } catch (Exception e) {
+                            err = e.getMessage();
+                        }
                     }
                 }
 
@@ -224,7 +232,7 @@
                     throw new RuntimeException(
                         Utils.messages.createMessage(
                             MsgKey.ER_RESOURCE_COULD_NOT_FIND,
-                            new Object[] {entitiesResource, entitiesResource}));
+                            new Object[] {entitiesResource, err}));
                 }
 
                 // Fix Bugzilla#4000: force reading in UTF-8
@@ -456,64 +464,56 @@
         return isCleanTextASCII[value];
     }
 
-//  In the future one might want to use the array directly and avoid
-//  the method call, but I think the JIT alreay inlines this well enough
-//  so don't do it (for now) - bjm
-//    public final boolean[] getASCIIClean()
-//    {
-//        return isCleanTextASCII;
-//    }
-
-
-    private static CharInfo getCharInfoBasedOnPrivilege(
-        final String entitiesFileName, final String method,
-        final boolean internal){
-            return (CharInfo) AccessController.doPrivileged(
-                new PrivilegedAction() {
-                        public Object run() {
-                            return new CharInfo(entitiesFileName,
-                              method, internal);}
-            });
+
+    /**
+     * Read an internal resource file that describes the mapping of
+     * characters to entity references; Construct a CharInfo object.
+     *
+     * @param entitiesFileName Name of entities resource file that should
+     * be loaded, which describes the mapping of characters to entity references.
+     * @param method the output method type, which should be one of "xml", "html", and "text".
+     * @return an instance of CharInfo
+     *
+     * @xsl.usage internal
+     */
+    static CharInfo getCharInfoInternal(String entitiesFileName, String method)
+    {
+        CharInfo charInfo = (CharInfo) m_getCharInfoCache.get(entitiesFileName);
+        if (charInfo != null) {
+            return charInfo;
+        }
+
+        charInfo = new CharInfo(entitiesFileName, method, true);
+        m_getCharInfoCache.put(entitiesFileName, charInfo);
+        return charInfo;
     }
 
     /**
-     * Factory that reads in a resource file that describes the mapping of
-     * characters to entity references.
+     * Constructs a CharInfo object using the following process to try reading
+     * the entitiesFileName parameter:
+     *
+     *   1) attempt to load it as a ResourceBundle
+     *   2) try using the class loader to find the specified file
+     *   3) try opening it as an URI
      *
-     * Resource files must be encoded in UTF-8 and have a format like:
+     * In case of 2 and 3, the resource file must be encoded in UTF-8 and have the
+     * following format:
      * <pre>
      * # First char # is a comment
      * Entity numericValue
      * quot 34
      * amp 38
      * </pre>
-     * (Note: Why don't we just switch to .properties files? Oct-01 -sc)
      *
-     * @param entitiesResource Name of entities resource file that should
-     * be loaded, which describes that mapping of characters to entity references.
-     * @param method the output method type, which should be one of "xml", "html", "text"...
-     *
-     * @xsl.usage internal
+     * @param entitiesFileName Name of entities resource file that should
+     * be loaded, which describes the mapping of characters to entity references.
+     * @param method the output method type, which should be one of "xml", "html", and "text".
+     * @return an instance of CharInfo
      */
     static CharInfo getCharInfo(String entitiesFileName, String method)
     {
-        CharInfo charInfo = (CharInfo) m_getCharInfoCache.get(entitiesFileName);
-        if (charInfo != null) {
-            return charInfo;
-        }
-
-        // try to load it internally - cache
-        try {
-            charInfo = getCharInfoBasedOnPrivilege(entitiesFileName,
-                                        method, true);
-            m_getCharInfoCache.put(entitiesFileName, charInfo);
-            return charInfo;
-        } catch (Exception e) {}
-
-        // try to load it externally - do not cache
         try {
-            return getCharInfoBasedOnPrivilege(entitiesFileName,
-                                method, false);
+            return new CharInfo(entitiesFileName, method, false);
         } catch (Exception e) {}
 
         String absoluteEntitiesFileName;
@@ -530,8 +530,7 @@
             }
         }
 
-        return getCharInfoBasedOnPrivilege(entitiesFileName,
-                                method, false);
+        return new CharInfo(absoluteEntitiesFileName, method, false);
     }
 
     /** Table of user-specified char infos. */
--- jaxp/src/com/sun/org/apache/xml/internal/serializer/ToHTMLStream.java
+++ jaxp/src/com/sun/org/apache/xml/internal/serializer/ToHTMLStream.java
@@ -60,7 +60,7 @@
      */
     private static final CharInfo m_htmlcharInfo =
 //        new CharInfo(CharInfo.HTML_ENTITIES_RESOURCE);
-        CharInfo.getCharInfo(CharInfo.HTML_ENTITIES_RESOURCE, Method.HTML);
+        CharInfo.getCharInfoInternal(CharInfo.HTML_ENTITIES_RESOURCE, Method.HTML);
 
     /** A digital search trie for fast, case insensitive lookup of ElemDesc objects. */
     static final Trie m_elementFlags = new Trie();
--- jaxp/src/com/sun/org/apache/xml/internal/serializer/ToXMLStream.java
+++ jaxp/src/com/sun/org/apache/xml/internal/serializer/ToXMLStream.java
@@ -58,7 +58,7 @@
      */
     private static CharInfo m_xmlcharInfo =
 //      new CharInfo(CharInfo.XML_ENTITIES_RESOURCE);
-        CharInfo.getCharInfo(CharInfo.XML_ENTITIES_RESOURCE, Method.XML);
+        CharInfo.getCharInfoInternal(CharInfo.XML_ENTITIES_RESOURCE, Method.XML);
 
     /**
      * Default constructor.
--- jaxws/.hgtags
+++ jaxws/.hgtags
@@ -253,3 +253,16 @@
 aabc90596123d4eb7e576ecb0e7a843a9415d8eb jdk8-b129
 4195c0956930bf4e161ac6b0def0d6295bfba58f jdk8-b130
 012b935707fa24a1a88b429255f77b386e082643 jdk8-b131
+c2be0dd15dbf0c23ee693a1af32f8f6a012abd1e jdk8-b132
+2fcd3ddb57a6c71e082c7f113f4063de9a967fcd jdk8u5-b01
+384ccf4e14cb90c89570e16a5f4ca440a69d6d93 jdk8u5-b02
+e423a4f2ec72ea0e24bea0fa77dd105095bbee67 jdk8u5-b03
+738b966ee0b00d994445d34eb7eb087bd41a5478 jdk8u5-b04
+3960c6ef7bd1782d6357c510dab393d291164045 jdk8u5-b05
+0543f4dddddc67b142b4706b2d403a654809e605 jdk8u5-b06
+0eb7f9f88e93587ace50614385f85afd221f5cb1 jdk8u5-b07
+3ee93ab2a3739ae5e4e209ac14c36e7374f3f748 jdk8u5-b08
+6cd5065081477be64e4e99ef98ec68464dde2d72 jdk8u5-b09
+22a840b408eb0242e363700843fba3f4988df749 jdk8u5-b10
+75fd3933daaf5826e7c03bfb318026ac8a4c07ef jdk8u5-b11
+e2454d30b525bcb6ebcc711bd2928fbd29c11143 jdk8u5-b12
--- jaxws/.jcheck/conf
+++ jaxws/.jcheck/conf
@@ -1 +1,2 @@
 project=jdk8
+bugids=dup
--- jaxws/THIRD_PARTY_README
+++ jaxws/THIRD_PARTY_README
@@ -1399,13 +1399,13 @@
 
 -------------------------------------------------------------------------------
 
-%% This notice is provided with respect to Little CMS 2.4, which may be 
+%% This notice is provided with respect to Little CMS 2.5, which may be 
 included with JRE 8, JDK 8, and OpenJDK 8.
 
 --- begin of LICENSE ---
 
 Little CMS
-Copyright (c) 1998-2010 Marti Maria Saguer
+Copyright (c) 1998-2011 Marti Maria Saguer
 
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
--- jaxws/src/share/jaf_classes/javax/activation/CommandMap.java
+++ jaxws/src/share/jaf_classes/javax/activation/CommandMap.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2005, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,6 +25,9 @@
 
 package javax.activation;
 
+import java.util.Map;
+import java.util.WeakHashMap;
+
 
 /**
  * The CommandMap class provides an interface to a registry of
@@ -38,6 +41,8 @@
  */
 public abstract class CommandMap {
     private static CommandMap defaultCommandMap = null;
+    private static Map<ClassLoader,CommandMap> map =
+                                new WeakHashMap<ClassLoader,CommandMap>();
 
     /**
      * Get the default CommandMap.
@@ -56,11 +61,18 @@
      *
      * @return the CommandMap
      */
-    public static CommandMap getDefaultCommandMap() {
-        if (defaultCommandMap == null)
-            defaultCommandMap = new MailcapCommandMap();
-
-        return defaultCommandMap;
+    public static synchronized CommandMap getDefaultCommandMap() {
+        if (defaultCommandMap != null)
+            return defaultCommandMap;
+
+        // fetch per-thread-context-class-loader default
+        ClassLoader tccl = SecuritySupport.getContextClassLoader();
+        CommandMap def = map.get(tccl);
+        if (def == null) {
+            def = new MailcapCommandMap();
+            map.put(tccl, def);
+        }
+        return def;
     }
 
     /**
@@ -71,7 +83,7 @@
      * @exception SecurityException if the caller doesn't have permission
      *                                  to change the default
      */
-    public static void setDefaultCommandMap(CommandMap commandMap) {
+    public static synchronized void setDefaultCommandMap(CommandMap commandMap) {
         SecurityManager security = System.getSecurityManager();
         if (security != null) {
             try {
@@ -79,13 +91,16 @@
                 security.checkSetFactory();
             } catch (SecurityException ex) {
                 // otherwise, we also allow it if this code and the
-                // factory come from the same class loader (e.g.,
+                // factory come from the same (non-system) class loader (e.g.,
                 // the JAF classes were loaded with the applet classes).
-                if (CommandMap.class.getClassLoader() !=
+                if (CommandMap.class.getClassLoader() == null ||
+                    CommandMap.class.getClassLoader() !=
                             commandMap.getClass().getClassLoader())
                     throw ex;
             }
         }
+        // remove any per-thread-context-class-loader CommandMap
+        map.remove(SecuritySupport.getContextClassLoader());
         defaultCommandMap = commandMap;
     }
 
--- jaxws/src/share/jaf_classes/javax/activation/DataHandler.java
+++ jaxws/src/share/jaf_classes/javax/activation/DataHandler.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -368,7 +368,12 @@
         // if it's not set, set it...
         if (transferFlavors == emptyFlavors)
             transferFlavors = getDataContentHandler().getTransferDataFlavors();
-        return transferFlavors;
+
+        if (transferFlavors == emptyFlavors)
+            return transferFlavors;
+        else
+            return transferFlavors.clone();
+
     }
 
     /**
--- jaxws/src/share/jaf_classes/javax/activation/FileTypeMap.java
+++ jaxws/src/share/jaf_classes/javax/activation/FileTypeMap.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2005, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -26,6 +26,8 @@
 package javax.activation;
 
 import java.io.File;
+import java.util.Map;
+import java.util.WeakHashMap;
 
 /**
  * The FileTypeMap is an abstract class that provides a data typing
@@ -48,6 +50,8 @@
 public abstract class FileTypeMap {
 
     private static FileTypeMap defaultMap = null;
+    private static Map<ClassLoader,FileTypeMap> map =
+                                new WeakHashMap<ClassLoader,FileTypeMap>();
 
     /**
      * The default constructor.
@@ -78,11 +82,11 @@
      * Sets the default FileTypeMap for the system. This instance
      * will be returned to callers of getDefaultFileTypeMap.
      *
-     * @param map The FileTypeMap.
+     * @param fileTypeMap The FileTypeMap.
      * @exception SecurityException if the caller doesn't have permission
      *                                  to change the default
      */
-    public static void setDefaultFileTypeMap(FileTypeMap map) {
+    public static synchronized void setDefaultFileTypeMap(FileTypeMap fileTypeMap) {
         SecurityManager security = System.getSecurityManager();
         if (security != null) {
             try {
@@ -90,14 +94,17 @@
                 security.checkSetFactory();
             } catch (SecurityException ex) {
                 // otherwise, we also allow it if this code and the
-                // factory come from the same class loader (e.g.,
+                // factory come from the same (non-system) class loader (e.g.,
                 // the JAF classes were loaded with the applet classes).
-                if (FileTypeMap.class.getClassLoader() !=
-                        map.getClass().getClassLoader())
+                if (FileTypeMap.class.getClassLoader() == null ||
+                    FileTypeMap.class.getClassLoader() !=
+                        fileTypeMap.getClass().getClassLoader())
                     throw ex;
             }
         }
-        defaultMap = map;
+        // remove any per-thread-context-class-loader FileTypeMap
+        map.remove(SecuritySupport.getContextClassLoader());
+        defaultMap = fileTypeMap;
     }
 
     /**
@@ -109,10 +116,17 @@
      * @return The default FileTypeMap
      * @see javax.activation.FileTypeMap#setDefaultFileTypeMap
      */
-    public static FileTypeMap getDefaultFileTypeMap() {
-        // XXX - probably should be synchronized
-        if (defaultMap == null)
-            defaultMap = new MimetypesFileTypeMap();
-        return defaultMap;
+    public static synchronized FileTypeMap getDefaultFileTypeMap() {
+        if (defaultMap != null)
+            return defaultMap;
+
+        // fetch per-thread-context-class-loader default
+        ClassLoader tccl = SecuritySupport.getContextClassLoader();
+        FileTypeMap def = map.get(tccl);
+        if (def == null) {
+            def = new MimetypesFileTypeMap();
+            map.put(tccl, def);
+        }
+        return def;
     }
 }
--- jaxws/src/share/jaf_classes/javax/activation/MailcapCommandMap.java
+++ jaxws/src/share/jaf_classes/javax/activation/MailcapCommandMap.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2005, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -120,11 +120,7 @@
 public class MailcapCommandMap extends CommandMap {
     /*
      * We manage a collection of databases, searched in order.
-     * The default database is shared between all instances
-     * of this class.
-     * XXX - Can we safely share more databases between instances?
      */
-    private static MailcapFile defDB = null;
     private MailcapFile[] DB;
     private static final int PROG = 0;  // programmatically added entries
 
@@ -164,14 +160,10 @@
         loadAllResources(dbv, "META-INF/mailcap");
 
         LogSupport.log("MailcapCommandMap: load DEF");
-        synchronized (MailcapCommandMap.class) {
-            // see if another instance has created this yet.
-            if (defDB == null)
-                defDB = loadResource("/META-INF/mailcap.default");
-        }
+        mf = loadResource("/META-INF/mailcap.default");
 
-        if (defDB != null)
-            dbv.add(defDB);
+        if (mf != null)
+            dbv.add(mf);
 
         DB = new MailcapFile[dbv.size()];
         DB = (MailcapFile[])dbv.toArray(DB);
--- jaxws/src/share/jaf_classes/javax/activation/MimetypesFileTypeMap.java
+++ jaxws/src/share/jaf_classes/javax/activation/MimetypesFileTypeMap.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2005, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -69,11 +69,7 @@
 public class MimetypesFileTypeMap extends FileTypeMap {
     /*
      * We manage a collection of databases, searched in order.
-     * The default database is shared between all instances
-     * of this class.
-     * XXX - Can we safely share more databases between instances?
      */
-    private static MimeTypeFile defDB = null;
     private MimeTypeFile[] DB;
     private static final int PROG = 0;  // programmatically added entries
 
@@ -114,14 +110,10 @@
         loadAllResources(dbv, "META-INF/mime.types");
 
         LogSupport.log("MimetypesFileTypeMap: load DEF");
-        synchronized (MimetypesFileTypeMap.class) {
-            // see if another instance has created this yet.
-            if (defDB == null)
-                defDB = loadResource("/META-INF/mimetypes.default");
-        }
+        mf = loadResource("/META-INF/mimetypes.default");
 
-        if (defDB != null)
-            dbv.addElement(defDB);
+        if (mf != null)
+            dbv.addElement(mf);
 
         DB = new MimeTypeFile[dbv.size()];
         dbv.copyInto(DB);
--- jaxws/src/share/jaxws_classes/com/sun/tools/internal/ws/wsdl/parser/ContextClassloaderLocal.java	1969-12-31 19:00:00.000000000 -0500
+++ jaxws/src/share/jaxws_classes/com/sun/tools/internal/ws/wsdl/parser/ContextClassloaderLocal.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.sun.tools.internal.ws.wsdl.parser;
+
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+import java.text.MessageFormat;
+import java.util.ResourceBundle;
+import java.util.WeakHashMap;
+
+/**
+ * Simple utility ensuring that the value is cached only in case it is non-internal implementation
+ */
+abstract class ContextClassloaderLocal<V> {
+
+    private static final String FAILED_TO_CREATE_NEW_INSTANCE = "FAILED_TO_CREATE_NEW_INSTANCE";
+
+    private WeakHashMap<ClassLoader, V> CACHE = new WeakHashMap<ClassLoader, V>();
+
+    public V get() throws Error {
+        ClassLoader tccl = getContextClassLoader();
+        V instance = CACHE.get(tccl);
+        if (instance == null) {
+            instance = createNewInstance();
+            CACHE.put(tccl, instance);
+        }
+        return instance;
+    }
+
+    public void set(V instance) {
+        CACHE.put(getContextClassLoader(), instance);
+    }
+
+    protected abstract V initialValue() throws Exception;
+
+    private V createNewInstance() {
+        try {
+            return initialValue();
+        } catch (Exception e) {
+            throw new Error(format(FAILED_TO_CREATE_NEW_INSTANCE, getClass().getName()), e);
+        }
+    }
+
+    private static String format(String property, Object... args) {
+        String text = ResourceBundle.getBundle(ContextClassloaderLocal.class.getName()).getString(property);
+        return MessageFormat.format(text, args);
+    }
+
+    private static ClassLoader getContextClassLoader() {
+        return (ClassLoader)
+                AccessController.doPrivileged(new PrivilegedAction() {
+                    public Object run() {
+                        ClassLoader cl = null;
+                        try {
+                            cl = Thread.currentThread().getContextClassLoader();
+                        } catch (SecurityException ex) {
+                        }
+                        return cl;
+                    }
+                });
+    }
+}
+
--- jaxws/src/share/jaxws_classes/com/sun/tools/internal/ws/wsdl/parser/ContextClassloaderLocal.properties	1969-12-31 19:00:00.000000000 -0500
+++ jaxws/src/share/jaxws_classes/com/sun/tools/internal/ws/wsdl/parser/ContextClassloaderLocal.properties
@@ -0,0 +1,27 @@
+#
+# Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+# Error messages for ContextClassloaderLocal utility class
+FAILED_TO_CREATE_NEW_INSTANCE=Failed to create new instance of {0}
+
--- jaxws/src/share/jaxws_classes/com/sun/tools/internal/ws/wsdl/parser/Internalizer.java
+++ jaxws/src/share/jaxws_classes/com/sun/tools/internal/ws/wsdl/parser/Internalizer.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -60,12 +60,10 @@
  */
 public class Internalizer {
 
-    private static final XPathFactory xpf = XmlUtil.newXPathFactory(true);
-    private final XPath xpath = xpf.newXPath();
+    private final XPath xpath = xpf.get().newXPath();
     private final DOMForest forest;
     private final ErrorReceiver errorReceiver;
 
-
     public Internalizer(DOMForest forest, WsimportOptions options, ErrorReceiver errorReceiver) {
         this.forest = forest;
         this.errorReceiver = errorReceiver;
@@ -77,6 +75,12 @@
         }
     }
 
+    private static final ContextClassloaderLocal<XPathFactory> xpf = new ContextClassloaderLocal<XPathFactory>() {
+        @Override
+        protected XPathFactory initialValue() throws Exception {
+            return XPathFactory.newInstance();
+        }
+    };
     /**
      * Validates attributes of a &lt;JAXWS:bindings> element.
      */
--- jaxws/src/share/jaxws_classes/com/sun/tools/internal/ws/wsdl/parser/JAXWSBindingExtensionHandler.java
+++ jaxws/src/share/jaxws_classes/com/sun/tools/internal/ws/wsdl/parser/JAXWSBindingExtensionHandler.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -54,8 +54,14 @@
 public class JAXWSBindingExtensionHandler extends AbstractExtensionHandler {
 
     // xml security enabled always, xpath used for parsing "part" attribute
-    private static final XPathFactory xpf = XmlUtil.newXPathFactory(true);
-    private final XPath xpath = xpf.newXPath();
+    private static final ContextClassloaderLocal<XPathFactory> xpf = new ContextClassloaderLocal<XPathFactory>() {
+        @Override
+        protected XPathFactory initialValue() throws Exception {
+            return XPathFactory.newInstance();
+        }
+    };
+
+    private final XPath xpath = xpf.get().newXPath();
 
     public JAXWSBindingExtensionHandler(Map<String, AbstractExtensionHandler> extensionHandlerMap) {
         super(extensionHandlerMap);
--- jaxws/src/share/jaxws_classes/com/sun/tools/internal/xjc/reader/internalizer/ContextClassloaderLocal.java	1969-12-31 19:00:00.000000000 -0500
+++ jaxws/src/share/jaxws_classes/com/sun/tools/internal/xjc/reader/internalizer/ContextClassloaderLocal.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.sun.tools.internal.xjc.reader.internalizer;
+
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+import java.text.MessageFormat;
+import java.util.ResourceBundle;
+import java.util.WeakHashMap;
+
+/**
+ * Simple utility ensuring that the value is cached only in case it is non-internal implementation
+ */
+abstract class ContextClassloaderLocal<V> {
+
+    private static final String FAILED_TO_CREATE_NEW_INSTANCE = "FAILED_TO_CREATE_NEW_INSTANCE";
+
+    private WeakHashMap<ClassLoader, V> CACHE = new WeakHashMap<ClassLoader, V>();
+
+    public V get() throws Error {
+        ClassLoader tccl = getContextClassLoader();
+        V instance = CACHE.get(tccl);
+        if (instance == null) {
+            instance = createNewInstance();
+            CACHE.put(tccl, instance);
+        }
+        return instance;
+    }
+
+    public void set(V instance) {
+        CACHE.put(getContextClassLoader(), instance);
+    }
+
+    protected abstract V initialValue() throws Exception;
+
+    private V createNewInstance() {
+        try {
+            return initialValue();
+        } catch (Exception e) {
+            throw new Error(format(FAILED_TO_CREATE_NEW_INSTANCE, getClass().getName()), e);
+        }
+    }
+
+    private static String format(String property, Object... args) {
+        String text = ResourceBundle.getBundle(ContextClassloaderLocal.class.getName()).getString(property);
+        return MessageFormat.format(text, args);
+    }
+
+    private static ClassLoader getContextClassLoader() {
+        return (ClassLoader)
+                AccessController.doPrivileged(new PrivilegedAction() {
+                    public Object run() {
+                        ClassLoader cl = null;
+                        try {
+                            cl = Thread.currentThread().getContextClassLoader();
+                        } catch (SecurityException ex) {
+                        }
+                        return cl;
+                    }
+                });
+    }
+}
+
--- jaxws/src/share/jaxws_classes/com/sun/tools/internal/xjc/reader/internalizer/ContextClassloaderLocal.properties	1969-12-31 19:00:00.000000000 -0500
+++ jaxws/src/share/jaxws_classes/com/sun/tools/internal/xjc/reader/internalizer/ContextClassloaderLocal.properties
@@ -0,0 +1,27 @@
+#
+# Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+# Error messages for ContextClassloaderLocal utility class
+FAILED_TO_CREATE_NEW_INSTANCE=Failed to create new instance of {0}
+
--- jaxws/src/share/jaxws_classes/com/sun/tools/internal/xjc/reader/internalizer/Internalizer.java
+++ jaxws/src/share/jaxws_classes/com/sun/tools/internal/xjc/reader/internalizer/Internalizer.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -76,8 +76,6 @@
 
     private static final String WSDL_NS = "http://schemas.xmlsoap.org/wsdl/";
 
-    private static XPathFactory xpf = null;
-
     private final XPath xpath;
 
     /**
@@ -99,12 +97,7 @@
         this.errorHandler = forest.getErrorHandler();
         this.forest = forest;
         this.enableSCD = enableSCD;
-        synchronized (this) {
-            if (xpf == null) {
-                xpf = XmlFactory.createXPathFactory(disableSecureProcessing);
-            }
-        }
-        xpath = xpf.newXPath();
+        xpath = XmlFactory.createXPathFactory(disableSecureProcessing).newXPath();
     }
 
     /**
--- jaxws/src/share/jaxws_classes/com/sun/xml/internal/bind/DatatypeConverterImpl.java
+++ jaxws/src/share/jaxws_classes/com/sun/xml/internal/bind/DatatypeConverterImpl.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,9 +27,14 @@
 
 import java.math.BigDecimal;
 import java.math.BigInteger;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 import java.util.Calendar;
+import java.util.Collections;
 import java.util.GregorianCalendar;
+import java.util.Map;
 import java.util.TimeZone;
+import java.util.WeakHashMap;
 
 import javax.xml.bind.DatatypeConverter;
 import javax.xml.bind.DatatypeConverterInterface;
@@ -356,7 +361,7 @@
 
     public static GregorianCalendar _parseDateTime(CharSequence s) {
         String val = WhiteSpaceProcessor.trim(s).toString();
-        return datatypeFactory.newXMLGregorianCalendar(val).toGregorianCalendar();
+        return getDatatypeFactory().newXMLGregorianCalendar(val).toGregorianCalendar();
     }
 
     public static String _printDateTime(Calendar val) {
@@ -722,14 +727,30 @@
         }
         return false;
     }
-    private static final DatatypeFactory datatypeFactory;
 
-    static {
-        try {
-            datatypeFactory = DatatypeFactory.newInstance();
-        } catch (DatatypeConfigurationException e) {
-            throw new Error(e);
+    private static final Map<ClassLoader, DatatypeFactory> DF_CACHE = Collections.synchronizedMap(new WeakHashMap<ClassLoader, DatatypeFactory>());
+
+    public static DatatypeFactory getDatatypeFactory() {
+        ClassLoader tccl = AccessController.doPrivileged(new PrivilegedAction<ClassLoader>() {
+            public ClassLoader run() {
+                return Thread.currentThread().getContextClassLoader();
+            }
+        });
+        DatatypeFactory df = DF_CACHE.get(tccl);
+        if (df == null) {
+            synchronized (DatatypeConverterImpl.class) {
+                df = DF_CACHE.get(tccl);
+                if (df == null) { // to prevent multiple initialization
+                    try {
+                        df = DatatypeFactory.newInstance();
+                    } catch (DatatypeConfigurationException e) {
+                        throw new Error(Messages.FAILED_TO_INITIALE_DATATYPE_FACTORY.format(),e);
+                    }
+                    DF_CACHE.put(tccl, df);
+                }
+            }
         }
+        return df;
     }
 
     private static final class CalendarFormatter {
@@ -1045,7 +1066,7 @@
 
     @Deprecated
     public Calendar parseTime(String lexicalXSDTime) {
-        return datatypeFactory.newXMLGregorianCalendar(lexicalXSDTime).toGregorianCalendar();
+        return getDatatypeFactory().newXMLGregorianCalendar(lexicalXSDTime).toGregorianCalendar();
     }
 
     @Deprecated
@@ -1055,7 +1076,7 @@
 
     @Deprecated
     public Calendar parseDate(String lexicalXSDDate) {
-        return datatypeFactory.newXMLGregorianCalendar(lexicalXSDDate).toGregorianCalendar();
+        return getDatatypeFactory().newXMLGregorianCalendar(lexicalXSDDate).toGregorianCalendar();
     }
 
     @Deprecated
--- jaxws/src/share/jaxws_classes/com/sun/xml/internal/bind/Messages.java	1969-12-31 19:00:00.000000000 -0500
+++ jaxws/src/share/jaxws_classes/com/sun/xml/internal/bind/Messages.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.sun.xml.internal.bind;
+
+import java.text.MessageFormat;
+import java.util.ResourceBundle;
+
+/**
+ * Message resources
+ */
+enum Messages {
+    FAILED_TO_INITIALE_DATATYPE_FACTORY, // 0 args
+    ;
+
+    private static final ResourceBundle rb = ResourceBundle.getBundle(Messages.class.getName());
+
+    @Override
+    public String toString() {
+        return format();
+    }
+
+    public String format( Object... args ) {
+        return MessageFormat.format( rb.getString(name()), args );
+    }
+}
--- jaxws/src/share/jaxws_classes/com/sun/xml/internal/bind/Messages.properties	1969-12-31 19:00:00.000000000 -0500
+++ jaxws/src/share/jaxws_classes/com/sun/xml/internal/bind/Messages.properties
@@ -0,0 +1,27 @@
+#
+# Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+
+FAILED_TO_INITIALE_DATATYPE_FACTORY = \
+    Failed to initialize JAXP 1.3 DatatypeFactory class.
--- jaxws/src/share/jaxws_classes/com/sun/xml/internal/bind/v2/model/impl/Messages.java
+++ jaxws/src/share/jaxws_classes/com/sun/xml/internal/bind/v2/model/impl/Messages.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -60,7 +60,6 @@
     PROPERTY_ORDER_CONTAINS_UNUSED_ENTRY, // 2 args
 
     INVALID_XML_ENUM_VALUE, // 2 arg
-    FAILED_TO_INITIALE_DATATYPE_FACTORY, // 0 args
     NO_IMAGE_WRITER, // 1 arg
 
     ILLEGAL_MIME_TYPE, // 2 args
--- jaxws/src/share/jaxws_classes/com/sun/xml/internal/bind/v2/model/impl/RuntimeBuiltinLeafInfoImpl.java
+++ jaxws/src/share/jaxws_classes/com/sun/xml/internal/bind/v2/model/impl/RuntimeBuiltinLeafInfoImpl.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -63,9 +63,7 @@
 import javax.imageio.stream.ImageOutputStream;
 import javax.xml.bind.ValidationEvent;
 import javax.xml.bind.helpers.ValidationEventImpl;
-import javax.xml.datatype.DatatypeConfigurationException;
 import javax.xml.datatype.DatatypeConstants;
-import javax.xml.datatype.DatatypeFactory;
 import javax.xml.datatype.Duration;
 import javax.xml.datatype.XMLGregorianCalendar;
 import javax.xml.namespace.QName;
@@ -568,7 +566,8 @@
 
                 public XMLGregorianCalendar parse(CharSequence lexical) throws SAXException {
                     try {
-                        return datatypeFactory.newXMLGregorianCalendar(lexical.toString().trim()); // (.trim() - issue 396)
+                        return DatatypeConverterImpl.getDatatypeFactory()
+                                .newXMLGregorianCalendar(lexical.toString().trim()); // (.trim() - issue 396)
                     } catch (Exception e) {
                         UnmarshallingContext.getInstance().handleError(e);
                         return null;
@@ -838,7 +837,7 @@
 
                 public Duration parse(CharSequence lexical) {
                     TODO.checkSpec("JSR222 Issue #42");
-                    return datatypeFactory.newDuration(lexical.toString());
+                    return DatatypeConverterImpl.getDatatypeFactory().newDuration(lexical.toString());
                 }
             });
         primaryList.add(
@@ -879,21 +878,6 @@
         }
     }
 
-
-    /**
-     * Cached instance of {@link DatatypeFactory} to create
-     * {@link XMLGregorianCalendar} and {@link Duration}.
-     */
-    private static final DatatypeFactory datatypeFactory = init();
-
-    private static DatatypeFactory init() {
-        try {
-            return DatatypeFactory.newInstance();
-        } catch (DatatypeConfigurationException e) {
-            throw new Error(Messages.FAILED_TO_INITIALE_DATATYPE_FACTORY.format(),e);
-        }
-    }
-
         private static void checkXmlGregorianCalendarFieldRef(QName type,
                 XMLGregorianCalendar cal)throws javax.xml.bind.MarshalException{
                 StringBuilder buf = new StringBuilder();
--- jaxws/src/share/jaxws_classes/com/sun/xml/internal/bind/v2/runtime/JAXBContextImpl.java
+++ jaxws/src/share/jaxws_classes/com/sun/xml/internal/bind/v2/runtime/JAXBContextImpl.java
@@ -129,14 +129,6 @@
     private final Map<TypeReference,Bridge> bridges = new LinkedHashMap<TypeReference,Bridge>();
 
     /**
-     * Shared instance of {@link TransformerFactory}.
-     * Lock before use, because a {@link TransformerFactory} is not thread-safe
-     * whereas {@link JAXBContextImpl} is.
-     * Lazily created.
-     */
-    private volatile static SAXTransformerFactory tf;
-
-    /**
      * Shared instance of {@link DocumentBuilder}.
      * Lock before use. Lazily created.
      */
@@ -705,13 +697,7 @@
      */
     static Transformer createTransformer(boolean disableSecureProcessing) {
         try {
-            if (tf==null) {
-                synchronized(JAXBContextImpl.class) {
-                    if (tf==null) {
-                        tf = (SAXTransformerFactory)XmlFactory.createTransformerFactory(disableSecureProcessing);
-                    }
-                }
-            }
+            SAXTransformerFactory tf = (SAXTransformerFactory)XmlFactory.createTransformerFactory(disableSecureProcessing);
             return tf.newTransformer();
         } catch (TransformerConfigurationException e) {
             throw new Error(e); // impossible
@@ -723,13 +709,7 @@
      */
     public static TransformerHandler createTransformerHandler(boolean disableSecureProcessing) {
         try {
-            if (tf==null) {
-                synchronized(JAXBContextImpl.class) {
-                    if (tf==null) {
-                        tf = (SAXTransformerFactory)XmlFactory.createTransformerFactory(disableSecureProcessing);
-                    }
-                }
-            }
+            SAXTransformerFactory tf = (SAXTransformerFactory)XmlFactory.createTransformerFactory(disableSecureProcessing);
             return tf.newTransformerHandler();
         } catch (TransformerConfigurationException e) {
             throw new Error(e); // impossible
--- jaxws/src/share/jaxws_classes/com/sun/xml/internal/bind/v2/runtime/output/XMLStreamWriterOutput.java
+++ jaxws/src/share/jaxws_classes/com/sun/xml/internal/bind/v2/runtime/output/XMLStreamWriterOutput.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -153,7 +153,6 @@
         }
     }
 
-
     /**
      * Reference to FI's XMLStreamWriter class, if FI can be loaded.
      */
@@ -162,9 +161,8 @@
 
     private static Class initFIStAXWriterClass() {
         try {
-            ClassLoader loader = getClassLoader();
-            Class llfisw = Class.forName("com.sun.xml.internal.org.jvnet.fastinfoset.stax.LowLevelFastInfosetStreamWriter", true, loader);
-            Class sds = loader.loadClass("com.sun.xml.internal.fastinfoset.stax.StAXDocumentSerializer");
+            Class<?> llfisw = Class.forName("com.sun.xml.internal.org.jvnet.fastinfoset.stax.LowLevelFastInfosetStreamWriter");
+            Class<?> sds = Class.forName("com.sun.xml.internal.fastinfoset.stax.StAXDocumentSerializer");
             // Check if StAXDocumentSerializer implements LowLevelFastInfosetStreamWriter
             if (llfisw.isAssignableFrom(sds))
                 return sds;
@@ -179,8 +177,7 @@
         try {
             if (FI_STAX_WRITER_CLASS == null)
                 return null;
-            ClassLoader loader = getClassLoader();
-            Class c = Class.forName("com.sun.xml.internal.bind.v2.runtime.output.FastInfosetStreamWriterOutput", true, loader);
+            Class c = Class.forName("com.sun.xml.internal.bind.v2.runtime.output.FastInfosetStreamWriterOutput");
             return c.getConstructor(FI_STAX_WRITER_CLASS, JAXBContextImpl.class);
         } catch (Throwable e) {
             return null;
@@ -195,8 +192,7 @@
 
     private static Class initStAXExWriterClass() {
         try {
-            ClassLoader loader = getClassLoader();
-            return Class.forName("com.sun.xml.internal.org.jvnet.staxex.XMLStreamWriterEx",true,loader);
+            return Class.forName("com.sun.xml.internal.org.jvnet.staxex.XMLStreamWriterEx");
         } catch (Throwable e) {
             return null;
         }
@@ -204,20 +200,11 @@
 
     private static Constructor<? extends XmlOutput> initStAXExOutputClass() {
         try {
-            ClassLoader loader = getClassLoader();
-            Class c = Class.forName("com.sun.xml.internal.bind.v2.runtime.output.StAXExStreamWriterOutput",true, loader);
+            Class c = Class.forName("com.sun.xml.internal.bind.v2.runtime.output.StAXExStreamWriterOutput");
             return c.getConstructor(STAXEX_WRITER_CLASS);
         } catch (Throwable e) {
             return null;
         }
     }
 
-    private static ClassLoader getClassLoader() {
-        ClassLoader cl = SecureLoader.getClassClassLoader(UnmarshallerImpl.class);
-        if (cl == null) {
-            cl = SecureLoader.getContextClassLoader();
-        }
-        return cl;
-    }
-
 }
--- jaxws/src/share/jaxws_classes/com/sun/xml/internal/bind/v2/runtime/reflect/Messages.properties
+++ jaxws/src/share/jaxws_classes/com/sun/xml/internal/bind/v2/runtime/reflect/Messages.properties
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -38,3 +38,6 @@
 NO_GETTER = \
     The property has a setter "{0}" but no getter. \
     For marshaller, please define getters.
+
+INVALID_XML_ENUM_VALUE = \
+    "{0}" is not a valid value for {1}.
--- jaxws/src/share/jaxws_classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/StAXStreamConnector.java
+++ jaxws/src/share/jaxws_classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/StAXStreamConnector.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -336,9 +336,8 @@
 
     private static Class initFIStAXReaderClass() {
         try {
-            ClassLoader cl = getClassLoader();
-            Class fisr = cl.loadClass("com.sun.xml.internal.org.jvnet.fastinfoset.stax.FastInfosetStreamReader");
-            Class sdp = cl.loadClass("com.sun.xml.internal.fastinfoset.stax.StAXDocumentParser");
+            Class<?> fisr = Class.forName("com.sun.xml.internal.org.jvnet.fastinfoset.stax.FastInfosetStreamReader");
+            Class<?> sdp = Class.forName("com.sun.xml.internal.fastinfoset.stax.StAXDocumentParser");
             // Check if StAXDocumentParser implements FastInfosetStreamReader
             if (fisr.isAssignableFrom(sdp))
                 return sdp;
@@ -354,7 +353,7 @@
             if (FI_STAX_READER_CLASS == null)
                 return null;
 
-            Class c = getClassLoader().loadClass(
+            Class c = Class.forName(
                     "com.sun.xml.internal.bind.v2.runtime.unmarshaller.FastInfosetConnector");
             return c.getConstructor(FI_STAX_READER_CLASS,XmlVisitor.class);
         } catch (Throwable e) {
@@ -370,7 +369,7 @@
 
     private static Class initStAXExReader() {
         try {
-            return getClassLoader().loadClass("com.sun.xml.internal.org.jvnet.staxex.XMLStreamReaderEx");
+            return Class.forName("com.sun.xml.internal.org.jvnet.staxex.XMLStreamReaderEx");
         } catch (Throwable e) {
             return null;
         }
@@ -378,19 +377,11 @@
 
     private static Constructor<? extends StAXConnector> initStAXExConnector() {
         try {
-            Class c = getClassLoader().loadClass("com.sun.xml.internal.bind.v2.runtime.unmarshaller.StAXExConnector");
+            Class c = Class.forName("com.sun.xml.internal.bind.v2.runtime.unmarshaller.StAXExConnector");
             return c.getConstructor(STAX_EX_READER_CLASS,XmlVisitor.class);
         } catch (Throwable e) {
             return null;
         }
     }
 
-    private static ClassLoader getClassLoader() {
-        ClassLoader cl = SecureLoader.getClassClassLoader(UnmarshallerImpl.class);
-        if (cl == null) {
-            cl = SecureLoader.getContextClassLoader();
-        }
-        return cl;
-    }
-
 }
--- jaxws/src/share/jaxws_classes/com/sun/xml/internal/messaging/saaj/soap/AttachmentPartImpl.java
+++ jaxws/src/share/jaxws_classes/com/sun/xml/internal/messaging/saaj/soap/AttachmentPartImpl.java
@@ -62,61 +62,6 @@
         Logger.getLogger(LogDomainConstants.SOAP_DOMAIN,
                          "com.sun.xml.internal.messaging.saaj.soap.LocalStrings");
 
-    static {
-        try {
-            CommandMap map = CommandMap.getDefaultCommandMap();
-            if (map instanceof MailcapCommandMap) {
-                MailcapCommandMap mailMap = (MailcapCommandMap) map;
-                String hndlrStr = ";;x-java-content-handler=";
-                mailMap.addMailcap(
-                    "text/xml"
-                        + hndlrStr
-                        + "com.sun.xml.internal.messaging.saaj.soap.XmlDataContentHandler");
-                mailMap.addMailcap(
-                    "application/xml"
-                        + hndlrStr
-                        + "com.sun.xml.internal.messaging.saaj.soap.XmlDataContentHandler");
-                mailMap.addMailcap(
-                    "application/fastinfoset"
-                        + hndlrStr
-                        + "com.sun.xml.internal.messaging.saaj.soap.FastInfosetDataContentHandler");
-                /* Image DataContentHandler handles all image types
-                mailMap.addMailcap(
-                    "image/jpeg"
-                        + hndlrStr
-                        + "com.sun.xml.internal.messaging.saaj.soap.JpegDataContentHandler");
-                mailMap.addMailcap(
-                    "image/gif"
-                        + hndlrStr
-                        + "com.sun.xml.internal.messaging.saaj.soap.GifDataContentHandler"); */
-                /*mailMap.addMailcap(
-                    "multipart/*"
-                        + hndlrStr
-                        + "com.sun.xml.internal.messaging.saaj.soap.MultipartDataContentHandler");*/
-                mailMap.addMailcap(
-                    "image/*"
-                        + hndlrStr
-                        + "com.sun.xml.internal.messaging.saaj.soap.ImageDataContentHandler");
-                mailMap.addMailcap(
-                    "text/plain"
-                        + hndlrStr
-                        + "com.sun.xml.internal.messaging.saaj.soap.StringDataContentHandler");
-            } else {
-                throw new SOAPExceptionImpl("Default CommandMap is not a MailcapCommandMap");
-            }
-        } catch (Throwable t) {
-            log.log(
-                Level.SEVERE,
-                "SAAJ0508.soap.cannot.register.handlers",
-                t);
-            if (t instanceof RuntimeException) {
-                throw (RuntimeException) t;
-            } else {
-                throw new RuntimeException(t.getLocalizedMessage());
-            }
-        }
-    };
-
     private final MimeHeaders headers;
     private MimeBodyPart rawContent = null;
     private DataHandler dataHandler = null;
@@ -126,6 +71,12 @@
 
     public AttachmentPartImpl() {
         headers = new MimeHeaders();
+
+        // initialization from here should cover most of cases;
+        // if not, it would be necessary to call
+        //   AttachmentPartImpl.initializeJavaActivationHandlers()
+        // explicitly by programmer
+        initializeJavaActivationHandlers();
     }
 
     public AttachmentPartImpl(MIMEPart part) {
@@ -404,7 +355,7 @@
             throw new SOAPExceptionImpl(e.getLocalizedMessage());
         } finally {
             try {
-                decoded.close();
+                    decoded.close();
             } catch (IOException ex) {
                 throw new SOAPException(ex);
             }
@@ -613,4 +564,43 @@
         return headers;
     }
 
+    public static void initializeJavaActivationHandlers() {
+        // DataHandler.writeTo() may search for DCH. So adding some default ones.
+        try {
+            CommandMap map = CommandMap.getDefaultCommandMap();
+            if (map instanceof MailcapCommandMap) {
+                MailcapCommandMap mailMap = (MailcapCommandMap) map;
+
+                // registering our DCH since javamail's DCH doesn't handle
+                if (!cmdMapInitialized(mailMap)) {
+                    mailMap.addMailcap("text/xml;;x-java-content-handler=com.sun.xml.internal.messaging.saaj.soap.XmlDataContentHandler");
+                    mailMap.addMailcap("application/xml;;x-java-content-handler=com.sun.xml.internal.messaging.saaj.soap.XmlDataContentHandler");
+                    mailMap.addMailcap("application/fastinfoset;;x-java-content-handler=com.sun.xml.internal.messaging.saaj.soap.FastInfosetDataContentHandler");
+                    mailMap.addMailcap("multipart/*;;x-java-content-handler=com.sun.xml.internal.messaging.saaj.soap.MultipartDataContentHandler");
+                    mailMap.addMailcap("image/*;;x-java-content-handler=com.sun.xml.internal.messaging.saaj.soap.ImageDataContentHandler");
+                    mailMap.addMailcap("text/plain;;x-java-content-handler=com.sun.xml.internal.messaging.saaj.soap.StringDataContentHandler");
+                }
+            }
+        } catch (Throwable t) {
+            // ignore the exception.
+        }
+    }
+
+    private static boolean cmdMapInitialized(MailcapCommandMap mailMap) {
+
+        // checking fastinfoset handler, since this one is specific to SAAJ
+        CommandInfo[] commands = mailMap.getAllCommands("application/fastinfoset");
+        if (commands == null || commands.length == 0) {
+            return false;
+        }
+
+        String saajClassName = "com.sun.xml.internal.ws.binding.FastInfosetDataContentHandler";
+        for (CommandInfo command : commands) {
+            String commandClass = command.getCommandClass();
+            if (saajClassName.equals(commandClass)) {
+                return true;
+            }
+        }
+        return false;
+    }
 }
--- jaxws/src/share/jaxws_classes/com/sun/xml/internal/messaging/saaj/soap/ContextClassloaderLocal.java	1969-12-31 19:00:00.000000000 -0500
+++ jaxws/src/share/jaxws_classes/com/sun/xml/internal/messaging/saaj/soap/ContextClassloaderLocal.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.sun.xml.internal.messaging.saaj.soap;
+
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+import java.text.MessageFormat;
+import java.util.ResourceBundle;
+import java.util.WeakHashMap;
+
+/**
+ * Simple utility ensuring that the value is cached only in case it is non-internal implementation
+ */
+abstract class ContextClassloaderLocal<V> {
+
+    private static final String FAILED_TO_CREATE_NEW_INSTANCE = "FAILED_TO_CREATE_NEW_INSTANCE";
+
+    private WeakHashMap<ClassLoader, V> CACHE = new WeakHashMap<ClassLoader, V>();
+
+    public V get() throws Error {
+        ClassLoader tccl = getContextClassLoader();
+        V instance = CACHE.get(tccl);
+        if (instance == null) {
+            instance = createNewInstance();
+            CACHE.put(tccl, instance);
+        }
+        return instance;
+    }
+
+    public void set(V instance) {
+        CACHE.put(getContextClassLoader(), instance);
+    }
+
+    protected abstract V initialValue() throws Exception;
+
+    private V createNewInstance() {
+        try {
+            return initialValue();
+        } catch (Exception e) {
+            throw new Error(format(FAILED_TO_CREATE_NEW_INSTANCE, getClass().getName()), e);
+        }
+    }
+
+    private static String format(String property, Object... args) {
+        String text = ResourceBundle.getBundle(ContextClassloaderLocal.class.getName()).getString(property);
+        return MessageFormat.format(text, args);
+    }
+
+    private static ClassLoader getContextClassLoader() {
+        return (ClassLoader)
+                AccessController.doPrivileged(new PrivilegedAction() {
+                    public Object run() {
+                        ClassLoader cl = null;
+                        try {
+                            cl = Thread.currentThread().getContextClassLoader();
+                        } catch (SecurityException ex) {
+                        }
+                        return cl;
+                    }
+                });
+    }
+}
+
--- jaxws/src/share/jaxws_classes/com/sun/xml/internal/messaging/saaj/soap/ContextClassloaderLocal.properties	1969-12-31 19:00:00.000000000 -0500
+++ jaxws/src/share/jaxws_classes/com/sun/xml/internal/messaging/saaj/soap/ContextClassloaderLocal.properties
@@ -0,0 +1,27 @@
+#
+# Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+# Error messages for StaticCache utility class
+FAILED_TO_CREATE_NEW_INSTANCE=Failed to create new instance of {0}
+
--- jaxws/src/share/jaxws_classes/com/sun/xml/internal/messaging/saaj/soap/EnvelopeFactory.java
+++ jaxws/src/share/jaxws_classes/com/sun/xml/internal/messaging/saaj/soap/EnvelopeFactory.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,7 +25,14 @@
 
 package com.sun.xml.internal.messaging.saaj.soap;
 
-import java.util.logging.Logger;
+import com.sun.xml.internal.messaging.saaj.SOAPExceptionImpl;
+import com.sun.xml.internal.messaging.saaj.util.JAXMStreamSource;
+import com.sun.xml.internal.messaging.saaj.util.LogDomainConstants;
+import com.sun.xml.internal.messaging.saaj.util.ParserPool;
+import com.sun.xml.internal.messaging.saaj.util.RejectDoctypeSaxFilter;
+import com.sun.xml.internal.messaging.saaj.util.transform.EfficientStreamingTransformer;
+import org.xml.sax.InputSource;
+import org.xml.sax.XMLReader;
 
 import javax.xml.parsers.SAXParser;
 import javax.xml.soap.SOAPException;
@@ -34,14 +41,7 @@
 import javax.xml.transform.dom.DOMResult;
 import javax.xml.transform.sax.SAXSource;
 import javax.xml.transform.stream.StreamSource;
-
-import org.xml.sax.InputSource;
-import org.xml.sax.XMLReader;
-
-import com.sun.xml.internal.messaging.saaj.SOAPExceptionImpl;
-import com.sun.xml.internal.messaging.saaj.util.*;
-
-import com.sun.xml.internal.messaging.saaj.util.transform.EfficientStreamingTransformer;
+import java.util.logging.Logger;
 
 /**
  * EnvelopeFactory creates SOAP Envelope objects using different
@@ -50,14 +50,19 @@
 public class EnvelopeFactory {
 
     protected static final Logger
-        log = Logger.getLogger(LogDomainConstants.SOAP_DOMAIN,
-        "com.sun.xml.internal.messaging.saaj.soap.LocalStrings");
+            log = Logger.getLogger(LogDomainConstants.SOAP_DOMAIN,
+            "com.sun.xml.internal.messaging.saaj.soap.LocalStrings");
 
-    private static ParserPool parserPool = new ParserPool(5);
+    private static ContextClassloaderLocal<ParserPool> parserPool =
+            new ContextClassloaderLocal<ParserPool>() {
+                @Override
+                protected ParserPool initialValue() throws Exception {
+                    return new ParserPool(5);
+                }
+            };
 
     public static Envelope createEnvelope(Source src, SOAPPartImpl soapPart)
-        throws SOAPException
-    {
+            throws SOAPException {
         // Insert SAX filter to disallow Document Type Declarations since
         // they are not legal in SOAP
         SAXParser saxParser = null;
@@ -73,15 +78,15 @@
                 }
             }
             try {
-                saxParser = parserPool.get();
+                saxParser = parserPool.get().get();
             } catch (Exception e) {
                 log.severe("SAAJ0601.util.newSAXParser.exception");
                 throw new SOAPExceptionImpl(
-                    "Couldn't get a SAX parser while constructing a envelope",
-                    e);
+                        "Couldn't get a SAX parser while constructing a envelope",
+                        e);
             }
             InputSource is = SAXSource.sourceToInputSource(src);
-            if (is.getEncoding()== null && soapPart.getSourceCharsetEncoding() != null) {
+            if (is.getEncoding() == null && soapPart.getSourceCharsetEncoding() != null) {
                 is.setEncoding(soapPart.getSourceCharsetEncoding());
             }
             XMLReader rejectFilter;
@@ -90,15 +95,15 @@
             } catch (Exception ex) {
                 log.severe("SAAJ0510.soap.cannot.create.envelope");
                 throw new SOAPExceptionImpl(
-                    "Unable to create envelope from given source: ",
-                    ex);
+                        "Unable to create envelope from given source: ",
+                        ex);
             }
             src = new SAXSource(rejectFilter, is);
         }
 
         try {
             Transformer transformer =
-                EfficientStreamingTransformer.newTransformer();
+                    EfficientStreamingTransformer.newTransformer();
             DOMResult result = new DOMResult(soapPart);
             transformer.transform(src, result);
 
@@ -110,11 +115,11 @@
             }
             log.severe("SAAJ0511.soap.cannot.create.envelope");
             throw new SOAPExceptionImpl(
-                "Unable to create envelope from given source: ",
-                ex);
+                    "Unable to create envelope from given source: ",
+                    ex);
         } finally {
             if (saxParser != null) {
-                parserPool.returnParser(saxParser);
+                parserPool.get().returnParser(saxParser);
             }
         }
     }
--- jaxws/src/share/jaxws_classes/com/sun/xml/internal/stream/buffer/ContextClassloaderLocal.java	1969-12-31 19:00:00.000000000 -0500
+++ jaxws/src/share/jaxws_classes/com/sun/xml/internal/stream/buffer/ContextClassloaderLocal.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.sun.xml.internal.stream.buffer;
+
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+import java.text.MessageFormat;
+import java.util.ResourceBundle;
+import java.util.WeakHashMap;
+
+/**
+ * Simple utility ensuring that the value is cached only in case it is non-internal implementation
+ */
+abstract class ContextClassloaderLocal<V> {
+
+    private static final String FAILED_TO_CREATE_NEW_INSTANCE = "FAILED_TO_CREATE_NEW_INSTANCE";
+
+    private WeakHashMap<ClassLoader, V> CACHE = new WeakHashMap<ClassLoader, V>();
+
+    public V get() throws Error {
+        ClassLoader tccl = getContextClassLoader();
+        V instance = CACHE.get(tccl);
+        if (instance == null) {
+            instance = createNewInstance();
+            CACHE.put(tccl, instance);
+        }
+        return instance;
+    }
+
+    public void set(V instance) {
+        CACHE.put(getContextClassLoader(), instance);
+    }
+
+    protected abstract V initialValue() throws Exception;
+
+    private V createNewInstance() {
+        try {
+            return initialValue();
+        } catch (Exception e) {
+            throw new Error(format(FAILED_TO_CREATE_NEW_INSTANCE, getClass().getName()), e);
+        }
+    }
+
+    private static String format(String property, Object... args) {
+        String text = ResourceBundle.getBundle(ContextClassloaderLocal.class.getName()).getString(property);
+        return MessageFormat.format(text, args);
+    }
+
+    private static ClassLoader getContextClassLoader() {
+        return (ClassLoader)
+                AccessController.doPrivileged(new PrivilegedAction() {
+                    public Object run() {
+                        ClassLoader cl = null;
+                        try {
+                            cl = Thread.currentThread().getContextClassLoader();
+                        } catch (SecurityException ex) {
+                        }
+                        return cl;
+                    }
+                });
+    }
+}
+
--- jaxws/src/share/jaxws_classes/com/sun/xml/internal/stream/buffer/ContextClassloaderLocal.properties	1969-12-31 19:00:00.000000000 -0500
+++ jaxws/src/share/jaxws_classes/com/sun/xml/internal/stream/buffer/ContextClassloaderLocal.properties
@@ -0,0 +1,27 @@
+#
+# Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+# Error messages for ContextClassloaderLocal utility class
+FAILED_TO_CREATE_NEW_INSTANCE=Failed to create new instance of {0}
+
--- jaxws/src/share/jaxws_classes/com/sun/xml/internal/stream/buffer/XMLStreamBuffer.java
+++ jaxws/src/share/jaxws_classes/com/sun/xml/internal/stream/buffer/XMLStreamBuffer.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -370,7 +370,12 @@
         writeTo(handler, errorHandler, isFragment());
     }
 
-    private static final TransformerFactory trnsformerFactory = TransformerFactory.newInstance();
+    private static final ContextClassloaderLocal<TransformerFactory> trnsformerFactory = new ContextClassloaderLocal<TransformerFactory>() {
+        @Override
+        protected TransformerFactory initialValue() throws Exception {
+            return TransformerFactory.newInstance();
+        }
+    };
 
     /**
      * Writes out the contents of this buffer as DOM node and append that to the given node.
@@ -382,7 +387,7 @@
      */
     public final Node writeTo(Node n) throws XMLStreamBufferException {
         try {
-            Transformer t = trnsformerFactory.newTransformer();
+            Transformer t = trnsformerFactory.get().newTransformer();
             t.transform(new XMLStreamBufferSource(this), new DOMResult(n));
             return n.getLastChild();
         } catch (TransformerException e) {
--- jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/api/streaming/ContextClassloaderLocal.java	1969-12-31 19:00:00.000000000 -0500
+++ jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/api/streaming/ContextClassloaderLocal.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.sun.xml.internal.ws.api.streaming;
+
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+import java.text.MessageFormat;
+import java.util.ResourceBundle;
+import java.util.WeakHashMap;
+
+/**
+ * Simple utility ensuring that the value is cached only in case it is non-internal implementation
+ */
+abstract class ContextClassloaderLocal<V> {
+
+    private static final String FAILED_TO_CREATE_NEW_INSTANCE = "FAILED_TO_CREATE_NEW_INSTANCE";
+
+    private WeakHashMap<ClassLoader, V> CACHE = new WeakHashMap<ClassLoader, V>();
+
+    public V get() throws Error {
+        ClassLoader tccl = getContextClassLoader();
+        V instance = CACHE.get(tccl);
+        if (instance == null) {
+            instance = createNewInstance();
+            CACHE.put(tccl, instance);
+        }
+        return instance;
+    }
+
+    public void set(V instance) {
+        CACHE.put(getContextClassLoader(), instance);
+    }
+
+    protected abstract V initialValue() throws Exception;
+
+    private V createNewInstance() {
+        try {
+            return initialValue();
+        } catch (Exception e) {
+            throw new Error(format(FAILED_TO_CREATE_NEW_INSTANCE, getClass().getName()), e);
+        }
+    }
+
+    private static String format(String property, Object... args) {
+        String text = ResourceBundle.getBundle(ContextClassloaderLocal.class.getName()).getString(property);
+        return MessageFormat.format(text, args);
+    }
+
+    private static ClassLoader getContextClassLoader() {
+        return (ClassLoader)
+                AccessController.doPrivileged(new PrivilegedAction() {
+                    public Object run() {
+                        ClassLoader cl = null;
+                        try {
+                            cl = Thread.currentThread().getContextClassLoader();
+                        } catch (SecurityException ex) {
+                        }
+                        return cl;
+                    }
+                });
+    }
+}
+
--- jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/api/streaming/ContextClassloaderLocal.properties	1969-12-31 19:00:00.000000000 -0500
+++ jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/api/streaming/ContextClassloaderLocal.properties
@@ -0,0 +1,27 @@
+#
+# Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+# Error messages for ContextClassloaderLocal utility class
+FAILED_TO_CREATE_NEW_INSTANCE=Failed to create new instance of {0}
+
--- jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/api/streaming/XMLStreamReaderFactory.java
+++ jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/api/streaming/XMLStreamReaderFactory.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -63,39 +63,43 @@
 
     private static final Logger LOGGER = Logger.getLogger(XMLStreamReaderFactory.class.getName());
 
+    private static final String CLASS_NAME_OF_WSTXINPUTFACTORY = "com.ctc.wstx.stax.WstxInputFactory";
+
     /**
      * Singleton instance.
      */
-    private static volatile @NotNull XMLStreamReaderFactory theInstance;
-
-    private static final String CLASS_NAME_OF_WSTXINPUTFACTORY = "com.ctc.wstx.stax.WstxInputFactory";
+    private static volatile ContextClassloaderLocal<XMLStreamReaderFactory> streamReader =
+            new ContextClassloaderLocal<XMLStreamReaderFactory>() {
 
-    static {
-        XMLInputFactory xif = getXMLInputFactory();
-        XMLStreamReaderFactory f=null;
-
-        // this system property can be used to disable the pooling altogether,
-        // in case someone hits an issue with pooling in the production system.
-        if(!getProperty(XMLStreamReaderFactory.class.getName()+".noPool")) {
-            f = Zephyr.newInstance(xif);
-        }
-
-        if(f==null) {
-            // is this Woodstox?
-            if (xif.getClass().getName().equals(CLASS_NAME_OF_WSTXINPUTFACTORY)) {
-                f = new Woodstox(xif);
-            }
-        }
+                @Override
+                protected XMLStreamReaderFactory initialValue() {
 
-        if (f==null) {
-            f = new Default();
-        }
+                    XMLInputFactory xif = getXMLInputFactory();
+                    XMLStreamReaderFactory f=null;
 
-        theInstance = f;
-        if (LOGGER.isLoggable(Level.FINE)) {
-            LOGGER.log(Level.FINE, "XMLStreamReaderFactory instance is = {0}", theInstance);
-        }
-    }
+                    // this system property can be used to disable the pooling altogether,
+                    // in case someone hits an issue with pooling in the production system.
+                    if(!getProperty(XMLStreamReaderFactory.class.getName()+".noPool")) {
+                        f = Zephyr.newInstance(xif);
+                    }
+
+                    if(f==null) {
+                        // is this Woodstox?
+                        if (xif.getClass().getName().equals(CLASS_NAME_OF_WSTXINPUTFACTORY)) {
+                            f = new Woodstox(xif);
+                        }
+                    }
+
+                    if (f==null) {
+                        f = new Default();
+                    }
+
+                    if (LOGGER.isLoggable(Level.FINE)) {
+                        LOGGER.log(Level.FINE, "XMLStreamReaderFactory instance is = {0}", f);
+                    }
+                    return f;
+                }
+            };
 
     private static XMLInputFactory getXMLInputFactory() {
         XMLInputFactory xif = null;
@@ -126,11 +130,11 @@
         if(f==null) {
             throw new IllegalArgumentException();
         }
-        theInstance = f;
+        streamReader.set(f);
     }
 
     public static XMLStreamReaderFactory get() {
-        return theInstance;
+        return streamReader.get();
     }
 
     public static XMLStreamReader create(InputSource source, boolean rejectDTDs) {
--- jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/api/streaming/XMLStreamWriterFactory.java
+++ jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/api/streaming/XMLStreamWriterFactory.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -62,52 +62,54 @@
     /**
      * Singleton instance.
      */
-    private static volatile @NotNull XMLStreamWriterFactory theInstance;
+    private static volatile ContextClassloaderLocal<XMLStreamWriterFactory> writerFactory =
+            new ContextClassloaderLocal<XMLStreamWriterFactory>() {
 
-
-    static {
-        XMLOutputFactory  xof = null;
-        if (Boolean.getBoolean(XMLStreamWriterFactory.class.getName()+".woodstox")) {
-            try {
-                xof = (XMLOutputFactory)Class.forName("com.ctc.wstx.stax.WstxOutputFactory").newInstance();
-            } catch (Exception e) {
-                // Ignore and fallback to default XMLOutputFactory
+        @Override
+        protected XMLStreamWriterFactory initialValue() {
+            XMLOutputFactory  xof = null;
+            if (Boolean.getBoolean(XMLStreamWriterFactory.class.getName()+".woodstox")) {
+                try {
+                    xof = (XMLOutputFactory)Class.forName("com.ctc.wstx.stax.WstxOutputFactory").newInstance();
+                } catch (Exception e) {
+                    // Ignore and fallback to default XMLOutputFactory
+                }
+            }
+            if (xof == null) {
+                xof = XMLOutputFactory.newInstance();
             }
-        }
-        if (xof == null) {
-            xof = XMLOutputFactory.newInstance();
-        }
 
-        XMLStreamWriterFactory f=null;
+            XMLStreamWriterFactory f=null;
 
-        // this system property can be used to disable the pooling altogether,
-        // in case someone hits an issue with pooling in the production system.
-        if (!Boolean.getBoolean(XMLStreamWriterFactory.class.getName()+".noPool")) {
-            try {
-                Class<?> clazz = xof.createXMLStreamWriter(new StringWriter()).getClass();
-                if (clazz.getName().startsWith("com.sun.xml.internal.stream.")) {
-                    f =  new Zephyr(xof,clazz);
+            // this system property can be used to disable the pooling altogether,
+            // in case someone hits an issue with pooling in the production system.
+            if (!Boolean.getBoolean(XMLStreamWriterFactory.class.getName()+".noPool")) {
+                try {
+                    Class<?> clazz = xof.createXMLStreamWriter(new StringWriter()).getClass();
+                    if (clazz.getName().startsWith("com.sun.xml.internal.stream.")) {
+                        f =  new Zephyr(xof,clazz);
+                    }
+                } catch (XMLStreamException ex) {
+                    Logger.getLogger(XMLStreamWriterFactory.class.getName()).log(Level.INFO, null, ex);
+                } catch (NoSuchMethodException ex) {
+                    Logger.getLogger(XMLStreamWriterFactory.class.getName()).log(Level.INFO, null, ex);
                 }
-            } catch (XMLStreamException ex) {
-                Logger.getLogger(XMLStreamWriterFactory.class.getName()).log(Level.INFO, null, ex);
-            } catch (NoSuchMethodException ex) {
-                Logger.getLogger(XMLStreamWriterFactory.class.getName()).log(Level.INFO, null, ex);
             }
-        }
 
-        if(f==null) {
-            // is this Woodstox?
-            if(xof.getClass().getName().equals("com.ctc.wstx.stax.WstxOutputFactory"))
-                f = new NoLock(xof);
-        }
-        if (f == null)
-            f = new Default(xof);
+            if(f==null) {
+                // is this Woodstox?
+                if(xof.getClass().getName().equals("com.ctc.wstx.stax.WstxOutputFactory"))
+                    f = new NoLock(xof);
+            }
+            if (f == null)
+                f = new Default(xof);
 
-        theInstance = f;
-        if (LOGGER.isLoggable(Level.FINE)) {
-            LOGGER.log(Level.FINE, "XMLStreamWriterFactory instance is = {0}", f);
+            if (LOGGER.isLoggable(Level.FINE)) {
+                LOGGER.log(Level.FINE, "XMLStreamWriterFactory instance is = {0}", f);
+            }
+            return f;
         }
-    }
+    };
 
     /**
      * See {@link #create(OutputStream)} for the contract.
@@ -170,7 +172,7 @@
      * Gets the singleton instance.
      */
     public static @NotNull XMLStreamWriterFactory get() {
-        return theInstance;
+        return writerFactory.get();
     }
 
     /**
@@ -183,7 +185,7 @@
     @SuppressWarnings({"null", "ConstantConditions"})
     public static void set(@NotNull XMLStreamWriterFactory f) {
         if(f==null) throw new IllegalArgumentException();
-        theInstance = f;
+        writerFactory.set(f);
     }
 
     /**
--- jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/binding/BindingImpl.java
+++ jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/binding/BindingImpl.java
@@ -37,6 +37,9 @@
 import com.sun.xml.internal.ws.developer.MemberSubmissionAddressingFeature;
 import com.sun.xml.internal.ws.developer.BindingTypeFeature;
 
+import javax.activation.CommandInfo;
+import javax.activation.CommandMap;
+import javax.activation.MailcapCommandMap;
 import javax.xml.namespace.QName;
 import javax.xml.ws.Service;
 import javax.xml.ws.WebServiceFeature;
@@ -151,12 +154,61 @@
         return addressingVersion;
     }
 
-    public final
     @NotNull
-    Codec createCodec() {
+    public final Codec createCodec() {
+
+        // initialization from here should cover most of cases;
+        // if not, it would be necessary to call
+        //   BindingImpl.initializeJavaActivationHandlers()
+        // explicitly by programmer
+        initializeJavaActivationHandlers();
+
         return bindingId.createEncoder(this);
     }
 
+    public static void initializeJavaActivationHandlers() {
+        // DataHandler.writeTo() may search for DCH. So adding some default ones.
+        try {
+            CommandMap map = CommandMap.getDefaultCommandMap();
+            if (map instanceof MailcapCommandMap) {
+                MailcapCommandMap mailMap = (MailcapCommandMap) map;
+
+                // registering our DCH since javamail's DCH doesn't handle
+                if (!cmdMapInitialized(mailMap)) {
+                    mailMap.addMailcap("text/xml;;x-java-content-handler=com.sun.xml.internal.ws.encoding.XmlDataContentHandler");
+                    mailMap.addMailcap("application/xml;;x-java-content-handler=com.sun.xml.internal.ws.encoding.XmlDataContentHandler");
+                    mailMap.addMailcap("image/*;;x-java-content-handler=com.sun.xml.internal.ws.encoding.ImageDataContentHandler");
+                    mailMap.addMailcap("text/plain;;x-java-content-handler=com.sun.xml.internal.ws.encoding.StringDataContentHandler");
+                }
+            }
+        } catch (Throwable t) {
+            // ignore the exception.
+        }
+    }
+
+    private static boolean cmdMapInitialized(MailcapCommandMap mailMap) {
+        CommandInfo[] commands = mailMap.getAllCommands("text/xml");
+        if (commands == null || commands.length == 0) {
+            return false;
+        }
+
+        // SAAJ RI implements it's own DataHandlers which can be used for JAX-WS too;
+        // see com.sun.xml.internal.messaging.saaj.soap.AttachmentPartImpl#initializeJavaActivationHandlers
+        // so if found any of SAAJ or our own handler registered, we are ok; anyway using SAAJ directly here
+        // is not good idea since we don't want standalone JAX-WS to depend on specific SAAJ impl.
+        // This is also reason for duplication of Handler's code by JAX-WS
+        String saajClassName = "com.sun.xml.internal.messaging.saaj.soap.XmlDataContentHandler";
+        String jaxwsClassName = "com.sun.xml.internal.ws.encoding.XmlDataContentHandler";
+        for (CommandInfo command : commands) {
+            String commandClass = command.getCommandClass();
+            if (saajClassName.equals(commandClass) ||
+                    jaxwsClassName.equals(commandClass)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
     public static BindingImpl create(@NotNull BindingID bindingId) {
         if (bindingId.equals(BindingID.XML_HTTP))
             return new HTTPBindingImpl();
--- jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/commons/xmlutil/ContextClassloaderLocal.java	1969-12-31 19:00:00.000000000 -0500
+++ jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/commons/xmlutil/ContextClassloaderLocal.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.sun.xml.internal.ws.commons.xmlutil;
+
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+import java.text.MessageFormat;
+import java.util.ResourceBundle;
+import java.util.WeakHashMap;
+
+/**
+ * Simple utility ensuring that the value is cached only in case it is non-internal implementation
+ */
+abstract class ContextClassloaderLocal<V> {
+
+    private static final String FAILED_TO_CREATE_NEW_INSTANCE = "FAILED_TO_CREATE_NEW_INSTANCE";
+
+    private WeakHashMap<ClassLoader, V> CACHE = new WeakHashMap<ClassLoader, V>();
+
+    public V get() throws Error {
+        ClassLoader tccl = getContextClassLoader();
+        V instance = CACHE.get(tccl);
+        if (instance == null) {
+            instance = createNewInstance();
+            CACHE.put(tccl, instance);
+        }
+        return instance;
+    }
+
+    public void set(V instance) {
+        CACHE.put(getContextClassLoader(), instance);
+    }
+
+    protected abstract V initialValue() throws Exception;
+
+    private V createNewInstance() {
+        try {
+            return initialValue();
+        } catch (Exception e) {
+            throw new Error(format(FAILED_TO_CREATE_NEW_INSTANCE, getClass().getName()), e);
+        }
+    }
+
+    private static String format(String property, Object... args) {
+        String text = ResourceBundle.getBundle(ContextClassloaderLocal.class.getName()).getString(property);
+        return MessageFormat.format(text, args);
+    }
+
+    private static ClassLoader getContextClassLoader() {
+        return (ClassLoader)
+                AccessController.doPrivileged(new PrivilegedAction() {
+                    public Object run() {
+                        ClassLoader cl = null;
+                        try {
+                            cl = Thread.currentThread().getContextClassLoader();
+                        } catch (SecurityException ex) {
+                        }
+                        return cl;
+                    }
+                });
+    }
+}
+
--- jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/commons/xmlutil/ContextClassloaderLocal.properties	1969-12-31 19:00:00.000000000 -0500
+++ jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/commons/xmlutil/ContextClassloaderLocal.properties
@@ -0,0 +1,27 @@
+#
+# Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+# Error messages for ContextClassloaderLocal utility class
+FAILED_TO_CREATE_NEW_INSTANCE=Failed to create new instance of {0}
+
--- jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/commons/xmlutil/Converter.java
+++ jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/commons/xmlutil/Converter.java
@@ -53,7 +53,12 @@
         // prevents instantiation
     }
     private static final Logger LOGGER = Logger.getLogger(Converter.class);
-    private static final XMLOutputFactory xmlOutputFactory = XMLOutputFactory.newInstance();
+    private static final ContextClassloaderLocal<XMLOutputFactory> xmlOutputFactory = new ContextClassloaderLocal<XMLOutputFactory>() {
+        @Override
+        protected XMLOutputFactory initialValue() throws Exception {
+            return XMLOutputFactory.newInstance();
+        }
+    };
     private static final AtomicBoolean logMissingStaxUtilsWarning = new AtomicBoolean(false);
 
     /**
@@ -110,7 +115,7 @@
             stringOut = new StringWriter();
             XMLStreamWriter writer = null;
             try {
-                writer = xmlOutputFactory.createXMLStreamWriter(stringOut);
+                writer = xmlOutputFactory.get().createXMLStreamWriter(stringOut);
                 if (createIndenter) {
                     writer = createIndenter(writer);
                 }
@@ -143,7 +148,7 @@
 
         try {
             if (message != null) {
-                XMLStreamWriter xsw = xmlOutputFactory.createXMLStreamWriter(baos, encoding);
+                XMLStreamWriter xsw = xmlOutputFactory.get().createXMLStreamWriter(baos, encoding);
                 try {
                     message.writeTo(xsw);
                 } finally {
--- jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/developer/ContextClassloaderLocal.java	1969-12-31 19:00:00.000000000 -0500
+++ jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/developer/ContextClassloaderLocal.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.sun.xml.internal.ws.developer;
+
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+import java.text.MessageFormat;
+import java.util.ResourceBundle;
+import java.util.WeakHashMap;
+
+/**
+ * Simple utility ensuring that the value is cached only in case it is non-internal implementation
+ */
+abstract class ContextClassloaderLocal<V> {
+
+    private static final String FAILED_TO_CREATE_NEW_INSTANCE = "FAILED_TO_CREATE_NEW_INSTANCE";
+
+    private WeakHashMap<ClassLoader, V> CACHE = new WeakHashMap<ClassLoader, V>();
+
+    public V get() throws Error {
+        ClassLoader tccl = getContextClassLoader();
+        V instance = CACHE.get(tccl);
+        if (instance == null) {
+            instance = createNewInstance();
+            CACHE.put(tccl, instance);
+        }
+        return instance;
+    }
+
+    public void set(V instance) {
+        CACHE.put(getContextClassLoader(), instance);
+    }
+
+    protected abstract V initialValue() throws Exception;
+
+    private V createNewInstance() {
+        try {
+            return initialValue();
+        } catch (Exception e) {
+            throw new Error(format(FAILED_TO_CREATE_NEW_INSTANCE, getClass().getName()), e);
+        }
+    }
+
+    private static String format(String property, Object... args) {
+        String text = ResourceBundle.getBundle(ContextClassloaderLocal.class.getName()).getString(property);
+        return MessageFormat.format(text, args);
+    }
+
+    private static ClassLoader getContextClassLoader() {
+        return (ClassLoader)
+                AccessController.doPrivileged(new PrivilegedAction() {
+                    public Object run() {
+                        ClassLoader cl = null;
+                        try {
+                            cl = Thread.currentThread().getContextClassLoader();
+                        } catch (SecurityException ex) {
+                        }
+                        return cl;
+                    }
+                });
+    }
+}
+
--- jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/developer/ContextClassloaderLocal.properties	1969-12-31 19:00:00.000000000 -0500
+++ jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/developer/ContextClassloaderLocal.properties
@@ -0,0 +1,27 @@
+#
+# Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+# Error messages for ContextClassloaderLocal utility class
+FAILED_TO_CREATE_NEW_INSTANCE=Failed to create new instance of {0}
+
--- jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/developer/MemberSubmissionEndpointReference.java
+++ jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/developer/MemberSubmissionEndpointReference.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -64,7 +64,12 @@
 @XmlType(name = "EndpointReferenceType", namespace = MemberSubmissionEndpointReference.MSNS)
 public final class MemberSubmissionEndpointReference extends EndpointReference implements MemberSubmissionAddressingConstants {
 
-    private final static JAXBContext msjc = MemberSubmissionEndpointReference.getMSJaxbContext();
+    private final static ContextClassloaderLocal<JAXBContext> msjc = new ContextClassloaderLocal<JAXBContext>() {
+        @Override
+        protected JAXBContext initialValue() throws Exception {
+            return MemberSubmissionEndpointReference.getMSJaxbContext();
+        }
+    };
 
     public MemberSubmissionEndpointReference() {
     }
@@ -86,7 +91,7 @@
         }
 
         try {
-            Unmarshaller unmarshaller = MemberSubmissionEndpointReference.msjc.createUnmarshaller();
+            Unmarshaller unmarshaller = MemberSubmissionEndpointReference.msjc.get().createUnmarshaller();
             MemberSubmissionEndpointReference epr = unmarshaller.unmarshal(source,MemberSubmissionEndpointReference.class).getValue();
 
             this.addr = epr.addr;
@@ -106,7 +111,7 @@
     @Override
     public void writeTo(Result result) {
         try {
-            Marshaller marshaller = MemberSubmissionEndpointReference.msjc.createMarshaller();
+            Marshaller marshaller = MemberSubmissionEndpointReference.msjc.get().createMarshaller();
             //marshaller.setProperty(Marshaller.JAXB_FRAGMENT, true);
             marshaller.marshal(this, result);
         } catch (JAXBException e) {
--- jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/encoding/MimeCodec.java
+++ jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/encoding/MimeCodec.java
@@ -34,8 +34,6 @@
 import com.sun.xml.internal.ws.api.pipe.Codec;
 import com.sun.xml.internal.ws.api.pipe.ContentType;
 import com.sun.xml.internal.ws.developer.StreamingAttachmentFeature;
-import javax.activation.CommandMap;
-import javax.activation.MailcapCommandMap;
 
 import java.io.IOException;
 import java.io.InputStream;
@@ -63,33 +61,6 @@
  */
 abstract class MimeCodec implements Codec {
 
-    static {
-        // DataHandler.writeTo() may search for DCH. So adding some default ones.
-        try {
-            CommandMap map = CommandMap.getDefaultCommandMap();
-            if (map instanceof MailcapCommandMap) {
-                MailcapCommandMap mailMap = (MailcapCommandMap) map;
-                String hndlrStr = ";;x-java-content-handler=";
-                // registering our DCH since javamail's DCH doesn't handle
-                // Source
-                mailMap.addMailcap(
-                    "text/xml" + hndlrStr + XmlDataContentHandler.class.getName());
-                mailMap.addMailcap(
-                    "application/xml" + hndlrStr + XmlDataContentHandler.class.getName());
-                if (map.createDataContentHandler("image/*") == null) {
-                    mailMap.addMailcap(
-                        "image/*" + hndlrStr + ImageDataContentHandler.class.getName());
-                }
-                if (map.createDataContentHandler("text/plain") == null) {
-                    mailMap.addMailcap(
-                        "text/plain" + hndlrStr + StringDataContentHandler.class.getName());
-                }
-            }
-        } catch (Throwable t) {
-            // ignore the exception.
-        }
-    }
-
     public static final String MULTIPART_RELATED_MIME_TYPE = "multipart/related";
 
     protected Codec mimeRootCodec;
--- jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/sourcemodel/attach/ContextClassloaderLocal.java	1969-12-31 19:00:00.000000000 -0500
+++ jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/sourcemodel/attach/ContextClassloaderLocal.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.sun.xml.internal.ws.policy.sourcemodel.attach;
+
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+import java.text.MessageFormat;
+import java.util.ResourceBundle;
+import java.util.WeakHashMap;
+
+/**
+ * Simple utility ensuring that the value is cached only in case it is non-internal implementation
+ */
+abstract class ContextClassloaderLocal<V> {
+
+    private static final String FAILED_TO_CREATE_NEW_INSTANCE = "FAILED_TO_CREATE_NEW_INSTANCE";
+
+    private WeakHashMap<ClassLoader, V> CACHE = new WeakHashMap<ClassLoader, V>();
+
+    public V get() throws Error {
+        ClassLoader tccl = getContextClassLoader();
+        V instance = CACHE.get(tccl);
+        if (instance == null) {
+            instance = createNewInstance();
+            CACHE.put(tccl, instance);
+        }
+        return instance;
+    }
+
+    public void set(V instance) {
+        CACHE.put(getContextClassLoader(), instance);
+    }
+
+    protected abstract V initialValue() throws Exception;
+
+    private V createNewInstance() {
+        try {
+            return initialValue();
+        } catch (Exception e) {
+            throw new Error(format(FAILED_TO_CREATE_NEW_INSTANCE, getClass().getName()), e);
+        }
+    }
+
+    private static String format(String property, Object... args) {
+        String text = ResourceBundle.getBundle(ContextClassloaderLocal.class.getName()).getString(property);
+        return MessageFormat.format(text, args);
+    }
+
+    private static ClassLoader getContextClassLoader() {
+        return (ClassLoader)
+                AccessController.doPrivileged(new PrivilegedAction() {
+                    public Object run() {
+                        ClassLoader cl = null;
+                        try {
+                            cl = Thread.currentThread().getContextClassLoader();
+                        } catch (SecurityException ex) {
+                        }
+                        return cl;
+                    }
+                });
+    }
+}
+
--- jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/sourcemodel/attach/ContextClassloaderLocal.properties	1969-12-31 19:00:00.000000000 -0500
+++ jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/sourcemodel/attach/ContextClassloaderLocal.properties
@@ -0,0 +1,27 @@
+#
+# Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+# Error messages for ContextClassloaderLocal utility class
+FAILED_TO_CREATE_NEW_INSTANCE=Failed to create new instance of {0}
+
--- jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/sourcemodel/attach/ExternalAttachmentsUnmarshaller.java
+++ jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/sourcemodel/attach/ExternalAttachmentsUnmarshaller.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -83,7 +83,13 @@
     private static final QName POLICY = new QName("http://www.w3.org/ns/ws-policy", "Policy");
     private static final QName URI = new QName("http://www.w3.org/ns/ws-policy", "URI");
     private static final QName POLICIES = new QName(PolicyConstants.SUN_MANAGEMENT_NAMESPACE, "Policies");
-    private static final XMLInputFactory XML_INPUT_FACTORY = XMLInputFactory.newInstance();
+    private static final ContextClassloaderLocal<XMLInputFactory> XML_INPUT_FACTORY = new ContextClassloaderLocal<XMLInputFactory>() {
+        @Override
+        protected XMLInputFactory initialValue() throws Exception {
+            return XMLInputFactory.newInstance();
+        }
+    };
+
     private static final PolicyModelUnmarshaller POLICY_UNMARSHALLER = PolicyModelUnmarshaller.getXmlUnmarshaller();
 
     private final Map<URI, Policy> map = new HashMap<URI, Policy>();
@@ -93,7 +99,7 @@
     public static Map<URI, Policy> unmarshal(final Reader source) throws PolicyException {
         LOGGER.entering(source);
         try {
-            XMLEventReader reader = XML_INPUT_FACTORY.createXMLEventReader(source);
+            XMLEventReader reader = XML_INPUT_FACTORY.get().createXMLEventReader(source);
             ExternalAttachmentsUnmarshaller instance = new ExternalAttachmentsUnmarshaller();
             final Map<URI, Policy> map = instance.unmarshal(reader, null);
             LOGGER.exiting(map);
--- jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/spi/ContextClassloaderLocal.java	1969-12-31 19:00:00.000000000 -0500
+++ jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/spi/ContextClassloaderLocal.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.sun.xml.internal.ws.spi;
+
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+import java.text.MessageFormat;
+import java.util.ResourceBundle;
+import java.util.WeakHashMap;
+
+/**
+ * Simple utility ensuring that the value is cached only in case it is non-internal implementation
+ */
+abstract class ContextClassloaderLocal<V> {
+
+    private static final String FAILED_TO_CREATE_NEW_INSTANCE = "FAILED_TO_CREATE_NEW_INSTANCE";
+
+    private WeakHashMap<ClassLoader, V> CACHE = new WeakHashMap<ClassLoader, V>();
+
+    public V get() throws Error {
+        ClassLoader tccl = getContextClassLoader();
+        V instance = CACHE.get(tccl);
+        if (instance == null) {
+            instance = createNewInstance();
+            CACHE.put(tccl, instance);
+        }
+        return instance;
+    }
+
+    public void set(V instance) {
+        CACHE.put(getContextClassLoader(), instance);
+    }
+
+    protected abstract V initialValue() throws Exception;
+
+    private V createNewInstance() {
+        try {
+            return initialValue();
+        } catch (Exception e) {
+            throw new Error(format(FAILED_TO_CREATE_NEW_INSTANCE, getClass().getName()), e);
+        }
+    }
+
+    private static String format(String property, Object... args) {
+        String text = ResourceBundle.getBundle(ContextClassloaderLocal.class.getName()).getString(property);
+        return MessageFormat.format(text, args);
+    }
+
+    private static ClassLoader getContextClassLoader() {
+        return (ClassLoader)
+                AccessController.doPrivileged(new PrivilegedAction() {
+                    public Object run() {
+                        ClassLoader cl = null;
+                        try {
+                            cl = Thread.currentThread().getContextClassLoader();
+                        } catch (SecurityException ex) {
+                        }
+                        return cl;
+                    }
+                });
+    }
+}
+
--- jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/spi/ContextClassloaderLocal.properties	1969-12-31 19:00:00.000000000 -0500
+++ jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/spi/ContextClassloaderLocal.properties
@@ -0,0 +1,27 @@
+#
+# Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+# Error messages for StaticCache utility class
+FAILED_TO_CREATE_NEW_INSTANCE=Failed to create new instance of {0}
+
--- jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/spi/ProviderImpl.java
+++ jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/spi/ProviderImpl.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -80,7 +80,12 @@
  */
 public class ProviderImpl extends Provider {
 
-    private final static JAXBContext eprjc = getEPRJaxbContext();
+    private final static ContextClassloaderLocal<JAXBContext> eprjc = new ContextClassloaderLocal<JAXBContext>() {
+        @Override
+        protected JAXBContext initialValue() throws Exception {
+            return getEPRJaxbContext();
+        }
+    };
 
     /**
      * Convenient singleton instance.
@@ -148,7 +153,7 @@
         return AccessController.doPrivileged(new PrivilegedAction<EndpointReference>() {
             public EndpointReference run() {
                 try {
-                    Unmarshaller unmarshaller = eprjc.createUnmarshaller();
+                    Unmarshaller unmarshaller = eprjc.get().createUnmarshaller();
                     return (EndpointReference) unmarshaller.unmarshal(eprInfoset);
                 } catch (JAXBException e) {
                     throw new WebServiceException("Error creating Marshaller or marshalling.", e);
--- jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/util/version.properties
+++ jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/util/version.properties
@@ -26,4 +26,4 @@
 build-id=2.2.9-b130926.1035
 build-version=JAX-WS RI 2.2.9-b130926.1035
 major-version=2.2.9
-svn-revision=8c29a9a53251ff741fca1664a8221dc876b2eac8
+svn-revision=5f6196f2b90e9460065a4c2f4e30e065b245e51e
--- jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/util/xml/ContextClassloaderLocal.java	1969-12-31 19:00:00.000000000 -0500
+++ jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/util/xml/ContextClassloaderLocal.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.sun.xml.internal.ws.util.xml;
+
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+import java.text.MessageFormat;
+import java.util.ResourceBundle;
+import java.util.WeakHashMap;
+
+/**
+ * Simple utility ensuring that the value is cached only in case it is non-internal implementation
+ */
+abstract class ContextClassloaderLocal<V> {
+
+    private static final String FAILED_TO_CREATE_NEW_INSTANCE = "FAILED_TO_CREATE_NEW_INSTANCE";
+
+    private WeakHashMap<ClassLoader, V> CACHE = new WeakHashMap<ClassLoader, V>();
+
+    public V get() throws Error {
+        ClassLoader tccl = getContextClassLoader();
+        V instance = CACHE.get(tccl);
+        if (instance == null) {
+            instance = createNewInstance();
+            CACHE.put(tccl, instance);
+        }
+        return instance;
+    }
+
+    public void set(V instance) {
+        CACHE.put(getContextClassLoader(), instance);
+    }
+
+    protected abstract V initialValue() throws Exception;
+
+    private V createNewInstance() {
+        try {
+            return initialValue();
+        } catch (Exception e) {
+            throw new Error(format(FAILED_TO_CREATE_NEW_INSTANCE, getClass().getName()), e);
+        }
+    }
+
+    private static String format(String property, Object... args) {
+        String text = ResourceBundle.getBundle(ContextClassloaderLocal.class.getName()).getString(property);
+        return MessageFormat.format(text, args);
+    }
+
+    private static ClassLoader getContextClassLoader() {
+        return (ClassLoader)
+                AccessController.doPrivileged(new PrivilegedAction() {
+                    public Object run() {
+                        ClassLoader cl = null;
+                        try {
+                            cl = Thread.currentThread().getContextClassLoader();
+                        } catch (SecurityException ex) {
+                        }
+                        return cl;
+                    }
+                });
+    }
+}
+
--- jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/util/xml/ContextClassloaderLocal.properties	1969-12-31 19:00:00.000000000 -0500
+++ jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/util/xml/ContextClassloaderLocal.properties
@@ -0,0 +1,27 @@
+#
+# Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+# Error messages for StaticCache utility class
+FAILED_TO_CREATE_NEW_INSTANCE=Failed to create new instance of {0}
+
--- jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/util/xml/XmlUtil.java
+++ jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/util/xml/XmlUtil.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -215,20 +215,28 @@
         }
     }
 
-    static final TransformerFactory transformerFactory = newTransformerFactory();
-
-    static final SAXParserFactory saxParserFactory = newSAXParserFactory(true);
+    static final ContextClassloaderLocal<TransformerFactory> transformerFactory = new ContextClassloaderLocal<TransformerFactory>() {
+        @Override
+        protected TransformerFactory initialValue() throws Exception {
+            return TransformerFactory.newInstance();
+        }
+    };
 
-    static {
-        saxParserFactory.setNamespaceAware(true);
-    }
+    static final ContextClassloaderLocal<SAXParserFactory> saxParserFactory = new ContextClassloaderLocal<SAXParserFactory>() {
+        @Override
+        protected SAXParserFactory initialValue() throws Exception {
+            SAXParserFactory factory = SAXParserFactory.newInstance();
+            factory.setNamespaceAware(true);
+            return factory;
+        }
+    };
 
     /**
      * Creates a new identity transformer.
      */
     public static Transformer newTransformer() {
         try {
-            return transformerFactory.newTransformer();
+            return transformerFactory.get().newTransformer();
         } catch (TransformerConfigurationException tex) {
             throw new IllegalStateException("Unable to create a JAXP transformer");
         }
@@ -243,9 +251,9 @@
             // work around a bug in JAXP in JDK6u4 and earlier where the namespace processing
             // is not turned on by default
             StreamSource ssrc = (StreamSource) src;
-            TransformerHandler th = ((SAXTransformerFactory) transformerFactory).newTransformerHandler();
+            TransformerHandler th = ((SAXTransformerFactory) transformerFactory.get()).newTransformerHandler();
             th.setResult(result);
-            XMLReader reader = saxParserFactory.newSAXParser().getXMLReader();
+            XMLReader reader = saxParserFactory.get().newSAXParser().getXMLReader();
             reader.setContentHandler(th);
             reader.setProperty(LEXICAL_HANDLER_PROPERTY, th);
             reader.parse(toInputSource(ssrc));
--- jaxws/src/share/jaxws_classes/com/sun/xml/internal/xsom/util/ContextClassloaderLocal.java	1969-12-31 19:00:00.000000000 -0500
+++ jaxws/src/share/jaxws_classes/com/sun/xml/internal/xsom/util/ContextClassloaderLocal.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.sun.xml.internal.xsom.util;
+
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+import java.text.MessageFormat;
+import java.util.ResourceBundle;
+import java.util.WeakHashMap;
+
+/**
+ * Simple utility ensuring that the value is cached only in case it is non-internal implementation
+ */
+abstract class ContextClassloaderLocal<V> {
+
+    private static final String FAILED_TO_CREATE_NEW_INSTANCE = "FAILED_TO_CREATE_NEW_INSTANCE";
+
+    private WeakHashMap<ClassLoader, V> CACHE = new WeakHashMap<ClassLoader, V>();
+
+    public V get() throws Error {
+        ClassLoader tccl = getContextClassLoader();
+        V instance = CACHE.get(tccl);
+        if (instance == null) {
+            instance = createNewInstance();
+            CACHE.put(tccl, instance);
+        }
+        return instance;
+    }
+
+    public void set(V instance) {
+        CACHE.put(getContextClassLoader(), instance);
+    }
+
+    protected abstract V initialValue() throws Exception;
+
+    private V createNewInstance() {
+        try {
+            return initialValue();
+        } catch (Exception e) {
+            throw new Error(format(FAILED_TO_CREATE_NEW_INSTANCE, getClass().getName()), e);
+        }
+    }
+
+    private static String format(String property, Object... args) {
+        String text = ResourceBundle.getBundle(ContextClassloaderLocal.class.getName()).getString(property);
+        return MessageFormat.format(text, args);
+    }
+
+    private static ClassLoader getContextClassLoader() {
+        return (ClassLoader)
+                AccessController.doPrivileged(new PrivilegedAction() {
+                    public Object run() {
+                        ClassLoader cl = null;
+                        try {
+                            cl = Thread.currentThread().getContextClassLoader();
+                        } catch (SecurityException ex) {
+                        }
+                        return cl;
+                    }
+                });
+    }
+}
+
--- jaxws/src/share/jaxws_classes/com/sun/xml/internal/xsom/util/ContextClassloaderLocal.properties	1969-12-31 19:00:00.000000000 -0500
+++ jaxws/src/share/jaxws_classes/com/sun/xml/internal/xsom/util/ContextClassloaderLocal.properties
@@ -0,0 +1,27 @@
+#
+# Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+# Error messages for ContextClassloaderLocal utility class
+FAILED_TO_CREATE_NEW_INSTANCE=Failed to create new instance of {0}
+
--- jaxws/src/share/jaxws_classes/com/sun/xml/internal/xsom/util/DomAnnotationParserFactory.java
+++ jaxws/src/share/jaxws_classes/com/sun/xml/internal/xsom/util/DomAnnotationParserFactory.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -63,10 +63,15 @@
     }
 
     public AnnotationParser create(boolean disableSecureProcessing) {
-        return new AnnotationParserImpl();
+        return new AnnotationParserImpl(disableSecureProcessing);
     }
 
-    private static final SAXTransformerFactory stf = (SAXTransformerFactory) SAXTransformerFactory.newInstance();
+    private static final ContextClassloaderLocal<SAXTransformerFactory> stf = new ContextClassloaderLocal<SAXTransformerFactory>() {
+        @Override
+        protected SAXTransformerFactory initialValue() throws Exception {
+            return (SAXTransformerFactory) SAXTransformerFactory.newInstance();
+        }
+    };
 
     private static class AnnotationParserImpl extends AnnotationParser {
 
@@ -82,8 +87,9 @@
 
         AnnotationParserImpl(boolean disableSecureProcessing) {
             try {
-                transformer = stf.newTransformerHandler();
-                stf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, disableSecureProcessing);
+                SAXTransformerFactory factory = stf.get();
+                factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, disableSecureProcessing);
+                transformer = factory.newTransformerHandler();
             } catch (TransformerConfigurationException e) {
                 throw new Error(e); // impossible
             }
--- jaxws/src/share/jaxws_classes/javax/xml/ws/wsaddressing/W3CEndpointReference.java
+++ jaxws/src/share/jaxws_classes/javax/xml/ws/wsaddressing/W3CEndpointReference.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -69,7 +69,7 @@
 @XmlType(name="EndpointReferenceType",namespace=W3CEndpointReference.NS)
 public final class W3CEndpointReference extends EndpointReference {
 
-    private final static JAXBContext w3cjc = getW3CJaxbContext();
+    private final JAXBContext w3cjc = getW3CJaxbContext();
 
     // should be changed to package private, keeping original modifier to keep backwards compatibility
     protected static final String NS = "http://www.w3.org/2005/08/addressing";
--- jdk/.hgtags
+++ jdk/.hgtags
@@ -253,3 +253,16 @@
 80568a19aab7300bc92baf2dc225be929f5b03ed jdk8-b129
 43386cc9a017a9f9e704760050086bb18b778ae0 jdk8-b130
 e291ac47c9a90366c3c0787a6f7ce547a2bda308 jdk8-b131
+43cb25339b5500871f41388a5197f1b01c4b57b8 jdk8-b132
+fa2d5a06308f3f36fb09662fa58070a02352f023 jdk8u5-b01
+343f4f8ba0982b3516e33c859b01634d919243c4 jdk8u5-b02
+c35571198602a5856280d5c7c10bda4e7b769104 jdk8u5-b03
+55e6175fb6904d771bfaec4ada4f5e20b54f4791 jdk8u5-b04
+911d590f34aaa7f7b9ef300d0c0a019e70a62d1d jdk8u5-b05
+94fe0ed14bfcca335ff72abd20cf871dab100e79 jdk8u5-b06
+469c2c1a4885ddedc114e17902bb2f7f7326a4b7 jdk8u5-b07
+e48a0e01e6e19846533ec2cf3df15a6699d7ea8b jdk8u5-b08
+cd9a093d0f63375dc323f8af59a3f7e77bc5d3e9 jdk8u5-b09
+7f905cc47d4951628d956c436c8aa95aeb8bd014 jdk8u5-b10
+f4f3b7ccd2801a0a87dd4677332f5b93191d08f2 jdk8u5-b11
+9ff7f7909e122bb54f7df80efd0fc7a03ce7efff jdk8u5-b12
--- jdk/.jcheck/conf
+++ jdk/.jcheck/conf
@@ -1 +1,2 @@
 project=jdk8
+bugids=dup
--- jdk/THIRD_PARTY_README
+++ jdk/THIRD_PARTY_README
@@ -1399,13 +1399,13 @@
 
 -------------------------------------------------------------------------------
 
-%% This notice is provided with respect to Little CMS 2.4, which may be 
+%% This notice is provided with respect to Little CMS 2.5, which may be 
 included with JRE 8, JDK 8, and OpenJDK 8.
 
 --- begin of LICENSE ---
 
 Little CMS
-Copyright (c) 1998-2010 Marti Maria Saguer
+Copyright (c) 1998-2011 Marti Maria Saguer
 
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
--- jdk/make/CompileJavaClasses.gmk
+++ jdk/make/CompileJavaClasses.gmk
@@ -390,7 +390,7 @@
 
 ##########################################################################################
 
-all: $(BUILD_JDK) $(BUILD_SECURITY) $(BUILD_JOBJC) $(BUILD_JOBJC_HEADERS) $(COPY_EXTRA) \
+all: $(BUILD_JDK) $(BUILD_SECURITY) $(COPY_EXTRA) \
     $(JDK_OUTPUTDIR)/classes/META-INF/services/com.sun.tools.xjc.Plugin \
     $(BUILD_ACCESSBRIDGE_32) $(BUILD_ACCESSBRIDGE_64) \
     $(BUILD_ACCESSBRIDGE_LEGACY)
--- jdk/make/data/tzdata/VERSION
+++ jdk/make/data/tzdata/VERSION
@@ -21,4 +21,4 @@
 # or visit www.oracle.com if you need additional information or have any
 # questions.
 #
-tzdata2013h
+tzdata2013i
--- jdk/make/data/tzdata/africa
+++ jdk/make/data/tzdata/africa
@@ -500,14 +500,13 @@
 Rule	Libya	1997	only	-	Oct	 4	0:00	0	-
 Rule	Libya	2013	only	-	Mar	lastFri	1:00	1:00	S
 Rule	Libya	2013	only	-	Oct	lastFri	2:00	0	-
-
-# The 1996 and 1997 entries are from Shanks & Pottenger;
-# the IATA SSIM data contain some obvious errors.
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
 Zone	Africa/Tripoli	0:52:44 -	LMT	1920
 			1:00	Libya	CE%sT	1959
 			2:00	-	EET	1982
 			1:00	Libya	CE%sT	1990 May  4
+# The 1996 and 1997 entries are from Shanks & Pottenger;
+# the IATA SSIM data contain some obvious errors.
 			2:00	-	EET	1996 Sep 30
 			1:00	Libya	CE%sT	1997 Oct  4
 			2:00	-	EET	2012 Nov 10 2:00
--- jdk/make/data/tzdata/asia
+++ jdk/make/data/tzdata/asia
@@ -1403,12 +1403,22 @@
 # switch back to standard time this winter, so the will stay on DST
 # until about the same time next year (at least).
 # http://www.petra.gov.jo/Public_News/Nws_NewsDetails.aspx?NewsID=88950
-#
-# From Paul Eggert (2013-09-21):
-# It's looking like this change will be permanent; see
-# Petra News Agency, Cancelling winter saved Jordan $7 million (2013-02-20)
-# <http://www.albawaba.com/business/jordan-winter-electricity--472005>.
-# So move Jordan to UTC+3 as of the abovementioned date.
+
+# From Steffen Thorsen (2013-12-11):
+# Jordan Times and other sources say that Jordan is going back to
+# UTC+2 on 2013-12-19 at midnight:
+# http://jordantimes.com/govt-decides-to-switch-back-to-wintertime
+# Official, in Arabic:
+# http://www.petra.gov.jo/public_news/Nws_NewsDetails.aspx?Menu_ID=&Site_Id=2&lang=1&NewsID=133230&CatID=14
+# ... Our background/permalink about it
+# http://www.timeanddate.com/news/time/jordan-reverses-dst-decision.html
+# ...
+# http://www.petra.gov.jo/Public_News/Nws_NewsDetails.aspx?lang=2&site_id=1&NewsID=133313&Type=P
+# ... says midnight for the coming one and 1:00 for the ones in the future
+# (and they will use DST again next year, using the normal schedule).
+
+# From Paul Eggert (2013-12-11):
+# As Steffen suggested, consider the past 21-month experiment to be DST.
 
 # Rule	NAME	FROM	TO	TYPE	IN	ON	AT	SAVE	LETTER/S
 Rule	Jordan	1973	only	-	Jun	6	0:00	1:00	S
@@ -1438,11 +1448,13 @@
 Rule	Jordan	2003	only	-	Oct	24	0:00s	0	-
 Rule	Jordan	2004	only	-	Oct	15	0:00s	0	-
 Rule	Jordan	2005	only	-	Sep	lastFri	0:00s	0	-
-Rule	Jordan	2006	2012	-	Oct	lastFri	0:00s	0	-
+Rule	Jordan	2006	2011	-	Oct	lastFri	0:00s	0	-
+Rule	Jordan	2013	only	-	Dec	20	0:00	0	-
+Rule	Jordan	2014	max	-	Mar	lastThu	24:00	1:00	S
+Rule	Jordan	2014	max	-	Oct	lastFri	0:00s	0	-
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
 Zone	Asia/Amman	2:23:44 -	LMT	1931
-			2:00	Jordan	EE%sT	2012 Oct 26 0:00s
-			3:00	-	AST
+			2:00	Jordan	EE%sT
 
 
 # Kazakhstan
--- jdk/make/data/tzdata/northamerica
+++ jdk/make/data/tzdata/northamerica
@@ -2688,6 +2688,11 @@
 # to DST--and one more hour on 1999-04-04--when the announcers will have
 # returned to Baltimore, which switches on that date.)
 
+# From Steffen Thorsen (2013-11-11):
+# DST start in Cuba in 2004 ... does not follow the same rules as the
+# years before.  The correct date should be Sunday 2004-03-28 00:00 ...
+# https://web.archive.org/web/20040402060750/http://www.granma.cu/espanol/2004/marzo/sab27/reloj.html
+
 # From Evert van der Veer via Steffen Thorsen (2004-10-28):
 # Cuba is not going back to standard time this year.
 # From Paul Eggert (2006-03-22):
@@ -2877,7 +2882,8 @@
 Rule	Cuba	1997	only	-	Oct	12	0:00s	0	S
 Rule	Cuba	1998	1999	-	Mar	lastSun	0:00s	1:00	D
 Rule	Cuba	1998	2003	-	Oct	lastSun	0:00s	0	S
-Rule	Cuba	2000	2004	-	Apr	Sun>=1	0:00s	1:00	D
+Rule	Cuba	2000	2003	-	Apr	Sun>=1	0:00s	1:00	D
+Rule	Cuba	2004	only	-	Mar	lastSun	0:00s	1:00	D
 Rule	Cuba	2006	2010	-	Oct	lastSun	0:00s	0	S
 Rule	Cuba	2007	only	-	Mar	Sun>=8	0:00s	1:00	D
 Rule	Cuba	2008	only	-	Mar	Sun>=15	0:00s	1:00	D
--- jdk/src/macosx/classes/sun/font/CFontManager.java
+++ jdk/src/macosx/classes/sun/font/CFontManager.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,6 +27,8 @@
 
 import java.awt.*;
 import java.io.File;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.Hashtable;
@@ -38,6 +40,7 @@
 
 import sun.awt.FontConfiguration;
 import sun.awt.HeadlessToolkit;
+import sun.misc.ThreadGroupUtils;
 import sun.lwawt.macosx.*;
 
 public class CFontManager extends SunFontManager {
@@ -215,24 +218,19 @@
                                 });
                     }
                 };
-                java.security.AccessController.doPrivileged(
-                        new java.security.PrivilegedAction<Object>() {
-                            public Object run() {
-                                /* The thread must be a member of a thread group
-                                 * which will not get GCed before VM exit.
-                                 * Make its parent the top-level thread group.
-                                 */
-                                ThreadGroup tg =
-                                    Thread.currentThread().getThreadGroup();
-                                for (ThreadGroup tgn = tg;
-                                tgn != null;
-                                tg = tgn, tgn = tg.getParent());
-                                fileCloser = new Thread(tg, fileCloserRunnable);
-                                fileCloser.setContextClassLoader(null);
-                                Runtime.getRuntime().addShutdownHook(fileCloser);
-                                return null;
-                            }
-                        });
+                AccessController.doPrivileged(
+                        (PrivilegedAction<Void>) () -> {
+                            /* The thread must be a member of a thread group
+                             * which will not get GCed before VM exit.
+                             * Make its parent the top-level thread group.
+                             */
+                            ThreadGroup rootTG = ThreadGroupUtils.getRootThreadGroup();
+                            fileCloser = new Thread(rootTG, fileCloserRunnable);
+                            fileCloser.setContextClassLoader(null);
+                            Runtime.getRuntime().addShutdownHook(fileCloser);
+                            return null;
+                        }
+                );
                 }
             }
         }
--- jdk/src/macosx/classes/sun/lwawt/LWToolkit.java
+++ jdk/src/macosx/classes/sun/lwawt/LWToolkit.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -39,6 +39,7 @@
 import sun.lwawt.macosx.*;
 import sun.print.*;
 import sun.security.util.SecurityConstants;
+import sun.misc.ThreadGroupUtils;
 
 public abstract class LWToolkit extends SunToolkit implements Runnable {
 
@@ -72,30 +73,17 @@
     protected final void init() {
         AWTAutoShutdown.notifyToolkitThreadBusy();
 
-        ThreadGroup mainTG = AccessController.doPrivileged(
-            new PrivilegedAction<ThreadGroup>() {
-                public ThreadGroup run() {
-                    ThreadGroup currentTG = Thread.currentThread().getThreadGroup();
-                    ThreadGroup parentTG = currentTG.getParent();
-                    while (parentTG != null) {
-                        currentTG = parentTG;
-                        parentTG = currentTG.getParent();
-                    }
-                    return currentTG;
-                }
-            }
-        );
+        ThreadGroup rootTG = AccessController.doPrivileged(
+                (PrivilegedAction<ThreadGroup>) ThreadGroupUtils::getRootThreadGroup);
 
         Runtime.getRuntime().addShutdownHook(
-            new Thread(mainTG, new Runnable() {
-                public void run() {
-                    shutdown();
-                    waitForRunState(STATE_CLEANUP);
-                }
+            new Thread(rootTG, () -> {
+                shutdown();
+                waitForRunState(STATE_CLEANUP);
             })
         );
 
-        Thread toolkitThread = new Thread(mainTG, this, "AWT-LW");
+        Thread toolkitThread = new Thread(rootTG, this, "AWT-LW");
         toolkitThread.setDaemon(true);
         toolkitThread.setPriority(Thread.NORM_PRIORITY + 1);
         toolkitThread.start();
--- jdk/src/macosx/classes/sun/lwawt/macosx/CClipboard.java
+++ jdk/src/macosx/classes/sun/lwawt/macosx/CClipboard.java
@@ -55,7 +55,7 @@
     }
 
     protected void setContentsNative(Transferable contents) {
-
+        FlavorTable flavorMap = getDefaultFlavorTable();
         // Don't use delayed Clipboard rendering for the Transferable's data.
         // If we did that, we would call Transferable.getTransferData on
         // the Toolkit thread, which is a security hole.
--- jdk/src/macosx/classes/sun/lwawt/macosx/LWCToolkit.java
+++ jdk/src/macosx/classes/sun/lwawt/macosx/LWCToolkit.java
@@ -444,8 +444,12 @@
     }
 
     // Intended to be called from the LWCToolkit.m only.
-    private static void installToolkitThreadNameInJava() {
+    private static void installToolkitThreadInJava() {
         Thread.currentThread().setName(CThreading.APPKIT_THREAD_NAME);
+        AccessController.doPrivileged((PrivilegedAction<Void>) () -> {
+            Thread.currentThread().setContextClassLoader(null);
+            return null;
+        });
     }
 
     @Override
--- jdk/src/macosx/native/sun/awt/LWCToolkit.m
+++ jdk/src/macosx/native/sun/awt/LWCToolkit.m
@@ -188,15 +188,16 @@
 Java_sun_lwawt_macosx_LWCToolkit_initIDs
 (JNIEnv *env, jclass klass) {
     // set thread names
-    dispatch_async(dispatch_get_main_queue(), ^(void){
-        [[NSThread currentThread] setName:@"AppKit Thread"];
-
-        JNIEnv *env = [ThreadUtilities getJNIEnv];
-        static JNF_CLASS_CACHE(jc_LWCToolkit, "sun/lwawt/macosx/LWCToolkit");
-        static JNF_STATIC_MEMBER_CACHE(jsm_installToolkitThreadNameInJava, jc_LWCToolkit, "installToolkitThreadNameInJava", "()V");
-        JNFCallStaticVoidMethod(env, jsm_installToolkitThreadNameInJava);
-    });
-
+    if (![ThreadUtilities isAWTEmbedded]) {
+        dispatch_async(dispatch_get_main_queue(), ^(void){
+            [[NSThread currentThread] setName:@"AppKit Thread"];
+            JNIEnv *env = [ThreadUtilities getJNIEnv];
+            static JNF_CLASS_CACHE(jc_LWCToolkit, "sun/lwawt/macosx/LWCToolkit");
+            static JNF_STATIC_MEMBER_CACHE(jsm_installToolkitThreadInJava, jc_LWCToolkit, "installToolkitThreadInJava", "()V");
+            JNFCallStaticVoidMethod(env, jsm_installToolkitThreadInJava);
+        });
+    }
+    
     gNumberOfButtons = sun_lwawt_macosx_LWCToolkit_BUTTONS;
 
     jclass inputEventClazz = (*env)->FindClass(env, "java/awt/event/InputEvent");
--- jdk/src/macosx/native/sun/awt/awt.m
+++ jdk/src/macosx/native/sun/awt/awt.m
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -363,6 +363,7 @@
     //  AppKit Application.
     NSApplication *app = [NSApplicationAWT sharedApplication];
     isEmbedded = ![NSApp isKindOfClass:[NSApplicationAWT class]];
+    [ThreadUtilities setAWTEmbedded:isEmbedded];
 
     if (!isEmbedded) {
         // Install run loop observers and set the AppKit Java thread name
@@ -433,6 +434,14 @@
     if (isSWTInWebStart(env)) {
         forceEmbeddedMode = YES;
     }
+    JNIEnv* env = [ThreadUtilities getJNIEnvUncached];
+    jclass jc_ThreadGroupUtils = (*env)->FindClass(env, "sun/misc/ThreadGroupUtils");
+    jmethodID sjm_getRootThreadGroup = (*env)->GetStaticMethodID(env, jc_ThreadGroupUtils, "getRootThreadGroup", "()Ljava/lang/ThreadGroup;");
+    jobject rootThreadGroup = (*env)->CallStaticObjectMethod(env, jc_ThreadGroupUtils, sjm_getRootThreadGroup);
+    [ThreadUtilities setAppkitThreadGroup:(*env)->NewGlobalRef(env, rootThreadGroup)];
+    // The current thread was attached in getJNIEnvUnchached.
+    // Detach it back. It will be reattached later if needed with a proper TG
+    [ThreadUtilities detachCurrentThread];
 
     BOOL headless = isHeadless(env);
 
--- jdk/src/macosx/native/sun/osxapp/ThreadUtilities.h
+++ jdk/src/macosx/native/sun/osxapp/ThreadUtilities.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -127,6 +127,10 @@
 
 + (JNIEnv*)getJNIEnv;
 + (JNIEnv*)getJNIEnvUncached;
++ (void)detachCurrentThread;
++ (void)setAppkitThreadGroup:(jobject)group;
++ (void)setAWTEmbedded:(BOOL)embedded;
++ (BOOL)isAWTEmbedded;
 
 //Wrappers for the corresponding JNFRunLoop methods with a check for main thread
 + (void)performOnMainThreadWaiting:(BOOL)wait block:(void (^)())block;
--- jdk/src/macosx/native/sun/osxapp/ThreadUtilities.m
+++ jdk/src/macosx/native/sun/osxapp/ThreadUtilities.m
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -33,23 +33,45 @@
 // The following must be named "jvm", as there are extern references to it in AWT
 JavaVM *jvm = NULL;
 static JNIEnv *appKitEnv = NULL;
+static jobject appkitThreadGroup = NULL;
+static BOOL awtEmbedded = NO;
+
+inline void attachCurrentThread(void** env) {
+    if ([NSThread isMainThread]) {
+        JavaVMAttachArgs args;
+        args.version = JNI_VERSION_1_4;
+        args.name = "AppKit Thread";
+        args.group = appkitThreadGroup;
+        (*jvm)->AttachCurrentThreadAsDaemon(jvm, env, &args);
+    } else {
+        (*jvm)->AttachCurrentThreadAsDaemon(jvm, env, NULL);
+    }
+}
 
 @implementation ThreadUtilities
 
 + (JNIEnv*)getJNIEnv {
 AWT_ASSERT_APPKIT_THREAD;
     if (appKitEnv == NULL) {
-        (*jvm)->AttachCurrentThreadAsDaemon(jvm, (void **)&appKitEnv, NULL);
+        attachCurrentThread((void **)&appKitEnv);
     }
     return appKitEnv;
 }
 
 + (JNIEnv*)getJNIEnvUncached {
     JNIEnv *env = NULL;
-    (*jvm)->AttachCurrentThreadAsDaemon(jvm, (void **)&env, nil);
+    attachCurrentThread((void **)&env);
     return env;
 }
 
++ (void)detachCurrentThread {
+    (*jvm)->DetachCurrentThread(jvm);
+}
+
++ (void)setAppkitThreadGroup:(jobject)group {
+    appkitThreadGroup = group;
+}
+
 + (void)performOnMainThreadWaiting:(BOOL)wait block:(void (^)())block {
     if ([NSThread isMainThread] && wait == YES) {
         block(); 
@@ -66,6 +88,14 @@
     }
 }
 
++ (void)setAWTEmbedded:(BOOL)embedded {
+    awtEmbedded = embedded;
+}
+
++ (BOOL)isAWTEmbedded {
+    return awtEmbedded;
+}
+
 @end
 
 
--- jdk/src/share/classes/com/sun/jmx/remote/security/SubjectDelegator.java
+++ jdk/src/share/classes/com/sun/jmx/remote/security/SubjectDelegator.java
@@ -35,6 +35,8 @@
 import javax.management.remote.SubjectDelegationPermission;
 
 import com.sun.jmx.remote.util.CacheMap;
+import java.util.ArrayList;
+import java.util.Collection;
 
 public class SubjectDelegator {
     private static final int PRINCIPALS_CACHE_SIZE = 10;
@@ -53,11 +55,14 @@
                          boolean removeCallerContext)
             throws SecurityException {
 
+        if (System.getSecurityManager() != null && authenticatedACC == null) {
+            throw new SecurityException("Illegal AccessControlContext: null");
+        }
         if (principalsCache == null || accCache == null) {
             principalsCache =
-                    new CacheMap<Subject, Principal[]>(PRINCIPALS_CACHE_SIZE);
+                    new CacheMap<>(PRINCIPALS_CACHE_SIZE);
             accCache =
-                    new CacheMap<Subject, AccessControlContext>(ACC_CACHE_SIZE);
+                    new CacheMap<>(ACC_CACHE_SIZE);
         }
 
         // Retrieve the principals for the given
@@ -101,14 +106,15 @@
         // principal in the delegated subject
         //
         final Principal[] dp = delegatedPrincipals;
+        final Collection<Permission> permissions = new ArrayList<>(dp.length);
+        for(Principal p : dp) {
+            final String pname = p.getClass().getName() + "." + p.getName();
+            permissions.add(new SubjectDelegationPermission(pname));
+        }
         PrivilegedAction<Void> action =
             new PrivilegedAction<Void>() {
                 public Void run() {
-                    for (int i = 0 ; i < dp.length ; i++) {
-                        final String pname =
-                            dp[i].getClass().getName() + "." + dp[i].getName();
-                        Permission sdp =
-                            new SubjectDelegationPermission(pname);
+                    for (Permission sdp : permissions) {
                         AccessController.checkPermission(sdp);
                     }
                     return null;
--- jdk/src/share/classes/com/sun/jndi/dns/DnsClient.java
+++ jdk/src/share/classes/com/sun/jndi/dns/DnsClient.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -30,13 +30,14 @@
 import java.net.DatagramPacket;
 import java.net.InetAddress;
 import java.net.Socket;
+import java.security.SecureRandom;
 import javax.naming.*;
 
 import java.util.Collections;
 import java.util.Map;
 import java.util.HashMap;
-import java.util.Set;
-import java.util.HashSet;
+
+import sun.security.jca.JCAUtil;
 
 // Some of this code began life as part of sun.javaos.net.DnsClient
 // originally by sritchie@eng 1/96.  It was first hacked up for JNDI
@@ -77,6 +78,8 @@
     };
 
     private static final int DEFAULT_PORT = 53;
+    private static final int TRANSACTION_ID_BOUND = 0x10000;
+    private static final SecureRandom random = JCAUtil.getSecureRandom();
     private InetAddress[] servers;
     private int[] serverPorts;
     private int timeout;                // initial timeout on UDP queries in ms
@@ -85,7 +88,7 @@
     private DatagramSocket udpSocket;
 
     // Requests sent
-    private Set<Integer> reqs;
+    private Map<Integer, ResourceRecord> reqs;
 
     // Responses received
     private Map<Integer, byte[]> resps;
@@ -134,7 +137,8 @@
                 throw ne;
             }
         }
-        reqs = Collections.synchronizedSet(new HashSet<Integer>());
+        reqs = Collections.synchronizedMap(
+            new HashMap<Integer, ResourceRecord>());
         resps = Collections.synchronizedMap(new HashMap<Integer, byte[]>());
     }
 
@@ -153,10 +157,6 @@
         }
     }
 
-
-    private int ident = 0;              // used to set the msg ID field
-    private Object identLock = new Object();
-
     /*
      * If recursion is true, recursion is requested on the query.
      * If auth is true, only authoritative responses are accepted; other
@@ -167,15 +167,19 @@
             throws NamingException {
 
         int xid;
-        synchronized (identLock) {
-            ident = 0xFFFF & (ident + 1);
-            xid = ident;
-        }
+        Packet pkt;
+        ResourceRecord collision;
 
-        // enqueue the outstanding request
-        reqs.add(xid);
+        do {
+            // Generate a random transaction ID
+            xid = random.nextInt(TRANSACTION_ID_BOUND);
+            pkt = makeQueryPacket(fqdn, xid, qclass, qtype, recursion);
+
+            // enqueue the outstanding request
+            collision = reqs.putIfAbsent(xid, new ResourceRecord(pkt.getData(),
+                pkt.length(), Header.HEADER_SIZE, true, false));
 
-        Packet pkt = makeQueryPacket(fqdn, xid, qclass, qtype, recursion);
+        } while (collision != null);
 
         Exception caughtException = null;
         boolean[] doNotRetry = new boolean[servers.length];
@@ -305,11 +309,8 @@
     ResourceRecords queryZone(DnsName zone, int qclass, boolean recursion)
             throws NamingException {
 
-        int xid;
-        synchronized (identLock) {
-            ident = 0xFFFF & (ident + 1);
-            xid = ident;
-        }
+        int xid = random.nextInt(TRANSACTION_ID_BOUND);
+
         Packet pkt = makeQueryPacket(zone, xid, qclass,
                                      ResourceRecord.QTYPE_AXFR, recursion);
         Exception caughtException = null;
@@ -390,6 +391,7 @@
             DatagramPacket opkt = new DatagramPacket(
                     pkt.getData(), pkt.length(), server, port);
             DatagramPacket ipkt = new DatagramPacket(new byte[8000], 8000);
+            // Packets may only be sent to or received from this server address
             udpSocket.connect(server, port);
             int pktTimeout = (timeout * (1 << retry));
             try {
@@ -543,6 +545,9 @@
      * Checks the header of an incoming DNS response.
      * Returns true if it matches the given xid and throws a naming
      * exception, if appropriate, based on the response code.
+     *
+     * Also checks that the domain name, type and class in the response
+     * match those in the original query.
      */
     private boolean isMatchResponse(byte[] pkt, int xid)
                 throws NamingException {
@@ -552,7 +557,7 @@
             throw new CommunicationException("DNS error: expecting response");
         }
 
-        if (!reqs.contains(xid)) { // already received, ignore the response
+        if (!reqs.containsKey(xid)) { // already received, ignore the response
             return false;
         }
 
@@ -561,14 +566,47 @@
             if (debug) {
                 dprint("XID MATCH:" + xid);
             }
-
             checkResponseCode(hdr);
-            // remove the response for the xid if received by some other thread.
-            synchronized (queuesLock) {
-                resps.remove(xid);
-                reqs.remove(xid);
+            if (!hdr.query && hdr.numQuestions == 1) {
+
+                ResourceRecord rr = new ResourceRecord(pkt, pkt.length,
+                    Header.HEADER_SIZE, true, false);
+
+                // Retrieve the original query
+                ResourceRecord query = reqs.get(xid);
+                int qtype = query.getType();
+                int qclass = query.getRrclass();
+                DnsName qname = query.getName();
+
+                // Check that the type/class/name in the query section of the
+                // response match those in the original query
+                if ((qtype == ResourceRecord.QTYPE_STAR ||
+                    qtype == rr.getType()) &&
+                    (qclass == ResourceRecord.QCLASS_STAR ||
+                    qclass == rr.getRrclass()) &&
+                    qname.equals(rr.getName())) {
+
+                    if (debug) {
+                        dprint("MATCH NAME:" + qname + " QTYPE:" + qtype +
+                            " QCLASS:" + qclass);
+                    }
+
+                    // Remove the response for the xid if received by some other
+                    // thread.
+                    synchronized (queuesLock) {
+                        resps.remove(xid);
+                        reqs.remove(xid);
+                    }
+                    return true;
+
+                } else {
+                    if (debug) {
+                        dprint("NO-MATCH NAME:" + qname + " QTYPE:" + qtype +
+                            " QCLASS:" + qclass);
+                    }
+                }
             }
-            return true;
+            return false;
         }
 
         //
@@ -577,7 +615,7 @@
         // enqueue only the first response, responses for retries are ignored.
         //
         synchronized (queuesLock) {
-            if (reqs.contains(hdr.xid)) { // enqueue only the first response
+            if (reqs.containsKey(hdr.xid)) { // enqueue only the first response
                 resps.put(hdr.xid, pkt);
             }
         }
--- jdk/src/share/classes/com/sun/jndi/ldap/LdapBindingEnumeration.java
+++ jdk/src/share/classes/com/sun/jndi/ldap/LdapBindingEnumeration.java
@@ -25,6 +25,10 @@
 
 package com.sun.jndi.ldap;
 
+import java.security.AccessControlContext;
+import java.security.AccessController;
+import java.security.PrivilegedActionException;
+import java.security.PrivilegedExceptionAction;
 import java.util.Vector;
 import javax.naming.*;
 import javax.naming.directory.*;
@@ -36,6 +40,8 @@
 final class LdapBindingEnumeration
         extends AbstractLdapNamingEnumeration<Binding> {
 
+    private final AccessControlContext acc = AccessController.getContext();
+
     LdapBindingEnumeration(LdapCtx homeCtx, LdapResult answer, Name remain,
         Continuation cont) throws NamingException
     {
@@ -52,7 +58,16 @@
 
         if (attrs.get(Obj.JAVA_ATTRIBUTES[Obj.CLASSNAME]) != null) {
             // serialized object or object reference
-            obj = Obj.decodeObject(attrs);
+            try {
+                obj = AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {
+                    @Override
+                    public Object run() throws NamingException {
+                        return Obj.decodeObject(attrs);
+                    }
+                }, acc);
+            } catch (PrivilegedActionException e) {
+                throw (NamingException)e.getException();
+            }
         }
         if (obj == null) {
             // DirContext object
--- jdk/src/share/classes/com/sun/jndi/ldap/LdapSearchEnumeration.java
+++ jdk/src/share/classes/com/sun/jndi/ldap/LdapSearchEnumeration.java
@@ -25,6 +25,10 @@
 
 package com.sun.jndi.ldap;
 
+import java.security.AccessControlContext;
+import java.security.AccessController;
+import java.security.PrivilegedActionException;
+import java.security.PrivilegedExceptionAction;
 import java.util.Vector;
 import javax.naming.*;
 import javax.naming.directory.*;
@@ -40,6 +44,8 @@
     private Name startName;             // prefix of names of search results
     private LdapCtx.SearchArgs searchArgs = null;
 
+    private final AccessControlContext acc = AccessController.getContext();
+
     LdapSearchEnumeration(LdapCtx homeCtx, LdapResult search_results,
         String starter, LdapCtx.SearchArgs args, Continuation cont)
         throws NamingException {
@@ -112,8 +118,16 @@
             if (attrs.get(Obj.JAVA_ATTRIBUTES[Obj.CLASSNAME]) != null) {
                 // Entry contains Java-object attributes (ser/ref object)
                 // serialized object or object reference
-                obj = Obj.decodeObject(attrs);
-
+                try {
+                    obj = AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {
+                        @Override
+                        public Object run() throws NamingException {
+                            return Obj.decodeObject(attrs);
+                        }
+                    }, acc);
+                } catch (PrivilegedActionException e) {
+                    throw (NamingException)e.getException();
+                }
             }
             if (obj == null) {
                 obj = new LdapCtx(homeCtx, dn);
--- jdk/src/share/classes/com/sun/media/sound/JDK13Services.java
+++ jdk/src/share/classes/com/sun/media/sound/JDK13Services.java
@@ -25,27 +25,33 @@
 
 package com.sun.media.sound;
 
+import java.util.ArrayList;
 import java.util.Collections;
-import java.util.HashMap;
 import java.util.List;
-import java.util.Map;
 import java.util.Properties;
 
 import javax.sound.midi.Receiver;
 import javax.sound.midi.Sequencer;
 import javax.sound.midi.Synthesizer;
 import javax.sound.midi.Transmitter;
+import javax.sound.midi.spi.MidiDeviceProvider;
+import javax.sound.midi.spi.MidiFileReader;
+import javax.sound.midi.spi.MidiFileWriter;
+import javax.sound.midi.spi.SoundbankReader;
 import javax.sound.sampled.Clip;
 import javax.sound.sampled.Port;
 import javax.sound.sampled.SourceDataLine;
 import javax.sound.sampled.TargetDataLine;
+import javax.sound.sampled.spi.AudioFileReader;
+import javax.sound.sampled.spi.AudioFileWriter;
+import javax.sound.sampled.spi.FormatConversionProvider;
+import javax.sound.sampled.spi.MixerProvider;
 
 
 /**
- * JDK13Services uses the Service class in JDK 1.3
- * to discover a list of service providers installed
- * in the system.
- *
+ * JDK13Services uses the Service class in JDK 1.3 to discover a list of service
+ * providers installed in the system.
+ * <p>
  * This class is public because it is called from javax.sound.midi.MidiSystem
  * and javax.sound.sampled.AudioSystem. The alternative would be to make
  * JSSecurityManager public, which is considered worse.
@@ -54,80 +60,55 @@
  */
 public final class JDK13Services {
 
-    /** The default for the length of the period to hold the cache.
-        This value is given in milliseconds. It is equivalent to
-        1 minute.
-    */
-    private static final long DEFAULT_CACHING_PERIOD = 60000;
-
-    /** Filename of the properties file for default provider properties.
-        This file is searched in the subdirectory "lib" of the JRE directory
-        (this behaviour is hardcoded).
-    */
+    /**
+     * Filename of the properties file for default provider properties. This
+     * file is searched in the subdirectory "lib" of the JRE directory (this
+     * behaviour is hardcoded).
+     */
     private static final String PROPERTIES_FILENAME = "sound.properties";
 
-    /** Cache for the providers.
-        Class objects of the provider type (MixerProvider, MidiDeviceProvider
-        ...) are used as keys. The values are instances of ProviderCache.
-    */
-    private static final Map providersCacheMap = new HashMap();
-
-
-    /** The length of the period to hold the cache.
-        This value is given in milliseconds.
-    */
-    private static long cachingPeriod = DEFAULT_CACHING_PERIOD;
-
-    /** Properties loaded from the properties file for default provider
-        properties.
-    */
+    /**
+     * Properties loaded from the properties file for default provider
+     * properties.
+     */
     private static Properties properties;
 
-
-    /** Private, no-args constructor to ensure against instantiation.
+    /**
+     * Private, no-args constructor to ensure against instantiation.
      */
     private JDK13Services() {
     }
 
-
-    /** Set the period provider lists are cached.
-        This method is only intended for testing.
-     */
-    public static void setCachingPeriod(int seconds) {
-        cachingPeriod = seconds * 1000L;
-    }
-
-
-    /** Obtains a List containing installed instances of the
-        providers for the requested service.
-        The List of providers is cached for the period of time given by
-        {@link #cachingPeriod cachingPeriod}. During this period, the same
-        List instance is returned for the same type of provider. After this
-        period, a new instance is constructed and returned. The returned
-        List is immutable.
-        @param serviceClass The type of providers requested. This should be one
-        of AudioFileReader.class, AudioFileWriter.class,
-        FormatConversionProvider.class, MixerProvider.class,
-        MidiDeviceProvider.class, MidiFileReader.class, MidiFileWriter.class or
-        SoundbankReader.class.
-        @return A List of providers of the requested type. This List is
-        immutable.
-     */
-    public static synchronized List getProviders(Class serviceClass) {
-        ProviderCache cache = (ProviderCache) providersCacheMap.get(serviceClass);
-        if (cache == null) {
-            cache = new ProviderCache();
-            providersCacheMap.put(serviceClass, cache);
-        }
-        if (cache.providers == null ||
-            System.currentTimeMillis() > cache.lastUpdate + cachingPeriod) {
-            cache.providers = Collections.unmodifiableList(JSSecurityManager.getProviders(serviceClass));
-            cache.lastUpdate = System.currentTimeMillis();
+    /**
+     * Obtains a List containing installed instances of the providers for the
+     * requested service. The returned List is immutable.
+     *
+     * @param serviceClass The type of providers requested. This should be one
+     *                     of AudioFileReader.class, AudioFileWriter.class,
+     *                     FormatConversionProvider.class, MixerProvider.class,
+     *                     MidiDeviceProvider.class, MidiFileReader.class,
+     *                     MidiFileWriter.class or SoundbankReader.class.
+     *
+     * @return A List of providers of the requested type. This List is
+     *         immutable.
+     */
+    public static List<?> getProviders(final Class<?> serviceClass) {
+        final List<?> providers;
+        if (!MixerProvider.class.equals(serviceClass)
+                && !FormatConversionProvider.class.equals(serviceClass)
+                && !AudioFileReader.class.equals(serviceClass)
+                && !AudioFileWriter.class.equals(serviceClass)
+                && !MidiDeviceProvider.class.equals(serviceClass)
+                && !SoundbankReader.class.equals(serviceClass)
+                && !MidiFileWriter.class.equals(serviceClass)
+                && !MidiFileReader.class.equals(serviceClass)) {
+            providers = new ArrayList<>(0);
+        } else {
+            providers = JSSecurityManager.getProviders(serviceClass);
         }
-        return cache.providers;
+        return Collections.unmodifiableList(providers);
     }
 
-
     /** Obtain the provider class name part of a default provider property.
         @param typeClass The type of the default provider property. This
         should be one of Receiver.class, Transmitter.class, Sequencer.class,
@@ -219,14 +200,4 @@
         }
         return properties;
     }
-
-    // INNER CLASSES
-
-    private static class ProviderCache {
-        // System time of the last update in milliseconds.
-        public long lastUpdate;
-
-        // The providers.
-        public List providers;
-    }
 }
--- jdk/src/share/classes/com/sun/media/sound/JSSecurityManager.java
+++ jdk/src/share/classes/com/sun/media/sound/JSSecurityManager.java
@@ -185,8 +185,8 @@
         return thread;
     }
 
-    static <T> List<T> getProviders(final Class<T> providerClass) {
-        List<T> p = new ArrayList<>();
+    static synchronized <T> List<T> getProviders(final Class<T> providerClass) {
+        List<T> p = new ArrayList<>(7);
         // ServiceLoader creates "lazy" iterator instance, but it ensures that
         // next/hasNext run with permissions that are restricted by whatever
         // creates the ServiceLoader instance, so it requires to be called from
--- jdk/src/share/classes/com/sun/rowset/CachedRowSetImpl.java
+++ jdk/src/share/classes/com/sun/rowset/CachedRowSetImpl.java
@@ -37,6 +37,7 @@
 import javax.sql.rowset.serial.*;
 import com.sun.rowset.internal.*;
 import com.sun.rowset.providers.*;
+import sun.reflect.misc.ReflectUtil;
 
 /**
  * The standard implementation of the <code>CachedRowSet</code> interface.
@@ -2959,13 +2960,9 @@
                 // create new instance of the class
                 SQLData obj = null;
                 try {
-                    obj = (SQLData)c.newInstance();
-                } catch (java.lang.InstantiationException ex) {
-                    throw new SQLException(MessageFormat.format(resBundle.handleGetObject("cachedrowsetimpl.unableins").toString(),
-                    ex.getMessage()));
-                } catch (java.lang.IllegalAccessException ex) {
-                    throw new SQLException(MessageFormat.format(resBundle.handleGetObject("cachedrowsetimpl.unableins").toString(),
-                    ex.getMessage()));
+                    obj = (SQLData) ReflectUtil.newInstance(c);
+                } catch(Exception ex) {
+                    throw new SQLException("Unable to Instantiate: ", ex);
                 }
                 // get the attributes from the struct
                 Object attribs[] = s.getAttributes(map);
@@ -5710,13 +5707,9 @@
                 // create new instance of the class
                 SQLData obj = null;
                 try {
-                    obj = (SQLData)c.newInstance();
-                } catch (java.lang.InstantiationException ex) {
-                    throw new SQLException(MessageFormat.format(resBundle.handleGetObject("cachedrowsetimpl.unableins").toString(),
-                    ex.getMessage()));
-                } catch (java.lang.IllegalAccessException ex) {
-                    throw new SQLException(MessageFormat.format(resBundle.handleGetObject("cachedrowsetimpl.unableins").toString(),
-                    ex.getMessage()));
+                    obj = (SQLData) ReflectUtil.newInstance(c);
+                } catch(Exception ex) {
+                    throw new SQLException("Unable to Instantiate: ", ex);
                 }
                 // get the attributes from the struct
                 Object attribs[] = s.getAttributes(map);
--- jdk/src/share/classes/com/sun/rowset/internal/CachedRowSetWriter.java
+++ jdk/src/share/classes/com/sun/rowset/internal/CachedRowSetWriter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -29,6 +29,7 @@
 import javax.sql.*;
 import java.util.*;
 import java.io.*;
+import sun.reflect.misc.ReflectUtil;
 
 import com.sun.rowset.*;
 import java.text.MessageFormat;
@@ -572,13 +573,9 @@
                         // create new instance of the class
                         SQLData obj = null;
                         try {
-                            obj = (SQLData)c.newInstance();
-                        } catch (java.lang.InstantiationException ex) {
-                            throw new SQLException(MessageFormat.format(resBundle.handleGetObject("cachedrowsetimpl.unableins").toString(),
-                            ex.getMessage()));
-                        } catch (java.lang.IllegalAccessException ex) {
-                            throw new SQLException(MessageFormat.format(resBundle.handleGetObject("cachedrowsetimpl.unableins").toString(),
-                            ex.getMessage()));
+                            obj = (SQLData)ReflectUtil.newInstance(c);
+                        } catch (Exception ex) {
+                            throw new SQLException("Unable to Instantiate: ", ex);
                         }
                         // get the attributes from the struct
                         Object attribs[] = s.getAttributes(map);
--- jdk/src/share/classes/java/awt/EventQueue.java
+++ jdk/src/share/classes/java/awt/EventQueue.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -1062,11 +1062,11 @@
                             t.setContextClassLoader(classLoader);
                             t.setPriority(Thread.NORM_PRIORITY + 1);
                             t.setDaemon(false);
+                            AWTAutoShutdown.getInstance().notifyThreadBusy(t);
                             return t;
                         }
                     }
                 );
-                AWTAutoShutdown.getInstance().notifyThreadBusy(dispatchThread);
                 dispatchThread.start();
             }
         } finally {
--- jdk/src/share/classes/java/awt/datatransfer/SystemFlavorMap.java
+++ jdk/src/share/classes/java/awt/datatransfer/SystemFlavorMap.java
@@ -44,8 +44,8 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
-import java.util.WeakHashMap;
 
+import sun.awt.AppContext;
 import sun.awt.datatransfer.DataTransferer;
 
 /**
@@ -66,10 +66,7 @@
      */
     private static String JavaMIME = "JAVA_DATAFLAVOR:";
 
-    /**
-     * System singleton which maps a thread's ClassLoader to a SystemFlavorMap.
-     */
-    private static final WeakHashMap<ClassLoader, FlavorMap> flavorMaps = new WeakHashMap<>();
+    private static final Object FLAVOR_MAP_KEY = new Object();
 
     /**
      * Copied from java.util.Properties.
@@ -183,22 +180,12 @@
      * Returns the default FlavorMap for this thread's ClassLoader.
      */
     public static FlavorMap getDefaultFlavorMap() {
-        ClassLoader contextClassLoader =
-            Thread.currentThread().getContextClassLoader();
-        if (contextClassLoader == null) {
-            contextClassLoader = ClassLoader.getSystemClassLoader();
-        }
-
-        FlavorMap fm;
-
-        synchronized(flavorMaps) {
-            fm = flavorMaps.get(contextClassLoader);
-            if (fm == null) {
-                fm = new SystemFlavorMap();
-                flavorMaps.put(contextClassLoader, fm);
-            }
+        AppContext context = AppContext.getAppContext();
+        FlavorMap fm = (FlavorMap) context.get(FLAVOR_MAP_KEY);
+        if (fm == null) {
+            fm = new SystemFlavorMap();
+            context.put(FLAVOR_MAP_KEY, fm);
         }
-
         return fm;
     }
 
@@ -239,26 +226,11 @@
                     }
                 });
 
-        BufferedReader flavormapURL =
+        String url =
             java.security.AccessController.doPrivileged(
-                new java.security.PrivilegedAction<BufferedReader>() {
-                    public BufferedReader run() {
-                        String url = Toolkit.getProperty("AWT.DnD.flavorMapFileURL", null);
-
-                        if (url == null) {
-                            return null;
-                        }
-
-                        try {
-                            return new BufferedReader
-                                (new InputStreamReader
-                                    (new URL(url).openStream(), "ISO-8859-1"));
-                        } catch (MalformedURLException e) {
-                            System.err.println("MalformedURLException:" + e + " while reading AWT.DnD.flavorMapFileURL:" + url);
-                        } catch (IOException e) {
-                            System.err.println("IOException:" + e + " while reading AWT.DnD.flavorMapFileURL:" + url);
-                        }
-                        return null;
+                new java.security.PrivilegedAction<String>() {
+                    public String run() {
+                        return Toolkit.getProperty("AWT.DnD.flavorMapFileURL", null);
                     }
                 });
 
@@ -270,6 +242,19 @@
             }
         }
 
+        BufferedReader flavormapURL = null;
+        if (url != null) {
+            try {
+                flavormapURL = new BufferedReader(new InputStreamReader(new URL(url).openStream(), "ISO-8859-1"));
+            } catch (MalformedURLException e) {
+                System.err.println("MalformedURLException:" + e + " while reading AWT.DnD.flavorMapFileURL:" + url);
+            } catch (IOException e) {
+                System.err.println("IOException:" + e + " while reading AWT.DnD.flavorMapFileURL:" + url);
+            } catch (SecurityException e) {
+                // ignored
+            }
+        }
+
         if (flavormapURL != null) {
             try {
                 parseAndStoreReader(flavormapURL);
--- jdk/src/share/classes/java/lang/Thread.java
+++ jdk/src/share/classes/java/lang/Thread.java
@@ -366,6 +366,8 @@
             throw new NullPointerException("name cannot be null");
         }
 
+        this.name = name.toCharArray();
+
         Thread parent = currentThread();
         SecurityManager security = System.getSecurityManager();
         if (g == null) {
@@ -402,7 +404,6 @@
         this.group = g;
         this.daemon = parent.isDaemon();
         this.priority = parent.getPriority();
-        this.name = name.toCharArray();
         if (security == null || isCCLOverridden(parent.getClass()))
             this.contextClassLoader = parent.getContextClassLoader();
         else
--- jdk/src/share/classes/java/lang/invoke/BoundMethodHandle.java
+++ jdk/src/share/classes/java/lang/invoke/BoundMethodHandle.java
@@ -140,7 +140,7 @@
      * Return the {@link SpeciesData} instance representing this BMH species. All subclasses must provide a
      * static field containing this value, and they must accordingly implement this method.
      */
-    protected abstract SpeciesData speciesData();
+    /*non-public*/ abstract SpeciesData speciesData();
 
     @Override
     final Object internalProperties() {
@@ -156,7 +156,7 @@
         return Arrays.asList(boundValues);
     }
 
-    public final Object arg(int i) {
+    /*non-public*/ final Object arg(int i) {
         try {
             switch (speciesData().fieldType(i)) {
             case 'L': return argL(i);
@@ -170,22 +170,22 @@
         }
         throw new InternalError("unexpected type: " + speciesData().types+"."+i);
     }
-    public final Object argL(int i) throws Throwable { return          speciesData().getters[i].invokeBasic(this); }
-    public final int    argI(int i) throws Throwable { return (int)    speciesData().getters[i].invokeBasic(this); }
-    public final float  argF(int i) throws Throwable { return (float)  speciesData().getters[i].invokeBasic(this); }
-    public final double argD(int i) throws Throwable { return (double) speciesData().getters[i].invokeBasic(this); }
-    public final long   argJ(int i) throws Throwable { return (long)   speciesData().getters[i].invokeBasic(this); }
+    /*non-public*/ final Object argL(int i) throws Throwable { return          speciesData().getters[i].invokeBasic(this); }
+    /*non-public*/ final int    argI(int i) throws Throwable { return (int)    speciesData().getters[i].invokeBasic(this); }
+    /*non-public*/ final float  argF(int i) throws Throwable { return (float)  speciesData().getters[i].invokeBasic(this); }
+    /*non-public*/ final double argD(int i) throws Throwable { return (double) speciesData().getters[i].invokeBasic(this); }
+    /*non-public*/ final long   argJ(int i) throws Throwable { return (long)   speciesData().getters[i].invokeBasic(this); }
 
     //
     // cloning API
     //
 
-    public abstract BoundMethodHandle clone(MethodType mt, LambdaForm lf) throws Throwable;
-    public abstract BoundMethodHandle cloneExtendL(MethodType mt, LambdaForm lf, Object narg) throws Throwable;
-    public abstract BoundMethodHandle cloneExtendI(MethodType mt, LambdaForm lf, int    narg) throws Throwable;
-    public abstract BoundMethodHandle cloneExtendJ(MethodType mt, LambdaForm lf, long   narg) throws Throwable;
-    public abstract BoundMethodHandle cloneExtendF(MethodType mt, LambdaForm lf, float  narg) throws Throwable;
-    public abstract BoundMethodHandle cloneExtendD(MethodType mt, LambdaForm lf, double narg) throws Throwable;
+    /*non-public*/ abstract BoundMethodHandle clone(MethodType mt, LambdaForm lf) throws Throwable;
+    /*non-public*/ abstract BoundMethodHandle cloneExtendL(MethodType mt, LambdaForm lf, Object narg) throws Throwable;
+    /*non-public*/ abstract BoundMethodHandle cloneExtendI(MethodType mt, LambdaForm lf, int    narg) throws Throwable;
+    /*non-public*/ abstract BoundMethodHandle cloneExtendJ(MethodType mt, LambdaForm lf, long   narg) throws Throwable;
+    /*non-public*/ abstract BoundMethodHandle cloneExtendF(MethodType mt, LambdaForm lf, float  narg) throws Throwable;
+    /*non-public*/ abstract BoundMethodHandle cloneExtendD(MethodType mt, LambdaForm lf, double narg) throws Throwable;
 
     // The following is a grossly irregular hack:
     @Override MethodHandle reinvokerTarget() {
@@ -203,39 +203,39 @@
     private  // make it private to force users to access the enclosing class first
     static final class Species_L extends BoundMethodHandle {
         final Object argL0;
-        public Species_L(MethodType mt, LambdaForm lf, Object argL0) {
+        /*non-public*/ Species_L(MethodType mt, LambdaForm lf, Object argL0) {
             super(mt, lf);
             this.argL0 = argL0;
         }
         // The following is a grossly irregular hack:
         @Override MethodHandle reinvokerTarget() { return (MethodHandle) argL0; }
         @Override
-        public SpeciesData speciesData() {
+        /*non-public*/ SpeciesData speciesData() {
             return SPECIES_DATA;
         }
-        public static final SpeciesData SPECIES_DATA = SpeciesData.getForClass("L", Species_L.class);
+        /*non-public*/ static final SpeciesData SPECIES_DATA = SpeciesData.getForClass("L", Species_L.class);
         @Override
-        public final BoundMethodHandle clone(MethodType mt, LambdaForm lf) throws Throwable {
+        /*non-public*/ final BoundMethodHandle clone(MethodType mt, LambdaForm lf) throws Throwable {
             return new Species_L(mt, lf, argL0);
         }
         @Override
-        public final BoundMethodHandle cloneExtendL(MethodType mt, LambdaForm lf, Object narg) throws Throwable {
+        /*non-public*/ final BoundMethodHandle cloneExtendL(MethodType mt, LambdaForm lf, Object narg) throws Throwable {
             return (BoundMethodHandle) SPECIES_DATA.extendWithIndex(INDEX_L).constructor[0].invokeBasic(mt, lf, argL0, narg);
         }
         @Override
-        public final BoundMethodHandle cloneExtendI(MethodType mt, LambdaForm lf, int narg) throws Throwable {
+        /*non-public*/ final BoundMethodHandle cloneExtendI(MethodType mt, LambdaForm lf, int narg) throws Throwable {
             return (BoundMethodHandle) SPECIES_DATA.extendWithIndex(INDEX_I).constructor[0].invokeBasic(mt, lf, argL0, narg);
         }
         @Override
-        public final BoundMethodHandle cloneExtendJ(MethodType mt, LambdaForm lf, long narg) throws Throwable {
+        /*non-public*/ final BoundMethodHandle cloneExtendJ(MethodType mt, LambdaForm lf, long narg) throws Throwable {
             return (BoundMethodHandle) SPECIES_DATA.extendWithIndex(INDEX_J).constructor[0].invokeBasic(mt, lf, argL0, narg);
         }
         @Override
-        public final BoundMethodHandle cloneExtendF(MethodType mt, LambdaForm lf, float narg) throws Throwable {
+        /*non-public*/ final BoundMethodHandle cloneExtendF(MethodType mt, LambdaForm lf, float narg) throws Throwable {
             return (BoundMethodHandle) SPECIES_DATA.extendWithIndex(INDEX_F).constructor[0].invokeBasic(mt, lf, argL0, narg);
         }
         @Override
-        public final BoundMethodHandle cloneExtendD(MethodType mt, LambdaForm lf, double narg) throws Throwable {
+        /*non-public*/ final BoundMethodHandle cloneExtendD(MethodType mt, LambdaForm lf, double narg) throws Throwable {
             return (BoundMethodHandle) SPECIES_DATA.extendWithIndex(INDEX_D).constructor[0].invokeBasic(mt, lf, argL0, narg);
         }
     }
@@ -338,10 +338,10 @@
         final MethodHandle[]                     getters;
         final SpeciesData[]                      extensions;
 
-        public int fieldCount() {
+        /*non-public*/ int fieldCount() {
             return types.length();
         }
-        public char fieldType(int i) {
+        /*non-public*/ char fieldType(int i) {
             return types.charAt(i);
         }
 
@@ -551,30 +551,30 @@
          *     final Object argL0;
          *     final Object argL1;
          *     final int argI2;
-         *     public Species_LLI(MethodType mt, LambdaForm lf, Object argL0, Object argL1, int argI2) {
+         *     Species_LLI(MethodType mt, LambdaForm lf, Object argL0, Object argL1, int argI2) {
          *         super(mt, lf);
          *         this.argL0 = argL0;
          *         this.argL1 = argL1;
          *         this.argI2 = argI2;
          *     }
-         *     public final SpeciesData speciesData() { return SPECIES_DATA; }
-         *     public static final SpeciesData SPECIES_DATA = SpeciesData.getForClass("LLI", Species_LLI.class);
-         *     public final BoundMethodHandle clone(MethodType mt, LambdaForm lf) {
+         *     final SpeciesData speciesData() { return SPECIES_DATA; }
+         *     static final SpeciesData SPECIES_DATA = SpeciesData.getForClass("LLI", Species_LLI.class);
+         *     final BoundMethodHandle clone(MethodType mt, LambdaForm lf) {
          *         return SPECIES_DATA.constructor[0].invokeBasic(mt, lf, argL0, argL1, argI2);
          *     }
-         *     public final BoundMethodHandle cloneExtendL(MethodType mt, LambdaForm lf, Object narg) {
+         *     final BoundMethodHandle cloneExtendL(MethodType mt, LambdaForm lf, Object narg) {
          *         return SPECIES_DATA.extendWithIndex(INDEX_L).constructor[0].invokeBasic(mt, lf, argL0, argL1, argI2, narg);
          *     }
-         *     public final BoundMethodHandle cloneExtendI(MethodType mt, LambdaForm lf, int narg) {
+         *     final BoundMethodHandle cloneExtendI(MethodType mt, LambdaForm lf, int narg) {
          *         return SPECIES_DATA.extendWithIndex(INDEX_I).constructor[0].invokeBasic(mt, lf, argL0, argL1, argI2, narg);
          *     }
-         *     public final BoundMethodHandle cloneExtendJ(MethodType mt, LambdaForm lf, long narg) {
+         *     final BoundMethodHandle cloneExtendJ(MethodType mt, LambdaForm lf, long narg) {
          *         return SPECIES_DATA.extendWithIndex(INDEX_J).constructor[0].invokeBasic(mt, lf, argL0, argL1, argI2, narg);
          *     }
-         *     public final BoundMethodHandle cloneExtendF(MethodType mt, LambdaForm lf, float narg) {
+         *     final BoundMethodHandle cloneExtendF(MethodType mt, LambdaForm lf, float narg) {
          *         return SPECIES_DATA.extendWithIndex(INDEX_F).constructor[0].invokeBasic(mt, lf, argL0, argL1, argI2, narg);
          *     }
-         *     public final BoundMethodHandle cloneExtendD(MethodType mt, LambdaForm lf, double narg) {
+         *     final BoundMethodHandle cloneExtendD(MethodType mt, LambdaForm lf, double narg) {
          *         return SPECIES_DATA.extendWithIndex(INDEX_D).constructor[0].invokeBasic(mt, lf, argL0, argL1, argI2, narg);
          *     }
          * }
@@ -588,11 +588,12 @@
 
             final String className  = SPECIES_PREFIX_PATH + types;
             final String sourceFile = SPECIES_PREFIX_NAME + types;
-            cw.visit(V1_6, ACC_PUBLIC + ACC_FINAL + ACC_SUPER, className, null, BMH, null);
+            final int NOT_ACC_PUBLIC = 0;  // not ACC_PUBLIC
+            cw.visit(V1_6, NOT_ACC_PUBLIC + ACC_FINAL + ACC_SUPER, className, null, BMH, null);
             cw.visitSource(sourceFile, null);
 
             // emit static types and SPECIES_DATA fields
-            cw.visitField(ACC_PUBLIC + ACC_STATIC, "SPECIES_DATA", SPECIES_DATA_SIG, null, null).visitEnd();
+            cw.visitField(NOT_ACC_PUBLIC + ACC_STATIC, "SPECIES_DATA", SPECIES_DATA_SIG, null, null).visitEnd();
 
             // emit bound argument fields
             for (int i = 0; i < types.length(); ++i) {
@@ -605,7 +606,7 @@
             MethodVisitor mv;
 
             // emit constructor
-            mv = cw.visitMethod(ACC_PUBLIC, "<init>", makeSignature(types, true), null, null);
+            mv = cw.visitMethod(NOT_ACC_PUBLIC, "<init>", makeSignature(types, true), null, null);
             mv.visitCode();
             mv.visitVarInsn(ALOAD, 0);
             mv.visitVarInsn(ALOAD, 1);
@@ -629,7 +630,7 @@
             mv.visitEnd();
 
             // emit implementation of reinvokerTarget()
-            mv = cw.visitMethod(ACC_PUBLIC + ACC_FINAL, "reinvokerTarget", "()" + MH_SIG, null, null);
+            mv = cw.visitMethod(NOT_ACC_PUBLIC + ACC_FINAL, "reinvokerTarget", "()" + MH_SIG, null, null);
             mv.visitCode();
             mv.visitVarInsn(ALOAD, 0);
             mv.visitFieldInsn(GETFIELD, className, "argL0", JLO_SIG);
@@ -639,7 +640,7 @@
             mv.visitEnd();
 
             // emit implementation of speciesData()
-            mv = cw.visitMethod(ACC_PUBLIC + ACC_FINAL, "speciesData", MYSPECIES_DATA_SIG, null, null);
+            mv = cw.visitMethod(NOT_ACC_PUBLIC + ACC_FINAL, "speciesData", MYSPECIES_DATA_SIG, null, null);
             mv.visitCode();
             mv.visitFieldInsn(GETSTATIC, className, "SPECIES_DATA", SPECIES_DATA_SIG);
             mv.visitInsn(ARETURN);
@@ -647,7 +648,7 @@
             mv.visitEnd();
 
             // emit clone()
-            mv = cw.visitMethod(ACC_PUBLIC + ACC_FINAL, "clone", makeSignature("", false), null, E_THROWABLE);
+            mv = cw.visitMethod(NOT_ACC_PUBLIC + ACC_FINAL, "clone", makeSignature("", false), null, E_THROWABLE);
             mv.visitCode();
             // return speciesData().constructor[0].invokeBasic(mt, lf, argL0, ...)
             // obtain constructor
@@ -670,7 +671,7 @@
             // for each type, emit cloneExtendT()
             for (Class<?> c : TYPES) {
                 char t = Wrapper.basicTypeChar(c);
-                mv = cw.visitMethod(ACC_PUBLIC + ACC_FINAL, "cloneExtend" + t, makeSignature(String.valueOf(t), false), null, E_THROWABLE);
+                mv = cw.visitMethod(NOT_ACC_PUBLIC + ACC_FINAL, "cloneExtend" + t, makeSignature(String.valueOf(t), false), null, E_THROWABLE);
                 mv.visitCode();
                 // return SPECIES_DATA.extendWithIndex(extensionIndex(t)).constructor[0].invokeBasic(mt, lf, argL0, ..., narg)
                 // obtain constructor
@@ -697,7 +698,7 @@
             }
 
             // emit class initializer
-            mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, "<clinit>", VOID_SIG, null, null);
+            mv = cw.visitMethod(NOT_ACC_PUBLIC | ACC_STATIC, "<clinit>", VOID_SIG, null, null);
             mv.visitCode();
             mv.visitLdcInsn(types);
             mv.visitLdcInsn(Type.getObjectType(className));
--- jdk/src/share/classes/java/lang/invoke/InvokerBytecodeGenerator.java
+++ jdk/src/share/classes/java/lang/invoke/InvokerBytecodeGenerator.java
@@ -274,8 +274,9 @@
      * Set up class file generation.
      */
     private void classFilePrologue() {
+        final int NOT_ACC_PUBLIC = 0;  // not ACC_PUBLIC
         cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);
-        cw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC + Opcodes.ACC_FINAL + Opcodes.ACC_SUPER, className, null, superName, null);
+        cw.visit(Opcodes.V1_8, NOT_ACC_PUBLIC + Opcodes.ACC_FINAL + Opcodes.ACC_SUPER, className, null, superName, null);
         cw.visitSource(sourceFile, null);
 
         String invokerDesc = invokerType.toMethodDescriptorString();
--- jdk/src/share/classes/java/lang/invoke/MethodHandles.java
+++ jdk/src/share/classes/java/lang/invoke/MethodHandles.java
@@ -2070,6 +2070,7 @@
      */
     public static
     MethodHandle permuteArguments(MethodHandle target, MethodType newType, int... reorder) {
+        reorder = reorder.clone();
         checkReorder(reorder, newType, target.type());
         return target.permuteArguments(newType, reorder);
     }
@@ -2264,6 +2265,7 @@
             throw newIllegalArgumentException("no argument type to remove");
         ArrayList<Class<?>> ptypes = new ArrayList<>(oldType.parameterList());
         ptypes.addAll(pos, valueTypes);
+        if (ptypes.size() != inargs)  throw newIllegalArgumentException("valueTypes");
         MethodType newType = MethodType.methodType(oldType.returnType(), ptypes);
         return target.dropArguments(newType, pos, dropped);
     }
--- jdk/src/share/classes/java/net/SocketPermission.java
+++ jdk/src/share/classes/java/net/SocketPermission.java
@@ -235,13 +235,11 @@
     private static Debug debug = null;
     private static boolean debugInit = false;
 
-    // ephemeral port range for this system
-    private static final int ephemeralLow = initEphemeralPorts(
-        "low", DEF_EPH_LOW
-    );
-    private static final int ephemeralHigh = initEphemeralPorts(
-        "high", PORT_MAX
-    );
+    // lazy initializer
+    private static class EphemeralRange {
+        static final int low = initEphemeralPorts("low", DEF_EPH_LOW);
+        static final int high = initEphemeralPorts("high", PORT_MAX);
+    };
 
     static {
         Boolean tmp = java.security.AccessController.doPrivileged(
@@ -1235,6 +1233,9 @@
         int policyLow, int policyHigh, int targetLow, int targetHigh
     )
     {
+        final int ephemeralLow = EphemeralRange.low;
+        final int ephemeralHigh = EphemeralRange.high;
+
         if (targetLow == 0) {
             // check policy includes ephemeral range
             if (!inRange(policyLow, policyHigh, ephemeralLow, ephemeralHigh)) {
--- jdk/src/share/classes/java/util/ServiceLoader.java
+++ jdk/src/share/classes/java/util/ServiceLoader.java
@@ -382,7 +382,7 @@
                 return p;
             } catch (Throwable x) {
                 fail(service,
-                     "Provider " + cn + " could not be instantiated: " + x,
+                     "Provider " + cn + " could not be instantiated",
                      x);
             }
             throw new Error();          // This cannot happen
--- jdk/src/share/classes/java/util/TreeMap.java
+++ jdk/src/share/classes/java/util/TreeMap.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -1338,6 +1338,7 @@
      */
     abstract static class NavigableSubMap<K,V> extends AbstractMap<K,V>
         implements NavigableMap<K,V>, java.io.Serializable {
+        private static final long serialVersionUID = -2102997345730753016L;
         /**
          * The backing map.
          */
--- jdk/src/share/classes/java/util/jar/JarVerifier.java
+++ jdk/src/share/classes/java/util/jar/JarVerifier.java
@@ -687,6 +687,8 @@
                 } else {
                     matchUnsigned = true;
                 }
+            } else {
+                matchUnsigned = true;
             }
         }
 
@@ -789,23 +791,7 @@
 
     // true if file is part of the signature mechanism itself
     static boolean isSigningRelated(String name) {
-        name = name.toUpperCase(Locale.ENGLISH);
-        if (!name.startsWith("META-INF/")) {
-            return false;
-        }
-        name = name.substring(9);
-        if (name.indexOf('/') != -1) {
-            return false;
-        }
-        if (name.endsWith(".DSA")
-                || name.endsWith(".RSA")
-                || name.endsWith(".SF")
-                || name.endsWith(".EC")
-                || name.startsWith("SIG-")
-                || name.equals("MANIFEST.MF")) {
-            return true;
-        }
-        return false;
+        return SignatureFileVerifier.isSigningRelated(name);
     }
 
     private Enumeration<String> unsignedEntryNames(JarFile jar) {
--- jdk/src/share/classes/java/util/logging/LogManager.java
+++ jdk/src/share/classes/java/util/logging/LogManager.java
@@ -551,7 +551,7 @@
         Logger result = getLogger(name);
         if (result == null) {
             // only allocate the new logger once
-            Logger newLogger = new Logger(name, resourceBundleName, caller, this);
+            Logger newLogger = new Logger(name, resourceBundleName, caller, this, false);
             do {
                 if (addLogger(newLogger)) {
                     // We successfully added the new Logger that we
@@ -598,13 +598,13 @@
         } while (logger == null);
 
         // LogManager will set the sysLogger's handlers via LogManager.addLogger method.
-        if (logger != sysLogger && sysLogger.getHandlers().length == 0) {
+        if (logger != sysLogger && sysLogger.accessCheckedHandlers().length == 0) {
             // if logger already exists but handlers not set
             final Logger l = logger;
             AccessController.doPrivileged(new PrivilegedAction<Void>() {
                 @Override
                 public Void run() {
-                    for (Handler hdl : l.getHandlers()) {
+                    for (Handler hdl : l.accessCheckedHandlers()) {
                         sysLogger.addHandler(hdl);
                     }
                     return null;
@@ -922,7 +922,7 @@
             Logger result = findLogger(name);
             if (result == null) {
                 // only allocate the new system logger once
-                Logger newLogger = new Logger(name, resourceBundleName, null, getOwner());
+                Logger newLogger = new Logger(name, resourceBundleName, null, getOwner(), true);
                 do {
                     if (addLocalLogger(newLogger)) {
                         // We successfully added the new Logger that we
@@ -1640,7 +1640,7 @@
             // We do not call the protected Logger two args constructor here,
             // to avoid calling LogManager.getLogManager() from within the
             // RootLogger constructor.
-            super("", null, null, LogManager.this);
+            super("", null, null, LogManager.this, true);
         }
 
         @Override
@@ -1663,9 +1663,9 @@
         }
 
         @Override
-        public Handler[] getHandlers() {
+        Handler[] accessCheckedHandlers() {
             initializeGlobalHandlers();
-            return super.getHandlers();
+            return super.accessCheckedHandlers();
         }
     }
 
--- jdk/src/share/classes/java/util/logging/Logger.java
+++ jdk/src/share/classes/java/util/logging/Logger.java
@@ -277,6 +277,7 @@
     private volatile Level levelObject;
     private volatile int levelValue;  // current effective level value
     private WeakReference<ClassLoader> callersClassLoaderRef;
+    private final boolean isSystemLogger;
 
     /**
      * GLOBAL_LOGGER_NAME is a name for the global logger.
@@ -370,11 +371,12 @@
      *             no corresponding resource can be found.
      */
     protected Logger(String name, String resourceBundleName) {
-        this(name, resourceBundleName, null, LogManager.getLogManager());
+        this(name, resourceBundleName, null, LogManager.getLogManager(), false);
     }
 
-    Logger(String name, String resourceBundleName, Class<?> caller, LogManager manager) {
+    Logger(String name, String resourceBundleName, Class<?> caller, LogManager manager, boolean isSystemLogger) {
         this.manager = manager;
+        this.isSystemLogger = isSystemLogger;
         setupResourceInfo(resourceBundleName, caller);
         this.name = name;
         levelValue = Level.INFO.intValue();
@@ -401,6 +403,7 @@
     private Logger(String name) {
         // The manager field is not initialized here.
         this.name = name;
+        this.isSystemLogger = true;
         levelValue = Level.INFO.intValue();
     }
 
@@ -635,7 +638,7 @@
         // cleanup some Loggers that have been GC'ed
         manager.drainLoggerRefQueueBounded();
         Logger result = new Logger(null, resourceBundleName,
-                                   Reflection.getCallerClass(), manager);
+                                   Reflection.getCallerClass(), manager, false);
         result.anonymous = true;
         Logger root = manager.getLogger("");
         result.doSetParent(root);
@@ -727,15 +730,23 @@
 
         Logger logger = this;
         while (logger != null) {
-            for (Handler handler : logger.getHandlers()) {
+            final Handler[] loggerHandlers = isSystemLogger
+                ? logger.accessCheckedHandlers()
+                : logger.getHandlers();
+
+            for (Handler handler : loggerHandlers) {
                 handler.publish(record);
             }
 
-            if (!logger.getUseParentHandlers()) {
+            final boolean useParentHdls = isSystemLogger
+                ? logger.useParentHandlers
+                : logger.getUseParentHandlers();
+
+            if (!useParentHdls) {
                 break;
             }
 
-            logger = logger.getParent();
+            logger = isSystemLogger ? logger.parent : logger.getParent();
         }
     }
 
@@ -1762,6 +1773,12 @@
      * @return  an array of all registered Handlers
      */
     public Handler[] getHandlers() {
+        return accessCheckedHandlers();
+    }
+
+    // This method should ideally be marked final - but unfortunately
+    // it needs to be overridden by LogManager.RootLogger
+    Handler[] accessCheckedHandlers() {
         return handlers.toArray(emptyHandlers);
     }
 
@@ -2150,12 +2167,14 @@
             if (trb.userBundle != null) {
                 return trb;
             }
-            final String rbName = target.getResourceBundleName();
+            final String rbName = isSystemLogger
+                ? trb.resourceBundleName
+                : target.getResourceBundleName();
             if (rbName != null) {
                 return LoggerBundle.get(rbName,
                             findResourceBundle(rbName, true));
             }
-            target = target.getParent();
+            target = isSystemLogger ? target.parent : target.getParent();
         }
         return NO_RESOURCE_BUNDLE;
     }
--- jdk/src/share/classes/javax/script/ScriptEngineManager.java
+++ jdk/src/share/classes/javax/script/ScriptEngineManager.java
@@ -81,23 +81,28 @@
         nameAssociations = new HashMap<String, ScriptEngineFactory>();
         extensionAssociations = new HashMap<String, ScriptEngineFactory>();
         mimeTypeAssociations = new HashMap<String, ScriptEngineFactory>();
-        AccessController.doPrivileged(new PrivilegedAction<Object>() {
-            public Object run() {
-                initEngines(loader);
-                return null;
-            }
-        });
+        initEngines(loader);
+    }
+
+    private ServiceLoader<ScriptEngineFactory> getServiceLoader(final ClassLoader loader) {
+        if (loader != null) {
+            return ServiceLoader.load(ScriptEngineFactory.class, loader);
+        } else {
+            return ServiceLoader.loadInstalled(ScriptEngineFactory.class);
+        }
     }
 
     private void initEngines(final ClassLoader loader) {
         Iterator<ScriptEngineFactory> itr = null;
         try {
-            ServiceLoader<ScriptEngineFactory> sl;
-            if (loader != null) {
-                sl = ServiceLoader.load(ScriptEngineFactory.class, loader);
-            } else {
-                sl = ServiceLoader.loadInstalled(ScriptEngineFactory.class);
-            }
+            ServiceLoader<ScriptEngineFactory> sl = AccessController.doPrivileged(
+                new PrivilegedAction<ServiceLoader<ScriptEngineFactory>>() {
+                    @Override
+                    public ServiceLoader<ScriptEngineFactory> run() {
+                        return getServiceLoader(loader);
+                    }
+                });
+
             itr = sl.iterator();
         } catch (ServiceConfigurationError err) {
             System.err.println("Can't find ScriptEngineFactory providers: " +
--- jdk/src/share/classes/javax/security/auth/Subject.java
+++ jdk/src/share/classes/javax/security/auth/Subject.java
@@ -959,14 +959,30 @@
     /**
      * Reads this object from a stream (i.e., deserializes it)
      */
+    @SuppressWarnings("unchecked")
     private void readObject(java.io.ObjectInputStream s)
                 throws java.io.IOException, ClassNotFoundException {
 
-        s.defaultReadObject();
+        ObjectInputStream.GetField gf = s.readFields();
+
+        readOnly = gf.get("readOnly", false);
+
+        Set<Principal> inputPrincs = (Set<Principal>)gf.get("principals", null);
 
         // Rewrap the principals into a SecureSet
-        principals = Collections.synchronizedSet(new SecureSet<Principal>
-                                (this, PRINCIPAL_SET, principals));
+        if (inputPrincs == null) {
+            throw new NullPointerException
+                (ResourcesMgr.getString("invalid.null.input.s."));
+        }
+        try {
+            principals = Collections.synchronizedSet(new SecureSet<Principal>
+                                (this, PRINCIPAL_SET, inputPrincs));
+        } catch (NullPointerException npe) {
+            // Sometimes people deserialize the principals set only.
+            // Subject is not accessible, so just don't fail.
+            principals = Collections.synchronizedSet
+                        (new SecureSet<Principal>(this, PRINCIPAL_SET));
+        }
 
         // The Credential {@code Set} is not serialized, but we do not
         // want the default deserialization routine to set it to null.
--- jdk/src/share/classes/javax/sql/rowset/RowSetProvider.java
+++ jdk/src/share/classes/javax/sql/rowset/RowSetProvider.java
@@ -28,8 +28,11 @@
 import java.security.AccessController;
 import java.security.PrivilegedAction;
 import java.sql.SQLException;
+import java.util.PropertyPermission;
 import java.util.ServiceConfigurationError;
 import java.util.ServiceLoader;
+import javax.sql.rowset.spi.SyncFactoryException;
+import sun.reflect.misc.ReflectUtil;
 
 /**
  * A factory API that enables applications to obtain a
@@ -129,15 +132,11 @@
             factoryClassName = getSystemProperty(ROWSET_FACTORY_NAME);
             if (factoryClassName != null) {
                 trace("Found system property, value=" + factoryClassName);
-                factory = (RowSetFactory) getFactoryClass(factoryClassName, null, true).newInstance();
+                factory = (RowSetFactory) ReflectUtil.newInstance(getFactoryClass(factoryClassName, null, true));
             }
-        } catch (ClassNotFoundException e) {
-            throw new SQLException(
-                    "RowSetFactory: " + factoryClassName + " not found", e);
-        } catch (Exception e) {
-            throw new SQLException(
-                    "RowSetFactory: " + factoryClassName + " could not be instantiated: " + e,
-                    e);
+        }  catch (Exception e) {
+            throw new SQLException( "RowSetFactory: " + factoryClassName +
+                    " could not be instantiated: ", e);
         }
 
         // Check to see if we found the RowSetFactory via a System property
@@ -182,6 +181,16 @@
             throws SQLException {
 
         trace("***In newInstance()");
+
+        if(factoryClassName == null) {
+            throw new SQLException("Error: factoryClassName cannot be null");
+        }
+        try {
+            ReflectUtil.checkPackageAccess(factoryClassName);
+        } catch (java.security.AccessControlException e) {
+            throw new SQLException("Access Exception",e);
+        }
+
         try {
             Class<?> providerClass = getFactoryClass(factoryClassName, cl, false);
             RowSetFactory instance = (RowSetFactory) providerClass.newInstance();
@@ -291,8 +300,9 @@
                 public String run() {
                     return System.getProperty(propName);
                 }
-            });
+            }, null, new PropertyPermission(propName, "read"));
         } catch (SecurityException se) {
+            trace("error getting " + propName + ":  "+ se);
             if (debug) {
                 se.printStackTrace();
             }
--- jdk/src/share/classes/javax/sql/rowset/serial/SQLInputImpl.java
+++ jdk/src/share/classes/javax/sql/rowset/serial/SQLInputImpl.java
@@ -27,6 +27,7 @@
 import java.sql.*;
 import java.util.Arrays;
 import java.util.Map;
+import sun.reflect.misc.ReflectUtil;
 
 /**
  * An input stream used for custom mapping user-defined types (UDTs).
@@ -476,13 +477,9 @@
                 // create new instance of the class
                 SQLData obj = null;
                 try {
-                    obj = (SQLData)c.newInstance();
-                } catch (java.lang.InstantiationException ex) {
-                    throw new SQLException("Unable to instantiate: " +
-                            ex.getMessage());
-                } catch (java.lang.IllegalAccessException ex) {
-                    throw new SQLException("Unable to instantiate: " +
-                            ex.getMessage());
+                    obj = (SQLData)ReflectUtil.newInstance(c);
+                } catch (Exception ex) {
+                    throw new SQLException("Unable to Instantiate: ", ex);
                 }
                 // get the attributes from the struct
                 Object attribs[] = s.getAttributes(map);
--- jdk/src/share/classes/javax/sql/rowset/spi/SyncFactory.java
+++ jdk/src/share/classes/javax/sql/rowset/spi/SyncFactory.java
@@ -37,8 +37,11 @@
 import java.io.FileNotFoundException;
 import java.security.AccessController;
 import java.security.PrivilegedAction;
+import java.security.PrivilegedActionException;
+import java.security.PrivilegedExceptionAction;
 
 import javax.naming.*;
+import sun.reflect.misc.ReflectUtil;
 
 /**
  * The Service Provider Interface (SPI) mechanism that generates <code>SyncProvider</code>
@@ -329,7 +332,7 @@
         // Local implementation class names and keys from Properties
         // file, translate names into Class objects using Class.forName
         // and store mappings
-        Properties properties = new Properties();
+        final Properties properties = new Properties();
 
         if (implementations == null) {
             implementations = new Hashtable<>();
@@ -356,10 +359,11 @@
                         public String run() {
                             return System.getProperty("rowset.properties");
                         }
-                    }, null, new PropertyPermission("rowset.properties","read"));
+                    }, null, new PropertyPermission("rowset.properties", "read"));
                 } catch (Exception ex) {
+                    System.out.println("errorget rowset.properties: " + ex);
                     strRowsetProperties = null;
-                }
+                };
 
                 if (strRowsetProperties != null) {
                     // Load user's implementation of SyncProvider
@@ -380,14 +384,27 @@
 
                 ClassLoader cl = Thread.currentThread().getContextClassLoader();
 
-                try (InputStream stream =
-                         (cl == null) ? ClassLoader.getSystemResourceAsStream(ROWSET_PROPERTIES)
-                                      : cl.getResourceAsStream(ROWSET_PROPERTIES)) {
-                    if (stream == null) {
-                        throw new SyncFactoryException(
-                            "Resource " + ROWSET_PROPERTIES + " not found");
+                try {
+                    AccessController.doPrivileged((PrivilegedExceptionAction<Void>) () -> {
+                        try (InputStream stream = (cl == null) ?
+                                ClassLoader.getSystemResourceAsStream(ROWSET_PROPERTIES)
+                                : cl.getResourceAsStream(ROWSET_PROPERTIES)) {
+                            if (stream == null) {
+                                throw new SyncFactoryException("Resource " + ROWSET_PROPERTIES + " not found");
+                            }
+                            properties.load(stream);
+                        }
+                        return null;
+                    });
+                } catch (PrivilegedActionException ex) {
+                    Throwable e = ex.getException();
+                    if (e instanceof SyncFactoryException) {
+                      throw (SyncFactoryException) e;
+                    } else {
+                        SyncFactoryException sfe = new SyncFactoryException();
+                        sfe.initCause(ex.getException());
+                        throw sfe;
                     }
-                    properties.load(stream);
                 }
 
                 parseProperties(properties);
@@ -411,7 +428,7 @@
                     public String run() {
                         return System.getProperty(ROWSET_SYNC_PROVIDER);
                     }
-                }, null, new PropertyPermission(ROWSET_SYNC_PROVIDER,"read"));
+                }, null, new PropertyPermission(ROWSET_SYNC_PROVIDER, "read"));
             } catch (Exception ex) {
                 providerImpls = null;
             }
@@ -547,6 +564,14 @@
             return new com.sun.rowset.providers.RIOptimisticProvider();
         }
 
+        try {
+            ReflectUtil.checkPackageAccess(providerID);
+        } catch (java.security.AccessControlException e) {
+            SyncFactoryException sfe = new SyncFactoryException();
+            sfe.initCause(e);
+            throw sfe;
+        }
+
         // Attempt to invoke classname from registered SyncProvider list
         Class<?> c = null;
         try {
@@ -555,7 +580,7 @@
             /**
              * The SyncProvider implementation of the user will be in
              * the classpath. We need to find the ClassLoader which loads
-             * this SyncFactory and try to laod the SyncProvider class from
+             * this SyncFactory and try to load the SyncProvider class from
              * there.
              **/
             c = Class.forName(providerID, true, cl);
--- jdk/src/share/classes/sun/awt/AWTAutoShutdown.java
+++ jdk/src/share/classes/sun/awt/AWTAutoShutdown.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,13 +27,15 @@
 
 import java.awt.AWTEvent;
 
-import java.util.Collections;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 import java.util.HashSet;
 import java.util.IdentityHashMap;
 import java.util.Map;
 import java.util.Set;
 
 import sun.util.logging.PlatformLogger;
+import sun.misc.ThreadGroupUtils;
 
 /**
  * This class is to let AWT shutdown automatically when a user is done
@@ -215,7 +217,10 @@
         synchronized (activationLock) {
             synchronized (mainLock) {
                 if (!isReadyToShutdown() && blockerThread == null) {
-                    activateBlockerThread();
+                    AccessController.doPrivileged((PrivilegedAction<Void>) () -> {
+                        activateBlockerThread();
+                        return null;
+                    });
                 } else {
                     mainLock.notifyAll();
                     timeoutPassed = false;
@@ -331,9 +336,12 @@
     /**
      * Creates and starts a new blocker thread. Doesn't return until
      * the new blocker thread starts.
+     *
+     * Must be called with {@link sun.security.util.SecurityConstants#MODIFY_THREADGROUP_PERMISSION}
      */
     private void activateBlockerThread() {
-        Thread thread = new Thread(this, "AWT-Shutdown");
+        Thread thread = new Thread(ThreadGroupUtils.getRootThreadGroup(), this, "AWT-Shutdown");
+        thread.setContextClassLoader(null);
         thread.setDaemon(false);
         blockerThread = thread;
         thread.start();
--- jdk/src/share/classes/sun/awt/SunToolkit.java
+++ jdk/src/share/classes/sun/awt/SunToolkit.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -37,6 +37,7 @@
 import java.awt.SystemTray;
 import java.awt.event.InputEvent;
 import java.net.URL;
+import java.security.PrivilegedAction;
 import java.util.*;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.locks.Condition;
@@ -49,6 +50,7 @@
 import sun.font.FontDesignMetrics;
 import sun.awt.im.InputContext;
 import sun.awt.image.*;
+import sun.net.util.URLUtil;
 import sun.security.action.GetPropertyAction;
 import sun.security.action.GetBooleanAction;
 import java.lang.reflect.InvocationTargetException;
@@ -719,7 +721,7 @@
         if (sm != null) {
             try {
                 java.security.Permission perm =
-                    url.openConnection().getPermission();
+                    URLUtil.getConnectPermission(url);
                 if (perm != null) {
                     try {
                         sm.checkPermission(perm);
@@ -795,7 +797,7 @@
         if (sm != null) {
             try {
                 java.security.Permission perm =
-                    url.openConnection().getPermission();
+                        URLUtil.getConnectPermission(url);
                 if (perm != null) {
                     try {
                         sm.checkPermission(perm);
--- jdk/src/share/classes/sun/awt/datatransfer/ClipboardTransferable.java
+++ jdk/src/share/classes/sun/awt/datatransfer/ClipboardTransferable.java
@@ -87,7 +87,7 @@
                 HashMap cached_data = new HashMap(formats.length, 1.0f);
 
                 Map flavorsForFormats = DataTransferer.getInstance().
-                    getFlavorsForFormats(formats, SunClipboard.flavorMap);
+                    getFlavorsForFormats(formats, SunClipboard.getDefaultFlavorTable());
                 for (Iterator iter = flavorsForFormats.keySet().iterator();
                      iter.hasNext(); )
                 {
--- jdk/src/share/classes/sun/awt/datatransfer/SunClipboard.java
+++ jdk/src/share/classes/sun/awt/datatransfer/SunClipboard.java
@@ -64,9 +64,6 @@
 public abstract class SunClipboard extends Clipboard
     implements PropertyChangeListener {
 
-    public static final FlavorTable flavorMap =
-        (FlavorTable)SystemFlavorMap.getDefaultFlavorMap();
-
     private AppContext contentsContext = null;
 
     private final Object CLIPBOARD_FLAVOR_LISTENER_KEY;
@@ -172,7 +169,7 @@
         long[] formats = getClipboardFormatsOpenClose();
 
         return DataTransferer.getInstance().
-            getFlavorsForFormatsAsArray(formats, flavorMap);
+            getFlavorsForFormatsAsArray(formats, getDefaultFlavorTable());
     }
 
     /**
@@ -218,7 +215,7 @@
 
             long[] formats = getClipboardFormats();
             Long lFormat = (Long)DataTransferer.getInstance().
-                    getFlavorsForFormats(formats, flavorMap).get(flavor);
+                    getFlavorsForFormats(formats, getDefaultFlavorTable()).get(flavor);
 
             if (lFormat == null) {
                 throw new UnsupportedFlavorException(flavor);
@@ -349,7 +346,7 @@
     private static Set formatArrayAsDataFlavorSet(long[] formats) {
         return (formats == null) ? null :
                 DataTransferer.getInstance().
-                getFlavorsForFormatsAsSet(formats, flavorMap);
+                getFlavorsForFormatsAsSet(formats, getDefaultFlavorTable());
     }
 
 
@@ -469,4 +466,7 @@
         }
     }
 
+    public static FlavorTable getDefaultFlavorTable() {
+        return (FlavorTable) SystemFlavorMap.getDefaultFlavorMap();
+    }
 }
--- jdk/src/share/classes/sun/awt/image/URLImageSource.java
+++ jdk/src/share/classes/sun/awt/image/URLImageSource.java
@@ -31,6 +31,7 @@
 import java.net.URL;
 import java.net.URLConnection;
 import java.net.MalformedURLException;
+import sun.net.util.URLUtil;
 
 public class URLImageSource extends InputStreamImageSource {
     URL url;
@@ -43,7 +44,7 @@
         if (sm != null) {
             try {
                 java.security.Permission perm =
-                    u.openConnection().getPermission();
+                      URLUtil.getConnectPermission(u);
                 if (perm != null) {
                     try {
                         sm.checkPermission(perm);
--- jdk/src/share/classes/sun/font/CreatedFontTracker.java
+++ jdk/src/share/classes/sun/font/CreatedFontTracker.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,12 +27,15 @@
 
 import java.io.File;
 import java.io.OutputStream;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.concurrent.Semaphore;
 import java.util.concurrent.TimeUnit;
 
 import sun.awt.AppContext;
+import sun.misc.ThreadGroupUtils;
 
 public class CreatedFontTracker {
 
@@ -112,28 +115,18 @@
         static void init() {
             if (t == null) {
                 // Add a shutdown hook to remove the temp file.
-                java.security.AccessController.doPrivileged(
-                   new java.security.PrivilegedAction() {
-                      public Object run() {
-                          /* The thread must be a member of a thread group
-                           * which will not get GCed before VM exit.
-                           * Make its parent the top-level thread group.
-                           */
-                          ThreadGroup tg =
-                              Thread.currentThread().getThreadGroup();
-                          for (ThreadGroup tgn = tg;
-                               tgn != null;
-                               tg = tgn, tgn = tg.getParent());
-                          t = new Thread(tg, new Runnable() {
-                              public void run() {
-                                  runHooks();
-                              }
-                          });
-                          t.setContextClassLoader(null);
-                          Runtime.getRuntime().addShutdownHook(t);
-                          return null;
-                      }
-                   });
+                AccessController.doPrivileged(
+                        (PrivilegedAction<Void>) () -> {
+                            /* The thread must be a member of a thread group
+                             * which will not get GCed before VM exit.
+                             * Make its parent the top-level thread group.
+                             */
+                            ThreadGroup rootTG = ThreadGroupUtils.getRootThreadGroup();
+                            t = new Thread(rootTG, TempFileDeletionHook::runHooks);
+                            t.setContextClassLoader(null);
+                            Runtime.getRuntime().addShutdownHook(t);
+                            return null;
+                        });
             }
         }
 
--- jdk/src/share/classes/sun/font/SunFontManager.java
+++ jdk/src/share/classes/sun/font/SunFontManager.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -52,6 +52,7 @@
 import sun.awt.AppContext;
 import sun.awt.FontConfiguration;
 import sun.awt.SunToolkit;
+import sun.misc.ThreadGroupUtils;
 import sun.java2d.FontSupport;
 import sun.util.logging.PlatformLogger;
 
@@ -2521,24 +2522,18 @@
                           });
                       }
                     };
-                    java.security.AccessController.doPrivileged(
-                       new java.security.PrivilegedAction() {
-                          public Object run() {
-                              /* The thread must be a member of a thread group
-                               * which will not get GCed before VM exit.
-                               * Make its parent the top-level thread group.
-                               */
-                              ThreadGroup tg =
-                                  Thread.currentThread().getThreadGroup();
-                              for (ThreadGroup tgn = tg;
-                                   tgn != null;
-                                   tg = tgn, tgn = tg.getParent());
-                              fileCloser = new Thread(tg, fileCloserRunnable);
-                              fileCloser.setContextClassLoader(null);
-                              Runtime.getRuntime().addShutdownHook(fileCloser);
-                              return null;
-                          }
-                    });
+                    AccessController.doPrivileged(
+                            (PrivilegedAction<Void>) () -> {
+                                /* The thread must be a member of a thread group
+                                 * which will not get GCed before VM exit.
+                                 * Make its parent the top-level thread group.
+                                 */
+                                ThreadGroup rootTG = ThreadGroupUtils.getRootThreadGroup();
+                                fileCloser = new Thread(rootTG, fileCloserRunnable);
+                                fileCloser.setContextClassLoader(null);
+                                Runtime.getRuntime().addShutdownHook(fileCloser);
+                                return null;
+                            });
                 }
             }
         }
--- jdk/src/share/classes/sun/java2d/Disposer.java
+++ jdk/src/share/classes/sun/java2d/Disposer.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2002, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2002, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,10 +25,14 @@
 
 package sun.java2d;
 
+import sun.misc.ThreadGroupUtils;
+
 import java.lang.ref.Reference;
 import java.lang.ref.ReferenceQueue;
 import java.lang.ref.PhantomReference;
 import java.lang.ref.WeakReference;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 import java.util.ArrayList;
 import java.util.Hashtable;
 
@@ -76,26 +80,20 @@
             }
         }
         disposerInstance = new Disposer();
-        java.security.AccessController.doPrivileged(
-            new java.security.PrivilegedAction() {
-                public Object run() {
+        AccessController.doPrivileged(
+                (PrivilegedAction<Void>) () -> {
                     /* The thread must be a member of a thread group
                      * which will not get GCed before VM exit.
                      * Make its parent the top-level thread group.
                      */
-                    ThreadGroup tg = Thread.currentThread().getThreadGroup();
-                    for (ThreadGroup tgn = tg;
-                         tgn != null;
-                         tg = tgn, tgn = tg.getParent());
-                    Thread t =
-                        new Thread(tg, disposerInstance, "Java2D Disposer");
+                    ThreadGroup rootTG = ThreadGroupUtils.getRootThreadGroup();
+                    Thread t = new Thread(rootTG, disposerInstance, "Java2D Disposer");
                     t.setContextClassLoader(null);
                     t.setDaemon(true);
                     t.setPriority(Thread.MAX_PRIORITY);
                     t.start();
                     return null;
                 }
-            }
         );
     }
 
--- jdk/src/share/classes/sun/java2d/opengl/OGLRenderQueue.java
+++ jdk/src/share/classes/sun/java2d/opengl/OGLRenderQueue.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,6 +25,7 @@
 
 package sun.java2d.opengl;
 
+import sun.misc.ThreadGroupUtils;
 import sun.java2d.pipe.RenderBuffer;
 import sun.java2d.pipe.RenderQueue;
 import static sun.java2d.pipe.BufferedOpCodes.*;
@@ -47,14 +48,8 @@
          * The thread must be a member of a thread group
          * which will not get GCed before VM exit.
          */
-        flusher = AccessController.doPrivileged(new PrivilegedAction<QueueFlusher>() {
-            public QueueFlusher run() {
-                ThreadGroup rootThreadGroup = Thread.currentThread().getThreadGroup();
-                while (rootThreadGroup.getParent() != null) {
-                    rootThreadGroup = rootThreadGroup.getParent();
-                }
-                return new QueueFlusher(rootThreadGroup);
-            }
+        flusher = AccessController.doPrivileged((PrivilegedAction<QueueFlusher>) () -> {
+            return new QueueFlusher(ThreadGroupUtils.getRootThreadGroup());
         });
     }
 
--- jdk/src/share/classes/sun/misc/InnocuousThread.java	1969-12-31 19:00:00.000000000 -0500
+++ jdk/src/share/classes/sun/misc/InnocuousThread.java
@@ -0,0 +1,121 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNUNSAFE General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUNSAFET
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICUNSAFELAR PUNSAFERPOSE.  See the GNUNSAFE General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNUNSAFE General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 UNSAFESA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 UNSAFESA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package sun.misc;
+
+import java.security.AccessControlContext;
+import java.security.ProtectionDomain;
+
+/**
+ * A thread that has no permissions, is not a member of any user-defined
+ * ThreadGroup and supports the ability to erase ThreadLocals.
+ *
+ * @implNote Based on the implementation of InnocuousForkJoinWorkerThread.
+ */
+public final class InnocuousThread extends Thread {
+    private static final Unsafe UNSAFE;
+    private static final ThreadGroup THREADGROUP;
+    private static final AccessControlContext ACC;
+    private static final long THREADLOCALS;
+    private static final long INHERITABLETHREADLOCALS;
+    private static final long INHERITEDACCESSCONTROLCONTEXT;
+
+    public InnocuousThread(Runnable target) {
+        super(THREADGROUP, target, "anInnocuousThread");
+        UNSAFE.putOrderedObject(this, INHERITEDACCESSCONTROLCONTEXT, ACC);
+        eraseThreadLocals();
+    }
+
+    @Override
+    public ClassLoader getContextClassLoader() {
+        // always report system class loader
+        return ClassLoader.getSystemClassLoader();
+    }
+
+    @Override
+    public void setUncaughtExceptionHandler(UncaughtExceptionHandler x) {
+        // silently fail
+    }
+
+    @Override
+    public void setContextClassLoader(ClassLoader cl) {
+        throw new SecurityException("setContextClassLoader");
+    }
+
+    // ensure run method is run only once
+    private volatile boolean hasRun;
+
+    @Override
+    public void run() {
+        if (Thread.currentThread() == this && !hasRun) {
+            hasRun = true;
+            super.run();
+        }
+    }
+
+    /**
+     * Drops all thread locals (and inherited thread locals).
+     */
+    public void eraseThreadLocals() {
+        UNSAFE.putObject(this, THREADLOCALS, null);
+        UNSAFE.putObject(this, INHERITABLETHREADLOCALS, null);
+    }
+
+    // Use Unsafe to access Thread group and ThreadGroup parent fields
+    static {
+        try {
+            ACC = new AccessControlContext(new ProtectionDomain[] {
+                new ProtectionDomain(null, null)
+            });
+
+            // Find and use topmost ThreadGroup as parent of new group
+            UNSAFE = Unsafe.getUnsafe();
+            Class<?> tk = Thread.class;
+            Class<?> gk = ThreadGroup.class;
+
+            THREADLOCALS = UNSAFE.objectFieldOffset
+                (tk.getDeclaredField("threadLocals"));
+            INHERITABLETHREADLOCALS = UNSAFE.objectFieldOffset
+                (tk.getDeclaredField("inheritableThreadLocals"));
+            INHERITEDACCESSCONTROLCONTEXT = UNSAFE.objectFieldOffset
+                (tk.getDeclaredField("inheritedAccessControlContext"));
+
+            long tg = UNSAFE.objectFieldOffset(tk.getDeclaredField("group"));
+            long gp = UNSAFE.objectFieldOffset(gk.getDeclaredField("parent"));
+            ThreadGroup group = (ThreadGroup)
+                UNSAFE.getObject(Thread.currentThread(), tg);
+
+            while (group != null) {
+                ThreadGroup parent = (ThreadGroup)UNSAFE.getObject(group, gp);
+                if (parent == null)
+                    break;
+                group = parent;
+            }
+            THREADGROUP = new ThreadGroup(group, "InnocuousThreadGroup");
+        } catch (Exception e) {
+            throw new Error(e);
+        }
+    }
+}
--- jdk/src/share/classes/sun/misc/Service.java
+++ jdk/src/share/classes/sun/misc/Service.java
@@ -299,7 +299,7 @@
                 return service.cast(c.newInstance());
             } catch (Throwable x) {
                 fail(service,
-                     "Provider " + cn + " could not be instantiated: " + x,
+                     "Provider " + cn + " could not be instantiated",
                      x);
             }
             return null;        /* This cannot happen */
--- jdk/src/share/classes/sun/misc/ThreadGroupUtils.java	1969-12-31 19:00:00.000000000 -0500
+++ jdk/src/share/classes/sun/misc/ThreadGroupUtils.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package sun.misc;
+
+/**
+ * A utility class needed to access the root {@code ThreadGroup}
+ *
+ * The class should not depend on any others, because it' called from JNI_OnLoad of the AWT
+ * native library. Triggering class loading could could lead to a deadlock.
+ */
+public final class ThreadGroupUtils {
+
+    private ThreadGroupUtils() {
+        // Avoid instantiation
+    }
+
+    /**
+     * Returns a root thread group.
+     * Should be called with {@link sun.security.util.SecurityConstants#MODIFY_THREADGROUP_PERMISSION}
+     *
+     * @return a root {@code ThreadGroup}
+     */
+    public static ThreadGroup getRootThreadGroup() {
+        ThreadGroup currentTG = Thread.currentThread().getThreadGroup();
+        ThreadGroup parentTG = currentTG.getParent();
+        while (parentTG != null) {
+            currentTG = parentTG;
+            parentTG = currentTG.getParent();
+        }
+        return currentTG;
+    }
+}
--- jdk/src/share/classes/sun/net/util/URLUtil.java
+++ jdk/src/share/classes/sun/net/util/URLUtil.java
@@ -25,7 +25,10 @@
 
 package sun.net.util;
 
+import java.io.IOException;
 import java.net.URL;
+import java.net.URLPermission;
+import java.security.Permission;
 
 /**
  * URL Utility class.
@@ -76,5 +79,26 @@
 
         return strForm.toString();
     }
+
+    public static Permission getConnectPermission(URL url) throws IOException {
+        String urlStringLowerCase = url.toString().toLowerCase();
+        if (urlStringLowerCase.startsWith("http:") || urlStringLowerCase.startsWith("https:")) {
+            return getURLConnectPermission(url);
+        } else if (urlStringLowerCase.startsWith("jar:http:") || urlStringLowerCase.startsWith("jar:https:")) {
+            String urlString = url.toString();
+            int bangPos = urlString.indexOf("!/");
+            urlString = urlString.substring(4, bangPos > -1 ? bangPos : urlString.length());
+            URL u = new URL(urlString);
+            return getURLConnectPermission(u);
+            // If protocol is HTTP or HTTPS than use URLPermission object
+        } else {
+            return url.openConnection().getPermission();
+        }
+    }
+
+    private static Permission getURLConnectPermission(URL url) {
+        String urlString = url.getProtocol() + "://" + url.getAuthority() + url.getPath();
+        return new URLPermission(urlString);
+    }
 }
 
--- jdk/src/share/classes/sun/nio/ch/Invoker.java
+++ jdk/src/share/classes/sun/nio/ch/Invoker.java
@@ -130,6 +130,18 @@
 
         // clear interrupt
         Thread.interrupted();
+
+        // clear thread locals when in default thread pool
+        if (System.getSecurityManager() != null) {
+            Thread me = Thread.currentThread();
+            if (me instanceof sun.misc.InnocuousThread) {
+                GroupAndInvokeCount thisGroupAndInvokeCount = myGroupAndInvokeCount.get();
+                ((sun.misc.InnocuousThread)me).eraseThreadLocals();
+                if (thisGroupAndInvokeCount != null) {
+                    myGroupAndInvokeCount.set(thisGroupAndInvokeCount);
+                }
+            }
+        }
     }
 
     /**
--- jdk/src/share/classes/sun/nio/ch/ThreadPool.java
+++ jdk/src/share/classes/sun/nio/ch/ThreadPool.java
@@ -27,6 +27,7 @@
 
 import java.util.concurrent.*;
 import java.security.AccessController;
+import java.security.PrivilegedAction;
 import sun.security.action.GetPropertyAction;
 import sun.security.action.GetIntegerAction;
 
@@ -39,14 +40,6 @@
         "java.nio.channels.DefaultThreadPool.threadFactory";
     private static final String DEFAULT_THREAD_POOL_INITIAL_SIZE =
         "java.nio.channels.DefaultThreadPool.initialSize";
-    private static final ThreadFactory defaultThreadFactory = new ThreadFactory() {
-         @Override
-         public Thread newThread(Runnable r) {
-             Thread t = new Thread(r);
-             t.setDaemon(true);
-             return t;
-        }
-     };
 
     private final ExecutorService executor;
 
@@ -79,7 +72,22 @@
     }
 
     static ThreadFactory defaultThreadFactory() {
-        return defaultThreadFactory;
+        if (System.getSecurityManager() == null) {
+            return (Runnable r) -> {
+                Thread t = new Thread(r);
+                t.setDaemon(true);
+                return t;
+            };
+        } else {
+            return (Runnable r) -> {
+                PrivilegedAction<Thread> action = () -> {
+                    Thread t = new sun.misc.InnocuousThread(r);
+                    t.setDaemon(true);
+                    return t;
+               };
+               return AccessController.doPrivileged(action);
+           };
+        }
     }
 
     private static class DefaultThreadPoolHolder {
@@ -100,7 +108,7 @@
         // default to thread factory that creates daemon threads
         ThreadFactory threadFactory = getDefaultThreadPoolThreadFactory();
         if (threadFactory == null)
-            threadFactory = defaultThreadFactory;
+            threadFactory = defaultThreadFactory();
         // create thread pool
         ExecutorService executor = Executors.newCachedThreadPool(threadFactory);
         return new ThreadPool(executor, false, initialSize);
--- jdk/src/share/classes/sun/security/provider/SeedGenerator.java
+++ jdk/src/share/classes/sun/security/provider/SeedGenerator.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -179,8 +179,8 @@
                             md.update(p.getProperty(s).getBytes());
                         }
 
-                        md.update
-                            (InetAddress.getLocalHost().toString().getBytes());
+                        // Include network adapter names (and a Mac address)
+                        addNetworkAdapterInfo(md);
 
                         // The temporary dir
                         File f = new File(p.getProperty("java.io.tmpdir"));
@@ -221,6 +221,31 @@
         return md.digest();
     }
 
+    /*
+     * Include network adapter names and, if available, a Mac address
+     *
+     * See also java.util.concurrent.ThreadLocalRandom.initialSeed()
+     */
+    private static void addNetworkAdapterInfo(MessageDigest md) {
+
+        try {
+            Enumeration<NetworkInterface> ifcs =
+                NetworkInterface.getNetworkInterfaces();
+            while (ifcs.hasMoreElements()) {
+                NetworkInterface ifc = ifcs.nextElement();
+                md.update(ifc.toString().getBytes());
+                if (!ifc.isVirtual()) { // skip fake addresses
+                    byte[] bs = ifc.getHardwareAddress();
+                    if (bs != null) {
+                        md.update(bs);
+                        break;
+                    }
+                }
+            }
+        } catch (Exception ignore) {
+        }
+    }
+
     /**
      * Helper function to convert a long into a byte array (least significant
      * byte first).
--- jdk/src/share/classes/sun/security/provider/certpath/AlgorithmChecker.java
+++ jdk/src/share/classes/sun/security/provider/certpath/AlgorithmChecker.java
@@ -75,7 +75,7 @@
     private PublicKey prevPubKey;
 
     private final static Set<CryptoPrimitive> SIGNATURE_PRIMITIVE_SET =
-                                    EnumSet.of(CryptoPrimitive.SIGNATURE);
+        Collections.unmodifiableSet(EnumSet.of(CryptoPrimitive.SIGNATURE));
 
     private final static DisabledAlgorithmConstraints
         certPathDefaultConstraints = new DisabledAlgorithmConstraints(
--- jdk/src/share/classes/sun/security/rsa/RSAPadding.java
+++ jdk/src/share/classes/sun/security/rsa/RSAPadding.java
@@ -25,11 +25,9 @@
 
 package sun.security.rsa;
 
-import java.math.BigInteger;
 import java.util.*;
 
 import java.security.*;
-import java.security.interfaces.*;
 import java.security.spec.*;
 
 import javax.crypto.BadPaddingException;
@@ -41,21 +39,41 @@
 /**
  * RSA padding and unpadding.
  *
- * Format of PKCS#1 v1.5 padding is:
+ * The various PKCS#1 versions can be found in the EMC/RSA Labs
+ * web site, which is currently:
+ *
+ *     http://www.emc.com/emc-plus/rsa-labs/index.htm
+ *
+ * or in the IETF RFCs derived from the above PKCS#1 standards.
+ *
+ *     RFC 2313: v1.5
+ *     RFC 2437: v2.0
+ *     RFC 3447: v2.1
+ *
+ * The format of PKCS#1 v1.5 padding is:
+ *
  *   0x00 | BT | PS...PS | 0x00 | data...data
+ *
  * where BT is the blocktype (1 or 2). The length of the entire string
  * must be the same as the size of the modulus (i.e. 128 byte for a 1024 bit
  * key). Per spec, the padding string must be at least 8 bytes long. That
  * leaves up to (length of key in bytes) - 11 bytes for the data.
  *
- * OAEP padding is a bit more complicated and has a number of options.
- * We support:
+ * OAEP padding was introduced in PKCS#1 v2.0 and is a bit more complicated
+ * and has a number of options. We support:
+ *
  *   . arbitrary hash functions ('Hash' in the specification), MessageDigest
  *     implementation must be available
  *   . MGF1 as the mask generation function
  *   . the empty string as the default value for label L and whatever
  *     specified in javax.crypto.spec.OAEPParameterSpec
  *
+ * The algorithms (representations) are forwards-compatible: that is,
+ * the algorithm described in previous releases are in later releases.
+ * However, additional comments/checks/clarifications were added to the
+ * later versions based on real-world experience (e.g. stricter v1.5
+ * format checking.)
+ *
  * Note: RSA keys should be at least 512 bits long
  *
  * @since   1.5
@@ -156,7 +174,8 @@
                         throw new InvalidAlgorithmParameterException
                             ("Unsupported MGF algo: " + mgfName);
                     }
-                    mgfMdName = ((MGF1ParameterSpec)spec.getMGFParameters()).getDigestAlgorithm();
+                    mgfMdName = ((MGF1ParameterSpec)spec.getMGFParameters())
+                            .getDigestAlgorithm();
                     PSource pSrc = spec.getPSource();
                     String pSrcAlgo = pSrc.getAlgorithm();
                     if (!pSrcAlgo.equalsIgnoreCase("PSpecified")) {
@@ -198,7 +217,7 @@
      */
     private static byte[] getInitialHash(MessageDigest md,
         byte[] digestInput) {
-        byte[] result = null;
+        byte[] result;
         if ((digestInput == null) || (digestInput.length == 0)) {
             String digestName = md.getAlgorithm();
             result = emptyHashes.get(digestName);
@@ -213,8 +232,8 @@
     }
 
     /**
-     * Return the maximum size of the plaintext data that can be processed using
-     * this object.
+     * Return the maximum size of the plaintext data that can be processed
+     * using this object.
      */
     public int getMaxDataSize() {
         return maxDataSize;
@@ -262,7 +281,7 @@
      */
     public byte[] unpad(byte[] padded) throws BadPaddingException {
         if (padded.length != paddedSize) {
-            throw new BadPaddingException("Padded length must be " + paddedSize);
+            throw new BadPaddingException("Decryption error");
         }
         switch (type) {
         case PAD_NONE:
@@ -282,7 +301,8 @@
      */
     private byte[] padV15(byte[] data) throws BadPaddingException {
         byte[] padded = new byte[paddedSize];
-        System.arraycopy(data, 0, padded, paddedSize - data.length, data.length);
+        System.arraycopy(data, 0, padded, paddedSize - data.length,
+            data.length);
         int psSize = paddedSize - 3 - data.length;
         int k = 0;
         padded[k++] = 0;
@@ -317,55 +337,53 @@
     }
 
     /**
-     * PKCS#1 v1.5 unpadding (blocktype 1 and 2).
+     * PKCS#1 v1.5 unpadding (blocktype 1 (signature) and 2 (encryption)).
      *
      * Note that we want to make it a constant-time operation
      */
     private byte[] unpadV15(byte[] padded) throws BadPaddingException {
         int k = 0;
-        BadPaddingException bpe = null;
+        boolean bp = false;
 
         if (padded[k++] != 0) {
-            bpe = new BadPaddingException("Data must start with zero");
+            bp = true;
         }
-        if (padded[k++] != type && bpe == null) {
-            bpe = new BadPaddingException("Blocktype mismatch: " + padded[1]);
+        if (padded[k++] != type) {
+            bp = true;
         }
         int p = 0;
         while (k < padded.length) {
             int b = padded[k++] & 0xff;
-            if (b == 0 && p == 0) {
+            if ((b == 0) && (p == 0)) {
                 p = k;
             }
-            if (k == padded.length && p == 0 && bpe == null) {
-                bpe = new BadPaddingException("Padding string not terminated");
+            if ((k == padded.length) && (p == 0)) {
+                bp = true;
             }
             if ((type == PAD_BLOCKTYPE_1) && (b != 0xff) &&
-                    p == 0 && bpe == null) {
-                bpe = new BadPaddingException("Padding byte not 0xff: " + b);
+                    (p == 0)) {
+                bp = true;
             }
         }
         int n = padded.length - p;
-        if (n > maxDataSize && bpe == null) {
-            bpe = new BadPaddingException("Padding string too short");
+        if (n > maxDataSize) {
+            bp = true;
         }
 
         // copy useless padding array for a constant-time method
-        //
-        // Is it necessary?
         byte[] padding = new byte[p];
         System.arraycopy(padded, 0, padding, 0, p);
 
         byte[] data = new byte[n];
         System.arraycopy(padded, p, data, 0, n);
 
-        if (bpe == null) {
-            bpe = new BadPaddingException("Unused exception");
-        } else {
+        BadPaddingException bpe = new BadPaddingException("Decryption error");
+
+        if (bp) {
             throw bpe;
+        } else {
+            return data;
         }
-
-        return data;
     }
 
     /**
@@ -424,10 +442,11 @@
      */
     private byte[] unpadOAEP(byte[] padded) throws BadPaddingException {
         byte[] EM = padded;
+        boolean bp = false;
         int hLen = lHash.length;
 
         if (EM[0] != 0) {
-            throw new BadPaddingException("Data must start with zero");
+            bp = true;
         }
 
         int seedStart = 1;
@@ -442,29 +461,48 @@
         // verify lHash == lHash'
         for (int i = 0; i < hLen; i++) {
             if (lHash[i] != EM[dbStart + i]) {
-                throw new BadPaddingException("lHash mismatch");
+                bp = true;
             }
         }
 
-        // skip over padding (0x00 bytes)
-        int i = dbStart + hLen;
-        while (EM[i] == 0) {
-            i++;
-            if (i >= EM.length) {
-                throw new BadPaddingException("Padding string not terminated");
+        int padStart = dbStart + hLen;
+        int onePos = -1;
+
+        for (int i = padStart; i < EM.length; i++) {
+            int value = EM[i];
+            if (onePos == -1) {
+                if (value == 0x00) {
+                    // continue;
+                } else if (value == 0x01) {
+                    onePos = i;
+                } else {  // Anything other than {0,1} is bad.
+                    bp = true;
+                }
             }
         }
 
-        if (EM[i++] != 1) {
-            throw new BadPaddingException
-                ("Padding string not terminated by 0x01 byte");
+        // We either ran off the rails or found something other than 0/1.
+        if (onePos == -1) {
+            bp = true;
+            onePos = EM.length - 1;  // Don't inadvertently return any data.
         }
 
-        int mLen = EM.length - i;
-        byte[] m = new byte[mLen];
-        System.arraycopy(EM, i, m, 0, mLen);
+        int mStart = onePos + 1;
+
+        // copy useless padding array for a constant-time method
+        byte [] tmp = new byte[mStart - padStart];
+        System.arraycopy(EM, padStart, tmp, 0, tmp.length);
+
+        byte [] m = new byte[EM.length - mStart];
+        System.arraycopy(EM, mStart, m, 0, m.length);
 
-        return m;
+        BadPaddingException bpe = new BadPaddingException("Decryption error");
+
+        if (bp) {
+            throw bpe;
+        } else {
+            return m;
+        }
     }
 
     /**
@@ -499,5 +537,4 @@
             }
         }
     }
-
 }
--- jdk/src/share/classes/sun/security/ssl/SignatureAndHashAlgorithm.java
+++ jdk/src/share/classes/sun/security/ssl/SignatureAndHashAlgorithm.java
@@ -68,7 +68,7 @@
 
     // performance optimization
     private final static Set<CryptoPrimitive> SIGNATURE_PRIMITIVE_SET =
-                                    EnumSet.of(CryptoPrimitive.SIGNATURE);
+        Collections.unmodifiableSet(EnumSet.of(CryptoPrimitive.SIGNATURE));
 
     // supported pairs of signature and hash algorithm
     private final static Map<Integer, SignatureAndHashAlgorithm> supportedMap;
--- jdk/src/share/classes/sun/security/tools/jarsigner/Main.java
+++ jdk/src/share/classes/sun/security/tools/jarsigner/Main.java
@@ -90,9 +90,6 @@
 
     private static final String META_INF = "META-INF/";
 
-    // prefix for new signature-related files in META-INF directory
-    private static final String SIG_PREFIX = META_INF + "SIG-";
-
     private static final Class<?>[] PARAM_STRING = { String.class };
 
     private static final String NONE = "NONE";
@@ -1522,22 +1519,7 @@
      * . META-INF/*.EC
      */
     private boolean signatureRelated(String name) {
-        String ucName = name.toUpperCase(Locale.ENGLISH);
-        if (ucName.equals(JarFile.MANIFEST_NAME) ||
-            ucName.equals(META_INF) ||
-            (ucName.startsWith(SIG_PREFIX) &&
-                ucName.indexOf("/") == ucName.lastIndexOf("/"))) {
-            return true;
-        }
-
-        if (ucName.startsWith(META_INF) &&
-            SignatureFileVerifier.isBlockOrSF(ucName)) {
-            // .SF/.DSA/.RSA/.EC files in META-INF subdirs
-            // are not considered signature-related
-            return (ucName.indexOf("/") == ucName.lastIndexOf("/"));
-        }
-
-        return false;
+        return SignatureFileVerifier.isSigningRelated(name);
     }
 
     Map<CodeSigner,String> cacheForSignerInfo = new IdentityHashMap<>();
--- jdk/src/share/classes/sun/security/util/SignatureFileVerifier.java
+++ jdk/src/share/classes/sun/security/util/SignatureFileVerifier.java
@@ -152,6 +152,52 @@
         return false;
     }
 
+    /**
+     * Yet another utility method used by JarVerifier and JarSigner
+     * to determine what files are signature related, which includes
+     * the MANIFEST, SF files, known signature block files, and other
+     * unknown signature related files (those starting with SIG- with
+     * an optional [A-Z0-9]{1,3} extension right inside META-INF).
+     *
+     * @param s file name
+     * @return true if the input file name is signature related
+     */
+    public static boolean isSigningRelated(String name) {
+        name = name.toUpperCase(Locale.ENGLISH);
+        if (!name.startsWith("META-INF/")) {
+            return false;
+        }
+        name = name.substring(9);
+        if (name.indexOf('/') != -1) {
+            return false;
+        }
+        if (isBlockOrSF(name) || name.equals("MANIFEST.MF")) {
+            return true;
+        } else if (name.startsWith("SIG-")) {
+            // check filename extension
+            // see http://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html#Digital_Signatures
+            // for what filename extensions are legal
+            int extIndex = name.lastIndexOf('.');
+            if (extIndex != -1) {
+                String ext = name.substring(extIndex + 1);
+                // validate length first
+                if (ext.length() > 3 || ext.length() < 1) {
+                    return false;
+                }
+                // then check chars, must be in [a-zA-Z0-9] per the jar spec
+                for (int index = 0; index < ext.length(); index++) {
+                    char cc = ext.charAt(index);
+                    // chars are promoted to uppercase so skip lowercase checks
+                    if ((cc < 'A' || cc > 'Z') && (cc < '0' || cc > '9')) {
+                        return false;
+                    }
+                }
+            }
+            return true; // no extension is OK
+        }
+        return false;
+    }
+
     /** get digest from cache */
 
     private MessageDigest getDigest(String algorithm)
--- jdk/src/share/classes/sun/util/resources/TimeZoneNames.java
+++ jdk/src/share/classes/sun/util/resources/TimeZoneNames.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -578,7 +578,7 @@
             {"Asia/Almaty", new String[] {"Alma-Ata Time", "ALMT",
                                           "Alma-Ata Summer Time", "ALMST",
                                           "Alma-Ata Time", "ALMT"}},
-            {"Asia/Amman", ARAST},
+            {"Asia/Amman", EET},
             {"Asia/Anadyr", new String[] {"Anadyr Time", "ANAT",
                                           "Anadyr Summer Time", "ANAST",
                                           "Anadyr Time", "ANAT"}},
--- jdk/src/share/classes/sun/util/resources/TimeZoneNamesBundle.java
+++ jdk/src/share/classes/sun/util/resources/TimeZoneNamesBundle.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- jdk/src/share/classes/sun/util/resources/de/TimeZoneNames_de.java
+++ jdk/src/share/classes/sun/util/resources/de/TimeZoneNames_de.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -578,7 +578,7 @@
             {"Asia/Almaty", new String[] {"Alma Ata Zeit", "ALMT",
                                           "Alma-Ata Sommerzeit", "ALMST",
                                           "Alma Ata Zeit", "ALMT"}},
-            {"Asia/Amman", ARAST},
+            {"Asia/Amman", EET},
             {"Asia/Anadyr", new String[] {"Anadyr Zeit", "ANAT",
                                           "Anadyr Sommerzeit", "ANAST",
                                           "Anadyr Zeit", "ANAT"}},
--- jdk/src/share/classes/sun/util/resources/es/TimeZoneNames_es.java
+++ jdk/src/share/classes/sun/util/resources/es/TimeZoneNames_es.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -578,7 +578,7 @@
             {"Asia/Almaty", new String[] {"Hora de Alma-Ata", "ALMT",
                                           "Hora de verano de Alma-Ata", "ALMST",
                                           "Hora de Alma-Ata", "ALMT"}},
-            {"Asia/Amman", ARAST},
+            {"Asia/Amman", EET},
             {"Asia/Anadyr", new String[] {"Hora de Anadyr", "ANAT",
                                           "Hora de verano de Anadyr", "ANAST",
                                           "Hora de Anadyr", "ANAT"}},
--- jdk/src/share/classes/sun/util/resources/fr/TimeZoneNames_fr.java
+++ jdk/src/share/classes/sun/util/resources/fr/TimeZoneNames_fr.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -578,7 +578,7 @@
             {"Asia/Almaty", new String[] {"Heure d'Alma-Ata", "ALMT",
                                           "Heure d'\u00e9t\u00e9 d'Alma-Ata", "ALMST",
                                           "Heure d'Alma-Ata", "ALMT"}},
-            {"Asia/Amman", ARAST},
+            {"Asia/Amman", EET},
             {"Asia/Anadyr", new String[] {"Heure d'Anadyr", "ANAT",
                                           "Heure d'\u00e9t\u00e9 d'Anadyr", "ANAST",
                                           "Heure d'Anadyr", "ANAT"}},
--- jdk/src/share/classes/sun/util/resources/it/TimeZoneNames_it.java
+++ jdk/src/share/classes/sun/util/resources/it/TimeZoneNames_it.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -578,7 +578,7 @@
             {"Asia/Almaty", new String[] {"Ora di Alma-Ata", "ALMT",
                                           "Ora estiva di Alma-Ata", "ALMST",
                                           "Ora di Alma-Ata", "ALMT"}},
-            {"Asia/Amman", ARAST},
+            {"Asia/Amman", EET},
             {"Asia/Anadyr", new String[] {"Ora di Anadyr", "ANAT",
                                           "Ora estiva di Anadyr", "ANAST",
                                           "Ora di Anadyr", "ANAT"}},
--- jdk/src/share/classes/sun/util/resources/ja/TimeZoneNames_ja.java
+++ jdk/src/share/classes/sun/util/resources/ja/TimeZoneNames_ja.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -578,7 +578,7 @@
             {"Asia/Almaty", new String[] {"\u30a2\u30eb\u30de\u30a2\u30bf\u6642\u9593", "ALMT",
                                           "\u30a2\u30eb\u30de\u30a2\u30bf\u590f\u6642\u9593", "ALMST",
                                           "\u30A2\u30EB\u30DE\u30A2\u30BF\u6642\u9593", "ALMT"}},
-            {"Asia/Amman", ARAST},
+            {"Asia/Amman", EET},
             {"Asia/Anadyr", new String[] {"\u30a2\u30ca\u30c9\u30a5\u30a4\u30ea\u6642\u9593", "ANAT",
                                           "\u30a2\u30ca\u30c9\u30a5\u30a4\u30ea\u590f\u6642\u9593", "ANAST",
                                           "\u30A2\u30CA\u30C7\u30A3\u30EA\u6642\u9593", "ANAT"}},
--- jdk/src/share/classes/sun/util/resources/ko/TimeZoneNames_ko.java
+++ jdk/src/share/classes/sun/util/resources/ko/TimeZoneNames_ko.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -578,7 +578,7 @@
             {"Asia/Almaty", new String[] {"\uc54c\ub9c8\uc544\ud0c0 \uc2dc\uac04", "ALMT",
                                           "\uc54c\ub9c8\uc544\ud0c0 \uc77c\uad11\uc808\uc57d\uc2dc\uac04", "ALMST",
                                           "\uC54C\uB9C8\uC544\uD0C0 \uD45C\uC900\uC2DC", "ALMT"}},
-            {"Asia/Amman", ARAST},
+            {"Asia/Amman", EET},
             {"Asia/Anadyr", new String[] {"\uc544\ub098\ub514\ub974 \uc2dc\uac04", "ANAT",
                                           "\uc544\ub098\ub514\ub974 \uc77c\uad11\uc808\uc57d\uc2dc\uac04", "ANAST",
                                           "\uC544\uB098\uB514\uB9AC \uD45C\uC900\uC2DC", "ANAT"}},
--- jdk/src/share/classes/sun/util/resources/pt/TimeZoneNames_pt_BR.java
+++ jdk/src/share/classes/sun/util/resources/pt/TimeZoneNames_pt_BR.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -578,7 +578,7 @@
             {"Asia/Almaty", new String[] {"Fuso hor\u00e1rio de Alma-Ata", "ALMT",
                                           "Fuso hor\u00e1rio de ver\u00e3o de Alma-Ata", "ALMST",
                                           "Hor\u00E1rio de Alma-Ata", "ALMT"}},
-            {"Asia/Amman", ARAST},
+            {"Asia/Amman", EET},
             {"Asia/Anadyr", new String[] {"Fuso hor\u00e1rio de Anadyr", "ANAT",
                                           "Fuso hor\u00e1rio de ver\u00e3o de Anadyr", "ANAST",
                                           "Hor\u00E1rio de Anadyr", "ANAT"}},
--- jdk/src/share/classes/sun/util/resources/sv/TimeZoneNames_sv.java
+++ jdk/src/share/classes/sun/util/resources/sv/TimeZoneNames_sv.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -578,7 +578,7 @@
             {"Asia/Almaty", new String[] {"Alma-Ata, normaltid", "ALMT",
                                           "Alma-Ata, sommartid", "ALMST",
                                           "Alma-Ata-tid", "ALMT"}},
-            {"Asia/Amman", ARAST},
+            {"Asia/Amman", EET},
             {"Asia/Anadyr", new String[] {"Anadyr, normaltid", "ANAT",
                                           "Anadyr, sommartid", "ANAST",
                                           "Anadyr-tid", "ANAT"}},
--- jdk/src/share/classes/sun/util/resources/zh/TimeZoneNames_zh_CN.java
+++ jdk/src/share/classes/sun/util/resources/zh/TimeZoneNames_zh_CN.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -578,7 +578,7 @@
             {"Asia/Almaty", new String[] {"Alma-Ata \u65f6\u95f4", "ALMT",
                                           "Alma-Ata \u590f\u4ee4\u65f6", "ALMST",
                                           "Alma-Ata \u65F6\u95F4", "ALMT"}},
-            {"Asia/Amman", ARAST},
+            {"Asia/Amman", EET},
             {"Asia/Anadyr", new String[] {"\u963f\u90a3\u5e95\u6cb3\u65f6\u95f4", "ANAT",
                                           "\u963f\u90a3\u5e95\u6cb3\u590f\u4ee4\u65f6", "ANAST",
                                           "\u963F\u90A3\u5E95\u6CB3\u65F6\u95F4", "ANAT"}},
--- jdk/src/share/classes/sun/util/resources/zh/TimeZoneNames_zh_TW.java
+++ jdk/src/share/classes/sun/util/resources/zh/TimeZoneNames_zh_TW.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -578,7 +578,7 @@
             {"Asia/Almaty", new String[] {"Alma-Ata \u6642\u9593", "ALMT",
                                           "Alma-Ata \u590f\u4ee4\u6642\u9593", "ALMST",
                                           "\u963F\u62C9\u6728\u5716\u6642\u9593", "ALMT"}},
-            {"Asia/Amman", ARAST},
+            {"Asia/Amman", EET},
             {"Asia/Anadyr", new String[] {"\u963f\u90a3\u5e95\u6cb3\u6642\u9593", "ANAT",
                                           "\u963f\u90a3\u5e95\u6cb3\u590f\u4ee4\u6642\u9593", "ANAST",
                                           "\u963F\u90A3\u5E95\u6CB3\u6642\u9593", "ANAT"}},
--- jdk/src/share/native/com/sun/java/util/jar/pack/unpack.cpp
+++ jdk/src/share/native/com/sun/java/util/jar/pack/unpack.cpp
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -5166,39 +5166,7 @@
   } else if (log_file[0] != '\0' && (errstrm = fopen(log_file,"a+")) != NULL) {
     return;
   } else {
-    char log_file_name[PATH_MAX+100];
-    char tmpdir[PATH_MAX];
-#ifdef WIN32
-    int n = GetTempPath(PATH_MAX,tmpdir); //API returns with trailing '\'
-    if (n < 1 || n > PATH_MAX) {
-      sprintf(tmpdir,"C:\\");
-    }
-    sprintf(log_file_name, "%sunpack.log", tmpdir);
-#else
-    sprintf(tmpdir,"/tmp");
-    sprintf(log_file_name, "/tmp/unpack.log");
-#endif
-    if ((errstrm = fopen(log_file_name, "a+")) != NULL) {
-      log_file = errstrm_name = saveStr(log_file_name);
-      return ;
-    }
-
-    char *tname = tempnam(tmpdir,"#upkg");
-    if (tname == NULL) return;
-    sprintf(log_file_name, "%s", tname);
-    ::free(tname);
-    if ((errstrm = fopen(log_file_name, "a+")) != NULL) {
-      log_file = errstrm_name = saveStr(log_file_name);
-      return ;
-    }
-#ifndef WIN32
-    sprintf(log_file_name, "/dev/null");
-    // On windows most likely it will fail.
-    if ( (errstrm = fopen(log_file_name, "a+")) != NULL) {
-      log_file = errstrm_name = saveStr(log_file_name);
-      return ;
-    }
-#endif
+    fprintf(stderr, "Can not open log file %s\n", log_file);
     // Last resort
     // (Do not use stdout, since it might be jarout->jarfp.)
     errstrm = stderr;
--- jdk/src/share/native/sun/awt/giflib/dgif_lib.c
+++ jdk/src/share/native/sun/awt/giflib/dgif_lib.c
@@ -435,9 +435,7 @@
     Private->PixelCount = (long)GifFile->Image.Width *
        (long)GifFile->Image.Height;
 
-    DGifSetupDecompress(GifFile);  /* Reset decompress algorithm parameters. */
-
-    return GIF_OK;
+    return DGifSetupDecompress(GifFile);  /* Reset decompress algorithm parameters. */
 }
 
 /******************************************************************************
--- jdk/src/share/native/sun/awt/image/gif/gifdecoder.c
+++ jdk/src/share/native/sun/awt/image/gif/gifdecoder.c
@@ -249,6 +249,7 @@
                 /* fill the block */
                 len = (*env)->CallIntMethod(env, this, readID,
                                             blockh, remain, blockLength + 1);
+                if (len > blockLength + 1) len = blockLength + 1;
                 if ((*env)->ExceptionOccurred(env)) {
                     return 0;
                 }
--- jdk/src/share/native/sun/awt/image/jpeg/imageioJPEG.c
+++ jdk/src/share/native/sun/awt/image/jpeg/imageioJPEG.c
@@ -939,6 +939,9 @@
                                 JPEGImageReader_readInputDataID,
                                 sb->hstreamBuffer, 0,
                                 sb->bufferLength);
+    if ((ret > 0) && ((unsigned int)ret > sb->bufferLength)) {
+         ret = sb->bufferLength;
+    }
     if ((*env)->ExceptionOccurred(env)
         || !GET_ARRAYS(env, data, &(src->next_input_byte))) {
             cinfo->err->error_exit((j_common_ptr) cinfo);
@@ -1035,6 +1038,7 @@
                                 JPEGImageReader_readInputDataID,
                                 sb->hstreamBuffer,
                                 offset, buflen);
+    if ((ret > 0) && ((unsigned int)ret > buflen)) ret = buflen;
     if ((*env)->ExceptionOccurred(env)
         || !GET_ARRAYS(env, data, &(src->next_input_byte))) {
         cinfo->err->error_exit((j_common_ptr) cinfo);
--- jdk/src/share/native/sun/awt/image/jpeg/jdmarker.c
+++ jdk/src/share/native/sun/awt/image/jpeg/jdmarker.c
@@ -349,6 +349,12 @@
 
     TRACEMS3(cinfo, 1, JTRC_SOS_COMPONENT, cc,
              compptr->dc_tbl_no, compptr->ac_tbl_no);
+
+    /* This CSi (cc) should differ from the previous CSi */
+    for (ci = 0; ci < i; ci++) {
+      if (cinfo->cur_comp_info[ci] == compptr)
+        ERREXIT1(cinfo, JERR_BAD_COMPONENT_ID, cc);
+    }
   }
 
   /* Collect the additional scan parameters Ss, Se, Ah/Al. */
--- jdk/src/share/native/sun/awt/image/jpeg/jpegdecoder.c
+++ jdk/src/share/native/sun/awt/image/jpeg/jpegdecoder.c
@@ -289,6 +289,7 @@
     buflen = (*env)->GetArrayLength(env, src->hInputBuffer);
     ret = (*env)->CallIntMethod(env, src->hInputStream, InputStream_readID,
                                 src->hInputBuffer, 0, buflen);
+    if (ret > buflen) ret = buflen;
     if ((*env)->ExceptionOccurred(env) || !GET_ARRAYS(env, src)) {
         cinfo->err->error_exit((struct jpeg_common_struct *) cinfo);
     }
@@ -349,6 +350,7 @@
     }
     ret = (*env)->CallIntMethod(env, src->hInputStream, InputStream_readID,
                                 src->hInputBuffer, offset, buflen);
+    if ((ret > 0) && ((unsigned int)ret > buflen)) ret = buflen;
     if ((*env)->ExceptionOccurred(env) || !GET_ARRAYS(env, src)) {
         cinfo->err->error_exit((struct jpeg_common_struct *) cinfo);
     }
@@ -424,6 +426,7 @@
         ret = (*env)->CallIntMethod(env, src->hInputStream,
                                     InputStream_readID,
                                     src->hInputBuffer, 0, buflen);
+        if (ret > buflen) ret = buflen;
         if ((*env)->ExceptionOccurred(env)) {
             cinfo->err->error_exit((struct jpeg_common_struct *) cinfo);
         }
--- jdk/src/share/native/sun/awt/libpng/pngrtran.c
+++ jdk/src/share/native/sun/awt/libpng/pngrtran.c
@@ -1862,6 +1862,9 @@
 
          info_ptr->bit_depth = 8;
          info_ptr->num_trans = 0;
+
+         if (png_ptr->palette == NULL)
+            png_error (png_ptr, "Palette is NULL in indexed image");
       }
       else
       {
--- jdk/src/share/native/sun/awt/libpng/pngset.c
+++ jdk/src/share/native/sun/awt/libpng/pngset.c
@@ -512,6 +512,17 @@
       }
    }
 
+   if ((num_palette > 0 && palette == NULL) ||
+      (num_palette == 0
+#        ifdef PNG_MNG_FEATURES_SUPPORTED
+            && (png_ptr->mng_features_permitted & PNG_FLAG_MNG_EMPTY_PLTE) == 0
+#        endif
+      ))
+   {
+      png_error(png_ptr, "Invalid palette");
+      return;
+   }
+
    /* It may not actually be necessary to set png_ptr->palette here;
     * we do it for backward compatibility with the way the png_handle_tRNS
     * function used to do the allocation.
--- jdk/src/share/native/sun/awt/medialib/awt_ImagingLib.c
+++ jdk/src/share/native/sun/awt/medialib/awt_ImagingLib.c
@@ -228,6 +228,49 @@
     }
 }
 
+/*
+ * We have to make sure that awt_setPixels can be safely applied to the given pair of
+ * raster and mlib image.
+ *
+ * In particular, make sure that
+ *  - dimension is the same
+ *  - number of channels in mlib image corresponds to the number of bands in the raster
+ *  - sample size in image and raster are the same.
+ *
+ * Returns:
+ *  -1 to indicate failure,
+ *   1 to indicate success
+ */
+static int setPixelsFormMlibImage(JNIEnv *env, RasterS_t *rasterP, mlib_image* img) {
+    if (rasterP->width != img->width || rasterP->height != img->height) {
+        /* dimension does not match */
+        return -1;
+    }
+
+    if (rasterP->numBands != img->channels) {
+        /* number of bands does not match */
+        return -1;
+    }
+
+    switch (rasterP->dataType) {
+    case BYTE_DATA_TYPE:
+        if (img->type != MLIB_BYTE) {
+            return -1;
+        }
+        break;
+    case SHORT_DATA_TYPE:
+        if (img->type != MLIB_SHORT && img->type != MLIB_USHORT) {
+            return -1;
+        }
+        break;
+    default:
+        /* awt_setPixels does not support such rasters */
+        return -1;
+    }
+
+    return awt_setPixels(env, rasterP, mlib_ImageGetData(img));
+}
+
 /***************************************************************************
  *                          External Functions                             *
  ***************************************************************************/
@@ -700,7 +743,9 @@
 
     /* Means that we couldn't write directly into the destination buffer */
     if (ddata == NULL) {
-        retStatus = awt_setPixels(env, dstRasterP, mlib_ImageGetData(dst));
+        if (storeRasterArray(env, srcRasterP, dstRasterP, dst) < 0) {
+            retStatus = setPixelsFormMlibImage(env, dstRasterP, dst);
+        }
     }
 
     /* Release the pinned memory */
@@ -1106,7 +1151,7 @@
     if (ddata == NULL) {
         /* Need to store it back into the array */
         if (storeRasterArray(env, srcRasterP, dstRasterP, dst) < 0) {
-            retStatus = awt_setPixels(env, dstRasterP, mlib_ImageGetData(dst));
+            retStatus = setPixelsFormMlibImage(env, dstRasterP, dst);
         }
     }
 
@@ -1432,6 +1477,14 @@
         retStatus = 0;
     }
 
+   /* Release the LUT */
+    for (i=0; i < lut_nbands; i++) {
+        (*env)->ReleasePrimitiveArrayCritical(env, jtable[i].jArray,
+            (jbyte *) jtable[i].table, JNI_ABORT);
+    }
+    free ((void *) jtable);
+    free ((void *) tbl);
+
     /*
      * Means that we couldn't write directly into
      * the destination buffer
@@ -1445,13 +1498,6 @@
         }
     }
 
-    /* Release the LUT */
-    for (i=0; i < lut_nbands; i++) {
-        (*env)->ReleasePrimitiveArrayCritical(env, jtable[i].jArray,
-            (jbyte *) jtable[i].table, JNI_ABORT);
-    }
-    free ((void *) jtable);
-    free ((void *) tbl);
 
     /* Release the pinned memory */
     freeArray(env, srcImageP, src, sdata, dstImageP, dst, ddata);
@@ -1669,18 +1715,20 @@
         retStatus = 0;
     }
 
+    /* Release the LUT */
+    for (i=0; i < lut_nbands; i++) {
+        (*env)->ReleasePrimitiveArrayCritical(env, jtable[i].jArray,
+                                              (jbyte *) jtable[i].table, JNI_ABORT);
+    }
+
     /*
      * Means that we couldn't write directly into
      * the destination buffer
      */
     if (ddata == NULL) {
-        retStatus = awt_setPixels(env, dstRasterP, mlib_ImageGetData(dst));
-    }
-
-    /* Release the LUT */
-    for (i=0; i < lut_nbands; i++) {
-        (*env)->ReleasePrimitiveArrayCritical(env, jtable[i].jArray,
-                                              (jbyte *) jtable[i].table, JNI_ABORT);
+        if (storeRasterArray(env, srcRasterP, dstRasterP, dst) < 0) {
+            retStatus = setPixelsFormMlibImage(env, dstRasterP, dst);
+        }
     }
 
     /* Release the pinned memory */
@@ -2640,7 +2688,7 @@
             }
         }
         else if (mlibImP->type == MLIB_SHORT) {
-            return awt_setPixels(env, rasterP, mlibImP->data);
+            return setPixelsFormMlibImage(env, rasterP, mlibImP);
         }
     }
     else {
--- jdk/src/share/native/sun/font/layout/ContextualGlyphSubstProc2.cpp
+++ jdk/src/share/native/sun/font/layout/ContextualGlyphSubstProc2.cpp
@@ -154,6 +154,7 @@
             TTGlyphID glyphCode = (TTGlyphID) LE_GET_GLYPH(gid);
             if ((glyphCode >= firstGlyph) && (glyphCode < lastGlyph)) {
               LEReferenceToArrayOf<LookupValue> valueArray(lookupTable8, success, &lookupTable8->valueArray[0], glyphCount);
+              if (LE_FAILURE(success)) { return newGlyph; }
               newGlyph = SWAPW(valueArray(glyphCode - firstGlyph, success));
             }
         }
--- jdk/src/share/native/sun/font/layout/ContextualSubstSubtables.cpp
+++ jdk/src/share/native/sun/font/layout/ContextualSubstSubtables.cpp
@@ -110,6 +110,8 @@
     LEErrorCode &success,
     le_bool backtrack)
 {
+    if (LE_FAILURE(success)) { return FALSE; }
+
     le_int32 direction = 1;
     le_int32 match = 0;
 
@@ -255,6 +257,7 @@
                 le_uint16 matchCount = SWAPW(subRuleTable->glyphCount) - 1;
                 le_uint16 substCount = SWAPW(subRuleTable->substCount);
                 LEReferenceToArrayOf<TTGlyphID> inputGlyphArray(base, success, subRuleTable->inputGlyphArray, matchCount+2);
+                if (LE_FAILURE(success)) { return 0; }
                 if (matchGlyphIDs(inputGlyphArray, matchCount, glyphIterator)) {
                   LEReferenceToArrayOf<SubstitutionLookupRecord>
                     substLookupRecordArray(base, success, (const SubstitutionLookupRecord *) &subRuleTable->inputGlyphArray[matchCount], substCount);
@@ -315,6 +318,7 @@
 
                 LEReferenceToArrayOf<le_uint16> classArray(base, success, subClassRuleTable->classArray, matchCount+1);
 
+                if (LE_FAILURE(success)) { return 0; }
                 if (matchGlyphClasses(classArray, matchCount, glyphIterator, classDefinitionTable, success)) {
                     LEReferenceToArrayOf<SubstitutionLookupRecord>
                       substLookupRecordArray(base, success, (const SubstitutionLookupRecord *) &subClassRuleTable->classArray[matchCount], substCount);
@@ -573,7 +577,7 @@
                 if (matchGlyphClasses(inputClassArray, inputGlyphCount, glyphIterator, inputClassDefinitionTable, success)) {
                     LEReferenceToArrayOf<SubstitutionLookupRecord>
                       substLookupRecordArray(base, success, (const SubstitutionLookupRecord *) lookaheadClassArray.getAlias(lookaheadGlyphCount + 1, success), substCount);
-
+                    if (LE_FAILURE(success)) { return 0; }
                     applySubstitutionLookups(lookupProcessor, substLookupRecordArray, substCount, glyphIterator, fontInstance, position, success);
 
                     return inputGlyphCount + 1;
@@ -601,9 +605,10 @@
     le_uint16 backtrkGlyphCount = SWAPW(backtrackGlyphCount);
     le_uint16 inputGlyphCount = (le_uint16) SWAPW(backtrackCoverageTableOffsetArray[backtrkGlyphCount]);
     LEReferenceToArrayOf<Offset>   inputCoverageTableOffsetArray(base, success, &backtrackCoverageTableOffsetArray[backtrkGlyphCount + 1], inputGlyphCount+2); // offset
+    if (LE_FAILURE(success)) { return 0; }
     const le_uint16 lookaheadGlyphCount = (le_uint16) SWAPW(inputCoverageTableOffsetArray[inputGlyphCount]);
 
-    if( LE_FAILURE(success) ) { return 0; }
+    if( LE_FAILURE(success)) { return 0; }
     LEReferenceToArrayOf<Offset>   lookaheadCoverageTableOffsetArray(base, success, inputCoverageTableOffsetArray.getAlias(inputGlyphCount + 1, success), lookaheadGlyphCount+2);
 
     if( LE_FAILURE(success) ) { return 0; }
--- jdk/src/share/native/sun/font/layout/LigatureSubstProc2.cpp
+++ jdk/src/share/native/sun/font/layout/LigatureSubstProc2.cpp
@@ -95,7 +95,7 @@
 
     if (actionOffset != 0) {
         LEReferenceTo<LigatureActionEntry> ap(stHeader, success, ligActionOffset); // byte offset
-        ap.addObject(ligActionIndex - 1, success);  // index offset ( one before the actual start, because we will pre-increment)
+        ap.addObject(ligActionIndex, success);
         LEReferenceToArrayOf<TTGlyphID> ligatureTable(stHeader, success, ligatureOffset, LE_UNBOUNDED_ARRAY);
         LigatureActionEntry action;
         le_int32 offset, i = 0;
@@ -111,7 +111,6 @@
         do {
             le_uint32 componentGlyph = componentStack[m--]; // pop off
 
-            ap.addObject(success);
             action = SWAPL(*ap.getAlias());
 
             if (m < 0) {
@@ -145,7 +144,8 @@
               LE_DEBUG_BAD_FONT("m<0")
             }
 #endif
-        } while (!(action & lafLast) && (m>=0) ); // stop if last bit is set, or if run out of items
+            ap.addObject(success);
+        } while (LE_SUCCESS(success) && !(action & lafLast) && (m>=0) ); // stop if last bit is set, or if run out of items
 
         while (mm >= 0) {
             if (++m >= nComponents) {
--- jdk/src/share/native/sun/font/layout/LookupProcessor.cpp
+++ jdk/src/share/native/sun/font/layout/LookupProcessor.cpp
@@ -282,6 +282,7 @@
 
             for (le_uint16 feature = 0; feature < featureCount; feature += 1) {
               LEReferenceToArrayOf<le_uint16> featureIndexArray(langSysTable, success, langSysTable->featureIndexArray, featureCount);
+              if (LE_FAILURE(success)) { continue; }
               le_uint16 featureIndex = SWAPW(featureIndexArray.getObject(feature,success));
 
                 // don't add the required feature to the list more than once...
--- jdk/src/share/native/sun/font/layout/MarkToBasePosnSubtables.cpp
+++ jdk/src/share/native/sun/font/layout/MarkToBasePosnSubtables.cpp
@@ -67,6 +67,7 @@
 
     LEPoint markAnchor;
     LEReferenceTo<MarkArray> markArray(base, success,  (const MarkArray *) ((char *) this + SWAPW(markArrayOffset)));
+    if(LE_FAILURE(success)) return 0;
     le_int32 markClass = markArray->getMarkClass(markArray, markGlyph, markCoverage, fontInstance, markAnchor, success);
     le_uint16 mcCount = SWAPW(classCount);
 
--- jdk/src/share/native/sun/font/layout/OpenTypeUtilities.cpp
+++ jdk/src/share/native/sun/font/layout/OpenTypeUtilities.cpp
@@ -79,8 +79,8 @@
 
 Offset OpenTypeUtilities::getTagOffset(LETag tag, const LEReferenceToArrayOf<TagAndOffsetRecord> &records, LEErrorCode &success)
 {
-  const TagAndOffsetRecord *r0 = (const TagAndOffsetRecord*)records.getAlias();
   if(LE_FAILURE(success)) return 0;
+  const TagAndOffsetRecord *r0 = (const TagAndOffsetRecord*)records.getAlias();
 
   le_uint32 recordCount = records.getCount();
   le_uint8 bit = highBit(recordCount);
--- jdk/src/share/native/sun/font/layout/SegmentArrayProcessor.cpp
+++ jdk/src/share/native/sun/font/layout/SegmentArrayProcessor.cpp
@@ -73,6 +73,7 @@
 
             if (offset != 0) {
               LEReferenceToArrayOf<TTGlyphID> glyphArray(subtableHeader, success, offset, LE_UNBOUNDED_ARRAY);
+              if (LE_FAILURE(success)) { continue; }
               TTGlyphID   newGlyph   = SWAPW(glyphArray(LE_GET_GLYPH(thisGlyph) - firstGlyph, success));
               glyphStorage[glyph] = LE_SET_GLYPH(thisGlyph, newGlyph);
             }
--- jdk/src/share/native/sun/font/layout/StateTableProcessor.cpp
+++ jdk/src/share/native/sun/font/layout/StateTableProcessor.cpp
@@ -97,6 +97,7 @@
 
         LEReferenceToArrayOf<EntryTableIndex> stateArray(stHeader, success, currentState, LE_UNBOUNDED_ARRAY);
         EntryTableIndex entryTableIndex = stateArray.getObject((le_uint8)classCode, success);
+        if (LE_FAILURE(success)) { break; }
         LE_STATE_PATIENCE_CURR(le_int32, currGlyph);
         currentState = processStateEntry(glyphStorage, currGlyph, entryTableIndex);
         LE_STATE_PATIENCE_INCR(currGlyph);
--- jdk/src/share/native/sun/java2d/cmm/lcms/cmscam02.c
+++ jdk/src/share/native/sun/java2d/cmm/lcms/cmscam02.c
@@ -81,7 +81,7 @@
     cmsUInt32Number surround;
     cmsFloat64Number n, Nbb, Ncb, z, FL, D;
 
-       cmsContext ContextID;
+    cmsContext ContextID;
 
 } cmsCIECAM02;
 
@@ -467,6 +467,7 @@
     CAM02COLOR clr;
     cmsCIECAM02* lpMod = (cmsCIECAM02*) hModel;
 
+    memset(&clr, 0, sizeof(clr));
     _cmsAssert(lpMod != NULL);
     _cmsAssert(pIn != NULL);
     _cmsAssert(pOut != NULL);
@@ -491,6 +492,7 @@
     CAM02COLOR clr;
     cmsCIECAM02* lpMod = (cmsCIECAM02*) hModel;
 
+    memset(&clr, 0, sizeof(clr));
     _cmsAssert(lpMod != NULL);
     _cmsAssert(pIn != NULL);
     _cmsAssert(pOut != NULL);
--- jdk/src/share/native/sun/java2d/cmm/lcms/cmscgats.c
+++ jdk/src/share/native/sun/java2d/cmm/lcms/cmscgats.c
@@ -59,8 +59,8 @@
 // IT8.7 / CGATS.17-200x handling -----------------------------------------------------------------------------
 
 
-#define MAXID        128     // Max lenght of identifier
-#define MAXSTR      1024     // Max lenght of string
+#define MAXID        128     // Max length of identifier
+#define MAXSTR      1024     // Max length of string
 #define MAXTABLES    255     // Max Number of tables in a single stream
 #define MAXINCLUDE    20     // Max number of nested includes
 
@@ -383,28 +383,28 @@
 //Forward declaration of some internal functions
 static void* AllocChunk(cmsIT8* it8, cmsUInt32Number size);
 
-// Checks if c is a separator
+// Checks whatever c is a separator
 static
 cmsBool isseparator(int c)
 {
-        return (c == ' ') || (c == '\t') || (c == '\r');
+    return (c == ' ') || (c == '\t') ;
 }
 
-// Checks whatever if c is a valid identifier char
+// Checks whatever c is a valid identifier char
 static
 cmsBool ismiddle(int c)
 {
    return (!isseparator(c) && (c != '#') && (c !='\"') && (c != '\'') && (c > 32) && (c < 127));
 }
 
-// Checks whatsever if c is a valid identifier middle char.
+// Checks whatsever c is a valid identifier middle char.
 static
 cmsBool isidchar(int c)
 {
    return isalnum(c) || ismiddle(c);
 }
 
-// Checks whatsever if c is a valid identifier first char.
+// Checks whatsever c is a valid identifier first char.
 static
 cmsBool isfirstidchar(int c)
 {
@@ -436,7 +436,6 @@
 }
 
 
-
 // Makes a file path based on a given reference path
 // NOTE: this function doesn't check if the path exists or even if it's legal
 static
@@ -634,6 +633,7 @@
     cmsFloat64Number dnum = 0.0;
     int sign = 1;
 
+    // keep safe
     if (Buffer == NULL) return 0.0;
 
     if (*Buffer == '-' || *Buffer == '+') {
@@ -869,6 +869,14 @@
 
 
         // Next line
+        case '\r':
+            NextCh(it8);
+            if (it8 ->ch == '\n')
+                NextCh(it8);
+            it8->sy = SEOLN;
+            it8->lineno++;
+            break;
+
         case '\n':
             NextCh(it8);
             it8->sy = SEOLN;
@@ -878,7 +886,7 @@
         // Comment
         case '#':
             NextCh(it8);
-            while (it8->ch && it8->ch != '\n')
+            while (it8->ch && it8->ch != '\n' && it8->ch != '\r')
                 NextCh(it8);
 
             it8->sy = SCOMMENT;
@@ -996,6 +1004,9 @@
 {
     switch (it8->sy) {
 
+    case SEOLN:   // Empty value
+                  Buffer[0]=0;
+                  break;
     case SIDENT:  strncpy(Buffer, it8->id, max);
                   Buffer[max-1]=0;
                   break;
@@ -1145,9 +1156,9 @@
         if (*Key != '#') { // Comments are ignored
 
             if (cmsstrcasecmp(Key, p->Keyword) == 0)
-                    break;
-        }
+                break;
         }
+    }
 
     if (p == NULL)
         return FALSE;
@@ -1157,11 +1168,13 @@
 
     for (; p != NULL; p = p->NextSubkey) {
 
+        if (p ->Subkey == NULL) continue;
+
         if (LastPtr) *LastPtr = p;
 
         if (cmsstrcasecmp(Subkey, p->Subkey) == 0)
-                    return TRUE;
-        }
+            return TRUE;
+    }
 
     return FALSE;
 }
@@ -1284,7 +1297,7 @@
 
      it8 ->nTable = nTable;
 
-     return nTable;
+     return (cmsInt32Number) nTable;
 }
 
 
@@ -1389,7 +1402,7 @@
     cmsIT8* it8 = (cmsIT8*) hIT8;
     char Buffer[1024];
 
-    sprintf(Buffer, "%d", Val);
+    sprintf(Buffer, "%u", Val);
 
     return AddToList(it8, &GetTable(it8)->HeaderList, cProp, NULL, Buffer, WRITE_HEXADECIMAL) != NULL;
 }
@@ -1426,6 +1439,8 @@
 {
     const char *v = cmsIT8GetProperty(hIT8, cProp);
 
+    if (v == NULL) return 0.0;
+
     return ParseFloatNumber(v);
 }
 
@@ -1458,7 +1473,7 @@
         t -> nSamples = 10;
         }
 
-    t -> DataFormat = (char**) AllocChunk (it8, (t->nSamples + 1) * sizeof(char *));
+    t -> DataFormat = (char**) AllocChunk (it8, ((cmsUInt32Number) t->nSamples + 1) * sizeof(char *));
     if (t->DataFormat == NULL) {
 
         SynError(it8, "AllocateDataFormat: Unable to allocate dataFormat array");
@@ -1514,7 +1529,7 @@
     t-> nSamples   = atoi(cmsIT8GetProperty(it8, "NUMBER_OF_FIELDS"));
     t-> nPatches   = atoi(cmsIT8GetProperty(it8, "NUMBER_OF_SETS"));
 
-    t-> Data = (char**)AllocChunk (it8, (t->nSamples + 1) * (t->nPatches + 1) *sizeof (char*));
+    t-> Data = (char**)AllocChunk (it8, ((cmsUInt32Number) t->nSamples + 1) * ((cmsUInt32Number) t->nPatches + 1) *sizeof (char*));
     if (t->Data == NULL) {
 
         SynError(it8, "AllocateDataSet: Unable to allocate data array");
@@ -1573,7 +1588,7 @@
     if (str == NULL)
         str = " ";
 
-    // Lenghth to write
+    // Length to write
     len = (cmsUInt32Number) strlen(str);
     f ->Used += len;
 
@@ -2097,7 +2112,7 @@
                                          NextCh(it8);
 
                                      // If a newline is found, then this is a type string
-                                    if (it8 ->ch == '\n') {
+                                    if (it8 ->ch == '\n' || it8->ch == '\r') {
 
                                          cmsIT8SetSheetType(it8, it8 ->id);
                                          InSymbol(it8);
@@ -2212,7 +2227,7 @@
                                         char Buffer[256];
 
                                         char *Type  = p ->Value;
-                                        int  nTable = k;
+                                        int  nTable = (int) k;
 
                                         snprintf(Buffer, 255, "%s %d %s", Label, nTable, Type );
 
@@ -2566,6 +2581,8 @@
 
     Buffer = cmsIT8GetDataRowCol(hIT8, row, col);
 
+    if (Buffer == NULL) return 0.0;
+
     return ParseFloatNumber(Buffer);
 }
 
@@ -2778,7 +2795,7 @@
     if (Formatter == NULL)
         strcpy(it8->DoubleFormatter, DEFAULT_DBL_FORMAT);
     else
-        strcpy(it8->DoubleFormatter, Formatter);
+        strncpy(it8->DoubleFormatter, Formatter, sizeof(it8->DoubleFormatter));
 
     it8 ->DoubleFormatter[sizeof(it8 ->DoubleFormatter)-1] = 0;
 }
--- jdk/src/share/native/sun/java2d/cmm/lcms/cmscnvrt.c
+++ jdk/src/share/native/sun/java2d/cmm/lcms/cmscnvrt.c
@@ -270,7 +270,7 @@
             // m2 holds CHAD from output white to D50 times abs. col. scaling
 
             // Observer is not adapted, undo the chromatic adaptation
-            _cmsMAT3per(m, &m3, ChromaticAdaptationMatrixOut);
+            _cmsMAT3per(m, &m2, ChromaticAdaptationMatrixOut);
 
             m3 = *ChromaticAdaptationMatrixIn;
             if (!_cmsMAT3inverse(&m3, &m4)) return FALSE;
@@ -411,57 +411,61 @@
     // Handle PCS mismatches. A specialized stage is added to the LUT in such case
     switch (InPCS) {
 
-        case cmsSigXYZData: // Input profile operates in XYZ
+    case cmsSigXYZData: // Input profile operates in XYZ
 
-            switch (OutPCS) {
+        switch (OutPCS) {
 
-            case cmsSigXYZData:  // XYZ -> XYZ
-                if (!IsEmptyLayer(m, off))
-                    cmsPipelineInsertStage(Result, cmsAT_END, cmsStageAllocMatrix(Result ->ContextID, 3, 3, m_as_dbl, off_as_dbl));
-                break;
-
-            case cmsSigLabData:  // XYZ -> Lab
-                if (!IsEmptyLayer(m, off))
-                    cmsPipelineInsertStage(Result, cmsAT_END, cmsStageAllocMatrix(Result ->ContextID, 3, 3, m_as_dbl, off_as_dbl));
-                cmsPipelineInsertStage(Result, cmsAT_END, _cmsStageAllocXYZ2Lab(Result ->ContextID));
-                break;
-
-            default:
-                return FALSE;   // Colorspace mismatch
-                }
-                break;
+        case cmsSigXYZData:  // XYZ -> XYZ
+            if (!IsEmptyLayer(m, off) &&
+                !cmsPipelineInsertStage(Result, cmsAT_END, cmsStageAllocMatrix(Result ->ContextID, 3, 3, m_as_dbl, off_as_dbl)))
+                return FALSE;
+            break;
 
+        case cmsSigLabData:  // XYZ -> Lab
+            if (!IsEmptyLayer(m, off) &&
+                !cmsPipelineInsertStage(Result, cmsAT_END, cmsStageAllocMatrix(Result ->ContextID, 3, 3, m_as_dbl, off_as_dbl)))
+                return FALSE;
+            if (!cmsPipelineInsertStage(Result, cmsAT_END, _cmsStageAllocXYZ2Lab(Result ->ContextID)))
+                return FALSE;
+            break;
 
-        case cmsSigLabData: // Input profile operates in Lab
+        default:
+            return FALSE;   // Colorspace mismatch
+        }
+        break;
 
-            switch (OutPCS) {
+    case cmsSigLabData: // Input profile operates in Lab
 
-            case cmsSigXYZData:  // Lab -> XYZ
+        switch (OutPCS) {
 
-                cmsPipelineInsertStage(Result, cmsAT_END, _cmsStageAllocLab2XYZ(Result ->ContextID));
-                if (!IsEmptyLayer(m, off))
-                    cmsPipelineInsertStage(Result, cmsAT_END, cmsStageAllocMatrix(Result ->ContextID, 3, 3, m_as_dbl, off_as_dbl));
-                break;
+        case cmsSigXYZData:  // Lab -> XYZ
 
-            case cmsSigLabData:  // Lab -> Lab
+            if (!cmsPipelineInsertStage(Result, cmsAT_END, _cmsStageAllocLab2XYZ(Result ->ContextID)))
+                return FALSE;
+            if (!IsEmptyLayer(m, off) &&
+                !cmsPipelineInsertStage(Result, cmsAT_END, cmsStageAllocMatrix(Result ->ContextID, 3, 3, m_as_dbl, off_as_dbl)))
+                return FALSE;
+            break;
 
-                if (!IsEmptyLayer(m, off)) {
-                    cmsPipelineInsertStage(Result, cmsAT_END, _cmsStageAllocLab2XYZ(Result ->ContextID));
-                    cmsPipelineInsertStage(Result, cmsAT_END, cmsStageAllocMatrix(Result ->ContextID, 3, 3, m_as_dbl, off_as_dbl));
-                    cmsPipelineInsertStage(Result, cmsAT_END, _cmsStageAllocXYZ2Lab(Result ->ContextID));
-                }
-                break;
+        case cmsSigLabData:  // Lab -> Lab
 
-            default:
-                return FALSE;  // Mismatch
+            if (!IsEmptyLayer(m, off)) {
+                if (!cmsPipelineInsertStage(Result, cmsAT_END, _cmsStageAllocLab2XYZ(Result ->ContextID)) ||
+                    !cmsPipelineInsertStage(Result, cmsAT_END, cmsStageAllocMatrix(Result ->ContextID, 3, 3, m_as_dbl, off_as_dbl)) ||
+                    !cmsPipelineInsertStage(Result, cmsAT_END, _cmsStageAllocXYZ2Lab(Result ->ContextID)))
+                    return FALSE;
             }
             break;
 
-
-            // On colorspaces other than PCS, check for same space
         default:
-            if (InPCS != OutPCS) return FALSE;
-            break;
+            return FALSE;  // Mismatch
+        }
+        break;
+
+        // On colorspaces other than PCS, check for same space
+    default:
+        if (InPCS != OutPCS) return FALSE;
+        break;
     }
 
     return TRUE;
@@ -497,7 +501,8 @@
                                cmsFloat64Number AdaptationStates[],
                                cmsUInt32Number  dwFlags)
 {
-    cmsPipeline* Lut, *Result;
+    cmsPipeline* Lut = NULL;
+    cmsPipeline* Result;
     cmsHPROFILE hProfile;
     cmsMAT3 m;
     cmsVEC3 off;
@@ -593,8 +598,11 @@
         }
 
         // Concatenate to the output LUT
-        cmsPipelineCat(Result, Lut);
+        if (!cmsPipelineCat(Result, Lut))
+            goto Error;
+
         cmsPipelineFree(Lut);
+        Lut = NULL;
 
         // Update current space
         CurrentColorSpace = ColorSpaceOut;
@@ -604,6 +612,7 @@
 
 Error:
 
+    if (Lut != NULL) cmsPipelineFree(Lut);
     if (Result != NULL) cmsPipelineFree(Result);
     return NULL;
 
@@ -742,7 +751,8 @@
     if (CLUT == NULL) goto Error;
 
     // This is the one and only MPE in this LUT
-    cmsPipelineInsertStage(Result, cmsAT_BEGIN, CLUT);
+    if (!cmsPipelineInsertStage(Result, cmsAT_BEGIN, CLUT))
+        goto Error;
 
     // Sample it. We cannot afford pre/post linearization this time.
     if (!cmsStageSampleCLut16bit(CLUT, BlackPreservingGrayOnlySampler, (void*) &bp, 0))
@@ -959,7 +969,8 @@
     CLUT = cmsStageAllocCLut16bit(ContextID, nGridPoints, 4, 4, NULL);
     if (CLUT == NULL) goto Cleanup;
 
-    cmsPipelineInsertStage(Result, cmsAT_BEGIN, CLUT);
+    if (!cmsPipelineInsertStage(Result, cmsAT_BEGIN, CLUT))
+        goto Cleanup;
 
     cmsStageSampleCLut16bit(CLUT, BlackPreservingSampler, (void*) &bp, 0);
 
@@ -1057,7 +1068,7 @@
 }
 
 // The plug-in registration. User can add new intents or override default routines
-cmsBool  _cmsRegisterRenderingIntentPlugin(cmsPluginBase* Data)
+cmsBool  _cmsRegisterRenderingIntentPlugin(cmsContext id, cmsPluginBase* Data)
 {
     cmsPluginRenderingIntent* Plugin = (cmsPluginRenderingIntent*) Data;
     cmsIntentsList* fl;
@@ -1072,7 +1083,7 @@
     fl = SearchIntent(Plugin ->Intent);
 
     if (fl == NULL) {
-        fl = (cmsIntentsList*) _cmsPluginMalloc(sizeof(cmsIntentsList));
+        fl = (cmsIntentsList*) _cmsPluginMalloc(id, sizeof(cmsIntentsList));
         if (fl == NULL) return FALSE;
     }
 
--- jdk/src/share/native/sun/java2d/cmm/lcms/cmserr.c
+++ jdk/src/share/native/sun/java2d/cmm/lcms/cmserr.c
@@ -302,8 +302,6 @@
         return NULL;
     }
 
-
-
     chunk ->BlockSize = Initial;
     chunk ->Used      = 0;
     chunk ->next      = NULL;
--- jdk/src/share/native/sun/java2d/cmm/lcms/cmsgamma.c
+++ jdk/src/share/native/sun/java2d/cmm/lcms/cmsgamma.c
@@ -30,7 +30,7 @@
 //---------------------------------------------------------------------------------
 //
 //  Little Color Management System
-//  Copyright (c) 1998-2012 Marti Maria Saguer
+//  Copyright (c) 1998-2013 Marti Maria Saguer
 //
 // Permission is hereby granted, free of charge, to any person obtaining
 // a copy of this software and associated documentation files (the "Software"),
@@ -99,7 +99,7 @@
 static _cmsParametricCurvesCollection* ParametricCurves = &DefaultCurves;
 
 // As a way to install new parametric curves
-cmsBool _cmsRegisterParametricCurvesPlugin(cmsPluginBase* Data)
+cmsBool _cmsRegisterParametricCurvesPlugin(cmsContext id, cmsPluginBase* Data)
 {
     cmsPluginParametricCurves* Plugin = (cmsPluginParametricCurves*) Data;
     _cmsParametricCurvesCollection* fl;
@@ -110,7 +110,7 @@
           return TRUE;
     }
 
-    fl = (_cmsParametricCurvesCollection*) _cmsPluginMalloc(sizeof(_cmsParametricCurvesCollection));
+    fl = (_cmsParametricCurvesCollection*) _cmsPluginMalloc(id, sizeof(_cmsParametricCurvesCollection));
     if (fl == NULL) return FALSE;
 
     // Copy the parameters
@@ -258,7 +258,8 @@
     }
 
     p ->InterpParams = _cmsComputeInterpParams(ContextID, p ->nEntries, 1, 1, p->Table16, CMS_LERP_FLAGS_16BITS);
-    return p;
+    if (p->InterpParams != NULL)
+        return p;
 
 Error:
     if (p -> Segments) _cmsFree(ContextID, p ->Segments);
@@ -423,7 +424,7 @@
             if (e > 0)
                 Val = pow(e, Params[0]) + Params[5];
             else
-                Val = 0;
+                Val = Params[5];
         }
         else
             Val = R*Params[3] + Params[6];
@@ -458,7 +459,7 @@
         e = Params[1]*R + Params[2];
 
         if (e < 0)
-            Val = 0;
+            Val = Params[3];
         else
             Val = pow(e, Params[0]) + Params[3];
         break;
@@ -478,7 +479,7 @@
 
        e = Params[2] * pow(R, Params[0]) + Params[3];
        if (e <= 0)
-           Val = 0;
+           Val = Params[4];
        else
            Val = Params[1]*log10(e) + Params[4];
        break;
@@ -544,7 +545,7 @@
             // Type == 0 means segment is sampled
             if (g ->Segments[i].Type == 0) {
 
-                cmsFloat32Number R1 = (cmsFloat32Number) (R - g ->Segments[i].x0);
+                cmsFloat32Number R1 = (cmsFloat32Number) (R - g ->Segments[i].x0) / (g ->Segments[i].x1 - g ->Segments[i].x0);
                 cmsFloat32Number Out;
 
                 // Setup the table (TODO: clean that)
@@ -629,20 +630,21 @@
 // Use a segmented curve to store the floating point table
 cmsToneCurve* CMSEXPORT cmsBuildTabulatedToneCurveFloat(cmsContext ContextID, cmsUInt32Number nEntries, const cmsFloat32Number values[])
 {
-    cmsCurveSegment Seg[2];
+    cmsCurveSegment Seg[3];
 
-    // Initialize segmented curve part up to 0
-    Seg[0].x0 = -1;
+    // A segmented tone curve should have function segments in the first and last positions
+    // Initialize segmented curve part up to 0 to constant value = samples[0]
+    Seg[0].x0 = MINUS_INF;
     Seg[0].x1 = 0;
     Seg[0].Type = 6;
 
     Seg[0].Params[0] = 1;
     Seg[0].Params[1] = 0;
     Seg[0].Params[2] = 0;
-    Seg[0].Params[3] = 0;
+    Seg[0].Params[3] = values[0];
     Seg[0].Params[4] = 0;
 
-    // From zero to any
+    // From zero to 1
     Seg[1].x0 = 0;
     Seg[1].x1 = 1.0;
     Seg[1].Type = 0;
@@ -650,7 +652,19 @@
     Seg[1].nGridPoints = nEntries;
     Seg[1].SampledPoints = (cmsFloat32Number*) values;
 
-    return cmsBuildSegmentedToneCurve(ContextID, 2, Seg);
+    // Final segment is constant = lastsample
+    Seg[2].x0 = 1.0;
+    Seg[2].x1 = PLUS_INF;
+    Seg[2].Type = 6;
+
+    Seg[2].Params[0] = 1;
+    Seg[2].Params[1] = 0;
+    Seg[2].Params[2] = 0;
+    Seg[2].Params[3] = values[nEntries-1];
+    Seg[2].Params[4] = 0;
+
+
+    return cmsBuildSegmentedToneCurve(ContextID, 3, Seg);
 }
 
 // Parametric curves
@@ -993,7 +1007,7 @@
 
     if (Tab == NULL) return FALSE;
 
-    if (cmsIsToneCurveLinear(Tab)) return FALSE; // Nothing to do
+    if (cmsIsToneCurveLinear(Tab)) return TRUE; // Nothing to do
 
     nItems = Tab -> nEntries;
 
@@ -1020,11 +1034,20 @@
 
         if (z[i] == 0.) Zeros++;
         if (z[i] >= 65535.) Poles++;
-        if (z[i] < z[i-1]) return FALSE; // Non-Monotonic
+        if (z[i] < z[i-1]) {
+            cmsSignalError(Tab ->InterpParams->ContextID, cmsERROR_RANGE, "cmsSmoothToneCurve: Non-Monotonic.");
+            return FALSE;
+        }
     }
 
-    if (Zeros > (nItems / 3)) return FALSE;  // Degenerated, mostly zeros
-    if (Poles > (nItems / 3)) return FALSE;  // Degenerated, mostly poles
+    if (Zeros > (nItems / 3)) {
+        cmsSignalError(Tab ->InterpParams->ContextID, cmsERROR_RANGE, "cmsSmoothToneCurve: Degenerated, mostly zeros.");
+        return FALSE;
+    }
+    if (Poles > (nItems / 3)) {
+        cmsSignalError(Tab ->InterpParams->ContextID, cmsERROR_RANGE, "cmsSmoothToneCurve: Degenerated, mostly poles.");
+        return FALSE;
+    }
 
     // Seems ok
     for (i=0; i < nItems; i++) {
--- jdk/src/share/native/sun/java2d/cmm/lcms/cmsgmt.c
+++ jdk/src/share/native/sun/java2d/cmm/lcms/cmsgmt.c
@@ -249,13 +249,10 @@
     cmsFloat64Number dE1, dE2, ErrorRatio;
 
     // Assume in-gamut by default.
-    dE1 = 0.;
-    dE2 = 0;
     ErrorRatio = 1.0;
 
     // Convert input to Lab
-    if (t -> hInput != NULL)
-        cmsDoTransform(t -> hInput, In, &LabIn1, 1);
+    cmsDoTransform(t -> hInput, In, &LabIn1, 1);
 
     // converts from PCS to colorant. This always
     // does return in-gamut values,
@@ -267,7 +264,7 @@
     memmove(&LabIn2, &LabOut1, sizeof(cmsCIELab));
 
     // Try again, but this time taking Check as input
-    cmsDoTransform(t -> hForward, &LabOut1, Proof2,  1);
+    cmsDoTransform(t -> hForward, &LabOut1, Proof2, 1);
     cmsDoTransform(t -> hReverse, Proof2, &LabOut2, 1);
 
     // Take difference of direct value
@@ -374,7 +371,7 @@
     ProfileList[nGamutPCSposition] = hLab;
     BPCList[nGamutPCSposition] = 0;
     AdaptationList[nGamutPCSposition] = 1.0;
-    Intents[nGamutPCSposition] = INTENT_RELATIVE_COLORIMETRIC;
+    IntentList[nGamutPCSposition] = INTENT_RELATIVE_COLORIMETRIC;
 
 
     ColorSpace  = cmsGetColorSpace(hGamut);
@@ -385,45 +382,48 @@
 
     // 16 bits to Lab double
     Chain.hInput = cmsCreateExtendedTransform(ContextID,
-                                              nGamutPCSposition + 1,
-                                              ProfileList,
-                                              BPCList,
-                                              Intents,
-                                              AdaptationList,
-                                              NULL, 0,
-                                              dwFormat, TYPE_Lab_DBL,
-                                              cmsFLAGS_NOCACHE);
+        nGamutPCSposition + 1,
+        ProfileList,
+        BPCList,
+        IntentList,
+        AdaptationList,
+        NULL, 0,
+        dwFormat, TYPE_Lab_DBL,
+        cmsFLAGS_NOCACHE);
 
 
     // Does create the forward step. Lab double to device
     dwFormat    = (CHANNELS_SH(nChannels)|BYTES_SH(2));
     Chain.hForward = cmsCreateTransformTHR(ContextID,
-                                           hLab, TYPE_Lab_DBL,
-                                           hGamut, dwFormat,
-                                           INTENT_RELATIVE_COLORIMETRIC,
-                                           cmsFLAGS_NOCACHE);
+        hLab, TYPE_Lab_DBL,
+        hGamut, dwFormat,
+        INTENT_RELATIVE_COLORIMETRIC,
+        cmsFLAGS_NOCACHE);
 
     // Does create the backwards step
     Chain.hReverse = cmsCreateTransformTHR(ContextID, hGamut, dwFormat,
-                                           hLab, TYPE_Lab_DBL,
-                                           INTENT_RELATIVE_COLORIMETRIC,
-                                           cmsFLAGS_NOCACHE);
+        hLab, TYPE_Lab_DBL,
+        INTENT_RELATIVE_COLORIMETRIC,
+        cmsFLAGS_NOCACHE);
 
 
     // All ok?
-    if (Chain.hForward && Chain.hReverse) {
+    if (Chain.hInput && Chain.hForward && Chain.hReverse) {
 
         // Go on, try to compute gamut LUT from PCS. This consist on a single channel containing
         // dE when doing a transform back and forth on the colorimetric intent.
 
         Gamut = cmsPipelineAlloc(ContextID, 3, 1);
-
         if (Gamut != NULL) {
 
-          CLUT = cmsStageAllocCLut16bit(ContextID, nGridpoints, nChannels, 1, NULL);
-          cmsPipelineInsertStage(Gamut, cmsAT_BEGIN, CLUT);
-
-          cmsStageSampleCLut16bit(CLUT, GamutSampler, (void*) &Chain, 0);
+            CLUT = cmsStageAllocCLut16bit(ContextID, nGridpoints, nChannels, 1, NULL);
+            if (!cmsPipelineInsertStage(Gamut, cmsAT_BEGIN, CLUT)) {
+                cmsPipelineFree(Gamut);
+                Gamut = NULL;
+            }
+            else {
+                cmsStageSampleCLut16bit(CLUT, GamutSampler, (void*) &Chain, 0);
+            }
         }
     }
     else
--- jdk/src/share/native/sun/java2d/cmm/lcms/cmsintrp.c
+++ jdk/src/share/native/sun/java2d/cmm/lcms/cmsintrp.c
@@ -83,7 +83,6 @@
 
 
 // Set the interpolation method
-
 cmsBool _cmsSetInterpolationRoutine(cmsInterpParams* p)
 {
     // Invoke factory, possibly in the Plug-in
@@ -831,7 +830,7 @@
                      register cmsUInt16Number Output[],
                      register const cmsInterpParams* p16)
 {
-    const cmsUInt16Number* LutTable = (cmsUInt16Number*) p16 -> Table;
+    const cmsUInt16Number* LutTable;
     cmsS15Fixed16Number fk;
     cmsS15Fixed16Number k0, rk;
     int K0, K1;
--- jdk/src/share/native/sun/java2d/cmm/lcms/cmsio0.c
+++ jdk/src/share/native/sun/java2d/cmm/lcms/cmsio0.c
@@ -154,7 +154,6 @@
     return iohandler;
 
 Error:
-    if (fm) _cmsFree(ContextID, fm);
     if (iohandler) _cmsFree(ContextID, iohandler);
     return NULL;
 
@@ -223,12 +222,17 @@
 
 // Writes data to memory, also keeps used space for further reference.
 static
-cmsBool  MemoryWrite(struct _cms_io_handler* iohandler, cmsUInt32Number size, const void *Ptr)
+cmsBool MemoryWrite(struct _cms_io_handler* iohandler, cmsUInt32Number size, const void *Ptr)
 {
     FILEMEM* ResData = (FILEMEM*) iohandler ->stream;
 
     if (ResData == NULL) return FALSE; // Housekeeping
 
+    // Check for available space. Clip.
+    if (iohandler ->UsedSpace + size > ResData->Size) {
+        size = ResData ->Size - iohandler ->UsedSpace;
+    }
+
     if (size == 0) return TRUE;     // Write zero bytes is ok, but does nothing
 
     memmove(ResData ->Block + ResData ->Pointer, Ptr, size);
@@ -350,7 +354,7 @@
     return nReaded;
 }
 
-// Position file pointer in the file
+// Postion file pointer in the file
 static
 cmsBool  FileSeek(cmsIOHANDLER* iohandler, cmsUInt32Number offset)
 {
@@ -389,13 +393,15 @@
     return TRUE;
 }
 
-// Create a iohandler for disk based files. if FileName is NULL, then 'stream' member is also set
-// to NULL and no real writting is performed. This only happens in writting access mode
+// Create a iohandler for disk based files.
 cmsIOHANDLER* CMSEXPORT cmsOpenIOhandlerFromFile(cmsContext ContextID, const char* FileName, const char* AccessMode)
 {
     cmsIOHANDLER* iohandler = NULL;
     FILE* fm = NULL;
 
+    _cmsAssert(FileName != NULL);
+    _cmsAssert(AccessMode != NULL);
+
     iohandler = (cmsIOHANDLER*) _cmsMallocZero(ContextID, sizeof(cmsIOHANDLER));
     if (iohandler == NULL) return NULL;
 
@@ -432,11 +438,8 @@
     iohandler ->UsedSpace = 0;
 
     // Keep track of the original file
-    if (FileName != NULL)  {
-
-        strncpy(iohandler -> PhysicalFile, FileName, sizeof(iohandler -> PhysicalFile)-1);
-        iohandler -> PhysicalFile[sizeof(iohandler -> PhysicalFile)-1] = 0;
-    }
+    strncpy(iohandler -> PhysicalFile, FileName, sizeof(iohandler -> PhysicalFile)-1);
+    iohandler -> PhysicalFile[sizeof(iohandler -> PhysicalFile)-1] = 0;
 
     iohandler ->Read    = FileRead;
     iohandler ->Seek    = FileSeek;
@@ -616,6 +619,31 @@
        return _cmsSearchTag(Icc, sig, FALSE) >= 0;
 }
 
+/*
+ * Enforces that the profile version is per. spec.
+ * Operates on the big endian bytes from the profile.
+ * Called before converting to platform endianness.
+ * Byte 0 is BCD major version, so max 9.
+ * Byte 1 is 2 BCD digits, one per nibble.
+ * Reserved bytes 2 & 3 must be 0.
+ */
+static cmsUInt32Number _validatedVersion(cmsUInt32Number DWord)
+{
+    cmsUInt8Number* pByte = (cmsUInt8Number*)&DWord;
+    cmsUInt8Number temp1;
+    cmsUInt8Number temp2;
+
+    if (*pByte > 0x09) *pByte = (cmsUInt8Number)9;
+    temp1 = *(pByte+1) & 0xf0;
+    temp2 = *(pByte+1) & 0x0f;
+    if (temp1 > 0x90) temp1 = 0x90;
+    if (temp2 > 9) temp2 = 0x09;
+    *(pByte+1) = (cmsUInt8Number)(temp1 | temp2);
+    *(pByte+2) = (cmsUInt8Number)0;
+    *(pByte+3) = (cmsUInt8Number)0;
+
+    return DWord;
+}
 
 // Read profile header and validate it
 cmsBool _cmsReadHeader(_cmsICCPROFILE* Icc)
@@ -643,12 +671,15 @@
     Icc -> DeviceClass     = (cmsProfileClassSignature) _cmsAdjustEndianess32(Header.deviceClass);
     Icc -> ColorSpace      = (cmsColorSpaceSignature)   _cmsAdjustEndianess32(Header.colorSpace);
     Icc -> PCS             = (cmsColorSpaceSignature)   _cmsAdjustEndianess32(Header.pcs);
+
     Icc -> RenderingIntent = _cmsAdjustEndianess32(Header.renderingIntent);
     Icc -> flags           = _cmsAdjustEndianess32(Header.flags);
     Icc -> manufacturer    = _cmsAdjustEndianess32(Header.manufacturer);
     Icc -> model           = _cmsAdjustEndianess32(Header.model);
+    Icc -> creator         = _cmsAdjustEndianess32(Header.creator);
+
     _cmsAdjustEndianess64(&Icc -> attributes, &Header.attributes);
-    Icc -> Version         = _cmsAdjustEndianess32(Header.version);
+    Icc -> Version         = _cmsAdjustEndianess32(_validatedVersion(Header.version));
 
     // Get size as reported in header
     HeaderSize = _cmsAdjustEndianess32(Header.size);
@@ -815,28 +846,33 @@
 cmsUInt32Number CMSEXPORT cmsGetHeaderManufacturer(cmsHPROFILE hProfile)
 {
     _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;
-    return (cmsUInt32Number) Icc ->manufacturer;
+    return Icc ->manufacturer;
 }
 
 void CMSEXPORT cmsSetHeaderManufacturer(cmsHPROFILE hProfile, cmsUInt32Number manufacturer)
 {
     _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;
-    Icc -> manufacturer = (cmsUInt32Number) manufacturer;
+    Icc -> manufacturer = manufacturer;
+}
+
+cmsUInt32Number CMSEXPORT cmsGetHeaderCreator(cmsHPROFILE hProfile)
+{
+    _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;
+    return Icc ->creator;
 }
 
 cmsUInt32Number CMSEXPORT cmsGetHeaderModel(cmsHPROFILE hProfile)
 {
     _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;
-    return (cmsUInt32Number) Icc ->model;
+    return Icc ->model;
 }
 
 void CMSEXPORT cmsSetHeaderModel(cmsHPROFILE hProfile, cmsUInt32Number model)
 {
     _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;
-    Icc -> model = (cmsUInt32Number) model;
+    Icc -> model = model;
 }
 
-
 void CMSEXPORT cmsGetHeaderAttributes(cmsHPROFILE hProfile, cmsUInt64Number* Flags)
 {
     _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;
@@ -1073,7 +1109,6 @@
     return cmsOpenProfileFromMemTHR(NULL, MemPtr, dwSize);
 }
 
-
 static
 cmsBool SanityCheck(_cmsICCPROFILE* profile)
 {
@@ -1112,11 +1147,13 @@
     cmsIOHANDLER* io = Icc ->IOhandler;
     cmsTagDescriptor* TagDescriptor;
     cmsTagTypeSignature TypeBase;
+    cmsTagTypeSignature Type;
     cmsTagTypeHandler* TypeHandler;
+    cmsFloat64Number   Version = cmsGetProfileVersion((cmsHPROFILE) Icc);
+    cmsTagTypeHandler LocalTypeHandler;
 
     for (i=0; i < Icc -> TagCount; i++) {
 
-
         if (Icc ->TagNames[i] == 0) continue;
 
         // Linked tags are not written
@@ -1168,7 +1205,16 @@
             TagDescriptor = _cmsGetTagDescriptor(Icc -> TagNames[i]);
             if (TagDescriptor == NULL) continue;                        // Unsupported, ignore it
 
-            TypeHandler = Icc ->TagTypeHandlers[i];
+            if (TagDescriptor ->DecideType != NULL) {
+
+                Type = TagDescriptor ->DecideType(Version, Data);
+            }
+            else {
+
+                Type = TagDescriptor ->SupportedTypes[0];
+            }
+
+            TypeHandler =  _cmsGetTagTypeHandler(Type);
 
             if (TypeHandler == NULL) {
                 cmsSignalError(Icc ->ContextID, cmsERROR_INTERNAL, "(Internal) no handler for tag %x", Icc -> TagNames[i]);
@@ -1179,9 +1225,10 @@
             if (!_cmsWriteTypeBase(io, TypeBase))
                 return FALSE;
 
-            TypeHandler ->ContextID  = Icc ->ContextID;
-            TypeHandler ->ICCVersion = Icc ->Version;
-            if (!TypeHandler ->WritePtr(TypeHandler, io, Data, TagDescriptor ->ElemCount)) {
+            LocalTypeHandler = *TypeHandler;
+            LocalTypeHandler.ContextID  = Icc ->ContextID;
+            LocalTypeHandler.ICCVersion = Icc ->Version;
+            if (!LocalTypeHandler.WritePtr(&LocalTypeHandler, io, Data, TagDescriptor ->ElemCount)) {
 
                 char String[5];
 
@@ -1318,8 +1365,8 @@
     // Should we just calculate the needed space?
     if (MemPtr == NULL) {
 
-        *BytesNeeded = cmsSaveProfileToIOhandler(hProfile, NULL);
-        return (*BytesNeeded == 0 ? FALSE : TRUE);
+           *BytesNeeded =  cmsSaveProfileToIOhandler(hProfile, NULL);
+            return (*BytesNeeded == 0 ? FALSE : TRUE);
     }
 
     // That is a real write operation
@@ -1357,10 +1404,11 @@
             cmsTagTypeHandler* TypeHandler = Icc ->TagTypeHandlers[i];
 
             if (TypeHandler != NULL) {
+                cmsTagTypeHandler LocalTypeHandler = *TypeHandler;
 
-                TypeHandler ->ContextID = Icc ->ContextID;              // As an additional parameters
-                TypeHandler ->ICCVersion = Icc ->Version;
-                TypeHandler ->FreePtr(TypeHandler, Icc -> TagPtrs[i]);
+                LocalTypeHandler.ContextID = Icc ->ContextID;              // As an additional parameters
+                LocalTypeHandler.ICCVersion = Icc ->Version;
+                LocalTypeHandler.FreePtr(&LocalTypeHandler, Icc -> TagPtrs[i]);
             }
             else
                 _cmsFree(Icc ->ContextID, Icc ->TagPtrs[i]);
@@ -1404,6 +1452,7 @@
     _cmsICCPROFILE* Icc = (_cmsICCPROFILE*) hProfile;
     cmsIOHANDLER* io = Icc ->IOhandler;
     cmsTagTypeHandler* TypeHandler;
+    cmsTagTypeHandler LocalTypeHandler;
     cmsTagDescriptor*  TagDescriptor;
     cmsTagTypeSignature BaseType;
     cmsUInt32Number Offset, TagSize;
@@ -1427,7 +1476,7 @@
 
     // Seek to its location
     if (!io -> Seek(io, Offset))
-            return NULL;
+        return NULL;
 
     // Search for support on this tag
     TagDescriptor = _cmsGetTagDescriptor(sig);
@@ -1444,14 +1493,15 @@
     // Get type handler
     TypeHandler = _cmsGetTagTypeHandler(BaseType);
     if (TypeHandler == NULL) return NULL;
+    LocalTypeHandler = *TypeHandler;
 
 
     // Read the tag
     Icc -> TagTypeHandlers[n] = TypeHandler;
 
-    TypeHandler ->ContextID = Icc ->ContextID;
-    TypeHandler ->ICCVersion = Icc ->Version;
-    Icc -> TagPtrs[n] = TypeHandler ->ReadPtr(TypeHandler, io, &ElemCount, TagSize);
+    LocalTypeHandler.ContextID = Icc ->ContextID;
+    LocalTypeHandler.ICCVersion = Icc ->Version;
+    Icc -> TagPtrs[n] = LocalTypeHandler.ReadPtr(&LocalTypeHandler, io, &ElemCount, TagSize);
 
     // The tag type is supported, but something wrong happend and we cannot read the tag.
     // let know the user about this (although it is just a warning)
@@ -1472,7 +1522,7 @@
 
         _cmsTagSignature2String(String, sig);
         cmsSignalError(Icc ->ContextID, cmsERROR_CORRUPTION_DETECTED, "'%s' Inconsistent number of items: expected %d, got %d",
-                                                             String, TagDescriptor ->ElemCount, ElemCount);
+            String, TagDescriptor ->ElemCount, ElemCount);
     }
 
 
@@ -1504,6 +1554,7 @@
 {
     _cmsICCPROFILE* Icc = (_cmsICCPROFILE*) hProfile;
     cmsTagTypeHandler* TypeHandler = NULL;
+    cmsTagTypeHandler LocalTypeHandler;
     cmsTagDescriptor* TagDescriptor = NULL;
     cmsTagTypeSignature Type;
     int i;
@@ -1534,9 +1585,10 @@
 
                 if (TypeHandler != NULL) {
 
-                    TypeHandler ->ContextID = Icc ->ContextID;              // As an additional parameter
-                    TypeHandler ->ICCVersion = Icc ->Version;
-                    TypeHandler->FreePtr(TypeHandler, Icc -> TagPtrs[i]);
+                    LocalTypeHandler = *TypeHandler;
+                    LocalTypeHandler.ContextID = Icc ->ContextID;              // As an additional parameter
+                    LocalTypeHandler.ICCVersion = Icc ->Version;
+                    LocalTypeHandler.FreePtr(&LocalTypeHandler, Icc -> TagPtrs[i]);
                 }
             }
         }
@@ -1575,7 +1627,7 @@
         // Let the tag descriptor to decide the type base on depending on
         // the data. This is useful for example on parametric curves, where
         // curves specified by a table cannot be saved as parametric and needs
-        // to be revented to single v2-curves, even on v4 profiles.
+        // to be casted to single v2-curves, even on v4 profiles.
 
         Type = TagDescriptor ->DecideType(Version, data);
     }
@@ -1613,9 +1665,10 @@
     Icc ->TagSizes[i]         = 0;
     Icc ->TagOffsets[i]       = 0;
 
-    TypeHandler ->ContextID  = Icc ->ContextID;
-    TypeHandler ->ICCVersion = Icc ->Version;
-    Icc ->TagPtrs[i]         = TypeHandler ->DupPtr(TypeHandler, data, TagDescriptor ->ElemCount);
+    LocalTypeHandler = *TypeHandler;
+    LocalTypeHandler.ContextID  = Icc ->ContextID;
+    LocalTypeHandler.ICCVersion = Icc ->Version;
+    Icc ->TagPtrs[i]         = LocalTypeHandler.DupPtr(&LocalTypeHandler, data, TagDescriptor ->ElemCount);
 
     if (Icc ->TagPtrs[i] == NULL)  {
 
@@ -1642,6 +1695,7 @@
     int i;
     cmsIOHANDLER* MemIO;
     cmsTagTypeHandler* TypeHandler = NULL;
+    cmsTagTypeHandler LocalTypeHandler;
     cmsTagDescriptor* TagDescriptor = NULL;
     cmsUInt32Number rc;
     cmsUInt32Number Offset, TagSize;
@@ -1657,15 +1711,16 @@
         Offset   = Icc ->TagOffsets[i];
         TagSize  = Icc ->TagSizes[i];
 
-
         // read the data directly, don't keep copy
         if (data != NULL) {
 
             if (BufferSize < TagSize)
-                 TagSize = BufferSize;
+                TagSize = BufferSize;
 
             if (!Icc ->IOhandler ->Seek(Icc ->IOhandler, Offset)) return 0;
             if (!Icc ->IOhandler ->Read(Icc ->IOhandler, data, 1, TagSize)) return 0;
+
+            return TagSize;
         }
 
         return Icc ->TagSizes[i];
@@ -1679,9 +1734,11 @@
 
             TagSize  = Icc ->TagSizes[i];
             if (BufferSize < TagSize)
-                       TagSize = BufferSize;
+                TagSize = BufferSize;
 
             memmove(data, Icc ->TagPtrs[i], TagSize);
+
+            return TagSize;
         }
 
         return Icc ->TagSizes[i];
@@ -1697,7 +1754,7 @@
     if (data == NULL) {
         MemIO = cmsOpenIOhandlerFromNULL(cmsGetProfileContextID(hProfile));
     } else{
-      MemIO = cmsOpenIOhandlerFromMem(cmsGetProfileContextID(hProfile), data, BufferSize, "w");
+        MemIO = cmsOpenIOhandlerFromMem(cmsGetProfileContextID(hProfile), data, BufferSize, "w");
     }
     if (MemIO == NULL) return 0;
 
@@ -1705,20 +1762,22 @@
     TypeHandler = Icc ->TagTypeHandlers[i];
     TagDescriptor = _cmsGetTagDescriptor(sig);
     if (TagDescriptor == NULL) {
-         cmsCloseIOhandler(MemIO);
-         return 0;
+        cmsCloseIOhandler(MemIO);
+        return 0;
     }
 
+    // FIXME: No handling for TypeHandler == NULL here?
     // Serialize
-    TypeHandler ->ContextID  = Icc ->ContextID;
-    TypeHandler ->ICCVersion = Icc ->Version;
+    LocalTypeHandler = *TypeHandler;
+    LocalTypeHandler.ContextID  = Icc ->ContextID;
+    LocalTypeHandler.ICCVersion = Icc ->Version;
 
     if (!_cmsWriteTypeBase(MemIO, TypeHandler ->Signature)) {
         cmsCloseIOhandler(MemIO);
         return 0;
     }
 
-    if (!TypeHandler ->WritePtr(TypeHandler, MemIO, Object, TagDescriptor ->ElemCount)) {
+    if (!LocalTypeHandler.WritePtr(&LocalTypeHandler, MemIO, Object, TagDescriptor ->ElemCount)) {
         cmsCloseIOhandler(MemIO);
         return 0;
     }
@@ -1756,7 +1815,7 @@
 // Using this function you can collapse several tag entries to the same block in the profile
 cmsBool CMSEXPORT cmsLinkTag(cmsHPROFILE hProfile, cmsTagSignature sig, cmsTagSignature dest)
 {
-     _cmsICCPROFILE* Icc = (_cmsICCPROFILE*) hProfile;
+    _cmsICCPROFILE* Icc = (_cmsICCPROFILE*) hProfile;
     int i;
 
     if (!_cmsNewTag(Icc, sig, &i)) return FALSE;
--- jdk/src/share/native/sun/java2d/cmm/lcms/cmsio1.c
+++ jdk/src/share/native/sun/java2d/cmm/lcms/cmsio1.c
@@ -129,7 +129,6 @@
     Tag = (cmsMAT3*) cmsReadTag(hProfile, cmsSigChromaticAdaptationTag);
 
     if (Tag != NULL) {
-
         *Dest = *Tag;
         return TRUE;
     }
@@ -193,7 +192,8 @@
     if (GrayTRC == NULL) return NULL;
 
     Lut = cmsPipelineAlloc(ContextID, 1, 3);
-    if (Lut == NULL) return NULL;
+    if (Lut == NULL)
+        goto Error;
 
     if (cmsGetPCS(hProfile) == cmsSigLabData) {
 
@@ -204,28 +204,35 @@
 
         EmptyTab = cmsBuildTabulatedToneCurve16(ContextID, 2, Zero);
 
-        if (EmptyTab == NULL) {
-
-                 cmsPipelineFree(Lut);
-                 return NULL;
-        }
+        if (EmptyTab == NULL)
+            goto Error;
 
         LabCurves[0] = GrayTRC;
         LabCurves[1] = EmptyTab;
         LabCurves[2] = EmptyTab;
 
-        cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocMatrix(ContextID, 3,  1, OneToThreeInputMatrix, NULL));
-        cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocToneCurves(ContextID, 3, LabCurves));
+        if (!cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocMatrix(ContextID, 3,  1, OneToThreeInputMatrix, NULL)) ||
+            !cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocToneCurves(ContextID, 3, LabCurves))) {
+                cmsFreeToneCurve(EmptyTab);
+                goto Error;
+        }
 
         cmsFreeToneCurve(EmptyTab);
 
     }
     else  {
-       cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocToneCurves(ContextID, 1, &GrayTRC));
-       cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocMatrix(ContextID, 3,  1, GrayInputMatrix, NULL));
+
+        if (!cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocToneCurves(ContextID, 1, &GrayTRC)) ||
+            !cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocMatrix(ContextID, 3,  1, GrayInputMatrix, NULL)))
+            goto Error;
     }
 
     return Lut;
+
+Error:
+    cmsFreeToneCurve(GrayTRC);
+    cmsPipelineFree(Lut);
+    return NULL;
 }
 
 // RGB Matrix shaper
@@ -259,49 +266,31 @@
     Lut = cmsPipelineAlloc(ContextID, 3, 3);
     if (Lut != NULL) {
 
-        cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocToneCurves(ContextID, 3, Shapes));
-        cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocMatrix(ContextID, 3, 3, (cmsFloat64Number*) &Mat, NULL));
+        if (!cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocToneCurves(ContextID, 3, Shapes)) ||
+            !cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocMatrix(ContextID, 3, 3, (cmsFloat64Number*) &Mat, NULL)))
+            goto Error;
 
         // Note that it is certainly possible a single profile would have a LUT based
         // tag for output working in lab and a matrix-shaper for the fallback cases.
         // This is not allowed by the spec, but this code is tolerant to those cases
         if (cmsGetPCS(hProfile) == cmsSigLabData) {
 
-             cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageAllocXYZ2Lab(ContextID));
+            if (!cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageAllocXYZ2Lab(ContextID)))
+                goto Error;
         }
 
     }
 
     return Lut;
+
+Error:
+    cmsPipelineFree(Lut);
+    return NULL;
 }
 
 
 
 // Read the DToAX tag, adjusting the encoding of Lab or XYZ if neded
-/*static
-cmsPipeline* _cmsReadFloatInputTag(cmsHPROFILE hProfile, cmsTagSignature tagFloat)
-{
-    cmsContext ContextID       = cmsGetProfileContextID(hProfile);
-    cmsPipeline* Lut           = cmsPipelineDup((cmsPipeline*) cmsReadTag(hProfile, tagFloat));
-    cmsColorSpaceSignature spc = cmsGetColorSpace(hProfile);
-
-    if (Lut == NULL) return NULL;
-
-    // If PCS is Lab or XYZ, the floating point tag is accepting data in the space encoding,
-    // and since the formatter has already accomodated to 0..1.0, we should undo this change
-    if ( spc == cmsSigLabData)
-    {
-        cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageNormalizeFromLabFloat(ContextID));
-    }
-    else
-        if (spc == cmsSigXYZData)
-        {
-            cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageNormalizeFromXyzFloat(ContextID));
-        }
-
-    return Lut;
-}
-*/
 static
 cmsPipeline* _cmsReadFloatInputTag(cmsHPROFILE hProfile, cmsTagSignature tagFloat)
 {
@@ -316,23 +305,31 @@
     //  these need to be normalized into the appropriate ranges (Lab = 100,0,0, XYZ=1.0,1.0,1.0)
     if ( spc == cmsSigLabData)
     {
-        cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageNormalizeToLabFloat(ContextID));
+        if (!cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageNormalizeToLabFloat(ContextID)))
+            goto Error;
     }
     else if (spc == cmsSigXYZData)
     {
-        cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageNormalizeToXyzFloat(ContextID));
+        if (!cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageNormalizeToXyzFloat(ContextID)))
+            goto Error;
     }
 
     if ( PCS == cmsSigLabData)
     {
-        cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageNormalizeFromLabFloat(ContextID));
+        if (!cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageNormalizeFromLabFloat(ContextID)))
+            goto Error;
     }
     else if( PCS == cmsSigXYZData)
     {
-        cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageNormalizeFromXyzFloat(ContextID));
+        if (!cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageNormalizeFromXyzFloat(ContextID)))
+            goto Error;
     }
 
     return Lut;
+
+Error:
+    cmsPipelineFree(Lut);
+    return NULL;
 }
 
 
@@ -359,8 +356,11 @@
             return NULL;
         }
 
-        cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageAllocNamedColor(nc, TRUE));
-        cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageAllocLabV2ToV4(ContextID));
+        if (!cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageAllocNamedColor(nc, TRUE)) ||
+            !cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageAllocLabV2ToV4(ContextID))) {
+            cmsPipelineFree(Lut);
+            return NULL;
+        }
         return Lut;
     }
 
@@ -395,12 +395,18 @@
             return Lut;
 
         // If the input is Lab, add also a conversion at the begin
-        if (cmsGetColorSpace(hProfile) == cmsSigLabData)
-            cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageAllocLabV4ToV2(ContextID));
+        if (cmsGetColorSpace(hProfile) == cmsSigLabData &&
+            !cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageAllocLabV4ToV2(ContextID)))
+            goto Error;
 
         // Add a matrix for conversion V2 to V4 Lab PCS
-        cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageAllocLabV2ToV4(ContextID));
+        if (!cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageAllocLabV2ToV4(ContextID)))
+            goto Error;
+
         return Lut;
+Error:
+        cmsPipelineFree(Lut);
+        return NULL;
     }
 
     // Lut was not found, try to create a matrix-shaper
@@ -445,19 +451,25 @@
 
     if (cmsGetPCS(hProfile) == cmsSigLabData) {
 
-        cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocMatrix(ContextID, 1,  3, PickLstarMatrix, NULL));
+        if (!cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocMatrix(ContextID, 1,  3, PickLstarMatrix, NULL)))
+            goto Error;
     }
     else  {
-        cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocMatrix(ContextID, 1,  3, PickYMatrix, NULL));
+        if (!cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocMatrix(ContextID, 1,  3, PickYMatrix, NULL)))
+            goto Error;
     }
 
-    cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocToneCurves(ContextID, 1, &RevGrayTRC));
-    cmsFreeToneCurve(RevGrayTRC);
+    if (!cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocToneCurves(ContextID, 1, &RevGrayTRC)))
+        goto Error;
 
+    cmsFreeToneCurve(RevGrayTRC);
     return Lut;
-}
-
 
+Error:
+    cmsFreeToneCurve(RevGrayTRC);
+    cmsPipelineFree(Lut);
+    return NULL;
+}
 
 
 static
@@ -506,15 +518,21 @@
         // This is not allowed by the spec, but this code is tolerant to those cases
         if (cmsGetPCS(hProfile) == cmsSigLabData) {
 
-             cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageAllocLab2XYZ(ContextID));
+            if (!cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageAllocLab2XYZ(ContextID)))
+                goto Error;
         }
 
-        cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocMatrix(ContextID, 3, 3, (cmsFloat64Number*) &Inv, NULL));
-        cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocToneCurves(ContextID, 3, InvShapes));
+        if (!cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocMatrix(ContextID, 3, 3, (cmsFloat64Number*) &Inv, NULL)) ||
+            !cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocToneCurves(ContextID, 3, InvShapes)))
+            goto Error;
     }
 
     cmsFreeToneCurveTriple(InvShapes);
     return Lut;
+Error:
+    cmsFreeToneCurveTriple(InvShapes);
+    cmsPipelineFree(Lut);
+    return NULL;
 }
 
 
@@ -540,30 +558,6 @@
 
 
 // Read the DToAX tag, adjusting the encoding of Lab or XYZ if neded
-/*static
-cmsPipeline* _cmsReadFloatOutputTag(cmsHPROFILE hProfile, cmsTagSignature tagFloat)
-{
-    cmsContext ContextID       = cmsGetProfileContextID(hProfile);
-    cmsPipeline* Lut           = cmsPipelineDup((cmsPipeline*) cmsReadTag(hProfile, tagFloat));
-    cmsColorSpaceSignature PCS = cmsGetPCS(hProfile);
-
-    if (Lut == NULL) return NULL;
-
-    // If PCS is Lab or XYZ, the floating point tag is accepting data in the space encoding,
-    // and since the formatter has already accomodated to 0..1.0, we should undo this change
-    if ( PCS == cmsSigLabData)
-    {
-        cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageNormalizeToLabFloat(ContextID));
-    }
-    else
-        if (PCS == cmsSigXYZData)
-        {
-            cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageNormalizeToXyzFloat(ContextID));
-        }
-
-    return Lut;
-}*/
-
 static
 cmsPipeline* _cmsReadFloatOutputTag(cmsHPROFILE hProfile, cmsTagSignature tagFloat)
 {
@@ -578,25 +572,33 @@
     // and since the formatter has already accomodated to 0..1.0, we should undo this change
     if ( PCS == cmsSigLabData)
     {
-        cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageNormalizeToLabFloat(ContextID));
+        if (!cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageNormalizeToLabFloat(ContextID)))
+            goto Error;
     }
     else
         if (PCS == cmsSigXYZData)
         {
-            cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageNormalizeToXyzFloat(ContextID));
+            if (!cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageNormalizeToXyzFloat(ContextID)))
+                goto Error;
         }
 
     // the output can be Lab or XYZ, in which case normalisation is needed on the end of the pipeline
     if ( dataSpace == cmsSigLabData)
     {
-        cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageNormalizeFromLabFloat(ContextID));
+        if (!cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageNormalizeFromLabFloat(ContextID)))
+            goto Error;
     }
-    else if ( dataSpace == cmsSigXYZData)
+    else if (dataSpace == cmsSigXYZData)
     {
-        cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageNormalizeFromXyzFloat(ContextID));
+        if (!cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageNormalizeFromXyzFloat(ContextID)))
+            goto Error;
     }
 
     return Lut;
+
+Error:
+    cmsPipelineFree(Lut);
+    return NULL;
 }
 
 // Create an output MPE LUT from agiven profile. Version mismatches are handled here
@@ -636,30 +638,35 @@
         // Now it is time for a controversial stuff. I found that for 3D LUTS using
         // Lab used as indexer space,  trilinear interpolation should be used
         if (cmsGetPCS(hProfile) == cmsSigLabData)
-                             ChangeInterpolationToTrilinear(Lut);
+            ChangeInterpolationToTrilinear(Lut);
 
         // We need to adjust data only for Lab and Lut16 type
         if (OriginalType != cmsSigLut16Type || cmsGetPCS(hProfile) != cmsSigLabData)
             return Lut;
 
         // Add a matrix for conversion V4 to V2 Lab PCS
-        cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageAllocLabV4ToV2(ContextID));
+        if (!cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageAllocLabV4ToV2(ContextID)))
+            goto Error;
 
         // If the output is Lab, add also a conversion at the end
         if (cmsGetColorSpace(hProfile) == cmsSigLabData)
-            cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageAllocLabV2ToV4(ContextID));
+            if (!cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageAllocLabV2ToV4(ContextID)))
+                goto Error;
 
         return Lut;
+Error:
+        cmsPipelineFree(Lut);
+        return NULL;
     }
 
     // Lut not found, try to create a matrix-shaper
 
     // Check if this is a grayscale profile.
-     if (cmsGetColorSpace(hProfile) == cmsSigGrayData) {
+    if (cmsGetColorSpace(hProfile) == cmsSigGrayData) {
 
-              // if so, build appropiate conversion tables.
-              // The tables are the PCS iluminant, scaled across GrayTRC
-              return BuildGrayOutputPipeline(hProfile);
+        // if so, build appropiate conversion tables.
+        // The tables are the PCS iluminant, scaled across GrayTRC
+        return BuildGrayOutputPipeline(hProfile);
     }
 
     // Not gray, create a normal matrix-shaper, which only operates in XYZ space
@@ -681,25 +688,32 @@
 
     if (spc == cmsSigLabData)
     {
-        cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageNormalizeToLabFloat(ContextID));
+        if (!cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageNormalizeToLabFloat(ContextID)))
+            goto Error;
     }
     else
         if (spc == cmsSigXYZData)
         {
-            cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageNormalizeToXyzFloat(ContextID));
+            if (!cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageNormalizeToXyzFloat(ContextID)))
+                goto Error;
         }
 
         if (PCS == cmsSigLabData)
         {
-            cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageNormalizeFromLabFloat(ContextID));
+            if (!cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageNormalizeFromLabFloat(ContextID)))
+                goto Error;
         }
         else
             if (PCS == cmsSigXYZData)
             {
-                cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageNormalizeFromXyzFloat(ContextID));
+                if (!cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageNormalizeFromXyzFloat(ContextID)))
+                    goto Error;
             }
 
-            return Lut;
+    return Lut;
+Error:
+    cmsPipelineFree(Lut);
+    return NULL;
 }
 
 // This one includes abstract profiles as well. Matrix-shaper cannot be obtained on that device class. The
@@ -721,15 +735,21 @@
         if (nc == NULL) return NULL;
 
         Lut = cmsPipelineAlloc(ContextID, 0, 0);
-        if (Lut == NULL) {
-            cmsFreeNamedColorList(nc);
-            return NULL;
-        }
+        if (Lut == NULL)
+            goto Error;
+
+        if (!cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageAllocNamedColor(nc, FALSE)))
+            goto Error;
 
-        cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageAllocNamedColor(nc, FALSE));
         if (cmsGetColorSpace(hProfile) == cmsSigLabData)
-              cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageAllocLabV2ToV4(ContextID));
+            if (!cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageAllocLabV2ToV4(ContextID)))
+                goto Error;
+
         return Lut;
+Error:
+        cmsPipelineFree(Lut);
+        cmsFreeNamedColorList(nc);
+        return NULL;
     }
 
     if (cmsIsTag(hProfile, tagFloat)) {  // Float tag takes precedence
@@ -760,10 +780,10 @@
     Lut = cmsPipelineDup(Lut);
     if (Lut == NULL) return NULL;
 
-     // Now it is time for a controversial stuff. I found that for 3D LUTS using
-     // Lab used as indexer space,  trilinear interpolation should be used
+    // Now it is time for a controversial stuff. I found that for 3D LUTS using
+    // Lab used as indexer space,  trilinear interpolation should be used
     if (cmsGetColorSpace(hProfile) == cmsSigLabData)
-                        ChangeInterpolationToTrilinear(Lut);
+        ChangeInterpolationToTrilinear(Lut);
 
     // After reading it, we have info about the original type
     OriginalType =  _cmsGetTagTrueType(hProfile, tag16);
@@ -774,16 +794,20 @@
     // Here it is possible to get Lab on both sides
 
     if (cmsGetPCS(hProfile) == cmsSigLabData) {
-            cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageAllocLabV4ToV2(ContextID));
+        if(!cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageAllocLabV4ToV2(ContextID)))
+            goto Error2;
     }
 
     if (cmsGetColorSpace(hProfile) == cmsSigLabData) {
-            cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageAllocLabV2ToV4(ContextID));
+        if(!cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageAllocLabV2ToV4(ContextID)))
+            goto Error2;
     }
 
     return Lut;
 
-
+Error2:
+    cmsPipelineFree(Lut);
+    return NULL;
 }
 
 // ---------------------------------------------------------------------------------------------------------------
--- jdk/src/share/native/sun/java2d/cmm/lcms/cmslut.c
+++ jdk/src/share/native/sun/java2d/cmm/lcms/cmslut.c
@@ -264,10 +264,10 @@
     if (NewElem ->TheCurves != NULL) {
         for (i=0; i < NewElem ->nCurves; i++) {
             if (NewElem ->TheCurves[i])
-                cmsFreeToneCurve(Data ->TheCurves[i]);
+                cmsFreeToneCurve(NewElem ->TheCurves[i]);
         }
     }
-    _cmsFree(mpe ->ContextID, Data ->TheCurves);
+    _cmsFree(mpe ->ContextID, NewElem ->TheCurves);
     _cmsFree(mpe ->ContextID, NewElem);
     return NULL;
 }
@@ -392,6 +392,8 @@
 void MatrixElemTypeFree(cmsStage* mpe)
 {
     _cmsStageMatrixData* Data = (_cmsStageMatrixData*) mpe ->Data;
+    if (Data == NULL)
+        return;
     if (Data ->Double)
         _cmsFree(mpe ->ContextID, Data ->Double);
 
@@ -526,10 +528,15 @@
 
     if (Data ->Tab.T) {
 
-        if (Data ->HasFloatValues)
+        if (Data ->HasFloatValues) {
             NewElem ->Tab.TFloat = (cmsFloat32Number*) _cmsDupMem(mpe ->ContextID, Data ->Tab.TFloat, Data ->nEntries * sizeof (cmsFloat32Number));
-        else
+            if (NewElem ->Tab.TFloat == NULL)
+                goto Error;
+        } else {
             NewElem ->Tab.T = (cmsUInt16Number*) _cmsDupMem(mpe ->ContextID, Data ->Tab.T, Data ->nEntries * sizeof (cmsUInt16Number));
+            if (NewElem ->Tab.TFloat == NULL)
+                goto Error;
+        }
     }
 
     NewElem ->Params   = _cmsComputeInterpParamsEx(mpe ->ContextID,
@@ -538,8 +545,14 @@
                                                    Data ->Params ->nOutputs,
                                                    NewElem ->Tab.T,
                                                    Data ->Params ->dwFlags);
-
-    return (void*) NewElem;
+    if (NewElem->Params != NULL)
+        return (void*) NewElem;
+ Error:
+    if (NewElem->Tab.T)
+        // This works for both types
+        _cmsFree(mpe ->ContextID, NewElem -> Tab.T);
+    _cmsFree(mpe ->ContextID, NewElem);
+    return NULL;
 }
 
 
@@ -636,7 +649,6 @@
     for (i=0; i < MAX_INPUT_DIMENSIONS; i++)
         Dimensions[i] = nGridPoints;
 
-
     return cmsStageAllocCLut16bitGranular(ContextID, Dimensions, inputChan, outputChan, Table);
 }
 
@@ -706,15 +718,12 @@
         }
     }
 
-
     NewElem ->Params = _cmsComputeInterpParamsEx(ContextID, clutPoints,  inputChan, outputChan, NewElem ->Tab.TFloat, CMS_LERP_FLAGS_FLOAT);
     if (NewElem ->Params == NULL) {
         cmsStageFree(NewMPE);
         return NULL;
     }
 
-
-
     return NewMPE;
 }
 
@@ -772,7 +781,7 @@
     int i, t, nTotalPoints, index, rest;
     int nInputs, nOutputs;
     cmsUInt32Number* nSamples;
-    cmsUInt16Number In[cmsMAXCHANNELS], Out[MAX_STAGE_CHANNELS];
+    cmsUInt16Number In[MAX_INPUT_DIMENSIONS+1], Out[MAX_STAGE_CHANNELS];
     _cmsStageCLutData* clut;
 
     if (mpe == NULL) return FALSE;
@@ -785,7 +794,9 @@
     nInputs  = clut->Params ->nInputs;
     nOutputs = clut->Params ->nOutputs;
 
-    if (nInputs >= cmsMAXCHANNELS) return FALSE;
+    if (nInputs <= 0) return FALSE;
+    if (nOutputs <= 0) return FALSE;
+    if (nInputs > MAX_INPUT_DIMENSIONS) return FALSE;
     if (nOutputs >= MAX_STAGE_CHANNELS) return FALSE;
 
     nTotalPoints = CubeSize(nSamples, nInputs);
@@ -832,14 +843,16 @@
     int i, t, nTotalPoints, index, rest;
     int nInputs, nOutputs;
     cmsUInt32Number* nSamples;
-    cmsFloat32Number In[cmsMAXCHANNELS], Out[MAX_STAGE_CHANNELS];
+    cmsFloat32Number In[MAX_INPUT_DIMENSIONS+1], Out[MAX_STAGE_CHANNELS];
     _cmsStageCLutData* clut = (_cmsStageCLutData*) mpe->Data;
 
     nSamples = clut->Params ->nSamples;
     nInputs  = clut->Params ->nInputs;
     nOutputs = clut->Params ->nOutputs;
 
-    if (nInputs >= cmsMAXCHANNELS) return FALSE;
+    if (nInputs <= 0) return FALSE;
+    if (nOutputs <= 0) return FALSE;
+    if (nInputs  > MAX_INPUT_DIMENSIONS) return FALSE;
     if (nOutputs >= MAX_STAGE_CHANNELS) return FALSE;
 
     nTotalPoints = CubeSize(nSamples, nInputs);
@@ -1021,8 +1034,7 @@
     mpe = cmsStageAllocToneCurves(ContextID, 3, LabTable);
     cmsFreeToneCurveTriple(LabTable);
 
-    if (mpe == NULL) return mpe;
-
+    if (mpe == NULL) return NULL;
     mpe ->Implements = cmsSigLabV2toV4;
     return mpe;
 }
@@ -1248,12 +1260,22 @@
                                      NULL);
     if (NewMPE == NULL) return NULL;
 
-    NewMPE ->Implements     = mpe ->Implements;
+    NewMPE ->Implements = mpe ->Implements;
+
+    if (mpe ->DupElemPtr) {
+
+        NewMPE ->Data = mpe ->DupElemPtr(mpe);
+
+        if (NewMPE->Data == NULL) {
+
+            cmsStageFree(NewMPE);
+            return NULL;
+        }
+
+    } else {
 
-    if (mpe ->DupElemPtr)
-        NewMPE ->Data       = mpe ->DupElemPtr(mpe);
-    else
         NewMPE ->Data       = NULL;
+    }
 
     return NewMPE;
 }
@@ -1266,7 +1288,7 @@
 static
 void BlessLUT(cmsPipeline* lut)
 {
-    // We can set the input/output channels only if we have elements.
+    // We can set the input/ouput channels only if we have elements.
     if (lut ->Elements != NULL) {
 
         cmsStage *First, *Last;
@@ -1466,12 +1488,12 @@
 }
 
 
-void CMSEXPORT cmsPipelineInsertStage(cmsPipeline* lut, cmsStageLoc loc, cmsStage* mpe)
+int CMSEXPORT cmsPipelineInsertStage(cmsPipeline* lut, cmsStageLoc loc, cmsStage* mpe)
 {
     cmsStage* Anterior = NULL, *pt;
 
-    _cmsAssert(lut != NULL);
-    _cmsAssert(mpe != NULL);
+    if (lut == NULL || mpe == NULL)
+        return FALSE;
 
     switch (loc) {
 
@@ -1495,9 +1517,11 @@
             }
             break;
         default:;
+            return FALSE;
     }
 
     BlessLUT(lut);
+    return TRUE;
 }
 
 // Unlink an element and return the pointer to it
@@ -1559,7 +1583,7 @@
 // Concatenate two LUT into a new single one
 cmsBool  CMSEXPORT cmsPipelineCat(cmsPipeline* l1, const cmsPipeline* l2)
 {
-    cmsStage* mpe, *NewMPE;
+    cmsStage* mpe;
 
     // If both LUTS does not have elements, we need to inherit
     // the number of channels
@@ -1574,17 +1598,12 @@
          mpe = mpe ->Next) {
 
             // We have to dup each element
-             NewMPE = cmsStageDup(mpe);
-
-             if (NewMPE == NULL) {
-                 return FALSE;
-             }
-
-             cmsPipelineInsertStage(l1, cmsAT_END, NewMPE);
+            if (!cmsPipelineInsertStage(l1, cmsAT_END, cmsStageDup(mpe)))
+                return FALSE;
     }
 
-  BlessLUT(l1);
-  return TRUE;
+    BlessLUT(l1);
+    return TRUE;
 }
 
 
@@ -1714,16 +1733,11 @@
     cmsFloat32Number  fx[4], x[4], xd[4], fxd[4];
     cmsVEC3 tmp, tmp2;
     cmsMAT3 Jacobian;
-    cmsFloat64Number LastResult[4];
-
 
     // Only 3->3 and 4->3 are supported
     if (lut ->InputChannels != 3 && lut ->InputChannels != 4) return FALSE;
     if (lut ->OutputChannels != 3) return FALSE;
 
-    // Mark result of -1
-    LastResult[0] = LastResult[1] = LastResult[2] = -1.0f;
-
     // Take the hint as starting point if specified
     if (Hint == NULL) {
 
--- jdk/src/share/native/sun/java2d/cmm/lcms/cmsmd5.c
+++ jdk/src/share/native/sun/java2d/cmm/lcms/cmsmd5.c
@@ -338,7 +338,7 @@
 Error:
 
     // Free resources as something went wrong
-    if (MD5 != NULL) _cmsFree(ContextID, MD5);
+    // "MD5" cannot be other than NULL here, so no need to free it
     if (Mem != NULL) _cmsFree(ContextID, Mem);
     memmove(Icc, &Keep, sizeof(_cmsICCPROFILE));
     return FALSE;
--- jdk/src/share/native/sun/java2d/cmm/lcms/cmsnamed.c
+++ jdk/src/share/native/sun/java2d/cmm/lcms/cmsnamed.c
@@ -359,9 +359,9 @@
     if (Best == -1)
         Best = 0;
 
-     v = mlu ->Entries + Best;
+    v = mlu ->Entries + Best;
 
-     if (UsedLanguageCode != NULL) *UsedLanguageCode = v ->Language;
+    if (UsedLanguageCode != NULL) *UsedLanguageCode = v ->Language;
     if (UsedCountryCode  != NULL) *UsedCountryCode = v ->Country;
 
     if (len != NULL) *len   = v ->Len;
@@ -475,6 +475,35 @@
 }
 
 
+
+// Get the number of translations in the MLU object
+cmsUInt32Number CMSEXPORT cmsMLUtranslationsCount(const cmsMLU* mlu)
+{
+    if (mlu == NULL) return 0;
+    return mlu->UsedEntries;
+}
+
+// Get the language and country codes for a specific MLU index
+cmsBool CMSEXPORT cmsMLUtranslationsCodes(const cmsMLU* mlu,
+                                          cmsUInt32Number idx,
+                                          char LanguageCode[3],
+                                          char CountryCode[3])
+{
+    _cmsMLUentry *entry;
+
+    if (mlu == NULL) return FALSE;
+
+    if (idx >= (cmsUInt32Number) mlu->UsedEntries) return FALSE;
+
+    entry = &mlu->Entries[idx];
+
+    *(cmsUInt16Number *)LanguageCode = _cmsAdjustEndianess16(entry->Language);
+    *(cmsUInt16Number *)CountryCode  = _cmsAdjustEndianess16(entry->Country);
+
+    return TRUE;
+}
+
+
 // Named color lists --------------------------------------------------------------------------------------------
 
 // Grow the list to keep at least NumElements
@@ -517,9 +546,9 @@
     while (v -> Allocated < n)
         GrowNamedColorList(v);
 
-    strncpy(v ->Prefix, Prefix, sizeof(v ->Prefix) - 1);
-    strncpy(v ->Suffix, Suffix, sizeof(v ->Suffix) - 1);
-    v->Prefix[sizeof(v ->Prefix) - 1] = v->Suffix[sizeof(v ->Suffix) - 1] = 0;
+    strncpy(v ->Prefix, Prefix, sizeof(v ->Prefix)-1);
+    strncpy(v ->Suffix, Suffix, sizeof(v ->Suffix)-1);
+    v->Prefix[32] = v->Suffix[32] = 0;
 
     v -> ColorantCount = ColorantCount;
 
@@ -529,8 +558,9 @@
 // Free a list
 void CMSEXPORT cmsFreeNamedColorList(cmsNAMEDCOLORLIST* v)
 {
+    if (v == NULL) return;
     if (v ->List) _cmsFree(v ->ContextID, v ->List);
-    if (v) _cmsFree(v ->ContextID, v);
+    _cmsFree(v ->ContextID, v);
 }
 
 cmsNAMEDCOLORLIST* CMSEXPORT cmsDupNamedColorList(const cmsNAMEDCOLORLIST* v)
@@ -576,11 +606,8 @@
 
     if (Name != NULL) {
 
-        strncpy(NamedColorList ->List[NamedColorList ->nColors].Name, Name,
-                    sizeof(NamedColorList ->List[NamedColorList ->nColors].Name) - 1);
-
-        NamedColorList ->List[NamedColorList ->nColors].
-            Name[sizeof(NamedColorList ->List[NamedColorList ->nColors].Name) - 1] = 0;
+        strncpy(NamedColorList ->List[NamedColorList ->nColors].Name, Name, cmsMAX_PATH-1);
+        NamedColorList ->List[NamedColorList ->nColors].Name[cmsMAX_PATH-1] = 0;
 
     }
     else
@@ -891,7 +918,6 @@
 {
     _cmsDICT* old_dict = (_cmsDICT*) hDict;
     cmsHANDLE hNew;
-    _cmsDICT* new_dict;
     cmsDICTentry *entry;
 
     _cmsAssert(old_dict != NULL);
@@ -899,8 +925,6 @@
     hNew  = cmsDictAlloc(old_dict ->ContextID);
     if (hNew == NULL) return NULL;
 
-    new_dict = (_cmsDICT*) hNew;
-
     // Walk the list freeing all nodes
     entry = old_dict ->head;
     while (entry != NULL) {
--- jdk/src/share/native/sun/java2d/cmm/lcms/cmsopt.c
+++ jdk/src/share/native/sun/java2d/cmm/lcms/cmsopt.c
@@ -27,6 +27,7 @@
 // However, the following notice accompanied the original version of this
 // file:
 //
+
 //---------------------------------------------------------------------------------
 //
 //  Little Color Management System
@@ -81,10 +82,6 @@
     int nInputs;
     int nOutputs;
 
-    // Since there is no limitation of the output number of channels, this buffer holding the connexion CLUT-shaper
-    // has to be dynamically allocated. This is not the case of first step shaper-CLUT, which is limited to max inputs
-    cmsUInt16Number* StageDEF;
-
     _cmsInterpFn16 EvalCurveIn16[MAX_INPUT_DIMENSIONS];       // The maximum number of input channels is known in advance
     cmsInterpParams*  ParamsCurveIn16[MAX_INPUT_DIMENSIONS];
 
@@ -202,8 +199,6 @@
 {
     cmsBool AnyOpt = FALSE, Opt;
 
-    AnyOpt = FALSE;
-
     do {
 
         Opt = FALSE;
@@ -253,6 +248,7 @@
 {
     Prelin16Data* p16 = (Prelin16Data*) D;
     cmsUInt16Number  StageABC[MAX_INPUT_DIMENSIONS];
+    cmsUInt16Number  StageDEF[cmsMAXCHANNELS];
     int i;
 
     for (i=0; i < p16 ->nInputs; i++) {
@@ -260,11 +256,11 @@
         p16 ->EvalCurveIn16[i](&Input[i], &StageABC[i], p16 ->ParamsCurveIn16[i]);
     }
 
-    p16 ->EvalCLUT(StageABC, p16 ->StageDEF, p16 ->CLUTparams);
+    p16 ->EvalCLUT(StageABC, StageDEF, p16 ->CLUTparams);
 
     for (i=0; i < p16 ->nOutputs; i++) {
 
-        p16 ->EvalCurveOut16[i](&p16->StageDEF[i], &Output[i], p16 ->ParamsCurveOut16[i]);
+        p16 ->EvalCurveOut16[i](&StageDEF[i], &Output[i], p16 ->ParamsCurveOut16[i]);
     }
 }
 
@@ -274,7 +270,6 @@
 {
     Prelin16Data* p16 = (Prelin16Data*) ptr;
 
-    _cmsFree(ContextID, p16 ->StageDEF);
     _cmsFree(ContextID, p16 ->EvalCurveOut16);
     _cmsFree(ContextID, p16 ->ParamsCurveOut16);
 
@@ -289,7 +284,6 @@
 
     if (Duped == NULL) return NULL;
 
-    Duped ->StageDEF         = _cmsCalloc(ContextID, p16 ->nOutputs, sizeof(cmsUInt16Number));
     Duped ->EvalCurveOut16   = _cmsDupMem(ContextID, p16 ->EvalCurveOut16, p16 ->nOutputs * sizeof(_cmsInterpFn16));
     Duped ->ParamsCurveOut16 = _cmsDupMem(ContextID, p16 ->ParamsCurveOut16, p16 ->nOutputs * sizeof(cmsInterpParams* ));
 
@@ -328,7 +322,6 @@
     p16 ->EvalCLUT   = ColorMap ->Interpolation.Lerp16;
 
 
-    p16 -> StageDEF = _cmsCalloc(ContextID, p16 ->nOutputs, sizeof(cmsUInt16Number));
     p16 -> EvalCurveOut16 = (_cmsInterpFn16*) _cmsCalloc(ContextID, nOutputs, sizeof(_cmsInterpFn16));
     p16 -> ParamsCurveOut16 = (cmsInterpParams**) _cmsCalloc(ContextID, nOutputs, sizeof(cmsInterpParams* ));
 
@@ -413,7 +406,7 @@
     int        i, index;
 
     if (CLUT -> Type != cmsSigCLutElemType) {
-        cmsSignalError(CLUT->ContextID, cmsERROR_INTERNAL, "(internal) Attempt to PatchLUT on non-lut MPE");
+        cmsSignalError(CLUT->ContextID, cmsERROR_INTERNAL, "(internal) Attempt to PatchLUT on non-lut stage");
         return FALSE;
     }
 
@@ -579,8 +572,8 @@
 static
 cmsBool OptimizeByResampling(cmsPipeline** Lut, cmsUInt32Number Intent, cmsUInt32Number* InputFormat, cmsUInt32Number* OutputFormat, cmsUInt32Number* dwFlags)
 {
-    cmsPipeline* Src;
-    cmsPipeline* Dest;
+    cmsPipeline* Src = NULL;
+    cmsPipeline* Dest = NULL;
     cmsStage* mpe;
     cmsStage* CLUT;
     cmsStage *KeepPreLin = NULL, *KeepPostLin = NULL;
@@ -593,7 +586,6 @@
     cmsToneCurve** DataSetOut;
     Prelin16Data* p16;
 
-
     // This is a loosy optimization! does not apply in floating-point cases
     if (_cmsFormatterIsFloat(*InputFormat) || _cmsFormatterIsFloat(*OutputFormat)) return FALSE;
 
@@ -607,10 +599,10 @@
 
     Src = *Lut;
 
-   // Named color pipelines cannot be optimized either
-   for (mpe = cmsPipelineGetPtrToFirstStage(Src);
-         mpe != NULL;
-         mpe = cmsStageNext(mpe)) {
+    // Named color pipelines cannot be optimized either
+    for (mpe = cmsPipelineGetPtrToFirstStage(Src);
+        mpe != NULL;
+        mpe = cmsStageNext(mpe)) {
             if (cmsStageType(mpe) == cmsSigNamedColorElemType) return FALSE;
     }
 
@@ -632,7 +624,8 @@
 
                 // All seems ok, proceed.
                 NewPreLin = cmsStageDup(PreLin);
-                cmsPipelineInsertStage(Dest, cmsAT_BEGIN, NewPreLin);
+                if(!cmsPipelineInsertStage(Dest, cmsAT_BEGIN, NewPreLin))
+                    goto Error;
 
                 // Remove prelinearization. Since we have duplicated the curve
                 // in destination LUT, the sampling shoud be applied after this stage.
@@ -646,7 +639,9 @@
     if (CLUT == NULL) return FALSE;
 
     // Add the CLUT to the destination LUT
-    cmsPipelineInsertStage(Dest, cmsAT_END, CLUT);
+    if (!cmsPipelineInsertStage(Dest, cmsAT_END, CLUT)) {
+        goto Error;
+    }
 
     // Postlinearization tables are kept unless indicated by flags
     if (*dwFlags & cmsFLAGS_CLUT_POST_LINEARIZATION) {
@@ -662,7 +657,8 @@
 
                 // All seems ok, proceed.
                 NewPostLin = cmsStageDup(PostLin);
-                cmsPipelineInsertStage(Dest, cmsAT_END, NewPostLin);
+                if (!cmsPipelineInsertStage(Dest, cmsAT_END, NewPostLin))
+                    goto Error;
 
                 // In destination LUT, the sampling shoud be applied after this stage.
                 cmsPipelineUnlinkStage(Src, cmsAT_END, &KeepPostLin);
@@ -673,10 +669,18 @@
     // Now its time to do the sampling. We have to ignore pre/post linearization
     // The source LUT whithout pre/post curves is passed as parameter.
     if (!cmsStageSampleCLut16bit(CLUT, XFormSampler16, (void*) Src, 0)) {
-
+Error:
         // Ops, something went wrong, Restore stages
-        if (KeepPreLin != NULL)  cmsPipelineInsertStage(Src, cmsAT_BEGIN, KeepPreLin);
-        if (KeepPostLin != NULL) cmsPipelineInsertStage(Src, cmsAT_END,   KeepPostLin);
+        if (KeepPreLin != NULL) {
+            if (!cmsPipelineInsertStage(Src, cmsAT_BEGIN, KeepPreLin)) {
+                _cmsAssert(0); // This never happens
+            }
+        }
+        if (KeepPostLin != NULL) {
+            if (!cmsPipelineInsertStage(Src, cmsAT_END,   KeepPostLin)) {
+                _cmsAssert(0); // This never happens
+            }
+        }
         cmsPipelineFree(Dest);
         return FALSE;
     }
@@ -703,12 +707,11 @@
     else {
 
         p16 = PrelinOpt16alloc(Dest ->ContextID,
-                               DataCLUT ->Params,
-                               Dest ->InputChannels,
-                               DataSetIn,
-                               Dest ->OutputChannels,
-                               DataSetOut);
-
+            DataCLUT ->Params,
+            Dest ->InputChannels,
+            DataSetIn,
+            Dest ->OutputChannels,
+            DataSetOut);
 
         _cmsPipelineSetOptimizationParameters(Dest, PrelinEval16, (void*) p16, PrelinOpt16free, Prelin16dup);
     }
@@ -1062,7 +1065,8 @@
     LutPlusCurves = cmsPipelineDup(OriginalLut);
     if (LutPlusCurves == NULL) goto Error;
 
-    cmsPipelineInsertStage(LutPlusCurves, cmsAT_BEGIN, cmsStageAllocToneCurves(OriginalLut ->ContextID, OriginalLut ->InputChannels, TransReverse));
+    if (!cmsPipelineInsertStage(LutPlusCurves, cmsAT_BEGIN, cmsStageAllocToneCurves(OriginalLut ->ContextID, OriginalLut ->InputChannels, TransReverse)))
+        goto Error;
 
     // Create the result LUT
     OptimizedLUT = cmsPipelineAlloc(OriginalLut ->ContextID, OriginalLut ->InputChannels, OriginalLut ->OutputChannels);
@@ -1071,13 +1075,15 @@
     OptimizedPrelinMpe = cmsStageAllocToneCurves(OriginalLut ->ContextID, OriginalLut ->InputChannels, Trans);
 
     // Create and insert the curves at the beginning
-    cmsPipelineInsertStage(OptimizedLUT, cmsAT_BEGIN, OptimizedPrelinMpe);
+    if (!cmsPipelineInsertStage(OptimizedLUT, cmsAT_BEGIN, OptimizedPrelinMpe))
+        goto Error;
 
     // Allocate the CLUT for result
     OptimizedCLUTmpe = cmsStageAllocCLut16bit(OriginalLut ->ContextID, nGridPoints, OriginalLut ->InputChannels, OriginalLut ->OutputChannels, NULL);
 
     // Add the CLUT to the destination LUT
-    cmsPipelineInsertStage(OptimizedLUT, cmsAT_END, OptimizedCLUTmpe);
+    if (!cmsPipelineInsertStage(OptimizedLUT, cmsAT_END, OptimizedCLUTmpe))
+        goto Error;
 
     // Resample the LUT
     if (!cmsStageSampleCLut16bit(OptimizedCLUTmpe, XFormSampler16, (void*) LutPlusCurves, 0)) goto Error;
@@ -1205,13 +1211,14 @@
     for (i=0; i < nCurves; i++) {
 
         c16->Curves[i] = _cmsCalloc(ContextID, nElements, sizeof(cmsUInt16Number));
+
         if (c16->Curves[i] == NULL) {
+
             for (j=0; j < i; j++) {
                 _cmsFree(ContextID, c16->Curves[j]);
             }
             _cmsFree(ContextID, c16->Curves);
             _cmsFree(ContextID, c16);
-
             return NULL;
         }
 
@@ -1340,7 +1347,8 @@
     // Maybe the curves are linear at the end
     if (!AllCurvesAreLinear(ObtainedCurves)) {
 
-        cmsPipelineInsertStage(Dest, cmsAT_BEGIN, ObtainedCurves);
+        if (!cmsPipelineInsertStage(Dest, cmsAT_BEGIN, ObtainedCurves))
+            goto Error;
 
         // If the curves are to be applied in 8 bits, we can save memory
         if (_cmsFormatterIs8bit(*InputFormat)) {
@@ -1348,6 +1356,7 @@
             _cmsStageToneCurvesData* Data = (_cmsStageToneCurvesData*) ObtainedCurves ->Data;
              Curves16Data* c16 = CurvesAlloc(Dest ->ContextID, Data ->nCurves, 256, Data ->TheCurves);
 
+             if (c16 == NULL) goto Error;
              *dwFlags |= cmsFLAGS_NOCACHE;
             _cmsPipelineSetOptimizationParameters(Dest, FastEvaluateCurves8, c16, CurvesFree, CurvesDup);
 
@@ -1357,6 +1366,7 @@
             _cmsStageToneCurvesData* Data = (_cmsStageToneCurvesData*) cmsStageData(ObtainedCurves);
              Curves16Data* c16 = CurvesAlloc(Dest ->ContextID, Data ->nCurves, 65536, Data ->TheCurves);
 
+             if (c16 == NULL) goto Error;
              *dwFlags |= cmsFLAGS_NOCACHE;
             _cmsPipelineSetOptimizationParameters(Dest, FastEvaluateCurves16, c16, CurvesFree, CurvesDup);
         }
@@ -1366,7 +1376,8 @@
         // LUT optimizes to nothing. Set the identity LUT
         cmsStageFree(ObtainedCurves);
 
-        cmsPipelineInsertStage(Dest, cmsAT_BEGIN, cmsStageAllocIdentity(Dest ->ContextID, Src ->InputChannels));
+        if (!cmsPipelineInsertStage(Dest, cmsAT_BEGIN, cmsStageAllocIdentity(Dest ->ContextID, Src ->InputChannels)))
+            goto Error;
 
         *dwFlags |= cmsFLAGS_NOCACHE;
         _cmsPipelineSetOptimizationParameters(Dest, FastIdentity16, (void*) Dest, NULL, NULL);
@@ -1596,10 +1607,14 @@
     if (!Dest) return FALSE;
 
     // Assamble the new LUT
-    cmsPipelineInsertStage(Dest, cmsAT_BEGIN, cmsStageDup(Curve1));
+    if (!cmsPipelineInsertStage(Dest, cmsAT_BEGIN, cmsStageDup(Curve1)))
+        goto Error;
+
     if (!IdentityMat)
-        cmsPipelineInsertStage(Dest, cmsAT_END, cmsStageAllocMatrix(Dest ->ContextID, 3, 3, (const cmsFloat64Number*) &res, Data2 ->Offset));
-    cmsPipelineInsertStage(Dest, cmsAT_END, cmsStageDup(Curve2));
+        if (!cmsPipelineInsertStage(Dest, cmsAT_END, cmsStageAllocMatrix(Dest ->ContextID, 3, 3, (const cmsFloat64Number*) &res, Data2 ->Offset)))
+            goto Error;
+    if (!cmsPipelineInsertStage(Dest, cmsAT_END, cmsStageDup(Curve2)))
+        goto Error;
 
     // If identity on matrix, we can further optimize the curves, so call the join curves routine
     if (IdentityMat) {
@@ -1621,6 +1636,10 @@
     cmsPipelineFree(Src);
     *Lut = Dest;
     return TRUE;
+Error:
+    // Leave Src unchanged
+    cmsPipelineFree(Dest);
+    return FALSE;
 }
 
 
@@ -1650,7 +1669,7 @@
 static _cmsOptimizationCollection* OptimizationCollection = DefaultOptimization;
 
 // Register new ways to optimize
-cmsBool  _cmsRegisterOptimizationPlugin(cmsPluginBase* Data)
+cmsBool  _cmsRegisterOptimizationPlugin(cmsContext id, cmsPluginBase* Data)
 {
     cmsPluginOptimization* Plugin = (cmsPluginOptimization*) Data;
     _cmsOptimizationCollection* fl;
@@ -1664,7 +1683,7 @@
     // Optimizer callback is required
     if (Plugin ->OptimizePtr == NULL) return FALSE;
 
-    fl = (_cmsOptimizationCollection*) _cmsPluginMalloc(sizeof(_cmsOptimizationCollection));
+    fl = (_cmsOptimizationCollection*) _cmsPluginMalloc(id, sizeof(_cmsOptimizationCollection));
     if (fl == NULL) return FALSE;
 
     // Copy the parameters
--- jdk/src/share/native/sun/java2d/cmm/lcms/cmspack.c
+++ jdk/src/share/native/sun/java2d/cmm/lcms/cmspack.c
@@ -317,6 +317,23 @@
 }
 
 static
+cmsUInt8Number* Unroll3BytesSkip1SwapSwapFirst(register _cmsTRANSFORM* info,
+                                              register cmsUInt16Number wIn[],
+                                              register cmsUInt8Number* accum,
+                                              register cmsUInt32Number Stride)
+{
+    wIn[2] = FROM_8_TO_16(*accum); accum++; // B
+    wIn[1] = FROM_8_TO_16(*accum); accum++; // G
+    wIn[0] = FROM_8_TO_16(*accum); accum++; // R
+    accum++; // A
+
+    return accum;
+
+    cmsUNUSED_PARAMETER(info);
+    cmsUNUSED_PARAMETER(Stride);
+}
+
+static
 cmsUInt8Number* Unroll3BytesSkip1SwapFirst(register _cmsTRANSFORM* info,
                                            register cmsUInt16Number wIn[],
                                            register cmsUInt8Number* accum,
@@ -2901,6 +2918,9 @@
     { CHANNELS_SH(3)|EXTRA_SH(1)|BYTES_SH(1)|DOSWAP_SH(1),     ANYSPACE,  Unroll3BytesSkip1Swap},
     { CHANNELS_SH(3)|EXTRA_SH(1)|BYTES_SH(1)|SWAPFIRST_SH(1),  ANYSPACE,  Unroll3BytesSkip1SwapFirst},
 
+    { CHANNELS_SH(3)|EXTRA_SH(1)|BYTES_SH(1)|DOSWAP_SH(1)|SWAPFIRST_SH(1),
+                                                               ANYSPACE,  Unroll3BytesSkip1SwapSwapFirst},
+
     { CHANNELS_SH(4)|BYTES_SH(1),                              ANYSPACE,  Unroll4Bytes},
     { CHANNELS_SH(4)|BYTES_SH(1)|FLAVOR_SH(1),                 ANYSPACE,  Unroll4BytesReverse},
     { CHANNELS_SH(4)|BYTES_SH(1)|SWAPFIRST_SH(1),              ANYSPACE,  Unroll4BytesSwapFirst},
@@ -3166,7 +3186,7 @@
 
 
 // Formatters management
-cmsBool  _cmsRegisterFormattersPlugin(cmsPluginBase* Data)
+cmsBool  _cmsRegisterFormattersPlugin(cmsContext id, cmsPluginBase* Data)
 {
     cmsPluginFormatters* Plugin = (cmsPluginFormatters*) Data;
     cmsFormattersFactoryList* fl ;
@@ -3178,7 +3198,7 @@
           return TRUE;
     }
 
-    fl = (cmsFormattersFactoryList*) _cmsPluginMalloc(sizeof(cmsFormattersFactoryList));
+    fl = (cmsFormattersFactoryList*) _cmsPluginMalloc(id, sizeof(cmsFormattersFactoryList));
     if (fl == NULL) return FALSE;
 
     fl ->Factory    = Plugin ->FormattersFactory;
--- jdk/src/share/native/sun/java2d/cmm/lcms/cmspcs.c
+++ jdk/src/share/native/sun/java2d/cmm/lcms/cmspcs.c
@@ -898,9 +898,11 @@
 {
     switch (ColorSpace) {
 
+    case cmsSigMCH1Data:
     case cmsSig1colorData:
     case cmsSigGrayData: return 1;
 
+    case cmsSigMCH2Data:
     case cmsSig2colorData:  return 2;
 
     case cmsSigXYZData:
@@ -912,10 +914,12 @@
     case cmsSigHsvData:
     case cmsSigHlsData:
     case cmsSigCmyData:
+    case cmsSigMCH3Data:
     case cmsSig3colorData:  return 3;
 
     case cmsSigLuvKData:
     case cmsSigCmykData:
+    case cmsSigMCH4Data:
     case cmsSig4colorData:  return 4;
 
     case cmsSigMCH5Data:
--- jdk/src/share/native/sun/java2d/cmm/lcms/cmsplugin.c
+++ jdk/src/share/native/sun/java2d/cmm/lcms/cmsplugin.c
@@ -125,10 +125,14 @@
     pOut[0] = pIn[7];
 
 #else
-
     _cmsAssert(Result != NULL);
 
+#  ifdef CMS_DONT_USE_INT64
+    (*Result)[0] = QWord[0];
+    (*Result)[1] = QWord[1];
+#  else
     *Result = *QWord;
+#  endif
 #endif
 }
 
@@ -543,10 +547,10 @@
 static _cmsSubAllocator* PluginPool = NULL;
 
 // Specialized malloc for plug-ins, that is freed upon exit.
-void* _cmsPluginMalloc(cmsUInt32Number size)
+void* _cmsPluginMalloc(cmsContext id, cmsUInt32Number size)
 {
     if (PluginPool == NULL)
-        PluginPool = _cmsCreateSubAlloc(0, 4*1024);
+        PluginPool = _cmsCreateSubAlloc(id, 4*1024);
 
     return _cmsSubAlloc(PluginPool, size);
 }
@@ -555,6 +559,11 @@
 // Main plug-in dispatcher
 cmsBool CMSEXPORT cmsPlugin(void* Plug_in)
 {
+  return cmsPluginTHR(NULL, Plug_in);
+}
+
+cmsBool CMSEXPORT cmsPluginTHR(cmsContext id, void* Plug_in)
+{
     cmsPluginBase* Plugin;
 
     for (Plugin = (cmsPluginBase*) Plug_in;
@@ -583,35 +592,35 @@
                     break;
 
                 case cmsPluginTagTypeSig:
-                    if (!_cmsRegisterTagTypePlugin(Plugin)) return FALSE;
+                    if (!_cmsRegisterTagTypePlugin(id, Plugin)) return FALSE;
                     break;
 
                 case cmsPluginTagSig:
-                    if (!_cmsRegisterTagPlugin(Plugin)) return FALSE;
+                    if (!_cmsRegisterTagPlugin(id, Plugin)) return FALSE;
                     break;
 
                 case cmsPluginFormattersSig:
-                    if (!_cmsRegisterFormattersPlugin(Plugin)) return FALSE;
+                    if (!_cmsRegisterFormattersPlugin(id, Plugin)) return FALSE;
                     break;
 
                 case cmsPluginRenderingIntentSig:
-                    if (!_cmsRegisterRenderingIntentPlugin(Plugin)) return FALSE;
+                    if (!_cmsRegisterRenderingIntentPlugin(id, Plugin)) return FALSE;
                     break;
 
                 case cmsPluginParametricCurveSig:
-                    if (!_cmsRegisterParametricCurvesPlugin(Plugin)) return FALSE;
+                    if (!_cmsRegisterParametricCurvesPlugin(id, Plugin)) return FALSE;
                     break;
 
                 case cmsPluginMultiProcessElementSig:
-                    if (!_cmsRegisterMultiProcessElementPlugin(Plugin)) return FALSE;
+                    if (!_cmsRegisterMultiProcessElementPlugin(id, Plugin)) return FALSE;
                     break;
 
                 case cmsPluginOptimizationSig:
-                    if (!_cmsRegisterOptimizationPlugin(Plugin)) return FALSE;
+                    if (!_cmsRegisterOptimizationPlugin(id, Plugin)) return FALSE;
                     break;
 
                 case cmsPluginTransformSig:
-                    if (!_cmsRegisterTransformPlugin(Plugin)) return FALSE;
+                    if (!_cmsRegisterTransformPlugin(id, Plugin)) return FALSE;
                     break;
 
                 default:
@@ -630,14 +639,14 @@
 {
     _cmsRegisterMemHandlerPlugin(NULL);
     _cmsRegisterInterpPlugin(NULL);
-    _cmsRegisterTagTypePlugin(NULL);
-    _cmsRegisterTagPlugin(NULL);
-    _cmsRegisterFormattersPlugin(NULL);
-    _cmsRegisterRenderingIntentPlugin(NULL);
-    _cmsRegisterParametricCurvesPlugin(NULL);
-    _cmsRegisterMultiProcessElementPlugin(NULL);
-    _cmsRegisterOptimizationPlugin(NULL);
-    _cmsRegisterTransformPlugin(NULL);
+    _cmsRegisterTagTypePlugin(NULL, NULL);
+    _cmsRegisterTagPlugin(NULL, NULL);
+    _cmsRegisterFormattersPlugin(NULL, NULL);
+    _cmsRegisterRenderingIntentPlugin(NULL, NULL);
+    _cmsRegisterParametricCurvesPlugin(NULL, NULL);
+    _cmsRegisterMultiProcessElementPlugin(NULL, NULL);
+    _cmsRegisterOptimizationPlugin(NULL, NULL);
+    _cmsRegisterTransformPlugin(NULL, NULL);
 
     if (PluginPool != NULL)
         _cmsSubAllocDestroy(PluginPool);
--- jdk/src/share/native/sun/java2d/cmm/lcms/cmsps2.c
+++ jdk/src/share/native/sun/java2d/cmm/lcms/cmsps2.c
@@ -806,7 +806,6 @@
 
     mpe = Pipeline ->Elements;
 
-
     switch (cmsStageInputChannels(mpe)) {
     case 3:
 
@@ -838,8 +837,6 @@
         mpe = mpe ->Next;
     }
 
-
-
     if (cmsStageType(mpe) == cmsSigCLutElemType) {
 
             _cmsIOPrintf(m, "/Table ");
@@ -854,7 +851,6 @@
     _cmsIOPrintf(m, "   >>\n");
     _cmsIOPrintf(m, "]\n");
 
-
     return 1;
 }
 
@@ -950,6 +946,7 @@
 
             rc = EmitCIEBasedDEF(m, DeviceLink, Intent, &BlackPointAdaptedToD50);
             cmsPipelineFree(DeviceLink);
+            if (rc == 0) return 0;
             }
             break;
 
--- jdk/src/share/native/sun/java2d/cmm/lcms/cmssamp.c
+++ jdk/src/share/native/sun/java2d/cmm/lcms/cmssamp.c
@@ -56,6 +56,8 @@
 #include "lcms2_internal.h"
 
 
+#define cmsmin(a, b) (((a) < (b)) ? (a) : (b))
+#define cmsmax(a, b) (((a) > (b)) ? (a) : (b))
 
 // This file contains routines for resampling and LUT optimization, black point detection
 // and black preservation.
@@ -67,13 +69,13 @@
 static
 cmsHTRANSFORM CreateRoundtripXForm(cmsHPROFILE hProfile, cmsUInt32Number nIntent)
 {
-    cmsHPROFILE hLab = cmsCreateLab4Profile(NULL);
+    cmsContext ContextID = cmsGetProfileContextID(hProfile);
+    cmsHPROFILE hLab = cmsCreateLab4ProfileTHR(ContextID, NULL);
     cmsHTRANSFORM xform;
     cmsBool BPC[4] = { FALSE, FALSE, FALSE, FALSE };
     cmsFloat64Number States[4] = { 1.0, 1.0, 1.0, 1.0 };
     cmsHPROFILE hProfiles[4];
     cmsUInt32Number Intents[4];
-    cmsContext ContextID = cmsGetProfileContextID(hProfile);
 
     hProfiles[0] = hLab; hProfiles[1] = hProfile; hProfiles[2] = hProfile; hProfiles[3] = hLab;
     Intents[0]   = INTENT_RELATIVE_COLORIMETRIC; Intents[1] = nIntent; Intents[2] = INTENT_RELATIVE_COLORIMETRIC; Intents[3] = INTENT_RELATIVE_COLORIMETRIC;
@@ -141,8 +143,8 @@
     cmsCloseProfile(hLab);
 
     if (xform == NULL) {
-        // Something went wrong. Get rid of open resources and return zero as black
 
+        // Something went wrong. Get rid of open resources and return zero as black
         BlackPoint -> X = BlackPoint ->Y = BlackPoint -> Z = 0.0;
         return FALSE;
     }
@@ -173,7 +175,6 @@
 // Lab (0, 0, 0) -> [Perceptual] Profile -> CMYK -> [Rel. colorimetric] Profile -> Lab
 static
 cmsBool BlackPointUsingPerceptualBlack(cmsCIEXYZ* BlackPoint, cmsHPROFILE hProfile)
-
 {
     cmsHTRANSFORM hRoundTrip;
     cmsCIELab LabIn, LabOut;
@@ -218,17 +219,27 @@
 // involves to turn BP to neutral and to use only L component.
 cmsBool CMSEXPORT cmsDetectBlackPoint(cmsCIEXYZ* BlackPoint, cmsHPROFILE hProfile, cmsUInt32Number Intent, cmsUInt32Number dwFlags)
 {
+    cmsProfileClassSignature devClass;
 
-    // Zero for black point
-    if (cmsGetDeviceClass(hProfile) == cmsSigLinkClass) {
+    // Make sure the device class is adequate
+    devClass = cmsGetDeviceClass(hProfile);
+    if (devClass == cmsSigLinkClass ||
+        devClass == cmsSigAbstractClass ||
+        devClass == cmsSigNamedColorClass) {
+            BlackPoint -> X = BlackPoint ->Y = BlackPoint -> Z = 0.0;
+            return FALSE;
+    }
 
-        BlackPoint -> X = BlackPoint ->Y = BlackPoint -> Z = 0.0;
-        return FALSE;
+    // Make sure intent is adequate
+    if (Intent != INTENT_PERCEPTUAL &&
+        Intent != INTENT_RELATIVE_COLORIMETRIC &&
+        Intent != INTENT_SATURATION) {
+            BlackPoint -> X = BlackPoint ->Y = BlackPoint -> Z = 0.0;
+            return FALSE;
     }
 
     // v4 + perceptual & saturation intents does have its own black point, and it is
     // well specified enough to use it. Black point tag is deprecated in V4.
-
     if ((cmsGetEncodedICCversion(hProfile) >= 0x4000000) &&
         (Intent == INTENT_PERCEPTUAL || Intent == INTENT_SATURATION)) {
 
@@ -303,7 +314,7 @@
 {
     double sum_x = 0, sum_x2 = 0, sum_x3 = 0, sum_x4 = 0;
     double sum_y = 0, sum_yx = 0, sum_yx2 = 0;
-    double disc;
+    double d, a, b, c;
     int i;
     cmsMAT3 m;
     cmsVEC3 v, res;
@@ -333,14 +344,32 @@
 
     if (!_cmsMAT3solve(&res, &m, &v)) return 0;
 
-    // y = t x2 + u x + c
-    // x = ( - u + Sqrt( u^2 - 4 t c ) ) / ( 2 t )
-    disc = res.n[1]*res.n[1] - 4.0 * res.n[0] * res.n[2];
-    if (disc < 0) return -1;
 
-    return ( -1.0 * res.n[1] + sqrt( disc )) / (2.0 * res.n[0]);
+    a = res.n[2];
+    b = res.n[1];
+    c = res.n[0];
+
+    if (fabs(a) < 1.0E-10) {
+
+        return cmsmin(0, cmsmax(50, -c/b ));
+    }
+    else {
+
+         d = b*b - 4.0 * a * c;
+         if (d <= 0) {
+             return 0;
+         }
+         else {
+
+             double rt = (-b + sqrt(d)) / (2.0 * a);
+
+             return cmsmax(0, cmsmin(50, rt));
+         }
+   }
+
 }
 
+/*
 static
 cmsBool IsMonotonic(int n, const cmsFloat64Number Table[])
 {
@@ -361,6 +390,7 @@
 
     return TRUE;
 }
+*/
 
 // Calculates the black point of a destination profile.
 // This algorithm comes from the Adobe paper disclosing its black point compensation method.
@@ -369,21 +399,30 @@
     cmsColorSpaceSignature ColorSpace;
     cmsHTRANSFORM hRoundTrip = NULL;
     cmsCIELab InitialLab, destLab, Lab;
-
+    cmsFloat64Number inRamp[256], outRamp[256];
     cmsFloat64Number MinL, MaxL;
-    cmsBool NearlyStraightMidRange = FALSE;
-    cmsFloat64Number L;
-    cmsFloat64Number x[101], y[101];
-    cmsFloat64Number lo, hi, NonMonoMin;
-    int n, l, i, NonMonoIndx;
-
+    cmsBool NearlyStraightMidrange = TRUE;
+    cmsFloat64Number yRamp[256];
+    cmsFloat64Number x[256], y[256];
+    cmsFloat64Number lo, hi;
+    int n, l;
+    cmsProfileClassSignature devClass;
+
+    // Make sure the device class is adequate
+    devClass = cmsGetDeviceClass(hProfile);
+    if (devClass == cmsSigLinkClass ||
+        devClass == cmsSigAbstractClass ||
+        devClass == cmsSigNamedColorClass) {
+            BlackPoint -> X = BlackPoint ->Y = BlackPoint -> Z = 0.0;
+            return FALSE;
+    }
 
     // Make sure intent is adequate
     if (Intent != INTENT_PERCEPTUAL &&
         Intent != INTENT_RELATIVE_COLORIMETRIC &&
         Intent != INTENT_SATURATION) {
-        BlackPoint -> X = BlackPoint ->Y = BlackPoint -> Z = 0.0;
-        return FALSE;
+            BlackPoint -> X = BlackPoint ->Y = BlackPoint -> Z = 0.0;
+            return FALSE;
     }
 
 
@@ -415,10 +454,8 @@
         return cmsDetectBlackPoint(BlackPoint, hProfile, Intent, dwFlags);
     }
 
-    // It is one of the valid cases!, presto chargo hocus pocus, go for the Adobe magic
+    // It is one of the valid cases!, use Adobe algorithm
 
-    // Step 1
-    // ======
 
     // Set a first guess, that should work on good profiles.
     if (Intent == INTENT_RELATIVE_COLORIMETRIC) {
@@ -449,71 +486,68 @@
     hRoundTrip = CreateRoundtripXForm(hProfile, Intent);
     if (hRoundTrip == NULL)  return FALSE;
 
-    // Calculate Min L*
-    Lab = InitialLab;
-    Lab.L = 0;
-    cmsDoTransform(hRoundTrip, &Lab, &destLab, 1);
-    MinL = destLab.L;
-
-    // Calculate Max L*
-    Lab = InitialLab;
-    Lab.L = 100;
-    cmsDoTransform(hRoundTrip, &Lab, &destLab, 1);
-    MaxL = destLab.L;
+    // Compute ramps
 
-    // Step 3
-    // ======
+    for (l=0; l < 256; l++) {
 
-    // check if quadratic estimation needs to be done.
-    if (Intent == INTENT_RELATIVE_COLORIMETRIC) {
+        Lab.L = (cmsFloat64Number) (l * 100.0) / 255.0;
+        Lab.a = cmsmin(50, cmsmax(-50, InitialLab.a));
+        Lab.b = cmsmin(50, cmsmax(-50, InitialLab.b));
 
-        // Conceptually, this code tests how close the source l and converted L are to one another in the mid-range
-        // of the values. If the converted ramp of L values is close enough to a straight line y=x, then InitialLab
-        // is good enough to be the DestinationBlackPoint,
-        NearlyStraightMidRange = TRUE;
+        cmsDoTransform(hRoundTrip, &Lab, &destLab, 1);
+
+        inRamp[l]  = Lab.L;
+        outRamp[l] = destLab.L;
+    }
+
+    // Make monotonic
+    for (l = 254; l > 0; --l) {
+        outRamp[l] = cmsmin(outRamp[l], outRamp[l+1]);
+    }
 
-        for (l=0; l <= 100; l++) {
+    // Check
+    if (! (outRamp[0] < outRamp[255])) {
 
-            Lab.L = l;
-            Lab.a = InitialLab.a;
-            Lab.b = InitialLab.b;
+        cmsDeleteTransform(hRoundTrip);
+        BlackPoint -> X = BlackPoint ->Y = BlackPoint -> Z = 0.0;
+        return FALSE;
+    }
 
-            cmsDoTransform(hRoundTrip, &Lab, &destLab, 1);
 
-            L = destLab.L;
+    // Test for mid range straight (only on relative colorimetric)
 
-            // Check the mid range in 20% after MinL
-            if (L > (MinL + 0.2 * (MaxL - MinL))) {
+    NearlyStraightMidrange = TRUE;
+    MinL = outRamp[0]; MaxL = outRamp[255];
+    if (Intent == INTENT_RELATIVE_COLORIMETRIC) {
 
-                // Is close enough?
-                if (fabs(L - l) > 4.0) {
+        for (l=0; l < 256; l++) {
 
-                    // Too far away, profile is buggy!
-                    NearlyStraightMidRange = FALSE;
-                    break;
-                }
-            }
+            if (! ((inRamp[l] <= MinL + 0.2 * (MaxL - MinL) ) ||
+                (fabs(inRamp[l] - outRamp[l]) < 4.0 )))
+                NearlyStraightMidrange = FALSE;
         }
-    }
-    else {
-        // Check is always performed for perceptual and saturation intents
-        NearlyStraightMidRange = FALSE;
-    }
 
+        // If the mid range is straight (as determined above) then the
+        // DestinationBlackPoint shall be the same as initialLab.
+        // Otherwise, the DestinationBlackPoint shall be determined
+        // using curve fitting.
 
-    // If no furter checking is needed, we are done
-    if (NearlyStraightMidRange) {
+        if (NearlyStraightMidrange) {
 
-        cmsLab2XYZ(NULL, BlackPoint, &InitialLab);
-        cmsDeleteTransform(hRoundTrip);
-        return TRUE;
+            cmsLab2XYZ(NULL, BlackPoint, &InitialLab);
+            cmsDeleteTransform(hRoundTrip);
+            return TRUE;
+        }
     }
 
-    // The round-trip curve normally looks like a nearly constant section at the black point,
+
+    // curve fitting: The round-trip curve normally looks like a nearly constant section at the black point,
     // with a corner and a nearly straight line to the white point.
 
-    // STEP 4
-    // =======
+    for (l=0; l < 256; l++) {
+
+        yRamp[l] = (outRamp[l] - MinL) / (MaxL - MinL);
+    }
 
     // find the black point using the least squares error quadratic curve fitting
 
@@ -528,62 +562,32 @@
         hi = 0.25;
     }
 
-    // Capture points for the fitting.
+    // Capture shadow points for the fitting.
     n = 0;
-    for (l=0; l <= 100; l++) {
-
-        cmsFloat64Number ff;
-
-        Lab.L = (cmsFloat64Number) l;
-        Lab.a = InitialLab.a;
-        Lab.b = InitialLab.b;
+    for (l=0; l < 256; l++) {
 
-        cmsDoTransform(hRoundTrip, &Lab, &destLab, 1);
-
-        ff = (destLab.L - MinL)/(MaxL - MinL);
+        cmsFloat64Number ff = yRamp[l];
 
         if (ff >= lo && ff < hi) {
-
-            x[n] = Lab.L;
-            y[n] = ff;
+            x[n] = inRamp[l];
+            y[n] = yRamp[l];
             n++;
         }
-
     }
 
-    // This part is not on the Adobe paper, but I found is necessary for getting any result.
-
-    if (IsMonotonic(n, y)) {
-
-        // Monotonic means lower point is stil valid
-        cmsLab2XYZ(NULL, BlackPoint, &InitialLab);
-        cmsDeleteTransform(hRoundTrip);
-        return TRUE;
-    }
 
-    // No suitable points, regret and use safer algorithm
-    if (n == 0) {
+    // No suitable points
+    if (n < 3 ) {
         cmsDeleteTransform(hRoundTrip);
-        return cmsDetectBlackPoint(BlackPoint, hProfile, Intent, dwFlags);
-    }
-
-
-    NonMonoMin = 100;
-    NonMonoIndx = 0;
-    for (i=0; i < n; i++) {
-
-        if (y[i] < NonMonoMin) {
-            NonMonoIndx = i;
-            NonMonoMin = y[i];
-        }
+        BlackPoint -> X = BlackPoint ->Y = BlackPoint -> Z = 0.0;
+        return FALSE;
     }
 
-    Lab.L = x[NonMonoIndx];
 
     // fit and get the vertex of quadratic curve
     Lab.L = RootOfLeastSquaresFitQuadraticCurve(n, x, y);
 
-    if (Lab.L < 0.0 || Lab.L > 50.0) { // clip to zero L* if the vertex is negative
+    if (Lab.L < 0.0) { // clip to zero L* if the vertex is negative
         Lab.L = 0;
     }
 
--- jdk/src/share/native/sun/java2d/cmm/lcms/cmstypes.c
+++ jdk/src/share/native/sun/java2d/cmm/lcms/cmstypes.c
@@ -91,7 +91,7 @@
 
 // Register a new type handler. This routine is shared between normal types and MPE
 static
-cmsBool RegisterTypesPlugin(cmsPluginBase* Data, _cmsTagTypeLinkedList* LinkedList, cmsUInt32Number DefaultListCount)
+cmsBool RegisterTypesPlugin(cmsContext id, cmsPluginBase* Data, _cmsTagTypeLinkedList* LinkedList, cmsUInt32Number DefaultListCount)
 {
     cmsPluginTagType* Plugin = (cmsPluginTagType*) Data;
     _cmsTagTypeLinkedList *pt, *Anterior = NULL;
@@ -118,7 +118,7 @@
     }
 
     // Registering happens in plug-in memory pool
-    pt = (_cmsTagTypeLinkedList*) _cmsPluginMalloc(sizeof(_cmsTagTypeLinkedList));
+    pt = (_cmsTagTypeLinkedList*) _cmsPluginMalloc(id, sizeof(_cmsTagTypeLinkedList));
     if (pt == NULL) return FALSE;
 
     pt ->Handler   = Plugin ->Handler;
@@ -208,10 +208,10 @@
     cmsUInt32Number *ElementOffsets = NULL, *ElementSizes = NULL;
 
     // Let's take the offsets to each element
-    ElementOffsets = (cmsUInt32Number *) _cmsCalloc(io ->ContextID, Count, sizeof(cmsUInt32Number *));
+    ElementOffsets = (cmsUInt32Number *) _cmsCalloc(io ->ContextID, Count, sizeof(cmsUInt32Number));
     if (ElementOffsets == NULL) goto Error;
 
-    ElementSizes = (cmsUInt32Number *) _cmsCalloc(io ->ContextID, Count, sizeof(cmsUInt32Number *));
+    ElementSizes = (cmsUInt32Number *) _cmsCalloc(io ->ContextID, Count, sizeof(cmsUInt32Number));
     if (ElementSizes == NULL) goto Error;
 
     for (i=0; i < Count; i++) {
@@ -257,10 +257,10 @@
     cmsUInt32Number *ElementOffsets = NULL, *ElementSizes = NULL;
 
      // Create table
-    ElementOffsets = (cmsUInt32Number *) _cmsCalloc(io ->ContextID, Count, sizeof(cmsUInt32Number *));
+    ElementOffsets = (cmsUInt32Number *) _cmsCalloc(io ->ContextID, Count, sizeof(cmsUInt32Number));
     if (ElementOffsets == NULL) goto Error;
 
-    ElementSizes = (cmsUInt32Number *) _cmsCalloc(io ->ContextID, Count, sizeof(cmsUInt32Number *));
+    ElementSizes = (cmsUInt32Number *) _cmsCalloc(io ->ContextID, Count, sizeof(cmsUInt32Number));
     if (ElementSizes == NULL) goto Error;
 
     // Keep starting position of curve offsets
@@ -456,6 +456,7 @@
 void* Type_Chromaticity_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)
 {
     return _cmsDupMem(self ->ContextID, Ptr, sizeof(cmsCIExyYTRIPLE));
+
     cmsUNUSED_PARAMETER(n);
 }
 
@@ -1106,8 +1107,6 @@
 {
     cmsUInt32Number Count;
     cmsToneCurve* NewGamma;
-    cmsUInt16Number Linear[2] = { 0, 0xffff };
-
 
     *nItems = 0;
     if (!_cmsReadUInt32Number(io, &Count)) return NULL;
@@ -1115,11 +1114,14 @@
     switch (Count) {
 
            case 0:   // Linear.
+               {
+                   cmsFloat64Number SingleGamma = 1.0;
 
-               NewGamma = cmsBuildTabulatedToneCurve16(self ->ContextID, 2, Linear);
-               if (!NewGamma) return NULL;
-               *nItems = 1;
-               return NewGamma;
+                   NewGamma = cmsBuildParametricToneCurve(self ->ContextID, 1, &SingleGamma);
+                   if (!NewGamma) return NULL;
+                   *nItems = 1;
+                   return NewGamma;
+               }
 
            case 1:  // Specified as the exponent of gamma function
                {
@@ -1210,6 +1212,7 @@
     if (ICCVersion < 4.0) return cmsSigCurveType;
     if (Curve ->nSegments != 1) return cmsSigCurveType;          // Only 1-segment curves can be saved as parametric
     if (Curve ->Segments[0].Type < 0) return cmsSigCurveType;    // Only non-inverted curves
+    if (Curve ->Segments[0].Type > 5) return cmsSigCurveType;    // Only ICC parametric curves
 
     return cmsSigParametricCurveType;
 }
@@ -1386,6 +1389,9 @@
 {
     cmsICCMeasurementConditions mc;
 
+
+    memset(&mc, 0, sizeof(mc));
+
     if (!_cmsReadUInt32Number(io, &mc.Observer)) return NULL;
     if (!_cmsReadXYZNumber(io,    &mc.Backing)) return NULL;
     if (!_cmsReadUInt32Number(io, &mc.Geometry)) return NULL;
@@ -1640,7 +1646,6 @@
 static
 cmsBool  Read8bitTables(cmsContext ContextID, cmsIOHANDLER* io, cmsPipeline* lut, int nChannels)
 {
-    cmsStage* mpe;
     cmsUInt8Number* Temp = NULL;
     int i, j;
     cmsToneCurve* Tables[cmsMAXCHANNELS];
@@ -1669,11 +1674,8 @@
     _cmsFree(ContextID, Temp);
     Temp = NULL;
 
-
-    mpe = cmsStageAllocToneCurves(ContextID, nChannels, Tables);
-    if (mpe == NULL) goto Error;
-
-    cmsPipelineInsertStage(lut, cmsAT_END, mpe);
+    if (!cmsPipelineInsertStage(lut, cmsAT_END, cmsStageAllocToneCurves(ContextID, nChannels, Tables)))
+        goto Error;
 
     for (i=0; i < nChannels; i++)
         cmsFreeToneCurve(Tables[i]);
@@ -1701,21 +1703,30 @@
 
         if (Tables) {
 
-            if (Tables ->TheCurves[i]->nEntries != 256) {
-                cmsSignalError(ContextID, cmsERROR_RANGE, "LUT8 needs 256 entries on prelinearization");
-                return FALSE;
-            }
-
-        }
-
-        for (j=0; j < 256; j++) {
+            // Usual case of identity curves
+            if ((Tables ->TheCurves[i]->nEntries == 2) &&
+                (Tables->TheCurves[i]->Table16[0] == 0) &&
+                (Tables->TheCurves[i]->Table16[1] == 65535)) {
 
-            if (Tables != NULL)
-                val = (cmsUInt8Number) FROM_16_TO_8(Tables->TheCurves[i]->Table16[j]);
+                    for (j=0; j < 256; j++) {
+                        if (!_cmsWriteUInt8Number(io, (cmsUInt8Number) j)) return FALSE;
+                    }
+            }
             else
-                val = (cmsUInt8Number) j;
+                if (Tables ->TheCurves[i]->nEntries != 256) {
+                    cmsSignalError(ContextID, cmsERROR_RANGE, "LUT8 needs 256 entries on prelinearization");
+                    return FALSE;
+                }
+                else
+                    for (j=0; j < 256; j++) {
+
+                        if (Tables != NULL)
+                            val = (cmsUInt8Number) FROM_16_TO_8(Tables->TheCurves[i]->Table16[j]);
+                        else
+                            val = (cmsUInt8Number) j;
 
-            if (!_cmsWriteUInt8Number(io, val)) return FALSE;
+                        if (!_cmsWriteUInt8Number(io, val)) return FALSE;
+                    }
         }
     }
     return TRUE;
@@ -1724,7 +1735,7 @@
 
 // Check overflow
 static
-size_t uipow(cmsUInt32Number n, cmsUInt32Number a, cmsUInt32Number b)
+cmsUInt32Number uipow(cmsUInt32Number n, cmsUInt32Number a, cmsUInt32Number b)
 {
     cmsUInt32Number rv = 1, rc;
 
@@ -1736,13 +1747,13 @@
         rv *= a;
 
         // Check for overflow
-        if (rv > UINT_MAX / a) return (size_t) -1;
+        if (rv > UINT_MAX / a) return (cmsUInt32Number) -1;
 
     }
 
     rc = rv * n;
 
-    if (rv != rc / n) return (size_t) -1;
+    if (rv != rc / n) return (cmsUInt32Number) -1;
     return rc;
 }
 
@@ -1757,7 +1768,6 @@
     cmsUInt8Number InputChannels, OutputChannels, CLUTpoints;
     cmsUInt8Number* Temp = NULL;
     cmsPipeline* NewLUT = NULL;
-    cmsStage *mpemat, *mpeclut;
     cmsUInt32Number nTabSize, i;
     cmsFloat64Number Matrix[3*3];
 
@@ -1796,9 +1806,8 @@
     // Only operates if not identity...
     if ((InputChannels == 3) && !_cmsMAT3isIdentity((cmsMAT3*) Matrix)) {
 
-        mpemat = cmsStageAllocMatrix(self ->ContextID, 3, 3, Matrix, NULL);
-        if (mpemat == NULL) goto Error;
-        cmsPipelineInsertStage(NewLUT, cmsAT_BEGIN, mpemat);
+        if (!cmsPipelineInsertStage(NewLUT, cmsAT_BEGIN, cmsStageAllocMatrix(self ->ContextID, 3, 3, Matrix, NULL)))
+            goto Error;
     }
 
     // Get input tables
@@ -1806,13 +1815,10 @@
 
     // Get 3D CLUT. Check the overflow....
     nTabSize = uipow(OutputChannels, CLUTpoints, InputChannels);
-    if (nTabSize == (size_t) -1) goto Error;
+    if (nTabSize == (cmsUInt32Number) -1) goto Error;
     if (nTabSize > 0) {
 
         cmsUInt16Number *PtrW, *T;
-        cmsUInt32Number Tsize;
-
-        Tsize = (cmsUInt32Number) nTabSize * sizeof(cmsUInt16Number);
 
         PtrW = T  = (cmsUInt16Number*) _cmsCalloc(self ->ContextID, nTabSize, sizeof(cmsUInt16Number));
         if (T  == NULL) goto Error;
@@ -1829,10 +1835,8 @@
         _cmsFree(self ->ContextID, Temp);
         Temp = NULL;
 
-
-        mpeclut = cmsStageAllocCLut16bit(self ->ContextID, CLUTpoints, InputChannels, OutputChannels, T);
-        if (mpeclut == NULL) goto Error;
-        cmsPipelineInsertStage(NewLUT, cmsAT_END, mpeclut);
+        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, cmsStageAllocCLut16bit(self ->ContextID, CLUTpoints, InputChannels, OutputChannels, T)))
+            goto Error;
         _cmsFree(self ->ContextID, T);
     }
 
@@ -1934,7 +1938,7 @@
     if (!Write8bitTables(self ->ContextID, io, NewLUT ->InputChannels, PreMPE)) return FALSE;
 
     nTabSize = uipow(NewLUT->OutputChannels, clutPoints, NewLUT ->InputChannels);
-    if (nTabSize == (size_t) -1) return FALSE;
+    if (nTabSize == (cmsUInt32Number) -1) return FALSE;
     if (nTabSize > 0) {
 
         // The 3D CLUT.
@@ -1983,7 +1987,6 @@
 static
 cmsBool  Read16bitTables(cmsContext ContextID, cmsIOHANDLER* io, cmsPipeline* lut, int nChannels, int nEntries)
 {
-    cmsStage* mpe;
     int i;
     cmsToneCurve* Tables[cmsMAXCHANNELS];
 
@@ -2007,10 +2010,8 @@
 
 
     // Add the table (which may certainly be an identity, but this is up to the optimizer, not the reading code)
-    mpe = cmsStageAllocToneCurves(ContextID, nChannels, Tables);
-    if (mpe == NULL) goto Error;
-
-    cmsPipelineInsertStage(lut, cmsAT_END, mpe);
+    if (!cmsPipelineInsertStage(lut, cmsAT_END, cmsStageAllocToneCurves(ContextID, nChannels, Tables)))
+        goto Error;
 
     for (i=0; i < nChannels; i++)
         cmsFreeToneCurve(Tables[i]);
@@ -2031,7 +2032,9 @@
     int j;
     cmsUInt32Number i;
     cmsUInt16Number val;
-    int nEntries = 256;
+    int nEntries;
+
+    _cmsAssert(Tables != NULL);
 
     nEntries = Tables->TheCurves[0]->nEntries;
 
@@ -2039,11 +2042,7 @@
 
         for (j=0; j < nEntries; j++) {
 
-            if (Tables != NULL)
-                val = Tables->TheCurves[i]->Table16[j];
-            else
-                val = _cmsQuantizeVal(j, nEntries);
-
+            val = Tables->TheCurves[i]->Table16[j];
             if (!_cmsWriteUInt16Number(io, val)) return FALSE;
         }
     }
@@ -2057,7 +2056,6 @@
 {
     cmsUInt8Number InputChannels, OutputChannels, CLUTpoints;
     cmsPipeline* NewLUT = NULL;
-    cmsStage *mpemat,  *mpeclut;
     cmsUInt32Number nTabSize;
     cmsFloat64Number Matrix[3*3];
     cmsUInt16Number InputEntries, OutputEntries;
@@ -2094,9 +2092,8 @@
     // Only operates on 3 channels
     if ((InputChannels == 3) && !_cmsMAT3isIdentity((cmsMAT3*) Matrix)) {
 
-        mpemat = cmsStageAllocMatrix(self ->ContextID, 3, 3, Matrix, NULL);
-        if (mpemat == NULL) goto Error;
-        cmsPipelineInsertStage(NewLUT, cmsAT_END, mpemat);
+        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, cmsStageAllocMatrix(self ->ContextID, 3, 3, Matrix, NULL)))
+            goto Error;
     }
 
     if (!_cmsReadUInt16Number(io, &InputEntries)) goto Error;
@@ -2110,7 +2107,7 @@
 
     // Get 3D CLUT
     nTabSize = uipow(OutputChannels, CLUTpoints, InputChannels);
-    if (nTabSize == (size_t) -1) goto Error;
+    if (nTabSize == (cmsUInt32Number) -1) goto Error;
     if (nTabSize > 0) {
 
         cmsUInt16Number *T;
@@ -2123,13 +2120,10 @@
             goto Error;
         }
 
-        mpeclut = cmsStageAllocCLut16bit(self ->ContextID, CLUTpoints, InputChannels, OutputChannels, T);
-        if (mpeclut == NULL) {
-             _cmsFree(self ->ContextID, T);
+        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, cmsStageAllocCLut16bit(self ->ContextID, CLUTpoints, InputChannels, OutputChannels, T))) {
+            _cmsFree(self ->ContextID, T);
             goto Error;
         }
-
-        cmsPipelineInsertStage(NewLUT, cmsAT_END, mpeclut);
         _cmsFree(self ->ContextID, T);
     }
 
@@ -2159,7 +2153,7 @@
     _cmsStageToneCurvesData* PreMPE = NULL, *PostMPE = NULL;
     _cmsStageMatrixData* MatMPE = NULL;
     _cmsStageCLutData* clut = NULL;
-    int InputChannels, OutputChannels, clutPoints;
+    int i, InputChannels, OutputChannels, clutPoints;
 
     // Disassemble the LUT into components.
     mpe = NewLUT -> Elements;
@@ -2234,13 +2228,13 @@
     if (PreMPE != NULL) {
         if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) PreMPE ->TheCurves[0]->nEntries)) return FALSE;
     } else {
-            if (!_cmsWriteUInt16Number(io, 0)) return FALSE;
+            if (!_cmsWriteUInt16Number(io, 2)) return FALSE;
     }
 
     if (PostMPE != NULL) {
         if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) PostMPE ->TheCurves[0]->nEntries)) return FALSE;
     } else {
-        if (!_cmsWriteUInt16Number(io, 0)) return FALSE;
+        if (!_cmsWriteUInt16Number(io, 2)) return FALSE;
 
     }
 
@@ -2249,9 +2243,16 @@
     if (PreMPE != NULL) {
         if (!Write16bitTables(self ->ContextID, io, PreMPE)) return FALSE;
     }
+    else {
+        for (i=0; i < InputChannels; i++) {
+
+            if (!_cmsWriteUInt16Number(io, 0)) return FALSE;
+            if (!_cmsWriteUInt16Number(io, 0xffff)) return FALSE;
+        }
+    }
 
     nTabSize = uipow(OutputChannels, clutPoints, InputChannels);
-    if (nTabSize == (size_t) -1) return FALSE;
+    if (nTabSize == (cmsUInt32Number) -1) return FALSE;
     if (nTabSize > 0) {
         // The 3D CLUT.
         if (clut != NULL) {
@@ -2263,7 +2264,13 @@
     if (PostMPE != NULL) {
         if (!Write16bitTables(self ->ContextID, io, PostMPE)) return FALSE;
     }
+    else {
+        for (i=0; i < OutputChannels; i++) {
 
+            if (!_cmsWriteUInt16Number(io, 0)) return FALSE;
+            if (!_cmsWriteUInt16Number(io, 0xffff)) return FALSE;
+        }
+    }
 
     return TRUE;
 
@@ -2479,7 +2486,6 @@
     cmsUInt32Number      offsetM;        // Offset to first "M" curve
     cmsUInt32Number      offsetC;        // Offset to CLUT
     cmsUInt32Number      offsetA;        // Offset to first "A" curve
-    cmsStage* mpe;
     cmsPipeline* NewLUT = NULL;
 
 
@@ -2501,37 +2507,35 @@
     if (NewLUT == NULL) return NULL;
 
     if (offsetA!= 0) {
-        mpe = ReadSetOfCurves(self, io, BaseOffset + offsetA, inputChan);
-        if (mpe == NULL) { cmsPipelineFree(NewLUT); return NULL; }
-        cmsPipelineInsertStage(NewLUT, cmsAT_END, mpe);
+        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, ReadSetOfCurves(self, io, BaseOffset + offsetA, inputChan)))
+            goto Error;
     }
 
     if (offsetC != 0) {
-        mpe = ReadCLUT(self, io, BaseOffset + offsetC, inputChan, outputChan);
-        if (mpe == NULL) { cmsPipelineFree(NewLUT); return NULL; }
-        cmsPipelineInsertStage(NewLUT, cmsAT_END, mpe);
+        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, ReadCLUT(self, io, BaseOffset + offsetC, inputChan, outputChan)))
+            goto Error;
     }
 
     if (offsetM != 0) {
-        mpe = ReadSetOfCurves(self, io, BaseOffset + offsetM, outputChan);
-        if (mpe == NULL) { cmsPipelineFree(NewLUT); return NULL; }
-        cmsPipelineInsertStage(NewLUT, cmsAT_END, mpe);
+        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, ReadSetOfCurves(self, io, BaseOffset + offsetM, outputChan)))
+            goto Error;
     }
 
     if (offsetMat != 0) {
-        mpe = ReadMatrix(self, io, BaseOffset + offsetMat);
-        if (mpe == NULL) { cmsPipelineFree(NewLUT); return NULL; }
-        cmsPipelineInsertStage(NewLUT, cmsAT_END, mpe);
+        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, ReadMatrix(self, io, BaseOffset + offsetMat)))
+            goto Error;
     }
 
     if (offsetB != 0) {
-        mpe = ReadSetOfCurves(self, io, BaseOffset + offsetB, outputChan);
-        if (mpe == NULL) { cmsPipelineFree(NewLUT); return NULL; }
-        cmsPipelineInsertStage(NewLUT, cmsAT_END, mpe);
+        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, ReadSetOfCurves(self, io, BaseOffset + offsetB, outputChan)))
+            goto Error;
     }
 
     *nItems = 1;
     return NewLUT;
+Error:
+    cmsPipelineFree(NewLUT);
+    return NULL;
 
     cmsUNUSED_PARAMETER(SizeOfTag);
 }
@@ -2798,7 +2802,6 @@
     cmsUInt32Number      offsetM;        // Offset to first "M" curve
     cmsUInt32Number      offsetC;        // Offset to CLUT
     cmsUInt32Number      offsetA;        // Offset to first "A" curve
-    cmsStage* mpe;
     cmsPipeline* NewLUT = NULL;
 
 
@@ -2821,37 +2824,35 @@
     if (NewLUT == NULL) return NULL;
 
     if (offsetB != 0) {
-        mpe = ReadSetOfCurves(self, io, BaseOffset + offsetB, inputChan);
-        if (mpe == NULL) { cmsPipelineFree(NewLUT); return NULL; }
-        cmsPipelineInsertStage(NewLUT, cmsAT_END, mpe);
+        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, ReadSetOfCurves(self, io, BaseOffset + offsetB, inputChan)))
+            goto Error;
     }
 
     if (offsetMat != 0) {
-        mpe = ReadMatrix(self, io, BaseOffset + offsetMat);
-        if (mpe == NULL) { cmsPipelineFree(NewLUT); return NULL; }
-        cmsPipelineInsertStage(NewLUT, cmsAT_END, mpe);
+        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, ReadMatrix(self, io, BaseOffset + offsetMat)))
+            goto Error;
     }
 
     if (offsetM != 0) {
-        mpe = ReadSetOfCurves(self, io, BaseOffset + offsetM, inputChan);
-        if (mpe == NULL) { cmsPipelineFree(NewLUT); return NULL; }
-        cmsPipelineInsertStage(NewLUT, cmsAT_END, mpe);
+        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, ReadSetOfCurves(self, io, BaseOffset + offsetM, inputChan)))
+            goto Error;
     }
 
     if (offsetC != 0) {
-        mpe = ReadCLUT(self, io, BaseOffset + offsetC, inputChan, outputChan);
-        if (mpe == NULL) { cmsPipelineFree(NewLUT); return NULL; }
-        cmsPipelineInsertStage(NewLUT, cmsAT_END, mpe);
+        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, ReadCLUT(self, io, BaseOffset + offsetC, inputChan, outputChan)))
+            goto Error;
     }
 
     if (offsetA!= 0) {
-        mpe = ReadSetOfCurves(self, io, BaseOffset + offsetA, outputChan);
-        if (mpe == NULL) { cmsPipelineFree(NewLUT); return NULL; }
-        cmsPipelineInsertStage(NewLUT, cmsAT_END, mpe);
+        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, ReadSetOfCurves(self, io, BaseOffset + offsetA, outputChan)))
+            goto Error;
     }
 
     *nItems = 1;
     return NewLUT;
+Error:
+    cmsPipelineFree(NewLUT);
+    return NULL;
 
     cmsUNUSED_PARAMETER(SizeOfTag);
 }
@@ -3287,7 +3288,7 @@
         SizeOfTag -= sizeof(cmsUInt32Number);
 
         if (!_cmsReadUInt64Number(io, &sec ->attributes)) goto Error;
-        if (SizeOfTag < sizeof(cmsUInt32Number)) goto Error;
+        if (SizeOfTag < sizeof(cmsUInt64Number)) goto Error;
         SizeOfTag -= sizeof(cmsUInt64Number);
 
         if (!_cmsReadUInt32Number(io, (cmsUInt32Number *)&sec ->technology)) goto Error;
@@ -4292,6 +4293,9 @@
     if (!_cmsReadUInt16Number(io, &InputChans)) return NULL;
     if (!_cmsReadUInt16Number(io, &OutputChans)) return NULL;
 
+    if (InputChans == 0) goto Error;
+    if (OutputChans == 0) goto Error;
+
     if (io ->Read(io, Dimensions8, sizeof(cmsUInt8Number), 16) != 16)
         goto Error;
 
@@ -4381,7 +4385,6 @@
 {
     cmsStageSignature ElementSig;
     cmsTagTypeHandler* TypeHandler;
-    cmsStage *mpe = NULL;
     cmsUInt32Number nItems;
     cmsPipeline *NewLUT = (cmsPipeline *) Cargo;
 
@@ -4409,11 +4412,8 @@
     if (TypeHandler ->ReadPtr != NULL) {
 
         // This is a real element which should be read and processed
-        mpe = (cmsStage*) TypeHandler ->ReadPtr(self, io, &nItems, SizeOfTag);
-        if (mpe == NULL) return FALSE;
-
-        // All seems ok, insert element
-        cmsPipelineInsertStage(NewLUT, cmsAT_END, mpe);
+        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, (cmsStage*) TypeHandler ->ReadPtr(self, io, &nItems, SizeOfTag)))
+            return FALSE;
     }
 
     return TRUE;
@@ -4479,10 +4479,10 @@
     outputChan = cmsPipelineOutputChannels(Lut);
     ElemCount  = cmsPipelineStageCount(Lut);
 
-    ElementOffsets = (cmsUInt32Number *) _cmsCalloc(self ->ContextID, ElemCount, sizeof(cmsUInt32Number *));
+    ElementOffsets = (cmsUInt32Number *) _cmsCalloc(self ->ContextID, ElemCount, sizeof(cmsUInt32Number));
     if (ElementOffsets == NULL) goto Error;
 
-    ElementSizes = (cmsUInt32Number *) _cmsCalloc(self ->ContextID, ElemCount, sizeof(cmsUInt32Number *));
+    ElementSizes = (cmsUInt32Number *) _cmsCalloc(self ->ContextID, ElemCount, sizeof(cmsUInt32Number));
     if (ElementSizes == NULL) goto Error;
 
     // Write the head
@@ -4825,10 +4825,10 @@
 static
 cmsBool AllocElem(cmsContext ContextID, _cmsDICelem* e,  cmsUInt32Number Count)
 {
-    e->Offsets = (cmsUInt32Number *) _cmsCalloc(ContextID, Count, sizeof(cmsUInt32Number *));
+    e->Offsets = (cmsUInt32Number *) _cmsCalloc(ContextID, Count, sizeof(cmsUInt32Number));
     if (e->Offsets == NULL) return FALSE;
 
-    e->Sizes = (cmsUInt32Number *) _cmsCalloc(ContextID, Count, sizeof(cmsUInt32Number *));
+    e->Sizes = (cmsUInt32Number *) _cmsCalloc(ContextID, Count, sizeof(cmsUInt32Number));
     if (e->Sizes == NULL) {
 
         _cmsFree(ContextID, e -> Offsets);
@@ -4844,7 +4844,7 @@
 void FreeElem(_cmsDICelem* e)
 {
     if (e ->Offsets != NULL)  _cmsFree(e -> ContextID, e -> Offsets);
-    if (e ->Sizes   != NULL)  _cmsFree(e -> ContextID, e ->Sizes);
+    if (e ->Sizes   != NULL)  _cmsFree(e -> ContextID, e -> Sizes);
     e->Offsets = e ->Sizes = NULL;
 }
 
@@ -5084,7 +5084,7 @@
     if (!_cmsReadUInt32Number(io, &Count)) return NULL;
     SizeOfTag -= sizeof(cmsUInt32Number);
 
-    // Get rec lenghth
+    // Get rec length
     if (!_cmsReadUInt32Number(io, &Length)) return NULL;
     SizeOfTag -= sizeof(cmsUInt32Number);
 
@@ -5118,14 +5118,22 @@
             if (!ReadOneMLUC(self, io, &a.DisplayValue, i, &DisplayValueMLU)) goto Error;
         }
 
+        if (NameWCS == NULL || ValueWCS == NULL) {
+
+            cmsSignalError(self->ContextID, cmsERROR_CORRUPTION_DETECTED, "Bad dictionary Name/Value");
+            rc = FALSE;
+        }
+        else {
+
         rc = cmsDictAddEntry(hDict, NameWCS, ValueWCS, DisplayNameMLU, DisplayValueMLU);
+        }
 
         if (NameWCS != NULL) _cmsFree(self ->ContextID, NameWCS);
         if (ValueWCS != NULL) _cmsFree(self ->ContextID, ValueWCS);
         if (DisplayNameMLU != NULL) cmsMLUfree(DisplayNameMLU);
         if (DisplayValueMLU != NULL) cmsMLUfree(DisplayValueMLU);
 
-        if (!rc) return FALSE;
+        if (!rc) goto Error;
     }
 
    FreeArray(&a);
@@ -5277,14 +5285,14 @@
 #define DEFAULT_TAG_TYPE_COUNT  (sizeof(SupportedTagTypes) / sizeof(_cmsTagTypeLinkedList))
 
 // Both kind of plug-ins share same structure
-cmsBool  _cmsRegisterTagTypePlugin(cmsPluginBase* Data)
+cmsBool  _cmsRegisterTagTypePlugin(cmsContext id, cmsPluginBase* Data)
 {
-    return RegisterTypesPlugin(Data, SupportedTagTypes, DEFAULT_TAG_TYPE_COUNT);
+    return RegisterTypesPlugin(id, Data, SupportedTagTypes, DEFAULT_TAG_TYPE_COUNT);
 }
 
-cmsBool  _cmsRegisterMultiProcessElementPlugin(cmsPluginBase* Data)
+cmsBool  _cmsRegisterMultiProcessElementPlugin(cmsContext id, cmsPluginBase* Data)
 {
-    return RegisterTypesPlugin(Data, SupportedMPEtypes, DEFAULT_MPE_TYPE_COUNT);
+    return RegisterTypesPlugin(id, Data, SupportedMPEtypes, DEFAULT_MPE_TYPE_COUNT);
 }
 
 
@@ -5391,7 +5399,9 @@
     { cmsSigScreeningTag,           { 1, 1, { cmsSigScreeningType},          NULL }, &SupportedTags[59]},
     { cmsSigVcgtTag,                { 1, 1, { cmsSigVcgtType},               NULL }, &SupportedTags[60]},
     { cmsSigMetaTag,                { 1, 1, { cmsSigDictType},               NULL }, &SupportedTags[61]},
-    { cmsSigProfileSequenceIdTag,   { 1, 1, { cmsSigProfileSequenceIdType},  NULL},  NULL}
+    { cmsSigProfileSequenceIdTag,   { 1, 1, { cmsSigProfileSequenceIdType},  NULL },  &SupportedTags[62]},
+    { cmsSigProfileDescriptionMLTag,{ 1, 1, { cmsSigMultiLocalizedUnicodeType}, NULL}, NULL}
+
 
 };
 
@@ -5406,7 +5416,7 @@
 
 #define DEFAULT_TAG_COUNT  (sizeof(SupportedTags) / sizeof(_cmsTagLinkedList))
 
-cmsBool  _cmsRegisterTagPlugin(cmsPluginBase* Data)
+cmsBool  _cmsRegisterTagPlugin(cmsContext id, cmsPluginBase* Data)
 {
     cmsPluginTag* Plugin = (cmsPluginTag*) Data;
     _cmsTagLinkedList *pt, *Anterior;
@@ -5430,7 +5440,7 @@
         pt = pt ->Next;
     }
 
-    pt = (_cmsTagLinkedList*) _cmsPluginMalloc(sizeof(_cmsTagLinkedList));
+    pt = (_cmsTagLinkedList*) _cmsPluginMalloc(id, sizeof(_cmsTagLinkedList));
     if (pt == NULL) return FALSE;
 
     pt ->Signature  = Plugin ->Signature;
--- jdk/src/share/native/sun/java2d/cmm/lcms/cmsvirt.c
+++ jdk/src/share/native/sun/java2d/cmm/lcms/cmsvirt.c
@@ -208,9 +208,26 @@
 
     if (TransferFunction) {
 
+        // Tries to minimize space. Thanks to Richard Hughes for this nice idea
         if (!cmsWriteTag(hICC, cmsSigRedTRCTag,   (void*) TransferFunction[0])) goto Error;
-        if (!cmsWriteTag(hICC, cmsSigGreenTRCTag, (void*) TransferFunction[1])) goto Error;
-        if (!cmsWriteTag(hICC, cmsSigBlueTRCTag,  (void*) TransferFunction[2])) goto Error;
+
+        if (TransferFunction[1] == TransferFunction[0]) {
+
+            if (!cmsLinkTag (hICC, cmsSigGreenTRCTag, cmsSigRedTRCTag)) goto Error;
+
+        } else {
+
+            if (!cmsWriteTag(hICC, cmsSigGreenTRCTag, (void*) TransferFunction[1])) goto Error;
+        }
+
+        if (TransferFunction[2] == TransferFunction[0]) {
+
+            if (!cmsLinkTag (hICC, cmsSigBlueTRCTag, cmsSigRedTRCTag)) goto Error;
+
+        } else {
+
+            if (!cmsWriteTag(hICC, cmsSigBlueTRCTag, (void*) TransferFunction[2])) goto Error;
+        }
     }
 
     if (Primaries) {
@@ -303,7 +320,6 @@
 {
     cmsHPROFILE hICC;
     cmsPipeline* Pipeline;
-    cmsStage* Lin;
     int nChannels;
 
     hICC = cmsCreateProfilePlaceholder(ContextID);
@@ -327,10 +343,8 @@
 
 
     // Copy tables to Pipeline
-    Lin = cmsStageAllocToneCurves(ContextID, nChannels, TransferFunctions);
-    if (Lin == NULL) goto Error;
-
-    cmsPipelineInsertStage(Pipeline, cmsAT_BEGIN, Lin);
+    if (!cmsPipelineInsertStage(Pipeline, cmsAT_BEGIN, cmsStageAllocToneCurves(ContextID, nChannels, TransferFunctions)))
+        goto Error;
 
     // Create tags
     if (!SetTextTags(hICC, L"Linearization built-in")) goto Error;
@@ -344,6 +358,7 @@
     return hICC;
 
 Error:
+    cmsPipelineFree(Pipeline);
     if (hICC)
         cmsCloseProfile(hICC);
 
@@ -451,9 +466,10 @@
 
     if (!cmsStageSampleCLut16bit(CLUT, InkLimitingSampler, (void*) &Limit, 0)) goto Error;
 
-    cmsPipelineInsertStage(LUT, cmsAT_BEGIN, _cmsStageAllocIdentityCurves(ContextID, nChannels));
-    cmsPipelineInsertStage(LUT, cmsAT_END, CLUT);
-    cmsPipelineInsertStage(LUT, cmsAT_END, _cmsStageAllocIdentityCurves(ContextID, nChannels));
+    if (!cmsPipelineInsertStage(LUT, cmsAT_BEGIN, _cmsStageAllocIdentityCurves(ContextID, nChannels)) ||
+        !cmsPipelineInsertStage(LUT, cmsAT_END, CLUT) ||
+        !cmsPipelineInsertStage(LUT, cmsAT_END, _cmsStageAllocIdentityCurves(ContextID, nChannels)))
+        goto Error;
 
     // Create tags
     if (!SetTextTags(hICC, L"ink-limiting built-in")) goto Error;
@@ -504,7 +520,8 @@
     LUT = cmsPipelineAlloc(ContextID, 3, 3);
     if (LUT == NULL) goto Error;
 
-    cmsPipelineInsertStage(LUT, cmsAT_BEGIN, _cmsStageAllocIdentityCLut(ContextID, 3));
+    if (!cmsPipelineInsertStage(LUT, cmsAT_BEGIN, _cmsStageAllocIdentityCLut(ContextID, 3)))
+        goto Error;
 
     if (!cmsWriteTag(hProfile, cmsSigAToB0Tag, LUT)) goto Error;
     cmsPipelineFree(LUT);
@@ -550,7 +567,8 @@
     LUT = cmsPipelineAlloc(ContextID, 3, 3);
     if (LUT == NULL) goto Error;
 
-    cmsPipelineInsertStage(LUT, cmsAT_BEGIN, _cmsStageAllocIdentityCurves(ContextID, 3));
+    if (!cmsPipelineInsertStage(LUT, cmsAT_BEGIN, _cmsStageAllocIdentityCurves(ContextID, 3)))
+        goto Error;
 
     if (!cmsWriteTag(hProfile, cmsSigAToB0Tag, LUT)) goto Error;
     cmsPipelineFree(LUT);
@@ -595,7 +613,8 @@
     LUT = cmsPipelineAlloc(ContextID, 3, 3);
     if (LUT == NULL) goto Error;
 
-    cmsPipelineInsertStage(LUT, cmsAT_BEGIN, _cmsStageAllocIdentityCurves(ContextID, 3));
+    if (!cmsPipelineInsertStage(LUT, cmsAT_BEGIN, _cmsStageAllocIdentityCurves(ContextID, 3)))
+        goto Error;
 
     if (!cmsWriteTag(hProfile, cmsSigAToB0Tag, LUT)) goto Error;
     cmsPipelineFree(LUT);
@@ -734,81 +753,83 @@
 // contrast, Saturation and white point displacement
 
 cmsHPROFILE CMSEXPORT cmsCreateBCHSWabstractProfileTHR(cmsContext ContextID,
-                                                     int nLUTPoints,
-                                                     cmsFloat64Number Bright,
-                                                     cmsFloat64Number Contrast,
-                                                     cmsFloat64Number Hue,
-                                                     cmsFloat64Number Saturation,
-                                                     int TempSrc,
-                                                     int TempDest)
-{
-     cmsHPROFILE hICC;
-     cmsPipeline* Pipeline;
-     BCHSWADJUSTS bchsw;
-     cmsCIExyY WhitePnt;
-     cmsStage* CLUT;
-     cmsUInt32Number Dimensions[MAX_INPUT_DIMENSIONS];
-     int i;
-
-
-     bchsw.Brightness = Bright;
-     bchsw.Contrast   = Contrast;
-     bchsw.Hue        = Hue;
-     bchsw.Saturation = Saturation;
-
-     cmsWhitePointFromTemp(&WhitePnt, TempSrc );
-     cmsxyY2XYZ(&bchsw.WPsrc, &WhitePnt);
-
-     cmsWhitePointFromTemp(&WhitePnt, TempDest);
-     cmsxyY2XYZ(&bchsw.WPdest, &WhitePnt);
-
-      hICC = cmsCreateProfilePlaceholder(ContextID);
-       if (!hICC)                          // can't allocate
-            return NULL;
-
-
-       cmsSetDeviceClass(hICC,      cmsSigAbstractClass);
-       cmsSetColorSpace(hICC,       cmsSigLabData);
-       cmsSetPCS(hICC,              cmsSigLabData);
-
-       cmsSetHeaderRenderingIntent(hICC,  INTENT_PERCEPTUAL);
-
-
-       // Creates a Pipeline with 3D grid only
-       Pipeline = cmsPipelineAlloc(ContextID, 3, 3);
-       if (Pipeline == NULL) {
-           cmsCloseProfile(hICC);
-           return NULL;
-           }
+    int nLUTPoints,
+    cmsFloat64Number Bright,
+    cmsFloat64Number Contrast,
+    cmsFloat64Number Hue,
+    cmsFloat64Number Saturation,
+    int TempSrc,
+    int TempDest)
+{
+    cmsHPROFILE hICC;
+    cmsPipeline* Pipeline;
+    BCHSWADJUSTS bchsw;
+    cmsCIExyY WhitePnt;
+    cmsStage* CLUT;
+    cmsUInt32Number Dimensions[MAX_INPUT_DIMENSIONS];
+    int i;
 
-       for (i=0; i < MAX_INPUT_DIMENSIONS; i++) Dimensions[i] = nLUTPoints;
-       CLUT = cmsStageAllocCLut16bitGranular(ContextID, Dimensions, 3, 3, NULL);
-       if (CLUT == NULL) return NULL;
+    bchsw.Brightness = Bright;
+    bchsw.Contrast   = Contrast;
+    bchsw.Hue        = Hue;
+    bchsw.Saturation = Saturation;
 
+    cmsWhitePointFromTemp(&WhitePnt, TempSrc );
+    cmsxyY2XYZ(&bchsw.WPsrc, &WhitePnt);
 
-       if (!cmsStageSampleCLut16bit(CLUT, bchswSampler, (void*) &bchsw, 0)) {
+    cmsWhitePointFromTemp(&WhitePnt, TempDest);
+    cmsxyY2XYZ(&bchsw.WPdest, &WhitePnt);
 
-                // Shouldn't reach here
-                cmsPipelineFree(Pipeline);
-                cmsCloseProfile(hICC);
-                return NULL;
-       }
+    hICC = cmsCreateProfilePlaceholder(ContextID);
+    if (!hICC)                          // can't allocate
+        return NULL;
 
-       cmsPipelineInsertStage(Pipeline, cmsAT_END, CLUT);
 
-       // Create tags
+    cmsSetDeviceClass(hICC,      cmsSigAbstractClass);
+    cmsSetColorSpace(hICC,       cmsSigLabData);
+    cmsSetPCS(hICC,              cmsSigLabData);
 
-       if (!SetTextTags(hICC, L"BCHS built-in")) return NULL;
+    cmsSetHeaderRenderingIntent(hICC,  INTENT_PERCEPTUAL);
 
-       cmsWriteTag(hICC, cmsSigMediaWhitePointTag, (void*) cmsD50_XYZ());
+    // Creates a Pipeline with 3D grid only
+    Pipeline = cmsPipelineAlloc(ContextID, 3, 3);
+    if (Pipeline == NULL) {
+        cmsCloseProfile(hICC);
+        return NULL;
+    }
+
+    for (i=0; i < MAX_INPUT_DIMENSIONS; i++) Dimensions[i] = nLUTPoints;
+    CLUT = cmsStageAllocCLut16bitGranular(ContextID, Dimensions, 3, 3, NULL);
+    if (CLUT == NULL) return NULL;
+
+
+    if (!cmsStageSampleCLut16bit(CLUT, bchswSampler, (void*) &bchsw, 0)) {
+
+        // Shouldn't reach here
+        goto Error;
+    }
+
+    if (!cmsPipelineInsertStage(Pipeline, cmsAT_END, CLUT)) {
+        goto Error;
+    }
+
+    // Create tags
+    if (!SetTextTags(hICC, L"BCHS built-in")) return NULL;
+
+    cmsWriteTag(hICC, cmsSigMediaWhitePointTag, (void*) cmsD50_XYZ());
 
-       cmsWriteTag(hICC, cmsSigAToB0Tag, (void*) Pipeline);
+    cmsWriteTag(hICC, cmsSigAToB0Tag, (void*) Pipeline);
 
-       // Pipeline is already on virtual profile
-       cmsPipelineFree(Pipeline);
+    // Pipeline is already on virtual profile
+    cmsPipelineFree(Pipeline);
 
-       // Ok, done
-       return hICC;
+    // Ok, done
+    return hICC;
+
+Error:
+    cmsPipelineFree(Pipeline);
+    cmsCloseProfile(hICC);
+    return NULL;
 }
 
 
@@ -856,7 +877,8 @@
     PostLin = cmsStageAllocToneCurves(ContextID, 1, &EmptyTab);
     cmsFreeToneCurve(EmptyTab);
 
-    cmsPipelineInsertStage(LUT, cmsAT_END, PostLin);
+    if (!cmsPipelineInsertStage(LUT, cmsAT_END, PostLin))
+        goto Error;
 
     if (!cmsWriteTag(hProfile, cmsSigBToA0Tag, (void*) LUT)) goto Error;
     if (!cmsWriteTag(hProfile, cmsSigMediaWhitePointTag, cmsD50_XYZ())) goto Error;
@@ -999,6 +1021,7 @@
 
     { FALSE, 0,              cmsSigLut16Type,    4,  { cmsSigMatrixElemType,  cmsSigCurveSetElemType, cmsSigCLutElemType, cmsSigCurveSetElemType}},
     { FALSE, 0,              cmsSigLut16Type,    3,  { cmsSigCurveSetElemType, cmsSigCLutElemType, cmsSigCurveSetElemType}},
+    { FALSE, 0,              cmsSigLut16Type,    2,  { cmsSigCurveSetElemType, cmsSigCLutElemType}},
     { TRUE , 0,              cmsSigLutAtoBType,  1,  { cmsSigCurveSetElemType }},
     { TRUE , cmsSigAToB0Tag, cmsSigLutAtoBType,  3,  { cmsSigCurveSetElemType, cmsSigMatrixElemType, cmsSigCurveSetElemType } },
     { TRUE , cmsSigAToB0Tag, cmsSigLutAtoBType,  3,  { cmsSigCurveSetElemType, cmsSigCLutElemType, cmsSigCurveSetElemType   } },
@@ -1059,6 +1082,7 @@
     cmsContext ContextID = cmsGetTransformContextID(hTransform);
     const cmsAllowedLUT* AllowedLUT;
     cmsTagSignature DestinationTag;
+    cmsProfileClassSignature deviceClass;
 
     _cmsAssert(hTransform != NULL);
 
@@ -1080,13 +1104,15 @@
     // Time to fix the Lab2/Lab4 issue.
     if ((xform ->EntryColorSpace == cmsSigLabData) && (Version < 4.0)) {
 
-        cmsPipelineInsertStage(LUT, cmsAT_BEGIN, _cmsStageAllocLabV2ToV4curves(ContextID));
+        if (!cmsPipelineInsertStage(LUT, cmsAT_BEGIN, _cmsStageAllocLabV2ToV4curves(ContextID)))
+            goto Error;
     }
 
     // On the output side too
     if ((xform ->ExitColorSpace) == cmsSigLabData && (Version < 4.0)) {
 
-        cmsPipelineInsertStage(LUT, cmsAT_END, _cmsStageAllocLabV4ToV2(ContextID));
+        if (!cmsPipelineInsertStage(LUT, cmsAT_END, _cmsStageAllocLabV4ToV2(ContextID)))
+            goto Error;
     }
 
 
@@ -1108,8 +1134,9 @@
     FrmIn  = COLORSPACE_SH(ColorSpaceBitsIn) | CHANNELS_SH(ChansIn)|BYTES_SH(2);
     FrmOut = COLORSPACE_SH(ColorSpaceBitsOut) | CHANNELS_SH(ChansOut)|BYTES_SH(2);
 
+    deviceClass = cmsGetDeviceClass(hProfile);
 
-     if (cmsGetDeviceClass(hProfile) == cmsSigOutputClass)
+     if (deviceClass == cmsSigOutputClass)
          DestinationTag = cmsSigBToA0Tag;
      else
          DestinationTag = cmsSigAToB0Tag;
@@ -1136,10 +1163,12 @@
 
         // Put identity curves if needed
         if (cmsPipelineGetPtrToFirstStage(LUT) ->Type != cmsSigCurveSetElemType)
-             cmsPipelineInsertStage(LUT, cmsAT_BEGIN, _cmsStageAllocIdentityCurves(ContextID, ChansIn));
+             if (!cmsPipelineInsertStage(LUT, cmsAT_BEGIN, _cmsStageAllocIdentityCurves(ContextID, ChansIn)))
+                 goto Error;
 
         if (cmsPipelineGetPtrToLastStage(LUT) ->Type != cmsSigCurveSetElemType)
-             cmsPipelineInsertStage(LUT, cmsAT_END,   _cmsStageAllocIdentityCurves(ContextID, ChansOut));
+             if (!cmsPipelineInsertStage(LUT, cmsAT_END,   _cmsStageAllocIdentityCurves(ContextID, ChansOut)))
+                 goto Error;
 
         AllowedLUT = FindCombination(LUT, Version >= 4.0, DestinationTag);
     }
@@ -1168,10 +1197,22 @@
            if (!cmsWriteTag(hProfile, cmsSigColorantTableOutTag, xform->OutputColorant)) goto Error;
     }
 
-    if (xform ->Sequence != NULL) {
+    if ((deviceClass == cmsSigLinkClass) && (xform ->Sequence != NULL)) {
         if (!_cmsWriteProfileSequence(hProfile, xform ->Sequence)) goto Error;
     }
 
+    // Set the white point
+    if (deviceClass == cmsSigInputClass) {
+        if (!cmsWriteTag(hProfile, cmsSigMediaWhitePointTag, &xform ->EntryWhitePoint)) goto Error;
+    }
+    else {
+         if (!cmsWriteTag(hProfile, cmsSigMediaWhitePointTag, &xform ->ExitWhitePoint)) goto Error;
+    }
+
+
+    // Per 7.2.15 in spec 4.3
+    cmsSetHeaderRenderingIntent(hProfile, xform ->RenderingIntent);
+
     cmsPipelineFree(LUT);
     return hProfile;
 
--- jdk/src/share/native/sun/java2d/cmm/lcms/cmswtpnt.c
+++ jdk/src/share/native/sun/java2d/cmm/lcms/cmswtpnt.c
@@ -30,7 +30,7 @@
 //---------------------------------------------------------------------------------
 //
 //  Little Color Management System
-//  Copyright (c) 1998-2010 Marti Maria Saguer
+//  Copyright (c) 1998-2012 Marti Maria Saguer
 //
 // Permission is hereby granted, free of charge, to any person obtaining
 // a copy of this software and associated documentation files (the "Software"),
@@ -76,48 +76,48 @@
 // Obtains WhitePoint from Temperature
 cmsBool  CMSEXPORT cmsWhitePointFromTemp(cmsCIExyY* WhitePoint, cmsFloat64Number TempK)
 {
-       cmsFloat64Number x, y;
-       cmsFloat64Number T, T2, T3;
-       // cmsFloat64Number M1, M2;
+    cmsFloat64Number x, y;
+    cmsFloat64Number T, T2, T3;
+    // cmsFloat64Number M1, M2;
 
-       _cmsAssert(WhitePoint != NULL);
-
-       T = TempK;
-       T2 = T*T;            // Square
-       T3 = T2*T;           // Cube
-
-       // For correlated color temperature (T) between 4000K and 7000K:
+    _cmsAssert(WhitePoint != NULL);
 
-       if (T >= 4000. && T <= 7000.)
-       {
-              x = -4.6070*(1E9/T3) + 2.9678*(1E6/T2) + 0.09911*(1E3/T) + 0.244063;
-       }
-       else
-              // or for correlated color temperature (T) between 7000K and 25000K:
+    T = TempK;
+    T2 = T*T;            // Square
+    T3 = T2*T;           // Cube
+
+    // For correlated color temperature (T) between 4000K and 7000K:
+
+    if (T >= 4000. && T <= 7000.)
+    {
+        x = -4.6070*(1E9/T3) + 2.9678*(1E6/T2) + 0.09911*(1E3/T) + 0.244063;
+    }
+    else
+        // or for correlated color temperature (T) between 7000K and 25000K:
 
-       if (T > 7000.0 && T <= 25000.0)
-       {
-              x = -2.0064*(1E9/T3) + 1.9018*(1E6/T2) + 0.24748*(1E3/T) + 0.237040;
-       }
-       else {
-              cmsSignalError(0, cmsERROR_RANGE, "cmsWhitePointFromTemp: invalid temp");
-              return FALSE;
-              }
+        if (T > 7000.0 && T <= 25000.0)
+        {
+            x = -2.0064*(1E9/T3) + 1.9018*(1E6/T2) + 0.24748*(1E3/T) + 0.237040;
+        }
+        else {
+            cmsSignalError(0, cmsERROR_RANGE, "cmsWhitePointFromTemp: invalid temp");
+            return FALSE;
+        }
 
-       // Obtain y(x)
+        // Obtain y(x)
 
-       y = -3.000*(x*x) + 2.870*x - 0.275;
+        y = -3.000*(x*x) + 2.870*x - 0.275;
 
-       // wave factors (not used, but here for futures extensions)
+        // wave factors (not used, but here for futures extensions)
 
-       // M1 = (-1.3515 - 1.7703*x + 5.9114 *y)/(0.0241 + 0.2562*x - 0.7341*y);
-       // M2 = (0.0300 - 31.4424*x + 30.0717*y)/(0.0241 + 0.2562*x - 0.7341*y);
+        // M1 = (-1.3515 - 1.7703*x + 5.9114 *y)/(0.0241 + 0.2562*x - 0.7341*y);
+        // M2 = (0.0300 - 31.4424*x + 30.0717*y)/(0.0241 + 0.2562*x - 0.7341*y);
 
-       WhitePoint -> x = x;
-       WhitePoint -> y = y;
-       WhitePoint -> Y = 1.0;
+        WhitePoint -> x = x;
+        WhitePoint -> y = y;
+        WhitePoint -> Y = 1.0;
 
-       return TRUE;
+        return TRUE;
 }
 
 
@@ -266,7 +266,7 @@
         {{  0.8951,  0.2664, -0.1614 }},
         {{ -0.7502,  1.7135,  0.0367 }},
         {{  0.0389, -0.0685,  1.0296 }}
-      }};
+    }};
 
     if (ConeMatrix == NULL)
         ConeMatrix = &LamRigg;
--- jdk/src/share/native/sun/java2d/cmm/lcms/cmsxform.c
+++ jdk/src/share/native/sun/java2d/cmm/lcms/cmsxform.c
@@ -396,7 +396,7 @@
 static _cmsTransformCollection* TransformCollection = NULL;
 
 // Register new ways to transform
-cmsBool  _cmsRegisterTransformPlugin(cmsPluginBase* Data)
+cmsBool  _cmsRegisterTransformPlugin(cmsContext id, cmsPluginBase* Data)
 {
     cmsPluginTransform* Plugin = (cmsPluginTransform*) Data;
     _cmsTransformCollection* fl;
@@ -412,7 +412,7 @@
    if (Plugin ->Factory == NULL) return FALSE;
 
 
-    fl = (_cmsTransformCollection*) _cmsPluginMalloc(sizeof(_cmsTransformCollection));
+    fl = (_cmsTransformCollection*) _cmsPluginMalloc(id, sizeof(_cmsTransformCollection));
     if (fl == NULL) return FALSE;
 
       // Copy the parameters
@@ -651,6 +651,22 @@
 
 // ----------------------------------------------------------------------------------------------------------------
 
+static
+void SetWhitePoint(cmsCIEXYZ* wtPt, const cmsCIEXYZ* src)
+{
+    if (src == NULL) {
+        wtPt ->X = cmsD50X;
+        wtPt ->Y = cmsD50Y;
+        wtPt ->Z = cmsD50Z;
+    }
+    else {
+        wtPt ->X = src->X;
+        wtPt ->Y = src->Y;
+        wtPt ->Z = src->Z;
+    }
+
+}
+
 // New to lcms 2.0 -- have all parameters available.
 cmsHTRANSFORM CMSEXPORT cmsCreateExtendedTransform(cmsContext ContextID,
                                                    cmsUInt32Number nProfiles, cmsHPROFILE hProfiles[],
@@ -664,7 +680,6 @@
                                                    cmsUInt32Number dwFlags)
 {
     _cmsTRANSFORM* xform;
-    cmsBool  FloatTransform;
     cmsColorSpaceSignature EntryColorSpace;
     cmsColorSpaceSignature ExitColorSpace;
     cmsPipeline* Lut;
@@ -681,9 +696,7 @@
         if (hGamutProfile == NULL) dwFlags &= ~cmsFLAGS_GAMUTCHECK;
     }
 
-    // On floating point transforms, inhibit optimizations
-    FloatTransform = (_cmsFormatterIsFloat(InputFormat) && _cmsFormatterIsFloat(OutputFormat));
-
+    // On floating point transforms, inhibit cache
     if (_cmsFormatterIsFloat(InputFormat) || _cmsFormatterIsFloat(OutputFormat))
         dwFlags |= cmsFLAGS_NOCACHE;
 
@@ -730,6 +743,10 @@
     xform ->ExitColorSpace  = ExitColorSpace;
     xform ->RenderingIntent = Intents[nProfiles-1];
 
+    // Take white points
+    SetWhitePoint(&xform->EntryWhitePoint, (cmsCIEXYZ*) cmsReadTag(hProfiles[0], cmsSigMediaWhitePointTag));
+    SetWhitePoint(&xform->ExitWhitePoint,  (cmsCIEXYZ*) cmsReadTag(hProfiles[nProfiles-1], cmsSigMediaWhitePointTag));
+
 
     // Create a gamut check LUT if requested
     if (hGamutProfile != NULL && (dwFlags & cmsFLAGS_GAMUTCHECK))
--- jdk/src/share/native/sun/java2d/cmm/lcms/lcms2.h
+++ jdk/src/share/native/sun/java2d/cmm/lcms/lcms2.h
@@ -30,7 +30,7 @@
 //---------------------------------------------------------------------------------
 //
 //  Little Color Management System
-//  Copyright (c) 1998-2011 Marti Maria Saguer
+//  Copyright (c) 1998-2013 Marti Maria Saguer
 //
 // Permission is hereby granted, free of charge, to any person obtaining
 // a copy of this software and associated documentation files (the "Software"),
@@ -52,7 +52,7 @@
 //
 //---------------------------------------------------------------------------------
 //
-// Version 2.4
+// Version 2.5
 //
 
 #ifndef _lcms2_H
@@ -101,7 +101,7 @@
 #endif
 
 // Version/release
-#define LCMS_VERSION        2040
+#define LCMS_VERSION        2050
 
 // I will give the chance of redefining basic types for compilers that are not fully C99 compliant
 #ifndef CMS_BASIC_TYPES_ALREADY_DEFINED
@@ -367,6 +367,7 @@
     cmsSigPreview1Tag                       = 0x70726531,  // 'pre1'
     cmsSigPreview2Tag                       = 0x70726532,  // 'pre2'
     cmsSigProfileDescriptionTag             = 0x64657363,  // 'desc'
+    cmsSigProfileDescriptionMLTag           = 0x6473636d,  // 'dscm'
     cmsSigProfileSequenceDescTag            = 0x70736571,  // 'pseq'
     cmsSigProfileSequenceIdTag              = 0x70736964,  // 'psid'
     cmsSigPs2CRD0Tag                        = 0x70736430,  // 'psd0'
@@ -1014,6 +1015,7 @@
 // Plug-In registering  ---------------------------------------------------------------------------------------------------
 
 CMSAPI cmsBool           CMSEXPORT cmsPlugin(void* Plugin);
+CMSAPI cmsBool           CMSEXPORT cmsPluginTHR(cmsContext ContextID, void* Plugin);
 CMSAPI void              CMSEXPORT cmsUnregisterPlugins(void);
 
 // Error logging ----------------------------------------------------------------------------------------------------------
@@ -1190,7 +1192,7 @@
 // Where to place/locate the stages in the pipeline chain
 typedef enum { cmsAT_BEGIN, cmsAT_END } cmsStageLoc;
 
-CMSAPI void              CMSEXPORT cmsPipelineInsertStage(cmsPipeline* lut, cmsStageLoc loc, cmsStage* mpe);
+CMSAPI int               CMSEXPORT cmsPipelineInsertStage(cmsPipeline* lut, cmsStageLoc loc, cmsStage* mpe);
 CMSAPI void              CMSEXPORT cmsPipelineUnlinkStage(cmsPipeline* lut, cmsStageLoc loc, cmsStage** mpe);
 
 // This function is quite useful to analyze the structure of a Pipeline and retrieve the Stage elements
@@ -1274,6 +1276,13 @@
                                                          const char LanguageCode[3], const char CountryCode[3],
                                                          char ObtainedLanguage[3], char ObtainedCountry[3]);
 
+CMSAPI cmsUInt32Number   CMSEXPORT cmsMLUtranslationsCount(const cmsMLU* mlu);
+
+CMSAPI cmsBool           CMSEXPORT cmsMLUtranslationsCodes(const cmsMLU* mlu,
+                                                             cmsUInt32Number idx,
+                                                             char LanguageCode[3],
+                                                             char CountryCode[3]);
+
 // Undercolorremoval & black generation -------------------------------------------------------------------------------------
 
 typedef struct {
@@ -1424,6 +1433,7 @@
 CMSAPI void              CMSEXPORT cmsSetHeaderFlags(cmsHPROFILE hProfile, cmsUInt32Number Flags);
 CMSAPI cmsUInt32Number   CMSEXPORT cmsGetHeaderManufacturer(cmsHPROFILE hProfile);
 CMSAPI void              CMSEXPORT cmsSetHeaderManufacturer(cmsHPROFILE hProfile, cmsUInt32Number manufacturer);
+CMSAPI cmsUInt32Number   CMSEXPORT cmsGetHeaderCreator(cmsHPROFILE hProfile);
 CMSAPI cmsUInt32Number   CMSEXPORT cmsGetHeaderModel(cmsHPROFILE hProfile);
 CMSAPI void              CMSEXPORT cmsSetHeaderModel(cmsHPROFILE hProfile, cmsUInt32Number model);
 CMSAPI void              CMSEXPORT cmsSetHeaderAttributes(cmsHPROFILE hProfile, cmsUInt64Number Flags);
--- jdk/src/share/native/sun/java2d/cmm/lcms/lcms2_internal.h
+++ jdk/src/share/native/sun/java2d/cmm/lcms/lcms2_internal.h
@@ -27,7 +27,7 @@
 // However, the following notice accompanied the original version of this
 // file:
 //
-//---------------------------------------------------------------------------------
+
 //
 //  Little Color Management System
 //  Copyright (c) 1998-2011 Marti Maria Saguer
@@ -196,7 +196,7 @@
 // Plug-In registering ---------------------------------------------------------------
 
 // Specialized function for plug-in memory management. No pairing free() since whole pool is freed at once.
-void* _cmsPluginMalloc(cmsUInt32Number size);
+void* _cmsPluginMalloc(cmsContext ContextID, cmsUInt32Number size);
 
 // Memory management
 cmsBool   _cmsRegisterMemHandlerPlugin(cmsPluginBase* Plugin);
@@ -205,28 +205,28 @@
 cmsBool  _cmsRegisterInterpPlugin(cmsPluginBase* Plugin);
 
 // Parametric curves
-cmsBool  _cmsRegisterParametricCurvesPlugin(cmsPluginBase* Plugin);
+cmsBool  _cmsRegisterParametricCurvesPlugin(cmsContext ContextID, cmsPluginBase* Plugin);
 
 // Formatters management
-cmsBool  _cmsRegisterFormattersPlugin(cmsPluginBase* Plugin);
+cmsBool  _cmsRegisterFormattersPlugin(cmsContext ContextID, cmsPluginBase* Plugin);
 
 // Tag type management
-cmsBool  _cmsRegisterTagTypePlugin(cmsPluginBase* Plugin);
+cmsBool  _cmsRegisterTagTypePlugin(cmsContext ContextID, cmsPluginBase* Plugin);
 
 // Tag management
-cmsBool  _cmsRegisterTagPlugin(cmsPluginBase* Plugin);
+cmsBool  _cmsRegisterTagPlugin(cmsContext ContextID, cmsPluginBase* Plugin);
 
 // Intent management
-cmsBool  _cmsRegisterRenderingIntentPlugin(cmsPluginBase* Plugin);
+cmsBool  _cmsRegisterRenderingIntentPlugin(cmsContext ContextID, cmsPluginBase* Plugin);
 
 // Multi Process elements
-cmsBool  _cmsRegisterMultiProcessElementPlugin(cmsPluginBase* Plugin);
+cmsBool  _cmsRegisterMultiProcessElementPlugin(cmsContext ContextID, cmsPluginBase* Plugin);
 
 // Optimization
-cmsBool  _cmsRegisterOptimizationPlugin(cmsPluginBase* Plugin);
+cmsBool  _cmsRegisterOptimizationPlugin(cmsContext ContextID, cmsPluginBase* Plugin);
 
 // Transform
-cmsBool  _cmsRegisterTransformPlugin(cmsPluginBase* Plugin);
+cmsBool  _cmsRegisterTransformPlugin(cmsContext ContextID, cmsPluginBase* Plugin);
 
 // ---------------------------------------------------------------------------------------------------------
 
@@ -263,7 +263,7 @@
     cmsUInt16Number Country;
 
     cmsUInt32Number StrW;       // Offset to current unicode string
-    cmsUInt32Number Len;        // Lenght in bytes
+    cmsUInt32Number Len;        // Length in bytes
 
 } _cmsMLUentry;
 
@@ -330,9 +330,11 @@
     cmsColorSpaceSignature   ColorSpace;
     cmsColorSpaceSignature   PCS;
     cmsUInt32Number          RenderingIntent;
+
     cmsUInt32Number          flags;
     cmsUInt32Number          manufacturer, model;
     cmsUInt64Number          attributes;
+    cmsUInt32Number          creator;
 
     cmsProfileID             ProfileID;
 
@@ -585,6 +587,10 @@
     cmsColorSpaceSignature EntryColorSpace;
     cmsColorSpaceSignature ExitColorSpace;
 
+    // White points (informative only)
+    cmsCIEXYZ EntryWhitePoint;
+    cmsCIEXYZ ExitWhitePoint;
+
     // Profiles used to create the transform
     cmsSEQ* Sequence;
 
--- jdk/src/share/native/sun/management/Flag.c
+++ jdk/src/share/native/sun/management/Flag.c
@@ -95,12 +95,12 @@
         return 0;
     }
 
-    if (count == 0) {
+    if (count <= 0) {
         JNU_ThrowIllegalArgumentException(env, 0);
         return 0;
     }
 
-    gsize = count * sizeof(jmmVMGlobal);
+    gsize = (size_t)count * sizeof(jmmVMGlobal);
     globals = (jmmVMGlobal*) malloc(gsize);
     if (globals == NULL) {
         JNU_ThrowOutOfMemoryError(env, 0);
--- jdk/src/share/native/sun/management/GcInfoBuilder.c
+++ jdk/src/share/native/sun/management/GcInfoBuilder.c
@@ -59,12 +59,12 @@
         return;
     }
 
-    if (num_attributes == 0) {
+    if (num_attributes <= 0) {
         JNU_ThrowIllegalArgumentException(env, "Invalid num_attributes");
         return;
     }
 
-    ext_att_info = (jmmExtAttributeInfo*) malloc(num_attributes *
+    ext_att_info = (jmmExtAttributeInfo*) malloc((size_t)num_attributes *
                                                  sizeof(jmmExtAttributeInfo));
     if (ext_att_info == NULL) {
         JNU_ThrowOutOfMemoryError(env, 0);
@@ -78,7 +78,7 @@
         return;
     }
 
-    nativeTypes = (jchar*) malloc(num_attributes * sizeof(jchar));
+    nativeTypes = (jchar*) malloc((size_t)num_attributes * sizeof(jchar));
     if (nativeTypes == NULL) {
         free(ext_att_info);
         JNU_ThrowOutOfMemoryError(env, 0);
@@ -188,11 +188,16 @@
         return 0;
     }
 
+    if (ext_att_count <= 0) {
+        JNU_ThrowIllegalArgumentException(env, "Invalid ext_att_count");
+        return;
+    }
+
     gc_stat.usage_before_gc = usageBeforeGC;
     gc_stat.usage_after_gc = usageAfterGC;
     gc_stat.gc_ext_attribute_values_size = ext_att_count;
     if (ext_att_count > 0) {
-        gc_stat.gc_ext_attribute_values = (jvalue*) malloc(ext_att_count *
+        gc_stat.gc_ext_attribute_values = (jvalue*) malloc((size_t)ext_att_count *
                                                            sizeof(jvalue));
         if (gc_stat.gc_ext_attribute_values == NULL) {
             JNU_ThrowOutOfMemoryError(env, 0);
@@ -212,7 +217,7 @@
     }
 
     // convert the ext_att_types to native types
-    nativeTypes = (jchar*) malloc(ext_att_count * sizeof(jchar));
+    nativeTypes = (jchar*) malloc((size_t)ext_att_count * sizeof(jchar));
     if (nativeTypes == NULL) {
         if (gc_stat.gc_ext_attribute_values != NULL) {
             free(gc_stat.gc_ext_attribute_values);
--- jdk/src/solaris/classes/sun/awt/X11/XClipboard.java
+++ jdk/src/solaris/classes/sun/awt/X11/XClipboard.java
@@ -86,7 +86,7 @@
     protected synchronized void setContentsNative(Transferable contents) {
         SortedMap<Long,DataFlavor> formatMap =
             DataTransferer.getInstance().getFormatsForTransferable
-                (contents, DataTransferer.adaptFlavorMap(flavorMap));
+                (contents, DataTransferer.adaptFlavorMap(getDefaultFlavorTable()));
         long[] formats = DataTransferer.keysToLongArray(formatMap);
 
         if (!selection.setOwner(contents, formatMap, formats,
@@ -125,7 +125,7 @@
     private void checkChangeHere(Transferable contents) {
         if (areFlavorListenersRegistered()) {
             checkChange(DataTransferer.getInstance().
-                        getFormatsForTransferableAsArray(contents, flavorMap));
+                        getFormatsForTransferableAsArray(contents, getDefaultFlavorTable()));
         }
     }
 
--- jdk/src/solaris/classes/sun/awt/X11/XToolkit.java
+++ jdk/src/solaris/classes/sun/awt/X11/XToolkit.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2002, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2002, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -49,7 +49,7 @@
 import sun.awt.*;
 import sun.font.FontConfigManager;
 import sun.java2d.SunGraphicsEnvironment;
-import sun.misc.PerformanceLogger;
+import sun.misc.*;
 import sun.print.PrintJob2D;
 import sun.security.action.GetPropertyAction;
 import sun.security.action.GetBooleanAction;
@@ -254,33 +254,25 @@
         } finally {
             awtUnlock();
         }
-        PrivilegedAction<Void> a = new PrivilegedAction<Void>() {
-            public Void run() {
-                ThreadGroup mainTG = Thread.currentThread().getThreadGroup();
-                ThreadGroup parentTG = mainTG.getParent();
-                while (parentTG != null) {
-                    mainTG = parentTG;
-                    parentTG = mainTG.getParent();
-                }
-                Thread shutdownThread = new Thread(mainTG, "XToolkt-Shutdown-Thread") {
-                        public void run() {
-                            XSystemTrayPeer peer = XSystemTrayPeer.getPeerInstance();
-                            if (peer != null) {
-                                peer.dispose();
-                            }
-                            if (xs != null) {
-                                ((XAWTXSettings)xs).dispose();
-                            }
-                            freeXKB();
-                            if (log.isLoggable(PlatformLogger.Level.FINE)) {
-                                dumpPeers();
-                            }
+        PrivilegedAction<Void> a = () -> {
+            Thread shutdownThread = new Thread(sun.misc.ThreadGroupUtils.getRootThreadGroup(), "XToolkt-Shutdown-Thread") {
+                    public void run() {
+                        XSystemTrayPeer peer = XSystemTrayPeer.getPeerInstance();
+                        if (peer != null) {
+                            peer.dispose();
                         }
-                    };
-                shutdownThread.setContextClassLoader(null);
-                Runtime.getRuntime().addShutdownHook(shutdownThread);
-                return null;
-            }
+                        if (xs != null) {
+                            ((XAWTXSettings)xs).dispose();
+                        }
+                        freeXKB();
+                        if (log.isLoggable(PlatformLogger.Level.FINE)) {
+                            dumpPeers();
+                        }
+                    }
+                };
+            shutdownThread.setContextClassLoader(null);
+            Runtime.getRuntime().addShutdownHook(shutdownThread);
+            return null;
         };
         AccessController.doPrivileged(a);
     }
@@ -324,22 +316,13 @@
             init();
             XWM.init();
             SunToolkit.setDataTransfererClassName(DATA_TRANSFERER_CLASS_NAME);
-
-            PrivilegedAction<Thread> action = new PrivilegedAction() {
-                public Thread run() {
-                    ThreadGroup currentTG = Thread.currentThread().getThreadGroup();
-                    ThreadGroup parentTG = currentTG.getParent();
-                    while (parentTG != null) {
-                        currentTG = parentTG;
-                        parentTG = currentTG.getParent();
-                    }
-                    Thread thread = new Thread(currentTG, XToolkit.this, "AWT-XAWT");
-                    thread.setPriority(Thread.NORM_PRIORITY + 1);
-                    thread.setDaemon(true);
-                    return thread;
-                }
-            };
-            toolkitThread = AccessController.doPrivileged(action);
+            toolkitThread = AccessController.doPrivileged((PrivilegedAction<Thread>) () -> {
+                Thread thread = new Thread(sun.misc.ThreadGroupUtils.getRootThreadGroup(), XToolkit.this, "AWT-XAWT");
+                thread.setContextClassLoader(null);
+                thread.setPriority(Thread.NORM_PRIORITY + 1);
+                thread.setDaemon(true);
+                return thread;
+            });
             toolkitThread.start();
         }
     }
--- jdk/src/solaris/classes/sun/awt/X11GraphicsDevice.java
+++ jdk/src/solaris/classes/sun/awt/X11GraphicsDevice.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -42,6 +42,8 @@
 import sun.java2d.xr.XRGraphicsConfig;
 import sun.java2d.loops.SurfaceType;
 
+import sun.misc.ThreadGroupUtils;
+
 /**
  * This is an implementation of a GraphicsDevice object for a single
  * X11 screen.
@@ -423,28 +425,19 @@
             // is already in the original DisplayMode at that time, this
             // hook will have no effect)
             shutdownHookRegistered = true;
-            PrivilegedAction<Void> a = new PrivilegedAction<Void>() {
-                public Void run() {
-                    ThreadGroup mainTG = Thread.currentThread().getThreadGroup();
-                    ThreadGroup parentTG = mainTG.getParent();
-                    while (parentTG != null) {
-                        mainTG = parentTG;
-                        parentTG = mainTG.getParent();
+            PrivilegedAction<Void> a = () -> {
+                ThreadGroup rootTG = ThreadGroupUtils.getRootThreadGroup();
+                Runnable r = () -> {
+                    Window old = getFullScreenWindow();
+                    if (old != null) {
+                        exitFullScreenExclusive(old);
+                        setDisplayMode(origDisplayMode);
                     }
-                    Runnable r = new Runnable() {
-                            public void run() {
-                                Window old = getFullScreenWindow();
-                                if (old != null) {
-                                    exitFullScreenExclusive(old);
-                                    setDisplayMode(origDisplayMode);
-                                }
-                            }
-                        };
-                    Thread t = new Thread(mainTG, r,"Display-Change-Shutdown-Thread-"+screen);
-                    t.setContextClassLoader(null);
-                    Runtime.getRuntime().addShutdownHook(t);
-                    return null;
-                }
+                };
+                Thread t = new Thread(rootTG, r,"Display-Change-Shutdown-Thread-"+screen);
+                t.setContextClassLoader(null);
+                Runtime.getRuntime().addShutdownHook(t);
+                return null;
             };
             AccessController.doPrivileged(a);
         }
--- jdk/src/solaris/demo/jni/Poller/Poller.c
+++ jdk/src/solaris/demo/jni/Poller/Poller.c
@@ -318,7 +318,7 @@
 
   ioevent_t *ioeh;
 
-  if (handle < 0 || handle > MAX_HANDLES)
+  if (handle < 0 || handle >= MAX_HANDLES)
     {
       STATE_EXCEPTION("DestroyPoller - handle out of range");
       return;
@@ -366,7 +366,7 @@
   int retval;
   ioevent_t *ioeh;
 
-  if (handle < 0 || handle > MAX_HANDLES)
+  if (handle < 0 || handle >= MAX_HANDLES)
     return STATE_EXCEPTION("AddFd - handle out of range");
 
   ioeh = &IOE_handles[handle];
@@ -459,7 +459,7 @@
   return fd;
 }
 
-/*
+/*
  * Class:     Poller
  * Method:    nativeRemoveFd
  * Signature: (II)I
@@ -469,7 +469,7 @@
 {
   ioevent_t *ioeh;
 
-  if (handle < 0 || handle > MAX_HANDLES)
+  if (handle < 0 || handle >= MAX_HANDLES)
     return STATE_EXCEPTION("RemoveFd - handle out of range");
 
   ioeh = &IOE_handles[handle];
@@ -576,7 +576,7 @@
   int i;
   ioevent_t *ioeh;
 
-  if (handle < 0 || handle > MAX_HANDLES)
+  if (handle < 0 || handle >= MAX_HANDLES)
     return STATE_EXCEPTION("IsMember - handle out of range");
 
   ioeh = &IOE_handles[handle];
@@ -629,7 +629,7 @@
   ioevent_t *ioeh;
   jboolean isCopy1,isCopy2;
 
-  if (handle < 0 || handle > MAX_HANDLES)
+  if (handle < 0 || handle >= MAX_HANDLES)
     return STATE_EXCEPTION("nativeWait - handle out of range");
 
   ioeh = &IOE_handles[handle];
--- jdk/src/solaris/native/com/sun/media/sound/PLATFORM_API_SolarisOS_Utils.c
+++ jdk/src/solaris/native/com/sun/media/sound/PLATFORM_API_SolarisOS_Utils.c
@@ -76,7 +76,7 @@
             adPath[*count].st_ino = statBuf.st_ino;
             adPath[*count].st_dev = statBuf.st_dev;
             strncpy(adPath[*count].path, path, MAX_NAME_LENGTH);
-            adPath[*count].path[MAX_NAME_LENGTH] = 0;
+            adPath[*count].path[MAX_NAME_LENGTH - 1] = 0;
             (*count)++;
             TRACE1("Added audio device %s\n", path);
         }
--- jdk/src/solaris/native/sun/awt/awt_LoadLibrary.c
+++ jdk/src/solaris/native/sun/awt/awt_LoadLibrary.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -109,7 +109,7 @@
     jvm = vm;
 
     /* Get address of this library and the directory containing it. */
-    dladdr((void *)JNI_OnLoad, &dlinfo);
+    dladdr((void *)AWT_OnLoad, &dlinfo);
     realpath((char *)dlinfo.dli_fname, buf);
     len = strlen(buf);
     p = strrchr(buf, '/');
--- jdk/src/windows/classes/sun/awt/shell/Win32ShellFolderManager2.java
+++ jdk/src/windows/classes/sun/awt/shell/Win32ShellFolderManager2.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -39,6 +39,7 @@
 
 import static sun.awt.shell.Win32ShellFolder2.*;
 import sun.awt.OSInfo;
+import sun.misc.ThreadGroupUtils;
 
 // NOTE: This class supersedes Win32ShellFolderManager, which was removed
 //       from distribution after version 1.4.2.
@@ -509,23 +510,16 @@
                     }
                 }
             };
-            comThread =
-                AccessController.doPrivileged(
-                    new PrivilegedAction<Thread>() {
-                        public Thread run() {
+            comThread =  AccessController.doPrivileged((PrivilegedAction<Thread>) () -> {
                             /* The thread must be a member of a thread group
                              * which will not get GCed before VM exit.
                              * Make its parent the top-level thread group.
                              */
-                            ThreadGroup tg = Thread.currentThread().getThreadGroup();
-                            for (ThreadGroup tgn = tg;
-                                 tgn != null;
-                                 tg = tgn, tgn = tg.getParent());
-                            Thread thread = new Thread(tg, comRun, "Swing-Shell");
+                            ThreadGroup rootTG = ThreadGroupUtils.getRootThreadGroup();
+                            Thread thread = new Thread(rootTG, comRun, "Swing-Shell");
                             thread.setDaemon(true);
                             return thread;
                         }
-                    }
                 );
             return comThread;
         }
--- jdk/src/windows/classes/sun/awt/windows/WClipboard.java
+++ jdk/src/windows/classes/sun/awt/windows/WClipboard.java
@@ -63,7 +63,6 @@
     }
 
     protected void setContentsNative(Transferable contents) {
-
         // Don't use delayed Clipboard rendering for the Transferable's data.
         // If we did that, we would call Transferable.getTransferData on
         // the Toolkit thread, which is a security hole.
@@ -72,7 +71,7 @@
         // translated. Then, for each format, translate the data and post
         // it to the Clipboard.
         Map <Long, DataFlavor> formatMap = WDataTransferer.getInstance().
-            getFormatsForTransferable(contents, flavorMap);
+            getFormatsForTransferable(contents, getDefaultFlavorTable());
 
         openClipboard(this);
 
--- jdk/src/windows/classes/sun/awt/windows/WToolkit.java
+++ jdk/src/windows/classes/sun/awt/windows/WToolkit.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -39,6 +39,7 @@
 import sun.awt.AWTAutoShutdown;
 import sun.awt.LightweightFrame;
 import sun.awt.SunToolkit;
+import sun.misc.ThreadGroupUtils;
 import sun.awt.Win32GraphicsDevice;
 import sun.awt.Win32GraphicsEnvironment;
 import sun.java2d.d3d.D3DRenderQueue;
@@ -222,7 +223,7 @@
 
     private static native void postDispose();
 
-    private static native boolean startToolkitThread(Runnable thread);
+    private static native boolean startToolkitThread(Runnable thread, ThreadGroup rootThreadGroup);
 
     public WToolkit() {
         // Startup toolkit threads
@@ -239,8 +240,11 @@
          */
         AWTAutoShutdown.notifyToolkitThreadBusy();
 
-        if (!startToolkitThread(this)) {
-            Thread toolkitThread = new Thread(this, "AWT-Windows");
+        // Find a root TG and attach Appkit thread to it
+        ThreadGroup rootTG = AccessController.doPrivileged(
+                (PrivilegedAction<ThreadGroup>) ThreadGroupUtils::getRootThreadGroup);
+        if (!startToolkitThread(this, rootTG)) {
+            Thread toolkitThread = new Thread(rootTG, this, "AWT-Windows");
             toolkitThread.setDaemon(true);
             toolkitThread.start();
         }
@@ -268,29 +272,20 @@
     }
 
     private final void registerShutdownHook() {
-        AccessController.doPrivileged(new PrivilegedAction<Void>() {
-            public Void run() {
-                ThreadGroup currentTG =
-                    Thread.currentThread().getThreadGroup();
-                ThreadGroup parentTG = currentTG.getParent();
-                while (parentTG != null) {
-                    currentTG = parentTG;
-                    parentTG = currentTG.getParent();
-                }
-                Thread shutdown = new Thread(currentTG, new Runnable() {
-                    public void run() {
-                        shutdown();
-                    }
-                });
-                shutdown.setContextClassLoader(null);
-                Runtime.getRuntime().addShutdownHook(shutdown);
-                return null;
-            }
+        AccessController.doPrivileged((PrivilegedAction<Void>) () -> {
+            Thread shutdown = new Thread(ThreadGroupUtils.getRootThreadGroup(), this::shutdown);
+            shutdown.setContextClassLoader(null);
+            Runtime.getRuntime().addShutdownHook(shutdown);
+            return null;
         });
      }
 
     public void run() {
-        Thread.currentThread().setPriority(Thread.NORM_PRIORITY+1);
+        AccessController.doPrivileged((PrivilegedAction<Void>) () -> {
+            Thread.currentThread().setContextClassLoader(null);
+            return null;
+        });
+        Thread.currentThread().setPriority(Thread.NORM_PRIORITY + 1);
         boolean startPump = init();
 
         if (startPump) {
--- jdk/src/windows/classes/sun/java2d/d3d/D3DScreenUpdateManager.java
+++ jdk/src/windows/classes/sun/java2d/d3d/D3DScreenUpdateManager.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2007, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -36,8 +36,9 @@
 import java.security.PrivilegedAction;
 import java.util.ArrayList;
 import java.util.HashMap;
-import sun.awt.SunToolkit;
+
 import sun.awt.AWTAccessor;
+import sun.misc.ThreadGroupUtils;
 import sun.awt.Win32GraphicsConfig;
 import sun.awt.windows.WComponentPeer;
 import sun.java2d.InvalidPipeException;
@@ -92,21 +93,12 @@
     public D3DScreenUpdateManager() {
         done = false;
         AccessController.doPrivileged(
-            new PrivilegedAction() {
-                public Object run() {
-                    ThreadGroup currentTG =
-                        Thread.currentThread().getThreadGroup();
-                    ThreadGroup parentTG = currentTG.getParent();
-                    while (parentTG != null) {
-                        currentTG = parentTG;
-                        parentTG = currentTG.getParent();
-                    }
-                    Thread shutdown = new Thread(currentTG, new Runnable() {
-                            public void run() {
-                                done = true;
-                                wakeUpUpdateThread();
-                            }
-                        });
+                (PrivilegedAction<Void>) () -> {
+                    ThreadGroup rootTG = ThreadGroupUtils.getRootThreadGroup();
+                    Thread shutdown = new Thread(rootTG, () -> {
+                        done = true;
+                        wakeUpUpdateThread();
+                    });
                     shutdown.setContextClassLoader(null);
                     try {
                         Runtime.getRuntime().addShutdownHook(shutdown);
@@ -115,7 +107,6 @@
                     }
                     return null;
                 }
-            }
         );
     }
 
@@ -354,21 +345,17 @@
      */
     private synchronized void startUpdateThread() {
         if (screenUpdater == null) {
-            screenUpdater = (Thread)java.security.AccessController.doPrivileged(
-                new java.security.PrivilegedAction() {
-                    public Object run() {
-                        ThreadGroup tg =
-                            Thread.currentThread().getThreadGroup();
-                        for (ThreadGroup tgn = tg;
-                             tgn != null; tg = tgn, tgn = tg.getParent());
-                        Thread t = new Thread(tg, D3DScreenUpdateManager.this,
-                                              "D3D Screen Updater");
+            screenUpdater = AccessController.doPrivileged(
+                    (PrivilegedAction<Thread>) () -> {
+                        ThreadGroup rootTG = ThreadGroupUtils.getRootThreadGroup();
+                        Thread t = new Thread(rootTG,
+                                D3DScreenUpdateManager.this,
+                                "D3D Screen Updater");
                         // REMIND: should it be higher?
                         t.setPriority(Thread.NORM_PRIORITY + 2);
                         t.setDaemon(true);
                         return t;
-                    }
-            });
+                    });
             screenUpdater.start();
         } else {
             wakeUpUpdateThread();
--- jdk/src/windows/native/sun/windows/awt_Toolkit.cpp
+++ jdk/src/windows/native/sun/windows/awt_Toolkit.cpp
@@ -364,6 +364,7 @@
     HANDLE hCompleted;
 
     jobject thread;
+    jobject threadGroup;
 };
 
 void ToolkitThreadProc(void *param)
@@ -376,7 +377,7 @@
     JavaVMAttachArgs attachArgs;
     attachArgs.version  = JNI_VERSION_1_2;
     attachArgs.name     = "AWT-Windows";
-    attachArgs.group    = NULL;
+    attachArgs.group    = data->threadGroup;
 
     jint res = jvm->AttachCurrentThreadAsDaemon((void **)&env, &attachArgs);
     if (res < 0) {
@@ -415,17 +416,18 @@
 /*
  * Class:     sun_awt_windows_WToolkit
  * Method:    startToolkitThread
- * Signature: (Ljava/lang/Runnable;)Z
+ * Signature: (Ljava/lang/Runnable;Ljava/lang/ThreadGroup)Z
  */
 JNIEXPORT jboolean JNICALL
-Java_sun_awt_windows_WToolkit_startToolkitThread(JNIEnv *env, jclass cls, jobject thread)
+Java_sun_awt_windows_WToolkit_startToolkitThread(JNIEnv *env, jclass cls, jobject thread, jobject threadGroup)
 {
     AwtToolkit& tk = AwtToolkit::GetInstance();
 
     ToolkitThreadProc_Data data;
     data.result = false;
     data.thread = env->NewGlobalRef(thread);
-    if (data.thread == NULL) {
+    data.threadGroup = env->NewGlobalRef(threadGroup);
+    if (data.thread == NULL || data.threadGroup == NULL) {
         return JNI_FALSE;
     }
     data.hCompleted = ::CreateEvent(NULL, FALSE, FALSE, NULL);
@@ -443,6 +445,7 @@
     ::CloseHandle(data.hCompleted);
 
     env->DeleteGlobalRef(data.thread);
+    env->DeleteGlobalRef(data.threadGroup);
 
     return result ? JNI_TRUE : JNI_FALSE;
 }
--- jdk/test/java/awt/Toolkit/LoadAWTCrashTest/LoadAWTCrashTest.java	1969-12-31 19:00:00.000000000 -0500
+++ jdk/test/java/awt/Toolkit/LoadAWTCrashTest/LoadAWTCrashTest.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+  @test
+  @bug 8031477
+  @summary Crash while awt starting
+  @author Petr Pchelko
+  @run main/othervm LoadAWTCrashTest
+*/
+
+public class LoadAWTCrashTest {
+    public static void main(String[] args) {
+        System.loadLibrary("awt");
+        // If the bug is present JVM would crash or deadlock
+    }
+}
--- jdk/test/java/awt/font/TextLayout/TestAATMorxFont.java	1969-12-31 19:00:00.000000000 -0500
+++ jdk/test/java/awt/font/TextLayout/TestAATMorxFont.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+/* @test
+ * @summary verify rendering of MORX fonts on OS X.
+ * @bug 8031462
+ */
+
+import javax.swing.*;
+import javax.swing.border.LineBorder;
+import java.awt.*;
+import java.awt.event.ActionEvent;
+
+public class TestAATMorxFont extends JComponent {
+    public static void main(String[] args) {
+        String osName = System.getProperty("os.name");
+        System.out.println("OS is " + osName);
+        osName = osName.toLowerCase();
+        if (!osName.startsWith("mac")) {
+            return;
+        }
+        SwingUtilities.invokeLater(new Runnable() {
+            public void run() {
+                JFrame frame = new JFrame("Test Morx");
+                frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
+                TestAATMorxFont  panel = new TestAATMorxFont();
+                frame.add(panel);
+                frame.pack();
+                frame.setVisible(true);
+            }
+        });
+    }
+
+    public Dimension getPreferredSize() {
+        return new Dimension(1200, 400);
+    }
+
+    public void paintComponent(Graphics g) {
+        Graphics2D g2d = (Graphics2D)g;
+        g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,
+                             RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
+        int y = 50;
+        g.setFont(new Font("Gujarati MT", Font.PLAIN, 40));
+        System.out.println(g.getFont());
+        g.drawString("\u0A95\u0ACD \u0A95\u0A95\u0A95 \u0A95\u0ACD\u0A95\u0ACD\u0A95", 20, y);
+        y += 50;
+        g.setFont(new Font("Tamil Sangam MN", Font.PLAIN, 40));
+        System.out.println(g.getFont());
+        g.drawString("\u0b95\u0bCD \u0b95\u0b95\u0b95 \u0b95\u0bCD\u0b95\u0bCD\u0b95", 20, y);
+        y += 50;
+        g.setFont(new Font("Telugu Sangam MN", Font.PLAIN, 40));
+        System.out.println(g.getFont());
+        g.drawString("\u0c15\u0c4D \u0c15\u0c15\u0c15 \u0c15\u0c4D\u0c15\u0c4D\u0c15", 20, y);
+        y += 50;
+        g.setFont(new Font("Devanagari Sangam MN", Font.PLAIN, 40));
+        System.out.println(g.getFont());
+        g.drawString("\u0915\u0940 \u0915\u0947 \u0915\u0942", 20, y);
+        y += 50;
+        g.drawString("\u0907\u0930\u094D\u0915\u094D\u0915\u094D\u0915\u094D\u0915\u094D\u0915\u094D\u0915\u094D\u0915\u094D\u0915\u094D\u0915\u094D\u0915", 20, y);
+        y += 50;
+        g.drawString("\u0930\u093F\u0935\u094D\u092F\u0942 \u0915\u0947 \u092C\u093E\u0926 \u0935\u093F\u0915\u093E\u0938 \u0913\u0932\u0902\u092A\u093F\u0915 \u0938\u0947 \u092C\u093E\u0939\u0930 (\u0926\u0947\u0935\u0928\u093E\u0917\u0930\u0940) (\u0939\u093F\u0928\u094D\u0926\u0940) \u0907\u0930\u094D\u0915\u094D\u0915\u094D\u0915\u094D\u0915\u094D\u0915\u094D\u0915\u094D\u0915\u094D\u0915\u094D\u0915\u094D\u0915", 20, y);
+
+    }
+}
+
--- jdk/test/javax/imageio/plugins/jpeg/TruncatedImageWarningTest.java	1969-12-31 19:00:00.000000000 -0500
+++ jdk/test/javax/imageio/plugins/jpeg/TruncatedImageWarningTest.java
@@ -0,0 +1,68 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/**
+ * @test
+ * @bug     8032370
+ *
+ * @summary Test verifies that Image I/O jpeg reader correctly handles
+ *          and warns of a truncated image stream.
+ *
+ * @run     main TruncatedImageWarningTest
+ */
+
+import java.io.File;
+import java.io.IOException;
+import javax.imageio.ImageIO;
+import javax.imageio.ImageReader;
+import javax.imageio.event.IIOReadWarningListener;
+import javax.imageio.stream.ImageInputStream;
+
+public class TruncatedImageWarningTest implements IIOReadWarningListener {
+
+    private static String fileName = "truncated.jpg";
+    boolean receivedWarning = false;
+
+    public static void main(String[] args) throws IOException {
+
+        String sep = System.getProperty("file.separator");
+        String dir = System.getProperty("test.src", ".");
+        String filePath = dir+sep+fileName;
+        System.out.println("Test file: " + filePath);
+        File f = new File(filePath);
+        ImageInputStream in = ImageIO.createImageInputStream(f);
+        ImageReader reader = ImageIO.getImageReaders(in).next();
+        TruncatedImageWarningTest twt = new TruncatedImageWarningTest();
+        reader.addIIOReadWarningListener(twt);
+        reader.setInput(in);
+        reader.read(0);
+        if (!twt.receivedWarning) {
+            throw new RuntimeException("No expected warning");
+        }
+    }
+
+    public void warningOccurred(ImageReader source, String warning) {
+        System.out.println("Expected warning: " + warning);
+        receivedWarning = true;
+    }
+}
Files openjdk/jdk/test/javax/imageio/plugins/jpeg/truncated.jpg and jdk8u5-b13/jdk/test/javax/imageio/plugins/jpeg/truncated.jpg differ
--- jdk/test/sun/util/calendar/zi/tzdata/VERSION
+++ jdk/test/sun/util/calendar/zi/tzdata/VERSION
@@ -21,4 +21,4 @@
 # or visit www.oracle.com if you need additional information or have any
 # questions.
 #
-tzdata2013h
+tzdata2013i
--- jdk/test/sun/util/calendar/zi/tzdata/africa
+++ jdk/test/sun/util/calendar/zi/tzdata/africa
@@ -500,14 +500,13 @@
 Rule	Libya	1997	only	-	Oct	 4	0:00	0	-
 Rule	Libya	2013	only	-	Mar	lastFri	1:00	1:00	S
 Rule	Libya	2013	only	-	Oct	lastFri	2:00	0	-
-
-# The 1996 and 1997 entries are from Shanks & Pottenger;
-# the IATA SSIM data contain some obvious errors.
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
 Zone	Africa/Tripoli	0:52:44 -	LMT	1920
 			1:00	Libya	CE%sT	1959
 			2:00	-	EET	1982
 			1:00	Libya	CE%sT	1990 May  4
+# The 1996 and 1997 entries are from Shanks & Pottenger;
+# the IATA SSIM data contain some obvious errors.
 			2:00	-	EET	1996 Sep 30
 			1:00	Libya	CE%sT	1997 Oct  4
 			2:00	-	EET	2012 Nov 10 2:00
--- jdk/test/sun/util/calendar/zi/tzdata/asia
+++ jdk/test/sun/util/calendar/zi/tzdata/asia
@@ -1403,12 +1403,22 @@
 # switch back to standard time this winter, so the will stay on DST
 # until about the same time next year (at least).
 # http://www.petra.gov.jo/Public_News/Nws_NewsDetails.aspx?NewsID=88950
-#
-# From Paul Eggert (2013-09-21):
-# It's looking like this change will be permanent; see
-# Petra News Agency, Cancelling winter saved Jordan $7 million (2013-02-20)
-# <http://www.albawaba.com/business/jordan-winter-electricity--472005>.
-# So move Jordan to UTC+3 as of the abovementioned date.
+
+# From Steffen Thorsen (2013-12-11):
+# Jordan Times and other sources say that Jordan is going back to
+# UTC+2 on 2013-12-19 at midnight:
+# http://jordantimes.com/govt-decides-to-switch-back-to-wintertime
+# Official, in Arabic:
+# http://www.petra.gov.jo/public_news/Nws_NewsDetails.aspx?Menu_ID=&Site_Id=2&lang=1&NewsID=133230&CatID=14
+# ... Our background/permalink about it
+# http://www.timeanddate.com/news/time/jordan-reverses-dst-decision.html
+# ...
+# http://www.petra.gov.jo/Public_News/Nws_NewsDetails.aspx?lang=2&site_id=1&NewsID=133313&Type=P
+# ... says midnight for the coming one and 1:00 for the ones in the future
+# (and they will use DST again next year, using the normal schedule).
+
+# From Paul Eggert (2013-12-11):
+# As Steffen suggested, consider the past 21-month experiment to be DST.
 
 # Rule	NAME	FROM	TO	TYPE	IN	ON	AT	SAVE	LETTER/S
 Rule	Jordan	1973	only	-	Jun	6	0:00	1:00	S
@@ -1438,11 +1448,13 @@
 Rule	Jordan	2003	only	-	Oct	24	0:00s	0	-
 Rule	Jordan	2004	only	-	Oct	15	0:00s	0	-
 Rule	Jordan	2005	only	-	Sep	lastFri	0:00s	0	-
-Rule	Jordan	2006	2012	-	Oct	lastFri	0:00s	0	-
+Rule	Jordan	2006	2011	-	Oct	lastFri	0:00s	0	-
+Rule	Jordan	2013	only	-	Dec	20	0:00	0	-
+Rule	Jordan	2014	max	-	Mar	lastThu	24:00	1:00	S
+Rule	Jordan	2014	max	-	Oct	lastFri	0:00s	0	-
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
 Zone	Asia/Amman	2:23:44 -	LMT	1931
-			2:00	Jordan	EE%sT	2012 Oct 26 0:00s
-			3:00	-	AST
+			2:00	Jordan	EE%sT
 
 
 # Kazakhstan
--- jdk/test/sun/util/calendar/zi/tzdata/northamerica
+++ jdk/test/sun/util/calendar/zi/tzdata/northamerica
@@ -2688,6 +2688,11 @@
 # to DST--and one more hour on 1999-04-04--when the announcers will have
 # returned to Baltimore, which switches on that date.)
 
+# From Steffen Thorsen (2013-11-11):
+# DST start in Cuba in 2004 ... does not follow the same rules as the
+# years before.  The correct date should be Sunday 2004-03-28 00:00 ...
+# https://web.archive.org/web/20040402060750/http://www.granma.cu/espanol/2004/marzo/sab27/reloj.html
+
 # From Evert van der Veer via Steffen Thorsen (2004-10-28):
 # Cuba is not going back to standard time this year.
 # From Paul Eggert (2006-03-22):
@@ -2877,7 +2882,8 @@
 Rule	Cuba	1997	only	-	Oct	12	0:00s	0	S
 Rule	Cuba	1998	1999	-	Mar	lastSun	0:00s	1:00	D
 Rule	Cuba	1998	2003	-	Oct	lastSun	0:00s	0	S
-Rule	Cuba	2000	2004	-	Apr	Sun>=1	0:00s	1:00	D
+Rule	Cuba	2000	2003	-	Apr	Sun>=1	0:00s	1:00	D
+Rule	Cuba	2004	only	-	Mar	lastSun	0:00s	1:00	D
 Rule	Cuba	2006	2010	-	Oct	lastSun	0:00s	0	S
 Rule	Cuba	2007	only	-	Mar	Sun>=8	0:00s	1:00	D
 Rule	Cuba	2008	only	-	Mar	Sun>=15	0:00s	1:00	D
--- langtools/.hgtags
+++ langtools/.hgtags
@@ -253,3 +253,16 @@
 8fe7202d3c38784f3f14368e3954fc4e0394afa4 jdk8-b129
 9d81ae1c417a4748f58921c1f8def7f3c401cecd jdk8-b130
 196ab3dcbd28fac1578590684a337f1c7cf505c9 jdk8-b131
+c8a87a58eb3efdd64055566b502c9d4a72ca0996 jdk8-b132
+519557cab6d4a7fd77b33226e71f92303090420b jdk8u5-b01
+9003a59a512e6b764d8a3f805aadc3996a58e5bd jdk8u5-b02
+30e3dad0ebbdf3129bacd04a7f4cdecd3df92bb2 jdk8u5-b03
+019dcdfffced0ca2026a0ad8c0e5fcb49d46116f jdk8u5-b04
+c9db8c800797258540e0411e58b8f7d59273de5f jdk8u5-b05
+b1920c0b701d5ff219c9f622db5cafc9bf00d5c8 jdk8u5-b06
+180df7f2c078f1efaa6fcd8ca9f55dc5f81b182c jdk8u5-b07
+9c3d7d1a70391bd772693dc5a838b53e1cad0761 jdk8u5-b08
+169c8c1a2e8d1e80a4474d91f7809aa2a6b2249a jdk8u5-b09
+026543c71810701de08cdfd906d1b8fdc69b89c0 jdk8u5-b10
+a12055904afd9f951131804868215e724c71b684 jdk8u5-b11
+2a7002626e7997e946b96530629e2787bc1864bb jdk8u5-b12
--- langtools/.jcheck/conf
+++ langtools/.jcheck/conf
@@ -1 +1,2 @@
 project=jdk8
+bugids=dup
--- langtools/THIRD_PARTY_README
+++ langtools/THIRD_PARTY_README
@@ -1399,13 +1399,13 @@
 
 -------------------------------------------------------------------------------
 
-%% This notice is provided with respect to Little CMS 2.4, which may be 
+%% This notice is provided with respect to Little CMS 2.5, which may be 
 included with JRE 8, JDK 8, and OpenJDK 8.
 
 --- begin of LICENSE ---
 
 Little CMS
-Copyright (c) 1998-2010 Marti Maria Saguer
+Copyright (c) 1998-2011 Marti Maria Saguer
 
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
--- langtools/src/share/classes/com/sun/tools/doclets/formats/html/ConfigurationImpl.java
+++ langtools/src/share/classes/com/sun/tools/doclets/formats/html/ConfigurationImpl.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1998, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -247,7 +247,7 @@
             } else if (opt.equals("-doctitle")) {
                 doctitle = os[1];
             } else if (opt.equals("-windowtitle")) {
-                windowtitle = os[1];
+                windowtitle = os[1].replaceAll("\\<.*?>", "");
             } else if (opt.equals("-top")) {
                 top = os[1];
             } else if (opt.equals("-bottom")) {
--- langtools/src/share/classes/com/sun/tools/javac/resources/compiler_ja.properties
+++ langtools/src/share/classes/com/sun/tools/javac/resources/compiler_ja.properties
@@ -419,8 +419,6 @@
 
 compiler.err.intf.expected.here=\u3053\u3053\u306B\u30A4\u30F3\u30BF\u30D5\u30A7\u30FC\u30B9\u304C\u5FC5\u8981\u3067\u3059
 
-compiler.err.intf.or.array.expected.here=\u3053\u3053\u306B\u30A4\u30F3\u30BF\u30D5\u30A7\u30FC\u30B9\u307E\u305F\u306F\u914D\u5217\u578B\u304C\u5FC5\u8981\u3067\u3059
-
 compiler.err.intf.meth.cant.have.body=\u30A4\u30F3\u30BF\u30D5\u30A7\u30FC\u30B9\u62BD\u8C61\u30E1\u30BD\u30C3\u30C9\u304C\u672C\u4F53\u3092\u6301\u3064\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093
 
 # 0: symbol
--- langtools/src/share/classes/com/sun/tools/javac/resources/compiler_zh_CN.properties
+++ langtools/src/share/classes/com/sun/tools/javac/resources/compiler_zh_CN.properties
@@ -419,8 +419,6 @@
 
 compiler.err.intf.expected.here=\u6B64\u5904\u9700\u8981\u63A5\u53E3
 
-compiler.err.intf.or.array.expected.here=\u6B64\u5904\u9884\u671F\u4E3A\u63A5\u53E3\u6216\u6570\u7EC4\u7C7B\u578B
-
 compiler.err.intf.meth.cant.have.body=\u63A5\u53E3\u62BD\u8C61\u65B9\u6CD5\u4E0D\u80FD\u5E26\u6709\u4E3B\u4F53
 
 # 0: symbol
--- langtools/src/share/classes/com/sun/tools/jdeps/resources/jdeps_ja.properties
+++ langtools/src/share/classes/com/sun/tools/jdeps/resources/jdeps_ja.properties
@@ -29,8 +29,11 @@
 
 main.opt.dotoutput=\  -dotoutput <dir>                   DOT\u30D5\u30A1\u30A4\u30EB\u51FA\u529B\u306E\u5B9B\u5148\u30C7\u30A3\u30EC\u30AF\u30C8\u30EA
 
+main.opt.jdkinternals=\  -jdkinternals                      JDK\u5185\u90E8API\u306E\u30AF\u30E9\u30B9\u30EC\u30D9\u30EB\u306E\u4F9D\u5B58\u6027\u3092\u691C\u51FA\u3057\u307E\u3059\u3002\n                                     \u30C7\u30D5\u30A9\u30EB\u30C8\u3067\u306F\u3001-include\u30AA\u30D7\u30B7\u30E7\u30F3\u3092\u6307\u5B9A\u3057\u306A\u3044\u3068\u3001\n                                     -classpath\u306E\u3059\u3079\u3066\u306E\u30AF\u30E9\u30B9\u3068\u5165\u529B\u30D5\u30A1\u30A4\u30EB\u3092\u5206\u6790\u3057\u307E\u3059\u3002\n                                     \u3053\u306E\u30AA\u30D7\u30B7\u30E7\u30F3\u306F-p\u3001-e\u304A\u3088\u3073-s\u30AA\u30D7\u30B7\u30E7\u30F3\u3068\u4E00\u7DD2\u306B\u4F7F\u7528\u3067\u304D\u307E\u305B\u3093\u3002\n                                     \u8B66\u544A: JDK\u5185\u90E8API\u306F\u3001\u6B21\u306E\u30EA\u30EA\u30FC\u30B9\u3067\u30A2\u30AF\u30BB\u30B9\u3067\u304D\u306A\u304F\u306A\u308B\u53EF\u80FD\u6027\u304C\n                                     \u3042\u308A\u307E\u3059\u3002
+
 main.opt.depth=\  -depth=<depth>                     \u63A8\u79FB\u7684\u306A\u4F9D\u5B58\u6027\u5206\u6790\u306E\u6DF1\u3055\u3092\n                                     \u6307\u5B9A\u3057\u307E\u3059
 
+
 err.unknown.option=\u4E0D\u660E\u306A\u30AA\u30D7\u30B7\u30E7\u30F3: {0}
 err.missing.arg={0}\u306B\u5024\u304C\u6307\u5B9A\u3055\u308C\u3066\u3044\u307E\u305B\u3093
 err.internal.error=\u5185\u90E8\u30A8\u30E9\u30FC: {0} {1} {2}
--- langtools/src/share/classes/com/sun/tools/jdeps/resources/jdeps_zh_CN.properties
+++ langtools/src/share/classes/com/sun/tools/jdeps/resources/jdeps_zh_CN.properties
@@ -29,8 +29,11 @@
 
 main.opt.dotoutput=\  -dotoutput <dir>                   DOT \u6587\u4EF6\u8F93\u51FA\u7684\u76EE\u6807\u76EE\u5F55
 
+main.opt.jdkinternals=\  -jdkinternals                      \u5728 JDK \u5185\u90E8 API \u4E0A\u67E5\u627E\u7C7B\u7EA7\u522B\u7684\u88AB\u4F9D\u8D56\u5BF9\u8C61\u3002\n                                     \u9ED8\u8BA4\u60C5\u51B5\u4E0B, \u5B83\u5206\u6790 -classpath \u4E0A\u7684\u6240\u6709\u7C7B\n                                     \u548C\u8F93\u5165\u6587\u4EF6, \u9664\u975E\u6307\u5B9A\u4E86 -include \u9009\u9879\u3002\n                                     \u6B64\u9009\u9879\u4E0D\u80FD\u4E0E -p, -e \u548C -s \u9009\u9879\u4E00\u8D77\u4F7F\u7528\u3002\n                                     \u8B66\u544A: \u5728\u4E0B\u4E00\u4E2A\u53D1\u884C\u7248\u4E2D\u53EF\u80FD\u65E0\u6CD5\u8BBF\u95EE\n                                     JDK \u5185\u90E8 API\u3002
+
 main.opt.depth=\  -depth=<depth>                     \u6307\u5B9A\u8FC7\u6E21\u88AB\u4F9D\u8D56\u5BF9\u8C61\u5206\u6790\n                                     \u7684\u6DF1\u5EA6
 
+
 err.unknown.option=\u672A\u77E5\u9009\u9879: {0}
 err.missing.arg=\u6CA1\u6709\u4E3A{0}\u6307\u5B9A\u503C
 err.internal.error=\u5185\u90E8\u9519\u8BEF: {0} {1} {2}
--- langtools/test/com/sun/javadoc/testWindowTitle/TestWindowTitle.java
+++ langtools/test/com/sun/javadoc/testWindowTitle/TestWindowTitle.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2013, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -23,7 +23,7 @@
 
 /*
  * @test
- * @bug 8016675
+ * @bug 8016675 8026736
  * @summary Test for window title.
  * @author Bhavesh Patel
  * @library ../lib/
@@ -34,26 +34,153 @@
 public class TestWindowTitle extends JavadocTester {
 
     private static final String BUG_ID = "8016675";
-    private static final String WIN_TITLE =
+    //Window title with JavaScript special characters.
+    private static final String TITLE_JS_CHARS =
             "Testing \"Window 'Title'\" with a \\ backslash and a / " +
             "forward slash and a \u00e8 unicode char also a    tab and also a " +
             "\t special character another \u0002 unicode)";
-    private static final String[][] TEST = {
-        {BUG_ID + FS  + "overview-summary.html",
+    private static final String[] ARGS_JS_CHARS = new String[]{
+        "-d", BUG_ID + "-1", "-windowtitle", TITLE_JS_CHARS, "-sourcepath", SRC_DIR, "p1", "p2"
+    };
+    private static final String[][] TEST_JS_CHARS = {
+        {BUG_ID + "-1" + FS + "overview-summary.html",
             "parent.document.title=\"Overview (Testing \\\"Window \\\'Title\\\'\\\" " +
             "with a \\\\ backslash and a / forward slash and a \\u00E8 unicode char " +
             "also a    tab and also a \\t special character another \\u0002 unicode))\";"
         },
     };
-    private static final String[][] NEG_TEST = {
-        {BUG_ID + FS + "overview-summary.html",
+    private static final String[][] NEG_TEST_JS_CHARS = {
+        {BUG_ID + "-1" + FS + "overview-summary.html",
             "parent.document.title=\"Overview (Testing \"Window \'Title\'\" " +
             "with a \\ backslash and a / forward slash and a \u00E8 unicode char " +
             "also a    tab and also a \t special character another \u0002 unicode))\";"
+        }
+    };
+
+    //Window title with a script tag.
+    private static final String TITLE_SCRIPT_TAG =
+            "Testing script tag in title </title><script>alert(\"Should not pop up\")</script>.";
+    private static final String[] ARGS_SCRIPT_TAG = new String[]{
+        "-d", BUG_ID + "-2", "-windowtitle", TITLE_SCRIPT_TAG, "-sourcepath", SRC_DIR, "p1", "p2"
+    };
+    private static final String[][] TEST_SCRIPT_TAG = {
+        {BUG_ID + "-2" + FS + "overview-summary.html",
+            "parent.document.title=\"Overview (Testing script tag in title alert" +
+            "(\\\"Should not pop up\\\").)\";"
         },
+        {BUG_ID + "-2" + FS + "p2" + FS + "C2.html",
+            "parent.document.title=\"C2 (Testing script tag in title alert" +
+            "(\\\"Should not pop up\\\").)\";"
+        }
+    };
+    private static final String[][] NEG_TEST_SCRIPT_TAG = {
+        {BUG_ID + "-2" + FS + "overview-summary.html",
+            "parent.document.title=\"Overview (Testing script tag in title </title><script>" +
+            "alert(\\\"Should not pop up\\\")</script>.)\";"
+        },
+        {BUG_ID + "-2" + FS + "p2" + FS + "C2.html",
+            "parent.document.title=\"C2 (Testing script tag in title </title><script>" +
+            "alert(\\\"Should not pop up\\\")</script>.)\";"
+        }
+    };
+
+    //Window title with other HTML tags.
+    private static final String TITLE_HTML_TAGS =
+            "Testing another <p>HTML</p> tag. Another <h1>tag</h1>. A " +
+            "<span id=\"testTag\">tag with attributes</span>. <script and </p are not tags.";
+    private static final String[] ARGS_HTML_TAGS = new String[]{
+        "-d", BUG_ID + "-3", "-windowtitle", TITLE_HTML_TAGS, "-sourcepath", SRC_DIR, "p1", "p2"
+    };
+    private static final String[][] TEST_HTML_TAGS = {
+        {BUG_ID + "-3" + FS + "overview-summary.html",
+            "parent.document.title=\"Overview (Testing another HTML tag. Another tag. A " +
+            "tag with attributes. <script and </p are not tags.)\";"
+        }
+    };
+    private static final String[][] NEG_TEST_HTML_TAGS = {
+        {BUG_ID + "-3" + FS + "overview-summary.html",
+            "parent.document.title=\"Overview (Testing another <p>HTML</p> tag. Another " +
+            "<h1>tag</h1>. A <span id=\"testTag\">tag with attributes</span>. <script and " +
+            "</p are not tags.)\";"
+        }
+    };
+
+    //Window title using entities.
+    private static final String TITLE_HTML_ENTITIES =
+            "Testing entities &lt;script&gt;alert(\"Should not pop up\")&lt;/script&gt;.";
+    private static final String[] ARGS_HTML_ENTITIES = new String[]{
+        "-d", BUG_ID + "-4", "-windowtitle", TITLE_HTML_ENTITIES, "-sourcepath", SRC_DIR, "p1", "p2"
+    };
+    private static final String[][] TEST_HTML_ENTITIES = {
+        {BUG_ID + "-4" + FS + "overview-summary.html",
+            "parent.document.title=\"Overview (Testing entities &lt;script&gt;alert(\\\"Should " +
+            "not pop up\\\")&lt;/script&gt;.)\";"
+        }
+    };
+    private static final String[][] NEG_TEST_HTML_ENTITIES = {
+        {BUG_ID + "-4" + FS  + "overview-summary.html",
+            "parent.document.title=\"Overview (Testing entities alert(\\\"Should not pop up\\\").)\";"
+        }
+    };
+
+    //Window title with just empty HTML tags.
+    private static final String TITLE_EMPTY_TAGS =
+            "</title><script></script>";
+    private static final String[] ARGS_EMPTY_TAGS = new String[]{
+        "-d", BUG_ID + "-5", "-windowtitle", TITLE_EMPTY_TAGS, "-sourcepath", SRC_DIR, "p1", "p2"
+    };
+    private static final String[][] TEST_EMPTY_TAGS = {
+        {BUG_ID + "-5" + FS + "overview-summary.html",
+            "parent.document.title=\"Overview\";"
+        }
+    };
+    private static final String[][] NEG_TEST_EMPTY_TAGS = {
+        {BUG_ID + "-5" + FS + "overview-summary.html",
+            "parent.document.title=\"Overview (</title><script></script>)\";"
+        }
+    };
+
+    //Window title with unicode characters.
+    private static final String TITLE_UNICODE_CHARS =
+            "Testing unicode \u003cscript\u003ealert(\"Should not pop up\")\u003c/script\u003e.";
+    private static final String[] ARGS_UNICODE_CHARS = new String[]{
+        "-d", BUG_ID + "-6", "-windowtitle", TITLE_UNICODE_CHARS, "-sourcepath", SRC_DIR, "p1", "p2"
+    };
+    private static final String[][] TEST_UNICODE_CHARS = {
+        {BUG_ID + "-6" + FS + "overview-summary.html",
+            "parent.document.title=\"Overview (Testing unicode alert(\\\"Should " +
+            "not pop up\\\").)\";"
+        }
     };
-    private static final String[] ARGS = new String[]{
-        "-d", BUG_ID, "-windowtitle", WIN_TITLE, "-sourcepath", SRC_DIR, "p1", "p2"
+    private static final String[][] NEG_TEST_UNICODE_CHARS = {
+        {BUG_ID + "-6" + FS + "overview-summary.html",
+            "parent.document.title=\"Overview (Testing unicode <script>alert(\\\"Should not pop up\\\")" +
+            "</script>.)\";"
+        }
+    };
+
+    //An empty window title.
+    private static final String TITLE_EMPTY =
+            "";
+    private static final String[] ARGS_EMPTY_TITLE = new String[]{
+        "-d", BUG_ID + "-7", "-windowtitle", TITLE_EMPTY, "-sourcepath", SRC_DIR, "p1", "p2"
+    };
+    private static final String[][] TEST_EMPTY = {
+        {BUG_ID + "-7" + FS + "overview-summary.html",
+            "parent.document.title=\"Overview\";"
+        }
+    };
+
+    //Test doctitle.
+    private static final String[] ARGS_DOCTITLE = new String[]{
+        "-d", BUG_ID + "-8", "-doctitle", TITLE_JS_CHARS, "-sourcepath", SRC_DIR, "p1", "p2"
+    };
+    private static final String[][] NEG_TEST_DOCTITLE = {
+        {BUG_ID + "-8" + FS + "overview-summary.html",
+            "parent.document.title=\"Overview (Testing \\\"Window \\\'Title\\\'\\\" " +
+            "with a \\\\ backslash and a / forward slash and a \\u00E8 unicode char " +
+            "also a    tab and also a \\t special character another \\u0002 unicode)\";"
+        },
     };
 
     /**
@@ -62,7 +189,14 @@
      */
     public static void main(String[] args) {
         TestWindowTitle tester = new TestWindowTitle();
-        run(tester, ARGS, TEST, NEG_TEST);
+        run(tester, ARGS_JS_CHARS, TEST_JS_CHARS, NEG_TEST_JS_CHARS);
+        run(tester, ARGS_SCRIPT_TAG, TEST_SCRIPT_TAG, NEG_TEST_SCRIPT_TAG);
+        run(tester, ARGS_HTML_TAGS, TEST_HTML_TAGS, NEG_TEST_HTML_TAGS);
+        run(tester, ARGS_HTML_ENTITIES, TEST_HTML_ENTITIES, NEG_TEST_HTML_ENTITIES);
+        run(tester, ARGS_EMPTY_TAGS, TEST_EMPTY_TAGS, NEG_TEST_EMPTY_TAGS);
+        run(tester, ARGS_UNICODE_CHARS, TEST_UNICODE_CHARS, NEG_TEST_UNICODE_CHARS);
+        run(tester, ARGS_EMPTY_TITLE, TEST_EMPTY, NO_TEST);
+        run(tester, ARGS_DOCTITLE, NO_TEST, NEG_TEST_DOCTITLE);
         tester.printSummary();
     }
 
--- nashorn/.hgtags
+++ nashorn/.hgtags
@@ -241,3 +241,17 @@
 9cc3fd32fbabdd8b06771d11a319c9802e118612 jdk8-b129
 f87eba70e9ee96255137c389db7cb4e2480e53e7 jdk8-b130
 cca9748cfec7025ac0ddcdede9e5724fa676ad13 jdk8-b131
+5dbdae28a6f3dae3913b118c128bcb1f803317ac jdk8-b132
+13ca8f1a9eba716295fb7d9c2ddad81390931919 jdk8u5-b01
+7e7cb9977a3d1244384ffa454a4890764a07b042 jdk8u5-b02
+2abeb654b57f306f73f3f73bdfa05f93bce2a1f3 jdk8u5-b03
+7c650ceee4902249f32bdc066926b77291007859 jdk8u5-b04
+d88b60cdc8f3cfceb8ef19b095769015b441e37f jdk8u11-b00
+d88b60cdc8f3cfceb8ef19b095769015b441e37f jdk8u5-b05
+d6dfad8b7fb524780ebf4f6b62284cf5679f9ba8 jdk8u5-b06
+96ad962a6a88874830e99e0cd11aece89a1bd1f4 jdk8u5-b07
+f0b7b8b5e29a3a4e481fbeb9b346552c9819675e jdk8u5-b08
+6ca65190effb3bf8119bb4e93f1692487337ec72 jdk8u5-b09
+8bc83045abc547edb7cfb7d688d84164f0b11cea jdk8u5-b10
+bc23b19e08eb1575663044902b6442ceaafa924f jdk8u5-b11
+18b007062905dac9304605955a4b84eaf2a08553 jdk8u5-b12
--- nashorn/.jcheck/conf
+++ nashorn/.jcheck/conf
@@ -1 +1,2 @@
 project=jdk8
+bugids=dup
--- nashorn/THIRD_PARTY_README
+++ nashorn/THIRD_PARTY_README
@@ -1399,13 +1399,13 @@
 
 -------------------------------------------------------------------------------
 
-%% This notice is provided with respect to Little CMS 2.4, which may be 
+%% This notice is provided with respect to Little CMS 2.5, which may be 
 included with JRE 8, JDK 8, and OpenJDK 8.
 
 --- begin of LICENSE ---
 
 Little CMS
-Copyright (c) 1998-2010 Marti Maria Saguer
+Copyright (c) 1998-2011 Marti Maria Saguer
 
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
--- nashorn/src/jdk/internal/dynalink/beans/AccessibleMembersLookup.java
+++ nashorn/src/jdk/internal/dynalink/beans/AccessibleMembersLookup.java
@@ -211,7 +211,8 @@
         if(!CheckRestrictedPackage.isRestrictedClass(clazz)) {
             searchSuperTypes = false;
             for(Method method: clazz.getMethods()) {
-                if(instance != Modifier.isStatic(method.getModifiers())) {
+                final boolean isStatic = Modifier.isStatic(method.getModifiers());
+                if(instance != isStatic) {
                     final MethodSignature sig = new MethodSignature(method);
                     if(!methods.containsKey(sig)) {
                         final Class<?> declaringClass = method.getDeclaringClass();
@@ -228,7 +229,10 @@
                             //generate the said synthetic delegators.
                             searchSuperTypes = true;
                         } else {
-                            methods.put(sig, method);
+                            // don't allow inherited static
+                            if (!isStatic || clazz == declaringClass) {
+                                methods.put(sig, method);
+                            }
                         }
                     }
                 }
@@ -245,7 +249,8 @@
             searchSuperTypes = true;
         }
 
-        if(searchSuperTypes) {
+        // don't need to search super types for static methods
+        if(instance && searchSuperTypes) {
             // If we reach here, the class is either not public, or it is in a restricted package. Alternatively, it is
             // public, but some of its methods claim that their declaring class is non-public. We'll try superclasses
             // and implemented interfaces then looking for public ones.
--- nashorn/src/jdk/internal/dynalink/beans/FacetIntrospector.java
+++ nashorn/src/jdk/internal/dynalink/beans/FacetIntrospector.java
@@ -136,7 +136,13 @@
         final Field[] fields = clazz.getFields();
         final Collection<Field> cfields = new ArrayList<>(fields.length);
         for(Field field: fields) {
-            if(instance != Modifier.isStatic(field.getModifiers()) && isAccessible(field)) {
+            final boolean isStatic = Modifier.isStatic(field.getModifiers());
+            if(isStatic && clazz != field.getDeclaringClass()) {
+                // ignore inherited static fields
+                continue;
+            }
+
+            if(instance != isStatic && isAccessible(field)) {
                 cfields.add(field);
             }
         }
--- nashorn/src/jdk/nashorn/internal/runtime/linker/JavaAdapterBytecodeGenerator.java
+++ nashorn/src/jdk/nashorn/internal/runtime/linker/JavaAdapterBytecodeGenerator.java
@@ -131,20 +131,17 @@
  * implemented securely.
  */
 final class JavaAdapterBytecodeGenerator {
-    static final Type CONTEXT_TYPE       = Type.getType(Context.class);
     static final Type OBJECT_TYPE        = Type.getType(Object.class);
-    static final Type SCRIPT_OBJECT_TYPE = Type.getType(ScriptObject.class);
 
-    static final String CONTEXT_TYPE_NAME = CONTEXT_TYPE.getInternalName();
     static final String OBJECT_TYPE_NAME  = OBJECT_TYPE.getInternalName();
 
     static final String INIT = "<init>";
 
     static final String GLOBAL_FIELD_NAME = "global";
 
-    static final String SCRIPT_OBJECT_TYPE_DESCRIPTOR = SCRIPT_OBJECT_TYPE.getDescriptor();
+    static final String GLOBAL_TYPE_DESCRIPTOR = OBJECT_TYPE.getDescriptor();
 
-    static final String SET_GLOBAL_METHOD_DESCRIPTOR = Type.getMethodDescriptor(Type.VOID_TYPE, SCRIPT_OBJECT_TYPE);
+    static final String SET_GLOBAL_METHOD_DESCRIPTOR = Type.getMethodDescriptor(Type.VOID_TYPE, OBJECT_TYPE);
     static final String VOID_NOARG_METHOD_DESCRIPTOR = Type.getMethodDescriptor(Type.VOID_TYPE);
 
     private static final Type SCRIPT_FUNCTION_TYPE = Type.getType(ScriptFunction.class);
@@ -155,7 +152,7 @@
             OBJECT_TYPE, STRING_TYPE, METHOD_TYPE_TYPE);
     private static final String GET_HANDLE_FUNCTION_DESCRIPTOR = Type.getMethodDescriptor(METHOD_HANDLE_TYPE,
             SCRIPT_FUNCTION_TYPE, METHOD_TYPE_TYPE);
-    private static final String GET_CLASS_INITIALIZER_DESCRIPTOR = Type.getMethodDescriptor(SCRIPT_OBJECT_TYPE);
+    private static final String GET_CLASS_INITIALIZER_DESCRIPTOR = Type.getMethodDescriptor(OBJECT_TYPE);
     private static final Type RUNTIME_EXCEPTION_TYPE = Type.getType(RuntimeException.class);
     private static final Type THROWABLE_TYPE = Type.getType(Throwable.class);
     private static final Type UNSUPPORTED_OPERATION_TYPE = Type.getType(UnsupportedOperationException.class);
@@ -167,7 +164,7 @@
     private static final String UNSUPPORTED_OPERATION_TYPE_NAME = UNSUPPORTED_OPERATION_TYPE.getInternalName();
 
     private static final String METHOD_HANDLE_TYPE_DESCRIPTOR = METHOD_HANDLE_TYPE.getDescriptor();
-    private static final String GET_GLOBAL_METHOD_DESCRIPTOR = Type.getMethodDescriptor(SCRIPT_OBJECT_TYPE);
+    private static final String GET_GLOBAL_METHOD_DESCRIPTOR = Type.getMethodDescriptor(OBJECT_TYPE);
     private static final String GET_CLASS_METHOD_DESCRIPTOR = Type.getMethodDescriptor(Type.getType(Class.class));
 
     // Package used when the adapter can't be defined in the adaptee's package (either because it's sealed, or because
@@ -259,7 +256,7 @@
     }
 
     private void generateGlobalFields() {
-        cw.visitField(ACC_PRIVATE | ACC_FINAL | (classOverride ? ACC_STATIC : 0), GLOBAL_FIELD_NAME, SCRIPT_OBJECT_TYPE_DESCRIPTOR, null, null).visitEnd();
+        cw.visitField(ACC_PRIVATE | ACC_FINAL | (classOverride ? ACC_STATIC : 0), GLOBAL_FIELD_NAME, GLOBAL_TYPE_DESCRIPTOR, null, null).visitEnd();
         usedFieldNames.add(GLOBAL_FIELD_NAME);
     }
 
@@ -363,7 +360,7 @@
         }
         // Assign "global = Context.getGlobal()"
         invokeGetGlobalWithNullCheck(mv);
-        mv.putstatic(generatedClassName, GLOBAL_FIELD_NAME, SCRIPT_OBJECT_TYPE_DESCRIPTOR);
+        mv.putstatic(generatedClassName, GLOBAL_FIELD_NAME, GLOBAL_TYPE_DESCRIPTOR);
 
         endInitMethod(mv);
     }
@@ -508,7 +505,7 @@
         // Assign "this.global = Context.getGlobal()"
         mv.visitVarInsn(ALOAD, 0);
         invokeGetGlobalWithNullCheck(mv);
-        mv.putfield(generatedClassName, GLOBAL_FIELD_NAME, SCRIPT_OBJECT_TYPE_DESCRIPTOR);
+        mv.putfield(generatedClassName, GLOBAL_FIELD_NAME, GLOBAL_TYPE_DESCRIPTOR);
 
         endInitMethod(mv);
     }
@@ -524,11 +521,11 @@
     }
 
     private static void invokeGetGlobal(final InstructionAdapter mv) {
-        mv.invokestatic(CONTEXT_TYPE_NAME, "getGlobal", GET_GLOBAL_METHOD_DESCRIPTOR);
+        mv.invokestatic(SERVICES_CLASS_TYPE_NAME, "getGlobal", GET_GLOBAL_METHOD_DESCRIPTOR);
     }
 
     private static void invokeSetGlobal(final InstructionAdapter mv) {
-        mv.invokestatic(CONTEXT_TYPE_NAME, "setGlobal", SET_GLOBAL_METHOD_DESCRIPTOR);
+        mv.invokestatic(SERVICES_CLASS_TYPE_NAME, "setGlobal", SET_GLOBAL_METHOD_DESCRIPTOR);
     }
 
     /**
@@ -652,10 +649,10 @@
         // Load the creatingGlobal object
         if(classOverride) {
             // If class handle is defined, load the static defining global
-            mv.getstatic(generatedClassName, GLOBAL_FIELD_NAME, SCRIPT_OBJECT_TYPE_DESCRIPTOR);
+            mv.getstatic(generatedClassName, GLOBAL_FIELD_NAME, GLOBAL_TYPE_DESCRIPTOR);
         } else {
             mv.visitVarInsn(ALOAD, 0);
-            mv.getfield(generatedClassName, GLOBAL_FIELD_NAME, SCRIPT_OBJECT_TYPE_DESCRIPTOR);
+            mv.getfield(generatedClassName, GLOBAL_FIELD_NAME, GLOBAL_TYPE_DESCRIPTOR);
         }
         // stack: [creatingGlobal, handle]
         final Label setupGlobal = new Label();
@@ -744,7 +741,7 @@
         final Label methodEnd = new Label();
         mv.visitLabel(methodEnd);
 
-        mv.visitLocalVariable("currentGlobal", SCRIPT_OBJECT_TYPE_DESCRIPTOR, null, setupGlobal, methodEnd, currentGlobalVar);
+        mv.visitLocalVariable("currentGlobal", GLOBAL_TYPE_DESCRIPTOR, null, setupGlobal, methodEnd, currentGlobalVar);
         mv.visitLocalVariable("globalsDiffer", Type.INT_TYPE.getDescriptor(), null, setupGlobal, methodEnd, globalsDifferVar);
 
         if(throwableDeclared) {
--- nashorn/src/jdk/nashorn/internal/runtime/linker/JavaAdapterClassLoader.java
+++ nashorn/src/jdk/nashorn/internal/runtime/linker/JavaAdapterClassLoader.java
@@ -31,6 +31,8 @@
 import java.security.ProtectionDomain;
 import java.security.SecureClassLoader;
 import jdk.internal.dynalink.beans.StaticClass;
+import jdk.nashorn.internal.runtime.Context;
+import jdk.nashorn.internal.runtime.ScriptFunction;
 
 /**
  * This class encapsulates the bytecode of the adapter class and can be used to load it into the JVM as an actual Class.
@@ -85,13 +87,14 @@
             @Override
             public Class<?> loadClass(final String name, final boolean resolve) throws ClassNotFoundException {
                 try {
+                    Context.checkPackageAccess(name);
                     return super.loadClass(name, resolve);
                 } catch (final SecurityException se) {
                     // we may be implementing an interface or extending a class that was
                     // loaded by a loader that prevents package.access. If so, it'd throw
                     // SecurityException for nashorn's classes!. For adapter's to work, we
-                    // should be able to refer to nashorn classes.
-                    if (name.startsWith("jdk.nashorn.internal.")) {
+                    // should be able to refer to the few classes it needs in its implementation.
+                    if(ScriptFunction.class.getName().equals(name) || JavaAdapterServices.class.getName().equals(name)) {
                         return myLoader.loadClass(name);
                     }
                     throw se;
--- nashorn/src/jdk/nashorn/internal/runtime/linker/JavaAdapterFactory.java
+++ nashorn/src/jdk/nashorn/internal/runtime/linker/JavaAdapterFactory.java
@@ -248,7 +248,7 @@
     }
 
     private static class AdapterInfo {
-        private static final ClassAndLoader SCRIPT_OBJECT_LOADER = new ClassAndLoader(ScriptObject.class, true);
+        private static final ClassAndLoader SCRIPT_OBJECT_LOADER = new ClassAndLoader(ScriptFunction.class, true);
 
         private final ClassLoader commonLoader;
         // TODO: soft reference the JavaAdapterClassLoader objects. They can be recreated when needed.
--- nashorn/src/jdk/nashorn/internal/runtime/linker/JavaAdapterServices.java
+++ nashorn/src/jdk/nashorn/internal/runtime/linker/JavaAdapterServices.java
@@ -116,8 +116,8 @@
      * static initializers.
      * @return the thread-local JS object used to define methods for the class being initialized.
      */
-    public static ScriptObject getClassOverrides() {
-        final ScriptObject overrides = classOverrides.get();
+    public static Object getClassOverrides() {
+        final Object overrides = classOverrides.get();
         assert overrides != null;
         return overrides;
     }
@@ -134,6 +134,22 @@
         NO_PERMISSIONS_INVOKER.invokeExact(method, arg);
     }
 
+    /**
+     * Set the current global scope
+     * @param global the global scope
+     */
+    public static void setGlobal(final Object global) {
+        Context.setGlobal((ScriptObject)global);
+    }
+
+    /**
+     * Get the current global scope
+     * @return the current global scope
+     */
+    public static Object getGlobal() {
+        return Context.getGlobal();
+    }
+
     static void setClassOverrides(ScriptObject overrides) {
         classOverrides.set(overrides);
     }
--- nashorn/src/jdk/nashorn/internal/runtime/linker/ReflectionCheckLinker.java
+++ nashorn/src/jdk/nashorn/internal/runtime/linker/ReflectionCheckLinker.java
@@ -39,16 +39,38 @@
  * Check java reflection permission for java reflective and java.lang.invoke access from scripts
  */
 final class ReflectionCheckLinker implements TypeBasedGuardingDynamicLinker{
+    private static final Class<?> STATEMENT_CLASS  = getBeanClass("Statement");
+    private static final Class<?> XMLENCODER_CLASS = getBeanClass("XMLEncoder");
+    private static final Class<?> XMLDECODER_CLASS = getBeanClass("XMLDecoder");
+
+    private static Class<?> getBeanClass(final String name) {
+        try {
+            return Class.forName("java.beans." + name);
+        } catch (final ClassNotFoundException cnfe) {
+            // Possible to miss this class in other profiles.
+            return null;
+        }
+    }
+
     @Override
     public boolean canLinkType(final Class<?> type) {
         return isReflectionClass(type);
     }
 
     private static boolean isReflectionClass(final Class<?> type) {
+        // Class or ClassLoader subclasses
         if (type == Class.class || ClassLoader.class.isAssignableFrom(type)) {
             return true;
         }
 
+        // check for bean reflection
+        if ((STATEMENT_CLASS != null && STATEMENT_CLASS.isAssignableFrom(type)) ||
+            (XMLENCODER_CLASS != null && XMLENCODER_CLASS.isAssignableFrom(type)) ||
+            (XMLDECODER_CLASS != null && XMLDECODER_CLASS.isAssignableFrom(type))) {
+            return true;
+        }
+
+        // package name check
         final String name = type.getName();
         return name.startsWith("java.lang.reflect.") || name.startsWith("java.lang.invoke.");
     }
