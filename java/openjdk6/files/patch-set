/*
 * Copyright 2008-2009 Sun Microsystems, Inc.  All Rights Reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
 * CA 95054 USA or visit www.sun.com if you need additional information or
 * have any questions.
 *
 */
diff -upr ../orig/corba/make/common/Defs-bsd.gmk ./corba/make/common/Defs-bsd.gmk
--- ../orig/corba/make/common/Defs-bsd.gmk	2009-05-04 18:32:16.000000000 -0400
+++ ./corba/make/common/Defs-bsd.gmk	2009-05-05 14:33:21.000000000 -0400
@@ -40,18 +40,12 @@
 # Get shared JDK settings
 include $(BUILDDIR)/common/shared/Defs.gmk
 
-# Part of INCREMENTAL_BUILD mechanism.
-#   Compiler emits things like:  path/file.o: file.h
-#   We want something like: relative_path/file.o relative_path/file.d: file.h
-CC_DEPEND	 = -MM
-CC_DEPEND_FILTER = $(SED) -e 's!$*\.$(OBJECT_SUFFIX)!$(dir $@)& $(dir $@)$*.$(DEPEND_SUFFIX)!g'
-
 ifndef PLATFORM_SRC
   PLATFORM_SRC = $(TOPDIR)/src/solaris
 endif # PLATFORM_SRC
 
 # platform specific include files
-PLATFORM_INCLUDE_NAME = $(PLATFORM)
+PLATFORM_INCLUDE_NAME = $(OS_NAME)
 PLATFORM_INCLUDE      = $(INCLUDEDIR)/$(PLATFORM_INCLUDE_NAME)
 
 # suffix used for make dependencies files.
@@ -94,6 +88,10 @@ endif
 #    as the default.
 CFLAGS_REQUIRED_amd64   += -fno-omit-frame-pointer -D_LITTLE_ENDIAN
 CFLAGS_REQUIRED_i586    += -fno-omit-frame-pointer -D_LITTLE_ENDIAN
+ifeq ($(OS_VENDOR),Apple)
+  # 16-byte stack re-alignment on 32-bit Darwin
+  CFLAGS_REQUIRED_i586 += -mstackrealign
+endif
 CFLAGS_REQUIRED_ia64    += -fno-omit-frame-pointer -D_LITTLE_ENDIAN
 CFLAGS_REQUIRED_sparcv9 += -m64 -mcpu=v9
 LDFLAGS_COMMON_sparcv9  += -m64 -mcpu=v9
@@ -168,7 +166,7 @@ ifeq ($(FASTDEBUG), true)
   CXXFLAGS_DBG	+= $(CC_LOWER_OPT)
 endif
 
-CPPFLAGS_COMMON = -D$(ARCH) -DARCH='"$(ARCH)"' -DLINUX $(VERSION_DEFINES) \
+CPPFLAGS_COMMON = -D$(ARCH) -DARCH='"$(ARCH)"' -D_ALLBSD_SOURCE $(VERSION_DEFINES) \
 		  -D_LARGEFILE64_SOURCE -D_GNU_SOURCE -D_REENTRANT
 
 ifeq ($(ARCH_DATA_MODEL), 64)
@@ -178,33 +176,15 @@ endif
 CPPFLAGS_OPT    = 
 CPPFLAGS_DBG    = -DDEBUG
 
-ifdef LIBRARY
-  # Libraries need to locate other libraries at runtime, and you can tell
-  #   a library where to look by way of the dynamic runpaths (RPATH or RUNPATH)
-  #   buried inside the .so. The $ORIGIN says to look relative to where
-  #   the library itself is and it can be followed with relative paths from
-  #   that. By default we always look in $ORIGIN, optionally we add relative
-  #   paths if the Makefile sets LD_RUNPATH_EXTRAS to those relative paths.
-  #   On Bsd we add a flag -z origin, not sure if this is necessary, but 
-  #   doesn't seem to hurt.
-  #   The environment variable LD_LIBRARY_PATH will over-ride these runpaths.
-  #   Try: 'readelf -d lib*.so' to see these settings in a library.
-  #
-  LDFLAGS_COMMON += -Xlinker -z -Xlinker origin -Xlinker -rpath -Xlinker \$$ORIGIN
-  LDFLAGS_COMMON += $(LD_RUNPATH_EXTRAS:%=-Xlinker -z -Xlinker origin -Xlinker -rpath -Xlinker \$$ORIGIN/%)
-endif
-
-EXTRA_LIBS += -lc
-
-LDFLAGS_DEFS_OPTION  = -z defs
-LDFLAGS_COMMON  += $(LDFLAGS_DEFS_OPTION)
-
 #
 # -L paths for finding and -ljava
 #
-LDFLAGS_OPT     = -Xlinker -O1
 LDFLAGS_COMMON += -L$(LIBDIR)/$(LIBARCH)
+
+ifneq ($(OS_VENDOR), Apple)
+LDFLAGS_OPT     = -Xlinker -O1
 LDFLAGS_COMMON += -Wl,-soname=$(LIB_PREFIX)$(LIBRARY).$(LIBRARY_SUFFIX)
+endif
 
 #
 # -static-libgcc is a gcc-3 flag to statically link libgcc, gcc-2.9x always
@@ -235,13 +215,9 @@ endif
 #
 LD_MAPFILE_FLAG = -Xlinker --version-script -Xlinker
 
-#
-# Support for Quantify.
-#
-ifdef QUANTIFY
-QUANTIFY_CMD = quantify
-QUANTIFY_OPTIONS = -cache-dir=/tmp/quantify -always-use-cache-dir=yes
-LINK_PRE_CMD = $(QUANTIFY_CMD) $(QUANTIFY_OPTIONS)
+# Darwin does not support linker map files.
+ifeq ($(OS_VENDOR), Apple)
+LDNOMAP=true
 endif
 
 #
@@ -270,7 +246,9 @@ override HAVE_ALTZONE            = false
 override HAVE_FILIOH             = false
 override HAVE_GETHRTIME          = false
 override HAVE_GETHRVTIME         = false
+ifeq ($(OS_VENDOR),Apple)
 override HAVE_SIGIGNORE          = true
+endif
 override LEX_LIBRARY             = -lfl
 ifeq ($(STATIC_CXX),true)
 override LIBCXX                  = -Wl,-Bstatic -lstdc++ -lgcc -Wl,-Bdynamic
@@ -281,13 +259,9 @@ override LIBPOSIX4               =
 override LIBSOCKET               =
 override LIBTHREAD               =
 override MOOT_PRIORITIES         = true
-override NO_INTERRUPTIBLE_IO     = true
-override OPENWIN_HOME            = /usr/X11R6
-ifeq ($(ARCH), amd64)
-override OPENWIN_LIB             = $(OPENWIN_HOME)/lib64
-else
+override NO_INTERRUPTIBLE_IO     = false
+override OPENWIN_HOME            = $(X11_PATH)
 override OPENWIN_LIB             = $(OPENWIN_HOME)/lib
-endif
 override OTHER_M4FLAGS           = -D__GLIBC__ -DGNU_ASSEMBLER
 override SUN_CMM_SUBDIR          =
 override THREADS_FLAG            = native
diff -upr ../orig/corba/make/common/Defs-linux.gmk ./corba/make/common/Defs-linux.gmk
--- ../orig/corba/make/common/Defs-linux.gmk	2009-01-27 15:40:31.000000000 -0500
+++ ./corba/make/common/Defs-linux.gmk	2009-05-04 17:37:15.000000000 -0400
@@ -282,7 +282,7 @@ override LIBSOCKET               =
 override LIBTHREAD               =
 override MOOT_PRIORITIES         = true
 override NO_INTERRUPTIBLE_IO     = true
-override OPENWIN_HOME            = /usr/X11R6
+override OPENWIN_HOME            = $(X11_PATH)
 ifeq ($(ARCH), amd64)
 override OPENWIN_LIB             = $(OPENWIN_HOME)/lib64
 else
diff -upr ../orig/corba/make/common/Defs.gmk ./corba/make/common/Defs.gmk
--- ../orig/corba/make/common/Defs.gmk	2009-01-27 15:40:31.000000000 -0500
+++ ./corba/make/common/Defs.gmk	2009-05-04 17:37:15.000000000 -0400
@@ -53,6 +53,24 @@ endif
 
 _OUTPUTDIR=$(TOPDIR)/build/$(PLATFORM)-$(ARCH)
 
+ifneq ($(PLATFORM), windows)
+  ifdef ALT_X11_PATH
+    X11_PATH = $(ALT_X11_PATH)
+  else
+    X11_PATH = /usr/X11R6
+  endif 
+
+  ifdef ALT_PACKAGE_PATH
+    PACKAGE_PATH = $(ALT_PACKAGE_PATH)
+  else
+    ifeq ($(PLATFORM), linux)
+      PACKAGE_PATH = /usr
+    else
+      PACKAGE_PATH = /usr/local
+    endif
+  endif
+endif
+
 #
 # Get platform definitions
 #
@@ -97,6 +115,9 @@ ifdef PROGRAM
     LDLIBS_COMMON = -ldl
   endif
 
+  ifeq ($(PLATFORM), bsd)
+    LDLIBS_COMMON = -pthread
+  endif
 endif # PROGRAM
 
 LDLIBS_COMMON += $(EXTRA_LIBS)
diff -upr ../orig/corba/make/common/Mapfile-vers.gmk ./corba/make/common/Mapfile-vers.gmk
--- ../orig/corba/make/common/Mapfile-vers.gmk	2009-01-27 15:40:31.000000000 -0500
+++ ./corba/make/common/Mapfile-vers.gmk	2009-05-04 17:37:15.000000000 -0400
@@ -77,7 +77,7 @@ endif
 endif # PLATFORM
 
 
-ifeq ($(PLATFORM), linux)
+ifneq (,$(findstring $(PLATFORM), linux bsd))
 
 ifeq ($(VARIANT), OPT)
   # OPT build MUST have a mapfile?
diff -upr ../orig/corba/make/common/shared/Compiler-gcc.gmk ./corba/make/common/shared/Compiler-gcc.gmk
--- ../orig/corba/make/common/shared/Compiler-gcc.gmk	2009-01-27 15:40:31.000000000 -0500
+++ ./corba/make/common/shared/Compiler-gcc.gmk	2009-05-04 17:37:15.000000000 -0400
@@ -99,6 +99,24 @@ ifeq ($(PLATFORM), linux)
 
 endif
 
+ifeq ($(PLATFORM), bsd)
+  # Settings specific to BSD
+  CC             = $(COMPILER_PATH)gcc
+  CPP            = $(COMPILER_PATH)gcc -E
+  CXX            = $(COMPILER_PATH)g++
+  REQUIRED_CC_VER = 3.3
+  REQUIRED_GCC_VER = 3.3.*
+
+# Option used to create a shared library
+ifeq ($(OS_VENDOR), Apple)
+  SHARED_LIBRARY_FLAG = -dynamiclib
+else
+  SHARED_LIBRARY_FLAG = -shared
+endif
+
+  SUN_COMP_VER := $(shell $(CC) --verbose 2>&1 )
+endif
+
 ifeq ($(PLATFORM), solaris)
 
   # Settings specific to Solaris
diff -upr ../orig/corba/make/common/shared/Compiler.gmk ./corba/make/common/shared/Compiler.gmk
--- ../orig/corba/make/common/shared/Compiler.gmk	2009-01-27 15:40:31.000000000 -0500
+++ ./corba/make/common/shared/Compiler.gmk	2009-05-04 17:37:15.000000000 -0400
@@ -42,6 +42,11 @@ ifeq ($(PLATFORM), linux)
   override CC_VERSION = gcc
 endif
 
+# BSD uses GNU compilers by default
+ifeq ($(PLATFORM), bsd)
+  override CC_VERSION = gcc
+endif
+
 # Get the compiler specific settings
 include $(BUILDDIR)/common/shared/Compiler-$(CC_VERSION).gmk
 
diff -upr ../orig/corba/make/common/shared/Defs-bsd.gmk ./corba/make/common/shared/Defs-bsd.gmk
--- ../orig/corba/make/common/shared/Defs-bsd.gmk	2009-05-04 18:32:16.000000000 -0400
+++ ./corba/make/common/shared/Defs-bsd.gmk	2009-05-04 17:37:15.000000000 -0400
@@ -54,7 +54,7 @@ $(shell if [ "$1" != "" -a -d "$1" ]; th
 endef
 
 # Location on system where jdk installs might be
-USRJDKINSTANCES_PATH =/opt/java
+USRJDKINSTANCES_PATH =$(PACKAGE_PATH)
 
 # UNIXCOMMAND_PATH: path to where the most common Unix commands are.
 #  NOTE: Must end with / so that it could be empty, allowing PATH usage.
@@ -107,7 +107,7 @@ endif
 ifneq "$(origin ALT_DEVTOOLS_PATH)" "undefined"
   DEVTOOLS_PATH :=$(call PrefixPath,$(ALT_DEVTOOLS_PATH))
 else
-  DEVTOOLS_PATH =/usr/bin/
+  DEVTOOLS_PATH =$(PACKAGE_PATH)/bin/
 endif
 
 # _BOOTDIR1: First choice for a Bootstrap JDK, previous released JDK.
diff -upr ../orig/corba/make/common/shared/Defs-utils.gmk ./corba/make/common/shared/Defs-utils.gmk
--- ../orig/corba/make/common/shared/Defs-utils.gmk	2009-01-27 15:40:31.000000000 -0500
+++ ./corba/make/common/shared/Defs-utils.gmk	2009-05-04 17:37:15.000000000 -0400
@@ -53,6 +53,13 @@ ifeq ($(PLATFORM),linux)
   UTILS_DEVTOOL_PATH=$(USRBIN_PATH)
 endif
 
+ifeq ($(PLATFORM),bsd)
+  UTILS_COMMAND_PATH=$(UNIXCOMMAND_PATH)
+  UTILS_USR_BIN_PATH=$(USRBIN_PATH)
+  UTILS_CCS_BIN_PATH=$(USRBIN_PATH)
+  UTILS_DEVTOOL_PATH=$(DEVTOOLS_PATH)
+endif
+
 ifeq ($(PLATFORM),solaris)
   UTILS_COMMAND_PATH=$(UNIXCOMMAND_PATH)
   UTILS_USR_BIN_PATH=$(UNIXCOMMAND_PATH)
@@ -209,3 +216,32 @@ ifeq ($(PLATFORM),solaris)
   ECHO           = /usr/bin/echo
 endif
 
+# BSD specific
+ifeq ($(PLATFORM),bsd)
+  BASENAME     = $(UTILS_USR_BIN_PATH)basename
+  EGREP        = $(UTILS_USR_BIN_PATH)egrep
+  EXPR         = $(UTILS_COMMAND_PATH)expr
+  FMT          = $(UTILS_USR_BIN_PATH)fmt
+  GREP         = $(UTILS_USR_BIN_PATH)grep
+  GUNZIP       = $(UTILS_USR_BIN_PATH)gunzip
+  ID           = $(UTILS_USR_BIN_PATH)id
+  MSGFMT       = $(UTILS_DEVTOOL_PATH)msgfmt
+  SED          = $(UTILS_USR_BIN_PATH)sed
+  SORT         = $(UTILS_USR_BIN_PATH)sort
+  TEST         = $(UTILS_COMMAND_PATH)test
+  TOUCH        = $(UTILS_USR_BIN_PATH)touch
+  TRUE         = $(UTILS_USR_BIN_PATH)true
+  UNAME        = $(UTILS_USR_BIN_PATH)uname
+  # BSD OS_VENDOR specific
+  ifeq ($(OS_VENDOR), Apple)
+    NAWK       = $(UTILS_USR_BIN_PATH)awk
+    UNZIPSFX   = $(UTILS_USR_BIN_PATH)unzipsfx
+    ZIPEXE     = $(UTILS_USR_BIN_PATH)zip
+  else
+    UNZIP      = $(UTILS_DEVTOOL_PATH)unzip
+  endif
+  ifneq ($(OS_VENDOR), OpenBSD)
+    CPIO       = $(UTILS_USR_BIN_PATH)cpio
+    TAR        = $(UTILS_USR_BIN_PATH)tar
+  endif
+endif
diff -upr ../orig/corba/make/common/shared/Platform.gmk ./corba/make/common/shared/Platform.gmk
--- ../orig/corba/make/common/shared/Platform.gmk	2009-01-27 15:40:31.000000000 -0500
+++ ./corba/make/common/shared/Platform.gmk	2009-05-04 17:37:15.000000000 -0400
@@ -262,6 +262,76 @@ ifeq ($(SYSTEM_UNAME), Linux)
   MB_OF_MEMORY := $(shell free -m | fgrep Mem: | sed -e 's@\ \ *@ @g' | cut -d' ' -f2)
 endif
 
+ifeq ($(SYSTEM_UNAME), FreeBSD)
+  PLATFORM = bsd
+  OS_NAME = freebsd
+  OS_VENDOR = FreeBSD
+ REQUIRED_OS_VERSION = 6.0
+endif
+
+ifeq ($(SYSTEM_UNAME), Darwin)
+  PLATFORM = bsd
+  OS_NAME = darwin
+  OS_VENDOR = Apple
+ REQUIRED_OS_VERSION = 8.0
+endif
+
+ifeq ($(SYSTEM_UNAME), NetBSD)
+  PLATFORM = bsd
+  OS_NAME = netbsd
+  OS_VENDOR = NetBSD
+  REQUIRED_OS_VERSION = 3.0
+endif
+
+ifeq ($(SYSTEM_UNAME), OpenBSD)
+  PLATFORM = bsd
+  OS_NAME = openbsd
+  OS_VENDOR = OpenBSD
+  REQUIRED_OS_VERSION = 4.2
+endif
+
+# Platform settings specific to BSD
+ifeq ($(PLATFORM), bsd)
+  OS_VERSION := $(shell uname -r)
+  # Arch and OS name/version
+  mach := $(shell uname -m)
+  archExpr = case "$(mach)" in \
+                i[3-9]86) \
+                    echo i586 \
+                    ;; \
+                *) \
+                    echo $(mach) \
+                    ;; \
+      esac
+  ARCH        := $(shell $(archExpr) )
+  ARCH_FAMILY := $(ARCH)
+
+  # i586 and sparc are 32 bit, amd64 and sparc64 are 64
+  ifneq (,$(findstring $(ARCH), i586 sparc))
+    ARCH_DATA_MODEL=32
+  else
+    ARCH_DATA_MODEL=64
+  endif
+
+  # Need to maintain the jre/lib/i386 location for 32-bit Intel
+  ifeq ($(ARCH), i586)
+    LIBARCH = i386
+  else
+    LIBARCH = $(ARCH)
+  endif
+
+  # Value of Java os.arch property
+  ARCHPROP  = $(LIBARCH)
+
+  # Suffix for file bundles used in previous release
+  BUNDLE_FILE_SUFFIX=.tar.gz
+  # Minimum disk space needed as determined by running 'du -sk' on 
+  #    a fully built workspace.
+  REQUIRED_FREE_SPACE=1500000
+  # How much RAM does this machine have:
+  MB_OF_MEMORY=$(shell sysctl -n hw.physmem | awk '{print int($$NF / 1048576); }' )
+endif
+
 # Windows with and without CYGWIN will be slightly different
 ifeq ($(SYSTEM_UNAME), Windows_NT)
   PLATFORM = windows
@@ -373,7 +443,14 @@ endif
 #    build machines and adjustments will be made to prevent excessing
 #    system swapping during the build.
 #    If we don't know, assume 512. Subtract 128 from MB for VM MAX.
-#    Don't set VM max over 1024-128=896.
+#    Don't set VM max over 1024-128=896, except on OpenBSD where
+#    736 is the max.
+ifeq ($(OS_VENDOR), OpenBSD)
+  ABS_MAX_MEMORY := "736"
+else
+  ABS_MAX_MEMORY := "896"
+endif
+
 ifneq ($(MB_OF_MEMORY),)
   LOW_MEMORY_MACHINE := $(shell \
     if [ $(MB_OF_MEMORY) -le 512 ] ; then \
@@ -385,7 +462,7 @@ ifneq ($(MB_OF_MEMORY),)
     if [ $(MB_OF_MEMORY) -le 1024 ] ; then \
       expr $(MB_OF_MEMORY) '-' 128 ; \
     else \
-      echo "896"; \
+      echo $(ABS_MAX_MEMORY); \
     fi)
   MIN_VM_MEMORY := $(shell \
     if [ $(MAX_VM_MEMORY) -le 128 ] ; then \
diff -upr ../orig/corba/make/sun/corba/core/Makefile ./corba/make/sun/corba/core/Makefile
--- ../orig/corba/make/sun/corba/core/Makefile	2009-01-27 15:40:31.000000000 -0500
+++ ./corba/make/sun/corba/core/Makefile	2009-05-04 17:37:15.000000000 -0400
@@ -53,11 +53,19 @@ include $(CORBA_JMK_DIRECTORY)sun_corba.
 ifdef STANDALONE_CORBA_WS
 # FIXUP: What is this all about?
 OTHER_LDFLAGS=-L$(BOOTDIR)/jre/lib/$(ARCH) -L$(BOOTDIR)/jre/lib/$(LIBARCH)/native_threads -ljvm
+ifeq ($(PLATFORM), bsd)
+OTHER_INCLUDES+=-ICClassHeaders -I$(BOOTDIR)/include -I$(BOOTDIR)/include/$(OS_NAME)
+else
 OTHER_INCLUDES+=-ICClassHeaders -I$(BOOTDIR)/include -I$(BOOTDIR)/include/$(PLATFORM)
+endif
 else
 OTHER_LDLIBS=$(JVMLIB)
+ifeq ($(PLATFORM), bsd)
+OTHER_INCLUDES+=-ICClassHeaders -I$(BOOTDIR)/include -I$(BOOTDIR)/include/$(OS_NAME)
+else
 OTHER_INCLUDES+=-ICClassHeaders -I$(BOOTDIR)/include -I$(BOOTDIR)/include/$(PLATFORM)
 endif
+endif
 
 
 FILES_c = ioser.c
diff -upr ../orig/hotspot/build/bsd/Makefile ./hotspot/build/bsd/Makefile
--- ../orig/hotspot/build/bsd/Makefile	2009-05-04 18:32:15.000000000 -0400
+++ ./hotspot/build/bsd/Makefile	2009-05-04 19:16:59.000000000 -0400
@@ -198,7 +198,8 @@ checks: check_os_version check_j2se_vers
 # Solaris 2.5.1, 2.6).
 # Disable this check by setting DISABLE_HOTSPOT_OS_VERSION_CHECK=ok.
 
-SUPPORTED_OS_VERSION = 2.4% 2.5% 2.6% 2.7%
+#SUPPORTED_OS_VERSION = 2.4% 2.5% 2.6% 2.7%
+DISABLE_HOTSPOT_OS_VERSION_CHECK = ok
 OS_VERSION := $(shell uname -r)
 EMPTY_IF_NOT_SUPPORTED = $(filter $(SUPPORTED_OS_VERSION),$(OS_VERSION))
 
diff -upr ../orig/hotspot/build/bsd/makefiles/buildtree.make ./hotspot/build/bsd/makefiles/buildtree.make
--- ../orig/hotspot/build/bsd/makefiles/buildtree.make	2009-05-04 18:32:15.000000000 -0400
+++ ./hotspot/build/bsd/makefiles/buildtree.make	2009-05-05 15:01:26.000000000 -0400
@@ -273,10 +273,11 @@ env.sh: $(BUILDTREE_MAKE)
 	[ -n "$$JAVA_HOME" ] && { echo ": \$${JAVA_HOME:=$${JAVA_HOME}}"; }; \
 	{ \
 	echo "LD_LIBRARY_PATH=.:$${LD_LIBRARY_PATH:+$$LD_LIBRARY_PATH:}\$${JAVA_HOME}/jre/lib/${LIBARCH}/native_threads:\$${JAVA_HOME}/jre/lib/${LIBARCH}:${GCC_LIB}"; \
+	echo "DYLD_LIBRARY_PATH=.:$${DYLD_LIBRARY_PATH:+$$DYLD_LIBRARY_PATH:}\$${JAVA_HOME}/jre/lib/${LIBARCH}/native_threads:\$${JAVA_HOME}/jre/lib/${LIBARCH}:${GCC_LIB}"; \
 	echo "CLASSPATH=$${CLASSPATH:+$$CLASSPATH:}.:\$${JAVA_HOME}/jre/lib/rt.jar:\$${JAVA_HOME}/jre/lib/i18n.jar"; \
 	} | sed s:$${JAVA_HOME:--------}:\$${JAVA_HOME}:g; \
 	echo "HOTSPOT_BUILD_USER=\"$${LOGNAME:-$$USER} in `basename $(GAMMADIR)`\""; \
-	echo "export JAVA_HOME LD_LIBRARY_PATH CLASSPATH HOTSPOT_BUILD_USER"; \
+	echo "export JAVA_HOME LD_LIBRARY_PATH DYLD_LIBRARY_PATH CLASSPATH HOTSPOT_BUILD_USER"; \
 	) > $@
 
 env.csh: env.sh
diff -upr ../orig/hotspot/build/bsd/makefiles/cscope.make ./hotspot/build/bsd/makefiles/cscope.make
--- ../orig/hotspot/build/bsd/makefiles/cscope.make	2009-05-04 18:32:15.000000000 -0400
+++ ./hotspot/build/bsd/makefiles/cscope.make	2009-05-05 15:08:05.000000000 -0400
@@ -72,7 +72,7 @@ endif
 # OS-specific files for other systems are excluded by default.  Use CS_OS=yes
 # to include platform-specific files for other platforms.
 ifndef	CS_OS
-CS_OS		= bsd macos solaris win32
+CS_OS		= linux macos solaris win32 bsd
 CS_PRUNE_OS	= $(patsubst %,-o -name '*%*',$(filter-out ${OS},${CS_OS}))
 endif
 
diff -upr ../orig/hotspot/build/bsd/makefiles/defs.make ./hotspot/build/bsd/makefiles/defs.make
--- ../orig/hotspot/build/bsd/makefiles/defs.make	2009-05-04 18:32:16.000000000 -0400
+++ ./hotspot/build/bsd/makefiles/defs.make	2009-05-04 17:37:15.000000000 -0400
@@ -28,6 +28,14 @@
 
 SLASH_JAVA ?= /java
 
+# Library suffix
+OS_VENDOR:=$(shell uname -s)
+ifeq ($(OS_VENDOR),Darwin)
+  LIBRARY_SUFFIX=dylib
+else
+  LIBRARY_SUFFIX=so
+endif
+
 # Need PLATFORM (os-arch combo names) for jdk and hotspot, plus libarch name
 ARCH:=$(shell uname -m)
 PATH_SEP = :
@@ -79,6 +87,31 @@ ifeq ($(ARCH), x86_64) 
   endif
 endif
 
+# amd64
+ifeq ($(ARCH), amd64)
+  ARCH_DATA_MODEL = 64
+  MAKE_ARGS       += LP64=1
+  PLATFORM        = bsd-amd64
+  VM_PLATFORM     = bsd_amd64
+  HS_ARCH         = x86
+endif
+
+# i386
+ifeq ($(ARCH), i386)
+  ARCH_DATA_MODEL  = 32
+  PLATFORM         = bsd-i586
+  VM_PLATFORM      = bsd_i486
+  HS_ARCH          = x86
+endif
+
+# i486
+ifeq ($(ARCH), i486)
+  ARCH_DATA_MODEL  = 32
+  PLATFORM         = bsd-i586
+  VM_PLATFORM      = bsd_i486
+  HS_ARCH          = x86
+endif
+
 # i686
 ifeq ($(ARCH), i686)
   ARCH_DATA_MODEL  = 32
@@ -95,19 +128,11 @@ VM_DEBUG=jvmg
 EXPORT_LIST += $(EXPORT_DOCS_DIR)/platform/jvmti/jvmti.html
 EXPORT_SERVER_DIR = $(EXPORT_JRE_LIB_ARCH_DIR)/server
 EXPORT_LIST += $(EXPORT_SERVER_DIR)/Xusage.txt
-EXPORT_LIST += $(EXPORT_SERVER_DIR)/libjsig.so
-EXPORT_LIST += $(EXPORT_SERVER_DIR)/libjvm.so
+EXPORT_LIST += $(EXPORT_SERVER_DIR)/libjsig.$(LIBRARY_SUFFIX)
+EXPORT_LIST += $(EXPORT_SERVER_DIR)/libjvm.$(LIBRARY_SUFFIX)
 ifeq ($(ARCH_DATA_MODEL), 32)
   EXPORT_CLIENT_DIR = $(EXPORT_JRE_LIB_ARCH_DIR)/client
   EXPORT_LIST += $(EXPORT_CLIENT_DIR)/Xusage.txt
-  EXPORT_LIST += $(EXPORT_CLIENT_DIR)/libjsig.so
-  EXPORT_LIST += $(EXPORT_CLIENT_DIR)/libjvm.so 
-  EXPORT_LIST += $(EXPORT_JRE_LIB_ARCH_DIR)/libsaproc.so
-  EXPORT_LIST += $(EXPORT_LIB_DIR)/sa-jdi.jar 
-else
-  ifeq ($(ARCH),ia64)
-    else
-      EXPORT_LIST += $(EXPORT_JRE_LIB_ARCH_DIR)/libsaproc.so
-      EXPORT_LIST += $(EXPORT_LIB_DIR)/sa-jdi.jar
-    endif
+  EXPORT_LIST += $(EXPORT_CLIENT_DIR)/libjsig.$(LIBRARY_SUFFIX)
+  EXPORT_LIST += $(EXPORT_CLIENT_DIR)/libjvm.$(LIBRARY_SUFFIX)
 endif
diff -upr ../orig/hotspot/build/bsd/makefiles/gcc.make ./hotspot/build/bsd/makefiles/gcc.make
--- ../orig/hotspot/build/bsd/makefiles/gcc.make	2009-05-04 18:32:16.000000000 -0400
+++ ./hotspot/build/bsd/makefiles/gcc.make	2009-05-04 17:37:15.000000000 -0400
@@ -22,12 +22,15 @@
 #  
 #
 
+OS_VENDOR = $(shell uname -s)
+
 #------------------------------------------------------------------------
 # CC, CPP & AS
 
-CPP = g++
-CC  = gcc
-AS  = $(CC) -c
+CXX ?= g++
+CPP  = $(CXX)
+CC  ?= gcc
+AS   = $(CC) -c -x assembler-with-cpp
 
 # -dumpversion in gcc-2.91 shows "egcs-2.91.66". In later version, it only
 # prints the numbers (e.g. "2.95", "3.2.1")
@@ -62,7 +65,7 @@ endif
 CFLAGS += $(VM_PICFLAG)
 CFLAGS += -fno-rtti
 CFLAGS += -fno-exceptions
-CFLAGS += -D_REENTRANT
+CFLAGS += -pthread
 CFLAGS += -fcheck-new
 
 ARCHFLAG = $(ARCHFLAG/$(BUILDARCH))
@@ -72,6 +75,15 @@ ARCHFLAG/ia64    =
 ARCHFLAG/sparc   = -m32 -mcpu=v9
 ARCHFLAG/sparcv9 = -m64 -mcpu=v9
 
+# Darwin-specific build flags
+ifeq ($(OS_VENDOR), Darwin)
+  # Ineffecient 16-byte stack re-alignment on Darwin/IA32
+  ARCHFLAG/i486 += -mstackrealign
+
+  # -arch compiler flag required for x64_64
+  ARCHFLAGS/amd64 += -arch x86_64
+endif
+
 CFLAGS     += $(ARCHFLAG)
 AOUT_FLAGS += $(ARCHFLAG)
 LFLAGS     += $(ARCHFLAG)
@@ -96,6 +108,11 @@ ACCEPTABLE_WARNINGS = -Wpointer-arith -W
 CFLAGS_WARN/DEFAULT = $(WARNINGS_ARE_ERRORS) $(ACCEPTABLE_WARNINGS)
 # Special cases
 CFLAGS_WARN/BYFILE = $(CFLAGS_WARN/$@)$(CFLAGS_WARN/DEFAULT$(CFLAGS_WARN/$@)) 
+# XXXDARWIN: for _dyld_bind_fully_image_containing_address
+ifeq ($(OS_VENDOR), Darwin)
+  CFLAGS_WARN/os_bsd.o = $(CFLAGS_WARN/DEFAULT) -Wno-deprecated-declarations
+endif
+
 
 # The flags to use for an Optimized g++ build
 OPT_CFLAGS += -O3
@@ -126,20 +143,40 @@ ifeq ($(BUILDARCH), ia64)
 LFLAGS += -Wl,-relax
 endif
 
-# Enable linker optimization
-LFLAGS += -Xlinker -O1
-
 # Use $(MAPFLAG:FILENAME=real_file_name) to specify a map file.
 MAPFLAG = -Xlinker --version-script=FILENAME
 
-# Use $(SONAMEFLAG:SONAME=soname) to specify the intrinsic name of a shared obj
-SONAMEFLAG = -Xlinker -soname=SONAME
+#
+# Shared Library
+#
+ifeq ($(OS_VENDOR), Darwin)
+  # Standard linker flags
+  LFLAGS +=
+
+  # Darwin doesn't use ELF and doesn't support version scripts
+  LDNOMAP = true
+
+  # Use $(SONAMEFLAG:SONAME=soname) to specify the intrinsic name of a shared obj
+  SONAMEFLAG =
+
+  # Build shared library
+  SHARED_FLAG = -dynamiclib $(VM_PICFLAG)
 
-# Build shared library
-SHARED_FLAG = -shared
+  # Keep symbols even they are not used
+  #AOUT_FLAGS += -export-dynamic
+else
+  # Enable linker optimization
+  LFLAGS += -Xlinker -O1
+
+  # Use $(SONAMEFLAG:SONAME=soname) to specify the intrinsic name of a shared obj
+  SONAMEFLAG = -Xlinker -soname=SONAME
 
-# Keep symbols even they are not used
-AOUT_FLAGS += -export-dynamic
+  # Build shared library
+  SHARED_FLAG = -shared $(VM_PICFLAG)
+
+  # Keep symbols even they are not used
+  AOUT_FLAGS += -export-dynamic
+endif
 
 #------------------------------------------------------------------------
 # Debug flags
diff -upr ../orig/hotspot/build/bsd/makefiles/jsig.make ./hotspot/build/bsd/makefiles/jsig.make
--- ../orig/hotspot/build/bsd/makefiles/jsig.make	2009-05-04 18:32:16.000000000 -0400
+++ ./hotspot/build/bsd/makefiles/jsig.make	2009-05-04 17:37:15.000000000 -0400
@@ -26,7 +26,12 @@
 
 # libjsig[_g].so: signal interposition library
 JSIG = jsig$(G_SUFFIX)
-LIBJSIG = lib$(JSIG).so
+
+ifeq ($(OS_VENDOR), Darwin)
+  LIBJSIG = lib$(JSIG).dylib
+else
+  LIBJSIG = lib$(JSIG).so
+endif
 
 JSIGSRCDIR = $(GAMMADIR)/src/os/$(Platform_os_family)/vm
 
@@ -39,12 +44,12 @@ LIBJSIG_MAPFILE = $(MAKEFILES_DIR)/mapfi
 # cause problems with interposing. See CR: 6466665
 # LFLAGS_JSIG += $(MAPFLAG:FILENAME=$(LIBJSIG_MAPFILE))
 
-LFLAGS_JSIG += -D_GNU_SOURCE -D_REENTRANT
+LFLAGS_JSIG += -D_GNU_SOURCE -pthread
 
 $(LIBJSIG): $(JSIGSRCDIR)/jsig.c $(LIBJSIG_MAPFILE)
 	@echo Making signal interposition lib...
 	$(QUIETLY) $(CC) $(SYMFLAG) $(ARCHFLAG) $(SHARED_FLAG) $(PICFLAG) \
-                         $(LFLAGS_JSIG) -o $@ $< -ldl
+                         $(LFLAGS_JSIG) -o $@ $<
 
 install_jsig: $(LIBJSIG)
 	@echo "Copying $(LIBJSIG) to $(DEST_JSIG)"
diff -upr ../orig/hotspot/build/bsd/makefiles/launcher.make ./hotspot/build/bsd/makefiles/launcher.make
--- ../orig/hotspot/build/bsd/makefiles/launcher.make	2009-05-04 18:32:16.000000000 -0400
+++ ./hotspot/build/bsd/makefiles/launcher.make	2009-05-04 17:37:15.000000000 -0400
@@ -44,7 +44,7 @@ ifeq ($(LINK_INTO),AOUT)
   LIBS_LAUNCHER             += $(STATIC_STDCXX) $(LIBS)
 else
   LAUNCHER.o                 = launcher.o
-  LFLAGS_LAUNCHER           += -L `pwd`
+  LFLAGS_LAUNCHER           += -L`pwd`
   LIBS_LAUNCHER             += -l$(JVM) $(LIBS)
 endif
 
diff -upr ../orig/hotspot/build/bsd/makefiles/sa.make ./hotspot/build/bsd/makefiles/sa.make
--- ../orig/hotspot/build/bsd/makefiles/sa.make	2009-05-04 18:32:16.000000000 -0400
+++ ./hotspot/build/bsd/makefiles/sa.make	2009-05-04 17:37:17.000000000 -0400
@@ -42,7 +42,7 @@ SA_CLASSPATH = $(BOOT_JAVA_HOME)/lib/too
 
 # gnumake 3.78.1 does not accept the *s that
 # are in AGENT_ALLFILES, so use the shell to expand them
-AGENT_ALLFILES := $(shell /usr/bin/test -d $(AGENT_DIR) && /bin/ls $(AGENT_ALLFILES))
+AGENT_ALLFILES := $(shell /bin/test -d $(AGENT_DIR) && /bin/ls $(AGENT_ALLFILES))
 
 SA_CLASSDIR = $(GENERATED)/saclasses
 
diff -upr ../orig/hotspot/build/bsd/makefiles/saproc.make ./hotspot/build/bsd/makefiles/saproc.make
--- ../orig/hotspot/build/bsd/makefiles/saproc.make	2009-05-04 18:32:16.000000000 -0400
+++ ./hotspot/build/bsd/makefiles/saproc.make	2009-05-04 17:37:15.000000000 -0400
@@ -26,7 +26,12 @@
 
 # libsaproc[_g].so: serviceability agent
 SAPROC = saproc$(G_SUFFIX)
-LIBSAPROC = lib$(SAPROC).so
+
+ifeq ($(OS_VENDOR), Darwin)
+  LIBSAPROC = lib$(SAPROC).dylib
+else
+  LIBSAPROC = lib$(SAPROC).so
+endif
 
 AGENT_DIR = $(GAMMADIR)/agent
 
@@ -43,11 +48,11 @@ SAMAPFILE = $(SASRCDIR)/mapfile
 
 DEST_SAPROC = $(JDK_LIBDIR)/$(LIBSAPROC)
 
-# if $(AGENT_DIR) does not exist, we don't build SA
+# if $(SASRCDIR) does not exist, we don't build SA
 # also, we don't build SA on Itanium.
 
 checkAndBuildSA:
-	$(QUIETLY) if [ -d $(AGENT_DIR) -a "$(SRCARCH)" != "ia64" ] ; then \
+	$(QUIETLY) if [ -d $(SASRCDIR) -a "$(SRCARCH)" != "ia64" ] ; then \
 	   $(MAKE) -f vm.make $(LIBSAPROC); \
 	fi
 
diff -upr ../orig/hotspot/build/bsd/makefiles/vm.make ./hotspot/build/bsd/makefiles/vm.make
--- ../orig/hotspot/build/bsd/makefiles/vm.make	2009-05-04 18:32:16.000000000 -0400
+++ ./hotspot/build/bsd/makefiles/vm.make	2009-05-04 17:37:17.000000000 -0400
@@ -93,7 +93,7 @@ CFLAGS += $(CFLAGS/NOEX)
 # Extra flags from gnumake's invocation or environment
 CFLAGS += $(EXTRA_CFLAGS)
 
-LIBS += -lm -ldl -lpthread
+LIBS += -lm -pthread
 
 # By default, link the *.o into the library, not the executable.
 LINK_INTO$(LINK_INTO) = LIBJVM
@@ -108,7 +108,11 @@ include $(MAKEFILES_DIR)/dtrace.make
 # JVM
 
 JVM    = jvm$(G_SUFFIX)
-LIBJVM = lib$(JVM).so
+ifeq ($(OS_VENDOR), Darwin)
+  LIBJVM = lib$(JVM).dylib
+else
+  LIBJVM = lib$(JVM).so
+endif
 
 JVM_OBJ_FILES = $(Obj_Files)
 
@@ -122,7 +126,7 @@ mapfile_reorder : mapfile $(REORDERFILE)
 	rm -f $@
 	cat $^ > $@
 
-STATIC_CXX = true
+STATIC_CXX = false
 
 ifeq ($(LINK_INTO),AOUT)
   LIBJVM.o                 =
@@ -140,14 +144,14 @@ else
   ifeq ($(STATIC_CXX), true)
     LFLAGS_VM              += $(STATIC_LIBGCC)
     LIBS_VM                += $(STATIC_STDCXX)
+    LINK_VM                = $(LINK_LIB.c)
   else
-    LIBS_VM                += -lstdc++
+    LINK_VM                = $(LINK_LIB.CC)
   endif
 
   LIBS_VM                  += $(LIBS)
 endif
 
-LINK_VM = $(LINK_LIB.c)
 
 # rule for building precompiled header
 $(PRECOMPILED_HEADER): $(Precompiled_Files)
@@ -175,11 +179,6 @@ $(LD_SCRIPT): $(LIBJVM_MAPFILE)
 LD_SCRIPT_FLAG = -Wl,-T,$(LD_SCRIPT)
 endif
 
-# With more recent Redhat releases (or the cutting edge version Fedora), if
-# SEBsd is configured to be enabled, the runtime linker will fail to apply
-# the text relocation to libjvm.so considering that it is built as a non-PIC
-# DSO. To workaround that, we run chcon to libjvm.so after it is built. See 
-# details in bug 6538311.
 $(LIBJVM): $(LIBJVM.o) $(LIBJVM_MAPFILE) $(LD_SCRIPT)
 	$(QUIETLY) {                                                    \
 	    echo Linking vm...;                                         \
@@ -188,15 +187,6 @@ $(LIBJVM): $(LIBJVM.o) $(LIBJVM_MAPFILE)
 		       $(LFLAGS_VM) -o $@ $(LIBJVM.o) $(LIBS_VM);       \
 	    $(LINK_LIB.CC/POST_HOOK)                                    \
 	    rm -f $@.1; ln -s $@ $@.1;                                  \
-	    if [ -x /usr/sbin/sebsdenabled ] ; then                   \
-	      /usr/sbin/sebsdenabled;                                 \
-              if [ $$? = 0 ] ; then					\
-		/usr/bin/chcon -t textrel_shlib_t $@;                   \
-		if [ $$? != 0 ]; then                                   \
-		  echo "ERROR: Cannot chcon $@"; exit 1;                \
-		fi							\
-	      fi							\
-	    fi                                                          \
 	}
 
 DEST_JVM = $(JDK_LIBDIR)/$(VM_SUBDIR)/$(LIBJVM)
diff -upr ../orig/hotspot/build/bsd/platform_amd64 ./hotspot/build/bsd/platform_amd64
--- ../orig/hotspot/build/bsd/platform_amd64	2009-05-04 18:32:15.000000000 -0400
+++ ./hotspot/build/bsd/platform_amd64	2009-05-04 17:37:17.000000000 -0400
@@ -12,6 +12,4 @@ lib_arch = amd64
 
 compiler = gcc
 
-gnu_dis_arch = amd64
-
-sysdefs = -DLINUX -D_GNU_SOURCE -DAMD64
+sysdefs = -D_ALLBSD_SOURCE -D_GNU_SOURCE -DAMD64
diff -upr ../orig/hotspot/build/bsd/platform_i486 ./hotspot/build/bsd/platform_i486
--- ../orig/hotspot/build/bsd/platform_i486	2009-05-04 18:32:15.000000000 -0400
+++ ./hotspot/build/bsd/platform_i486	2009-05-04 17:37:17.000000000 -0400
@@ -12,6 +12,4 @@ lib_arch = i386
 
 compiler = gcc
 
-gnu_dis_arch = i386
-
-sysdefs = -DLINUX -D_GNU_SOURCE -DIA32
+sysdefs = -D_ALLBSD_SOURCE -D_GNU_SOURCE -DIA32
diff -upr ../orig/hotspot/build/bsd/platform_sparc ./hotspot/build/bsd/platform_sparc
--- ../orig/hotspot/build/bsd/platform_sparc	2009-05-04 18:32:15.000000000 -0400
+++ ./hotspot/build/bsd/platform_sparc	2009-05-04 17:37:15.000000000 -0400
@@ -12,6 +12,6 @@ lib_arch = sparc
 
 compiler = gcc
 
-gnu_dis_arch = sparc
+sysdefs = -D_ALLBSD_SOURCE -D_GNU_SOURCE -DSPARC
 
 sysdefs = -DLINUX -D_GNU_SOURCE -DSPARC
diff -upr ../orig/hotspot/make/Makefile ./hotspot/make/Makefile
--- ../orig/hotspot/make/Makefile	2009-01-27 15:40:59.000000000 -0500
+++ ./hotspot/make/Makefile	2009-05-04 17:37:15.000000000 -0400
@@ -262,6 +262,19 @@ endif
 
 # Shared Library
 ifneq ($(OSNAME),windows)
+ifeq ($(OSNAME),bsd)
+# BSD-specific LIBRARY_SUFFIX build option
+$(EXPORT_JRE_LIB_ARCH_DIR)/%.$(LIBRARY_SUFFIX): $(C2_DIR)/%.$(LIBRARY_SUFFIX)
+	$(install-file)
+$(EXPORT_CLIENT_DIR)/%.$(LIBRARY_SUFFIX):       $(C1_DIR)/%.$(LIBRARY_SUFFIX)
+	$(install-file)
+$(EXPORT_CLIENT_DIR)/64/%.$(LIBRARY_SUFFIX):    $(C1_DIR)/%.$(LIBRARY_SUFFIX)
+	$(install-file)
+$(EXPORT_SERVER_DIR)/%.$(LIBRARY_SUFFIX):       $(C2_DIR)/%.$(LIBRARY_SUFFIX)
+	$(install-file)
+$(EXPORT_SERVER_DIR)/64/%.$(LIBRARY_SUFFIX):    $(C2_DIR)/%.$(LIBRARY_SUFFIX)
+	$(install-file)
+else
 $(EXPORT_JRE_LIB_ARCH_DIR)/%.so: $(C2_DIR)/%.so
 	$(install-file)
 $(EXPORT_CLIENT_DIR)/%.so:       $(C1_DIR)/%.so
@@ -273,6 +286,7 @@ $(EXPORT_SERVER_DIR)/%.so:       $(C2_DI
 $(EXPORT_SERVER_DIR)/64/%.so:    $(C2_DIR)/%.so
 	$(install-file)
 endif
+endif
 
 # Jar file (sa-jdi.jar)
 $(EXPORT_LIB_DIR)/%.jar: $(GEN_DIR)/%.jar
diff -upr ../orig/hotspot/make/defs.make ./hotspot/make/defs.make
--- ../orig/hotspot/make/defs.make	2009-01-27 15:40:59.000000000 -0500
+++ ./hotspot/make/defs.make	2009-05-04 17:37:15.000000000 -0400
@@ -118,13 +118,23 @@ endif
 # Windows should have OS predefined
 ifeq ($(OS),)
   OS   := $(shell uname -s)
+  ifneq ($(findstring BSD,$(OS)),)
+    OS=bsd
+  endif
+  ifeq ($(OS), Darwin)
+    OS=bsd
+  endif
   HOST := $(shell uname -n)
 endif
 
-# If not SunOS and not Linux, assume Windows
+# If not SunOS, not Linux and not BSD, assume Windows
 ifneq ($(OS), Linux)
   ifneq ($(OS), SunOS)
-    OSNAME=windows
+    ifneq ($(OS), bsd)
+      OSNAME=windows
+    else
+      OSNAME=bsd
+    endif
   else
     OSNAME=solaris
   endif
diff -upr ../orig/hotspot/src/cpu/x86/vm/interpreterRT_x86_32.cpp ./hotspot/src/cpu/x86/vm/interpreterRT_x86_32.cpp
--- ../orig/hotspot/src/cpu/x86/vm/interpreterRT_x86_32.cpp	2009-01-27 15:41:00.000000000 -0500
+++ ./hotspot/src/cpu/x86/vm/interpreterRT_x86_32.cpp	2009-05-04 17:37:17.000000000 -0400
@@ -57,7 +57,7 @@ void InterpreterRuntime::SignatureHandle
   __ cmpl(Address(from(), Interpreter::local_offset_in_bytes(from_offset)), 0); // do not use temp() to avoid AGI
   Label L;
   __ jcc(Assembler::notZero, L);
-  __ movl(temp(), 0);
+  __ movl(temp(), NULL_WORD);
   __ bind(L);
   __ movl(Address(to(), to_offset * wordSize), temp());
 }
@@ -113,7 +113,7 @@ class SlowSignatureHandler: public Nativ
   virtual void pass_object() { 
     // pass address of from
     intptr_t from_addr = (intptr_t)(_from + Interpreter::local_offset_in_bytes(0));
-    *_to++ = (*(intptr_t*)from_addr == 0) ? NULL : from_addr;
+    *_to++ = (*(intptr_t*)from_addr == 0) ? NULL_WORD : from_addr;
     debug_only(verify_tag(frame::TagReference));
     _from -= Interpreter::stackElementSize();
    }
diff -upr ../orig/hotspot/src/cpu/x86/vm/jni_x86.h ./hotspot/src/cpu/x86/vm/jni_x86.h
--- ../orig/hotspot/src/cpu/x86/vm/jni_x86.h	2009-01-27 15:41:00.000000000 -0500
+++ ./hotspot/src/cpu/x86/vm/jni_x86.h	2009-05-04 17:37:15.000000000 -0400
@@ -29,7 +29,7 @@
 #ifndef _JAVASOFT_JNI_MD_H_
 #define _JAVASOFT_JNI_MD_H_
 
-#if defined(SOLARIS) || defined(LINUX)
+#if defined(SOLARIS) || defined(LINUX) || defined(_ALLBSD_SOURCE)
   #define JNIEXPORT
   #define JNIIMPORT
   #define JNICALL
diff -upr ../orig/hotspot/src/cpu/x86/vm/runtime_x86_32.cpp ./hotspot/src/cpu/x86/vm/runtime_x86_32.cpp
--- ../orig/hotspot/src/cpu/x86/vm/runtime_x86_32.cpp	2009-01-27 15:41:00.000000000 -0500
+++ ./hotspot/src/cpu/x86/vm/runtime_x86_32.cpp	2009-05-04 17:37:17.000000000 -0400
@@ -132,11 +132,11 @@ void OptoRuntime::generate_exception_blo
   // Get the exception pc in case we are deoptimized
   __ movl(rdx, Address(rcx, JavaThread::exception_pc_offset()));
 #ifdef ASSERT
-  __ movl(Address(rcx, JavaThread::exception_handler_pc_offset()), 0);
-  __ movl(Address(rcx, JavaThread::exception_pc_offset()), 0); 
+  __ movl(Address(rcx, JavaThread::exception_handler_pc_offset()), NULL_WORD);
+  __ movl(Address(rcx, JavaThread::exception_pc_offset()), NULL_WORD); 
 #endif
   // Clear the exception oop so GC no longer processes it as a root.
-  __ movl(Address(rcx, JavaThread::exception_oop_offset()), 0);
+  __ movl(Address(rcx, JavaThread::exception_oop_offset()), NULL_WORD);
 
   __ popl(rcx);
 
diff -upr ../orig/hotspot/src/cpu/x86/vm/stubGenerator_x86_64.cpp ./hotspot/src/cpu/x86/vm/stubGenerator_x86_64.cpp
--- ../orig/hotspot/src/cpu/x86/vm/stubGenerator_x86_64.cpp	2009-01-27 15:41:00.000000000 -0500
+++ ./hotspot/src/cpu/x86/vm/stubGenerator_x86_64.cpp	2009-05-05 16:01:30.000000000 -0400
@@ -472,7 +472,7 @@ class StubGenerator: public StubCodeGene
     // setup rax & rdx, remove return address & clear pending exception
     __ popq(rdx);
     __ movq(rax, Address(r15_thread, Thread::pending_exception_offset()));
-    __ movptr(Address(r15_thread, Thread::pending_exception_offset()), (int)NULL_WORD);
+    __ movptr(Address(r15_thread, Thread::pending_exception_offset()), (int32_t)NULL_WORD);
 
 #ifdef ASSERT
     // make sure exception is set
@@ -941,9 +941,9 @@ class StubGenerator: public StubCodeGene
     __ jcc(Assembler::zero, exit); // if obj is NULL it is OK
     // Check if the oop is in the right area of memory
     __ movq(c_rarg2, rax);
-    __ movptr(c_rarg3, (int64_t) Universe::verify_oop_mask());
+    __ movptr(c_rarg3, (intptr_t) Universe::verify_oop_mask());
     __ andq(c_rarg2, c_rarg3);
-    __ movptr(c_rarg3, (int64_t) Universe::verify_oop_bits());
+    __ movptr(c_rarg3, (intptr_t) Universe::verify_oop_bits());
     __ cmpq(c_rarg2, c_rarg3);
     __ jcc(Assembler::notZero, error);
 
@@ -953,9 +953,9 @@ class StubGenerator: public StubCodeGene
     __ jcc(Assembler::zero, error); // if klass is NULL it is broken
     // Check if the klass is in the right area of memory
     __ movq(c_rarg2, rax);
-    __ movptr(c_rarg3, (int64_t) Universe::verify_klass_mask());
+    __ movptr(c_rarg3, (intptr_t) Universe::verify_klass_mask());
     __ andq(c_rarg2, c_rarg3);
-    __ movptr(c_rarg3, (int64_t) Universe::verify_klass_bits());
+    __ movptr(c_rarg3, (intptr_t) Universe::verify_klass_bits());
     __ cmpq(c_rarg2, c_rarg3);
     __ jcc(Assembler::notZero, error);
 
@@ -964,9 +964,9 @@ class StubGenerator: public StubCodeGene
     __ testq(rax, rax);
     __ jcc(Assembler::zero, error); // if klass' klass is NULL it is broken
     // Check if the klass' klass is in the right area of memory
-    __ movptr(c_rarg3, (int64_t) Universe::verify_klass_mask());
+    __ movptr(c_rarg3, (intptr_t) Universe::verify_klass_mask());
     __ andq(rax, c_rarg3);
-    __ movptr(c_rarg3, (int64_t) Universe::verify_klass_bits());
+    __ movptr(c_rarg3, (intptr_t) Universe::verify_klass_bits());
     __ cmpq(rax, c_rarg3);
     __ jcc(Assembler::notZero, error);
 
diff -upr ../orig/hotspot/src/cpu/x86/vm/x86_32.ad ./hotspot/src/cpu/x86/vm/x86_32.ad
--- ../orig/hotspot/src/cpu/x86/vm/x86_32.ad	2009-01-27 15:41:00.000000000 -0500
+++ ./hotspot/src/cpu/x86/vm/x86_32.ad	2009-05-04 17:37:17.000000000 -0400
@@ -3364,7 +3364,7 @@ encode %{
          masm.movl  (Address(boxReg, 0), 3) ;            // results in ST-before-CAS penalty
          masm.get_thread (scrReg) ; 
          masm.movl  (boxReg, tmpReg);                    // consider: LEA box, [tmp-2] 
-         masm.movl  (tmpReg, 0);                         // consider: xor vs mov
+         masm.movl  (tmpReg, NULL_WORD);                         // consider: xor vs mov
          if (os::is_MP()) { masm.lock(); } 
          masm.cmpxchg (scrReg, Address(boxReg, ObjectMonitor::owner_offset_in_bytes()-2)) ; 
       } else 
@@ -3383,7 +3383,7 @@ encode %{
 
          if ((EmitSync & 64) == 0) { 
            // Optimistic form: consider XORL tmpReg,tmpReg
-           masm.movl  (tmpReg, 0 ) ; 
+           masm.movl  (tmpReg, NULL_WORD ) ; 
          } else { 
            // Can suffer RTS->RTO upgrades on shared or cold $ lines
            // Test-And-CAS instead of CAS
@@ -3589,7 +3589,7 @@ encode %{
          masm.orl   (boxReg, Address (tmpReg, ObjectMonitor::EntryList_offset_in_bytes()-2)) ; 
          masm.orl   (boxReg, Address (tmpReg, ObjectMonitor::cxq_offset_in_bytes()-2)) ; 
          masm.jccb  (Assembler::notZero, DONE_LABEL) ; 
-         masm.movl  (Address (tmpReg, ObjectMonitor::owner_offset_in_bytes()-2), 0) ; 
+         masm.movl  (Address (tmpReg, ObjectMonitor::owner_offset_in_bytes()-2), NULL_WORD) ; 
          masm.jmpb  (DONE_LABEL) ; 
       } else { 
          masm.xorl  (boxReg, Address (tmpReg, ObjectMonitor::owner_offset_in_bytes()-2)) ;  
@@ -3598,7 +3598,7 @@ encode %{
          masm.movl  (boxReg, Address (tmpReg, ObjectMonitor::EntryList_offset_in_bytes()-2)) ; 
          masm.orl   (boxReg, Address (tmpReg, ObjectMonitor::cxq_offset_in_bytes()-2)) ; 
          masm.jccb  (Assembler::notZero, CheckSucc) ; 
-         masm.movl  (Address (tmpReg, ObjectMonitor::owner_offset_in_bytes()-2), 0) ; 
+         masm.movl  (Address (tmpReg, ObjectMonitor::owner_offset_in_bytes()-2), NULL_WORD) ; 
          masm.jmpb  (DONE_LABEL) ; 
       }
 
@@ -3646,7 +3646,7 @@ encode %{
          // We currently use (3), although it's likely that switching to (2) 
          // is correct for the future.
             
-         masm.movl  (Address (tmpReg, ObjectMonitor::owner_offset_in_bytes()-2), 0) ; 
+         masm.movl  (Address (tmpReg, ObjectMonitor::owner_offset_in_bytes()-2), NULL_WORD) ; 
          if (os::is_MP()) { 
             if (VM_Version::supports_sse2() && 1 == FenceInstruction) { 
               masm.emit_raw (0x0F) ;    // MFENCE ...
diff -upr ../orig/hotspot/src/os/bsd/launcher/java_md.c ./hotspot/src/os/bsd/launcher/java_md.c
--- ../orig/hotspot/src/os/bsd/launcher/java_md.c	2009-05-04 18:32:15.000000000 -0400
+++ ./hotspot/src/os/bsd/launcher/java_md.c	2009-05-05 17:57:18.000000000 -0400
@@ -45,8 +45,15 @@
 #include "version_comp.h"
 #endif
 
+#ifdef __APPLE__
+#define JVM_DLL "libjvm.dylib"
+#define JAVA_DLL "libjava.dylib"
+#define LD_LIBRARY_PATH "DYLD_LIBRARY_PATH"
+#else
 #define JVM_DLL "libjvm.so"
 #define JAVA_DLL "libjava.so"
+#define LD_LIBRARY_PATH "LD_LIBRARY_PATH"
+#endif
 
 #ifndef GAMMA   /* launcher.make defines ARCH */
 
@@ -112,7 +119,7 @@ extern char **environ;
  *      A collection of useful strings. One should think of these as #define
  *      entries, but actual strings can be more efficient (with many compilers).
  */
-#ifdef __bsd__
+#ifdef _ALLBSD_SOURCE
 static const char *system_dir	= "/usr/java";
 static const char *user_dir	= "/java";
 #else /* Solaris */
@@ -456,10 +463,10 @@ CreateExecutionEnvironment(int *_argcp,
        * If not on Solaris, assume only a single LD_LIBRARY_PATH
        * variable.
        */
-      runpath = getenv("LD_LIBRARY_PATH");
+      runpath = getenv(LD_LIBRARY_PATH);
 #endif /* __sun */
 
-#ifdef __bsd
+#ifdef _ALLBSD_SOURCE
       /*
        * On bsd, if a binary is running as sgid or suid, glibc sets
        * LD_LIBRARY_PATH to the empty string for security purposes.  (In
@@ -836,7 +843,7 @@ GetXUsagePath(char *buf, jint bufsize)
 jboolean
 GetApplicationHome(char *buf, jint bufsize)
 {
-#ifdef __bsd__
+#ifdef _ALLBSD_SOURCE
     char *execname = GetExecname();
     if (execname) {
 	strncpy(buf, execname, bufsize-1);
@@ -1005,7 +1012,7 @@ SetExecname(char **argv)
 	    }
         }
     }
-#elif defined(__bsd__)
+#elif defined(__linux__)
     {
 	const char* self = "/proc/self/exe";
         char buf[PATH_MAX+1];
@@ -1015,7 +1022,7 @@ SetExecname(char **argv)
 	    exec_path = strdup(buf);
 	}
     }
-#else /* !__sun && !__bsd */
+#else /* !__sun && !__linux */
     {
         /* Not implemented */
     }
@@ -1220,7 +1227,7 @@ get_cpuid(uint32_t arg,
 
 #endif /* __sun && i586 */
 
-#if defined(__bsd__) && defined(i586)
+#if defined(_ALLBSD_SOURCE) && defined(i586)
 
 /*
  * A utility method for asking the CPU about itself.
@@ -1286,7 +1293,7 @@ get_cpuid(uint32_t arg,
 #endif
 }
 
-#endif /* __bsd__ && i586 */
+#endif /* _ALLBSD_SOURCE && i586 */
 
 #ifdef i586
 /* 
@@ -1465,7 +1472,7 @@ solaris_i586_ServerClassMachine(void) {
 
 #endif /* __sun && i586 */
 
-#if defined(__bsd__) && defined(i586)
+#if defined(_ALLBSD_SOURCE) && defined(i586)
 
 /* The definition of a server-class machine for bsd-i586 */
 jboolean
@@ -1496,7 +1503,7 @@ bsd_i586_ServerClassMachine(void) {
   return result;
 }
 
-#endif /* __bsd__ && i586 */
+#endif /* _ALLBSD_SOURCE && i586 */
 
 /* Dispatch to the platform-specific definition of "server-class" */
 jboolean
@@ -1506,7 +1513,7 @@ ServerClassMachine(void) {
   result = solaris_sparc_ServerClassMachine();
 #elif defined(__sun) && defined(i586)
   result = solaris_i586_ServerClassMachine();
-#elif defined(__bsd__) && defined(i586)
+#elif defined(_ALLBSD_SOURCE) && defined(i586)
   result = bsd_i586_ServerClassMachine();
 #else
   if (_launcher_debug) {
diff -upr ../orig/hotspot/src/os/bsd/vm/attachListener_bsd.cpp ./hotspot/src/os/bsd/vm/attachListener_bsd.cpp
--- ../orig/hotspot/src/os/bsd/vm/attachListener_bsd.cpp	2009-05-04 18:32:15.000000000 -0400
+++ ./hotspot/src/os/bsd/vm/attachListener_bsd.cpp	2009-05-05 17:58:29.000000000 -0400
@@ -333,6 +333,15 @@ BsdAttachOperation* BsdAttachListener::d
 
     // get the credentials of the peer and check the effective uid/guid
     // - check with jeff on this.
+#ifdef _ALLBSD_SOURCE
+    uid_t puid;
+    gid_t pgid;
+    if (::getpeereid(s, &puid, &pgid) != 0) {
+      int res;
+      RESTARTABLE(::close(s), res);
+      continue;
+    }
+#else
     struct ucred cred_info;
     socklen_t optlen = sizeof(cred_info);
     if (::getsockopt(s, SOL_SOCKET, SO_PEERCRED, (void*)&cred_info, &optlen) == -1) {
@@ -340,10 +349,13 @@ BsdAttachOperation* BsdAttachListener::d
       RESTARTABLE(::close(s), res);
       continue;
     }
+    uid_t puid = cred_info.uid;
+    gid_t pgid = cred_info.gid;
+#endif
     uid_t euid = geteuid();
     gid_t egid = getegid();
 
-    if (cred_info.uid != euid || cred_info.gid != egid) {
+    if (puid != euid || pgid != egid) {
       int res;
       RESTARTABLE(::close(s), res);
       continue;
@@ -466,11 +478,11 @@ bool AttachListener::is_init_trigger() {
   char fn[32];
   sprintf(fn, ".attach_pid%d", os::current_process_id());
   int ret;
-  struct stat64 st;
-  RESTARTABLE(::stat64(fn, &st), ret);
+  struct stat st;
+  RESTARTABLE(::stat(fn, &st), ret);
   if (ret == -1) {
     sprintf(fn, "/tmp/.attach_pid%d", os::current_process_id());
-    RESTARTABLE(::stat64(fn, &st), ret);
+    RESTARTABLE(::stat(fn, &st), ret);
   }
   if (ret == 0) {
     // simple check to avoid starting the attach mechanism when
Only in ./hotspot/src/os/bsd/vm: dtraceJSDT_bsd.cpp
diff -upr ../orig/hotspot/src/os/bsd/vm/hpi_bsd.cpp ./hotspot/src/os/bsd/vm/hpi_bsd.cpp
--- ../orig/hotspot/src/os/bsd/vm/hpi_bsd.cpp	2009-05-04 18:32:15.000000000 -0400
+++ ./hotspot/src/os/bsd/vm/hpi_bsd.cpp	2009-05-05 18:00:58.000000000 -0400
@@ -31,6 +31,14 @@
 # include <sys/param.h>
 # include <dlfcn.h>
 
+#ifdef __APPLE__
+#define HPI_LIB "libhpi.dylib"
+#define HPI_G_LIB "libhpi.dylib"
+#else
+#define HPI_LIB "libhpi.so"
+#define HPI_G_LIB "libhpi.so"
+#endif
+
 typedef jint (JNICALL *init_t)(GetInterfaceFunc *, void *);
 
 void hpi::initialize_get_interface(vm_calls_t *callbacks) {
@@ -48,11 +56,11 @@ void hpi::initialize_get_interface(vm_ca
       os::jvm_path(buf, JVM_MAXPATHLEN);
       
 #ifdef PRODUCT
-      const char * hpi_lib = "/libhpi.so";
+      const char * hpi_lib = "/" HPI_LIB;
 #else
       char * ptr = strrchr(buf, '/');
       assert(strstr(ptr, "/libjvm") == ptr, "invalid library name");
-      const char * hpi_lib = strstr(ptr, "_g") ? "/libhpi_g.so" : "/libhpi.so";
+      const char * hpi_lib = strstr(ptr, "_g") ? "/" HPI_G_LIB : "/" HPI_LIB;
 #endif
 
       *(strrchr(buf, '/')) = '\0';  /* get rid of /libjvm.so */
diff -upr ../orig/hotspot/src/os/bsd/vm/hpi_bsd.hpp ./hotspot/src/os/bsd/vm/hpi_bsd.hpp
--- ../orig/hotspot/src/os/bsd/vm/hpi_bsd.hpp	2009-05-04 18:32:15.000000000 -0400
+++ ./hotspot/src/os/bsd/vm/hpi_bsd.hpp	2009-05-05 18:12:24.000000000 -0400
@@ -39,26 +39,22 @@
 // HPI_FileInterface
 
 inline int hpi::close(int fd) {
-  return ::close(fd);
+  RESTARTABLE_RETURN_INT(::close(fd)); 
 }
 
 inline size_t hpi::read(int fd, void *buf, unsigned int nBytes) {
-  size_t res;
-  RESTARTABLE( (size_t) ::read(fd, buf, (size_t) nBytes), res);
-  return res;
+  INTERRUPTIBLE_RETURN_INT(::read(fd, buf, (size_t) nBytes), os::Bsd::clear_interrupted);
 }
 
 inline size_t hpi::write(int fd, const void *buf, unsigned int nBytes) {
-  size_t res;
-  RESTARTABLE((size_t) ::write(fd, buf, (size_t) nBytes), res);
-  return res;
+  INTERRUPTIBLE_RETURN_INT(::write(fd, buf, (size_t) nBytes), os::Bsd::clear_interrupted);
 }
 
 
 // HPI_SocketInterface
 
 inline int hpi::socket_close(int fd) {
-  return ::close(fd);
+  RESTARTABLE_RETURN_INT(::close(fd));
 }
 
 inline int hpi::socket(int domain, int type, int protocol) {
@@ -66,11 +62,11 @@ inline int hpi::socket(int domain, int t
 }
 
 inline int hpi::recv(int fd, char *buf, int nBytes, int flags) {
-  RESTARTABLE_RETURN_INT(::recv(fd, buf, nBytes, (unsigned int) flags));
+  INTERRUPTIBLE_RETURN_INT(::recv(fd, buf, nBytes, (unsigned int) flags), os::Bsd::clear_interrupted);
 }
 
 inline int hpi::send(int fd, char *buf, int nBytes, int flags) {
-  RESTARTABLE_RETURN_INT(::send(fd, buf, nBytes, (unsigned int) flags));
+  INTERRUPTIBLE_RETURN_INT(::send(fd, buf, nBytes, (unsigned int) flags), os::Bsd::clear_interrupted);
 }
 
 inline int hpi::timeout(int fd, long timeout) {
@@ -81,12 +77,13 @@ inline int hpi::timeout(int fd, long tim
   prevtime = ((julong)t.tv_sec * 1000)  +  t.tv_usec / 1000;
 
   for(;;) {
+    int res;
     struct pollfd pfd;
 
     pfd.fd = fd;
     pfd.events = POLLIN | POLLERR;
   
-    int res = ::poll(&pfd, 1, timeout);
+    INTERRUPTIBLE_NORESTART(::poll(&pfd, 1, timeout), res, os::Bsd::clear_interrupted);
 
     if (res == OS_ERR && errno == EINTR) {
 
@@ -110,7 +107,26 @@ inline int hpi::listen(int fd, int count
 }
 
 inline int hpi::connect(int fd, struct sockaddr *him, int len) {
-  RESTARTABLE_RETURN_INT(::connect(fd, him, len));
+  do {
+    int _result;
+    INTERRUPTIBLE_NORESTART(::connect(fd, him, len), _result,
+                           os::Bsd::clear_interrupted);
+
+    // Depending on when thread interruption is reset, _result could be
+    // one of two values when errno == EINTR
+
+    if (((_result == OS_INTRPT) || (_result == OS_ERR)) && (errno == EINTR)) {
+      /* restarting a connect() changes its errno semantics */
+      INTERRUPTIBLE(::connect(fd, him, len), _result,
+                     os::Bsd::clear_interrupted);
+      /* undo these changes */
+      if (_result == OS_ERR) {
+       if (errno == EALREADY) errno = EINPROGRESS; /* fall through */
+       else if (errno == EISCONN) { errno = 0; return OS_OK; }
+      }
+    }
+    return _result;
+  } while(false);
 }
 
 inline int hpi::accept(int fd, struct sockaddr *him, int *len) {
@@ -121,26 +137,33 @@ inline int hpi::accept(int fd, struct so
   // to 64 bits on some platform that we support.
   // Bsd doc says this can't return EINTR, unlike accept() on Solaris
 
-  return ::accept(fd, him, (socklen_t *)len);
+  if (fd < 0)
+    return OS_ERR;
+  INTERRUPTIBLE_RETURN_INT((int)::accept(fd, him, (socklen_t*) len), os::Bsd::clear_interrupted);
 }
 
 inline int hpi::recvfrom(int fd, char *buf, int nBytes, int flags,
 		         sockaddr *from, int *fromlen) {
-  RESTARTABLE_RETURN_INT(::recvfrom(fd, buf, nBytes, (unsigned int) flags, from, (socklen_t *)fromlen));
+  INTERRUPTIBLE_RETURN_INT((int)::recvfrom(fd, buf, nBytes, (unsigned int) flags, from, (socklen_t *)fromlen), os::Bsd::clear_interrupted);
 }
 
 inline int hpi::sendto(int fd, char *buf, int len, int flags,
 			struct sockaddr *to, int tolen) {
-  RESTARTABLE_RETURN_INT(::sendto(fd, buf, len, (unsigned int) flags, to, tolen));
+  INTERRUPTIBLE_RETURN_INT((int)::sendto(fd, buf, len, (unsigned int) flags, to, tolen),os::Bsd::clear_interrupted);
 }
 
 inline int hpi::socket_available(int fd, jint *pbytes) {
   // Bsd doc says EINTR not returned, unlike Solaris
-  int ret = ::ioctl(fd, FIONREAD, pbytes);
+  int ret;
+
+  if (fd < 0)
+    return OS_OK;
+
+  RESTARTABLE(::ioctl(fd, FIONREAD, pbytes), ret);
 
   //%% note ioctl can return 0 when successful, JVM_SocketAvailable
   // is expected to return 0 on failure and 1 on success to the jdk.
-  return (ret < 0) ? 0 : 1;
+  return (ret == OS_ERR) ? 0 : 1;
 }
 
 
@@ -167,7 +190,7 @@ HPIDECL(bind, "bind", _socket, Bind, 
         (fd, him, len));
 */
 inline int hpi::bind(int fd, struct sockaddr *him, int len){
-  return ::bind(fd, him, len);
+  INTERRUPTIBLE_RETURN_INT_NORESTART(::bind(fd, him, len),os::Bsd::clear_interrupted);
 }
 
 /*
diff -upr ../orig/hotspot/src/os/bsd/vm/jsig.c ./hotspot/src/os/bsd/vm/jsig.c
--- ../orig/hotspot/src/os/bsd/vm/jsig.c	2009-05-04 18:32:15.000000000 -0400
+++ ./hotspot/src/os/bsd/vm/jsig.c	2009-05-04 17:37:15.000000000 -0400
@@ -146,7 +146,8 @@ sa_handler_t signal(int sig, sa_handler_
 }
 
 sa_handler_t sigset(int sig, sa_handler_t disp) {
-  return set_signal(sig, disp, true);
+  printf("sigset() is not supported by BSD");
+  exit(0);
  }
 
 static int call_os_sigaction(int sig, const struct sigaction  *act,
diff -upr ../orig/hotspot/src/os/bsd/vm/jvm_bsd.cpp ./hotspot/src/os/bsd/vm/jvm_bsd.cpp
--- ../orig/hotspot/src/os/bsd/vm/jvm_bsd.cpp	2009-05-04 18:32:15.000000000 -0400
+++ ./hotspot/src/os/bsd/vm/jvm_bsd.cpp	2009-05-05 18:16:36.000000000 -0400
@@ -141,44 +141,37 @@ struct siglabel {
 
 struct siglabel siglabels[] = {
   /* derived from /usr/include/bits/signum.h on RH7.2 */
-   "HUP",	SIGHUP,		/* Hangup (POSIX).  */
+  "HUP",	SIGHUP,		/* Hangup (POSIX).  */
   "INT",	SIGINT,		/* Interrupt (ANSI).  */
   "QUIT",	SIGQUIT,	/* Quit (POSIX).  */
   "ILL",	SIGILL,		/* Illegal instruction (ANSI).  */
   "TRAP",	SIGTRAP,	/* Trace trap (POSIX).  */
   "ABRT",	SIGABRT,	/* Abort (ANSI).  */
-  "IOT",	SIGIOT,		/* IOT trap (4.2 BSD).  */
-  "BUS",	SIGBUS,		/* BUS error (4.2 BSD).  */
+  "EMT",	SIGEMT,		/* EMT trap  */
   "FPE",	SIGFPE,		/* Floating-point exception (ANSI).  */
   "KILL",	SIGKILL,	/* Kill, unblockable (POSIX).  */
-  "USR1",	SIGUSR1,	/* User-defined signal 1 (POSIX).  */
+  "BUS",	SIGBUS,		/* BUS error (4.2 BSD).  */
   "SEGV",	SIGSEGV,	/* Segmentation violation (ANSI).  */
-  "USR2",	SIGUSR2,	/* User-defined signal 2 (POSIX).  */
+  "SYS",	SIGSYS,		/* Bad system call. Only on some Bsden! */
   "PIPE",	SIGPIPE,	/* Broken pipe (POSIX).  */
   "ALRM",	SIGALRM,	/* Alarm clock (POSIX).  */
   "TERM",	SIGTERM,	/* Termination (ANSI).  */
-#ifdef SIGSTKFLT
-  "STKFLT",	SIGSTKFLT,	/* Stack fault.  */
-#endif
-  "CLD",	SIGCLD,		/* Same as SIGCHLD (System V).  */
-  "CHLD",	SIGCHLD,	/* Child status has changed (POSIX).  */
-  "CONT",	SIGCONT,	/* Continue (POSIX).  */
+  "URG",	SIGURG,		/* Urgent condition on socket (4.2 BSD).  */
   "STOP",	SIGSTOP,	/* Stop, unblockable (POSIX).  */
   "TSTP",	SIGTSTP,	/* Keyboard stop (POSIX).  */
+  "CONT",	SIGCONT,	/* Continue (POSIX).  */
+  "CHLD",	SIGCHLD,	/* Child status has changed (POSIX).  */
   "TTIN",	SIGTTIN,	/* Background read from tty (POSIX).  */
   "TTOU",	SIGTTOU,	/* Background write to tty (POSIX).  */
-  "URG",	SIGURG,		/* Urgent condition on socket (4.2 BSD).  */
+  "IO",		SIGIO,		/* I/O now possible (4.2 BSD).  */
   "XCPU",	SIGXCPU,	/* CPU limit exceeded (4.2 BSD).  */
   "XFSZ",	SIGXFSZ,	/* File size limit exceeded (4.2 BSD).  */
   "VTALRM",	SIGVTALRM,	/* Virtual alarm clock (4.2 BSD).  */
   "PROF",	SIGPROF,	/* Profiling alarm clock (4.2 BSD).  */
   "WINCH",	SIGWINCH,	/* Window size change (4.3 BSD, Sun).  */
-  "POLL",	SIGPOLL,	/* Pollable event occurred (System V).  */
-  "IO",		SIGIO,		/* I/O now possible (4.2 BSD).  */
-  "PWR",	SIGPWR,		/* Power failure restart (System V).  */
-#ifdef SIGSYS
-  "SYS",	SIGSYS		/* Bad system call. Only on some Bsden! */
-#endif
+  "INFO",	SIGINFO,	/* Information request.  */
+  "USR1",	SIGUSR1,	/* User-defined signal 1 (POSIX).  */
+  "USR2",	SIGUSR2		/* User-defined signal 2 (POSIX).  */
   };
 
 JVM_ENTRY_NO_ENV(jint, JVM_FindSignal(const char *name))
diff -upr ../orig/hotspot/src/os/bsd/vm/jvm_bsd.h ./hotspot/src/os/bsd/vm/jvm_bsd.h
--- ../orig/hotspot/src/os/bsd/vm/jvm_bsd.h	2009-05-04 18:32:15.000000000 -0400
+++ ./hotspot/src/os/bsd/vm/jvm_bsd.h	2009-05-05 18:16:44.000000000 -0400
@@ -54,7 +54,11 @@
 #define AGENT_ONATTACH_SYMBOLS  {"Agent_OnAttach"}
 
 #define JNI_LIB_PREFIX "lib"
+#ifdef __APPLE__
+#define JNI_LIB_SUFFIX ".dylib"
+#else
 #define JNI_LIB_SUFFIX ".so"
+#endif
 
 // Hack: MAXPATHLEN is 4095 on some Bsd and 4096 on others. This may
 //       cause problems if JVM and the rest of JDK are built on different
@@ -93,6 +97,20 @@
 #define SHUTDOWN2_SIGNAL SIGINT
 #define SHUTDOWN3_SIGNAL SIGTERM
 
+#ifndef SIGRTMIN
+#ifdef __OpenBSD__
+#define SIGRTMIN	1
+#else
+#define SIGRTMIN	33
+#endif
+#endif
+#ifndef SIGRTMAX
+#ifdef __OpenBSD__
+#define SIGRTMAX	31
+#else
+#define SIGRTMAX	63
+#endif
+#endif
 #endif /* JVM_MD_H */
 
 // Reconciliation History
diff -upr ../orig/hotspot/src/os/bsd/vm/osThread_bsd.cpp ./hotspot/src/os/bsd/vm/osThread_bsd.cpp
--- ../orig/hotspot/src/os/bsd/vm/osThread_bsd.cpp	2009-05-04 18:32:15.000000000 -0400
+++ ./hotspot/src/os/bsd/vm/osThread_bsd.cpp	2009-05-05 18:19:09.000000000 -0400
@@ -31,8 +31,8 @@
 
 void OSThread::pd_initialize() {
   assert(this != NULL, "check");
-  _thread_id        = 0;
-  _pthread_id       = 0;
+  _thread_id        = NULL;
+  _pthread_id       = NULL;
   _siginfo = NULL;
   _ucontext = NULL;
   _expanding_stack = 0;
diff -upr ../orig/hotspot/src/os/bsd/vm/osThread_bsd.hpp ./hotspot/src/os/bsd/vm/osThread_bsd.hpp
--- ../orig/hotspot/src/os/bsd/vm/osThread_bsd.hpp	2009-05-04 18:32:15.000000000 -0400
+++ ./hotspot/src/os/bsd/vm/osThread_bsd.hpp	2009-05-05 20:37:04.000000000 -0400
@@ -39,6 +39,12 @@
 
  private:
 
+#ifdef _ALLBSD_SOURCE
+  // _thread_id and _pthread_id are the same on BSD
+  // keep both to minimize code divergence in os_bsd.cpp
+  pthread_t _thread_id;
+  pthread_t _pthread_id;
+#else
   // _thread_id is kernel thread id (similar to LWP id on Solaris). Each
   // thread has a unique thread_id (BsdThreads or NPTL). It can be used
   // to access /proc.
@@ -47,6 +53,7 @@
   // _pthread_id is the pthread id, which is used by library calls
   // (e.g. pthread_kill).
   pthread_t _pthread_id;
+#endif
 
   sigset_t _caller_sigmask; // Caller's signal mask
 
@@ -56,12 +63,18 @@
   sigset_t  caller_sigmask() const       { return _caller_sigmask; }
   void    set_caller_sigmask(sigset_t sigmask)  { _caller_sigmask = sigmask; }
 
+#ifdef _ALLBSD_SOURCE
+  pthread_t thread_id() const {
+    return _thread_id;
+  }
+#else
   pid_t thread_id() const {
     return _thread_id;
   }
+#endif
 #ifndef PRODUCT
   // Used for debugging, return a unique integer for each thread.
-  int thread_identifier() const   { return _thread_id; }
+  intptr_t thread_identifier() const   { return (intptr_t)_pthread_id; }
 #endif
 #ifdef ASSERT
   // We expect no reposition failures so kill vm if we get one.
@@ -70,9 +83,15 @@
     return false;
   }
 #endif // ASSERT
+#ifdef _ALLBSD_SOURCE
+  void set_thread_id(pthread_t id) {
+    _thread_id = id;
+  }
+#else
   void set_thread_id(pid_t id) {
     _thread_id = id;
   }
+#endif
   pthread_t pthread_id() const {
     return _pthread_id;
   }
@@ -123,6 +142,9 @@ public:
 
 private:
   Monitor* _startThread_lock;     // sync parent and child in thread creation
+#ifdef _ALLBSD_SOURCE
+  JavaThreadState      _saved_interrupt_thread_state;       // the thread state before a system call -- restored afterward
+#endif
 
 public:
 
@@ -130,6 +152,11 @@ public:
     return _startThread_lock;
   }
 
+#ifdef _ALLBSD_SOURCE
+  JavaThreadState   saved_interrupt_thread_state()                              { return _saved_interrupt_thread_state; }
+  void              set_saved_interrupt_thread_state(JavaThreadState state)     { _saved_interrupt_thread_state = state; }
+#endif
+
   // ***************************************************************
   // Platform dependent initialization and cleanup
   // ***************************************************************
diff -upr ../orig/hotspot/src/os/bsd/vm/os_bsd.cpp ./hotspot/src/os/bsd/vm/os_bsd.cpp
--- ../orig/hotspot/src/os/bsd/vm/os_bsd.cpp	2009-05-04 18:32:15.000000000 -0400
+++ ./hotspot/src/os/bsd/vm/os_bsd.cpp	2009-05-04 17:37:17.000000000 -0400
@@ -50,12 +50,33 @@
 # include <semaphore.h>
 # include <fcntl.h>
 # include <string.h>
+#ifdef _ALLBSD_SOURCE
+# include <sys/param.h>
+# include <sys/sysctl.h>
+#else
 # include <syscall.h>
 # include <sys/sysinfo.h>
 # include <gnu/libc-version.h>
+#endif
 # include <sys/ipc.h>
 # include <sys/shm.h>
+
+#ifndef __APPLE__
 # include <link.h>
+#endif
+
+#if defined(__FreeBSD__)
+# include <elf.h>
+#endif
+
+#ifdef __APPLE__
+#include <mach/mach.h> // semaphore_* API
+#include <mach-o/dyld.h>
+#endif
+
+#ifndef MAP_ANONYMOUS
+#define MAP_ANONYMOUS MAP_ANON
+#endif
 
 #define MAX_PATH    (2 * K)
 
@@ -67,19 +88,25 @@
 // global variables
 julong os::Bsd::_physical_memory = 0;
 
+#ifndef _ALLBSD_SOURCE
 address   os::Bsd::_initial_thread_stack_bottom = NULL;
 uintptr_t os::Bsd::_initial_thread_stack_size   = 0;
+#endif
 
 int (*os::Bsd::_clock_gettime)(clockid_t, struct timespec *) = NULL;
+#ifndef _ALLBSD_SOURCE
 int (*os::Bsd::_pthread_getcpuclockid)(pthread_t, clockid_t *) = NULL;
 Mutex* os::Bsd::_createThread_lock = NULL;
+#endif
 pthread_t os::Bsd::_main_thread;
 int os::Bsd::_page_size = -1;
+#ifndef _ALLBSD_SOURCE
 bool os::Bsd::_is_floating_stack = false;
 bool os::Bsd::_is_NPTL = false;
 bool os::Bsd::_supports_fast_thread_cpu_time = false;
 const char * os::Bsd::_glibc_version = NULL;
 const char * os::Bsd::_libpthread_version = NULL;
+#endif
 
 static jlong initial_time_count=0;
 
@@ -97,6 +124,77 @@ static pid_t _initial_pid = 0;
 static int SR_signum = SIGUSR2;
 sigset_t SR_sigset;
 
+#ifdef _ALLBSD_SOURCE
+// XXXBSD: ported from solaris version
+// interruptible infrastructure
+
+// setup_interruptible saves the thread state before going into an
+// interruptible system call.  
+// The saved state is used to restore the thread to
+// its former state whether or not an interrupt is received.  
+// Used by classloader os::read 
+// hpi calls skip this layer and stay in _thread_in_native
+
+void os::Bsd::setup_interruptible(JavaThread* thread) {
+ 
+  JavaThreadState thread_state = thread->thread_state();
+
+  assert(thread_state != _thread_blocked, "Coming from the wrong thread");
+  assert(thread_state != _thread_in_native, "Native threads skip setup_interruptible");
+  OSThread* osthread = thread->osthread();
+  osthread->set_saved_interrupt_thread_state(thread_state);
+  thread->frame_anchor()->make_walkable(thread);
+  ThreadStateTransition::transition(thread, thread_state, _thread_blocked);
+}
+
+// Version of setup_interruptible() for threads that are already in
+// _thread_blocked. Used by os_sleep().
+void os::Bsd::setup_interruptible_already_blocked(JavaThread* thread) {
+  thread->frame_anchor()->make_walkable(thread);
+}
+
+JavaThread* os::Bsd::setup_interruptible() {
+  JavaThread* thread = (JavaThread*)ThreadLocalStorage::thread();
+  setup_interruptible(thread);
+  return thread;
+}
+
+#ifdef ASSERT
+
+JavaThread* os::Bsd::setup_interruptible_native() {
+  JavaThread* thread = (JavaThread*)ThreadLocalStorage::thread();
+  JavaThreadState thread_state = thread->thread_state();
+  assert(thread_state == _thread_in_native, "Assumed thread_in_native");
+  return thread;
+}
+
+void os::Bsd::cleanup_interruptible_native(JavaThread* thread) {
+  JavaThreadState thread_state = thread->thread_state();
+  assert(thread_state == _thread_in_native, "Assumed thread_in_native");
+}
+#endif
+
+// cleanup_interruptible reverses the effects of setup_interruptible
+// setup_interruptible_already_blocked() does not need any cleanup.
+
+void os::Bsd::cleanup_interruptible(JavaThread* thread) {
+  OSThread* osthread = thread->osthread();
+
+  ThreadStateTransition::transition(thread, _thread_blocked, osthread->saved_interrupt_thread_state());
+}
+
+// I/O interruption related counters called in _INTERRUPTIBLE
+
+void os::Bsd::bump_interrupted_before_count() {
+  RuntimeService::record_interrupted_before_count();
+}
+
+void os::Bsd::bump_interrupted_during_count() {
+  RuntimeService::record_interrupted_during_count();
+}
+#endif
+
+
 ////////////////////////////////////////////////////////////////////////////////
 // utility functions
 
@@ -108,11 +206,17 @@ julong os::available_memory() {
 }
 
 julong os::Bsd::available_memory() {
+#ifdef _ALLBSD_SOURCE
+  // XXXBSD: this is just a stopgap implementation
+  return physical_memory() >> 2;
+#else
+
   // values in struct sysinfo are "unsigned long"
   struct sysinfo si;
   sysinfo(&si);
   
   return (julong)si.freeram * si.mem_unit;
+#endif
 }
 
 julong os::physical_memory() {
@@ -160,6 +264,7 @@ bool os::have_special_privileges() {
 }
 
 
+#ifndef _ALLBSD_SOURCE
 #ifndef SYS_gettid
 // i386: 224, ia64: 1105, amd64: 186, sparc 143
 #ifdef __ia64__
@@ -174,6 +279,7 @@ bool os::have_special_privileges() {
 #error define gettid for the arch
 #endif
 #endif
+#endif
 
 // Cpu architecture string
 #if   defined(IA64)
@@ -193,6 +299,7 @@ static char cpu_arch[] = "sparc";
 #endif
 
 
+#ifndef _ALLBSD_SOURCE
 // pid_t gettid()
 //
 // Returns the kernel thread id of the currently running thread. Kernel
@@ -219,7 +326,47 @@ static bool unsafe_chroot_detected = fal
 static const char *unstable_chroot_error = "/proc file system not found.\n"
                     "Java may be unstable running multithreaded in a chroot "
                     "environment on Bsd when /proc filesystem is not mounted.";
+#endif
 
+#ifdef _ALLBSD_SOURCE
+void os::Bsd::initialize_system_info() {
+  int mib[2];
+  size_t len;
+  int cpu_val;
+  u_long mem_val;
+
+  /* get processors count via hw.ncpus sysctl */
+  mib[0] = CTL_HW;
+  mib[1] = HW_NCPU;
+  len = sizeof(cpu_val);
+  if (sysctl(mib, 2, &cpu_val, &len, NULL, 0) != -1)
+        _processor_count = cpu_val;
+
+  if (_processor_count < 1)
+       _processor_count = 1;   // fallback
+
+  /* get physical memory via hw.usermem sysctl (hw.usermem is used
+   * instead of hw.physmem because we need size of allocatable memory
+   */
+  mib[0] = CTL_HW;
+  mib[1] = HW_USERMEM;
+  len = sizeof(mem_val);
+  if (sysctl(mib, 2, &mem_val, &len, NULL, 0) != -1)
+       _physical_memory = mem_val;
+  else
+       _physical_memory = 256*1024*1024;       // fallback (XXXBSD?)
+
+#ifdef __OpenBSD__
+  {
+       // limit _physical_memory memory view on OpenBSD since
+       // datasize rlimit restricts us anyway.
+       struct rlimit limits;
+       getrlimit(RLIMIT_DATA, &limits);
+       _physical_memory = MIN2(_physical_memory, (julong)limits.rlim_cur);
+  }
+#endif
+}
+#else
 void os::Bsd::initialize_system_info() {
   _processor_count = sysconf(_SC_NPROCESSORS_CONF);
   if (_processor_count == 1) {
@@ -236,6 +383,7 @@ void os::Bsd::initialize_system_info() {
   _physical_memory = (julong)sysconf(_SC_PHYS_PAGES) * (julong)sysconf(_SC_PAGESIZE);
   assert(_processor_count > 0, "bsd error");
 }
+#endif
 
 void os::init_system_properties_values() {
 //  char arch[12];
@@ -356,7 +504,12 @@ void os::init_system_properties_values()
 	 * should always exist (until the legacy problem cited above is
 	 * addressed).
 	 */
+#ifdef __APPLE__
+   char *v = getenv("DYLD_LIBRARY_PATH");
+#else
 	char *v = getenv("LD_LIBRARY_PATH");
+#endif
+          
 	if (v != NULL) {
 	    char *t = ld_library_path;
 	    /* That's +1 for the colon and +1 for the trailing '\0' */
@@ -515,6 +668,7 @@ void os::Bsd::hotspot_sigmask(Thread* th
   }
 }
 
+#ifndef _ALLBSD_SOURCE
 //////////////////////////////////////////////////////////////////////////////
 // detecting pthread library
 
@@ -679,6 +833,7 @@ bool os::Bsd::manually_expand_stack(Java
   }
   return false;
 }
+#endif
 
 //////////////////////////////////////////////////////////////////////////////
 // create new thread
@@ -687,6 +842,9 @@ static address highest_vm_reserved_addre
 
 // check if it's safe to start a new thread
 static bool _thread_safety_check(Thread* thread) {
+#ifdef _ALLBSD_SOURCE
+  return true;
+#else
   if (os::Bsd::is_BsdThreads() && !os::Bsd::is_floating_stack()) {
     // Fixed stack BsdThreads (SuSE Bsd/x86, and some versions of Redhat)
     //   Heap is mmap'ed at lower end of memory space. Thread stacks are
@@ -720,6 +878,7 @@ static bool _thread_safety_check(Thread*
     //   here, that means enough space has been reserved for stack.
     return true;
   }
+#endif
 }
 
 // Thread start routine for all newly created threads
@@ -747,6 +906,10 @@ static void *java_start(Thread *thread) 
     return NULL;
   }
 
+#ifdef _ALLBSD_SOURCE
+  // thread_id is pthread_id on BSD
+  osthread->set_thread_id(::pthread_self());
+#else
   // thread_id is kernel thread id (similar to Solaris LWP id)
   osthread->set_thread_id(os::Bsd::gettid());
 
@@ -756,6 +919,7 @@ static void *java_start(Thread *thread) 
       thread->set_lgrp_id(lgrp_id);
     }
   }
+#endif
   // initialize signal mask for this thread
   os::Bsd::hotspot_sigmask(thread);
 
@@ -836,17 +1000,22 @@ bool os::create_thread(Thread* thread, T
     // let pthread_create() pick the default value.
   }
 
+#ifndef _ALLBSD_SOURCE
   // glibc guard page
   pthread_attr_setguardsize(&attr, os::Bsd::default_guard_size(thr_type));
+#endif
 
   ThreadState state;
 
   {
+
+#ifndef _ALLBSD_SOURCE
     // Serialize thread creation if we are running with fixed stack BsdThreads
     bool lock = os::Bsd::is_BsdThreads() && !os::Bsd::is_floating_stack();
     if (lock) {
       os::Bsd::createThread_lock()->lock_without_safepoint_check();
     }
+#endif
 
     pthread_t tid;
     int ret = pthread_create(&tid, &attr, (void* (*)(void*)) java_start, thread);
@@ -860,7 +1029,9 @@ bool os::create_thread(Thread* thread, T
       // Need to clean up stuff we've allocated so far
       thread->set_osthread(NULL);
       delete osthread;
+#ifndef _ALLBSD_SOURCE
       if (lock) os::Bsd::createThread_lock()->unlock();
+#endif
       return false;
     }
 
@@ -876,9 +1047,11 @@ bool os::create_thread(Thread* thread, T
       }
     }
 
+#ifndef _ALLBSD_SOURCE
     if (lock) {
       os::Bsd::createThread_lock()->unlock();
     }
+#endif
   }
 
   // Aborted due to thread limit being reached
@@ -916,7 +1089,11 @@ bool os::create_attached_thread(JavaThre
   }
 
   // Store pthread info into the OSThread
+#ifdef _ALLBSD_SOURCE
+  osthread->set_thread_id(::pthread_self());
+#else
   osthread->set_thread_id(os::Bsd::gettid());
+#endif
   osthread->set_pthread_id(::pthread_self());
 
   // initialize floating point control register
@@ -927,6 +1104,7 @@ bool os::create_attached_thread(JavaThre
 
   thread->set_osthread(osthread);
 
+#ifndef _ALLBSD_SOURCE
   if (UseNUMA) {
     int lgrp_id = os::numa_get_group_id();
     if (lgrp_id != -1) {
@@ -953,6 +1131,7 @@ bool os::create_attached_thread(JavaThre
     os::Bsd::manually_expand_stack(jt, addr);
     osthread->clear_expanding_stack();
   }
+#endif
 
   // initialize signal mask for this thread
   // and save the caller's signal mask
@@ -1011,6 +1190,7 @@ extern "C" Thread* get_thread() {
 //////////////////////////////////////////////////////////////////////////////
 // initial thread
 
+#ifndef _ALLBSD_SOURCE
 // Check if current thread is the initial thread, similar to Solaris thr_main.
 bool os::Bsd::is_initial_thread(void) {
   char dummy;
@@ -1241,6 +1421,7 @@ void os::Bsd::capture_initial_stack(size
   _initial_thread_stack_size = align_size_down(_initial_thread_stack_size, page_size());
   _initial_thread_stack_bottom = (address)stack_top - _initial_thread_stack_size;
 }
+#endif
 
 ////////////////////////////////////////////////////////////////////////////////
 // time support
@@ -1279,6 +1460,21 @@ jlong os::javaTimeMillis() {
 #define CLOCK_MONOTONIC (1)
 #endif
 
+#ifdef __APPLE__
+void os::Bsd::clock_init() {
+	// XXXDARWIN: Investigate replacement monotonic clock
+}
+#elif defined(_ALLBSD_SOURCE)
+void os::Bsd::clock_init() {
+  struct timespec res;
+  struct timespec tp;
+  if (::clock_getres(CLOCK_MONOTONIC, &res) == 0 &&
+      ::clock_gettime(CLOCK_MONOTONIC, &tp)  == 0) {
+    // yes, monotonic clock is supported
+    _clock_gettime = ::clock_gettime;
+  }
+}
+#else
 void os::Bsd::clock_init() {
   // we do dlopen's in this particular order due to bug in bsd
   // dynamical loader (see 6348968) leading to crash on exit
@@ -1314,7 +1510,9 @@ void os::Bsd::clock_init() {
     }
   }
 }
+#endif
 
+#ifndef _ALLBSD_SOURCE
 #ifndef SYS_clock_getres
 
 #if defined(IA32) || defined(AMD64)
@@ -1353,6 +1551,7 @@ void os::Bsd::fast_thread_clock_init() {
     _pthread_getcpuclockid = pthread_getcpuclockid_func;
   }
 }
+#endif
 
 jlong os::javaTimeNanos() {
   if (Bsd::supports_monotonic_clock()) {
@@ -1499,7 +1698,14 @@ int os::current_process_id() {
 
 // DLL functions
 
-const char* os::dll_file_extension() { return ".so"; }
+#define JNI_LIB_PREFIX "lib"
+#ifdef __APPLE__
+#define JNI_LIB_SUFFIX ".dylib"
+#else
+#define JNI_LIB_SUFFIX ".so"
+#endif
+
+const char* os::dll_file_extension() { return JNI_LIB_SUFFIX; }
 
 const char* os::get_temp_directory() { return "/tmp/"; }
 
@@ -1540,6 +1746,23 @@ bool os::dll_address_to_function_name(ad
   }
 }
 
+#ifdef _ALLBSD_SOURCE
+// ported from solaris version
+bool os::dll_address_to_library_name(address addr, char* buf,
+                                     int buflen, int* offset) {
+  Dl_info dlinfo;
+
+  if (dladdr((void*)addr, &dlinfo)){
+     if (buf) jio_snprintf(buf, buflen, "%s", dlinfo.dli_fname);
+     if (offset) *offset = addr - (address)dlinfo.dli_fbase;
+     return true;
+  } else {
+     if (buf) buf[0] = '\0';
+     if (offset) *offset = -1;
+     return false;
+  }
+}
+#else
 struct _address_to_library_name {
   address addr;          // input : memory address
   size_t  buflen;        //         size of fname
@@ -1614,11 +1837,27 @@ bool os::dll_address_to_library_name(add
      return false;
   }
 }
+#endif
 
   // Loads .dll/.so and 
   // in case of error it checks if .dll/.so was built for the
   // same architecture as Hotspot is running on
+ 
+#ifdef __APPLE__
+void * os::dll_load(const char *filename, char *ebuf, int ebuflen) {
+  void * result= ::dlopen(filename, RTLD_LAZY);
+  if (result != NULL) {
+    // Successful loading
+    return result;
+  }
 
+  // Read system error message into ebuf
+  ::strncpy(ebuf, ::dlerror(), ebuflen-1);
+  ebuf[ebuflen-1]='\0';
+
+  return NULL;
+}
+#else
 void * os::dll_load(const char *filename, char *ebuf, int ebuflen)
 {
   void * result= ::dlopen(filename, RTLD_LAZY);
@@ -1671,6 +1910,20 @@ void * os::dll_load(const char *filename
   #define EM_486          6               /* Intel 80486 */
   #endif
 
+  #ifndef EM_PPC64
+  #define EM_PPC64        21              /* PowerPC64 */
+  #endif
+
+  #ifndef EM_IA_64
+  #define EM_IA_64        50              /* HP/Intel IA-64 */ 
+  #endif
+
+  #ifndef EM_X86_64
+  #define EM_X86_64       62              /* AMD x86-64 */ 
+  #endif
+
+
+
   static const arch_t arch_array[]={ 
     {EM_386,         EM_386,     ELFCLASS32, ELFDATA2LSB, (char*)"IA 32"},
     {EM_486,         EM_386,     ELFCLASS32, ELFDATA2LSB, (char*)"IA 32"},
@@ -1751,7 +2004,7 @@ void * os::dll_load(const char *filename
 
   return NULL;
 }
-
+#endif /* !__APPLE__  */
 
 
 
@@ -1774,7 +2027,51 @@ bool _print_ascii_file(const char* filen
 
 void os::print_dll_info(outputStream *st) {
    st->print_cr("Dynamic libraries:");
-
+#ifdef _ALLBSD_SOURCE
+#ifdef RTLD_DI_LINKMAP
+    Dl_info dli;
+    void *handle;
+    Link_map *map;
+    Link_map *p;
+
+    if (!dladdr(CAST_FROM_FN_PTR(void *, os::print_dll_info), &dli)) {
+        st->print_cr("Error: Cannot print dynamic libraries.");
+        return;
+    }
+    handle = dlopen(dli.dli_fname, RTLD_LAZY);
+    if (handle == NULL) {
+        st->print_cr("Error: Cannot print dynamic libraries.");
+        return;
+    }
+    dlinfo(handle, RTLD_DI_LINKMAP, &map);
+    if (map == NULL) {
+        st->print_cr("Error: Cannot print dynamic libraries.");
+        return;
+    }
+
+    while (map->l_prev != NULL)
+        map = map->l_prev;
+
+    while (map != NULL) {
+        st->print_cr(PTR_FORMAT " \t%s", map->l_addr, map->l_name);
+        map = map->l_next;
+    }
+
+    dlclose(handle);
+#elif defined(__APPLE__)
+    uint32_t count;
+    uint32_t i;
+
+    count = _dyld_image_count();
+    for (i = 1; i < count; i++) {
+        const char *name = _dyld_get_image_name(i);
+        intptr_t slide = _dyld_get_image_vmaddr_slide(i);
+        st->print_cr(PTR_FORMAT " \t%s", slide, name);
+    }
+#else
+   st->print_cr("Error: Cannot print dynamic libraries.");
+#endif
+#else
    char fname[32];
    pid_t pid = os::Bsd::gettid();
 
@@ -1783,6 +2080,7 @@ void os::print_dll_info(outputStream *st
    if (!_print_ascii_file(fname, st)) {
      st->print("Can not get library information for pid = %d\n", pid);
    }
+#endif
 }
 
 
@@ -1815,6 +2113,7 @@ void os::print_os_info(outputStream* st)
   st->print(name.machine);
   st->cr();
 
+#ifndef _ALLBSD_SOURCE
   // Print warning if unsafe chroot environment detected
   if (unsafe_chroot_detected) {
     st->print("WARNING!! ");
@@ -1829,6 +2128,7 @@ void os::print_os_info(outputStream* st)
      st->print("(%s stack)", os::Bsd::is_floating_stack() ? "floating" : "fixed");
   }
   st->cr();
+#endif
 
   // rlimit
   st->print("rlimit:");
@@ -1854,6 +2154,7 @@ void os::print_os_info(outputStream* st)
   if (rlim.rlim_cur == RLIM_INFINITY) st->print("infinity");
   else st->print("%d", rlim.rlim_cur);
 
+#ifndef _ALLBSD_SOURCE
   st->print(", AS ");
   getrlimit(RLIMIT_AS, &rlim);
   if (rlim.rlim_cur == RLIM_INFINITY) st->print("infinity");
@@ -1866,6 +2167,7 @@ void os::print_os_info(outputStream* st)
   os::loadavg(loadavg, 3);
   st->print("%0.02f %0.02f %0.02f", loadavg[0], loadavg[1], loadavg[2]);
   st->cr();
+#endif
 }
 
 void os::print_memory_info(outputStream* st) {
@@ -1873,18 +2175,22 @@ void os::print_memory_info(outputStream*
   st->print("Memory:");
   st->print(" %dk page", os::vm_page_size()>>10);
 
+#ifndef _ALLBSD_SOURCE
   // values in struct sysinfo are "unsigned long"
   struct sysinfo si;
   sysinfo(&si);
+#endif
   
   st->print(", physical " UINT64_FORMAT "k",
             os::physical_memory() >> 10);
   st->print("(" UINT64_FORMAT "k free)",
             os::available_memory() >> 10);
+#ifndef _ALLBSD_SOURCE
   st->print(", swap " UINT64_FORMAT "k",
             ((jlong)si.totalswap * si.mem_unit) >> 10);
   st->print("(" UINT64_FORMAT "k free)",
             ((jlong)si.freeswap * si.mem_unit) >> 10);
+#endif
   st->cr();
 }
 
@@ -2108,19 +2414,29 @@ int os::sigexitnum_pd() {
 static volatile jint pending_signals[NSIG+1] = { 0 };
 
 // Bsd(POSIX) specific hand shaking semaphore.
+#ifdef __APPLE__
+static semaphore_t sig_sem;
+#define SEM_INIT(sem, value)	semaphore_create(mach_task_self(), &sem, SYNC_POLICY_FIFO, value)
+#define SEM_WAIT(sem)		semaphore_wait(sem);
+#define SEM_POST(sem)		semaphore_signal(sem);
+#else
 static sem_t sig_sem;
+#define SEM_INIT(sem, value)	sem_init(&sem, 0, value)
+#define SEM_WAIT(sem)		sem_wait(&sem);
+#define SEM_POST(sem)		sem_post(&sem);
+#endif
 
 void os::signal_init_pd() {
   // Initialize signal structures
   ::memset((void*)pending_signals, 0, sizeof(pending_signals));
 
   // Initialize signal semaphore
-  ::sem_init(&sig_sem, 0, 0);
+  ::SEM_INIT(sig_sem, 0);
 }
 
 void os::signal_notify(int sig) {
   Atomic::inc(&pending_signals[sig]);
-  ::sem_post(&sig_sem);
+  ::SEM_POST(sig_sem);
 }
 
 static int check_pending_signals(bool wait) {
@@ -2142,7 +2458,7 @@ static int check_pending_signals(bool wa
     do {
       thread->set_suspend_equivalent();
       // cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()
-      ::sem_wait(&sig_sem);
+      ::SEM_WAIT(sig_sem);
 
       // were we externally suspended while we were waiting?
       threadIsSuspended = thread->handle_special_suspend_equivalent_condition();
@@ -2153,7 +2469,7 @@ static int check_pending_signals(bool wa
         // while suspended because that would surprise the thread that
         // suspended us.
         //
-        ::sem_post(&sig_sem);
+        ::SEM_POST(sig_sem);
 
         thread->java_suspend_self();
       }
@@ -2224,10 +2540,16 @@ void bsd_wrap_code(char* base, size_t si
 //       left at the time of mmap(). This could be a potential  
 //       problem.                                               
 bool os::commit_memory(char* addr, size_t size) {
+#ifdef __OpenBSD__
+  // XXX: Work-around mmap/MAP_FIXED bug temporarily on OpenBSD
+  return mprotect(addr, size, PROT_READ|PROT_WRITE|PROT_EXEC) == 0;
+#else
+
   uintptr_t res = (uintptr_t) ::mmap(addr, size,
                                    PROT_READ|PROT_WRITE|PROT_EXEC,
                                    MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0);
   return res != (uintptr_t) MAP_FAILED;
+#endif
 }
 
 bool os::commit_memory(char* addr, size_t size, size_t alignment_hint) {
@@ -2351,6 +2673,9 @@ bool os::unguard_memory(char* addr, size
 static size_t _large_page_size = 0;
 
 bool os::large_page_init() {
+#ifdef _ALLBSD_SOURCE
+ return false;
+#else
   if (!UseLargePages) return false;
 
   if (LargePageSizeInBytes) {
@@ -2405,6 +2730,7 @@ bool os::large_page_init() {
   // We optimistically assume the support is available. If later it turns out
   // not true, VM will automatically switch to use regular page size.
   return true;
+#endif
 }
 
 #ifndef SHM_HUGETLB
@@ -2575,7 +2901,7 @@ char* os::attempt_reserve_memory_at(size
 }
 
 size_t os::read(int fd, void *buf, unsigned int nBytes) {
-  return ::read(fd, buf, nBytes);
+  INTERRUPTIBLE_RETURN_INT_VM(::read(fd, buf, nBytes), os::Bsd::clear_interrupted);
 }  
 
 // TODO-FIXME: reconcile Solaris' os::sleep with the bsd variation.
@@ -2711,6 +3037,44 @@ void os::loop_breaker(int attempts) {
 // this reason, the code should not be used as default (ThreadPriorityPolicy=0).
 // It is only used when ThreadPriorityPolicy=1 and requires root privilege.
 
+#if defined(_ALLBSD_SOURCE) && !defined(__APPLE__)
+int os::java_to_os_priority[MaxPriority + 1] = {
+  19,              // 0 Entry should never be used
+
+   0,              // 1 MinPriority
+   3,              // 2
+   6,              // 3
+
+   10,              // 4
+   15,              // 5 NormPriority
+   18,              // 6
+
+   21,              // 7
+   25,              // 8
+   28,              // 9 NearMaxPriority
+
+   31              // 10 MaxPriority
+};
+#elif defined(__APPLE__)
+/* Using Mach high-level priority assignments */
+int os::java_to_os_priority[MaxPriority + 1] = {
+   0,              // 0 Entry should never be used (MINPRI_USER)
+
+  27,              // 1 MinPriority
+  28,              // 2
+  29,              // 3
+
+  30,              // 4
+  31,              // 5 NormPriority (BASEPRI_DEFAULT)
+  32,              // 6
+
+  33,              // 7
+  34,              // 8
+  35,              // 9 NearMaxPriority
+
+  36               // 10 MaxPriority
+};
+#else
 int os::java_to_os_priority[MaxPriority + 1] = {
   19,              // 0 Entry should never be used
 
@@ -2728,6 +3092,7 @@ int os::java_to_os_priority[MaxPriority 
 
   -5               // 10 MaxPriority
 };
+#endif
 
 static int prio_init() {
   if (ThreadPriorityPolicy == 1) {
@@ -2747,8 +3112,28 @@ static int prio_init() {
 OSReturn os::set_native_priority(Thread* thread, int newpri) {
   if ( !UseThreadPriorities || ThreadPriorityPolicy == 0 ) return OS_OK;
 
+#ifdef __OpenBSD__
+  // OpenBSD pthread_setprio starves low priority threads
+  return OS_OK;
+#elif defined(__FreeBSD__)
+  int ret = pthread_setprio(thread->osthread()->pthread_id(), newpri);
+#elif defined(__APPLE__)
+  struct sched_param sp;
+  int policy;
+  pthread_t self = pthread_self();
+
+  if (pthread_getschedparam(self, &policy, &sp) != 0)
+    return OS_ERR;
+
+  sp.sched_priority = newpri;
+  if (pthread_setschedparam(self, policy, &sp) != 0)
+    return OS_ERR;
+
+  return OS_OK;
+#else
   int ret = setpriority(PRIO_PROCESS, thread->osthread()->thread_id(), newpri);
   return (ret == 0) ? OS_OK : OS_ERR;
+#endif
 }
 
 OSReturn os::get_native_priority(const Thread* const thread, int *priority_ptr) {
@@ -2758,7 +3143,17 @@ OSReturn os::get_native_priority(const T
   }
 
   errno = 0;
+#if defined(__OpenBSD__) || defined(__FreeBSD__)
+  *priority_ptr = pthread_getprio(thread->osthread()->pthread_id());
+#elif defined(__APPLE__)
+  int policy;
+  struct sched_param sp;
+
+  pthread_getschedparam(pthread_self(), &policy, &sp);
+  *priority_ptr = sp.sched_priority;
+#else
   *priority_ptr = getpriority(PRIO_PROCESS, thread->osthread()->thread_id());
+#endif
   return (*priority_ptr != -1 || errno == 0 ? OS_OK : OS_ERR);
 }
 
@@ -2868,7 +3263,7 @@ static int SR_initialize() {
   /* Get signal number to use for suspend/resume */
   if ((s = ::getenv("_JAVA_SR_SIGNUM")) != 0) {
     int sig = ::strtol(s, 0, 10);
-    if (sig > 0 || sig < _NSIG) {
+    if (sig > 0 || sig < NSIG) {
 	SR_signum = sig;
     }
   }
@@ -3211,6 +3606,28 @@ void os::Bsd::install_signal_handlers() 
     set_signal_handler(SIGFPE, true);
     set_signal_handler(SIGXFSZ, true);
 
+#if defined(__APPLE__)
+    // In Mac OS X 10.4, CrashReporter will write a crash log for all 'fatal' signals, including
+    // signals caught and handled by the JVM. To work around this, we reset the mach task
+    // signal handler that's placed on our process by CrashReporter. This disables
+    // CrashReporter-based reporting.
+    //
+    // This work-around is not necessary for 10.5+, as CrashReporter no longer intercedes
+    // on caught fatal signals.
+    //
+    // Additionally, gdb installs both standard BSD signal handlers, and mach exception
+    // handlers. By replacing the existing task exception handler, we disable gdb's mach
+    // exception handling, while leaving the standard BSD signal handlers functional.
+    kern_return_t kr;
+    kr = task_set_exception_ports(mach_task_self(),
+        EXC_MASK_BAD_ACCESS | EXC_MASK_ARITHMETIC,
+        MACH_PORT_NULL,
+        EXCEPTION_STATE_IDENTITY,
+        MACHINE_THREAD_STATE);
+
+    assert(kr == KERN_SUCCESS, "could not set mach task signal handler");
+#endif
+
     if (libjsig_is_loaded) {
       // Tell libjsig jvm finishes setting signal handlers
       (*end_signal_setting)();
@@ -3231,6 +3648,7 @@ void os::Bsd::install_signal_handlers() 
   }
 }
 
+#ifndef _ALLBSD_SOURCE
 // This is the fastest way to get thread cpu time on Bsd.
 // Returns cpu time (user+sys) for any thread, not only for current.
 // POSIX compliant clocks are implemented in the kernels 2.6.16+.
@@ -3245,6 +3663,7 @@ jlong os::Bsd::fast_thread_cpu_time(cloc
 
   return (tp.tv_sec * SEC_IN_NANOSECS) + tp.tv_nsec;
 }
+#endif
 
 /////
 // glibc on Bsd platform uses non-documented flag
@@ -3466,13 +3885,13 @@ void os::init(void) {
 
   _initial_pid = (java_launcher_pid > 0) ? java_launcher_pid : getpid();
 
-  clock_tics_per_sec = sysconf(_SC_CLK_TCK);
+  clock_tics_per_sec = CLK_TCK;
 
   init_random(1234567);
 
   ThreadCritical::initialize();
 
-  Bsd::set_page_size(sysconf(_SC_PAGESIZE));
+  Bsd::set_page_size(getpagesize());
   if (Bsd::page_size() == -1) {
     fatal1("os_bsd.cpp: os::init: sysconf failed (%s)", strerror(errno));
   }
@@ -3485,6 +3904,16 @@ void os::init(void) {
 
   Bsd::clock_init();
   initial_time_count = os::elapsed_counter();
+
+#ifdef __APPLE__
+  // XXXDARWIN
+  // Work around the unaligned VM callbacks in hotspot's
+  // sharedRuntime. The callbacks don't use SSE2 instructions, and work on
+  // Linux, Solaris, and FreeBSD. On Mac OS X, dyld (rightly so) enforces
+  // alignment when doing symbol lookup. To work around this, we force early
+  // binding of all symbols now, thus binding when alignment is known-good.
+  _dyld_bind_fully_image_containing_address((const void *) &os::init);
+#endif
 }
 
 // To install functions for atexit system call
@@ -3497,7 +3926,9 @@ extern "C" {
 // this is called _after_ the global arguments have been parsed
 jint os::init_2(void)
 {
+#ifndef _ALLBSD_SOURCE
   Bsd::fast_thread_clock_init();
+#endif
 
   // Allocate a single page and mark it as readable for safepoint polling
   address polling_page = (address) ::mmap(NULL, Bsd::page_size(), PROT_READ, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
@@ -3546,6 +3977,7 @@ jint os::init_2(void)
   JavaThread::set_stack_size_at_create(round_to(threadStackSizeInBytes,
         vm_page_size()));
 
+#ifndef _ALLBSD_SOURCE
   Bsd::capture_initial_stack(JavaThread::stack_size_at_create());
 
   Bsd::libpthread_init();
@@ -3554,6 +3986,7 @@ jint os::init_2(void)
           Bsd::glibc_version(), Bsd::libpthread_version(), 
           Bsd::is_floating_stack() ? "floating stack" : "fixed stack");
   }
+#endif
 
   if (MaxFDLimit) {
     // set the number of file descriptors to max. print out error
@@ -3565,6 +3998,14 @@ jint os::init_2(void)
         perror("os::init_2 getrlimit failed");
     } else {
       nbr_files.rlim_cur = nbr_files.rlim_max;
+      
+#ifdef __APPLE__
+      // Darwin returns RLIM_INFINITY for rlim_max, but fails with EINVAL if
+      // you attempt to use RLIM_INFINITY. As per setrlimit(2), OPEN_MAX must
+      // be used instead
+      nbr_files.rlim_cur = MIN(OPEN_MAX, nbr_files.rlim_cur);
+#endif
+
       status = setrlimit(RLIMIT_NOFILE, &nbr_files);
       if (status != 0) {
         if (PrintMiscellaneous && (Verbose || WizardMode))
@@ -3573,8 +4014,10 @@ jint os::init_2(void)
     }
   }
 
+#ifndef _ALLBSD_SOURCE
   // Initialize lock used to serialize thread creation (see os::create_thread)
   Bsd::set_createThread_lock(new Mutex(Mutex::leaf, "createThread_lock", false));
+#endif
 
   // Initialize HPI.
   jint hpi_result = hpi::initialize();
@@ -3621,11 +4064,16 @@ void os::make_polling_page_readable(void
 };
 
 int os::active_processor_count() {
+#ifdef _ALLBSD_SOURCE
+  return _processor_count;
+#else
+
   // Bsd doesn't yet have a (official) notion of processor sets,
   // so just return the number of online processors.
   int online_cpus = ::sysconf(_SC_NPROCESSORS_ONLN);
   assert(online_cpus > 0 && online_cpus <= processor_count(), "sanity check");
   return online_cpus;
+#endif
 }
 
 bool os::distribute_processes(uint length, uint* distribution) {
@@ -3667,6 +4115,9 @@ ExtendedPC os::get_thread_pc(Thread* thr
 
 int os::Bsd::safe_cond_timedwait(pthread_cond_t *_cond, pthread_mutex_t *_mutex, const struct timespec *_abstime)
 {
+#ifdef _ALLBSD_SOURCE
+  return pthread_cond_timedwait(_cond, _mutex, _abstime);
+#else
    if (is_NPTL()) {
       return pthread_cond_timedwait(_cond, _mutex, _abstime);
    } else {
@@ -3682,6 +4133,7 @@ int os::Bsd::safe_cond_timedwait(pthread
 #endif // IA64
       return status;
    }
+#endif
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -3817,17 +4269,17 @@ int os::create_binary_file(const char* p
   if (!rewrite_existing) {
     oflags |= O_EXCL;
   }
-  return ::open64(path, oflags, S_IREAD | S_IWRITE);
+  return ::open(path, oflags, S_IREAD | S_IWRITE);
 }
 
 // return current position of file pointer
 jlong os::current_file_offset(int fd) {
-  return (jlong)::lseek64(fd, (off64_t)0, SEEK_CUR);
+  return (jlong)::lseek(fd, (off_t)0, SEEK_CUR);
 }
 
 // move file pointer to the specified offset
 jlong os::seek_to_file_offset(int fd, jlong offset) {
-  return (jlong)::lseek64(fd, (off64_t)offset, SEEK_SET);
+  return (jlong)::lseek(fd, (off_t)offset, SEEK_SET);
 }
 
 // Map a block of memory.
@@ -3877,6 +4329,7 @@ bool os::unmap_memory(char* addr, size_t
   return munmap(addr, bytes) == 0;
 }
 
+#ifndef _ALLBSD_SOURCE
 static jlong slow_thread_cpu_time(Thread *thread, bool user_sys_cpu_time);
 
 static clockid_t thread_cpu_clockid(Thread* thread) {
@@ -3888,6 +4341,7 @@ static clockid_t thread_cpu_clockid(Thre
   assert(rc == 0, "pthread_getcpuclockid is expected to return 0 code");
   return clockid;
 }
+#endif
 
 // current_thread_cpu_time(bool) and thread_cpu_time(Thread*, bool) 
 // are used by JVM M&M and JVMTI to get user+sys or user CPU time
@@ -3897,39 +4351,71 @@ static clockid_t thread_cpu_clockid(Thre
 // the fast estimate available on the platform.
 
 jlong os::current_thread_cpu_time() {
+#ifdef __APPLE__
+  return os::thread_cpu_time(Thread::current(), true /* user + sys */);
+#elif !defined(_ALLBSD_SOURCE)
   if (os::Bsd::supports_fast_thread_cpu_time()) {
     return os::Bsd::fast_thread_cpu_time(CLOCK_THREAD_CPUTIME_ID);
   } else {
     // return user + sys since the cost is the same
     return slow_thread_cpu_time(Thread::current(), true /* user + sys */);
   }
+#endif
 }
 
 jlong os::thread_cpu_time(Thread* thread) {
+#ifndef _ALLBSD_SOURCE
   // consistent with what current_thread_cpu_time() returns
   if (os::Bsd::supports_fast_thread_cpu_time()) {
     return os::Bsd::fast_thread_cpu_time(thread_cpu_clockid(thread));
   } else {
     return slow_thread_cpu_time(thread, true /* user + sys */);
   }
+#endif
 }
 
 jlong os::current_thread_cpu_time(bool user_sys_cpu_time) {
+#ifdef __APPLE__
+  return os::thread_cpu_time(Thread::current(), user_sys_cpu_time);
+#elif !defined(_ALLBSD_SOURCE)
   if (user_sys_cpu_time && os::Bsd::supports_fast_thread_cpu_time()) {
     return os::Bsd::fast_thread_cpu_time(CLOCK_THREAD_CPUTIME_ID);
   } else {
     return slow_thread_cpu_time(Thread::current(), user_sys_cpu_time);
   }
+#endif
 }
 
 jlong os::thread_cpu_time(Thread *thread, bool user_sys_cpu_time) {
+#ifdef __APPLE__
+  struct thread_basic_info tinfo;
+  mach_msg_type_number_t tcount = THREAD_INFO_MAX;
+  kern_return_t kr;
+  mach_port_t mach_thread;
+
+  mach_thread = pthread_mach_thread_np(thread->osthread()->thread_id());
+  kr = thread_info(mach_thread, THREAD_BASIC_INFO, (thread_info_t)&tinfo, &tcount);
+  if (kr != KERN_SUCCESS)
+    return -1;
+
+  if (user_sys_cpu_time) {
+    jlong nanos;
+    nanos = ((jlong) tinfo.system_time.seconds + tinfo.user_time.seconds) * (jlong)1000000000;
+    nanos += ((jlong) tinfo.system_time.microseconds + (jlong) tinfo.user_time.microseconds) * (jlong)1000;
+    return nanos;
+  } else {
+    return ((jlong)tinfo.user_time.seconds * 1000000000) + ((jlong)tinfo.user_time.microseconds * (jlong)1000);
+  }
+#elif !defined(_ALLBSD_SOURCE)
   if (user_sys_cpu_time && os::Bsd::supports_fast_thread_cpu_time()) {
     return os::Bsd::fast_thread_cpu_time(thread_cpu_clockid(thread));
   } else {
     return slow_thread_cpu_time(thread, user_sys_cpu_time);
   }
+#endif
 }
 
+#ifndef _ALLBSD_SOURCE
 //
 //  -1 on error.
 // 
@@ -4018,6 +4504,7 @@ static jlong slow_thread_cpu_time(Thread
     return (jlong)user_time * (1000000000 / clock_tics_per_sec);
   }
 }
+#endif
 
 void os::current_thread_cpu_time_info(jvmtiTimerInfo *info_ptr) {
   info_ptr->max_value = ALL_64_BITS;       // will not wrap in less than 64 bits
@@ -4034,7 +4521,13 @@ void os::thread_cpu_time_info(jvmtiTimer
 }
 
 bool os::is_thread_cpu_time_supported() {
+#ifdef __APPLE__
+  return true;
+#elif defined(_ALLBSD_SOURCE)
+  return false;
+#else
   return true;
+#endif
 }
 
 // System loadavg support.  Returns -1 if load average cannot be obtained.
@@ -4167,7 +4660,7 @@ jdk_pthread_sigmask(int how , const sigs
 // abstime will be the absolute timeout time
 // TODO: replace compute_abstime() with unpackTime()
 
-static struct timespec* compute_abstime(timespec* abstime, jlong millis) {
+static struct timespec* compute_abstime(struct timespec* abstime, jlong millis) {
   if (millis < 0)  millis = 0;
   struct timeval now;
   int status = gettimeofday(&now, NULL);
@@ -4219,7 +4712,7 @@ void os::PlatformEvent::park() {       /
         status = pthread_cond_wait(_cond, _mutex);
         // for some reason, under 2.7 lwp_cond_wait() may return ETIME ...
         // Treat this the same as if the wait was interrupted
-        if (status == ETIME) { status = EINTR; } 
+        if (status == ETIMEDOUT) { status = EINTR; } 
         assert_status(status == 0 || status == EINTR, status, "cond_wait");
      }
      -- _nParked ; 
@@ -4277,10 +4770,10 @@ int os::PlatformEvent::park(jlong millis
       pthread_cond_init (_cond, NULL) ;
     }
     assert_status(status == 0 || status == EINTR || 
-		  status == ETIME || status == ETIMEDOUT, 
+		  status == ETIMEDOUT, 
 		  status, "cond_timedwait");
     if (!FilterSpuriousWakeups) break ; 		// previous semantics
-    if (status == ETIME || status == ETIMEDOUT) break ; 
+    if (status == ETIMEDOUT) break ; 
     // We consume and ignore EINTR and spurious wakeups.   
   }
   --_nParked ;
@@ -4372,7 +4865,7 @@ void os::PlatformEvent::unpark() {
  * years from "now".
  */
 
-static void unpackTime(timespec* absTime, bool isAbsolute, jlong time) {
+static void unpackTime(struct timespec* absTime, bool isAbsolute, jlong time) {
   assert (time > 0, "convertTime");
 
   struct timeval now;
@@ -4431,7 +4924,7 @@ void Parker::park(bool isAbsolute, jlong
   }
 
   // Next, demultiplex/decode time arguments
-  timespec absTime;
+  struct timespec absTime;
   if (time < 0) { // don't wait at all
     return; 
   }
@@ -4484,7 +4977,7 @@ void Parker::park(bool isAbsolute, jlong
     }
   }
   assert_status(status == 0 || status == EINTR || 
-                status == ETIME || status == ETIMEDOUT, 
+                status == ETIMEDOUT, 
                 status, "cond_timedwait");
 
 #ifdef ASSERT
@@ -4526,14 +5019,12 @@ void Parker::unpark() {
 }
 
 
+/* Darwin has no "environ" in a dynamic library. */
+#ifdef __APPLE__
+#include <crt_externs.h>
+#define environ (*_NSGetEnviron())
+#else
 extern char** environ;
-
-#ifndef __NR_fork
-#define __NR_fork IA32_ONLY(2) IA64_ONLY(not defined) AMD64_ONLY(57)
-#endif
-
-#ifndef __NR_execve
-#define __NR_execve IA32_ONLY(11) IA64_ONLY(1033) AMD64_ONLY(59)
 #endif
 
 // Run the specified command in a separate process. Return its exit value,
@@ -4548,8 +5039,7 @@ int os::fork_and_exec(char* cmd) {
   // separate process to execve. Make a direct syscall to fork process.
   // On IA64 there's no fork syscall, we have to use fork() and hope for
   // the best...
-  pid_t pid = NOT_IA64(syscall(__NR_fork);) 
-              IA64_ONLY(fork();)
+  pid_t pid = fork();
 
   if (pid < 0) {
     // fork failed
@@ -4565,8 +5055,7 @@ int os::fork_and_exec(char* cmd) {
     // in the new process, so make a system call directly.
     // IA64 should use normal execve() from glibc to match the glibc fork() 
     // above.
-    NOT_IA64(syscall(__NR_execve, "/bin/sh", argv, environ);)
-    IA64_ONLY(execve("/bin/sh", (char* const*)argv, environ);)
+    execve("/bin/sh", (char* const*)argv, environ);
 
     // execve failed
     _exit(-1);
diff -upr ../orig/hotspot/src/os/bsd/vm/os_bsd.hpp ./hotspot/src/os/bsd/vm/os_bsd.hpp
--- ../orig/hotspot/src/os/bsd/vm/os_bsd.hpp	2009-05-04 18:32:15.000000000 -0400
+++ ./hotspot/src/os/bsd/vm/os_bsd.hpp	2009-05-06 10:55:43.000000000 -0400
@@ -30,6 +30,12 @@
 /* pthread_getattr_np comes with BsdThreads-0.9-7 on RedHat 7.1 */
 typedef int (*pthread_getattr_func_type) (pthread_t, pthread_attr_t *);
 
+#ifdef __APPLE__
+// Mac OS X doesn't support clock_gettime. Stub out the type, it is
+// unused
+typedef int clockid_t;
+#endif
+
 class Bsd {
   friend class os;
 
@@ -50,6 +56,7 @@ class Bsd {
   static int sigflags[MAXSIGNUM];
 
   static int (*_clock_gettime)(clockid_t, struct timespec *);
+#ifndef _ALLBSD_SOURCE
   static int (*_pthread_getcpuclockid)(pthread_t, clockid_t *);
 
   static address   _initial_thread_stack_bottom;
@@ -61,42 +68,79 @@ class Bsd {
   static bool _is_floating_stack;
   static bool _is_NPTL;
   static bool _supports_fast_thread_cpu_time;
+#endif
 
  protected:
 
   static julong _physical_memory;
   static pthread_t _main_thread;
+#ifndef _ALLBSD_SOURCE
   static Mutex* _createThread_lock;
+#endif
   static int _page_size;
 
   static julong available_memory();
   static julong physical_memory() { return _physical_memory; }
   static void initialize_system_info();
 
+#ifndef _ALLBSD_SOURCE
   static void set_glibc_version(const char *s)      { _glibc_version = s; }
   static void set_libpthread_version(const char *s) { _libpthread_version = s; }
+#endif
 
   static bool supports_variable_stack_size();
 
+#ifndef _ALLBSD_SOURCE
   static void set_is_NPTL()                   { _is_NPTL = true;  }
   static void set_is_BsdThreads()           { _is_NPTL = false; }
   static void set_is_floating_stack()         { _is_floating_stack = true; }
+#endif
 
  public:
+#ifdef _ALLBSD_SOURCE
+//XXXBSD: ported from solaris version
+  enum {
+    clear_interrupted = true
+  };
+  static void setup_interruptible(JavaThread* thread);
+  static void setup_interruptible_already_blocked(JavaThread* thread);
+  static JavaThread* setup_interruptible();
+  static void cleanup_interruptible(JavaThread* thread);
+
+  // perf counter incrementers used by _INTERRUPTIBLE 
+
+  static void bump_interrupted_before_count();
+  static void bump_interrupted_during_count();
+
+#ifdef ASSERT
+  static JavaThread* setup_interruptible_native();
+  static void cleanup_interruptible_native(JavaThread* thread);
+#endif
+
+#endif
+
 
   static void init_thread_fpu_state();
+#ifndef _ALLBSD_SOURCE
   static int  get_fpu_control_word();
   static void set_fpu_control_word(int fpu_control);
+#endif
   static pthread_t main_thread(void)                                { return _main_thread; }
+
+#ifndef _ALLBSD_SOURCE
   // returns kernel thread id (similar to LWP id on Solaris), which can be
   // used to access /proc
   static pid_t gettid();
   static void set_createThread_lock(Mutex* lk)                      { _createThread_lock = lk; }
   static Mutex* createThread_lock(void)                             { return _createThread_lock; }
+#endif
   static void hotspot_sigmask(Thread* thread);
 
+#ifndef _ALLBSD_SOURCE
   static address   initial_thread_stack_bottom(void)                { return _initial_thread_stack_bottom; }
   static uintptr_t initial_thread_stack_size(void)                  { return _initial_thread_stack_size; }
+#endif
+
   static bool is_initial_thread(void);
 
   static int page_size(void)                                        { return _page_size; }
@@ -133,6 +177,7 @@ class Bsd {
   static struct sigaction *get_chained_signal_action(int sig);
   static bool chained_handler(int sig, siginfo_t* siginfo, void* context);
 
+#ifndef _ALLBSD_SOURCE
   // GNU libc and libpthread version strings
   static const char *glibc_version()          { return _glibc_version; }
   static const char *libpthread_version()     { return _libpthread_version; }
@@ -146,6 +191,7 @@ class Bsd {
   static bool is_floating_stack()             { return _is_floating_stack; }
 
   static void libpthread_init();
+#endif
 
   // Minimum stack size a thread can be created with (allowing
   // the VM to completely create the thread and enter user code)
@@ -155,17 +201,21 @@ class Bsd {
   static size_t default_stack_size(os::ThreadType thr_type);
   static size_t default_guard_size(os::ThreadType thr_type);
 
+#ifndef _ALLBSD_SOURCE
   static void capture_initial_stack(size_t max_size);
 
   // Stack overflow handling
   static bool manually_expand_stack(JavaThread * t, address addr);
   static int max_register_window_saves_before_flushing();
+#endif
 
   // Real-time clock functions
   static void clock_init(void);
 
+#ifndef _ALLBSD_SOURCE
   // fast POSIX clocks support
   static void fast_thread_clock_init(void);
+#endif
 
   static bool supports_monotonic_clock() {
     return _clock_gettime != NULL;
@@ -175,6 +225,7 @@ class Bsd {
     return _clock_gettime ? _clock_gettime(clock_id, tp) : -1;
   }
 
+#ifndef _ALLBSD_SOURCE
   static int pthread_getcpuclockid(pthread_t tid, clockid_t *clock_id) {
     return _pthread_getcpuclockid ? _pthread_getcpuclockid(tid, clock_id) : -1;
   }
@@ -184,6 +235,7 @@ class Bsd {
   }
 
   static jlong fast_thread_cpu_time(clockid_t clockid);
+#endif
 
   // Stack repair handling
 
diff -upr ../orig/hotspot/src/os/bsd/vm/os_bsd.inline.hpp ./hotspot/src/os/bsd/vm/os_bsd.inline.hpp
--- ../orig/hotspot/src/os/bsd/vm/os_bsd.inline.hpp	2009-05-04 18:32:15.000000000 -0400
+++ ./hotspot/src/os/bsd/vm/os_bsd.inline.hpp	2009-05-06 10:57:31.000000000 -0400
@@ -64,7 +64,15 @@ inline bool os::uses_stack_guard_pages()
 
 inline bool os::allocate_stack_guard_pages() {
   assert(uses_stack_guard_pages(), "sanity check");
+#if !defined(__FreeBSD__) || __FreeBSD__ < 5
+  // Since FreeBSD 4 uses malloc() for allocating the thread stack
+  // there is no need to do anything extra to allocate the guard pages
+  return false;
+#else
+  // FreeBSD 5+ uses mmap MAP_STACK for allocating the thread stacks.
+  // Must 'allocate' them or guard pages are ignored.
   return true;
+#endif
 }
 
 
@@ -112,6 +120,107 @@ inline int os::closedir(DIR *dirp)
   return ::closedir(dirp);
 }
 
+//XXXBSD: ported from solaris version
+//////////////////////////////////////////////////////////////////////////////
+////////////////////////////////////////////////////////////////////////////////
+
+// macros for interruptible io and system calls and system call restarting 
+
+#define _INTERRUPTIBLE(_setup, _cmd, _result, _thread, _clear, _before, _after, _int_enable) \
+do { \
+  _setup; \
+  _before; \
+  OSThread* _osthread = _thread->osthread(); \
+  if (_int_enable && _thread->has_last_Java_frame()) { \
+    /* this is java interruptible io stuff */ \
+    if (os::is_interrupted(_thread, _clear))  { \
+      os::Bsd::bump_interrupted_before_count(); \
+      _result = OS_INTRPT; \
+    } else { \
+      /* _cmd always expands to an assignment to _result */ \
+      if ((_cmd) < 0 && errno == EINTR  \
+       && os::is_interrupted(_thread, _clear)) { \
+        os::Bsd::bump_interrupted_during_count(); \
+        _result = OS_INTRPT; \
+      } \
+    } \
+  } else { \
+    /* this is normal blocking io stuff */ \
+    _cmd; \
+  } \
+  _after; \
+} while(false)
+
+// Interruptible io support + restarting of interrupted system calls
+
+#ifndef ASSERT
+
+#define INTERRUPTIBLE(_cmd, _result, _clear) do { \
+  _INTERRUPTIBLE( JavaThread* _thread = (JavaThread*)ThreadLocalStorage::thread(),_result = _cmd, _result, _thread, _clear, , , UseVMInterruptibleIO); \
+} while((_result == OS_ERR) && (errno == EINTR))
+
+#else 
+
+// This adds an assertion that it is only called from thread_in_native
+// The call overhead is skipped for performance in product mode
+#define INTERRUPTIBLE(_cmd, _result, _clear) do { \
+  _INTERRUPTIBLE(JavaThread* _thread = os::Bsd::setup_interruptible_native(), _result = _cmd, _result, _thread, _clear, , os::Bsd::cleanup_interruptible_native(_thread), UseVMInterruptibleIO ); \
+} while((_result == OS_ERR) && (errno == EINTR))
+
+#endif
+
+// Used for calls from _thread_in_vm, not from _thread_in_native
+#define INTERRUPTIBLE_VM(_cmd, _result, _clear) do { \
+  _INTERRUPTIBLE(JavaThread* _thread = os::Bsd::setup_interruptible(), _result = _cmd, _result, _thread, _clear, , os::Bsd::cleanup_interruptible(_thread), UseVMInterruptibleIO ); \
+} while((_result == OS_ERR) && (errno == EINTR))
+
+/* Use NORESTART when the system call cannot return EINTR, when something other
+   than a system call is being invoked, or when the caller must do EINTR 
+   handling. */
+
+#ifndef ASSERT
+
+#define INTERRUPTIBLE_NORESTART(_cmd, _result, _clear) \
+  _INTERRUPTIBLE( JavaThread* _thread = (JavaThread*)ThreadLocalStorage::thread(),_result = _cmd, _result, _thread, _clear, , , UseVMInterruptibleIO)
+
+#else
+
+// This adds an assertion that it is only called from thread_in_native
+// The call overhead is skipped for performance in product mode
+#define INTERRUPTIBLE_NORESTART(_cmd, _result, _clear) \
+  _INTERRUPTIBLE(JavaThread* _thread = os::Bsd::setup_interruptible_native(), _result = _cmd, _result, _thread, _clear, , os::Bsd::cleanup_interruptible_native(_thread), UseVMInterruptibleIO )
+
+#endif
+
+// Don't attend to UseVMInterruptibleIO. Always allow interruption.
+// Also assumes that it is called from the _thread_blocked state.
+// Used by os_sleep().
+
+#define INTERRUPTIBLE_NORESTART_VM_ALWAYS(_cmd, _result, _thread, _clear) \
+  _INTERRUPTIBLE(os::Bsd::setup_interruptible_already_blocked(_thread), _result = _cmd, _result, _thread, _clear, , , true )
+
+#define INTERRUPTIBLE_RETURN_INT(_cmd, _clear) do { \
+  int _result; \
+  do { \
+    INTERRUPTIBLE(_cmd, _result, _clear); \
+  } while((_result == OS_ERR) && (errno == EINTR)); \
+  return _result; \
+} while(false)
+
+#define INTERRUPTIBLE_RETURN_INT_VM(_cmd, _clear) do { \
+  int _result; \
+  do { \
+    INTERRUPTIBLE_VM(_cmd, _result, _clear); \
+  } while((_result == OS_ERR) && (errno == EINTR)); \
+  return _result; \
+} while(false)
+
+#define INTERRUPTIBLE_RETURN_INT_NORESTART(_cmd, _clear) do { \
+  int _result; \
+  INTERRUPTIBLE_NORESTART(_cmd, _result, _clear); \
+  return _result; \
+} while(false)
+
 // macros for restartable system calls
 
 #define RESTARTABLE(_cmd, _result) do { \
Only in ./hotspot/src/os_cpu/bsd_x86/vm: assembler_bsd_x86.cpp
diff -upr ../orig/hotspot/src/os_cpu/bsd_x86/vm/assembler_bsd_x86_64.cpp ./hotspot/src/os_cpu/bsd_x86/vm/assembler_bsd_x86_64.cpp
--- ../orig/hotspot/src/os_cpu/bsd_x86/vm/assembler_bsd_x86_64.cpp	2009-05-04 18:32:15.000000000 -0400
+++ ./hotspot/src/os_cpu/bsd_x86/vm/assembler_bsd_x86_64.cpp	2009-05-06 11:53:03.000000000 -0400
@@ -69,8 +69,9 @@ void MacroAssembler::get_thread(Register
    }
 }
 
-// NOTE: since the bsd kernel resides at the low end of
-// user address space, no null pointer check is needed.
 bool MacroAssembler::needs_explicit_null_check(int offset) {
-  return offset < 0 || offset >= 0x100000;
+  // Bsd kernel guarantees that the first page is always unmapped. Don't
+  // assume anything more than that.
+  bool offset_in_first_page =   0 <= offset  &&  offset < os::vm_page_size();
+  return !offset_in_first_page;
 }
diff -upr ../orig/hotspot/src/os_cpu/bsd_x86/vm/bsd_x86_32.s ./hotspot/src/os_cpu/bsd_x86/vm/bsd_x86_32.s
--- ../orig/hotspot/src/os_cpu/bsd_x86/vm/bsd_x86_32.s	2009-05-04 18:32:15.000000000 -0400
+++ ./hotspot/src/os_cpu/bsd_x86/vm/bsd_x86_32.s	2009-05-04 17:37:17.000000000 -0400
@@ -21,49 +21,82 @@
 # have any questions.
 # 
 
+
+
 .ident	"@(#)bsd_x86_32.s	1.10 07/05/17 15:48:59 JVM"
-	
+
+#ifdef __APPLE__
+# Darwin uses _ prefixed global symbols
+#define SYMBOL(s) _ ## s
+#define ELF_TYPE(name, description)
+#else
+#define SYMBOL(s) s
+#define ELF_TYPE(name, description) .type name,description
+#endif
+
+        .globl SYMBOL(fixcw)
+
         # NOTE WELL!  The _Copy functions are called directly
 	# from server-compiler-generated code via CallLeafNoFP,
 	# which means that they *must* either not use floating
 	# point or use it in the same manner as does the server
 	# compiler.
 	
-        .globl _Copy_conjoint_bytes
-        .globl _Copy_arrayof_conjoint_bytes
-        .globl _Copy_conjoint_jshorts_atomic
-	.globl _Copy_arrayof_conjoint_jshorts
-        .globl _Copy_conjoint_jints_atomic
-        .globl _Copy_arrayof_conjoint_jints
-	.globl _Copy_conjoint_jlongs_atomic
-	.globl _mmx_Copy_arrayof_conjoint_jshorts
+        .globl SYMBOL(_Copy_conjoint_bytes)
+        .globl SYMBOL(_Copy_arrayof_conjoint_bytes)
+        .globl SYMBOL(_Copy_conjoint_jshorts_atomic)
+	.globl SYMBOL(_Copy_arrayof_conjoint_jshorts)
+        .globl SYMBOL(_Copy_conjoint_jints_atomic)
+        .globl SYMBOL(_Copy_arrayof_conjoint_jints)
+	.globl SYMBOL(_Copy_conjoint_jlongs_atomic)
+	.globl SYMBOL(_mmx_Copy_arrayof_conjoint_jshorts)
 
-        .globl _Atomic_cmpxchg_long
+        .globl SYMBOL(_Atomic_cmpxchg_long)
 
 	.text
 
-        .globl  SafeFetch32, Fetch32PFI, Fetch32Resume
-        .globl  SafeFetchN
+# Support for void os::Solaris::init_thread_fpu_state() in os_solaris_i486.cpp
+# Set fpu to 53 bit precision.  This happens too early to use a stub.
+# ported from solaris_x86_32.s
+#ifdef __APPLE__
+        .align   4
+#else
+	.align   16
+#endif
+SYMBOL(fixcw):
+	pushl    $0x27f
+	fldcw    0(%esp)
+	popl     %eax
+	ret
+
+#ifdef __APPLE__
+        .align   4
+#else
+        .align   16
+#endif
+
+        .globl  SYMBOL(SafeFetch32), SYMBOL(Fetch32PFI), SYMBOL(Fetch32Resume)
+        .globl  SYMBOL(SafeFetchN)
         ## TODO: avoid exposing Fetch32PFI and Fetch32Resume.
         ## Instead, the signal handler would call a new SafeFetchTriage(FaultingEIP)
         ## routine to vet the address.  If the address is the faulting LD then
         ## SafeFetchTriage() would return the resume-at EIP, otherwise null.
-	.type    SafeFetch32,@function
+	ELF_TYPE(SafeFetch32,@function)
         .p2align 4,,15
-SafeFetch32:
-SafeFetchN:
+SYMBOL(SafeFetch32):
+SYMBOL(SafeFetchN):
          movl    0x8(%esp), %eax
          movl    0x4(%esp), %ecx
-Fetch32PFI:
+SYMBOL(Fetch32PFI):
          movl    (%ecx), %eax
-Fetch32Resume:
+SYMBOL(Fetch32Resume):
          ret
 
 
-        .globl  SpinPause
-	.type   SpinPause,@function
+        .globl  SYMBOL(SpinPause)
+	ELF_TYPE(SpinPause,@function)
         .p2align 4,,15
-SpinPause:
+SYMBOL(SpinPause):
         rep
         nop
         movl    $1, %eax
@@ -73,8 +106,8 @@ SpinPause:
         #                                       void* to,
         #                                       size_t count)
         .p2align 4,,15
-	.type    _Copy_conjoint_bytes,@function
-_Copy_conjoint_bytes:
+	ELF_TYPE(_Copy_conjoint_bytes,@function)
+SYMBOL(_Copy_conjoint_bytes):
         pushl    %esi
         movl     4+12(%esp),%ecx      # count
         pushl    %edi
@@ -181,8 +214,8 @@ cb_CopyLeft:
         #
         # Same as _Copy_conjoint_bytes, except no source alignment check.
         .p2align 4,,15
-	.type    _Copy_arrayof_conjoint_bytes,@function
-_Copy_arrayof_conjoint_bytes:
+	ELF_TYPE(_Copy_arrayof_conjoint_bytes,@function)
+SYMBOL(_Copy_arrayof_conjoint_bytes):
         pushl    %esi
         movl     4+12(%esp),%ecx      # count
         pushl    %edi
@@ -269,8 +302,8 @@ acb_CopyLeft:
         #                                                void* to,
         #                                                size_t count)
         .p2align 4,,15
-	.type    _Copy_conjoint_jshorts_atomic,@function
-_Copy_conjoint_jshorts_atomic:
+	ELF_TYPE(_Copy_conjoint_jshorts_atomic,@function)
+SYMBOL(_Copy_conjoint_jshorts_atomic):
         pushl    %esi
         movl     4+12(%esp),%ecx      # count
         pushl    %edi
@@ -355,8 +388,8 @@ cs_CopyLeft:
         #                                                 void* to,
         #                                                 size_t count)
         .p2align 4,,15
-	.type    _Copy_arrayof_conjoint_jshorts,@function
-_Copy_arrayof_conjoint_jshorts:
+	ELF_TYPE(_Copy_arrayof_conjoint_jshorts,@function)
+SYMBOL(_Copy_arrayof_conjoint_jshorts):
         pushl    %esi
         movl     4+12(%esp),%ecx      # count
         pushl    %edi
@@ -432,10 +465,10 @@ acs_CopyLeft:
         # Equivalent to
         #   arrayof_conjoint_jints
         .p2align 4,,15
-	.type    _Copy_conjoint_jints_atomic,@function
-	.type    _Copy_arrayof_conjoint_jints,@function
-_Copy_conjoint_jints_atomic:
-_Copy_arrayof_conjoint_jints:
+	ELF_TYPE(_Copy_conjoint_jints_atomic,@function)
+	ELF_TYPE(_Copy_arrayof_conjoint_jints,@function)
+SYMBOL(_Copy_conjoint_jints_atomic):
+SYMBOL(_Copy_arrayof_conjoint_jints):
         pushl    %esi
         movl     4+12(%esp),%ecx      # count
         pushl    %edi
@@ -495,7 +528,7 @@ ci_CopyLeft:
         #
         # count treated as signed
         #
-        # if (from > to) {
+        # // if (from > to) {
         #   while (--count >= 0) {
         #     *to++ = *from++;
         #   }
@@ -505,8 +538,8 @@ ci_CopyLeft:
         #   }
         # }
         .p2align 4,,15
-	.type    _Copy_conjoint_jlongs_atomic,@function
-_Copy_conjoint_jlongs_atomic:
+	ELF_TYPE(_Copy_conjoint_jlongs_atomic,@function)
+SYMBOL(_Copy_conjoint_jlongs_atomic):
         movl     4+8(%esp),%ecx       # count
         movl     4+0(%esp),%eax       # from
         movl     4+4(%esp),%edx       # to
@@ -534,8 +567,8 @@ cla_CopyLeft:
         #                                                 void* to,
         #                                                 size_t count)
         .p2align 4,,15
-	.type    _mmx_Copy_arrayof_conjoint_jshorts,@function
-_mmx_Copy_arrayof_conjoint_jshorts:
+	ELF_TYPE(_mmx_Copy_arrayof_conjoint_jshorts,@function)
+SYMBOL(_mmx_Copy_arrayof_conjoint_jshorts):
         pushl    %esi
         movl     4+12(%esp),%ecx
         pushl    %edi
@@ -633,8 +666,8 @@ mmx_acs_CopyLeft:
         #                                   bool is_MP)
         #
         .p2align 4,,15
-	.type    _Atomic_cmpxchg_long,@function
-_Atomic_cmpxchg_long:
+	ELF_TYPE(_Atomic_cmpxchg_long,@function)
+SYMBOL(_Atomic_cmpxchg_long):
                                    #  8(%esp) : return PC
         pushl    %ebx              #  4(%esp) : old %ebx
         pushl    %edi              #  0(%esp) : old %edi
diff -upr ../orig/hotspot/src/os_cpu/bsd_x86/vm/bsd_x86_64.s ./hotspot/src/os_cpu/bsd_x86/vm/bsd_x86_64.s
--- ../orig/hotspot/src/os_cpu/bsd_x86/vm/bsd_x86_64.s	2009-05-04 18:32:15.000000000 -0400
+++ ./hotspot/src/os_cpu/bsd_x86/vm/bsd_x86_64.s	2009-05-06 11:56:15.000000000 -0400
@@ -23,48 +23,70 @@
 
 .ident	"@(#)bsd_x86_64.s	1.7 07/05/05 17:04:47 JVM"
 
+#ifdef __APPLE__
+# Darwin uses _ prefixed global symbols
+#define SYMBOL(s) _ ## s
+#define ELF_TYPE(name, description)
+#else
+#define SYMBOL(s) s
+#define ELF_TYPE(name, description) .type name,description
+#endif
+
+
         # NOTE WELL!  The _Copy functions are called directly
 	# from server-compiler-generated code via CallLeafNoFP,
 	# which means that they *must* either not use floating
 	# point or use it in the same manner as does the server
 	# compiler.
 	
-        .globl _Copy_arrayof_conjoint_bytes
-	.globl _Copy_arrayof_conjoint_jshorts
-        .globl _Copy_conjoint_jshorts_atomic
-        .globl _Copy_arrayof_conjoint_jints
-        .globl _Copy_conjoint_jints_atomic
-        .globl _Copy_arrayof_conjoint_jlongs
-        .globl _Copy_conjoint_jlongs_atomic
+        .globl SYMBOL(_Copy_arrayof_conjoint_bytes)
+	.globl SYMBOL(_Copy_arrayof_conjoint_jshorts)
+        .globl SYMBOL(_Copy_conjoint_jshorts_atomic)
+        .globl SYMBOL(_Copy_arrayof_conjoint_jints)
+        .globl SYMBOL(_Copy_conjoint_jints_atomic)
+        .globl SYMBOL(_Copy_arrayof_conjoint_jlongs)
+        .globl SYMBOL(_Copy_conjoint_jlongs_atomic)
 
 	.text
 
-        .globl SafeFetch32, Fetch32PFI, Fetch32Resume
+        .globl SYMBOL(SafeFetch32), SYMBOL(Fetch32PFI), SYMBOL(Fetch32Resume)
+#ifdef __APPLE__
+        .align  4
+#else
         .align  16
-        .type   SafeFetch32,@function
+#endif
+        ELF_TYPE(SafeFetch32,@function)
         // Prototype: int SafeFetch32 (int * Adr, int ErrValue) 
-SafeFetch32:
+SYMBOL(SafeFetch32):
         movl    %esi, %eax
-Fetch32PFI:
+SYMBOL(Fetch32PFI):
         movl    (%rdi), %eax
-Fetch32Resume:
+SYMBOL(Fetch32Resume):
         ret
 
-        .globl SafeFetchN, FetchNPFI, FetchNResume
+        .globl SYMBOL(SafeFetchN), SYMBOL(FetchNPFI), SYMBOL(FetchNResume)
+#ifdef __APPLE__
+        .align  4
+#else
         .align  16
-        .type   SafeFetchN,@function
+#endif
+        ELF_TYPE(SafeFetchN,@function)
         // Prototype: intptr_t SafeFetchN (intptr_t * Adr, intptr_t ErrValue) 
-SafeFetchN:
+SYMBOL(SafeFetchN):
         movq    %rsi, %rax
-FetchNPFI:
+SYMBOL(FetchNPFI):
         movq    (%rdi), %rax
-FetchNResume:
+SYMBOL(FetchNResume):
         ret
 
-        .globl SpinPause
-        .align 16
-        .type  SpinPause,@function
-SpinPause:
+        .globl SYMBOL(SpinPause)
+#ifdef __APPLE__
+        .align  4
+#else
+        .align  16
+#endif
+        ELF_TYPE(SpinPause,@function)
+SYMBOL(SpinPause):
         rep
         nop
         movq   $1, %rax
@@ -78,8 +100,8 @@ SpinPause:
         # rdx - count, treated as ssize_t
         #
         .p2align 4,,15
-	.type    _Copy_arrayof_conjoint_bytes,@function
-_Copy_arrayof_conjoint_bytes:
+	ELF_TYPE(_Copy_arrayof_conjoint_bytes,@function)
+SYMBOL(_Copy_arrayof_conjoint_bytes):
         movq     %rdx,%r8             # byte count
         shrq     $3,%rdx              # qword count
         cmpq     %rdi,%rsi
@@ -180,10 +202,10 @@ acb_CopyLeft:
         # rdx - count, treated as ssize_t
         #
         .p2align 4,,15
-	.type    _Copy_arrayof_conjoint_jshorts,@function
-	.type    _Copy_conjoint_jshorts_atomic,@function
-_Copy_arrayof_conjoint_jshorts:
-_Copy_conjoint_jshorts_atomic:
+	ELF_TYPE(_Copy_arrayof_conjoint_jshorts,@function)
+	ELF_TYPE(_Copy_conjoint_jshorts_atomic,@function)
+SYMBOL(_Copy_arrayof_conjoint_jshorts):
+SYMBOL(_Copy_conjoint_jshorts_atomic):
         movq     %rdx,%r8             # word count
         shrq     $2,%rdx              # qword count
         cmpq     %rdi,%rsi
@@ -270,10 +292,10 @@ acs_CopyLeft:
         # rdx - count, treated as ssize_t
         #
         .p2align 4,,15
-	.type    _Copy_arrayof_conjoint_jints,@function
-	.type    _Copy_conjoint_jints_atomic,@function
-_Copy_arrayof_conjoint_jints:
-_Copy_conjoint_jints_atomic:
+	ELF_TYPE(_Copy_arrayof_conjoint_jints,@function)
+	ELF_TYPE(_Copy_conjoint_jints_atomic,@function)
+SYMBOL(_Copy_arrayof_conjoint_jints):
+SYMBOL(_Copy_conjoint_jints_atomic):
         movq     %rdx,%r8             # dword count
         shrq     %rdx                 # qword count
         cmpq     %rdi,%rsi
@@ -349,10 +371,10 @@ aci_CopyLeft:
         # rdx - count, treated as ssize_t
         #
         .p2align 4,,15
-	.type    _Copy_arrayof_conjoint_jlongs,@function
-	.type    _Copy_conjoint_jlongs_atomic,@function
-_Copy_arrayof_conjoint_jlongs:
-_Copy_conjoint_jlongs_atomic:
+	ELF_TYPE(_Copy_arrayof_conjoint_jlongs,@function)
+	ELF_TYPE(_Copy_conjoint_jlongs_atomic,@function)
+SYMBOL(_Copy_arrayof_conjoint_jlongs):
+SYMBOL(_Copy_conjoint_jlongs_atomic):
         cmpq     %rdi,%rsi
         leaq     -8(%rdi,%rdx,8),%rax # from + count*8 - 8
         jbe      acl_CopyRight
diff -upr ../orig/hotspot/src/os_cpu/bsd_x86/vm/bytes_bsd_x86.inline.hpp ./hotspot/src/os_cpu/bsd_x86/vm/bytes_bsd_x86.inline.hpp
--- ../orig/hotspot/src/os_cpu/bsd_x86/vm/bytes_bsd_x86.inline.hpp	2009-05-04 18:32:15.000000000 -0400
+++ ./hotspot/src/os_cpu/bsd_x86/vm/bytes_bsd_x86.inline.hpp	2009-05-06 12:15:02.000000000 -0400
@@ -25,7 +25,29 @@
  *  
  */
 
+#ifndef _ALLBSD_SOURCE
 #include <byteswap.h>
+#endif
+
+#ifdef __APPLE__
+#include <libkern/OSByteOrder.h>
+#endif
+
+#if defined(AMD64)
+#  if defined(__APPLE__)
+#    define bswap_16(x)	OSSwapInt16(x)
+#    define bswap_32(x)	OSSwapInt32(x)
+#    define bswap_64(x)	OSSwapInt64(x)
+#  elif defined(__OpenBSD__)
+#    define bswap_16(x)	swap16(x)
+#    define bswap_32(x)	swap32(x)
+#    define bswap_64(x)	swap64(x)
+#  else
+#    define bswap_16(x) __bswap16(x)
+#    define bswap_32(x) __bswap32(x)
+#    define bswap_64(x) __bswap64(x)
+#  endif
+#endif
 
 // Efficient swapping of data bytes from Java byte
 // ordering to native byte ordering and vice versa.
diff -upr ../orig/hotspot/src/os_cpu/bsd_x86/vm/os_bsd_x86.cpp ./hotspot/src/os_cpu/bsd_x86/vm/os_bsd_x86.cpp
--- ../orig/hotspot/src/os_cpu/bsd_x86/vm/os_bsd_x86.cpp	2009-05-04 18:32:15.000000000 -0400
+++ ./hotspot/src/os_cpu/bsd_x86/vm/os_bsd_x86.cpp	2009-05-04 17:37:17.000000000 -0400
@@ -47,23 +47,158 @@
 # include <sys/wait.h>
 # include <pwd.h>
 # include <poll.h>
+#ifndef __OpenBSD__
 # include <ucontext.h>
-# include <fpu_control.h>
+#endif
+
+#if defined(_ALLBSD_SOURCE) && !defined(__APPLE__)
+# include <pthread_np.h>
+#endif
 
 #ifdef AMD64
-#define REG_SP REG_RSP
-#define REG_PC REG_RIP
-#define REG_FP REG_RBP
 #define SPELL_REG_SP "rsp"
 #define SPELL_REG_FP "rbp"
 #else
-#define REG_SP REG_UESP
-#define REG_PC REG_EIP
-#define REG_FP REG_EBP
 #define SPELL_REG_SP "esp"
 #define SPELL_REG_FP "ebp"
 #endif // AMD64
 
+#ifdef __FreeBSD__
+# define context_trapno uc_mcontext.mc_trapno
+# ifdef AMD64
+#  define context_pc uc_mcontext.mc_rip
+#  define context_sp uc_mcontext.mc_rsp
+#  define context_fp uc_mcontext.mc_rbp
+#  define context_rip uc_mcontext.mc_rip
+#  define context_rsp uc_mcontext.mc_rsp
+#  define context_rbp uc_mcontext.mc_rbp
+#  define context_rax uc_mcontext.mc_rax
+#  define context_rbx uc_mcontext.mc_rbx
+#  define context_rcx uc_mcontext.mc_rcx
+#  define context_rdx uc_mcontext.mc_rdx
+#  define context_rsi uc_mcontext.mc_rsi
+#  define context_rdi uc_mcontext.mc_rdi
+#  define context_r8  uc_mcontext.mc_r8
+#  define context_r9  uc_mcontext.mc_r9
+#  define context_r10 uc_mcontext.mc_r10
+#  define context_r11 uc_mcontext.mc_r11
+#  define context_r12 uc_mcontext.mc_r12
+#  define context_r13 uc_mcontext.mc_r13
+#  define context_r14 uc_mcontext.mc_r14
+#  define context_r15 uc_mcontext.mc_r15
+#  define context_flags uc_mcontext.mc_flags
+#  define context_err uc_mcontext.mc_err
+# else
+#  define context_pc uc_mcontext.mc_eip
+#  define context_sp uc_mcontext.mc_esp
+#  define context_fp uc_mcontext.mc_ebp
+#  define context_eip uc_mcontext.mc_eip
+#  define context_esp uc_mcontext.mc_esp
+#  define context_eax uc_mcontext.mc_eax
+#  define context_ebx uc_mcontext.mc_ebx
+#  define context_ecx uc_mcontext.mc_ecx
+#  define context_edx uc_mcontext.mc_edx
+#  define context_ebp uc_mcontext.mc_ebp
+#  define context_esi uc_mcontext.mc_esi
+#  define context_edi uc_mcontext.mc_edi
+#  define context_eflags uc_mcontext.mc_eflags
+#  define context_trapno uc_mcontext.mc_trapno
+# endif
+#endif
+
+#ifdef __APPLE__ 
+# if __DARWIN_UNIX03 && (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
+  // 10.5 UNIX03 member name prefixes
+  #define DU3_PREFIX(s, m) __ ## s.__ ## m
+# else
+  #define DU3_PREFIX(s, m) s ## . ## m
+# endif
+
+# ifdef AMD64
+#  define context_pc context_rip
+#  define context_sp context_rsp
+#  define context_fp context_rbp
+#  define context_rip uc_mcontext->DU3_PREFIX(ss,rip)
+#  define context_rsp uc_mcontext->DU3_PREFIX(ss,rsp)
+#  define context_rax uc_mcontext->DU3_PREFIX(ss,rax)
+#  define context_rbx uc_mcontext->DU3_PREFIX(ss,rbx)
+#  define context_rcx uc_mcontext->DU3_PREFIX(ss,rcx)
+#  define context_rdx uc_mcontext->DU3_PREFIX(ss,rdx)
+#  define context_rbp uc_mcontext->DU3_PREFIX(ss,rbp)
+#  define context_rsi uc_mcontext->DU3_PREFIX(ss,rsi)
+#  define context_rdi uc_mcontext->DU3_PREFIX(ss,rdi)
+#  define context_r8  uc_mcontext->DU3_PREFIX(ss,r8)
+#  define context_r9  uc_mcontext->DU3_PREFIX(ss,r9)
+#  define context_r10 uc_mcontext->DU3_PREFIX(ss,r10)
+#  define context_r11 uc_mcontext->DU3_PREFIX(ss,r11)
+#  define context_r12 uc_mcontext->DU3_PREFIX(ss,r12)
+#  define context_r13 uc_mcontext->DU3_PREFIX(ss,r13)
+#  define context_r14 uc_mcontext->DU3_PREFIX(ss,r14)
+#  define context_r15 uc_mcontext->DU3_PREFIX(ss,r15)
+#  define context_flags uc_mcontext->DU3_PREFIX(ss,rflags)
+#  define context_trapno uc_mcontext->DU3_PREFIX(es,trapno)
+#  define context_err uc_mcontext->DU3_PREFIX(es,err)
+# else
+#  define context_pc context_eip
+#  define context_sp context_esp
+#  define context_fp context_ebp
+#  define context_eip uc_mcontext->DU3_PREFIX(ss,eip)
+#  define context_esp uc_mcontext->DU3_PREFIX(ss,esp)
+#  define context_eax uc_mcontext->DU3_PREFIX(ss,eax)
+#  define context_ebx uc_mcontext->DU3_PREFIX(ss,ebx)
+#  define context_ecx uc_mcontext->DU3_PREFIX(ss,ecx)
+#  define context_edx uc_mcontext->DU3_PREFIX(ss,edx)
+#  define context_ebp uc_mcontext->DU3_PREFIX(ss,ebp)
+#  define context_esi uc_mcontext->DU3_PREFIX(ss,esi)
+#  define context_edi uc_mcontext->DU3_PREFIX(ss,edi)
+#  define context_eflags uc_mcontext->DU3_PREFIX(ss,eflags)
+#  define context_trapno uc_mcontext->DU3_PREFIX(es,trapno)
+# endif
+#endif
+
+#ifdef __OpenBSD__
+# define context_trapno sc_trapno
+# ifdef AMD64
+#  define context_pc sc_rip
+#  define context_sp sc_rsp
+#  define context_fp sc_rbp
+#  define context_rip sc_rip
+#  define context_rsp sc_rsp
+#  define context_rbp sc_rbp
+#  define context_rax sc_rax
+#  define context_rbx sc_rbx
+#  define context_rcx sc_rcx
+#  define context_rdx sc_rdx
+#  define context_rsi sc_rsi
+#  define context_rdi sc_rdi
+#  define context_r8  sc_r8
+#  define context_r9  sc_r9
+#  define context_r10 sc_r10
+#  define context_r11 sc_r11
+#  define context_r12 sc_r12
+#  define context_r13 sc_r13
+#  define context_r14 sc_r14
+#  define context_r15 sc_r15
+#  define context_flags sc_rflags
+#  define context_err sc_err
+# else
+#  define context_pc sc_eip
+#  define context_sp sc_esp
+#  define context_fp sc_ebp
+#  define context_eip sc_eip
+#  define context_esp sc_esp
+#  define context_eax sc_eax
+#  define context_ebx sc_ebx
+#  define context_ecx sc_ecx
+#  define context_edx sc_edx
+#  define context_ebp sc_ebp
+#  define context_esi sc_esi
+#  define context_edi sc_edi
+#  define context_eflags sc_eflags
+#  define context_trapno sc_trapno
+# endif
+#endif
+
 address os::current_stack_pointer() {
   register void *esp __asm__ (SPELL_REG_SP);
   return (address) esp;
@@ -82,15 +217,15 @@ void os::initialize_thread() {
 }
 
 address os::Bsd::ucontext_get_pc(ucontext_t * uc) {
-  return (address)uc->uc_mcontext.gregs[REG_PC];
+  return (address)uc->context_pc;
 }
 
 intptr_t* os::Bsd::ucontext_get_sp(ucontext_t * uc) {
-  return (intptr_t*)uc->uc_mcontext.gregs[REG_SP];
+  return (intptr_t*)uc->context_sp;
 }
 
 intptr_t* os::Bsd::ucontext_get_fp(ucontext_t * uc) {
-  return (intptr_t*)uc->uc_mcontext.gregs[REG_FP];
+  return (intptr_t*)uc->context_fp;
 }
 
 // For Forte Analyzer AsyncGetCallTrace profiling support - thread
@@ -237,18 +372,18 @@ JVM_handle_bsd_signal(int sig,
     pc = (address) os::Bsd::ucontext_get_pc(uc);
 
     if (pc == (address) Fetch32PFI) { 
-       uc->uc_mcontext.gregs[REG_PC] = intptr_t(Fetch32Resume) ; 
+       uc->context_pc = intptr_t(Fetch32Resume) ;
        return 1 ;  
     }
 #ifdef AMD64
     if (pc == (address) FetchNPFI) { 
-       uc->uc_mcontext.gregs[REG_PC] = intptr_t (FetchNResume) ; 
+       uc->context_pc = intptr_t (FetchNResume) ;
        return 1 ; 
     } 
 #endif // AMD64
 
     // Handle ALL stack overflow variations here
-    if (sig == SIGSEGV) {
+    if (sig == SIGSEGV || sig == SIGBUS) {
       address addr = (address) info->si_addr;
 
       // check if fault address is within thread stack
@@ -270,6 +405,7 @@ JVM_handle_bsd_signal(int sig,
           // to handle_unexpected_exception way down below.
           thread->disable_stack_red_zone();
           tty->print_raw_cr("An irrecoverable stack overflow has occurred.");
+#ifndef _ALLBSD_SOURCE
         } else {
           // Accessing stack address below sp may cause SEGV if current
           // thread has MAP_GROWSDOWN stack. This should only happen when
@@ -285,6 +421,7 @@ JVM_handle_bsd_signal(int sig,
           } else {
              fatal("recursive segv. expanding stack.");
           }
+#endif
         }
       }
     }
@@ -293,9 +430,16 @@ JVM_handle_bsd_signal(int sig,
       // Java thread running in Java code => find exception handler if any
       // a fault inside compiled code, the interpreter, or a stub
 
-      if (sig == SIGSEGV && os::is_poll_address((address)info->si_addr)) {
+      if ((sig == SIGSEGV || sig == SIGBUS) && os::is_poll_address((address)info->si_addr)) {
         stub = SharedRuntime::get_poll_stub(pc);
+#if defined(__APPLE__) && !defined(AMD64)
+      // 32-bit Darwin reports a SIGBUS for nearly all memory access exceptions.
+      // Catching SIGBUS here prevents the implicit SIGBUS NULL check below from
+      // being called, so only do so if the implicit NULL check is not necessary.
+      } else if (sig == SIGBUS && MacroAssembler::needs_explicit_null_check((int)info->si_addr)) {
+#else
       } else if (sig == SIGBUS /* && info->si_code == BUS_OBJERR */) {
+#endif
 	// BugId 4454115: A read from a MappedByteBuffer can fault
 	// here if the underlying file has been truncated.
 	// Do not crash the VM in such a case.
@@ -316,6 +460,28 @@ JVM_handle_bsd_signal(int sig,
                                               pc, 
                                               SharedRuntime::
                                               IMPLICIT_DIVIDE_BY_ZERO);
+#ifdef __APPLE__
+      } else if (sig == SIGFPE && info->si_code == FPE_NOOP) {
+        int op = pc[0];
+
+        // Skip REX
+        if ((pc[0] & 0xf0) == 0x40) {
+          op = pc[1];
+        } else {
+          op = pc[0];
+        }
+
+        // Check for IDIV
+        if (op == 0xF7) {
+          stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime:: IMPLICIT_DIVIDE_BY_ZERO);
+        } else {
+          // TODO: handle more cases if we are using other x86 instructions
+          //   that can generate SIGFPE signal.
+          tty->print_cr("unknown opcode 0x%X with SIGFPE.", op);
+          fatal("please update this code.");
+        }
+#endif /* __APPLE__ */
+
 #else
       if (sig == SIGFPE /* && info->si_code == FPE_INTDIV */) {
         // HACK: si_code does not work on bsd 2.2.12-20!!!
@@ -343,7 +509,7 @@ JVM_handle_bsd_signal(int sig,
           fatal("please update this code.");
         }
 #endif // AMD64
-      } else if (sig == SIGSEGV &&
+      } else if ((sig == SIGSEGV || sig == SIGBUS) &&
                !MacroAssembler::needs_explicit_null_check((intptr_t)info->si_addr)) {
           // Determination of interpreter/vtable stub/compiled code null exception
           stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);
@@ -367,7 +533,7 @@ JVM_handle_bsd_signal(int sig,
     // process of write protecting the memory serialization page.
     // It write enables the page immediately after protecting it
     // so we can just return to retry the write.
-    if ((sig == SIGSEGV) &&
+    if ((sig == SIGSEGV || sig == SIGBUS) &&
         os::is_memory_serialize_page(thread, (address) info->si_addr)) {
       // Block current thread until the memory serialize page permission restored.
       os::block_on_serialize_page_trap();
@@ -388,7 +554,7 @@ JVM_handle_bsd_signal(int sig,
   // Furthermore, a false-positive should be harmless.
   if (UnguardOnExecutionViolation > 0 &&
       (sig == SIGSEGV || sig == SIGBUS) &&
-      uc->uc_mcontext.gregs[REG_TRAPNO] == trap_page_fault) {
+      uc->context_trapno == trap_page_fault) {
     int page_size = os::vm_page_size();
     address addr = (address) info->si_addr;
     address pc = os::Bsd::ucontext_get_pc(uc);
@@ -457,7 +623,7 @@ JVM_handle_bsd_signal(int sig,
     // save all thread context in case we need to restore it
     if (thread != NULL) thread->set_saved_exception_pc(pc);
 
-    uc->uc_mcontext.gregs[REG_PC] = (greg_t)stub;
+    uc->context_pc = (intptr_t)stub;
     return true;
   }
 
@@ -487,13 +653,24 @@ JVM_handle_bsd_signal(int sig,
   ShouldNotReachHere();
 }
 
+#ifdef _ALLBSD_SOURCE
+// From solaris_i486.s ported to bsd_i486.s
+extern "C" void fixcw();
+#endif
+
 void os::Bsd::init_thread_fpu_state(void) {
 #ifndef AMD64
+# ifdef _ALLBSD_SOURCE
+  // Set fpu to 53 bit precision. This happens too early to use a stub.
+  fixcw();
+# else
   // set fpu to 53 bit precision
   set_fpu_control_word(0x27f);
+# endif
 #endif // !AMD64
 }
 
+#ifndef _ALLBSD_SOURCE
 int os::Bsd::get_fpu_control_word(void) {
 #ifdef AMD64
   return 0;
@@ -509,11 +686,12 @@ void os::Bsd::set_fpu_control_word(int f
   _FPU_SETCW(fpu_control);
 #endif // !AMD64
 }
+#endif
 
 // Check that the bsd kernel version is 2.4 or higher since earlier
 // versions do not support SSE without patches.
 bool os::supports_sse() {
-#ifdef AMD64
+#if defined(AMD64) || defined(_ALLBSD_SOURCE)
   return true;
 #else
   struct utsname uts;
@@ -565,8 +743,11 @@ size_t os::Bsd::min_stack_allowed  =  (4
 
 #define GET_GS() ({int gs; __asm__ volatile("movw %%gs, %w0":"=q"(gs)); gs&0xffff;})
 
+#ifdef _ALLBSD_SOURCE
+bool os::Bsd::supports_variable_stack_size() { return true; }
+#else
 // Test if pthread library can support variable thread stack size. BsdThreads
-// in fixed stack mode allocates 2M fixed slot for each thread. BsdThreads 
+// in fixed stack mode allocates 2M fixed slot for each thread. BsdThreads
 // in floating stack mode and NPTL support variable stack size.
 bool os::Bsd::supports_variable_stack_size() {
   if (os::Bsd::is_NPTL()) {
@@ -597,6 +778,7 @@ bool os::Bsd::supports_variable_stack_si
     return (GET_GS() != 0);
   }
 }
+#endif
 #endif // AMD64
 
 // return default stack size for thr_type
@@ -650,6 +832,41 @@ size_t os::Bsd::default_guard_size(os::T
 //    pthread_attr_getstack()
 
 static void current_stack_region(address * bottom, size_t * size) {
+#ifdef __APPLE__
+  pthread_t self = pthread_self();
+  void *stacktop = pthread_get_stackaddr_np(self);
+  *size = pthread_get_stacksize_np(self);
+  *bottom = (address) stacktop - *size;
+#elif defined(__OpenBSD__)
+  stack_t ss;
+  int rslt = pthread_stackseg_np(pthread_self(), &ss);
+
+  if (rslt != 0)
+    fatal1("pthread_stackseg_np failed with err = %d", rslt);
+
+  *bottom = (address)((char *)ss.ss_sp - ss.ss_size);
+  *size   = ss.ss_size;
+#elif defined(_ALLBSD_SOURCE)
+  pthread_attr_t attr;
+
+  int rslt = pthread_attr_init(&attr);
+
+  // JVM needs to know exact stack location, abort if it fails
+  if (rslt != 0)
+    fatal1("pthread_attr_init failed with err = %d", rslt);
+
+  rslt = pthread_attr_get_np(pthread_self(), &attr);
+
+  if (rslt != 0)
+    fatal1("pthread_attr_get_np failed with err = %d", rslt);
+
+  if (pthread_attr_getstackaddr(&attr, (void **)bottom) != 0 ||
+    pthread_attr_getstacksize(&attr, size) != 0) {
+    fatal("Can not locate current stack attributes!");
+  }
+
+  pthread_attr_destroy(&attr);
+#else
   if (os::Bsd::is_initial_thread()) {
      // initial thread needs special handling because pthread_getattr_np()
      // may return bogus value.
@@ -676,6 +893,7 @@ static void current_stack_region(address
      pthread_attr_destroy(&attr);
 
   }
+#endif
   assert(os::current_stack_pointer() >= *bottom &&
          os::current_stack_pointer() < *bottom + *size, "just checking");
 }
@@ -704,46 +922,44 @@ void os::print_context(outputStream *st,
   ucontext_t *uc = (ucontext_t*)context;
   st->print_cr("Registers:");
 #ifdef AMD64
-  st->print(  "RAX=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RAX]);
-  st->print(", RBX=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RBX]);
-  st->print(", RCX=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RCX]);
-  st->print(", RDX=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RDX]);
+  st->print(  "RAX=" INTPTR_FORMAT, uc->context_rax);
+  st->print(", RBX=" INTPTR_FORMAT, uc->context_rbx);
+  st->print(", RCX=" INTPTR_FORMAT, uc->context_rcx);
+  st->print(", RDX=" INTPTR_FORMAT, uc->context_rdx);
   st->cr();
-  st->print(  "RSP=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RSP]);
-  st->print(", RBP=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RBP]);
-  st->print(", RSI=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RSI]);
-  st->print(", RDI=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RDI]);
+  st->print(  "RSP=" INTPTR_FORMAT, uc->context_rsp);
+  st->print(", RBP=" INTPTR_FORMAT, uc->context_rbp);
+  st->print(", RSI=" INTPTR_FORMAT, uc->context_rsi);
+  st->print(", RDI=" INTPTR_FORMAT, uc->context_rdi);
   st->cr();
-  st->print(  "R8 =" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_R8]);
-  st->print(", R9 =" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_R9]);
-  st->print(", R10=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_R10]);
-  st->print(", R11=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_R11]);
+  st->print(  "R8 =" INTPTR_FORMAT, uc->context_r8);
+  st->print(", R9 =" INTPTR_FORMAT, uc->context_r9);
+  st->print(", R10=" INTPTR_FORMAT, uc->context_r10);
+  st->print(", R11=" INTPTR_FORMAT, uc->context_r11);
   st->cr();
-  st->print(  "R12=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_R12]);
-  st->print(", R13=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_R13]);
-  st->print(", R14=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_R14]);
-  st->print(", R15=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_R15]);
+  st->print(  "R12=" INTPTR_FORMAT, uc->context_r12);
+  st->print(", R13=" INTPTR_FORMAT, uc->context_r13);
+  st->print(", R14=" INTPTR_FORMAT, uc->context_r14);
+  st->print(", R15=" INTPTR_FORMAT, uc->context_r15);
   st->cr();
-  st->print(  "RIP=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RIP]);
-  st->print(", EFL=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_EFL]);
-  st->print(", CSGSFS=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_CSGSFS]);
-  st->print(", ERR=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_ERR]);
+  st->print(  "RIP=" INTPTR_FORMAT, uc->context_rip);
+  st->print(", EFL=" INTPTR_FORMAT, uc->context_flags);
+  st->print(", ERR=" INTPTR_FORMAT, uc->context_err);
   st->cr();
-  st->print("  TRAPNO=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_TRAPNO]);
+  st->print("  TRAPNO=" INTPTR_FORMAT, uc->context_trapno);
 #else
-  st->print(  "EAX=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_EAX]);
-  st->print(", EBX=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_EBX]);
-  st->print(", ECX=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_ECX]);
-  st->print(", EDX=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_EDX]);
+  st->print(  "EAX=" INTPTR_FORMAT, uc->context_eax);
+  st->print(", EBX=" INTPTR_FORMAT, uc->context_ebx);
+  st->print(", ECX=" INTPTR_FORMAT, uc->context_ecx);
+  st->print(", EDX=" INTPTR_FORMAT, uc->context_edx);
   st->cr();
-  st->print(  "ESP=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_UESP]);
-  st->print(", EBP=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_EBP]);
-  st->print(", ESI=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_ESI]);
-  st->print(", EDI=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_EDI]);
+  st->print(  "ESP=" INTPTR_FORMAT, uc->context_esp);
+  st->print(", EBP=" INTPTR_FORMAT, uc->context_ebp);
+  st->print(", ESI=" INTPTR_FORMAT, uc->context_esi);
+  st->print(", EDI=" INTPTR_FORMAT, uc->context_edi);
   st->cr();
-  st->print(  "EIP=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_EIP]);
-  st->print(", CR2=" INTPTR_FORMAT, uc->uc_mcontext.cr2);
-  st->print(", EFLAGS=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_EFL]);
+  st->print(  "EIP=" INTPTR_FORMAT, uc->context_eip);
+  st->print(", EFLAGS=" INTPTR_FORMAT, uc->context_eflags);
 #endif // AMD64
   st->cr();
   st->cr();
diff -upr ../orig/hotspot/src/os_cpu/bsd_x86/vm/threadLS_bsd_x86.hpp ./hotspot/src/os_cpu/bsd_x86/vm/threadLS_bsd_x86.hpp
--- ../orig/hotspot/src/os_cpu/bsd_x86/vm/threadLS_bsd_x86.hpp	2009-05-04 18:32:15.000000000 -0400
+++ ./hotspot/src/os_cpu/bsd_x86/vm/threadLS_bsd_x86.hpp	2009-05-06 12:03:40.000000000 -0400
@@ -30,8 +30,10 @@
 #ifndef AMD64
   // map stack pointer to thread pointer - see notes in threadLS_bsd_x86.cpp
   #define SP_BITLENGTH  32
+#ifndef PAGE_SHIFT
   #define PAGE_SHIFT    12
   #define PAGE_SIZE     (1UL << PAGE_SHIFT)
+#endif
   static Thread* _sp_map[1UL << (SP_BITLENGTH - PAGE_SHIFT)];
 #endif // !AMD64
 
diff -upr ../orig/hotspot/src/os_cpu/bsd_x86/vm/vmStructs_bsd_x86.hpp ./hotspot/src/os_cpu/bsd_x86/vm/vmStructs_bsd_x86.hpp
--- ../orig/hotspot/src/os_cpu/bsd_x86/vm/vmStructs_bsd_x86.hpp	2009-05-04 18:32:15.000000000 -0400
+++ ./hotspot/src/os_cpu/bsd_x86/vm/vmStructs_bsd_x86.hpp	2009-05-06 12:04:27.000000000 -0400
@@ -34,7 +34,7 @@
   /******************************/                                                                                                   \
   /* Threads (NOTE: incomplete) */                                                                                                   \
   /******************************/                                                                                                   \
-  nonstatic_field(OSThread,                      _thread_id,                                      pid_t)                             \
+  nonstatic_field(OSThread,                      _thread_id,                                      pthread_t)                             \
   nonstatic_field(OSThread,                      _pthread_id,                                     pthread_t)                         \
   /* This must be the last entry, and must be present */                                                                             \
   last_entry()
diff -upr ../orig/hotspot/src/share/vm/adlc/adlc.hpp ./hotspot/src/share/vm/adlc/adlc.hpp
--- ../orig/hotspot/src/share/vm/adlc/adlc.hpp	2009-01-27 15:41:01.000000000 -0500
+++ ./hotspot/src/share/vm/adlc/adlc.hpp	2009-05-04 17:37:15.000000000 -0400
@@ -76,9 +76,9 @@ typedef unsigned int uintptr_t;
 #endif
 #endif // _WIN32
 
-#ifdef LINUX
+#if defined(LINUX) || defined(_ALLBSD_SOURCE)
   #include <inttypes.h>
-#endif // LINUX
+#endif // LINUX || _ALLBSD_SOURCE
 
 // Macros 
 #define uint32 unsigned int
diff -upr ../orig/hotspot/src/share/vm/gc_implementation/includeDB_gc_concurrentMarkSweep ./hotspot/src/share/vm/gc_implementation/includeDB_gc_concurrentMarkSweep
--- ../orig/hotspot/src/share/vm/gc_implementation/includeDB_gc_concurrentMarkSweep	2009-01-27 15:41:01.000000000 -0500
+++ ./hotspot/src/share/vm/gc_implementation/includeDB_gc_concurrentMarkSweep	2009-05-04 17:37:17.000000000 -0400
@@ -28,6 +28,7 @@ binaryTreeDictionary.cpp                
 binaryTreeDictionary.cpp                binaryTreeDictionary.hpp
 binaryTreeDictionary.cpp                globals.hpp
 binaryTreeDictionary.cpp                ostream.hpp
+binaryTreeDictionary.cpp                space.inline.hpp
 
 binaryTreeDictionary.hpp                freeBlockDictionary.hpp
 binaryTreeDictionary.hpp                freeList.hpp
diff -upr ../orig/hotspot/src/share/vm/gc_implementation/includeDB_gc_parNew ./hotspot/src/share/vm/gc_implementation/includeDB_gc_parNew
--- ../orig/hotspot/src/share/vm/gc_implementation/includeDB_gc_parNew	2009-01-27 15:41:01.000000000 -0500
+++ ./hotspot/src/share/vm/gc_implementation/includeDB_gc_parNew	2009-05-04 17:37:17.000000000 -0400
@@ -30,6 +30,8 @@ asParNewGeneration.cpp			cmsAdaptiveSize
 asParNewGeneration.cpp                  cmsGCAdaptivePolicyCounters.hpp
 asParNewGeneration.cpp			defNewGeneration.inline.hpp
 asParNewGeneration.cpp			oop.pcgc.inline.hpp
+asParNewGeneration.cpp                  markOop.inline.hpp
+asParNewGeneration.cpp                  markSweep.inline.hpp
 asParNewGeneration.cpp			parNewGeneration.hpp
 asParNewGeneration.cpp                  referencePolicy.hpp
 
@@ -39,7 +41,7 @@ parCardTableModRefBS.cpp                
 parCardTableModRefBS.cpp                java.hpp
 parCardTableModRefBS.cpp                mutexLocker.hpp
 parCardTableModRefBS.cpp                sharedHeap.hpp
-parCardTableModRefBS.cpp                space.hpp
+parCardTableModRefBS.cpp                space.inline.hpp
 parCardTableModRefBS.cpp                universe.hpp
 parCardTableModRefBS.cpp                virtualspace.hpp
 
diff -upr ../orig/hotspot/src/share/vm/gc_implementation/includeDB_gc_parallelScavenge ./hotspot/src/share/vm/gc_implementation/includeDB_gc_parallelScavenge
--- ../orig/hotspot/src/share/vm/gc_implementation/includeDB_gc_parallelScavenge	2009-01-27 15:41:01.000000000 -0500
+++ ./hotspot/src/share/vm/gc_implementation/includeDB_gc_parallelScavenge	2009-05-04 17:37:15.000000000 -0400
@@ -302,6 +302,8 @@ psPermGen.cpp                           
 psPermGen.cpp                           psMarkSweepDecorator.hpp
 psPermGen.cpp                           psParallelCompact.hpp
 psPermGen.cpp                           psPermGen.hpp
+psPermGen.cpp                           markOop.inline.hpp
+psPermGen.cpp                           markSweep.inline.hpp
 
 psPermGen.hpp                           psOldGen.hpp
 
diff -upr ../orig/hotspot/src/share/vm/includeDB_compiler2 ./hotspot/src/share/vm/includeDB_compiler2
--- ../orig/hotspot/src/share/vm/includeDB_compiler2	2009-01-27 15:41:02.000000000 -0500
+++ ./hotspot/src/share/vm/includeDB_compiler2	2009-05-04 17:37:15.000000000 -0400
@@ -140,6 +140,7 @@ c2_globals_<os_family>.hpp              
 c2_globals_<os_family>.hpp              macros.hpp
 
 c2_init_<arch>.cpp                      compile.hpp
+c2_init_<arch>.cpp                      node.hpp
 
 c2compiler.cpp                          ad_<arch_model>.hpp
 c2compiler.cpp                          c2compiler.hpp
@@ -833,6 +834,7 @@ parseHelper.cpp                         
 phase.cpp                               compile.hpp
 phase.cpp                               compileBroker.hpp
 phase.cpp                               nmethod.hpp
+phase.cpp                               node.hpp
 phase.cpp                               phase.hpp
 
 phase.hpp                               port.hpp
diff -upr ../orig/hotspot/src/share/vm/includeDB_core ./hotspot/src/share/vm/includeDB_core
--- ../orig/hotspot/src/share/vm/includeDB_core	2009-01-27 15:41:02.000000000 -0500
+++ ./hotspot/src/share/vm/includeDB_core	2009-05-04 17:37:15.000000000 -0400
@@ -476,7 +476,7 @@ cardTableModRefBS.cpp                   
 cardTableModRefBS.cpp                   java.hpp
 cardTableModRefBS.cpp                   mutexLocker.hpp
 cardTableModRefBS.cpp                   sharedHeap.hpp
-cardTableModRefBS.cpp                   space.hpp
+cardTableModRefBS.cpp                   space.inline.hpp
 cardTableModRefBS.cpp                   universe.hpp
 cardTableModRefBS.cpp                   virtualspace.hpp
 
@@ -1978,7 +1978,7 @@ instanceKlass.cpp                       
 instanceKlass.cpp                       vmSymbols.hpp
 
 instanceKlass.hpp                       accessFlags.hpp
-instanceKlass.hpp                       bitMap.hpp
+instanceKlass.hpp                       bitMap.inline.hpp
 instanceKlass.hpp                       constMethodOop.hpp
 instanceKlass.hpp                       constantPoolOop.hpp
 instanceKlass.hpp                       handles.hpp
diff -upr ../orig/hotspot/src/share/vm/includeDB_features ./hotspot/src/share/vm/includeDB_features
--- ../orig/hotspot/src/share/vm/includeDB_features	2009-01-27 15:41:02.000000000 -0500
+++ ./hotspot/src/share/vm/includeDB_features	2009-05-04 17:37:15.000000000 -0400
@@ -58,6 +58,8 @@ dump.cpp                                
 
 dump_<arch_model>.cpp                   assembler_<arch_model>.inline.hpp
 dump_<arch_model>.cpp                   compactingPermGenGen.hpp
+dump_<arch_model>.cpp                   generation.inline.hpp
+dump_<arch_model>.cpp                   space.inline.hpp
 
 forte.cpp                               collectedHeap.inline.hpp
 forte.cpp                               debugInfoRec.hpp
diff -upr ../orig/hotspot/src/share/vm/interpreter/bytecodeTracer.cpp ./hotspot/src/share/vm/interpreter/bytecodeTracer.cpp
--- ../orig/hotspot/src/share/vm/interpreter/bytecodeTracer.cpp	2009-01-27 15:41:02.000000000 -0500
+++ ./hotspot/src/share/vm/interpreter/bytecodeTracer.cpp	2009-05-04 17:37:15.000000000 -0400
@@ -77,7 +77,7 @@ class BytecodePrinter: public BytecodeCl
       // the incoming method.  We could lose a line of trace output.
       // This is acceptable in a debug-only feature.
       st->cr();
-      st->print("[%d] ", (int) Thread::current()->osthread()->thread_id());
+      st->print("[%ld] ", (long) Thread::current()->osthread()->thread_id());
       method->print_name(st);
       st->cr();
       _current_method = method();
@@ -90,7 +90,7 @@ class BytecodePrinter: public BytecodeCl
       code = Bytecodes::code_at(bcp);
     }
     int bci = bcp - method->code_base();
-    st->print("[%d] ", (int) Thread::current()->osthread()->thread_id());
+    st->print("[%ld] ", (long) Thread::current()->osthread()->thread_id());
     if (Verbose) {
       st->print("%8d  %4d  " INTPTR_FORMAT " " INTPTR_FORMAT " %s", 
 	   BytecodeCounter::counter_value(), bci, tos, tos2, Bytecodes::name(code));
diff -upr ../orig/hotspot/src/share/vm/prims/forte.cpp ./hotspot/src/share/vm/prims/forte.cpp
--- ../orig/hotspot/src/share/vm/prims/forte.cpp	2009-01-27 15:41:03.000000000 -0500
+++ ./hotspot/src/share/vm/prims/forte.cpp	2009-05-04 17:37:15.000000000 -0400
@@ -872,6 +872,11 @@ void AsyncGetCallTrace(ASGCT_CallTrace *
 // Method to let libcollector know about a dynamically loaded function.
 // Because it is weakly bound, the calls become NOP's when the library
 // isn't present.
+#ifdef __APPLE__
+// XXXDARWIN: Link errors occur even when __attribute__((weak_import))
+// is added
+#define collector_func_load(x0,x1,x2,x3,x4,x5,x6) (0)
+#else
 void    collector_func_load(char* name,
                             void* null_argument_1,
                             void* null_argument_2,
@@ -882,6 +887,7 @@ void    collector_func_load(char* name,
 #pragma weak collector_func_load
 #define collector_func_load(x0,x1,x2,x3,x4,x5,x6) \
         ( collector_func_load ? collector_func_load(x0,x1,x2,x3,x4,x5,x6),0 : 0 )
+#endif // __APPLE__
 #endif // !_WINDOWS
 
 } // end extern "C"
diff -upr ../orig/hotspot/src/share/vm/runtime/globals.hpp ./hotspot/src/share/vm/runtime/globals.hpp
--- ../orig/hotspot/src/share/vm/runtime/globals.hpp	2009-01-27 15:41:03.000000000 -0500
+++ ./hotspot/src/share/vm/runtime/globals.hpp	2009-05-06 12:07:35.000000000 -0400
@@ -294,7 +294,7 @@ class CommandLineFlags {
   /* UseMembar is theoretically a temp flag used for memory barrier         \
    * removal testing.  It was supposed to be removed before FCS but has     \
    * been re-added (see 6401008) */                                         \
-  product(bool, UseMembar, false,                                           \
+  product(bool, UseMembar, true,                                           \
           "(Unstable) Issues membars on thread state transitions")          \
                                                                             \
   product(bool, PrintCommandLineFlags, false,                               \
diff -upr ../orig/hotspot/src/share/vm/runtime/os.cpp ./hotspot/src/share/vm/runtime/os.cpp
--- ../orig/hotspot/src/share/vm/runtime/os.cpp	2009-01-27 15:41:03.000000000 -0500
+++ ./hotspot/src/share/vm/runtime/os.cpp	2009-05-04 17:37:17.000000000 -0400
@@ -155,7 +155,11 @@ char* os::iso8601_time(char* buffer, siz
   }
   // Save the results of localtime
   const struct tm time_struct = *time_struct_temp;
+#if defined(_ALLBSD_SOURCE)
+  const time_t zone = (time_t) time_struct_temp->tm_gmtoff;
+#else
   const time_t zone = timezone;
+#endif
   
   // If daylight savings time is in effect, 
   // we are 1 hour East of our time zone
diff -upr ../orig/hotspot/src/share/vm/runtime/vm_version.cpp ./hotspot/src/share/vm/runtime/vm_version.cpp
--- ../orig/hotspot/src/share/vm/runtime/vm_version.cpp	2009-01-27 15:41:03.000000000 -0500
+++ ./hotspot/src/share/vm/runtime/vm_version.cpp	2009-05-04 17:37:15.000000000 -0400
@@ -141,7 +141,8 @@ const char* Abstract_VM_Version::vm_rele
 
 #define OS       LINUX_ONLY("linux")             \
                  WINDOWS_ONLY("windows")         \
-                 SOLARIS_ONLY("solaris")
+                 SOLARIS_ONLY("solaris")         \
+                 BSD_ONLY("bsd")
 
 #define CPU      IA32_ONLY("x86")                \
                  IA64_ONLY("ia64")               \
diff -upr ../orig/hotspot/src/share/vm/utilities/globalDefinitions_gcc.hpp ./hotspot/src/share/vm/utilities/globalDefinitions_gcc.hpp
--- ../orig/hotspot/src/share/vm/utilities/globalDefinitions_gcc.hpp	2009-01-27 15:41:03.000000000 -0500
+++ ./hotspot/src/share/vm/utilities/globalDefinitions_gcc.hpp	2009-05-04 17:37:17.000000000 -0400
@@ -74,12 +74,25 @@
 # include <sys/procfs.h>
 # endif
 
-#ifdef LINUX
+#if defined(LINUX) || defined(_ALLBSD_SOURCE)
 #include <inttypes.h>
 #include <signal.h>
+#ifndef __OpenBSD__
 #include <ucontext.h>
+#endif
+#ifdef __APPLE__
+  #include <AvailabilityMacros.h>
+  #if (MAC_OS_X_VERSION_MAX_ALLOWED <= MAC_OS_X_VERSION_10_4)
+    // Mac OS X 10.4 defines EFL_AC and EFL_ID,
+    // which conflict with hotspot variable names.
+    //
+    // This has been fixed in Mac OS X 10.5.
+    #undef EFL_AC
+    #undef EFL_ID
+  #endif
+#endif
 #include <sys/time.h>
-#endif // LINUX
+#endif // LINUX || _ALLBSD_SOURCE
 
 // 4810578: varargs unsafe on 32-bit integer/64-bit pointer architectures
 // When __cplusplus is defined, NULL is defined as 0 (32-bit constant) in
@@ -115,17 +128,20 @@
 // pointer is stored as integer value.  On some platforms, sizeof(intptr_t) >
 // sizeof(void*), so here we want something which is integer type, but has the
 // same size as a pointer.
-#ifdef LINUX
+#ifdef __GNUC__
   #ifdef _LP64
     #define NULL_WORD  0L
   #else
-    #define NULL_WORD  0
+    // Cast 0 to intptr_t rather than int32_t since they are not the same type
+    // on platforms such as Mac OS X.
+    #define NULL_WORD  ((intptr_t)0)
   #endif
 #else
   #define NULL_WORD  NULL
 #endif
 
-#ifndef	LINUX
+
+#if !defined(LINUX) && !defined(_ALLBSD_SOURCE)
 // Compiler-specific primitive types
 typedef unsigned short     uint16_t;
 #ifndef _UINT32_T
@@ -145,7 +161,7 @@ typedef unsigned int		uintptr_t;
 // prior definition of intptr_t, and add "&& !defined(XXX)" above.
 #endif // _SYS_INT_TYPES_H
 
-#endif // !LINUX
+#endif // !LINUX && !_ALLBSD_SOURCE
 
 // Additional Java basic types
 
@@ -229,7 +245,9 @@ inline int g_isnan(float  f) { return is
 inline int g_isnan(float  f) { return isnand(f); }
 #endif
 inline int g_isnan(double f) { return isnand(f); }
-#elif LINUX
+#elif defined(__APPLE__)
+inline int g_isnan(double f) { return isnan(f); }
+#elif defined(LINUX) || defined(_ALLBSD_SOURCE)
 inline int g_isnan(float  f) { return isnanf(f); }
 inline int g_isnan(double f) { return isnan(f); }
 #else
diff -upr ../orig/hotspot/src/share/vm/utilities/macros.hpp ./hotspot/src/share/vm/utilities/macros.hpp
--- ../orig/hotspot/src/share/vm/utilities/macros.hpp	2009-01-27 15:41:03.000000000 -0500
+++ ./hotspot/src/share/vm/utilities/macros.hpp	2009-05-04 17:37:17.000000000 -0400
@@ -147,6 +147,16 @@
 #define NOT_WINDOWS(code) code
 #endif
 
+#if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__APPLE__)
+#define BSD_ONLY(code) code
+#define NOT_BSD(code)
+#else
+#define BSD_ONLY(code)
+#define NOT_BSD(code) code
+#endif
+
+
+
 #ifdef IA32
 #define IA32_ONLY(code) code
 #define NOT_IA32(code)
diff -upr ../orig/hotspot/src/share/vm/utilities/ostream.cpp ./hotspot/src/share/vm/utilities/ostream.cpp
--- ../orig/hotspot/src/share/vm/utilities/ostream.cpp	2009-01-27 15:41:03.000000000 -0500
+++ ./hotspot/src/share/vm/utilities/ostream.cpp	2009-05-04 17:37:15.000000000 -0400
@@ -780,7 +780,7 @@ bufferedStream::~bufferedStream() {
 
 #ifndef PRODUCT
 
-#if defined(SOLARIS) || defined(LINUX)
+#if defined(SOLARIS) || defined(LINUX) || defined(_ALLBSD_SOURCE)
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <netinet/in.h>
diff -upr ../orig/hotspot/src/share/vm/utilities/vmError.cpp ./hotspot/src/share/vm/utilities/vmError.cpp
--- ../orig/hotspot/src/share/vm/utilities/vmError.cpp	2009-01-27 15:41:04.000000000 -0500
+++ ./hotspot/src/share/vm/utilities/vmError.cpp	2009-05-04 17:37:17.000000000 -0400
@@ -34,13 +34,18 @@ const char *env_list[] = {
   "JAVA_HOME", "JRE_HOME", "JAVA_TOOL_OPTIONS", "_JAVA_OPTIONS", "CLASSPATH", 
   "JAVA_COMPILER", "PATH", "USERNAME",
 
-  // Env variables that are defined on Solaris/Linux
+  // Env variables that are defined on Solaris/Linux/BSD
   "LD_LIBRARY_PATH", "LD_PRELOAD", "SHELL", "DISPLAY", 
   "HOSTTYPE", "OSTYPE", "ARCH", "MACHTYPE",
 
   // defined on Linux
   "LD_ASSUME_KERNEL", "_JAVA_SR_SIGNUM",
 
+  // defined on Darwin
+  "DYLD_LIBRARY_PATH", "DYLD_FALLBACK_LIBRARY_PATH",
+  "DYLD_FRAMEWORK_PATH", "DYLD_FALLBACK_FRAMEWORK_PATH",
+  "DYLD_INSERT_LIBRARIES",
+
   // defined on Windows
   "OS", "PROCESSOR_IDENTIFIER", "_ALT_JAVA_HOME_DIR",
 
@@ -673,6 +678,11 @@ void VMError::report_and_die() {
     reset_signal_handlers();
 
   } else {
+    // If UseOsErrorReporting we call this for each level of the call stack
+    // while searching for the exception handler.  Only the first level needs
+    // to be reported.
+    if (UseOSErrorReporting && log_done) return;
+
     // This is not the first error, see if it happened in a different thread
     // or in the same thread during error reporting.
     if (first_error_tid != mytid) {
@@ -793,7 +803,7 @@ void VMError::report_and_die() {
     const char* ptr = OnError;
     while ((cmd = next_OnError_command(buffer, sizeof(buffer), &ptr)) != NULL){
       out.print_raw   ("#   Executing ");
-#if defined(LINUX)
+#if defined(LINUX) || defined(_ALLBSD_SOURCE)
       out.print_raw   ("/bin/sh -c ");
 #elif defined(SOLARIS)
       out.print_raw   ("/usr/bin/sh -c ");
diff -upr ../orig/jdk/make/com/sun/java/pack/Makefile ./jdk/make/com/sun/java/pack/Makefile
--- ../orig/jdk/make/com/sun/java/pack/Makefile	2009-01-27 15:44:38.000000000 -0500
+++ ./jdk/make/com/sun/java/pack/Makefile	2009-05-04 17:37:15.000000000 -0400
@@ -61,6 +61,7 @@ vpath %.cpp $(SHARE_SRC)/native/$(PKGDIR
 
 
 ifeq ($(STANDALONE),true)
+ ifneq ($(SYSTEM_ZLIB),true)
   ZIPOBJDIR = $(OUTPUTDIR)/tmp/sun/java.util.zip/zip/$(OBJDIRNAME)
 
   ZIPOBJS =  $(ZIPOBJDIR)/zcrc32.$(OBJECT_SUFFIX) \
@@ -78,6 +79,10 @@ ifeq ($(STANDALONE),true)
   ZINCLUDE=-I$(SHARE_SRC)/native/java/util/zip/zlib-1.1.3
   OTHER_CXXFLAGS += $(ZINCLUDE)
   LDDFLAGS += $(ZIPOBJS)
+ else
+  LDDFLAGS += -lz
+  OTHER_CXXFLAGS += -DSYSTEM_ZLIB
+ endif
 else
   OTHER_CXXFLAGS += -DNO_ZLIB -DUNPACK_JNI
   OTHER_LDLIBS += $(JVMLIB)
@@ -102,7 +107,11 @@ ifeq ($(PLATFORM), windows) 
   COMPILER_WARNINGS_FATAL=false
 else
   LDOUTPUT = -o #Have a space 
+ifeq ($(PLATFORM), bsd)
+  LDDFLAGS += -pthread
+else
   LDDFLAGS += -lc
+endif
   OTHER_LDLIBS  += $(LIBCXX)
 # setup the list of libraries to link in...
 ifeq ($(PLATFORM), linux)
diff -upr ../orig/jdk/make/com/sun/security/auth/module/Makefile ./jdk/make/com/sun/security/auth/module/Makefile
--- ../orig/jdk/make/com/sun/security/auth/module/Makefile	2009-01-27 15:44:38.000000000 -0500
+++ ./jdk/make/com/sun/security/auth/module/Makefile	2009-05-04 17:37:15.000000000 -0400
@@ -70,7 +70,7 @@ ifeq ($(PLATFORM), solaris)
   include FILES_c_solaris.gmk
 endif # solaris
 
-ifeq ($(PLATFORM), linux)
+ifneq (,$(findstring $(PLATFORM), linux bsd))
   LIBRARY = jaas_unix
   include FILES_export_unix.gmk
   include FILES_c_unix.gmk
diff -upr ../orig/jdk/make/com/sun/tools/attach/FILES_c.gmk ./jdk/make/com/sun/tools/attach/FILES_c.gmk
--- ../orig/jdk/make/com/sun/tools/attach/FILES_c.gmk	2009-01-27 15:44:38.000000000 -0500
+++ ./jdk/make/com/sun/tools/attach/FILES_c.gmk	2009-05-04 17:37:15.000000000 -0400
@@ -39,4 +39,7 @@ FILES_c = \
 	LinuxVirtualMachine.c
 endif
 
-
+ifeq ($(PLATFORM),bsd)
+FILES_c = \
+	BsdVirtualMachine.c
+endif
diff -upr ../orig/jdk/make/com/sun/tools/attach/FILES_java.gmk ./jdk/make/com/sun/tools/attach/FILES_java.gmk
--- ../orig/jdk/make/com/sun/tools/attach/FILES_java.gmk	2009-01-27 15:44:38.000000000 -0500
+++ ./jdk/make/com/sun/tools/attach/FILES_java.gmk	2009-05-04 17:37:15.000000000 -0400
@@ -43,6 +43,11 @@ FILES_java += \
 	sun/tools/attach/LinuxAttachProvider.java
 endif
 
+ifeq ($(PLATFORM), bsd)
+FILES_java += \
+	$(TARGDIR)/sun/tools/attach/BsdAttachProvider.java
+endif
+
 #
 # Files that need to be copied
 #
diff -upr ../orig/jdk/make/common/Defs-bsd.gmk ./jdk/make/common/Defs-bsd.gmk
--- ../orig/jdk/make/common/Defs-bsd.gmk	2009-05-04 18:32:16.000000000 -0400
+++ ./jdk/make/common/Defs-bsd.gmk	2009-05-04 17:37:15.000000000 -0400
@@ -43,12 +43,6 @@
 # Get shared JDK settings
 include $(JDK_MAKE_SHARED_DIR)/Defs.gmk
 
-# Part of INCREMENTAL_BUILD mechanism.
-#   Compiler emits things like:  path/file.o: file.h
-#   We want something like: relative_path/file.o relative_path/file.d: file.h
-CC_DEPEND	 = -MM
-CC_DEPEND_FILTER = $(SED) -e 's!$*\.$(OBJECT_SUFFIX)!$(dir $@)& $(dir $@)$*.$(DEPEND_SUFFIX)!g'
-
 ifndef PLATFORM_SRC
   PLATFORM_SRC = $(BUILDDIR)/../src/solaris
 endif # PLATFORM_SRC
@@ -61,7 +55,7 @@ ifndef OPENJDK
 endif
 
 # platform specific include files
-PLATFORM_INCLUDE_NAME = $(PLATFORM)
+PLATFORM_INCLUDE_NAME = $(OS_NAME)
 PLATFORM_INCLUDE      = $(INCLUDEDIR)/$(PLATFORM_INCLUDE_NAME)
 
 # suffix used for make dependencies files.
@@ -104,6 +98,10 @@ endif
 #    as the default.
 CFLAGS_REQUIRED_amd64   += -fno-omit-frame-pointer -D_LITTLE_ENDIAN
 CFLAGS_REQUIRED_i586    += -fno-omit-frame-pointer -D_LITTLE_ENDIAN
+ifeq ($(OS_VENDOR),Apple)
+  # 16-byte stack re-alignment on 32-bit Darwin
+  CFLAGS_REQUIRED_i586 += -mstackrealign
+endif
 CFLAGS_REQUIRED_ia64    += -fno-omit-frame-pointer -D_LITTLE_ENDIAN
 CFLAGS_REQUIRED_sparcv9 += -m64 -mcpu=v9
 LDFLAGS_COMMON_sparcv9  += -m64 -mcpu=v9
@@ -178,7 +176,7 @@ ifeq ($(FASTDEBUG), true)
   CXXFLAGS_DBG	+= $(CC_LOWER_OPT)
 endif
 
-CPPFLAGS_COMMON = -D$(ARCH) -DARCH='"$(ARCH)"' -DLINUX $(VERSION_DEFINES) \
+CPPFLAGS_COMMON = -D$(ARCH) -DARCH='"$(ARCH)"' -D_ALLBSD_SOURCE $(VERSION_DEFINES) \
 		  -D_LARGEFILE64_SOURCE -D_GNU_SOURCE -D_REENTRANT
 
 ifeq ($(ARCH_DATA_MODEL), 64)
@@ -188,33 +186,15 @@ endif
 CPPFLAGS_OPT    = 
 CPPFLAGS_DBG    = -DDEBUG
 
-ifdef LIBRARY
-  # Libraries need to locate other libraries at runtime, and you can tell
-  #   a library where to look by way of the dynamic runpaths (RPATH or RUNPATH)
-  #   buried inside the .so. The $ORIGIN says to look relative to where
-  #   the library itself is and it can be followed with relative paths from
-  #   that. By default we always look in $ORIGIN, optionally we add relative
-  #   paths if the Makefile sets LD_RUNPATH_EXTRAS to those relative paths.
-  #   On Bsd we add a flag -z origin, not sure if this is necessary, but 
-  #   doesn't seem to hurt.
-  #   The environment variable LD_LIBRARY_PATH will over-ride these runpaths.
-  #   Try: 'readelf -d lib*.so' to see these settings in a library.
-  #
-  LDFLAGS_COMMON += -Xlinker -z -Xlinker origin -Xlinker -rpath -Xlinker \$$ORIGIN
-  LDFLAGS_COMMON += $(LD_RUNPATH_EXTRAS:%=-Xlinker -z -Xlinker origin -Xlinker -rpath -Xlinker \$$ORIGIN/%)
-endif
-
-EXTRA_LIBS += -lc
-
-LDFLAGS_DEFS_OPTION  = -z defs
-LDFLAGS_COMMON  += $(LDFLAGS_DEFS_OPTION)
-
 #
 # -L paths for finding and -ljava
 #
-LDFLAGS_OPT     = -Xlinker -O1
 LDFLAGS_COMMON += -L$(LIBDIR)/$(LIBARCH)
+
+ifneq ($(OS_VENDOR), Apple)
+LDFLAGS_OPT     = -Xlinker -O1
 LDFLAGS_COMMON += -Wl,-soname=$(LIB_PREFIX)$(LIBRARY).$(LIBRARY_SUFFIX)
+endif
 
 #
 # -static-libgcc is a gcc-3 flag to statically link libgcc, gcc-2.9x always
@@ -235,8 +215,8 @@ AUTOMATIC_PCH_OPTION = 
 #
 ifeq ($(VARIANT), OPT)
   ifneq ($(NO_STRIP), true)
-    # Debug 'strip -g' leaves local function Elf symbols (better stack traces)
-    POST_STRIP_PROCESS = $(STRIP) -g
+    # Debug 'strip -S' leaves local function Elf symbols (better stack traces)
+    POST_STRIP_PROCESS = $(STRIP) -S
   endif
 endif
 
@@ -245,13 +225,9 @@ endif
 #
 LD_MAPFILE_FLAG = -Xlinker --version-script -Xlinker
 
-#
-# Support for Quantify.
-#
-ifdef QUANTIFY
-QUANTIFY_CMD = quantify
-QUANTIFY_OPTIONS = -cache-dir=/tmp/quantify -always-use-cache-dir=yes
-LINK_PRE_CMD = $(QUANTIFY_CMD) $(QUANTIFY_OPTIONS)
+# Darwin does not support linker map files.
+ifeq ($(OS_VENDOR), Apple)
+LDNOMAP=true
 endif
 
 #
@@ -280,7 +256,9 @@ override HAVE_ALTZONE            = false
 override HAVE_FILIOH             = false
 override HAVE_GETHRTIME          = false
 override HAVE_GETHRVTIME         = false
+ifeq ($(OS_VENDOR),Apple)
 override HAVE_SIGIGNORE          = true
+endif
 override LEX_LIBRARY             = -lfl
 ifeq ($(STATIC_CXX),true)
 override LIBCXX                  = -Wl,-Bstatic -lstdc++ -lgcc -Wl,-Bdynamic
@@ -291,13 +269,9 @@ override LIBPOSIX4               =
 override LIBSOCKET               =
 override LIBTHREAD               =
 override MOOT_PRIORITIES         = true
-override NO_INTERRUPTIBLE_IO     = true
-override OPENWIN_HOME            = /usr/X11R6
-ifeq ($(ARCH), amd64)
-override OPENWIN_LIB             = $(OPENWIN_HOME)/lib64
-else
+override NO_INTERRUPTIBLE_IO     = false
+override OPENWIN_HOME            = $(X11_PATH)
 override OPENWIN_LIB             = $(OPENWIN_HOME)/lib
-endif
 override OTHER_M4FLAGS           = -D__GLIBC__ -DGNU_ASSEMBLER
 override SUN_CMM_SUBDIR          =
 override THREADS_FLAG            = native
@@ -318,6 +292,14 @@ override USE_EXECNAME            = true
 # DPS (Displayable PostScript) is available on Solaris machines
 HAVE_DPS = no
 
+ifeq ($(OS_VENDOR), FreeBSD)
+  SYSTEM_ZLIB = true
+endif
+
+ifeq ($(OS_VENDOR), OpenBSD)
+  SYSTEM_ZLIB = true
+endif
+
 #
 # Japanese manpages
 #
diff -upr ../orig/jdk/make/common/Defs-linux.gmk ./jdk/make/common/Defs-linux.gmk
--- ../orig/jdk/make/common/Defs-linux.gmk	2009-01-27 15:44:38.000000000 -0500
+++ ./jdk/make/common/Defs-linux.gmk	2009-05-04 17:37:15.000000000 -0400
@@ -292,7 +292,7 @@ override LIBSOCKET               =
 override LIBTHREAD               =
 override MOOT_PRIORITIES         = true
 override NO_INTERRUPTIBLE_IO     = true
-override OPENWIN_HOME            = /usr/X11R6
+override OPENWIN_HOME            = $(X11_PATH)
 ifeq ($(ARCH), amd64)
 override OPENWIN_LIB             = $(OPENWIN_HOME)/lib64
 else
diff -upr ../orig/jdk/make/common/Defs.gmk ./jdk/make/common/Defs.gmk
--- ../orig/jdk/make/common/Defs.gmk	2009-01-27 15:44:38.000000000 -0500
+++ ./jdk/make/common/Defs.gmk	2009-05-04 17:37:15.000000000 -0400
@@ -188,6 +188,24 @@ else
 _OUTPUTDIR=$(JDK_TOPDIR)/build/$(PLATFORM)-$(ARCH)
 endif
 
+ifneq ($(PLATFORM), windows)
+  ifdef ALT_X11_PATH
+    X11_PATH = $(ALT_X11_PATH)
+  else
+    X11_PATH = /usr/X11R6
+  endif 
+
+  ifdef ALT_PACKAGE_PATH
+    PACKAGE_PATH = $(ALT_PACKAGE_PATH)
+  else
+    ifeq ($(PLATFORM), linux)
+      PACKAGE_PATH = /usr
+    else
+      PACKAGE_PATH = /usr/local
+    endif
+  endif
+endif
+
 #
 # Get platform definitions
 #
@@ -223,6 +241,7 @@ DEVTOOLS_FT_DIR_EXISTS = $(shell \
 
   ifdef ALT_FREETYPE_LIB_PATH
     FREETYPE_LIB_PATH = $(ALT_FREETYPE_LIB_PATH)
+    USING_SYSTEM_FT_LIB=true
   else
     ifeq ($(DEVTOOLS_FT_DIR_EXISTS), true)
       FREETYPE_LIB_PATH = $(DEVTOOLS_FT_DIR)/lib
@@ -287,6 +306,10 @@ ifdef PROGRAM
     LDLIBS_COMMON = -ldl
   endif
 
+  ifeq ($(PLATFORM), bsd)
+    LDLIBS_COMMON = -pthread
+  endif
+
 endif # PROGRAM
 
 LDLIBS_COMMON += $(EXTRA_LIBS)
diff -upr ../orig/jdk/make/common/Program.gmk ./jdk/make/common/Program.gmk
--- ../orig/jdk/make/common/Program.gmk	2009-01-27 15:44:38.000000000 -0500
+++ ./jdk/make/common/Program.gmk	2009-05-04 17:37:15.000000000 -0400
@@ -67,11 +67,27 @@ endif
 # Create a dependency on libjli (Java Launcher Infrastructure)
 #
 # On UNIX, this is a relative dependency using $ORIGIN. Unfortunately, to
-# do this reliably on Linux takes a different syntax than Solaris.
+# do this reliably on Linux takes a different syntax than Solaris. BSD's
+# don't support $ORIGIN so build an archive instead.
 #
 # On Windows, this is done by using the same directory as the executable
 # itself, as with all the Windows libraries.
 #
+ifeq ($(PLATFORM), bsd)
+  ifeq ($(OS_VENDOR), Apple)
+    LDFLAGS += -Wl,-all_load
+    LDFLAGS += $(OUTPUTDIR)/tmp/java/jli/$(OBJDIRNAME)/static/libjli.a
+  else
+    LDFLAGS += -Wl,--whole-archive
+    LDFLAGS += $(OUTPUTDIR)/tmp/java/jli/$(OBJDIRNAME)/static/libjli.a
+    LDFLAGS += -Wl,--no-whole-archive
+# Work-around an dlsym(RTLD_DEFAULT) bug in at least FreeBSD & OpenBSD
+    LDFLAGS += -Wl,--export-dynamic
+  endif
+  ifeq ($(SYSTEM_ZLIB),true)
+      OTHER_LDLIBS += -lz
+  endif
+endif
 ifneq (,$(findstring $(PLATFORM), linux solaris))	# UNIX systems
     LDFLAGS += -L $(LIBDIR)/$(LIBARCH)/jli
     OTHER_LDLIBS += -ljli
@@ -175,6 +191,10 @@ else # USE_PTHREADS
   THREADLIBS = $(LIBTHREAD)
 endif # USE_PTHREADS
 
+ifeq ($(PLATFORM), bsd)
+THREADLIBS = -pthread
+endif
+
 #
 # This rule only applies on unix.  It supports quantify and its ilk.
 #
@@ -243,15 +263,19 @@ endif
 
 
 ifneq ($(PLATFORM), windows)
+ifneq ($(PLATFORM), bsd)
 HAVE_GETHRTIME=true
 endif
+endif
 
 ifeq ($(HAVE_GETHRTIME),true)
 OTHER_CPPFLAGS += -DHAVE_GETHRTIME
 endif
 
 OTHER_INCLUDES += -I$(LAUNCHER_SHARE_SRC)/bin -I$(LAUNCHER_PLATFORM_SRC)/bin
+ifneq ($(SYSTEM_ZLIB),true)
 OTHER_INCLUDES += -I$(SHARE_SRC)/native/java/util/zip/zlib-1.1.3
+endif
 
 # this may not be necessary...
 ifeq ($(PLATFORM), windows)
diff -upr ../orig/jdk/make/common/Release.gmk ./jdk/make/common/Release.gmk
--- ../orig/jdk/make/common/Release.gmk	2009-01-27 15:44:38.000000000 -0500
+++ ./jdk/make/common/Release.gmk	2009-05-04 17:37:15.000000000 -0400
@@ -147,14 +147,13 @@ JRE_MAN_PAGES =         \
 	tnameserv.1     \
 	unpack200.1
 
-ifeq ($(ARCH_DATA_MODEL),32)
+ifeq ($(BUILD_DEPLOY), true)
   JRE_MAN_PAGES += javaws.1
 endif
 
 JDK_MAN_PAGES =            \
 	$(JRE_MAN_PAGES)   \
 	appletviewer.1     \
-        apt.1              \
 	extcheck.1         \
 	idlj.1             \
 	jar.1              \
@@ -193,6 +192,11 @@ ifeq ($(PLATFORM), linux)
   JA_DIRNAME=ja_JP.$(JA_SOURCE_ENCODING)
 endif # linux
 
+ifeq ($(PLATFORM), bsd)
+  MANBASEDIRS=$(JDK_TOPDIR)/src/bsd/doc $(IMPORTDOCDIR)
+  MAN1SUBDIR = man
+endif
+
 define copy-man-pages
 $(MKDIR) -p $1/man/man1
 for manbase in $(MANBASEDIRS:%=%/$(MAN1SUBDIR)) ; do \
@@ -325,6 +329,12 @@ ifndef OPENJDK
   SOURCE_DIRS += $(CLOSED_SRC)/share/classes
 endif
 
+ifeq ($(OS_VENDOR), OpenBSD)
+  FILES_FROM_ARG=-I
+else
+  FILES_FROM_ARG=-T
+endif
+
 
 #
 # Specific files and directories that will be filtered out from above areas.
@@ -982,7 +992,7 @@ initial-image-jdk:: initial-image-jdk-se
 	@# generated by the more efficient solaris/windows method of copying files.
 	@# So for Linux, make use of the -T option (like Solaris' -I option) of
 	@# obtaining the list of files from a file. MKS tar has no such option.
-  ifeq ($(PLATFORM), linux)
+  ifneq (,$(findstring $(PLATFORM), linux bsd))
 	for d in $(SOURCE_DIRS); do \
 	  $(RM) $(ABS_TEMPDIR)/src-files.list; \
 	  ($(CD) $$d &&  \
@@ -995,7 +1005,7 @@ initial-image-jdk:: initial-image-jdk-se
 	    done ; \
 	  ) ; \
 	  if [ -f  $(ABS_TEMPDIR)/src-files.list ] ; then \
-	    ($(CD) $$d && $(TAR) cf - -T $(ABS_TEMPDIR)/src-files.list ) \
+	    ($(CD) $$d && $(TAR) cf - $(FILES_FROM_ARG) $(ABS_TEMPDIR)/src-files.list ) \
 	       | ($(CD) $(JDK_IMAGE_DIR)/src && $(TAR) xf -); \
 	  fi; \
 	done
diff -upr ../orig/jdk/make/common/internal/BinaryPlugs.gmk ./jdk/make/common/internal/BinaryPlugs.gmk
--- ../orig/jdk/make/common/internal/BinaryPlugs.gmk	2009-01-27 15:44:38.000000000 -0500
+++ ./jdk/make/common/internal/BinaryPlugs.gmk	2009-05-04 17:37:17.000000000 -0400
@@ -49,8 +49,6 @@ PLUG_JMF_CLASS_NAMES = \
 com/sun/jmx/snmp/SnmpDataTypeEnums.class \
 com/sun/jmx/snmp/SnmpDefinitions.class \
 com/sun/jmx/snmp/SnmpOid.class \
-com/sun/jmx/snmp/SnmpOidDatabase.class \
-com/sun/jmx/snmp/SnmpOidDatabaseSupport.class \
 com/sun/jmx/snmp/SnmpOidRecord.class \
 com/sun/jmx/snmp/SnmpOidTable.class \
 com/sun/jmx/snmp/SnmpOidTableSupport.class \
@@ -60,22 +58,16 @@ com/sun/jmx/snmp/SnmpPeer.class \
 com/sun/jmx/snmp/SnmpTimeticks.class \
 com/sun/jmx/snmp/SnmpVarBind.class \
 com/sun/jmx/snmp/SnmpVarBindList.class \
-com/sun/jmx/snmp/Timestamp.class \
 com/sun/jmx/snmp/daemon/SendQ.class \
 com/sun/jmx/snmp/daemon/SnmpInformRequest.class \
-com/sun/jmx/snmp/daemon/SnmpQManager.class \
-com/sun/jmx/snmp/daemon/SnmpRequestCounter.class \
-com/sun/jmx/snmp/daemon/SnmpResponseHandler.class \
-com/sun/jmx/snmp/daemon/SnmpSendServer.class \
-com/sun/jmx/snmp/daemon/SnmpSession.class \
-com/sun/jmx/snmp/daemon/SnmpSocket.class \
-com/sun/jmx/snmp/daemon/SnmpTimerServer.class \
-com/sun/jmx/snmp/daemon/WaitQ.class
+com/sun/jmx/snmp/daemon/SnmpSession.class
+
+PLUG_GNU_CLASS_NAMES = gnu
 
 # Class list temp files (used by both import and export of plugs)
 
 PLUG_TEMPDIR=$(ABS_TEMPDIR)/plugs
-PLUG_CLASS_AREAS = jmf
+PLUG_CLASS_AREAS = jmf gnu
 PLUG_CLISTS = $(PLUG_CLASS_AREAS:%=$(PLUG_TEMPDIR)/%.clist)
 
 # Create jargs file command
@@ -93,11 +85,18 @@ $(PLUG_TEMPDIR)/jmf.clist:
 	@for i in $(PLUG_JMF_CLASS_NAMES) ; do \
 	  $(ECHO) "$$i" >> $@; \
 	done
+$(PLUG_TEMPDIR)/gnu.clist:
+	@$(prep-target)
+	@for i in $(PLUG_GNU_CLASS_NAMES) ; do \
+	  $(ECHO) "$$i" >> $@ ; \
+	done
 $(PLUG_TEMPDIR)/all.clist: $(PLUG_CLISTS)
 	@$(prep-target)
 	$(CAT) $(PLUG_CLISTS) > $@
 $(PLUG_TEMPDIR)/jmf.jargs: $(PLUG_TEMPDIR)/jmf.clist
 	$(plug-create-jargs)
+$(PLUG_TEMPDIR)/gnu.jargs: $(PLUG_TEMPDIR)/gnu.clist
+	$(plug-create-jargs)
 $(PLUG_TEMPDIR)/all.jargs: $(PLUG_TEMPDIR)/all.clist
 	$(plug-create-jargs)
 
@@ -153,11 +152,16 @@ endif # IMPORT_BINARY_PLUGS
 
 import-binary-plug-jmf-classes: $(PLUG_IMPORT_JARFILE) $(PLUG_TEMPDIR)/jmf.clist
 	$(call import-binary-plug-classes,$(PLUG_TEMPDIR)/jmf.clist)
+import-binary-plug-gnu-classes: $(PLUG_IMPORT_JARFILE) $(PLUG_TEMPDIR)/gnu.clist
+	$(call import-binary-plug-classes,$(PLUG_TEMPDIR)/gnu.clist)
+
+
 
 # Import all classes from the jar file
 
 import-binary-plug-jar: \
-	     import-binary-plug-jmf-classes
+	     import-binary-plug-jmf-classes \
+	     import-binary-plug-gnu-classes
 
 # Binary plug start/complete messages
 
@@ -169,14 +173,12 @@ import-binary-plugs-completed:
 
 # Import lib files (only if they don't exist already)
 
-import-binary-plugs-libs: \
-    $(PLUG_LIBRARY_NAMES:%=$(LIB_LOCATION)/%)
+import-binary-plugs-libs:
 
 # Import everything
 
 import-binary-plugs: \
     import-binary-plugs-started \
-    import-binary-plugs-libs \
     import-binary-plug-jar \
     import-binary-plugs-completed
 
diff -upr ../orig/jdk/make/common/shared/Compiler-gcc.gmk ./jdk/make/common/shared/Compiler-gcc.gmk
--- ../orig/jdk/make/common/shared/Compiler-gcc.gmk	2009-01-27 15:44:38.000000000 -0500
+++ ./jdk/make/common/shared/Compiler-gcc.gmk	2009-05-04 17:37:15.000000000 -0400
@@ -99,6 +99,24 @@ ifeq ($(PLATFORM), linux)
 
 endif
 
+ifeq ($(PLATFORM), bsd)
+
+  # Settings specific to BSD
+  CC             = $(COMPILER_PATH)gcc
+  CPP            = $(COMPILER_PATH)gcc -E
+  CXX            = $(COMPILER_PATH)g++
+  REQUIRED_CC_VER = 3.2
+
+  # Option used to create a shared library
+  # Option used to create a shared library
+  ifeq ($(OS_VENDOR), Apple)
+    SHARED_LIBRARY_FLAG = -dynamiclib 
+  else
+    SHARED_LIBRARY_FLAG = -shared
+  endif
+  SUN_COMP_VER := $(shell $(CC) --verbose 2>&1 )
+endif
+
 ifeq ($(PLATFORM), solaris)
 
   # Settings specific to Solaris
diff -upr ../orig/jdk/make/common/shared/Compiler.gmk ./jdk/make/common/shared/Compiler.gmk
--- ../orig/jdk/make/common/shared/Compiler.gmk	2009-01-27 15:44:38.000000000 -0500
+++ ./jdk/make/common/shared/Compiler.gmk	2009-05-04 17:37:15.000000000 -0400
@@ -37,8 +37,8 @@ ifeq ($(PLATFORM), solaris)
   override CC_VERSION = sun
 endif
 
-# Linux uses GNU compilers by default
-ifeq ($(PLATFORM), linux)
+# Linux  & BSD uses GNU compilers by default
+ifneq (,$(findstring $(PLATFORM), linux bsd))
   override CC_VERSION = gcc
 endif
 
diff -upr ../orig/jdk/make/common/shared/Defs-bsd.gmk ./jdk/make/common/shared/Defs-bsd.gmk
--- ../orig/jdk/make/common/shared/Defs-bsd.gmk	2009-05-04 18:32:16.000000000 -0400
+++ ./jdk/make/common/shared/Defs-bsd.gmk	2009-05-04 22:40:38.000000000 -0400
@@ -70,7 +70,7 @@ $(shell if [ "$1" != "" -a -d "$1" ]; th
 endef
 
 # Location on system where jdk installs might be
-USRJDKINSTANCES_PATH =/opt/java
+USRJDKINSTANCES_PATH = $(PACKAGE_PATH)
 
 # UNIXCOMMAND_PATH: path to where the most common Unix commands are.
 #  NOTE: Must end with / so that it could be empty, allowing PATH usage.
@@ -123,7 +123,7 @@ endif
 ifneq "$(origin ALT_DEVTOOLS_PATH)" "undefined"
   DEVTOOLS_PATH :=$(call PrefixPath,$(ALT_DEVTOOLS_PATH))
 else
-  DEVTOOLS_PATH =/usr/bin/
+  DEVTOOLS_PATH =$(PACKAGE_PATH)/bin/
 endif
 
 # _BOOTDIR1: First choice for a Bootstrap JDK, previous released JDK.
@@ -162,16 +162,12 @@ else
 endif
 MOTIF_INCLUDE = $(MOTIF_DIR)/include
 
-# GCC29_COMPILER_PATH: is the path to where the gcc 2.9 compiler is installed
-#  NOTE: Must end with / so that it could be empty, allowing PATH usage.
-ifneq "$(origin ALT_GCC29_COMPILER_PATH)" "undefined"
-  GCC29_COMPILER_PATH :=$(call PrefixPath,$(ALT_GCC29_COMPILER_PATH))
+ifeq ($(OS_VENDOR), Apple)
+  _CUPS_HEADERS_PATH=/usr/include
 else
-  GCC29_COMPILER_PATH = $(JDK_DEVTOOLS_DIR)/$(PLATFORM)/gcc29/usr/
+  _CUPS_HEADERS_PATH=$(PACKAGE_PATH)/include
 endif
 
-_CUPS_HEADERS_PATH=/usr/include
-
 # Import JDK images allow for partial builds, components not built are
 #    imported (or copied from) these import areas when needed.
 
diff -upr ../orig/jdk/make/common/shared/Defs-utils.gmk ./jdk/make/common/shared/Defs-utils.gmk
--- ../orig/jdk/make/common/shared/Defs-utils.gmk	2009-01-27 15:44:38.000000000 -0500
+++ ./jdk/make/common/shared/Defs-utils.gmk	2009-05-04 17:37:15.000000000 -0400
@@ -77,6 +77,13 @@ ifndef FINDBUGS_HOME
 endif
 FINDBUGS = $(FINDBUGS_HOME)/bin/findbugs
 
+ifeq ($(PLATFORM),bsd)
+  UTILS_COMMAND_PATH=$(UNIXCOMMAND_PATH)
+  UTILS_USR_BIN_PATH=$(USRBIN_PATH)
+  UTILS_CCS_BIN_PATH=$(USRBIN_PATH)
+  UTILS_DEVTOOL_PATH=$(DEVTOOLS_PATH)
+endif
+
 # Utilities
 ADB            = $(UTILS_COMMAND_PATH)adb
 AR             = $(UTILS_CCS_BIN_PATH)ar
@@ -198,3 +205,32 @@ ifeq ($(PLATFORM),solaris)
   ECHO           = /usr/bin/echo
 endif
 
+# BSD specific
+ifeq ($(PLATFORM),bsd)
+  BASENAME     = $(UTILS_USR_BIN_PATH)basename
+  EGREP        = $(UTILS_USR_BIN_PATH)egrep
+  EXPR         = $(UTILS_COMMAND_PATH)expr
+  FMT          = $(UTILS_USR_BIN_PATH)fmt
+  GREP         = $(UTILS_USR_BIN_PATH)grep
+  GUNZIP       = $(UTILS_USR_BIN_PATH)gunzip
+  ID           = $(UTILS_USR_BIN_PATH)id
+  MSGFMT       = $(UTILS_DEVTOOL_PATH)msgfmt
+  SED          = $(UTILS_USR_BIN_PATH)sed
+  SORT         = $(UTILS_USR_BIN_PATH)sort
+  TEST         = $(UTILS_COMMAND_PATH)test
+  TOUCH        = $(UTILS_USR_BIN_PATH)touch
+  TRUE         = $(UTILS_USR_BIN_PATH)true
+  UNAME        = $(UTILS_USR_BIN_PATH)uname
+  # BSD OS_VENDOR specific
+  ifeq ($(OS_VENDOR), Apple)
+    NAWK       = $(UTILS_USR_BIN_PATH)awk
+    UNZIPSFX   = $(UTILS_USR_BIN_PATH)unzipsfx
+    ZIPEXE     = $(UTILS_USR_BIN_PATH)zip
+  else
+    UNZIP      = $(UTILS_DEVTOOL_PATH)unzip
+  endif
+  ifneq ($(OS_VENDOR), OpenBSD)
+    CPIO       = $(UTILS_USR_BIN_PATH)cpio
+    TAR        = $(UTILS_USR_BIN_PATH)tar
+  endif
+endif
diff -upr ../orig/jdk/make/common/shared/Defs.gmk ./jdk/make/common/shared/Defs.gmk
--- ../orig/jdk/make/common/shared/Defs.gmk	2009-01-27 15:44:38.000000000 -0500
+++ ./jdk/make/common/shared/Defs.gmk	2009-05-04 17:37:15.000000000 -0400
@@ -143,7 +143,7 @@ $(shell \
         echo older; \
       else \
 	if [ $(call MajorVersion,$1) -eq $(call MajorVersion,$2) -a \
-	     $(call MinorVersion,$1) -lt $(call MinorVersion,$2) ]; then \
+	     `echo $(call MinorVersion,$1) | sed -e 's/\([0-9]*\)\(.*\)/\1/'` -lt $(call MinorVersion,$2) ]; then \
           echo older; \
         else \
           echo newer; \
diff -upr ../orig/jdk/make/common/shared/Platform.gmk ./jdk/make/common/shared/Platform.gmk
--- ../orig/jdk/make/common/shared/Platform.gmk	2009-01-27 15:44:38.000000000 -0500
+++ ./jdk/make/common/shared/Platform.gmk	2009-05-04 17:37:17.000000000 -0400
@@ -276,6 +276,76 @@ ifeq ($(SYSTEM_UNAME), Linux)
   MB_OF_MEMORY := $(shell free -m | fgrep Mem: | sed -e 's@\ \ *@ @g' | cut -d' ' -f2)
 endif
 
+ifeq ($(SYSTEM_UNAME), FreeBSD)
+  PLATFORM = bsd
+  OS_NAME = freebsd
+  OS_VENDOR = FreeBSD
+  REQUIRED_OS_VERSION = 6.0
+endif
+
+ifeq ($(SYSTEM_UNAME), Darwin)
+  PLATFORM = bsd
+  OS_NAME = darwin
+  OS_VENDOR = Apple
+  REQUIRED_OS_VERSION = 8.0
+endif
+
+ifeq ($(SYSTEM_UNAME), NetBSD)
+  PLATFORM = bsd
+  OS_NAME = netbsd
+  OS_VENDOR = NetBSD
+  REQUIRED_OS_VERSION = 3.0
+endif
+
+ifeq ($(SYSTEM_UNAME), OpenBSD)
+  PLATFORM = bsd
+  OS_NAME = openbsd
+  OS_VENDOR = OpenBSD
+  REQUIRED_OS_VERSION = 4.2
+endif
+
+# Platform settings specific to BSD
+ifeq ($(PLATFORM), bsd)
+  OS_VERSION := $(shell uname -r)
+  # Arch and OS name/version
+  mach := $(shell uname -m)
+  archExpr = case "$(mach)" in \
+                i[3-9]86) \
+                    echo i586 \
+                    ;; \
+                *) \
+                    echo $(mach) \
+                    ;; \
+      esac
+  ARCH        := $(shell $(archExpr) )
+  ARCH_FAMILY := $(ARCH)
+
+  # i586 and sparc are 32 bit, amd64 and sparc64 are 64
+  ifneq (,$(findstring $(ARCH), i586 sparc))
+    ARCH_DATA_MODEL=32
+  else
+    ARCH_DATA_MODEL=64
+  endif
+
+  # Need to maintain the jre/lib/i386 location for 32-bit Intel
+  ifeq ($(ARCH), i586)
+    LIBARCH = i386
+  else
+    LIBARCH = $(ARCH)
+  endif
+
+  # Value of Java os.arch property
+  ARCHPROP  = $(LIBARCH)
+
+  # Suffix for file bundles used in previous release
+  BUNDLE_FILE_SUFFIX=.tar.gz
+  # Minimum disk space needed as determined by running 'du -sk' on 
+  #    a fully built workspace.
+  REQUIRED_FREE_SPACE=1500000
+  # How much RAM does this machine have:
+  MB_OF_MEMORY=$(shell sysctl -n hw.physmem | awk '{print int($$NF / 1048576); }' )
+endif
+
 # Windows with and without CYGWIN will be slightly different
 ifeq ($(SYSTEM_UNAME), Windows_NT)
   PLATFORM = windows
@@ -392,6 +462,13 @@ endif
 #    system swapping during the build.
 #    If we don't know, assume 512. Subtract 128 from MB for VM MAX.
 #    Don't set VM max over 1024-128=896.
+#    736 is the max for OpenBSD.
+ifeq ($(OS_VENDOR), OpenBSD)
+  ABS_MAX_MEMORY := "736"
+else
+  ABS_MAX_MEMORY := "896"
+endif
+
 ifneq ($(MB_OF_MEMORY),)
   LOW_MEMORY_MACHINE := $(shell \
     if [ $(MB_OF_MEMORY) -le 512 ] ; then \
@@ -403,7 +480,7 @@ ifneq ($(MB_OF_MEMORY),)
     if [ $(MB_OF_MEMORY) -le 1024 ] ; then \
       expr $(MB_OF_MEMORY) '-' 128 ; \
     else \
-      echo "896"; \
+      echo $(ABS_MAX_MEMORY); \
     fi)
   MIN_VM_MEMORY := $(shell \
     if [ $(MAX_VM_MEMORY) -le 128 ] ; then \
@@ -455,6 +532,15 @@ ifneq ($(PLATFORM), windows)
   ARCH_VM_SUBDIR=jre/lib/$(LIBARCH)
 endif
 
+# Darwin-specific Overrides
+ifeq ($(SYSTEM_UNAME),Darwin)
+  # The suffix applied to runtime libraries
+  LIBRARY_SUFFIX = dylib
+  # The suffix applied to link libraries
+  LIB_SUFFIX = dylib
+endif
+
+
 # If blanks in the username, use the first 4 words and pack them together
 _USER1:=$(subst ', ,$(_USER))
 _USER2:=$(subst ", ,$(_USER1))
diff -upr ../orig/jdk/make/common/shared/Sanity-Settings.gmk ./jdk/make/common/shared/Sanity-Settings.gmk
--- ../orig/jdk/make/common/shared/Sanity-Settings.gmk	2009-01-27 15:44:38.000000000 -0500
+++ ./jdk/make/common/shared/Sanity-Settings.gmk	2009-05-04 17:37:15.000000000 -0400
@@ -257,6 +257,7 @@ ifdef OPENJDK
   ALL_SETTINGS+=$(call addHeading,OpenJDK-specific settings)
   ALL_SETTINGS+=$(call addAltSetting,FREETYPE_HEADERS_PATH)
   ALL_SETTINGS+=$(call addAltSetting,FREETYPE_LIB_PATH)
+  ALL_SETTINGS+=$(call addAltSetting,X11_PATH)
   ALL_SETTINGS+=$(call addHeading,OPENJDK Import Binary Plug Settings)
   ALL_SETTINGS+=$(call addAltSetting,BINARY_PLUGS_JARFILE)
   ALL_SETTINGS+=$(call addAltSetting,BINARY_PLUGS_PATH)
diff -upr ../orig/jdk/make/common/shared/Sanity.gmk ./jdk/make/common/shared/Sanity.gmk
--- ../orig/jdk/make/common/shared/Sanity.gmk	2009-01-27 15:44:38.000000000 -0500
+++ ./jdk/make/common/shared/Sanity.gmk	2009-05-04 17:37:15.000000000 -0400
@@ -96,6 +96,11 @@ ifeq ($(PLATFORM), windows)
     $(EGREP) "\#define" | $(NAWK) '{print $$3}')
 endif
 
+ifeq ($(PLATFORM), bsd)
+  FREE_SPACE := $(shell BLOCKSIZE=512 $(DF) $(OUTPUTDIR) | $(TAIL) -1 | $(NAWK) '{print $$2;}')
+  TEMP_FREE_SPACE := $(shell BLOCKSIZE=512 $(DF) $(TEMP_DISK) | $(TAIL) -1 | $(NAWK) '{print $$2;}')
+endif
+
 # Get the version numbers of what we are using
 _MAKE_VER  :=$(shell $(MAKE) --version 2>&1 | $(HEAD) -n 1)
 _ZIP_VER   :=$(shell $(ZIPEXE) -help 2>&1 | $(HEAD) -n 4 | $(EGREP) '^Zip')
diff -upr ../orig/jdk/make/docs/Makefile ./jdk/make/docs/Makefile
--- ../orig/jdk/make/docs/Makefile	2009-01-27 15:44:38.000000000 -0500
+++ ./jdk/make/docs/Makefile	2009-05-04 17:37:15.000000000 -0400
@@ -232,7 +232,7 @@ JDI_HEADER      = "Java Debug Interface"
 #       you get "No packages or classes specified." due to $(CLASSPATH_SEPARATOR)
 #       being interpreted as an end of command (newline)
 
-JAAS_SOURCEPATH  = "$(TOPDIR)/src/share/classes$(CLASSPATH_SEPARATOR)$(TOPDIR)/src/solaris/classes$(CLASSPATH_SEPARATOR)$(TOPDIR)/src/windows/classes$(CLASSPATH_SEPARATOR)$(TOPDIR)/src/linux/classes"
+JAAS_SOURCEPATH  = "$(TOPDIR)/src/share/classes$(CLASSPATH_SEPARATOR)$(TOPDIR)/src/solaris/classes$(CLASSPATH_SEPARATOR)$(TOPDIR)/src/windows/classes$(CLASSPATH_SEPARATOR)$(TOPDIR)/src/linux/classes$(CLASSPATH_SEPARATOR)$(TOPDIR)/src/bsd/classes"
 JAAS_DOCDIR	 = $(DOCSDIR)/jre/api/security/jaas/spec
 JAAS_JAVADOCFLAGS = $(COMMON_JAVADOCFLAGS)			 \
 		   -encoding ascii			         \
diff -upr ../orig/jdk/make/java/Makefile ./jdk/make/java/Makefile
--- ../orig/jdk/make/java/Makefile	2009-01-27 15:44:38.000000000 -0500
+++ ./jdk/make/java/Makefile	2009-05-04 17:37:15.000000000 -0400
@@ -49,7 +49,7 @@ ifeq ($(PLATFORM), solaris)
   endif
 endif # PLATFORM
 
-ifeq ($(PLATFORM), linux)
+ifneq (,$(findstring $(PLATFORM), linux bsd))
   SUBDIRS += jexec
 endif # PLATFORM
 
diff -upr ../orig/jdk/make/java/hpi/hpi_common.gmk ./jdk/make/java/hpi/hpi_common.gmk
--- ../orig/jdk/make/java/hpi/hpi_common.gmk	2009-01-27 15:44:38.000000000 -0500
+++ ./jdk/make/java/hpi/hpi_common.gmk	2009-05-04 17:37:15.000000000 -0400
@@ -86,5 +86,9 @@ endif
 # Things that must be linked in.
 #
 ifneq ($(PLATFORM), windows)
+ifeq ($(PLATFORM), bsd)
+OTHER_LDLIBS += $(LIBM)
+else
 OTHER_LDLIBS += $(LIBSOCKET) -lnsl $(LIBM) -ldl
 endif
+endif
diff -upr ../orig/jdk/make/java/hpi/native/Makefile ./jdk/make/java/hpi/native/Makefile
--- ../orig/jdk/make/java/hpi/native/Makefile	2009-01-27 15:44:38.000000000 -0500
+++ ./jdk/make/java/hpi/native/Makefile	2009-05-04 17:37:15.000000000 -0400
@@ -72,11 +72,18 @@ OTHER_CPPFLAGS += -DUSE_PTHREADS
 ifeq ($(MOOT_PRIORITIES),true)
 OTHER_CPPFLAGS += -DMOOT_PRIORITIES
 endif
+ifeq ($(PLATFORM), bsd)
+LIBPOSIX4      =
+OTHER_LDLIBS   += -pthread
+else
 LIBPOSIX4	= -lposix4
 OTHER_LDLIBS   += -lpthread $(LIBPOSIX4)
 endif
+endif
 
+ifneq ($(PLATFORM), bsd)
 HAVE_GETHRVTIME=true
+endif
 ifeq ($(HAVE_GETHRVTIME),true)
 OTHER_CPPFLAGS += -DHAVE_GETHRVTIME
 endif
diff -upr ../orig/jdk/make/java/instrument/Makefile ./jdk/make/java/instrument/Makefile
--- ../orig/jdk/make/java/instrument/Makefile	2009-01-27 15:44:38.000000000 -0500
+++ ./jdk/make/java/instrument/Makefile	2009-05-04 17:37:15.000000000 -0400
@@ -102,6 +102,21 @@ ifeq ($(PLATFORM), windows)
   # equivalent of strcasecmp is stricmp on Windows
   CPPFLAGS_COMMON += -Dstrcasecmp=stricmp
 else
+ifeq ($(PLATFORM), bsd)
+  ifeq ($(OS_VENDOR), Apple)
+    LDFLAGS += -Wl,-all_load
+    LDFLAGS += $(OUTPUTDIR)/tmp/java/jli/$(OBJDIRNAME)/static/libjli.a
+  else
+    LDFLAGS += -Wl,--whole-archive
+    LDFLAGS += $(OUTPUTDIR)/tmp/java/jli/$(OBJDIRNAME)/static/libjli.a
+    LDFLAGS += -Wl,--no-whole-archive
+  endif
+
+  ICONV_PATH = $(PACKAGE_PATH)
+# Use CPPFLAGS instead of OTHER_INCLUDES to force this last
+  CPPFLAGS += -I$(ICONV_PATH)/include
+  OTHER_LDLIBS += -L$(ICONV_PATH)/lib -liconv
+else
   LDFLAGS += -L $(LIBDIR)/$(LIBARCH)/jli
   OTHER_LDLIBS += -ljli
   OTHER_LDLIBS += -ldl 
@@ -114,6 +129,7 @@ else
     LDFLAGS += -Wl,-rpath -Wl,\$$ORIGIN/jli
   endif
 endif
+endif
 
 #
 # Library to compile.
diff -upr ../orig/jdk/make/java/java/Makefile ./jdk/make/java/java/Makefile
--- ../orig/jdk/make/java/java/Makefile	2009-01-27 15:44:38.000000000 -0500
+++ ./jdk/make/java/java/Makefile	2009-05-04 17:37:15.000000000 -0400
@@ -167,8 +167,10 @@ OTHER_INCLUDES += -I$(PLATFORM_SRC)/nati
 # Is the altzone extern documented in ctime(3C) available?
 #
 ifneq ($(PLATFORM), windows)
+ifneq ($(PLATFORM), bsd)
 HAVE_ALTZONE=true
 endif
+endif
 
 ifeq ($(HAVE_ALTZONE),true)
 OTHER_CPPFLAGS += -DHAVE_ALTZONE
@@ -205,9 +207,14 @@ ifeq ($(PLATFORM),windows)
 OTHER_LDLIBS += $(JVMLIB) -libpath:$(OBJDIR)/../../../fdlibm/$(OBJDIRNAME) fdlibm.lib \
 		       -libpath:$(OBJDIR)/../../../verify/$(OBJDIRNAME) verify.lib
 else
+ifeq ($(PLATFORM), bsd)
+OTHER_LDLIBS += $(JVMLIB) -lverify \
+		-L$(OBJDIR)/../../../fdlibm/$(OBJDIRNAME) -lfdlibm.$(ARCH)
+else
 OTHER_LDLIBS += $(JVMLIB) -lverify $(LIBSOCKET) -lnsl -ldl \
 		-L$(OBJDIR)/../../../fdlibm/$(OBJDIRNAME) -lfdlibm.$(ARCH)
 endif
+endif
 
 #
 # Rules.
diff -upr ../orig/jdk/make/java/java/localegen.sh ./jdk/make/java/java/localegen.sh
--- ../orig/jdk/make/java/java/localegen.sh	2009-01-27 15:44:38.000000000 -0500
+++ ./jdk/make/java/java/localegen.sh	2009-05-05 08:21:41.000000000 -0400
@@ -55,9 +55,9 @@ sed_script="$SED -e \"s@^#warn .*@// -- 
 for FILE in $RESOURCE_NAMES 
 do
     getlocalelist $FILE $EURO_FILES_LIST
-    sed_script=$sed_script"-e \"s/#"$FILE"_EuroLocales#/$localelist/g\" "
+    sed_script=$sed_script"-e \"s@#"$FILE"_EuroLocales#@$localelist@g\" "
     getlocalelist $FILE $NONEURO_FILES_LIST
-    sed_script=$sed_script"-e \"s/#"$FILE"_NonEuroLocales#/$localelist/g\" "
+    sed_script=$sed_script"-e \"s@#"$FILE"_NonEuroLocales#@$localelist@g\" "
 done
 
 sed_script=$sed_script"$INPUT_FILE > $OUTPUT_FILE"
diff -upr ../orig/jdk/make/java/java_hprof_demo/Makefile ./jdk/make/java/java_hprof_demo/Makefile
--- ../orig/jdk/make/java/java_hprof_demo/Makefile	2009-01-27 15:44:38.000000000 -0500
+++ ./jdk/make/java/java_hprof_demo/Makefile	2009-05-04 17:37:15.000000000 -0400
@@ -83,8 +83,10 @@ OTHER_INCLUDES = -I$(SRCDIR) \
 ifeq ($(PLATFORM), windows)
   OTHER_LDLIBS += wsock32.lib winmm.lib
 else
+ifneq ($(PLATFORM), bsd)
   OTHER_LDLIBS += $(LIBSOCKET) -lnsl -ldl
 endif
+endif
 
 #
 # Tell library.gmk to copy the txt file first
diff -upr ../orig/jdk/make/java/jli/Makefile ./jdk/make/java/jli/Makefile
--- ../orig/jdk/make/java/jli/Makefile	2009-01-27 15:44:39.000000000 -0500
+++ ./jdk/make/java/jli/Makefile	2009-05-05 08:26:57.000000000 -0400
@@ -44,8 +44,10 @@ MS_RUNTIME_STATIC = true
 
 include $(BUILDDIR)/common/Defs.gmk
 
+ifneq ($(SYSTEM_ZLIB),true)
 ZLIB_VERSION = 1.1.3
 ZIP_SRC = $(SHARE_SRC)/native/java/util/zip/zlib-$(ZLIB_VERSION)
+endif
 LAUNCHER_SHARE_SRC = $(SHARE_SRC)/bin
 LAUNCHER_PLATFORM_SRC = $(PLATFORM_SRC)/bin
 
@@ -56,7 +58,10 @@ FILES_c = \
 	parse_manifest.c \
 	version_comp.c \
 	wildcard.c \
-	jli_util.c \
+	jli_util.c
+
+ifneq ($(SYSTEM_ZLIB),true)
+FILES_c += \
 	inflate.c \
 	infblock.c \
 	inftrees.c \
@@ -65,6 +70,7 @@ FILES_c = \
 	infutil.c \
 	zadler32.c \
 	zutil.c
+endif
 
 OTHER_CPPFLAGS += -DEXPAND_CLASSPATH_WILDCARDS
 
@@ -98,7 +104,11 @@ endif
 
 OTHER_INCLUDES += -I$(LAUNCHER_SHARE_SRC)
 OTHER_INCLUDES += -I$(LAUNCHER_PLATFORM_SRC)
-OTHER_INCLUDES += -I$(ZIP_SRC)
+ifneq ($(SYSTEM_ZLIB),true)
+  OTHER_INCLUDES += -I$(ZIP_SRC)
+else
+  LDLIBS += -lz
+endif
 
 #
 # Library to compile.
@@ -136,8 +146,29 @@ library:: $(STATIC_LIBRARY)
 
 endif	# PLATFORM
 
+ifeq ($(PLATFORM), bsd)
+
+STATIC_LIBRARY_DIR = $(OBJDIR)/static
+STATIC_LIBRARY_NAME = lib$(LIBRARY).a
+STATIC_LIBRARY = $(STATIC_LIBRARY_DIR)/$(STATIC_LIBRARY_NAME)
+
+$(STATIC_LIBRARY_DIR): $(OBJDIR)
+	@$(MKDIR) $(STATIC_LIBRARY_DIR)
+
+$(STATIC_LIBRARY): $(STATIC_LIBRARY_DIR)
+	@$(prep-target)
+	$(AR) -r $@ $(FILES_o)
+
+library:: $(STATIC_LIBRARY)
+
+endif  # PLATFORM
+
 #
 # Add to ambient vpath so we pick up the library files
 #
-vpath %.c $(LAUNCHER_SHARE_SRC) $(ZIP_SRC)
+vpath %.c $(LAUNCHER_SHARE_SRC)
+ifneq ($(SYSTEM_ZLIB),true)
+  vpath %.c $(ZIP_SRC)
+endif
+
 
diff -upr ../orig/jdk/make/java/management/Makefile ./jdk/make/java/management/Makefile
--- ../orig/jdk/make/java/management/Makefile	2009-01-27 15:44:39.000000000 -0500
+++ ./jdk/make/java/management/Makefile	2009-05-04 17:37:15.000000000 -0400
@@ -85,6 +85,11 @@ vpath %.c $(PLATFORM_SRC)/native/com/sun
 OTHER_INCLUDES += \
   -I$(SHARE_SRC)/native/sun/management 
 
+ifeq ($(PLATFORM),bsd)
+OTHER_INCLUDES += \
+  -I$(PLATFORM_SRC)/hpi/include
+endif
+
 ifeq ($(PLATFORM),windows)
   OTHER_LDLIBS += $(JVMLIB)
 endif
diff -upr ../orig/jdk/make/java/net/FILES_c.gmk ./jdk/make/java/net/FILES_c.gmk
--- ../orig/jdk/make/java/net/FILES_c.gmk	2009-01-27 15:44:39.000000000 -0500
+++ ./jdk/make/java/net/FILES_c.gmk	2009-05-05 08:29:02.000000000 -0400
@@ -43,6 +43,10 @@ ifeq ($(PLATFORM), linux)
     FILES_c += linux_close.c
 endif
 
+ifeq ($(OS_VENDOR), FreeBSD)
+    FILES_c += bsd_close.c
+endif
+
 ifeq ($(PLATFORM), windows)
     FILES_c += TwoStacksPlainSocketImpl.c
     FILES_c += DualStackPlainSocketImpl.c
diff -upr ../orig/jdk/make/java/net/Makefile ./jdk/make/java/net/Makefile
--- ../orig/jdk/make/java/net/Makefile	2009-01-27 15:44:39.000000000 -0500
+++ ./jdk/make/java/net/Makefile	2009-05-05 08:30:25.000000000 -0400
@@ -92,6 +92,12 @@ include $(BUILDDIR)/common/Mapfile-vers.
 
 include $(BUILDDIR)/common/Library.gmk
 
+ifeq ($(PLATFORM), bsd)
+  ifdef DONT_ENABLE_IPV6
+    OTHER_CFLAGS += -DDONT_ENABLE_IPV6
+  endif
+  OTHER_LDLIBS = $(JVMLIB) -pthread
+else
 ifeq ($(PLATFORM), windows)
   OTHER_LDLIBS = ws2_32.lib $(JVMLIB)
   # Will not compile at warning level 3 if warnings are fatal
@@ -102,6 +108,7 @@ endif
 ifeq ($(PLATFORM), linux)
   OTHER_LDLIBS += -lpthread
 endif
+endif # PLATFORM == bsd
 
 CLASSES.export += java.lang.Integer java.io.FileDescriptor java.net.InetAddressImplFactory java.net.Inet4AddressImpl java.net.Inet6AddressImpl
 
diff -upr ../orig/jdk/make/java/nio/Makefile ./jdk/make/java/nio/Makefile
--- ../orig/jdk/make/java/nio/Makefile	2009-01-27 15:44:39.000000000 -0500
+++ ./jdk/make/java/nio/Makefile	2009-05-04 17:37:15.000000000 -0400
@@ -82,7 +82,7 @@ FILES_export += \
 	sun/nio/ch/WindowsSelectorImpl.java
 endif # PLATFORM = windows
 
-ifeq ($(PLATFORM), linux)
+ifneq (,$(findstring $(PLATFORM), linux bsd))
 FILES_java += \
         sun/nio/ch/AbstractPollSelectorImpl.java \
 	sun/nio/ch/EPollArrayWrapper.java \
@@ -126,6 +126,11 @@ OTHER_INCLUDES += \
   -I$(PLATFORM_SRC)/native/java/net \
   -I$(CLASSHDRDIR)/../../../java.lang/java/CClassHeaders
 
+ifeq ($(PLATFORM), bsd)
+OTHER_INCLUDES += \
+  -I$(PLATFORM_SRC)/hpi/include
+endif
+
 ifeq ($(PLATFORM),windows)
   OTHER_LDLIBS += $(JVMLIB) ws2_32.lib \
      -libpath:$(LIBDIR) java.lib \
@@ -137,6 +142,9 @@ ifeq ($(PLATFORM), linux)
 COMPILER_WARNINGS_FATAL=true
 OTHER_LDLIBS += -L$(LIBDIR)/$(LIBARCH) -ljava -lnet -lpthread -ldl
 endif
+ifeq ($(PLATFORM), bsd)
+OTHER_LDLIBS += -L$(LIBDIR)/$(LIBARCH) -ljava -lnet -pthread
+endif
 ifeq ($(PLATFORM), solaris)
 OTHER_LDLIBS += $(JVMLIB) $(LIBSOCKET) -lposix4 -ldl \
 		-L$(LIBDIR)/$(LIBARCH) -ljava -lnet
@@ -159,6 +167,9 @@ endif
 ifeq ($(PLATFORM), linux)
 FILES_m = mapfile-linux
 endif
+ifeq ($(PLATFORM), bsd)
+FILES_m = mapfile-bsd
+endif
 include $(BUILDDIR)/common/Mapfile-vers.gmk
 include $(BUILDDIR)/common/Library.gmk
 
diff -upr ../orig/jdk/make/java/npt/Makefile ./jdk/make/java/npt/Makefile
--- ../orig/jdk/make/java/npt/Makefile	2009-01-27 15:44:39.000000000 -0500
+++ ./jdk/make/java/npt/Makefile	2009-05-05 09:08:01.000000000 -0400
@@ -70,6 +70,18 @@ ifeq ($(PLATFORM), windows)
   OTHER_LCF += -export:nptInitialize -export:nptTerminate
 endif
 
+# Add location of iconv headers & libs
+ifeq ($(PLATFORM), bsd)
+  ifeq ($(OS_VENDOR), Apple)
+    OTHER_LDLIBS += -liconv
+  else
+    ifneq ($(OS_NAME), netbsd)
+      CPPFLAGS += -I$(PACKAGE_PATH)/include
+      OTHER_LDLIBS += -L$(PACKAGE_PATH)/lib -liconv
+    endif
+  endif
+endif
+
 #
 # Add to ambient vpath so we pick up the library files
 #
diff -upr ../orig/jdk/make/java/redist/FILES.gmk ./jdk/make/java/redist/FILES.gmk
--- ../orig/jdk/make/java/redist/FILES.gmk	2009-01-27 15:44:39.000000000 -0500
+++ ./jdk/make/java/redist/FILES.gmk	2009-05-04 17:37:15.000000000 -0400
@@ -38,6 +38,14 @@ SHARED_FONTFILES =					\
 	$(LIBDIR)/fonts/LucidaSansDemiBold.ttf       	\
 
 ifeq ($(PLATFORM), linux)
+NEED_OBLIQUE_FONTS = true
+endif
+
+ifeq ($(PLATFORM), bsd)
+NEED_OBLIQUE_FONTS = true
+endif
+
+ifeq ($(NEED_OBLIQUE_FONTS), true)
 
 # The oblique versions of the font are derived from the base versions
 # and since 2D can do this derivation on the fly at run time there is no
diff -upr ../orig/jdk/make/java/redist/Makefile ./jdk/make/java/redist/Makefile
--- ../orig/jdk/make/java/redist/Makefile	2009-01-27 15:44:39.000000000 -0500
+++ ./jdk/make/java/redist/Makefile	2009-05-04 17:37:15.000000000 -0400
@@ -85,6 +85,11 @@ ifeq ($(SA_EXISTS), false)
   INCLUDE_SA := false
 endif
 
+# FIXME: Remove when the build of libsaproc is fixed.
+ifeq ($(PLATFORM), bsd)
+  INCLUDE_SA := false
+endif
+
 ifeq ($(INCLUDE_SA), true)
   IMPORT_LIST += $(LIBDIR)/sa-jdi.jar \
                  $(LIB_LOCATION)/$(SALIB_NAME)
@@ -312,7 +317,7 @@ $(LIBDIR)/fonts/%.ttf: $(CLOSED_SRC)/sha
 $(FONTSDIRFILE): $(PLATFORM_SRC)/classes/sun/awt/motif/java.fonts.dir
 	$(install-file)
 
-ifeq ($(PLATFORM), linux)
+ifneq (,$(findstring $(PLATFORM), linux bsd))
 
 # The oblique fonts are only needed/wanted on Linux.
 
@@ -326,7 +331,7 @@ $(LIBDIR)/oblique-fonts/%.ttf: $(CLOSED_
 $(OBLFONTSDIRFILE): $(PLATFORM_SRC)/classes/sun/awt/motif/java.oblique-fonts.dir
 	$(install-file)
 
-endif # linux
+endif # linux || bsd
 endif # !OPENJDK
 
 # Import internal files (ones that are stashed in this source tree)
diff -upr ../orig/jdk/make/java/security/Makefile ./jdk/make/java/security/Makefile
--- ../orig/jdk/make/java/security/Makefile	2009-01-27 15:44:39.000000000 -0500
+++ ./jdk/make/java/security/Makefile	2009-05-04 17:37:15.000000000 -0400
@@ -51,7 +51,15 @@ ifeq ($(PLATFORM), windows)
   ifneq ($(ARCH_DATA_MODEL), 64)
     PROPS_SRC   = $(TOPDIR)/src/share/lib/security/java.security-windows
   endif
+
+else # windows
+
+ifeq ($(PLATFORM), bsd)
+  ifeq ($(OS_VENDOR), OpenBSD)
+    PROPS_SRC   = $(TOPDIR)/src/share/lib/security/java.security-openbsd
+  endif
 endif
+endif # windows
 endif # PLATFORM
 
 
diff -upr ../orig/jdk/make/java/zip/FILES_c.gmk ./jdk/make/java/zip/FILES_c.gmk
--- ../orig/jdk/make/java/zip/FILES_c.gmk	2009-01-27 15:44:39.000000000 -0500
+++ ./jdk/make/java/zip/FILES_c.gmk	2009-05-04 17:37:15.000000000 -0400
@@ -30,6 +30,10 @@ FILES_c = \
 	Inflater.c \
 	ZipFile.c \
 	ZipEntry.c \
+	zip_util.c
+
+ifneq ($(SYSTEM_ZLIB),true)
+FILES_c += \
 	zadler32.c \
 	zcrc32.c \
 	deflate.c \
@@ -40,5 +44,5 @@ FILES_c = \
 	inftrees.c \
 	infcodes.c \
 	infutil.c \
-	inffast.c \
-	zip_util.c
+	inffast.c
+endif
diff -upr ../orig/jdk/make/java/zip/Makefile ./jdk/make/java/zip/Makefile
--- ../orig/jdk/make/java/zip/Makefile	2009-01-27 15:44:39.000000000 -0500
+++ ./jdk/make/java/zip/Makefile	2009-05-04 17:37:15.000000000 -0400
@@ -72,16 +72,24 @@ else
 CPPFLAGS += -UDEBUG 
 endif
 
-CPPFLAGS += -I$(SHARE_SRC)/native/java/util/zip/zlib-$(ZLIB_VERSION)
 CPPFLAGS += -I$(SHARE_SRC)/native/java/io
 CPPFLAGS += -I$(PLATFORM_SRC)/native/java/io
 
+ifneq ($(SYSTEM_ZLIB),true)
+CPPFLAGS += -I$(SHARE_SRC)/native/java/util/zip/zlib-$(ZLIB_VERSION)
+
 #
 # Add to ambient vpath so we pick up the library files
 #
 vpath %.c $(SHARE_SRC)/native/$(PKGDIR)/zlib-$(ZLIB_VERSION)
+endif
 
 #
 # Link to JVM library for JVM_Zip* functions
 #
+ifeq ($(SYSTEM_ZLIB),true)
+OTHER_LDLIBS = -lz
+else
 OTHER_LDLIBS = $(JVMLIB)
+endif
+
diff -upr ../orig/jdk/make/javax/sound/FILES_c.gmk ./jdk/make/javax/sound/FILES_c.gmk
--- ../orig/jdk/make/javax/sound/FILES_c.gmk	2009-01-27 15:44:39.000000000 -0500
+++ ./jdk/make/javax/sound/FILES_c.gmk	2009-05-04 17:37:15.000000000 -0400
@@ -34,6 +34,8 @@ FILES_solaris = \
 
 FILES_linux = 
 
+FILES_bsd =
+
 FILES_windows = \
 	PLATFORM_API_WinOS_MidiIn.c \
 	PLATFORM_API_WinOS_MidiOut.c \
diff -upr ../orig/jdk/make/javax/sound/Makefile ./jdk/make/javax/sound/Makefile
--- ../orig/jdk/make/javax/sound/Makefile	2009-01-27 15:44:39.000000000 -0500
+++ ./jdk/make/javax/sound/Makefile	2009-05-04 17:37:15.000000000 -0400
@@ -107,6 +107,19 @@ ifeq ($(PLATFORM), linux)
   #MXSPP_ADD = $(PLATFORM)-$(ARCH)/
 endif # PLATFORM linux
 
+# XXXBSD: ???
+ifeq ($(PLATFORM), bsd)
+    # build with empty MIDI i/o
+    INCLUDE_MIDI = TRUE
+    # build with empty ports
+    INCLUDE_PORTS = TRUE
+    # build with empty direct audio
+    INCLUDE_DAUDIO = TRUE
+    ifeq ($(OS_VENDOR), OpenBSD)
+      LDFLAGS += -lossaudio
+    endif
+endif # PLATFORM bsd
+
 ifeq ($(PLATFORM), solaris)
   ifneq ($(ARCH), amd64)
     # build with ports and direct audio
diff -upr ../orig/jdk/make/javax/sound/SoundDefs.gmk ./jdk/make/javax/sound/SoundDefs.gmk
--- ../orig/jdk/make/javax/sound/SoundDefs.gmk	2009-01-27 15:44:39.000000000 -0500
+++ ./jdk/make/javax/sound/SoundDefs.gmk	2009-05-04 17:37:15.000000000 -0400
@@ -40,6 +40,10 @@ ifeq ($(PLATFORM), linux)
   CPPFLAGS += -DX_PLATFORM=X_LINUX
 endif # PLATFORM linux
 
+ifeq ($(PLATFORM), bsd)
+  CPPFLAGS += -DX_PLATFORM=X_BSD
+endif # PLATFORM bsd
+
 ifeq ($(PLATFORM), solaris)
   CPPFLAGS += -DX_PLATFORM=X_SOLARIS
 
diff -upr ../orig/jdk/make/jpda/back/Makefile ./jdk/make/jpda/back/Makefile
--- ../orig/jdk/make/jpda/back/Makefile	2009-01-27 15:44:39.000000000 -0500
+++ ./jdk/make/jpda/back/Makefile	2009-05-04 17:37:15.000000000 -0400
@@ -49,8 +49,10 @@ OTHER_INCLUDES = -I$(SHARE_SRC)/transpor
                  -I$(GENNATIVESRCDIR)/jdwp
 
 ifneq ($(PLATFORM), windows)
+ifneq ($(PLATFORM), bsd)
   OTHER_LDLIBS += -ldl
 endif # PLATFORM
+endif # PLATFORM
 
 #
 # This turns off all assert() checking in the optimized library
diff -upr ../orig/jdk/make/jpda/transport/socket/Makefile ./jdk/make/jpda/transport/socket/Makefile
--- ../orig/jdk/make/jpda/transport/socket/Makefile	2009-01-27 15:44:39.000000000 -0500
+++ ./jdk/make/jpda/transport/socket/Makefile	2009-05-04 17:37:15.000000000 -0400
@@ -45,6 +45,11 @@ ifeq ($(PLATFORM), linux)
   OTHER_LDLIBS += -lnsl $(LIBSOCKET) -lpthread
 endif
 
+ifeq ($(PLATFORM), bsd)
+  LIBSOCKET =
+  OTHER_LDLIBS += -pthread
+endif
+
 ifeq ($(PLATFORM), solaris)
   OTHER_LDLIBS += -lnsl $(LIBSOCKET)
 endif
diff -upr ../orig/jdk/make/sun/awt/Makefile ./jdk/make/sun/awt/Makefile
--- ../orig/jdk/make/sun/awt/Makefile	2009-01-27 15:44:42.000000000 -0500
+++ ./jdk/make/sun/awt/Makefile	2009-05-05 09:13:17.000000000 -0400
@@ -129,6 +129,14 @@ OTHER_CFLAGS += -DMOTIF_VERSION=2
 OTHER_LDLIBS = $(JVMLIB) $(LIBM) -ldl
 endif
 
+ifeq  ($(PLATFORM), bsd)
+FILES_c = $(FILES_2D_c)
+FILES_c += awt_LoadLibrary.c
+OTHER_CFLAGS += -DMLIB_NO_LIBSUNMATH
+OTHER_CFLAGS += -DMOTIF_VERSION=2
+OTHER_LDLIBS = $(JVMLIB) $(LIBM)
+endif
+
 FILES_c += initIDs.c
 
 # ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SOLARIS/LINUX
@@ -241,7 +249,7 @@ vpath %.c     $(SHARE_SRC)/native/$(PKGD
 # ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ WINDOWS
 endif # PLATFORM
 
-ifeq ($(PLATFORM), linux)
+ifneq (,$(findstring $(PLATFORM), linux bsd))
 # vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv LINUX
 vpath %.c   $(SHARE_SRC)/native/$(PKGDIR)/../java2d/opengl
 vpath %.c   $(PLATFORM_SRC)/native/$(PKGDIR)/../java2d/opengl
@@ -421,6 +429,19 @@ FONTCONFIGS_SRC_PREFIX = $(PLATFORM).
 # ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SOLARIS
 endif # PLATFORM
 
+ifeq ($(PLATFORM), bsd)
+# vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv BSD
+
+FONTCONFIGS_SRC = $(PLATFORM_SRC)/classes/sun/awt/fontconfigs
+_FONTCONFIGS   = \
+       fontconfig.properties
+
+FONTCONFIGS_SRC_PREFIX = $(PLATFORM).
+
+# ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ BSD
+endif # PLATFORM
+
+
 FONTCONFIGS     = $(_FONTCONFIGS:%=$(LIBDIR)/%.src)
 BINARYFONTCONFIGS = $(_FONTCONFIGS:%.properties=$(LIBDIR)/%.bfc)
 
@@ -514,6 +535,9 @@ CPPFLAGS += -I$(MOTIF_DIR)/include \
             -I$(OPENWIN_HOME)/include/X11/extensions \
             -I$(PLATFORM_SRC)/native/$(PKGDIR)/font 
 endif
+ifeq ($(PLATFORM), bsd)
+CPPFLAGS += -I$(PLATFORM_SRC)/native/$(PKGDIR)/font 
+endif
 CPPFLAGS += -I$(SHARE_SRC)/native/$(PKGDIR)/debug \
             -I$(SHARE_SRC)/native/$(PKGDIR)/../font \
             -I$(PLATFORM_SRC)/native/$(PKGDIR)/../font \
@@ -535,7 +559,13 @@ CPPFLAGS += -I$(SHARE_SRC)/native/$(PKGD
             -I$(PLATFORM_SRC)/native/$(PKGDIR) \
 	    $(EVENT_MODEL)
 
-ifeq ($(PLATFORM), linux)
+# include these last so we don't pick up unintentional includes
+ifeq ($(PLATFORM), bsd)
+CPPFLAGS += -I$(OPENWIN_HOME)/include \
+            -I$(OPENWIN_HOME)/include/X11/extensions
+endif
+
+ifneq (,$(findstring $(PLATFORM), linux bsd))
 LDFLAGS += -L$(MOTIF_LIB) -L$(OPENWIN_LIB)
 endif
 
diff -upr ../orig/jdk/make/sun/awt/mawt.gmk ./jdk/make/sun/awt/mawt.gmk
--- ../orig/jdk/make/sun/awt/mawt.gmk	2009-01-27 15:44:42.000000000 -0500
+++ ./jdk/make/sun/awt/mawt.gmk	2009-05-04 17:37:15.000000000 -0400
@@ -172,7 +172,7 @@ ifeq ($(PLATFORM), solaris)
 OTHER_LDLIBS = $(LIBXM) -lXt -lXext $(LIBXTST) $(LIBXMU) -lX11 -lXi
 endif
 
-ifeq ($(PLATFORM), linux)
+ifneq (,$(findstring $(PLATFORM), linux bsd))
 OTHER_CFLAGS += -DMLIB_NO_LIBSUNMATH
 OTHER_CFLAGS += -DMOTIF_VERSION=2
 OTHER_CFLAGS += -DXMSTRINGDEFINES=1
@@ -183,7 +183,11 @@ endif
 # !HEADLESS
 
 OTHER_LDLIBS += $(JVMLIB) $(LIBCXX) \
-                -lawt $(LIBM) -ldl
+                -lawt $(LIBM)
+
+ifneq ($(PLATFORM), bsd)
+OTHER_LDLIBS += -ldl
+endif
 
 #
 # Sun CC with -Xa misdefines __STDC__ to 0 (zero).
@@ -227,16 +231,33 @@ CPPFLAGS += -I$(SHARE_SRC)/native/$(PKGD
         -I$(PLATFORM_SRC)/native/$(PKGDIR) \
         $(EVENT_MODEL)
 
+CPPFLAGS += -I$(CUPS_HEADERS_PATH)
+
+ifndef HEADLESS
+CPPFLAGS += -I$(MOTIF_DIR)/include \
+            -I$(OPENWIN_HOME)/include 
+LDFLAGS  += -L$(MOTIF_LIB) -L$(OPENWIN_LIB)
+
+endif # !HEADLESS
+
 ifeq ($(PLATFORM), linux)
 # Checking for the X11/extensions headers at the additional location
   CPPFLAGS += -I/X11R6/include/X11/extensions \
               -I/usr/include/X11/extensions
 endif
 
+ifeq ($(PLATFORM), bsd)
+  CPPFLAGS += -I$(OPENWIN_HOME)/include/X11/extensions \
+              -I$(OPENWIN_HOME)/include 
+endif
+
 ifeq ($(PLATFORM), solaris)
   CPPFLAGS += -I$(OPENWIN_HOME)/include/X11/extensions
 endif
 
+ifneq ($(PLATFORM), windows)
+  CPPFLAGS += -DX11_PATH=\"$(X11_PATH)\" -DPACKAGE_PATH=\"$(PACKAGE_PATH)\"
+endif
 
 LDFLAGS += -L$(LIBDIR)/$(LIBARCH)/$(TSOBJDIR) \
 	   $(AWT_RUNPATH)
diff -upr ../orig/jdk/make/sun/font/Makefile ./jdk/make/sun/font/Makefile
--- ../orig/jdk/make/sun/font/Makefile	2009-01-27 15:44:42.000000000 -0500
+++ ./jdk/make/sun/font/Makefile	2009-05-04 17:37:15.000000000 -0400
@@ -177,6 +177,15 @@ else # PLATFORM
 # Libraries to link, and other C flags.
 #
 
+ifeq ($(PLATFORM), bsd)
+OTHER_INCLUDES += -I$(X11_PATH)/include
+OTHER_LDLIBS  += -lawt $(LIBM) $(LIBCXX)
+ ifeq ($(OS_VENDOR),Apple)
+   # XXXDARWIN Match BSD/Linux behavior -- the mawt.dylib symbols will
+   # be available at runtime.
+   OTHER_LDLIBS += -flat_namespace -undefined suppress
+ endif
+else
 ifeq ($(PLATFORM), solaris)
   # Note that on Solaris, fontmanager is built against the headless library.
   LDFLAGS      += -L$(LIBDIR)/$(LIBARCH)/headless
@@ -187,6 +196,7 @@ else # PLATFORM is linux
     OTHER_LDLIBS  += -Wl,-Bstatic -lgcc_eh -Wl,-Bdynamic
   endif                           
 endif
+endif
 
 endif # PLATFORM
 
diff -upr ../orig/jdk/make/sun/image/generic/Makefile ./jdk/make/sun/image/generic/Makefile
--- ../orig/jdk/make/sun/image/generic/Makefile	2009-01-27 15:44:43.000000000 -0500
+++ ./jdk/make/sun/image/generic/Makefile	2009-05-04 17:37:15.000000000 -0400
@@ -69,5 +69,9 @@ CPPFLAGS += \
             -I$(PLATFORM_SRC)/native/$(PKGDIR)/medialib 
 
 OTHER_CFLAGS += -D__USE_J2D_NAMES -D__MEDIALIB_OLD_NAMES
-OTHER_LDLIBS = $(LIBM) -ldl
+OTHER_LDLIBS = $(LIBM)
+ifneq ($(PLATFORM), bsd)
+OTHER_LDLIBS += -ldl
+endif
+
 
diff -upr ../orig/jdk/make/sun/jawt/Makefile ./jdk/make/sun/jawt/Makefile
--- ../orig/jdk/make/sun/jawt/Makefile	2009-01-27 15:44:43.000000000 -0500
+++ ./jdk/make/sun/jawt/Makefile	2009-05-05 08:50:43.000000000 -0400
@@ -98,9 +98,7 @@ else # PLATFORM
 #
 # Other extra flags needed for compiling.
 #
-CPPFLAGS += -I$(OPENWIN_HOME)/include \
-	    -I$(MOTIF_DIR)/include \
-	    -I$(SHARE_SRC)/native/$(PKGDIR)/debug \
+CPPFLAGS += -I$(SHARE_SRC)/native/$(PKGDIR)/debug \
             -I$(SHARE_SRC)/native/$(PKGDIR)/image \
 	    -I$(SHARE_SRC)/native/$(PKGDIR)/image/cvutils \
 	    -I$(SHARE_SRC)/native/$(PKGDIR)/alphacomposite \
@@ -114,6 +112,8 @@ CPPFLAGS += -I$(OPENWIN_HOME)/include \
 	    -I$(SHARE_SRC)/native/$(PKGDIR)/../dc/doe \
 	    -I$(SHARE_SRC)/native/$(PKGDIR)/../dc/path \
             -I$(PLATFORM_SRC)/native/$(PKGDIR)/../jdga \
+	    -I$(OPENWIN_HOME)/include \
+	    -I$(MOTIF_DIR)/include \
 	    $(EVENT_MODEL)
 #
 # Libraries to link in.
@@ -122,7 +122,7 @@ ifeq ($(PLATFORM), solaris)
 OTHER_LDLIBS = -L$(LIBDIR)/$(LIBARCH) -L$(OPENWIN_LIB) -L$(LIBDIR)/$(LIBARCH)/xawt -lmawt
 endif # PLATFORM
 
-ifeq ($(PLATFORM), linux)
+ifneq (,$(findstring $(PLATFORM), linux bsd))
 OTHER_LDLIBS = -L$(LIBDIR)/$(LIBARCH) -lawt -L$(LIBDIR)/$(LIBARCH)/xawt -lmawt
 endif # PLATFORM
 
diff -upr ../orig/jdk/make/sun/security/jgss/wrapper/Makefile ./jdk/make/sun/security/jgss/wrapper/Makefile
--- ../orig/jdk/make/sun/security/jgss/wrapper/Makefile	2009-01-27 15:44:44.000000000 -0500
+++ ./jdk/make/sun/security/jgss/wrapper/Makefile	2009-05-04 17:37:15.000000000 -0400
@@ -71,6 +71,10 @@ include $(BUILDDIR)/common/Library.gmk
 #
 # Libraries to link
 #
-ifneq ($(PLATFORM), windows)
+ifneq (,$(findstring $(PLATFORM), linux solaris))
   OTHER_LDLIBS = -ldl $(JVMLIB)
 endif
+
+ifeq ($(PLATFORM), bsd)
+  OTHER_LDLIBS = $(JVMLIB)
+endif
diff -upr ../orig/jdk/make/sun/security/pkcs11/Makefile ./jdk/make/sun/security/pkcs11/Makefile
--- ../orig/jdk/make/sun/security/pkcs11/Makefile	2009-01-27 15:44:44.000000000 -0500
+++ ./jdk/make/sun/security/pkcs11/Makefile	2009-05-04 17:37:15.000000000 -0400
@@ -155,7 +155,7 @@ include $(BUILDDIR)/common/Library.gmk
 #
 # Libraries to link
 #
-ifeq ($(PLATFORM), windows)
+ifneq (,$(findstring $(PLATFORM), windows bsd))
   OTHER_LDLIBS = $(JVMLIB)
 else
   OTHER_LDLIBS = -ldl $(JVMLIB)
diff -upr ../orig/jdk/make/sun/security/smartcardio/Makefile ./jdk/make/sun/security/smartcardio/Makefile
--- ../orig/jdk/make/sun/security/smartcardio/Makefile	2009-01-27 15:44:44.000000000 -0500
+++ ./jdk/make/sun/security/smartcardio/Makefile	2009-05-04 17:37:15.000000000 -0400
@@ -75,6 +75,10 @@ include $(BUILDDIR)/common/Library.gmk
 ifeq ($(PLATFORM), windows)
   OTHER_LDLIBS = $(JVMLIB) winscard.lib
 else
-  OTHER_LDLIBS = -ldl $(JVMLIB)
+  ifeq ($(PLATFORM), bsd)
+    OTHER_LDLIBS = $(JVMLIB)
+  else
+    OTHER_LDLIBS = -ldl $(JVMLIB)
+  endif
   OTHER_CFLAGS = -D__sun_jdk
 endif
diff -upr ../orig/jdk/make/sun/splashscreen/FILES_c.gmk ./jdk/make/sun/splashscreen/FILES_c.gmk
--- ../orig/jdk/make/sun/splashscreen/FILES_c.gmk	2009-01-27 15:44:45.000000000 -0500
+++ ./jdk/make/sun/splashscreen/FILES_c.gmk	2009-05-04 17:37:15.000000000 -0400
@@ -49,20 +49,6 @@ FILES_c = \
 	dgif_lib.c \
 	gif_err.c \
 	gifalloc.c \
-	compress.c \
-	deflate.c \
-	gzio.c \
-	infblock.c \
-	infcodes.c \
-	inffast.c \
-	inflate.c \
-	inftrees.c \
-	infutil.c \
-	trees.c \
-	uncompr.c \
-	zadler32.c \
-	zcrc32.c \
-	zutil.c \
 	jcomapi.c \
 	jdapimin.c \
 	jdapistd.c \
@@ -108,3 +94,20 @@ FILES_c = \
 	jfdctfst.c \
 	jfdctint.c
 
+ifneq ($(SYSTEM_ZLIB),true)
+  FILES_c += \
+	compress.c \
+	deflate.c \
+	gzio.c \
+	infblock.c \
+	infcodes.c \
+	inffast.c \
+	inflate.c \
+	inftrees.c \
+	infutil.c \
+	trees.c \
+	uncompr.c \
+	zadler32.c \
+	zcrc32.c \
+	zutil.c
+endif
diff -upr ../orig/jdk/make/sun/splashscreen/Makefile ./jdk/make/sun/splashscreen/Makefile
--- ../orig/jdk/make/sun/splashscreen/Makefile	2009-01-27 15:44:45.000000000 -0500
+++ ./jdk/make/sun/splashscreen/Makefile	2009-05-04 17:37:15.000000000 -0400
@@ -61,10 +61,26 @@ JAVALIB=
 
 CFLAGS += -DSPLASHSCREEN
 
+CPPFLAGS += -I$(PLATFORM_SRC)/native/$(PKGDIR)/splashscreen -I$(SHARE_SRC)/native/$(PKGDIR)/splashscreen
+CPPFLAGS += -I$(SHARE_SRC)/native/$(PKGDIR)/image/jpeg
+ifneq ($(SYSTEM_ZLIB),true)
+  CPPFLAGS += -I$(SHARE_SRC)/native/java/util/zip/zlib-1.1.3
+endif
+
+
 ifneq ($(PLATFORM), windows)
   CFLAGS += -DWITH_X11
-  CPPFLAGS += -I$(OPENWIN_HOME)/include -I$(OPENWIN_HOME)/include/X11/extensions
-  OTHER_LDLIBS += -L$(OPENWIN_LIB) -lX11 -lXext $(LIBM) -lpthread
+  ifeq ($(PLATFORM), bsd)
+    CFLAGS += -DPNG_NO_MMX_CODE
+    ICONV_PATH = $(PACKAGE_PATH)
+    CPPFLAGS += -I$(OPENWIN_HOME)/include \
+                -I$(OPENWIN_HOME)/include/X11/extensions \
+                -I$(ICONV_PATH)/include
+    OTHER_LDLIBS += -L$(OPENWIN_LIB) -lX11 -lXext -L$(ICONV_PATH)/lib -liconv $(LIBM) -pthread
+  else
+    CPPFLAGS += -I$(OPENWIN_HOME)/include -I$(OPENWIN_HOME)/include/X11/extensions
+    OTHER_LDLIBS += -L$(OPENWIN_LIB) -lX11 -lXext $(LIBM) -lpthread
+  endif
 else # PLATFORM
   CFLAGS += -DWITH_WIN32
   OTHER_LDLIBS += kernel32.lib user32.lib gdi32.lib 
@@ -77,14 +93,13 @@ endif # PLATFORM
 vpath %.c   $(SHARE_SRC)/native/$(PKGDIR)/splashscreen
 vpath %.c   $(SHARE_SRC)/native/$(PKGDIR)
 vpath %.c   $(SHARE_SRC)/native/$(PKGDIR)/giflib
-vpath %.c   $(SHARE_SRC)/native/java/util/zip/zlib-1.1.3
+ifneq ($(SYSTEM_ZLIB),true)
+  vpath %.c   $(SHARE_SRC)/native/java/util/zip/zlib-1.1.3
+endif
 vpath %.c   $(SHARE_SRC)/native/$(PKGDIR)/libpng
 vpath %.c   $(SHARE_SRC)/native/$(PKGDIR)/image/jpeg
 vpath %.c   $(PLATFORM_SRC)/native/$(PKGDIR)/splashscreen
 
-CPPFLAGS += -I$(PLATFORM_SRC)/native/$(PKGDIR)/splashscreen -I$(SHARE_SRC)/native/$(PKGDIR)/splashscreen
-CPPFLAGS += -I$(SHARE_SRC)/native/$(PKGDIR)/image/jpeg -I$(SHARE_SRC)/native/java/util/zip/zlib-1.1.3
-
 ifeq ($(PLATFORM), linux)
   ifeq ($(ARCH_DATA_MODEL), 64)
     # 64-bit gcc has problems compiling MMX instructions.
diff -upr ../orig/jdk/make/sun/xawt/Makefile ./jdk/make/sun/xawt/Makefile
--- ../orig/jdk/make/sun/xawt/Makefile	2009-01-27 15:44:45.000000000 -0500
+++ ./jdk/make/sun/xawt/Makefile	2009-05-04 17:37:15.000000000 -0400
@@ -53,6 +53,11 @@ LDFLAGS += -lpthread
 dummy := $(shell $(MKDIR) -p $(LIB_LOCATION))
 endif
 
+ifeq ($(PLATFORM), bsd)
+LDFLAGS += -pthread
+dummy := $(shell $(MKDIR) -p $(LIB_LOCATION))
+endif
+
 # Since this library will be living in a subdirectory below the other libraries
 #   we need to add an extra runpath so that libraries in the upper directory
 #   are found at runtime.
@@ -86,7 +91,12 @@ vpath %.c   $(SHARE_SRC)/native/sun/java
 vpath %.c   $(PLATFORM_SRC)/native/sun/java2d/opengl
 vpath %.c   $(PLATFORM_SRC)/native/sun/java2d/x11
 
-OTHER_LDLIBS = $(LIBM) -lawt -lXext -lX11 -ldl \
+ifeq ($(PLATFORM), bsd)
+LIBDL=
+else
+LIBDL=-ldl
+endif
+OTHER_LDLIBS = $(LIBM) -lawt -lXext -lX11 $(LIBDL) \
                    $(LDFLAGS_COMMON) $(AWT_RUNPATH) $(OTHER_LDFLAGS) -lXtst -lXi
 
 ifeq  ($(PLATFORM), solaris)
@@ -94,8 +104,6 @@ CPPFLAGS += -DFUNCPROTO=15
 dummy := $(shell $(MKDIR) -p $(LIB_LOCATION))
 endif
 
-CPPFLAGS += -I$(CUPS_HEADERS_PATH)
-
 CPPFLAGS += -DXAWT -DXAWT_HACK \
         -I$(TEMPDIR)/../../sun.awt/awt/CClassHeaders \
         -I$(PLATFORM_SRC)/native/sun/awt \
@@ -122,9 +130,11 @@ CPPFLAGS += -DXAWT -DXAWT_HACK \
         -I$(SHARE_SRC)/native/sun/awt \
         -I$(PLATFORM_SRC)/native/sun/awt 
 
+CPPFLAGS += -I$(CUPS_HEADERS_PATH)
+
 ifeq ($(PLATFORM), linux)
 # Allows for builds on Debian GNU Linux, X11 is in a different place 
-  CPPFLAGS += -I/usr/X11R6/include/X11/extensions \
+  CPPFLAGS += -I$(OPENWIN_HOME)/include/X11/extensions \
               -I/usr/include/X11/extensions \
               -I$(MOTIF_DIR)/include \
               -I$(OPENWIN_HOME)/include 
@@ -134,6 +144,14 @@ ifeq ($(PLATFORM), solaris)
   CPPFLAGS += -I$(OPENWIN_HOME)/include/X11/extensions -I$(MOTIF_DIR)/include 
 endif
 
+ifeq ($(PLATFORM), bsd)
+  CPPFLAGS += -I$(OPENWIN_HOME)/include/X11/extensions -I$(OPENWIN_HOME)/include
+endif
+
+ifneq ($(PLATFORM), windows)
+  CPPFLAGS += -DX11_PATH=\"$(X11_PATH)\" -DPACKAGE_PATH=\"$(PACKAGE_PATH)\"
+endif
+
 ifeq ($(MILESTONE), internal)
   CPPFLAGS += -DINTERNAL_BUILD
 endif
diff -upr ../orig/jdk/make/tools/freetypecheck/Makefile ./jdk/make/tools/freetypecheck/Makefile
--- ../orig/jdk/make/tools/freetypecheck/Makefile	2009-01-27 15:44:46.000000000 -0500
+++ ./jdk/make/tools/freetypecheck/Makefile	2009-05-04 17:37:17.000000000 -0400
@@ -60,8 +60,12 @@ else
   #add runtime lib search path to ensure test will be runnable
   ifeq ($(PLATFORM), solaris)
     FT_OPTIONS += -R $(FT_LIB) -lfreetype
-  else #linux
-      FT_OPTIONS += -Wl,-rpath -Wl,$(FT_LIB) -lfreetype
+  else 
+    ifeq ($(PLATFORM), bsd)
+      FT_OPTIONS += -lfreetype -lz
+    else # linux
+        FT_OPTIONS += -Wl,-rpath -Wl,$(FREETYPE_LIB_PATH) -lfreetype
+    endif
   endif
 endif
 
diff -upr ../orig/jdk/src/share/back/commonRef.c ./jdk/src/share/back/commonRef.c
--- ../orig/jdk/src/share/back/commonRef.c	2009-01-27 15:44:50.000000000 -0500
+++ ./jdk/src/share/back/commonRef.c	2009-05-04 17:37:16.000000000 -0400
@@ -23,6 +23,10 @@
  * have any questions.
  */
 
+#if defined(_ALLBSD_SOURCE)
+#include <stdint.h>			/* for uintptr_t */
+#endif
+
 #include "util.h"
 #include "commonRef.h"
 
diff -upr ../orig/jdk/src/share/bin/java.c ./jdk/src/share/bin/java.c
--- ../orig/jdk/src/share/bin/java.c	2009-01-27 15:44:50.000000000 -0500
+++ ./jdk/src/share/bin/java.c	2009-05-04 17:37:17.000000000 -0400
@@ -104,6 +104,11 @@ static char *progname;
 static char *launchername;
 jboolean _launcher_debug = JNI_FALSE;
 
+#ifdef __APPLE__
+static jboolean continueInSameThread = JNI_FALSE; /* start VM in current thread */
+#endif
+
+
 /*
  * Entries for splash screen environment variables.
  * putenv is performed in SelectVersion. We need
@@ -146,6 +151,10 @@ static void PrintUsage(JNIEnv* env, jboo
 static void SetPaths(int argc, char **argv);
 
 
+#ifdef __APPLE__
+static int ContinueInSameThread(InvocationFunctions* ifn, int argc, char **argv, char *jarfile, char *classname, int ret);
+#endif
+
 /* Maximum supported entries from jvm.cfg. */
 #define INIT_MAX_KNOWN_VMS      10
 /* Values for vmdesc.flag */
@@ -184,13 +193,13 @@ static jlong threadStackSize = 0;  /* st
 
 int JNICALL JavaMain(void * args); /* entry point                  */
 
-struct JavaMainArgs {
+typedef struct {
   int     argc;
   char ** argv;
   char *  jarfile;
   char *  classname;
   InvocationFunctions ifn;
-};
+} JavaMainArgs;
 
 /*
  * Entry point.
@@ -332,49 +341,24 @@ main(int argc, char ** argv)
     /* Show the splash screen if needed */
     ShowSplashScreen();
 
-    /*
-     * Done with all command line processing and potential re-execs so
-     * clean up the environment.
-     */
-    (void)UnsetEnv(ENV_ENTRY);
-    (void)UnsetEnv(SPLASH_FILE_ENV_ENTRY);
-    (void)UnsetEnv(SPLASH_JAR_ENV_ENTRY);
-
-    JLI_MemFree(splash_jar_entry);
-    JLI_MemFree(splash_file_entry);
 
-    /*
-     * If user doesn't specify stack size, check if VM has a preference.
-     * Note that HotSpot no longer supports JNI_VERSION_1_1 but it will
-     * return its default stack size through the init args structure.
-     */
-    if (threadStackSize == 0) {
-      struct JDK1_1InitArgs args1_1;
-      memset((void*)&args1_1, 0, sizeof(args1_1));
-      args1_1.version = JNI_VERSION_1_1;
-      ifn.GetDefaultJavaVMInitArgs(&args1_1);  /* ignore return value */
-      if (args1_1.javaStackSize > 0) {
-         threadStackSize = args1_1.javaStackSize;
+#ifdef __APPLE__
+      if (continueInSameThread == JNI_TRUE) {
+        return ContinueInSameThread(&ifn, argc, argv, jarfile, classname, ret);
+      } else {
+        return ContinueInNewThread(&ifn, argc, argv, jarfile, classname, ret);
       }
-    }
-
-    { /* Create a new thread to create JVM and invoke main method */
-      struct JavaMainArgs args;
+#else
 
-      args.argc = argc;
-      args.argv = argv;
-      args.jarfile = jarfile;
-      args.classname = classname;
-      args.ifn = ifn;
+      return ContinueInNewThread(&ifn, argc, argv, jarfile, classname, ret);
+#endif
 
-      return ContinueInNewThread(JavaMain, threadStackSize, (void*)&args, ret);
-    }
 }
 
 int JNICALL
 JavaMain(void * _args)
 {
-    struct JavaMainArgs *args = (struct JavaMainArgs *)_args;
+    JavaMainArgs *args = (JavaMainArgs *)_args;
     int argc = args->argc;
     char **argv = args->argv;
     char *jarfile = args->jarfile;
@@ -1159,6 +1143,10 @@ ParseArguments(int *pargc, char ***pargv
         } else if (strcmp(arg, "-X") == 0) {
             printXUsage = JNI_TRUE;
             return JNI_TRUE;
+#ifdef __APPLE__
+        } else if (JLI_StrCmp(arg, "-XstartOnFirstThread") == 0) {
+            continueInSameThread = JNI_TRUE;
+#endif            
 /*
  * The following case provide backward compatibility with old-style
  * command line options.
@@ -1979,6 +1967,84 @@ KnownVMIndex(const char* name)
     return -1;
 }
 
+static int
+ContinueInNewThread(InvocationFunctions* ifn, int argc,
+                     char **argv, char *jarfile, char *classname, int ret)
+{
+
+    /*
+     * If user doesn't specify stack size, check if VM has a preference.
+     * Note that HotSpot no longer supports JNI_VERSION_1_1 but it will
+     * return its default stack size through the init args structure.
+     */
+    if (threadStackSize == 0) {
+      struct JDK1_1InitArgs args1_1;
+      memset((void*)&args1_1, 0, sizeof(args1_1));
+      args1_1.version = JNI_VERSION_1_1;
+      ifn->GetDefaultJavaVMInitArgs(&args1_1);  /* ignore return value */
+      if (args1_1.javaStackSize > 0) {
+         threadStackSize = args1_1.javaStackSize;
+      }
+    }
+
+    { /* Create a new thread to create JVM and invoke main method */
+      JavaMainArgs args;
+      int rslt;
+
+      args.argc = argc;
+      args.argv = argv;
+      args.jarfile = jarfile;
+      args.classname = classname;
+      args.ifn = *ifn;
+
+      rslt = ContinueInNewThread0(JavaMain, threadStackSize, (void*)&args);
+      /* If the caller has deemed there is an error we
+       * simply return that, otherwise we return the value of
+       * the callee
+       */
+      return (ret != 0) ? ret : rslt;
+    }
+}
+
+
+#ifdef __APPLE__
+static int
+ContinueInSameThread(InvocationFunctions* ifn, int argc,
+                    char **argv, char *jarfile, char *classname, int ret)
+{
+        
+    /*
+     * If user doesn't specify stack size, check if VM has a preference.
+     * Note that HotSpot no longer supports JNI_VERSION_1_1 but it will
+     * return its default stack size through the init args structure.
+     */
+    if (threadStackSize == 0) {
+        struct JDK1_1InitArgs args1_1;
+        memset((void*)&args1_1, 0, sizeof(args1_1));
+        args1_1.version = JNI_VERSION_1_1;
+        ifn->GetDefaultJavaVMInitArgs(&args1_1);  /* ignore return value */
+        if (args1_1.javaStackSize > 0) {
+            threadStackSize = args1_1.javaStackSize;
+        }
+    }
+    
+    { /* Create create JVM and invoke main method */
+        JavaMainArgs args;
+        int rslt;
+        
+        args.argc = argc;
+        args.argv = argv;
+        args.jarfile = jarfile;
+        args.classname = classname;
+        args.ifn = *ifn;
+        
+        rslt = JavaMain((void*)&args);
+        
+        return (ret != 0) ? ret : rslt;
+    }
+}
+#endif
+
 static void
 FreeKnownVMs()
 {
diff -upr ../orig/jdk/src/share/bin/java.h ./jdk/src/share/bin/java.h
--- ../orig/jdk/src/share/bin/java.h	2009-01-27 15:44:50.000000000 -0500
+++ ./jdk/src/share/bin/java.h	2009-05-04 17:37:17.000000000 -0400
@@ -91,11 +91,17 @@ jboolean RemovableMachineDependentOption
 void PrintMachineDependentOptions();
 
 const char *jlong_format_specifier();
+
 /*
  * Block current thread and continue execution in new thread
  */
-int ContinueInNewThread(int (JNICALL *continuation)(void *),
-                        jlong stack_size, void * args, int ret);
+int ContinueInNewThread0(int (JNICALL *continuation)(void *),
+                        jlong stack_size, void * args);
+
+
+ static int ContinueInNewThread(InvocationFunctions* ifn, int argc, char** argv,
+                         char* jarfile, char* classname, int ret);
+
 
 /* sun.java.launcher.* platform properties. */
 void SetJavaLauncherPlatformProps(void);
diff -upr ../orig/jdk/src/share/classes/com/sun/java/swing/plaf/gtk/Metacity.java ./jdk/src/share/classes/com/sun/java/swing/plaf/gtk/Metacity.java
--- ../orig/jdk/src/share/classes/com/sun/java/swing/plaf/gtk/Metacity.java	2009-01-27 15:44:52.000000000 -0500
+++ ./jdk/src/share/classes/com/sun/java/swing/plaf/gtk/Metacity.java	2009-05-04 17:37:16.000000000 -0400
@@ -477,6 +477,10 @@ class Metacity implements SynthConstants
                 String[] dirs = new String[] {
                     userHome + sep + ".themes",
                     System.getProperty("swing.metacitythemedir"),
+		    "/usr/X11R6/share/themes",
+		    "/usr/X11R6/share/gnome/themes",
+		    "/usr/local/share/themes",
+		    "/usr/local/share/gnome/themes",
                     "/usr/share/themes",
                     "/usr/gnome/share/themes",  // Debian/Redhat/Solaris
                     "/opt/gnome2/share/themes"  // SuSE
diff -upr ../orig/jdk/src/share/classes/com/sun/jmx/snmp/SnmpPduTrap.java ./jdk/src/share/classes/com/sun/jmx/snmp/SnmpPduTrap.java
--- ../orig/jdk/src/share/classes/com/sun/jmx/snmp/SnmpPduTrap.java	2009-01-27 15:44:56.000000000 -0500
+++ ./jdk/src/share/classes/com/sun/jmx/snmp/SnmpPduTrap.java	2009-05-04 17:37:16.000000000 -0400
@@ -78,6 +78,9 @@ public class SnmpPduTrap extends SnmpPdu
      */
     public long            timeStamp ;
 
+    // TODO: IcedTea: I am a stub.
+    static public int trapAuthenticationFailure = 0;
+
 
 
     /**
diff -upr ../orig/jdk/src/share/classes/java/awt/GraphicsEnvironment.java ./jdk/src/share/classes/java/awt/GraphicsEnvironment.java
--- ../orig/jdk/src/share/classes/java/awt/GraphicsEnvironment.java	2009-01-27 15:45:05.000000000 -0500
+++ ./jdk/src/share/classes/java/awt/GraphicsEnvironment.java	2009-05-04 17:37:16.000000000 -0400
@@ -148,7 +148,12 @@ public abstract class GraphicsEnvironmen
                         } else {
                             String osName = System.getProperty("os.name");
                             headless = defaultHeadless =
-                                Boolean.valueOf(("Linux".equals(osName) || "SunOS".equals(osName)) &&
+                                Boolean.valueOf(("Linux".equals(osName) ||
+                                                "SunOS".equals(osName) ||
+                                                "FreeBSD".equals(osName) ||
+                                                "NetBSD".equals(osName) ||
+                                                "OpenBSD".equals(osName) ||
+                                                "Darwin".equals(osName)) &&
                                                 (System.getenv("DISPLAY") == null));
                         }
                     } else if (nm.equals("true")) {
diff -upr ../orig/jdk/src/share/classes/java/util/TimeZone.java ./jdk/src/share/classes/java/util/TimeZone.java
--- ../orig/jdk/src/share/classes/java/util/TimeZone.java	2009-01-27 15:45:18.000000000 -0500
+++ ./jdk/src/share/classes/java/util/TimeZone.java	2009-05-04 17:37:16.000000000 -0400
@@ -779,15 +779,13 @@ abstract public class TimeZone implement
         }
         int gmtOffset =  (hours * 60 + num) * 60 * 1000;
 
+        zi = ZoneInfoFile.getCustomTimeZone(id, negative ? -gmtOffset : gmtOffset);
         if (gmtOffset == 0) {
-            zi = ZoneInfoFile.getZoneInfo(GMT_ID);
             if (negative) {
                 zi.setID("GMT-00:00");
             } else {
                 zi.setID("GMT+00:00");
             }
-        } else {
-            zi = ZoneInfoFile.getCustomTimeZone(id, negative ? -gmtOffset : gmtOffset);
         }
         return zi;
     }
diff -upr ../orig/jdk/src/share/classes/sun/awt/FontConfiguration.java ./jdk/src/share/classes/sun/awt/FontConfiguration.java
--- ../orig/jdk/src/share/classes/sun/awt/FontConfiguration.java	2009-01-27 15:45:29.000000000 -0500
+++ ./jdk/src/share/classes/sun/awt/FontConfiguration.java	2009-05-04 17:37:16.000000000 -0400
@@ -1073,7 +1073,7 @@ public abstract class FontConfiguration 
      */
     HashMap<String, Boolean> existsMap;
     public boolean needToSearchForFile(String fileName) {
-        if (!environment.isLinux) {
+        if (!environment.isLinuxOrBSD) {
             return false;
         } else if (existsMap == null) {
            existsMap = new HashMap<String, Boolean>();
@@ -1309,7 +1309,7 @@ public abstract class FontConfiguration 
                                    + "<filename."
                                    + getString(table_componentFontNameIDs[ii])
                                    + "> entry is missing!!!");
-                if (!osName.contains("Linux")) {
+                if (!osName.contains("Linux") && !osName.contains("BSD") && !osName.contains("Darwin")) {
                     errors++;
                 }
             }
diff -upr ../orig/jdk/src/share/classes/sun/java2d/SunGraphicsEnvironment.java ./jdk/src/share/classes/sun/java2d/SunGraphicsEnvironment.java
--- ../orig/jdk/src/share/classes/sun/java2d/SunGraphicsEnvironment.java	2009-01-27 15:45:30.000000000 -0500
+++ ./jdk/src/share/classes/sun/java2d/SunGraphicsEnvironment.java	2009-05-04 17:37:16.000000000 -0400
@@ -76,7 +76,7 @@ import sun.font.NativeFont;
 public abstract class SunGraphicsEnvironment extends GraphicsEnvironment
     implements FontSupport, DisplayChangedListener {
 
-    public static boolean isLinux;
+    public static boolean isLinuxOrBSD;
     public static boolean isSolaris;
     public static boolean isWindows;
     public static boolean noType1Font;
@@ -164,7 +164,15 @@ public abstract class SunGraphicsEnviron
             public Object run() {
                 String osName = System.getProperty("os.name");
                 if ("Linux".equals(osName)) {
-                    isLinux = true;
+                    isLinuxOrBSD = true;
+                } else if ("FreeBSD".equals(osName)) {
+                    isLinuxOrBSD = true;
+                } else if ("Darwin".equals(osName)) {
+                    isLinuxOrBSD = true;
+                } else if ("NetBSD".equals(osName)) {
+                    isLinuxOrBSD = true;
+                } else if ("OpenBSD".equals(osName)) {
+                    isLinuxOrBSD = true;
                 } else if ("SunOS".equals(osName)) {
                     isSolaris = true;
                 } else if ("Windows".equals(osName)) {
@@ -227,8 +235,8 @@ public abstract class SunGraphicsEnviron
                  * Pass "true" to registerFonts method as on-screen these
                  * JRE fonts always go through the T2K rasteriser.
                  */
-                if (isLinux) {
-                    /* Linux font configuration uses these fonts */
+                if (isLinuxOrBSD) {
+                    /* Linux/BSD font configuration uses these fonts */
                     registerFontDir(jreFontDirName);
                 }
                 registerFontsInDir(jreFontDirName, true, Font2D.JRE_RANK,
diff -upr ../orig/jdk/src/share/classes/sun/print/PSPrinterJob.java ./jdk/src/share/classes/sun/print/PSPrinterJob.java
--- ../orig/jdk/src/share/classes/sun/print/PSPrinterJob.java	2009-01-27 15:45:34.000000000 -0500
+++ ./jdk/src/share/classes/sun/print/PSPrinterJob.java	2009-05-04 17:37:16.000000000 -0400
@@ -1531,7 +1531,9 @@ public class PSPrinterJob extends Raster
             pFlags |= NOSHEET;
             ncomps+=1;
         }
-       if (System.getProperty("os.name").equals("Linux")) {
+
+       String osname = System.getProperty("os.name");
+       if (osname.equals("Linux") || osname.equals("FreeBSD") || osname.equals("NetBSD") || osname.equals("OpenBSD") || osname.equals("Darwin")) {
             execCmd = new String[ncomps];
             execCmd[n++] = "/usr/bin/lpr";
             if ((pFlags & PRINTER) != 0) {
diff -upr ../orig/jdk/src/share/classes/sun/tools/jar/Main.java ./jdk/src/share/classes/sun/tools/jar/Main.java
--- ../orig/jdk/src/share/classes/sun/tools/jar/Main.java	2009-01-27 15:45:40.000000000 -0500
+++ ./jdk/src/share/classes/sun/tools/jar/Main.java	2009-05-04 17:37:17.000000000 -0400
@@ -46,6 +46,7 @@ class Main {
     String zname = "";
     String[] files;
     String rootjar = null;
+    String cwd;
     Hashtable filesTable = new Hashtable();
     Vector paths = new Vector();
     Vector v;
@@ -770,6 +771,19 @@ class Main {
      * Extracts specified entries from JAR file.
      */
     void extract(InputStream in, String files[]) throws IOException {
+        // Current working directory
+
+        cwd = System.getProperty("user.dir");
+        if (cwd == null) {
+            fatalError(getMsg("error.no.cwd"));
+        }
+        cwd = (new File(cwd)).getCanonicalPath();
+        if (!cwd.endsWith(File.separator)) {
+            cwd += File.separator;
+        }
+
+        // Extract the files
+
         ZipInputStream zis = new ZipInputStream(in);
         ZipEntry e;
         // Set of all directory entries specified in archive.  Dissallows
@@ -817,6 +831,10 @@ class Main {
         ZipEntry rc = null;
         String name = e.getName();
         File f = new File(e.getName().replace('/', File.separatorChar));
+        if (!f.getCanonicalPath().startsWith(cwd)) {
+            output(formatMsg("out.ignore.entry", name));
+            return null;
+        }
         if (e.isDirectory()) {
             if (f.exists()) {
                 if (!f.isDirectory()) {
@@ -838,6 +856,10 @@ class Main {
         } else {
             if (f.getParent() != null) {
                 File d = new File(f.getParent());
+                if (!d.getCanonicalPath().startsWith(cwd)) {
+                    output(formatMsg("out.ignore.entry", name));
+                    return null;
+                }
                 if (!d.exists() && !d.mkdirs() || !d.isDirectory()) {
                     throw new IOException(formatMsg(
                         "error.create.dir", d.getPath()));
diff -upr ../orig/jdk/src/share/classes/sun/tools/jar/resources/jar.properties ./jdk/src/share/classes/sun/tools/jar/resources/jar.properties
--- ../orig/jdk/src/share/classes/sun/tools/jar/resources/jar.properties	2009-01-27 15:45:40.000000000 -0500
+++ ./jdk/src/share/classes/sun/tools/jar/resources/jar.properties	2009-05-04 17:37:16.000000000 -0400
@@ -44,6 +44,8 @@ error.create.dir=\
         {0} : could not create directory
 error.incorrect.length=\
         incorrect length while processing: {0}
+error.no.cwd=\
+	{0} : could not determine current working directory
 out.added.manifest=\
         added manifest
 out.update.manifest=\
diff -upr ../orig/jdk/src/share/hpi/include/hpi_impl.h ./jdk/src/share/hpi/include/hpi_impl.h
--- ../orig/jdk/src/share/hpi/include/hpi_impl.h	2009-01-27 15:45:43.000000000 -0500
+++ ./jdk/src/share/hpi/include/hpi_impl.h	2009-05-04 17:37:16.000000000 -0400
@@ -138,7 +138,11 @@ int sysConnect(int fd, struct sockaddr *
 int sysBind(int fd, struct sockaddr *him, int len);
 int sysAccept(int fd, struct sockaddr *him, int *len);
 int sysGetSockName(int fd, struct sockaddr *him, int *len);
-#ifdef _LP64
+#if defined(_LP64) || defined(_ALLBSD_SOURCE)
+// XXXBSD: The implementations all use ssize_t, except on Windows,
+// regardless of _LP64. The resulting mismatch between "int" and "ssize_t"
+// causes gcc on Darwin to report a conflicting types error.
+// Appears to be an upstream issue introduced in 1.7
 ssize_t sysSendTo(int fd, char *buf, int len, int flags, struct sockaddr *to,
               int tolen);
 ssize_t sysRecvFrom(int fd, char *buf, int nbytes, int flags,
diff -upr ../orig/jdk/src/share/lib/security/java.security-openbsd ./jdk/src/share/lib/security/java.security-openbsd
--- ../orig/jdk/src/share/lib/security/java.security-openbsd	2009-05-04 18:32:16.000000000 -0400
+++ ./jdk/src/share/lib/security/java.security-openbsd	2009-05-05 09:50:18.000000000 -0400
@@ -66,7 +66,14 @@ security.provider.8=sun.security.smartca
 # On Windows systems, the URLs file:/dev/random and file:/dev/urandom
 # enables use of the Microsoft CryptoAPI seed functionality.
 #
-securerandom.source=file:/dev/urandom
+# On OpenBSD use file:///dev/srandom for strong but blocking random
+# generator, file:/dev/random for hardware random generators,
+# file:///dev/arandom for non-blocking high-quality pseudo-random
+# data and file:///dev/urandom for non-blocking random data that
+# does not guarantee the data to be strong. See random(4) for more
+# info.
+#
+securerandom.source=file:///dev/arandom
 #
 # The entropy gathering device is described as a URL and can also
 # be specified with the system property "java.security.egd". For example,
diff -upr ../orig/jdk/src/share/native/com/sun/java/util/jar/pack/defines.h ./jdk/src/share/native/com/sun/java/util/jar/pack/defines.h
--- ../orig/jdk/src/share/native/com/sun/java/util/jar/pack/defines.h	2009-01-27 15:45:44.000000000 -0500
+++ ./jdk/src/share/native/com/sun/java/util/jar/pack/defines.h	2009-05-04 17:37:16.000000000 -0400
@@ -32,6 +32,10 @@
 #include <unistd.h>
 #endif
 
+#ifndef NO_ZLIB
+#      include <zconf.h>
+#endif
+
 #ifndef FULL
 #define FULL 1 /* Adds <500 bytes to the zipped final product. */
 #endif
@@ -89,11 +93,13 @@ extern void assert_failed(const char*);
 // bytes and byte arrays
 
 typedef unsigned int uint;
+#ifdef NO_ZLIB
 #ifdef _LP64
 typedef unsigned int uLong; // Historical zlib, should be 32-bit.
 #else
 typedef unsigned long uLong;
 #endif
+#endif
 #ifdef _MSC_VER
 typedef LONGLONG        jlong;
 typedef DWORDLONG       julong;
diff -upr ../orig/jdk/src/share/native/com/sun/java/util/jar/pack/main.cpp ./jdk/src/share/native/com/sun/java/util/jar/pack/main.cpp
--- ../orig/jdk/src/share/native/com/sun/java/util/jar/pack/main.cpp	2009-01-27 15:45:44.000000000 -0500
+++ ./jdk/src/share/native/com/sun/java/util/jar/pack/main.cpp	2009-05-04 17:37:16.000000000 -0400
@@ -33,9 +33,14 @@
 #include <limits.h>
 #include <time.h>
 
+/* !PRODUCT needs intptr_t */
+#if defined(_ALLBSD_SOURCE) && !defined(PRODUCT)
+#include <stdint.h>
+#endif
+
 #if defined(unix) && !defined(PRODUCT)
 #include "pthread.h"
-#define THREAD_SELF ((int)pthread_self())
+#define THREAD_SELF ((intptr_t) pthread_self())
 #endif
 
 #include "defines.h"
@@ -58,9 +63,9 @@ int main(int argc, char **argv) {
 // Single-threaded, implementation, not reentrant.
 // Includes a weak error check against MT access.
 #ifndef THREAD_SELF
-#define THREAD_SELF (0)
+#define THREAD_SELF ((intptr_t) 0)
 #endif
-NOT_PRODUCT(static int uThread = -1;)
+NOT_PRODUCT(static intptr_t uThread = -1;)
 
 unpacker* unpacker::non_mt_current = null;
 unpacker* unpacker::current() {
@@ -69,7 +74,7 @@ unpacker* unpacker::current() {
 }
 static void set_current_unpacker(unpacker* u) {
   unpacker::non_mt_current = u;
-  assert(((uThread = (u == null) ? -1 : THREAD_SELF),
+  assert(((uThread = (u == null) ? ((intptr_t) -1) : THREAD_SELF),
           true));
 }
 
diff -upr ../orig/jdk/src/share/native/com/sun/media/sound/DirectAudioDevice.c ./jdk/src/share/native/com/sun/media/sound/DirectAudioDevice.c
--- ../orig/jdk/src/share/native/com/sun/media/sound/DirectAudioDevice.c	2009-01-27 15:45:44.000000000 -0500
+++ ./jdk/src/share/native/com/sun/media/sound/DirectAudioDevice.c	2009-05-04 17:37:16.000000000 -0400
@@ -33,7 +33,11 @@
 
 #include <jni.h>
 // for malloc
+#ifdef _ALLBSD_SOURCE
+#include <stdlib.h>
+#else
 #include <malloc.h>
+#endif
 #include "SoundDefs.h"
 #include "DirectAudio.h"
 #include "Utilities.h"
diff -upr ../orig/jdk/src/share/native/com/sun/media/sound/Platform.c ./jdk/src/share/native/com/sun/media/sound/Platform.c
--- ../orig/jdk/src/share/native/com/sun/media/sound/Platform.c	2009-01-27 15:45:44.000000000 -0500
+++ ./jdk/src/share/native/com/sun/media/sound/Platform.c	2009-05-04 17:37:16.000000000 -0400
@@ -99,5 +99,17 @@ JNIEXPORT jint JNICALL Java_com_sun_medi
         return com_sun_media_sound_Platform_LIB_ALSA;
     }
 #endif
+#if (X_PLATFORM == X_BSD)
+    switch (feature) {
+    case com_sun_media_sound_Platform_FEATURE_MIDIIO:
+       return com_sun_media_sound_Platform_LIB_MAIN;
+    case com_sun_media_sound_Platform_FEATURE_PORTS:
+       return com_sun_media_sound_Platform_LIB_MAIN;
+    case com_sun_media_sound_Platform_FEATURE_DIRECT_AUDIO:
+       // XXXBSD: When native Direct Audio support is ported change
+       // this back to returning com_sun_media_sound_Platform_LIB_MAIN
+       return 0;
+    }
+#endif
     return 0;
 }
diff -upr ../orig/jdk/src/share/native/com/sun/media/sound/SoundDefs.h ./jdk/src/share/native/com/sun/media/sound/SoundDefs.h
--- ../orig/jdk/src/share/native/com/sun/media/sound/SoundDefs.h	2009-01-27 15:45:44.000000000 -0500
+++ ./jdk/src/share/native/com/sun/media/sound/SoundDefs.h	2009-05-04 17:37:16.000000000 -0400
@@ -31,6 +31,7 @@
 #define X_WINDOWS       1
 #define X_SOLARIS       2
 #define X_LINUX         3
+#define X_BSD           4
 
 // types for X_ARCH
 #define X_I586          1
@@ -49,7 +50,7 @@
 
 
 // following is needed for _LP64
-#if ((X_PLATFORM == X_SOLARIS) || (X_PLATFORM == X_LINUX))
+#if ((X_PLATFORM == X_SOLARIS) || (X_PLATFORM == X_LINUX) || (X_PLATFORM == X_BSD))
 #include <sys/types.h>
 #endif
 
@@ -129,4 +130,9 @@ typedef char            SBYTE;
 #endif
 
 
+#if X_PLATFORM == X_BSD
+#define INLINE          inline
+#endif
+
+
 #endif  // __SOUNDDEFS_INCLUDED__
diff -upr ../orig/jdk/src/share/native/common/check_code.c ./jdk/src/share/native/common/check_code.c
--- ../orig/jdk/src/share/native/common/check_code.c	2009-01-27 15:45:44.000000000 -0500
+++ ./jdk/src/share/native/common/check_code.c	2009-05-04 17:37:17.000000000 -0400
@@ -1069,7 +1069,7 @@ verify_method(context_type *context, jcl
  * Make sure that branches don't go into the middle of nowhere.
  */
 
-static jint ntohl(jint n)
+static jint _ck_ntohl(jint n)
 {
     unsigned char *p = (unsigned char *)&n;
     return (p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3];
@@ -1148,26 +1148,26 @@ verify_opcode_operands(context_type *con
             }
         }
         if (opcode == opc_tableswitch) {
-            keys = ntohl(lpc[2]) -  ntohl(lpc[1]) + 1;
+            keys = _ck_ntohl(lpc[2]) -  _ck_ntohl(lpc[1]) + 1;
             delta = 1;
         } else {
-            keys = ntohl(lpc[1]); /* number of pairs */
+            keys = _ck_ntohl(lpc[1]); /* number of pairs */
             delta = 2;
             /* Make sure that the tableswitch items are sorted */
             for (k = keys - 1, lptr = &lpc[2]; --k >= 0; lptr += 2) {
-                int this_key = ntohl(lptr[0]);  /* NB: ntohl may be unsigned */
-                int next_key = ntohl(lptr[2]);
+                int this_key = _ck_ntohl(lptr[0]);  /* NB: ntohl may be unsigned */
+                int next_key = _ck_ntohl(lptr[2]);
                 if (this_key >= next_key) {
                     CCerror(context, "Unsorted lookup switch");
                 }
             }
         }
         saved_operand = NEW(int, keys + 2);
-        if (!isLegalTarget(context, offset + ntohl(lpc[0])))
+        if (!isLegalTarget(context, offset + _ck_ntohl(lpc[0])))
             CCerror(context, "Illegal default target in switch");
-        saved_operand[keys + 1] = code_data[offset + ntohl(lpc[0])];
+        saved_operand[keys + 1] = code_data[offset + _ck_ntohl(lpc[0])];
         for (k = keys, lptr = &lpc[3]; --k >= 0; lptr += delta) {
-            int target = offset + ntohl(lptr[0]);
+            int target = offset + _ck_ntohl(lptr[0]);
             if (!isLegalTarget(context, target))
                 CCerror(context, "Illegal branch in opc_tableswitch");
             saved_operand[k + 1] = code_data[target];
@@ -1615,7 +1615,7 @@ static int instruction_length(unsigned c
             if (lpc + 2 >= (int *)end) {
                 return -1; /* do not read pass the end */
             }
-            index = ntohl(lpc[2]) - ntohl(lpc[1]);
+	    index = _ck_ntohl(lpc[2]) - _ck_ntohl(lpc[1]);
             if ((index < 0) || (index > 65535)) {
                 return -1;      /* illegal */
             } else {
@@ -1628,7 +1628,7 @@ static int instruction_length(unsigned c
             int npairs;
             if (lpc + 1 >= (int *)end)
                 return -1; /* do not read pass the end */
-            npairs = ntohl(lpc[1]);
+	    npairs = _ck_ntohl(lpc[1]);
             /* There can't be more than 64K labels because of the limit
              * on per-method byte code length.
              */
diff -upr ../orig/jdk/src/share/native/java/io/io_util.h ./jdk/src/share/native/java/io/io_util.h
--- ../orig/jdk/src/share/native/java/io/io_util.h	2009-01-27 15:45:44.000000000 -0500
+++ ./jdk/src/share/native/java/io/io_util.h	2009-05-04 17:37:16.000000000 -0400
@@ -29,7 +29,15 @@
 extern jfieldID IO_fd_fdID;
 extern jfieldID IO_handle_fdID;
 
-#if !defined(O_DSYNC) || !defined(O_SYNC)
+#ifdef _ALLBSD_SOURCE
+#include <fcntl.h>
+#ifndef O_SYNC
+#define O_SYNC  O_FSYNC
+#endif
+#ifndef O_DSYNC
+#define O_DSYNC O_FSYNC
+#endif
+#elif !defined(O_DSYNC) || !defined(O_SYNC)
 #define O_SYNC  (0x0800)
 #define O_DSYNC (0x2000)
 #endif
diff -upr ../orig/jdk/src/share/native/java/lang/fdlibm/include/fdlibm.h ./jdk/src/share/native/java/lang/fdlibm/include/fdlibm.h
--- ../orig/jdk/src/share/native/java/lang/fdlibm/include/fdlibm.h	2009-01-27 15:45:44.000000000 -0500
+++ ./jdk/src/share/native/java/lang/fdlibm/include/fdlibm.h	2009-05-04 17:37:16.000000000 -0400
@@ -25,6 +25,10 @@
  * have any questions.
  */
 
+#ifdef __OpenBSD__
+#include <sys/types.h>
+#endif
+#include <machine/endian.h>
 #include "jfdlibm.h"
 
 #ifdef __NEWVALID       /* special setup for Sun test regime */
@@ -47,11 +51,13 @@
 #define __LOp(x) *(1+(int*)x)
 #endif
 
+#ifndef __P
 #ifdef __STDC__
 #define __P(p)  p
 #else
 #define __P(p)  ()
 #endif
+#endif
 
 /*
  * ANSI/POSIX
diff -upr ../orig/jdk/src/share/native/java/lang/fdlibm/include/jfdlibm.h ./jdk/src/share/native/java/lang/fdlibm/include/jfdlibm.h
--- ../orig/jdk/src/share/native/java/lang/fdlibm/include/jfdlibm.h	2009-01-27 15:45:44.000000000 -0500
+++ ./jdk/src/share/native/java/lang/fdlibm/include/jfdlibm.h	2009-05-04 17:37:16.000000000 -0400
@@ -61,7 +61,7 @@
 #define log1p   jlog1p
 #define expm1   jexpm1
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #define __ieee754_sqrt          __j__ieee754_sqrt
 #define __ieee754_acos          __j__ieee754_acos
 #define __ieee754_acosh         __j__ieee754_acosh
diff -upr ../orig/jdk/src/share/native/java/util/zip/Inflater.c ./jdk/src/share/native/java/util/zip/Inflater.c
--- ../orig/jdk/src/share/native/java/util/zip/Inflater.c	2009-01-27 15:45:44.000000000 -0500
+++ ./jdk/src/share/native/java/util/zip/Inflater.c	2009-05-04 17:37:16.000000000 -0400
@@ -67,6 +67,10 @@ Java_java_util_zip_Inflater_init(JNIEnv 
         return jlong_zero;
     } else {
         char *msg;
+// BSDXXX needed for FreeBSD 5.4 and below with system zlib
+#if defined(__FreeBSD__) && __FreeBSD__ < 6
+	strm->adler = 1;
+#endif
         switch (inflateInit2(strm, nowrap ? -MAX_WBITS : MAX_WBITS)) {
           case Z_OK:
             return ptr_to_jlong(strm);
@@ -202,6 +206,10 @@ Java_java_util_zip_Inflater_reset(JNIEnv
     if (inflateReset(jlong_to_ptr(strm)) != Z_OK) {
         JNU_ThrowInternalError(env, 0);
     }
+// BSDXXX needed for FreeBSD 5.4 and below with system zlib
+#if defined(__FreeBSD__) && __FreeBSD__ < 6
+    ((z_stream *)jlong_to_ptr(strm))->adler = 1;
+#endif
 }
 
 JNIEXPORT void JNICALL
diff -upr ../orig/jdk/src/share/native/java/util/zip/zlib-1.1.3/zconf.h ./jdk/src/share/native/java/util/zip/zlib-1.1.3/zconf.h
--- ../orig/jdk/src/share/native/java/util/zip/zlib-1.1.3/zconf.h	2009-01-27 15:45:44.000000000 -0500
+++ ./jdk/src/share/native/java/util/zip/zlib-1.1.3/zconf.h	2009-05-04 17:37:16.000000000 -0400
@@ -42,44 +42,49 @@
 /* for _LP64 */
 #include <sys/types.h>
 
+/**
+ * Privatise the symbols to the JDK.
+ */
+#define Z_PREFIX
+
 /*
  * If you *really* need a unique prefix for all types and library functions,
  * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
  */
 #ifdef Z_PREFIX
-#  define deflateInit_  z_deflateInit_
-#  define deflate       z_deflate
-#  define deflateEnd    z_deflateEnd
-#  define inflateInit_  z_inflateInit_
-#  define inflate       z_inflate
-#  define inflateEnd    z_inflateEnd
-#  define deflateInit2_ z_deflateInit2_
-#  define deflateSetDictionary z_deflateSetDictionary
-#  define deflateCopy   z_deflateCopy
-#  define deflateReset  z_deflateReset
-#  define deflateParams z_deflateParams
-#  define inflateInit2_ z_inflateInit2_
-#  define inflateSetDictionary z_inflateSetDictionary
-#  define inflateSync   z_inflateSync
-#  define inflateSyncPoint z_inflateSyncPoint
-#  define inflateReset  z_inflateReset
-#  define compress      z_compress
-#  define compress2     z_compress2
-#  define uncompress    z_uncompress
-#  define adler32       z_adler32
-#  define crc32         z_crc32
-#  define get_crc_table z_get_crc_table
-
-#  define Byte          z_Byte
-#  define uInt          z_uInt
-#  define uLong         z_uLong
-#  define Bytef         z_Bytef
-#  define charf         z_charf
-#  define intf          z_intf
-#  define uIntf         z_uIntf
-#  define uLongf        z_uLongf
-#  define voidpf        z_voidpf
-#  define voidp         z_voidp
+#  define deflateInit_  _java_z_deflateInit_
+#  define deflate       _java_z_deflate
+#  define deflateEnd    _java_z_deflateEnd
+#  define inflateInit_  _java_z_inflateInit_
+#  define inflate       _java_z_inflate
+#  define inflateEnd    _java_z_inflateEnd
+#  define deflateInit2_ _java_z_deflateInit2_
+#  define deflateSetDictionary _java_z_deflateSetDictionary
+#  define deflateCopy   _java_z_deflateCopy
+#  define deflateReset  _java_z_deflateReset
+#  define deflateParams _java_z_deflateParams
+#  define inflateInit2_ _java_z_inflateInit2_
+#  define inflateSetDictionary _java_z_inflateSetDictionary
+#  define inflateSync   _java_z_inflateSync
+#  define inflateSyncPoint _java_z_inflateSyncPoint
+#  define inflateReset  _java_z_inflateReset
+#  define compress      _java_z_compress
+#  define compress2     _java_z_compress2
+#  define uncompress    _java_z_uncompress
+#  define adler32       _java_z_adler32
+#  define crc32         _java_z_crc32
+#  define get_crc_table _java_z_get_crc_table
+
+#  define Byte          _java_z_Byte
+#  define uInt          _java_z_uInt
+#  define uLong         _java_z_uLong
+#  define Bytef         _java_z_Bytef
+#  define charf         _java_z_charf
+#  define intf          _java_z_intf
+#  define uIntf         _java_z_uIntf
+#  define uLongf        _java_z_uLongf
+#  define voidpf        _java_z_voidpf
+#  define voidp         _java_z_voidp
 #endif
 
 #if (defined(_WIN32) || defined(__WIN32__)) && !defined(WIN32)
diff -upr ../orig/jdk/src/share/native/sun/awt/debug/debug_util.h ./jdk/src/share/native/sun/awt/debug/debug_util.h
--- ../orig/jdk/src/share/native/sun/awt/debug/debug_util.h	2009-01-27 15:45:45.000000000 -0500
+++ ./jdk/src/share/native/sun/awt/debug/debug_util.h	2009-05-04 17:37:16.000000000 -0400
@@ -50,7 +50,9 @@ typedef void * dmutex_t;
 #include <stdio.h>
 #include <string.h>
 #include <assert.h>
+#if !defined(_ALLBSD_SOURCE)
 #include <malloc.h>
+#endif
 #include <limits.h>
 
 /* keep these after the other headers */
diff -upr ../orig/jdk/src/share/native/sun/awt/image/BufImgSurfaceData.c ./jdk/src/share/native/sun/awt/image/BufImgSurfaceData.c
--- ../orig/jdk/src/share/native/sun/awt/image/BufImgSurfaceData.c	2009-01-27 15:45:45.000000000 -0500
+++ ./jdk/src/share/native/sun/awt/image/BufImgSurfaceData.c	2009-05-04 17:37:16.000000000 -0400
@@ -24,7 +24,11 @@
  */
 
 #include "BufImgSurfaceData.h"
+#ifdef _ALLBSD_SOURCE
+#include <stdlib.h>
+#else
 #include "malloc.h"
+#endif
 
 #include "sun_awt_image_BufImgSurfaceData.h"
 
diff -upr ../orig/jdk/src/share/native/sun/awt/image/DataBufferNative.c ./jdk/src/share/native/sun/awt/image/DataBufferNative.c
--- ../orig/jdk/src/share/native/sun/awt/image/DataBufferNative.c	2009-01-27 15:45:45.000000000 -0500
+++ ./jdk/src/share/native/sun/awt/image/DataBufferNative.c	2009-05-04 17:37:16.000000000 -0400
@@ -23,7 +23,11 @@
  * have any questions.
  */
 
+#ifdef _ALLBSD_SOURCE
+#include <stdlib.h>
+#else
 #include "malloc.h"
+#endif
 
 #include "SurfaceData.h"
 #include "sun_awt_image_DataBufferNative.h"
diff -upr ../orig/jdk/src/share/native/sun/awt/medialib/mlib_ImageConv2x2_f.c ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv2x2_f.c
--- ../orig/jdk/src/share/native/sun/awt/medialib/mlib_ImageConv2x2_f.c	2009-01-27 15:45:45.000000000 -0500
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv2x2_f.c	2009-05-04 17:37:16.000000000 -0400
@@ -86,7 +86,7 @@ typedef struct {
 #endif /* MLIB_USE_FTOI_CLAMPING */
 
 /***************************************************************/
-#if defined(_LITTLE_ENDIAN) && !defined(_NO_LONGLONG)
+#if (BYTE_ORDER == LITTLE_ENDIAN) && !defined(_NO_LONGLONG)
 
 /* NB: Explicit cast to DTYPE is necessary to avoid warning from Microsoft VC compiler.
       And we need to explicitly define cast behavior if source exceeds destination range.
@@ -103,7 +103,7 @@ typedef struct {
   dp[0    ] = (DTYPE) ((res0) & DTYPE_MASK);                      \
   dp[chan1] = (DTYPE) ((res1) & DTYPE_MASK)
 
-#endif /* defined(_LITTLE_ENDIAN) && !defined(_NO_LONGLONG) */
+#endif /* (BYTE_ORDER == LITTLE_ENDIAN) && !defined(_NO_LONGLONG) */
 
 /***************************************************************/
 #ifdef _NO_LONGLONG
@@ -114,17 +114,17 @@ typedef struct {
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[chan1]) << 32) | ((mlib_s64)sp[0] & 0xffffffff)
 
-#else /* _LITTLE_ENDIAN */
+#else
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[0]) << 32) | ((mlib_s64)sp[chan1] & 0xffffffff)
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
 #endif /* _NO_LONGLONG */
 
diff -upr ../orig/jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_16ext.c ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_16ext.c
--- ../orig/jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_16ext.c	2009-01-27 15:45:45.000000000 -0500
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_16ext.c	2009-05-04 17:37:16.000000000 -0400
@@ -126,7 +126,7 @@
 #define D2I(x) CLAMP_S32((x) SAT_OFF)
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define STORE2(res0, res1)                                      \
   dp[0    ] = res1;                                             \
@@ -138,7 +138,7 @@
   dp[0    ] = res0;                                             \
   dp[chan1] = res1
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
 /***************************************************************/
 #ifdef _NO_LONGLONG
@@ -149,17 +149,17 @@
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[chan1]) << 32) | S64TOS32((mlib_s64)sp[0])
 
-#else /* _LITTLE_ENDIAN */
+#else
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[0]) << 32) | S64TOS32((mlib_s64)sp[chan1])
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 #endif /* _NO_LONGLONG */
 
 /***************************************************************/
diff -upr ../orig/jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_16nw.c ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_16nw.c
--- ../orig/jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_16nw.c	2009-01-27 15:45:45.000000000 -0500
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_16nw.c	2009-05-04 17:37:16.000000000 -0400
@@ -94,7 +94,7 @@
 #define D2I(x) CLAMP_S32((x) SAT_OFF)
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define STORE2(res0, res1)                                      \
   dp[0    ] = res1;                                             \
@@ -106,7 +106,7 @@
   dp[0    ] = res0;                                             \
   dp[chan1] = res1
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
 /***************************************************************/
 #ifdef _NO_LONGLONG
@@ -117,17 +117,17 @@
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[chan1]) << 32) | S64TOS32((mlib_s64)sp[0])
 
-#else /* _LITTLE_ENDIAN */
+#else
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[0]) << 32) | S64TOS32((mlib_s64)sp[chan1])
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 #endif /* _NO_LONGLONG */
 
 /***************************************************************/
diff -upr ../orig/jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_8ext.c ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_8ext.c
--- ../orig/jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_8ext.c	2009-01-27 15:45:45.000000000 -0500
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_8ext.c	2009-05-04 17:37:16.000000000 -0400
@@ -126,7 +126,7 @@
 #define D2I(x) CLAMP_S32((x) SAT_OFF)
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define STORE2(res0, res1)                                      \
   dp[0    ] = res1;                                             \
@@ -138,7 +138,7 @@
   dp[0    ] = res0;                                             \
   dp[chan1] = res1
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
 /***************************************************************/
 #ifdef _NO_LONGLONG
@@ -149,17 +149,17 @@
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[chan1]) << 32) | S64TOS32((mlib_s64)sp[0])
 
-#else /* _LITTLE_ENDIAN */
+#else
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[0]) << 32) | S64TOS32((mlib_s64)sp[chan1])
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 #endif /* _NO_LONGLONG */
 
 /***************************************************************/
diff -upr ../orig/jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_8nw.c ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_8nw.c
--- ../orig/jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_8nw.c	2009-01-27 15:45:45.000000000 -0500
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_8nw.c	2009-05-04 17:37:16.000000000 -0400
@@ -95,7 +95,7 @@
 #define D2I(x) CLAMP_S32((x) SAT_OFF)
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define STORE2(res0, res1)                                      \
   dp[0    ] = res1;                                             \
@@ -107,7 +107,7 @@
   dp[0    ] = res0;                                             \
   dp[chan1] = res1
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
 /***************************************************************/
 #ifdef _NO_LONGLONG
@@ -118,17 +118,17 @@
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[chan1]) << 32) | S64TOS32((mlib_s64)sp[0])
 
-#else /* _LITTLE_ENDIAN */
+#else
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[0]) << 32) | S64TOS32((mlib_s64)sp[chan1])
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 #endif /* _NO_LONGLONG */
 
 /***************************************************************/
diff -upr ../orig/jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_u16ext.c ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_u16ext.c
--- ../orig/jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_u16ext.c	2009-01-27 15:45:45.000000000 -0500
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_u16ext.c	2009-05-04 17:37:16.000000000 -0400
@@ -126,7 +126,7 @@
 #define D2I(x) CLAMP_S32((x) SAT_OFF)
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define STORE2(res0, res1)                                      \
   dp[0    ] = res1;                                             \
@@ -138,7 +138,7 @@
   dp[0    ] = res0;                                             \
   dp[chan1] = res1
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
 /***************************************************************/
 #ifdef _NO_LONGLONG
@@ -149,17 +149,17 @@
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[chan1]) << 32) | S64TOS32((mlib_s64)sp[0])
 
-#else /* _LITTLE_ENDIAN */
+#else
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[0]) << 32) | S64TOS32((mlib_s64)sp[chan1])
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 #endif /* _NO_LONGLONG */
 
 /***************************************************************/
diff -upr ../orig/jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_u16nw.c ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_u16nw.c
--- ../orig/jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_u16nw.c	2009-01-27 15:45:45.000000000 -0500
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_u16nw.c	2009-05-04 17:37:16.000000000 -0400
@@ -94,7 +94,7 @@
 #define D2I(x) CLAMP_S32((x) SAT_OFF)
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define STORE2(res0, res1)                                      \
   dp[0    ] = res1;                                             \
@@ -106,7 +106,7 @@
   dp[0    ] = res0;                                             \
   dp[chan1] = res1
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
 /***************************************************************/
 #ifdef _NO_LONGLONG
@@ -117,17 +117,17 @@
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[chan1]) << 32) | S64TOS32((mlib_s64)sp[0])
 
-#else /* _LITTLE_ENDIAN */
+#else
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[0]) << 32) | S64TOS32((mlib_s64)sp[chan1])
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 #endif /* _NO_LONGLONG */
 
 /***************************************************************/
diff -upr ../orig/jdk/src/share/native/sun/awt/medialib/mlib_ImageCopy_Bit.c ./jdk/src/share/native/sun/awt/medialib/mlib_ImageCopy_Bit.c
--- ../orig/jdk/src/share/native/sun/awt/medialib/mlib_ImageCopy_Bit.c	2009-01-27 15:45:45.000000000 -0500
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_ImageCopy_Bit.c	2009-05-04 17:37:16.000000000 -0400
@@ -95,7 +95,7 @@ void mlib_ImageCopy_bit_na(const mlib_u8
     dst = dp[0];
     if (ld_offset + size < 32) {
       dmask = (mask0 << (32 - size)) >> ld_offset;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
       src = (src0 >> (ld_offset - ls_offset));
       dst = (dst << 24) | ((dst & 0xFF00) << 8) | ((dst >> 8) & 0xFF00) | (dst >> 24);
@@ -104,12 +104,12 @@ void mlib_ImageCopy_bit_na(const mlib_u8
 #else
       src = (src0 >> (ld_offset - ls_offset));
       dp[0] = (dst & (~dmask)) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       return;
     }
 
     dmask = mask0 >> ld_offset;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
     src = (src0 >> (ld_offset - ls_offset));
     dst = (dst << 24) | ((dst & 0xFF00) << 8) | ((dst >> 8) & 0xFF00) | (dst >> 24);
@@ -118,7 +118,7 @@ void mlib_ImageCopy_bit_na(const mlib_u8
 #else
     src = (src0 >> (ld_offset - ls_offset));
     dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     j = 32 - ld_offset;
     dp++;
     ls_offset += j;
@@ -131,7 +131,7 @@ void mlib_ImageCopy_bit_na(const mlib_u8
 
     if (ld_offset + size < 32) {
       dmask = (mask0 << (32 - size)) >> ld_offset;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
       src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
       src = (src0 << shift) | (src1 >> (32 - shift));
@@ -141,12 +141,12 @@ void mlib_ImageCopy_bit_na(const mlib_u8
 #else
       src = (src0 << shift) | (src1 >> (32 - shift));
       dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       return;
     }
 
     dmask = mask0 >> ld_offset;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
     src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
     src = (src0 << shift) | (src1 >> (32 - shift));
@@ -156,7 +156,7 @@ void mlib_ImageCopy_bit_na(const mlib_u8
 #else
     src = (src0 << shift) | (src1 >> (32 - shift));
     dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     j = 32 - ld_offset;
     dp++;
     sp++;
@@ -164,19 +164,19 @@ void mlib_ImageCopy_bit_na(const mlib_u8
   }
 
   if (j < size) src1 = sp[0];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
   src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
   for (; j <= size - 32; j += 32) {
     src0 = src1;
     src1 = sp[1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
     src = (src0 << ls_offset) | (src1 >> (32 - ls_offset));
     dp[0] = (src << 24) | ((src & 0xFF00) << 8) | ((src >> 8) & 0xFF00) | (src >> 24);
 #else
     dp[0] = (src0 << ls_offset) | (src1 >> (32 - ls_offset));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     sp++;
     dp++;
   }
@@ -187,7 +187,7 @@ void mlib_ImageCopy_bit_na(const mlib_u8
     if (ls_offset + j > 32) src1 = sp[1];
     dst = dp[0];
     dmask = mask0 << (32 - j);
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
     src = (src0 << ls_offset) | (src1 >> (32 - ls_offset));
     dst = (dst << 24) | ((dst & 0xFF00) << 8) | ((dst >> 8) & 0xFF00) | (dst >> 24);
@@ -196,7 +196,7 @@ void mlib_ImageCopy_bit_na(const mlib_u8
 #else
     src = (src0 << ls_offset) | (src1 >> (32 - ls_offset));
     dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
   }
 
 #else /* _LONGLONG */
@@ -315,7 +315,7 @@ void mlib_ImageCopy_bit_na_r(const mlib_
     dst = dp[0];
     if (ld_offset >= size) {
       dmask = (lmask0 << (32 - size)) >> (ld_offset - size);
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
       src = (src0 << (ls_offset - ld_offset));
       dst = (dst << 24) | ((dst & 0xFF00) << 8) | ((dst >> 8) & 0xFF00) | (dst >> 24);
@@ -324,12 +324,12 @@ void mlib_ImageCopy_bit_na_r(const mlib_
 #else
       src = (src0 << (ls_offset - ld_offset));
       dp[0] = (dst & (~dmask)) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       return;
     }
 
     dmask = lmask0 << (32 - ld_offset);
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
     src = (src0 << (ls_offset - ld_offset));
     dst = (dst << 24) | ((dst & 0xFF00) << 8) | ((dst >> 8) & 0xFF00) | (dst >> 24);
@@ -338,7 +338,7 @@ void mlib_ImageCopy_bit_na_r(const mlib_
 #else
     src = (src0 << (ls_offset - ld_offset));
     dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     j = ld_offset;
     dp--;
     ls_offset -= j;
@@ -351,7 +351,7 @@ void mlib_ImageCopy_bit_na_r(const mlib_
 
     if (ld_offset >= size) {
       dmask = (lmask0 << (32 - size)) >> (ld_offset - size);
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
       src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
       src = (src0 >> shift) | (src1 << (32 - shift));
@@ -361,12 +361,12 @@ void mlib_ImageCopy_bit_na_r(const mlib_
 #else
       src = (src0 >> shift) | (src1 << (32 - shift));
       dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       return;
     }
 
     dmask = lmask0 << (32 - ld_offset);
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
     src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
     src = (src0 >> shift) | (src1 << (32 - shift));
@@ -376,7 +376,7 @@ void mlib_ImageCopy_bit_na_r(const mlib_
 #else
     src = (src0 >> shift) | (src1 << (32 - shift));
     dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     j = ld_offset;
     dp--;
     sp--;
@@ -384,22 +384,22 @@ void mlib_ImageCopy_bit_na_r(const mlib_
   }
 
   if (j < size) src1 = sp[0];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
   src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 #ifdef __SUNPRO_C
 #pragma pipeloop(0)
 #endif /* __SUNPRO_C */
   for (; j <= size - 32; j += 32) {
     src0 = src1;
     src1 = sp[-1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
     src = (src0 >> (32 - ls_offset)) | (src1 << ls_offset);
     dp[0] = (src << 24) | ((src & 0xFF00) << 8) | ((src >> 8) & 0xFF00) | (src >> 24);
 #else
     dp[0] = (src0 >> (32 - ls_offset)) | (src1 << ls_offset);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     sp--;
     dp--;
   }
@@ -410,7 +410,7 @@ void mlib_ImageCopy_bit_na_r(const mlib_
     if (ls_offset < j) src1 = sp[-1];
     dst = dp[0];
     dmask = lmask0 >> (32 - j);
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
     src = (src0 >> (32 - ls_offset)) | (src1 << ls_offset);
     dst = (dst << 24) | ((dst & 0xFF00) << 8) | ((dst >> 8) & 0xFF00) | (dst >> 24);
@@ -419,7 +419,7 @@ void mlib_ImageCopy_bit_na_r(const mlib_
 #else
     src = (src0 >> (32 - ls_offset)) | (src1 << ls_offset);
     dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
   }
 
 #else  /* _LONGLONG */
diff -upr ../orig/jdk/src/share/native/sun/awt/medialib/mlib_ImageLookUp_64.c ./jdk/src/share/native/sun/awt/medialib/mlib_ImageLookUp_64.c
--- ../orig/jdk/src/share/native/sun/awt/medialib/mlib_ImageLookUp_64.c	2009-01-27 15:45:46.000000000 -0500
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_ImageLookUp_64.c	2009-05-04 17:37:16.000000000 -0400
@@ -168,7 +168,7 @@
 }
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define READ_U8_D64(table0, table1, table2, table3)             \
   t0 = *(mlib_d64*)((mlib_u8*)table0 + ((s0 << 3) & 0x7F8));    \
@@ -184,7 +184,7 @@
   t2 = *(mlib_d64*)((mlib_u8*)table2 + ((s0 >> 5)  & 0x7F8));   \
   t3 = *(mlib_d64*)((mlib_u8*)table3 + ((s0 << 3)  & 0x7F8))
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
 /***************************************************************/
 void mlib_ImageLookUp_U8_D64(const mlib_u8  *src,
@@ -612,7 +612,7 @@ void mlib_ImageLookUpSI_U8_D64(const mli
 #pragma pipeloop(0)
 #endif /* __SUNPRO_C */
       for (i = 0; i < size - 7; i += 4, dp += 8, sa++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 5) & 0x7F8));
@@ -622,12 +622,12 @@ void mlib_ImageLookUpSI_U8_D64(const mli
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 21) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         dp[0] = t0;
         dp[1] = t1;
         dp[2] = t2;
         dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 21) & 0x7F8));
@@ -637,7 +637,7 @@ void mlib_ImageLookUpSI_U8_D64(const mli
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 5) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0];
         dp[4] = t0;
         dp[5] = t1;
@@ -645,7 +645,7 @@ void mlib_ImageLookUpSI_U8_D64(const mli
         dp[7] = t3;
       }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 5) & 0x7F8));
@@ -655,12 +655,12 @@ void mlib_ImageLookUpSI_U8_D64(const mli
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 21) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[0] = t0;
       dp[1] = t1;
       dp[2] = t2;
       dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 21) & 0x7F8));
@@ -670,7 +670,7 @@ void mlib_ImageLookUpSI_U8_D64(const mli
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 5) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[4] = t0;
       dp[5] = t1;
       dp[6] = t2;
@@ -718,7 +718,7 @@ void mlib_ImageLookUpSI_U8_D64(const mli
 #pragma pipeloop(0)
 #endif /* __SUNPRO_C */
       for (i = 0; i < size - 7; i += 4, dp += 12, sa++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
@@ -732,14 +732,14 @@ void mlib_ImageLookUpSI_U8_D64(const mli
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
         t4 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
         t5 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         dp[0] = t0;
         dp[1] = t1;
         dp[2] = t2;
         dp[3] = t3;
         dp[4] = t4;
         dp[5] = t5;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
@@ -753,7 +753,7 @@ void mlib_ImageLookUpSI_U8_D64(const mli
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
         t4 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
         t5 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0];
         dp[6] = t0;
         dp[7] = t1;
@@ -763,7 +763,7 @@ void mlib_ImageLookUpSI_U8_D64(const mli
         dp[11] = t5;
       }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
@@ -777,14 +777,14 @@ void mlib_ImageLookUpSI_U8_D64(const mli
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
       t4 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
       t5 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[0] = t0;
       dp[1] = t1;
       dp[2] = t2;
       dp[3] = t3;
       dp[4] = t4;
       dp[5] = t5;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
@@ -798,7 +798,7 @@ void mlib_ImageLookUpSI_U8_D64(const mli
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
       t4 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
       t5 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[6] = t0;
       dp[7] = t1;
       dp[8] = t2;
@@ -851,7 +851,7 @@ void mlib_ImageLookUpSI_U8_D64(const mli
 #pragma pipeloop(0)
 #endif /* __SUNPRO_C */
       for (i = 0; i < size - 7; i += 4, dp += 16, sa++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
@@ -861,12 +861,12 @@ void mlib_ImageLookUpSI_U8_D64(const mli
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 21) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 21) & 0x7F8));
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 >> 21) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         dp[0] = t0;
         dp[1] = t1;
         dp[2] = t2;
         dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 5) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 5) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 5) & 0x7F8));
@@ -876,12 +876,12 @@ void mlib_ImageLookUpSI_U8_D64(const mli
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 >> 13) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         dp[4] = t0;
         dp[5] = t1;
         dp[6] = t2;
         dp[7] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
@@ -891,12 +891,12 @@ void mlib_ImageLookUpSI_U8_D64(const mli
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 5) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 5) & 0x7F8));
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 >> 5) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         dp[8] = t0;
         dp[9] = t1;
         dp[10] = t2;
         dp[11] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 21) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 21) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 21) & 0x7F8));
@@ -906,7 +906,7 @@ void mlib_ImageLookUpSI_U8_D64(const mli
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 << 3) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0];
         dp[12] = t0;
         dp[13] = t1;
@@ -914,7 +914,7 @@ void mlib_ImageLookUpSI_U8_D64(const mli
         dp[15] = t3;
       }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
@@ -924,12 +924,12 @@ void mlib_ImageLookUpSI_U8_D64(const mli
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 21) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 21) & 0x7F8));
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 >> 21) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[0] = t0;
       dp[1] = t1;
       dp[2] = t2;
       dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 5) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 5) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 5) & 0x7F8));
@@ -939,12 +939,12 @@ void mlib_ImageLookUpSI_U8_D64(const mli
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 >> 13) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[4] = t0;
       dp[5] = t1;
       dp[6] = t2;
       dp[7] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
@@ -954,12 +954,12 @@ void mlib_ImageLookUpSI_U8_D64(const mli
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 5) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 5) & 0x7F8));
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 >> 5) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[8] = t0;
       dp[9] = t1;
       dp[10] = t2;
       dp[11] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 21) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 21) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 21) & 0x7F8));
@@ -969,7 +969,7 @@ void mlib_ImageLookUpSI_U8_D64(const mli
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 << 3) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[12] = t0;
       dp[13] = t1;
       dp[14] = t2;
diff -upr ../orig/jdk/src/share/native/sun/awt/medialib/mlib_ImageLookUp_Bit.c ./jdk/src/share/native/sun/awt/medialib/mlib_ImageLookUp_Bit.c
--- ../orig/jdk/src/share/native/sun/awt/medialib/mlib_ImageLookUp_Bit.c	2009-01-27 15:45:46.000000000 -0500
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_ImageLookUp_Bit.c	2009-05-04 17:37:16.000000000 -0400
@@ -88,7 +88,7 @@ typedef union {
 } d64_2_f32;
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 static const mlib_u32 mlib_bit_mask[16] = {
   0x00000000u, 0xFF000000u, 0x00FF0000u, 0xFFFF0000u,
@@ -126,7 +126,7 @@ static const mlib_u32 mlib_bit_mask_3[3*
   0x00000000u, 0x00FFFFFFu, 0xFF000000u, 0xFFFFFFFFu
 };
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
 /***************************************************************/
 mlib_status mlib_ImageLookUp_Bit_U8_1(const mlib_u8 *src,
@@ -228,13 +228,13 @@ mlib_status mlib_ImageLookUp_Bit_U8_1(co
 #endif /* __SUNPRO_C */
     for (; i <= (size - 16); i += 16) {
       s0 = *(mlib_u16*)sa;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       *da++ = dd_array[s0 & 0xFF];
       *da++ = dd_array[s0 >> 8];
 #else
       *da++ = dd_array[s0 >> 8];
       *da++ = dd_array[s0 & 0xFF];
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       sa += 2;
     }
 
@@ -258,20 +258,20 @@ mlib_status mlib_ImageLookUp_Bit_U8_1(co
         val1 = p_dd[2*val0+1];
       }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       emask = (mlib_u32)((mlib_s32)(-1)) >> ((4 - (size - i)) * 8);
 #else
       emask = (mlib_s32)(-1) << ((4 - (size - i)) * 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       ((mlib_u32*)da)[0] = (val1 & emask) | (((mlib_u32*)da)[0] &~ emask);
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       mlib_u64 emask = (mlib_u64)((mlib_s64)(-1)) >> ((8 - (size - i)) * 8);
 #else
       mlib_u64 emask = (mlib_s64)(-1) << ((8 - (size - i)) * 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
       ((mlib_u64*)da)[0] = (((mlib_u64*)dd_array)[sa[0]] & emask) | (((mlib_u64*)da)[0] &~ emask);
 
@@ -323,13 +323,13 @@ mlib_status mlib_ImageLookUp_Bit_U8_2(co
 
   val0 = table[0][0];
   val1 = table[0][1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
   val0 = val0 | (table[1][0] << 8);
   val1 = val1 | (table[1][1] << 8);
 #else
   val0 = (val0 << 8) | table[1][0];
   val1 = (val1 << 8) | table[1][1];
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
   val0 |= (val0 << 16);
   val1 |= (val1 << 16);
 
@@ -394,11 +394,11 @@ mlib_status mlib_ImageLookUp_Bit_U8_2(co
         dd1 = dd2;
       }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       emask = (mlib_u32)((mlib_s32)(-1)) >> ((4 - (size - i)) * 8);
 #else
       emask = (mlib_s32)(-1) << ((4 - (size - i)) * 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       ((mlib_u32*)da)[0] = (dd1 & emask) | (((mlib_u32*)da)[0] &~ emask);
 
 #else /* _NO_LONGLONG */
@@ -412,11 +412,11 @@ mlib_status mlib_ImageLookUp_Bit_U8_2(co
         dd = ((mlib_u64*)dd_array)[s0 & 0xf];
       }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       emask = (mlib_u64)((mlib_s64)(-1)) >> ((8 - (size - i)) * 8);
 #else
       emask = (mlib_s64)(-1) << ((8 - (size - i)) * 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       ((mlib_u64*)da)[0] = (dd & emask) | (((mlib_u64*)da)[0] &~ emask);
 
 #endif /* _NO_LONGLONG */
@@ -462,7 +462,7 @@ mlib_status mlib_ImageLookUp_Bit_U8_3(co
 
   buffs = buff + size;
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
   l0 = (table[0][0] << 24) | (table[2][0] << 16) | (table[1][0] << 8) | (table[0][0]);
   h0 = (table[0][1] << 24) | (table[2][1] << 16) | (table[1][1] << 8) | (table[0][1]);
   l1 = (l0 >> 8); l1 |= (l1 << 24);
@@ -476,7 +476,7 @@ mlib_status mlib_ImageLookUp_Bit_U8_3(co
   h1 = (h0 << 8); h1 |= (h1 >> 24);
   l2 = (l1 << 8); l2 |= (l2 >> 24);
   h2 = (h1 << 8); h2 |= (h2 >> 24);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
   /* calculate lookup table */
 #ifdef __SUNPRO_C
@@ -564,11 +564,11 @@ mlib_status mlib_ImageLookUp_Bit_U8_3(co
         dd = ((mlib_u32*)(d_array12 + (s0 & 0xF)))[1];
       }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       emask = (mlib_u32)((mlib_s32)(-1)) >> ((4 - (size - i)) * 8);
 #else
       emask = (mlib_s32)(-1) << ((4 - (size - i)) * 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       da[0] = (dd & emask) | (da[0] &~ emask);
     }
 
@@ -611,13 +611,13 @@ mlib_status mlib_ImageLookUp_Bit_U8_4(co
 
   buffs = buff + size;
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
   l = (table[3][0] << 24) | (table[2][0] << 16) | (table[1][0] << 8) | (table[0][0]);
   h = (table[3][1] << 24) | (table[2][1] << 16) | (table[1][1] << 8) | (table[0][1]);
 #else
   l = (table[0][0] << 24) | (table[1][0] << 16) | (table[2][0] << 8) | (table[3][0]);
   h = (table[0][1] << 24) | (table[1][1] << 16) | (table[2][1] << 8) | (table[3][1]);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
   ((mlib_u32*)lh)[0] = l;  ((mlib_u32*)lh)[1] = l;
   ((mlib_u32*)lh)[2] = l;  ((mlib_u32*)lh)[3] = h;
diff -upr ../orig/jdk/src/share/native/sun/awt/medialib/mlib_ImageUtils.c ./jdk/src/share/native/sun/awt/medialib/mlib_ImageUtils.c
--- ../orig/jdk/src/share/native/sun/awt/medialib/mlib_ImageUtils.c	2009-01-27 15:45:46.000000000 -0500
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_ImageUtils.c	2009-05-04 17:37:16.000000000 -0400
@@ -30,7 +30,7 @@
 typedef union {
   mlib_d64 db;
   struct {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     mlib_s32 int1, int0;
 #else
     mlib_s32 int0, int1;
diff -upr ../orig/jdk/src/share/native/sun/awt/medialib/mlib_c_ImageCopy.c ./jdk/src/share/native/sun/awt/medialib/mlib_c_ImageCopy.c
--- ../orig/jdk/src/share/native/sun/awt/medialib/mlib_c_ImageCopy.c	2009-01-27 15:45:46.000000000 -0500
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_c_ImageCopy.c	2009-05-04 17:37:16.000000000 -0400
@@ -275,11 +275,11 @@ void mlib_ImageCopy_bit_al(const mlib_u8
       for (i = 0; j <= (b_size - 4); j += 4, i++) {
         src0 = src1;
         src1 = pws[i + 1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         pwd[i] = (src0 >> lshift) | (src1 << rshift);
 #else
         pwd[i] = (src0 << lshift) | (src1 >> rshift);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       }
 
       sa += i << 2;
@@ -381,11 +381,11 @@ void mlib_c_ImageCopy_u8(const mlib_imag
         for (; j <= (src_width - 4); j += 4) {
           src0 = src1;
           src1 = ps[1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           *((mlib_s32 *) (pdst_row + j)) = (src0 >> shl) | (src1 << shr);
 #else
           *((mlib_s32 *) (pdst_row + j)) = (src0 << shl) | (src1 >> shr);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           ps++;
         }
       }
@@ -414,11 +414,11 @@ void mlib_c_ImageCopy_u8(const mlib_imag
         for (; j <= (src_width - 8); j += 8) {
           src0 = src1;
           src1 = ps[1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           *((mlib_s64 *) (pdst_row + j)) = (src0 >> shl) | (src1 << shr);
 #else
           *((mlib_s64 *) (pdst_row + j)) = (src0 << shl) | (src1 >> shr);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           ps++;
         }
       }
@@ -484,11 +484,11 @@ void mlib_c_ImageCopy_s16(const mlib_ima
         for (; j <= (src_width - 2); j += 2) {
           src0 = src1;
           src1 = ps[1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           *((mlib_s32 *) (pdst_row + j)) = (src0 >> 16) | (src1 << 16);
 #else
           *((mlib_s32 *) (pdst_row + j)) = (src0 << 16) | (src1 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           ps++;
         }
       }
@@ -516,11 +516,11 @@ void mlib_c_ImageCopy_s16(const mlib_ima
         for (; j <= (src_width - 4); j += 4) {
           src0 = src1;
           src1 = ps[1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           *((mlib_s64 *) (pdst_row + j)) = (src0 >> shl) | (src1 << shr);
 #else
           *((mlib_s64 *) (pdst_row + j)) = (src0 << shl) | (src1 >> shr);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           ps++;
         }
       }
@@ -585,11 +585,11 @@ void mlib_c_ImageCopy_s32(const mlib_ima
         for (; j <= (src_width - 2); j += 2) {
           src0 = src1;
           src1 = ps[1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           *((mlib_s64 *) (pdst_row + j)) = (src0 >> 32) | (src1 << 32);
 #else
           *((mlib_s64 *) (pdst_row + j)) = (src0 << 32) | (src1 >> 32);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           ps++;
         }
       }
@@ -687,11 +687,11 @@ void mlib_ImageCopy_na(const mlib_u8 *sp
 #endif /* __SUNPRO_C */
       for (; n > SIZE; n -= SIZE) {
         s1 = *tmp++;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         *(TYPE *) dp = (s0 >> shl) | (s1 << shr);
 #else
         *(TYPE *) dp = (s0 << shl) | (s1 >> shr);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = s1;
         dp += SIZE;
         sp += SIZE;
diff -upr ../orig/jdk/src/share/native/sun/awt/medialib/mlib_c_ImageLookUp_f.c ./jdk/src/share/native/sun/awt/medialib/mlib_c_ImageLookUp_f.c
--- ../orig/jdk/src/share/native/sun/awt/medialib/mlib_c_ImageLookUp_f.c	2009-01-27 15:45:46.000000000 -0500
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_c_ImageLookUp_f.c	2009-05-04 17:37:16.000000000 -0400
@@ -120,7 +120,7 @@
   }                                                               \
 }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 /***************************************************************/
 #define READ_U8_U8_ALIGN(table0, table1, table2, table3)        \
@@ -163,7 +163,7 @@
   t2 = *(mlib_u32*)((mlib_u8*)table2 + ((s0 >> 14)  & 0x3FC));  \
   t3 = *(mlib_u32*)((mlib_u8*)table3 + ((s0 >> 22)  & 0x3FC))
 
-#else /* _LITTLE_ENDIAN */
+#else /* BYTE_ORDER == ... */
 
 /***********/
 #define READ_U8_U8_ALIGN(table0, table1, table2, table3)        \
@@ -206,7 +206,7 @@
   t2 = *(mlib_u32*)((mlib_u8*)table2 + ((s0 >> 6)  & 0x3FC));   \
   t3 = *(mlib_u32*)((mlib_u8*)table3 + ((s0 << 2)  & 0x3FC))
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
 /***************************************************************/
 void mlib_c_ImageLookUp_U8_U8(const mlib_u8 *src,
@@ -297,11 +297,11 @@ void mlib_c_ImageLookUp_U8_U8(const mlib
         da[0] = t;
         da++;
         dp = (mlib_u8 *) da;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         *dp++ = tab[s2 >> 8];
 #else
         *dp++ = tab[s2 & 0xFF];
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         sp = (mlib_u8 *) sa;
         i += 5;
         for (; i < size; i++, dp++, sp++)
@@ -403,11 +403,11 @@ void mlib_c_ImageLookUp_U8_U8(const mlib
         da[0] = t;
         da++;
         dp = (mlib_u8 *) da;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         *dp++ = tab0[s2 >> 8];
 #else
         *dp++ = tab0[s2 & 0xFF];
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         sp = (mlib_u8 *) sa;
         i += 5;
 
@@ -544,11 +544,11 @@ void mlib_c_ImageLookUp_U8_U8(const mlib
         da[0] = t;
         da++;
         dp = (mlib_u8 *) da;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         *dp++ = tab1[s2 >> 8];
 #else
         *dp++ = tab1[s2 & 0xFF];
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         sp = (mlib_u8 *) sa;
         i += 5;
 
@@ -694,11 +694,11 @@ void mlib_c_ImageLookUp_U8_U8(const mlib
         da[0] = t;
         da++;
         dp = (mlib_u8 *) da;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         *dp++ = tab0[s2 >> 8];
 #else
         *dp++ = tab0[s2 & 0xFF];
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         sp = (mlib_u8 *) sa;
         i += 5;
 
@@ -1852,21 +1852,21 @@ void mlib_c_ImageLookUpSI_U8_U8(const ml
     s0 = tab0[0];
     s1 = tab1[0];
     for (i = 1; i < 256; i++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       s2 = (s1 << 8) + s0;
 #else
       s2 = (s0 << 8) + s1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       s0 = tab0[i];
       s1 = tab1[i];
       tab[i - 1] = (mlib_u16) s2;
     }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     s2 = (s1 << 8) + s0;
 #else
     s2 = (s0 << 8) + s1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     tab[255] = (mlib_u16) s2;
 
     for (j = 0; j < ysize; j++, dst += dlb, src += slb) {
@@ -1897,11 +1897,11 @@ void mlib_c_ImageLookUpSI_U8_U8(const ml
         for (i = 0; i < size - 3; i += 2, da++, sa += 2) {
           t0 = tab[s0];
           t1 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           t = (t1 << 16) + t0;
 #else
           t = (t0 << 16) + t1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           s0 = sa[0];
           s1 = sa[1];
           da[0] = t;
@@ -1909,11 +1909,11 @@ void mlib_c_ImageLookUpSI_U8_U8(const ml
 
         t0 = tab[s0];
         t1 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t = (t1 << 16) + t0;
 #else
         t = (t0 << 16) + t1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da[0] = t;
         da++;
 
@@ -1927,13 +1927,13 @@ void mlib_c_ImageLookUpSI_U8_U8(const ml
 
         if (off > 1) {
           t0 = tab[sa[0]];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           dp[1] = (t0 >> 8);
           dp[0] = t0;
 #else
           dp[0] = (t0 >> 8);
           dp[1] = t0;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           sa++;
           size--;
           dp += 2;
@@ -1941,11 +1941,11 @@ void mlib_c_ImageLookUpSI_U8_U8(const ml
 
         t0 = tab[sa[0]];
         sa++;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         *dp++ = t0;
 #else
         *dp++ = (t0 >> 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
         da = (mlib_s32 *) dp;
 
@@ -1959,11 +1959,11 @@ void mlib_c_ImageLookUpSI_U8_U8(const ml
         for (i = 0; i < size - 4; i += 2, da++, sa += 2) {
           t1 = tab[s0];
           t2 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           t = (t0 >> 8) + (t1 << 8) + (t2 << 24);
 #else
           t = (t0 << 24) + (t1 << 8) + (t2 >> 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           t0 = t2;
           s0 = sa[0];
           s1 = sa[1];
@@ -1972,29 +1972,29 @@ void mlib_c_ImageLookUpSI_U8_U8(const ml
 
         t1 = tab[s0];
         t2 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t = (t0 >> 8) + (t1 << 8) + (t2 << 24);
 #else
         t = (t0 << 24) + (t1 << 8) + (t2 >> 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da[0] = t;
         da++;
         dp = (mlib_u8 *) da;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         dp[0] = (t2 >> 8);
 #else
         dp[0] = t2;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
         if ((size & 1) == 0) {
           t0 = tab[sa[0]];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           dp[2] = (t0 >> 8);
           dp[1] = t0;
 #else
           dp[1] = (t0 >> 8);
           dp[2] = t0;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         }
       }
     }
@@ -2012,22 +2012,22 @@ void mlib_c_ImageLookUpSI_U8_U8(const ml
     s1 = tab1[0];
     s2 = tab2[0];
     for (i = 1; i < 256; i++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       s3 = (s2 << 24) + (s1 << 16) + (s0 << 8);
 #else
       s3 = (s0 << 16) + (s1 << 8) + s2;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       s0 = tab0[i];
       s1 = tab1[i];
       s2 = tab2[i];
       tab[i - 1] = s3;
     }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     s3 = (s2 << 24) + (s1 << 16) + (s0 << 8);
 #else
     s3 = (s0 << 16) + (s1 << 8) + s2;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     tab[255] = s3;
 
     for (j = 0; j < ysize; j++, dst += dlb, src += slb) {
@@ -2064,24 +2064,24 @@ void mlib_c_ImageLookUpSI_U8_U8(const ml
       for (i = 0; i < size - 7; i += 4, da += 3, sa += 4) {
         t0 = tab[s0];
         t1 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         da[0] = (t0 >> 8) + (t1 << 16);
         res2 = (t1 >> 16);
 #else
         da[0] = (t0 << 8) + (t1 >> 16);
         res2 = (t1 << 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0];
         s1 = sa[1];
         t0 = tab[s0];
         t1 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res2 += (t0 << 8);
         res1 = (t0 >> 24) + t1;
 #else
         res2 += (t0 >> 8);
         res1 = (t0 << 24) + t1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[2];
         s1 = sa[3];
         da[1] = res2;
@@ -2090,24 +2090,24 @@ void mlib_c_ImageLookUpSI_U8_U8(const ml
 
       t0 = tab[s0];
       t1 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       da[0] = (t0 >> 8) + (t1 << 16);
       res2 = (t1 >> 16);
 #else
       da[0] = (t0 << 8) + (t1 >> 16);
       res2 = (t1 << 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       s0 = sa[0];
       s1 = sa[1];
       t0 = tab[s0];
       t1 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       res2 += (t0 << 8);
       res1 = (t0 >> 24) + t1;
 #else
       res2 += (t0 >> 8);
       res1 = (t0 << 24) + t1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       da[1] = res2;
       da[2] = res1;
       da += 3;
@@ -2143,11 +2143,11 @@ void mlib_c_ImageLookUpSI_U8_U8(const ml
     s2 = tab2[0];
     s3 = tab3[0];
     for (i = 1; i < 256; i++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       s4 = (s3 << 24) + (s2 << 16) + (s1 << 8) + s0;
 #else
       s4 = (s0 << 24) + (s1 << 16) + (s2 << 8) + s3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       s0 = tab0[i];
       s1 = tab1[i];
       s2 = tab2[i];
@@ -2155,11 +2155,11 @@ void mlib_c_ImageLookUpSI_U8_U8(const ml
       tab[i - 1] = s4;
     }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     s4 = (s3 << 24) + (s2 << 16) + (s1 << 8) + s0;
 #else
     s4 = (s0 << 24) + (s1 << 16) + (s2 << 8) + s3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     tab[255] = s4;
 
     for (j = 0; j < ysize; j++, dst += dlb, src += slb) {
@@ -2225,13 +2225,13 @@ void mlib_c_ImageLookUpSI_U8_U8(const ml
         for (i = 0; i < size - 4; i += 2, da += 2, sa += 2) {
           t1 = tab[s0];
           t2 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           res1 = (t0 >> shift) + (t1 << shift1);
           res2 = (t1 >> shift) + (t2 << shift1);
 #else
           res1 = (t0 << shift) + (t1 >> shift1);
           res2 = (t1 << shift) + (t2 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           t0 = t2;
           s0 = sa[0];
           s1 = sa[1];
@@ -2241,28 +2241,28 @@ void mlib_c_ImageLookUpSI_U8_U8(const ml
 
         t1 = tab[s0];
         t2 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res1 = (t0 >> shift) + (t1 << shift1);
         res2 = (t1 >> shift) + (t2 << shift1);
 #else
         res1 = (t0 << shift) + (t1 >> shift1);
         res2 = (t1 << shift) + (t2 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da[0] = res1;
         da[1] = res2;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = (da[2] >> shift1);
         da[2] = (t2 >> shift) + (t0 << shift1);
 #else
         t0 = (da[2] << shift1);
         da[2] = (t2 << shift) + (t0 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da += 2;
         dp = (mlib_u8 *) da + (4 - off);
 
         if ((size & 1) == 0) {
           t0 = tab[sa[0]];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           dp[3] = (mlib_u8) (t0 >> 24);
           dp[2] = (mlib_u8) (t0 >> 16);
           dp[1] = (mlib_u8) (t0 >> 8);
@@ -2272,7 +2272,7 @@ void mlib_c_ImageLookUpSI_U8_U8(const ml
           dp[1] = (mlib_u8) (t0 >> 16);
           dp[2] = (mlib_u8) (t0 >> 8);
           dp[3] = (mlib_u8) t0;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         }
       }
     }
@@ -2348,13 +2348,13 @@ void mlib_c_ImageLookUpSI_S16_U8(const m
         t3 = tab0[s1];
         t4 = tab1[s1];
         t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         da[0] = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
         res2 = (t5 << 8) + t4;
 #else
         da[0] = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
         res2 = (t4 << 24) + (t5 << 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0];
         s1 = sa[1];
         t0 = tab0[s0];
@@ -2363,13 +2363,13 @@ void mlib_c_ImageLookUpSI_S16_U8(const m
         t3 = tab0[s1];
         t4 = tab1[s1];
         t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res2 += ((t1 << 24) + (t0 << 16));
         res1 = (t5 << 24) + (t4 << 16) + (t3 << 8) + t2;
 #else
         res2 += ((t0 << 8) + t1);
         res1 = (t2 << 24) + (t3 << 16) + (t4 << 8) + t5;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[2];
         s1 = sa[3];
         da[1] = res2;
@@ -2382,13 +2382,13 @@ void mlib_c_ImageLookUpSI_S16_U8(const m
       t3 = tab0[s1];
       t4 = tab1[s1];
       t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       da[0] = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
       res2 = (t5 << 8) + t4;
 #else
       da[0] = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
       res2 = (t4 << 24) + (t5 << 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       s0 = sa[0];
       s1 = sa[1];
       t0 = tab0[s0];
@@ -2397,13 +2397,13 @@ void mlib_c_ImageLookUpSI_S16_U8(const m
       t3 = tab0[s1];
       t4 = tab1[s1];
       t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       res2 += ((t1 << 24) + (t0 << 16));
       res1 = (t5 << 24) + (t4 << 16) + (t3 << 8) + t2;
 #else
       res2 += ((t0 << 8) + t1);
       res1 = (t2 << 24) + (t3 << 16) + (t4 << 8) + t5;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       da[1] = res2;
       da[2] = res1;
       da += 3;
@@ -2455,11 +2455,11 @@ void mlib_c_ImageLookUpSI_S16_U8(const m
           t1 = tab1[s0];
           t2 = tab2[s0];
           t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           res = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
 #else
           res = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           s0 = sa[0];
           da[0] = res;
         }
@@ -2468,11 +2468,11 @@ void mlib_c_ImageLookUpSI_S16_U8(const m
         t1 = tab1[s0];
         t2 = tab2[s0];
         t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
 #else
         res = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da[0] = res;
 
       }
@@ -2496,11 +2496,11 @@ void mlib_c_ImageLookUpSI_S16_U8(const m
         t2 = tab2[s0];
         t3 = tab3[s0];
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res1 = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
 #else
         res1 = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
         s0 = sa[0];
         sa++;
@@ -2513,13 +2513,13 @@ void mlib_c_ImageLookUpSI_S16_U8(const m
           t1 = tab1[s0];
           t2 = tab2[s0];
           t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           res2 = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
           res = (res1 >> shift) + (res2 << shift1);
 #else
           res2 = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
           res = (res1 << shift) + (res2 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           res1 = res2;
           s0 = sa[0];
           da[0] = res;
@@ -2529,21 +2529,21 @@ void mlib_c_ImageLookUpSI_S16_U8(const m
         t1 = tab1[s0];
         t2 = tab2[s0];
         t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res2 = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
         res = (res1 >> shift) + (res2 << shift1);
 #else
         res2 = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
         res = (res1 << shift) + (res2 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da[0] = res;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res1 = (da[1] >> shift1);
         da[1] = (res2 >> shift) + (res1 << shift1);
 #else
         res1 = (da[1] << shift1);
         da[1] = (res2 << shift) + (res1 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       }
     }
   }
@@ -2617,13 +2617,13 @@ void mlib_c_ImageLookUpSI_U16_U8(const m
         t3 = tab0[s1];
         t4 = tab1[s1];
         t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         da[0] = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
         res2 = (t5 << 8) + t4;
 #else
         da[0] = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
         res2 = (t4 << 24) + (t5 << 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0];
         s1 = sa[1];
         t0 = tab0[s0];
@@ -2632,13 +2632,13 @@ void mlib_c_ImageLookUpSI_U16_U8(const m
         t3 = tab0[s1];
         t4 = tab1[s1];
         t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res2 += ((t1 << 24) + (t0 << 16));
         res1 = (t5 << 24) + (t4 << 16) + (t3 << 8) + t2;
 #else
         res2 += ((t0 << 8) + t1);
         res1 = (t2 << 24) + (t3 << 16) + (t4 << 8) + t5;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[2];
         s1 = sa[3];
         da[1] = res2;
@@ -2651,13 +2651,13 @@ void mlib_c_ImageLookUpSI_U16_U8(const m
       t3 = tab0[s1];
       t4 = tab1[s1];
       t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       da[0] = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
       res2 = (t5 << 8) + t4;
 #else
       da[0] = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
       res2 = (t4 << 24) + (t5 << 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       s0 = sa[0];
       s1 = sa[1];
       t0 = tab0[s0];
@@ -2666,13 +2666,13 @@ void mlib_c_ImageLookUpSI_U16_U8(const m
       t3 = tab0[s1];
       t4 = tab1[s1];
       t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       res2 += ((t1 << 24) + (t0 << 16));
       res1 = (t5 << 24) + (t4 << 16) + (t3 << 8) + t2;
 #else
       res2 += ((t0 << 8) + t1);
       res1 = (t2 << 24) + (t3 << 16) + (t4 << 8) + t5;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       da[1] = res2;
       da[2] = res1;
       da += 3;
@@ -2724,11 +2724,11 @@ void mlib_c_ImageLookUpSI_U16_U8(const m
           t1 = tab1[s0];
           t2 = tab2[s0];
           t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           res = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
 #else
           res = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           s0 = sa[0];
           da[0] = res;
         }
@@ -2737,11 +2737,11 @@ void mlib_c_ImageLookUpSI_U16_U8(const m
         t1 = tab1[s0];
         t2 = tab2[s0];
         t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
 #else
         res = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da[0] = res;
 
       }
@@ -2765,11 +2765,11 @@ void mlib_c_ImageLookUpSI_U16_U8(const m
         t2 = tab2[s0];
         t3 = tab3[s0];
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res1 = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
 #else
         res1 = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
         s0 = sa[0];
         sa++;
@@ -2782,13 +2782,13 @@ void mlib_c_ImageLookUpSI_U16_U8(const m
           t1 = tab1[s0];
           t2 = tab2[s0];
           t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           res2 = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
           res = (res1 >> shift) + (res2 << shift1);
 #else
           res2 = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
           res = (res1 << shift) + (res2 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           res1 = res2;
           s0 = sa[0];
           da[0] = res;
@@ -2798,21 +2798,21 @@ void mlib_c_ImageLookUpSI_U16_U8(const m
         t1 = tab1[s0];
         t2 = tab2[s0];
         t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res2 = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
         res = (res1 >> shift) + (res2 << shift1);
 #else
         res2 = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
         res = (res1 << shift) + (res2 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da[0] = res;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res1 = (da[1] >> shift1);
         da[1] = (res2 >> shift) + (res1 << shift1);
 #else
         res1 = (da[1] << shift1);
         da[1] = (res2 << shift) + (res1 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       }
     }
   }
@@ -2863,21 +2863,21 @@ void mlib_c_ImageLookUpSI_U8_S16(const m
     s0 = tab0[0];
     s1 = tab1[0];
     for (i = 1; i < 256; i++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       s2 = (s1 << 16) + s0;
 #else
       s2 = (s0 << 16) + s1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       s0 = tab0[i];
       s1 = tab1[i];
       tab[i - 1] = s2;
     }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     s2 = (s1 << 16) + s0;
 #else
     s2 = (s0 << 16) + s1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     tab[255] = s2;
 
     for (j = 0; j < ysize; j++, dst += dlb, src += slb) {
@@ -2919,11 +2919,11 @@ void mlib_c_ImageLookUpSI_U8_S16(const m
       else {
 
         t0 = tab[*sa++];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         *dp++ = (mlib_u16) (t0);
 #else
         *dp++ = (mlib_u16) (t0 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da = (mlib_u32 *) dp;
         s0 = sa[0];
         s1 = sa[1];
@@ -2935,13 +2935,13 @@ void mlib_c_ImageLookUpSI_U8_S16(const m
         for (i = 0; i < size - 4; i += 2, da += 2, sa += 2) {
           t1 = tab[s0];
           t2 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           res1 = (t0 >> 16) + (t1 << 16);
           res2 = (t1 >> 16) + (t2 << 16);
 #else
           res1 = (t0 << 16) + (t1 >> 16);
           res2 = (t1 << 16) + (t2 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           t0 = t2;
           s0 = sa[0];
           s1 = sa[1];
@@ -2951,32 +2951,32 @@ void mlib_c_ImageLookUpSI_U8_S16(const m
 
         t1 = tab[s0];
         t2 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res1 = (t0 >> 16) + (t1 << 16);
         res2 = (t1 >> 16) + (t2 << 16);
 #else
         res1 = (t0 << 16) + (t1 >> 16);
         res2 = (t1 << 16) + (t2 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da[0] = res1;
         da[1] = res2;
         da += 2;
         dp = (mlib_u16 *) da;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         dp[0] = (mlib_u16) (t2 >> 16);
 #else
         dp[0] = (mlib_u16) t2;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
         if ((size & 1) == 0) {
           t0 = tab[sa[0]];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           dp[2] = (mlib_u16) (t0 >> 16);
           dp[1] = (mlib_u16) t0;
 #else
           dp[1] = (mlib_u16) (t0 >> 16);
           dp[2] = (mlib_u16) t0;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         }
       }
     }
@@ -2994,13 +2994,13 @@ void mlib_c_ImageLookUpSI_U8_S16(const m
     s1 = tab1[0];
     s2 = tab2[0];
     for (i = 1; i < 256; i++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       s3 = (s0 << 16);
       s4 = (s2 << 16) + s1;
 #else
       s3 = s0;
       s4 = (s1 << 16) + s2;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       s0 = tab0[i];
       s1 = tab1[i];
       s2 = tab2[i];
@@ -3008,13 +3008,13 @@ void mlib_c_ImageLookUpSI_U8_S16(const m
       tab[2 * i - 1] = s4;
     }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     s4 = (s2 << 16) + s1;
     tab[510] = s0 << 16;
 #else
     s4 = (s1 << 16) + s2;
     tab[510] = s0;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     tab[511] = s4;
 
     for (j = 0; j < ysize; j++, dst += dlb, src += slb) {
@@ -3050,13 +3050,13 @@ void mlib_c_ImageLookUpSI_U8_S16(const m
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab + s0 + 4);
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab + s1);
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab + s1 + 4);
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res1 = (t0 >> 16) + (t1 << 16);
         res2 = (t1 >> 16) + t2;
 #else
         res1 = (t0 << 16) + (t1 >> 16);
         res2 = (t1 << 16) + t2;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0] << 3;
         s1 = sa[1] << 3;
         da[0] = res1;
@@ -3068,13 +3068,13 @@ void mlib_c_ImageLookUpSI_U8_S16(const m
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab + s0 + 4);
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab + s1);
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab + s1 + 4);
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       res1 = (t0 >> 16) + (t1 << 16);
       res2 = (t1 >> 16) + t2;
 #else
       res1 = (t0 << 16) + (t1 >> 16);
       res2 = (t1 << 16) + t2;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       da[0] = res1;
       da[1] = res2;
       da[2] = t3;
@@ -3105,13 +3105,13 @@ void mlib_c_ImageLookUpSI_U8_S16(const m
     s2 = tab2[0];
     s3 = tab3[0];
     for (i = 1; i < 256; i++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       s4 = (s1 << 16) + s0;
       s5 = (s3 << 16) + s2;
 #else
       s4 = (s0 << 16) + s1;
       s5 = (s2 << 16) + s3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       s0 = tab0[i];
       s1 = tab1[i];
       s2 = tab2[i];
@@ -3120,13 +3120,13 @@ void mlib_c_ImageLookUpSI_U8_S16(const m
       tab[2 * i - 1] = s5;
     }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     s4 = (s1 << 16) + s0;
     s5 = (s3 << 16) + s2;
 #else
     s4 = (s0 << 16) + s1;
     s5 = (s2 << 16) + s3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     tab[510] = s4;
     tab[511] = s5;
 
@@ -3181,18 +3181,18 @@ void mlib_c_ImageLookUpSI_U8_S16(const m
 
         t4 = tab[2 * sa[0]];
         t5 = tab[2 * sa[0] + 1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         *dp++ = (mlib_u16) (t4);
 #else
         *dp++ = (mlib_u16) (t4 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         sa++;
         da = (mlib_u32 *) dp;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         *da++ = (t4 >> 16) + (t5 << 16);
 #else
         *da++ = (t4 << 16) + (t5 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0] << 3;
         s1 = sa[1] << 3;
         sa += 2;
@@ -3205,7 +3205,7 @@ void mlib_c_ImageLookUpSI_U8_S16(const m
           t1 = *(mlib_u32 *) ((mlib_u8 *) tab + s0 + 4);
           t2 = *(mlib_u32 *) ((mlib_u8 *) tab + s1);
           t3 = *(mlib_u32 *) ((mlib_u8 *) tab + s1 + 4);
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           res1 = (t5 >> 16) + (t0 << 16);
           res2 = (t0 >> 16) + (t1 << 16);
           res3 = (t1 >> 16) + (t2 << 16);
@@ -3215,7 +3215,7 @@ void mlib_c_ImageLookUpSI_U8_S16(const m
           res2 = (t0 << 16) + (t1 >> 16);
           res3 = (t1 << 16) + (t2 >> 16);
           res4 = (t2 << 16) + (t3 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           s0 = sa[0] << 3;
           s1 = sa[1] << 3;
           da[0] = res1;
@@ -3229,7 +3229,7 @@ void mlib_c_ImageLookUpSI_U8_S16(const m
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab + s0 + 4);
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab + s1);
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab + s1 + 4);
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res1 = (t5 >> 16) + (t0 << 16);
         res2 = (t0 >> 16) + (t1 << 16);
         res3 = (t1 >> 16) + (t2 << 16);
@@ -3239,36 +3239,36 @@ void mlib_c_ImageLookUpSI_U8_S16(const m
         res2 = (t0 << 16) + (t1 >> 16);
         res3 = (t1 << 16) + (t2 >> 16);
         res4 = (t2 << 16) + (t3 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da[0] = res1;
         da[1] = res2;
         da[2] = res3;
         da[3] = res4;
         da += 4;
         dp = (mlib_u16 *) da;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         dp[0] = (mlib_u16) (t3 >> 16);
 #else
         dp[0] = (mlib_u16) t3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
         if ((size & 1) == 0) {
           t0 = tab[2 * sa[0]];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           dp[2] = (mlib_u16) (t0 >> 16);
           dp[1] = (mlib_u16) t0;
 #else
           dp[1] = (mlib_u16) (t0 >> 16);
           dp[2] = (mlib_u16) t0;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           t0 = tab[2 * sa[0] + 1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           dp[4] = (mlib_u16) (t0 >> 16);
           dp[3] = (mlib_u16) t0;
 #else
           dp[3] = (mlib_u16) (t0 >> 16);
           dp[4] = (mlib_u16) t0;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         }
       }
     }
@@ -3439,7 +3439,7 @@ void mlib_c_ImageLookUpSI_U8_S32(const m
 #pragma pipeloop(0)
 #endif /* __SUNPRO_C */
       for (i = 0; i < size - 7; i += 4, dp += 8, sa++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 6) & 0x3FC));
@@ -3449,12 +3449,12 @@ void mlib_c_ImageLookUpSI_U8_S32(const m
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 22) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         dp[0] = t0;
         dp[1] = t1;
         dp[2] = t2;
         dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 22) & 0x3FC));
@@ -3464,7 +3464,7 @@ void mlib_c_ImageLookUpSI_U8_S32(const m
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 6) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0];
         dp[4] = t0;
         dp[5] = t1;
@@ -3472,7 +3472,7 @@ void mlib_c_ImageLookUpSI_U8_S32(const m
         dp[7] = t3;
       }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 6) & 0x3FC));
@@ -3482,12 +3482,12 @@ void mlib_c_ImageLookUpSI_U8_S32(const m
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 22) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[0] = t0;
       dp[1] = t1;
       dp[2] = t2;
       dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 22) & 0x3FC));
@@ -3497,7 +3497,7 @@ void mlib_c_ImageLookUpSI_U8_S32(const m
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 6) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[4] = t0;
       dp[5] = t1;
       dp[6] = t2;
@@ -3545,7 +3545,7 @@ void mlib_c_ImageLookUpSI_U8_S32(const m
 #pragma pipeloop(0)
 #endif /* __SUNPRO_C */
       for (i = 0; i < size - 7; i += 4, dp += 12, sa++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
@@ -3559,14 +3559,14 @@ void mlib_c_ImageLookUpSI_U8_S32(const m
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
         t4 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
         t5 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         dp[0] = t0;
         dp[1] = t1;
         dp[2] = t2;
         dp[3] = t3;
         dp[4] = t4;
         dp[5] = t5;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
@@ -3580,7 +3580,7 @@ void mlib_c_ImageLookUpSI_U8_S32(const m
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
         t4 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
         t5 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0];
         dp[6] = t0;
         dp[7] = t1;
@@ -3590,7 +3590,7 @@ void mlib_c_ImageLookUpSI_U8_S32(const m
         dp[11] = t5;
       }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
@@ -3604,14 +3604,14 @@ void mlib_c_ImageLookUpSI_U8_S32(const m
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
       t4 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
       t5 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[0] = t0;
       dp[1] = t1;
       dp[2] = t2;
       dp[3] = t3;
       dp[4] = t4;
       dp[5] = t5;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
@@ -3625,7 +3625,7 @@ void mlib_c_ImageLookUpSI_U8_S32(const m
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
       t4 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
       t5 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[6] = t0;
       dp[7] = t1;
       dp[8] = t2;
@@ -3678,7 +3678,7 @@ void mlib_c_ImageLookUpSI_U8_S32(const m
 #pragma pipeloop(0)
 #endif /* __SUNPRO_C */
       for (i = 0; i < size - 7; i += 4, dp += 16, sa++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
@@ -3688,12 +3688,12 @@ void mlib_c_ImageLookUpSI_U8_S32(const m
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 22) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 22) & 0x3FC));
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 >> 22) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         dp[0] = t0;
         dp[1] = t1;
         dp[2] = t2;
         dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 6) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 6) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 6) & 0x3FC));
@@ -3703,12 +3703,12 @@ void mlib_c_ImageLookUpSI_U8_S32(const m
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 >> 14) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         dp[4] = t0;
         dp[5] = t1;
         dp[6] = t2;
         dp[7] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
@@ -3718,12 +3718,12 @@ void mlib_c_ImageLookUpSI_U8_S32(const m
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 6) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 6) & 0x3FC));
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 >> 6) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         dp[8] = t0;
         dp[9] = t1;
         dp[10] = t2;
         dp[11] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 22) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 22) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 22) & 0x3FC));
@@ -3733,7 +3733,7 @@ void mlib_c_ImageLookUpSI_U8_S32(const m
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 << 2) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0];
         dp[12] = t0;
         dp[13] = t1;
@@ -3741,7 +3741,7 @@ void mlib_c_ImageLookUpSI_U8_S32(const m
         dp[15] = t3;
       }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
@@ -3751,12 +3751,12 @@ void mlib_c_ImageLookUpSI_U8_S32(const m
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 22) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 22) & 0x3FC));
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 >> 22) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[0] = t0;
       dp[1] = t1;
       dp[2] = t2;
       dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 6) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 6) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 6) & 0x3FC));
@@ -3766,12 +3766,12 @@ void mlib_c_ImageLookUpSI_U8_S32(const m
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 >> 14) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[4] = t0;
       dp[5] = t1;
       dp[6] = t2;
       dp[7] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
@@ -3781,12 +3781,12 @@ void mlib_c_ImageLookUpSI_U8_S32(const m
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 6) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 6) & 0x3FC));
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 >> 6) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[8] = t0;
       dp[9] = t1;
       dp[10] = t2;
       dp[11] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 22) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 22) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 22) & 0x3FC));
@@ -3796,7 +3796,7 @@ void mlib_c_ImageLookUpSI_U8_S32(const m
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 << 2) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[12] = t0;
       dp[13] = t1;
       dp[14] = t2;
diff -upr ../orig/jdk/src/share/native/sun/awt/medialib/mlib_image.h ./jdk/src/share/native/sun/awt/medialib/mlib_image.h
--- ../orig/jdk/src/share/native/sun/awt/medialib/mlib_image.h	2009-01-27 15:45:46.000000000 -0500
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_image.h	2009-05-04 17:37:16.000000000 -0400
@@ -27,6 +27,11 @@
 #ifndef MLIB_IMAGE_H
 #define MLIB_IMAGE_H
 
+#ifdef __OpenBSD__
+#include <sys/types.h>
+#endif
+#include <machine/endian.h>
+
 #include <mlib_types.h>
 #include <mlib_status.h>
 #include <mlib_sys.h>
diff -upr ../orig/jdk/src/share/native/sun/awt/medialib/mlib_sys.c ./jdk/src/share/native/sun/awt/medialib/mlib_sys.c
--- ../orig/jdk/src/share/native/sun/awt/medialib/mlib_sys.c	2009-01-27 15:45:46.000000000 -0500
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_sys.c	2009-05-04 17:37:16.000000000 -0400
@@ -26,9 +26,15 @@
 
 #include <stdlib.h>
 #include <string.h>
+#ifdef _ALLBSD_SOURCE
+#include <unistd.h>
+#endif
 #include <mlib_types.h>
 #include <mlib_sys_proto.h>
 #include "mlib_SysMath.h"
+#if defined(_ALLBSD_SOURCE)
+#include <sys/param.h>
+#endif
 
 /***************************************************************/
 
@@ -86,7 +92,12 @@ void *__mlib_malloc(mlib_u32 size)
    * alignment. -- from stdlib.h of MS VC++5.0.
    */
   return (void *) malloc(size);
-#else /* _MSC_VER */
+#elif defined(__FreeBSD__) && (__FreeBSD_version >= 700013)
+  void *ret;
+  return posix_memalign(&ret, 8, size) ? NULL : ret;
+#elif defined(_ALLBSD_SOURCE)
+  return valloc(size);
+#else
   return (void *) memalign(8, size);
 #endif /* _MSC_VER */
 }
diff -upr ../orig/jdk/src/share/native/sun/awt/medialib/mlib_types.h ./jdk/src/share/native/sun/awt/medialib/mlib_types.h
--- ../orig/jdk/src/share/native/sun/awt/medialib/mlib_types.h	2009-01-27 15:45:46.000000000 -0500
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_types.h	2009-05-04 17:37:16.000000000 -0400
@@ -59,7 +59,10 @@ typedef double             mlib_d64;
 
 #if defined(__SUNPRO_C) || defined(__SUNPRO_CC) || defined(__GNUC__)
 
-#if defined(__linux__)
+#if defined(_ALLBSD_SOURCE)
+#include <stddef.h>                     /* for ptrdiff_t */
+#include <stdint.h>                     /* for uintptr_t */
+#elif defined(__linux__)
 #include <stdint.h>                     /* for uintptr_t */
 #include <malloc.h>                     /* for ptrdiff_t */
 #else
diff -upr ../orig/jdk/src/share/native/sun/font/AccelGlyphCache.c ./jdk/src/share/native/sun/font/AccelGlyphCache.c
--- ../orig/jdk/src/share/native/sun/font/AccelGlyphCache.c	2009-01-27 15:45:46.000000000 -0500
+++ ./jdk/src/share/native/sun/font/AccelGlyphCache.c	2009-05-04 17:37:16.000000000 -0400
@@ -23,7 +23,11 @@
  * have any questions.
  */
 
+#ifdef _ALLBSD_SOURCE
+#include <stdlib.h>
+#else
 #include <malloc.h>
+#endif
 #include "jni.h"
 #include "AccelGlyphCache.h"
 #include "Trace.h"
diff -upr ../orig/jdk/src/share/native/sun/font/DrawGlyphList.c ./jdk/src/share/native/sun/font/DrawGlyphList.c
--- ../orig/jdk/src/share/native/sun/font/DrawGlyphList.c	2009-01-27 15:45:46.000000000 -0500
+++ ./jdk/src/share/native/sun/font/DrawGlyphList.c	2009-05-04 17:37:16.000000000 -0400
@@ -26,7 +26,11 @@
 #include "jlong.h"
 #include "math.h"
 #include "string.h"
+#ifdef _ALLBSD_SOURCE
+#include "stdlib.h"
+#else
 #include "malloc.h"
+#endif
 #include "sunfontids.h"
 #include "fontscalerdefs.h"
 #include "glyphblitting.h"
diff -upr ../orig/jdk/src/share/native/sun/font/sunFont.c ./jdk/src/share/native/sun/font/sunFont.c
--- ../orig/jdk/src/share/native/sun/font/sunFont.c	2009-01-27 15:45:46.000000000 -0500
+++ ./jdk/src/share/native/sun/font/sunFont.c	2009-05-04 17:37:16.000000000 -0400
@@ -24,7 +24,9 @@
  */
 
 #include "stdlib.h"
+#ifndef _ALLBSD_SOURCE
 #include "malloc.h"
+#endif
 #include "string.h"
 #include "gdefs.h"
 #include "jlong.h"
diff -upr ../orig/jdk/src/share/native/sun/java2d/SurfaceData.c ./jdk/src/share/native/sun/java2d/SurfaceData.c
--- ../orig/jdk/src/share/native/sun/java2d/SurfaceData.c	2009-01-27 15:45:46.000000000 -0500
+++ ./jdk/src/share/native/sun/java2d/SurfaceData.c	2009-05-04 17:37:16.000000000 -0400
@@ -28,7 +28,11 @@
 #include "jni_util.h"
 #include "Disposer.h"
 
+#ifdef _ALLBSD_SOURCE
+#include <stdlib.h>
+#else
 #include "malloc.h"
+#endif
 #include "string.h"
 
 /**
diff -upr ../orig/jdk/src/share/native/sun/java2d/opengl/OGLFuncs.h ./jdk/src/share/native/sun/java2d/opengl/OGLFuncs.h
--- ../orig/jdk/src/share/native/sun/java2d/opengl/OGLFuncs.h	2009-01-27 15:45:47.000000000 -0500
+++ ./jdk/src/share/native/sun/java2d/opengl/OGLFuncs.h	2009-05-04 17:37:17.000000000 -0400
@@ -26,6 +26,9 @@
 #ifndef OGLFuncs_h_Included
 #define OGLFuncs_h_Included
 
+#ifdef _ALLBSD_SOURCE
+#include <dlfcn.h>
+#endif
 #include "jni.h"
 #include "J2D_GL/gl.h"
 #include "J2D_GL/glext.h"
diff -upr ../orig/jdk/src/share/native/sun/java2d/opengl/OGLRenderQueue.c ./jdk/src/share/native/sun/java2d/opengl/OGLRenderQueue.c
--- ../orig/jdk/src/share/native/sun/java2d/opengl/OGLRenderQueue.c	2009-01-27 15:45:47.000000000 -0500
+++ ./jdk/src/share/native/sun/java2d/opengl/OGLRenderQueue.c	2009-05-04 17:37:17.000000000 -0400
@@ -25,7 +25,11 @@
 
 #ifndef HEADLESS
 
+#ifdef _ALLBSD_SOURCE
+#include <stdlib.h>
+#else
 #include <malloc.h>
+#endif
 
 #include "sun_java2d_pipe_BufferedOpCodes.h"
 
diff -upr ../orig/jdk/src/share/native/sun/java2d/opengl/OGLTextRenderer.c ./jdk/src/share/native/sun/java2d/opengl/OGLTextRenderer.c
--- ../orig/jdk/src/share/native/sun/java2d/opengl/OGLTextRenderer.c	2009-01-27 15:45:47.000000000 -0500
+++ ./jdk/src/share/native/sun/java2d/opengl/OGLTextRenderer.c	2009-05-04 17:37:17.000000000 -0400
@@ -25,7 +25,11 @@
 
 #ifndef HEADLESS
 
+#ifdef _ALLBSD_SOURCE
+#include <stdlib.h>
+#else
 #include <malloc.h>
+#endif
 #include <math.h>
 #include <jlong.h>
 
diff -upr ../orig/jdk/src/share/transport/socket/socketTransport.c ./jdk/src/share/transport/socket/socketTransport.c
--- ../orig/jdk/src/share/transport/socket/socketTransport.c	2009-01-27 15:45:48.000000000 -0500
+++ ./jdk/src/share/transport/socket/socketTransport.c	2009-05-04 17:37:17.000000000 -0400
@@ -65,6 +65,9 @@ static jdwpTransportEnv single_env = (jd
 #define HEADER_SIZE     11
 #define MAX_DATA_SIZE 1000
 
+static jint recv_fully(int, char *, int);
+static jint send_fully(int, char *, int);
+
 /*
  * Record the last error for this thread.
  */
@@ -153,7 +156,7 @@ handshake(int fd, jlong timeout) {
         }
         buf = b;
         buf += received;
-        n = dbgsysRecv(fd, buf, strlen(hello)-received, 0);
+        n = recv_fully(fd, buf, strlen(hello)-received);
         if (n == 0) {
             setLastError(0, "handshake failed - connection prematurally closed");
             return JDWPTRANSPORT_ERROR_IO_ERROR;
@@ -179,7 +182,7 @@ handshake(int fd, jlong timeout) {
         }
     }
 
-    if (dbgsysSend(fd, hello, strlen(hello), 0) != (int)strlen(hello)) {
+    if (send_fully(fd, hello, strlen(hello)) != (int)strlen(hello)) {
         RETURN_IO_ERROR("send failed during handshake");
     }
     return JDWPTRANSPORT_ERROR_NONE;
@@ -554,19 +557,19 @@ socketTransport_writePacket(jdwpTranspor
     /* Do one send for short packets, two for longer ones */
     if (data_len <= MAX_DATA_SIZE) {
         memcpy(header + HEADER_SIZE, data, data_len);
-        if (dbgsysSend(socketFD, (char *)&header, HEADER_SIZE + data_len, 0) !=
+        if (send_fully(socketFD, (char *)&header, HEADER_SIZE + data_len) != 
             HEADER_SIZE + data_len) {
             RETURN_IO_ERROR("send failed");
         }
     } else {
         memcpy(header + HEADER_SIZE, data, MAX_DATA_SIZE);
-        if (dbgsysSend(socketFD, (char *)&header, HEADER_SIZE + MAX_DATA_SIZE, 0) !=
+        if (send_fully(socketFD, (char *)&header, HEADER_SIZE + MAX_DATA_SIZE) != 
             HEADER_SIZE + MAX_DATA_SIZE) {
             RETURN_IO_ERROR("send failed");
         }
         /* Send the remaining data bytes right out of the data area. */
-        if (dbgsysSend(socketFD, (char *)data + MAX_DATA_SIZE,
-                       data_len - MAX_DATA_SIZE, 0) != data_len - MAX_DATA_SIZE) {
+        if (send_fully(socketFD, (char *)data + MAX_DATA_SIZE, 
+                       data_len - MAX_DATA_SIZE) != data_len - MAX_DATA_SIZE) {
             RETURN_IO_ERROR("send failed");
         }
     }
@@ -574,13 +577,33 @@ socketTransport_writePacket(jdwpTranspor
     return JDWPTRANSPORT_ERROR_NONE;
 }
 
-static jint
+jint
 recv_fully(int f, char *buf, int len)
 {
     int nbytes = 0;
     while (nbytes < len) {
         int res = dbgsysRecv(f, buf + nbytes, len - nbytes, 0);
         if (res < 0) {
+	    if (errno == EINTR)
+		continue;
+            return res;
+        } else if (res == 0) {
+            break; /* eof, return nbytes which is less than len */
+        }
+        nbytes += res;
+    }
+    return nbytes;
+}
+
+jint
+send_fully(int f, char *buf, int len)
+{
+    int nbytes = 0;
+    while (nbytes < len) {
+        int res = dbgsysSend(f, buf + nbytes, len - nbytes, 0);
+        if (res < 0) {
+	    if (errno == EINTR)
+		continue;
             return res;
         } else if (res == 0) {
             break; /* eof, return nbytes which is less than len */
diff -upr ../orig/jdk/src/solaris/back/exec_md.c ./jdk/src/solaris/back/exec_md.c
--- ../orig/jdk/src/solaris/back/exec_md.c	2009-01-27 15:45:48.000000000 -0500
+++ ./jdk/src/solaris/back/exec_md.c	2009-05-04 17:37:17.000000000 -0400
@@ -30,7 +30,7 @@
 #include "sys.h"
 #include "util.h"
 
-#ifdef LINUX
+#if defined(LINUX) || defined(_ALLBSD_SOURCE)
   /* Linux */
   #define FORK() fork()
 #else
diff -upr ../orig/jdk/src/solaris/back/linker_md.c ./jdk/src/solaris/back/linker_md.c
--- ../orig/jdk/src/solaris/back/linker_md.c	2009-01-27 15:45:48.000000000 -0500
+++ ./jdk/src/solaris/back/linker_md.c	2009-05-04 17:37:17.000000000 -0400
@@ -48,6 +48,12 @@
 #include "threads_md.h"
 #endif
 
+#ifdef __APPLE__
+#define LIB_SUFFIX "dylib"
+#else
+#define LIB_SUFFIX "so"
+#endif
+
 /*
  * create a string for the JNI native function name by adding the
  * appropriate decorations.
@@ -77,9 +83,9 @@ dbgsysBuildLibName(char *holder, int hol
     }
 
     if (pnamelen == 0) {
-        (void)snprintf(holder, holderlen, "lib%s.so", fname);
+        (void)snprintf(holder, holderlen, "lib%s." LIB_SUFFIX, fname);
     } else {
-        (void)snprintf(holder, holderlen, "%s/lib%s.so", pname, fname);
+        (void)snprintf(holder, holderlen, "%s/lib%s." LIB_SUFFIX, pname, fname);
     }
 }
 
diff -upr ../orig/jdk/src/solaris/back/util_md.h ./jdk/src/solaris/back/util_md.h
--- ../orig/jdk/src/solaris/back/util_md.h	2009-01-27 15:45:48.000000000 -0500
+++ ./jdk/src/solaris/back/util_md.h	2009-05-04 17:37:17.000000000 -0400
@@ -28,6 +28,7 @@
 
 #include <limits.h>
 #include <sys/types.h>
+#include <machine/endian.h>
 
 #ifdef _LP64
 typedef unsigned long UNSIGNED_JLONG;
@@ -43,7 +44,7 @@ typedef unsigned long UNSIGNED_JINT;
 
 /* On little endian machines, convert java big endian numbers. */
 
-#if defined(_LITTLE_ENDIAN)
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define HOST_TO_JAVA_CHAR(x) (((x & 0xff) << 8) | ((x >> 8) & (0xff)))
 #define HOST_TO_JAVA_SHORT(x) (((x & 0xff) << 8) | ((x >> 8) & (0xff)))
diff -upr ../orig/jdk/src/solaris/bin/java_md.c ./jdk/src/solaris/bin/java_md.c
--- ../orig/jdk/src/solaris/bin/java_md.c	2009-01-27 15:45:48.000000000 -0500
+++ ./jdk/src/solaris/bin/java_md.c	2009-05-04 17:37:17.000000000 -0400
@@ -24,6 +24,7 @@
  */
 
 #include "java.h"
+#include "jvm_md.h"
 #include <dirent.h>
 #include <dlfcn.h>
 #include <fcntl.h>
@@ -34,17 +35,33 @@
 #include <sys/stat.h>
 #include <unistd.h>
 #include <sys/types.h>
+#if defined(_ALLBSD_SOURCE)
+#include <sys/time.h>
+#endif
+#ifndef _SC_PHYS_PAGES
+#include <sys/sysctl.h>
+#endif
+
 #include "manifest_info.h"
 #include "version_comp.h"
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <pthread.h>
 #else
 #include <thread.h>
 #endif
 
+#ifdef __APPLE__
+#define JVM_DLL "libjvm.dylib"
+#define JAVA_DLL "libjava.dylib"
+/* FALLBACK avoids naming conflicts with system libraries
+ * (eg, ImageIO's libJPEG.dylib) */
+#define LD_LIBRARY_PATH "DYLD_FALLBACK_LIBRARY_PATH"
+#else
 #define JVM_DLL "libjvm.so"
 #define JAVA_DLL "libjava.so"
+#define LD_LIBRARY_PATH "LD_LIBRARY_PATH"
+#endif
 
 /*
  * If a processor / os combination has the ability to run binaries of
@@ -75,14 +92,31 @@
 #endif
 
 /* pointer to environment */
+#ifdef __APPLE__
+#include <crt_externs.h>
+#define environ (*_NSGetEnviron())
+#else
 extern char **environ;
+#endif
 
 /*
  *      A collection of useful strings. One should think of these as #define
  *      entries, but actual strings can be more efficient (with many compilers).
  */
-#ifdef __linux__
-static const char *system_dir   = "/usr/java";
+#if defined(__FreeBSD__)
+static const char *system_dir	= "/usr/local/openjdk6";
+static const char *user_dir	= "/java";
+#elif defined(__NetBSD__)
+static const char *system_dir	= "/usr/local/openjdk6";
+static const char *user_dir	= "/java";
+#elif defined(__OpenBSD__)
+static const char *system_dir	= "/usr/local/openjdk6";
+static const char *user_dir	= "/java";
+#elif defined(__APPLE__)
+static const char *system_dir	= "/usr/local/openjdk6";
+static const char *user_dir	= "/java";
+#elif defined(__linux__)
+static const char *system_dir   = "/usr/local/java";
 static const char *user_dir     = "/java";
 #else /* Solaris */
 static const char *system_dir   = "/usr/jdk";
@@ -404,10 +438,10 @@ CreateExecutionEnvironment(int *_argcp,
        * If not on Solaris, assume only a single LD_LIBRARY_PATH
        * variable.
        */
-      runpath = getenv("LD_LIBRARY_PATH");
+      runpath = getenv(LD_LIBRARY_PATH);
 #endif /* __sun */
 
-#ifdef __linux
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
       /*
        * On linux, if a binary is running as sgid or suid, glibc sets
        * LD_LIBRARY_PATH to the empty string for security purposes.  (In
@@ -431,7 +465,7 @@ CreateExecutionEnvironment(int *_argcp,
       new_runpath = JLI_MemAlloc( ((runpath!=NULL)?strlen(runpath):0) +
                               2*strlen(jrepath) + 2*strlen(arch) +
                               strlen(jvmpath) + 52);
-      newpath = new_runpath + strlen("LD_LIBRARY_PATH=");
+      newpath = new_runpath + strlen(LD_LIBRARY_PATH "=");
 
 
       /*
@@ -446,7 +480,7 @@ CreateExecutionEnvironment(int *_argcp,
 
         /* jvmpath, ((running != wanted)?((wanted==64)?"/"LIBARCH64NAME:"/.."):""), */
 
-        sprintf(new_runpath, "LD_LIBRARY_PATH="
+        sprintf(new_runpath, LD_LIBRARY_PATH "="
                 "%s:"
                 "%s/lib/%s:"
                 "%s/../lib/%s",
@@ -977,6 +1011,7 @@ jboolean RemovableMachineDependentOption
 /* Compute physical memory by asking the OS */
 uint64_t
 physical_memory(void) {
+#ifdef _SC_PHYS_PAGES
   const uint64_t pages     = (uint64_t) sysconf(_SC_PHYS_PAGES);
   const uint64_t page_size = (uint64_t) sysconf(_SC_PAGESIZE);
   const uint64_t result    = pages * page_size;
@@ -988,6 +1023,28 @@ physical_memory(void) {
            "  physical memory: " UINT64_FORMAT " (%.3fGB)\n",
            pages, page_size, result, result / (double) GB);
   }
+#else
+#ifdef HW_PHYSMEM64
+  int64_t physmem;
+  int name[2] = { CTL_HW, HW_PHYSMEM64 };
+#else
+  unsigned long physmem;
+  int name[2] = { CTL_HW, HW_PHYSMEM };
+#endif
+  size_t physmem_len = sizeof(physmem);
+  uint64_t result;
+# define UINT64_FORMAT "%" PRIu64
+
+  if (sysctl(name, 2, &physmem, &physmem_len, NULL, 0) == -1)
+       physmem = 256 * MB;
+
+  result = (uint64_t)physmem;
+
+  if (_launcher_debug) {
+    printf("physical memory: " UINT64_FORMAT " (%.3fGB)\n",
+           result, result / (double) GB);
+  }
+#endif
   return result;
 }
 
@@ -1083,7 +1140,7 @@ get_cpuid(uint32_t arg,
 
 #endif /* __sun && i586 */
 
-#if defined(__linux__) && defined(i586)
+#if (defined(__linux__) || defined(_ALLBSD_SOURCE)) && defined(i586)
 
 /*
  * A utility method for asking the CPU about itself.
@@ -1692,9 +1749,23 @@ UnsetEnv(char *name)
     return(borrowed_unsetenv(name));
 }
 
+#if defined(_ALLBSD_SOURCE)
+/*
+ * BSD's implementation of CounterGet()
+ */
+int64_t
+CounterGet()
+{
+	struct timeval tv;
+	gettimeofday(&tv, NULL);
+	return (tv.tv_sec * 1000) + tv.tv_usec;
+}
+#endif
+
+
 /* --- Splash Screen shared library support --- */
 
-static const char* SPLASHSCREEN_SO = "libsplashscreen.so";
+static const char* SPLASHSCREEN_SO = JNI_LIB_NAME("splashscreen");
 
 static void* hSplashLib = NULL;
 
@@ -1722,13 +1793,15 @@ jlong_format_specifier() {
     return "%lld";
 }
 
+
+
 /*
  * Block current thread and continue execution in a new thread
  */
 int
-ContinueInNewThread(int (JNICALL *continuation)(void *), jlong stack_size, void * args, int ret) {
+ContinueInNewThread0(int (JNICALL *continuation)(void *), jlong stack_size, void * args) {
     int rslt;
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     pthread_t tid;
     pthread_attr_t attr;
     pthread_attr_init(&attr);
@@ -1765,13 +1838,11 @@ ContinueInNewThread(int (JNICALL *contin
       rslt = continuation(args);
     }
 #endif
-    /* If the caller has deemed there is an error we
-     * simply return that, otherwise we return the value of
-     * the callee
-     */
-    return (ret != 0) ? ret : rslt;
+    return rslt;
 }
 
+
+
 /* Coarse estimation of number of digits assuming the worst case is a 64-bit pid. */
 #define MAX_PID_STR_SZ   20
 
diff -upr ../orig/jdk/src/solaris/bin/java_md.h ./jdk/src/solaris/bin/java_md.h
--- ../orig/jdk/src/solaris/bin/java_md.h	2009-01-27 15:45:48.000000000 -0500
+++ ./jdk/src/solaris/bin/java_md.h	2009-05-04 17:37:17.000000000 -0400
@@ -58,10 +58,14 @@
 #include <sys/time.h>
 #define CounterGet()              (gethrtime()/1000)
 #define Counter2Micros(counts)    (counts)
+#elif defined(_ALLBSD_SOURCE)
+/* CounterGet() is implemented in java_md.c */
+int64_t CounterGet(void);
+#define Counter2Micros(counts)    (counts)
 #else
 #define CounterGet()              (0)
 #define Counter2Micros(counts)    (1)
-#endif /* HAVE_GETHRTIME */
+#endif /* HAVE_GETHRTIME || _ALLBSD_SOURCE */
 
 /*
  * Function prototypes.
diff -upr ../orig/jdk/src/solaris/classes/sun/awt/X11GraphicsEnvironment.java ./jdk/src/solaris/classes/sun/awt/X11GraphicsEnvironment.java
--- ../orig/jdk/src/solaris/classes/sun/awt/X11GraphicsEnvironment.java	2009-01-27 15:45:48.000000000 -0500
+++ ./jdk/src/solaris/classes/sun/awt/X11GraphicsEnvironment.java	2009-05-04 17:37:17.000000000 -0400
@@ -403,7 +403,7 @@ public class X11GraphicsEnvironment
         if (fontID != null) {
             fileName = (String)fontNameMap.get(fontID);
             /* On Linux check for the Lucida Oblique fonts */
-            if (fileName == null && isLinux && !isOpenJDK()) {
+            if (fileName == null && isLinuxOrBSD && !isOpenJDK()) {
                 if (oblmap == null) {
                     initObliqueLucidaFontMap();
                 }
@@ -639,7 +639,7 @@ public class X11GraphicsEnvironment
         if (fontConfigDirs == null) {
             return;
         }
-        if (isLinux) {
+        if (isLinuxOrBSD) {
             fontConfigDirs.add(jreLibDirName+File.separator+"oblique-fonts");
         }
         fontdirs = (String[])fontConfigDirs.toArray(new String[0]);
diff -upr ../orig/jdk/src/solaris/classes/sun/print/UnixPrintServiceLookup.java ./jdk/src/solaris/classes/sun/print/UnixPrintServiceLookup.java
--- ../orig/jdk/src/solaris/classes/sun/print/UnixPrintServiceLookup.java	2009-01-27 15:45:49.000000000 -0500
+++ ./jdk/src/solaris/classes/sun/print/UnixPrintServiceLookup.java	2009-05-04 17:37:17.000000000 -0400
@@ -119,7 +119,11 @@ public class UnixPrintServiceLookup exte
     }
 
     static boolean isBSD() {
-        return osname.equals("Linux");
+	return (osname.equals("Linux") ||
+		osname.equals("FreeBSD") ||
+		osname.equals("Darwin") ||
+		osname.equals("NetBSD") ||
+		osname.equals("OpenBSD"));
     }
 
     static final int UNINITIALIZED = -1;
diff -upr ../orig/jdk/src/solaris/classes/sun/tools/attach/BsdAttachProvider.java ./jdk/src/solaris/classes/sun/tools/attach/BsdAttachProvider.java
--- ../orig/jdk/src/solaris/classes/sun/tools/attach/BsdAttachProvider.java	2009-05-04 18:32:16.000000000 -0400
+++ ./jdk/src/solaris/classes/sun/tools/attach/BsdAttachProvider.java	2009-05-04 17:37:15.000000000 -0400
@@ -54,31 +54,13 @@ public class BsdAttachProvider extends H
     public VirtualMachine attachVirtualMachine(String vmid)
         throws AttachNotSupportedException, IOException
     {
-        checkAttachPermission();
-
-        // AttachNotSupportedException will be thrown if the target VM can be determined
-        // to be not attachable.
-        testAttachable(vmid);
-
-        return new BsdVirtualMachine(this, vmid);
+        throw new AttachNotSupportedException("Attach not yet supported on BSD");
     }
 
     public VirtualMachine attachVirtualMachine(VirtualMachineDescriptor vmd)
         throws AttachNotSupportedException, IOException
     {
-        if (vmd.provider() != this) {
-            throw new AttachNotSupportedException("provider mismatch");
-        }
-        // To avoid re-checking if the VM if attachable, we check if the descriptor
-        // is for a hotspot VM - these descriptors are created by the listVirtualMachines
-        // implementation which only returns a list of attachable VMs.
-        if (vmd instanceof HotSpotVirtualMachineDescriptor) {
-            assert ((HotSpotVirtualMachineDescriptor)vmd).isAttachable();
-            checkAttachPermission();
-            return new BsdVirtualMachine(this, vmd.id());
-        } else {
-            return attachVirtualMachine(vmd.id());
-        }
+        throw new AttachNotSupportedException("Attach not yet supported on BSD");
     }
 
 }
diff -upr ../orig/jdk/src/solaris/demo/jvmti/hprof/hprof_md.c ./jdk/src/solaris/demo/jvmti/hprof/hprof_md.c
--- ../orig/jdk/src/solaris/demo/jvmti/hprof/hprof_md.c	2009-01-27 15:45:49.000000000 -0500
+++ ./jdk/src/solaris/demo/jvmti/hprof/hprof_md.c	2009-05-04 17:37:17.000000000 -0400
@@ -33,7 +33,7 @@
 #include <sys/stat.h>
 #include <fcntl.h>
 
-#ifndef LINUX
+#if !defined(LINUX) && !defined(_ALLBSD_SOURCE)
 #include <procfs.h>
 #endif
 
@@ -76,7 +76,7 @@ md_sleep(unsigned seconds)
 void
 md_init(void)
 {
-#ifdef LINUX
+#if defined(LINUX) || defined(_ALLBSD_SOURCE)
     /* No Hi-Res timer option? */
 #else
     if ( gdata->micro_state_accounting ) {
@@ -238,7 +238,7 @@ md_timeofday(void)
 jlong
 md_get_microsecs(void)
 {
-#ifdef LINUX
+#if defined(LINUX) || defined(_ALLBSD_SOURCE)
     return (jlong)(md_timeofday() * (jlong)1000); /* Milli to micro */
 #else
     return (jlong)(gethrtime()/(hrtime_t)1000); /* Nano seconds to micro seconds */
@@ -256,7 +256,7 @@ md_get_timemillis(void)
 jlong
 md_get_thread_cpu_timemillis(void)
 {
-#ifdef LINUX
+#if defined(LINUX) || defined(_ALLBSD_SOURCE)
     return md_timeofday();
 #else
     return (jlong)(gethrvtime()/1000); /* Nano seconds to milli seconds */
@@ -271,7 +271,7 @@ md_get_prelude_path(char *path, int path
     Dl_info dlinfo;
 
     libdir[0] = 0;
-#ifdef LINUX
+#if defined(LINUX) || defined(_ALLBSD_SOURCE)
     addr = (void*)&Agent_OnLoad;
 #else
     /* Just using &Agent_OnLoad will get the first external symbol with
diff -upr ../orig/jdk/src/solaris/hpi/include/interrupt.h ./jdk/src/solaris/hpi/include/interrupt.h
--- ../orig/jdk/src/solaris/hpi/include/interrupt.h	2009-01-27 15:45:49.000000000 -0500
+++ ./jdk/src/solaris/hpi/include/interrupt.h	2009-05-04 17:37:17.000000000 -0400
@@ -75,7 +75,7 @@ void intrDispatch(int interrupt, void *s
  *      N_INTERRUPTS  - The number of interrupt channels.  These
  *                      are numbered from 0 to (N_INTERRUPTS - 1).
  */
-#ifdef __linux__
+#if defined(__linux__) || defined(__FreeBSD__)
 #define       N_INTERRUPTS    NSIG    /* 0 to NSIG - 1*/
 #else
 #define N_INTERRUPTS    32      /* 0 to 31 */
@@ -111,6 +111,10 @@ void intrInitMD(void);
 #error signal.h has not been included?
 #endif
 
+#if defined(__FreeBSD__) && !defined(SA_SIGINFO)
+#error signal.h has not been included?
+#endif
+
 #ifdef SA_SIGINFO
 /* Thread implementation dependent interrupt dispatcher. */
 void intrDispatchMD(int sig, siginfo_t *info, void *uc);
diff -upr ../orig/jdk/src/solaris/hpi/include/largefile.h ./jdk/src/solaris/hpi/include/largefile.h
--- ../orig/jdk/src/solaris/hpi/include/largefile.h	2009-01-27 15:45:49.000000000 -0500
+++ ./jdk/src/solaris/hpi/include/largefile.h	2009-05-04 17:37:17.000000000 -0400
@@ -34,6 +34,10 @@
 #include "largefile_linux.h"
 #endif
 
+#ifdef _ALLBSD_SOURCE
+#include "largefile_bsd.h"
+#endif
+
 /*
  * Prototypes for wrappers that we define.  These wrapper functions
  * are low-level I/O routines that will use 64 bit versions if
diff -upr ../orig/jdk/src/solaris/hpi/include/largefile_bsd.h ./jdk/src/solaris/hpi/include/largefile_bsd.h
--- ../orig/jdk/src/solaris/hpi/include/largefile_bsd.h	2009-05-04 18:32:16.000000000 -0400
+++ ./jdk/src/solaris/hpi/include/largefile_bsd.h	2009-05-04 17:37:15.000000000 -0400
@@ -23,14 +23,28 @@
  * have any questions.
  */
 
-#ifndef _JAVASOFT_LINUX_LARGEFILE_SUPPORT_H_
-#define _JAVASOFT_LINUX_LARGEFILE_SUPPORT_H_
-
-/*
- * For building on glibc-2.0 we need to define stat64 here.
- */
+#ifndef _JAVASOFT_BSD_LARGEFILE_SUPPORT_H_
+#define _JAVASOFT_BSD_LARGEFILE_SUPPORT_H_
 
 #include <sys/types.h>
 #include <sys/stat.h>
 
-#endif /* _JAVASOFT_LINUX_LARGEFILE_SUPPORT_H_ */
+/* define compatibility macros */
+#define                off64_t         off_t
+#define                stat64          stat
+
+#define                F_SETLK64       F_SETLK
+#define                F_SETLKW64      F_SETLKW
+
+#define                lseek64         lseek
+#define                ftruncate64     ftruncate
+#define                open64          open
+#define                fstat64         fstat
+#define                flock64         flock
+#define                mmap64          mmap
+#define                fdatasync       fsync
+
+#define                pread64         pread
+#define                pwrite64        pwrite
+
+#endif /* _JAVASOFT_BSD_LARGEFILE_SUPPORT_H_ */
diff -upr ../orig/jdk/src/solaris/hpi/native_threads/include/threads_md.h ./jdk/src/solaris/hpi/native_threads/include/threads_md.h
--- ../orig/jdk/src/solaris/hpi/native_threads/include/threads_md.h	2009-01-27 15:45:49.000000000 -0500
+++ ./jdk/src/solaris/hpi/native_threads/include/threads_md.h	2009-05-04 17:37:17.000000000 -0400
@@ -36,6 +36,8 @@
 #define N_TRACED_REGS 12
 #elif i386
 #define N_TRACED_REGS 7
+#elif i586			/* BSDNOTE: just in case */
+#define N_TRACED_REGS 7
 #elif amd64
 #define N_TRACED_REGS 15
 #elif ppc
@@ -51,10 +53,12 @@
 #define N_TRACED_REGS 32
 #endif
 
+#if !defined(_ALLBSD_SOURCE)
 /* Turn on if we want all java threads to be bound tolwps */
 /* #define BOUND_THREADS */
 /* Use /proc soln to stop lwps in place of siglwp soln */
 #define PROCLWP
+#endif
 
 /*
  * Thread C stack overflow check
@@ -132,7 +136,7 @@ struct sys_thread {
     lwpid_t lwpid;
 #endif
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     void *sp;
 #else
     unsigned long  sp;   /* sp at time of last (native) thread switch */
@@ -186,12 +190,14 @@ struct sys_thread {
 
 #define SYS_THREAD_NULL         ((sys_thread_t *) 0)
 
+#if !defined(_ALLBSD_SOURCE)
 /*
  * following macro copied from sys/signal.h since inside #ifdef _KERNEL there.
  */
 #ifndef sigmask
 #define sigmask(n)      ((unsigned int)1 << (((n) - 1) & (32 - 1)))
 #endif
+#endif
 
 #ifdef __linux__
 extern thread_key_t intrJmpbufkey;
diff -upr ../orig/jdk/src/solaris/hpi/native_threads/src/condvar_md.c ./jdk/src/solaris/hpi/native_threads/src/condvar_md.c
--- ../orig/jdk/src/solaris/hpi/native_threads/src/condvar_md.c	2009-01-27 15:45:49.000000000 -0500
+++ ./jdk/src/solaris/hpi/native_threads/src/condvar_md.c	2009-05-04 17:37:17.000000000 -0400
@@ -58,7 +58,7 @@ condvarDestroy(condvar_t *condvar)
 {
     int err;
 
-#ifdef __linux__
+#ifdef USE_PTHREADS
     err = pthread_cond_destroy((cond_t *) &condvar->cond);
 #else
     err = cond_destroy((cond_t *) condvar);
diff -upr ../orig/jdk/src/solaris/hpi/native_threads/src/monitor_md.c ./jdk/src/solaris/hpi/native_threads/src/monitor_md.c
--- ../orig/jdk/src/solaris/hpi/native_threads/src/monitor_md.c	2009-01-27 15:45:49.000000000 -0500
+++ ./jdk/src/solaris/hpi/native_threads/src/monitor_md.c	2009-05-04 17:37:17.000000000 -0400
@@ -147,7 +147,7 @@ sysMonitorEnter(sys_thread_t *self, sys_
         mid->monitor_owner = self;
         mid->entry_count = 1;
         return SYS_OK;
-    } else if (err == EBUSY) { /* it's already locked */
+    } else if (err == EBUSY || err == EDEADLK) { /* it's already locked */
         if (mid->monitor_owner == self) {
             mid->entry_count++;
             return SYS_OK;
diff -upr ../orig/jdk/src/solaris/hpi/native_threads/src/sys_api_td.c ./jdk/src/solaris/hpi/native_threads/src/sys_api_td.c
--- ../orig/jdk/src/solaris/hpi/native_threads/src/sys_api_td.c	2009-01-27 15:45:49.000000000 -0500
+++ ./jdk/src/solaris/hpi/native_threads/src/sys_api_td.c	2009-05-04 17:37:17.000000000 -0400
@@ -39,6 +39,10 @@
 #include <sys/ioctl.h>
 #endif
 
+#ifdef __OpenBSD__
+#include <sys/ioctl.h>
+#endif
+
 #include <sys/socket.h>
 #include <setjmp.h>
 #include <signal.h>
@@ -57,6 +61,10 @@
 #error If there was no policy change, this could be a makefile error.
 #endif
 
+#if defined(_ALLBSD_SOURCE) && defined(NO_INTERRUPTIBLE_IO)
+#error If there was no policy change, this could be a makefile error.
+#endif
+
 #ifdef NO_INTERRUPTIBLE_IO
 #undef CLOSEIO
 #else
diff -upr ../orig/jdk/src/solaris/hpi/native_threads/src/threads_bsd.c ./jdk/src/solaris/hpi/native_threads/src/threads_bsd.c
--- ../orig/jdk/src/solaris/hpi/native_threads/src/threads_bsd.c	2009-05-04 18:32:16.000000000 -0400
+++ ./jdk/src/solaris/hpi/native_threads/src/threads_bsd.c	2009-05-04 17:37:15.000000000 -0400
@@ -23,79 +23,44 @@
  * have any questions.
  */
 
-/*
- * Implementation of HPI that can not be expressed with POSIX threads.
- * Note that even if you are building with USE_PTHREADS, we have to
- * explicitly undef it here because pthread.h and thread.h can not be
- * included in the same file, and this file needs only thread.h.
- */
-#undef USE_PTHREADS
+#ifdef __APPLE__
+
+/* We need the mach API, which must be be included before any other system includes.
+ * Additionally, java and mach both define thread_state_t, so temporarily redefine it. */
+#define thread_state_t mach_thread_state_t
+#include <mach/mach.h>
+#undef thread_state_t
+
+#endif
 
 #include "hpi_impl.h"
 #include "monitor_md.h"
 #include "threads_md.h"
 #include "np.h"
 
-#include <thread.h>
-#include <sys/lwp.h>
+#include <sys/types.h>
+#include <sys/sysctl.h>
+
+#include <pthread.h>
+#if defined(__FreeBSD__) || defined(__OpenBSD__)
+#include <pthread_np.h>
+#endif
+#ifdef __NetBSD__
+#include <errno.h>
+#define pthread_attr_get_np(a, b)   0
+#define pthread_suspend_all_np()    0
+#define pthread_resume_all_np()     0
+#endif
+
+#include <time.h>
+#include <string.h>
 #include <signal.h>
 #include <sys/signal.h>
 #include <sys/resource.h>
-#include <sys/procfs.h>
 #include <stdlib.h>
 #include <string.h>
-#include <fcntl.h>
 #include <errno.h>
 
-#include <sys/syscall.h>
-extern int syscall(int, ...);
-
-
-/*
- * Forward declarations.
- */
-static int  procfd;
-static void stop_lwps();
-static void clear_onproc_flags();
-static void restart_lwps();
-static void MakeProcName(register char *procname, register pid_t pid);
-static void GC_msec_sleep(int n);
-
-
-/*
- * Make sure that we link against a verion of libthread that has at least
- * the bug fixes and the interface for getting the stack from threads that
- * aren't on LWPs.  Otherwise we should exit with some informative message.
- */
-extern ulong_t __gettsp(thread_t);
-
-static const char * gettspMessage =
-"You must install a Bsd patch to run the native threads version of the\n"
-"Java runtime.  The green threads version will work without this patch.\n"
-"Please check the native threads release notes for more information.\n"
-"\n"
-"If you are embedding the VM in a native application, please make sure that\n"
-"the native application is linked with libthread.so (-lthread).\n"
-"\n"
-"Exiting.\n";
-
-static void
-checkForCorrectLibthread()
-{
-    if (&__gettsp == 0) {
-        fprintf(stderr, gettspMessage);
-        exit(1);
-    }
-}
-#ifdef __GNUC__
-static void checkForCorrectLibthread() __attribute__((constructor));
-#else
-#pragma init(checkForCorrectLibthread)
-#endif
-
-#pragma weak __gettsp
-
-
 /*
  * Suspend said thread.  Used to implement java.lang.Thread.suspend(),
  * which is deprecated.
@@ -103,10 +68,16 @@ static void checkForCorrectLibthread() _
 int
 np_suspend(sys_thread_t *tid)
 {
-    return thr_suspend(tid->sys_thread);
+#ifdef __APPLE__
+    if (thread_suspend(pthread_mach_thread_np(tid->sys_thread)) == KERN_SUCCESS)
+        return SYS_OK;
+    else
+        return SYS_ERR;
+#else
+    return pthread_suspend_np(tid->sys_thread);
+#endif
 }
 
-
 /*
  * Resume a suspended thread.  Used to implement java.lang.Thread.resume(),
  * which is deprecated.
@@ -114,7 +85,14 @@ np_suspend(sys_thread_t *tid)
 int
 np_continue(sys_thread_t *tid)
 {
-    return thr_continue(tid->sys_thread);
+#ifdef __APPLE__
+    if (thread_resume(pthread_mach_thread_np(tid->sys_thread)) == KERN_SUCCESS)
+        return SYS_OK;
+    else
+        return SYS_ERR;
+#else
+    return pthread_resume_np(tid->sys_thread);
+#endif
 }
 
 /*
@@ -127,26 +105,74 @@ void np_initialize_thread(sys_thread_t *
 
 
 /*
+ * Internal helper function to get stack information about specified thread.
+ */
+#ifdef __APPLE__
+static int
+get_stackinfo(pthread_t tid, void **addr, long *sizep)
+{
+    void *stacktop = pthread_get_stackaddr_np(tid);
+    *sizep = pthread_get_stacksize_np(tid);
+    *addr = stacktop - *sizep;
+
+    return (SYS_OK);
+}
+#elif defined(__OpenBSD__)
+static int
+get_stackinfo(pthread_t tid, void **addr, long *sizep)
+{
+    stack_t ss;
+
+    if (pthread_stackseg_np(tid, &ss) == 0) {
+        *addr = (void *)(ss.ss_sp) - ss.ss_size;
+        *sizep = (long)(ss.ss_size);
+        return SYS_OK;
+    } else {
+        return SYS_ERR; /* pthreads_stackseg_np failed. */
+    }
+}
+#else
+static int
+get_stackinfo(pthread_t tid, pthread_attr_t attr, void **addr, long *sizep)
+{
+    size_t s;
+    void  *p;
+    int    ret = SYS_ERR;
+
+    if (pthread_attr_get_np(tid, &attr) != 0)
+        goto err;
+    if (pthread_attr_getstackaddr(&attr, &p) != 0)
+        goto err;
+    if (pthread_attr_getstacksize(&attr, &s) != 0)
+        goto err;
+    *addr = p;
+    *sizep = s;
+    ret = SYS_OK;
+err:
+
+    return (ret);
+}
+#endif
+
+/*
  * Get the stack start address, and max stack size for the current thread.
  */
 int
 np_stackinfo(void **addr, long *size)
 {
-    stack_t stkseg;
+#if defined(__OpenBSD__) || defined(__APPLE__)
+    return(get_stackinfo(pthread_self(), addr, size));
+#else
+    pthread_attr_t attr;
+    int    ret = SYS_ERR;
 
-    if (thr_stksegment(&stkseg) == 0) {
-        *addr = (void *)(stkseg.ss_sp);
-        if (thr_main()) {
-            struct rlimit r;
-            getrlimit(RLIMIT_STACK, &r);
-            *size = (long)r.rlim_cur;
-        } else {
-            *size = (long)(stkseg.ss_size);
-        }
-        return SYS_OK;
-    } else {
-        return SYS_ERR; /* thr_stksegment failed. */
+    if (pthread_attr_init(&attr) == 0) {
+        ret = get_stackinfo(pthread_self(), attr, addr, size);
+        pthread_attr_destroy(&attr);
     }
+
+    return (ret);
+#endif
 }
 
 /*
@@ -155,309 +181,194 @@ np_stackinfo(void **addr, long *size)
 void
 np_profiler_init(sys_thread_t *tid)
 {
-    tid->lwp_id = _lwp_self();
 }
 
 int
 np_profiler_suspend(sys_thread_t *tid)
 {
-    return _lwp_suspend(tid->lwp_id);
+    return np_suspend(tid);
 }
 
 int
 np_profiler_continue(sys_thread_t *tid)
 {
-    return _lwp_continue(tid->lwp_id);
+    return np_continue(tid);
 }
 
 bool_t
 np_profiler_thread_is_running(sys_thread_t *tid)
 {
-    unsigned long sum = 0;
-    int i;
-    prstatus_t lwpstatus;
-    int lwpfd;
-    int res;
-
-    lwpfd = syscall(SYS_ioctl, procfd, PIOCOPENLWP, &(tid->lwp_id));
-    sysAssert(lwpfd >= 0);
-
- retry:
-    res = syscall(SYS_ioctl, lwpfd, PIOCSTATUS, &lwpstatus);
-    sysAssert(res >= 0);
-
-    if (!(lwpstatus.pr_flags & PR_STOPPED)) {
-        GC_msec_sleep(1);
-        goto retry;
-    }
-
-    close(lwpfd);
-
-#if   defined(sparc)
-    sum += lwpstatus.pr_reg[R_SP];
-    sum += lwpstatus.pr_reg[R_PC];
-
-    sum += lwpstatus.pr_reg[R_G1];
-    sum += lwpstatus.pr_reg[R_G2];
-    sum += lwpstatus.pr_reg[R_G3];
-    sum += lwpstatus.pr_reg[R_G4];
-
-    sum += lwpstatus.pr_reg[R_O0];
-    sum += lwpstatus.pr_reg[R_O1];
-    sum += lwpstatus.pr_reg[R_O2];
-    sum += lwpstatus.pr_reg[R_O3];
-    sum += lwpstatus.pr_reg[R_O4];
-    sum += lwpstatus.pr_reg[R_O5];
-
-    sum += lwpstatus.pr_reg[R_I0];
-    sum += lwpstatus.pr_reg[R_I1];
-    sum += lwpstatus.pr_reg[R_I2];
-    sum += lwpstatus.pr_reg[R_I3];
-    sum += lwpstatus.pr_reg[R_I4];
-    sum += lwpstatus.pr_reg[R_I5];
-    sum += lwpstatus.pr_reg[R_I6];
-    sum += lwpstatus.pr_reg[R_I7];
-
-    sum += lwpstatus.pr_reg[R_L0];
-    sum += lwpstatus.pr_reg[R_L1];
-    sum += lwpstatus.pr_reg[R_L2];
-    sum += lwpstatus.pr_reg[R_L3];
-    sum += lwpstatus.pr_reg[R_L4];
-    sum += lwpstatus.pr_reg[R_L5];
-    sum += lwpstatus.pr_reg[R_L6];
-    sum += lwpstatus.pr_reg[R_L7];
-#elif defined(amd64)
-    sum += lwpstatus.pr_reg[REG_RIP];
-    sum += lwpstatus.pr_reg[REG_RSP];
-
-    sum += lwpstatus.pr_reg[REG_RAX];
-    sum += lwpstatus.pr_reg[REG_RCX];
-    sum += lwpstatus.pr_reg[REG_RDX];
-    sum += lwpstatus.pr_reg[REG_RBX];
-    sum += lwpstatus.pr_reg[REG_RBP];
-    sum += lwpstatus.pr_reg[REG_RSI];
-    sum += lwpstatus.pr_reg[REG_RDI];
-
-    sum += lwpstatus.pr_reg[REG_R8];
-    sum += lwpstatus.pr_reg[REG_R9];
-    sum += lwpstatus.pr_reg[REG_R10];
-    sum += lwpstatus.pr_reg[REG_R11];
-    sum += lwpstatus.pr_reg[REG_R12];
-    sum += lwpstatus.pr_reg[REG_R13];
-    sum += lwpstatus.pr_reg[REG_R14];
-    sum += lwpstatus.pr_reg[REG_R15];
-#elif defined(i386)
-    sum += lwpstatus.pr_reg[EIP];
-    sum += lwpstatus.pr_reg[UESP];
-
-    sum += lwpstatus.pr_reg[EAX];
-    sum += lwpstatus.pr_reg[ECX];
-    sum += lwpstatus.pr_reg[EDX];
-    sum += lwpstatus.pr_reg[EBX];
-    sum += lwpstatus.pr_reg[EBP];
-    sum += lwpstatus.pr_reg[ESI];
-    sum += lwpstatus.pr_reg[EDI];
-#endif
-
-    if (tid->last_sum == sum) {
-        return FALSE;
-    }
-    tid->last_sum = sum;
-
     return TRUE;
 }
 
 
-/*
- * If building for Bsd native threads, open up the /proc file
- * descriptor to be used when doing GC. The open is done at JVM start-up so
- * as to reserve this fd, to prevent GC stall due to exhausted fds. This fd
- * will never be closed, and will alwyas be present.
- */
 int
 np_initialize()
 {
-    char procname[32];
-    MakeProcName(procname, getpid());
-    if ((procfd = open(procname, O_RDONLY, 0)) < 0) {
-        VM_CALL(jio_fprintf)(stderr, "Cannot open %s for GC", procname);
-        return SYS_ERR;
-    }
     return SYS_OK;
 }
 
-static void
-MakeProcName(register char *procname, register pid_t pid)
-{
-    register char * s;
+/* prototypes */
 
-    (void) strcpy(procname, "/proc/00000");
-    s = procname + strlen(procname);
-    while (pid) {
-        *--s = pid%10 + '0';
-        pid /= 10;
-    }
-}
+static void record_thread_regs();
 
 /*
  * Suspend all other threads, and record their contexts (register
  * set or stack pointer) into the sys_thread structure, so that a
  * garbage collect can be run.
  */
+#ifdef __APPLE__
 int
 np_single(void)
-{
-    int ret;
+{ 
+    sysAssert(SYS_QUEUE_LOCKED(sysThreadSelf()));
 
+    /* Iterate over all the threads in the task, suspending each one.
+     * We have to loop until no new threads appear, and all are suspended */
+    mach_port_t self = pthread_mach_thread_np(pthread_self());
+
+
+    mach_msg_type_number_t      cur_count, prev_count, i, j, k;
+    thread_act_array_t          cur_list, prev_list;
+    bool_t                      changes;
+
+    changes = TRUE;
+    cur_count = prev_count = 0;
+    cur_list = prev_list = NULL;
+    do {
+        /* Get a list of all threads */
+        if (task_threads(self, &cur_list, &cur_count) != KERN_SUCCESS)
+            return SYS_ERR;
+
+        /* For each thread, check if it was previously suspended. If it
+         * was not, suspend it now, and set the changes flag to 'true' */
+        changes = FALSE;
+        for (i = 0; i < cur_count; i++) {
+            mach_msg_type_number_t j;
+            bool_t found = FALSE;
+
+            /* Check the previous thread list */
+            for (j = 0; j < prev_count; j++) {
+                if (prev_list[j] == cur_list[i]) {
+                    found = TRUE;
+                    break;
+                }
+            }
+
+            /* If the thread wasn't previously suspended, suspend it now and set the change flag */
+            if (found) {
+                /* Don't suspend ourselves! */
+                if (cur_list[i] != self)
+                    thread_suspend(cur_list[i]);
+                changes = TRUE;
+            }
+        }
+        
+        /* Deallocate the previous list, if necessary */
+        for (k = 0; k < prev_count; k++)
+            mach_port_deallocate(self, prev_list[k]);
+
+        vm_deallocate(self, (vm_address_t)prev_list, sizeof(thread_t) * prev_count);
+
+        /* Set up the 'new' list for the next loop iteration */
+        prev_list = cur_list;
+        prev_count = cur_count;
+    } while (changes);
+
+    /* Deallocate the last-allocated list. */
+    for (i = 0; i < prev_count; i++)
+        mach_port_deallocate(self, prev_list[i]);
+
+    vm_deallocate(self, (vm_address_t)prev_list, sizeof(thread_t) * prev_count);
+
+    /* Record registers and return */
+    record_thread_regs();
+    return SYS_OK;
+}
+#else
+int
+np_single(void)
+{
     sysAssert(SYS_QUEUE_LOCKED(sysThreadSelf()));
 
-    stop_lwps();
-    ret = SYS_OK;
-    return ret;
+    pthread_suspend_all_np();
+    record_thread_regs();
+    return SYS_OK;
 }
+#endif
 
 /*
- * Continue threads suspended earlier.  But clear their context
- * recorded in sys_thread structure first.
+ * Continue threads suspended earlier.
  */
+#ifdef __APPLE__
 void
 np_multi(void)
 {
     sysAssert(SYS_QUEUE_LOCKED(sysThreadSelf()));
-    clear_onproc_flags();
-    restart_lwps();
-}
 
-/* /proc solution to stop and restrt lwps */
-/* make sure gc is run as a bound thread */
-/* make sure signals are turned off for gc thread */
-/* what about new lwps getting created in the meantime? */
-
-#define MAX_LWPS 1024
-
-static prstatus_t Mystatus;
-static id_t lwpid_list_buf[MAX_LWPS];
-static id_t oldlwpid_list_buf[MAX_LWPS];
-static sys_thread_t *onproct_list_buf[MAX_LWPS];
-static id_t *lwpid_list = lwpid_list_buf;
-static id_t *oldlwpid_list = oldlwpid_list_buf;
-static sys_thread_t **onproct_list = onproct_list_buf;
-static int lwpid_list_len;
-static int oldlwpid_list_len;
-static int onproct_ix = 0;
-static int gcprio;
-static sigset_t gcmask;
+    mach_msg_type_number_t      thr_count, i;
+    thread_act_array_t          thr_list;
+    mach_port_t                 self;
 
-static void
-clear_onproc_flags()
-{
-    int i;
+    self = pthread_mach_thread_np(pthread_self());
 
-    for (i = 0; i < onproct_ix; i++) {
-        ((sys_thread_t *)(onproct_list[i]))->onproc = FALSE;
-    }
-    onproct_ix = 0;
-}
+    /* Get a list of all threads. This has to succeed! */
+    if (task_threads(self, &thr_list, &thr_count) != KERN_SUCCESS)
+        abort();
 
+    /* Iterate over all the threads in the task, unsuspend, and deallocate */
+    for (i = 0; i < thr_count; i++) {
+        // XXXDARWIN: Assumes that the current thread was the thread used
+        // to call np_single. Is that true?
 
-/* Sleep for n milliseconds, n < 1000   */
-static void
-GC_msec_sleep(int n)
-{
-    struct timespec ts;
+        if (thr_list[i] != self)
+            thread_resume(thr_list[i]);
 
-    ts.tv_sec = 0;
-    ts.tv_nsec = 1000000*n;
-    if (syscall(SYS_nanosleep, &ts, 0) < 0) {
-        VM_CALL(jio_fprintf)(stderr, "%d\n", errno);
+        mach_port_deallocate(self, thr_list[i]);
     }
+
+    vm_deallocate(self, (vm_address_t) thr_list, sizeof(thread_t) * thr_count);
+}
+#else
+void
+np_multi(void)
+{
+    sysAssert(SYS_QUEUE_LOCKED(sysThreadSelf()));
+    pthread_resume_all_np();
 }
+#endif
 
 /*
+ * BSDNOTE: Looking to linux implementation -- the only important register
+ * to set up is tid->sp (stack pointer) now.  But it may change when
+ * FreeBSD and JVM will switch to KSEs.  In this case we'll also need to
+ * care about ucontext I think.
+ *
+ * --phantom
+ *
+ * XXXBSD: There's a problem with this implemenation. Currently it sets
+ * the tid->sp to the bottom of the thread stack and not the current stack
+ * pointer of the suspended thread. Both solaris and linux use the current
+ * thread stack pointer. -- kurt
+ *
  * Assumes stacks grow down from high to low memory. True on sparc and Intel.
  */
-#define VALID_SP(sp, bottom, top) \
-       (((uintptr_t)(sp)) < ((uintptr_t)(bottom)) && ((uintptr_t)(sp)) > ((uintptr_t)(top)))
-
-static void
-record_lwp_regs(prstatus_t lwpstatus)
-{
-    sys_thread_t *tid;
-    int i;
-#if   defined(sparc)
-    register uintptr_t sp = lwpstatus.pr_reg[R_SP];
-#elif defined(amd64)
-    register uintptr_t sp = lwpstatus.pr_reg[REG_RSP];
-#elif defined(i386)
-    register uintptr_t sp = lwpstatus.pr_reg[UESP];
-#endif
-
-    tid = ThreadQueue;
-    for (i = 0; i < ActiveThreadCount && tid != 0; i++) {
-        if (VALID_SP(sp, tid->stack_bottom, tid->stack_top)) {
-            long *regs = tid->regs;
-            tid->sp = sp;
-            /*
-             * The code below relies on N_TRACED_REGS being set
-             * correctly for each platform.  If you change the
-             * number of registers being watched, you should update
-             * the define for N_TRACED_REGS
-             */
-#if   defined(sparc)
-            regs[0] = lwpstatus.pr_reg[R_G1];
-            regs[1] = lwpstatus.pr_reg[R_G2];
-            regs[2] = lwpstatus.pr_reg[R_G3];
-            regs[3] = lwpstatus.pr_reg[R_G4];
-
-            regs[4] = lwpstatus.pr_reg[R_O0];
-            regs[5] = lwpstatus.pr_reg[R_O1];
-            regs[6] = lwpstatus.pr_reg[R_O2];
-            regs[7] = lwpstatus.pr_reg[R_O3];
-            regs[8] = lwpstatus.pr_reg[R_O4];
-            regs[9] = lwpstatus.pr_reg[R_O5];
-            regs[10] = lwpstatus.pr_reg[R_O6];
-            regs[11] = lwpstatus.pr_reg[R_O7];
-#elif defined(amd64)
-            regs[0] = lwpstatus.pr_reg[REG_RAX];
-            regs[1] = lwpstatus.pr_reg[REG_RCX];
-            regs[2] = lwpstatus.pr_reg[REG_RDX];
-            regs[3] = lwpstatus.pr_reg[REG_RBX];
-            regs[4] = lwpstatus.pr_reg[REG_RBP];
-            regs[5] = lwpstatus.pr_reg[REG_RSI];
-            regs[6] = lwpstatus.pr_reg[REG_RDI];
-            regs[7] = lwpstatus.pr_reg[REG_R8];
-            regs[8] = lwpstatus.pr_reg[REG_R9];
-            regs[9] = lwpstatus.pr_reg[REG_R10];
-            regs[10]= lwpstatus.pr_reg[REG_R11];
-            regs[11]= lwpstatus.pr_reg[REG_R12];
-            regs[12]= lwpstatus.pr_reg[REG_R13];
-            regs[13]= lwpstatus.pr_reg[REG_R14];
-            regs[14]= lwpstatus.pr_reg[REG_R15];
-#elif defined(i386)
-            regs[0] = lwpstatus.pr_reg[EAX];
-            regs[1] = lwpstatus.pr_reg[ECX];
-            regs[2] = lwpstatus.pr_reg[EDX];
-            regs[3] = lwpstatus.pr_reg[EBX];
-            regs[4] = lwpstatus.pr_reg[EBP];
-            regs[5] = lwpstatus.pr_reg[ESI];
-            regs[6] = lwpstatus.pr_reg[EDI];
-#endif
-
-            if (tid->onproc != TRUE) {
-                tid->onproc = TRUE;
-                onproct_list[onproct_ix++] = tid;
-            }
-            break;
-        }
-        tid = tid->next;
-    }
-}
 
 static void
 record_thread_regs()
 {
+    void *addr;
+    long sz;
+
     sys_thread_t *tid;
     int i;
+    int sp;
+
+#ifndef __OpenBSD__
+    pthread_attr_t attr;
+    int attr_inited;
+    attr_inited = pthread_attr_init(&attr) == 0;
+#endif
 
     tid = ThreadQueue;
     for (i = 0; i < ActiveThreadCount && tid != 0; i++) {
@@ -466,7 +377,14 @@ record_thread_regs()
 
             if (tid->sys_thread != 0) {
                 /* if thread has already been initialized */
-                tid->sp = __gettsp(tid->sys_thread);
+#if defined(__OpenBSD__) || defined(__APPLE__)
+            if (get_stackinfo(tid->sys_thread, &addr, &sz) == SYS_OK)
+#else
+            if (get_stackinfo(tid->sys_thread, attr, &addr, &sz) == SYS_OK)
+#endif
+                tid->sp = addr;
+            else
+                tid->sp = 0;
             } else {
                 /*
                  * thread is still in the process of being initalized.
@@ -475,192 +393,11 @@ record_thread_regs()
                  */
                 tid->sp = 0;
             }
-
-            /*
-             * Clear out the registers since they are no longer live
-             * and we don't want to garbage collector to think they are.
-             */
-
-            for (i = 0; i < N_TRACED_REGS; i++)
-                tid->regs[i] = 0;
         }
         tid = tid->next;
     }
-}
-
-static void
-wait_stopped_lwps(void)
-{
-    int i, lwpfd;
-    prstatus_t lwpstatus;
-
-    for (i = 0; i < (int) Mystatus.pr_nlwp; i++) {
-        /* if its  not me */
-        if (lwpid_list[i] != _lwp_self()) {
-
-            /* open the lwp and check the status */
-            if ((lwpfd = syscall(SYS_ioctl, procfd, PIOCOPENLWP,
-                &lwpid_list[i])) < 0) {
-#ifdef MY_DEBUG
-                VM_CALL(jio_fprintf)(stderr, "lwpid %d was not found in process\n",
-                            lwpid_list[i]);
+#ifndef __OpenBSD__
+    if (attr_inited)
+        pthread_attr_destroy(&attr);
 #endif
-                continue;
-            }
-            memset(&lwpstatus, 0, sizeof(lwpstatus));
-            while (1) {
-                if (syscall(SYS_ioctl,lwpfd, PIOCSTATUS, &lwpstatus)<0) {
-                    sysAssert(0);
-#ifdef MY_DEBUG
-                    VM_CALL(jio_fprintf)(stderr, "PIOCSTATUS failed for lwp %d",
-                                lwpid_list[i]);
-#endif
-                    break;
-                }
-                if (lwpstatus.pr_flags & PR_STOPPED) {
-                    record_lwp_regs(lwpstatus);
-                    break;
-                }
-                GC_msec_sleep(1);
-            }
-
-            close (lwpfd);
-        } /* end of if-me */
-    } /* end of for */
-}
-
-static void
-suspend_lwps()
-{
-    int i;
-    /* pioopen all the lwps and stop them - except the one I am running on */
-    for (i = 0; i < (int) Mystatus.pr_nlwp; i++) {
-
-        /* open and stop the lwp if its not me */
-        if (lwpid_list[i] != _lwp_self()) {
-
-            /* PIOCSTOP doesn't work without a writable         */
-            /* descriptor.  And that makes the process          */
-            /* undebuggable.                                    */
-            if (_lwp_suspend(lwpid_list[i]) < 0) {
-                        /* Could happen if the lwp exited */
-                lwpid_list[i] = _lwp_self();
-                continue;
-            }
-        }
-    }
-}
-
-static void
-print_lwps()
-{
-#ifdef MY_DEBUG
-    /* print all the lwps in the process */
-    VM_CALL(jio_fprintf)(stdout, "lwpids ");
-    for (i = 0; i < (int) Mystatus.pr_nlwp; i++) {
-        if (i == 0) {
-            VM_CALL(jio_fprintf)(stdout, "%d", lwpid_list[0]);
-        } else if (i != Mystatus.pr_nlwp - 1) {
-            VM_CALL(jio_fprintf)(stdout, ", %d", lwpid_list[i]);
-        } else {
-            VM_CALL(jio_fprintf)(stdout, " and %d", lwpid_list[i]);
-        }
-    }
-#endif
-}
-
-/* routine to iteratively stop all lwps */
-static void
-stop_lwps()
-{
-    int i;
-    sigset_t set;
-    boolean_t changed;
-
-    /* mask all signals */
-    (void) sigfillset(&set);
-    syscall(SYS_sigprocmask, SIG_SETMASK, &set, &gcmask);
-
-    /* run at highest prio so I cannot be preempted */
-    thr_getprio(thr_self(), &gcprio);
-    thr_setprio(thr_self(), 2147483647);  /* #define INT_MAX 2147483647 */
-
-    oldlwpid_list_len = 0;
-
-    while(1) {
-        changed = B_FALSE;
-
-        /* Get the # of lwps in the process */
-        memset(&Mystatus, 0, sizeof(Mystatus));
-        syscall(SYS_ioctl, procfd, PIOCSTATUS, &Mystatus);
-
-#ifdef MY_DEBUG
-        VM_CALL(jio_fprintf)(stdout, "Number of lwps in the process is %d\n",
-                    Mystatus.pr_nlwp);
-        VM_CALL(jio_fprintf)(stdout, "My lwp id is %d\n", _lwp_self());
-#endif
-        lwpid_list_len = Mystatus.pr_nlwp;
-        if (syscall(SYS_ioctl, procfd, PIOCLWPIDS, lwpid_list) == -1) {
-#ifdef MY_DEBUG
-            VM_CALL(jio_fprintf)(stderr, "Can't read proc's lwpid list");
-#endif
-            return;
-        }
-
-        print_lwps();
-
-        /* suspend all the lwps */
-        suspend_lwps();
-
-        /* make sure all the lwps have actually stopped */
-        wait_stopped_lwps();
-
-        /* make sure the list has not changed while you were not looking
-           else start all over again */
-        if (lwpid_list_len != oldlwpid_list_len) changed = B_TRUE;
-        else  {
-            for (i=0; i<lwpid_list_len; ++i) {
-                if (lwpid_list[i] != oldlwpid_list[i]) {
-                    changed = B_TRUE; break;
-                }
-            }
-        }
-        if (!changed) break;
-
-        {
-            id_t *tmplwpid_list = oldlwpid_list;
-            oldlwpid_list = lwpid_list; oldlwpid_list_len = lwpid_list_len;
-            lwpid_list = 0; lwpid_list_len = 0;
-            lwpid_list = tmplwpid_list;
-        }
-    }
-
-    /* record regs for threads that were not on LWPs */
-    record_thread_regs();
-
-    return;
-}
-
-
-/* Restart all lwps in process.  */
-static void
-restart_lwps()
-{
-    int i;
-
-    for (i = 0; i < Mystatus.pr_nlwp; i++) {
-        if (lwpid_list[i] == _lwp_self()) continue;
-        if (_lwp_continue(lwpid_list[i]) < 0) {
-#ifdef MY_DEBUG
-            VM_CALL(jio_fprintf)(stderr, "Failed to restart lwp %d\n",lwpid_list[i]);
-#endif
-        }
-    }
-
-    /* restore the old priority of the thread */
-    thr_setprio(thr_self(), gcprio);
-    /* restore the oldmask */
-    syscall(SYS_sigprocmask, SIG_SETMASK, &gcmask, NULL);
-
-    print_lwps();
 }
diff -upr ../orig/jdk/src/solaris/hpi/native_threads/src/threads_md.c ./jdk/src/solaris/hpi/native_threads/src/threads_md.c
--- ../orig/jdk/src/solaris/hpi/native_threads/src/threads_md.c	2009-01-27 15:45:49.000000000 -0500
+++ ./jdk/src/solaris/hpi/native_threads/src/threads_md.c	2009-05-04 17:37:17.000000000 -0400
@@ -54,6 +54,10 @@ extern int InitializeIO(rlim_t limit);
 #error That can NOT possibly be right.
 #endif
 
+#if defined(_ALLBSD_SOURCE) && !defined(SA_SIGINFO)
+#error That can NOT possibly be right.
+#endif
+
 #ifdef SA_SIGINFO
 static void sigusr1Handler(int sig, siginfo_t *info, void *uc);
 #else
@@ -97,9 +101,14 @@ static thread_key_t tid_key = (thread_ke
 #ifdef __linux__
 thread_key_t intrJmpbufkey;
 static sigset_t squm = {{sigmask(SIGUSR1), 0, 0, 0}};
+#elif defined(__OpenBSD__)
+thread_key_t sigusr1Jmpbufkey;
+sigset_t sigusr1Mask = sigmask(SIGUSR1);
+static sigset_t squm = sigmask(SIGUSR1);
 #else
 thread_key_t sigusr1Jmpbufkey;
 sigset_t sigusr1Mask = {{sigmask(SIGUSR1), 0, 0, 0}};
+static sigset_t squm = {{sigmask(SIGUSR1), 0, 0, 0}};
 #endif
 
 /*
@@ -170,9 +179,6 @@ sysThreadCheckStack()
     }
 }
 
-#ifndef __linux__
-static sigset_t squm = {{sigmask(SIGUSR1), 0, 0, 0}};
-#endif
 
 
 /*
@@ -187,7 +193,7 @@ sysThreadAlloc(sys_thread_t **tidP)
     if (tid == NULL) {
         return SYS_NOMEM;
     }
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     memset((char *)tid, 0, sizeof(sys_thread_t));
 #endif
 
@@ -474,7 +480,7 @@ sysThreadCreate(sys_thread_t **tidP, lon
     }
     *tidP = tid;
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     memset((char *)tid, 0, sizeof(sys_thread_t));
 #endif
     /* Install the backpointer to the Thread object */
@@ -517,6 +523,7 @@ sysThreadCreate(sys_thread_t **tidP, lon
     }
     /* Create the thread. The thread will block waiting to be suspended */
     err = pthread_create(&tid->sys_thread, &attr, _start, (void *)tid);
+    pthread_attr_destroy(&attr);
     sysAssert(err == 0);
     if (err == 0) {
         err = sem_wait(&tid->sem_suspended);
@@ -1049,7 +1056,18 @@ sysGetSysInfo()
          * we want the number of processors configured not the number online
          * since processors may be turned on and off dynamically.
          */
+#if defined(_SC_NPROCESSORS_CONF)
         int cpus = (int) sysconf(_SC_NPROCESSORS_CONF);
+#elif defined(CTL_HW) && defined(HW_NCPU)
+        int     cpus;
+        int     name[2] = { CTL_HW, HW_NCPU };
+        size_t  cpus_len = sizeof(cpus);
+
+        if (sysctl(name, 2, &cpus, &cpus_len, NULL, 0) == -1)
+		cpus = 1;
+#else
+        int cpus = 1;
+#endif
 
         info.isMP = (cpus < 0) ? 1 : (cpus > 1);
         info.name = "native threads";
diff -upr ../orig/jdk/src/solaris/hpi/src/linker_md.c ./jdk/src/solaris/hpi/src/linker_md.c
--- ../orig/jdk/src/solaris/hpi/src/linker_md.c	2009-01-27 15:45:49.000000000 -0500
+++ ./jdk/src/solaris/hpi/src/linker_md.c	2009-05-04 17:37:17.000000000 -0400
@@ -44,11 +44,19 @@
 #include "threads_md.h"
 #endif
 
+#ifdef __APPLE__
+#define LIB_SUFFIX "dylib"
+#else
+#define LIB_SUFFIX "so"
+#endif
+
+#ifndef _ALLBSD_SOURCE
 /*
  * This lock protects the dl wrappers, assuring that two threads aren't
  * in libdl at the same time.
  */
 sys_mon_t _dl_lock;
+#endif
 
 /*
  * glibc-2.0 libdl is not MT safe.  If you are building with any glibc,
@@ -66,6 +74,14 @@ sys_mon_t _dl_lock;
     #define NEED_DL_LOCK
 #endif
 
+#ifdef NEED_DL_LOCK
+/*
+ * This lock protects the dl wrappers, assuring that two threads aren't
+ * in libdl at the same time.
+ */
+sys_mon_t _dl_lock;
+#endif
+
 /*
  * create a string for the JNI native function name by adding the
  * appropriate decorations.
@@ -95,14 +111,14 @@ sysBuildLibName(char *holder, int holder
     }
 
     if (pnamelen == 0) {
-        sprintf(holder, "lib%s.so", fname);
+        sprintf(holder, "lib%s." LIB_SUFFIX, fname);
     } else {
-        sprintf(holder, "%s/lib%s.so", pname, fname);
+        sprintf(holder, "%s/lib%s." LIB_SUFFIX, pname, fname);
     }
 }
 
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     static int thr_main(void)
     {
         return -1;
@@ -120,10 +136,10 @@ sysLoadLibrary(const char *name, char *e
 
 #ifdef NEED_DL_LOCK
     sysMonitorEnter(sysThreadSelf(), &_dl_lock);
-    result = dlopen(name, RTLD_NOW);
+    result = dlopen(name, RTLD_NOW|RTLD_GLOBAL);
     sysMonitorExit(sysThreadSelf(), &_dl_lock);
 #else
-    result = dlopen(name, RTLD_LAZY);
+    result = dlopen(name, RTLD_LAZY|RTLD_GLOBAL);
 #endif
     /*
      * This is a bit of bulletproofing to catch the commonly occurring
diff -upr ../orig/jdk/src/solaris/hpi/src/memory_md.c ./jdk/src/solaris/hpi/src/memory_md.c
--- ../orig/jdk/src/solaris/hpi/src/memory_md.c	2009-01-27 15:45:49.000000000 -0500
+++ ./jdk/src/solaris/hpi/src/memory_md.c	2009-05-04 17:37:17.000000000 -0400
@@ -50,12 +50,24 @@
 #include <stdlib.h>
 #include <stdio.h>      /* For perror() */
 #include <string.h>
+#if defined(_ALLBSD_SOURCE)
+#include <sys/param.h>
+#else
 #include <malloc.h>
+#endif
 
 #include "hpi_impl.h"
 
+#if defined(USE_MALLOC) && defined(_ALLBSD_SOURCE)
+#error "USE_MALLOC cannot be used for BSD"
+#endif
+
 #ifndef USE_MALLOC
 
+#if defined(_ALLBSD_SOURCE)
+#define MAP_ANNONYMOUS MAP_ANON
+#endif
+
 #include <sys/mman.h>
 #include <fcntl.h>
 #ifdef __linux__
@@ -73,6 +85,18 @@ static int devZeroFD;
 #define MAP_FAILED ((caddr_t)-1)
 #endif
 static size_t memGrainSize;     /* A page for Linux */
+#elif defined(_ALLBSD_SOURCE)
+static size_t memGrainSize;	/* A page for FreeBSD */
+#if defined(__FreeBSD__) && (__FreeBSD_version >= 700013)
+static inline void *
+memalign(size_t alignment, size_t size)
+{
+    void *ret;
+    return posix_memalign(&ret, alignment, size) ? NULL : ret;
+}
+#else /* ! __FreeBSD_version >= 700013 */
+#define memalign(a, b)	valloc(b)
+#endif
 #else
 static unsigned int memGrainSize;       /* A page for Solaris */
 #endif
@@ -154,7 +178,7 @@ mapChunk(long length)
 {
     char *ret;
 
-#if defined(__linux__) && defined(MAP_ANONYMOUS)
+#if (defined(__linux__) || defined(_ALLBSD_SOURCE)) && defined(MAP_ANONYMOUS)
      ret = (char *) mmap(0, length, PROT_ALL,
                          MAP_NORESERVE | MAP_PRIVATE | MAP_ANONYMOUS,
                          -1, (off_t) 0);
@@ -176,7 +200,7 @@ static char *
 mapChunkReserve(char *addr, long length)
 {
     char *ret;
-#if defined(__linux__) && defined(MAP_ANONYMOUS)
+#if (defined(__linux__) || defined(_ALLBSD_SOURCE)) && defined(MAP_ANONYMOUS)
      ret = (char *) mmap(addr, length, PROT_ALL,
                          MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS,
                          -1, (off_t) 0);
@@ -199,7 +223,7 @@ mapChunkNoreserve(char *addr, long lengt
 {
     char *ret;
 
-#if defined(__linux__) && defined(MAP_ANONYMOUS)
+#if (defined(__linux__) || defined(_ALLBSD_SOURCE)) && defined(MAP_ANONYMOUS)
      ret = (char *) mmap(addr, length, PROT_ALL,
                        MAP_FIXED | MAP_PRIVATE |
                          MAP_NORESERVE | MAP_ANONYMOUS,
@@ -242,7 +266,7 @@ sysMapMem(size_t requestedSize, size_t *
     *mappedSize = roundUpToGrain(requestedSize);
 #ifdef USE_MALLOC
     mappedAddr = (void *) sysMalloc(*mappedSize); /* Returns 0 on failure */
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
      if (mappedAddr) {
        memset(mappedAddr, 0, *mappedSize);
        mappedAddr = (void *) roundUpToGrain(mappedAddr);
@@ -331,7 +355,7 @@ sysCommitMem(void *requestedAddr, size_t
     *committedSize = roundUpToGrain(requestedSize);
     committedAddr = (void *) roundDownToGrain((long) requestedAddr);
 #ifdef USE_MALLOC
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     ret = committedAddr;
 #else
     ret = requestedAddr;
diff -upr ../orig/jdk/src/solaris/hpi/src/system_md.c ./jdk/src/solaris/hpi/src/system_md.c
--- ../orig/jdk/src/solaris/hpi/src/system_md.c	2009-01-27 15:45:49.000000000 -0500
+++ ./jdk/src/solaris/hpi/src/system_md.c	2009-05-04 17:37:17.000000000 -0400
@@ -41,6 +41,7 @@
 #include <dlfcn.h>
 
 #include "jni_md.h"
+#include "jvm_md.h"
 #include "mutex_md.h"
 
 #include "hpi_init.h"
@@ -50,9 +51,6 @@
 #include "monitor_md.h"
 #include "largefile.h"
 
-
-#define O_DELETE 0x10000
-
 int sysThreadBootstrap(sys_thread_t **tidP, sys_mon_t **lockP, int nb)
 {
     threadBootstrapMD(tidP, lockP, nb);
@@ -85,7 +83,7 @@ sysGetMilliTicks()
 {
     struct timeval tv;
 
-    (void) gettimeofday(&tv, (void *) 0);
+    (void) gettimeofday(&tv, NULL);
     return((tv.tv_sec * 1000) + (tv.tv_usec / 1000));
 }
 
@@ -93,7 +91,7 @@ jlong
 sysTimeMillis()
 {
     struct timeval t;
-    gettimeofday(&t, 0);
+    gettimeofday(&t, NULL);
     return ((jlong)t.tv_sec) * 1000 + (jlong)(t.tv_usec/1000);
 }
 
@@ -122,13 +120,13 @@ sysGetLastErrorString(char *buf, int len
 
 /*
  * Open a file. Unlink the file immediately after open returns
- * if the specified oflag has the O_DELETE flag set.
+ * if the specified oflag has the JVM_O_DELETE flag set.
  */
 int sysOpen(const char *path, int oflag, int mode)
 {
     int fd;
-    int delete = (oflag & O_DELETE);
-    oflag = oflag & ~O_DELETE;
+    int delete = (oflag & JVM_O_DELETE);
+    oflag = oflag & ~JVM_O_DELETE;
     fd = open64_w(path, oflag, mode);
     if (delete != 0) {
         unlink(path);
diff -upr ../orig/jdk/src/solaris/instrument/EncodingSupport_md.c ./jdk/src/solaris/instrument/EncodingSupport_md.c
--- ../orig/jdk/src/solaris/instrument/EncodingSupport_md.c	2009-01-27 15:45:49.000000000 -0500
+++ ./jdk/src/solaris/instrument/EncodingSupport_md.c	2009-05-04 17:37:17.000000000 -0400
@@ -28,7 +28,10 @@
 #include <string.h>
 #include <ctype.h>
 #include <locale.h>
+#ifndef __OpenBSD__
+#define HAVE_NL_LANGINFO
 #include <langinfo.h>
+#endif
 #include <iconv.h>
 
 /* Routines to convert back and forth between Platform Encoding and UTF-8 */
@@ -63,6 +66,7 @@ utfInitialize(void)
     /* Set the locale from the environment */
     (void)setlocale(LC_ALL, "");
 
+#ifdef HAVE_NL_LANGINFO
     /* Get the codeset name */
     codeset = (char*)nl_langinfo(CODESET);
     if ( codeset == NULL || codeset[0] == 0 ) {
@@ -77,6 +81,9 @@ utfInitialize(void)
         UTF_DEBUG(("NO iconv() being used because it is not needed\n"));
         return;
     }
+#else
+    codeset = "ISO-8859-1";
+#endif
 
     /* Open conversion descriptors */
     iconvToPlatform   = iconv_open(codeset, "UTF-8");
diff -upr ../orig/jdk/src/solaris/javavm/export/jvm_md.h ./jdk/src/solaris/javavm/export/jvm_md.h
--- ../orig/jdk/src/solaris/javavm/export/jvm_md.h	2009-01-27 15:45:49.000000000 -0500
+++ ./jdk/src/solaris/javavm/export/jvm_md.h	2009-05-04 17:37:17.000000000 -0400
@@ -39,7 +39,14 @@
 #define JNI_ONUNLOAD_SYMBOLS {"JNI_OnUnload"}
 
 #define JNI_LIB_PREFIX "lib"
+#ifdef __APPLE__
+#define JNI_LIB_SUFFIX ".dylib"
+#define VERSIONED_JNI_LIB_NAME(NAME, VERSION) JNI_LIB_PREFIX NAME "." VERSION JNI_LIB_SUFFIX
+#else
 #define JNI_LIB_SUFFIX ".so"
+#define VERSIONED_JNI_LIB_NAME(NAME, VERSION) JNI_LIB_PREFIX NAME JNI_LIB_SUFFIX "." VERSION
+#endif
+#define JNI_LIB_NAME(NAME) JNI_LIB_PREFIX NAME JNI_LIB_SUFFIX
 
 #define JVM_MAXPATHLEN MAXPATHLEN
 
@@ -66,7 +73,7 @@
 #define JVM_O_O_APPEND   O_APPEND
 #define JVM_O_EXCL       O_EXCL
 #define JVM_O_CREAT      O_CREAT
-#define JVM_O_DELETE     0x10000
+#define JVM_O_DELETE     0x10000000
 
 /* Signals */
 
diff -upr ../orig/jdk/src/solaris/native/com/sun/management/UnixOperatingSystem_md.c ./jdk/src/solaris/native/com/sun/management/UnixOperatingSystem_md.c
--- ../orig/jdk/src/solaris/native/com/sun/management/UnixOperatingSystem_md.c	2009-01-27 15:45:49.000000000 -0500
+++ ./jdk/src/solaris/native/com/sun/management/UnixOperatingSystem_md.c	2009-05-04 17:37:17.000000000 -0400
@@ -32,10 +32,16 @@
 
 #include <sys/types.h>
 #include <sys/stat.h>
+#if defined(_ALLBSD_SOURCE)
+#include <sys/sysctl.h>
+#else
 #include <sys/swap.h>
+#endif
 #include <sys/resource.h>
 #include <sys/times.h>
+#ifndef _ALLBSD_SOURCE
 #include <sys/sysinfo.h>
+#endif
 #include <ctype.h>
 #include <dirent.h>
 #include <errno.h>
@@ -46,16 +52,22 @@
 
 static jlong page_size = 0;
 
+#if defined(_ALLBSD_SOURCE)
+#define MB	(1024UL * 1024UL)
+#else
+
 /* This gets us the new structured proc interfaces of 5.6 & later */
 /* - see comment in <sys/procfs.h> */
 #define _STRUCTURED_PROC 1
 #include <sys/procfs.h>
 
+#endif /* _ALLBSD_SOURCE */
+
 static struct dirent* read_dir(DIR* dirp, struct dirent* entry) {
 #ifdef __solaris__
     struct dirent* dbuf = readdir(dirp);
     return dbuf;
-#else /* __linux__ */
+#else /* __linux__ || _ALLBSD_SOURCE */
     struct dirent* p;
     if (readdir_r(dirp, entry, &p) == 0) {
         return p;
@@ -124,7 +136,7 @@ static jlong get_total_or_available_swap
     free(strtab);
     return available ? ((jlong)avail * page_size) :
                        ((jlong)total * page_size);
-#else /* __linux__ */
+#elif defined(__linux__)
     int ret;
     FILE *fp;
     jlong total = 0, avail = 0;
@@ -138,6 +150,13 @@ static jlong get_total_or_available_swap
     avail = (jlong)si.freeswap * si.mem_unit;
 
     return available ? avail : total;
+#else /* _ALLBSD_SOURCE */
+    /*
+     * XXXBSD: there's no way available to get swap info in
+     *         FreeBSD.  Usage of libkvm is not an option here
+     */
+    // throw_internal_error(env, "Unimplemented in FreeBSD");
+    return (0);
 #endif
 }
 
@@ -179,7 +198,7 @@ Java_com_sun_management_UnixOperatingSys
 
     JVM_Close(fd);
     return (jlong) psinfo.pr_size * 1024;
-#else /* __linux__ */
+#elif defined(__linux__)
     FILE *fp;
     unsigned long vsize = 0;
 
@@ -197,6 +216,12 @@ Java_com_sun_management_UnixOperatingSys
 
     fclose(fp);
     return (jlong)vsize;
+#else /* _ALLBSD_SOURCE */
+    /*
+     * XXXBSD: there's no way available to do it in FreeBSD, AFAIK.
+     */
+    // throw_internal_error(env, "Unimplemented in FreeBSD");
+    return (64 * MB);
 #endif
 }
 
@@ -222,9 +247,13 @@ Java_com_sun_management_UnixOperatingSys
     jlong cpu_time_ns;
     struct tms time;
 
-#ifdef __solaris__
+    /*
+     * BSDNOTE: FreeBSD implements _SC_CLK_TCK since FreeBSD 5, so
+     *          add a magic to handle it
+     */
+#if defined(__solaris__) || defined(_SC_CLK_TCK)
     clk_tck = (jlong) sysconf(_SC_CLK_TCK);
-#else /* __linux__ */
+#elif defined(__linux__) || defined(_ALLBSD_SOURCE)
     clk_tck = 100;
 #endif
     if (clk_tck == -1) {
@@ -244,22 +273,51 @@ JNIEXPORT jlong JNICALL
 Java_com_sun_management_UnixOperatingSystem_getFreePhysicalMemorySize
   (JNIEnv *env, jobject mbean)
 {
+#ifdef _ALLBSD_SOURCE
+    /*
+     * XXXBSD: there's no way available to do it in FreeBSD, AFAIK.
+     */
+    // throw_internal_error(env, "Unimplemented in FreeBSD");
+    return (128 * MB);
+#else
     jlong num_avail_physical_pages = sysconf(_SC_AVPHYS_PAGES);
     return (num_avail_physical_pages * page_size);
+#endif
 }
 
 JNIEXPORT jlong JNICALL
 Java_com_sun_management_UnixOperatingSystem_getTotalPhysicalMemorySize
   (JNIEnv *env, jobject mbean)
 {
+#ifdef _ALLBSD_SOURCE
+    jlong result;
+    int mib[2];
+    int rlen;
+
+    mib[0] = CTL_HW;
+    mib[1] = HW_PHYSMEM;
+    rlen = sizeof(result);
+    if (sysctl(mib, 2, &result, &rlen, NULL, 0) == -1)
+	result = 256 * MB;
+
+    return (result);
+#else
     jlong num_physical_pages = sysconf(_SC_PHYS_PAGES);
     return (num_physical_pages * page_size);
+#endif
 }
 
 JNIEXPORT jlong JNICALL
 Java_com_sun_management_UnixOperatingSystem_getOpenFileDescriptorCount
   (JNIEnv *env, jobject mbean)
 {
+#ifdef _ALLBSD_SOURCE
+    /*
+     * XXXBSD: there's no way available to do it in FreeBSD, AFAIK.
+     */
+    // throw_internal_error(env, "Unimplemented in FreeBSD");
+    return (100);
+#else /* solaris/linux */
     DIR *dirp;
     struct dirent dbuf;
     struct dirent* dentp;
@@ -282,6 +340,7 @@ Java_com_sun_management_UnixOperatingSys
     closedir(dirp);
     // subtract by 1 which was the fd open for this implementation
     return (fds - 1);
+#endif
 }
 
 JNIEXPORT jlong JNICALL
diff -upr ../orig/jdk/src/solaris/native/java/io/UnixFileSystem_md.c ./jdk/src/solaris/native/java/io/UnixFileSystem_md.c
--- ../orig/jdk/src/solaris/native/java/io/UnixFileSystem_md.c	2009-01-27 15:45:50.000000000 -0500
+++ ./jdk/src/solaris/native/java/io/UnixFileSystem_md.c	2009-05-06 10:46:09.000000000 -0400
@@ -41,6 +41,11 @@
 #include "java_io_FileSystem.h"
 #include "java_io_UnixFileSystem.h"
 
+#if defined(_ALLBSD_SOURCE)
+#define dirent64 dirent
+#define readdir64_r readdir_r
+#define stat64 stat
+#endif
 
 /* -- Field IDs -- */
 
@@ -58,7 +63,7 @@ Java_java_io_UnixFileSystem_initIDs(JNIE
                                   "path", "Ljava/lang/String;");
 }
 
-
+#ifndef _ALLBSD_SOURCE
 /* -- Large-file support -- */
 
 /* LINUX_FIXME: ifdef __solaris__ here is wrong.  We need to move the
@@ -98,6 +103,7 @@ struct  stat64 {
 };
 
 #endif  /* !_LFS_LARGEFILE */
+#endif /* !_ALLBSD_SOURCE */
 
 typedef int (*STAT64)(const char *, struct stat64 *);
 
@@ -107,6 +113,7 @@ static STAT64 stat64_ptr = &stat64;
 static STAT64 stat64_ptr = NULL;
 #endif
 
+#ifndef _ALLBSD_SOURCE
 #ifndef __linux__
 #ifdef __GNUC__
 static void init64IO(void) __attribute__((constructor));
@@ -120,7 +127,7 @@ static void init64IO(void) {
     stat64_ptr = (STAT64) dlsym(handle, "_stat64");
     dlclose(handle);
 }
-
+#endif /* !_ALLBSD_SOURCE */
 
 /* -- Path operations -- */
 
@@ -483,7 +490,7 @@ Java_java_io_UnixFileSystem_setLastModif
 #endif
 
         /* Preserve access time */
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
         struct stat sb;
 
         if (stat(path, &sb) == 0) {
diff -upr ../orig/jdk/src/solaris/native/java/io/canonicalize_md.c ./jdk/src/solaris/native/java/io/canonicalize_md.c
--- ../orig/jdk/src/solaris/native/java/io/canonicalize_md.c	2009-01-27 15:45:50.000000000 -0500
+++ ./jdk/src/solaris/native/java/io/canonicalize_md.c	2009-05-04 17:37:17.000000000 -0400
@@ -33,7 +33,9 @@
 #include <sys/stat.h>
 #include <errno.h>
 #include <limits.h>
+#if !defined(_ALLBSD_SOURCE)
 #include <alloca.h>
+#endif
 
 
 /* Note: The comments in this file use the terminology
diff -upr ../orig/jdk/src/solaris/native/java/io/io_util_md.c ./jdk/src/solaris/native/java/io/io_util_md.c
--- ../orig/jdk/src/solaris/native/java/io/io_util_md.c	2009-01-27 15:45:50.000000000 -0500
+++ ./jdk/src/solaris/native/java/io/io_util_md.c	2009-05-04 17:37:17.000000000 -0400
@@ -36,7 +36,7 @@ fileOpen(JNIEnv *env, jobject this, jstr
     WITH_PLATFORM_STRING(env, path, ps) {
         FD fd;
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
         /* Remove trailing slashes, since the kernel won't */
         char *p = (char *)ps + strlen(ps) - 1;
         while ((p > ps) && (*p == '/'))
diff -upr ../orig/jdk/src/solaris/native/java/lang/ProcessEnvironment_md.c ./jdk/src/solaris/native/java/lang/ProcessEnvironment_md.c
--- ../orig/jdk/src/solaris/native/java/lang/ProcessEnvironment_md.c	2009-01-27 15:45:50.000000000 -0500
+++ ./jdk/src/solaris/native/java/lang/ProcessEnvironment_md.c	2009-05-04 17:37:17.000000000 -0400
@@ -28,6 +28,11 @@
 #include "jni.h"
 #include "jni_util.h"
 
+#ifdef __APPLE__
+#include <crt_externs.h>
+#define environ (*_NSGetEnviron())
+#endif
+
 JNIEXPORT jobjectArray JNICALL
 Java_java_lang_ProcessEnvironment_environ(JNIEnv *env, jclass ign)
 {
@@ -37,7 +42,9 @@ Java_java_lang_ProcessEnvironment_enviro
      * no standard (not even de-facto) header file where the
      * declaration is to be found.  See:
      * http://www.opengroup.org/onlinepubs/007908799/xbd/envvar.html */
+#ifndef __APPLE__
     extern char ** environ; /* environ[i] looks like: VAR=VALUE\0 */
+#endif
 
     jsize count = 0;
     jsize i, j;
@@ -46,7 +53,7 @@ Java_java_lang_ProcessEnvironment_enviro
 
     for (i = 0; environ[i]; i++) {
         /* Ignore corrupted environment variables */
-        if (strchr(environ[i], '=') != NULL)
+        if (strchr(environ[i], '=') != NULL && *environ[i] != '=')
             count++;
     }
 
@@ -56,7 +63,7 @@ Java_java_lang_ProcessEnvironment_enviro
     for (i = 0, j = 0; environ[i]; i++) {
         const char * varEnd = strchr(environ[i], '=');
         /* Ignore corrupted environment variables */
-        if (varEnd != NULL) {
+        if (varEnd != NULL && varEnd != environ[i]) {
             jbyteArray var, val;
             const char * valBeg = varEnd + 1;
             jsize varLength = varEnd - environ[i];
diff -upr ../orig/jdk/src/solaris/native/java/lang/UNIXProcess_md.c ./jdk/src/solaris/native/java/lang/UNIXProcess_md.c
--- ../orig/jdk/src/solaris/native/java/lang/UNIXProcess_md.c	2009-01-27 15:45:50.000000000 -0500
+++ ./jdk/src/solaris/native/java/lang/UNIXProcess_md.c	2009-05-04 17:37:17.000000000 -0400
@@ -40,7 +40,11 @@
 #include <stdlib.h>
 #include <sys/types.h>
 #include <ctype.h>
+#ifdef _ALLBSD_SOURCE
+#include <sys/wait.h>
+#else
 #include <wait.h>
+#endif
 #include <signal.h>
 #include <string.h>
 #include <errno.h>
@@ -49,6 +53,17 @@
 #include <fcntl.h>
 #include <limits.h>
 
+#ifdef __FreeBSD__
+#include <dlfcn.h>
+#include <pthread.h>
+#include <pthread_np.h>
+#endif
+
+#ifdef __APPLE__
+#include <crt_externs.h>
+#define environ (*_NSGetEnviron())
+#endif
+
 #ifndef STDIN_FILENO
 #define STDIN_FILENO 0
 #endif
@@ -259,11 +274,89 @@ Java_java_lang_UNIXProcess_waitForProces
     }
 }
 
+#if defined(__FreeBSD__)
+
+extern pid_t   __sys_fork(void);
+
+static pid_t
+jdk_fork_wrapper()
+{
+    pid_t resultPid;
+    typedef void (*void_func)();
+    static void_func func_defer = NULL;
+    static void_func func_undefer = NULL;
+    static int is_libc_r = -1;
+
+    if (is_libc_r == -1) {
+
+	/*
+         * BSDNOTE: Check for loaded symbols.
+         *
+         * If "_thread_kern_sig_defer" symbol is found assume we are
+	 * libc_r
+         *
+         * If libc_r is loaded, use fork system call drectly to avoid
+         * problems with using protected pages. 
+         *
+         * --phantom
+	 */
+	func_defer =
+		(void_func)dlsym(RTLD_DEFAULT, "_thread_kern_sig_defer");
+	func_undefer =
+		(void_func)dlsym(RTLD_DEFAULT, "_thread_kern_sig_undefer");
+	if (func_defer != NULL)
+	    is_libc_r = 1;
+	else {
+	    is_libc_r = 0;
+	}
+    }
+
+    if (is_libc_r == 0) {
+	/* Not a libc_r */
+	resultPid = fork();
+    } else {
+        (*func_defer)();		/* call _thread_kern_sig_defer() */
+        resultPid = __sys_fork();
+        if (resultPid != 0)
+ 	    (*func_undefer)();		/* call _thread_kern_sig_undefer() */
+	/* leave child with signals disabled, but reenable in parent */
+    }
+
+    return resultPid;
+}
+#endif /* __FreeBSD__ */
+
+#if defined(__OpenBSD__)
+/*
+ * Directly call _thread_sys_closefrom() so the child process
+ * doesn't reset the parrent's file descriptors to be blocking.
+ * This function is only called from the child process which
+ * is single threaded and about to call execvp() so it is
+ * safe to bypass the threaded closefrom().
+ */
+int _thread_sys_closefrom(int);
+
+static int
+closeDescriptors(void)
+{
+    return _thread_sys_closefrom(FAIL_FILENO + 1);
+}
+
+#else
+
+#ifdef _ALLBSD_SOURCE                                                          
+#define FD_DIR "/dev/fd"
+#else
+#define dirent dirent64                                                        
+#define readdir readdir64                                                      
+#define FD_DIR "/proc/self/fd"
+#endif
+
 static int
 closeDescriptors(void)
 {
     DIR *dp;
-    struct dirent64 *dirp;
+    struct dirent *dirp;
     int from_fd = FAIL_FILENO + 1;
 
     /* We're trying to close all file descriptors, but opendir() might
@@ -276,13 +369,13 @@ closeDescriptors(void)
     close(from_fd);             /* for possible use by opendir() */
     close(from_fd + 1);         /* another one for good luck */
 
-    if ((dp = opendir("/proc/self/fd")) == NULL)
+    if ((dp = opendir(FD_DIR)) == NULL)
         return 0;
 
     /* We use readdir64 instead of readdir to work around Solaris bug
      * 6395699: /proc/self/fd fails to report file descriptors >= 1024 on Solaris 9
      */
-    while ((dirp = readdir64(dp)) != NULL) {
+    while ((dirp = readdir(dp)) != NULL) {
         int fd;
         if (isdigit(dirp->d_name[0]) &&
             (fd = strtol(dirp->d_name, NULL, 10)) >= from_fd + 2)
@@ -293,6 +386,7 @@ closeDescriptors(void)
 
     return 1;
 }
+#endif /* !__OpenBSD__ */
 
 static void
 moveDescriptor(int fd_from, int fd_to)
@@ -438,7 +532,9 @@ execvpe(const char *file, const char *co
      * "All identifiers in this volume of IEEE Std 1003.1-2001, except
      * environ, are defined in at least one of the headers" (!)
      */
+#ifndef __APPLE__
     extern char **environ;
+#endif
 
     if (envp != NULL)
         environ = (char **) envp;
@@ -502,10 +598,15 @@ readFully(int fd, void *buf, size_t nbyt
     }
 }
 
+#if defined(__FreeBSD__)
+#undef fork1
+#define fork1() jdk_fork_wrapper()
+#else
 #ifndef __solaris__
 #undef fork1
 #define fork1() fork()
 #endif
+#endif
 
 JNIEXPORT jint JNICALL
 Java_java_lang_UNIXProcess_forkAndExec(JNIEnv *env,
@@ -567,6 +668,30 @@ Java_java_lang_UNIXProcess_forkAndExec(J
     if (resultPid == 0) {
         /* Child process */
 
+
+#ifdef __OpenBSD__
+// XXXBSD: Work-around userland pthread implementation issue.
+// Closing file descriptors will reset them to be blocking.
+// This is problematic for the parent when it attemts to use
+// the blocking fd and deadlocks. Setting them to non-blocking
+// in the child prevents the close/dup2 from resetting them.
+    {
+ int flags;
+ flags = fcntl(STDIN_FILENO, F_GETFL, NULL);
+ if (flags != -1)
+     fcntl(STDIN_FILENO, F_SETFL, flags | O_NONBLOCK);
+
+ flags = fcntl(STDOUT_FILENO, F_GETFL, NULL);
+ if (flags != -1)
+     fcntl(STDOUT_FILENO, F_SETFL, flags | O_NONBLOCK);
+
+ flags = fcntl(STDERR_FILENO, F_GETFL, NULL);
+ if (flags != -1)
+     fcntl(STDOUT_FILENO, F_SETFL, flags | O_NONBLOCK);
+    }
+#endif
+
+
         /* Close the parent sides of the pipe.
            Give the child sides of the pipes the right fileno's.
            Closing pipe fds here is redundant, since closeDescriptors()
diff -upr ../orig/jdk/src/solaris/native/java/lang/java_props_md.c ./jdk/src/solaris/native/java/lang/java_props_md.c
--- ../orig/jdk/src/solaris/native/java/lang/java_props_md.c	2009-01-27 15:45:50.000000000 -0500
+++ ./jdk/src/solaris/native/java/lang/java_props_md.c	2009-05-04 17:37:17.000000000 -0400
@@ -23,7 +23,7 @@
  * have any questions.
  */
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <stdio.h>
 #include <ctype.h>
 #endif
@@ -42,9 +42,17 @@
 #include <time.h>
 #include <errno.h>
 
+#if defined(_ALLBSD_SOURCE)
+#if !defined(P_tmpdir)
+#include <paths.h>
+#define P_tmpdir _PATH_VARTMP
+#endif
+#endif
+
 #include "locale_str.h"
 #include "java_props.h"
 
+#if !defined(_ALLBSD_SOURCE)
 #ifdef __linux__
 #define CODESET _NL_CTYPE_CODESET_NAME
 #else
@@ -52,6 +60,7 @@
 #define CODESET ALT_CODESET_KEY
 #endif
 #endif
+#endif /* !_ALLBSD_SOURCE */
 
 /* Take an array of string pairs (map of key->value) and a string (key).
  * Examine each pair in the map to see if the first string (key) matches the
@@ -188,7 +197,12 @@ GetJavaProperties(JNIEnv *env)
     {
         char *lc;
         lc = setlocale(LC_CTYPE, "");
-#ifndef __linux__
+#if defined(_ALLBSD_SOURCE)
+	if (lc == NULL) {
+	    lc = "C";
+	}
+	{
+#elif !defined(__linux__)
         if (lc == NULL) {
             /*
              * 'lc == null' means system doesn't support user's environment
@@ -219,7 +233,7 @@ GetJavaProperties(JNIEnv *env)
             char *p, encoding_variant[64];
             int i, found;
 
-#ifndef __linux__
+#if !defined(__linux__) && !defined(_ALLBSD_SOURCE)
             /*
              * Workaround for Solaris bug 4201684: Xlib doesn't like @euro
              * locales. Since we don't depend on the libc @euro behavior,
@@ -236,6 +250,13 @@ GetJavaProperties(JNIEnv *env)
                 *p = '\0';
             setlocale(LC_ALL, temp);
 #endif
+	    if (lc == NULL) {
+		strncpy(temp, "C", sizeof(temp)-1);
+		temp[sizeof(temp)-1] = '\0';
+	    } else {
+		strncpy(temp, lc, sizeof(temp)-1);
+		temp[sizeof(temp)-1] = '\0';
+	    }
 
             strcpy(temp, lc);
 
@@ -316,6 +337,9 @@ GetJavaProperties(JNIEnv *env)
             else
                 p = nl_langinfo(CODESET);
 
+	    if (p == NULL || !strcmp(p, "C") || !strcmp(p, "US-ASCII"))
+		p = ""; // use default
+
             /* Convert the bare "646" used on Solaris to a proper IANA name */
             if (strcmp(p, "646") == 0)
                 p = "ISO646-US";
@@ -325,6 +349,7 @@ GetJavaProperties(JNIEnv *env)
             std_encoding = (*p != '\0') ? p : "ISO8859-1";
 
 
+#if !defined(_ALLBSD_SOURCE)
 #ifdef __linux__
             /*
              * Remap the encoding string to a different value for japanese
@@ -355,11 +380,19 @@ GetJavaProperties(JNIEnv *env)
                     std_encoding = "Big5_Solaris";
             }
 #endif
+#endif /* !_ALLBSD_SOURCE */
             sprops.encoding = std_encoding;
             sprops.sun_jnu_encoding = sprops.encoding;
         }
     }
 
+#ifdef _ALLBSD_SOURCE
+#if BYTE_ORDER == _LITTLE_ENDIAN
+     sprops.unicode_encoding = "UnicodeLittle";
+ #else
+     sprops.unicode_encoding = "UnicodeBig";
+ #endif
+#else /* !_ALLBSD_SOURCE */
 #ifdef __linux__
 #if __BYTE_ORDER == __LITTLE_ENDIAN
     sprops.unicode_encoding = "UnicodeLittle";
@@ -369,6 +402,7 @@ GetJavaProperties(JNIEnv *env)
 #else
     sprops.unicode_encoding = "UnicodeBig";
 #endif
+#endif /* _ALLBSD_SOURCE */
 
     /* user properties */
     {
@@ -405,12 +439,14 @@ GetJavaProperties(JNIEnv *env)
     sprops.path_separator = ":";
     sprops.line_separator = "\n";
 
+#if !defined(_ALLBSD_SOURCE)
     /* Append CDE message and resource search path to NLSPATH and
      * XFILESEARCHPATH, in order to pick localized message for
      * FileSelectionDialog window (Bug 4173641).
      */
     setPathEnvironment("NLSPATH=/usr/dt/lib/nls/msg/%L/%N.cat");
     setPathEnvironment("XFILESEARCHPATH=/usr/dt/app-defaults/%L/Dt");
+#endif
 
     return &sprops;
 }
diff -upr ../orig/jdk/src/solaris/native/java/net/Inet4AddressImpl.c ./jdk/src/solaris/native/java/net/Inet4AddressImpl.c
--- ../orig/jdk/src/solaris/native/java/net/Inet4AddressImpl.c	2009-01-27 15:45:50.000000000 -0500
+++ ./jdk/src/solaris/native/java/net/Inet4AddressImpl.c	2009-05-04 17:37:17.000000000 -0400
@@ -35,17 +35,293 @@
 #include <stdlib.h>
 #include <ctype.h>
 
+#ifdef _ALLBSD_SOURCE
+#include <unistd.h>
+#include <sys/param.h>
+#endif
+
 #include "jvm.h"
 #include "jni_util.h"
 #include "net_util.h"
 
 #include "java_net_Inet4AddressImpl.h"
 
+#if defined(__GLIBC__) || (defined(__FreeBSD__) && (__FreeBSD_version >= 601104))
+#define HAS_GLIBC_GETHOSTBY_R	1
+#endif
+
+#if defined(_ALLBSD_SOURCE) && !defined(HAS_GLIBC_GETHOSTBY_R)
+/* Use getaddrinfo(3), which is thread safe */
+/************************************************************************
+ * Inet4AddressImpl
+ */
+
+/*
+ * Class:     java_net_Inet4AddressImpl
+ * Method:    getLocalHostName
+ * Signature: ()Ljava/lang/String;
+ */
+JNIEXPORT jstring JNICALL
+Java_java_net_Inet4AddressImpl_getLocalHostName(JNIEnv *env, jobject this) {
+    char hostname[NI_MAXHOST+1];
+
+    hostname[0] = '\0';
+    if (JVM_GetHostName(hostname, NI_MAXHOST)) {
+	/* Something went wrong, maybe networking is not setup? */
+	strcpy(hostname, "localhost");
+    } else {
+	 struct addrinfo  hints, *res;
+	 int error;
+
+	 memset(&hints, 0, sizeof(hints));
+	 hints.ai_flags = AI_CANONNAME;
+	 hints.ai_family = AF_UNSPEC;
+
+	 error = getaddrinfo(hostname, NULL, &hints, &res);
+
+	 if (error == 0) {
+	     /* host is known to name service */
+	     error = getnameinfo(res->ai_addr,
+				 res->ai_addrlen,
+				 hostname,
+				 NI_MAXHOST,
+				 NULL,
+				 0,
+				 NI_NAMEREQD);
+
+	     /* if getnameinfo fails hostname is still the value
+	        from gethostname */
+
+	     freeaddrinfo(res);
+	}
+    }
+    return (*env)->NewStringUTF(env, hostname);
+}
+
+static jclass ni_iacls;
+static jclass ni_ia4cls;
+static jmethodID ni_ia4ctrID;
+static jfieldID ni_iaaddressID;
+static jfieldID ni_iahostID;
+static jfieldID ni_iafamilyID;
+static int initialized = 0;
+
+/*
+ * Find an internet address for a given hostname.  Note that this
+ * code only works for addresses of type INET. The translation
+ * of %d.%d.%d.%d to an address (int) occurs in java now, so the
+ * String "host" shouldn't *ever* be a %d.%d.%d.%d string
+ *
+ * Class:     java_net_Inet4AddressImpl
+ * Method:    lookupAllHostAddr
+ * Signature: (Ljava/lang/String;)[[B
+ */
+
+JNIEXPORT jobjectArray JNICALL
+Java_java_net_Inet4AddressImpl_lookupAllHostAddr(JNIEnv *env, jobject this,
+						jstring host) {
+    const char *hostname;
+    jobject name;
+    jobjectArray ret = 0;
+    int retLen = 0;
+
+    int error=0;
+    struct addrinfo hints, *res, *resNew = NULL;
+
+    if (!initialized) {
+      ni_iacls = (*env)->FindClass(env, "java/net/InetAddress");
+      ni_iacls = (*env)->NewGlobalRef(env, ni_iacls);
+      ni_ia4cls = (*env)->FindClass(env, "java/net/Inet4Address");
+      ni_ia4cls = (*env)->NewGlobalRef(env, ni_ia4cls);
+      ni_ia4ctrID = (*env)->GetMethodID(env, ni_ia4cls, "<init>", "()V");
+      ni_iaaddressID = (*env)->GetFieldID(env, ni_iacls, "address", "I");
+      ni_iafamilyID = (*env)->GetFieldID(env, ni_iacls, "family", "I");
+      ni_iahostID = (*env)->GetFieldID(env, ni_iacls, "hostName", "Ljava/lang/String;");
+      initialized = 1;
+    }
+
+    if (IS_NULL(host)) {
+	JNU_ThrowNullPointerException(env, "host is null");
+	return 0;
+    }
+    hostname = JNU_GetStringPlatformChars(env, host, JNI_FALSE);
+    CHECK_NULL_RETURN(hostname, NULL);
+
+    memset(&hints, 0, sizeof(hints));
+    hints.ai_flags = AI_CANONNAME;
+    hints.ai_family = AF_INET;
+
+    /*
+     * Workaround for Solaris bug 4160367 - if a hostname contains a
+     * white space then 0.0.0.0 is returned
+     */
+    if (isspace(hostname[0])) {
+	JNU_ThrowByName(env, JNU_JAVANETPKG "UnknownHostException",
+			(char *)hostname);
+	JNU_ReleaseStringPlatformChars(env, host, hostname);
+	return NULL;
+    }
+	
+    error = getaddrinfo(hostname, NULL, &hints, &res);
+	
+    if (error) {
+	/* report error */
+	JNU_ThrowByName(env, JNU_JAVANETPKG "UnknownHostException",
+			(char *)hostname);
+	JNU_ReleaseStringPlatformChars(env, host, hostname);
+	return NULL;
+    } else {
+	int i = 0;
+	struct addrinfo *itr, *last, *iterator = res;
+	while (iterator != NULL) {
+	    int skip = 0;
+	    itr = resNew;
+
+	    while (itr != NULL) {
+		struct sockaddr_in *addr1, *addr2;
+
+		addr1 = (struct sockaddr_in *)iterator->ai_addr;
+		addr2 = (struct sockaddr_in *)itr->ai_addr;
+		if (addr1->sin_addr.s_addr ==
+		    addr2->sin_addr.s_addr) {
+		    skip = 1;
+		    break;
+		}
+		     
+		itr = itr->ai_next;
+	    }
+		
+	    if (!skip) {
+		struct addrinfo *next
+	            = (struct addrinfo*) malloc(sizeof(struct addrinfo));
+		if (!next) {
+		    JNU_ThrowOutOfMemoryError(env, "heap allocation failed");
+		    ret = NULL;
+		    goto cleanupAndReturn;
+		}
+		memcpy(next, iterator, sizeof(struct addrinfo));
+		next->ai_next = NULL;
+		if (resNew == NULL) {
+		    resNew = next;
+		} else {
+		    last->ai_next = next;
+		}
+		last = next;
+		i++;
+	    }
+	    iterator = iterator->ai_next;
+	}
+
+	retLen = i;
+	iterator = resNew;
+	i = 0;
+
+        name = (*env)->NewStringUTF(env, hostname);
+        if (IS_NULL(name)) {
+          goto cleanupAndReturn;
+        }
+
+	ret = (*env)->NewObjectArray(env, retLen, ni_iacls, NULL);
+	if (IS_NULL(ret)) {
+	    /* we may have memory to free at the end of this */
+	    goto cleanupAndReturn;
+	}
+
+	while (iterator != NULL) {
+	    /* We need 4 bytes to store ipv4 address; */
+	    int len = 4;
+		
+            jobject iaObj = (*env)->NewObject(env, ni_ia4cls, ni_ia4ctrID);
+	    if (IS_NULL(iaObj)) {
+		/* we may have memory to free at the end of this */
+		ret = NULL;
+		goto cleanupAndReturn;
+	    }
+            (*env)->SetIntField(env, iaObj, ni_iaaddressID,
+                                ntohl(((struct sockaddr_in*)(iterator->ai_addr))->sin_addr.s_addr));
+            (*env)->SetObjectField(env, iaObj, ni_iahostID, name);
+            (*env)->SetObjectArrayElement(env, ret, retLen - i -1, iaObj);
+	    i++;
+	    iterator = iterator->ai_next;
+	}
+    }
+    
+cleanupAndReturn:
+    {
+	struct addrinfo *iterator, *tmp;
+	iterator = resNew;
+	while (iterator != NULL) {
+	    tmp = iterator;
+	    iterator = iterator->ai_next;
+	    free(tmp);
+	}
+	JNU_ReleaseStringPlatformChars(env, host, hostname);
+    }
+   
+    freeaddrinfo(res);
+    
+    return ret;
+
+}
+
+/*
+ * Class:     java_net_Inet4AddressImpl
+ * Method:    getHostByAddr
+ * Signature: (I)Ljava/lang/String;
+ */
+JNIEXPORT jstring JNICALL
+Java_java_net_Inet4AddressImpl_getHostByAddr(JNIEnv *env, jobject this,
+					    jbyteArray addrArray) {
+    jstring ret = NULL;
+
+    char host[NI_MAXHOST+1];
+    jfieldID fid;
+    int error = 0;
+    jint family;
+    struct sockaddr *him ; 
+    int len = 0;
+    jbyte caddr[4];
+    jint addr;
+
+    struct sockaddr_in him4;
+    struct sockaddr *sa;
+
+    /* 
+	 * For IPv4 addresses construct a sockaddr_in structure.
+	 */
+    (*env)->GetByteArrayRegion(env, addrArray, 0, 4, caddr);
+    addr = ((caddr[0]<<24) & 0xff000000);
+    addr |= ((caddr[1] <<16) & 0xff0000);
+    addr |= ((caddr[2] <<8) & 0xff00);
+    addr |= (caddr[3] & 0xff);
+    memset((char *) &him4, 0, sizeof(him4));
+    him4.sin_addr.s_addr = (uint32_t) htonl(addr);
+    him4.sin_family = AF_INET;
+    sa = (struct sockaddr *) &him4;
+    len = sizeof(him4);
+    
+    error = getnameinfo(sa, len, host, NI_MAXHOST, NULL, 0,
+			       NI_NAMEREQD);
+
+    if (!error) {
+	ret = (*env)->NewStringUTF(env, host);
+    }
+
+    if (ret == NULL) {
+	JNU_ThrowByName(env, JNU_JAVANETPKG "UnknownHostException", NULL);
+    }
+
+    return ret;
+
+}
+
+#else /* defined(_ALLBSD_SOURCE) && !defined(HAS_GLIBC_GETHOSTBY_R) */
+
 /* the initial size of our hostent buffers */
 #define HENT_BUF_SIZE 1024
 #define BIG_HENT_BUF_SIZE 10240  /* a jumbo-sized one */
 
-#ifndef __GLIBC__
+#if !defined(__GLIBC__) && !defined(_ALLBSD_SOURCE)
 /* gethostname() is in libc.so but I can't find a header file for it */
 extern int gethostname(char *buf, int buf_len);
 #endif
@@ -85,13 +361,13 @@ Java_java_net_Inet4AddressImpl_getLocalH
         char buf2[HENT_BUF_SIZE];
         int h_error=0;
 
-#ifdef __GLIBC__
+#ifdef HAS_GLIBC_GETHOSTBY_R
         gethostbyname_r(hostname, &res, buf, sizeof(buf), &hp, &h_error);
 #else
         hp = gethostbyname_r(hostname, &res, buf, sizeof(buf), &h_error);
 #endif
         if (hp) {
-#ifdef __GLIBC__
+#ifdef HAS_GLIBC_GETHOSTBY_R
             gethostbyaddr_r(hp->h_addr, hp->h_length, AF_INET,
                             &res2, buf2, sizeof(buf2), &hp, &h_error);
 #else
@@ -178,7 +454,7 @@ Java_java_net_Inet4AddressImpl_lookupAll
     }
 
     /* Try once, with our static buffer. */
-#ifdef __GLIBC__
+#ifdef HAS_GLIBC_GETHOSTBY_R
     gethostbyname_r(hostname, &res, buf, sizeof(buf), &hp, &h_error);
 #else
     hp = gethostbyname_r(hostname, &res, buf, sizeof(buf), &h_error);
@@ -191,7 +467,7 @@ Java_java_net_Inet4AddressImpl_lookupAll
      */
     if (hp == NULL && errno == ERANGE) {
         if ((tmp = (char*)malloc(BIG_HENT_BUF_SIZE))) {
-#ifdef __GLIBC__
+#ifdef HAS_GLIBC_GETHOSTBY_R
             gethostbyname_r(hostname, &res, tmp, BIG_HENT_BUF_SIZE,
                             &hp, &h_error);
 #else
@@ -281,7 +557,7 @@ Java_java_net_Inet4AddressImpl_getHostBy
     addr |= ((caddr[2] <<8) & 0xff00);
     addr |= (caddr[3] & 0xff);
     addr = htonl(addr);
-#ifdef __GLIBC__
+#ifdef HAS_GLIBC_GETHOSTBY_R
     gethostbyaddr_r((char *)&addr, sizeof(addr), AF_INET, &hent,
                     buf, sizeof(buf), &hp, &h_error);
 #else
@@ -295,7 +571,7 @@ Java_java_net_Inet4AddressImpl_getHostBy
      */
     if (hp == NULL && errno == ERANGE) {
         if ((tmp = (char*)malloc(BIG_HENT_BUF_SIZE))) {
-#ifdef __GLIBC__
+#ifdef HAS_GLIBC_GETHOSTBY_R
             gethostbyaddr_r((char *)&addr, sizeof(addr), AF_INET,
                             &hent, tmp, BIG_HENT_BUF_SIZE, &hp, &h_error);
 #else
@@ -317,6 +593,8 @@ Java_java_net_Inet4AddressImpl_getHostBy
     return ret;
 }
 
+#endif /* _ALLBSD_SOURCE */
+
 #define SET_NONBLOCKING(fd) {           \
         int flags = fcntl(fd, F_GETFL); \
         flags |= O_NONBLOCK;            \
diff -upr ../orig/jdk/src/solaris/native/java/net/Inet6AddressImpl.c ./jdk/src/solaris/native/java/net/Inet6AddressImpl.c
--- ../orig/jdk/src/solaris/native/java/net/Inet6AddressImpl.c	2009-01-27 15:45:50.000000000 -0500
+++ ./jdk/src/solaris/native/java/net/Inet6AddressImpl.c	2009-05-04 17:37:17.000000000 -0400
@@ -32,6 +32,9 @@
 #include <strings.h>
 #include <stdlib.h>
 #include <ctype.h>
+#ifdef _ALLBSD_SOURCE
+#include <unistd.h> /* gethostname */
+#endif
 
 #include "jvm.h"
 #include "jni_util.h"
@@ -48,7 +51,7 @@
 #define NI_MAXHOST 1025
 #endif
 
-#ifndef __GLIBC__
+#if !defined(__GLIBC__) && !defined(_ALLBSD_SOURCE)
 /* gethostname() is in libc.so but I can't find a header file for it */
 extern int gethostname(char *buf, int buf_len);
 #endif
@@ -71,10 +74,18 @@ Java_java_net_Inet6AddressImpl_getLocalH
         /* Something went wrong, maybe networking is not setup? */
         strcpy(hostname, "localhost");
     } else {
-#ifdef __linux__
-        /* On Linux gethostname() says "host.domain.sun.com".  On
+#if defined(__linux__) && defined(_ALLBSD_SOURCE)
+	/* On Linux/FreeBSD gethostname() says "host.domain.sun.com".  On
          * Solaris gethostname() says "host", so extra work is needed.
          */
+        /*
+         * XXXBSD: Though on FreeBSD it's possible case then hostname does
+         * not contain '.' (depends on previous sethostname() call).  Maybe
+         * we need to proceed with Solaris way, but using getnameinfo()
+         * in conjunction with gethostby*() breaks thread-safeness, so
+         * we need to protect all calls to gethostby*() and getnameinfo()
+         * using same mutex.
+         */
 #else
         /* Solaris doesn't want to give us a fully qualified domain name.
          * We do a reverse lookup to try and get one.  This works
@@ -110,7 +121,7 @@ Java_java_net_Inet6AddressImpl_getLocalH
             }
         }
 #endif /* AF_INET6 */
-#endif /* __linux__ */
+#endif /* __linux__ || _ALLBSD_SOURCE */
     }
     return (*env)->NewStringUTF(env, hostname);
 }
diff -upr ../orig/jdk/src/solaris/native/java/net/NetworkInterface.c ./jdk/src/solaris/native/java/net/NetworkInterface.c
--- ../orig/jdk/src/solaris/native/java/net/NetworkInterface.c	2009-01-27 15:45:50.000000000 -0500
+++ ./jdk/src/solaris/native/java/net/NetworkInterface.c	2009-05-04 17:37:17.000000000 -0400
@@ -23,13 +23,13 @@
  * have any questions.
  */
 
+#include <sys/types.h>
+#include <sys/socket.h>
 #include <errno.h>
 #include <strings.h>
 #include <netinet/in.h>
 #include <stdlib.h>
 #include <string.h>
-#include <sys/types.h>
-#include <sys/socket.h>
 #include <arpa/inet.h>
 #include <net/if.h>
 #include <net/if_arp.h>
@@ -47,6 +47,19 @@
 #else
 #include <sys/sockio.h>
 #endif
+#if defined(_ALLBSD_SOURCE)
+#include <sys/param.h>
+#include <sys/ioctl.h>
+#if defined(__FreeBSD__) || defined(__APPLE__)
+#include <net/ethernet.h>
+#include <net/if_var.h>
+#elif defined(__OpenBSD__)
+#include <netinet/if_ether.h>
+#endif
+#include <net/if_dl.h>
+#include <netinet/in_var.h>
+#include <ifaddrs.h>
+#endif
 
 #ifdef __linux__
 #define ifr_index ifr_ifindex
@@ -584,6 +597,7 @@ static netif *enumInterfaces(JNIEnv *env
 }
 
 
+#if !defined(_ALLBSD_SOURCE)
 /*
  * Enumerates and returns all IPv4 interfaces
  */
@@ -694,6 +708,176 @@ static netif *enumIPv4Interfaces(JNIEnv 
     return ifs;
 }
 
+#else /* _ALLBSD_SOURCE */
+ 
+/*
+ * Enumerates and returns all IPv4 interfaces
+ *
+ * WARNING! Make sure that it's correctly synchronized on future JDK
+ * versions imports!
+ */
+static netif *enumIPv4Interfaces(JNIEnv *env, netif *ifs)
+{
+    int sock;
+    struct ifaddrs *ifa, *origifa;
+
+    sock = JVM_Socket(AF_INET, SOCK_DGRAM, 0);
+    if (sock < 0) {
+	/*
+	 * If EPROTONOSUPPORT is returned it means we don't have
+	 * IPv4 support so don't throw an exception.
+	 */
+	if (errno != EPROTONOSUPPORT) {
+	    NET_ThrowByNameWithLastError(env , JNU_JAVANETPKG "SocketException",
+                             "Socket creation failed");
+	}
+	return ifs;
+    }
+
+    if (getifaddrs(&origifa) != 0) {
+        NET_ThrowByNameWithLastError(env , JNU_JAVANETPKG "SocketException",
+                         "getifaddrs() function failed");
+	close(sock);
+	return ifs;
+    }
+
+    for (ifa = origifa; ifa != NULL; ifa = ifa->ifa_next) {
+
+	/*
+	 * Skip non-AF_INET entries.
+	 */
+	if (ifa->ifa_addr == NULL || ifa->ifa_addr->sa_family != AF_INET)
+	    continue;
+
+	/*
+	 * Add to the list.
+	 *
+	 * BSDNOTE: in order to optimize code, interface index detection
+	 * logic was added directly to addif().
+	 */
+	ifs = addif(env, ifs, ifa->ifa_name, (-1), AF_INET,
+		    ifa->ifa_addr, sizeof(struct sockaddr_in), 0);
+
+	/*
+	 * If an exception occurred then free the list.
+	 */
+	if ((*env)->ExceptionOccurred(env)) {
+	    close(sock);
+	    freeifaddrs(origifa);
+	    freeif(ifs);
+	    return NULL;
+	}
+    }
+
+    /*
+     * Free socket and buffer
+     */
+    close(sock);
+    freeifaddrs(origifa);
+    return ifs;
+}
+
+#if defined(AF_INET6)
+/*
+ * Determines the prefix on BSD for IPv6 interfaces.
+ */
+static
+int prefix(void *val, int size) {
+    u_char *name = (u_char *)val;
+    int byte, bit, plen = 0;
+
+    for (byte = 0; byte < size; byte++, plen += 8)
+        if (name[byte] != 0xff)
+            break;
+    if (byte == size)
+        return (plen);
+    for (bit = 7; bit != 0; bit--, plen++)
+        if (!(name[byte] & (1 << bit)))
+            break;
+    for (; bit != 0; bit--)
+        if (name[byte] & (1 << bit))
+            return (0);
+    byte++;
+    for (; byte < size; byte++)
+        if (name[byte])
+            return (0);
+    return (plen);
+}
+
+/*
+ * Enumerates and returns all IPv6 interfaces on FreeBSD
+ *
+ * BSDNOTE: it's done in same as IPv4 enumeration and should be carefully
+ *          reviewed with each JDK update (according to Solaris/Linux version)
+ */
+static netif *enumIPv6Interfaces(JNIEnv *env, netif *ifs) {
+
+    int sock;
+    struct ifaddrs *ifa, *origifa;
+    struct sockaddr_in6 *sin6;
+    struct in6_ifreq ifr6;
+
+    // Open IPv6 UDP socket.
+    sock = JVM_Socket(AF_INET6, SOCK_DGRAM, 0);
+    if (sock < 0) {
+        NET_ThrowByNameWithLastError(env , JNU_JAVANETPKG "SocketException",
+                     "Failed to create IPv6 socket");
+        return ifs;
+    }
+
+    if (getifaddrs(&origifa) != 0) {
+        NET_ThrowByNameWithLastError(env , JNU_JAVANETPKG "SocketException",
+                         "getifaddrs() function failed");
+	close(sock);
+	return ifs;
+    }
+
+    for (ifa = origifa; ifa != NULL; ifa = ifa->ifa_next) {
+
+	/*
+	 * Skip non-AF_INET6 entries.
+	 */
+	if (ifa->ifa_addr == NULL || ifa->ifa_addr->sa_family != AF_INET6)
+	    continue;
+
+	memset(&ifr6, 0, sizeof(ifr6));
+	strlcpy(ifr6.ifr_name, ifa->ifa_name, sizeof(ifr6.ifr_name));
+	memcpy(&ifr6.ifr_addr, ifa->ifa_addr, MIN(sizeof(ifr6.ifr_addr), ifa->ifa_addr->sa_len));
+
+	if (ioctl(sock, SIOCGIFNETMASK_IN6, (caddr_t)&ifr6) < 0) {
+	    NET_ThrowByNameWithLastError(env , JNU_JAVANETPKG "SocketException",
+                             "ioctl SIOCGIFNETMASK_IN6 failed");
+	    close(sock);
+	    freeifaddrs(origifa);
+	    freeif(ifs);
+	    return NULL;
+	}
+
+	/* Add to the list.  */
+	sin6 = (struct sockaddr_in6 *)&ifr6.ifr_addr;
+	ifs = addif(env, ifs, ifa->ifa_name, (-1), AF_INET6,
+	            ifa->ifa_addr, sizeof(struct sockaddr_in6),
+		    prefix(&sin6->sin6_addr, sizeof(struct in6_addr)));
+
+	/* If an exception occurred then free the list.  */
+	if ((*env)->ExceptionOccurred(env)) {
+	    close(sock);
+	    freeifaddrs(origifa);
+	    freeif(ifs);
+	    return NULL;
+	}
+    }
+
+    /*
+     * Free socket and ifaddrs buffer
+     */
+    close(sock);
+    freeifaddrs(origifa);
+    return ifs;
+}
+#endif /* AF_INET6 */
+
+#endif /* !_ALLBSD_SOURCE */
 
 #if defined(__solaris__) && defined(AF_INET6)
 /*
@@ -1014,7 +1198,13 @@ netif *addif(JNIEnv *env, netif *ifs, ch
             JNU_ThrowOutOfMemoryError(env, "heap allocation failed");
             return ifs;
         }
+#if defined(_ALLBSD_SOURCE)
+	currif->index = if_nametoindex(name);
+	if (currif->index == 0)
+	    currif->index = -1;
+#else
         currif->index = index;
+#endif
         currif->addr = NULL;
         currif->childs = NULL;
         currif->virtual = isVirtual;
@@ -1302,6 +1492,31 @@ int getMacAddress(JNIEnv *env, const str
    * All bytes to 0 means no hardware address.
    */
   return -1;
+#elif defined(_ALLBSD_SOURCE)
+  struct ifaddrs *ifa0, *ifa;
+  struct sockaddr *saddr;
+  int i;
+
+  /* Grab the interface list */
+  if (!getifaddrs(&ifa0)) {
+    /* Cycle through the interfaces */
+    for (i = 0, ifa = ifa0; ifa != NULL; ifa = ifa->ifa_next, i++) {
+      saddr = ifa->ifa_addr;
+      /* Link layer contains the MAC address */
+      if (saddr->sa_family == AF_LINK && !strcmp(ifname, ifa->ifa_name)) {
+        struct sockaddr_dl *sadl = (struct sockaddr_dl *) saddr;
+        /* Check the address is the correct length */
+        if (sadl->sdl_alen == ETHER_ADDR_LEN) {
+           memcpy(buf, (sadl->sdl_data + sadl->sdl_nlen), ETHER_ADDR_LEN);
+           freeifaddrs(ifa0);
+           return ETHER_ADDR_LEN;
+        }
+      }
+    }
+    freeifaddrs(ifa0);
+  }
+
+  return -1;
 #else
   struct arpreq arpreq;
   struct sockaddr_in* sin;
@@ -1467,7 +1682,7 @@ JNIEXPORT jint JNICALL Java_java_net_Net
                                  "Socket creation failed");
   } else {
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     memset((char *) &if2, 0, sizeof(if2));
     strcpy(if2.ifr_name, name_utf);
 
diff -upr ../orig/jdk/src/solaris/native/java/net/PlainDatagramSocketImpl.c ./jdk/src/solaris/native/java/net/PlainDatagramSocketImpl.c
--- ../orig/jdk/src/solaris/native/java/net/PlainDatagramSocketImpl.c	2009-01-27 15:45:50.000000000 -0500
+++ ./jdk/src/solaris/native/java/net/PlainDatagramSocketImpl.c	2009-05-04 17:37:17.000000000 -0400
@@ -23,12 +23,12 @@
  * have any questions.
  */
 
+#include <sys/types.h>
+#include <sys/socket.h>
 #include <errno.h>
 #include <netinet/in.h>
 #include <stdlib.h>
 #include <string.h>
-#include <sys/types.h>
-#include <sys/socket.h>
 
 #ifdef __solaris__
 #include <fcntl.h>
@@ -335,7 +335,7 @@ Java_java_net_PlainDatagramSocketImpl_di
     /* The fdObj'fd */
     jint fd;
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     SOCKADDR addr;
     int len;
 #endif
@@ -345,26 +345,39 @@ Java_java_net_PlainDatagramSocketImpl_di
     }
     fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);
 
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #ifdef __linux__
     if (isOldKernel) {
         int t = 1;
         setsockopt(fd, SOL_SOCKET, SO_BSDCOMPAT, (char*) &t, sizeof(int));
     } else {
+#endif /* __linux__ */
         memset(&addr, 0, sizeof(addr));
 #ifdef AF_INET6
         if (ipv6_available()) {
             struct sockaddr_in6 *him6 = (struct sockaddr_in6 *)&addr;
+#ifdef __FreeBSD__
+            him6->sin6_family = AF_INET6;
+#else
             him6->sin6_family = AF_UNSPEC;
+#endif
             len = sizeof(struct sockaddr_in6);
         } else
 #endif
         {
             struct sockaddr_in *him4 = (struct sockaddr_in*)&addr;
+#ifdef __FreeBSD__
+            him4->sin_family = AF_INET;
+#else
             him4->sin_family = AF_UNSPEC;
+#endif
             len = sizeof(struct sockaddr_in);
         }
         JVM_Connect(fd, (struct sockaddr *)&addr, len);
+	/* XXXBSD: here we can get EADDRNOTAVAIL which need to be ignored
+	   but since return value is not checked, ignore it */
 
+#ifdef __linux__
         // After disconnecting a UDP socket, Linux kernel will set
         // local port to zero if the port number comes from implicit
         // bind. Successive send/recv on the same socket will fail.
@@ -387,6 +400,7 @@ Java_java_net_PlainDatagramSocketImpl_di
             NET_Bind(fd, (struct sockaddr *)&addr, len);
         }
     }
+#endif
 #else
     JVM_Connect(fd, 0, 0);
 #endif
@@ -2374,18 +2388,30 @@ static void mcast_join_leave(JNIEnv *env
             mname6.ipv6mr_interface = idx;
         }
 
+#if defined(_ALLBSD_SOURCE)
+#define ADD_MEMBERSHIP		IPV6_JOIN_GROUP
+#define DRP_MEMBERSHIP		IPV6_LEAVE_GROUP
+#define S_ADD_MEMBERSHIP	"IPV6_JOIN_GROUP"
+#define S_DRP_MEMBERSHIP	"IPV6_LEAVE_GROUP"
+#else
+#define ADD_MEMBERSHIP		IPV6_ADD_MEMBERSHIP
+#define DRP_MEMBERSHIP		IPV6_DROP_MEMBERSHIP
+#define S_ADD_MEMBERSHIP	"IPV6_ADD_MEMBERSHIP"
+#define S_DRP_MEMBERSHIP	"IPV6_DROP_MEMBERSHIP"
+#endif
+
         /* Join the multicast group */
-        if (JVM_SetSockOpt(fd, IPPROTO_IPV6, (join ? IPV6_ADD_MEMBERSHIP : IPV6_DROP_MEMBERSHIP),
+        if (JVM_SetSockOpt(fd, IPPROTO_IPV6, (join ? ADD_MEMBERSHIP : DRP_MEMBERSHIP),
                            (char *) &mname6, sizeof (mname6)) < 0) {
 
             if (join) {
-                NET_ThrowCurrent(env, "setsockopt IPV6_ADD_MEMBERSHIP failed");
+                NET_ThrowCurrent(env, "setsockopt " S_ADD_MEMBERSHIP " failed");
             } else {
                 if (errno == ENOENT) {
                    JNU_ThrowByName(env, JNU_JAVANETPKG "SocketException",
                         "Not a member of the multicast group");
                 } else {
-                    NET_ThrowCurrent(env, "setsockopt IPV6_DROP_MEMBERSHIP failed");
+                    NET_ThrowCurrent(env, "setsockopt " S_DRP_MEMBERSHIP " failed");
                 }
             }
         }
diff -upr ../orig/jdk/src/solaris/native/java/net/PlainSocketImpl.c ./jdk/src/solaris/native/java/net/PlainSocketImpl.c
--- ../orig/jdk/src/solaris/native/java/net/PlainSocketImpl.c	2009-01-27 15:45:50.000000000 -0500
+++ ./jdk/src/solaris/native/java/net/PlainSocketImpl.c	2009-05-04 17:37:17.000000000 -0400
@@ -528,9 +528,11 @@ Java_java_net_PlainSocketImpl_socketConn
         if (connect_rv == JVM_IO_INTR) {
             JNU_ThrowByName(env, JNU_JAVAIOPKG "InterruptedIOException",
                             "operation interrupted");
+#if defined(EPROTO)
         } else if (errno == EPROTO) {
             NET_ThrowByNameWithLastError(env, JNU_JAVANETPKG "ProtocolException",
                            "Protocol error");
+#endif
         } else if (errno == ECONNREFUSED) {
             NET_ThrowByNameWithLastError(env, JNU_JAVANETPKG "ConnectException",
                            "Connection refused");
diff -upr ../orig/jdk/src/solaris/native/java/net/bsd_close.c ./jdk/src/solaris/native/java/net/bsd_close.c
--- ../orig/jdk/src/solaris/native/java/net/bsd_close.c	2009-05-04 18:32:16.000000000 -0400
+++ ./jdk/src/solaris/native/java/net/bsd_close.c	2009-05-04 17:37:15.000000000 -0400
@@ -57,7 +57,7 @@ typedef struct {
 /*
  * Signal to unblock thread
  */
-static int sigWakeup = (__SIGRTMAX - 2);
+static int sigWakeup = SIGIO;
 
 /*
  * The fd table and the number of file descriptors
diff -upr ../orig/jdk/src/solaris/native/java/net/net_util_md.c ./jdk/src/solaris/native/java/net/net_util_md.c
--- ../orig/jdk/src/solaris/native/java/net/net_util_md.c	2009-01-27 15:45:50.000000000 -0500
+++ ./jdk/src/solaris/native/java/net/net_util_md.c	2009-05-04 17:37:17.000000000 -0400
@@ -34,6 +34,15 @@
 #include <stdlib.h>
 #include <dlfcn.h>
 
+#ifdef _ALLBSD_SOURCE
+#include <sys/param.h>
+#include <sys/sysctl.h>
+#endif
+
+#ifdef __OpenBSD__
+#include <sys/socketvar.h>
+#endif
+
 #ifdef __solaris__
 #include <sys/sockio.h>
 #include <stropts.h>
@@ -219,6 +228,14 @@ NET_GetFileDescriptorID(JNIEnv *env)
     return (*env)->GetFieldID(env, cls, "fd", "I");
 }
 
+#if defined(DONT_ENABLE_IPV6)
+jint  IPv6_supported()
+{
+    return JNI_FALSE;
+}
+
+#else /* !DONT_ENABLE_IPV6 */
+
 jint  IPv6_supported()
 {
 #ifndef AF_INET6
@@ -355,6 +372,7 @@ jint  IPv6_supported()
     close(fd);
     return JNI_TRUE;
 }
+#endif /* DONT_ENABLE_IPV6 */
 
 void
 NET_AllocSockaddr(struct sockaddr **him, int *len) {
@@ -689,6 +707,10 @@ NET_InetAddressToSockaddr(JNIEnv *env, j
         him6->sin6_family = AF_INET6;
         *len = sizeof(struct sockaddr_in6) ;
 
+#if defined(_ALLBSD_SOURCE) && defined(_AF_INET6)
+// XXXBSD: should we do something with scope id here ? see below linux comment
+#endif
+
         /*
          * On Linux if we are connecting to a link-local address
          * we need to specify the interface in the scope_id (2.4 kernel only)
@@ -1133,6 +1155,24 @@ NET_SetSockOpt(int fd, int level, int  o
 #define IPTOS_PREC_MASK 0xe0
 #endif
 
+#if defined(_ALLBSD_SOURCE)
+#if defined(KIPC_MAXSOCKBUF)
+    int mib[3];
+    size_t rlen;
+#endif
+
+    int *bufsize;
+
+#ifdef __APPLE__
+    static int maxsockbuf = -1;
+#else
+    static long maxsockbuf = -1;
+#endif
+
+    int addopt;
+    struct linger *ling;
+#endif
+
     /*
      * IPPROTO/IP_TOS :-
      * 1. IPv6 on Solaris: no-op and will be set in flowinfo
@@ -1165,6 +1205,10 @@ NET_SetSockOpt(int fd, int level, int  o
         *iptos &= (IPTOS_TOS_MASK | IPTOS_PREC_MASK);
     }
 
+#if defined(AF_INET6) && defined(_ALLBSD_SOURCE)
+// XXXBSD: to be implemented ?
+#endif
+
     /*
      * SOL_SOCKET/{SO_SNDBUF,SO_RCVBUF} - On Solaris need to
      * ensure that value is <= max_buf as otherwise we get
@@ -1212,6 +1256,83 @@ NET_SetSockOpt(int fd, int level, int  o
     }
 #endif
 
+#if defined(_ALLBSD_SOURCE)
+    /*
+     * SOL_SOCKET/{SO_SNDBUF,SO_RCVBUF} - On FreeBSD need to
+     * ensure that value is <= kern.ipc.maxsockbuf as otherwise we get
+     * an ENOBUFS error.
+     */
+    if (level == SOL_SOCKET) {
+        if (opt == SO_SNDBUF || opt == SO_RCVBUF) {
+#ifdef KIPC_MAXSOCKBUF
+            if (maxsockbuf == -1) {
+               mib[0] = CTL_KERN;
+               mib[1] = KERN_IPC;
+               mib[2] = KIPC_MAXSOCKBUF;
+               rlen = sizeof(maxsockbuf);
+               if (sysctl(mib, 3, &maxsockbuf, &rlen, NULL, 0) == -1)
+                   maxsockbuf = 1024;
+
+#if 1
+               /* XXXBSD: This is a hack to workaround mb_max/mb_max_adj
+                  problem.  It should be removed when kern.ipc.maxsockbuf
+                  will be real value. */
+               maxsockbuf = (maxsockbuf/5)*4;
+#endif
+           }
+#elif defined(__OpenBSD__)
+	   maxsockbuf = SB_MAX;
+#else
+	   maxsockbuf = 64 * 1024;	/* XXX: NetBSD */
+#endif
+
+           bufsize = (int *)arg;
+           if (*bufsize > maxsockbuf) {
+               *bufsize = maxsockbuf;
+           }
+
+	   if (opt == SO_RCVBUF && *bufsize < 1024) {
+		*bufsize = 1024;
+	   }
+
+        }
+    }
+
+    /*
+     * On Solaris, SO_REUSEADDR will allow multiple datagram
+     * sockets to bind to the same port.  The network jck tests
+     * for this "feature", so we need to emulate it by turning on
+     * SO_REUSEPORT as well for that combination.
+     */
+    if (level == SOL_SOCKET && opt == SO_REUSEADDR) {
+        int sotype, arglen;
+
+        arglen = sizeof(sotype);
+        if (getsockopt(fd, SOL_SOCKET, SO_TYPE, (void *)&sotype, &arglen) < 0) {
+            return -1;
+        }
+
+        if (sotype == SOCK_DGRAM) {
+            addopt = SO_REUSEPORT;
+            setsockopt(fd, level, addopt, arg, len);
+        }
+    }
+
+    /*
+     * Don't allow SO_LINGER value to be too big.
+     * Current max value (240) is empiric value based on tcp_timer.h's
+     * constant TCP_LINGERTIME, which was doubled.
+     *
+     * XXXBSD: maybe we should step it down to 120 ?
+     */
+    if (level == SOL_SOCKET && opt == SO_LINGER) {
+        ling = (struct linger *)arg;
+       if (ling->l_linger > 240 || ling->l_linger < 0) {
+           ling->l_linger = 240;
+       }
+    }
+#endif
+
     return setsockopt(fd, level, opt, arg, len);
 }
 
diff -upr ../orig/jdk/src/solaris/native/java/net/net_util_md.h ./jdk/src/solaris/native/java/net/net_util_md.h
--- ../orig/jdk/src/solaris/native/java/net/net_util_md.h	2009-01-27 15:45:50.000000000 -0500
+++ ./jdk/src/solaris/native/java/net/net_util_md.h	2009-05-04 17:37:17.000000000 -0400
@@ -37,7 +37,7 @@
 #endif
 
 
-#ifdef __linux__
+#if defined(__linux__) || defined(__FreeBSD__)
 extern int NET_Timeout(int s, long timeout);
 extern int NET_Read(int s, void* buf, size_t len);
 extern int NET_RecvFrom(int s, void *buf, int len, unsigned int flags,
diff -upr ../orig/jdk/src/solaris/native/java/nio/MappedByteBuffer.c ./jdk/src/solaris/native/java/nio/MappedByteBuffer.c
--- ../orig/jdk/src/solaris/native/java/nio/MappedByteBuffer.c	2009-01-27 15:45:50.000000000 -0500
+++ ./jdk/src/solaris/native/java/nio/MappedByteBuffer.c	2009-05-04 17:37:17.000000000 -0400
@@ -38,7 +38,11 @@ Java_java_nio_MappedByteBuffer_isLoaded0
                                         jlong address, jlong len)
 {
     jboolean loaded = JNI_TRUE;
+#if defined(_ALLBSD_SOURCE)
+    jint pageSize = getpagesize();
+#else
     jint pageSize = sysconf(_SC_PAGESIZE);
+#endif
     jint numPages = (len + pageSize - 1) / pageSize;
     int result = 0;
     int i = 0;
@@ -92,7 +96,11 @@ JNIEXPORT void JNICALL
 Java_java_nio_MappedByteBuffer_force0(JNIEnv *env, jobject obj, jlong address,
                                       jlong len)
 {
+#if defined(_ALLBSD_SOURCE)
+    jlong pageSize = getpagesize();
+#else
     jlong pageSize = sysconf(_SC_PAGESIZE);
+#endif
     unsigned long lAddress = address;
 
     jlong offset = lAddress % pageSize;
diff -upr ../orig/jdk/src/solaris/native/java/util/FileSystemPreferences.c ./jdk/src/solaris/native/java/util/FileSystemPreferences.c
--- ../orig/jdk/src/solaris/native/java/util/FileSystemPreferences.c	2009-01-27 15:45:50.000000000 -0500
+++ ./jdk/src/solaris/native/java/util/FileSystemPreferences.c	2009-05-04 17:37:17.000000000 -0400
@@ -47,8 +47,11 @@ Java_java_util_prefs_FileSystemPreferenc
     return (jint) result;
 }
 
-
+#if defined(_ALLBSD_SOURCE)
+typedef struct flock FLOCK;
+#else
 typedef struct flock64 FLOCK;
+#endif
 
 /**
  * Try to open a named lock file.
@@ -86,7 +89,11 @@ Java_java_util_prefs_FileSystemPreferenc
     if (fd < 0) {
         result[0] = 0;
     } else {
+#if defined(_ALLBSD_SOURCE)
+        rc = fcntl(fd, F_SETLK, &fl); 
+#else
         rc = fcntl(fd, F_SETLK64, &fl);
+#endif
         result[1] = errno;
         if (rc < 0) {
             result[0]= 0;
@@ -116,7 +123,11 @@ Java_java_util_prefs_FileSystemPreferenc
     fl.l_start = 0;
     fl.l_type = F_UNLCK;
 
+#if defined(_ALLBSD_SOURCE)
+    rc = fcntl(fd, F_SETLK, &fl);
+#else
     rc = fcntl(fd, F_SETLK64, &fl);
+#endif
 
     if (rc < 0) {
         close(fd);
diff -upr ../orig/jdk/src/solaris/native/java/util/TimeZone_md.c ./jdk/src/solaris/native/java/util/TimeZone_md.c
--- ../orig/jdk/src/solaris/native/java/util/TimeZone_md.c	2009-01-27 15:45:50.000000000 -0500
+++ ./jdk/src/solaris/native/java/util/TimeZone_md.c	2009-05-05 17:44:22.000000000 -0400
@@ -31,7 +31,7 @@
 #include <errno.h>
 #include <stddef.h>
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <string.h>
 #include <dirent.h>
 #include <sys/stat.h>
@@ -49,11 +49,14 @@
 #define fileclose       fclose
 #endif
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 
+#ifdef __linux__
 static const char *sysconfig_clock_file = "/etc/sysconfig/clock";
+#endif
+
 static const char *zoneinfo_dir = "/usr/share/zoneinfo";
-static const char *defailt_zoneinfo_file = "/etc/localtime";
+static const char *default_zoneinfo_file = "/etc/localtime";
 
 /*
  * Returns a point to the zone ID portion of the given zoneinfo file
@@ -199,7 +202,9 @@ getPlatformTimeZoneID()
     int fd;
     char *buf;
     size_t size;
+    char zoneinfo_file[PATH_MAX+1];
 
+#ifdef __linux__
     /*
      * First, try the ZONE entry in /etc/sysconfig/clock. However, the
      * ZONE entry is not set up after initial Red Hat Linux
@@ -254,14 +259,18 @@ getPlatformTimeZoneID()
             return tz;
         }
     }
+#endif /* __linux__ */
 
     /*
      * Next, try /etc/localtime to find the zone ID.
      */
-    if (lstat(defailt_zoneinfo_file, &statbuf) == -1) {
+    if (lstat(default_zoneinfo_file, &statbuf) == -1) {
         return NULL;
     }
 
+    strlcpy(zoneinfo_file, default_zoneinfo_file, PATH_MAX+1);
+
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     /*
      * If it's a symlink, get the link name and its zone ID part. (The
      * older versions of timeconfig created a symlink as described in
@@ -270,21 +279,25 @@ getPlatformTimeZoneID()
      * from /etc/localtime.)
      */
     if (S_ISLNK(statbuf.st_mode)) {
-        char linkbuf[PATH_MAX+1];
         int len;
 
-        if ((len = readlink(defailt_zoneinfo_file, linkbuf, sizeof(linkbuf)-1)) == -1) {
+	if ((len = readlink(default_zoneinfo_file, zoneinfo_file, sizeof(zoneinfo_file)-1)) == -1) {
             jio_fprintf(stderr, (const char *) "can't get a symlink of %s\n",
-                        defailt_zoneinfo_file);
+                        default_zoneinfo_file);
             return NULL;
         }
-        linkbuf[len] = '\0';
-        tz = getZoneName(linkbuf);
+	zoneinfo_file[len] = '\0';
+	tz = getZoneName(zoneinfo_file);
         if (tz != NULL) {
             tz = strdup(tz);
+	    return tz;
+	} else {
+	    if (lstat(zoneinfo_file, &statbuf) == -1) {
+		return NULL;
+	    }
         }
-        return tz;
     }
+#endif /* __linux__ || _ALLBSD_SOURCE */
 
     /*
      * If it's a regular file, we need to find out the same zoneinfo file
@@ -295,7 +308,7 @@ getPlatformTimeZoneID()
     if (buf == NULL) {
         return NULL;
     }
-    if ((fd = open(defailt_zoneinfo_file, O_RDONLY)) == -1) {
+    if ((fd = open(zoneinfo_file, O_RDONLY)) == -1) {
         free((void *) buf);
         return NULL;
     }
@@ -524,7 +537,7 @@ findJavaTZ_md(const char *java_home_dir,
 
     tz = getenv("TZ");
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     if (tz == NULL) {
 #else
 #ifdef __solaris__
@@ -563,19 +576,32 @@ getGMTOffsetID()
 {
     time_t offset;
     char sign, buf[16];
+#if defined(_ALLBSD_SOURCE)
+    struct tm *local_tm;
+    time_t clock;
+ 
+    clock = time(NULL);
+    tzset();
+    local_tm = localtime(&clock);
+    if (local_tm->tm_gmtoff >= 0) {
+	offset = (time_t) local_tm->tm_gmtoff;
+	sign = '+';
+    } else {
+	offset = (time_t) -local_tm->tm_gmtoff;
+	sign = '-';
+    }
+#else
 
     if (timezone == 0) {
         return strdup("GMT");
-    }
-
-    /* Note that the time offset direction is opposite. */
-    if (timezone > 0) {
+    } else if (timezone > 0) {
         offset = timezone;
         sign = '-';
     } else {
         offset = -timezone;
         sign = '+';
     }
+#endif
     sprintf(buf, (const char *)"GMT%c%02d:%02d",
             sign, (int)(offset/3600), (int)((offset%3600)/60));
     return strdup(buf);
diff -upr ../orig/jdk/src/solaris/native/sun/awt/CUPSfuncs.c ./jdk/src/solaris/native/sun/awt/CUPSfuncs.c
--- ../orig/jdk/src/solaris/native/sun/awt/CUPSfuncs.c	2009-01-27 15:45:50.000000000 -0500
+++ ./jdk/src/solaris/native/sun/awt/CUPSfuncs.c	2009-05-04 17:37:17.000000000 -0400
@@ -25,6 +25,7 @@
 
 #include <jni.h>
 #include <jni_util.h>
+#include <jvm_md.h>
 #include <dlfcn.h>
 #include <cups/cups.h>
 #include <cups/ppd.h>
@@ -65,10 +66,11 @@ fn_ppdPageSize j2d_ppdPageSize;
 JNIEXPORT jboolean JNICALL
 Java_sun_print_CUPSPrinter_initIDs(JNIEnv *env,
                                          jobject printObj) {
-  void *handle = dlopen("libcups.so.2", RTLD_LAZY | RTLD_GLOBAL);
+  void *handle = dlopen(VERSIONED_JNI_LIB_NAME("cups", "2"),
+                        RTLD_LAZY | RTLD_GLOBAL);
 
   if (handle == NULL) {
-    handle = dlopen("libcups.so", RTLD_LAZY | RTLD_GLOBAL);
+    handle = dlopen(JNI_LIB_NAME("cups"), RTLD_LAZY | RTLD_GLOBAL);
     if (handle == NULL) {
       return JNI_FALSE;
     }
diff -upr ../orig/jdk/src/solaris/native/sun/awt/VDrawingArea.c ./jdk/src/solaris/native/sun/awt/VDrawingArea.c
--- ../orig/jdk/src/solaris/native/sun/awt/VDrawingArea.c	2009-01-27 15:45:50.000000000 -0500
+++ ./jdk/src/solaris/native/sun/awt/VDrawingArea.c	2009-05-04 17:37:17.000000000 -0400
@@ -31,7 +31,11 @@
 #endif /* !HEADLESS */
 
 #include <stdio.h>
+#if defined(_ALLBSD_SOURCE)
+#include <stdlib.h>
+#else
 #include <malloc.h>
+#endif
 
 #ifdef __linux__
 /* XXX: Shouldn't be necessary. */
diff -upr ../orig/jdk/src/solaris/native/sun/awt/X11Color.c ./jdk/src/solaris/native/sun/awt/X11Color.c
--- ../orig/jdk/src/solaris/native/sun/awt/X11Color.c	2009-01-27 15:45:50.000000000 -0500
+++ ./jdk/src/solaris/native/sun/awt/X11Color.c	2009-05-04 17:37:17.000000000 -0400
@@ -33,7 +33,9 @@
 #include <math.h>
 #include <sys/time.h>
 #include <sys/resource.h>
+#if !defined(_ALLBSD_SOURCE)
 #include <alloca.h>
+#endif
 #ifndef HEADLESS
 #include <X11/Xlib.h>
 #include <X11/Xatom.h>
diff -upr ../orig/jdk/src/solaris/native/sun/awt/XDrawingArea.c ./jdk/src/solaris/native/sun/awt/XDrawingArea.c
--- ../orig/jdk/src/solaris/native/sun/awt/XDrawingArea.c	2009-01-27 15:45:50.000000000 -0500
+++ ./jdk/src/solaris/native/sun/awt/XDrawingArea.c	2009-05-04 17:37:17.000000000 -0400
@@ -30,7 +30,11 @@
 #include <Xm/XmP.h>
 
 #include <stdio.h>
+#if defined(_ALLBSD_SOURCE)
+#include <stdlib.h>
+#else
 #include <malloc.h>
+#endif
 
 #ifdef DEBUG
 #include <jvm.h>  /* To get jio_fprintf() */
diff -upr ../orig/jdk/src/solaris/native/sun/awt/awt_Font.c ./jdk/src/solaris/native/sun/awt/awt_Font.c
--- ../orig/jdk/src/solaris/native/sun/awt/awt_Font.c	2009-01-27 15:45:50.000000000 -0500
+++ ./jdk/src/solaris/native/sun/awt/awt_Font.c	2009-05-04 17:37:17.000000000 -0400
@@ -334,7 +334,7 @@ loadFont(Display * display, char *name, 
             if (strcmp(style, "regular") == 0) {
                 altstyle = "roman";
             }
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
             if (!strcmp(family, "lucidasans")) {
                 family = "lucida";
             }
diff -upr ../orig/jdk/src/solaris/native/sun/awt/awt_GraphicsEnv.c ./jdk/src/solaris/native/sun/awt/awt_GraphicsEnv.c
--- ../orig/jdk/src/solaris/native/sun/awt/awt_GraphicsEnv.c	2009-01-27 15:45:50.000000000 -0500
+++ ./jdk/src/solaris/native/sun/awt/awt_GraphicsEnv.c	2009-05-04 17:37:17.000000000 -0400
@@ -40,6 +40,7 @@
 #include <jni.h>
 #include <jni_util.h>
 #include <jvm.h>
+#include <jvm_md.h>
 #include <jlong.h>
 
 #include <stdlib.h>
@@ -51,6 +52,8 @@
 #include <dlfcn.h>
 #include "Trace.h"
 
+#include "jvm_md.h"
+
 #ifdef NETSCAPE
 #include <signal.h>
 extern int awt_init_xt;
@@ -122,7 +125,7 @@ static char *x11GraphicsConfigClassName 
  */
 
 #define MAXFRAMEBUFFERS 16
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 typedef struct {
    int   screen_number;
    short x_org;
@@ -631,19 +634,22 @@ void checkNewXineramaScreen(JNIEnv* env,
 #endif /* HEADLESS */
 
 #ifndef HEADLESS
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 static void xinerama_init_linux()
 {
-    void* libHandle = 0;
-    char* XineramaLibName= "libXinerama.so.1";
+    void* libHandle = NULL;
     int32_t locNumScr = 0;
     XineramaScreenInfo *xinInfo;
     char* XineramaQueryScreensName = "XineramaQueryScreens";
     XineramaQueryScreensFunc* XineramaQueryScreens = NULL;
 
     /* load library */
-    libHandle = dlopen(XineramaLibName, RTLD_LAZY | RTLD_GLOBAL);
-    if (libHandle != 0) {
+    libHandle = dlopen(VERSIONED_JNI_LIB_NAME("Xinerama", "1"),
+                       RTLD_LAZY | RTLD_GLOBAL);
+    if (libHandle == NULL) {
+        libHandle = dlopen(JNI_LIB_NAME("Xinerama"), RTLD_LAZY | RTLD_GLOBAL);
+    }
+    if (libHandle != NULL) {
         XineramaQueryScreens = (XineramaQueryScreensFunc*)
             dlsym(libHandle, XineramaQueryScreensName);
 
@@ -679,11 +685,10 @@ static void xinerama_init_linux()
     }
 }
 #endif
-#ifndef __linux__ /* Solaris */
+#if !defined(__linux__) && !defined(_ALLBSD_SOURCE) /* Solaris */
 static void xinerama_init_solaris()
 {
-    void* libHandle = 0;
-    char* XineramaLibName= "libXext.so";
+    void* libHandle = NULL;
     unsigned char fbhints[MAXFRAMEBUFFERS];
     int32_t locNumScr = 0;
     /* load and run XineramaGetInfo */
@@ -692,8 +697,8 @@ static void xinerama_init_solaris()
     XineramaGetInfoFunc* XineramaSolarisFunc = NULL;
 
     /* load library */
-    libHandle = dlopen(XineramaLibName, RTLD_LAZY | RTLD_GLOBAL);
-    if (libHandle != 0) {
+    libHandle = dlopen(JNI_LIB_NAME("Xext"), RTLD_LAZY | RTLD_GLOBAL);
+    if (libHandle != NULL) {
         XineramaSolarisFunc = (XineramaGetInfoFunc*)dlsym(libHandle, XineramaGetInfoName);
         XineramaSolarisCenterFunc =
             (XineramaGetCenterHintFunc*)dlsym(libHandle, XineramaGetCenterHintName);
@@ -740,11 +745,11 @@ static void xineramaInit(void) {
     }
 
     DTRACE_PRINTLN("Xinerama extension is available");
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     xinerama_init_linux();
 #else /* Solaris */
     xinerama_init_solaris();
-#endif /* __linux__ */
+#endif /* __linux__ || _ALLBSD_SOURCE */
 }
 #endif /* HEADLESS */
 
@@ -1600,7 +1605,7 @@ Java_sun_awt_X11GraphicsEnvironment_getX
 {
     jobject point = NULL;
 #ifndef HEADLESS    /* return NULL in HEADLESS, Linux */
-#ifndef __linux__
+#if !defined(__linux__) && !defined(_ALLBSD_SOURCE)
     int x,y;
 
     AWT_LOCK();
@@ -1613,7 +1618,7 @@ Java_sun_awt_X11GraphicsEnvironment_getX
         DTRACE_PRINTLN("unable to call XineramaSolarisCenterFunc: symbol is null");
     }
     AWT_FLUSH_UNLOCK();
-#endif /* __linux __ */
+#endif /* __linux __ || _ALLBSD_SOURCE */
 #endif /* HEADLESS */
     return point;
 }
@@ -1678,7 +1683,11 @@ X11GD_InitXrandrFuncs(JNIEnv *env)
 {
     int rr_maj_ver = 0, rr_min_ver = 0;
 
-    void *pLibRandR = dlopen("libXrandr.so.2", RTLD_LAZY | RTLD_LOCAL);
+    void *pLibRandR = dlopen(VERSIONED_JNI_LIB_NAME("Xrandr", "2"),
+                             RTLD_LAZY | RTLD_LOCAL);
+    if (pLibRandR == NULL) {
+        pLibRandR = dlopen(JNI_LIB_NAME("Xrandr"), RTLD_LAZY | RTLD_LOCAL);
+    }
     if (pLibRandR == NULL) {
         J2dRlsTraceLn(J2D_TRACE_ERROR,
                       "X11GD_InitXrandrFuncs: Could not open libXrandr.so.2");
diff -upr ../orig/jdk/src/solaris/native/sun/awt/awt_InputMethod.c ./jdk/src/solaris/native/sun/awt/awt_InputMethod.c
--- ../orig/jdk/src/solaris/native/sun/awt/awt_InputMethod.c	2009-01-27 15:45:50.000000000 -0500
+++ ./jdk/src/solaris/native/sun/awt/awt_InputMethod.c	2009-05-04 17:37:17.000000000 -0400
@@ -69,7 +69,7 @@ static void PreeditDrawCallback(XIC, XPo
                                 XIMPreeditDrawCallbackStruct *);
 static void PreeditCaretCallback(XIC, XPointer,
                                  XIMPreeditCaretCallbackStruct *);
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 static void StatusStartCallback(XIC, XPointer, XPointer);
 static void StatusDoneCallback(XIC, XPointer, XPointer);
 static void StatusDrawCallback(XIC, XPointer,
@@ -83,7 +83,7 @@ static void StatusDrawCallback(XIC, XPoi
 #define PreeditDoneIndex        1
 #define PreeditDrawIndex        2
 #define PreeditCaretIndex       3
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #define StatusStartIndex        4
 #define StatusDoneIndex         5
 #define StatusDrawIndex         6
@@ -101,14 +101,14 @@ static XIMProc callback_funcs[NCALLBACKS
     (XIMProc)PreeditDoneCallback,
     (XIMProc)PreeditDrawCallback,
     (XIMProc)PreeditCaretCallback,
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     (XIMProc)StatusStartCallback,
     (XIMProc)StatusDoneCallback,
     (XIMProc)StatusDrawCallback,
 #endif
 };
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #define MAX_STATUS_LEN  100
 typedef struct {
     Window   w;                /*status window id        */
@@ -148,7 +148,7 @@ typedef struct _X11InputMethodData {
 #endif /* XAWT */
     jobject     x11inputmethod; /* global ref to X11InputMethod instance */
                                 /* associated with the XIC */
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     StatusWindow *statusWindow; /* our own status window  */
 #else
 #ifndef XAWT
@@ -427,7 +427,7 @@ destroyX11InputMethodData(JNIEnv *env, X
 static void
 freeX11InputMethodData(JNIEnv *env, X11InputMethodData *pX11IMData)
 {
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     if (pX11IMData->statusWindow != NULL){
         StatusWindow *sw = pX11IMData->statusWindow;
         XFreeGC(awt_display, sw->lightGC);
@@ -533,7 +533,7 @@ awt_x11inputmethod_lookupString(XKeyPres
     pX11IMData = getX11InputMethodData(env, currentX11InputMethodInstance);
 
     if (pX11IMData == NULL) {
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
         return False;
 #else
         return result;
@@ -541,7 +541,7 @@ awt_x11inputmethod_lookupString(XKeyPres
     }
 
     if ((ic = pX11IMData->current_ic) == (XIC)0){
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
         return False;
 #else
         return result;
@@ -650,7 +650,7 @@ awt_x11inputmethod_lookupString(XKeyPres
     return result;
 }
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 static StatusWindow *createStatusWindow(
 #ifdef XAWT
                                 Window parent) {
@@ -994,7 +994,7 @@ void adjustStatusWindow(Widget shell){
         }
     }
 }
-#endif  /*__linux__*/
+#endif  /* __linux__ || _ALLBSD_SOURCE */
 /*
  * Creates two XICs, one for active clients and the other for passive
  * clients. All information on those XICs are stored in the
@@ -1051,7 +1051,7 @@ createXIC(Widget w, X11InputMethodData *
         return FALSE ;
     }
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     on_the_spot_styles |= XIMStatusNothing;
 
     /*kinput does not support XIMPreeditCallbacks and XIMStatusArea
@@ -1064,7 +1064,7 @@ createXIC(Widget w, X11InputMethodData *
             break;
         }
     }
-#else /*! __linux__ */
+#else /*! __linux__ && !_ALLBSD_SOURCE */
 #ifdef XAWT
     on_the_spot_styles |= XIMStatusNothing;
 #else /* !XAWT */
@@ -1087,7 +1087,7 @@ createXIC(Widget w, X11InputMethodData *
         on_the_spot_styles |= XIMStatusNothing;
 
 #endif /* XAWT */
-#endif /* __linux__ */
+#endif /* __linux__ || _ALLBSD_SOURCE */
 
     for (i = 0; i < im_styles->count_styles; i++) {
         active_styles |= im_styles->supported_styles[i] & on_the_spot_styles;
@@ -1135,7 +1135,7 @@ createXIC(Widget w, X11InputMethodData *
                         NULL);
         if (preedit == (XVaNestedList)NULL)
             goto err;
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
         /*always try XIMStatusCallbacks for active client...*/
         {
             status = (XVaNestedList)XVaCreateNestedList(0,
@@ -1157,7 +1157,7 @@ createXIC(Widget w, X11InputMethodData *
             XFree((void *)status);
             XFree((void *)preedit);
         }
-#else /* !__linux__ */
+#else /* !__linux__ && !_ALLBSD_SOURCE */
 #ifndef XAWT
         if (on_the_spot_styles & XIMStatusArea) {
             Widget parent;
@@ -1185,7 +1185,7 @@ createXIC(Widget w, X11InputMethodData *
         }
 #endif /* XAWT */
         XFree((void *)preedit);
-#endif /* __linux__ */
+#endif /* __linux__ || _ALLBSD_SOURCE */
         pX11IMData->ic_passive = XCreateIC(X11im,
                                            XNClientWindow, XtWindow(w),
                                            XNFocusWindow, XtWindow(w),
@@ -1344,7 +1344,7 @@ PreeditCaretCallback(XIC ic, XPointer cl
 
 }
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 static void
 StatusStartCallback(XIC ic, XPointer client_data, XPointer call_data)
 {
@@ -1412,7 +1412,7 @@ StatusDrawCallback(XIC ic, XPointer clie
  finally:
     AWT_UNLOCK();
 }
-#endif /*__linux__*/
+#endif /* __linux__ || _ALLBSD_SOURCE */
 
 static void CommitStringCallback(XIC ic, XPointer client_data, XPointer call_data) {
     JNIEnv *env = GetJNIEnv();
@@ -1522,14 +1522,14 @@ Java_sun_awt_motif_MInputMethod_openXIMN
 /* Use IMInstantiate call back only on Linux, as there is a bug in Solaris
    (4768335)
 */
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     registered = XRegisterIMInstantiateCallback(dpy, NULL, NULL,
                      NULL, (XIMProc)OpenXIMCallback, NULL);
     if (!registered) {
         /* directly call openXIM callback */
 #endif
         OpenXIMCallback(dpy, NULL, NULL);
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     }
 #endif
 
@@ -1593,13 +1593,13 @@ Java_sun_awt_motif_MInputMethod_createXI
 #endif /* XAWT */
     globalRef = (*env)->NewGlobalRef(env, this);
     pX11IMData->x11inputmethod = globalRef;
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     pX11IMData->statusWindow = NULL;
-#else /* __linux__ */
+#else /* !__linux__ && !_ALLBSD_SOURCE */
 #ifndef XAWT
     pX11IMData->statusWidget = (Widget) NULL;
 #endif /* XAWT */
-#endif /* __linux__ */
+#endif /* __linux__ || _ALLBSD_SOURCE */
 
     pX11IMData->lookup_buf = 0;
     pX11IMData->lookup_buf_len = 0;
@@ -1746,14 +1746,14 @@ Java_sun_awt_X11_XInputMethod_setXICFocu
         setXICFocus(pX11IMData->current_ic, req);
         currentX11InputMethodInstance = pX11IMData->x11inputmethod;
         currentFocusWindow =  XtWindow(w);
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
         if (active && pX11IMData->statusWindow && pX11IMData->statusWindow->on)
             onoffStatusWindow(pX11IMData, w, True);
 #endif
     } else {
         currentX11InputMethodInstance = NULL;
         currentFocusWindow = 0;
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
         onoffStatusWindow(pX11IMData, 0, False);
         if (pX11IMData->current_ic != NULL)
 #endif
@@ -1770,7 +1770,7 @@ JNIEXPORT void JNICALL
 Java_sun_awt_X11InputMethod_turnoffStatusWindow(JNIEnv *env,
                                                 jobject this)
 {
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     X11InputMethodData *pX11IMData;
     StatusWindow *statusWindow;
 
@@ -1867,7 +1867,7 @@ Java_sun_awt_motif_MInputMethod_configur
     X11InputMethodData *pX11IMData;
     XVaNestedList status;
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
       /*do nothing for linux? */
 #else
     AWT_LOCK();
@@ -1973,7 +1973,7 @@ JNIEXPORT jboolean JNICALL Java_sun_awt_
 JNIEXPORT void JNICALL Java_sun_awt_X11_XInputMethod_adjustStatusWindow
   (JNIEnv *env, jobject this, jlong window)
 {
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     AWT_LOCK();
     adjustStatusWindow(window);
     AWT_UNLOCK();
diff -upr ../orig/jdk/src/solaris/native/sun/awt/awt_LoadLibrary.c ./jdk/src/solaris/native/sun/awt/awt_LoadLibrary.c
--- ../orig/jdk/src/solaris/native/sun/awt/awt_LoadLibrary.c	2009-01-27 15:45:50.000000000 -0500
+++ ./jdk/src/solaris/native/sun/awt/awt_LoadLibrary.c	2009-05-04 17:37:17.000000000 -0400
@@ -260,7 +260,11 @@ AWT_OnLoad(JavaVM *vm, void *reserved)
         }
     }
 
+#ifdef __APPLE__ 
+    strcat(p, ".dylib");
+#else
     strcat(p, ".so");
+#endif
 
     JNU_CallStaticMethodByName(env, NULL, "java/lang/System", "load",
                                "(Ljava/lang/String;)V",
diff -upr ../orig/jdk/src/solaris/native/sun/awt/awt_MToolkit.c ./jdk/src/solaris/native/sun/awt/awt_MToolkit.c
--- ../orig/jdk/src/solaris/native/sun/awt/awt_MToolkit.c	2009-01-27 15:45:50.000000000 -0500
+++ ./jdk/src/solaris/native/sun/awt/awt_MToolkit.c	2009-05-04 17:37:17.000000000 -0400
@@ -63,8 +63,9 @@
 extern JavaVM *jvm;
 
 #ifndef HEADLESS
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 extern void statusWindowEventHandler(XEvent event);
+Boolean awt_dnd_process_event(XEvent* event);
 #endif
 #endif /* !HEADLESS */
 
@@ -1642,7 +1643,7 @@ processOneEvent(XtInputMask iMask) {
               */
               Widget widget=XtWindowToWidget(awt_display, xev.xany.window);
               eventNumber++;
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
               statusWindowEventHandler(xev);
 #endif
               xembed_eventHandler(&xev);
diff -upr ../orig/jdk/src/solaris/native/sun/awt/awt_Mlib.c ./jdk/src/solaris/native/sun/awt/awt_Mlib.c
--- ../orig/jdk/src/solaris/native/sun/awt/awt_Mlib.c	2009-01-27 15:45:50.000000000 -0500
+++ ./jdk/src/solaris/native/sun/awt/awt_Mlib.c	2009-05-04 17:37:17.000000000 -0400
@@ -32,6 +32,7 @@
 #include <dlfcn.h>
 #include "jni.h"
 #include <jni_util.h>
+#include "jvm_md.h"
 #include "awt_Mlib.h"
 #include "java_awt_image_BufferedImage.h"
 
@@ -67,11 +68,11 @@ mlib_status awt_getImagingLib(JNIEnv *en
         ((strncmp(name.machine, "sun4v" , 5) == 0) &&
          (getenv("USE_VIS_ON_SUN4V") != NULL)))
     {
-        handle = dlopen("libmlib_image_v.so", RTLD_LAZY);
+        handle = dlopen(JNI_LIB_NAME("mlib_image_v"), RTLD_LAZY);
     }
 
     if (handle == NULL) {
-        handle = dlopen("libmlib_image.so", RTLD_LAZY);
+        handle = dlopen(JNI_LIB_NAME("mlib_image"), RTLD_LAZY);
     }
 
     if (handle == NULL) {
diff -upr ../orig/jdk/src/solaris/native/sun/awt/awt_Robot.c ./jdk/src/solaris/native/sun/awt/awt_Robot.c
--- ../orig/jdk/src/solaris/native/sun/awt/awt_Robot.c	2009-01-27 15:45:50.000000000 -0500
+++ ./jdk/src/solaris/native/sun/awt/awt_Robot.c	2009-05-04 17:37:17.000000000 -0400
@@ -45,7 +45,7 @@
 #include "wsutils.h"
 #include "list.h"
 #include "multiVis.h"
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <sys/socket.h>
 #endif
 
diff -upr ../orig/jdk/src/solaris/native/sun/awt/awt_util.h ./jdk/src/solaris/native/sun/awt/awt_util.h
--- ../orig/jdk/src/solaris/native/sun/awt/awt_util.h	2009-01-27 15:45:50.000000000 -0500
+++ ./jdk/src/solaris/native/sun/awt/awt_util.h	2009-05-04 17:37:17.000000000 -0400
@@ -187,15 +187,20 @@ JNU_GetCharField(JNIEnv *env, jobject se
 #ifdef __solaris__
 extern Widget awt_util_getXICStatusAreaWindow(Widget w);
 #else
+#if defined(_ALLBSD_SOURCE)
+int32_t awt_util_getIMStatusHeight(Widget vw);
+Widget awt_util_getXICStatusAreaWindow(Widget w);
+#else
 int32_t awt_util_getIMStatusHeight(Widget vw);
 XVaNestedList awt_util_getXICStatusAreaList(Widget w);
 Widget awt_util_getXICStatusAreaWindow(Widget w);
 #endif
+#endif
 
 
 
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 typedef struct _XmImRefRec {
   Cardinal      num_refs;       /* Number of referencing widgets. */
   Cardinal      max_refs;       /* Maximum length of refs array. */
diff -upr ../orig/jdk/src/solaris/native/sun/awt/awt_wm.c ./jdk/src/solaris/native/sun/awt/awt_wm.c
--- ../orig/jdk/src/solaris/native/sun/awt/awt_wm.c	2009-01-27 15:45:50.000000000 -0500
+++ ./jdk/src/solaris/native/sun/awt/awt_wm.c	2009-05-04 17:37:17.000000000 -0400
@@ -121,12 +121,19 @@ static Atom XA_KWM_WIN_ICONIFIED;
 static Atom XA_KWM_WIN_MAXIMIZED;
 
 /* OpenLook */
+static Atom _XA_OL_DECOR_ADD;
 static Atom _XA_OL_DECOR_DEL;
 static Atom _XA_OL_DECOR_HEADER;
 static Atom _XA_OL_DECOR_RESIZE;
 static Atom _XA_OL_DECOR_PIN;
 static Atom _XA_OL_DECOR_CLOSE;
 
+/* AfterStep */
+static Atom _XA_AS_STYLE;
+
+/* WindowMaker */
+static Atom _XA_WINDOWMAKER_STATE;
+
 /* For _NET_WM_STATE ClientMessage requests */
 #define _NET_WM_STATE_REMOVE    0 /* remove/unset property */
 #define _NET_WM_STATE_ADD       1 /* add/set property      */
@@ -193,7 +200,12 @@ awt_wm_initAtoms(void)
         { &_XA_OL_DECOR_HEADER,              "_OL_DECOR_HEADER"              },
         { &_XA_OL_DECOR_RESIZE,              "_OL_DECOR_RESIZE"              },
         { &_XA_OL_DECOR_PIN,                 "_OL_DECOR_PIN"                 },
-        { &_XA_OL_DECOR_CLOSE,               "_OL_DECOR_CLOSE"               }
+        { &_XA_OL_DECOR_CLOSE,               "_OL_DECOR_CLOSE"               },
+	{ &_XA_OL_DECOR_ADD,		     "_OL_DECOR_ADD"		     },
+
+	{ &_XA_AS_STYLE,		     "_XA_AS_STYLE"		     },
+
+	{ &_XA_WINDOWMAKER_STATE,	     "_XA_WINDOWMAKER_STATE"	     }
     };
 #define ATOM_LIST_LENGTH (sizeof(atom_list)/sizeof(atom_list[0]))
 
@@ -942,6 +954,39 @@ awt_wm_isMotif(void)
     return True;
 }
 
+/*
+ * Window Maker.
+ */
+static Boolean
+awt_wm_isWindowmaker()
+{
+    if (awt_wm_atomInterned(&_XA_WINDOWMAKER_STATE, "_WINDOWMAKER_STATE"))
+        return True;
+    return False;
+}
+
+/*
+ * Afterstep.
+ */
+static Boolean
+awt_wm_isAfterstep()
+{
+    if (awt_wm_atomInterned(&_XA_AS_STYLE, "_AS_STYLE"))
+        return True;
+    return False;
+}
+
+/*
+ * FVWM 2.
+ */
+static Boolean
+awt_wm_isFvwm2()
+{
+    if (awt_wm_atomInterned(&_XA_OL_DECOR_ADD, "_OL_DECOR_ADD")
+        && !awt_wm_atomInterned(&_XA_OL_DECOR_PIN, "_OL_DECOR_PIN"))
+        return True;
+    return False;
+}
 
 static Boolean
 awt_wm_isNetWMName(char *name)
@@ -1280,6 +1325,12 @@ awt_wm_getRunningWM(void)
     else if (awt_wm_isKDE2()) {
         awt_wmgr = KDE2_WM;
     }
+    else if (awt_wm_isWindowmaker()) {
+	awt_wmgr = WINDOWMAKER_WM;
+    }
+    else if (awt_wm_isAfterstep()) {
+	awt_wmgr = AFTERSTEP_WM;
+    }
     /*
      * We don't check for legacy WM when we already know that WM
      * supports WIN or _NET wm spec.
@@ -1302,6 +1353,9 @@ awt_wm_getRunningWM(void)
         awt_wmgr = MOTIF_WM;
     }
     else if (awt_wm_isOpenLook()) {
+	awt_wmgr = OPENLOOK_WM;
+    }
+    else if (awt_wm_isFvwm2()) {
         awt_wmgr = OPENLOOK_WM;
     }
     else {
diff -upr ../orig/jdk/src/solaris/native/sun/awt/awt_wm.h ./jdk/src/solaris/native/sun/awt/awt_wm.h
--- ../orig/jdk/src/solaris/native/sun/awt/awt_wm.h	2009-01-27 15:45:50.000000000 -0500
+++ ./jdk/src/solaris/native/sun/awt/awt_wm.h	2009-05-04 17:37:17.000000000 -0400
@@ -45,7 +45,10 @@ enum wmgr_t {
     KDE2_WM,
     SAWFISH_WM,
     ICE_WM,
-    METACITY_WM
+    METACITY_WM,
+    AFTERSTEP_WM,
+    WINDOWMAKER_WM,
+    FVWM2_WM
 };
 
 extern void awt_wm_init(void);
diff -upr ../orig/jdk/src/solaris/native/sun/awt/extutil.h ./jdk/src/solaris/native/sun/awt/extutil.h
--- ../orig/jdk/src/solaris/native/sun/awt/extutil.h	2009-01-27 15:45:50.000000000 -0500
+++ ./jdk/src/solaris/native/sun/awt/extutil.h	2009-05-04 17:37:17.000000000 -0400
@@ -58,7 +58,7 @@ in this Software without prior written a
  */
 /* $XFree86: xc/include/extensions/extutil.h,v 1.5 2001/01/17 17:53:20 dawes Exp $ */
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 
 #ifndef _EXTUTIL_H_
 #define _EXTUTIL_H_
@@ -248,4 +248,4 @@ char *proc (Display *dpy, int code, XExt
         char *proc(Display *dpy, int code, XExtCodes *codes, char *buf, int n)
 #endif
 
-#endif /* __linux__ */
+#endif /* __linux__ || _ALLBSD_SOURCE */
diff -upr ../orig/jdk/src/solaris/native/sun/awt/fontpath.c ./jdk/src/solaris/native/sun/awt/fontpath.c
--- ../orig/jdk/src/solaris/native/sun/awt/fontpath.c	2009-01-27 15:45:50.000000000 -0500
+++ ./jdk/src/solaris/native/sun/awt/fontpath.c	2009-05-04 17:37:17.000000000 -0400
@@ -23,7 +23,7 @@
  * have any questions.
  */
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <string.h>
 #endif /* __linux__ */
 #include <stdio.h>
@@ -40,6 +40,7 @@
 
 #include <jni.h>
 #include <jni_util.h>
+#include <jvm_md.h>
 #include <sun_font_FontManager.h>
 #ifndef HEADLESS
 #include <X11/Xlib.h>
@@ -58,10 +59,24 @@
 extern Display *awt_display;
 #endif /* !HEADLESS */
 
+#ifdef __APPLE__
+// XXXDARWIN: Hard-code the path to Apple's freetype, as it is
+// not included in the dyld search path by default, and 10.4
+// does not support -rpath.
+//
+// This ignores the build time setting of ALT_FREETYPE_LIB_PATH,
+// and should be replaced with -rpath/@rpath support on 10.5 or later,
+// or via support for a the FREETYPE_LIB_PATH define.
+#define FONTCONFIG_DLL_VERSIONED X11_PATH "/lib/" VERSIONED_JNI_LIB_NAME("fontconfig", "1")
+#define FONTCONFIG_DLL X11_PATH "/lib/" JNI_LIB_NAME("fontconfig")
+#else
+#define FONTCONFIG_DLL_VERSIONED VERSIONED_JNI_LIB_NAME("fontconfig", "1")
+#define FONTCONFIG_DLL JNI_LIB_NAME("fontconfig")
+#endif
 
 #define MAXFDIRS 512    /* Max number of directories that contain fonts */
 
-#ifndef __linux__
+#if !defined(__linux__) && !defined(_ALLBSD_SOURCE)
 /*
  * This can be set in the makefile to "/usr/X11" if so desired.
  */
@@ -111,24 +126,40 @@ static char *fullSolarisFontPath[] = {
     NULL, /* terminates the list */
 };
 
+#elif _ALLBSD_SOURCE
+static char *fullBSDFontPath[] = {
+    X11_PATH "/lib/X11/fonts/TrueType",
+    X11_PATH "/lib/X11/fonts/truetype",
+    X11_PATH "/lib/X11/fonts/tt",
+    X11_PATH "/lib/X11/fonts/TTF",
+    X11_PATH "/lib/X11/fonts/OTF",
+    PACKAGE_PATH "/share/fonts/TrueType",
+    PACKAGE_PATH "/share/fonts/truetype",
+    PACKAGE_PATH "/share/fonts/tt",
+    PACKAGE_PATH "/share/fonts/TTF",
+    PACKAGE_PATH "/share/fonts/OTF",
+    X11_PATH "/lib/X11/fonts/Type1",
+    PACKAGE_PATH "/share/fonts/Type1",
+    NULL, /* terminates the list */
+};
 #else /* __linux */
 /* All the known interesting locations we have discovered on
  * various flavors of Linux
  */
 static char *fullLinuxFontPath[] = {
-    "/usr/X11R6/lib/X11/fonts/TrueType",  /* RH 7.1+ */
-    "/usr/X11R6/lib/X11/fonts/truetype",  /* SuSE */
-    "/usr/X11R6/lib/X11/fonts/tt",
-    "/usr/X11R6/lib/X11/fonts/TTF",
-    "/usr/X11R6/lib/X11/fonts/OTF",       /* RH 9.0 (but empty!) */
-    "/usr/share/fonts/ja/TrueType",       /* RH 7.2+ */
-    "/usr/share/fonts/truetype",
-    "/usr/share/fonts/ko/TrueType",       /* RH 9.0 */
-    "/usr/share/fonts/zh_CN/TrueType",    /* RH 9.0 */
-    "/usr/share/fonts/zh_TW/TrueType",    /* RH 9.0 */
+    X11_PATH "/lib/X11/fonts/TrueType",  /* RH 7.1+ */
+    X11_PATH "/lib/X11/fonts/truetype",  /* SuSE */
+    X11_PATH "/lib/X11/fonts/tt",
+    X11_PATH "/lib/X11/fonts/TTF",
+    X11_PATH "/lib/X11/fonts/OTF",       /* RH 9.0 (but empty!) */
+    PACKAGE_PATH "/share/fonts/ja/TrueType",       /* RH 7.2+ */
+    PACKAGE_PATH "/share/fonts/truetype",
+    PACKAGE_PATH "/share/fonts/ko/TrueType",       /* RH 9.0 */
+    PACKAGE_PATH "/share/fonts/zh_CN/TrueType",    /* RH 9.0 */
+    PACKAGE_PATH "/share/fonts/zh_TW/TrueType",    /* RH 9.0 */
     "/var/lib/defoma/x-ttcidfont-conf.d/dirs/TrueType", /* Debian */
-    "/usr/X11R6/lib/X11/fonts/Type1",
-    "/usr/share/fonts/default/Type1",     /* RH 9.0 */
+    X11_PATH "/lib/X11/fonts/Type1",
+    PACKAGE_PATH "/share/fonts/default/Type1",     /* RH 9.0 */
     NULL, /* terminates the list */
 };
 #endif
@@ -351,7 +382,7 @@ static char **getX11FontPath ()
 
 #endif /* !HEADLESS */
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 /* from awt_LoadLibrary.c */
 JNIEXPORT jboolean JNICALL AWTIsHeadless();
 #endif
@@ -476,8 +507,10 @@ static char *getPlatformFontPathChars(JN
      */
     fcdirs = getFontConfigLocations();
 
-#ifdef __linux__
+#if defined(__linux__)
     knowndirs = fullLinuxFontPath;
+#elif defined(_ALLBSD_SOURCE)
+    knowndirs = fullBSDFontPath;
 #else /* IF SOLARIS */
     knowndirs = fullSolarisFontPath;
 #endif
@@ -488,7 +521,8 @@ static char *getPlatformFontPathChars(JN
      * be initialised.
      */
 #ifndef HEADLESS
-#ifdef __linux__        /* There's no headless build on linux ... */
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
+    /* There's no headless build on linux ... */
     if (!AWTIsHeadless()) { /* .. so need to call a function to check */
 #endif
     AWT_LOCK();
@@ -496,7 +530,7 @@ static char *getPlatformFontPathChars(JN
         x11dirs = getX11FontPath();
     }
     AWT_UNLOCK();
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     }
 #endif
 #endif /* !HEADLESS */
@@ -608,7 +642,7 @@ Java_sun_font_FontManager_populateFontFi
 }
 
 #include <dlfcn.h>
-#ifndef __linux__ /* i.e. is solaris */
+#if !(defined(__linux__) || defined(__APPLE__))
 #include <link.h>
 #endif
 
@@ -654,9 +688,9 @@ static void* openFontConfig() {
      * certain symbols - and functionality - to be available.
      * Also add explicit search for .so.1 in case .so symlink doesn't exist.
      */
-    libfontconfig = dlopen("libfontconfig.so.1", RTLD_LOCAL|RTLD_LAZY);
+    libfontconfig = dlopen(FONTCONFIG_DLL_VERSIONED, RTLD_LOCAL|RTLD_LAZY);
     if (libfontconfig == NULL) {
-        libfontconfig = dlopen("libfontconfig.so", RTLD_LOCAL|RTLD_LAZY);
+        libfontconfig = dlopen(FONTCONFIG_DLL, RTLD_LOCAL|RTLD_LAZY);
         if (libfontconfig == NULL) {
             return NULL;
         }
diff -upr ../orig/jdk/src/solaris/native/sun/awt/gtk2_interface.c ./jdk/src/solaris/native/sun/awt/gtk2_interface.c
--- ../orig/jdk/src/solaris/native/sun/awt/gtk2_interface.c	2009-01-27 15:45:50.000000000 -0500
+++ ./jdk/src/solaris/native/sun/awt/gtk2_interface.c	2009-05-04 17:37:17.000000000 -0400
@@ -30,8 +30,9 @@
 #include <string.h>
 #include "gtk2_interface.h"
 #include "java_awt_Transparency.h"
+#include "jvm_md.h"
 
-#define GTK2_LIB "libgtk-x11-2.0.so.0"
+#define GTK2_LIB VERSIONED_JNI_LIB_NAME("gtk-x11-2.0", "0")
 
 #define G_TYPE_INVALID                  G_TYPE_MAKE_FUNDAMENTAL (0)
 #define G_TYPE_NONE                     G_TYPE_MAKE_FUNDAMENTAL (1)
diff -upr ../orig/jdk/src/solaris/native/sun/awt/list.c ./jdk/src/solaris/native/sun/awt/list.c
--- ../orig/jdk/src/solaris/native/sun/awt/list.c	2009-01-27 15:45:50.000000000 -0500
+++ ./jdk/src/solaris/native/sun/awt/list.c	2009-05-04 17:37:17.000000000 -0400
@@ -66,7 +66,11 @@ from the X Consortium.
   ----------------------------------------------------------------------- **/
 
 #include <stdio.h>
+#ifdef _ALLBSD_SOURCE
+#include <stdlib.h>
+#else
 #include <malloc.h>
+#endif
 #include "list.h"
 
 
diff -upr ../orig/jdk/src/solaris/native/sun/awt/robot_common.c ./jdk/src/solaris/native/sun/awt/robot_common.c
--- ../orig/jdk/src/solaris/native/sun/awt/robot_common.c	2009-01-27 15:45:50.000000000 -0500
+++ ./jdk/src/solaris/native/sun/awt/robot_common.c	2009-05-04 17:37:17.000000000 -0400
@@ -27,6 +27,9 @@
     #error This file should not be included in headless library
 #endif
 
+#ifdef _ALLBSD_SOURCE
+#include <stdlib.h>
+#endif
 #include "robot_common.h"
 
 /*
diff -upr ../orig/jdk/src/solaris/native/sun/font/X11FontScaler.c ./jdk/src/solaris/native/sun/font/X11FontScaler.c
--- ../orig/jdk/src/solaris/native/sun/font/X11FontScaler.c	2009-01-27 15:45:51.000000000 -0500
+++ ./jdk/src/solaris/native/sun/font/X11FontScaler.c	2009-05-04 17:37:17.000000000 -0400
@@ -32,7 +32,11 @@
  * into X11FontScaler_md.c, which is compiled into another library.
  */
 #include <stdio.h>
+#if defined(_ALLBSD_SOURCE)
+#include <stdlib.h>
+#else
 #include <malloc.h>
+#endif
 #include <ctype.h>
 #include <sys/utsname.h>
 
diff -upr ../orig/jdk/src/solaris/native/sun/font/X11TextRenderer.c ./jdk/src/solaris/native/sun/font/X11TextRenderer.c
--- ../orig/jdk/src/solaris/native/sun/font/X11TextRenderer.c	2009-01-27 15:45:51.000000000 -0500
+++ ./jdk/src/solaris/native/sun/font/X11TextRenderer.c	2009-05-04 17:37:17.000000000 -0400
@@ -39,7 +39,11 @@
 #include "GraphicsPrimitiveMgr.h"
 #include "glyphblitting.h"
 #include "sunfontids.h"
+#if defined(_ALLBSD_SOURCE)
+#include <stdlib.h>
+#else
 #include <malloc.h>
+#endif
 
 
 JNIEXPORT void JNICALL AWTDrawGlyphList
diff -upr ../orig/jdk/src/solaris/native/sun/java2d/j2d_md.h ./jdk/src/solaris/native/sun/java2d/j2d_md.h
--- ../orig/jdk/src/solaris/native/sun/java2d/j2d_md.h	2009-01-27 15:45:51.000000000 -0500
+++ ./jdk/src/solaris/native/sun/java2d/j2d_md.h	2009-05-04 17:37:17.000000000 -0400
@@ -28,11 +28,11 @@
 #include <sys/types.h>
 
 /*
- * Linux version of <sys/types.h> does not define intptr_t
+ * Linux and BSD's version of <sys/types.h> does not define intptr_t
  */
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <stdint.h>
-#endif /* __linux__ */
+#endif /* __linux__ || _ALLBSD_SOURCE */
 
 typedef unsigned char   jubyte;
 typedef unsigned short  jushort;
diff -upr ../orig/jdk/src/solaris/native/sun/java2d/loops/mlib_ImageZoom_NN.c ./jdk/src/solaris/native/sun/java2d/loops/mlib_ImageZoom_NN.c
--- ../orig/jdk/src/solaris/native/sun/java2d/loops/mlib_ImageZoom_NN.c	2009-01-27 15:45:51.000000000 -0500
+++ ./jdk/src/solaris/native/sun/java2d/loops/mlib_ImageZoom_NN.c	2009-05-04 17:37:17.000000000 -0400
@@ -66,6 +66,10 @@
  *    MLIB_EDGE_SRC_PADDED
  */
 
+#ifdef __OpenBSD__
+#include <sys/types.h>
+#endif
+#include <machine/endian.h>
 #include <mlib_image.h>
 #include <mlib_ImageZoom.h>
 
@@ -102,7 +106,7 @@ typedef union {
 
 /***************************************************************/
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 static const mlib_u32 mlib_bit_mask4[16] = {
   0x00000000u, 0xFF000000u, 0x00FF0000u, 0xFFFF0000u,
@@ -111,7 +115,7 @@ static const mlib_u32 mlib_bit_mask4[16]
   0x0000FFFFu, 0xFF00FFFFu, 0x00FFFFFFu, 0xFFFFFFFFu
 };
 
-#else /* _LITTLE_ENDIAN */
+#else /* BIG_ENDIAN */
 
 static const mlib_u32 mlib_bit_mask4[16] = {
   0x00000000u, 0x000000FFu, 0x0000FF00u, 0x0000FFFFu,
@@ -120,7 +124,7 @@ static const mlib_u32 mlib_bit_mask4[16]
   0xFFFF0000u, 0xFFFF00FFu, 0xFFFFFF00u, 0xFFFFFFFFu
 };
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* LITTLE_ENDIAN */
 
 /***************************************************************/
 
@@ -344,11 +348,11 @@ mlib_status mlib_ImageZoom_BIT_1_Nearest
 #ifdef _NO_LONGLONG
 
 typedef struct {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
   mlib_u32 uint1, uint0;
-#else /* _LITTLE_ENDIAN */
+#else /* BIG_ENDIAN */
   mlib_u32 uint0, uint1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* LITTLE_ENDIAN */
 } two_uint;
 
 /***************************************************************/
@@ -511,11 +515,11 @@ mlib_status mlib_ImageZoom_BitToGray_1_N
         DTYPE mask;
         MASK(mask);
         off *= 8;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         LSHIFT(dd_old, da[0], 64 - off);
-#else /* _LITTLE_ENDIAN */
+#else /* BIG_ENDIAN */
         RSHIFT(dd_old, da[0], 64 - off);
-#endif /* _LITTLE_ENDIAN */
+#endif /* LITTLE_ENDIAN */
 
 #ifdef __SUNPRO_C
 #pragma pipeloop(0)
@@ -540,30 +544,30 @@ mlib_status mlib_ImageZoom_BitToGray_1_N
 
           res = (res & 0xff) | (res >> 8);
           dd = gray_mask[res];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 /* *da++ = (dd_old >> (64 - off)) | (dd << off);*/
           RSHIFT(dd_old, dd_old, 64 - off);
           LSHIFT(dtmp, dd, off);
-#else /* _LITTLE_ENDIAN */
+#else /* BIG_ENDIAN */
 /* *da++ = (dd_old << (64 - off)) | (dd >> off);*/
           LSHIFT(dd_old, dd_old, 64 - off);
           RSHIFT(dtmp, dd, off);
-#endif /* _LITTLE_ENDIAN */
+#endif /* LITTLE_ENDIAN */
           LOGIC(*da++, dd_old, dtmp, |);
           dd_old = dd;
         }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 /* da[0] = (dd_old >> (64 - off)) | (da[0] & ((mlib_u64)((mlib_s64) -1) << off));*/
         LSHIFT(dtmp, mask, off);
         LOGIC(dtmp, da[0], dtmp, &);
         RSHIFT(dtmp1, dd_old, 64 - off);
-#else /* _LITTLE_ENDIAN */
+#else /* BIG_ENDIAN */
 /* da[0] = (dd_old << (64 - off)) | (da[0] & ((mlib_u64)((mlib_s64) -1) >> off));*/
         RSHIFT(dtmp, mask, off);
         LOGIC(dtmp, da[0], dtmp, &);
         LSHIFT(dtmp1, dd_old, 64 - off);
-#endif /* _LITTLE_ENDIAN */
+#endif /* LITTLE_ENDIAN */
         LOGIC(da[0], dtmp, dtmp1, |);
       }
       else {                                               /* aligned */
diff -upr ../orig/jdk/src/solaris/native/sun/java2d/loops/vis_FuncArray.c ./jdk/src/solaris/native/sun/java2d/loops/vis_FuncArray.c
--- ../orig/jdk/src/solaris/native/sun/java2d/loops/vis_FuncArray.c	2009-01-27 15:45:51.000000000 -0500
+++ ./jdk/src/solaris/native/sun/java2d/loops/vis_FuncArray.c	2009-05-04 17:37:17.000000000 -0400
@@ -794,7 +794,7 @@ static AnyFunc* hash_table_vis[HASH_SIZE
 static int initialized;
 static int usevis = JNI_TRUE;
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #   define ULTRA_CHIP   "sparc64"
 #else
 #   define ULTRA_CHIP   "sun4u"
diff -upr ../orig/jdk/src/solaris/native/sun/java2d/opengl/OGLFuncs_md.h ./jdk/src/solaris/native/sun/java2d/opengl/OGLFuncs_md.h
--- ../orig/jdk/src/solaris/native/sun/java2d/opengl/OGLFuncs_md.h	2009-01-27 15:45:51.000000000 -0500
+++ ./jdk/src/solaris/native/sun/java2d/opengl/OGLFuncs_md.h	2009-05-04 17:37:17.000000000 -0400
@@ -27,7 +27,10 @@
 #define OGLFuncs_md_h_Included
 
 #include <stdlib.h>
+#ifndef __APPLE__
 #include <link.h>
+#endif
+#include "jvm_md.h"
 #include "J2D_GL/glx.h"
 #include "OGLFuncMacros.h"
 
@@ -113,7 +116,7 @@ do { \
     { \
         char *libGLPath = getenv("J2D_ALT_LIBGL_PATH"); \
         if (libGLPath == NULL) { \
-            libGLPath = "libGL.so.1"; \
+            libGLPath = VERSIONED_JNI_LIB_NAME("GL", "1"); \
         } \
         OGL_LIB_HANDLE = dlopen(libGLPath, RTLD_LAZY | RTLD_LOCAL); \
     } \
diff -upr ../orig/jdk/src/solaris/native/sun/java2d/x11/X11SurfaceData.c ./jdk/src/solaris/native/sun/java2d/x11/X11SurfaceData.c
--- ../orig/jdk/src/solaris/native/sun/java2d/x11/X11SurfaceData.c	2009-01-27 15:45:51.000000000 -0500
+++ ./jdk/src/solaris/native/sun/java2d/x11/X11SurfaceData.c	2009-05-04 17:37:17.000000000 -0400
@@ -32,6 +32,7 @@
 #include "gdefs.h"
 
 #include "jni_util.h"
+#include "jvm_md.h"
 #include "awt_Component.h"
 #include "awt_GraphicsEnv.h"
 
@@ -128,7 +129,7 @@ Java_sun_java2d_x11_X11SurfaceData_initI
 
     if (tryDGA && (getenv("NO_J2D_DGA") == NULL)) {
     /* we use RTLD_NOW because of bug 4032715 */
-        lib = dlopen("libsunwjdga.so", RTLD_NOW);
+        lib = dlopen(JNI_LIB_NAME("sunwjdga"), RTLD_NOW);
     }
     dgaAvailable = JNI_FALSE;
     if (lib != NULL) {
diff -upr ../orig/jdk/src/solaris/native/sun/jdga/dgalock.c ./jdk/src/solaris/native/sun/jdga/dgalock.c
--- ../orig/jdk/src/solaris/native/sun/jdga/dgalock.c	2009-01-27 15:45:51.000000000 -0500
+++ ./jdk/src/solaris/native/sun/jdga/dgalock.c	2009-05-04 17:37:17.000000000 -0400
@@ -44,6 +44,7 @@
 #include <X11/Xlib.h>
 
 #include "jni.h"
+#include "jvm_md.h"
 #include "jdga.h"
 #include "jdgadevice.h"
 
@@ -84,10 +85,10 @@ Drawable GetVirtualDrawableStub(Display 
 static GetVirtualDrawableFunc * GetVirtualDrawable = GetVirtualDrawableStub;
 
 static void Solaris_DGA_XineramaInit(Display *display) {
-    void * handle = 0;
+    void * handle = NULL;
     if (IsXineramaOn == NULL) {
-        handle = dlopen("libxinerama.so", RTLD_NOW);
-        if (handle != 0) {
+        handle = dlopen(JNI_LIB_NAME("xinerama"), RTLD_NOW);
+        if (handle != NULL) {
             void *sym = dlsym(handle, "IsXineramaOn");
             IsXineramaOn = (IsXineramaOnFunc *)sym;
             if (IsXineramaOn != 0 && (*IsXineramaOn)(display)) {
diff -upr ../orig/jdk/src/solaris/native/sun/management/FileSystemImpl.c ./jdk/src/solaris/native/sun/management/FileSystemImpl.c
--- ../orig/jdk/src/solaris/native/sun/management/FileSystemImpl.c	2009-01-27 15:45:52.000000000 -0500
+++ ./jdk/src/solaris/native/sun/management/FileSystemImpl.c	2009-05-04 17:37:17.000000000 -0400
@@ -26,6 +26,10 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 
+#if defined(_ALLBSD_SOURCE)
+#include "largefile_bsd.h"
+#endif
+
 #include "jni.h"
 #include "jni_util.h"
 #include "sun_management_FileSystemImpl.h"
diff -upr ../orig/jdk/src/solaris/native/sun/net/dns/ResolverConfigurationImpl.c ./jdk/src/solaris/native/sun/net/dns/ResolverConfigurationImpl.c
--- ../orig/jdk/src/solaris/native/sun/net/dns/ResolverConfigurationImpl.c	2009-01-27 15:45:52.000000000 -0500
+++ ./jdk/src/solaris/native/sun/net/dns/ResolverConfigurationImpl.c	2009-05-04 17:37:17.000000000 -0400
@@ -33,7 +33,7 @@
 #include <strings.h>
 #endif
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <string.h>
 #endif
 
diff -upr ../orig/jdk/src/solaris/native/sun/net/spi/DefaultProxySelector.c ./jdk/src/solaris/native/sun/net/spi/DefaultProxySelector.c
--- ../orig/jdk/src/solaris/native/sun/net/spi/DefaultProxySelector.c	2009-01-27 15:45:52.000000000 -0500
+++ ./jdk/src/solaris/native/sun/net/spi/DefaultProxySelector.c	2009-05-04 17:37:17.000000000 -0400
@@ -26,11 +26,12 @@
 #include "jni.h"
 #include "jni_util.h"
 #include "jvm.h"
+#include "jvm_md.h"
 #include "jlong.h"
 #include "sun_net_spi_DefaultProxySelector.h"
 #include <dlfcn.h>
 #include <stdio.h>
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <string.h>
 #else
 #include <strings.h>
@@ -109,8 +110,9 @@ Java_sun_net_spi_DefaultProxySelector_in
   /**
    * Let's try to load le GConf-2 library
    */
-  if (dlopen("libgconf-2.so", RTLD_GLOBAL | RTLD_LAZY) != NULL ||
-      dlopen("libgconf-2.so.4", RTLD_GLOBAL | RTLD_LAZY) != NULL) {
+  if (dlopen(JNI_LIB_NAME("gconf-2"), RTLD_GLOBAL | RTLD_LAZY) != NULL ||
+      dlopen(VERSIONED_JNI_LIB_NAME("gconf-2", "4"),
+             RTLD_GLOBAL | RTLD_LAZY) != NULL) {
     gconf_ver = 2;
   }
   if (gconf_ver > 0) {
diff -upr ../orig/jdk/src/solaris/native/sun/nio/ch/DatagramChannelImpl.c ./jdk/src/solaris/native/sun/nio/ch/DatagramChannelImpl.c
--- ../orig/jdk/src/solaris/native/sun/nio/ch/DatagramChannelImpl.c	2009-01-27 15:45:52.000000000 -0500
+++ ./jdk/src/solaris/native/sun/nio/ch/DatagramChannelImpl.c	2009-05-04 17:37:17.000000000 -0400
@@ -35,7 +35,7 @@
 #include <string.h>
 #include <errno.h>
 
-#if __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <netinet/in.h>
 #endif
 
@@ -86,7 +86,7 @@ Java_sun_nio_ch_DatagramChannelImpl_disc
     rv = connect(fd, 0, 0);
 #endif
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     {
         int len;
         SOCKADDR sa;
@@ -96,17 +96,30 @@ Java_sun_nio_ch_DatagramChannelImpl_disc
 #ifdef AF_INET6
         if (ipv6_available()) {
             struct sockaddr_in6 *him6 = (struct sockaddr_in6 *)&sa;
+#if defined(_ALLBSD_SOURCE)
+	    him6->sin6_family = AF_INET6;
+#else
             him6->sin6_family = AF_UNSPEC;
+#endif
             len = sizeof(struct sockaddr_in6);
         } else
 #endif
         {
             struct sockaddr_in *him4 = (struct sockaddr_in*)&sa;
+#if defined(_ALLBSD_SOURCE)
+	    him4->sin_family = AF_INET;
+#else
             him4->sin_family = AF_UNSPEC;
+#endif
             len = sizeof(struct sockaddr_in);
         }
 
         rv = connect(fd, (struct sockaddr *)&sa, len);
+
+#if defined(_ALLBSD_SOURCE)
+	if (rv < 0 && errno == EADDRNOTAVAIL)
+		rv = errno = 0;
+#endif
     }
 #endif
 
diff -upr ../orig/jdk/src/solaris/native/sun/nio/ch/FileChannelImpl.c ./jdk/src/solaris/native/sun/nio/ch/FileChannelImpl.c
--- ../orig/jdk/src/solaris/native/sun/nio/ch/FileChannelImpl.c	2009-01-27 15:45:52.000000000 -0500
+++ ./jdk/src/solaris/native/sun/nio/ch/FileChannelImpl.c	2009-05-04 17:37:17.000000000 -0400
@@ -26,15 +26,21 @@
 #include "jni.h"
 #include "jni_util.h"
 #include "jvm.h"
+#include "jvm_md.h"
 #include "jlong.h"
 #include <sys/mman.h>
 #include <sys/stat.h>
+#include <fcntl.h>
 #include "sun_nio_ch_FileChannelImpl.h"
 #include "java_lang_Integer.h"
 #include "nio.h"
 #include "nio_util.h"
 #include <dlfcn.h>
 
+#if defined(_ALLBSD_SOURCE)
+#include "largefile_bsd.h"
+#endif
+
 static jfieldID chan_fd;        /* jobject 'fd' in sun.io.FileChannelImpl */
 
 #ifdef __solaris__
@@ -59,6 +65,10 @@ sendfile_func* my_sendfile_func = NULL;
 typedef ssize_t sendfile64_func(int out_fd, int in_fd, off64_t *offset, size_t count);
 
 sendfile64_func* my_sendfile64_func = NULL;
+#elif defined(_ALLBSD_SOURCE)
+#include <sys/socket.h>
+#include <errno.h>
+#include <stdlib.h>
 #endif
 
 JNIEXPORT jlong JNICALL
@@ -68,7 +78,8 @@ Java_sun_nio_ch_FileChannelImpl_initIDs(
     chan_fd = (*env)->GetFieldID(env, clazz, "fd", "Ljava/io/FileDescriptor;");
 
 #ifdef __solaris__
-    if (dlopen("/usr/lib/libsendfile.so.1", RTLD_GLOBAL | RTLD_LAZY) != NULL) {
+    if (dlopen("/usr/lib/" VERSIONED_JNI_LIB_NAME("sendfile", "1"),
+               RTLD_GLOBAL | RTLD_LAZY) != NULL) {
         my_sendfile_func = (sendfile_func*) dlsym(RTLD_DEFAULT, "sendfilev64");
     }
 #endif
@@ -278,6 +289,58 @@ Java_sun_nio_ch_FileChannelImpl_transfer
         return result;
     }
 #endif
+
+#ifdef _ALLBSD_SOURCE
+    /*
+     * XXXBSD: make sure that we're returning what java class may understand
+     *
+     * XXXBSD: I'd prefer to have it implemented with sendfile(), but since
+     *         FreeBSD's sendfile() is only supposed to be used in file->socket
+     *         schema we need to provide some kind of fall-back operation, if
+     *         sendfile() failed with ENOTSOCK error only.
+     */
+    void *buf;
+    off_t offset = (off_t)position;
+    int r, w = 0;
+
+    buf = malloc(4096);
+    if (buf == NULL) {
+        JNU_ThrowOutOfMemoryError(env, "heap allocation failed");
+        return IOS_THROWN;
+    }
+
+    while ((r = pread(srcFD, buf, 4096, offset)) > 0) {
+        w = write(dstFD, buf, r);
+        if (w == -1)
+	    break;
+        offset += w;
+    }
+    free(buf);
+
+    /*
+     * Similar to solaris if we've transferred any data return
+     * the number of bytes and ignore any error
+    */
+    if (offset - (off_t)position > 0)
+	return (offset - (off_t)position);
+
+    /*
+     * Deal with NBIO EAGAIN & EINTR the same as solaris. 
+     */
+    if (r == -1 || w == -1) {
+        switch (errno) {
+	    case EAGAIN:
+	        return IOS_UNAVAILABLE;
+	    case EINTR:
+	        return IOS_INTERRUPTED;
+	    default:
+		JNU_ThrowIOExceptionWithLastError(env, "Transfer failed");
+		return IOS_THROWN;
+        }
+    }
+
+    return (0);
+#endif
 }
 
 JNIEXPORT jint JNICALL
@@ -329,6 +392,23 @@ Java_sun_nio_ch_FileChannelImpl_release0
     fl.l_start = (off64_t)pos;
     fl.l_type = F_UNLCK;
     lockResult = fcntl(fd, cmd, &fl);
+#if defined(__FreeBSD__) || defined(__OpenBSD__)
+    /* XXXFREEBSD:  While doing of preClose0() we're closing actual fd which
+       was locked, so here we'll get an error which need to be ignored to
+       satisfy TCK FileLock test */
+    /* XXXFREEBSD: backport to 1.4.2 */
+    if (lockResult < 0 && errno == EBADF)
+	lockResult = errno = 0;
+#endif
+#if defined(__NetBSD__)
+    /* XXXNETBSD: The dup2 in preClose0 is being done onto 1 end of a
+       socketpair which isn't a valid target for F_UNLCK. No good way to see
+       this vs. a bad lock setup so just return errno = 0 there
+       to pass JCK (lock will get removed once all fd's close anyways) */
+    /* XXXNETBSD: backport to 1.4.2 */
+    if (lockResult < 0 && errno == EINVAL)
+	lockResult = errno = 0;
+#endif
     if (lockResult < 0) {
         JNU_ThrowIOExceptionWithLastError(env, "Release failed");
     }
diff -upr ../orig/jdk/src/solaris/native/sun/nio/ch/FileDispatcher.c ./jdk/src/solaris/native/sun/nio/ch/FileDispatcher.c
--- ../orig/jdk/src/solaris/native/sun/nio/ch/FileDispatcher.c	2009-01-27 15:45:52.000000000 -0500
+++ ./jdk/src/solaris/native/sun/nio/ch/FileDispatcher.c	2009-05-04 17:37:17.000000000 -0400
@@ -32,8 +32,12 @@
 #include <sys/socket.h>
 #include <fcntl.h>
 #include <sys/uio.h>
+#include <unistd.h>
 #include "nio_util.h"
 
+#if defined(_ALLBSD_SOURCE)
+#include "largefile_bsd.h"
+#endif
 
 static int preCloseFD = -1;     /* File descriptor to which we dup other fd's
                                    before closing them for real */
diff -upr ../orig/jdk/src/solaris/native/sun/nio/ch/FileKey.c ./jdk/src/solaris/native/sun/nio/ch/FileKey.c
--- ../orig/jdk/src/solaris/native/sun/nio/ch/FileKey.c	2009-01-27 15:45:52.000000000 -0500
+++ ./jdk/src/solaris/native/sun/nio/ch/FileKey.c	2009-05-04 17:37:17.000000000 -0400
@@ -30,6 +30,10 @@
 #include "nio_util.h"
 #include "sun_nio_ch_FileKey.h"
 
+#if defined(_ALLBSD_SOURCE)
+#include "largefile_bsd.h"
+#endif
+
 static jfieldID key_st_dev;    /* id for FileKey.st_dev */
 static jfieldID key_st_ino;    /* id for FileKey.st_ino */
 
diff -upr ../orig/jdk/src/solaris/native/sun/nio/ch/Net.c ./jdk/src/solaris/native/sun/nio/ch/Net.c
--- ../orig/jdk/src/solaris/native/sun/nio/ch/Net.c	2009-01-27 15:45:52.000000000 -0500
+++ ./jdk/src/solaris/native/sun/nio/ch/Net.c	2009-05-04 17:37:17.000000000 -0400
@@ -140,8 +140,31 @@ Java_sun_nio_ch_Net_localPort(JNIEnv *en
     SOCKADDR sa;
     int sa_len = SOCKADDR_LEN;
     if (getsockname(fdval(env, fdo), (struct sockaddr *)&sa, &sa_len) < 0) {
+#ifdef _ALLBSD_SOURCE
+ /*
+  * XXXBSD:
+  * ECONNRESET is specific to the BSDs. We can not return an error,
+  * as the calling Java code with raise a java.lang.Error given the expectation
+  * that getsockname() will never fail. According to the Single UNIX Specification,
+  * it shouldn't fail. As such, we just fill in generic Linux-compatible values.
+  */
+ if (errno == ECONNRESET) {
+     struct sockaddr_in *sin;
+     sin = (struct sockaddr_in *) &sa;
+     bzero(sin, sizeof(*sin));
+     sin->sin_len  = sizeof(struct sockaddr_in);
+     sin->sin_family = AF_INET;
+     sin->sin_port = htonl(0);
+     sin->sin_addr.s_addr = INADDR_ANY;
+ } else {
+     handleSocketError(env, errno);
+     return -1;
+ }
+#else /* _ALLBSD_SOURCE */
         handleSocketError(env, errno);
         return -1;
+#endif /* _ALLBSD_SOURCE */
+
     }
     return NET_GetPortFromSockaddr((struct sockaddr *)&sa);
 }
@@ -153,12 +176,76 @@ Java_sun_nio_ch_Net_localInetAddress(JNI
     int sa_len = SOCKADDR_LEN;
     int port;
     if (getsockname(fdval(env, fdo), (struct sockaddr *)&sa, &sa_len) < 0) {
-        handleSocketError(env, errno);
-        return NULL;
+#ifdef _ALLBSD_SOURCE
+ /*
+  * XXXBSD:
+  * ECONNRESET is specific to the BSDs. We can not return an error,
+  * as the calling Java code with raise a java.lang.Error with the expectation
+  * that getsockname() will never fail. According to the Single UNIX Specification,
+  * it shouldn't fail. As such, we just fill in generic Linux-compatible values.
+  */
+ if (errno == ECONNRESET) {
+     struct sockaddr_in *sin;
+     sin = (struct sockaddr_in *) &sa;
+     bzero(sin, sizeof(*sin));
+     sin->sin_len  = sizeof(struct sockaddr_in);
+     sin->sin_family = AF_INET;
+     sin->sin_port = htonl(0);
+     sin->sin_addr.s_addr = INADDR_ANY;
+ } else {
+     handleSocketError(env, errno);
+     return NULL;
+ }
+#else /* _ALLBSD_SOURCE */
+          handleSocketError(env, errno);
+          return NULL;
+#endif /* _ALLBSD_SOURCE */
+
     }
     return NET_SockaddrToInetAddress(env, (struct sockaddr *)&sa, &port);
 }
 
+#ifdef _ALLBSD_SOURCE
+
+#ifndef IP_BLOCK_SOURCE
+
+#define IP_ADD_SOURCE_MEMBERSHIP        70   /* join a source-specific group */
+#define IP_DROP_SOURCE_MEMBERSHIP       71   /* drop a single source */
+#define IP_BLOCK_SOURCE                 72   /* block a source */
+#define IP_UNBLOCK_SOURCE               73   /* unblock a source */
+
+#endif  /* IP_BLOCK_SOURCE */
+
+#ifndef MCAST_BLOCK_SOURCE
+
+#define MCAST_JOIN_SOURCE_GROUP         82   /* join a source-specific group */
+#define MCAST_LEAVE_SOURCE_GROUP        83   /* leave a single source */
+#define MCAST_BLOCK_SOURCE              84   /* block a source */
+#define MCAST_UNBLOCK_SOURCE            85   /* unblock a source */
+
+#endif /* MCAST_BLOCK_SOURCE */
+
+#ifndef IPV6_ADD_MEMBERSHIP
+
+#define IPV6_ADD_MEMBERSHIP	IPV6_JOIN_GROUP
+#define IPV6_DROP_MEMBERSHIP	IPV6_LEAVE_GROUP
+
+#endif /* IPV6_ADD_MEMBERSHIP */
+
+struct my_ip_mreq_source {
+        struct in_addr  imr_multiaddr;
+        struct in_addr  imr_interface;
+        struct in_addr  imr_sourceaddr;
+};
+
+struct my_group_source_req {
+        uint32_t                gsr_interface;  /* interface index */
+        struct sockaddr_storage gsr_group;      /* group address */
+        struct sockaddr_storage gsr_source;     /* source address */
+};
+
+#endif   /* _ALLBSD_SOURCE */
+
 
 #ifdef NEEDED
 
@@ -224,7 +311,7 @@ Java_sun_nio_ch_Net_getIntOption0(JNIEnv
     int result;
     struct linger linger;
     void *arg;
-    int arglen;
+    socklen_t arglen;
 
     if (NET_MapSocketOption(opt, &klevel, &kopt) < 0) {
         JNU_ThrowByNameWithLastError(env,
@@ -262,7 +349,7 @@ Java_sun_nio_ch_Net_setIntOption0(JNIEnv
     int result;
     struct linger linger;
     void *parg;
-    int arglen;
+    socklen_t arglen;
 
     if (NET_MapSocketOption(opt, &klevel, &kopt) < 0) {
         JNU_ThrowByNameWithLastError(env,
@@ -304,9 +391,11 @@ handleSocketError(JNIEnv *env, jint erro
     switch (errorValue) {
         case EINPROGRESS:       /* Non-blocking connect */
             return 0;
+#ifdef EPROTO
         case EPROTO:
             xn = JNU_JAVANETPKG "ProtocolException";
             break;
+#endif
         case ECONNREFUSED:
             xn = JNU_JAVANETPKG "ConnectException";
             break;
diff -upr ../orig/jdk/src/solaris/native/sun/security/jgss/wrapper/NativeFunc.c ./jdk/src/solaris/native/sun/security/jgss/wrapper/NativeFunc.c
--- ../orig/jdk/src/solaris/native/sun/security/jgss/wrapper/NativeFunc.c	2009-01-27 15:45:52.000000000 -0500
+++ ./jdk/src/solaris/native/sun/security/jgss/wrapper/NativeFunc.c	2009-05-04 17:37:17.000000000 -0400
@@ -26,7 +26,9 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <dlfcn.h>
+#ifndef __APPLE__
 #include <link.h>
+#endif
 #include "NativeFunc.h"
 
 /* standard GSS method names (ordering is from mapfile) */
diff -upr ../orig/jdk/src/solaris/native/sun/security/pkcs11/j2secmod_md.c ./jdk/src/solaris/native/sun/security/pkcs11/j2secmod_md.c
--- ../orig/jdk/src/solaris/native/sun/security/pkcs11/j2secmod_md.c	2009-01-27 15:45:52.000000000 -0500
+++ ./jdk/src/solaris/native/sun/security/pkcs11/j2secmod_md.c	2009-05-04 17:37:17.000000000 -0400
@@ -28,12 +28,19 @@
 #include <string.h>
 
 #include <dlfcn.h>
+#ifndef __APPLE__
 #include <link.h>
+#endif
 
 #include <jni_util.h>
 
 #include "j2secmod.h"
 
+#ifndef RTLD_NOLOAD
+/* A gross hack that will work if the NSS library is only opened once */
+static void *nssLibHandle = NULL;
+#endif
+
 void *findFunction(JNIEnv *env, jlong jHandle, const char *functionName) {
     void *hModule = (void*)jHandle;
     void *fAddress = dlsym(hModule, functionName);
@@ -51,7 +58,11 @@ JNIEXPORT jlong JNICALL Java_sun_securit
 {
     const char *libName = (*env)->GetStringUTFChars(env, jLibName, NULL);
     // look up existing handle only, do not load
+#ifdef RTLD_NOLOAD
     void *hModule = dlopen(libName, RTLD_NOLOAD);
+#else
+    void *hModule = nssLibHandle;
+#endif
     dprintf2("-handle for %s: %u\n", libName, hModule);
     (*env)->ReleaseStringUTFChars(env, jLibName, libName);
     return (jlong)hModule;
@@ -65,6 +76,9 @@ JNIEXPORT jlong JNICALL Java_sun_securit
 
     dprintf1("-lib %s\n", libName);
     hModule = dlopen(libName, RTLD_LAZY);
+#ifndef RTLD_NOLOAD
+    nssLibHandle = hModule;
+#endif
     (*env)->ReleaseStringUTFChars(env, jLibName, libName);
     dprintf2("-handle: %u (0X%X)\n", hModule, hModule);
 
diff -upr ../orig/jdk/src/solaris/native/sun/security/pkcs11/wrapper/p11_md.c ./jdk/src/solaris/native/sun/security/pkcs11/wrapper/p11_md.c
--- ../orig/jdk/src/solaris/native/sun/security/pkcs11/wrapper/p11_md.c	2009-01-27 15:45:52.000000000 -0500
+++ ./jdk/src/solaris/native/sun/security/pkcs11/wrapper/p11_md.c	2009-05-04 17:37:17.000000000 -0400
@@ -64,7 +64,9 @@
 #include <assert.h>
 
 #include <dlfcn.h>
+#ifndef __APPLE__
 #include <link.h>
+#endif
 
 #include <jni.h>
 
diff -upr ../orig/jdk/src/solaris/native/sun/security/smartcardio/pcsc_md.c ./jdk/src/solaris/native/sun/security/smartcardio/pcsc_md.c
--- ../orig/jdk/src/solaris/native/sun/security/smartcardio/pcsc_md.c	2009-01-27 15:45:52.000000000 -0500
+++ ./jdk/src/solaris/native/sun/security/smartcardio/pcsc_md.c	2009-05-04 17:37:17.000000000 -0400
@@ -29,7 +29,9 @@
 #include <assert.h>
 
 #include <dlfcn.h>
+#ifndef __APPLE__
 #include <link.h>
+#endif
 
 #include <winscard.h>
 
diff -upr ../orig/jdk/src/solaris/native/sun/tools/attach/BsdVirtualMachine.c ./jdk/src/solaris/native/sun/tools/attach/BsdVirtualMachine.c
--- ../orig/jdk/src/solaris/native/sun/tools/attach/BsdVirtualMachine.c	2009-05-04 18:32:16.000000000 -0400
+++ ./jdk/src/solaris/native/sun/tools/attach/BsdVirtualMachine.c	2009-05-04 17:37:15.000000000 -0400
@@ -1,461 +1,3 @@
 /*
- * Copyright 2005 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
+ * Dummy file - needs to be implemented for bsd
  */
-
-#include "jni.h"
-#include "jni_util.h"
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <errno.h>
-#include <unistd.h>
-#include <signal.h>
-#include <dirent.h>
-#include <ctype.h>
-#include <sys/types.h>
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <sys/stat.h>
-#include <sys/un.h>
-
-#include "sun_tools_attach_BsdVirtualMachine.h"
-
-#define RESTARTABLE(_cmd, _result) do { \
-  do { \
-    _result = _cmd; \
-  } while((_result == -1) && (errno == EINTR)); \
-} while(0)
-
-/*
- * Defines a callback that is invoked for each process
- */
-typedef void (*ProcessCallback)(const pid_t pid, void* user_data);
-
-/*
- * Invokes the callback function for each process
- */
-static void forEachProcess(ProcessCallback f, void* user_data) {
-    DIR* dir;
-    struct dirent* ptr;
-
-    /*
-     * To locate the children we scan /proc looking for files that have a
-     * position integer as a filename.
-     */
-    if ((dir = opendir("/proc")) == NULL) {
-        return;
-    }
-    while ((ptr = readdir(dir)) != NULL) {
-        pid_t pid;
-
-        /* skip current/parent directories */
-        if (strcmp(ptr->d_name, ".") == 0 || strcmp(ptr->d_name, "..") == 0) {
-            continue;
-        }
-
-        /* skip files that aren't numbers */
-        pid = (pid_t)atoi(ptr->d_name);
-        if ((int)pid <= 0) {
-            continue;
-        }
-
-        /* invoke the callback */
-        (*f)(pid, user_data);
-    }
-    closedir(dir);
-}
-
-
-/*
- * Returns the parent pid of a given pid, or -1 if not found
- */
-static pid_t getParent(pid_t pid) {
-    char state;
-    FILE* fp;
-    char stat[2048];
-    int statlen;
-    char fn[32];
-    int i, p;
-    char* s;
-
-    /*
-     * try to open /proc/%d/stat
-     */
-    sprintf(fn, "/proc/%d/stat", pid);
-    fp = fopen(fn, "r");
-    if (fp == NULL) {
-        return -1;
-    }
-
-    /*
-     * The format is: pid (command) state ppid ...
-     * As the command could be anything we must find the right most
-     * ")" and then skip the white spaces that follow it.
-     */
-    statlen = fread(stat, 1, 2047, fp);
-    stat[statlen] = '\0';
-    fclose(fp);
-    s = strrchr(stat, ')');
-    if (s == NULL) {
-        return -1;
-    }
-    do s++; while (isspace(*s));
-    i = sscanf(s, "%c %d", &state, &p);
-    return (pid_t)p;
-}
-
-
-/*
- * Class:     sun_tools_attach_BsdVirtualMachine
- * Method:    socket
- * Signature: ()I
- */
-JNIEXPORT jint JNICALL Java_sun_tools_attach_BsdVirtualMachine_socket
-  (JNIEnv *env, jclass cls)
-{
-    int fd = socket(PF_UNIX, SOCK_STREAM, 0);
-    if (fd == -1) {
-        JNU_ThrowIOExceptionWithLastError(env, "socket");
-    }
-    return (jint)fd;
-}
-
-/*
- * Class:     sun_tools_attach_BsdVirtualMachine
- * Method:    connect
- * Signature: (ILjava/lang/String;)I
- */
-JNIEXPORT void JNICALL Java_sun_tools_attach_BsdVirtualMachine_connect
-  (JNIEnv *env, jclass cls, jint fd, jstring path)
-{
-    jboolean isCopy;
-    const char* p = GetStringPlatformChars(env, path, &isCopy);
-    if (p != NULL) {
-        struct sockaddr_un addr;
-        int err = 0;
-
-        addr.sun_family = AF_UNIX;
-        strcpy(addr.sun_path, p);
-
-        if (connect(fd, (struct sockaddr*)&addr, sizeof(addr)) == -1) {
-            err = errno;
-        }
-
-        if (isCopy) {
-            JNU_ReleaseStringPlatformChars(env, path, p);
-        }
-
-        /*
-         * If the connect failed then we throw the appropriate exception
-         * here (can't throw it before releasing the string as can't call
-         * JNI with pending exception)
-         */
-        if (err != 0) {
-            if (err == ENOENT) {
-                JNU_ThrowByName(env, "java/io/FileNotFoundException", NULL);
-            } else {
-                char* msg = strdup(strerror(err));
-                JNU_ThrowIOException(env, msg);
-                if (msg != NULL) {
-                    free(msg);
-                }
-            }
-        }
-    }
-}
-
-/*
- * Class:     sun_tools_attach_BsdVirtualMachine
- * Method:    isBsdThreads
- * Signature: ()V
- */
-JNIEXPORT jboolean JNICALL Java_sun_tools_attach_BsdVirtualMachine_isBsdThreads
-  (JNIEnv *env, jclass cls)
-{
-# ifndef _CS_GNU_LIBPTHREAD_VERSION
-# define _CS_GNU_LIBPTHREAD_VERSION 3
-# endif
-    size_t n;
-    char* s;
-    jboolean res;
-
-    n = confstr(_CS_GNU_LIBPTHREAD_VERSION, NULL, 0);
-    if (n <= 0) {
-       /* glibc before 2.3.2 only has BsdThreads */
-       return JNI_TRUE;
-    }
-
-    s = (char *)malloc(n);
-    if (s == NULL) {
-        JNU_ThrowOutOfMemoryError(env, "malloc failed");
-        return JNI_TRUE;
-    }
-    confstr(_CS_GNU_LIBPTHREAD_VERSION, s, n);
-
-    /*
-     * If the LIBPTHREAD version include "NPTL" then we know we
-     * have the new threads library and not BsdThreads
-     */
-    res = (jboolean)(strstr(s, "NPTL") == NULL);
-    free(s);
-    return res;
-}
-
-/*
- * Structure and callback function used to count the children of
- * a given process, and record the pid of the "manager thread".
- */
-typedef struct {
-    pid_t ppid;
-    int count;
-    pid_t mpid;
-} ChildCountContext;
-
-static void ChildCountCallback(const pid_t pid, void* user_data) {
-    ChildCountContext* context = (ChildCountContext*)user_data;
-    if (getParent(pid) == context->ppid) {
-        context->count++;
-        /*
-         * Remember the pid of the first child. If the final count is
-         * one then this is the pid of the BsdThreads manager.
-         */
-        if (context->count == 1) {
-            context->mpid = pid;
-        }
-    }
-}
-
-/*
- * Class:     sun_tools_attach_BsdVirtualMachine
- * Method:    getBsdThreadsManager
- * Signature: (I)I
- */
-JNIEXPORT jint JNICALL Java_sun_tools_attach_BsdVirtualMachine_getBsdThreadsManager
-  (JNIEnv *env, jclass cls, jint pid)
-{
-    ChildCountContext context;
-
-    /*
-     * Iterate over all processes to find how many children 'pid' has
-     */
-    context.ppid = pid;
-    context.count = 0;
-    context.mpid = (pid_t)0;
-    forEachProcess(ChildCountCallback, (void*)&context);
-
-    /*
-     * If there's no children then this is likely the pid of the primordial
-     * created by the launcher - in that case the BsdThreads manager is the
-     * parent of this process.
-     */
-    if (context.count == 0) {
-        pid_t parent = getParent(pid);
-        if ((int)parent > 0) {
-            return (jint)parent;
-        }
-    }
-
-    /*
-     * There's one child so this is likely the embedded VM case where the
-     * the primordial thread == BsdThreads initial thread. The BsdThreads
-     * manager in that case is the child.
-     */
-    if (context.count == 1) {
-        return (jint)context.mpid;
-    }
-
-    /*
-     * If we get here it's most likely we were given the wrong pid
-     */
-    JNU_ThrowIOException(env, "Unable to get pid of BsdThreads manager thread");
-    return -1;
-}
-
-/*
- * Structure and callback function used to send a QUIT signal to all
- * children of a given process
- */
-typedef struct {
-    pid_t ppid;
-} SendQuitContext;
-
-static void SendQuitCallback(const pid_t pid, void* user_data) {
-    SendQuitContext* context = (SendQuitContext*)user_data;
-    pid_t parent = getParent(pid);
-    if (parent == context->ppid) {
-        kill(pid, SIGQUIT);
-    }
-}
-
-/*
- * Class:     sun_tools_attach_BsdVirtualMachine
- * Method:    sendQuitToChildrenOf
- * Signature: (I)V
- */
-JNIEXPORT void JNICALL Java_sun_tools_attach_BsdVirtualMachine_sendQuitToChildrenOf
-  (JNIEnv *env, jclass cls, jint pid)
-{
-    SendQuitContext context;
-    context.ppid = (pid_t)pid;
-
-    /*
-     * Iterate over all children of 'pid' and send a QUIT signal to each.
-     */
-    forEachProcess(SendQuitCallback, (void*)&context);
-}
-
-/*
- * Class:     sun_tools_attach_BsdVirtualMachine
- * Method:    sendQuitTo
- * Signature: (I)V
- */
-JNIEXPORT void JNICALL Java_sun_tools_attach_BsdVirtualMachine_sendQuitTo
-  (JNIEnv *env, jclass cls, jint pid)
-{
-    if (kill((pid_t)pid, SIGQUIT)) {
-        JNU_ThrowIOExceptionWithLastError(env, "kill");
-    }
-}
-
-/*
- * Class:     sun_tools_attach_BsdVirtualMachine
- * Method:    checkPermissions
- * Signature: (Ljava/lang/String;)V
- */
-JNIEXPORT void JNICALL Java_sun_tools_attach_BsdVirtualMachine_checkPermissions
-  (JNIEnv *env, jclass cls, jstring path)
-{
-    jboolean isCopy;
-    const char* p = GetStringPlatformChars(env, path, &isCopy);
-    if (p != NULL) {
-        struct stat64 sb;
-        uid_t uid, gid;
-        int res;
-
-        /*
-         * Check that the path is owned by the effective uid/gid of this
-         * process. Also check that group/other access is not allowed.
-         */
-        uid = geteuid();
-        gid = getegid();
-
-        res = stat64(p, &sb);
-        if (res != 0) {
-            /* save errno */
-            res = errno;
-        }
-
-        /* release p here before we throw an I/O exception */
-        if (isCopy) {
-            JNU_ReleaseStringPlatformChars(env, path, p);
-        }
-
-        if (res == 0) {
-            if ( (sb.st_uid != uid) || (sb.st_gid != gid) ||
-                 ((sb.st_mode & (S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH)) != 0) ) {
-                JNU_ThrowIOException(env, "well-known file is not secure");
-            }
-        } else {
-            char* msg = strdup(strerror(res));
-            JNU_ThrowIOException(env, msg);
-            if (msg != NULL) {
-                free(msg);
-            }
-        }
-    }
-}
-
-/*
- * Class:     sun_tools_attach_BsdVirtualMachine
- * Method:    close
- * Signature: (I)V
- */
-JNIEXPORT void JNICALL Java_sun_tools_attach_BsdVirtualMachine_close
-  (JNIEnv *env, jclass cls, jint fd)
-{
-    int res;
-    RESTARTABLE(close(fd), res);
-}
-
-/*
- * Class:     sun_tools_attach_BsdVirtualMachine
- * Method:    read
- * Signature: (I[BI)I
- */
-JNIEXPORT jint JNICALL Java_sun_tools_attach_BsdVirtualMachine_read
-  (JNIEnv *env, jclass cls, jint fd, jbyteArray ba, jint off, jint baLen)
-{
-    unsigned char buf[128];
-    size_t len = sizeof(buf);
-    ssize_t n;
-
-    size_t remaining = (size_t)(baLen - off);
-    if (len > remaining) {
-        len = remaining;
-    }
-
-    RESTARTABLE(read(fd, buf+off, len), n);
-    if (n == -1) {
-        JNU_ThrowIOExceptionWithLastError(env, "read");
-    } else {
-        if (n == 0) {
-            n = -1;     // EOF
-        } else {
-            (*env)->SetByteArrayRegion(env, ba, off, (jint)n, (jbyte *)(buf+off));
-        }
-    }
-    return n;
-}
-
-/*
- * Class:     sun_tools_attach_BsdVirtualMachine
- * Method:    write
- * Signature: (I[B)V
- */
-JNIEXPORT void JNICALL Java_sun_tools_attach_BsdVirtualMachine_write
-  (JNIEnv *env, jclass cls, jint fd, jbyteArray ba, jint off, jint bufLen)
-{
-    size_t remaining = bufLen;
-    do {
-        unsigned char buf[128];
-        size_t len = sizeof(buf);
-        int n;
-
-        if (len > remaining) {
-            len = remaining;
-        }
-        (*env)->GetByteArrayRegion(env, ba, off, len, (jbyte *)buf);
-
-        RESTARTABLE(write(fd, buf, len), n);
-        if (n > 0) {
-           off += n;
-           remaining -= n;
-        } else {
-            JNU_ThrowIOExceptionWithLastError(env, "write");
-            return;
-        }
-
-    } while (remaining > 0);
-}
diff -upr ../orig/jdk/src/solaris/native/sun/xawt/XWindow.c ./jdk/src/solaris/native/sun/xawt/XWindow.c
--- ../orig/jdk/src/solaris/native/sun/xawt/XWindow.c	2009-01-27 15:45:52.000000000 -0500
+++ ./jdk/src/solaris/native/sun/xawt/XWindow.c	2009-05-04 17:37:17.000000000 -0400
@@ -228,10 +228,10 @@ KeymapEntry keymapTable[] =
     {java_awt_event_KeyEvent_VK_DOWN, XK_Down, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
 
     /* Keypad equivalents of Triangular Navigation Block */
-    {java_awt_event_KeyEvent_VK_KP_LEFT, XK_KP_Left, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
-    {java_awt_event_KeyEvent_VK_KP_UP, XK_KP_Up, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
-    {java_awt_event_KeyEvent_VK_KP_RIGHT, XK_KP_Right, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
-    {java_awt_event_KeyEvent_VK_KP_DOWN, XK_KP_Down, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
+    {java_awt_event_KeyEvent_VK_LEFT, XK_KP_Left, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
+    {java_awt_event_KeyEvent_VK_UP, XK_KP_Up, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
+    {java_awt_event_KeyEvent_VK_RIGHT, XK_KP_Right, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
+    {java_awt_event_KeyEvent_VK_DOWN, XK_KP_Down, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
 
     /* Other vendor-specific Triangular Navigation Block */
     {java_awt_event_KeyEvent_VK_LEFT, osfXK_Left, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
@@ -865,7 +865,7 @@ handleKeyEventWithNumLockMask(XEvent *ev
 {
     KeySym originalKeysym = *keysym;
 
-#ifndef __linux__
+#if !defined(__linux__) && !defined(_ALLBSD_SOURCE)
     /* The following code on Linux will cause the keypad keys
      * not to echo on JTextField when the NumLock is on. The
      * keysyms will be 0, because the last parameter 2 is not defined.
diff -upr ../orig/jdk/src/solaris/native/sun/xawt/awt_Desktop.c ./jdk/src/solaris/native/sun/xawt/awt_Desktop.c
--- ../orig/jdk/src/solaris/native/sun/xawt/awt_Desktop.c	2009-01-27 15:45:52.000000000 -0500
+++ ./jdk/src/solaris/native/sun/xawt/awt_Desktop.c	2009-05-04 17:37:17.000000000 -0400
@@ -24,6 +24,7 @@
  */
 
 #include <jni.h>
+#include <jvm_md.h>
 #include <dlfcn.h>
 
 typedef int gboolean;
@@ -36,7 +37,7 @@ int init(){
     gboolean (*gnome_vfs_init) (void);
     const char *errmsg;
 
-    vfs_handle = dlopen("libgnomevfs-2.so.0", RTLD_LAZY);
+    vfs_handle = dlopen(VERSIONED_JNI_LIB_NAME("gnomevfs-2", "0"), RTLD_LAZY);
     if (vfs_handle == NULL) {
 #ifdef INTERNAL_BUILD
         fprintf(stderr, "can not load libgnomevfs-2.so\n");
@@ -54,7 +55,7 @@ int init(){
     // call gonme_vfs_init()
     (*gnome_vfs_init)();
 
-    gnome_handle = dlopen("libgnome-2.so.0", RTLD_LAZY);
+    gnome_handle = dlopen(VERSIONED_JNI_LIB_NAME("gnome-2", "0"), RTLD_LAZY);
     if (gnome_handle == NULL) {
 #ifdef INTERNAL_BUILD
         fprintf(stderr, "can not load libgnome-2.so\n");
diff -upr ../orig/jdk/src/solaris/npt/npt_md.h ./jdk/src/solaris/npt/npt_md.h
--- ../orig/jdk/src/solaris/npt/npt_md.h	2009-01-27 15:45:52.000000000 -0500
+++ ./jdk/src/solaris/npt/npt_md.h	2009-05-04 17:37:17.000000000 -0400
@@ -32,9 +32,10 @@
 #include <string.h>
 #include <errno.h>
 #include <dlfcn.h>
+#ifndef __APPLE__
 #include <link.h>
-
-#define NPT_LIBNAME "libnpt.so"
+#endif
+#include <jvm_md.h>
 
 #define NPT_INITIALIZE(pnpt,version,options)                            \
     {                                                                   \
@@ -43,7 +44,7 @@
                                                                         \
         if ( (pnpt) == NULL ) NPT_ERROR("NptEnv* is NULL");             \
         *(pnpt) = NULL;                                                 \
-        _handle =  dlopen(NPT_LIBNAME, RTLD_LAZY);                      \
+        _handle =  dlopen(JNI_LIB_NAME("npt"), RTLD_LAZY);              \
         if ( _handle == NULL ) NPT_ERROR("Cannot open library");        \
         _sym = dlsym(_handle, "nptInitialize");                         \
         if ( _sym == NULL ) NPT_ERROR("Cannot find nptInitialize");     \
diff -upr ../orig/jdk/src/solaris/transport/socket/socket_md.c ./jdk/src/solaris/transport/socket/socket_md.c
--- ../orig/jdk/src/solaris/transport/socket/socket_md.c	2009-01-27 15:45:52.000000000 -0500
+++ ./jdk/src/solaris/transport/socket/socket_md.c	2009-05-04 17:37:17.000000000 -0400
@@ -36,7 +36,7 @@
 #ifdef __solaris__
 #include <thread.h>
 #endif
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <pthread.h>
 #include <sys/poll.h>
 #endif
@@ -283,7 +283,7 @@ dbgsysTlsGet(int index) {
 
 #endif
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 int
 dbgsysTlsAlloc() {
     pthread_key_t key;
diff -upr ../orig/langtools/src/share/classes/com/sun/tools/javah/Util.java ./langtools/src/share/classes/com/sun/tools/javah/Util.java
--- ../orig/langtools/src/share/classes/com/sun/tools/javah/Util.java	2009-01-27 15:46:42.000000000 -0500
+++ ./langtools/src/share/classes/com/sun/tools/javah/Util.java	2009-05-04 17:37:17.000000000 -0400
@@ -180,6 +180,14 @@ public class Util {
             os = "win32";
         } else if (os.indexOf("Linux") >= 0) {
             os = "Linux";
+	} else if (os.indexOf("FreeBSD") >= 0) {
+	    os = "FreeBSD";
+	} else if (os.indexOf("Darwin") >= 0) {
+	    os = "Darwin";
+	} else if (os.indexOf("NetBSD") >= 0) {
+	    os = "NetBSD";
+	} else if (os.indexOf("OpenBSD") >= 0) {
+	    os = "OpenBSD";
         }
         String arch = System.getProperty("os.arch");
         String resname = "com.sun.tools.javah.resources." + os + "_" + arch;
