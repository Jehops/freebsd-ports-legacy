--- ./.hgtags	Thu Dec 19 09:00:36 2013 -0800
+++ ./.hgtags	Tue Mar 18 12:29:21 2014 -0700
@@ -378,6 +378,9 @@
 f0cdb08a4624a623bdd178b04c4bf5a2fa4dc39a jdk7u45-b18
 82f1f76c44124c31cb1151833fc15c13547ab280 jdk7u45-b30
 f4373de4b75ba8d7f7a5d9c1f77e7884d9064b7e jdk7u45-b31
+b73c006b5d81528dfb4104a79b994b56675bf75d jdk7u45-b33
+05742477836cb30235328181c8e6cae5d4bb06fd jdk7u45-b34
+d0d5badd77abce0469830466ff7b910d3621d847 jdk7u45-b35
 f2479abad143d2d9f33b6c872890ca0c5dd52530 jdk7u51-b00
 c5822e1d1baa9625ee4e54b8e83a9bf529c883fc jdk7u51-b01
 f750621fb31b8f6462b803b47bbf84f05cd5174a jdk7u51-b02
@@ -392,3 +395,22 @@
 573c4cfca7dda548463bb84330bddfd07fe1183f jdk7u51-b11
 df53ec7eb789e7dec375a685dce1fa5cf63618b4 jdk7u51-b12
 6c778574d87336a2e55156544af92ce2de799696 jdk7u51-b13
+d2eeac0235eda77d0a6c72c7235a6e96bc9ad4fb jdk7u51-b30
+626e76f127a44ba0118a545d37410f80000db8fb jdk7u51-b31
+472d67871307433bf3e2687c48237c48ffbf068e jdk7u51-b33
+503f1d094a1bbbd94386f5c3342130dc5f4ba6ee jdk7u51-b34
+df53ec7eb789e7dec375a685dce1fa5cf63618b4 jdk7u55-b00
+15bc13cd7f5d0bb06ab59935e25944fa7cb15bc8 jdk7u55-b01
+b829c5947c6cd473f42cadfe2c61399fb67c2da6 jdk7u55-b02
+a72b902cdd39d9f2f2d353d5ad629e543cbc01ae jdk7u55-b03
+6a8ee38075621564dd276e8ed7be576d637acf79 jdk7u55-b04
+92ac508efb9e00d88b04a2bd79ab8a55f450a048 jdk7u55-b05
+6c7cd2146f69cf0823765b3cf84c338c1dc7157c jdk7u55-b06
+5cad0f56c685a0673944dbc5632ea9ae7b9340c7 jdk7u55-b07
+f617c33f98e1941875457c5c227198c52917942e jdk7u55-b08
+1f02b1889f7098c1e6fdd271ef74c62a2e346b28 jdk7u55-b09
+736c951b19b9562830f61d5ebbad78775f200e94 jdk7u55-b09
+2a55bbab15f6c866281003dcf48708a9d8c145e9 jdk7u55-b10
+f4ace62029de00d2497058c3c0e1d26e019cde30 jdk7u55-b11
+de268da51b54a4f36bcc1a9af60faea285e94330 jdk7u55-b12
+d972a2d9e4f3f864d26c33ccfdacd8269e0f29a8 jdk7u55-b13
--- ./corba/.hgtags	Thu Dec 19 09:00:44 2013 -0800
+++ ./corba/.hgtags	Tue Mar 18 12:29:47 2014 -0700
@@ -381,6 +381,9 @@
 80f65a8f58500ef5d93ddf4426d9c1909b79fadf jdk7u45-b18
 a15e4a54504471f1e34a494ed66235870722a0f5 jdk7u45-b30
 b7fb35bbe70d88eced3725b6e9070ad0b5b621ad jdk7u45-b31
+d641ac83157ec86219519c0cbaf3122bdc997136 jdk7u45-b33
+aa24e046a2da95637257c9effeaabe254db0aa0b jdk7u45-b34
+fab1423e6ab8ecf36da8b6bf2e454156ec701e8a jdk7u45-b35
 b1f069eb48edfa6fb7428dc045a53e287215ef4a jdk7u51-b00
 8d884cf2e8cce92d532950de2c7283d9804f9e58 jdk7u51-b01
 327035fbb0433927c1b1af2bc0bcb84e7827f1b9 jdk7u51-b02
@@ -395,3 +398,22 @@
 a26d0e8ab1027e70ae1ded8ede0086a0a4a10256 jdk7u51-b11
 55a509ccc0e4ed49e311c7ecf2ed29a908bc1d6b jdk7u51-b12
 e2f0036f712aa636cfd55334ac21ea7ca2587a7b jdk7u51-b13
+6563d12c48c92af39a27ca46b4515fad8e994667 jdk7u51-b30
+0ad990211737fe1b1e2737a3498ab266146d2c53 jdk7u51-b31
+ee7d9f5d18fb67564e88a10f1bd682660db60aa2 jdk7u51-b33
+65ef96a075a43e9201866d1c9b8ee3138ebcc424 jdk7u51-b34
+55a509ccc0e4ed49e311c7ecf2ed29a908bc1d6b jdk7u55-b00
+aabfdc799c0799837dcbbf9ea8d6df1511978b1f jdk7u55-b01
+db2e6d87bade9d2061646ff9a6b39b5159fba0ec jdk7u55-b02
+02ff18f156bd3382fe22e4758b138370f5238e97 jdk7u55-b03
+6a88a170331fb38af5046e54bf75f38176af5c41 jdk7u55-b04
+a8d27c3fc4e4e6cd99fa164f04c30a71f474a2d6 jdk7u55-b05
+af7f1808106bf4e9b4680d943677299829245d08 jdk7u55-b06
+44801796d42bebc90e8c4c7fb5bd79db04b10b75 jdk7u55-b07
+aa98fb8dc3608a30ac593635b21aca2105aaab20 jdk7u55-b08
+2a4842e7ca0b2228017542cea0fed3b8d4f4491a jdk7u55-b09
+5805c3291eb3a82cd75e95ac06eb13daa7f92866 jdk7u55-b09
+b9dae31c56a2bf69fc5932cc490cd80fccc1e0fd jdk7u55-b10
+cbd5b4b07e0c8a5f61eff396b7622e7b04d2a164 jdk7u55-b11
+3cce2a49d18d93dfca2634db32368486ebbb1590 jdk7u55-b12
+8efa6e66c13a5329c312d1a521ffab75d9a330e3 jdk7u55-b13
--- ./corba/src/share/classes/com/sun/corba/se/impl/io/ObjectStreamClass.java	Thu Dec 19 09:00:44 2013 -0800
+++ ./corba/src/share/classes/com/sun/corba/se/impl/io/ObjectStreamClass.java	Tue Mar 18 12:29:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1998, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -52,6 +52,7 @@
 import java.io.DataOutputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.InvalidClassException;
+import java.io.Externalizable;
 import java.io.Serializable;
 
 import java.util.Arrays;
@@ -82,15 +83,15 @@
     public static final long kDefaultUID = -1;
 
     private static Object noArgsList[] = {};
-    private static Class noTypesList[] = {};
+    private static Class<?> noTypesList[] = {};
 
     /** true if represents enum type */
     private boolean isEnum;
 
     private static final Bridge bridge =
-        (Bridge)AccessController.doPrivileged(
-            new PrivilegedAction() {
-                public Object run() {
+        AccessController.doPrivileged(
+            new PrivilegedAction<Bridge>() {
+                public Bridge run() {
                     return Bridge.get() ;
                 }
             }
@@ -100,7 +101,7 @@
      * is returned if the specified class does not implement
      * java.io.Serializable or java.io.Externalizable.
      */
-    static final ObjectStreamClass lookup(Class cl)
+    static final ObjectStreamClass lookup(Class<?> cl)
     {
         ObjectStreamClass desc = lookupInternal(cl);
         if (desc.isSerializable() || desc.isExternalizable())
@@ -112,7 +113,7 @@
      * Find the class descriptor for the specified class.
      * Package access only so it can be called from ObjectIn/OutStream.
      */
-    static ObjectStreamClass lookupInternal(Class cl)
+    static ObjectStreamClass lookupInternal(Class<?> cl)
     {
         /* Synchronize on the hashtable so no two threads will do
          * this at the same time.
@@ -123,14 +124,14 @@
             desc = findDescriptorFor(cl);
             if (desc == null) {
                 /* Check if it's serializable */
-                boolean serializable = classSerializable.isAssignableFrom(cl);
+                boolean serializable = Serializable.class.isAssignableFrom(cl);
 
                 /* If the class is only Serializable,
                  * lookup the descriptor for the superclass.
                  */
                 ObjectStreamClass superdesc = null;
                 if (serializable) {
-                    Class superclass = cl.getSuperclass();
+                    Class<?> superclass = cl.getSuperclass();
                     if (superclass != null)
                         superdesc = lookup(superclass);
                 }
@@ -143,7 +144,7 @@
                 if (serializable) {
                     externalizable =
                         ((superdesc != null) && superdesc.isExternalizable()) ||
-                        classExternalizable.isAssignableFrom(cl);
+                        Externalizable.class.isAssignableFrom(cl);
                     if (externalizable) {
                         serializable = false;
                     }
@@ -187,7 +188,7 @@
      * that have evolved from a common root class and agree to be serialized
      * and deserialized using a common format.
      */
-    public static final long getSerialVersionUID( java.lang.Class clazz) {
+    public static final long getSerialVersionUID( java.lang.Class<?> clazz) {
         ObjectStreamClass theosc = ObjectStreamClass.lookup( clazz );
         if( theosc != null )
         {
@@ -221,7 +222,7 @@
     /**
      * Return the actual (computed) serialVersionUID for this class.
      */
-    public static final long getActualSerialVersionUID( java.lang.Class clazz )
+    public static final long getActualSerialVersionUID( java.lang.Class<?> clazz )
     {
         ObjectStreamClass theosc = ObjectStreamClass.lookup( clazz );
         if( theosc != null )
@@ -251,7 +252,7 @@
      * Return the class in the local VM that this version is mapped to.
      * Null is returned if there is no corresponding local class.
      */
-    public final Class forClass() {
+    public final Class<?> forClass() {
         return ofClass;
     }
 
@@ -351,7 +352,7 @@
      * Create a new ObjectStreamClass from a loaded class.
      * Don't call this directly, call lookup instead.
      */
-    private ObjectStreamClass(java.lang.Class cl, ObjectStreamClass superdesc,
+    private ObjectStreamClass(java.lang.Class<?> cl, ObjectStreamClass superdesc,
                               boolean serial, boolean extern)
     {
         ofClass = cl;           /* created from this class */
@@ -390,7 +391,7 @@
 
         PersistentFieldsValue() { }
 
-        ObjectStreamField[] get(Class type) {
+        ObjectStreamField[] get(Class<?> type) {
             Object value = map.get(type);
             if (value == null) {
                 value = computeValue(type);
@@ -448,7 +449,7 @@
         if (initialized)
             return;
 
-        final Class cl = ofClass;
+        final Class<?> cl = ofClass;
 
         if (!serializable ||
             externalizable ||
@@ -576,9 +577,9 @@
                      * will call it as necessary.
                      */
                     writeObjectMethod = getPrivateMethod( cl, "writeObject",
-                        new Class[] { java.io.ObjectOutputStream.class }, Void.TYPE ) ;
+                        new Class<?>[] { java.io.ObjectOutputStream.class }, Void.TYPE ) ;
                     readObjectMethod = getPrivateMethod( cl, "readObject",
-                        new Class[] { java.io.ObjectInputStream.class }, Void.TYPE ) ;
+                        new Class<?>[] { java.io.ObjectInputStream.class }, Void.TYPE ) ;
                 }
                 return null;
             }
@@ -604,9 +605,9 @@
      * class, or null if none found.  Access checks are disabled on the
      * returned method (if any).
      */
-    private static Method getPrivateMethod(Class cl, String name,
-                                           Class[] argTypes,
-                                           Class returnType)
+    private static Method getPrivateMethod(Class<?> cl, String name,
+                                           Class<?>[] argTypes,
+                                           Class<?> returnType)
     {
         try {
             Method meth = cl.getDeclaredMethod(name, argTypes);
@@ -667,7 +668,7 @@
      * Fill in the reflected Fields that will be used
      * for reading.
      */
-    final void setClass(Class cl) throws InvalidClassException {
+    final void setClass(Class<?> cl) throws InvalidClassException {
 
         if (cl == null) {
             localClassDesc = null;
@@ -934,9 +935,9 @@
      * Access checks are disabled on the returned constructor (if any), since
      * the defining class may still be non-public.
      */
-    private static Constructor getExternalizableConstructor(Class cl) {
+    private static Constructor getExternalizableConstructor(Class<?> cl) {
         try {
-            Constructor cons = cl.getDeclaredConstructor(new Class[0]);
+            Constructor cons = cl.getDeclaredConstructor(new Class<?>[0]);
             cons.setAccessible(true);
             return ((cons.getModifiers() & Modifier.PUBLIC) != 0) ?
                 cons : null;
@@ -950,15 +951,15 @@
      * superclass, or null if none found.  Access checks are disabled on the
      * returned constructor (if any).
      */
-    private static Constructor getSerializableConstructor(Class cl) {
-        Class initCl = cl;
+    private static Constructor getSerializableConstructor(Class<?> cl) {
+        Class<?> initCl = cl;
         while (Serializable.class.isAssignableFrom(initCl)) {
             if ((initCl = initCl.getSuperclass()) == null) {
                 return null;
             }
         }
         try {
-            Constructor cons = initCl.getDeclaredConstructor(new Class[0]);
+            Constructor cons = initCl.getDeclaredConstructor(new Class<?>[0]);
             int mods = cons.getModifiers();
             if ((mods & Modifier.PRIVATE) != 0 ||
                 ((mods & (Modifier.PUBLIC | Modifier.PROTECTED)) == 0 &&
@@ -1063,7 +1064,7 @@
      * items to the hash accumulating in the digest stream.
      * Fold the hash into a long.  Use the SHA secure hash function.
      */
-    private static long _computeSerialVersionUID(Class cl) {
+    private static long _computeSerialVersionUID(Class<?> cl) {
         if (DEBUG_SVUID)
             msg( "Computing SerialVersionUID for " + cl ) ;
         ByteArrayOutputStream devnull = new ByteArrayOutputStream(512);
@@ -1117,7 +1118,7 @@
                  * them from its computation.
                  */
 
-                Class interfaces[] = cl.getInterfaces();
+                Class<?> interfaces[] = cl.getInterfaces();
                 Arrays.sort(interfaces, compareClassByName);
 
                 for (int i = 0; i < interfaces.length; i++) {
@@ -1247,7 +1248,7 @@
         return h;
     }
 
-    private static long computeStructuralUID(com.sun.corba.se.impl.io.ObjectStreamClass osc, Class cl) {
+    private static long computeStructuralUID(com.sun.corba.se.impl.io.ObjectStreamClass osc, Class<?> cl) {
         ByteArrayOutputStream devnull = new ByteArrayOutputStream(512);
 
         long h = 0;
@@ -1267,7 +1268,7 @@
             DataOutputStream data = new DataOutputStream(mdo);
 
             // Get SUID of parent
-            Class parent = cl.getSuperclass();
+            Class<?> parent = cl.getSuperclass();
             if ((parent != null))
             // SerialBug 1; acc. to spec the one for
             // java.lang.object
@@ -1323,10 +1324,10 @@
     /**
      * Compute the JVM signature for the class.
      */
-    static String getSignature(Class clazz) {
+    static String getSignature(Class<?> clazz) {
         String type = null;
         if (clazz.isArray()) {
-            Class cl = clazz;
+            Class<?> cl = clazz;
             int dimensions = 0;
             while (cl.isArray()) {
                 dimensions++;
@@ -1372,7 +1373,7 @@
 
         sb.append("(");
 
-        Class[] params = meth.getParameterTypes(); // avoid clone
+        Class<?>[] params = meth.getParameterTypes(); // avoid clone
         for (int j = 0; j < params.length; j++) {
             sb.append(getSignature(params[j]));
         }
@@ -1389,7 +1390,7 @@
 
         sb.append("(");
 
-        Class[] params = cons.getParameterTypes(); // avoid clone
+        Class<?>[] params = cons.getParameterTypes(); // avoid clone
         for (int j = 0; j < params.length; j++) {
             sb.append(getSignature(params[j]));
         }
@@ -1409,7 +1410,7 @@
      * The entries are extended from java.lang.ref.SoftReference so the
      * gc will be able to free them if needed.
      */
-    private static ObjectStreamClass findDescriptorFor(Class cl) {
+    private static ObjectStreamClass findDescriptorFor(Class<?> cl) {
 
         int hash = cl.hashCode();
         int index = (hash & 0x7FFFFFFF) % descriptorFor.length;
@@ -1456,7 +1457,7 @@
         descriptorFor[index] = e;
     }
 
-    private static Field[] getDeclaredFields(final Class clz) {
+    private static Field[] getDeclaredFields(final Class<?> clz) {
         return (Field[]) AccessController.doPrivileged(new PrivilegedAction() {
             public Object run() {
                 return clz.getDeclaredFields();
@@ -1490,7 +1491,7 @@
     /*
      * Class that is a descriptor for in this virtual machine.
      */
-    private Class ofClass;
+    private Class<?> ofClass;
 
     /*
      * True if descriptor for a proxy class.
@@ -1562,30 +1563,17 @@
      * Returns true if the given class defines a static initializer method,
      * false otherwise.
      */
-    private static boolean hasStaticInitializer(Class cl) {
+    private static boolean hasStaticInitializer(Class<?> cl) {
         if (hasStaticInitializerMethod == null) {
-            Class classWithThisMethod = null;
+            Class<?> classWithThisMethod = null;
 
             try {
-                try {
-                    // When using rip-int with Merlin or when this is a Merlin
-                    // workspace, the method we want is in sun.misc.ClassReflector
-                    // and absent from java.io.ObjectStreamClass.
-                    //
-                    // When compiling rip-int with JDK 1.3.x, we have to get it
-                    // from java.io.ObjectStreamClass.
-                    classWithThisMethod = Class.forName("sun.misc.ClassReflector");
-                } catch (ClassNotFoundException cnfe) {
-                    // Do nothing.  This is either not a Merlin workspace,
-                    // or rip-int is being compiled with something other than
-                    // Merlin, probably JDK 1.3.  Fall back on java.io.ObjectStreaClass.
-                }
                 if (classWithThisMethod == null)
                     classWithThisMethod = java.io.ObjectStreamClass.class;
 
                 hasStaticInitializerMethod =
                     classWithThisMethod.getDeclaredMethod("hasStaticInitializer",
-                                                          new Class[] { Class.class });
+                                                          new Class<?>[] { Class.class });
             } catch (NoSuchMethodException ex) {
             }
 
@@ -1610,22 +1598,6 @@
     }
 
 
-    /* The Class Object for java.io.Serializable */
-    private static Class classSerializable = null;
-    private static Class classExternalizable = null;
-
-    /*
-     * Resolve java.io.Serializable at load time.
-     */
-    static {
-        try {
-            classSerializable = Class.forName("java.io.Serializable");
-            classExternalizable = Class.forName("java.io.Externalizable");
-        } catch (Throwable e) {
-            System.err.println("Could not load java.io.Serializable or java.io.Externalizable.");
-        }
-    }
-
     /** use serialVersionUID from JDK 1.1. for interoperability */
     private static final long serialVersionUID = -6120832682080437368L;
 
@@ -1663,8 +1635,8 @@
 
     private static class CompareClassByName implements Comparator {
         public int compare(Object o1, Object o2) {
-            Class c1 = (Class)o1;
-            Class c2 = (Class)o2;
+            Class<?> c1 = (Class)o1;
+            Class<?> c2 = (Class)o2;
             return (c1.getName()).compareTo(c2.getName());
         }
     }
@@ -1778,12 +1750,12 @@
      *
      * Copied from the Merlin java.io.ObjectStreamClass.
      */
-    private static Method getInheritableMethod(Class cl, String name,
-                                               Class[] argTypes,
-                                               Class returnType)
+    private static Method getInheritableMethod(Class<?> cl, String name,
+                                               Class<?>[] argTypes,
+                                               Class<?> returnType)
     {
         Method meth = null;
-        Class defCl = cl;
+        Class<?> defCl = cl;
         while (defCl != null) {
             try {
                 meth = defCl.getDeclaredMethod(name, argTypes);
@@ -1815,7 +1787,7 @@
      *
      * Copied from the Merlin java.io.ObjectStreamClass.
      */
-    private static boolean packageEquals(Class cl1, Class cl2) {
+    private static boolean packageEquals(Class<?> cl1, Class<?> cl2) {
         Package pkg1 = cl1.getPackage(), pkg2 = cl2.getPackage();
         return ((pkg1 == pkg2) || ((pkg1 != null) && (pkg1.equals(pkg2))));
     }
--- ./corba/src/share/classes/com/sun/corba/se/impl/orbutil/ObjectStreamClassUtil_1_3.java	Thu Dec 19 09:00:44 2013 -0800
+++ ./corba/src/share/classes/com/sun/corba/se/impl/orbutil/ObjectStreamClassUtil_1_3.java	Tue Mar 18 12:29:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000, 2002, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -94,7 +94,7 @@
         });
     }
 
-    public static long computeStructuralUID(boolean hasWriteObject, Class cl) {
+    public static long computeStructuralUID(boolean hasWriteObject, Class<?> cl) {
         ByteArrayOutputStream devnull = new ByteArrayOutputStream(512);
 
         long h = 0;
@@ -119,7 +119,7 @@
             // Object method in there
 
             // Get SUID of parent
-            Class parent = cl.getSuperclass();
+            Class<?> parent = cl.getSuperclass();
             if ((parent != null) && (parent != java.lang.Object.class)) {
                 boolean hasWriteObjectFlag = false;
                 Class [] args = {java.io.ObjectOutputStream.class};
@@ -503,19 +503,6 @@
             Class classWithThisMethod = null;
 
             try {
-                try {
-                    // When using rip-int with Merlin or when this is a Merlin
-                    // workspace, the method we want is in sun.misc.ClassReflector
-                    // and absent from java.io.ObjectStreamClass.
-                    //
-                    // When compiling rip-int with JDK 1.3.x, we have to get it
-                    // from java.io.ObjectStreamClass.
-                    classWithThisMethod = Class.forName("sun.misc.ClassReflector");
-                } catch (ClassNotFoundException cnfe) {
-                    // Do nothing.  This is either not a Merlin workspace,
-                    // or rip-int is being compiled with something other than
-                    // Merlin, probably JDK 1.3.  Fall back on java.io.ObjectStreaClass.
-                }
                 if (classWithThisMethod == null)
                     classWithThisMethod = java.io.ObjectStreamClass.class;
 
--- ./corba/src/share/classes/com/sun/corba/se/impl/orbutil/ObjectStreamClass_1_3_1.java	Thu Dec 19 09:00:44 2013 -0800
+++ ./corba/src/share/classes/com/sun/corba/se/impl/orbutil/ObjectStreamClass_1_3_1.java	Tue Mar 18 12:29:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -53,6 +53,7 @@
 import java.io.ByteArrayOutputStream;
 import java.io.InvalidClassException;
 import java.io.Serializable;
+import java.io.Externalizable;
 
 import java.util.Arrays;
 import java.util.Comparator;
@@ -88,7 +89,7 @@
     public static final long kDefaultUID = -1;
 
     private static Object noArgsList[] = {};
-    private static Class noTypesList[] = {};
+    private static Class<?> noTypesList[] = {};
 
     private static Hashtable translatedFields;
 
@@ -96,7 +97,7 @@
      * is returned if the specified class does not implement
      * java.io.Serializable or java.io.Externalizable.
      */
-    static final ObjectStreamClass_1_3_1 lookup(Class cl)
+    static final ObjectStreamClass_1_3_1 lookup(Class<?> cl)
     {
         ObjectStreamClass_1_3_1 desc = lookupInternal(cl);
         if (desc.isSerializable() || desc.isExternalizable())
@@ -108,7 +109,7 @@
      * Find the class descriptor for the specified class.
      * Package access only so it can be called from ObjectIn/OutStream.
      */
-    static ObjectStreamClass_1_3_1 lookupInternal(Class cl)
+    static ObjectStreamClass_1_3_1 lookupInternal(Class<?> cl)
     {
         /* Synchronize on the hashtable so no two threads will do
          * this at the same time.
@@ -122,13 +123,13 @@
             }
 
                 /* Check if it's serializable */
-                boolean serializable = classSerializable.isAssignableFrom(cl);
+                boolean serializable = Serializable.class.isAssignableFrom(cl);
                 /* If the class is only Serializable,
                  * lookup the descriptor for the superclass.
                  */
                 ObjectStreamClass_1_3_1 superdesc = null;
                 if (serializable) {
-                    Class superclass = cl.getSuperclass();
+                    Class<?> superclass = cl.getSuperclass();
                     if (superclass != null)
                         superdesc = lookup(superclass);
                 }
@@ -141,7 +142,7 @@
                 if (serializable) {
                     externalizable =
                         ((superdesc != null) && superdesc.isExternalizable()) ||
-                        classExternalizable.isAssignableFrom(cl);
+                        Externalizable.class.isAssignableFrom(cl);
                     if (externalizable) {
                         serializable = false;
                     }
@@ -170,7 +171,7 @@
      * that have evolved from a common root class and agree to be serialized
      * and deserialized using a common format.
      */
-    public static final long getSerialVersionUID( java.lang.Class clazz) {
+    public static final long getSerialVersionUID( java.lang.Class<?> clazz) {
         ObjectStreamClass_1_3_1 theosc = ObjectStreamClass_1_3_1.lookup( clazz );
         if( theosc != null )
         {
@@ -204,7 +205,7 @@
     /**
      * Return the actual (computed) serialVersionUID for this class.
      */
-    public static final long getActualSerialVersionUID( java.lang.Class clazz )
+    public static final long getActualSerialVersionUID( java.lang.Class<?> clazz )
     {
         ObjectStreamClass_1_3_1 theosc = ObjectStreamClass_1_3_1.lookup( clazz );
         if( theosc != null )
@@ -234,7 +235,7 @@
      * Return the class in the local VM that this version is mapped to.
      * Null is returned if there is no corresponding local class.
      */
-    public final Class forClass() {
+    public final Class<?> forClass() {
         return ofClass;
     }
 
@@ -333,7 +334,7 @@
      * Create a new ObjectStreamClass_1_3_1 from a loaded class.
      * Don't call this directly, call lookup instead.
      */
-    private ObjectStreamClass_1_3_1(java.lang.Class cl, ObjectStreamClass_1_3_1 superdesc,
+    private ObjectStreamClass_1_3_1(java.lang.Class<?> cl, ObjectStreamClass_1_3_1 superdesc,
                               boolean serial, boolean extern)
     {
         ofClass = cl;           /* created from this class */
@@ -376,7 +377,7 @@
     private void init() {
       synchronized (lock) {
 
-        final Class cl = ofClass;
+        final Class<?> cl = ofClass;
 
         if (fields != null) // already initialized
                 return;
@@ -558,7 +559,7 @@
                      * will call it as necessary.
                      */
                     try {
-                      Class[] args = {java.io.ObjectOutputStream.class};
+                      Class<?>[] args = {java.io.ObjectOutputStream.class};
                       writeObjectMethod = cl.getDeclaredMethod("writeObject", args);
                       hasWriteObjectMethod = true;
                       int mods = writeObjectMethod.getModifiers();
@@ -578,7 +579,7 @@
                      * ObjectInputStream so it can all the method directly.
                      */
                     try {
-                      Class[] args = {java.io.ObjectInputStream.class};
+                      Class<?>[] args = {java.io.ObjectInputStream.class};
                       readObjectMethod = cl.getDeclaredMethod("readObject", args);
                       int mods = readObjectMethod.getModifiers();
 
@@ -629,11 +630,11 @@
             if (translation != null)
                 return translation;
             else {
-                Class osfClass = com.sun.corba.se.impl.orbutil.ObjectStreamField.class;
+                Class<?> osfClass = com.sun.corba.se.impl.orbutil.ObjectStreamField.class;
 
                 translation = (Object[])java.lang.reflect.Array.newInstance(osfClass, objs.length);
                 Object arg[] = new Object[2];
-                Class types[] = {String.class, Class.class};
+                Class<?> types[] = {String.class, Class.class};
                 Constructor constructor = osfClass.getDeclaredConstructor(types);
                 for (int i = fields.length -1; i >= 0; i--){
                     arg[0] = fields[i].getName();
@@ -804,7 +805,7 @@
         }
     }
 
-    private static long computeStructuralUID(ObjectStreamClass_1_3_1 osc, Class cl) {
+    private static long computeStructuralUID(ObjectStreamClass_1_3_1 osc, Class<?> cl) {
         ByteArrayOutputStream devnull = new ByteArrayOutputStream(512);
 
         long h = 0;
@@ -824,7 +825,7 @@
             DataOutputStream data = new DataOutputStream(mdo);
 
             // Get SUID of parent
-            Class parent = cl.getSuperclass();
+            Class<?> parent = cl.getSuperclass();
             if ((parent != null))
             // SerialBug 1; acc. to spec the one for
             // java.lang.object
@@ -910,10 +911,10 @@
     /**
      * Compute the JVM signature for the class.
      */
-    static String getSignature(Class clazz) {
+    static String getSignature(Class<?> clazz) {
         String type = null;
         if (clazz.isArray()) {
-            Class cl = clazz;
+            Class<?> cl = clazz;
             int dimensions = 0;
             while (cl.isArray()) {
                 dimensions++;
@@ -959,7 +960,7 @@
 
         sb.append("(");
 
-        Class[] params = meth.getParameterTypes(); // avoid clone
+        Class<?>[] params = meth.getParameterTypes(); // avoid clone
         for (int j = 0; j < params.length; j++) {
             sb.append(getSignature(params[j]));
         }
@@ -976,7 +977,7 @@
 
         sb.append("(");
 
-        Class[] params = cons.getParameterTypes(); // avoid clone
+        Class<?>[] params = cons.getParameterTypes(); // avoid clone
         for (int j = 0; j < params.length; j++) {
             sb.append(getSignature(params[j]));
         }
@@ -996,7 +997,7 @@
      * The entries are extended from java.lang.ref.SoftReference so the
      * gc will be able to free them if needed.
      */
-    private static ObjectStreamClass_1_3_1 findDescriptorFor(Class cl) {
+    private static ObjectStreamClass_1_3_1 findDescriptorFor(Class<?> cl) {
 
         int hash = cl.hashCode();
         int index = (hash & 0x7FFFFFFF) % descriptorFor.length;
@@ -1077,7 +1078,7 @@
     /*
      * Class that is a descriptor for in this virtual machine.
      */
-    private Class ofClass;
+    private Class<?> ofClass;
 
     /*
      * True if descriptor for a proxy class.
@@ -1130,22 +1131,6 @@
     /* Get the private static final field for serial version UID */
     // private static native long getSerialVersionUIDField(Class cl);
 
-    /* The Class Object for java.io.Serializable */
-    private static Class classSerializable = null;
-    private static Class classExternalizable = null;
-
-    /*
-     * Resolve java.io.Serializable at load time.
-     */
-    static {
-        try {
-            classSerializable = Class.forName("java.io.Serializable");
-            classExternalizable = Class.forName("java.io.Externalizable");
-        } catch (Throwable e) {
-            System.err.println("Could not load java.io.Serializable or java.io.Externalizable.");
-        }
-    }
-
     /** use serialVersionUID from JDK 1.1. for interoperability */
     private static final long serialVersionUID = -6120832682080437368L;
 
@@ -1183,8 +1168,8 @@
 
     private static class CompareClassByName implements Comparator {
         public int compare(Object o1, Object o2) {
-            Class c1 = (Class)o1;
-            Class c2 = (Class)o2;
+            Class<?> c1 = (Class)o1;
+            Class<?> c2 = (Class)o2;
             return (c1.getName()).compareTo(c2.getName());
         }
     }
--- ./corba/src/share/classes/com/sun/corba/se/spi/orb/ORB.java	Thu Dec 19 09:00:44 2013 -0800
+++ ./corba/src/share/classes/com/sun/corba/se/spi/orb/ORB.java	Tue Mar 18 12:29:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2002, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2002, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -170,6 +170,12 @@
     // representing LogDomain and ExceptionGroup.
     private Map wrapperMap ;
 
+    static class Holder {
+        static final PresentationManager defaultPresentationManager =
+            setupPresentationManager();
+    }
+    private static final Object pmLock = new Object();
+
     private static Map staticWrapperMap = new ConcurrentHashMap();
 
     protected MonitoringManager monitoringManager;
@@ -235,13 +241,24 @@
      */
     public static PresentationManager getPresentationManager()
     {
-        AppContext ac = AppContext.getAppContext();
-        PresentationManager pm = (PresentationManager) ac.get(PresentationManager.class);
-        if (pm == null) {
-            pm = setupPresentationManager();
-            ac.put(PresentationManager.class, pm);
+        SecurityManager sm = System.getSecurityManager();
+        if (sm != null && AppContext.getAppContexts().size() > 0) {
+            AppContext ac = AppContext.getAppContext();
+            if (ac != null) {
+                synchronized (pmLock) {
+                    PresentationManager pm =
+                        (PresentationManager) ac.get(PresentationManager.class);
+                    if (pm == null) {
+                        pm = setupPresentationManager();
+                        ac.put(PresentationManager.class, pm);
+                    }
+                    return pm;
+                }
+            }
         }
-        return pm;
+
+        // No security manager or AppContext
+        return Holder.defaultPresentationManager;
     }
 
     /** Get the appropriate StubFactoryFactory.  This
--- ./corba/src/share/classes/org/omg/CORBA/ORB.java	Thu Dec 19 09:00:44 2013 -0800
+++ ./corba/src/share/classes/org/omg/CORBA/ORB.java	Tue Mar 18 12:29:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1995, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1995, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -36,6 +36,8 @@
 import java.security.AccessController;
 import java.security.PrivilegedAction;
 
+import sun.reflect.misc.ReflectUtil;
+
 /**
  * A class providing APIs for the CORBA Object Request Broker
  * features.  The <code>ORB</code> class also provides
@@ -289,20 +291,38 @@
                     (className.equals("com.sun.corba.se.impl.orb.ORBSingleton"))) {
                 singleton = new com.sun.corba.se.impl.orb.ORBSingleton();
             } else {
-                singleton = create_impl(className);
+                singleton = create_impl_with_systemclassloader(className);
             }
         }
         return singleton;
     }
 
+   private static ORB create_impl_with_systemclassloader(String className) {
+
+        try {
+            ReflectUtil.checkPackageAccess(className);
+            ClassLoader cl = ClassLoader.getSystemClassLoader();
+            Class<org.omg.CORBA.ORB> orbBaseClass = org.omg.CORBA.ORB.class;
+            Class<?> singletonOrbClass = Class.forName(className, true, cl).asSubclass(orbBaseClass);
+            return (ORB)singletonOrbClass.newInstance();
+        } catch (Throwable ex) {
+            SystemException systemException = new INITIALIZE(
+                "can't instantiate default ORB implementation " + className);
+            systemException.initCause(ex);
+            throw systemException;
+        }
+    }
+
     private static ORB create_impl(String className) {
-
         ClassLoader cl = Thread.currentThread().getContextClassLoader();
         if (cl == null)
             cl = ClassLoader.getSystemClassLoader();
 
         try {
-            return (ORB) Class.forName(className, true, cl).newInstance();
+            ReflectUtil.checkPackageAccess(className);
+            Class<org.omg.CORBA.ORB> orbBaseClass = org.omg.CORBA.ORB.class;
+            Class<?> orbClass = Class.forName(className, true, cl).asSubclass(orbBaseClass);
+            return (ORB)orbClass.newInstance();
         } catch (Throwable ex) {
             SystemException systemException = new INITIALIZE(
                "can't instantiate default ORB implementation " + className);
@@ -346,7 +366,6 @@
         } else {
             orb = create_impl(className);
         }
-
         orb.set_parameters(args, props);
         return orb;
     }
@@ -377,7 +396,6 @@
         } else {
             orb = create_impl(className);
         }
-
         orb.set_parameters(app, props);
         return orb;
     }
@@ -573,7 +591,7 @@
         try {
             // First try to load the OperationDef class
             String opDefClassName = "org.omg.CORBA.OperationDef";
-            Class opDefClass = null;
+            Class<?> opDefClass = null;
 
             ClassLoader cl = Thread.currentThread().getContextClassLoader();
             if ( cl == null )
@@ -583,7 +601,7 @@
 
             // OK, we loaded OperationDef. Now try to get the
             // create_operation_list(OperationDef oper) method.
-            Class[] argc = { opDefClass };
+            Class<?>[] argc = { opDefClass };
             java.lang.reflect.Method meth =
                 this.getClass().getMethod("create_operation_list", argc);
 
--- ./hotspot/.hgtags	Thu Dec 19 09:00:51 2013 -0800
+++ ./hotspot/.hgtags	Tue Mar 18 12:31:20 2014 -0700
@@ -590,6 +590,9 @@
 12374864c655a2cefb0d65caaacf215d5365ec5f jdk7u45-b18
 3677c8cc3c89c0fa608f485b84396e4cf755634b jdk7u45-b30
 520b7b3d9153c1407791325946b07c5c222cf0d6 jdk7u45-b31
+c373a733d5d5147f99eaa2b91d6b937c28214fc9 jdk7u45-b33
+0bcb43482f2ac5615437541ffb8dc0f79ece3148 jdk7u45-b34
+12ea8d416f105f5971c808c89dddc1006bfc4c53 jdk7u45-b35
 429884602206fcf5314c8b953c06d54d337558ca jdk7u51-b00
 68f03ff066f2341b89b52a6d6e21ae09de008351 jdk7u51-b01
 67910a581eca113847c5320c49436a9816c5d5c6 jdk7u51-b02
@@ -604,3 +607,22 @@
 1f11dff734af98f5bf11d4fceeda221ab1416971 jdk7u51-b11
 dee2a38ef6b26534c44c550ef4da2c3146c612c2 jdk7u51-b12
 6c6a2299029ad02fa2820b8ff8c61c2bbcae799c jdk7u51-b13
+a398ddc79d2310ad37b131cc3794b3cf574f088e jdk7u51-b30
+cf4110c35afb10456d8264c47b7cde1c20150cab jdk7u51-b31
+208419914859dd77abdb5ec755b32c237ee6e4eb jdk7u51-b33
+f8457a75bdb5052f1d8c547027a926f9b755b808 jdk7u51-b34
+dee2a38ef6b26534c44c550ef4da2c3146c612c2 jdk7u55-b00
+ac0063b4452bc724e8648e64f4b2d495054bb308 jdk7u55-b01
+408028d410e316a99495c42df0031018890c22fe jdk7u55-b02
+50fb91504dd8cdf410eb956075442daf3aacf1db jdk7u55-b03
+3be3b8a032a5508646c1c5620cee18d3e69fc708 jdk7u55-b04
+b86119fa2748bd91ae4984ff2264da92b6626f8c jdk7u55-b05
+260d919d52e500a0b20f911fade2a7710474067a jdk7u55-b06
+8cf6e0a3a0651c4132ae034c2b68ddf4eb5c4d88 jdk7u55-b07
+049fd2cef85bf2d557dd7dd8a90a6831a8168ce4 jdk7u55-b08
+9b238ab164e6d1cf9cfb560827d88ef8a7d8c898 jdk7u55-b09
+573d8d080af9eff48aa3b8f0696d8874ce36fbb1 jdk7u55-b09
+36f8bd4dd467ae4183340842fd7158ac3309b826 jdk7u55-b10
+49cada8e39b9215b9fd8b9183743f92625587cfc jdk7u55-b11
+aadc864abd1ced3049bf59ce32786a07997ba190 jdk7u55-b12
+b021fd817a0177b31d1e3d65127a27458e85801e jdk7u55-b13
--- ./hotspot/make/bsd/makefiles/arm.make	Thu Dec 19 09:00:51 2013 -0800
+++ ./hotspot/make/bsd/makefiles/arm.make	Tue Mar 18 12:31:20 2014 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2008, 2011, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -24,6 +24,8 @@
 
 Obj_Files += bsd_arm.o
 
-LIBS += $(EXT_LIBS_PATH)/sflt_glibc.a 
+ifneq ($(EXT_LIBS_PATH),)
+  LIBS += $(EXT_LIBS_PATH)/sflt_glibc.a 
+endif
 
 CFLAGS += -DVM_LITTLE_ENDIAN
--- ./hotspot/make/hotspot_version	Thu Dec 19 09:00:51 2013 -0800
+++ ./hotspot/make/hotspot_version	Tue Mar 18 12:31:20 2014 -0700
@@ -1,5 +1,5 @@
 # 
-# Copyright (c) 2006, 2013, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2006, 2014, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -31,10 +31,10 @@
 #
 
 # Don't put quotes (fail windows build).
-HOTSPOT_VM_COPYRIGHT=Copyright 2013
+HOTSPOT_VM_COPYRIGHT=Copyright 2014
 
 HS_MAJOR_VER=24
-HS_MINOR_VER=51
+HS_MINOR_VER=55
 HS_BUILD_NUMBER=03
 
 JDK_MAJOR_VER=1
--- ./hotspot/make/linux/makefiles/arm.make	Thu Dec 19 09:00:51 2013 -0800
+++ ./hotspot/make/linux/makefiles/arm.make	Tue Mar 18 12:31:20 2014 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2008, 2011, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -24,6 +24,8 @@
 
 Obj_Files += linux_arm.o
 
-LIBS += $(EXT_LIBS_PATH)/sflt_glibc.a 
+ifneq ($(EXT_LIBS_PATH),)
+  LIBS += $(EXT_LIBS_PATH)/sflt_glibc.a 
+endif
 
 CFLAGS += -DVM_LITTLE_ENDIAN
--- ./hotspot/src/os/windows/vm/os_windows.cpp	Thu Dec 19 09:00:51 2013 -0800
+++ ./hotspot/src/os/windows/vm/os_windows.cpp	Tue Mar 18 12:31:20 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -1591,6 +1591,7 @@
 
 void os::win32::print_windows_version(outputStream* st) {
   OSVERSIONINFOEX osvi;
+  SYSTEM_INFO si;
   ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));
   osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
 
@@ -1600,6 +1601,18 @@
   }
 
   int os_vers = osvi.dwMajorVersion * 1000 + osvi.dwMinorVersion;
+
+  ZeroMemory(&si, sizeof(SYSTEM_INFO));
+  if (os_vers >= 5002) {
+    // Retrieve SYSTEM_INFO from GetNativeSystemInfo call so that we could
+    // find out whether we are running on 64 bit processor or not.
+    if (os::Kernel32Dll::GetNativeSystemInfoAvailable()) {
+      os::Kernel32Dll::GetNativeSystemInfo(&si);
+    } else {
+      GetSystemInfo(&si);
+    }
+  }
+
   if (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT) {
     switch (os_vers) {
     case 3051: st->print(" Windows NT 3.51"); break;
@@ -1607,57 +1620,48 @@
     case 5000: st->print(" Windows 2000"); break;
     case 5001: st->print(" Windows XP"); break;
     case 5002:
-    case 6000:
-    case 6001:
-    case 6002: {
-      // Retrieve SYSTEM_INFO from GetNativeSystemInfo call so that we could
-      // find out whether we are running on 64 bit processor or not.
-      SYSTEM_INFO si;
-      ZeroMemory(&si, sizeof(SYSTEM_INFO));
-        if (!os::Kernel32Dll::GetNativeSystemInfoAvailable()){
-          GetSystemInfo(&si);
+      if (osvi.wProductType == VER_NT_WORKSTATION &&
+          si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64) {
+          st->print(" Windows XP x64 Edition");
       } else {
-        os::Kernel32Dll::GetNativeSystemInfo(&si);
-      }
-      if (os_vers == 5002) {
-        if (osvi.wProductType == VER_NT_WORKSTATION &&
-            si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64)
-          st->print(" Windows XP x64 Edition");
-        else
-            st->print(" Windows Server 2003 family");
-      } else if (os_vers == 6000) {
-        if (osvi.wProductType == VER_NT_WORKSTATION)
-            st->print(" Windows Vista");
-        else
-            st->print(" Windows Server 2008");
-        if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64)
-            st->print(" , 64 bit");
-      } else if (os_vers == 6001) {
-        if (osvi.wProductType == VER_NT_WORKSTATION) {
-            st->print(" Windows 7");
-        } else {
-            // Unrecognized windows, print out its major and minor versions
-            st->print(" Windows NT %d.%d", osvi.dwMajorVersion, osvi.dwMinorVersion);
-        }
-        if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64)
-            st->print(" , 64 bit");
-      } else if (os_vers == 6002) {
-        if (osvi.wProductType == VER_NT_WORKSTATION) {
-            st->print(" Windows 8");
-        } else {
-            st->print(" Windows Server 2012");
-        }
-        if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64)
-            st->print(" , 64 bit");
-      } else { // future os
-        // Unrecognized windows, print out its major and minor versions
-        st->print(" Windows NT %d.%d", osvi.dwMajorVersion, osvi.dwMinorVersion);
-        if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64)
-            st->print(" , 64 bit");
+          st->print(" Windows Server 2003 family");
       }
       break;
-    }
-    default: // future windows, print out its major and minor versions
+
+    case 6000:
+      if (osvi.wProductType == VER_NT_WORKSTATION) {
+        st->print(" Windows Vista");
+      } else {
+        st->print(" Windows Server 2008");
+      }
+      break;
+
+    case 6001:
+      if (osvi.wProductType == VER_NT_WORKSTATION) {
+        st->print(" Windows 7");
+      } else {
+        st->print(" Windows Server 2008 R2");
+      }
+      break;
+
+    case 6002:
+      if (osvi.wProductType == VER_NT_WORKSTATION) {
+        st->print(" Windows 8");
+      } else {
+        st->print(" Windows Server 2012");
+      }
+      break;
+
+    case 6003:
+      if (osvi.wProductType == VER_NT_WORKSTATION) {
+        st->print(" Windows 8.1");
+      } else {
+        st->print(" Windows Server 2012 R2");
+      }
+      break;
+
+    default: // future os
+      // Unrecognized windows, print out its major and minor versions
       st->print(" Windows NT %d.%d", osvi.dwMajorVersion, osvi.dwMinorVersion);
     }
   } else {
@@ -1669,6 +1673,11 @@
       st->print(" Windows %d.%d", osvi.dwMajorVersion, osvi.dwMinorVersion);
     }
   }
+
+  if (os_vers >= 6000 && si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64) {
+    st->print(" , 64 bit");
+  }
+
   st->print(" Build %d", osvi.dwBuildNumber);
   st->print(" %s", osvi.szCSDVersion);           // service pack
   st->cr();
--- ./hotspot/src/share/vm/classfile/classFileParser.cpp	Thu Dec 19 09:00:51 2013 -0800
+++ ./hotspot/src/share/vm/classfile/classFileParser.cpp	Tue Mar 18 12:31:20 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -2661,6 +2661,11 @@
                      "Short length on BootstrapMethods in class file %s",
                      CHECK);
 
+  guarantee_property(attribute_byte_length > sizeof(u2),
+                     "Invalid BootstrapMethods attribute length %u in class file %s",
+                     attribute_byte_length,
+                     CHECK);
+
   // The attribute contains a counted array of counted tuples of shorts,
   // represending bootstrap specifiers:
   //    length*{bootstrap_method_index, argument_count*{argument_index}}
--- ./hotspot/src/share/vm/oops/objArrayKlass.cpp	Thu Dec 19 09:00:51 2013 -0800
+++ ./hotspot/src/share/vm/oops/objArrayKlass.cpp	Tue Mar 18 12:31:20 2014 -0700
@@ -149,7 +149,7 @@
         if (element_is_null ||
             Klass::cast((new_val->klass()))->is_subtype_of(bound)) {
           bs->write_ref_field_pre(p, new_val);
-          *p = *from;
+          *p = element;
         } else {
           // We must do a barrier to cover the partial copy.
           const size_t pd = pointer_delta(p, dst, (size_t)heapOopSize);
--- ./hotspot/src/share/vm/opto/matcher.cpp	Thu Dec 19 09:00:51 2013 -0800
+++ ./hotspot/src/share/vm/opto/matcher.cpp	Tue Mar 18 12:31:20 2014 -0700
@@ -464,17 +464,17 @@
   C->FIRST_STACK_mask().Clear();
 
   // Add in the incoming argument area
-  OptoReg::Name init = OptoReg::add(_old_SP, C->out_preserve_stack_slots());
-  for (i = init; i < _in_arg_limit; i = OptoReg::add(i,1))
+  OptoReg::Name init_in = OptoReg::add(_old_SP, C->out_preserve_stack_slots());
+  for (i = init_in; i < _in_arg_limit; i = OptoReg::add(i,1)) {
     C->FIRST_STACK_mask().Insert(i);
-
+  }
   // Add in all bits past the outgoing argument area
   guarantee(RegMask::can_represent_arg(OptoReg::add(_out_arg_limit,-1)),
             "must be able to represent all call arguments in reg mask");
-  init = _out_arg_limit;
-  for (i = init; RegMask::can_represent(i); i = OptoReg::add(i,1))
+  OptoReg::Name init = _out_arg_limit;
+  for (i = init; RegMask::can_represent(i); i = OptoReg::add(i,1)) {
     C->FIRST_STACK_mask().Insert(i);
-
+  }
   // Finally, set the "infinite stack" bit.
   C->FIRST_STACK_mask().set_AllStack();
 
@@ -506,16 +506,36 @@
      idealreg2spillmask[Op_VecS]->OR(C->FIRST_STACK_mask());
   }
   if (Matcher::vector_size_supported(T_FLOAT,2)) {
+    // For VecD we need dual alignment and 8 bytes (2 slots) for spills.
+    // RA guarantees such alignment since it is needed for Double and Long values.
     *idealreg2spillmask[Op_VecD] = *idealreg2regmask[Op_VecD];
      idealreg2spillmask[Op_VecD]->OR(aligned_stack_mask);
   }
   if (Matcher::vector_size_supported(T_FLOAT,4)) {
+    // For VecX we need quadro alignment and 16 bytes (4 slots) for spills.
+    //
+    // RA can use input arguments stack slots for spills but until RA
+    // we don't know frame size and offset of input arg stack slots.
+    //
+    // Exclude last input arg stack slots to avoid spilling vectors there
+    // otherwise vector spills could stomp over stack slots in caller frame.
+    OptoReg::Name in = OptoReg::add(_in_arg_limit, -1);
+    for (int k = 1; (in >= init_in) && (k < RegMask::SlotsPerVecX); k++) {
+      aligned_stack_mask.Remove(in);
+      in = OptoReg::add(in, -1);
+    }
      aligned_stack_mask.clear_to_sets(RegMask::SlotsPerVecX);
      assert(aligned_stack_mask.is_AllStack(), "should be infinite stack");
     *idealreg2spillmask[Op_VecX] = *idealreg2regmask[Op_VecX];
      idealreg2spillmask[Op_VecX]->OR(aligned_stack_mask);
   }
   if (Matcher::vector_size_supported(T_FLOAT,8)) {
+    // For VecY we need octo alignment and 32 bytes (8 slots) for spills.
+    OptoReg::Name in = OptoReg::add(_in_arg_limit, -1);
+    for (int k = 1; (in >= init_in) && (k < RegMask::SlotsPerVecY); k++) {
+      aligned_stack_mask.Remove(in);
+      in = OptoReg::add(in, -1);
+    }
      aligned_stack_mask.clear_to_sets(RegMask::SlotsPerVecY);
      assert(aligned_stack_mask.is_AllStack(), "should be infinite stack");
     *idealreg2spillmask[Op_VecY] = *idealreg2regmask[Op_VecY];
--- ./hotspot/src/share/vm/opto/output.cpp	Thu Dec 19 09:00:51 2013 -0800
+++ ./hotspot/src/share/vm/opto/output.cpp	Tue Mar 18 12:31:20 2014 -0700
@@ -345,6 +345,11 @@
   uint*      jmp_offset = NEW_RESOURCE_ARRAY(uint,nblocks);
   uint*      jmp_size   = NEW_RESOURCE_ARRAY(uint,nblocks);
   int*       jmp_nidx   = NEW_RESOURCE_ARRAY(int ,nblocks);
+
+  // Collect worst case block paddings
+  int* block_worst_case_pad = NEW_RESOURCE_ARRAY(int, nblocks);
+  memset(block_worst_case_pad, 0, nblocks * sizeof(int));
+
   DEBUG_ONLY( uint *jmp_target = NEW_RESOURCE_ARRAY(uint,nblocks); )
   DEBUG_ONLY( uint *jmp_rule = NEW_RESOURCE_ARRAY(uint,nblocks); )
 
@@ -461,6 +466,7 @@
           last_avoid_back_to_back_adr += max_loop_pad;
         }
         blk_size += max_loop_pad;
+        block_worst_case_pad[i + 1] = max_loop_pad;
       }
     }
 
@@ -500,9 +506,16 @@
         if (bnum > i) { // adjust following block's offset
           offset -= adjust_block_start;
         }
+
+        // This block can be a loop header, account for the padding
+        // in the previous block.
+        int block_padding = block_worst_case_pad[i];
+        assert(i == 0 || block_padding == 0 || br_offs >= block_padding, "Should have at least a padding on top");
         // In the following code a nop could be inserted before
         // the branch which will increase the backward distance.
-        bool needs_padding = ((uint)br_offs == last_may_be_short_branch_adr);
+        bool needs_padding = ((uint)(br_offs - block_padding) == last_may_be_short_branch_adr);
+        assert(!needs_padding || jmp_offset[i] == 0, "padding only branches at the beginning of block");
+
         if (needs_padding && offset <= 0)
           offset -= nop_size;
 
--- ./jaxp/.hgtags	Thu Dec 19 09:01:08 2013 -0800
+++ ./jaxp/.hgtags	Tue Mar 18 12:34:22 2014 -0700
@@ -381,6 +381,9 @@
 4beb90ab48f7fd46c7a9afbe66f8cccb230699ba jdk7u45-b18
 a456c78a50e201a65c9f63565c8291b84a4fbd32 jdk7u45-b30
 3c34f244296e98d8ebb94973c752f3395612391a jdk7u45-b31
+056494e83d15cd1c546d32a3b35bdb6f670b3876 jdk7u45-b33
+b5a83862ed2ab9cc2de3719e38c72519481a4bbb jdk7u45-b34
+7fda9b300e07738116b2b95b568229bdb4b31059 jdk7u45-b35
 0a8b95184728548be4b20876e05f76e0262e4195 jdk7u51-b00
 2450ace952f45202e5a3fd4f6a8356a196fe029e jdk7u51-b01
 68def851cc6b17944756f1986734b323d8569571 jdk7u51-b02
@@ -395,3 +398,22 @@
 70b5691c44d2830efd4301856e6223fa43894462 jdk7u51-b11
 807946db29f42477e8d8390be01c7e27280bc85c jdk7u51-b12
 114654a331e2f97a048d7ed43d06d7512e20e2c1 jdk7u51-b13
+3161567adae93d12c64b79592bda3046f0c0a22d jdk7u51-b30
+e85ee81daec2ea2fa21bf804d03431b0664c6dff jdk7u51-b31
+1a6c3258ad218bf286c47d65e4cd80eb6763f8df jdk7u51-b33
+9cdc04d76eb19a871c739625acd801ed1b24bed9 jdk7u51-b34
+807946db29f42477e8d8390be01c7e27280bc85c jdk7u55-b00
+bb7779a8fc4d14719e907b8890a2665476cf45ae jdk7u55-b01
+8275dc4db7f852edb331ae48d663d08b9ab2b5c7 jdk7u55-b02
+381e73f93a83e8d3bfd7dbf79f4f363a8fd6442f jdk7u55-b03
+c72c57f71c2ba6362d9ccfbf4743947b9ecefcac jdk7u55-b04
+5592b0c44617022e3c136eedfa1e98d4f254c964 jdk7u55-b05
+c59d714090080ad2e06f0ca5e8d354403059d8ce jdk7u55-b06
+125ea54089add3a16898b801a9989bf6cca05da6 jdk7u55-b07
+39337c00cb3ce29b4d67f6d247c3fa80f16cb49f jdk7u55-b08
+537f4f609132f3d6a4ce506c98f1dbd57f1320f8 jdk7u55-b09
+997bdd44d5de4aee319ff0a0d2892a912d9de6f5 jdk7u55-b09
+606483a43e8b6317d84922b9ed2b2c30d9e77419 jdk7u55-b10
+f3f02e67d867ae25cd4f3b9bc39a4fd17f593126 jdk7u55-b11
+708a1872f5bb8ba58ecc9fcbf4e12e6fa4783998 jdk7u55-b12
+14719f73596f5c90e3f46c0f4312f32e5b105edd jdk7u55-b13
--- ./jaxp/src/com/sun/org/apache/xalan/internal/utils/ObjectFactory.java	Thu Dec 19 09:01:08 2013 -0800
+++ ./jaxp/src/com/sun/org/apache/xalan/internal/utils/ObjectFactory.java	Tue Mar 18 12:34:22 2014 -0700
@@ -54,8 +54,8 @@
     //
     // Constants
     //
-     private static final String XALAN_INTERNAL = "com.sun.org.apache.xalan.internal";
-     private static final String XERCES_INTERNAL = "com.sun.org.apache.xerces.internal";
+     private static final String JAXP_INTERNAL = "com.sun.org.apache";
+     private static final String STAX_INTERNAL = "com.sun.xml.internal";
 
     // name of default properties file to look for in JDK's jre/lib directory
     private static final String DEFAULT_PROPERTIES_FILENAME =
@@ -497,12 +497,8 @@
     public static Class findProviderClass(String className, boolean doFallback)
         throws ClassNotFoundException, ConfigurationError
     {
-        if (System.getSecurityManager()!=null) {
-            return Class.forName(className);
-        } else {
-            return findProviderClass (className,
+        return findProviderClass (className,
                 findClassLoader (), doFallback);
-        }
     }
 
     /**
@@ -517,8 +513,8 @@
         SecurityManager security = System.getSecurityManager();
         try{
             if (security != null){
-                if (className.startsWith(XALAN_INTERNAL) ||
-                    className.startsWith(XERCES_INTERNAL)) {
+                if (className.startsWith(JAXP_INTERNAL) ||
+                    className.startsWith(STAX_INTERNAL)) {
                     cl = null;
                 } else {
                     final int lastDot = className.lastIndexOf(".");
@@ -533,16 +529,7 @@
 
         Class providerClass;
         if (cl == null) {
-            // XXX Use the bootstrap ClassLoader.  There is no way to
-            // load a class using the bootstrap ClassLoader that works
-            // in both JDK 1.1 and Java 2.  However, this should still
-            // work b/c the following should be true:
-            //
-            // (cl == null) iff current ClassLoader == null
-            //
-            // Thus Class.forName(String) will use the current
-            // ClassLoader which will be the bootstrap ClassLoader.
-            providerClass = Class.forName(className);
+            providerClass = Class.forName(className, false, ObjectFactory.class.getClassLoader());
         } else {
             try {
                 providerClass = cl.loadClass(className);
--- ./jaxp/src/com/sun/org/apache/xalan/internal/utils/SecuritySupport.java	Thu Dec 19 09:01:08 2013 -0800
+++ ./jaxp/src/com/sun/org/apache/xalan/internal/utils/SecuritySupport.java	Tue Mar 18 12:34:22 2014 -0700
@@ -57,7 +57,7 @@
         return securitySupport;
     }
 
-    static ClassLoader getContextClassLoader() {
+    public static ClassLoader getContextClassLoader() {
         return (ClassLoader) AccessController.doPrivileged(new PrivilegedAction() {
             public Object run() {
                 ClassLoader cl = null;
--- ./jaxp/src/com/sun/org/apache/xerces/internal/utils/ObjectFactory.java	Thu Dec 19 09:01:08 2013 -0800
+++ ./jaxp/src/com/sun/org/apache/xerces/internal/utils/ObjectFactory.java	Tue Mar 18 12:34:22 2014 -0700
@@ -48,7 +48,8 @@
     //
     // Constants
     //
-    private static final String DEFAULT_INTERNAL_CLASSES = "com.sun.org.apache.";
+    private static final String JAXP_INTERNAL = "com.sun.org.apache";
+    private static final String STAX_INTERNAL = "com.sun.xml.internal";
 
     // name of default properties file to look for in JDK's jre/lib directory
     private static final String DEFAULT_PROPERTIES_FILENAME = "xerces.properties";
@@ -288,12 +289,8 @@
     public static Class findProviderClass(String className, boolean doFallback)
         throws ClassNotFoundException, ConfigurationError
     {
-        if (System.getSecurityManager()!=null) {
-            return Class.forName(className);
-        } else {
-            return findProviderClass (className,
+        return findProviderClass (className,
                 findClassLoader (), doFallback);
-        }
     }
     /**
      * Find a Class using the specified ClassLoader
@@ -306,7 +303,8 @@
         //restrict the access to package as speicified in java.security policy
         SecurityManager security = System.getSecurityManager();
         if (security != null) {
-            if (className.startsWith(DEFAULT_INTERNAL_CLASSES)) {
+            if (className.startsWith(JAXP_INTERNAL) ||
+                    className.startsWith(STAX_INTERNAL)) {
                 cl = null;
             } else {
                 final int lastDot = className.lastIndexOf(".");
@@ -318,7 +316,7 @@
         Class providerClass;
         if (cl == null) {
             //use the bootstrap ClassLoader.
-            providerClass = Class.forName(className);
+            providerClass = Class.forName(className, false, ObjectFactory.class.getClassLoader());
         } else {
             try {
                 providerClass = cl.loadClass(className);
--- ./jaxp/src/com/sun/org/apache/xml/internal/serializer/CharInfo.java	Thu Dec 19 09:01:08 2013 -0800
+++ ./jaxp/src/com/sun/org/apache/xml/internal/serializer/CharInfo.java	Tue Mar 18 12:34:22 2014 -0700
@@ -22,6 +22,11 @@
  */
 package com.sun.org.apache.xml.internal.serializer;
 
+import com.sun.org.apache.xalan.internal.utils.SecuritySupport;
+import com.sun.org.apache.xml.internal.serializer.utils.MsgKey;
+import com.sun.org.apache.xml.internal.serializer.utils.SystemIDResolver;
+import com.sun.org.apache.xml.internal.serializer.utils.Utils;
+import com.sun.org.apache.xml.internal.serializer.utils.WrappedRuntimeException;
 import java.io.BufferedReader;
 import java.io.InputStream;
 import java.io.InputStreamReader;
@@ -29,19 +34,11 @@
 import java.net.URL;
 import java.util.Enumeration;
 import java.util.HashMap;
+import java.util.Locale;
 import java.util.PropertyResourceBundle;
 import java.util.ResourceBundle;
-import java.security.AccessController;
-import java.security.PrivilegedAction;
-
 import javax.xml.transform.TransformerException;
 
-import com.sun.org.apache.xml.internal.serializer.utils.MsgKey;
-import com.sun.org.apache.xml.internal.serializer.utils.SystemIDResolver;
-import com.sun.org.apache.xml.internal.serializer.utils.Utils;
-import com.sun.org.apache.xml.internal.serializer.utils.WrappedRuntimeException;
-import com.sun.org.apache.xalan.internal.utils.ObjectFactory;
-
 /**
  * This class provides services that tell if a character should have
  * special treatement, such as entity reference substitution or normalization
@@ -176,13 +173,19 @@
         //      file
         //   3) try treating the resource a URI
 
-        if (internal) {
-            try {
+        try {
+            if (internal) {
                 // Load entity property files by using PropertyResourceBundle,
                 // cause of security issure for applets
                 entities = PropertyResourceBundle.getBundle(entitiesResource);
-            } catch (Exception e) {}
-        }
+            } else {
+                ClassLoader cl = SecuritySupport.getContextClassLoader();
+                if (cl != null) {
+                    entities = PropertyResourceBundle.getBundle(entitiesResource,
+                            Locale.getDefault(), cl);
+                }
+            }
+        } catch (Exception e) {}
 
         if (entities != null) {
             Enumeration keys = entities.getKeys();
@@ -198,6 +201,7 @@
             set(S_CARRIAGERETURN);
         } else {
             InputStream is = null;
+            String err = null;
 
             // Load user specified resource file by using URL loading, it
             // requires a valid URI as parameter
@@ -205,18 +209,22 @@
                 if (internal) {
                     is = CharInfo.class.getResourceAsStream(entitiesResource);
                 } else {
-                    ClassLoader cl = ObjectFactory.findClassLoader();
-                    if (cl == null) {
-                        is = ClassLoader.getSystemResourceAsStream(entitiesResource);
-                    } else {
-                        is = cl.getResourceAsStream(entitiesResource);
+                    ClassLoader cl = SecuritySupport.getContextClassLoader();
+                    if (cl != null) {
+                        try {
+                            is = cl.getResourceAsStream(entitiesResource);
+                        } catch (Exception e) {
+                            err = e.getMessage();
+                        }
                     }
 
                     if (is == null) {
                         try {
                             URL url = new URL(entitiesResource);
                             is = url.openStream();
-                        } catch (Exception e) {}
+                        } catch (Exception e) {
+                            err = e.getMessage();
+                        }
                     }
                 }
 
@@ -224,7 +232,7 @@
                     throw new RuntimeException(
                         Utils.messages.createMessage(
                             MsgKey.ER_RESOURCE_COULD_NOT_FIND,
-                            new Object[] {entitiesResource, entitiesResource}));
+                            new Object[] {entitiesResource, err}));
                 }
 
                 // Fix Bugzilla#4000: force reading in UTF-8
@@ -456,64 +464,56 @@
         return isCleanTextASCII[value];
     }
 
-//  In the future one might want to use the array directly and avoid
-//  the method call, but I think the JIT alreay inlines this well enough
-//  so don't do it (for now) - bjm
-//    public final boolean[] getASCIIClean()
-//    {
-//        return isCleanTextASCII;
-//    }
 
+    /**
+     * Read an internal resource file that describes the mapping of
+     * characters to entity references; Construct a CharInfo object.
+     *
+     * @param entitiesFileName Name of entities resource file that should
+     * be loaded, which describes the mapping of characters to entity references.
+     * @param method the output method type, which should be one of "xml", "html", and "text".
+     * @return an instance of CharInfo
+     *
+     * @xsl.usage internal
+     */
+    static CharInfo getCharInfoInternal(String entitiesFileName, String method)
+    {
+        CharInfo charInfo = (CharInfo) m_getCharInfoCache.get(entitiesFileName);
+        if (charInfo != null) {
+            return charInfo;
+        }
 
-    private static CharInfo getCharInfoBasedOnPrivilege(
-        final String entitiesFileName, final String method,
-        final boolean internal){
-            return (CharInfo) AccessController.doPrivileged(
-                new PrivilegedAction() {
-                        public Object run() {
-                            return new CharInfo(entitiesFileName,
-                              method, internal);}
-            });
+        charInfo = new CharInfo(entitiesFileName, method, true);
+        m_getCharInfoCache.put(entitiesFileName, charInfo);
+        return charInfo;
     }
 
     /**
-     * Factory that reads in a resource file that describes the mapping of
-     * characters to entity references.
+     * Constructs a CharInfo object using the following process to try reading
+     * the entitiesFileName parameter:
      *
-     * Resource files must be encoded in UTF-8 and have a format like:
+     *   1) attempt to load it as a ResourceBundle
+     *   2) try using the class loader to find the specified file
+     *   3) try opening it as an URI
+     *
+     * In case of 2 and 3, the resource file must be encoded in UTF-8 and have the
+     * following format:
      * <pre>
      * # First char # is a comment
      * Entity numericValue
      * quot 34
      * amp 38
      * </pre>
-     * (Note: Why don't we just switch to .properties files? Oct-01 -sc)
      *
-     * @param entitiesResource Name of entities resource file that should
-     * be loaded, which describes that mapping of characters to entity references.
-     * @param method the output method type, which should be one of "xml", "html", "text"...
-     *
-     * @xsl.usage internal
+     * @param entitiesFileName Name of entities resource file that should
+     * be loaded, which describes the mapping of characters to entity references.
+     * @param method the output method type, which should be one of "xml", "html", and "text".
+     * @return an instance of CharInfo
      */
     static CharInfo getCharInfo(String entitiesFileName, String method)
     {
-        CharInfo charInfo = (CharInfo) m_getCharInfoCache.get(entitiesFileName);
-        if (charInfo != null) {
-            return charInfo;
-        }
-
-        // try to load it internally - cache
         try {
-            charInfo = getCharInfoBasedOnPrivilege(entitiesFileName,
-                                        method, true);
-            m_getCharInfoCache.put(entitiesFileName, charInfo);
-            return charInfo;
-        } catch (Exception e) {}
-
-        // try to load it externally - do not cache
-        try {
-            return getCharInfoBasedOnPrivilege(entitiesFileName,
-                                method, false);
+            return new CharInfo(entitiesFileName, method, false);
         } catch (Exception e) {}
 
         String absoluteEntitiesFileName;
@@ -530,8 +530,7 @@
             }
         }
 
-        return getCharInfoBasedOnPrivilege(entitiesFileName,
-                                method, false);
+        return new CharInfo(absoluteEntitiesFileName, method, false);
     }
 
     /** Table of user-specified char infos. */
--- ./jaxp/src/com/sun/org/apache/xml/internal/serializer/ToHTMLStream.java	Thu Dec 19 09:01:08 2013 -0800
+++ ./jaxp/src/com/sun/org/apache/xml/internal/serializer/ToHTMLStream.java	Tue Mar 18 12:34:22 2014 -0700
@@ -60,7 +60,7 @@
      */
     private static final CharInfo m_htmlcharInfo =
 //        new CharInfo(CharInfo.HTML_ENTITIES_RESOURCE);
-        CharInfo.getCharInfo(CharInfo.HTML_ENTITIES_RESOURCE, Method.HTML);
+        CharInfo.getCharInfoInternal(CharInfo.HTML_ENTITIES_RESOURCE, Method.HTML);
 
     /** A digital search trie for fast, case insensitive lookup of ElemDesc objects. */
     static final Trie m_elementFlags = new Trie();
--- ./jaxp/src/com/sun/org/apache/xml/internal/serializer/ToXMLStream.java	Thu Dec 19 09:01:08 2013 -0800
+++ ./jaxp/src/com/sun/org/apache/xml/internal/serializer/ToXMLStream.java	Tue Mar 18 12:34:22 2014 -0700
@@ -58,7 +58,7 @@
      */
     private static CharInfo m_xmlcharInfo =
 //      new CharInfo(CharInfo.XML_ENTITIES_RESOURCE);
-        CharInfo.getCharInfo(CharInfo.XML_ENTITIES_RESOURCE, Method.XML);
+        CharInfo.getCharInfoInternal(CharInfo.XML_ENTITIES_RESOURCE, Method.XML);
 
     /**
      * Default constructor.
--- ./jaxws/.hgtags	Thu Dec 19 09:01:10 2013 -0800
+++ ./jaxws/.hgtags	Tue Mar 18 12:34:51 2014 -0700
@@ -381,6 +381,9 @@
 65b0f3ccdc8bcff0d79e1b543a8cefb817529b3f jdk7u45-b18
 c32c6a662d18d7195fc02125178c7543ce09bb00 jdk7u45-b30
 6802a1c098c48b2c8336e06f1565254759025bab jdk7u45-b31
+e040abab3625fbced33b30cba7c0307236268211 jdk7u45-b33
+e7df5d6b23c64509672d262187f51cde14db4e66 jdk7u45-b34
+c654ba4b2392c2913f45b495a2ea0c53cc348d98 jdk7u45-b35
 5524cced32d3959d95ed414add230273bc10c38d jdk7u51-b00
 db9e3328f393313e52cbf3fee5236aa2429028d0 jdk7u51-b01
 92a4787cb3617005a329fb49247c550e8d7eb47a jdk7u51-b02
@@ -395,3 +398,22 @@
 708507f4795cad1f0cf7e19ff2dc16fe9d441754 jdk7u51-b11
 7c7c2ea4b6808d0abf7fd48d11440d75b0c08d3a jdk7u51-b12
 81a1b110f70c37d2c2f0de7c0ef3bd2d04aba475 jdk7u51-b13
+5dbeb9983f104be717da35c9b14923d71dd248d7 jdk7u51-b30
+eb79f394916efba85f4f6c7ef562966699f2c1e8 jdk7u51-b31
+b2e40219fdcb579d9e10bf01bbd1f05ddcc936fb jdk7u51-b33
+f782f513bb1c74640fe0f4711fec6a417845e9e9 jdk7u51-b34
+7c7c2ea4b6808d0abf7fd48d11440d75b0c08d3a jdk7u55-b00
+c5eb0c2a0f9715b510bc641506fb90df9bf05ab0 jdk7u55-b01
+a257072fc2aa482abd6ffa28e235dbe532af6d00 jdk7u55-b02
+2916fdfc475bf29bc702887bf5ba02df67c98916 jdk7u55-b03
+f4759b4547602b3bc865db8c5f356f46979c6389 jdk7u55-b04
+8a8dfdbc66149b89f804c5a50e4692c2520569ae jdk7u55-b05
+2696d6747826cea92a97b2d80be4a59ff99462bd jdk7u55-b06
+1ad971afe2b5db93420654fa65b23f827760fed7 jdk7u55-b07
+57ba92e96b7fb6f4543038c1daa390c45d8a9d84 jdk7u55-b08
+c9d8555964a581486f4c8e1bf5f5db678eb3b9f2 jdk7u55-b09
+0f469a7307b98e911aaaab8cad781eab3bd94ad6 jdk7u55-b09
+1080e907d64ab63c6138b1a61d9e5b826e83634a jdk7u55-b10
+0db5b891d1ba10211da0a8158551b35f00da7684 jdk7u55-b11
+3834eb921dfd8d29d917a0c57bb9fdd9aa58c209 jdk7u55-b12
+3b0da73591b1ea23c48aa7babc34ed776fc183f0 jdk7u55-b13
--- ./jaxws/src/share/jaf_classes/javax/activation/CommandMap.java	Thu Dec 19 09:01:10 2013 -0800
+++ ./jaxws/src/share/jaf_classes/javax/activation/CommandMap.java	Tue Mar 18 12:34:51 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2005, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,6 +25,9 @@
 
 package javax.activation;
 
+import java.util.Map;
+import java.util.WeakHashMap;
+
 
 /**
  * The CommandMap class provides an interface to a registry of
@@ -38,6 +41,8 @@
  */
 public abstract class CommandMap {
     private static CommandMap defaultCommandMap = null;
+    private static Map<ClassLoader,CommandMap> map =
+                                new WeakHashMap<ClassLoader,CommandMap>();
 
     /**
      * Get the default CommandMap.
@@ -56,11 +61,18 @@
      *
      * @return the CommandMap
      */
-    public static CommandMap getDefaultCommandMap() {
-        if (defaultCommandMap == null)
-            defaultCommandMap = new MailcapCommandMap();
+    public static synchronized CommandMap getDefaultCommandMap() {
+        if (defaultCommandMap != null)
+            return defaultCommandMap;
 
-        return defaultCommandMap;
+        // fetch per-thread-context-class-loader default
+        ClassLoader tccl = SecuritySupport.getContextClassLoader();
+        CommandMap def = map.get(tccl);
+        if (def == null) {
+            def = new MailcapCommandMap();
+            map.put(tccl, def);
+        }
+        return def;
     }
 
     /**
@@ -71,7 +83,7 @@
      * @exception SecurityException if the caller doesn't have permission
      *                                  to change the default
      */
-    public static void setDefaultCommandMap(CommandMap commandMap) {
+    public static synchronized void setDefaultCommandMap(CommandMap commandMap) {
         SecurityManager security = System.getSecurityManager();
         if (security != null) {
             try {
@@ -79,13 +91,16 @@
                 security.checkSetFactory();
             } catch (SecurityException ex) {
                 // otherwise, we also allow it if this code and the
-                // factory come from the same class loader (e.g.,
+                // factory come from the same (non-system) class loader (e.g.,
                 // the JAF classes were loaded with the applet classes).
-                if (CommandMap.class.getClassLoader() !=
+                if (CommandMap.class.getClassLoader() == null ||
+                    CommandMap.class.getClassLoader() !=
                             commandMap.getClass().getClassLoader())
                     throw ex;
             }
         }
+        // remove any per-thread-context-class-loader CommandMap
+        map.remove(SecuritySupport.getContextClassLoader());
         defaultCommandMap = commandMap;
     }
 
--- ./jaxws/src/share/jaf_classes/javax/activation/DataHandler.java	Thu Dec 19 09:01:10 2013 -0800
+++ ./jaxws/src/share/jaf_classes/javax/activation/DataHandler.java	Tue Mar 18 12:34:51 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -368,7 +368,12 @@
         // if it's not set, set it...
         if (transferFlavors == emptyFlavors)
             transferFlavors = getDataContentHandler().getTransferDataFlavors();
-        return transferFlavors;
+
+        if (transferFlavors == emptyFlavors)
+            return transferFlavors;
+        else
+            return transferFlavors.clone();
+
     }
 
     /**
--- ./jaxws/src/share/jaf_classes/javax/activation/FileTypeMap.java	Thu Dec 19 09:01:10 2013 -0800
+++ ./jaxws/src/share/jaf_classes/javax/activation/FileTypeMap.java	Tue Mar 18 12:34:51 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2005, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -26,6 +26,8 @@
 package javax.activation;
 
 import java.io.File;
+import java.util.Map;
+import java.util.WeakHashMap;
 
 /**
  * The FileTypeMap is an abstract class that provides a data typing
@@ -48,6 +50,8 @@
 public abstract class FileTypeMap {
 
     private static FileTypeMap defaultMap = null;
+    private static Map<ClassLoader,FileTypeMap> map =
+                                new WeakHashMap<ClassLoader,FileTypeMap>();
 
     /**
      * The default constructor.
@@ -78,11 +82,11 @@
      * Sets the default FileTypeMap for the system. This instance
      * will be returned to callers of getDefaultFileTypeMap.
      *
-     * @param map The FileTypeMap.
+     * @param fileTypeMap The FileTypeMap.
      * @exception SecurityException if the caller doesn't have permission
      *                                  to change the default
      */
-    public static void setDefaultFileTypeMap(FileTypeMap map) {
+    public static synchronized void setDefaultFileTypeMap(FileTypeMap fileTypeMap) {
         SecurityManager security = System.getSecurityManager();
         if (security != null) {
             try {
@@ -90,14 +94,17 @@
                 security.checkSetFactory();
             } catch (SecurityException ex) {
                 // otherwise, we also allow it if this code and the
-                // factory come from the same class loader (e.g.,
+                // factory come from the same (non-system) class loader (e.g.,
                 // the JAF classes were loaded with the applet classes).
-                if (FileTypeMap.class.getClassLoader() !=
-                        map.getClass().getClassLoader())
+                if (FileTypeMap.class.getClassLoader() == null ||
+                    FileTypeMap.class.getClassLoader() !=
+                        fileTypeMap.getClass().getClassLoader())
                     throw ex;
             }
         }
-        defaultMap = map;
+        // remove any per-thread-context-class-loader FileTypeMap
+        map.remove(SecuritySupport.getContextClassLoader());
+        defaultMap = fileTypeMap;
     }
 
     /**
@@ -109,10 +116,17 @@
      * @return The default FileTypeMap
      * @see javax.activation.FileTypeMap#setDefaultFileTypeMap
      */
-    public static FileTypeMap getDefaultFileTypeMap() {
-        // XXX - probably should be synchronized
-        if (defaultMap == null)
-            defaultMap = new MimetypesFileTypeMap();
-        return defaultMap;
+    public static synchronized FileTypeMap getDefaultFileTypeMap() {
+        if (defaultMap != null)
+            return defaultMap;
+
+        // fetch per-thread-context-class-loader default
+        ClassLoader tccl = SecuritySupport.getContextClassLoader();
+        FileTypeMap def = map.get(tccl);
+        if (def == null) {
+            def = new MimetypesFileTypeMap();
+            map.put(tccl, def);
+        }
+        return def;
     }
 }
--- ./jaxws/src/share/jaf_classes/javax/activation/MailcapCommandMap.java	Thu Dec 19 09:01:10 2013 -0800
+++ ./jaxws/src/share/jaf_classes/javax/activation/MailcapCommandMap.java	Tue Mar 18 12:34:51 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2005, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -120,11 +120,7 @@
 public class MailcapCommandMap extends CommandMap {
     /*
      * We manage a collection of databases, searched in order.
-     * The default database is shared between all instances
-     * of this class.
-     * XXX - Can we safely share more databases between instances?
      */
-    private static MailcapFile defDB = null;
     private MailcapFile[] DB;
     private static final int PROG = 0;  // programmatically added entries
 
@@ -164,14 +160,10 @@
         loadAllResources(dbv, "META-INF/mailcap");
 
         LogSupport.log("MailcapCommandMap: load DEF");
-        synchronized (MailcapCommandMap.class) {
-            // see if another instance has created this yet.
-            if (defDB == null)
-                defDB = loadResource("/META-INF/mailcap.default");
-        }
+        mf = loadResource("/META-INF/mailcap.default");
 
-        if (defDB != null)
-            dbv.add(defDB);
+        if (mf != null)
+            dbv.add(mf);
 
         DB = new MailcapFile[dbv.size()];
         DB = (MailcapFile[])dbv.toArray(DB);
--- ./jaxws/src/share/jaf_classes/javax/activation/MimetypesFileTypeMap.java	Thu Dec 19 09:01:10 2013 -0800
+++ ./jaxws/src/share/jaf_classes/javax/activation/MimetypesFileTypeMap.java	Tue Mar 18 12:34:51 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2005, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -69,11 +69,7 @@
 public class MimetypesFileTypeMap extends FileTypeMap {
     /*
      * We manage a collection of databases, searched in order.
-     * The default database is shared between all instances
-     * of this class.
-     * XXX - Can we safely share more databases between instances?
      */
-    private static MimeTypeFile defDB = null;
     private MimeTypeFile[] DB;
     private static final int PROG = 0;  // programmatically added entries
 
@@ -114,14 +110,10 @@
         loadAllResources(dbv, "META-INF/mime.types");
 
         LogSupport.log("MimetypesFileTypeMap: load DEF");
-        synchronized (MimetypesFileTypeMap.class) {
-            // see if another instance has created this yet.
-            if (defDB == null)
-                defDB = loadResource("/META-INF/mimetypes.default");
-        }
+        mf = loadResource("/META-INF/mimetypes.default");
 
-        if (defDB != null)
-            dbv.addElement(defDB);
+        if (mf != null)
+            dbv.addElement(mf);
 
         DB = new MimeTypeFile[dbv.size()];
         dbv.copyInto(DB);
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jaxws/src/share/jaxws_classes/com/sun/tools/internal/ws/wsdl/parser/ContextClassloaderLocal.java	Tue Mar 18 12:34:51 2014 -0700
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.sun.tools.internal.ws.wsdl.parser;
+
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+import java.text.MessageFormat;
+import java.util.ResourceBundle;
+import java.util.WeakHashMap;
+
+/**
+ * Simple utility ensuring that the value is cached only in case it is non-internal implementation
+ */
+abstract class ContextClassloaderLocal<V> {
+
+    private static final String FAILED_TO_CREATE_NEW_INSTANCE = "FAILED_TO_CREATE_NEW_INSTANCE";
+
+    private WeakHashMap<ClassLoader, V> CACHE = new WeakHashMap<ClassLoader, V>();
+
+    public V get() throws Error {
+        ClassLoader tccl = getContextClassLoader();
+        V instance = CACHE.get(tccl);
+        if (instance == null) {
+            instance = createNewInstance();
+            CACHE.put(tccl, instance);
+        }
+        return instance;
+    }
+
+    public void set(V instance) {
+        CACHE.put(getContextClassLoader(), instance);
+    }
+
+    protected abstract V initialValue() throws Exception;
+
+    private V createNewInstance() {
+        try {
+            return initialValue();
+        } catch (Exception e) {
+            throw new Error(format(FAILED_TO_CREATE_NEW_INSTANCE, getClass().getName()), e);
+        }
+    }
+
+    private static String format(String property, Object... args) {
+        String text = ResourceBundle.getBundle(ContextClassloaderLocal.class.getName()).getString(property);
+        return MessageFormat.format(text, args);
+    }
+
+    private static ClassLoader getContextClassLoader() {
+        return (ClassLoader)
+                AccessController.doPrivileged(new PrivilegedAction() {
+                    public Object run() {
+                        ClassLoader cl = null;
+                        try {
+                            cl = Thread.currentThread().getContextClassLoader();
+                        } catch (SecurityException ex) {
+                        }
+                        return cl;
+                    }
+                });
+    }
+}
+
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jaxws/src/share/jaxws_classes/com/sun/tools/internal/ws/wsdl/parser/ContextClassloaderLocal.properties	Tue Mar 18 12:34:51 2014 -0700
@@ -0,0 +1,27 @@
+#
+# Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+# Error messages for ContextClassloaderLocal utility class
+FAILED_TO_CREATE_NEW_INSTANCE=Failed to create new instance of {0}
+
--- ./jaxws/src/share/jaxws_classes/com/sun/tools/internal/ws/wsdl/parser/Internalizer.java	Thu Dec 19 09:01:10 2013 -0800
+++ ./jaxws/src/share/jaxws_classes/com/sun/tools/internal/ws/wsdl/parser/Internalizer.java	Tue Mar 18 12:34:51 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -65,8 +65,15 @@
  * @author Vivek Pandey
  */
 public class Internalizer {
-    private static final XPathFactory xpf = XPathFactory.newInstance();
-    private final XPath xpath = xpf.newXPath();
+
+    private static final ContextClassloaderLocal<XPathFactory> xpf = new ContextClassloaderLocal<XPathFactory>() {
+        @Override
+        protected XPathFactory initialValue() throws Exception {
+            return XPathFactory.newInstance();
+        }
+    };
+
+    private final XPath xpath = xpf.get().newXPath();
     private final WsimportOptions options;
     private final DOMForest forest;
     private final ErrorReceiver errorReceiver;
--- ./jaxws/src/share/jaxws_classes/com/sun/tools/internal/ws/wsdl/parser/JAXWSBindingExtensionHandler.java	Thu Dec 19 09:01:10 2013 -0800
+++ ./jaxws/src/share/jaxws_classes/com/sun/tools/internal/ws/wsdl/parser/JAXWSBindingExtensionHandler.java	Tue Mar 18 12:34:51 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -56,8 +56,14 @@
  */
 public class JAXWSBindingExtensionHandler extends AbstractExtensionHandler {
 
-    private static final XPathFactory xpf = XPathFactory.newInstance();
-    private final XPath xpath = xpf.newXPath();
+    private static final ContextClassloaderLocal<XPathFactory> xpf = new ContextClassloaderLocal<XPathFactory>() {
+        @Override
+        protected XPathFactory initialValue() throws Exception {
+            return XPathFactory.newInstance();
+        }
+    };
+
+    private final XPath xpath = xpf.get().newXPath();
 
     public JAXWSBindingExtensionHandler(Map<String, AbstractExtensionHandler> extensionHandlerMap) {
         super(extensionHandlerMap);
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jaxws/src/share/jaxws_classes/com/sun/tools/internal/xjc/reader/internalizer/ContextClassloaderLocal.java	Tue Mar 18 12:34:51 2014 -0700
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.sun.tools.internal.xjc.reader.internalizer;
+
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+import java.text.MessageFormat;
+import java.util.ResourceBundle;
+import java.util.WeakHashMap;
+
+/**
+ * Simple utility ensuring that the value is cached only in case it is non-internal implementation
+ */
+abstract class ContextClassloaderLocal<V> {
+
+    private static final String FAILED_TO_CREATE_NEW_INSTANCE = "FAILED_TO_CREATE_NEW_INSTANCE";
+
+    private WeakHashMap<ClassLoader, V> CACHE = new WeakHashMap<ClassLoader, V>();
+
+    public V get() throws Error {
+        ClassLoader tccl = getContextClassLoader();
+        V instance = CACHE.get(tccl);
+        if (instance == null) {
+            instance = createNewInstance();
+            CACHE.put(tccl, instance);
+        }
+        return instance;
+    }
+
+    public void set(V instance) {
+        CACHE.put(getContextClassLoader(), instance);
+    }
+
+    protected abstract V initialValue() throws Exception;
+
+    private V createNewInstance() {
+        try {
+            return initialValue();
+        } catch (Exception e) {
+            throw new Error(format(FAILED_TO_CREATE_NEW_INSTANCE, getClass().getName()), e);
+        }
+    }
+
+    private static String format(String property, Object... args) {
+        String text = ResourceBundle.getBundle(ContextClassloaderLocal.class.getName()).getString(property);
+        return MessageFormat.format(text, args);
+    }
+
+    private static ClassLoader getContextClassLoader() {
+        return (ClassLoader)
+                AccessController.doPrivileged(new PrivilegedAction() {
+                    public Object run() {
+                        ClassLoader cl = null;
+                        try {
+                            cl = Thread.currentThread().getContextClassLoader();
+                        } catch (SecurityException ex) {
+                        }
+                        return cl;
+                    }
+                });
+    }
+}
+
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jaxws/src/share/jaxws_classes/com/sun/tools/internal/xjc/reader/internalizer/ContextClassloaderLocal.properties	Tue Mar 18 12:34:51 2014 -0700
@@ -0,0 +1,27 @@
+#
+# Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+# Error messages for ContextClassloaderLocal utility class
+FAILED_TO_CREATE_NEW_INSTANCE=Failed to create new instance of {0}
+
--- ./jaxws/src/share/jaxws_classes/com/sun/tools/internal/xjc/reader/internalizer/Internalizer.java	Thu Dec 19 09:01:10 2013 -0800
+++ ./jaxws/src/share/jaxws_classes/com/sun/tools/internal/xjc/reader/internalizer/Internalizer.java	Tue Mar 18 12:34:51 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -75,9 +75,14 @@
 
     private static final String WSDL_NS = "http://schemas.xmlsoap.org/wsdl/";
 
-    private static final XPathFactory xpf = XPathFactory.newInstance();
+    private static final ContextClassloaderLocal<XPathFactory> xpf = new ContextClassloaderLocal<XPathFactory>() {
+        @Override
+        protected XPathFactory initialValue() throws Exception {
+            return XPathFactory.newInstance();
+        }
+    };
 
-    private final XPath xpath = xpf.newXPath();
+    private final XPath xpath = xpf.get().newXPath();
 
     /**
      * Internalize all &lt;jaxb:bindings> customizations in the given forest.
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/bind/DatatypeConverterImpl.java	Thu Dec 19 09:01:10 2013 -0800
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/bind/DatatypeConverterImpl.java	Tue Mar 18 12:34:51 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,9 +27,14 @@
 
 import java.math.BigDecimal;
 import java.math.BigInteger;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 import java.util.Calendar;
+import java.util.Collections;
 import java.util.GregorianCalendar;
+import java.util.Map;
 import java.util.TimeZone;
+import java.util.WeakHashMap;
 
 import javax.xml.bind.DatatypeConverter;
 import javax.xml.bind.DatatypeConverterInterface;
@@ -352,7 +357,7 @@
 
     public static GregorianCalendar _parseDateTime(CharSequence s) {
         String val = WhiteSpaceProcessor.trim(s).toString();
-        return datatypeFactory.newXMLGregorianCalendar(val).toGregorianCalendar();
+        return getDatatypeFactory().newXMLGregorianCalendar(val).toGregorianCalendar();
     }
 
     public static String _printDateTime(Calendar val) {
@@ -718,14 +723,30 @@
         }
         return false;
     }
-    private static final DatatypeFactory datatypeFactory;
 
-    static {
-        try {
-            datatypeFactory = DatatypeFactory.newInstance();
-        } catch (DatatypeConfigurationException e) {
-            throw new Error(e);
+    private static final Map<ClassLoader, DatatypeFactory> DF_CACHE = Collections.synchronizedMap(new WeakHashMap<ClassLoader, DatatypeFactory>());
+
+    public static DatatypeFactory getDatatypeFactory() {
+        ClassLoader tccl = AccessController.doPrivileged(new PrivilegedAction<ClassLoader>() {
+            public ClassLoader run() {
+                return Thread.currentThread().getContextClassLoader();
+            }
+        });
+        DatatypeFactory df = DF_CACHE.get(tccl);
+        if (df == null) {
+            synchronized (DatatypeConverterImpl.class) {
+                df = DF_CACHE.get(tccl);
+                if (df == null) { // to prevent multiple initialization
+                    try {
+                        df = DatatypeFactory.newInstance();
+                    } catch (DatatypeConfigurationException e) {
+                        throw new Error(Messages.FAILED_TO_INITIALE_DATATYPE_FACTORY.format(),e);
+                    }
+                    DF_CACHE.put(tccl, df);
+                }
+            }
         }
+        return df;
     }
 
     private static final class CalendarFormatter {
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/bind/Messages.java	Tue Mar 18 12:34:51 2014 -0700
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.sun.xml.internal.bind;
+
+import java.text.MessageFormat;
+import java.util.ResourceBundle;
+
+/**
+ * Message resources
+ */
+enum Messages {
+    FAILED_TO_INITIALE_DATATYPE_FACTORY, // 0 args
+    ;
+
+    private static final ResourceBundle rb = ResourceBundle.getBundle(Messages.class.getName());
+
+    @Override
+    public String toString() {
+        return format();
+    }
+
+    public String format( Object... args ) {
+        return MessageFormat.format( rb.getString(name()), args );
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/bind/Messages.properties	Tue Mar 18 12:34:51 2014 -0700
@@ -0,0 +1,27 @@
+#
+# Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+
+FAILED_TO_INITIALE_DATATYPE_FACTORY = \
+    Failed to initialize JAXP 1.3 DatatypeFactory class.
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/bind/v2/model/impl/Messages.java	Thu Dec 19 09:01:10 2013 -0800
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/bind/v2/model/impl/Messages.java	Tue Mar 18 12:34:51 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -60,7 +60,6 @@
     PROPERTY_ORDER_CONTAINS_UNUSED_ENTRY, // 2 args
 
     INVALID_XML_ENUM_VALUE, // 2 arg
-    FAILED_TO_INITIALE_DATATYPE_FACTORY, // 0 args
     NO_IMAGE_WRITER, // 1 arg
 
     ILLEGAL_MIME_TYPE, // 2 args
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/bind/v2/model/impl/Messages.properties	Thu Dec 19 09:01:10 2013 -0800
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/bind/v2/model/impl/Messages.properties	Tue Mar 18 12:34:51 2014 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -86,9 +86,6 @@
 INVALID_XML_ENUM_VALUE = \
     "{0}" is not a valid value for {1}.
 
-FAILED_TO_INITIALE_DATATYPE_FACTORY = \
-    Failed to initialize JAXP 1.3 DatatypeFactory class.
-
 NO_IMAGE_WRITER = \
     No javax.imageio.ImageWriter is available for the specified MIME type "{0}"
 
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/bind/v2/model/impl/RuntimeBuiltinLeafInfoImpl.java	Thu Dec 19 09:01:10 2013 -0800
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/bind/v2/model/impl/RuntimeBuiltinLeafInfoImpl.java	Tue Mar 18 12:34:51 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -60,9 +60,7 @@
 import javax.imageio.stream.ImageOutputStream;
 import javax.xml.bind.ValidationEvent;
 import javax.xml.bind.helpers.ValidationEventImpl;
-import javax.xml.datatype.DatatypeConfigurationException;
 import javax.xml.datatype.DatatypeConstants;
-import javax.xml.datatype.DatatypeFactory;
 import javax.xml.datatype.Duration;
 import javax.xml.datatype.XMLGregorianCalendar;
 import javax.xml.namespace.QName;
@@ -565,7 +563,8 @@
 
                 public XMLGregorianCalendar parse(CharSequence lexical) throws SAXException {
                     try {
-                        return datatypeFactory.newXMLGregorianCalendar(lexical.toString().trim()); // (.trim() - issue 396)
+                        return DatatypeConverterImpl.getDatatypeFactory()
+                                .newXMLGregorianCalendar(lexical.toString().trim()); // (.trim() - issue 396)
                     } catch (Exception e) {
                         UnmarshallingContext.getInstance().handleError(e);
                         return null;
@@ -835,7 +834,7 @@
 
                 public Duration parse(CharSequence lexical) {
                     TODO.checkSpec("JSR222 Issue #42");
-                    return datatypeFactory.newDuration(lexical.toString());
+                    return DatatypeConverterImpl.getDatatypeFactory().newDuration(lexical.toString());
                 }
             });
         primaryList.add(
@@ -876,21 +875,6 @@
         }
     }
 
-
-    /**
-     * Cached instance of {@link DatatypeFactory} to create
-     * {@link XMLGregorianCalendar} and {@link Duration}.
-     */
-    private static final DatatypeFactory datatypeFactory = init();
-
-    private static DatatypeFactory init() {
-        try {
-            return DatatypeFactory.newInstance();
-        } catch (DatatypeConfigurationException e) {
-            throw new Error(Messages.FAILED_TO_INITIALE_DATATYPE_FACTORY.format(),e);
-        }
-    }
-
         private static void checkXmlGregorianCalendarFieldRef(QName type,
                 XMLGregorianCalendar cal)throws javax.xml.bind.MarshalException{
                 StringBuilder buf = new StringBuilder();
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/bind/v2/runtime/output/XMLStreamWriterOutput.java	Thu Dec 19 09:01:10 2013 -0800
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/bind/v2/runtime/output/XMLStreamWriterOutput.java	Tue Mar 18 12:34:51 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -33,7 +33,6 @@
 
 import com.sun.xml.internal.bind.v2.runtime.JAXBContextImpl;
 import com.sun.xml.internal.bind.v2.runtime.XMLSerializer;
-import com.sun.xml.internal.bind.v2.util.ClassLoaderRetriever;
 
 import org.xml.sax.SAXException;
 
@@ -153,7 +152,6 @@
         }
     }
 
-
     /**
      * Reference to FI's XMLStreamWriter class, if FI can be loaded.
      */
@@ -162,9 +160,8 @@
 
     private static Class initFIStAXWriterClass() {
         try {
-            ClassLoader loader = ClassLoaderRetriever.getClassLoader();
-            Class llfisw = Class.forName("com.sun.xml.internal.org.jvnet.fastinfoset.stax.LowLevelFastInfosetStreamWriter", true, loader);
-            Class sds = loader.loadClass("com.sun.xml.internal.fastinfoset.stax.StAXDocumentSerializer");
+            Class<?> llfisw = Class.forName("com.sun.xml.internal.org.jvnet.fastinfoset.stax.LowLevelFastInfosetStreamWriter");
+            Class<?> sds = Class.forName("com.sun.xml.internal.fastinfoset.stax.StAXDocumentSerializer");
             // Check if StAXDocumentSerializer implements LowLevelFastInfosetStreamWriter
             if (llfisw.isAssignableFrom(sds))
                 return sds;
@@ -179,8 +176,7 @@
         try {
             if (FI_STAX_WRITER_CLASS == null)
                 return null;
-            ClassLoader loader = ClassLoaderRetriever.getClassLoader();
-            Class c = Class.forName("com.sun.xml.internal.bind.v2.runtime.output.FastInfosetStreamWriterOutput", true, loader);
+            Class c = Class.forName("com.sun.xml.internal.bind.v2.runtime.output.FastInfosetStreamWriterOutput");
             return c.getConstructor(FI_STAX_WRITER_CLASS, JAXBContextImpl.class);
         } catch (Throwable e) {
             return null;
@@ -195,8 +191,7 @@
 
     private static Class initStAXExWriterClass() {
         try {
-            ClassLoader loader = ClassLoaderRetriever.getClassLoader();
-            return Class.forName("com.sun.xml.internal.org.jvnet.staxex.XMLStreamWriterEx",true,loader);
+            return Class.forName("com.sun.xml.internal.org.jvnet.staxex.XMLStreamWriterEx");
         } catch (Throwable e) {
             return null;
         }
@@ -204,8 +199,7 @@
 
     private static Constructor<? extends XmlOutput> initStAXExOutputClass() {
         try {
-            ClassLoader loader = ClassLoaderRetriever.getClassLoader();
-            Class c = Class.forName("com.sun.xml.internal.bind.v2.runtime.output.StAXExStreamWriterOutput",true, loader);
+            Class c = Class.forName("com.sun.xml.internal.bind.v2.runtime.output.StAXExStreamWriterOutput");
             return c.getConstructor(STAXEX_WRITER_CLASS);
         } catch (Throwable e) {
             return null;
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/StAXStreamConnector.java	Thu Dec 19 09:01:10 2013 -0800
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/bind/v2/runtime/unmarshaller/StAXStreamConnector.java	Tue Mar 18 12:34:51 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -33,7 +33,6 @@
 import javax.xml.stream.XMLStreamReader;
 
 import com.sun.xml.internal.bind.WhiteSpaceProcessor;
-import com.sun.xml.internal.bind.v2.util.ClassLoaderRetriever;
 
 import org.xml.sax.Attributes;
 import org.xml.sax.SAXException;
@@ -337,9 +336,8 @@
 
     private static Class initFIStAXReaderClass() {
         try {
-            ClassLoader cl = getClassLoader();
-            Class fisr = cl.loadClass("com.sun.xml.internal.org.jvnet.fastinfoset.stax.FastInfosetStreamReader");
-            Class sdp = cl.loadClass("com.sun.xml.internal.fastinfoset.stax.StAXDocumentParser");
+            Class<?> fisr = Class.forName("com.sun.xml.internal.org.jvnet.fastinfoset.stax.FastInfosetStreamReader");
+            Class<?> sdp = Class.forName("com.sun.xml.internal.fastinfoset.stax.StAXDocumentParser");
             // Check if StAXDocumentParser implements FastInfosetStreamReader
             if (fisr.isAssignableFrom(sdp))
                 return sdp;
@@ -355,7 +353,7 @@
             if (FI_STAX_READER_CLASS == null)
                 return null;
 
-            Class c = getClassLoader().loadClass(
+            Class c = Class.forName(
                     "com.sun.xml.internal.bind.v2.runtime.unmarshaller.FastInfosetConnector");
             return c.getConstructor(FI_STAX_READER_CLASS,XmlVisitor.class);
         } catch (Throwable e) {
@@ -371,7 +369,7 @@
 
     private static Class initStAXExReader() {
         try {
-            return getClassLoader().loadClass("com.sun.xml.internal.org.jvnet.staxex.XMLStreamReaderEx");
+            return Class.forName("com.sun.xml.internal.org.jvnet.staxex.XMLStreamReaderEx");
         } catch (Throwable e) {
             return null;
         }
@@ -379,15 +377,10 @@
 
     private static Constructor<? extends StAXConnector> initStAXExConnector() {
         try {
-            Class c = getClassLoader().loadClass("com.sun.xml.internal.bind.v2.runtime.unmarshaller.StAXExConnector");
+            Class c = Class.forName("com.sun.xml.internal.bind.v2.runtime.unmarshaller.StAXExConnector");
             return c.getConstructor(STAX_EX_READER_CLASS,XmlVisitor.class);
         } catch (Throwable e) {
             return null;
         }
     }
-
-    public static ClassLoader getClassLoader() {
-        return ClassLoaderRetriever.getClassLoader();
-    }
-
 }
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/messaging/saaj/soap/AttachmentPartImpl.java	Thu Dec 19 09:01:10 2013 -0800
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/messaging/saaj/soap/AttachmentPartImpl.java	Tue Mar 18 12:34:51 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -62,61 +62,6 @@
         Logger.getLogger(LogDomainConstants.SOAP_DOMAIN,
                          "com.sun.xml.internal.messaging.saaj.soap.LocalStrings");
 
-    static {
-        try {
-            CommandMap map = CommandMap.getDefaultCommandMap();
-            if (map instanceof MailcapCommandMap) {
-                MailcapCommandMap mailMap = (MailcapCommandMap) map;
-                String hndlrStr = ";;x-java-content-handler=";
-                mailMap.addMailcap(
-                    "text/xml"
-                        + hndlrStr
-                        + "com.sun.xml.internal.messaging.saaj.soap.XmlDataContentHandler");
-                mailMap.addMailcap(
-                    "application/xml"
-                        + hndlrStr
-                        + "com.sun.xml.internal.messaging.saaj.soap.XmlDataContentHandler");
-                mailMap.addMailcap(
-                    "application/fastinfoset"
-                        + hndlrStr
-                        + "com.sun.xml.internal.messaging.saaj.soap.FastInfosetDataContentHandler");
-                /* Image DataContentHandler handles all image types
-                mailMap.addMailcap(
-                    "image/jpeg"
-                        + hndlrStr
-                        + "com.sun.xml.internal.messaging.saaj.soap.JpegDataContentHandler");
-                mailMap.addMailcap(
-                    "image/gif"
-                        + hndlrStr
-                        + "com.sun.xml.internal.messaging.saaj.soap.GifDataContentHandler"); */
-                /*mailMap.addMailcap(
-                    "multipart/*"
-                        + hndlrStr
-                        + "com.sun.xml.internal.messaging.saaj.soap.MultipartDataContentHandler");*/
-                mailMap.addMailcap(
-                    "image/*"
-                        + hndlrStr
-                        + "com.sun.xml.internal.messaging.saaj.soap.ImageDataContentHandler");
-                mailMap.addMailcap(
-                    "text/plain"
-                        + hndlrStr
-                        + "com.sun.xml.internal.messaging.saaj.soap.StringDataContentHandler");
-            } else {
-                throw new SOAPExceptionImpl("Default CommandMap is not a MailcapCommandMap");
-            }
-        } catch (Throwable t) {
-            log.log(
-                Level.SEVERE,
-                "SAAJ0508.soap.cannot.register.handlers",
-                t);
-            if (t instanceof RuntimeException) {
-                throw (RuntimeException) t;
-            } else {
-                throw new RuntimeException(t.getLocalizedMessage());
-            }
-        }
-    };
-
     private final MimeHeaders headers;
     private MimeBodyPart rawContent = null;
     private DataHandler dataHandler = null;
@@ -126,6 +71,12 @@
 
     public AttachmentPartImpl() {
         headers = new MimeHeaders();
+
+        // initialization from here should cover most of cases;
+        // if not, it would be necessary to call
+        //   AttachmentPartImpl.initializeJavaActivationHandlers()
+        // explicitly by programmer
+        initializeJavaActivationHandlers();
     }
 
     public AttachmentPartImpl(MIMEPart part) {
@@ -263,7 +214,7 @@
         log.log(
             Level.FINE,
             "SAAJ0580.soap.set.Content-Type",
-            new String[] { dataHandler.getContentType()});
+                    new String[] { dataHandler.getContentType() });
         setMimeHeader("Content-Type", dataHandler.getContentType());
     }
 
@@ -405,7 +356,7 @@
             throw new SOAPExceptionImpl(e.getLocalizedMessage());
         } finally {
             try {
-                decoded.close();
+                    decoded.close();
             } catch (IOException ex) {
                 throw new SOAPException(ex);
             }
@@ -608,4 +559,43 @@
         return headers;
     }
 
-}
+    public static void initializeJavaActivationHandlers() {
+        // DataHandler.writeTo() may search for DCH. So adding some default ones.
+        try {
+            CommandMap map = CommandMap.getDefaultCommandMap();
+            if (map instanceof MailcapCommandMap) {
+                MailcapCommandMap mailMap = (MailcapCommandMap) map;
+
+                // registering our DCH since javamail's DCH doesn't handle
+                if (!cmdMapInitialized(mailMap)) {
+                    mailMap.addMailcap("text/xml;;x-java-content-handler=com.sun.xml.internal.messaging.saaj.soap.XmlDataContentHandler");
+                    mailMap.addMailcap("application/xml;;x-java-content-handler=com.sun.xml.internal.messaging.saaj.soap.XmlDataContentHandler");
+                    mailMap.addMailcap("application/fastinfoset;;x-java-content-handler=com.sun.xml.internal.messaging.saaj.soap.FastInfosetDataContentHandler");
+                    mailMap.addMailcap("multipart/*;;x-java-content-handler=com.sun.xml.internal.messaging.saaj.soap.MultipartDataContentHandler");
+                    mailMap.addMailcap("image/*;;x-java-content-handler=com.sun.xml.internal.messaging.saaj.soap.ImageDataContentHandler");
+                    mailMap.addMailcap("text/plain;;x-java-content-handler=com.sun.xml.internal.messaging.saaj.soap.StringDataContentHandler");
+                }
+            }
+        } catch (Throwable t) {
+            // ignore the exception.
+        }
+    }
+
+    private static boolean cmdMapInitialized(MailcapCommandMap mailMap) {
+
+        // checking fastinfoset handler, since this one is specific to SAAJ
+        CommandInfo[] commands = mailMap.getAllCommands("application/fastinfoset");
+        if (commands == null || commands.length == 0) {
+            return false;
+        }
+
+        String saajClassName = "com.sun.xml.internal.ws.binding.FastInfosetDataContentHandler";
+        for (CommandInfo command : commands) {
+            String commandClass = command.getCommandClass();
+            if (saajClassName.equals(commandClass)) {
+                return true;
+            }
+        }
+        return false;
+    }
+}
\ No newline at end of file
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/messaging/saaj/soap/ContextClassloaderLocal.java	Tue Mar 18 12:34:51 2014 -0700
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.sun.xml.internal.messaging.saaj.soap;
+
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+import java.text.MessageFormat;
+import java.util.ResourceBundle;
+import java.util.WeakHashMap;
+
+/**
+ * Simple utility ensuring that the value is cached only in case it is non-internal implementation
+ */
+abstract class ContextClassloaderLocal<V> {
+
+    private static final String FAILED_TO_CREATE_NEW_INSTANCE = "FAILED_TO_CREATE_NEW_INSTANCE";
+
+    private WeakHashMap<ClassLoader, V> CACHE = new WeakHashMap<ClassLoader, V>();
+
+    public V get() throws Error {
+        ClassLoader tccl = getContextClassLoader();
+        V instance = CACHE.get(tccl);
+        if (instance == null) {
+            instance = createNewInstance();
+            CACHE.put(tccl, instance);
+        }
+        return instance;
+    }
+
+    public void set(V instance) {
+        CACHE.put(getContextClassLoader(), instance);
+    }
+
+    protected abstract V initialValue() throws Exception;
+
+    private V createNewInstance() {
+        try {
+            return initialValue();
+        } catch (Exception e) {
+            throw new Error(format(FAILED_TO_CREATE_NEW_INSTANCE, getClass().getName()), e);
+        }
+    }
+
+    private static String format(String property, Object... args) {
+        String text = ResourceBundle.getBundle(ContextClassloaderLocal.class.getName()).getString(property);
+        return MessageFormat.format(text, args);
+    }
+
+    private static ClassLoader getContextClassLoader() {
+        return (ClassLoader)
+                AccessController.doPrivileged(new PrivilegedAction() {
+                    public Object run() {
+                        ClassLoader cl = null;
+                        try {
+                            cl = Thread.currentThread().getContextClassLoader();
+                        } catch (SecurityException ex) {
+                        }
+                        return cl;
+                    }
+                });
+    }
+}
+
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/messaging/saaj/soap/ContextClassloaderLocal.properties	Tue Mar 18 12:34:51 2014 -0700
@@ -0,0 +1,27 @@
+#
+# Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+# Error messages for StaticCache utility class
+FAILED_TO_CREATE_NEW_INSTANCE=Failed to create new instance of {0}
+
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/messaging/saaj/soap/EnvelopeFactory.java	Thu Dec 19 09:01:10 2013 -0800
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/messaging/saaj/soap/EnvelopeFactory.java	Tue Mar 18 12:34:51 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,7 +25,14 @@
 
 package com.sun.xml.internal.messaging.saaj.soap;
 
-import java.util.logging.Logger;
+import com.sun.xml.internal.messaging.saaj.SOAPExceptionImpl;
+import com.sun.xml.internal.messaging.saaj.util.JAXMStreamSource;
+import com.sun.xml.internal.messaging.saaj.util.LogDomainConstants;
+import com.sun.xml.internal.messaging.saaj.util.ParserPool;
+import com.sun.xml.internal.messaging.saaj.util.RejectDoctypeSaxFilter;
+import com.sun.xml.internal.messaging.saaj.util.transform.EfficientStreamingTransformer;
+import org.xml.sax.InputSource;
+import org.xml.sax.XMLReader;
 
 import javax.xml.parsers.SAXParser;
 import javax.xml.soap.SOAPException;
@@ -34,14 +41,7 @@
 import javax.xml.transform.dom.DOMResult;
 import javax.xml.transform.sax.SAXSource;
 import javax.xml.transform.stream.StreamSource;
-
-import org.xml.sax.InputSource;
-import org.xml.sax.XMLReader;
-
-import com.sun.xml.internal.messaging.saaj.SOAPExceptionImpl;
-import com.sun.xml.internal.messaging.saaj.util.*;
-
-import com.sun.xml.internal.messaging.saaj.util.transform.EfficientStreamingTransformer;
+import java.util.logging.Logger;
 
 /**
  * EnvelopeFactory creates SOAP Envelope objects using different
@@ -50,14 +50,19 @@
 public class EnvelopeFactory {
 
     protected static final Logger
-        log = Logger.getLogger(LogDomainConstants.SOAP_DOMAIN,
-        "com.sun.xml.internal.messaging.saaj.soap.LocalStrings");
+            log = Logger.getLogger(LogDomainConstants.SOAP_DOMAIN,
+            "com.sun.xml.internal.messaging.saaj.soap.LocalStrings");
 
-    private static ParserPool parserPool = new ParserPool(5);
+    private static ContextClassloaderLocal<ParserPool> parserPool =
+            new ContextClassloaderLocal<ParserPool>() {
+                @Override
+                protected ParserPool initialValue() throws Exception {
+                    return new ParserPool(5);
+                }
+            };
 
     public static Envelope createEnvelope(Source src, SOAPPartImpl soapPart)
-        throws SOAPException
-    {
+            throws SOAPException {
         // Insert SAX filter to disallow Document Type Declarations since
         // they are not legal in SOAP
         SAXParser saxParser = null;
@@ -73,15 +78,15 @@
                 }
             }
             try {
-                saxParser = parserPool.get();
+                saxParser = parserPool.get().get();
             } catch (Exception e) {
                 log.severe("SAAJ0601.util.newSAXParser.exception");
                 throw new SOAPExceptionImpl(
-                    "Couldn't get a SAX parser while constructing a envelope",
-                    e);
+                        "Couldn't get a SAX parser while constructing a envelope",
+                        e);
             }
             InputSource is = SAXSource.sourceToInputSource(src);
-            if (is.getEncoding()== null && soapPart.getSourceCharsetEncoding() != null) {
+            if (is.getEncoding() == null && soapPart.getSourceCharsetEncoding() != null) {
                 is.setEncoding(soapPart.getSourceCharsetEncoding());
             }
             XMLReader rejectFilter;
@@ -90,15 +95,15 @@
             } catch (Exception ex) {
                 log.severe("SAAJ0510.soap.cannot.create.envelope");
                 throw new SOAPExceptionImpl(
-                    "Unable to create envelope from given source: ",
-                    ex);
+                        "Unable to create envelope from given source: ",
+                        ex);
             }
             src = new SAXSource(rejectFilter, is);
         }
 
         try {
             Transformer transformer =
-                EfficientStreamingTransformer.newTransformer();
+                    EfficientStreamingTransformer.newTransformer();
             DOMResult result = new DOMResult(soapPart);
             transformer.transform(src, result);
 
@@ -110,11 +115,11 @@
             }
             log.severe("SAAJ0511.soap.cannot.create.envelope");
             throw new SOAPExceptionImpl(
-                "Unable to create envelope from given source: ",
-                ex);
+                    "Unable to create envelope from given source: ",
+                    ex);
         } finally {
             if (saxParser != null) {
-                parserPool.returnParser(saxParser);
+                parserPool.get().returnParser(saxParser);
             }
         }
     }
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/stream/buffer/ContextClassloaderLocal.java	Tue Mar 18 12:34:51 2014 -0700
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.sun.xml.internal.stream.buffer;
+
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+import java.text.MessageFormat;
+import java.util.ResourceBundle;
+import java.util.WeakHashMap;
+
+/**
+ * Simple utility ensuring that the value is cached only in case it is non-internal implementation
+ */
+abstract class ContextClassloaderLocal<V> {
+
+    private static final String FAILED_TO_CREATE_NEW_INSTANCE = "FAILED_TO_CREATE_NEW_INSTANCE";
+
+    private WeakHashMap<ClassLoader, V> CACHE = new WeakHashMap<ClassLoader, V>();
+
+    public V get() throws Error {
+        ClassLoader tccl = getContextClassLoader();
+        V instance = CACHE.get(tccl);
+        if (instance == null) {
+            instance = createNewInstance();
+            CACHE.put(tccl, instance);
+        }
+        return instance;
+    }
+
+    public void set(V instance) {
+        CACHE.put(getContextClassLoader(), instance);
+    }
+
+    protected abstract V initialValue() throws Exception;
+
+    private V createNewInstance() {
+        try {
+            return initialValue();
+        } catch (Exception e) {
+            throw new Error(format(FAILED_TO_CREATE_NEW_INSTANCE, getClass().getName()), e);
+        }
+    }
+
+    private static String format(String property, Object... args) {
+        String text = ResourceBundle.getBundle(ContextClassloaderLocal.class.getName()).getString(property);
+        return MessageFormat.format(text, args);
+    }
+
+    private static ClassLoader getContextClassLoader() {
+        return (ClassLoader)
+                AccessController.doPrivileged(new PrivilegedAction() {
+                    public Object run() {
+                        ClassLoader cl = null;
+                        try {
+                            cl = Thread.currentThread().getContextClassLoader();
+                        } catch (SecurityException ex) {
+                        }
+                        return cl;
+                    }
+                });
+    }
+}
+
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/stream/buffer/ContextClassloaderLocal.properties	Tue Mar 18 12:34:51 2014 -0700
@@ -0,0 +1,27 @@
+#
+# Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+# Error messages for ContextClassloaderLocal utility class
+FAILED_TO_CREATE_NEW_INSTANCE=Failed to create new instance of {0}
+
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/stream/buffer/XMLStreamBuffer.java	Thu Dec 19 09:01:10 2013 -0800
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/stream/buffer/XMLStreamBuffer.java	Tue Mar 18 12:34:51 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -370,7 +370,12 @@
         writeTo(handler, errorHandler, isFragment());
     }
 
-    private static final TransformerFactory trnsformerFactory = TransformerFactory.newInstance();
+    private static final ContextClassloaderLocal<TransformerFactory> trnsformerFactory = new ContextClassloaderLocal<TransformerFactory>() {
+        @Override
+        protected TransformerFactory initialValue() throws Exception {
+            return TransformerFactory.newInstance();
+        }
+    };
 
     /**
      * Writes out the contents of this buffer as DOM node and append that to the given node.
@@ -382,7 +387,7 @@
      */
     public final Node writeTo(Node n) throws XMLStreamBufferException {
         try {
-            Transformer t = trnsformerFactory.newTransformer();
+            Transformer t = trnsformerFactory.get().newTransformer();
             t.transform(new XMLStreamBufferSource(this), new DOMResult(n));
             return n.getLastChild();
         } catch (TransformerException e) {
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/api/streaming/ContextClassloaderLocal.java	Tue Mar 18 12:34:51 2014 -0700
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.sun.xml.internal.ws.api.streaming;
+
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+import java.text.MessageFormat;
+import java.util.ResourceBundle;
+import java.util.WeakHashMap;
+
+/**
+ * Simple utility ensuring that the value is cached only in case it is non-internal implementation
+ */
+abstract class ContextClassloaderLocal<V> {
+
+    private static final String FAILED_TO_CREATE_NEW_INSTANCE = "FAILED_TO_CREATE_NEW_INSTANCE";
+
+    private WeakHashMap<ClassLoader, V> CACHE = new WeakHashMap<ClassLoader, V>();
+
+    public V get() throws Error {
+        ClassLoader tccl = getContextClassLoader();
+        V instance = CACHE.get(tccl);
+        if (instance == null) {
+            instance = createNewInstance();
+            CACHE.put(tccl, instance);
+        }
+        return instance;
+    }
+
+    public void set(V instance) {
+        CACHE.put(getContextClassLoader(), instance);
+    }
+
+    protected abstract V initialValue() throws Exception;
+
+    private V createNewInstance() {
+        try {
+            return initialValue();
+        } catch (Exception e) {
+            throw new Error(format(FAILED_TO_CREATE_NEW_INSTANCE, getClass().getName()), e);
+        }
+    }
+
+    private static String format(String property, Object... args) {
+        String text = ResourceBundle.getBundle(ContextClassloaderLocal.class.getName()).getString(property);
+        return MessageFormat.format(text, args);
+    }
+
+    private static ClassLoader getContextClassLoader() {
+        return (ClassLoader)
+                AccessController.doPrivileged(new PrivilegedAction() {
+                    public Object run() {
+                        ClassLoader cl = null;
+                        try {
+                            cl = Thread.currentThread().getContextClassLoader();
+                        } catch (SecurityException ex) {
+                        }
+                        return cl;
+                    }
+                });
+    }
+}
+
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/api/streaming/ContextClassloaderLocal.properties	Tue Mar 18 12:34:51 2014 -0700
@@ -0,0 +1,27 @@
+#
+# Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+# Error messages for ContextClassloaderLocal utility class
+FAILED_TO_CREATE_NEW_INSTANCE=Failed to create new instance of {0}
+
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/api/streaming/XMLStreamReaderFactory.java	Thu Dec 19 09:01:10 2013 -0800
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/api/streaming/XMLStreamReaderFactory.java	Tue Mar 18 12:34:51 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -61,29 +61,32 @@
     /**
      * Singleton instance.
      */
-    private static volatile @NotNull XMLStreamReaderFactory theInstance;
+    private static volatile ContextClassloaderLocal<XMLStreamReaderFactory> streamReader =
+            new ContextClassloaderLocal<XMLStreamReaderFactory>() {
 
-    static {
-        XMLInputFactory xif = getXMLInputFactory();
-        XMLStreamReaderFactory f=null;
+        @Override
+        protected XMLStreamReaderFactory initialValue() {
+            XMLInputFactory xif = getXMLInputFactory();
+            XMLStreamReaderFactory f=null;
 
-        // this system property can be used to disable the pooling altogether,
-        // in case someone hits an issue with pooling in the production system.
-        if(!getProperty(XMLStreamReaderFactory.class.getName()+".noPool"))
-            f = Zephyr.newInstance(xif);
+            // this system property can be used to disable the pooling altogether,
+            // in case someone hits an issue with pooling in the production system.
+            if(!getProperty(XMLStreamReaderFactory.class.getName()+".noPool"))
+                f = Zephyr.newInstance(xif);
 
-        if(f==null) {
-            // is this Woodstox?
-            if(xif.getClass().getName().equals("com.ctc.wstx.stax.WstxInputFactory"))
-                f = new Woodstox(xif);
+            if(f==null) {
+                // is this Woodstox?
+                if(xif.getClass().getName().equals("com.ctc.wstx.stax.WstxInputFactory"))
+                    f = new Woodstox(xif);
+            }
+
+            if(f==null)
+                f = new Default();
+
+            LOGGER.fine("XMLStreamReaderFactory instance is = "+f);
+            return f;
         }
-
-        if(f==null)
-            f = new Default();
-
-        theInstance = f;
-        LOGGER.fine("XMLStreamReaderFactory instance is = "+theInstance);
-    }
+    };
 
     private static XMLInputFactory getXMLInputFactory() {
         XMLInputFactory xif = null;
@@ -109,11 +112,11 @@
      */
     public static void set(XMLStreamReaderFactory f) {
         if(f==null) throw new IllegalArgumentException();
-        theInstance = f;
+        streamReader.set(f);
     }
 
     public static XMLStreamReaderFactory get() {
-        return theInstance;
+        return streamReader.get();
     }
 
     public static XMLStreamReader create(InputSource source, boolean rejectDTDs) {
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/api/streaming/XMLStreamWriterFactory.java	Thu Dec 19 09:01:10 2013 -0800
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/api/streaming/XMLStreamWriterFactory.java	Tue Mar 18 12:34:51 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -57,39 +57,41 @@
     /**
      * Singleton instance.
      */
-    private static volatile @NotNull XMLStreamWriterFactory theInstance;
+    private static volatile ContextClassloaderLocal<XMLStreamWriterFactory> writerFactory =
+            new ContextClassloaderLocal<XMLStreamWriterFactory>() {
 
+        @Override
+        protected XMLStreamWriterFactory initialValue() {
+            XMLOutputFactory  xof = null;
+            if (Boolean.getBoolean(XMLStreamWriterFactory.class.getName()+".woodstox")) {
+                try {
+                    xof = (XMLOutputFactory)Class.forName("com.ctc.wstx.stax.WstxOutputFactory").newInstance();
+                } catch (Exception e) {
+                    // Ignore and fallback to default XMLOutputFactory
+                }
+            }
+            if (xof == null) {
+                xof = XMLOutputFactory.newInstance();
+            }
 
-    static {
-        XMLOutputFactory  xof = null;
-        if (Boolean.getBoolean(XMLStreamWriterFactory.class.getName()+".woodstox")) {
-            try {
-                xof = (XMLOutputFactory)Class.forName("com.ctc.wstx.stax.WstxOutputFactory").newInstance();
-            } catch (Exception e) {
-                // Ignore and fallback to default XMLOutputFactory
+            XMLStreamWriterFactory f=null;
+
+            // this system property can be used to disable the pooling altogether,
+            // in case someone hits an issue with pooling in the production system.
+            if(!Boolean.getBoolean(XMLStreamWriterFactory.class.getName()+".noPool"))
+                f = Zephyr.newInstance(xof);
+            if(f==null) {
+                // is this Woodstox?
+                if(xof.getClass().getName().equals("com.ctc.wstx.stax.WstxOutputFactory"))
+                    f = new NoLock(xof);
             }
+            if (f == null)
+                f = new Default(xof);
+
+            LOGGER.fine("XMLStreamWriterFactory instance is = "+ f);
+            return f;
         }
-        if (xof == null) {
-            xof = XMLOutputFactory.newInstance();
-        }
-
-        XMLStreamWriterFactory f=null;
-
-        // this system property can be used to disable the pooling altogether,
-        // in case someone hits an issue with pooling in the production system.
-        if(!Boolean.getBoolean(XMLStreamWriterFactory.class.getName()+".noPool"))
-            f = Zephyr.newInstance(xof);
-        if(f==null) {
-            // is this Woodstox?
-            if(xof.getClass().getName().equals("com.ctc.wstx.stax.WstxOutputFactory"))
-                f = new NoLock(xof);
-        }
-        if (f == null)
-            f = new Default(xof);
-
-        theInstance = f;
-        LOGGER.fine("XMLStreamWriterFactory instance is = "+theInstance);
-    }
+    };
 
     /**
      * See {@link #create(OutputStream)} for the contract.
@@ -152,7 +154,7 @@
      * Gets the singleton instance.
      */
     public static @NotNull XMLStreamWriterFactory get() {
-        return theInstance;
+        return writerFactory.get();
     }
 
     /**
@@ -164,7 +166,7 @@
      */
     public static void set(@NotNull XMLStreamWriterFactory f) {
         if(f==null) throw new IllegalArgumentException();
-        theInstance = f;
+        writerFactory.set(f);
     }
 
     /**
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/binding/BindingImpl.java	Thu Dec 19 09:01:10 2013 -0800
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/binding/BindingImpl.java	Tue Mar 18 12:34:51 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -36,6 +36,9 @@
 import com.sun.xml.internal.ws.developer.MemberSubmissionAddressingFeature;
 import com.sun.xml.internal.ws.developer.BindingTypeFeature;
 
+import javax.activation.CommandInfo;
+import javax.activation.CommandMap;
+import javax.activation.MailcapCommandMap;
 import javax.xml.ws.Service;
 import javax.xml.ws.WebServiceFeature;
 import javax.xml.ws.soap.AddressingFeature;
@@ -109,9 +112,15 @@
         return addressingVersion;
     }
 
-    public final
     @NotNull
-    Codec createCodec() {
+    public final Codec createCodec() {
+
+        // initialization from here should cover most of cases;
+        // if not, it would be necessary to call
+        //   BindingImpl.initializeJavaActivationHandlers()
+        // explicitly by programmer
+        initializeJavaActivationHandlers();
+
         return bindingId.createEncoder(this);
     }
 
@@ -169,4 +178,48 @@
     public void addFeature(@NotNull WebServiceFeature newFeature) {
         features.add(newFeature);
     }
+
+    public static void initializeJavaActivationHandlers() {
+        // DataHandler.writeTo() may search for DCH. So adding some default ones.
+        try {
+            CommandMap map = CommandMap.getDefaultCommandMap();
+            if (map instanceof MailcapCommandMap) {
+                MailcapCommandMap mailMap = (MailcapCommandMap) map;
+
+                // registering our DCH since javamail's DCH doesn't handle
+                if (!cmdMapInitialized(mailMap)) {
+                    mailMap.addMailcap("text/xml;;x-java-content-handler=com.sun.xml.internal.ws.encoding.XmlDataContentHandler");
+                    mailMap.addMailcap("application/xml;;x-java-content-handler=com.sun.xml.internal.ws.encoding.XmlDataContentHandler");
+                    mailMap.addMailcap("image/*;;x-java-content-handler=com.sun.xml.internal.ws.encoding.ImageDataContentHandler");
+                    mailMap.addMailcap("text/plain;;x-java-content-handler=com.sun.xml.internal.ws.encoding.StringDataContentHandler");
+                }
+            }
+        } catch (Throwable t) {
+            // ignore the exception.
+        }
+    }
+
+    private static boolean cmdMapInitialized(MailcapCommandMap mailMap) {
+        CommandInfo[] commands = mailMap.getAllCommands("text/xml");
+        if (commands == null || commands.length == 0) {
+            return false;
+        }
+
+        // SAAJ RI implements it's own DataHandlers which can be used for JAX-WS too;
+        // see com.sun.xml.internal.messaging.saaj.soap.AttachmentPartImpl#initializeJavaActivationHandlers
+        // so if found any of SAAJ or our own handler registered, we are ok; anyway using SAAJ directly here
+        // is not good idea since we don't want standalone JAX-WS to depend on specific SAAJ impl.
+        // This is also reason for duplication of Handler's code by JAX-WS
+        String saajClassName = "com.sun.xml.internal.messaging.saaj.soap.XmlDataContentHandler";
+        String jaxwsClassName = "com.sun.xml.internal.ws.encoding.XmlDataContentHandler";
+        for (CommandInfo command : commands) {
+            String commandClass = command.getCommandClass();
+            if (saajClassName.equals(commandClass) ||
+                    jaxwsClassName.equals(commandClass)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
 }
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/developer/ContextClassloaderLocal.java	Tue Mar 18 12:34:51 2014 -0700
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.sun.xml.internal.ws.developer;
+
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+import java.text.MessageFormat;
+import java.util.ResourceBundle;
+import java.util.WeakHashMap;
+
+/**
+ * Simple utility ensuring that the value is cached only in case it is non-internal implementation
+ */
+abstract class ContextClassloaderLocal<V> {
+
+    private static final String FAILED_TO_CREATE_NEW_INSTANCE = "FAILED_TO_CREATE_NEW_INSTANCE";
+
+    private WeakHashMap<ClassLoader, V> CACHE = new WeakHashMap<ClassLoader, V>();
+
+    public V get() throws Error {
+        ClassLoader tccl = getContextClassLoader();
+        V instance = CACHE.get(tccl);
+        if (instance == null) {
+            instance = createNewInstance();
+            CACHE.put(tccl, instance);
+        }
+        return instance;
+    }
+
+    public void set(V instance) {
+        CACHE.put(getContextClassLoader(), instance);
+    }
+
+    protected abstract V initialValue() throws Exception;
+
+    private V createNewInstance() {
+        try {
+            return initialValue();
+        } catch (Exception e) {
+            throw new Error(format(FAILED_TO_CREATE_NEW_INSTANCE, getClass().getName()), e);
+        }
+    }
+
+    private static String format(String property, Object... args) {
+        String text = ResourceBundle.getBundle(ContextClassloaderLocal.class.getName()).getString(property);
+        return MessageFormat.format(text, args);
+    }
+
+    private static ClassLoader getContextClassLoader() {
+        return (ClassLoader)
+                AccessController.doPrivileged(new PrivilegedAction() {
+                    public Object run() {
+                        ClassLoader cl = null;
+                        try {
+                            cl = Thread.currentThread().getContextClassLoader();
+                        } catch (SecurityException ex) {
+                        }
+                        return cl;
+                    }
+                });
+    }
+}
+
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/developer/ContextClassloaderLocal.properties	Tue Mar 18 12:34:51 2014 -0700
@@ -0,0 +1,27 @@
+#
+# Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+# Error messages for ContextClassloaderLocal utility class
+FAILED_TO_CREATE_NEW_INSTANCE=Failed to create new instance of {0}
+
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/developer/MemberSubmissionEndpointReference.java	Thu Dec 19 09:01:10 2013 -0800
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/developer/MemberSubmissionEndpointReference.java	Tue Mar 18 12:34:51 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -64,7 +64,12 @@
 @XmlType(name = "EndpointReferenceType", namespace = MemberSubmissionEndpointReference.MSNS)
 public final class MemberSubmissionEndpointReference extends EndpointReference implements MemberSubmissionAddressingConstants {
 
-    private final static JAXBContext msjc = MemberSubmissionEndpointReference.getMSJaxbContext();
+    private final static ContextClassloaderLocal<JAXBContext> msjc = new ContextClassloaderLocal<JAXBContext>() {
+        @Override
+        protected JAXBContext initialValue() throws Exception {
+            return MemberSubmissionEndpointReference.getMSJaxbContext();
+        }
+    };
 
     public MemberSubmissionEndpointReference() {
     }
@@ -85,7 +90,7 @@
             throw new WebServiceException("Source parameter can not be null on constructor");
 
         try {
-            Unmarshaller unmarshaller = MemberSubmissionEndpointReference.msjc.createUnmarshaller();
+            Unmarshaller unmarshaller = MemberSubmissionEndpointReference.msjc.get().createUnmarshaller();
             MemberSubmissionEndpointReference epr = unmarshaller.unmarshal(source,MemberSubmissionEndpointReference.class).getValue();
 
             this.addr = epr.addr;
@@ -104,7 +109,7 @@
 
     public void writeTo(Result result) {
         try {
-            Marshaller marshaller = MemberSubmissionEndpointReference.msjc.createMarshaller();
+            Marshaller marshaller = MemberSubmissionEndpointReference.msjc.get().createMarshaller();
             //marshaller.setProperty(Marshaller.JAXB_FRAGMENT, true);
             marshaller.marshal(this, result);
         } catch (JAXBException e) {
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/encoding/MimeCodec.java	Thu Dec 19 09:01:10 2013 -0800
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/encoding/MimeCodec.java	Tue Mar 18 12:34:51 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -34,9 +34,6 @@
 import com.sun.xml.internal.ws.api.pipe.ContentType;
 import com.sun.xml.internal.ws.developer.StreamingAttachmentFeature;
 
-import javax.activation.CommandMap;
-import javax.activation.MailcapCommandMap;
-import javax.activation.DataContentHandler;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -62,33 +59,6 @@
  */
 abstract class MimeCodec implements Codec {
 
-    static {
-        // DataHandler.writeTo() may search for DCH. So adding some default ones.
-        try {
-            CommandMap map = CommandMap.getDefaultCommandMap();
-            if (map instanceof MailcapCommandMap) {
-                MailcapCommandMap mailMap = (MailcapCommandMap) map;
-                String hndlrStr = ";;x-java-content-handler=";
-                // registering our DCH since javamail's DCH doesn't handle
-                // Source
-                mailMap.addMailcap(
-                    "text/xml" + hndlrStr + XmlDataContentHandler.class.getName());
-                mailMap.addMailcap(
-                    "application/xml" + hndlrStr + XmlDataContentHandler.class.getName());
-                if (map.createDataContentHandler("image/*") == null) {
-                    mailMap.addMailcap(
-                        "image/*" + hndlrStr + ImageDataContentHandler.class.getName());
-                }
-                if (map.createDataContentHandler("text/plain") == null) {
-                    mailMap.addMailcap(
-                        "text/plain" + hndlrStr + StringDataContentHandler.class.getName());
-                }
-            }
-        } catch (Throwable t) {
-            // ignore the exception.
-        }
-    }
-
     public static final String MULTIPART_RELATED_MIME_TYPE = "multipart/related";
 
     private String boundary;
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/sourcemodel/attach/ContextClassloaderLocal.java	Tue Mar 18 12:34:51 2014 -0700
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.sun.xml.internal.ws.policy.sourcemodel.attach;
+
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+import java.text.MessageFormat;
+import java.util.ResourceBundle;
+import java.util.WeakHashMap;
+
+/**
+ * Simple utility ensuring that the value is cached only in case it is non-internal implementation
+ */
+abstract class ContextClassloaderLocal<V> {
+
+    private static final String FAILED_TO_CREATE_NEW_INSTANCE = "FAILED_TO_CREATE_NEW_INSTANCE";
+
+    private WeakHashMap<ClassLoader, V> CACHE = new WeakHashMap<ClassLoader, V>();
+
+    public V get() throws Error {
+        ClassLoader tccl = getContextClassLoader();
+        V instance = CACHE.get(tccl);
+        if (instance == null) {
+            instance = createNewInstance();
+            CACHE.put(tccl, instance);
+        }
+        return instance;
+    }
+
+    public void set(V instance) {
+        CACHE.put(getContextClassLoader(), instance);
+    }
+
+    protected abstract V initialValue() throws Exception;
+
+    private V createNewInstance() {
+        try {
+            return initialValue();
+        } catch (Exception e) {
+            throw new Error(format(FAILED_TO_CREATE_NEW_INSTANCE, getClass().getName()), e);
+        }
+    }
+
+    private static String format(String property, Object... args) {
+        String text = ResourceBundle.getBundle(ContextClassloaderLocal.class.getName()).getString(property);
+        return MessageFormat.format(text, args);
+    }
+
+    private static ClassLoader getContextClassLoader() {
+        return (ClassLoader)
+                AccessController.doPrivileged(new PrivilegedAction() {
+                    public Object run() {
+                        ClassLoader cl = null;
+                        try {
+                            cl = Thread.currentThread().getContextClassLoader();
+                        } catch (SecurityException ex) {
+                        }
+                        return cl;
+                    }
+                });
+    }
+}
+
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/sourcemodel/attach/ContextClassloaderLocal.properties	Tue Mar 18 12:34:51 2014 -0700
@@ -0,0 +1,27 @@
+#
+# Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+# Error messages for ContextClassloaderLocal utility class
+FAILED_TO_CREATE_NEW_INSTANCE=Failed to create new instance of {0}
+
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/sourcemodel/attach/ExternalAttachmentsUnmarshaller.java	Thu Dec 19 09:01:10 2013 -0800
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/sourcemodel/attach/ExternalAttachmentsUnmarshaller.java	Tue Mar 18 12:34:51 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -83,7 +83,13 @@
     private static final QName POLICY = new QName("http://www.w3.org/ns/ws-policy", "Policy");
     private static final QName URI = new QName("http://www.w3.org/ns/ws-policy", "URI");
     private static final QName POLICIES = new QName(PolicyConstants.SUN_MANAGEMENT_NAMESPACE, "Policies");
-    private static final XMLInputFactory XML_INPUT_FACTORY = XMLInputFactory.newInstance();
+    private static final ContextClassloaderLocal<XMLInputFactory> XML_INPUT_FACTORY = new ContextClassloaderLocal<XMLInputFactory>() {
+        @Override
+        protected XMLInputFactory initialValue() throws Exception {
+            return XMLInputFactory.newInstance();
+        }
+    };
+
     private static final PolicyModelUnmarshaller POLICY_UNMARSHALLER = PolicyModelUnmarshaller.getXmlUnmarshaller();
 
     private final Map<URI, Policy> map = new HashMap<URI, Policy>();
@@ -93,7 +99,7 @@
     public static Map<URI, Policy> unmarshal(final Reader source) throws PolicyException {
         LOGGER.entering(source);
         try {
-            XMLEventReader reader = XML_INPUT_FACTORY.createXMLEventReader(source);
+            XMLEventReader reader = XML_INPUT_FACTORY.get().createXMLEventReader(source);
             ExternalAttachmentsUnmarshaller instance = new ExternalAttachmentsUnmarshaller();
             final Map<URI, Policy> map = instance.unmarshal(reader, null);
             LOGGER.exiting(map);
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/spi/ContextClassloaderLocal.java	Tue Mar 18 12:34:51 2014 -0700
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.sun.xml.internal.ws.spi;
+
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+import java.text.MessageFormat;
+import java.util.ResourceBundle;
+import java.util.WeakHashMap;
+
+/**
+ * Simple utility ensuring that the value is cached only in case it is non-internal implementation
+ */
+abstract class ContextClassloaderLocal<V> {
+
+    private static final String FAILED_TO_CREATE_NEW_INSTANCE = "FAILED_TO_CREATE_NEW_INSTANCE";
+
+    private WeakHashMap<ClassLoader, V> CACHE = new WeakHashMap<ClassLoader, V>();
+
+    public V get() throws Error {
+        ClassLoader tccl = getContextClassLoader();
+        V instance = CACHE.get(tccl);
+        if (instance == null) {
+            instance = createNewInstance();
+            CACHE.put(tccl, instance);
+        }
+        return instance;
+    }
+
+    public void set(V instance) {
+        CACHE.put(getContextClassLoader(), instance);
+    }
+
+    protected abstract V initialValue() throws Exception;
+
+    private V createNewInstance() {
+        try {
+            return initialValue();
+        } catch (Exception e) {
+            throw new Error(format(FAILED_TO_CREATE_NEW_INSTANCE, getClass().getName()), e);
+        }
+    }
+
+    private static String format(String property, Object... args) {
+        String text = ResourceBundle.getBundle(ContextClassloaderLocal.class.getName()).getString(property);
+        return MessageFormat.format(text, args);
+    }
+
+    private static ClassLoader getContextClassLoader() {
+        return (ClassLoader)
+                AccessController.doPrivileged(new PrivilegedAction() {
+                    public Object run() {
+                        ClassLoader cl = null;
+                        try {
+                            cl = Thread.currentThread().getContextClassLoader();
+                        } catch (SecurityException ex) {
+                        }
+                        return cl;
+                    }
+                });
+    }
+}
+
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/spi/ContextClassloaderLocal.properties	Tue Mar 18 12:34:51 2014 -0700
@@ -0,0 +1,27 @@
+#
+# Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+# Error messages for StaticCache utility class
+FAILED_TO_CREATE_NEW_INSTANCE=Failed to create new instance of {0}
+
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/spi/ProviderImpl.java	Thu Dec 19 09:01:10 2013 -0800
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/spi/ProviderImpl.java	Tue Mar 18 12:34:51 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -77,7 +77,12 @@
  */
 public class ProviderImpl extends Provider {
 
-    private final static JAXBContext eprjc = getEPRJaxbContext();
+    private final static ContextClassloaderLocal<JAXBContext> eprjc = new ContextClassloaderLocal<JAXBContext>() {
+        @Override
+        protected JAXBContext initialValue() throws Exception {
+            return getEPRJaxbContext();
+        }
+    };
 
     /**
      * Convenient singleton instance.
@@ -140,7 +145,7 @@
         return AccessController.doPrivileged(new PrivilegedAction<EndpointReference>() {
             public EndpointReference run() {
                 try {
-                    Unmarshaller unmarshaller = eprjc.createUnmarshaller();
+                    Unmarshaller unmarshaller = eprjc.get().createUnmarshaller();
                     return (EndpointReference) unmarshaller.unmarshal(eprInfoset);
                 } catch (JAXBException e) {
                     throw new WebServiceException("Error creating Marshaller or marshalling.", e);
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/util/xml/ContextClassloaderLocal.java	Tue Mar 18 12:34:51 2014 -0700
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.sun.xml.internal.ws.util.xml;
+
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+import java.text.MessageFormat;
+import java.util.ResourceBundle;
+import java.util.WeakHashMap;
+
+/**
+ * Simple utility ensuring that the value is cached only in case it is non-internal implementation
+ */
+abstract class ContextClassloaderLocal<V> {
+
+    private static final String FAILED_TO_CREATE_NEW_INSTANCE = "FAILED_TO_CREATE_NEW_INSTANCE";
+
+    private WeakHashMap<ClassLoader, V> CACHE = new WeakHashMap<ClassLoader, V>();
+
+    public V get() throws Error {
+        ClassLoader tccl = getContextClassLoader();
+        V instance = CACHE.get(tccl);
+        if (instance == null) {
+            instance = createNewInstance();
+            CACHE.put(tccl, instance);
+        }
+        return instance;
+    }
+
+    public void set(V instance) {
+        CACHE.put(getContextClassLoader(), instance);
+    }
+
+    protected abstract V initialValue() throws Exception;
+
+    private V createNewInstance() {
+        try {
+            return initialValue();
+        } catch (Exception e) {
+            throw new Error(format(FAILED_TO_CREATE_NEW_INSTANCE, getClass().getName()), e);
+        }
+    }
+
+    private static String format(String property, Object... args) {
+        String text = ResourceBundle.getBundle(ContextClassloaderLocal.class.getName()).getString(property);
+        return MessageFormat.format(text, args);
+    }
+
+    private static ClassLoader getContextClassLoader() {
+        return (ClassLoader)
+                AccessController.doPrivileged(new PrivilegedAction() {
+                    public Object run() {
+                        ClassLoader cl = null;
+                        try {
+                            cl = Thread.currentThread().getContextClassLoader();
+                        } catch (SecurityException ex) {
+                        }
+                        return cl;
+                    }
+                });
+    }
+}
+
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/util/xml/ContextClassloaderLocal.properties	Tue Mar 18 12:34:51 2014 -0700
@@ -0,0 +1,27 @@
+#
+# Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+# Error messages for StaticCache utility class
+FAILED_TO_CREATE_NEW_INSTANCE=Failed to create new instance of {0}
+
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/util/xml/XmlUtil.java	Thu Dec 19 09:01:10 2013 -0800
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/util/xml/XmlUtil.java	Tue Mar 18 12:34:51 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -199,20 +199,28 @@
         }
     }
 
-    static final TransformerFactory transformerFactory = TransformerFactory.newInstance();
+    static final ContextClassloaderLocal<TransformerFactory> transformerFactory = new ContextClassloaderLocal<TransformerFactory>() {
+        @Override
+        protected TransformerFactory initialValue() throws Exception {
+            return TransformerFactory.newInstance();
+        }
+    };
 
-    static final SAXParserFactory saxParserFactory = SAXParserFactory.newInstance();
-
-    static {
-        saxParserFactory.setNamespaceAware(true);
-    }
+    static final ContextClassloaderLocal<SAXParserFactory> saxParserFactory = new ContextClassloaderLocal<SAXParserFactory>() {
+        @Override
+        protected SAXParserFactory initialValue() throws Exception {
+            SAXParserFactory factory = SAXParserFactory.newInstance();
+            factory.setNamespaceAware(true);
+            return factory;
+        }
+    };
 
     /**
      * Creates a new identity transformer.
      */
     public static Transformer newTransformer() {
         try {
-            return transformerFactory.newTransformer();
+            return transformerFactory.get().newTransformer();
         } catch (TransformerConfigurationException tex) {
             throw new IllegalStateException("Unable to create a JAXP transformer");
         }
@@ -227,9 +235,9 @@
             // work around a bug in JAXP in JDK6u4 and earlier where the namespace processing
             // is not turned on by default
             StreamSource ssrc = (StreamSource) src;
-            TransformerHandler th = ((SAXTransformerFactory) transformerFactory).newTransformerHandler();
+            TransformerHandler th = ((SAXTransformerFactory) transformerFactory.get()).newTransformerHandler();
             th.setResult(result);
-            XMLReader reader = saxParserFactory.newSAXParser().getXMLReader();
+            XMLReader reader = saxParserFactory.get().newSAXParser().getXMLReader();
             reader.setContentHandler(th);
             reader.setProperty(LEXICAL_HANDLER_PROPERTY, th);
             reader.parse(toInputSource(ssrc));
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/xsom/util/ContextClassloaderLocal.java	Tue Mar 18 12:34:51 2014 -0700
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.sun.xml.internal.xsom.util;
+
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+import java.text.MessageFormat;
+import java.util.ResourceBundle;
+import java.util.WeakHashMap;
+
+/**
+ * Simple utility ensuring that the value is cached only in case it is non-internal implementation
+ */
+abstract class ContextClassloaderLocal<V> {
+
+    private static final String FAILED_TO_CREATE_NEW_INSTANCE = "FAILED_TO_CREATE_NEW_INSTANCE";
+
+    private WeakHashMap<ClassLoader, V> CACHE = new WeakHashMap<ClassLoader, V>();
+
+    public V get() throws Error {
+        ClassLoader tccl = getContextClassLoader();
+        V instance = CACHE.get(tccl);
+        if (instance == null) {
+            instance = createNewInstance();
+            CACHE.put(tccl, instance);
+        }
+        return instance;
+    }
+
+    public void set(V instance) {
+        CACHE.put(getContextClassLoader(), instance);
+    }
+
+    protected abstract V initialValue() throws Exception;
+
+    private V createNewInstance() {
+        try {
+            return initialValue();
+        } catch (Exception e) {
+            throw new Error(format(FAILED_TO_CREATE_NEW_INSTANCE, getClass().getName()), e);
+        }
+    }
+
+    private static String format(String property, Object... args) {
+        String text = ResourceBundle.getBundle(ContextClassloaderLocal.class.getName()).getString(property);
+        return MessageFormat.format(text, args);
+    }
+
+    private static ClassLoader getContextClassLoader() {
+        return (ClassLoader)
+                AccessController.doPrivileged(new PrivilegedAction() {
+                    public Object run() {
+                        ClassLoader cl = null;
+                        try {
+                            cl = Thread.currentThread().getContextClassLoader();
+                        } catch (SecurityException ex) {
+                        }
+                        return cl;
+                    }
+                });
+    }
+}
+
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/xsom/util/ContextClassloaderLocal.properties	Tue Mar 18 12:34:51 2014 -0700
@@ -0,0 +1,27 @@
+#
+# Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+# Error messages for ContextClassloaderLocal utility class
+FAILED_TO_CREATE_NEW_INSTANCE=Failed to create new instance of {0}
+
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/xsom/util/DomAnnotationParserFactory.java	Thu Dec 19 09:01:10 2013 -0800
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/xsom/util/DomAnnotationParserFactory.java	Tue Mar 18 12:34:51 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -60,7 +60,12 @@
         return new AnnotationParserImpl();
     }
 
-    private static final SAXTransformerFactory stf = (SAXTransformerFactory) SAXTransformerFactory.newInstance();
+    private static final ContextClassloaderLocal<SAXTransformerFactory> stf = new ContextClassloaderLocal<SAXTransformerFactory>() {
+        @Override
+        protected SAXTransformerFactory initialValue() throws Exception {
+            return (SAXTransformerFactory) SAXTransformerFactory.newInstance();
+        }
+    };
 
     private static class AnnotationParserImpl extends AnnotationParser {
 
@@ -72,7 +77,7 @@
 
         AnnotationParserImpl() {
             try {
-                transformer = stf.newTransformerHandler();
+                transformer = stf.get().newTransformerHandler();
             } catch (TransformerConfigurationException e) {
                 throw new Error(e); // impossible
             }
--- ./jaxws/src/share/jaxws_classes/javax/xml/bind/DatatypeConverterImpl.java	Thu Dec 19 09:01:10 2013 -0800
+++ ./jaxws/src/share/jaxws_classes/javax/xml/bind/DatatypeConverterImpl.java	Tue Mar 18 12:34:51 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2007, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,9 +27,14 @@
 
 import java.math.BigDecimal;
 import java.math.BigInteger;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 import java.util.Calendar;
+import java.util.Collections;
 import java.util.GregorianCalendar;
+import java.util.Map;
 import java.util.TimeZone;
+import java.util.WeakHashMap;
 
 import javax.xml.namespace.QName;
 import javax.xml.namespace.NamespaceContext;
@@ -418,7 +423,7 @@
 
     public static GregorianCalendar _parseDateTime(CharSequence s) {
         String val = WhiteSpaceProcessor.trim(s).toString();
-        return datatypeFactory.newXMLGregorianCalendar(val).toGregorianCalendar();
+        return getDatatypeFactory().newXMLGregorianCalendar(val).toGregorianCalendar();
     }
 
     public String printDateTime(Calendar val) {
@@ -492,7 +497,7 @@
     }
 
     public Calendar parseTime(String lexicalXSDTime) {
-        return datatypeFactory.newXMLGregorianCalendar(lexicalXSDTime).toGregorianCalendar();
+        return getDatatypeFactory().newXMLGregorianCalendar(lexicalXSDTime).toGregorianCalendar();
     }
 
     public String printTime(Calendar val) {
@@ -500,7 +505,7 @@
     }
 
     public Calendar parseDate(String lexicalXSDDate) {
-        return datatypeFactory.newXMLGregorianCalendar(lexicalXSDDate).toGregorianCalendar();
+        return getDatatypeFactory().newXMLGregorianCalendar(lexicalXSDDate).toGregorianCalendar();
     }
 
     public String printDate(Calendar val) {
@@ -882,14 +887,30 @@
         }
         return false;
     }
-    private static final DatatypeFactory datatypeFactory;
 
-    static {
-        try {
-            datatypeFactory = DatatypeFactory.newInstance();
-        } catch (DatatypeConfigurationException e) {
-            throw new Error(e);
+    private static final Map<ClassLoader, DatatypeFactory> DF_CACHE = Collections.synchronizedMap(new WeakHashMap<ClassLoader, DatatypeFactory>());
+
+    public static DatatypeFactory getDatatypeFactory() {
+        ClassLoader tccl = AccessController.doPrivileged(new PrivilegedAction<ClassLoader>() {
+            public ClassLoader run() {
+                return Thread.currentThread().getContextClassLoader();
+            }
+        });
+        DatatypeFactory df = DF_CACHE.get(tccl);
+        if (df == null) {
+            synchronized (DatatypeConverterImpl.class) {
+                df = DF_CACHE.get(tccl);
+                if (df == null) { // to prevent multiple initialization
+                    try {
+                        df = DatatypeFactory.newInstance();
+                    } catch (DatatypeConfigurationException e) {
+                        throw new Error(Messages.format(Messages.FAILED_TO_INITIALE_DATATYPE_FACTORY), e);
+                    }
+                    DF_CACHE.put(tccl, df);
+                }
+            }
         }
+        return df;
     }
 
     private static final class CalendarFormatter {
--- ./jaxws/src/share/jaxws_classes/javax/xml/bind/Messages.java	Thu Dec 19 09:01:10 2013 -0800
+++ ./jaxws/src/share/jaxws_classes/javax/xml/bind/Messages.java	Tue Mar 18 12:34:51 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -88,4 +88,6 @@
 
     static final String ILLEGAL_CAST = // 2 args
         "JAXBContext.IllegalCast";
+
+    static final String FAILED_TO_INITIALE_DATATYPE_FACTORY = "FAILED_TO_INITIALE_DATATYPE_FACTORY";
 }
--- ./jaxws/src/share/jaxws_classes/javax/xml/bind/Messages.properties	Thu Dec 19 09:01:10 2013 -0800
+++ ./jaxws/src/share/jaxws_classes/javax/xml/bind/Messages.properties	Tue Mar 18 12:34:51 2014 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2003, 2011, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2003, 2014, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -49,3 +49,6 @@
 
 JAXBContext.IllegalCast = \
     ClassCastException: attempting to cast {0} to {1}.  Please make sure that you are specifying the proper ClassLoader.
+
+FAILED_TO_INITIALE_DATATYPE_FACTORY = \
+    Failed to initialize JAXP 1.3 DatatypeFactory class.
--- ./jaxws/src/share/jaxws_classes/javax/xml/ws/wsaddressing/W3CEndpointReference.java	Thu Dec 19 09:01:10 2013 -0800
+++ ./jaxws/src/share/jaxws_classes/javax/xml/ws/wsaddressing/W3CEndpointReference.java	Tue Mar 18 12:34:51 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -69,7 +69,7 @@
 @XmlType(name="EndpointReferenceType",namespace=W3CEndpointReference.NS)
 public final class W3CEndpointReference extends EndpointReference {
 
-    private final static JAXBContext w3cjc = getW3CJaxbContext();
+    private final JAXBContext w3cjc = getW3CJaxbContext();
 
     protected W3CEndpointReference() {
     }
--- ./jdk/.hgtags	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/.hgtags	Tue Mar 18 12:35:25 2014 -0700
@@ -365,6 +365,9 @@
 c5ca4daec23b5e7f99ac8d684f5016ff8bfebbb0 jdk7u45-b18
 4797f984f6c93c433aa797e9b2d8f904cf083f96 jdk7u45-b30
 8c343a783777b8728cb819938f387db0acf7f3ac jdk7u45-b31
+402d54c7d8ce95f3945cc3d698e528e4adec7b9b jdk7u45-b33
+34e8f9f26ae612ebac36357eecbe70ea20e0233c jdk7u45-b34
+3dbb06a924cdf73d39b8543824ec88ae501ba5c6 jdk7u45-b35
 3c9a6d9eafd31be44b0ade0354e60f5078b417a4 jdk7u51-b00
 d76613074ff357d0664b97b4aaf99fbb65dcec47 jdk7u51-b01
 fb057871f094ebe4906ad6856326768b01a62c45 jdk7u51-b02
@@ -379,3 +382,22 @@
 f0425ecbbb0ca9d8c87c250c19e8f9524b38833d jdk7u51-b11
 f5eee4f1d5b4a1e19febc9c26c863ae853ed6d2e jdk7u51-b12
 d19a89fdfb9b959b8638441d9d396685d6c7ab7b jdk7u51-b13
+ef58b2b9a9a1e1a42b0139b57816a160c4681371 jdk7u51-b30
+5bca0d0969b13b1d9b8caba3cce8293a98d68318 jdk7u51-b31
+e9143dc3dc2a8f4b896e74f70d6c503d73c40533 jdk7u51-b33
+c1eaf405fb8d7beddd75c6f81671970f6baa70d8 jdk7u51-b34
+f5eee4f1d5b4a1e19febc9c26c863ae853ed6d2e jdk7u55-b00
+5010db5b9b5ab07a9409a5c557d3f43ab32dc428 jdk7u55-b01
+2ca3e1fa4455ad564228ad6e654498167af2f20d jdk7u55-b02
+c12b3c81366cb067ff4444952209d54bfa387353 jdk7u55-b03
+476d1bddaa32bf440953c3b1814ba38f16886c03 jdk7u55-b04
+7fa6d3ba2cc77cd1e6f24e33f0c39788cb2893b8 jdk7u55-b05
+795654fce29c38d4c8504f760d8d8a36248d38ed jdk7u55-b06
+4b2ed892b195e95f7541aaa3b129a2caa5faae1d jdk7u55-b07
+db1323224053a18ecc62bdc1d3902d93b33f0b70 jdk7u55-b08
+534eeff29ac9fcbbb99ef8908548dbb368d04baf jdk7u55-b09
+d39dd4135844ca5c707bc39ae1d7e020d49880ce jdk7u55-b09
+b231536550067c3b00c77d0e035afe8faaa15581 jdk7u55-b10
+2d80b7cd7aae76f0909a210414317dcf846ad651 jdk7u55-b11
+07be5d5508733ed37c11fcd21a13ae3c8288313b jdk7u55-b12
+92fd166252c2701092a510002f4cf9285a20473d jdk7u55-b13
--- ./jdk/make/common/Defs-embedded.gmk	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/make/common/Defs-embedded.gmk	Tue Mar 18 12:35:25 2014 -0700
@@ -71,7 +71,9 @@
 # and it must be linked after fdlibm - this places it at the end after libc
 # -z muldefs avoids linker errors for duplicate symbols.
 ifeq ($(CROSS_COMPILE_ARCH), arm)
-  EXTRA_LIBS += $(EXT_LIBS_PATH)/sflt_glibc_jdk.a -Xlinker -z -Xlinker muldefs
+  ifneq ($(EXT_LIBS_PATH),)
+    EXTRA_LIBS += $(EXT_LIBS_PATH)/sflt_glibc_jdk.a -Xlinker -z -Xlinker muldefs
+  endif
 endif 
 endif
 
--- ./jdk/make/java/java/Exportedfiles.gmk	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/make/java/java/Exportedfiles.gmk	Tue Mar 18 12:35:25 2014 -0700
@@ -50,6 +50,7 @@
     java/lang/SecurityManager.java \
     java/lang/Shutdown.java \
     java/lang/Package.java \
+    java/lang/UNIXProcess.java \
     java/lang/ref/Finalizer.java \
     java/lang/reflect/AccessibleObject.java \
     java/lang/reflect/Field.java \
--- ./jdk/make/java/java/Makefile	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/make/java/java/Makefile	Tue Mar 18 12:35:25 2014 -0700
@@ -84,6 +84,7 @@
                 java/util/prefs/FileSystemPreferencesFactory.java \
 
 FILES_c    +=   UNIXProcess_md.c \
+		childproc.c \
 		UnixFileSystem_md.c \
 		canonicalize_md.c \
 		TimeZone.c \
@@ -451,3 +452,36 @@
 clean::
 	$(RM) $(GENSRCDIR)/sun/util/CoreResourceBundleControl.java
 
+
+HELPER_EXE = $(LIBDIR)/$(LIBARCH)/jspawnhelper
+BUILDHELPER =
+ifeq ($(PLATFORM), solaris)
+    BUILDHELPER = 1
+endif
+ifeq ($(PLATFORM), macosx)
+    HELPER_EXE = $(LIBDIR)/jspawnhelper
+    BUILDHELPER = 1
+endif
+
+ARCHFLAG = 
+ifeq ($(ARCH_DATA_MODEL), 64)
+ARCHFLAG = -m64
+endif
+
+ifdef BUILDHELPER
+
+HELPER_EXE_FILES_c = jspawnhelper.c
+HELPER_EXE_FILES_o = $(OBJDIR)/jspawnhelper.o \
+		$(OBJDIR)/childproc.o
+
+$(HELPER_EXE): $(HELPER_EXE_FILES_o)
+	$(CC) $(ARCHFLAG) $(HELPER_EXE_FILES_o) \
+		-o $(TEMPDIR)/jspawnhelper
+	$(CP) $(TEMPDIR)/jspawnhelper $(HELPER_EXE)
+
+build: $(HELPER_EXE)
+
+clean clobber:: 
+	$(RM) $(HELPER_EXE_FILES_o) $(HELPER_EXE)
+
+endif #BUILDHELPER
--- ./jdk/make/java/java/mapfile-vers	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/make/java/java/mapfile-vers	Tue Mar 18 12:35:25 2014 -0700
@@ -215,7 +215,7 @@
 		Java_java_lang_Throwable_fillInStackTrace;
                 Java_java_lang_Throwable_getStackTraceDepth;
                 Java_java_lang_Throwable_getStackTraceElement;
-		Java_java_lang_UNIXProcess_initIDs;
+		Java_java_lang_UNIXProcess_init;
 		Java_java_lang_UNIXProcess_waitForProcessExit;
 		Java_java_lang_UNIXProcess_forkAndExec;
 		Java_java_lang_UNIXProcess_destroyProcess;
--- ./jdk/make/sun/javazic/tzdata/VERSION	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/make/sun/javazic/tzdata/VERSION	Tue Mar 18 12:35:25 2014 -0700
@@ -21,4 +21,4 @@
 # or visit www.oracle.com if you need additional information or have any
 # questions.
 #
-tzdata2013h
+tzdata2013i
--- ./jdk/make/sun/javazic/tzdata/africa	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/make/sun/javazic/tzdata/africa	Tue Mar 18 12:35:25 2014 -0700
@@ -500,14 +500,13 @@
 Rule	Libya	1997	only	-	Oct	 4	0:00	0	-
 Rule	Libya	2013	only	-	Mar	lastFri	1:00	1:00	S
 Rule	Libya	2013	only	-	Oct	lastFri	2:00	0	-
-
-# The 1996 and 1997 entries are from Shanks & Pottenger;
-# the IATA SSIM data contain some obvious errors.
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
 Zone	Africa/Tripoli	0:52:44 -	LMT	1920
 			1:00	Libya	CE%sT	1959
 			2:00	-	EET	1982
 			1:00	Libya	CE%sT	1990 May  4
+# The 1996 and 1997 entries are from Shanks & Pottenger;
+# the IATA SSIM data contain some obvious errors.
 			2:00	-	EET	1996 Sep 30
 			1:00	Libya	CE%sT	1997 Oct  4
 			2:00	-	EET	2012 Nov 10 2:00
--- ./jdk/make/sun/javazic/tzdata/asia	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/make/sun/javazic/tzdata/asia	Tue Mar 18 12:35:25 2014 -0700
@@ -1403,12 +1403,22 @@
 # switch back to standard time this winter, so the will stay on DST
 # until about the same time next year (at least).
 # http://www.petra.gov.jo/Public_News/Nws_NewsDetails.aspx?NewsID=88950
-#
-# From Paul Eggert (2013-09-21):
-# It's looking like this change will be permanent; see
-# Petra News Agency, Cancelling winter saved Jordan $7 million (2013-02-20)
-# <http://www.albawaba.com/business/jordan-winter-electricity--472005>.
-# So move Jordan to UTC+3 as of the abovementioned date.
+
+# From Steffen Thorsen (2013-12-11):
+# Jordan Times and other sources say that Jordan is going back to
+# UTC+2 on 2013-12-19 at midnight:
+# http://jordantimes.com/govt-decides-to-switch-back-to-wintertime
+# Official, in Arabic:
+# http://www.petra.gov.jo/public_news/Nws_NewsDetails.aspx?Menu_ID=&Site_Id=2&lang=1&NewsID=133230&CatID=14
+# ... Our background/permalink about it
+# http://www.timeanddate.com/news/time/jordan-reverses-dst-decision.html
+# ...
+# http://www.petra.gov.jo/Public_News/Nws_NewsDetails.aspx?lang=2&site_id=1&NewsID=133313&Type=P
+# ... says midnight for the coming one and 1:00 for the ones in the future
+# (and they will use DST again next year, using the normal schedule).
+
+# From Paul Eggert (2013-12-11):
+# As Steffen suggested, consider the past 21-month experiment to be DST.
 
 # Rule	NAME	FROM	TO	TYPE	IN	ON	AT	SAVE	LETTER/S
 Rule	Jordan	1973	only	-	Jun	6	0:00	1:00	S
@@ -1438,11 +1448,13 @@
 Rule	Jordan	2003	only	-	Oct	24	0:00s	0	-
 Rule	Jordan	2004	only	-	Oct	15	0:00s	0	-
 Rule	Jordan	2005	only	-	Sep	lastFri	0:00s	0	-
-Rule	Jordan	2006	2012	-	Oct	lastFri	0:00s	0	-
+Rule	Jordan	2006	2011	-	Oct	lastFri	0:00s	0	-
+Rule	Jordan	2013	only	-	Dec	20	0:00	0	-
+Rule	Jordan	2014	max	-	Mar	lastThu	24:00	1:00	S
+Rule	Jordan	2014	max	-	Oct	lastFri	0:00s	0	-
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
 Zone	Asia/Amman	2:23:44 -	LMT	1931
-			2:00	Jordan	EE%sT	2012 Oct 26 0:00s
-			3:00	-	AST
+			2:00	Jordan	EE%sT
 
 
 # Kazakhstan
--- ./jdk/make/sun/javazic/tzdata/northamerica	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/make/sun/javazic/tzdata/northamerica	Tue Mar 18 12:35:25 2014 -0700
@@ -2688,6 +2688,11 @@
 # to DST--and one more hour on 1999-04-04--when the announcers will have
 # returned to Baltimore, which switches on that date.)
 
+# From Steffen Thorsen (2013-11-11):
+# DST start in Cuba in 2004 ... does not follow the same rules as the
+# years before.  The correct date should be Sunday 2004-03-28 00:00 ...
+# https://web.archive.org/web/20040402060750/http://www.granma.cu/espanol/2004/marzo/sab27/reloj.html
+
 # From Evert van der Veer via Steffen Thorsen (2004-10-28):
 # Cuba is not going back to standard time this year.
 # From Paul Eggert (2006-03-22):
@@ -2877,7 +2882,8 @@
 Rule	Cuba	1997	only	-	Oct	12	0:00s	0	S
 Rule	Cuba	1998	1999	-	Mar	lastSun	0:00s	1:00	D
 Rule	Cuba	1998	2003	-	Oct	lastSun	0:00s	0	S
-Rule	Cuba	2000	2004	-	Apr	Sun>=1	0:00s	1:00	D
+Rule	Cuba	2000	2003	-	Apr	Sun>=1	0:00s	1:00	D
+Rule	Cuba	2004	only	-	Mar	lastSun	0:00s	1:00	D
 Rule	Cuba	2006	2010	-	Oct	lastSun	0:00s	0	S
 Rule	Cuba	2007	only	-	Mar	Sun>=8	0:00s	1:00	D
 Rule	Cuba	2008	only	-	Mar	Sun>=15	0:00s	1:00	D
--- ./jdk/src/macosx/classes/sun/font/CFontManager.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/macosx/classes/sun/font/CFontManager.java	Tue Mar 18 12:35:25 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,6 +27,8 @@
 
 import java.awt.*;
 import java.io.File;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.Hashtable;
@@ -38,6 +40,7 @@
 
 import sun.awt.FontConfiguration;
 import sun.awt.HeadlessToolkit;
+import sun.misc.ThreadGroupUtils;
 import sun.lwawt.macosx.*;
 
 public class CFontManager extends SunFontManager {
@@ -215,24 +218,22 @@
                                 });
                     }
                 };
-                java.security.AccessController.doPrivileged(
-                        new java.security.PrivilegedAction<Object>() {
-                            public Object run() {
+                AccessController.doPrivileged(
+                        new PrivilegedAction<Void>() {
+                            @Override
+                            public Void run() {
                                 /* The thread must be a member of a thread group
                                  * which will not get GCed before VM exit.
                                  * Make its parent the top-level thread group.
                                  */
-                                ThreadGroup tg =
-                                    Thread.currentThread().getThreadGroup();
-                                for (ThreadGroup tgn = tg;
-                                tgn != null;
-                                tg = tgn, tgn = tg.getParent());
-                                fileCloser = new Thread(tg, fileCloserRunnable);
+                                ThreadGroup rootTG = ThreadGroupUtils.getRootThreadGroup();
+                                fileCloser = new Thread(rootTG, fileCloserRunnable);
                                 fileCloser.setContextClassLoader(null);
                                 Runtime.getRuntime().addShutdownHook(fileCloser);
                                 return null;
                             }
-                        });
+                        }
+                );
                 }
             }
         }
--- ./jdk/src/macosx/classes/sun/font/CStrike.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/macosx/classes/sun/font/CStrike.java	Tue Mar 18 12:35:25 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -31,7 +31,7 @@
 
 import sun.awt.SunHints;
 
-public class CStrike extends FontStrike {
+public final class CStrike extends FontStrike {
 
     // Creates the native strike
     private static native long createNativeStrikePtr(long nativeFontPtr,
@@ -68,10 +68,10 @@
                                                          Rectangle2D.Float result,
                                                          double x, double y);
 
-    private CFont nativeFont;
+    private final CFont nativeFont;
     private AffineTransform invDevTx;
-    private GlyphInfoCache glyphInfoCache;
-    private GlyphAdvanceCache glyphAdvanceCache;
+    private final GlyphInfoCache glyphInfoCache;
+    private final GlyphAdvanceCache glyphAdvanceCache;
     private long nativeStrikePtr;
 
     CStrike(final CFont font, final FontStrikeDesc inDesc) {
@@ -84,11 +84,11 @@
         // Normally the device transform should be the identity transform
         // for screen operations.  The device transform only becomes
         // interesting when we are outputting between different dpi surfaces,
-        // like when we are printing to postscript.
+        // like when we are printing to postscript or use retina.
         if (inDesc.devTx != null && !inDesc.devTx.isIdentity()) {
             try {
                 invDevTx = inDesc.devTx.createInverse();
-            } catch (NoninvertibleTransformException e) {
+            } catch (NoninvertibleTransformException ignored) {
                 // ignored, since device transforms should not be that
                 // complicated, and if they are - there is nothing we can do,
                 // so we won't worry about it.
@@ -134,15 +134,13 @@
         nativeStrikePtr = 0;
     }
 
-    // the fractional metrics default on our platform is OFF
-    private boolean useFractionalMetrics() {
-        return desc.fmHint == SunHints.INTVAL_FRACTIONALMETRICS_ON;
-    }
 
+    @Override
     public int getNumGlyphs() {
         return nativeFont.getNumGlyphs();
     }
 
+    @Override
     StrikeMetrics getFontMetrics() {
         if (strikeMetrics == null) {
             StrikeMetrics metrics = getFontMetrics(getNativeStrikePtr());
@@ -155,74 +153,24 @@
         return strikeMetrics;
     }
 
-    float getGlyphAdvance(int glyphCode) {
-        return getScaledAdvanceForAdvance(getCachedNativeGlyphAdvance(glyphCode));
+    @Override
+    float getGlyphAdvance(final int glyphCode) {
+        return getCachedNativeGlyphAdvance(glyphCode);
     }
 
-    float getCodePointAdvance(int cp) {
-        float advance = getCachedNativeGlyphAdvance(nativeFont.getMapper().charToGlyph(cp));
-
-        double glyphScaleX = desc.glyphTx.getScaleX();
-        double devScaleX = desc.devTx.getScaleX();
-
-        if (devScaleX == 0) {
-            glyphScaleX = Math.sqrt(desc.glyphTx.getDeterminant());
-            devScaleX = Math.sqrt(desc.devTx.getDeterminant());
-        }
-
-        if (devScaleX == 0) {
-            devScaleX = Double.NaN; // this an undefined graphics state
-        }
-        advance = (float) (advance * glyphScaleX / devScaleX);
-        return useFractionalMetrics() ? advance : Math.round(advance);
+    @Override
+    float getCodePointAdvance(final int cp) {
+        return getGlyphAdvance(nativeFont.getMapper().charToGlyph(cp));
     }
 
-    // calculate an advance, and round if not using fractional metrics
-    private float getScaledAdvanceForAdvance(float advance) {
-        if (invDevTx != null) {
-            advance *= invDevTx.getScaleX();
-        }
-        advance *= desc.glyphTx.getScaleX();
-        return useFractionalMetrics() ? advance : Math.round(advance);
+    @Override
+    Point2D.Float getCharMetrics(final char ch) {
+        return getGlyphMetrics(nativeFont.getMapper().charToGlyph(ch));
     }
 
-    Point2D.Float getCharMetrics(char ch) {
-        return getScaledPointForAdvance(getCachedNativeGlyphAdvance(nativeFont.getMapper().charToGlyph(ch)));
-    }
-
-    Point2D.Float getGlyphMetrics(int glyphCode) {
-        return getScaledPointForAdvance(getCachedNativeGlyphAdvance(glyphCode));
-    }
-
-    // calculate an advance point, and round if not using fractional metrics
-    private Point2D.Float getScaledPointForAdvance(float advance) {
-        Point2D.Float pt = new Point2D.Float(advance, 0);
-
-        if (!desc.glyphTx.isIdentity()) {
-            return scalePoint(pt);
-        }
-
-        if (!useFractionalMetrics()) {
-            pt.x = Math.round(pt.x);
-        }
-        return pt;
-    }
-
-    private Point2D.Float scalePoint(Point2D.Float pt) {
-        if (invDevTx != null) {
-            // transform the point out of the device space first
-            invDevTx.transform(pt, pt);
-        }
-        desc.glyphTx.transform(pt, pt);
-        pt.x -= desc.glyphTx.getTranslateX();
-        pt.y -= desc.glyphTx.getTranslateY();
-
-        if (!useFractionalMetrics()) {
-            pt.x = Math.round(pt.x);
-            pt.y = Math.round(pt.y);
-        }
-
-        return pt;
+    @Override
+    Point2D.Float getGlyphMetrics(final int glyphCode) {
+        return new Point2D.Float(getGlyphAdvance(glyphCode), 0.0f);
     }
 
     Rectangle2D.Float getGlyphOutlineBounds(int glyphCode) {
@@ -414,9 +362,7 @@
         private SparseBitShiftingTwoLayerArray secondLayerCache;
         private HashMap<Integer, Long> generalCache;
 
-        public GlyphInfoCache(final Font2D nativeFont,
-                              final FontStrikeDesc desc)
-        {
+        GlyphInfoCache(final Font2D nativeFont, final FontStrikeDesc desc) {
             super(nativeFont, desc);
             firstLayerCache = new long[FIRST_LAYER_SIZE];
         }
@@ -527,7 +473,7 @@
             final int shift;
             final int secondLayerLength;
 
-            public SparseBitShiftingTwoLayerArray(final int size, final int shift) {
+            SparseBitShiftingTwoLayerArray(final int size, final int shift) {
                 this.shift = shift;
                 this.cache = new long[1 << shift][];
                 this.secondLayerLength = size >> shift;
@@ -559,6 +505,12 @@
         private SparseBitShiftingTwoLayerArray secondLayerCache;
         private HashMap<Integer, Float> generalCache;
 
+        // Empty non private constructor was added because access to this
+        // class shouldn't be emulated by a synthetic accessor method.
+        GlyphAdvanceCache() {
+            super();
+        }
+
         public synchronized float get(final int index) {
             if (index < 0) {
                 if (-index < SECOND_LAYER_SIZE) {
@@ -609,9 +561,7 @@
             final int shift;
             final int secondLayerLength;
 
-            public SparseBitShiftingTwoLayerArray(final int size,
-                                                  final int shift)
-            {
+            SparseBitShiftingTwoLayerArray(final int size, final int shift) {
                 this.shift = shift;
                 this.cache = new float[1 << shift][];
                 this.secondLayerLength = size >> shift;
--- ./jdk/src/macosx/classes/sun/lwawt/LWToolkit.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/macosx/classes/sun/lwawt/LWToolkit.java	Tue Mar 18 12:35:25 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -37,6 +37,7 @@
 
 import sun.awt.*;
 import sun.lwawt.macosx.*;
+import sun.misc.ThreadGroupUtils;
 import sun.print.*;
 
 public abstract class LWToolkit extends SunToolkit implements Runnable {
@@ -66,22 +67,17 @@
     protected final void init() {
         AWTAutoShutdown.notifyToolkitThreadBusy();
 
-        ThreadGroup mainTG = AccessController.doPrivileged(
-            new PrivilegedAction<ThreadGroup>() {
-                public ThreadGroup run() {
-                    ThreadGroup currentTG = Thread.currentThread().getThreadGroup();
-                    ThreadGroup parentTG = currentTG.getParent();
-                    while (parentTG != null) {
-                        currentTG = parentTG;
-                        parentTG = currentTG.getParent();
+        ThreadGroup rootTG = AccessController.doPrivileged(
+                new PrivilegedAction<ThreadGroup>() {
+                    @Override
+                    public ThreadGroup run() {
+                        return ThreadGroupUtils.getRootThreadGroup();
                     }
-                    return currentTG;
-                }
-            }
-        );
+                });
 
         Runtime.getRuntime().addShutdownHook(
-            new Thread(mainTG, new Runnable() {
+            new Thread(rootTG, new Runnable() {
+                @Override
                 public void run() {
                     shutdown();
                     waitForRunState(STATE_CLEANUP);
@@ -89,7 +85,7 @@
             })
         );
 
-        Thread toolkitThread = new Thread(mainTG, this, "AWT-LW");
+        Thread toolkitThread = new Thread(rootTG, this, "AWT-LW");
         toolkitThread.setDaemon(true);
         toolkitThread.setPriority(Thread.NORM_PRIORITY + 1);
         toolkitThread.start();
--- ./jdk/src/macosx/classes/sun/lwawt/macosx/CClipboard.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/macosx/classes/sun/lwawt/macosx/CClipboard.java	Tue Mar 18 12:35:25 2014 -0700
@@ -53,7 +53,7 @@
     }
 
     protected void setContentsNative(Transferable contents) {
-
+        FlavorTable flavorMap = getDefaultFlavorTable();
         // Don't use delayed Clipboard rendering for the Transferable's data.
         // If we did that, we would call Transferable.getTransferData on
         // the Toolkit thread, which is a security hole.
--- ./jdk/src/macosx/classes/sun/lwawt/macosx/CInputMethod.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/macosx/classes/sun/lwawt/macosx/CInputMethod.java	Tue Mar 18 12:35:25 2014 -0700
@@ -620,8 +620,7 @@
                     retString[0] = new String(selectedText);
                 }}
             }, fAwtFocussedComponent);
-        } catch (InterruptedException ie) { ie.printStackTrace(); }
-        catch (InvocationTargetException ite) { ite.printStackTrace(); }
+        } catch (InvocationTargetException ite) { ite.printStackTrace(); }
 
         synchronized(retString) { return retString[0]; }
     }
@@ -669,8 +668,7 @@
 
                 }}
             }, fAwtFocussedComponent);
-        } catch (InterruptedException ie) { ie.printStackTrace(); }
-        catch (InvocationTargetException ite) { ite.printStackTrace(); }
+        } catch (InvocationTargetException ite) { ite.printStackTrace(); }
 
         synchronized(returnValue) { return returnValue; }
     }
@@ -695,8 +693,7 @@
                     returnValue[0] = fIMContext.getInsertPositionOffset();
                 }}
             }, fAwtFocussedComponent);
-        } catch (InterruptedException ie) { ie.printStackTrace(); }
-        catch (InvocationTargetException ite) { ite.printStackTrace(); }
+        } catch (InvocationTargetException ite) { ite.printStackTrace(); }
 
         returnValue[1] = fCurrentTextLength;
         synchronized(returnValue) { return returnValue; }
@@ -743,8 +740,7 @@
                     }
                 }}
             }, fAwtFocussedComponent);
-        } catch (InterruptedException ie) { ie.printStackTrace(); }
-        catch (InvocationTargetException ite) { ite.printStackTrace(); }
+        } catch (InvocationTargetException ite) { ite.printStackTrace(); }
 
         synchronized(rect) { return rect; }
     }
@@ -764,8 +760,7 @@
                     insertPositionOffset[0] = fIMContext.getInsertPositionOffset();
                 }}
             }, fAwtFocussedComponent);
-        } catch (InterruptedException ie) { ie.printStackTrace(); }
-        catch (InvocationTargetException ite) { ite.printStackTrace(); }
+        } catch (InvocationTargetException ite) { ite.printStackTrace(); }
 
         // This bit of gymnastics ensures that the returned location is within the composed text.
         // If it falls outside that region, the input method will commit the text, which is inconsistent with native
--- ./jdk/src/macosx/classes/sun/lwawt/macosx/CPlatformWindow.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/macosx/classes/sun/lwawt/macosx/CPlatformWindow.java	Tue Mar 18 12:35:25 2014 -0700
@@ -918,7 +918,7 @@
                         //Posting an empty to flush the EventQueue without blocking the main thread
                     }
                 }, target);
-            } catch (InterruptedException | InvocationTargetException e) {
+            } catch (InvocationTargetException e) {
                 e.printStackTrace();
             }
         }
--- ./jdk/src/macosx/classes/sun/lwawt/macosx/CViewEmbeddedFrame.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/macosx/classes/sun/lwawt/macosx/CViewEmbeddedFrame.java	Tue Mar 18 12:35:25 2014 -0700
@@ -97,6 +97,6 @@
                     setVisible(true);
                 }
             }, this);
-        } catch (InterruptedException | InvocationTargetException ex) {}
+        } catch (InvocationTargetException ex) {}
     }
 }
--- ./jdk/src/macosx/classes/sun/lwawt/macosx/LWCToolkit.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/macosx/classes/sun/lwawt/macosx/LWCToolkit.java	Tue Mar 18 12:35:25 2014 -0700
@@ -414,8 +414,15 @@
     }
 
     // Intended to be called from the LWCToolkit.m only.
-    private static void installToolkitThreadNameInJava() {
+    private static void installToolkitThreadInJava() {
         Thread.currentThread().setName(CThreading.APPKIT_THREAD_NAME);
+        AccessController.doPrivileged(new PrivilegedAction<Void>() {
+            @Override
+            public Void run() {
+                Thread.currentThread().setContextClassLoader(null);
+                return null;
+            }
+        });
     }
 
     @Override
@@ -518,22 +525,21 @@
     // Any selector invoked using ThreadUtilities performOnMainThread will be processed in doAWTRunLoop
     // The InvocationEvent will call LWCToolkit.stopAWTRunLoop() when finished, which will stop our manual runloop
     // Does not dispatch native events while in the loop
-    public static void invokeAndWait(Runnable event, Component component) throws InterruptedException, InvocationTargetException {
+    public static void invokeAndWait(Runnable runnable, Component component) throws InvocationTargetException {
         final long mediator = createAWTRunLoopMediator();
 
-        InvocationEvent invocationEvent =
-                new InvocationEvent(component != null ? component : Toolkit.getDefaultToolkit(), event) {
-                    @Override
-                    public void dispatch() {
-                        try {
-                            super.dispatch();
-                        } finally {
-                            if (mediator != 0) {
-                                stopAWTRunLoop(mediator);
+        InvocationEvent invocationEvent = AWTAccessor.getInvocationEventAccessor()
+                .createEvent(component != null ? component : Toolkit.getDefaultToolkit(),
+                        runnable,
+                        new Runnable() {
+                            @Override
+                            public void run() {
+                                if (mediator != 0) {
+                                    stopAWTRunLoop(mediator);
+                                }
                             }
-                        }
-                    }
-                };
+                        },
+                        true);
 
         if (component != null) {
             AppContext appContext = SunToolkit.targetToAppContext(component);
--- ./jdk/src/macosx/native/sun/awt/LWCToolkit.m	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/macosx/native/sun/awt/LWCToolkit.m	Tue Mar 18 12:35:25 2014 -0700
@@ -193,8 +193,8 @@
 
         JNIEnv *env = [ThreadUtilities getJNIEnv];
         static JNF_CLASS_CACHE(jc_LWCToolkit, "sun/lwawt/macosx/LWCToolkit");
-        static JNF_STATIC_MEMBER_CACHE(jsm_installToolkitThreadNameInJava, jc_LWCToolkit, "installToolkitThreadNameInJava", "()V");
-        JNFCallStaticVoidMethod(env, jsm_installToolkitThreadNameInJava);
+        static JNF_STATIC_MEMBER_CACHE(jsm_installToolkitThreadInJava, jc_LWCToolkit, "installToolkitThreadInJava", "()V");
+        JNFCallStaticVoidMethod(env, jsm_installToolkitThreadInJava);
     });
     
     gNumberOfButtons = sun_lwawt_macosx_LWCToolkit_BUTTONS;
--- ./jdk/src/macosx/native/sun/awt/awt.m	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/macosx/native/sun/awt/awt.m	Tue Mar 18 12:35:25 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -432,6 +432,16 @@
         forceEmbeddedMode = YES;
     }
 
+    JNIEnv* env = [ThreadUtilities getJNIEnvUncached];
+    jclass jc_ThreadGroupUtils = (*env)->FindClass(env, "sun/misc/ThreadGroupUtils");
+    jmethodID sjm_getRootThreadGroup = (*env)->GetStaticMethodID(env, jc_ThreadGroupUtils, "getRootThreadGroup", "()Ljava/lang/ThreadGroup;");
+    jobject rootThreadGroup = (*env)->CallStaticObjectMethod(env, jc_ThreadGroupUtils, sjm_getRootThreadGroup);
+    [ThreadUtilities setAppkitThreadGroup:(*env)->NewGlobalRef(env, rootThreadGroup)];
+
+    // The current thread was attached in getJNIEnvUncached.
+    // Detach it back. It will be reattached later if needed with a proper TG
+    [ThreadUtilities detachCurrentThread];
+
     BOOL headless = isHeadless(env);
 
     // We need to let Foundation know that this is a multithreaded application, if it isn't already.
--- ./jdk/src/macosx/native/sun/font/AWTStrike.h	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/macosx/native/sun/font/AWTStrike.h	Tue Mar 18 12:35:25 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -31,11 +31,12 @@
 @interface AWTStrike : NSObject {
 @public
     AWTFont *                fAWTFont;
-    CGFloat                    fSize;
+    CGFloat                  fSize;
     JRSFontRenderingStyle    fStyle;
-    jint                    fAAStyle;
+    jint                     fAAStyle;
 
     CGAffineTransform        fTx;
+    CGAffineTransform        fDevTx;
     CGAffineTransform        fAltTx; // alternate strike tx used for Sun2D
     CGAffineTransform        fFontTx;
 }
--- ./jdk/src/macosx/native/sun/font/AWTStrike.m	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/macosx/native/sun/font/AWTStrike.m	Tue Mar 18 12:35:25 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -60,6 +60,7 @@
         invDevTx.b *= -1;
         invDevTx.c *= -1;
         fFontTx = CGAffineTransformConcat(CGAffineTransformConcat(tx, invDevTx), sInverseTX);
+        fDevTx = CGAffineTransformInvert(invDevTx);
 
         // the "font size" is the square root of the determinant of the matrix
         fSize = sqrt(abs(fFontTx.a * fFontTx.d - fFontTx.b * fFontTx.c));
@@ -143,7 +144,8 @@
 {
     CGSize advance;
 JNF_COCOA_ENTER(env);
-    AWTFont *awtFont = ((AWTStrike *)jlong_to_ptr(awtStrikePtr))->fAWTFont;
+    AWTStrike *awtStrike = (AWTStrike *)jlong_to_ptr(awtStrikePtr);
+    AWTFont *awtFont = awtStrike->fAWTFont;
 
     // negative glyph codes are really unicodes, which were placed there by the mapper
     // to indicate we should use CoreText to substitute the character
@@ -151,6 +153,10 @@
     const CTFontRef fallback = CTS_CopyCTFallbackFontAndGlyphForJavaGlyphCode(awtFont, glyphCode, &glyph);
     CTFontGetAdvancesForGlyphs(fallback, kCTFontDefaultOrientation, &glyph, &advance, 1);
     CFRelease(fallback);
+    advance = CGSizeApplyAffineTransform(advance, awtStrike->fFontTx);
+    if (!JRSFontStyleUsesFractionalMetrics(awtStrike->fStyle)) {
+        advance.width = round(advance.width);
+    }
 
 JNF_COCOA_EXIT(env);
     return advance.width;
--- ./jdk/src/macosx/native/sun/font/CGGlyphImages.m	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/macosx/native/sun/font/CGGlyphImages.m	Tue Mar 18 12:35:25 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -455,6 +455,7 @@
 #define CGGI_GLYPH_BBOX_PADDING 2.0f
 static inline GlyphInfo *
 CGGI_CreateNewGlyphInfoFrom(CGSize advance, CGRect bbox,
+                            const AWTStrike *strike,
                             const CGGI_RenderingMode *mode)
 {
     size_t pixelSize = mode->glyphDescriptor->pixelSize;
@@ -477,6 +478,12 @@
         width = 1;
         height = 1;
     }
+    advance = CGSizeApplyAffineTransform(advance, strike->fFontTx);
+    if (!JRSFontStyleUsesFractionalMetrics(strike->fStyle)) {
+        advance.width = round(advance.width);
+        advance.height = round(advance.height);
+    }
+    advance = CGSizeApplyAffineTransform(advance, strike->fDevTx);
 
 #ifdef USE_IMAGE_ALIGNED_MEMORY
     // create separate memory
@@ -564,10 +571,10 @@
     JRSFontGetBoundingBoxesForGlyphsAndStyle(fallback, &tx, style, &glyph, 1, &bbox);
 
     CGSize advance;
-    JRSFontGetAdvancesForGlyphsAndStyle(fallback, &tx, strike->fStyle, &glyph, 1, &advance);
+    CTFontGetAdvancesForGlyphs(fallback, kCTFontDefaultOrientation, &glyph, &advance, 1);
 
     // create the Sun2D GlyphInfo we are going to strike into
-    GlyphInfo *info = CGGI_CreateNewGlyphInfoFrom(advance, bbox, mode);
+    GlyphInfo *info = CGGI_CreateNewGlyphInfoFrom(advance, bbox, strike, mode);
 
     // fix the context size, just in case the substituted character is unexpectedly large
     CGGI_SizeCanvas(canvas, info->width, info->height, mode->cgFontMode);
@@ -715,7 +722,7 @@
     JRSFontRenderingStyle bboxCGMode = JRSFontAlignStyleForFractionalMeasurement(strike->fStyle);
 
     JRSFontGetBoundingBoxesForGlyphsAndStyle((CTFontRef)font->fFont, &tx, bboxCGMode, glyphs, len, bboxes);
-    JRSFontGetAdvancesForGlyphsAndStyle((CTFontRef)font->fFont, &tx, strike->fStyle, glyphs, len, advances);
+    CTFontGetAdvancesForGlyphs((CTFontRef)font->fFont, kCTFontDefaultOrientation, glyphs, advances, len);
 
     size_t maxWidth = 1;
     size_t maxHeight = 1;
@@ -732,7 +739,7 @@
         CGSize advance = advances[i];
         CGRect bbox = bboxes[i];
 
-        GlyphInfo *glyphInfo = CGGI_CreateNewGlyphInfoFrom(advance, bbox, mode);
+        GlyphInfo *glyphInfo = CGGI_CreateNewGlyphInfoFrom(advance, bbox, strike, mode);
 
         if (maxWidth < glyphInfo->width)   maxWidth = glyphInfo->width;
         if (maxHeight < glyphInfo->height) maxHeight = glyphInfo->height;
--- ./jdk/src/macosx/native/sun/osxapp/ThreadUtilities.h	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/macosx/native/sun/osxapp/ThreadUtilities.h	Tue Mar 18 12:35:25 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -127,6 +127,8 @@
 
 + (JNIEnv*)getJNIEnv;
 + (JNIEnv*)getJNIEnvUncached;
++ (void)detachCurrentThread;
++ (void)setAppkitThreadGroup:(jobject)group;
 
 //Wrappers for the corresponding JNFRunLoop methods with a check for main thread
 + (void)performOnMainThreadWaiting:(BOOL)wait block:(void (^)())block;
--- ./jdk/src/macosx/native/sun/osxapp/ThreadUtilities.m	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/macosx/native/sun/osxapp/ThreadUtilities.m	Tue Mar 18 12:35:25 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -33,23 +33,44 @@
 // The following must be named "jvm", as there are extern references to it in AWT
 JavaVM *jvm = NULL;
 static JNIEnv *appKitEnv = NULL;
+static jobject appkitThreadGroup = NULL;
+
+inline void attachCurrentThread(void** env) {
+    if ([NSThread isMainThread]) {
+        JavaVMAttachArgs args;
+        args.version = JNI_VERSION_1_4;
+        args.name = "AppKit Thread";
+        args.group = appkitThreadGroup;
+        (*jvm)->AttachCurrentThreadAsDaemon(jvm, env, &args);
+    } else {
+        (*jvm)->AttachCurrentThreadAsDaemon(jvm, env, NULL);
+    }
+}
 
 @implementation ThreadUtilities
 
 + (JNIEnv*)getJNIEnv {
 AWT_ASSERT_APPKIT_THREAD;
     if (appKitEnv == NULL) {
-        (*jvm)->AttachCurrentThreadAsDaemon(jvm, (void **)&appKitEnv, NULL);
+        attachCurrentThread((void **)&appKitEnv);
     }
     return appKitEnv;
 }
 
 + (JNIEnv*)getJNIEnvUncached {
     JNIEnv *env = NULL;
-    (*jvm)->AttachCurrentThreadAsDaemon(jvm, (void **)&env, nil);
+    attachCurrentThread((void **)&env);
     return env;
 }
 
++ (void)detachCurrentThread {
+    (*jvm)->DetachCurrentThread(jvm);
+}
+
++ (void)setAppkitThreadGroup:(jobject)group {
+    appkitThreadGroup = group;
+}
+
 + (void)performOnMainThreadWaiting:(BOOL)wait block:(void (^)())block {
     if ([NSThread isMainThread] && wait == YES) {
         block(); 
--- ./jdk/src/share/classes/com/sun/jmx/remote/security/SubjectDelegator.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/com/sun/jmx/remote/security/SubjectDelegator.java	Tue Mar 18 12:35:25 2014 -0700
@@ -35,6 +35,8 @@
 import javax.management.remote.SubjectDelegationPermission;
 
 import com.sun.jmx.remote.util.CacheMap;
+import java.util.ArrayList;
+import java.util.Collection;
 
 public class SubjectDelegator {
     private static final int PRINCIPALS_CACHE_SIZE = 10;
@@ -53,11 +55,14 @@
                          boolean removeCallerContext)
             throws SecurityException {
 
+        if (System.getSecurityManager() != null && authenticatedACC == null) {
+            throw new SecurityException("Illegal AccessControlContext: null");
+        }
         if (principalsCache == null || accCache == null) {
             principalsCache =
-                    new CacheMap<Subject, Principal[]>(PRINCIPALS_CACHE_SIZE);
+                    new CacheMap<>(PRINCIPALS_CACHE_SIZE);
             accCache =
-                    new CacheMap<Subject, AccessControlContext>(ACC_CACHE_SIZE);
+                    new CacheMap<>(ACC_CACHE_SIZE);
         }
 
         // Retrieve the principals for the given
@@ -101,14 +106,15 @@
         // principal in the delegated subject
         //
         final Principal[] dp = delegatedPrincipals;
+        final Collection<Permission> permissions = new ArrayList<>(dp.length);
+        for(Principal p : dp) {
+            final String pname = p.getClass().getName() + "." + p.getName();
+            permissions.add(new SubjectDelegationPermission(pname));
+        }
         PrivilegedAction<Void> action =
             new PrivilegedAction<Void>() {
                 public Void run() {
-                    for (int i = 0 ; i < dp.length ; i++) {
-                        final String pname =
-                            dp[i].getClass().getName() + "." + dp[i].getName();
-                        Permission sdp =
-                            new SubjectDelegationPermission(pname);
+                    for (Permission sdp : permissions) {
                         AccessController.checkPermission(sdp);
                     }
                     return null;
--- ./jdk/src/share/classes/com/sun/jndi/dns/DnsClient.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/com/sun/jndi/dns/DnsClient.java	Tue Mar 18 12:35:25 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -30,13 +30,14 @@
 import java.net.DatagramPacket;
 import java.net.InetAddress;
 import java.net.Socket;
+import java.security.SecureRandom;
 import javax.naming.*;
 
 import java.util.Collections;
 import java.util.Map;
 import java.util.HashMap;
-import java.util.Set;
-import java.util.HashSet;
+
+import sun.security.jca.JCAUtil;
 
 // Some of this code began life as part of sun.javaos.net.DnsClient
 // originally by sritchie@eng 1/96.  It was first hacked up for JNDI
@@ -77,6 +78,8 @@
     };
 
     private static final int DEFAULT_PORT = 53;
+    private static final int TRANSACTION_ID_BOUND = 0x10000;
+    private static final SecureRandom random = JCAUtil.getSecureRandom();
     private InetAddress[] servers;
     private int[] serverPorts;
     private int timeout;                // initial timeout on UDP queries in ms
@@ -85,7 +88,7 @@
     private DatagramSocket udpSocket;
 
     // Requests sent
-    private Set<Integer> reqs;
+    private Map<Integer, ResourceRecord> reqs;
 
     // Responses received
     private Map<Integer, byte[]> resps;
@@ -134,7 +137,8 @@
                 throw ne;
             }
         }
-        reqs = Collections.synchronizedSet(new HashSet<Integer>());
+        reqs = Collections.synchronizedMap(
+            new HashMap<Integer, ResourceRecord>());
         resps = Collections.synchronizedMap(new HashMap<Integer, byte[]>());
     }
 
@@ -153,10 +157,6 @@
         }
     }
 
-
-    private int ident = 0;              // used to set the msg ID field
-    private Object identLock = new Object();
-
     /*
      * If recursion is true, recursion is requested on the query.
      * If auth is true, only authoritative responses are accepted; other
@@ -167,15 +167,22 @@
             throws NamingException {
 
         int xid;
-        synchronized (identLock) {
-            ident = 0xFFFF & (ident + 1);
-            xid = ident;
-        }
+        Packet pkt;
+        ResourceRecord collision;
 
-        // enqueue the outstanding request
-        reqs.add(xid);
+        do {
+            // Generate a random transaction ID
+            xid = random.nextInt(TRANSACTION_ID_BOUND);
+            pkt = makeQueryPacket(fqdn, xid, qclass, qtype, recursion);
 
-        Packet pkt = makeQueryPacket(fqdn, xid, qclass, qtype, recursion);
+            // enqueue the outstanding request
+            synchronized (reqs) {
+                if ((collision = reqs.put(xid, new ResourceRecord(pkt.getData(),
+                    pkt.length(), Header.HEADER_SIZE, true, false))) != null) {
+                    reqs.put(xid, collision); // revert
+                }
+            }
+        } while (collision != null);
 
         Exception caughtException = null;
         boolean[] doNotRetry = new boolean[servers.length];
@@ -305,11 +312,8 @@
     ResourceRecords queryZone(DnsName zone, int qclass, boolean recursion)
             throws NamingException {
 
-        int xid;
-        synchronized (identLock) {
-            ident = 0xFFFF & (ident + 1);
-            xid = ident;
-        }
+        int xid = random.nextInt(TRANSACTION_ID_BOUND);
+
         Packet pkt = makeQueryPacket(zone, xid, qclass,
                                      ResourceRecord.QTYPE_AXFR, recursion);
         Exception caughtException = null;
@@ -390,6 +394,7 @@
             DatagramPacket opkt = new DatagramPacket(
                     pkt.getData(), pkt.length(), server, port);
             DatagramPacket ipkt = new DatagramPacket(new byte[8000], 8000);
+            // Packets may only be sent to or received from this server address
             udpSocket.connect(server, port);
             int pktTimeout = (timeout * (1 << retry));
             try {
@@ -524,7 +529,7 @@
                 "\tResponse Q:" + resps);
         }
         byte[] pkt;
-        if ((pkt = (byte[]) resps.get(xid)) != null) {
+        if ((pkt = resps.get(xid)) != null) {
             checkResponseCode(new Header(pkt, pkt.length));
             synchronized (queuesLock) {
                 resps.remove(xid);
@@ -543,6 +548,9 @@
      * Checks the header of an incoming DNS response.
      * Returns true if it matches the given xid and throws a naming
      * exception, if appropriate, based on the response code.
+     *
+     * Also checks that the domain name, type and class in the response
+     * match those in the original query.
      */
     private boolean isMatchResponse(byte[] pkt, int xid)
                 throws NamingException {
@@ -552,7 +560,7 @@
             throw new CommunicationException("DNS error: expecting response");
         }
 
-        if (!reqs.contains(xid)) { // already received, ignore the response
+        if (!reqs.containsKey(xid)) { // already received, ignore the response
             return false;
         }
 
@@ -561,14 +569,47 @@
             if (debug) {
                 dprint("XID MATCH:" + xid);
             }
+            checkResponseCode(hdr);
+            if (!hdr.query && hdr.numQuestions == 1) {
 
-            checkResponseCode(hdr);
-            // remove the response for the xid if received by some other thread.
-            synchronized (queuesLock) {
-                resps.remove(xid);
-                reqs.remove(xid);
+                ResourceRecord rr = new ResourceRecord(pkt, pkt.length,
+                    Header.HEADER_SIZE, true, false);
+
+                // Retrieve the original query
+                ResourceRecord query = reqs.get(xid);
+                int qtype = query.getType();
+                int qclass = query.getRrclass();
+                DnsName qname = query.getName();
+
+                // Check that the type/class/name in the query section of the
+                // response match those in the original query
+                if ((qtype == ResourceRecord.QTYPE_STAR ||
+                    qtype == rr.getType()) &&
+                    (qclass == ResourceRecord.QCLASS_STAR ||
+                    qclass == rr.getRrclass()) &&
+                    qname.equals(rr.getName())) {
+
+                    if (debug) {
+                        dprint("MATCH NAME:" + qname + " QTYPE:" + qtype +
+                            " QCLASS:" + qclass);
+                    }
+
+                    // Remove the response for the xid if received by some other
+                    // thread.
+                    synchronized (queuesLock) {
+                        resps.remove(xid);
+                        reqs.remove(xid);
+                    }
+                    return true;
+
+                } else {
+                    if (debug) {
+                        dprint("NO-MATCH NAME:" + qname + " QTYPE:" + qtype +
+                            " QCLASS:" + qclass);
+                    }
+                }
             }
-            return true;
+            return false;
         }
 
         //
@@ -577,7 +618,7 @@
         // enqueue only the first response, responses for retries are ignored.
         //
         synchronized (queuesLock) {
-            if (reqs.contains(hdr.xid)) { // enqueue only the first response
+            if (reqs.containsKey(hdr.xid)) { // enqueue only the first response
                 resps.put(hdr.xid, pkt);
             }
         }
--- ./jdk/src/share/classes/com/sun/jndi/ldap/LdapBindingEnumeration.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/com/sun/jndi/ldap/LdapBindingEnumeration.java	Tue Mar 18 12:35:25 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2003, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,6 +25,10 @@
 
 package com.sun.jndi.ldap;
 
+import java.security.AccessControlContext;
+import java.security.AccessController;
+import java.security.PrivilegedActionException;
+import java.security.PrivilegedExceptionAction;
 import java.util.Vector;
 import javax.naming.*;
 import javax.naming.directory.*;
@@ -34,6 +38,8 @@
 
 final class LdapBindingEnumeration extends LdapNamingEnumeration {
 
+    private final AccessControlContext acc = AccessController.getContext();
+
     LdapBindingEnumeration(LdapCtx homeCtx, LdapResult answer, Name remain,
         Continuation cont) throws NamingException
     {
@@ -41,7 +47,7 @@
     }
 
     protected NameClassPair
-      createItem(String dn, Attributes attrs, Vector respCtls)
+      createItem(String dn, final Attributes attrs, Vector respCtls)
         throws NamingException {
 
         Object obj = null;
@@ -49,7 +55,16 @@
 
         if (attrs.get(Obj.JAVA_ATTRIBUTES[Obj.CLASSNAME]) != null) {
             // serialized object or object reference
-            obj = Obj.decodeObject(attrs);
+            try {
+                obj = AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {
+                    @Override
+                    public Object run() throws NamingException {
+                        return Obj.decodeObject(attrs);
+                    }
+                }, acc);
+            } catch (PrivilegedActionException e) {
+                throw (NamingException)e.getException();
+            }
         }
         if (obj == null) {
             // DirContext object
--- ./jdk/src/share/classes/com/sun/jndi/ldap/LdapSearchEnumeration.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/com/sun/jndi/ldap/LdapSearchEnumeration.java	Tue Mar 18 12:35:25 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2003, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,6 +25,10 @@
 
 package com.sun.jndi.ldap;
 
+import java.security.AccessControlContext;
+import java.security.AccessController;
+import java.security.PrivilegedActionException;
+import java.security.PrivilegedExceptionAction;
 import java.util.Vector;
 import javax.naming.*;
 import javax.naming.directory.*;
@@ -39,6 +43,8 @@
     private Name startName;             // prefix of names of search results
     private LdapCtx.SearchArgs searchArgs = null;
 
+    private final AccessControlContext acc = AccessController.getContext();
+
     LdapSearchEnumeration(LdapCtx homeCtx, LdapResult search_results,
         String starter, LdapCtx.SearchArgs args, Continuation cont)
         throws NamingException {
@@ -53,7 +59,7 @@
     }
 
     protected NameClassPair
-    createItem(String dn, Attributes attrs, Vector respCtls)
+    createItem(String dn, final Attributes attrs, Vector respCtls)
         throws NamingException {
 
         Object obj = null;
@@ -110,8 +116,16 @@
             if (attrs.get(Obj.JAVA_ATTRIBUTES[Obj.CLASSNAME]) != null) {
                 // Entry contains Java-object attributes (ser/ref object)
                 // serialized object or object reference
-                obj = Obj.decodeObject(attrs);
-
+                try {
+                    obj = AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {
+                        @Override
+                        public Object run() throws NamingException {
+                            return Obj.decodeObject(attrs);
+                        }
+                    }, acc);
+                } catch (PrivilegedActionException e) {
+                    throw (NamingException)e.getException();
+                }
             }
             if (obj == null) {
                 obj = new LdapCtx(homeCtx, dn);
--- ./jdk/src/share/classes/com/sun/media/sound/JDK13Services.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/com/sun/media/sound/JDK13Services.java	Tue Mar 18 12:35:25 2014 -0700
@@ -25,27 +25,33 @@
 
 package com.sun.media.sound;
 
+import java.util.ArrayList;
 import java.util.Collections;
-import java.util.HashMap;
 import java.util.List;
-import java.util.Map;
 import java.util.Properties;
 
 import javax.sound.midi.Receiver;
 import javax.sound.midi.Sequencer;
 import javax.sound.midi.Synthesizer;
 import javax.sound.midi.Transmitter;
+import javax.sound.midi.spi.MidiDeviceProvider;
+import javax.sound.midi.spi.MidiFileReader;
+import javax.sound.midi.spi.MidiFileWriter;
+import javax.sound.midi.spi.SoundbankReader;
 import javax.sound.sampled.Clip;
 import javax.sound.sampled.Port;
 import javax.sound.sampled.SourceDataLine;
 import javax.sound.sampled.TargetDataLine;
+import javax.sound.sampled.spi.AudioFileReader;
+import javax.sound.sampled.spi.AudioFileWriter;
+import javax.sound.sampled.spi.FormatConversionProvider;
+import javax.sound.sampled.spi.MixerProvider;
 
 
 /**
- * JDK13Services uses the Service class in JDK 1.3
- * to discover a list of service providers installed
- * in the system.
- *
+ * JDK13Services uses the Service class in JDK 1.3 to discover a list of service
+ * providers installed in the system.
+ * <p>
  * This class is public because it is called from javax.sound.midi.MidiSystem
  * and javax.sound.sampled.AudioSystem. The alternative would be to make
  * JSSecurityManager public, which is considered worse.
@@ -54,80 +60,55 @@
  */
 public final class JDK13Services {
 
-    /** The default for the length of the period to hold the cache.
-        This value is given in milliseconds. It is equivalent to
-        1 minute.
-    */
-    private static final long DEFAULT_CACHING_PERIOD = 60000;
-
-    /** Filename of the properties file for default provider properties.
-        This file is searched in the subdirectory "lib" of the JRE directory
-        (this behaviour is hardcoded).
-    */
+    /**
+     * Filename of the properties file for default provider properties. This
+     * file is searched in the subdirectory "lib" of the JRE directory (this
+     * behaviour is hardcoded).
+     */
     private static final String PROPERTIES_FILENAME = "sound.properties";
 
-    /** Cache for the providers.
-        Class objects of the provider type (MixerProvider, MidiDeviceProvider
-        ...) are used as keys. The values are instances of ProviderCache.
-    */
-    private static final Map providersCacheMap = new HashMap();
-
-
-    /** The length of the period to hold the cache.
-        This value is given in milliseconds.
-    */
-    private static long cachingPeriod = DEFAULT_CACHING_PERIOD;
-
-    /** Properties loaded from the properties file for default provider
-        properties.
-    */
+    /**
+     * Properties loaded from the properties file for default provider
+     * properties.
+     */
     private static Properties properties;
 
-
-    /** Private, no-args constructor to ensure against instantiation.
+    /**
+     * Private, no-args constructor to ensure against instantiation.
      */
     private JDK13Services() {
     }
 
-
-    /** Set the period provider lists are cached.
-        This method is only intended for testing.
+    /**
+     * Obtains a List containing installed instances of the providers for the
+     * requested service. The returned List is immutable.
+     *
+     * @param serviceClass The type of providers requested. This should be one
+     *                     of AudioFileReader.class, AudioFileWriter.class,
+     *                     FormatConversionProvider.class, MixerProvider.class,
+     *                     MidiDeviceProvider.class, MidiFileReader.class,
+     *                     MidiFileWriter.class or SoundbankReader.class.
+     *
+     * @return A List of providers of the requested type. This List is
+     *         immutable.
      */
-    public static void setCachingPeriod(int seconds) {
-        cachingPeriod = seconds * 1000L;
+    public static List<?> getProviders(final Class<?> serviceClass) {
+        final List<?> providers;
+        if (!MixerProvider.class.equals(serviceClass)
+                && !FormatConversionProvider.class.equals(serviceClass)
+                && !AudioFileReader.class.equals(serviceClass)
+                && !AudioFileWriter.class.equals(serviceClass)
+                && !MidiDeviceProvider.class.equals(serviceClass)
+                && !SoundbankReader.class.equals(serviceClass)
+                && !MidiFileWriter.class.equals(serviceClass)
+                && !MidiFileReader.class.equals(serviceClass)) {
+            providers = new ArrayList<>(0);
+        } else {
+            providers = JSSecurityManager.getProviders(serviceClass);
+        }
+        return Collections.unmodifiableList(providers);
     }
 
-
-    /** Obtains a List containing installed instances of the
-        providers for the requested service.
-        The List of providers is cached for the period of time given by
-        {@link #cachingPeriod cachingPeriod}. During this period, the same
-        List instance is returned for the same type of provider. After this
-        period, a new instance is constructed and returned. The returned
-        List is immutable.
-        @param serviceClass The type of providers requested. This should be one
-        of AudioFileReader.class, AudioFileWriter.class,
-        FormatConversionProvider.class, MixerProvider.class,
-        MidiDeviceProvider.class, MidiFileReader.class, MidiFileWriter.class or
-        SoundbankReader.class.
-        @return A List of providers of the requested type. This List is
-        immutable.
-     */
-    public static synchronized List getProviders(Class serviceClass) {
-        ProviderCache cache = (ProviderCache) providersCacheMap.get(serviceClass);
-        if (cache == null) {
-            cache = new ProviderCache();
-            providersCacheMap.put(serviceClass, cache);
-        }
-        if (cache.providers == null ||
-            System.currentTimeMillis() > cache.lastUpdate + cachingPeriod) {
-            cache.providers = Collections.unmodifiableList(JSSecurityManager.getProviders(serviceClass));
-            cache.lastUpdate = System.currentTimeMillis();
-        }
-        return cache.providers;
-    }
-
-
     /** Obtain the provider class name part of a default provider property.
         @param typeClass The type of the default provider property. This
         should be one of Receiver.class, Transmitter.class, Sequencer.class,
@@ -219,14 +200,4 @@
         }
         return properties;
     }
-
-    // INNER CLASSES
-
-    private static class ProviderCache {
-        // System time of the last update in milliseconds.
-        public long lastUpdate;
-
-        // The providers.
-        public List providers;
-    }
 }
--- ./jdk/src/share/classes/com/sun/media/sound/JSSecurityManager.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/com/sun/media/sound/JSSecurityManager.java	Tue Mar 18 12:35:25 2014 -0700
@@ -187,7 +187,7 @@
         return thread;
     }
 
-    static List getProviders(final Class providerClass) {
+    static synchronized List getProviders(final Class providerClass) {
         List p = new ArrayList();
         // Service.providers(Class) just creates "lazy" iterator instance,
         // so it doesn't require do be called from privileged section
--- ./jdk/src/share/classes/com/sun/naming/internal/ResourceManager.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/com/sun/naming/internal/ResourceManager.java	Tue Mar 18 12:35:25 2014 -0700
@@ -69,6 +69,14 @@
     private static final String JRELIB_PROPERTY_FILE_NAME = "jndi.properties";
 
     /*
+     * Internal environment property, that when set to "true", disables
+     * application resource files lookup to prevent recursion issues
+     * when validating signed JARs.
+     */
+    private static final String DISABLE_APP_RESOURCE_FILES =
+        "com.sun.naming.disable.app.resource.files";
+
+    /*
      * The standard JNDI properties that specify colon-separated lists.
      */
     private static final String[] listProperties = {
@@ -218,6 +226,13 @@
             }
         }
 
+        // Return without merging if application resource files lookup
+        // is disabled.
+        String disableAppRes = (String)env.get(DISABLE_APP_RESOURCE_FILES);
+        if (disableAppRes != null && disableAppRes.equalsIgnoreCase("true")) {
+            return env;
+        }
+
         // Merge the above with the values read from all application
         // resource files.  Colon-separated lists are concatenated.
         mergeTables(env, getApplicationResources());
--- ./jdk/src/share/classes/com/sun/rowset/CachedRowSetImpl.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/com/sun/rowset/CachedRowSetImpl.java	Tue Mar 18 12:35:25 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -37,6 +37,7 @@
 import javax.sql.rowset.serial.*;
 import com.sun.rowset.internal.*;
 import com.sun.rowset.providers.*;
+import sun.reflect.misc.ReflectUtil;
 
 /**
  * The standard implementation of the <code>CachedRowSet</code> interface.
@@ -2963,13 +2964,9 @@
                 // create new instance of the class
                 SQLData obj = null;
                 try {
-                    obj = (SQLData)c.newInstance();
-                } catch (java.lang.InstantiationException ex) {
-                    throw new SQLException(MessageFormat.format(resBundle.handleGetObject("cachedrowsetimpl.unableins").toString(),
-                    ex.getMessage()));
-                } catch (java.lang.IllegalAccessException ex) {
-                    throw new SQLException(MessageFormat.format(resBundle.handleGetObject("cachedrowsetimpl.unableins").toString(),
-                    ex.getMessage()));
+                    obj = (SQLData) ReflectUtil.newInstance(c);
+                } catch(Exception ex) {
+                    throw new SQLException("Unable to Instantiate: ", ex);
                 }
                 // get the attributes from the struct
                 Object attribs[] = s.getAttributes(map);
@@ -5714,13 +5711,9 @@
                 // create new instance of the class
                 SQLData obj = null;
                 try {
-                    obj = (SQLData)c.newInstance();
-                } catch (java.lang.InstantiationException ex) {
-                    throw new SQLException(MessageFormat.format(resBundle.handleGetObject("cachedrowsetimpl.unableins").toString(),
-                    ex.getMessage()));
-                } catch (java.lang.IllegalAccessException ex) {
-                    throw new SQLException(MessageFormat.format(resBundle.handleGetObject("cachedrowsetimpl.unableins").toString(),
-                    ex.getMessage()));
+                    obj = (SQLData) ReflectUtil.newInstance(c);
+                } catch(Exception ex) {
+                    throw new SQLException("Unable to Instantiate: ", ex);
                 }
                 // get the attributes from the struct
                 Object attribs[] = s.getAttributes(map);
--- ./jdk/src/share/classes/com/sun/rowset/internal/CachedRowSetWriter.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/com/sun/rowset/internal/CachedRowSetWriter.java	Tue Mar 18 12:35:25 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -39,6 +39,7 @@
 import javax.sql.rowset.serial.SerialClob;
 import javax.sql.rowset.serial.SerialStruct;
 import javax.sql.rowset.spi.*;
+import sun.reflect.misc.ReflectUtil;
 
 
 /**
@@ -578,13 +579,9 @@
                         // create new instance of the class
                         SQLData obj = null;
                         try {
-                            obj = (SQLData)c.newInstance();
-                        } catch (java.lang.InstantiationException ex) {
-                            throw new SQLException(MessageFormat.format(resBundle.handleGetObject("cachedrowsetimpl.unableins").toString(),
-                            ex.getMessage()));
-                        } catch (java.lang.IllegalAccessException ex) {
-                            throw new SQLException(MessageFormat.format(resBundle.handleGetObject("cachedrowsetimpl.unableins").toString(),
-                            ex.getMessage()));
+                            obj = (SQLData)ReflectUtil.newInstance(c);
+                        } catch (Exception ex) {
+                            throw new SQLException("Unable to Instantiate: ", ex);
                         }
                         // get the attributes from the struct
                         Object attribs[] = s.getAttributes(map);
--- ./jdk/src/share/classes/java/awt/EventQueue.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/java/awt/EventQueue.java	Tue Mar 18 12:35:25 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -1043,11 +1043,11 @@
                             t.setContextClassLoader(classLoader);
                             t.setPriority(Thread.NORM_PRIORITY + 1);
                             t.setDaemon(false);
+                            AWTAutoShutdown.getInstance().notifyThreadBusy(t);
                             return t;
                         }
                     }
                 );
-                AWTAutoShutdown.getInstance().notifyThreadBusy(dispatchThread);
                 dispatchThread.start();
             }
         } finally {
@@ -1139,6 +1139,10 @@
                         if (entry.event instanceof SentEvent) {
                             ((SentEvent)entry.event).dispose();
                         }
+                        if (entry.event instanceof InvocationEvent) {
+                            AWTAccessor.getInvocationEventAccessor()
+                                    .dispose((InvocationEvent)entry.event);
+                        }
                         if (prev == null) {
                             queues[i].head = entry.next;
                         } else {
--- ./jdk/src/share/classes/java/awt/datatransfer/SystemFlavorMap.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/java/awt/datatransfer/SystemFlavorMap.java	Tue Mar 18 12:35:25 2014 -0700
@@ -45,8 +45,8 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
-import java.util.WeakHashMap;
 
+import sun.awt.AppContext;
 import sun.awt.datatransfer.DataTransferer;
 
 /**
@@ -72,10 +72,7 @@
      */
     private static String JavaMIME = "JAVA_DATAFLAVOR:";
 
-    /**
-     * System singleton which maps a thread's ClassLoader to a SystemFlavorMap.
-     */
-    private static final WeakHashMap flavorMaps = new WeakHashMap();
+    private static final Object FLAVOR_MAP_KEY = new Object();
 
     /**
      * Copied from java.util.Properties.
@@ -184,22 +181,12 @@
      * Returns the default FlavorMap for this thread's ClassLoader.
      */
     public static FlavorMap getDefaultFlavorMap() {
-        ClassLoader contextClassLoader =
-            Thread.currentThread().getContextClassLoader();
-        if (contextClassLoader == null) {
-            contextClassLoader = ClassLoader.getSystemClassLoader();
+        AppContext context = AppContext.getAppContext();
+        FlavorMap fm = (FlavorMap) context.get(FLAVOR_MAP_KEY);
+        if (fm == null) {
+            fm = new SystemFlavorMap();
+            context.put(FLAVOR_MAP_KEY, fm);
         }
-
-        FlavorMap fm;
-
-        synchronized(flavorMaps) {
-            fm = (FlavorMap)flavorMaps.get(contextClassLoader);
-            if (fm == null) {
-                fm = new SystemFlavorMap();
-                flavorMaps.put(contextClassLoader, fm);
-            }
-        }
-
         return fm;
     }
 
@@ -240,26 +227,11 @@
                     }
                 });
 
-        BufferedReader flavormapURL =
+        String url =
             java.security.AccessController.doPrivileged(
-                new java.security.PrivilegedAction<BufferedReader>() {
-                    public BufferedReader run() {
-                        String url = Toolkit.getProperty("AWT.DnD.flavorMapFileURL", null);
-
-                        if (url == null) {
-                            return null;
-                        }
-
-                        try {
-                            return new BufferedReader
-                                (new InputStreamReader
-                                    (new URL(url).openStream(), "ISO-8859-1"));
-                        } catch (MalformedURLException e) {
-                            System.err.println("MalformedURLException:" + e + " while reading AWT.DnD.flavorMapFileURL:" + url);
-                        } catch (IOException e) {
-                            System.err.println("IOException:" + e + " while reading AWT.DnD.flavorMapFileURL:" + url);
-                        }
-                        return null;
+                new java.security.PrivilegedAction<String>() {
+                    public String run() {
+                        return Toolkit.getProperty("AWT.DnD.flavorMapFileURL", null);
                     }
                 });
 
@@ -271,6 +243,19 @@
             }
         }
 
+        BufferedReader flavormapURL = null;
+        if (url != null) {
+            try {
+                flavormapURL = new BufferedReader(new InputStreamReader(new URL(url).openStream(), "ISO-8859-1"));
+            } catch (MalformedURLException e) {
+                System.err.println("MalformedURLException:" + e + " while reading AWT.DnD.flavorMapFileURL:" + url);
+            } catch (IOException e) {
+                System.err.println("IOException:" + e + " while reading AWT.DnD.flavorMapFileURL:" + url);
+            } catch (SecurityException e) {
+                // ignored
+            }
+        }
+
         if (flavormapURL != null) {
             try {
                 parseAndStoreReader(flavormapURL);
--- ./jdk/src/share/classes/java/awt/event/InvocationEvent.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/java/awt/event/InvocationEvent.java	Tue Mar 18 12:35:25 2014 -0700
@@ -25,6 +25,8 @@
 
 package java.awt.event;
 
+import sun.awt.AWTAccessor;
+
 import java.awt.ActiveEvent;
 import java.awt.AWTEvent;
 
@@ -56,6 +58,20 @@
  */
 public class InvocationEvent extends AWTEvent implements ActiveEvent {
 
+    static {
+        AWTAccessor.setInvocationEventAccessor(new AWTAccessor.InvocationEventAccessor() {
+            @Override
+            public void dispose(InvocationEvent invocationEvent) {
+                invocationEvent.finishedDispatching(false);
+            }
+            @Override
+            public InvocationEvent createEvent(Object source, Runnable runnable, Runnable listener,
+                                               boolean catchThrowables) {
+                return new InvocationEvent(source, runnable, listener, catchThrowables);
+            }
+        });
+    }
+
     /**
      * Marks the first integer id for the range of invocation event ids.
      */
@@ -85,6 +101,14 @@
     protected Object notifier;
 
     /**
+     * The (potentially null) Runnable whose run() method will be called
+     * immediately after the event was dispatched or disposed.
+     *
+     * @see #isDispatched
+     */
+    private final Runnable listener;
+
+    /**
      * Indicates whether the <code>run()</code> method of the <code>runnable</code>
      * was executed or not.
      *
@@ -147,7 +171,7 @@
      * @see #InvocationEvent(Object, Runnable, Object, boolean)
      */
     public InvocationEvent(Object source, Runnable runnable) {
-        this(source, runnable, null, false);
+        this(source, INVOCATION_DEFAULT, runnable, null, null, false);
     }
 
     /**
@@ -185,7 +209,39 @@
      */
     public InvocationEvent(Object source, Runnable runnable, Object notifier,
                            boolean catchThrowables) {
-        this(source, INVOCATION_DEFAULT, runnable, notifier, catchThrowables);
+        this(source, INVOCATION_DEFAULT, runnable, notifier, null, catchThrowables);
+    }
+
+    /**
+     * Constructs an <code>InvocationEvent</code> with the specified
+     * source which will execute the runnable's <code>run</code>
+     * method when dispatched.  If listener is non-<code>null</code>,
+     * <code>listener.run()</code> will be called immediately after
+     * <code>run</code> has returned, thrown an exception or the event
+     * was disposed.
+     * <p>This method throws an <code>IllegalArgumentException</code>
+     * if <code>source</code> is <code>null</code>.
+     *
+     * @param source            The <code>Object</code> that originated
+     *                          the event
+     * @param runnable          The <code>Runnable</code> whose
+     *                          <code>run</code> method will be
+     *                          executed
+     * @param listener          The <code>Runnable</code>Runnable whose
+     *                          <code>run()</code> method will be called
+     *                          after the {@code InvocationEvent}
+     *                          was dispatched or disposed
+     * @param catchThrowables   Specifies whether <code>dispatch</code>
+     *                          should catch Throwable when executing
+     *                          the <code>Runnable</code>'s <code>run</code>
+     *                          method, or should instead propagate those
+     *                          Throwables to the EventDispatchThread's
+     *                          dispatch loop
+     * @throws IllegalArgumentException if <code>source</code> is null
+     */
+    private InvocationEvent(Object source, Runnable runnable, Runnable listener,
+                           boolean catchThrowables)  {
+        this(source, INVOCATION_DEFAULT, runnable, null, listener, catchThrowables);
     }
 
     /**
@@ -221,13 +277,18 @@
      */
     protected InvocationEvent(Object source, int id, Runnable runnable,
                               Object notifier, boolean catchThrowables) {
+        this(source, id, runnable, notifier, null, catchThrowables);
+    }
+
+    private InvocationEvent(Object source, int id, Runnable runnable,
+                            Object notifier, Runnable listener, boolean catchThrowables) {
         super(source, id);
         this.runnable = runnable;
         this.notifier = notifier;
+        this.listener = listener;
         this.catchExceptions = catchThrowables;
         this.when = System.currentTimeMillis();
     }
-
     /**
      * Executes the Runnable's <code>run()</code> method and notifies the
      * notifier (if any) when <code>run()</code> has returned or thrown an exception.
@@ -251,13 +312,7 @@
                 runnable.run();
             }
         } finally {
-            dispatched = true;
-
-            if (notifier != null) {
-                synchronized (notifier) {
-                    notifier.notifyAll();
-                }
-            }
+            finishedDispatching(true);
         }
     }
 
@@ -331,6 +386,25 @@
     }
 
     /**
+     * Called when the event was dispatched or disposed
+     * @param dispatched true if the event was dispatched
+     *                   false if the event was disposed
+     */
+    private void finishedDispatching(boolean dispatched) {
+        this.dispatched = dispatched;
+
+        if (notifier != null) {
+            synchronized (notifier) {
+                notifier.notifyAll();
+            }
+        }
+
+        if (listener != null) {
+            listener.run();
+        }
+    }
+
+    /**
      * Returns a parameter string identifying this event.
      * This method is useful for event-logging and for debugging.
      *
--- ./jdk/src/share/classes/java/lang/Thread.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/java/lang/Thread.java	Tue Mar 18 12:35:25 2014 -0700
@@ -366,6 +366,8 @@
             throw new NullPointerException("name cannot be null");
         }
 
+        this.name = name.toCharArray();
+
         Thread parent = currentThread();
         SecurityManager security = System.getSecurityManager();
         if (g == null) {
@@ -402,7 +404,6 @@
         this.group = g;
         this.daemon = parent.isDaemon();
         this.priority = parent.getPriority();
-        this.name = name.toCharArray();
         if (security == null || isCCLOverridden(parent.getClass()))
             this.contextClassLoader = parent.getContextClassLoader();
         else
--- ./jdk/src/share/classes/java/lang/invoke/BoundMethodHandle.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/java/lang/invoke/BoundMethodHandle.java	Tue Mar 18 12:35:25 2014 -0700
@@ -140,7 +140,7 @@
      * Return the {@link SpeciesData} instance representing this BMH species. All subclasses must provide a
      * static field containing this value, and they must accordingly implement this method.
      */
-    protected abstract SpeciesData speciesData();
+    /*non-public*/ abstract SpeciesData speciesData();
 
     @Override
     final Object internalProperties() {
@@ -156,7 +156,7 @@
         return Arrays.asList(boundValues);
     }
 
-    public final Object arg(int i) {
+    /*non-public*/ final Object arg(int i) {
         try {
             switch (speciesData().fieldType(i)) {
             case 'L': return argL(i);
@@ -170,22 +170,22 @@
         }
         throw new InternalError("unexpected type: " + speciesData().types+"."+i);
     }
-    public final Object argL(int i) throws Throwable { return          speciesData().getters[i].invokeBasic(this); }
-    public final int    argI(int i) throws Throwable { return (int)    speciesData().getters[i].invokeBasic(this); }
-    public final float  argF(int i) throws Throwable { return (float)  speciesData().getters[i].invokeBasic(this); }
-    public final double argD(int i) throws Throwable { return (double) speciesData().getters[i].invokeBasic(this); }
-    public final long   argJ(int i) throws Throwable { return (long)   speciesData().getters[i].invokeBasic(this); }
+    /*non-public*/ final Object argL(int i) throws Throwable { return          speciesData().getters[i].invokeBasic(this); }
+    /*non-public*/ final int    argI(int i) throws Throwable { return (int)    speciesData().getters[i].invokeBasic(this); }
+    /*non-public*/ final float  argF(int i) throws Throwable { return (float)  speciesData().getters[i].invokeBasic(this); }
+    /*non-public*/ final double argD(int i) throws Throwable { return (double) speciesData().getters[i].invokeBasic(this); }
+    /*non-public*/ final long   argJ(int i) throws Throwable { return (long)   speciesData().getters[i].invokeBasic(this); }
 
     //
     // cloning API
     //
 
-    public abstract BoundMethodHandle clone(MethodType mt, LambdaForm lf) throws Throwable;
-    public abstract BoundMethodHandle cloneExtendL(MethodType mt, LambdaForm lf, Object narg) throws Throwable;
-    public abstract BoundMethodHandle cloneExtendI(MethodType mt, LambdaForm lf, int    narg) throws Throwable;
-    public abstract BoundMethodHandle cloneExtendJ(MethodType mt, LambdaForm lf, long   narg) throws Throwable;
-    public abstract BoundMethodHandle cloneExtendF(MethodType mt, LambdaForm lf, float  narg) throws Throwable;
-    public abstract BoundMethodHandle cloneExtendD(MethodType mt, LambdaForm lf, double narg) throws Throwable;
+    /*non-public*/ abstract BoundMethodHandle clone(MethodType mt, LambdaForm lf) throws Throwable;
+    /*non-public*/ abstract BoundMethodHandle cloneExtendL(MethodType mt, LambdaForm lf, Object narg) throws Throwable;
+    /*non-public*/ abstract BoundMethodHandle cloneExtendI(MethodType mt, LambdaForm lf, int    narg) throws Throwable;
+    /*non-public*/ abstract BoundMethodHandle cloneExtendJ(MethodType mt, LambdaForm lf, long   narg) throws Throwable;
+    /*non-public*/ abstract BoundMethodHandle cloneExtendF(MethodType mt, LambdaForm lf, float  narg) throws Throwable;
+    /*non-public*/ abstract BoundMethodHandle cloneExtendD(MethodType mt, LambdaForm lf, double narg) throws Throwable;
 
     // The following is a grossly irregular hack:
     @Override MethodHandle reinvokerTarget() {
@@ -203,39 +203,39 @@
     private  // make it private to force users to access the enclosing class first
     static final class Species_L extends BoundMethodHandle {
         final Object argL0;
-        public Species_L(MethodType mt, LambdaForm lf, Object argL0) {
+        /*non-public*/ Species_L(MethodType mt, LambdaForm lf, Object argL0) {
             super(mt, lf);
             this.argL0 = argL0;
         }
         // The following is a grossly irregular hack:
         @Override MethodHandle reinvokerTarget() { return (MethodHandle) argL0; }
         @Override
-        public SpeciesData speciesData() {
+        /*non-public*/ SpeciesData speciesData() {
             return SPECIES_DATA;
         }
-        public static final SpeciesData SPECIES_DATA = SpeciesData.getForClass("L", Species_L.class);
+        /*non-public*/ static final SpeciesData SPECIES_DATA = SpeciesData.getForClass("L", Species_L.class);
         @Override
-        public final BoundMethodHandle clone(MethodType mt, LambdaForm lf) throws Throwable {
+        /*non-public*/ final BoundMethodHandle clone(MethodType mt, LambdaForm lf) throws Throwable {
             return new Species_L(mt, lf, argL0);
         }
         @Override
-        public final BoundMethodHandle cloneExtendL(MethodType mt, LambdaForm lf, Object narg) throws Throwable {
+        /*non-public*/ final BoundMethodHandle cloneExtendL(MethodType mt, LambdaForm lf, Object narg) throws Throwable {
             return (BoundMethodHandle) SPECIES_DATA.extendWithIndex(INDEX_L).constructor[0].invokeBasic(mt, lf, argL0, narg);
         }
         @Override
-        public final BoundMethodHandle cloneExtendI(MethodType mt, LambdaForm lf, int narg) throws Throwable {
+        /*non-public*/ final BoundMethodHandle cloneExtendI(MethodType mt, LambdaForm lf, int narg) throws Throwable {
             return (BoundMethodHandle) SPECIES_DATA.extendWithIndex(INDEX_I).constructor[0].invokeBasic(mt, lf, argL0, narg);
         }
         @Override
-        public final BoundMethodHandle cloneExtendJ(MethodType mt, LambdaForm lf, long narg) throws Throwable {
+        /*non-public*/ final BoundMethodHandle cloneExtendJ(MethodType mt, LambdaForm lf, long narg) throws Throwable {
             return (BoundMethodHandle) SPECIES_DATA.extendWithIndex(INDEX_J).constructor[0].invokeBasic(mt, lf, argL0, narg);
         }
         @Override
-        public final BoundMethodHandle cloneExtendF(MethodType mt, LambdaForm lf, float narg) throws Throwable {
+        /*non-public*/ final BoundMethodHandle cloneExtendF(MethodType mt, LambdaForm lf, float narg) throws Throwable {
             return (BoundMethodHandle) SPECIES_DATA.extendWithIndex(INDEX_F).constructor[0].invokeBasic(mt, lf, argL0, narg);
         }
         @Override
-        public final BoundMethodHandle cloneExtendD(MethodType mt, LambdaForm lf, double narg) throws Throwable {
+        /*non-public*/ final BoundMethodHandle cloneExtendD(MethodType mt, LambdaForm lf, double narg) throws Throwable {
             return (BoundMethodHandle) SPECIES_DATA.extendWithIndex(INDEX_D).constructor[0].invokeBasic(mt, lf, argL0, narg);
         }
     }
@@ -338,10 +338,10 @@
         final MethodHandle[]                     getters;
         final SpeciesData[]                      extensions;
 
-        public int fieldCount() {
+        /*non-public*/ int fieldCount() {
             return types.length();
         }
-        public char fieldType(int i) {
+        /*non-public*/ char fieldType(int i) {
             return types.charAt(i);
         }
 
@@ -546,30 +546,30 @@
          *     final Object argL0;
          *     final Object argL1;
          *     final int argI2;
-         *     public Species_LLI(MethodType mt, LambdaForm lf, Object argL0, Object argL1, int argI2) {
+         *     Species_LLI(MethodType mt, LambdaForm lf, Object argL0, Object argL1, int argI2) {
          *         super(mt, lf);
          *         this.argL0 = argL0;
          *         this.argL1 = argL1;
          *         this.argI2 = argI2;
          *     }
-         *     public final SpeciesData speciesData() { return SPECIES_DATA; }
-         *     public static final SpeciesData SPECIES_DATA = SpeciesData.getForClass("LLI", Species_LLI.class);
-         *     public final BoundMethodHandle clone(MethodType mt, LambdaForm lf) {
+         *     final SpeciesData speciesData() { return SPECIES_DATA; }
+         *     static final SpeciesData SPECIES_DATA = SpeciesData.getForClass("LLI", Species_LLI.class);
+         *     final BoundMethodHandle clone(MethodType mt, LambdaForm lf) {
          *         return SPECIES_DATA.constructor[0].invokeBasic(mt, lf, argL0, argL1, argI2);
          *     }
-         *     public final BoundMethodHandle cloneExtendL(MethodType mt, LambdaForm lf, Object narg) {
+         *     final BoundMethodHandle cloneExtendL(MethodType mt, LambdaForm lf, Object narg) {
          *         return SPECIES_DATA.extendWithIndex(INDEX_L).constructor[0].invokeBasic(mt, lf, argL0, argL1, argI2, narg);
          *     }
-         *     public final BoundMethodHandle cloneExtendI(MethodType mt, LambdaForm lf, int narg) {
+         *     final BoundMethodHandle cloneExtendI(MethodType mt, LambdaForm lf, int narg) {
          *         return SPECIES_DATA.extendWithIndex(INDEX_I).constructor[0].invokeBasic(mt, lf, argL0, argL1, argI2, narg);
          *     }
-         *     public final BoundMethodHandle cloneExtendJ(MethodType mt, LambdaForm lf, long narg) {
+         *     final BoundMethodHandle cloneExtendJ(MethodType mt, LambdaForm lf, long narg) {
          *         return SPECIES_DATA.extendWithIndex(INDEX_J).constructor[0].invokeBasic(mt, lf, argL0, argL1, argI2, narg);
          *     }
-         *     public final BoundMethodHandle cloneExtendF(MethodType mt, LambdaForm lf, float narg) {
+         *     final BoundMethodHandle cloneExtendF(MethodType mt, LambdaForm lf, float narg) {
          *         return SPECIES_DATA.extendWithIndex(INDEX_F).constructor[0].invokeBasic(mt, lf, argL0, argL1, argI2, narg);
          *     }
-         *     public final BoundMethodHandle cloneExtendD(MethodType mt, LambdaForm lf, double narg) {
+         *     final BoundMethodHandle cloneExtendD(MethodType mt, LambdaForm lf, double narg) {
          *         return SPECIES_DATA.extendWithIndex(INDEX_D).constructor[0].invokeBasic(mt, lf, argL0, argL1, argI2, narg);
          *     }
          * }
@@ -583,11 +583,12 @@
 
             final String className  = SPECIES_PREFIX_PATH + types;
             final String sourceFile = SPECIES_PREFIX_NAME + types;
-            cw.visit(V1_6, ACC_PUBLIC + ACC_FINAL + ACC_SUPER, className, null, BMH, null);
+            final int NOT_ACC_PUBLIC = 0;  // not ACC_PUBLIC
+            cw.visit(V1_6, NOT_ACC_PUBLIC + ACC_FINAL + ACC_SUPER, className, null, BMH, null);
             cw.visitSource(sourceFile, null);
 
             // emit static types and SPECIES_DATA fields
-            cw.visitField(ACC_PUBLIC + ACC_STATIC, "SPECIES_DATA", SPECIES_DATA_SIG, null, null).visitEnd();
+            cw.visitField(NOT_ACC_PUBLIC + ACC_STATIC, "SPECIES_DATA", SPECIES_DATA_SIG, null, null).visitEnd();
 
             // emit bound argument fields
             for (int i = 0; i < types.length(); ++i) {
@@ -600,7 +601,7 @@
             MethodVisitor mv;
 
             // emit constructor
-            mv = cw.visitMethod(ACC_PUBLIC, "<init>", makeSignature(types, true), null, null);
+            mv = cw.visitMethod(NOT_ACC_PUBLIC, "<init>", makeSignature(types, true), null, null);
             mv.visitCode();
             mv.visitVarInsn(ALOAD, 0);
             mv.visitVarInsn(ALOAD, 1);
@@ -624,7 +625,7 @@
             mv.visitEnd();
 
             // emit implementation of reinvokerTarget()
-            mv = cw.visitMethod(ACC_PUBLIC + ACC_FINAL, "reinvokerTarget", "()" + MH_SIG, null, null);
+            mv = cw.visitMethod(NOT_ACC_PUBLIC + ACC_FINAL, "reinvokerTarget", "()" + MH_SIG, null, null);
             mv.visitCode();
             mv.visitVarInsn(ALOAD, 0);
             mv.visitFieldInsn(GETFIELD, className, "argL0", JLO_SIG);
@@ -634,7 +635,7 @@
             mv.visitEnd();
 
             // emit implementation of speciesData()
-            mv = cw.visitMethod(ACC_PUBLIC + ACC_FINAL, "speciesData", MYSPECIES_DATA_SIG, null, null);
+            mv = cw.visitMethod(NOT_ACC_PUBLIC + ACC_FINAL, "speciesData", MYSPECIES_DATA_SIG, null, null);
             mv.visitCode();
             mv.visitFieldInsn(GETSTATIC, className, "SPECIES_DATA", SPECIES_DATA_SIG);
             mv.visitInsn(ARETURN);
@@ -642,7 +643,7 @@
             mv.visitEnd();
 
             // emit clone()
-            mv = cw.visitMethod(ACC_PUBLIC + ACC_FINAL, "clone", makeSignature("", false), null, E_THROWABLE);
+            mv = cw.visitMethod(NOT_ACC_PUBLIC + ACC_FINAL, "clone", makeSignature("", false), null, E_THROWABLE);
             mv.visitCode();
             // return speciesData().constructor[0].invokeBasic(mt, lf, argL0, ...)
             // obtain constructor
@@ -665,7 +666,7 @@
             // for each type, emit cloneExtendT()
             for (Class<?> c : TYPES) {
                 char t = Wrapper.basicTypeChar(c);
-                mv = cw.visitMethod(ACC_PUBLIC + ACC_FINAL, "cloneExtend" + t, makeSignature(String.valueOf(t), false), null, E_THROWABLE);
+                mv = cw.visitMethod(NOT_ACC_PUBLIC + ACC_FINAL, "cloneExtend" + t, makeSignature(String.valueOf(t), false), null, E_THROWABLE);
                 mv.visitCode();
                 // return SPECIES_DATA.extendWithIndex(extensionIndex(t)).constructor[0].invokeBasic(mt, lf, argL0, ..., narg)
                 // obtain constructor
@@ -692,7 +693,7 @@
             }
 
             // emit class initializer
-            mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, "<clinit>", VOID_SIG, null, null);
+            mv = cw.visitMethod(NOT_ACC_PUBLIC | ACC_STATIC, "<clinit>", VOID_SIG, null, null);
             mv.visitCode();
             mv.visitLdcInsn(types);
             mv.visitLdcInsn(Type.getObjectType(className));
--- ./jdk/src/share/classes/java/lang/invoke/InvokerBytecodeGenerator.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/java/lang/invoke/InvokerBytecodeGenerator.java	Tue Mar 18 12:35:25 2014 -0700
@@ -289,8 +289,9 @@
      * Set up class file generation.
      */
     private void classFilePrologue() {
+        final int NOT_ACC_PUBLIC = 0;  // not ACC_PUBLIC
         cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);
-        cw.visit(Opcodes.V1_6, Opcodes.ACC_PUBLIC + Opcodes.ACC_FINAL + Opcodes.ACC_SUPER, className, null, superName, null);
+        cw.visit(Opcodes.V1_6, NOT_ACC_PUBLIC + Opcodes.ACC_FINAL + Opcodes.ACC_SUPER, className, null, superName, null);
         cw.visitSource(sourceFile, null);
 
         String invokerDesc = invokerType.toMethodDescriptorString();
--- ./jdk/src/share/classes/java/lang/invoke/MethodHandles.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/java/lang/invoke/MethodHandles.java	Tue Mar 18 12:35:25 2014 -0700
@@ -1616,6 +1616,7 @@
      */
     public static
     MethodHandle permuteArguments(MethodHandle target, MethodType newType, int... reorder) {
+        reorder = reorder.clone();
         checkReorder(reorder, newType, target.type());
         return target.permuteArguments(newType, reorder);
     }
@@ -1810,6 +1811,7 @@
             throw newIllegalArgumentException("no argument type to remove");
         ArrayList<Class<?>> ptypes = new ArrayList<>(oldType.parameterList());
         ptypes.addAll(pos, valueTypes);
+        if (ptypes.size() != inargs)  throw newIllegalArgumentException("valueTypes");
         MethodType newType = MethodType.methodType(oldType.returnType(), ptypes);
         return target.dropArguments(newType, pos, dropped);
     }
--- ./jdk/src/share/classes/java/util/ServiceLoader.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/java/util/ServiceLoader.java	Tue Mar 18 12:35:25 2014 -0700
@@ -375,7 +375,7 @@
                 return p;
             } catch (Throwable x) {
                 fail(service,
-                     "Provider " + cn + " could not be instantiated: " + x,
+                     "Provider " + cn + " could not be instantiated",
                      x);
             }
             throw new Error();          // This cannot happen
--- ./jdk/src/share/classes/java/util/jar/JarVerifier.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/java/util/jar/JarVerifier.java	Tue Mar 18 12:35:25 2014 -0700
@@ -677,6 +677,8 @@
                 } else {
                     matchUnsigned = true;
                 }
+            } else {
+                matchUnsigned = true;
             }
         }
 
@@ -779,23 +781,7 @@
 
     // true if file is part of the signature mechanism itself
     static boolean isSigningRelated(String name) {
-        name = name.toUpperCase(Locale.ENGLISH);
-        if (!name.startsWith("META-INF/")) {
-            return false;
-        }
-        name = name.substring(9);
-        if (name.indexOf('/') != -1) {
-            return false;
-        }
-        if (name.endsWith(".DSA")
-                || name.endsWith(".RSA")
-                || name.endsWith(".SF")
-                || name.endsWith(".EC")
-                || name.startsWith("SIG-")
-                || name.equals("MANIFEST.MF")) {
-            return true;
-        }
-        return false;
+        return SignatureFileVerifier.isSigningRelated(name);
     }
 
     private Enumeration<String> unsignedEntryNames(JarFile jar) {
--- ./jdk/src/share/classes/java/util/logging/LogManager.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/java/util/logging/LogManager.java	Tue Mar 18 12:35:25 2014 -0700
@@ -363,6 +363,9 @@
         changes.removePropertyChangeListener(l);
     }
 
+    // LoggerContext maps from AppContext
+    private static WeakHashMap<Object, LoggerContext> contextsMap = null;
+
     // Returns the LoggerContext for the user code (i.e. application or AppContext).
     // Loggers are isolated from each AppContext.
     private LoggerContext getUserContext() {
@@ -371,33 +374,28 @@
         SecurityManager sm = System.getSecurityManager();
         JavaAWTAccess javaAwtAccess = SharedSecrets.getJavaAWTAccess();
         if (sm != null && javaAwtAccess != null) {
+            // for each applet, it has its own LoggerContext isolated from others
             synchronized (javaAwtAccess) {
-                // AppContext.getAppContext() returns the system AppContext if called
-                // from a system thread but Logger.getLogger might be called from
-                // an applet code. Instead, find the AppContext of the applet code
-                // from the execution stack.
-                Object ecx = javaAwtAccess.getExecutionContext();
-                if (ecx == null) {
-                    // fall back to thread group seach of AppContext
-                    ecx = javaAwtAccess.getContext();
-                }
+                // find the AppContext of the applet code
+                // will be null if we are in the main app context.
+                final Object ecx = javaAwtAccess.getAppletContext();
                 if (ecx != null) {
-                    context = (LoggerContext)javaAwtAccess.get(ecx, LoggerContext.class);
+                    if (contextsMap == null) {
+                        contextsMap = new WeakHashMap<>();
+                    }
+                    context = contextsMap.get(ecx);
                     if (context == null) {
-                        if (javaAwtAccess.isMainAppContext()) {
-                            context = userContext;
-                        } else {
-                            // Create a new LoggerContext for the applet.
-                            // The new logger context has its requiresDefaultLoggers
-                            // flag set to true - so that these loggers will be
-                            // lazily added when the context is firt accessed.
-                            context = new LoggerContext(true);
-                        }
-                        javaAwtAccess.put(ecx, LoggerContext.class, context);
+                        // Create a new LoggerContext for the applet.
+                        // The new logger context has its requiresDefaultLoggers
+                        // flag set to true - so that these loggers will be
+                        // lazily added when the context is firt accessed.
+                        context = new LoggerContext(true);
+                        contextsMap.put(ecx, context);
                     }
                 }
             }
         }
+        // for standalone app, return userContext
         return context != null ? context : userContext;
     }
 
@@ -424,7 +422,7 @@
         Logger result = getLogger(name);
         if (result == null) {
             // only allocate the new logger once
-            Logger newLogger = new Logger(name, resourceBundleName, caller);
+            Logger newLogger = new Logger(name, resourceBundleName, caller, false);
             do {
                 if (addLogger(newLogger)) {
                     // We successfully added the new Logger that we
@@ -471,12 +469,12 @@
         } while (logger == null);
 
         // LogManager will set the sysLogger's handlers via LogManager.addLogger method.
-        if (logger != sysLogger && sysLogger.getHandlers().length == 0) {
+        if (logger != sysLogger && sysLogger.accessCheckedHandlers().length == 0) {
             // if logger already exists but handlers not set
             final Logger l = logger;
             AccessController.doPrivileged(new PrivilegedAction<Void>() {
                 public Void run() {
-                    for (Handler hdl : l.getHandlers()) {
+                    for (Handler hdl : l.accessCheckedHandlers()) {
                         sysLogger.addHandler(hdl);
                     }
                     return null;
@@ -760,7 +758,7 @@
             Logger result = findLogger(name);
             if (result == null) {
                 // only allocate the new system logger once
-                Logger newLogger = new Logger(name, resourceBundleName);
+                Logger newLogger = new Logger(name, resourceBundleName, null, true);
                 do {
                     if (addLocalLogger(newLogger)) {
                         // We successfully added the new Logger that we
@@ -1425,31 +1423,35 @@
     // We use a subclass of Logger for the root logger, so
     // that we only instantiate the global handlers when they
     // are first needed.
-    private class RootLogger extends Logger {
+    private final class RootLogger extends Logger {
         private RootLogger() {
-            super("", null);
+            super("", null, null, true);
             setLevel(defaultLevel);
         }
 
+        @Override
         public void log(LogRecord record) {
             // Make sure that the global handlers have been instantiated.
             initializeGlobalHandlers();
             super.log(record);
         }
 
+        @Override
         public void addHandler(Handler h) {
             initializeGlobalHandlers();
             super.addHandler(h);
         }
 
+        @Override
         public void removeHandler(Handler h) {
             initializeGlobalHandlers();
             super.removeHandler(h);
         }
 
-        public Handler[] getHandlers() {
+        @Override
+        Handler[] accessCheckedHandlers() {
             initializeGlobalHandlers();
-            return super.getHandlers();
+            return super.accessCheckedHandlers();
         }
     }
 
--- ./jdk/src/share/classes/java/util/logging/Logger.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/java/util/logging/Logger.java	Tue Mar 18 12:35:25 2014 -0700
@@ -178,7 +178,7 @@
     private String name;
     private final CopyOnWriteArrayList<Handler> handlers =
         new CopyOnWriteArrayList<>();
-    private String resourceBundleName;
+    private volatile String resourceBundleName;
     private volatile boolean useParentHandlers = true;
     private volatile Filter filter;
     private boolean anonymous;
@@ -189,7 +189,7 @@
 
     // The fields relating to parent-child relationships and levels
     // are managed under a separate lock, the treeLock.
-    private static Object treeLock = new Object();
+    private static final Object treeLock = new Object();
     // We keep weak references from parents to children, but strong
     // references from children to parents.
     private volatile Logger parent;    // our nearest parent.
@@ -197,6 +197,7 @@
     private volatile Level levelObject;
     private volatile int levelValue;  // current effective level value
     private WeakReference<ClassLoader> callersClassLoaderRef;
+    private final boolean isSystemLogger;
 
     /**
      * GLOBAL_LOGGER_NAME is a name for the global logger.
@@ -257,11 +258,12 @@
      *             no corresponding resource can be found.
      */
     protected Logger(String name, String resourceBundleName) {
-        this(name, resourceBundleName, null);
+        this(name, resourceBundleName, null, false);
     }
 
-    Logger(String name, String resourceBundleName, Class<?> caller) {
+    Logger(String name, String resourceBundleName, Class<?> caller, boolean isSystemLogger) {
         this.manager = LogManager.getLogManager();
+        this.isSystemLogger = isSystemLogger;
         setupResourceInfo(resourceBundleName, caller);
         this.name = name;
         levelValue = Level.INFO.intValue();
@@ -288,6 +290,7 @@
     private Logger(String name) {
         // The manager field is not initialized here.
         this.name = name;
+        this.isSystemLogger = true;
         levelValue = Level.INFO.intValue();
     }
 
@@ -528,7 +531,7 @@
         // cleanup some Loggers that have been GC'ed
         manager.drainLoggerRefQueueBounded();
         Logger result = new Logger(null, resourceBundleName,
-                                   Reflection.getCallerClass());
+                                   Reflection.getCallerClass(), false);
         result.anonymous = true;
         Logger root = manager.getLogger("");
         result.doSetParent(root);
@@ -606,15 +609,22 @@
 
         Logger logger = this;
         while (logger != null) {
-            for (Handler handler : logger.getHandlers()) {
+            final Handler[] loggerHandlers = isSystemLogger
+                ? logger.accessCheckedHandlers()
+                : logger.getHandlers();
+            for (Handler handler : loggerHandlers) {
                 handler.publish(record);
             }
 
-            if (!logger.getUseParentHandlers()) {
+            final boolean useParentHdls = isSystemLogger
+                ? logger.useParentHandlers
+                : logger.getUseParentHandlers();
+
+            if (!useParentHdls) {
                 break;
             }
 
-            logger = logger.getParent();
+            logger = isSystemLogger ? logger.parent : logger.getParent();
         }
     }
 
@@ -1337,6 +1347,12 @@
      * @return  an array of all registered Handlers
      */
     public Handler[] getHandlers() {
+        return accessCheckedHandlers();
+    }
+
+    // This method should ideally be marked final - but unfortunately
+    // it needs to be overridden by LogManager.RootLogger
+    Handler[] accessCheckedHandlers() {
         return handlers.toArray(emptyHandlers);
     }
 
@@ -1669,11 +1685,13 @@
     private String getEffectiveResourceBundleName() {
         Logger target = this;
         while (target != null) {
-            String rbn = target.getResourceBundleName();
+            final String rbn = isSystemLogger
+                ? target.resourceBundleName
+                : target.getResourceBundleName();
             if (rbn != null) {
                 return rbn;
             }
-            target = target.getParent();
+            target = isSystemLogger ? target.parent : target.getParent();
         }
         return null;
     }
--- ./jdk/src/share/classes/javax/script/ScriptEngineManager.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/javax/script/ScriptEngineManager.java	Tue Mar 18 12:35:25 2014 -0700
@@ -85,15 +85,18 @@
         nameAssociations = new HashMap<String, ScriptEngineFactory>();
         extensionAssociations = new HashMap<String, ScriptEngineFactory>();
         mimeTypeAssociations = new HashMap<String, ScriptEngineFactory>();
-        AccessController.doPrivileged(new PrivilegedAction<Object>() {
-            public Object run() {
-                initEngines(loader);
-                return null;
-            }
-        });
+        List<ScriptEngineFactory> facList = AccessController.doPrivileged(
+            new PrivilegedAction<List<ScriptEngineFactory>>() {
+                public List<ScriptEngineFactory> run() {
+                    return initEngines(loader);
+                }
+            });
+        for (ScriptEngineFactory fac : facList) {
+            engineSpis.add(fac);
+        }
     }
 
-    private void initEngines(final ClassLoader loader) {
+    private List<ScriptEngineFactory> initEngines(final ClassLoader loader) {
         Iterator itr = null;
         try {
             if (loader != null) {
@@ -110,14 +113,15 @@
             // do not throw any exception here. user may want to
             // manage his/her own factories using this manager
             // by explicit registratation (by registerXXX) methods.
-            return;
+            return null;
         }
 
+        final List<ScriptEngineFactory> facList = new ArrayList<>();
         try {
             while (itr.hasNext()) {
                 try {
                     ScriptEngineFactory fact = (ScriptEngineFactory) itr.next();
-                    engineSpis.add(fact);
+                    facList.add(fact);
                 } catch (ServiceConfigurationError err) {
                     System.err.println("ScriptEngineManager providers.next(): "
                                  + err.getMessage());
@@ -137,8 +141,8 @@
             // do not throw any exception here. user may want to
             // manage his/her own factories using this manager
             // by explicit registratation (by registerXXX) methods.
-            return;
         }
+        return facList;
     }
 
     /**
--- ./jdk/src/share/classes/javax/security/auth/Subject.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/javax/security/auth/Subject.java	Tue Mar 18 12:35:25 2014 -0700
@@ -941,14 +941,30 @@
     /**
      * Reads this object from a stream (i.e., deserializes it)
      */
+    @SuppressWarnings("unchecked")
     private void readObject(java.io.ObjectInputStream s)
                 throws java.io.IOException, ClassNotFoundException {
 
-        s.defaultReadObject();
+        ObjectInputStream.GetField gf = s.readFields();
+
+        readOnly = gf.get("readOnly", false);
+
+        Set<Principal> inputPrincs = (Set<Principal>)gf.get("principals", null);
 
         // Rewrap the principals into a SecureSet
-        principals = Collections.synchronizedSet(new SecureSet<Principal>
-                                (this, PRINCIPAL_SET, principals));
+        if (inputPrincs == null) {
+            throw new NullPointerException
+                (ResourcesMgr.getString("invalid.null.input.s."));
+        }
+        try {
+            principals = Collections.synchronizedSet(new SecureSet<Principal>
+                                (this, PRINCIPAL_SET, inputPrincs));
+        } catch (NullPointerException npe) {
+            // Sometimes people deserialize the principals set only.
+            // Subject is not accessible, so just don't fail.
+            principals = Collections.synchronizedSet
+                        (new SecureSet<Principal>(this, PRINCIPAL_SET));
+        }
 
         // The Credential <code>Set</code> is not serialized, but we do not
         // want the default deserialization routine to set it to null.
--- ./jdk/src/share/classes/javax/sql/rowset/RowSetProvider.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/javax/sql/rowset/RowSetProvider.java	Tue Mar 18 12:35:25 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -30,6 +30,7 @@
 import java.sql.SQLException;
 import java.util.ServiceConfigurationError;
 import java.util.ServiceLoader;
+import sun.reflect.misc.ReflectUtil;
 
 /**
  * A factory API that enables applications to obtain a
@@ -127,15 +128,11 @@
             factoryClassName = getSystemProperty(ROWSET_FACTORY_NAME);
             if (factoryClassName != null) {
                 trace("Found system property, value=" + factoryClassName);
-                factory = (RowSetFactory) getFactoryClass(factoryClassName, null, true).newInstance();
+                factory = (RowSetFactory) ReflectUtil.newInstance(getFactoryClass(factoryClassName, null, true));
             }
-        } catch (ClassNotFoundException e) {
-            throw new SQLException(
-                    "RowSetFactory: " + factoryClassName + " not found", e);
-        } catch (Exception e) {
-            throw new SQLException(
-                    "RowSetFactory: " + factoryClassName + " could not be instantiated: " + e,
-                    e);
+        }  catch (Exception e) {
+            throw new SQLException( "RowSetFactory: " + factoryClassName +
+                    " could not be instantiated: ", e);
         }
 
         // Check to see if we found the RowSetFactory via a System property
@@ -180,6 +177,16 @@
             throws SQLException {
 
         trace("***In newInstance()");
+
+        if(factoryClassName == null) {
+            throw new SQLException("Error: factoryClassName cannot be null");
+        }
+        try {
+            ReflectUtil.checkPackageAccess(factoryClassName);
+        } catch (java.security.AccessControlException e) {
+            throw new SQLException("Access Exception",e);
+        }
+
         try {
             Class providerClass = getFactoryClass(factoryClassName, cl, false);
             RowSetFactory instance = (RowSetFactory) providerClass.newInstance();
@@ -292,6 +299,7 @@
             });
         } catch (SecurityException se) {
             if (debug) {
+                trace("error getting " + propName + ":  "+ se);
                 se.printStackTrace();
             }
         }
--- ./jdk/src/share/classes/javax/sql/rowset/serial/SQLInputImpl.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/javax/sql/rowset/serial/SQLInputImpl.java	Tue Mar 18 12:35:25 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -30,6 +30,7 @@
 import java.io.*;
 import java.math.*;
 import java.util.Map;
+import sun.reflect.misc.ReflectUtil;
 
 /**
  * An input stream used for custom mapping user-defined types (UDTs).
@@ -606,13 +607,9 @@
                     // create new instance of the class
                     SQLData obj = null;
                     try {
-                        obj = (SQLData)c.newInstance();
-                    } catch (java.lang.InstantiationException ex) {
-                        throw new SQLException("Unable to instantiate: " +
-                                               ex.getMessage());
-                    } catch (java.lang.IllegalAccessException ex) {
-                        throw new SQLException("Unable to instantiate: " +
-                                               ex.getMessage());
+                        obj = (SQLData)ReflectUtil.newInstance(c);
+                    } catch (Exception ex) {
+                        throw new SQLException("Unable to Instantiate: ", ex);
                     }
                     // get the attributes from the struct
                     Object attribs[] = s.getAttributes(map);
--- ./jdk/src/share/classes/javax/sql/rowset/spi/SyncFactory.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/javax/sql/rowset/spi/SyncFactory.java	Tue Mar 18 12:35:25 2014 -0700
@@ -37,8 +37,11 @@
 import java.io.FileNotFoundException;
 import java.security.AccessController;
 import java.security.PrivilegedAction;
+import java.security.PrivilegedActionException;
+import java.security.PrivilegedExceptionAction;
 
 import javax.naming.*;
+import sun.reflect.misc.ReflectUtil;
 
 /**
  * The Service Provider Interface (SPI) mechanism that generates <code>SyncProvider</code>
@@ -343,7 +346,7 @@
         // Local implementation class names and keys from Properties
         // file, translate names into Class objects using Class.forName
         // and store mappings
-        Properties properties = new Properties();
+        final Properties properties = new Properties();
 
         if (implementations == null) {
             implementations = new Hashtable();
@@ -372,6 +375,7 @@
                         }
                     });
                 } catch (Exception ex) {
+                    System.out.println("errorget rowset.properties: " + ex);
                     strRowsetProperties = null;
                 }
                 if (strRowsetProperties != null) {
@@ -391,16 +395,33 @@
                         strFileSep + "rowset" + strFileSep +
                         "rowset.properties";
 
-                ClassLoader cl = Thread.currentThread().getContextClassLoader();
+                final ClassLoader cl = Thread.currentThread().getContextClassLoader();
 
-                try (InputStream stream =
-                         (cl == null) ? ClassLoader.getSystemResourceAsStream(ROWSET_PROPERTIES)
-                                      : cl.getResourceAsStream(ROWSET_PROPERTIES)) {
-                    if (stream == null) {
-                        throw new SyncFactoryException(
-                            "Resource " + ROWSET_PROPERTIES + " not found");
+                try {
+                    AccessController.doPrivileged(new PrivilegedExceptionAction<Void>() {
+                        @Override
+                        public Void run()  throws SyncFactoryException, IOException, FileNotFoundException {
+                            try (InputStream stream  = (cl == null) ?
+                                    ClassLoader.getSystemResourceAsStream(ROWSET_PROPERTIES)
+                                    : cl.getResourceAsStream(ROWSET_PROPERTIES)) {
+                                if (stream == null) {
+                                    throw new SyncFactoryException("Resource " + ROWSET_PROPERTIES + " not found");
+                                }
+                                properties.load(stream);
+                            }
+                            return null;
+                        }
+
+                    });
+                } catch (PrivilegedActionException ex) {
+                    Throwable e = ex.getException();
+                    if (e instanceof SyncFactoryException) {
+                      throw (SyncFactoryException) e;
+                    } else {
+                        SyncFactoryException sfe = new SyncFactoryException();
+                        sfe.initCause(ex.getException());
+                        throw sfe;
                     }
-                    properties.load(stream);
                 }
 
                 parseProperties(properties);
@@ -560,6 +581,13 @@
             return new com.sun.rowset.providers.RIOptimisticProvider();
         }
 
+        try {
+            ReflectUtil.checkPackageAccess(providerID);
+        } catch (java.security.AccessControlException e) {
+            SyncFactoryException sfe = new SyncFactoryException();
+            sfe.initCause(e);
+            throw sfe;
+        }
         // Attempt to invoke classname from registered SyncProvider list
         Class c = null;
         try {
@@ -568,7 +596,7 @@
             /**
              * The SyncProvider implementation of the user will be in
              * the classpath. We need to find the ClassLoader which loads
-             * this SyncFactory and try to laod the SyncProvider class from
+             * this SyncFactory and try to load the SyncProvider class from
              * there.
              **/
             c = Class.forName(providerID, true, cl);
--- ./jdk/src/share/classes/sun/awt/AWTAccessor.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/sun/awt/AWTAccessor.java	Tue Mar 18 12:35:25 2014 -0700
@@ -29,6 +29,7 @@
 import java.awt.KeyboardFocusManager;
 import java.awt.DefaultKeyboardFocusManager;
 import java.awt.event.InputEvent;
+import java.awt.event.InvocationEvent;
 import java.awt.event.KeyEvent;
 import java.awt.geom.Point2D;
 
@@ -690,6 +691,25 @@
     }
 
     /*
+     * An accessor object for the InvocationEvent class
+     */
+    public interface InvocationEventAccessor {
+        /**
+         * Disposes the InvocationEvent
+         */
+        void dispose(InvocationEvent event);
+
+        /**
+         * Creates an InvocationEvent with a completion listener -
+         * a Runnable whose run() method will be called immediately after
+         * the event is dispatched or disposed
+         */
+        InvocationEvent createEvent(Object source, Runnable runnable, Runnable listener,
+                                    boolean catchThrowables);
+    }
+
+
+    /*
      * Accessor instances are initialized in the static initializers of
      * corresponding AWT classes by using setters defined below.
      */
@@ -716,6 +736,7 @@
     private static TrayIconAccessor trayIconAccessor;
     private static DefaultKeyboardFocusManagerAccessor defaultKeyboardFocusManagerAccessor;
     private static SequencedEventAccessor sequencedEventAccessor;
+    private static InvocationEventAccessor invocationEventAccessor;
 
     /*
      * Set an accessor object for the java.awt.Component class.
@@ -1110,4 +1131,18 @@
         // (so not a single instance of the event has been created).
         return sequencedEventAccessor;
     }
+
+    /*
+     * Get the accessor object for the java.awt.event.InvocationEvent class.
+     */
+    public static void setInvocationEventAccessor(InvocationEventAccessor invocationEventAccessor) {
+        AWTAccessor.invocationEventAccessor = invocationEventAccessor;
+    }
+
+    /*
+     * Set the accessor object for the java.awt.event.InvocationEvent class.
+     */
+    public static InvocationEventAccessor getInvocationEventAccessor() {
+        return invocationEventAccessor;
+    }
 }
--- ./jdk/src/share/classes/sun/awt/AWTAutoShutdown.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/sun/awt/AWTAutoShutdown.java	Tue Mar 18 12:35:25 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000, 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -26,10 +26,13 @@
 package sun.awt;
 
 import java.awt.AWTEvent;
-import java.util.Collections;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 import java.util.HashSet;
 import java.util.IdentityHashMap;
 import java.util.Map;
+
+import sun.misc.ThreadGroupUtils;
 import sun.util.logging.PlatformLogger;
 
 /**
@@ -212,7 +215,13 @@
         synchronized (activationLock) {
             synchronized (mainLock) {
                 if (!isReadyToShutdown() && blockerThread == null) {
-                    activateBlockerThread();
+                    AccessController.doPrivileged(new PrivilegedAction<Void>() {
+                        @Override
+                        public Void run() {
+                            activateBlockerThread();
+                            return null;
+                        }
+                    });
                 } else {
                     mainLock.notifyAll();
                     timeoutPassed = false;
@@ -326,9 +335,12 @@
     /**
      * Creates and starts a new blocker thread. Doesn't return until
      * the new blocker thread starts.
+     *
+     * Must be called with {@link sun.security.util.SecurityConstants#MODIFY_THREADGROUP_PERMISSION}
      */
     private void activateBlockerThread() {
-        Thread thread = new Thread(this, "AWT-Shutdown");
+        Thread thread = new Thread(ThreadGroupUtils.getRootThreadGroup(), this, "AWT-Shutdown");
+        thread.setContextClassLoader(null);
         thread.setDaemon(false);
         blockerThread = thread;
         thread.start();
--- ./jdk/src/share/classes/sun/awt/AppContext.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/sun/awt/AppContext.java	Tue Mar 18 12:35:25 2014 -0700
@@ -837,21 +837,68 @@
             public boolean isMainAppContext() {
                 return (numAppContexts.get() == 1 && mainAppContext != null);
             }
-            public Object getContext() {
-                return getAppContext();
+
+            private boolean hasRootThreadGroup(final AppContext ecx) {
+                return AccessController.doPrivileged(new PrivilegedAction<Boolean>() {
+                    @Override
+                    public Boolean run() {
+                        return ecx.threadGroup.getParent() == null;
+                    }
+                });
             }
-            public Object getExecutionContext() {
-                return getExecutionAppContext();
+
+            /**
+             * Returns the AppContext used for applet logging isolation, or null if
+             * the default global context can be used.
+             * If there's no applet, or if the caller is a stand alone application,
+             * or running in the main app context, returns null.
+             * Otherwise, returns the AppContext of the calling applet.
+             * @return null if the global default context can be used,
+             *         an AppContext otherwise.
+             **/
+            public Object getAppletContext() {
+                // There's no AppContext: return null.
+                // No need to call getAppContext() if numAppContext == 0:
+                // it means that no AppContext has been created yet, and
+                // we don't want to trigger the creation of a main app
+                // context since we don't need it.
+                if (numAppContexts.get() == 0) return null;
+
+                // Get the context from the security manager
+                AppContext ecx = getExecutionAppContext();
+
+                // Not sure we really need to re-check numAppContexts here.
+                // If all applets have gone away then we could have a
+                // numAppContexts coming back to 0. So we recheck
+                // it here because we don't want to trigger the
+                // creation of a main AppContext in that case.
+                // This is probably not 100% MT-safe but should reduce
+                // the window of opportunity in which that issue could
+                // happen.
+                if (numAppContexts.get() > 0) {
+                   // Defaults to thread group caching.
+                   // This is probably not required as we only really need
+                   // isolation in a deployed applet environment, in which
+                   // case ecx will not be null when we reach here
+                   // However it helps emulate the deployed environment,
+                   // in tests for instance.
+                   ecx = ecx != null ? ecx : getAppContext();
+                }
+
+                // getAppletContext() may be called when initializing the main
+                // app context - in which case mainAppContext will still be
+                // null. To work around this issue we simply use
+                // AppContext.threadGroup.getParent() == null instead, since
+                // mainAppContext is the only AppContext which should have
+                // the root TG as its thread group.
+                // See: JDK-8023258
+                final boolean isMainAppContext = ecx == null
+                    || mainAppContext == ecx
+                    || mainAppContext == null && hasRootThreadGroup(ecx);
+
+                return isMainAppContext ? null : ecx;
             }
-            public Object get(Object context, Object key) {
-                return ((AppContext)context).get(key);
-            }
-            public void put(Object context, Object key, Object value) {
-                ((AppContext)context).put(key, value);
-            }
-            public void remove(Object context, Object key) {
-                ((AppContext)context).remove(key);
-            }
+
         });
     }
 }
--- ./jdk/src/share/classes/sun/awt/SunToolkit.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/sun/awt/SunToolkit.java	Tue Mar 18 12:35:25 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -37,6 +37,7 @@
 import java.awt.SystemTray;
 import java.awt.event.InputEvent;
 import java.net.URL;
+import java.security.PrivilegedAction;
 import java.util.*;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.locks.Condition;
--- ./jdk/src/share/classes/sun/awt/datatransfer/ClipboardTransferable.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/sun/awt/datatransfer/ClipboardTransferable.java	Tue Mar 18 12:35:25 2014 -0700
@@ -87,7 +87,7 @@
                 HashMap cached_data = new HashMap(formats.length, 1.0f);
 
                 Map flavorsForFormats = DataTransferer.getInstance().
-                    getFlavorsForFormats(formats, SunClipboard.flavorMap);
+                    getFlavorsForFormats(formats, SunClipboard.getDefaultFlavorTable());
                 for (Iterator iter = flavorsForFormats.keySet().iterator();
                      iter.hasNext(); )
                 {
--- ./jdk/src/share/classes/sun/awt/datatransfer/SunClipboard.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/sun/awt/datatransfer/SunClipboard.java	Tue Mar 18 12:35:25 2014 -0700
@@ -64,9 +64,6 @@
 public abstract class SunClipboard extends Clipboard
     implements PropertyChangeListener {
 
-    public static final FlavorTable flavorMap =
-        (FlavorTable)SystemFlavorMap.getDefaultFlavorMap();
-
     private AppContext contentsContext = null;
 
     private final Object CLIPBOARD_FLAVOR_LISTENER_KEY;
@@ -172,7 +169,7 @@
         long[] formats = getClipboardFormatsOpenClose();
 
         return DataTransferer.getInstance().
-            getFlavorsForFormatsAsArray(formats, flavorMap);
+            getFlavorsForFormatsAsArray(formats, getDefaultFlavorTable());
     }
 
     /**
@@ -218,7 +215,7 @@
 
             long[] formats = getClipboardFormats();
             Long lFormat = (Long)DataTransferer.getInstance().
-                    getFlavorsForFormats(formats, flavorMap).get(flavor);
+                    getFlavorsForFormats(formats, getDefaultFlavorTable()).get(flavor);
 
             if (lFormat == null) {
                 throw new UnsupportedFlavorException(flavor);
@@ -349,7 +346,7 @@
     private static Set formatArrayAsDataFlavorSet(long[] formats) {
         return (formats == null) ? null :
                 DataTransferer.getInstance().
-                getFlavorsForFormatsAsSet(formats, flavorMap);
+                getFlavorsForFormatsAsSet(formats, getDefaultFlavorTable());
     }
 
 
@@ -469,4 +466,7 @@
         }
     }
 
+    public static FlavorTable getDefaultFlavorTable() {
+        return (FlavorTable) SystemFlavorMap.getDefaultFlavorMap();
+    }
 }
--- ./jdk/src/share/classes/sun/font/CreatedFontTracker.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/sun/font/CreatedFontTracker.java	Tue Mar 18 12:35:25 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,12 +27,15 @@
 
 import java.io.File;
 import java.io.OutputStream;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.concurrent.Semaphore;
 import java.util.concurrent.TimeUnit;
 
 import sun.awt.AppContext;
+import sun.misc.ThreadGroupUtils;
 
 public class CreatedFontTracker {
 
@@ -112,28 +115,25 @@
         static void init() {
             if (t == null) {
                 // Add a shutdown hook to remove the temp file.
-                java.security.AccessController.doPrivileged(
-                   new java.security.PrivilegedAction() {
-                      public Object run() {
-                          /* The thread must be a member of a thread group
-                           * which will not get GCed before VM exit.
-                           * Make its parent the top-level thread group.
-                           */
-                          ThreadGroup tg =
-                              Thread.currentThread().getThreadGroup();
-                          for (ThreadGroup tgn = tg;
-                               tgn != null;
-                               tg = tgn, tgn = tg.getParent());
-                          t = new Thread(tg, new Runnable() {
-                              public void run() {
-                                  runHooks();
-                              }
-                          });
-                          t.setContextClassLoader(null);
-                          Runtime.getRuntime().addShutdownHook(t);
-                          return null;
-                      }
-                   });
+                AccessController.doPrivileged(new PrivilegedAction<Void>() {
+                            @Override
+                            public Void run() {
+                            /* The thread must be a member of a thread group
+                             * which will not get GCed before VM exit.
+                             * Make its parent the top-level thread group.
+                             */
+                                ThreadGroup rootTG = ThreadGroupUtils.getRootThreadGroup();
+                                t = new Thread(rootTG, new Runnable() {
+                                    @Override
+                                    public void run() {
+                                        runHooks();
+                                    }
+                                });
+                                t.setContextClassLoader(null);
+                                Runtime.getRuntime().addShutdownHook(t);
+                                return null;
+                            }
+                        });
             }
         }
 
--- ./jdk/src/share/classes/sun/font/SunFontManager.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/sun/font/SunFontManager.java	Tue Mar 18 12:35:25 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -52,6 +52,7 @@
 import sun.awt.AppContext;
 import sun.awt.FontConfiguration;
 import sun.awt.SunToolkit;
+import sun.misc.ThreadGroupUtils;
 import sun.java2d.FontSupport;
 import sun.util.logging.PlatformLogger;
 
@@ -2521,24 +2522,20 @@
                           });
                       }
                     };
-                    java.security.AccessController.doPrivileged(
-                       new java.security.PrivilegedAction() {
-                          public Object run() {
-                              /* The thread must be a member of a thread group
-                               * which will not get GCed before VM exit.
-                               * Make its parent the top-level thread group.
-                               */
-                              ThreadGroup tg =
-                                  Thread.currentThread().getThreadGroup();
-                              for (ThreadGroup tgn = tg;
-                                   tgn != null;
-                                   tg = tgn, tgn = tg.getParent());
-                              fileCloser = new Thread(tg, fileCloserRunnable);
-                              fileCloser.setContextClassLoader(null);
-                              Runtime.getRuntime().addShutdownHook(fileCloser);
-                              return null;
-                          }
-                    });
+                    AccessController.doPrivileged(new PrivilegedAction<Void>() {
+                                @Override
+                                public Void run() {
+                                /* The thread must be a member of a thread group
+                                 * which will not get GCed before VM exit.
+                                 * Make its parent the top-level thread group.
+                                 */
+                                    ThreadGroup rootTG = ThreadGroupUtils.getRootThreadGroup();
+                                    fileCloser = new Thread(rootTG, fileCloserRunnable);
+                                    fileCloser.setContextClassLoader(null);
+                                    Runtime.getRuntime().addShutdownHook(fileCloser);
+                                    return null;
+                                }
+                            });
                 }
             }
         }
--- ./jdk/src/share/classes/sun/java2d/Disposer.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/sun/java2d/Disposer.java	Tue Mar 18 12:35:25 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2002, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2002, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,10 +25,14 @@
 
 package sun.java2d;
 
+import sun.misc.ThreadGroupUtils;
+
 import java.lang.ref.Reference;
 import java.lang.ref.ReferenceQueue;
 import java.lang.ref.PhantomReference;
 import java.lang.ref.WeakReference;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 import java.util.ArrayList;
 import java.util.Hashtable;
 
@@ -71,26 +75,22 @@
             }
         }
         disposerInstance = new Disposer();
-        java.security.AccessController.doPrivileged(
-            new java.security.PrivilegedAction() {
-                public Object run() {
+        AccessController.doPrivileged(new PrivilegedAction<Void>() {
+                    @Override
+                    public Void run() {
                     /* The thread must be a member of a thread group
                      * which will not get GCed before VM exit.
                      * Make its parent the top-level thread group.
                      */
-                    ThreadGroup tg = Thread.currentThread().getThreadGroup();
-                    for (ThreadGroup tgn = tg;
-                         tgn != null;
-                         tg = tgn, tgn = tg.getParent());
-                    Thread t =
-                        new Thread(tg, disposerInstance, "Java2D Disposer");
-                    t.setContextClassLoader(null);
-                    t.setDaemon(true);
-                    t.setPriority(Thread.MAX_PRIORITY);
-                    t.start();
-                    return null;
+                        ThreadGroup rootTG = ThreadGroupUtils.getRootThreadGroup();
+                        Thread t = new Thread(rootTG, disposerInstance, "Java2D Disposer");
+                        t.setContextClassLoader(null);
+                        t.setDaemon(true);
+                        t.setPriority(Thread.MAX_PRIORITY);
+                        t.start();
+                        return null;
+                    }
                 }
-            }
         );
     }
 
--- ./jdk/src/share/classes/sun/java2d/opengl/OGLRenderQueue.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/sun/java2d/opengl/OGLRenderQueue.java	Tue Mar 18 12:35:25 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,6 +25,7 @@
 
 package sun.java2d.opengl;
 
+import sun.misc.ThreadGroupUtils;
 import sun.java2d.pipe.RenderBuffer;
 import sun.java2d.pipe.RenderQueue;
 import static sun.java2d.pipe.BufferedOpCodes.*;
@@ -48,12 +49,9 @@
          * which will not get GCed before VM exit.
          */
         flusher = AccessController.doPrivileged(new PrivilegedAction<QueueFlusher>() {
+            @Override
             public QueueFlusher run() {
-                ThreadGroup rootThreadGroup = Thread.currentThread().getThreadGroup();
-                while (rootThreadGroup.getParent() != null) {
-                    rootThreadGroup = rootThreadGroup.getParent();
-                }
-                return new QueueFlusher(rootThreadGroup);
+                return new QueueFlusher(ThreadGroupUtils.getRootThreadGroup());
             }
         });
     }
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/src/share/classes/sun/misc/InnocuousThread.java	Tue Mar 18 12:35:25 2014 -0700
@@ -0,0 +1,121 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNUNSAFE General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUNSAFET
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICUNSAFELAR PUNSAFERPOSE.  See the GNUNSAFE General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNUNSAFE General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 UNSAFESA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 UNSAFESA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package sun.misc;
+
+import java.security.AccessControlContext;
+import java.security.ProtectionDomain;
+
+/**
+ * A thread that has no permissions, is not a member of any user-defined
+ * ThreadGroup and supports the ability to erase ThreadLocals.
+ *
+ * @implNote Based on the implementation of InnocuousForkJoinWorkerThread.
+ */
+public final class InnocuousThread extends Thread {
+    private static final Unsafe UNSAFE;
+    private static final ThreadGroup THREADGROUP;
+    private static final AccessControlContext ACC;
+    private static final long THREADLOCALS;
+    private static final long INHERITABLETHREADLOCALS;
+    private static final long INHERITEDACCESSCONTROLCONTEXT;
+
+    public InnocuousThread(Runnable target) {
+        super(THREADGROUP, target, "anInnocuousThread");
+        UNSAFE.putOrderedObject(this, INHERITEDACCESSCONTROLCONTEXT, ACC);
+        eraseThreadLocals();
+    }
+
+    @Override
+    public ClassLoader getContextClassLoader() {
+        // always report system class loader
+        return ClassLoader.getSystemClassLoader();
+    }
+
+    @Override
+    public void setUncaughtExceptionHandler(UncaughtExceptionHandler x) {
+        // silently fail
+    }
+
+    @Override
+    public void setContextClassLoader(ClassLoader cl) {
+        throw new SecurityException("setContextClassLoader");
+    }
+
+    // ensure run method is run only once
+    private volatile boolean hasRun;
+
+    @Override
+    public void run() {
+        if (Thread.currentThread() == this && !hasRun) {
+            hasRun = true;
+            super.run();
+        }
+    }
+
+    /**
+     * Drops all thread locals (and inherited thread locals).
+     */
+    public void eraseThreadLocals() {
+        UNSAFE.putObject(this, THREADLOCALS, null);
+        UNSAFE.putObject(this, INHERITABLETHREADLOCALS, null);
+    }
+
+    // Use Unsafe to access Thread group and ThreadGroup parent fields
+    static {
+        try {
+            ACC = new AccessControlContext(new ProtectionDomain[] {
+                new ProtectionDomain(null, null)
+            });
+
+            // Find and use topmost ThreadGroup as parent of new group
+            UNSAFE = Unsafe.getUnsafe();
+            Class<?> tk = Thread.class;
+            Class<?> gk = ThreadGroup.class;
+
+            THREADLOCALS = UNSAFE.objectFieldOffset
+                (tk.getDeclaredField("threadLocals"));
+            INHERITABLETHREADLOCALS = UNSAFE.objectFieldOffset
+                (tk.getDeclaredField("inheritableThreadLocals"));
+            INHERITEDACCESSCONTROLCONTEXT = UNSAFE.objectFieldOffset
+                (tk.getDeclaredField("inheritedAccessControlContext"));
+
+            long tg = UNSAFE.objectFieldOffset(tk.getDeclaredField("group"));
+            long gp = UNSAFE.objectFieldOffset(gk.getDeclaredField("parent"));
+            ThreadGroup group = (ThreadGroup)
+                UNSAFE.getObject(Thread.currentThread(), tg);
+
+            while (group != null) {
+                ThreadGroup parent = (ThreadGroup)UNSAFE.getObject(group, gp);
+                if (parent == null)
+                    break;
+                group = parent;
+            }
+            THREADGROUP = new ThreadGroup(group, "InnocuousThreadGroup");
+        } catch (Exception e) {
+            throw new Error(e);
+        }
+    }
+}
--- ./jdk/src/share/classes/sun/misc/JavaAWTAccess.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/sun/misc/JavaAWTAccess.java	Tue Mar 18 12:35:25 2014 -0700
@@ -26,14 +26,16 @@
 package sun.misc;
 
 public interface JavaAWTAccess {
-    public Object getContext();
-    public Object getExecutionContext();
 
-    public Object get(Object context, Object key);
-    public void put(Object context, Object key, Object value);
-    public void remove(Object context, Object key);
+    // Returns the AppContext used for applet logging isolation, or null if
+    // no isolation is required.
+    // If there's no applet, or if the caller is a stand alone application,
+    // or running in the main app context, returns null.
+    // Otherwise, returns the AppContext of the calling applet.
+    public Object getAppletContext();
 
-    // convenience methods whose context is the object returned by getContext()
+    // convenience methods to cache objects in the current thread group's
+    // AppContext
     public Object get(Object key);
     public void put(Object key, Object value);
     public void remove(Object key);
--- ./jdk/src/share/classes/sun/misc/Service.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/sun/misc/Service.java	Tue Mar 18 12:35:25 2014 -0700
@@ -299,7 +299,7 @@
                 return service.cast(c.newInstance());
             } catch (Throwable x) {
                 fail(service,
-                     "Provider " + cn + " could not be instantiated: " + x,
+                     "Provider " + cn + " could not be instantiated",
                      x);
             }
             return null;        /* This cannot happen */
--- ./jdk/src/share/classes/sun/misc/SharedSecrets.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/sun/misc/SharedSecrets.java	Tue Mar 18 12:35:25 2014 -0700
@@ -197,9 +197,6 @@
     public static JavaAWTAccess getJavaAWTAccess() {
         // this may return null in which case calling code needs to
         // provision for.
-        if (javaAWTAccess == null || javaAWTAccess.getContext() == null) {
-            return null;
-        }
         return javaAWTAccess;
     }
 }
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/src/share/classes/sun/misc/ThreadGroupUtils.java	Tue Mar 18 12:35:25 2014 -0700
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package sun.misc;
+
+/**
+ * A utility class needed to access the root {@code ThreadGroup}
+ *
+ * The class should not depend on any others, because it' called from JNI_OnLoad of the AWT
+ * native library. Triggering class loading could could lead to a deadlock.
+ */
+public final class ThreadGroupUtils {
+
+    private ThreadGroupUtils() {
+        // Avoid instantiation
+    }
+
+    /**
+     * Returns a root thread group.
+     * Should be called with {@link sun.security.util.SecurityConstants#MODIFY_THREADGROUP_PERMISSION}
+     *
+     * @return a root {@code ThreadGroup}
+     */
+    public static ThreadGroup getRootThreadGroup() {
+        ThreadGroup currentTG = Thread.currentThread().getThreadGroup();
+        ThreadGroup parentTG = currentTG.getParent();
+        while (parentTG != null) {
+            currentTG = parentTG;
+            parentTG = currentTG.getParent();
+        }
+        return currentTG;
+    }
+}
--- ./jdk/src/share/classes/sun/nio/ch/Invoker.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/sun/nio/ch/Invoker.java	Tue Mar 18 12:35:25 2014 -0700
@@ -130,6 +130,18 @@
 
         // clear interrupt
         Thread.interrupted();
+
+        // clear thread locals when in default thread pool
+        if (System.getSecurityManager() != null) {
+            Thread me = Thread.currentThread();
+            if (me instanceof sun.misc.InnocuousThread) {
+                GroupAndInvokeCount thisGroupAndInvokeCount = myGroupAndInvokeCount.get();
+                ((sun.misc.InnocuousThread)me).eraseThreadLocals();
+                if (thisGroupAndInvokeCount != null) {
+                    myGroupAndInvokeCount.set(thisGroupAndInvokeCount);
+                }
+            }
+        }
     }
 
     /**
--- ./jdk/src/share/classes/sun/nio/ch/ThreadPool.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/sun/nio/ch/ThreadPool.java	Tue Mar 18 12:35:25 2014 -0700
@@ -27,6 +27,7 @@
 
 import java.util.concurrent.*;
 import java.security.AccessController;
+import java.security.PrivilegedAction;
 import sun.security.action.GetPropertyAction;
 import sun.security.action.GetIntegerAction;
 
@@ -39,14 +40,6 @@
         "java.nio.channels.DefaultThreadPool.threadFactory";
     private static final String DEFAULT_THREAD_POOL_INITIAL_SIZE =
         "java.nio.channels.DefaultThreadPool.initialSize";
-    private static final ThreadFactory defaultThreadFactory = new ThreadFactory() {
-         @Override
-         public Thread newThread(Runnable r) {
-             Thread t = new Thread(r);
-             t.setDaemon(true);
-             return t;
-        }
-     };
 
     private final ExecutorService executor;
 
@@ -79,7 +72,29 @@
     }
 
     static ThreadFactory defaultThreadFactory() {
-        return defaultThreadFactory;
+        if (System.getSecurityManager() == null) {
+            return new ThreadFactory() {
+                @Override
+                public Thread newThread(Runnable r) {
+                    Thread t = new Thread(r);
+                    t.setDaemon(true);
+                    return t;
+                }
+            };
+        } else {
+            return new ThreadFactory() {
+                @Override
+                public Thread newThread(final Runnable r) {
+                    return (Thread) AccessController.doPrivileged(new PrivilegedAction() {
+                        public Object run() {
+                            Thread t = new sun.misc.InnocuousThread(r);
+                            t.setDaemon(true);
+                            return t;
+                        }
+                    });
+                }
+            };
+        }
     }
 
     private static class DefaultThreadPoolHolder {
@@ -100,7 +115,7 @@
         // default to thread factory that creates daemon threads
         ThreadFactory threadFactory = getDefaultThreadPoolThreadFactory();
         if (threadFactory == null)
-            threadFactory = defaultThreadFactory;
+            threadFactory = defaultThreadFactory();
         // create thread pool
         ExecutorService executor =
             new ThreadPoolExecutor(0, Integer.MAX_VALUE,
--- ./jdk/src/share/classes/sun/security/provider/SeedGenerator.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/sun/security/provider/SeedGenerator.java	Tue Mar 18 12:35:25 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -173,8 +173,8 @@
                             md.update(p.getProperty(s).getBytes());
                         }
 
-                        md.update
-                            (InetAddress.getLocalHost().toString().getBytes());
+                        // Include network adapter names (and a Mac address)
+                        addNetworkAdapterInfo(md);
 
                         // The temporary dir
                         File f = new File(p.getProperty("java.io.tmpdir"));
@@ -212,6 +212,31 @@
         return md.digest();
     }
 
+    /*
+     * Include network adapter names and, if available, a Mac address
+     *
+     * See also java.util.concurrent.ThreadLocalRandom.initialSeed()
+     */
+    private static void addNetworkAdapterInfo(MessageDigest md) {
+
+        try {
+            Enumeration<NetworkInterface> ifcs =
+                NetworkInterface.getNetworkInterfaces();
+            while (ifcs.hasMoreElements()) {
+                NetworkInterface ifc = ifcs.nextElement();
+                md.update(ifc.toString().getBytes());
+                if (!ifc.isVirtual()) { // skip fake addresses
+                    byte[] bs = ifc.getHardwareAddress();
+                    if (bs != null) {
+                        md.update(bs);
+                        break;
+                    }
+                }
+            }
+        } catch (Exception ignore) {
+        }
+    }
+
     /**
      * Helper function to convert a long into a byte array (least significant
      * byte first).
--- ./jdk/src/share/classes/sun/security/provider/certpath/AlgorithmChecker.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/sun/security/provider/certpath/AlgorithmChecker.java	Tue Mar 18 12:35:25 2014 -0700
@@ -75,7 +75,7 @@
     private PublicKey prevPubKey;
 
     private final static Set<CryptoPrimitive> SIGNATURE_PRIMITIVE_SET =
-                                    EnumSet.of(CryptoPrimitive.SIGNATURE);
+        Collections.unmodifiableSet(EnumSet.of(CryptoPrimitive.SIGNATURE));
 
     private final static DisabledAlgorithmConstraints
         certPathDefaultConstraints = new DisabledAlgorithmConstraints(
--- ./jdk/src/share/classes/sun/security/provider/certpath/ldap/LDAPCertStore.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/sun/security/provider/certpath/ldap/LDAPCertStore.java	Tue Mar 18 12:35:25 2014 -0700
@@ -50,6 +50,7 @@
 import sun.security.util.Cache;
 import sun.security.util.Debug;
 import sun.security.x509.X500Name;
+import sun.security.action.GetBooleanAction;
 import sun.security.action.GetPropertyAction;
 
 /**
@@ -135,6 +136,14 @@
     private final static String PROP_LIFETIME =
                             "sun.security.certpath.ldap.cache.lifetime";
 
+    /*
+     * Internal system property, that when set to "true", disables the
+     * JNDI application resource files lookup to prevent recursion issues
+     * when validating signed JARs with LDAP URLs in certificates.
+     */
+    private final static String PROP_DISABLE_APP_RESOURCE_FILES =
+        "sun.security.certpath.ldap.disable.app.resource.files";
+
     static {
         String s = AccessController.doPrivileged(
                                 new GetPropertyAction(PROP_LIFETIME));
@@ -236,6 +245,17 @@
         env.put(Context.INITIAL_CONTEXT_FACTORY,
                 "com.sun.jndi.ldap.LdapCtxFactory");
         env.put(Context.PROVIDER_URL, url);
+
+        // If property is set to true, disable application resource file lookup.
+        boolean disableAppResourceFiles = AccessController.doPrivileged(
+            new GetBooleanAction(PROP_DISABLE_APP_RESOURCE_FILES));
+        if (disableAppResourceFiles) {
+            if (debug != null) {
+                debug.println("LDAPCertStore disabling app resource files");
+            }
+            env.put("com.sun.naming.disable.app.resource.files", "true");
+        }
+
         try {
             ctx = new InitialDirContext(env);
             /*
--- ./jdk/src/share/classes/sun/security/rsa/RSAPadding.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/sun/security/rsa/RSAPadding.java	Tue Mar 18 12:35:25 2014 -0700
@@ -25,11 +25,9 @@
 
 package sun.security.rsa;
 
-import java.math.BigInteger;
 import java.util.*;
 
 import java.security.*;
-import java.security.interfaces.*;
 import java.security.spec.*;
 
 import javax.crypto.BadPaddingException;
@@ -41,21 +39,41 @@
 /**
  * RSA padding and unpadding.
  *
- * Format of PKCS#1 v1.5 padding is:
+ * The various PKCS#1 versions can be found in the EMC/RSA Labs
+ * web site, which is currently:
+ *
+ *     http://www.emc.com/emc-plus/rsa-labs/index.htm
+ *
+ * or in the IETF RFCs derived from the above PKCS#1 standards.
+ *
+ *     RFC 2313: v1.5
+ *     RFC 2437: v2.0
+ *     RFC 3447: v2.1
+ *
+ * The format of PKCS#1 v1.5 padding is:
+ *
  *   0x00 | BT | PS...PS | 0x00 | data...data
+ *
  * where BT is the blocktype (1 or 2). The length of the entire string
  * must be the same as the size of the modulus (i.e. 128 byte for a 1024 bit
  * key). Per spec, the padding string must be at least 8 bytes long. That
  * leaves up to (length of key in bytes) - 11 bytes for the data.
  *
- * OAEP padding is a bit more complicated and has a number of options.
- * We support:
+ * OAEP padding was introduced in PKCS#1 v2.0 and is a bit more complicated
+ * and has a number of options. We support:
+ *
  *   . arbitrary hash functions ('Hash' in the specification), MessageDigest
  *     implementation must be available
  *   . MGF1 as the mask generation function
  *   . the empty string as the default value for label L and whatever
  *     specified in javax.crypto.spec.OAEPParameterSpec
  *
+ * The algorithms (representations) are forwards-compatible: that is,
+ * the algorithm described in previous releases are in later releases.
+ * However, additional comments/checks/clarifications were added to the
+ * later versions based on real-world experience (e.g. stricter v1.5
+ * format checking.)
+ *
  * Note: RSA keys should be at least 512 bits long
  *
  * @since   1.5
@@ -156,7 +174,8 @@
                         throw new InvalidAlgorithmParameterException
                             ("Unsupported MGF algo: " + mgfName);
                     }
-                    mgfMdName = ((MGF1ParameterSpec)spec.getMGFParameters()).getDigestAlgorithm();
+                    mgfMdName = ((MGF1ParameterSpec)spec.getMGFParameters())
+                            .getDigestAlgorithm();
                     PSource pSrc = spec.getPSource();
                     String pSrcAlgo = pSrc.getAlgorithm();
                     if (!pSrcAlgo.equalsIgnoreCase("PSpecified")) {
@@ -198,7 +217,7 @@
      */
     private static byte[] getInitialHash(MessageDigest md,
         byte[] digestInput) {
-        byte[] result = null;
+        byte[] result;
         if ((digestInput == null) || (digestInput.length == 0)) {
             String digestName = md.getAlgorithm();
             result = emptyHashes.get(digestName);
@@ -213,8 +232,8 @@
     }
 
     /**
-     * Return the maximum size of the plaintext data that can be processed using
-     * this object.
+     * Return the maximum size of the plaintext data that can be processed
+     * using this object.
      */
     public int getMaxDataSize() {
         return maxDataSize;
@@ -262,7 +281,7 @@
      */
     public byte[] unpad(byte[] padded) throws BadPaddingException {
         if (padded.length != paddedSize) {
-            throw new BadPaddingException("Padded length must be " + paddedSize);
+            throw new BadPaddingException("Decryption error");
         }
         switch (type) {
         case PAD_NONE:
@@ -282,7 +301,8 @@
      */
     private byte[] padV15(byte[] data) throws BadPaddingException {
         byte[] padded = new byte[paddedSize];
-        System.arraycopy(data, 0, padded, paddedSize - data.length, data.length);
+        System.arraycopy(data, 0, padded, paddedSize - data.length,
+            data.length);
         int psSize = paddedSize - 3 - data.length;
         int k = 0;
         padded[k++] = 0;
@@ -317,55 +337,53 @@
     }
 
     /**
-     * PKCS#1 v1.5 unpadding (blocktype 1 and 2).
+     * PKCS#1 v1.5 unpadding (blocktype 1 (signature) and 2 (encryption)).
      *
      * Note that we want to make it a constant-time operation
      */
     private byte[] unpadV15(byte[] padded) throws BadPaddingException {
         int k = 0;
-        BadPaddingException bpe = null;
+        boolean bp = false;
 
         if (padded[k++] != 0) {
-            bpe = new BadPaddingException("Data must start with zero");
+            bp = true;
         }
-        if (padded[k++] != type && bpe == null) {
-            bpe = new BadPaddingException("Blocktype mismatch: " + padded[1]);
+        if (padded[k++] != type) {
+            bp = true;
         }
         int p = 0;
         while (k < padded.length) {
             int b = padded[k++] & 0xff;
-            if (b == 0 && p == 0) {
+            if ((b == 0) && (p == 0)) {
                 p = k;
             }
-            if (k == padded.length && p == 0 && bpe == null) {
-                bpe = new BadPaddingException("Padding string not terminated");
+            if ((k == padded.length) && (p == 0)) {
+                bp = true;
             }
             if ((type == PAD_BLOCKTYPE_1) && (b != 0xff) &&
-                    p == 0 && bpe == null) {
-                bpe = new BadPaddingException("Padding byte not 0xff: " + b);
+                    (p == 0)) {
+                bp = true;
             }
         }
         int n = padded.length - p;
-        if (n > maxDataSize && bpe == null) {
-            bpe = new BadPaddingException("Padding string too short");
+        if (n > maxDataSize) {
+            bp = true;
         }
 
         // copy useless padding array for a constant-time method
-        //
-        // Is it necessary?
         byte[] padding = new byte[p];
         System.arraycopy(padded, 0, padding, 0, p);
 
         byte[] data = new byte[n];
         System.arraycopy(padded, p, data, 0, n);
 
-        if (bpe == null) {
-            bpe = new BadPaddingException("Unused exception");
+        BadPaddingException bpe = new BadPaddingException("Decryption error");
+
+        if (bp) {
+            throw bpe;
         } else {
-            throw bpe;
+            return data;
         }
-
-        return data;
     }
 
     /**
@@ -424,10 +442,11 @@
      */
     private byte[] unpadOAEP(byte[] padded) throws BadPaddingException {
         byte[] EM = padded;
+        boolean bp = false;
         int hLen = lHash.length;
 
         if (EM[0] != 0) {
-            throw new BadPaddingException("Data must start with zero");
+            bp = true;
         }
 
         int seedStart = 1;
@@ -442,29 +461,48 @@
         // verify lHash == lHash'
         for (int i = 0; i < hLen; i++) {
             if (lHash[i] != EM[dbStart + i]) {
-                throw new BadPaddingException("lHash mismatch");
+                bp = true;
             }
         }
 
-        // skip over padding (0x00 bytes)
-        int i = dbStart + hLen;
-        while (EM[i] == 0) {
-            i++;
-            if (i >= EM.length) {
-                throw new BadPaddingException("Padding string not terminated");
+        int padStart = dbStart + hLen;
+        int onePos = -1;
+
+        for (int i = padStart; i < EM.length; i++) {
+            int value = EM[i];
+            if (onePos == -1) {
+                if (value == 0x00) {
+                    // continue;
+                } else if (value == 0x01) {
+                    onePos = i;
+                } else {  // Anything other than {0,1} is bad.
+                    bp = true;
+                }
             }
         }
 
-        if (EM[i++] != 1) {
-            throw new BadPaddingException
-                ("Padding string not terminated by 0x01 byte");
+        // We either ran off the rails or found something other than 0/1.
+        if (onePos == -1) {
+            bp = true;
+            onePos = EM.length - 1;  // Don't inadvertently return any data.
         }
 
-        int mLen = EM.length - i;
-        byte[] m = new byte[mLen];
-        System.arraycopy(EM, i, m, 0, mLen);
+        int mStart = onePos + 1;
 
-        return m;
+        // copy useless padding array for a constant-time method
+        byte [] tmp = new byte[mStart - padStart];
+        System.arraycopy(EM, padStart, tmp, 0, tmp.length);
+
+        byte [] m = new byte[EM.length - mStart];
+        System.arraycopy(EM, mStart, m, 0, m.length);
+
+        BadPaddingException bpe = new BadPaddingException("Decryption error");
+
+        if (bp) {
+            throw bpe;
+        } else {
+            return m;
+        }
     }
 
     /**
@@ -478,7 +516,7 @@
     private void mgf1(byte[] seed, int seedOfs, int seedLen,
             byte[] out, int outOfs, int maskLen)  throws BadPaddingException {
         byte[] C = new byte[4]; // 32 bit counter
-        byte[] digest = new byte[20]; // 20 bytes is length of SHA-1 digest
+        byte[] digest = new byte[mgfMd.getDigestLength()];
         while (maskLen > 0) {
             mgfMd.update(seed, seedOfs, seedLen);
             mgfMd.update(C);
@@ -499,5 +537,4 @@
             }
         }
     }
-
 }
--- ./jdk/src/share/classes/sun/security/ssl/SignatureAndHashAlgorithm.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/sun/security/ssl/SignatureAndHashAlgorithm.java	Tue Mar 18 12:35:25 2014 -0700
@@ -68,7 +68,7 @@
 
     // performance optimization
     private final static Set<CryptoPrimitive> SIGNATURE_PRIMITIVE_SET =
-                                    EnumSet.of(CryptoPrimitive.SIGNATURE);
+        Collections.unmodifiableSet(EnumSet.of(CryptoPrimitive.SIGNATURE));
 
     // supported pairs of signature and hash algorithm
     private final static Map<Integer, SignatureAndHashAlgorithm> supportedMap;
--- ./jdk/src/share/classes/sun/security/tools/JarSigner.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/sun/security/tools/JarSigner.java	Tue Mar 18 12:35:25 2014 -0700
@@ -88,9 +88,6 @@
 
     private static final String META_INF = "META-INF/";
 
-    // prefix for new signature-related files in META-INF directory
-    private static final String SIG_PREFIX = META_INF + "SIG-";
-
     private static final Class[] PARAM_STRING = { String.class };
 
     private static final String NONE = "NONE";
@@ -1516,22 +1513,7 @@
      * . META-INF/*.EC
      */
     private boolean signatureRelated(String name) {
-        String ucName = name.toUpperCase(Locale.ENGLISH);
-        if (ucName.equals(JarFile.MANIFEST_NAME) ||
-            ucName.equals(META_INF) ||
-            (ucName.startsWith(SIG_PREFIX) &&
-                ucName.indexOf("/") == ucName.lastIndexOf("/"))) {
-            return true;
-        }
-
-        if (ucName.startsWith(META_INF) &&
-            SignatureFileVerifier.isBlockOrSF(ucName)) {
-            // .SF/.DSA/.RSA/.EC files in META-INF subdirs
-            // are not considered signature-related
-            return (ucName.indexOf("/") == ucName.lastIndexOf("/"));
-        }
-
-        return false;
+        return SignatureFileVerifier.isSigningRelated(name);
     }
 
     Map<CodeSigner,String> cacheForSignerInfo = new IdentityHashMap<>();
--- ./jdk/src/share/classes/sun/security/util/SignatureFileVerifier.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/sun/security/util/SignatureFileVerifier.java	Tue Mar 18 12:35:25 2014 -0700
@@ -153,6 +153,52 @@
         return false;
     }
 
+    /**
+     * Yet another utility method used by JarVerifier and JarSigner
+     * to determine what files are signature related, which includes
+     * the MANIFEST, SF files, known signature block files, and other
+     * unknown signature related files (those starting with SIG- with
+     * an optional [A-Z0-9]{1,3} extension right inside META-INF).
+     *
+     * @param s file name
+     * @return true if the input file name is signature related
+     */
+    public static boolean isSigningRelated(String name) {
+        name = name.toUpperCase(Locale.ENGLISH);
+        if (!name.startsWith("META-INF/")) {
+            return false;
+        }
+        name = name.substring(9);
+        if (name.indexOf('/') != -1) {
+            return false;
+        }
+        if (isBlockOrSF(name) || name.equals("MANIFEST.MF")) {
+            return true;
+        } else if (name.startsWith("SIG-")) {
+            // check filename extension
+            // see http://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html#Digital_Signatures
+            // for what filename extensions are legal
+            int extIndex = name.lastIndexOf('.');
+            if (extIndex != -1) {
+                String ext = name.substring(extIndex + 1);
+                // validate length first
+                if (ext.length() > 3 || ext.length() < 1) {
+                    return false;
+                }
+                // then check chars, must be in [a-zA-Z0-9] per the jar spec
+                for (int index = 0; index < ext.length(); index++) {
+                    char cc = ext.charAt(index);
+                    // chars are promoted to uppercase so skip lowercase checks
+                    if ((cc < 'A' || cc > 'Z') && (cc < '0' || cc > '9')) {
+                        return false;
+                    }
+                }
+            }
+            return true; // no extension is OK
+        }
+        return false;
+    }
+
     /** get digest from cache */
 
     private MessageDigest getDigest(String algorithm)
--- ./jdk/src/share/classes/sun/util/resources/TimeZoneNames.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/sun/util/resources/TimeZoneNames.java	Tue Mar 18 12:35:25 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -483,7 +483,7 @@
             {"Asia/Aden", ARAST},
             {"Asia/Almaty", new String[] {"Alma-Ata Time", "ALMT",
                                           "Alma-Ata Summer Time", "ALMST"}},
-            {"Asia/Amman", ARAST},
+            {"Asia/Amman", EET},
             {"Asia/Anadyr", new String[] {"Anadyr Time", "ANAT",
                                           "Anadyr Summer Time", "ANAST"}},
             {"Asia/Aqtau", new String[] {"Aqtau Time", "AQTT",
--- ./jdk/src/share/classes/sun/util/resources/TimeZoneNames_de.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/sun/util/resources/TimeZoneNames_de.java	Tue Mar 18 12:35:25 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -483,7 +483,7 @@
             {"Asia/Aden", ARAST},
             {"Asia/Almaty", new String[] {"Alma Ata Zeit", "ALMT",
                                           "Alma-Ata Sommerzeit", "ALMST"}},
-            {"Asia/Amman", ARAST},
+            {"Asia/Amman", EET},
             {"Asia/Anadyr", new String[] {"Anadyr Zeit", "ANAT",
                                           "Anadyr Sommerzeit", "ANAST"}},
             {"Asia/Aqtau", new String[] {"Aqtau Zeit", "AQTT",
--- ./jdk/src/share/classes/sun/util/resources/TimeZoneNames_es.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/sun/util/resources/TimeZoneNames_es.java	Tue Mar 18 12:35:25 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -483,7 +483,7 @@
             {"Asia/Aden", ARAST},
             {"Asia/Almaty", new String[] {"Hora de Alma-Ata", "ALMT",
                                           "Hora de verano de Alma-Ata", "ALMST"}},
-            {"Asia/Amman", ARAST},
+            {"Asia/Amman", EET},
             {"Asia/Anadyr", new String[] {"Hora de Anadyr", "ANAT",
                                           "Hora de verano de Anadyr", "ANAST"}},
             {"Asia/Aqtau", new String[] {"Hora de Aqtau", "AQTT",
--- ./jdk/src/share/classes/sun/util/resources/TimeZoneNames_fr.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/sun/util/resources/TimeZoneNames_fr.java	Tue Mar 18 12:35:25 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -483,7 +483,7 @@
             {"Asia/Aden", ARAST},
             {"Asia/Almaty", new String[] {"Heure d'Alma-Ata", "ALMT",
                                           "Heure d'\u00e9t\u00e9 d'Alma-Ata", "ALMST"}},
-            {"Asia/Amman", ARAST},
+            {"Asia/Amman", EET},
             {"Asia/Anadyr", new String[] {"Heure d'Anadyr", "ANAT",
                                           "Heure d'\u00e9t\u00e9 d'Anadyr", "ANAST"}},
             {"Asia/Aqtau", new String[] {"Heure d'Aqtau", "AQTT",
--- ./jdk/src/share/classes/sun/util/resources/TimeZoneNames_it.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/sun/util/resources/TimeZoneNames_it.java	Tue Mar 18 12:35:25 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -483,7 +483,7 @@
             {"Asia/Aden", ARAST},
             {"Asia/Almaty", new String[] {"Ora di Alma-Ata", "ALMT",
                                           "Ora estiva di Alma-Ata", "ALMST"}},
-            {"Asia/Amman", ARAST},
+            {"Asia/Amman", EET},
             {"Asia/Anadyr", new String[] {"Ora di Anadyr", "ANAT",
                                           "Ora estiva di Anadyr", "ANAST"}},
             {"Asia/Aqtau", new String[] {"Ora di Aqtau", "AQTT",
--- ./jdk/src/share/classes/sun/util/resources/TimeZoneNames_ja.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/sun/util/resources/TimeZoneNames_ja.java	Tue Mar 18 12:35:25 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -483,7 +483,7 @@
             {"Asia/Aden", ARAST},
             {"Asia/Almaty", new String[] {"\u30a2\u30eb\u30de\u30a2\u30bf\u6642\u9593", "ALMT",
                                           "\u30a2\u30eb\u30de\u30a2\u30bf\u590f\u6642\u9593", "ALMST"}},
-            {"Asia/Amman", ARAST},
+            {"Asia/Amman", EET},
             {"Asia/Anadyr", new String[] {"\u30a2\u30ca\u30c9\u30a5\u30a4\u30ea\u6642\u9593", "ANAT",
                                           "\u30a2\u30ca\u30c9\u30a5\u30a4\u30ea\u590f\u6642\u9593", "ANAST"}},
             {"Asia/Aqtau", new String[] {"\u30a2\u30af\u30bf\u30a6\u6642\u9593", "AQTT",
--- ./jdk/src/share/classes/sun/util/resources/TimeZoneNames_ko.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/sun/util/resources/TimeZoneNames_ko.java	Tue Mar 18 12:35:25 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -483,7 +483,7 @@
             {"Asia/Aden", ARAST},
             {"Asia/Almaty", new String[] {"\uc54c\ub9c8\uc544\ud0c0 \uc2dc\uac04", "ALMT",
                                           "\uc54c\ub9c8\uc544\ud0c0 \uc77c\uad11\uc808\uc57d\uc2dc\uac04", "ALMST"}},
-            {"Asia/Amman", ARAST},
+            {"Asia/Amman", EET},
             {"Asia/Anadyr", new String[] {"\uc544\ub098\ub514\ub974 \uc2dc\uac04", "ANAT",
                                           "\uc544\ub098\ub514\ub974 \uc77c\uad11\uc808\uc57d\uc2dc\uac04", "ANAST"}},
             {"Asia/Aqtau", new String[] {"\uc545\ud0c0\uc6b0 \uc2dc\uac04", "AQTT",
--- ./jdk/src/share/classes/sun/util/resources/TimeZoneNames_pt_BR.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/sun/util/resources/TimeZoneNames_pt_BR.java	Tue Mar 18 12:35:25 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -483,7 +483,7 @@
             {"Asia/Aden", ARAST},
             {"Asia/Almaty", new String[] {"Fuso hor\u00e1rio de Alma-Ata", "ALMT",
                                           "Fuso hor\u00e1rio de ver\u00e3o de Alma-Ata", "ALMST"}},
-            {"Asia/Amman", ARAST},
+            {"Asia/Amman", EET},
             {"Asia/Anadyr", new String[] {"Fuso hor\u00e1rio de Anadyr", "ANAT",
                                           "Fuso hor\u00e1rio de ver\u00e3o de Anadyr", "ANAST"}},
             {"Asia/Aqtau", new String[] {"Fuso hor\u00e1rio de Aqtau", "AQTT",
--- ./jdk/src/share/classes/sun/util/resources/TimeZoneNames_sv.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/sun/util/resources/TimeZoneNames_sv.java	Tue Mar 18 12:35:25 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -483,7 +483,7 @@
             {"Asia/Aden", ARAST},
             {"Asia/Almaty", new String[] {"Alma-Ata, normaltid", "ALMT",
                                           "Alma-Ata, sommartid", "ALMST"}},
-            {"Asia/Amman", ARAST},
+            {"Asia/Amman", EET},
             {"Asia/Anadyr", new String[] {"Anadyr, normaltid", "ANAT",
                                           "Anadyr, sommartid", "ANAST"}},
             {"Asia/Aqtau", new String[] {"Aqtau, normaltid", "AQTT",
--- ./jdk/src/share/classes/sun/util/resources/TimeZoneNames_zh_CN.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/sun/util/resources/TimeZoneNames_zh_CN.java	Tue Mar 18 12:35:25 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -483,7 +483,7 @@
             {"Asia/Aden", ARAST},
             {"Asia/Almaty", new String[] {"Alma-Ata \u65f6\u95f4", "ALMT",
                                           "Alma-Ata \u590f\u4ee4\u65f6", "ALMST"}},
-            {"Asia/Amman", ARAST},
+            {"Asia/Amman", EET},
             {"Asia/Anadyr", new String[] {"\u963f\u90a3\u5e95\u6cb3\u65f6\u95f4", "ANAT",
                                           "\u963f\u90a3\u5e95\u6cb3\u590f\u4ee4\u65f6", "ANAST"}},
             {"Asia/Aqtau", new String[] {"Aqtau \u65f6\u95f4", "AQTT",
--- ./jdk/src/share/classes/sun/util/resources/TimeZoneNames_zh_TW.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/classes/sun/util/resources/TimeZoneNames_zh_TW.java	Tue Mar 18 12:35:25 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -483,7 +483,7 @@
             {"Asia/Aden", ARAST},
             {"Asia/Almaty", new String[] {"Alma-Ata \u6642\u9593", "ALMT",
                                           "Alma-Ata \u590f\u4ee4\u6642\u9593", "ALMST"}},
-            {"Asia/Amman", ARAST},
+            {"Asia/Amman", EET},
             {"Asia/Anadyr", new String[] {"\u963f\u90a3\u5e95\u6cb3\u6642\u9593", "ANAT",
                                           "\u963f\u90a3\u5e95\u6cb3\u590f\u4ee4\u6642\u9593", "ANAST"}},
             {"Asia/Aqtau", new String[] {"Aqtau \u6642\u9593", "AQTT",
--- ./jdk/src/share/native/com/sun/java/util/jar/pack/unpack.cpp	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/native/com/sun/java/util/jar/pack/unpack.cpp	Tue Mar 18 12:35:25 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -4780,39 +4780,7 @@
   } else if (log_file[0] != '\0' && (errstrm = fopen(log_file,"a+")) != NULL) {
     return;
   } else {
-    char log_file_name[PATH_MAX+100];
-    char tmpdir[PATH_MAX];
-#ifdef WIN32
-    int n = GetTempPath(PATH_MAX,tmpdir); //API returns with trailing '\'
-    if (n < 1 || n > PATH_MAX) {
-      sprintf(tmpdir,"C:\\");
-    }
-    sprintf(log_file_name, "%sunpack.log", tmpdir);
-#else
-    sprintf(tmpdir,"/tmp");
-    sprintf(log_file_name, "/tmp/unpack.log");
-#endif
-    if ((errstrm = fopen(log_file_name, "a+")) != NULL) {
-      log_file = errstrm_name = saveStr(log_file_name);
-      return ;
-    }
-
-    char *tname = tempnam(tmpdir,"#upkg");
-    if (tname == NULL) return;
-    sprintf(log_file_name, "%s", tname);
-    ::free(tname);
-    if ((errstrm = fopen(log_file_name, "a+")) != NULL) {
-      log_file = errstrm_name = saveStr(log_file_name);
-      return ;
-    }
-#ifndef WIN32
-    sprintf(log_file_name, "/dev/null");
-    // On windows most likely it will fail.
-    if ( (errstrm = fopen(log_file_name, "a+")) != NULL) {
-      log_file = errstrm_name = saveStr(log_file_name);
-      return ;
-    }
-#endif
+    fprintf(stderr, "Can not open log file %s\n", log_file);
     // Last resort
     // (Do not use stdout, since it might be jarout->jarfp.)
     errstrm = stderr;
--- ./jdk/src/share/native/sun/awt/giflib/dgif_lib.c	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/native/sun/awt/giflib/dgif_lib.c	Tue Mar 18 12:35:25 2014 -0700
@@ -435,9 +435,7 @@
     Private->PixelCount = (long)GifFile->Image.Width *
        (long)GifFile->Image.Height;
 
-    DGifSetupDecompress(GifFile);  /* Reset decompress algorithm parameters. */
-
-    return GIF_OK;
+    return DGifSetupDecompress(GifFile);  /* Reset decompress algorithm parameters. */
 }
 
 /******************************************************************************
--- ./jdk/src/share/native/sun/awt/image/gif/gifdecoder.c	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/native/sun/awt/image/gif/gifdecoder.c	Tue Mar 18 12:35:25 2014 -0700
@@ -249,6 +249,7 @@
                 /* fill the block */
                 len = (*env)->CallIntMethod(env, this, readID,
                                             blockh, remain, blockLength + 1);
+                if (len > blockLength + 1) len = blockLength + 1;
                 if ((*env)->ExceptionOccurred(env)) {
                     return 0;
                 }
--- ./jdk/src/share/native/sun/awt/image/jpeg/imageioJPEG.c	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/native/sun/awt/image/jpeg/imageioJPEG.c	Tue Mar 18 12:35:25 2014 -0700
@@ -939,6 +939,9 @@
                                 JPEGImageReader_readInputDataID,
                                 sb->hstreamBuffer, 0,
                                 sb->bufferLength);
+    if ((ret > 0) && ((unsigned int)ret > sb->bufferLength)) {
+         ret = sb->bufferLength;
+    }
     if ((*env)->ExceptionOccurred(env)
         || !GET_ARRAYS(env, data, &(src->next_input_byte))) {
             cinfo->err->error_exit((j_common_ptr) cinfo);
@@ -1035,6 +1038,7 @@
                                 JPEGImageReader_readInputDataID,
                                 sb->hstreamBuffer,
                                 offset, buflen);
+    if ((ret > 0) && ((unsigned int)ret > buflen)) ret = buflen;
     if ((*env)->ExceptionOccurred(env)
         || !GET_ARRAYS(env, data, &(src->next_input_byte))) {
         cinfo->err->error_exit((j_common_ptr) cinfo);
--- ./jdk/src/share/native/sun/awt/image/jpeg/jdmarker.c	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/native/sun/awt/image/jpeg/jdmarker.c	Tue Mar 18 12:35:25 2014 -0700
@@ -349,6 +349,12 @@
 
     TRACEMS3(cinfo, 1, JTRC_SOS_COMPONENT, cc,
              compptr->dc_tbl_no, compptr->ac_tbl_no);
+
+    /* This CSi (cc) should differ from the previous CSi */
+    for (ci = 0; ci < i; ci++) {
+      if (cinfo->cur_comp_info[ci] == compptr)
+        ERREXIT1(cinfo, JERR_BAD_COMPONENT_ID, cc);
+    }
   }
 
   /* Collect the additional scan parameters Ss, Se, Ah/Al. */
--- ./jdk/src/share/native/sun/awt/image/jpeg/jpegdecoder.c	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/native/sun/awt/image/jpeg/jpegdecoder.c	Tue Mar 18 12:35:25 2014 -0700
@@ -289,6 +289,7 @@
     buflen = (*env)->GetArrayLength(env, src->hInputBuffer);
     ret = (*env)->CallIntMethod(env, src->hInputStream, InputStream_readID,
                                 src->hInputBuffer, 0, buflen);
+    if (ret > buflen) ret = buflen;
     if ((*env)->ExceptionOccurred(env) || !GET_ARRAYS(env, src)) {
         cinfo->err->error_exit((struct jpeg_common_struct *) cinfo);
     }
@@ -349,6 +350,7 @@
     }
     ret = (*env)->CallIntMethod(env, src->hInputStream, InputStream_readID,
                                 src->hInputBuffer, offset, buflen);
+    if ((ret > 0) && ((unsigned int)ret > buflen)) ret = buflen;
     if ((*env)->ExceptionOccurred(env) || !GET_ARRAYS(env, src)) {
         cinfo->err->error_exit((struct jpeg_common_struct *) cinfo);
     }
@@ -424,6 +426,7 @@
         ret = (*env)->CallIntMethod(env, src->hInputStream,
                                     InputStream_readID,
                                     src->hInputBuffer, 0, buflen);
+        if (ret > buflen) ret = buflen;
         if ((*env)->ExceptionOccurred(env)) {
             cinfo->err->error_exit((struct jpeg_common_struct *) cinfo);
         }
--- ./jdk/src/share/native/sun/awt/libpng/pngrtran.c	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/native/sun/awt/libpng/pngrtran.c	Tue Mar 18 12:35:25 2014 -0700
@@ -1862,6 +1862,9 @@
 
          info_ptr->bit_depth = 8;
          info_ptr->num_trans = 0;
+
+         if (png_ptr->palette == NULL)
+            png_error (png_ptr, "Palette is NULL in indexed image");
       }
       else
       {
--- ./jdk/src/share/native/sun/awt/libpng/pngset.c	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/native/sun/awt/libpng/pngset.c	Tue Mar 18 12:35:25 2014 -0700
@@ -512,6 +512,17 @@
       }
    }
 
+   if ((num_palette > 0 && palette == NULL) ||
+      (num_palette == 0
+#        ifdef PNG_MNG_FEATURES_SUPPORTED
+            && (png_ptr->mng_features_permitted & PNG_FLAG_MNG_EMPTY_PLTE) == 0
+#        endif
+      ))
+   {
+      png_error(png_ptr, "Invalid palette");
+      return;
+   }
+
    /* It may not actually be necessary to set png_ptr->palette here;
     * we do it for backward compatibility with the way the png_handle_tRNS
     * function used to do the allocation.
--- ./jdk/src/share/native/sun/awt/medialib/awt_ImagingLib.c	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/native/sun/awt/medialib/awt_ImagingLib.c	Tue Mar 18 12:35:25 2014 -0700
@@ -228,6 +228,49 @@
     }
 }
 
+/*
+ * We have to make sure that awt_setPixels can be safely applied to the given pair of
+ * raster and mlib image.
+ *
+ * In particular, make sure that
+ *  - dimension is the same
+ *  - number of channels in mlib image corresponds to the number of bands in the raster
+ *  - sample size in image and raster are the same.
+ *
+ * Returns:
+ *  -1 to indicate failure,
+ *   1 to indicate success
+ */
+static int setPixelsFormMlibImage(JNIEnv *env, RasterS_t *rasterP, mlib_image* img) {
+    if (rasterP->width != img->width || rasterP->height != img->height) {
+        /* dimension does not match */
+        return -1;
+    }
+
+    if (rasterP->numBands != img->channels) {
+        /* number of bands does not match */
+        return -1;
+    }
+
+    switch (rasterP->dataType) {
+    case BYTE_DATA_TYPE:
+        if (img->type != MLIB_BYTE) {
+            return -1;
+        }
+        break;
+    case SHORT_DATA_TYPE:
+        if (img->type != MLIB_SHORT && img->type != MLIB_USHORT) {
+            return -1;
+        }
+        break;
+    default:
+        /* awt_setPixels does not support such rasters */
+        return -1;
+    }
+
+    return awt_setPixels(env, rasterP, mlib_ImageGetData(img));
+}
+
 /***************************************************************************
  *                          External Functions                             *
  ***************************************************************************/
@@ -700,7 +743,9 @@
 
     /* Means that we couldn't write directly into the destination buffer */
     if (ddata == NULL) {
-        retStatus = awt_setPixels(env, dstRasterP, mlib_ImageGetData(dst));
+        if (storeRasterArray(env, srcRasterP, dstRasterP, dst) < 0) {
+            retStatus = setPixelsFormMlibImage(env, dstRasterP, dst);
+        }
     }
 
     /* Release the pinned memory */
@@ -1106,7 +1151,7 @@
     if (ddata == NULL) {
         /* Need to store it back into the array */
         if (storeRasterArray(env, srcRasterP, dstRasterP, dst) < 0) {
-            retStatus = awt_setPixels(env, dstRasterP, mlib_ImageGetData(dst));
+            retStatus = setPixelsFormMlibImage(env, dstRasterP, dst);
         }
     }
 
@@ -1432,6 +1477,14 @@
         retStatus = 0;
     }
 
+   /* Release the LUT */
+    for (i=0; i < lut_nbands; i++) {
+        (*env)->ReleasePrimitiveArrayCritical(env, jtable[i].jArray,
+            (jbyte *) jtable[i].table, JNI_ABORT);
+    }
+    free ((void *) jtable);
+    free ((void *) tbl);
+
     /*
      * Means that we couldn't write directly into
      * the destination buffer
@@ -1445,13 +1498,6 @@
         }
     }
 
-    /* Release the LUT */
-    for (i=0; i < lut_nbands; i++) {
-        (*env)->ReleasePrimitiveArrayCritical(env, jtable[i].jArray,
-            (jbyte *) jtable[i].table, JNI_ABORT);
-    }
-    free ((void *) jtable);
-    free ((void *) tbl);
 
     /* Release the pinned memory */
     freeArray(env, srcImageP, src, sdata, dstImageP, dst, ddata);
@@ -1669,18 +1715,20 @@
         retStatus = 0;
     }
 
+    /* Release the LUT */
+    for (i=0; i < lut_nbands; i++) {
+        (*env)->ReleasePrimitiveArrayCritical(env, jtable[i].jArray,
+                                              (jbyte *) jtable[i].table, JNI_ABORT);
+    }
+
     /*
      * Means that we couldn't write directly into
      * the destination buffer
      */
     if (ddata == NULL) {
-        retStatus = awt_setPixels(env, dstRasterP, mlib_ImageGetData(dst));
-    }
-
-    /* Release the LUT */
-    for (i=0; i < lut_nbands; i++) {
-        (*env)->ReleasePrimitiveArrayCritical(env, jtable[i].jArray,
-                                              (jbyte *) jtable[i].table, JNI_ABORT);
+        if (storeRasterArray(env, srcRasterP, dstRasterP, dst) < 0) {
+            retStatus = setPixelsFormMlibImage(env, dstRasterP, dst);
+        }
     }
 
     /* Release the pinned memory */
@@ -2640,7 +2688,7 @@
             }
         }
         else if (mlibImP->type == MLIB_SHORT) {
-            return awt_setPixels(env, rasterP, mlibImP->data);
+            return setPixelsFormMlibImage(env, rasterP, mlibImP);
         }
     }
     else {
--- ./jdk/src/share/native/sun/font/layout/ContextualGlyphSubstProc2.cpp	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/native/sun/font/layout/ContextualGlyphSubstProc2.cpp	Tue Mar 18 12:35:25 2014 -0700
@@ -154,6 +154,7 @@
             TTGlyphID glyphCode = (TTGlyphID) LE_GET_GLYPH(gid);
             if ((glyphCode >= firstGlyph) && (glyphCode < lastGlyph)) {
               LEReferenceToArrayOf<LookupValue> valueArray(lookupTable8, success, &lookupTable8->valueArray[0], glyphCount);
+              if (LE_FAILURE(success)) { return newGlyph; }
               newGlyph = SWAPW(valueArray(glyphCode - firstGlyph, success));
             }
         }
--- ./jdk/src/share/native/sun/font/layout/ContextualSubstSubtables.cpp	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/native/sun/font/layout/ContextualSubstSubtables.cpp	Tue Mar 18 12:35:25 2014 -0700
@@ -110,6 +110,8 @@
     LEErrorCode &success,
                                                le_bool backtrack)
 {
+    if (LE_FAILURE(success)) { return FALSE; }
+
     le_int32 direction = 1;
     le_int32 match = 0;
 
@@ -255,6 +257,7 @@
                 le_uint16 matchCount = SWAPW(subRuleTable->glyphCount) - 1;
                 le_uint16 substCount = SWAPW(subRuleTable->substCount);
                 LEReferenceToArrayOf<TTGlyphID> inputGlyphArray(base, success, subRuleTable->inputGlyphArray, matchCount+2);
+                if (LE_FAILURE(success)) { return 0; }
                 if (matchGlyphIDs(inputGlyphArray, matchCount, glyphIterator)) {
                   LEReferenceToArrayOf<SubstitutionLookupRecord>
                     substLookupRecordArray(base, success, (const SubstitutionLookupRecord *) &subRuleTable->inputGlyphArray[matchCount], substCount);
@@ -315,6 +318,7 @@
 
                 LEReferenceToArrayOf<le_uint16> classArray(base, success, subClassRuleTable->classArray, matchCount+1);
 
+                if (LE_FAILURE(success)) { return 0; }
                 if (matchGlyphClasses(classArray, matchCount, glyphIterator, classDefinitionTable, success)) {
                     LEReferenceToArrayOf<SubstitutionLookupRecord>
                       substLookupRecordArray(base, success, (const SubstitutionLookupRecord *) &subClassRuleTable->classArray[matchCount], substCount);
@@ -573,7 +577,7 @@
                 if (matchGlyphClasses(inputClassArray, inputGlyphCount, glyphIterator, inputClassDefinitionTable, success)) {
                     LEReferenceToArrayOf<SubstitutionLookupRecord>
                       substLookupRecordArray(base, success, (const SubstitutionLookupRecord *) lookaheadClassArray.getAlias(lookaheadGlyphCount + 1, success), substCount);
-
+                    if (LE_FAILURE(success)) { return 0; }
                     applySubstitutionLookups(lookupProcessor, substLookupRecordArray, substCount, glyphIterator, fontInstance, position, success);
 
                     return inputGlyphCount + 1;
@@ -601,6 +605,7 @@
     le_uint16 backtrkGlyphCount = SWAPW(backtrackGlyphCount);
     le_uint16 inputGlyphCount = (le_uint16) SWAPW(backtrackCoverageTableOffsetArray[backtrkGlyphCount]);
     LEReferenceToArrayOf<Offset>   inputCoverageTableOffsetArray(base, success, &backtrackCoverageTableOffsetArray[backtrkGlyphCount + 1], inputGlyphCount+2); // offset
+    if (LE_FAILURE(success)) { return 0; }
     const le_uint16 lookaheadGlyphCount = (le_uint16) SWAPW(inputCoverageTableOffsetArray[inputGlyphCount]);
 
     if( LE_FAILURE(success) ) { return 0; }
--- ./jdk/src/share/native/sun/font/layout/LigatureSubstProc2.cpp	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/native/sun/font/layout/LigatureSubstProc2.cpp	Tue Mar 18 12:35:25 2014 -0700
@@ -95,7 +95,7 @@
 
     if (actionOffset != 0) {
         LEReferenceTo<LigatureActionEntry> ap(stHeader, success, ligActionOffset); // byte offset
-        ap.addObject(ligActionIndex - 1, success);  // index offset ( one before the actual start, because we will pre-increment)
+        ap.addObject(ligActionIndex, success);
         LEReferenceToArrayOf<TTGlyphID> ligatureTable(stHeader, success, ligatureOffset, LE_UNBOUNDED_ARRAY);
         LigatureActionEntry action;
         le_int32 offset, i = 0;
@@ -111,7 +111,6 @@
         do {
             le_uint32 componentGlyph = componentStack[m--]; // pop off
 
-            ap.addObject(success);
             action = SWAPL(*ap.getAlias());
 
             if (m < 0) {
@@ -145,7 +144,8 @@
               LE_DEBUG_BAD_FONT("m<0")
             }
 #endif
-        } while (!(action & lafLast) && (m>=0) ); // stop if last bit is set, or if run out of items
+            ap.addObject(success);
+        } while (LE_SUCCESS(success) && !(action & lafLast) && (m>=0) ); // stop if last bit is set, or if run out of items
 
         while (mm >= 0) {
             if (++m >= nComponents) {
--- ./jdk/src/share/native/sun/font/layout/LookupProcessor.cpp	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/native/sun/font/layout/LookupProcessor.cpp	Tue Mar 18 12:35:25 2014 -0700
@@ -282,6 +282,7 @@
 
             for (le_uint16 feature = 0; feature < featureCount; feature += 1) {
               LEReferenceToArrayOf<le_uint16> featureIndexArray(langSysTable, success, langSysTable->featureIndexArray, featureCount);
+              if (LE_FAILURE(success)) { continue; }
               le_uint16 featureIndex = SWAPW(featureIndexArray.getObject(feature,success));
 
                 // don't add the required feature to the list more than once...
--- ./jdk/src/share/native/sun/font/layout/MarkToBasePosnSubtables.cpp	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/native/sun/font/layout/MarkToBasePosnSubtables.cpp	Tue Mar 18 12:35:25 2014 -0700
@@ -67,6 +67,7 @@
 
     LEPoint markAnchor;
     LEReferenceTo<MarkArray> markArray(base, success,  (const MarkArray *) ((char *) this + SWAPW(markArrayOffset)));
+    if(LE_FAILURE(success)) return 0;
     le_int32 markClass = markArray->getMarkClass(markArray, markGlyph, markCoverage, fontInstance, markAnchor, success);
     le_uint16 mcCount = SWAPW(classCount);
 
--- ./jdk/src/share/native/sun/font/layout/OpenTypeUtilities.cpp	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/native/sun/font/layout/OpenTypeUtilities.cpp	Tue Mar 18 12:35:25 2014 -0700
@@ -79,8 +79,8 @@
 
 Offset OpenTypeUtilities::getTagOffset(LETag tag, const LEReferenceToArrayOf<TagAndOffsetRecord> &records, LEErrorCode &success)
 {
+  if(LE_FAILURE(success)) return 0;
   const TagAndOffsetRecord *r0 = (const TagAndOffsetRecord*)records.getAlias();
-  if(LE_FAILURE(success)) return 0;
 
   le_uint32 recordCount = records.getCount();
   le_uint8 bit = highBit(recordCount);
--- ./jdk/src/share/native/sun/font/layout/SegmentArrayProcessor.cpp	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/native/sun/font/layout/SegmentArrayProcessor.cpp	Tue Mar 18 12:35:25 2014 -0700
@@ -73,6 +73,7 @@
 
             if (offset != 0) {
               LEReferenceToArrayOf<TTGlyphID> glyphArray(subtableHeader, success, offset, LE_UNBOUNDED_ARRAY);
+              if (LE_FAILURE(success)) { continue; }
               TTGlyphID   newGlyph   = SWAPW(glyphArray(LE_GET_GLYPH(thisGlyph) - firstGlyph, success));
               glyphStorage[glyph] = LE_SET_GLYPH(thisGlyph, newGlyph);
             }
--- ./jdk/src/share/native/sun/font/layout/StateTableProcessor.cpp	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/native/sun/font/layout/StateTableProcessor.cpp	Tue Mar 18 12:35:25 2014 -0700
@@ -97,6 +97,7 @@
 
         LEReferenceToArrayOf<EntryTableIndex> stateArray(stHeader, success, currentState, LE_UNBOUNDED_ARRAY);
         EntryTableIndex entryTableIndex = stateArray.getObject((le_uint8)classCode, success);
+        if (LE_FAILURE(success)) { break; }
         LE_STATE_PATIENCE_CURR(le_int32, currGlyph);
         currentState = processStateEntry(glyphStorage, currGlyph, entryTableIndex);
         LE_STATE_PATIENCE_INCR(currGlyph);
--- ./jdk/src/share/native/sun/java2d/cmm/lcms/cmscam02.c	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/native/sun/java2d/cmm/lcms/cmscam02.c	Tue Mar 18 12:35:25 2014 -0700
@@ -81,7 +81,7 @@
     cmsUInt32Number surround;
     cmsFloat64Number n, Nbb, Ncb, z, FL, D;
 
-       cmsContext ContextID;
+    cmsContext ContextID;
 
 } cmsCIECAM02;
 
@@ -467,6 +467,7 @@
     CAM02COLOR clr;
     cmsCIECAM02* lpMod = (cmsCIECAM02*) hModel;
 
+    memset(&clr, 0, sizeof(clr));
     _cmsAssert(lpMod != NULL);
     _cmsAssert(pIn != NULL);
     _cmsAssert(pOut != NULL);
@@ -491,6 +492,7 @@
     CAM02COLOR clr;
     cmsCIECAM02* lpMod = (cmsCIECAM02*) hModel;
 
+    memset(&clr, 0, sizeof(clr));
     _cmsAssert(lpMod != NULL);
     _cmsAssert(pIn != NULL);
     _cmsAssert(pOut != NULL);
--- ./jdk/src/share/native/sun/java2d/cmm/lcms/cmscgats.c	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/native/sun/java2d/cmm/lcms/cmscgats.c	Tue Mar 18 12:35:25 2014 -0700
@@ -59,8 +59,8 @@
 // IT8.7 / CGATS.17-200x handling -----------------------------------------------------------------------------
 
 
-#define MAXID        128     // Max lenght of identifier
-#define MAXSTR      1024     // Max lenght of string
+#define MAXID        128     // Max length of identifier
+#define MAXSTR      1024     // Max length of string
 #define MAXTABLES    255     // Max Number of tables in a single stream
 #define MAXINCLUDE    20     // Max number of nested includes
 
@@ -383,28 +383,28 @@
 //Forward declaration of some internal functions
 static void* AllocChunk(cmsIT8* it8, cmsUInt32Number size);
 
-// Checks if c is a separator
+// Checks whatever c is a separator
 static
 cmsBool isseparator(int c)
 {
-        return (c == ' ') || (c == '\t') || (c == '\r');
+    return (c == ' ') || (c == '\t') ;
 }
 
-// Checks whatever if c is a valid identifier char
+// Checks whatever c is a valid identifier char
 static
 cmsBool ismiddle(int c)
 {
    return (!isseparator(c) && (c != '#') && (c !='\"') && (c != '\'') && (c > 32) && (c < 127));
 }
 
-// Checks whatsever if c is a valid identifier middle char.
+// Checks whatsever c is a valid identifier middle char.
 static
 cmsBool isidchar(int c)
 {
    return isalnum(c) || ismiddle(c);
 }
 
-// Checks whatsever if c is a valid identifier first char.
+// Checks whatsever c is a valid identifier first char.
 static
 cmsBool isfirstidchar(int c)
 {
@@ -436,7 +436,6 @@
 }
 
 
-
 // Makes a file path based on a given reference path
 // NOTE: this function doesn't check if the path exists or even if it's legal
 static
@@ -634,6 +633,9 @@
     cmsFloat64Number dnum = 0.0;
     int sign = 1;
 
+    // keep safe
+    if (Buffer == NULL) return 0.0;
+
     if (*Buffer == '-' || *Buffer == '+') {
 
          sign = (*Buffer == '-') ? -1 : 1;
@@ -867,6 +869,14 @@
 
 
         // Next line
+        case '\r':
+            NextCh(it8);
+            if (it8 ->ch == '\n')
+                NextCh(it8);
+            it8->sy = SEOLN;
+            it8->lineno++;
+            break;
+
         case '\n':
             NextCh(it8);
             it8->sy = SEOLN;
@@ -876,7 +886,7 @@
         // Comment
         case '#':
             NextCh(it8);
-            while (it8->ch && it8->ch != '\n')
+            while (it8->ch && it8->ch != '\n' && it8->ch != '\r')
                 NextCh(it8);
 
             it8->sy = SCOMMENT;
@@ -994,6 +1004,9 @@
 {
     switch (it8->sy) {
 
+    case SEOLN:   // Empty value
+                  Buffer[0]=0;
+                  break;
     case SIDENT:  strncpy(Buffer, it8->id, max);
                   Buffer[max-1]=0;
                   break;
@@ -1143,9 +1156,9 @@
         if (*Key != '#') { // Comments are ignored
 
             if (cmsstrcasecmp(Key, p->Keyword) == 0)
-                    break;
+                break;
         }
-        }
+    }
 
     if (p == NULL)
         return FALSE;
@@ -1155,11 +1168,13 @@
 
     for (; p != NULL; p = p->NextSubkey) {
 
+        if (p ->Subkey == NULL) continue;
+
         if (LastPtr) *LastPtr = p;
 
         if (cmsstrcasecmp(Subkey, p->Subkey) == 0)
-                    return TRUE;
-        }
+            return TRUE;
+    }
 
     return FALSE;
 }
@@ -1282,7 +1297,7 @@
 
      it8 ->nTable = nTable;
 
-     return nTable;
+     return (cmsInt32Number) nTable;
 }
 
 
@@ -1387,7 +1402,7 @@
     cmsIT8* it8 = (cmsIT8*) hIT8;
     char Buffer[1024];
 
-    sprintf(Buffer, "%d", Val);
+    sprintf(Buffer, "%u", Val);
 
     return AddToList(it8, &GetTable(it8)->HeaderList, cProp, NULL, Buffer, WRITE_HEXADECIMAL) != NULL;
 }
@@ -1424,6 +1439,8 @@
 {
     const char *v = cmsIT8GetProperty(hIT8, cProp);
 
+    if (v == NULL) return 0.0;
+
     return ParseFloatNumber(v);
 }
 
@@ -1456,7 +1473,7 @@
         t -> nSamples = 10;
         }
 
-    t -> DataFormat = (char**) AllocChunk (it8, (t->nSamples + 1) * sizeof(char *));
+    t -> DataFormat = (char**) AllocChunk (it8, ((cmsUInt32Number) t->nSamples + 1) * sizeof(char *));
     if (t->DataFormat == NULL) {
 
         SynError(it8, "AllocateDataFormat: Unable to allocate dataFormat array");
@@ -1512,7 +1529,7 @@
     t-> nSamples   = atoi(cmsIT8GetProperty(it8, "NUMBER_OF_FIELDS"));
     t-> nPatches   = atoi(cmsIT8GetProperty(it8, "NUMBER_OF_SETS"));
 
-    t-> Data = (char**)AllocChunk (it8, (t->nSamples + 1) * (t->nPatches + 1) *sizeof (char*));
+    t-> Data = (char**)AllocChunk (it8, ((cmsUInt32Number) t->nSamples + 1) * ((cmsUInt32Number) t->nPatches + 1) *sizeof (char*));
     if (t->Data == NULL) {
 
         SynError(it8, "AllocateDataSet: Unable to allocate data array");
@@ -1571,7 +1588,7 @@
     if (str == NULL)
         str = " ";
 
-    // Lenghth to write
+    // Length to write
     len = (cmsUInt32Number) strlen(str);
     f ->Used += len;
 
@@ -2095,7 +2112,7 @@
                                          NextCh(it8);
 
                                      // If a newline is found, then this is a type string
-                                    if (it8 ->ch == '\n') {
+                                    if (it8 ->ch == '\n' || it8->ch == '\r') {
 
                                          cmsIT8SetSheetType(it8, it8 ->id);
                                          InSymbol(it8);
@@ -2210,7 +2227,7 @@
                                         char Buffer[256];
 
                                         char *Type  = p ->Value;
-                                        int  nTable = k;
+                                        int  nTable = (int) k;
 
                                         snprintf(Buffer, 255, "%s %d %s", Label, nTable, Type );
 
@@ -2564,6 +2581,8 @@
 
     Buffer = cmsIT8GetDataRowCol(hIT8, row, col);
 
+    if (Buffer == NULL) return 0.0;
+
     return ParseFloatNumber(Buffer);
 }
 
@@ -2776,7 +2795,7 @@
     if (Formatter == NULL)
         strcpy(it8->DoubleFormatter, DEFAULT_DBL_FORMAT);
     else
-        strcpy(it8->DoubleFormatter, Formatter);
+        strncpy(it8->DoubleFormatter, Formatter, sizeof(it8->DoubleFormatter));
 
     it8 ->DoubleFormatter[sizeof(it8 ->DoubleFormatter)-1] = 0;
 }
--- ./jdk/src/share/native/sun/java2d/cmm/lcms/cmscnvrt.c	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/native/sun/java2d/cmm/lcms/cmscnvrt.c	Tue Mar 18 12:35:25 2014 -0700
@@ -270,7 +270,7 @@
             // m2 holds CHAD from output white to D50 times abs. col. scaling
 
             // Observer is not adapted, undo the chromatic adaptation
-            _cmsMAT3per(m, &m3, ChromaticAdaptationMatrixOut);
+            _cmsMAT3per(m, &m2, ChromaticAdaptationMatrixOut);
 
             m3 = *ChromaticAdaptationMatrixIn;
             if (!_cmsMAT3inverse(&m3, &m4)) return FALSE;
@@ -411,57 +411,61 @@
     // Handle PCS mismatches. A specialized stage is added to the LUT in such case
     switch (InPCS) {
 
-        case cmsSigXYZData: // Input profile operates in XYZ
+    case cmsSigXYZData: // Input profile operates in XYZ
 
-            switch (OutPCS) {
+        switch (OutPCS) {
 
-            case cmsSigXYZData:  // XYZ -> XYZ
-                if (!IsEmptyLayer(m, off))
-                    cmsPipelineInsertStage(Result, cmsAT_END, cmsStageAllocMatrix(Result ->ContextID, 3, 3, m_as_dbl, off_as_dbl));
-                break;
+        case cmsSigXYZData:  // XYZ -> XYZ
+            if (!IsEmptyLayer(m, off) &&
+                !cmsPipelineInsertStage(Result, cmsAT_END, cmsStageAllocMatrix(Result ->ContextID, 3, 3, m_as_dbl, off_as_dbl)))
+                return FALSE;
+            break;
 
-            case cmsSigLabData:  // XYZ -> Lab
-                if (!IsEmptyLayer(m, off))
-                    cmsPipelineInsertStage(Result, cmsAT_END, cmsStageAllocMatrix(Result ->ContextID, 3, 3, m_as_dbl, off_as_dbl));
-                cmsPipelineInsertStage(Result, cmsAT_END, _cmsStageAllocXYZ2Lab(Result ->ContextID));
-                break;
+        case cmsSigLabData:  // XYZ -> Lab
+            if (!IsEmptyLayer(m, off) &&
+                !cmsPipelineInsertStage(Result, cmsAT_END, cmsStageAllocMatrix(Result ->ContextID, 3, 3, m_as_dbl, off_as_dbl)))
+                return FALSE;
+            if (!cmsPipelineInsertStage(Result, cmsAT_END, _cmsStageAllocXYZ2Lab(Result ->ContextID)))
+                return FALSE;
+            break;
 
-            default:
-                return FALSE;   // Colorspace mismatch
-                }
-                break;
+        default:
+            return FALSE;   // Colorspace mismatch
+        }
+        break;
 
+    case cmsSigLabData: // Input profile operates in Lab
 
-        case cmsSigLabData: // Input profile operates in Lab
+        switch (OutPCS) {
 
-            switch (OutPCS) {
+        case cmsSigXYZData:  // Lab -> XYZ
 
-            case cmsSigXYZData:  // Lab -> XYZ
+            if (!cmsPipelineInsertStage(Result, cmsAT_END, _cmsStageAllocLab2XYZ(Result ->ContextID)))
+                return FALSE;
+            if (!IsEmptyLayer(m, off) &&
+                !cmsPipelineInsertStage(Result, cmsAT_END, cmsStageAllocMatrix(Result ->ContextID, 3, 3, m_as_dbl, off_as_dbl)))
+                return FALSE;
+            break;
 
-                cmsPipelineInsertStage(Result, cmsAT_END, _cmsStageAllocLab2XYZ(Result ->ContextID));
-                if (!IsEmptyLayer(m, off))
-                    cmsPipelineInsertStage(Result, cmsAT_END, cmsStageAllocMatrix(Result ->ContextID, 3, 3, m_as_dbl, off_as_dbl));
-                break;
+        case cmsSigLabData:  // Lab -> Lab
 
-            case cmsSigLabData:  // Lab -> Lab
-
-                if (!IsEmptyLayer(m, off)) {
-                    cmsPipelineInsertStage(Result, cmsAT_END, _cmsStageAllocLab2XYZ(Result ->ContextID));
-                    cmsPipelineInsertStage(Result, cmsAT_END, cmsStageAllocMatrix(Result ->ContextID, 3, 3, m_as_dbl, off_as_dbl));
-                    cmsPipelineInsertStage(Result, cmsAT_END, _cmsStageAllocXYZ2Lab(Result ->ContextID));
-                }
-                break;
-
-            default:
-                return FALSE;  // Mismatch
+            if (!IsEmptyLayer(m, off)) {
+                if (!cmsPipelineInsertStage(Result, cmsAT_END, _cmsStageAllocLab2XYZ(Result ->ContextID)) ||
+                    !cmsPipelineInsertStage(Result, cmsAT_END, cmsStageAllocMatrix(Result ->ContextID, 3, 3, m_as_dbl, off_as_dbl)) ||
+                    !cmsPipelineInsertStage(Result, cmsAT_END, _cmsStageAllocXYZ2Lab(Result ->ContextID)))
+                    return FALSE;
             }
             break;
 
+        default:
+            return FALSE;  // Mismatch
+        }
+        break;
 
-            // On colorspaces other than PCS, check for same space
-        default:
-            if (InPCS != OutPCS) return FALSE;
-            break;
+        // On colorspaces other than PCS, check for same space
+    default:
+        if (InPCS != OutPCS) return FALSE;
+        break;
     }
 
     return TRUE;
@@ -497,7 +501,8 @@
                                cmsFloat64Number AdaptationStates[],
                                cmsUInt32Number  dwFlags)
 {
-    cmsPipeline* Lut, *Result;
+    cmsPipeline* Lut = NULL;
+    cmsPipeline* Result;
     cmsHPROFILE hProfile;
     cmsMAT3 m;
     cmsVEC3 off;
@@ -593,8 +598,11 @@
         }
 
         // Concatenate to the output LUT
-        cmsPipelineCat(Result, Lut);
+        if (!cmsPipelineCat(Result, Lut))
+            goto Error;
+
         cmsPipelineFree(Lut);
+        Lut = NULL;
 
         // Update current space
         CurrentColorSpace = ColorSpaceOut;
@@ -604,6 +612,7 @@
 
 Error:
 
+    if (Lut != NULL) cmsPipelineFree(Lut);
     if (Result != NULL) cmsPipelineFree(Result);
     return NULL;
 
@@ -742,7 +751,8 @@
     if (CLUT == NULL) goto Error;
 
     // This is the one and only MPE in this LUT
-    cmsPipelineInsertStage(Result, cmsAT_BEGIN, CLUT);
+    if (!cmsPipelineInsertStage(Result, cmsAT_BEGIN, CLUT))
+        goto Error;
 
     // Sample it. We cannot afford pre/post linearization this time.
     if (!cmsStageSampleCLut16bit(CLUT, BlackPreservingGrayOnlySampler, (void*) &bp, 0))
@@ -959,7 +969,8 @@
     CLUT = cmsStageAllocCLut16bit(ContextID, nGridPoints, 4, 4, NULL);
     if (CLUT == NULL) goto Cleanup;
 
-    cmsPipelineInsertStage(Result, cmsAT_BEGIN, CLUT);
+    if (!cmsPipelineInsertStage(Result, cmsAT_BEGIN, CLUT))
+        goto Cleanup;
 
     cmsStageSampleCLut16bit(CLUT, BlackPreservingSampler, (void*) &bp, 0);
 
@@ -1057,7 +1068,7 @@
 }
 
 // The plug-in registration. User can add new intents or override default routines
-cmsBool  _cmsRegisterRenderingIntentPlugin(cmsPluginBase* Data)
+cmsBool  _cmsRegisterRenderingIntentPlugin(cmsContext id, cmsPluginBase* Data)
 {
     cmsPluginRenderingIntent* Plugin = (cmsPluginRenderingIntent*) Data;
     cmsIntentsList* fl;
@@ -1072,7 +1083,7 @@
     fl = SearchIntent(Plugin ->Intent);
 
     if (fl == NULL) {
-        fl = (cmsIntentsList*) _cmsPluginMalloc(sizeof(cmsIntentsList));
+        fl = (cmsIntentsList*) _cmsPluginMalloc(id, sizeof(cmsIntentsList));
         if (fl == NULL) return FALSE;
     }
 
--- ./jdk/src/share/native/sun/java2d/cmm/lcms/cmserr.c	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/native/sun/java2d/cmm/lcms/cmserr.c	Tue Mar 18 12:35:25 2014 -0700
@@ -302,8 +302,6 @@
         return NULL;
     }
 
-
-
     chunk ->BlockSize = Initial;
     chunk ->Used      = 0;
     chunk ->next      = NULL;
--- ./jdk/src/share/native/sun/java2d/cmm/lcms/cmsgamma.c	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/native/sun/java2d/cmm/lcms/cmsgamma.c	Tue Mar 18 12:35:25 2014 -0700
@@ -30,7 +30,7 @@
 //---------------------------------------------------------------------------------
 //
 //  Little Color Management System
-//  Copyright (c) 1998-2012 Marti Maria Saguer
+//  Copyright (c) 1998-2013 Marti Maria Saguer
 //
 // Permission is hereby granted, free of charge, to any person obtaining
 // a copy of this software and associated documentation files (the "Software"),
@@ -99,7 +99,7 @@
 static _cmsParametricCurvesCollection* ParametricCurves = &DefaultCurves;
 
 // As a way to install new parametric curves
-cmsBool _cmsRegisterParametricCurvesPlugin(cmsPluginBase* Data)
+cmsBool _cmsRegisterParametricCurvesPlugin(cmsContext id, cmsPluginBase* Data)
 {
     cmsPluginParametricCurves* Plugin = (cmsPluginParametricCurves*) Data;
     _cmsParametricCurvesCollection* fl;
@@ -110,7 +110,7 @@
           return TRUE;
     }
 
-    fl = (_cmsParametricCurvesCollection*) _cmsPluginMalloc(sizeof(_cmsParametricCurvesCollection));
+    fl = (_cmsParametricCurvesCollection*) _cmsPluginMalloc(id, sizeof(_cmsParametricCurvesCollection));
     if (fl == NULL) return FALSE;
 
     // Copy the parameters
@@ -258,7 +258,8 @@
     }
 
     p ->InterpParams = _cmsComputeInterpParams(ContextID, p ->nEntries, 1, 1, p->Table16, CMS_LERP_FLAGS_16BITS);
-    return p;
+    if (p->InterpParams != NULL)
+        return p;
 
 Error:
     if (p -> Segments) _cmsFree(ContextID, p ->Segments);
@@ -423,7 +424,7 @@
             if (e > 0)
                 Val = pow(e, Params[0]) + Params[5];
             else
-                Val = 0;
+                Val = Params[5];
         }
         else
             Val = R*Params[3] + Params[6];
@@ -458,7 +459,7 @@
         e = Params[1]*R + Params[2];
 
         if (e < 0)
-            Val = 0;
+            Val = Params[3];
         else
             Val = pow(e, Params[0]) + Params[3];
         break;
@@ -478,7 +479,7 @@
 
        e = Params[2] * pow(R, Params[0]) + Params[3];
        if (e <= 0)
-           Val = 0;
+           Val = Params[4];
        else
            Val = Params[1]*log10(e) + Params[4];
        break;
@@ -544,7 +545,7 @@
             // Type == 0 means segment is sampled
             if (g ->Segments[i].Type == 0) {
 
-                cmsFloat32Number R1 = (cmsFloat32Number) (R - g ->Segments[i].x0);
+                cmsFloat32Number R1 = (cmsFloat32Number) (R - g ->Segments[i].x0) / (g ->Segments[i].x1 - g ->Segments[i].x0);
                 cmsFloat32Number Out;
 
                 // Setup the table (TODO: clean that)
@@ -629,20 +630,21 @@
 // Use a segmented curve to store the floating point table
 cmsToneCurve* CMSEXPORT cmsBuildTabulatedToneCurveFloat(cmsContext ContextID, cmsUInt32Number nEntries, const cmsFloat32Number values[])
 {
-    cmsCurveSegment Seg[2];
+    cmsCurveSegment Seg[3];
 
-    // Initialize segmented curve part up to 0
-    Seg[0].x0 = -1;
+    // A segmented tone curve should have function segments in the first and last positions
+    // Initialize segmented curve part up to 0 to constant value = samples[0]
+    Seg[0].x0 = MINUS_INF;
     Seg[0].x1 = 0;
     Seg[0].Type = 6;
 
     Seg[0].Params[0] = 1;
     Seg[0].Params[1] = 0;
     Seg[0].Params[2] = 0;
-    Seg[0].Params[3] = 0;
+    Seg[0].Params[3] = values[0];
     Seg[0].Params[4] = 0;
 
-    // From zero to any
+    // From zero to 1
     Seg[1].x0 = 0;
     Seg[1].x1 = 1.0;
     Seg[1].Type = 0;
@@ -650,7 +652,19 @@
     Seg[1].nGridPoints = nEntries;
     Seg[1].SampledPoints = (cmsFloat32Number*) values;
 
-    return cmsBuildSegmentedToneCurve(ContextID, 2, Seg);
+    // Final segment is constant = lastsample
+    Seg[2].x0 = 1.0;
+    Seg[2].x1 = PLUS_INF;
+    Seg[2].Type = 6;
+
+    Seg[2].Params[0] = 1;
+    Seg[2].Params[1] = 0;
+    Seg[2].Params[2] = 0;
+    Seg[2].Params[3] = values[nEntries-1];
+    Seg[2].Params[4] = 0;
+
+
+    return cmsBuildSegmentedToneCurve(ContextID, 3, Seg);
 }
 
 // Parametric curves
@@ -993,7 +1007,7 @@
 
     if (Tab == NULL) return FALSE;
 
-    if (cmsIsToneCurveLinear(Tab)) return FALSE; // Nothing to do
+    if (cmsIsToneCurveLinear(Tab)) return TRUE; // Nothing to do
 
     nItems = Tab -> nEntries;
 
@@ -1020,11 +1034,20 @@
 
         if (z[i] == 0.) Zeros++;
         if (z[i] >= 65535.) Poles++;
-        if (z[i] < z[i-1]) return FALSE; // Non-Monotonic
+        if (z[i] < z[i-1]) {
+            cmsSignalError(Tab ->InterpParams->ContextID, cmsERROR_RANGE, "cmsSmoothToneCurve: Non-Monotonic.");
+            return FALSE;
+        }
     }
 
-    if (Zeros > (nItems / 3)) return FALSE;  // Degenerated, mostly zeros
-    if (Poles > (nItems / 3)) return FALSE;  // Degenerated, mostly poles
+    if (Zeros > (nItems / 3)) {
+        cmsSignalError(Tab ->InterpParams->ContextID, cmsERROR_RANGE, "cmsSmoothToneCurve: Degenerated, mostly zeros.");
+        return FALSE;
+    }
+    if (Poles > (nItems / 3)) {
+        cmsSignalError(Tab ->InterpParams->ContextID, cmsERROR_RANGE, "cmsSmoothToneCurve: Degenerated, mostly poles.");
+        return FALSE;
+    }
 
     // Seems ok
     for (i=0; i < nItems; i++) {
--- ./jdk/src/share/native/sun/java2d/cmm/lcms/cmsgmt.c	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/native/sun/java2d/cmm/lcms/cmsgmt.c	Tue Mar 18 12:35:25 2014 -0700
@@ -249,13 +249,10 @@
     cmsFloat64Number dE1, dE2, ErrorRatio;
 
     // Assume in-gamut by default.
-    dE1 = 0.;
-    dE2 = 0;
     ErrorRatio = 1.0;
 
     // Convert input to Lab
-    if (t -> hInput != NULL)
-        cmsDoTransform(t -> hInput, In, &LabIn1, 1);
+    cmsDoTransform(t -> hInput, In, &LabIn1, 1);
 
     // converts from PCS to colorant. This always
     // does return in-gamut values,
@@ -267,7 +264,7 @@
     memmove(&LabIn2, &LabOut1, sizeof(cmsCIELab));
 
     // Try again, but this time taking Check as input
-    cmsDoTransform(t -> hForward, &LabOut1, Proof2,  1);
+    cmsDoTransform(t -> hForward, &LabOut1, Proof2, 1);
     cmsDoTransform(t -> hReverse, Proof2, &LabOut2, 1);
 
     // Take difference of direct value
@@ -374,7 +371,7 @@
     ProfileList[nGamutPCSposition] = hLab;
     BPCList[nGamutPCSposition] = 0;
     AdaptationList[nGamutPCSposition] = 1.0;
-    Intents[nGamutPCSposition] = INTENT_RELATIVE_COLORIMETRIC;
+    IntentList[nGamutPCSposition] = INTENT_RELATIVE_COLORIMETRIC;
 
 
     ColorSpace  = cmsGetColorSpace(hGamut);
@@ -385,45 +382,48 @@
 
     // 16 bits to Lab double
     Chain.hInput = cmsCreateExtendedTransform(ContextID,
-                                              nGamutPCSposition + 1,
-                                              ProfileList,
-                                              BPCList,
-                                              Intents,
-                                              AdaptationList,
-                                              NULL, 0,
-                                              dwFormat, TYPE_Lab_DBL,
-                                              cmsFLAGS_NOCACHE);
+        nGamutPCSposition + 1,
+        ProfileList,
+        BPCList,
+        IntentList,
+        AdaptationList,
+        NULL, 0,
+        dwFormat, TYPE_Lab_DBL,
+        cmsFLAGS_NOCACHE);
 
 
     // Does create the forward step. Lab double to device
     dwFormat    = (CHANNELS_SH(nChannels)|BYTES_SH(2));
     Chain.hForward = cmsCreateTransformTHR(ContextID,
-                                           hLab, TYPE_Lab_DBL,
-                                           hGamut, dwFormat,
-                                           INTENT_RELATIVE_COLORIMETRIC,
-                                           cmsFLAGS_NOCACHE);
+        hLab, TYPE_Lab_DBL,
+        hGamut, dwFormat,
+        INTENT_RELATIVE_COLORIMETRIC,
+        cmsFLAGS_NOCACHE);
 
     // Does create the backwards step
     Chain.hReverse = cmsCreateTransformTHR(ContextID, hGamut, dwFormat,
-                                           hLab, TYPE_Lab_DBL,
-                                           INTENT_RELATIVE_COLORIMETRIC,
-                                           cmsFLAGS_NOCACHE);
+        hLab, TYPE_Lab_DBL,
+        INTENT_RELATIVE_COLORIMETRIC,
+        cmsFLAGS_NOCACHE);
 
 
     // All ok?
-    if (Chain.hForward && Chain.hReverse) {
+    if (Chain.hInput && Chain.hForward && Chain.hReverse) {
 
         // Go on, try to compute gamut LUT from PCS. This consist on a single channel containing
         // dE when doing a transform back and forth on the colorimetric intent.
 
         Gamut = cmsPipelineAlloc(ContextID, 3, 1);
-
         if (Gamut != NULL) {
 
-          CLUT = cmsStageAllocCLut16bit(ContextID, nGridpoints, nChannels, 1, NULL);
-          cmsPipelineInsertStage(Gamut, cmsAT_BEGIN, CLUT);
-
-          cmsStageSampleCLut16bit(CLUT, GamutSampler, (void*) &Chain, 0);
+            CLUT = cmsStageAllocCLut16bit(ContextID, nGridpoints, nChannels, 1, NULL);
+            if (!cmsPipelineInsertStage(Gamut, cmsAT_BEGIN, CLUT)) {
+                cmsPipelineFree(Gamut);
+                Gamut = NULL;
+            }
+            else {
+                cmsStageSampleCLut16bit(CLUT, GamutSampler, (void*) &Chain, 0);
+            }
         }
     }
     else
--- ./jdk/src/share/native/sun/java2d/cmm/lcms/cmsintrp.c	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/native/sun/java2d/cmm/lcms/cmsintrp.c	Tue Mar 18 12:35:25 2014 -0700
@@ -83,7 +83,6 @@
 
 
 // Set the interpolation method
-
 cmsBool _cmsSetInterpolationRoutine(cmsInterpParams* p)
 {
     // Invoke factory, possibly in the Plug-in
@@ -215,6 +214,11 @@
     Output[0] = LinearInterp(rest, y0, y1);
 }
 
+// To prevent out of bounds indexing
+cmsINLINE cmsFloat32Number fclamp(cmsFloat32Number v)
+{
+    return v < 0.0f ? 0.0f : (v > 1.0f ? 1.0f : v);
+}
 
 // Floating-point version of 1D interpolation
 static
@@ -227,13 +231,15 @@
        int cell0, cell1;
        const cmsFloat32Number* LutTable = (cmsFloat32Number*) p ->Table;
 
+       val2 = fclamp(Value[0]);
+
        // if last value...
-       if (Value[0] == 1.0) {
+       if (val2 == 1.0) {
            Output[0] = LutTable[p -> Domain[0]];
            return;
        }
 
-       val2 = p -> Domain[0] * Value[0];
+       val2 *= p -> Domain[0];
 
        cell0 = (int) floor(val2);
        cell1 = (int) ceil(val2);
@@ -292,13 +298,15 @@
     cmsUInt32Number OutChan;
     const cmsFloat32Number* LutTable = (cmsFloat32Number*) p ->Table;
 
+    val2 = fclamp(Value[0]);
+
         // if last value...
-       if (Value[0] == 1.0) {
+       if (val2 == 1.0) {
            Output[0] = LutTable[p -> Domain[0]];
            return;
        }
 
-       val2 = p -> Domain[0] * Value[0];
+       val2 *= p -> Domain[0];
 
        cell0 = (int) floor(val2);
        cell1 = (int) ceil(val2);
@@ -339,8 +347,8 @@
         dxy;
 
     TotalOut   = p -> nOutputs;
-    px = Input[0] * p->Domain[0];
-    py = Input[1] * p->Domain[1];
+    px = fclamp(Input[0]) * p->Domain[0];
+    py = fclamp(Input[1]) * p->Domain[1];
 
     x0 = (int) _cmsQuickFloor(px); fx = px - (cmsFloat32Number) x0;
     y0 = (int) _cmsQuickFloor(py); fy = py - (cmsFloat32Number) y0;
@@ -454,20 +462,9 @@
     TotalOut   = p -> nOutputs;
 
     // We need some clipping here
-    px = Input[0];
-    py = Input[1];
-    pz = Input[2];
-
-    if (px < 0) px = 0;
-    if (px > 1) px = 1;
-    if (py < 0) py = 0;
-    if (py > 1) py = 1;
-    if (pz < 0) pz = 0;
-    if (pz > 1) pz = 1;
-
-    px *= p->Domain[0];
-    py *= p->Domain[1];
-    pz *= p->Domain[2];
+    px = fclamp(Input[0]) * p->Domain[0];
+    py = fclamp(Input[1]) * p->Domain[1];
+    pz = fclamp(Input[2]) * p->Domain[2];
 
     x0 = (int) _cmsQuickFloor(px); fx = px - (cmsFloat32Number) x0;
     y0 = (int) _cmsQuickFloor(py); fy = py - (cmsFloat32Number) y0;
@@ -609,20 +606,9 @@
     TotalOut   = p -> nOutputs;
 
     // We need some clipping here
-    px = Input[0];
-    py = Input[1];
-    pz = Input[2];
-
-    if (px < 0) px = 0;
-    if (px > 1) px = 1;
-    if (py < 0) py = 0;
-    if (py > 1) py = 1;
-    if (pz < 0) pz = 0;
-    if (pz > 1) pz = 1;
-
-    px *= p->Domain[0];
-    py *= p->Domain[1];
-    pz *= p->Domain[2];
+    px = fclamp(Input[0]) * p->Domain[0];
+    py = fclamp(Input[1]) * p->Domain[1];
+    pz = fclamp(Input[2]) * p->Domain[2];
 
     x0 = (int) _cmsQuickFloor(px); rx = (px - (cmsFloat32Number) x0);
     y0 = (int) _cmsQuickFloor(py); ry = (py - (cmsFloat32Number) y0);
@@ -844,7 +830,7 @@
                      register cmsUInt16Number Output[],
                      register const cmsInterpParams* p16)
 {
-    const cmsUInt16Number* LutTable = (cmsUInt16Number*) p16 -> Table;
+    const cmsUInt16Number* LutTable;
     cmsS15Fixed16Number fk;
     cmsS15Fixed16Number k0, rk;
     int K0, K1;
@@ -1039,8 +1025,7 @@
        cmsFloat32Number Tmp1[MAX_STAGE_CHANNELS], Tmp2[MAX_STAGE_CHANNELS];
        cmsInterpParams p1;
 
-
-       pk = Input[0] * p->Domain[0];
+       pk = fclamp(Input[0]) * p->Domain[0];
        k0 = _cmsQuickFloor(pk);
        rest = pk - (cmsFloat32Number) k0;
 
@@ -1127,7 +1112,7 @@
        cmsFloat32Number Tmp1[MAX_STAGE_CHANNELS], Tmp2[MAX_STAGE_CHANNELS];
        cmsInterpParams p1;
 
-       pk = Input[0] * p->Domain[0];
+       pk = fclamp(Input[0]) * p->Domain[0];
        k0 = _cmsQuickFloor(pk);
        rest = pk - (cmsFloat32Number) k0;
 
@@ -1214,7 +1199,7 @@
        cmsFloat32Number Tmp1[MAX_STAGE_CHANNELS], Tmp2[MAX_STAGE_CHANNELS];
        cmsInterpParams p1;
 
-       pk = Input[0] * p->Domain[0];
+       pk = fclamp(Input[0]) * p->Domain[0];
        k0 = _cmsQuickFloor(pk);
        rest = pk - (cmsFloat32Number) k0;
 
@@ -1299,7 +1284,7 @@
        cmsFloat32Number Tmp1[MAX_STAGE_CHANNELS], Tmp2[MAX_STAGE_CHANNELS];
        cmsInterpParams p1;
 
-       pk = Input[0] * p->Domain[0];
+       pk = fclamp(Input[0]) * p->Domain[0];
        k0 = _cmsQuickFloor(pk);
        rest = pk - (cmsFloat32Number) k0;
 
@@ -1384,7 +1369,7 @@
        cmsFloat32Number Tmp1[MAX_STAGE_CHANNELS], Tmp2[MAX_STAGE_CHANNELS];
        cmsInterpParams p1;
 
-       pk = Input[0] * p->Domain[0];
+       pk = fclamp(Input[0]) * p->Domain[0];
        k0 = _cmsQuickFloor(pk);
        rest = pk - (cmsFloat32Number) k0;
 
--- ./jdk/src/share/native/sun/java2d/cmm/lcms/cmsio0.c	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/native/sun/java2d/cmm/lcms/cmsio0.c	Tue Mar 18 12:35:25 2014 -0700
@@ -154,7 +154,6 @@
     return iohandler;
 
 Error:
-    if (fm) _cmsFree(ContextID, fm);
     if (iohandler) _cmsFree(ContextID, iohandler);
     return NULL;
 
@@ -223,12 +222,17 @@
 
 // Writes data to memory, also keeps used space for further reference.
 static
-cmsBool  MemoryWrite(struct _cms_io_handler* iohandler, cmsUInt32Number size, const void *Ptr)
+cmsBool MemoryWrite(struct _cms_io_handler* iohandler, cmsUInt32Number size, const void *Ptr)
 {
     FILEMEM* ResData = (FILEMEM*) iohandler ->stream;
 
     if (ResData == NULL) return FALSE; // Housekeeping
 
+    // Check for available space. Clip.
+    if (iohandler ->UsedSpace + size > ResData->Size) {
+        size = ResData ->Size - iohandler ->UsedSpace;
+    }
+
     if (size == 0) return TRUE;     // Write zero bytes is ok, but does nothing
 
     memmove(ResData ->Block + ResData ->Pointer, Ptr, size);
@@ -389,13 +393,15 @@
     return TRUE;
 }
 
-// Create a iohandler for disk based files. if FileName is NULL, then 'stream' member is also set
-// to NULL and no real writting is performed. This only happens in writting access mode
+// Create a iohandler for disk based files.
 cmsIOHANDLER* CMSEXPORT cmsOpenIOhandlerFromFile(cmsContext ContextID, const char* FileName, const char* AccessMode)
 {
     cmsIOHANDLER* iohandler = NULL;
     FILE* fm = NULL;
 
+    _cmsAssert(FileName != NULL);
+    _cmsAssert(AccessMode != NULL);
+
     iohandler = (cmsIOHANDLER*) _cmsMallocZero(ContextID, sizeof(cmsIOHANDLER));
     if (iohandler == NULL) return NULL;
 
@@ -432,11 +438,8 @@
     iohandler ->UsedSpace = 0;
 
     // Keep track of the original file
-    if (FileName != NULL)  {
-
-        strncpy(iohandler -> PhysicalFile, FileName, sizeof(iohandler -> PhysicalFile)-1);
-        iohandler -> PhysicalFile[sizeof(iohandler -> PhysicalFile)-1] = 0;
-    }
+    strncpy(iohandler -> PhysicalFile, FileName, sizeof(iohandler -> PhysicalFile)-1);
+    iohandler -> PhysicalFile[sizeof(iohandler -> PhysicalFile)-1] = 0;
 
     iohandler ->Read    = FileRead;
     iohandler ->Seek    = FileSeek;
@@ -616,6 +619,31 @@
        return _cmsSearchTag(Icc, sig, FALSE) >= 0;
 }
 
+/*
+ * Enforces that the profile version is per. spec.
+ * Operates on the big endian bytes from the profile.
+ * Called before converting to platform endianness.
+ * Byte 0 is BCD major version, so max 9.
+ * Byte 1 is 2 BCD digits, one per nibble.
+ * Reserved bytes 2 & 3 must be 0.
+ */
+static cmsUInt32Number _validatedVersion(cmsUInt32Number DWord)
+{
+    cmsUInt8Number* pByte = (cmsUInt8Number*)&DWord;
+    cmsUInt8Number temp1;
+    cmsUInt8Number temp2;
+
+    if (*pByte > 0x09) *pByte = (cmsUInt8Number)9;
+    temp1 = *(pByte+1) & 0xf0;
+    temp2 = *(pByte+1) & 0x0f;
+    if (temp1 > 0x90) temp1 = 0x90;
+    if (temp2 > 9) temp2 = 0x09;
+    *(pByte+1) = (cmsUInt8Number)(temp1 | temp2);
+    *(pByte+2) = (cmsUInt8Number)0;
+    *(pByte+3) = (cmsUInt8Number)0;
+
+    return DWord;
+}
 
 // Read profile header and validate it
 cmsBool _cmsReadHeader(_cmsICCPROFILE* Icc)
@@ -643,12 +671,15 @@
     Icc -> DeviceClass     = (cmsProfileClassSignature) _cmsAdjustEndianess32(Header.deviceClass);
     Icc -> ColorSpace      = (cmsColorSpaceSignature)   _cmsAdjustEndianess32(Header.colorSpace);
     Icc -> PCS             = (cmsColorSpaceSignature)   _cmsAdjustEndianess32(Header.pcs);
+
     Icc -> RenderingIntent = _cmsAdjustEndianess32(Header.renderingIntent);
     Icc -> flags           = _cmsAdjustEndianess32(Header.flags);
     Icc -> manufacturer    = _cmsAdjustEndianess32(Header.manufacturer);
     Icc -> model           = _cmsAdjustEndianess32(Header.model);
+    Icc -> creator         = _cmsAdjustEndianess32(Header.creator);
+
     _cmsAdjustEndianess64(&Icc -> attributes, &Header.attributes);
-    Icc -> Version         = _cmsAdjustEndianess32(Header.version);
+    Icc -> Version         = _cmsAdjustEndianess32(_validatedVersion(Header.version));
 
     // Get size as reported in header
     HeaderSize = _cmsAdjustEndianess32(Header.size);
@@ -815,28 +846,33 @@
 cmsUInt32Number CMSEXPORT cmsGetHeaderManufacturer(cmsHPROFILE hProfile)
 {
     _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;
-    return (cmsUInt32Number) Icc ->manufacturer;
+    return Icc ->manufacturer;
 }
 
 void CMSEXPORT cmsSetHeaderManufacturer(cmsHPROFILE hProfile, cmsUInt32Number manufacturer)
 {
     _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;
-    Icc -> manufacturer = (cmsUInt32Number) manufacturer;
+    Icc -> manufacturer = manufacturer;
+}
+
+cmsUInt32Number CMSEXPORT cmsGetHeaderCreator(cmsHPROFILE hProfile)
+{
+    _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;
+    return Icc ->creator;
 }
 
 cmsUInt32Number CMSEXPORT cmsGetHeaderModel(cmsHPROFILE hProfile)
 {
     _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;
-    return (cmsUInt32Number) Icc ->model;
+    return Icc ->model;
 }
 
 void CMSEXPORT cmsSetHeaderModel(cmsHPROFILE hProfile, cmsUInt32Number model)
 {
     _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;
-    Icc -> model = (cmsUInt32Number) model;
+    Icc -> model = model;
 }
 
-
 void CMSEXPORT cmsGetHeaderAttributes(cmsHPROFILE hProfile, cmsUInt64Number* Flags)
 {
     _cmsICCPROFILE*  Icc = (_cmsICCPROFILE*) hProfile;
@@ -1073,11 +1109,16 @@
     return cmsOpenProfileFromMemTHR(NULL, MemPtr, dwSize);
 }
 
-
 static
 cmsBool SanityCheck(_cmsICCPROFILE* profile)
 {
-    cmsIOHANDLER* io = profile->IOhandler;
+    cmsIOHANDLER* io;
+
+    if (!profile) {
+        return FALSE;
+    }
+
+    io = profile->IOhandler;
     if (!io) {
         return FALSE;
     }
@@ -1106,13 +1147,13 @@
     cmsIOHANDLER* io = Icc ->IOhandler;
     cmsTagDescriptor* TagDescriptor;
     cmsTagTypeSignature TypeBase;
+    cmsTagTypeSignature Type;
     cmsTagTypeHandler* TypeHandler;
-
-    if (!SanityCheck(FileOrig)) return FALSE;
+    cmsFloat64Number   Version = cmsGetProfileVersion((cmsHPROFILE) Icc);
+    cmsTagTypeHandler LocalTypeHandler;
 
     for (i=0; i < Icc -> TagCount; i++) {
 
-
         if (Icc ->TagNames[i] == 0) continue;
 
         // Linked tags are not written
@@ -1126,7 +1167,7 @@
 
             // Reach here if we are copying a tag from a disk-based ICC profile which has not been modified by user.
             // In this case a blind copy of the block data is performed
-            if (FileOrig != NULL && Icc -> TagOffsets[i]) {
+            if (SanityCheck(FileOrig) && Icc -> TagOffsets[i]) {
 
                 cmsUInt32Number TagSize   = FileOrig -> TagSizes[i];
                 cmsUInt32Number TagOffset = FileOrig -> TagOffsets[i];
@@ -1164,7 +1205,16 @@
             TagDescriptor = _cmsGetTagDescriptor(Icc -> TagNames[i]);
             if (TagDescriptor == NULL) continue;                        // Unsupported, ignore it
 
-            TypeHandler = Icc ->TagTypeHandlers[i];
+            if (TagDescriptor ->DecideType != NULL) {
+
+                Type = TagDescriptor ->DecideType(Version, Data);
+            }
+            else {
+
+                Type = TagDescriptor ->SupportedTypes[0];
+            }
+
+            TypeHandler =  _cmsGetTagTypeHandler(Type);
 
             if (TypeHandler == NULL) {
                 cmsSignalError(Icc ->ContextID, cmsERROR_INTERNAL, "(Internal) no handler for tag %x", Icc -> TagNames[i]);
@@ -1175,9 +1225,10 @@
             if (!_cmsWriteTypeBase(io, TypeBase))
                 return FALSE;
 
-            TypeHandler ->ContextID  = Icc ->ContextID;
-            TypeHandler ->ICCVersion = Icc ->Version;
-            if (!TypeHandler ->WritePtr(TypeHandler, io, Data, TagDescriptor ->ElemCount)) {
+            LocalTypeHandler = *TypeHandler;
+            LocalTypeHandler.ContextID  = Icc ->ContextID;
+            LocalTypeHandler.ICCVersion = Icc ->Version;
+            if (!LocalTypeHandler.WritePtr(&LocalTypeHandler, io, Data, TagDescriptor ->ElemCount)) {
 
                 char String[5];
 
@@ -1314,8 +1365,8 @@
     // Should we just calculate the needed space?
     if (MemPtr == NULL) {
 
-        *BytesNeeded = cmsSaveProfileToIOhandler(hProfile, NULL);
-        return (*BytesNeeded == 0 ? FALSE : TRUE);
+           *BytesNeeded =  cmsSaveProfileToIOhandler(hProfile, NULL);
+            return (*BytesNeeded == 0 ? FALSE : TRUE);
     }
 
     // That is a real write operation
@@ -1353,10 +1404,11 @@
             cmsTagTypeHandler* TypeHandler = Icc ->TagTypeHandlers[i];
 
             if (TypeHandler != NULL) {
+                cmsTagTypeHandler LocalTypeHandler = *TypeHandler;
 
-                TypeHandler ->ContextID = Icc ->ContextID;              // As an additional parameters
-                TypeHandler ->ICCVersion = Icc ->Version;
-                TypeHandler ->FreePtr(TypeHandler, Icc -> TagPtrs[i]);
+                LocalTypeHandler.ContextID = Icc ->ContextID;              // As an additional parameters
+                LocalTypeHandler.ICCVersion = Icc ->Version;
+                LocalTypeHandler.FreePtr(&LocalTypeHandler, Icc -> TagPtrs[i]);
             }
             else
                 _cmsFree(Icc ->ContextID, Icc ->TagPtrs[i]);
@@ -1400,6 +1452,7 @@
     _cmsICCPROFILE* Icc = (_cmsICCPROFILE*) hProfile;
     cmsIOHANDLER* io = Icc ->IOhandler;
     cmsTagTypeHandler* TypeHandler;
+    cmsTagTypeHandler LocalTypeHandler;
     cmsTagDescriptor*  TagDescriptor;
     cmsTagTypeSignature BaseType;
     cmsUInt32Number Offset, TagSize;
@@ -1423,7 +1476,7 @@
 
     // Seek to its location
     if (!io -> Seek(io, Offset))
-            return NULL;
+        return NULL;
 
     // Search for support on this tag
     TagDescriptor = _cmsGetTagDescriptor(sig);
@@ -1440,14 +1493,15 @@
     // Get type handler
     TypeHandler = _cmsGetTagTypeHandler(BaseType);
     if (TypeHandler == NULL) return NULL;
+    LocalTypeHandler = *TypeHandler;
 
 
     // Read the tag
     Icc -> TagTypeHandlers[n] = TypeHandler;
 
-    TypeHandler ->ContextID = Icc ->ContextID;
-    TypeHandler ->ICCVersion = Icc ->Version;
-    Icc -> TagPtrs[n] = TypeHandler ->ReadPtr(TypeHandler, io, &ElemCount, TagSize);
+    LocalTypeHandler.ContextID = Icc ->ContextID;
+    LocalTypeHandler.ICCVersion = Icc ->Version;
+    Icc -> TagPtrs[n] = LocalTypeHandler.ReadPtr(&LocalTypeHandler, io, &ElemCount, TagSize);
 
     // The tag type is supported, but something wrong happend and we cannot read the tag.
     // let know the user about this (although it is just a warning)
@@ -1468,7 +1522,7 @@
 
         _cmsTagSignature2String(String, sig);
         cmsSignalError(Icc ->ContextID, cmsERROR_CORRUPTION_DETECTED, "'%s' Inconsistent number of items: expected %d, got %d",
-                                                             String, TagDescriptor ->ElemCount, ElemCount);
+            String, TagDescriptor ->ElemCount, ElemCount);
     }
 
 
@@ -1500,6 +1554,7 @@
 {
     _cmsICCPROFILE* Icc = (_cmsICCPROFILE*) hProfile;
     cmsTagTypeHandler* TypeHandler = NULL;
+    cmsTagTypeHandler LocalTypeHandler;
     cmsTagDescriptor* TagDescriptor = NULL;
     cmsTagTypeSignature Type;
     int i;
@@ -1530,9 +1585,10 @@
 
                 if (TypeHandler != NULL) {
 
-                    TypeHandler ->ContextID = Icc ->ContextID;              // As an additional parameter
-                    TypeHandler ->ICCVersion = Icc ->Version;
-                    TypeHandler->FreePtr(TypeHandler, Icc -> TagPtrs[i]);
+                    LocalTypeHandler = *TypeHandler;
+                    LocalTypeHandler.ContextID = Icc ->ContextID;              // As an additional parameter
+                    LocalTypeHandler.ICCVersion = Icc ->Version;
+                    LocalTypeHandler.FreePtr(&LocalTypeHandler, Icc -> TagPtrs[i]);
                 }
             }
         }
@@ -1571,7 +1627,7 @@
         // Let the tag descriptor to decide the type base on depending on
         // the data. This is useful for example on parametric curves, where
         // curves specified by a table cannot be saved as parametric and needs
-        // to be revented to single v2-curves, even on v4 profiles.
+        // to be casted to single v2-curves, even on v4 profiles.
 
         Type = TagDescriptor ->DecideType(Version, data);
     }
@@ -1609,9 +1665,10 @@
     Icc ->TagSizes[i]         = 0;
     Icc ->TagOffsets[i]       = 0;
 
-    TypeHandler ->ContextID  = Icc ->ContextID;
-    TypeHandler ->ICCVersion = Icc ->Version;
-    Icc ->TagPtrs[i]         = TypeHandler ->DupPtr(TypeHandler, data, TagDescriptor ->ElemCount);
+    LocalTypeHandler = *TypeHandler;
+    LocalTypeHandler.ContextID  = Icc ->ContextID;
+    LocalTypeHandler.ICCVersion = Icc ->Version;
+    Icc ->TagPtrs[i]         = LocalTypeHandler.DupPtr(&LocalTypeHandler, data, TagDescriptor ->ElemCount);
 
     if (Icc ->TagPtrs[i] == NULL)  {
 
@@ -1638,6 +1695,7 @@
     int i;
     cmsIOHANDLER* MemIO;
     cmsTagTypeHandler* TypeHandler = NULL;
+    cmsTagTypeHandler LocalTypeHandler;
     cmsTagDescriptor* TagDescriptor = NULL;
     cmsUInt32Number rc;
     cmsUInt32Number Offset, TagSize;
@@ -1653,15 +1711,16 @@
         Offset   = Icc ->TagOffsets[i];
         TagSize  = Icc ->TagSizes[i];
 
-
         // read the data directly, don't keep copy
         if (data != NULL) {
 
             if (BufferSize < TagSize)
-                 TagSize = BufferSize;
+                TagSize = BufferSize;
 
             if (!Icc ->IOhandler ->Seek(Icc ->IOhandler, Offset)) return 0;
             if (!Icc ->IOhandler ->Read(Icc ->IOhandler, data, 1, TagSize)) return 0;
+
+            return TagSize;
         }
 
         return Icc ->TagSizes[i];
@@ -1675,9 +1734,11 @@
 
             TagSize  = Icc ->TagSizes[i];
             if (BufferSize < TagSize)
-                       TagSize = BufferSize;
+                TagSize = BufferSize;
 
             memmove(data, Icc ->TagPtrs[i], TagSize);
+
+            return TagSize;
         }
 
         return Icc ->TagSizes[i];
@@ -1693,7 +1754,7 @@
     if (data == NULL) {
         MemIO = cmsOpenIOhandlerFromNULL(cmsGetProfileContextID(hProfile));
     } else{
-      MemIO = cmsOpenIOhandlerFromMem(cmsGetProfileContextID(hProfile), data, BufferSize, "w");
+        MemIO = cmsOpenIOhandlerFromMem(cmsGetProfileContextID(hProfile), data, BufferSize, "w");
     }
     if (MemIO == NULL) return 0;
 
@@ -1701,20 +1762,22 @@
     TypeHandler = Icc ->TagTypeHandlers[i];
     TagDescriptor = _cmsGetTagDescriptor(sig);
     if (TagDescriptor == NULL) {
-         cmsCloseIOhandler(MemIO);
-         return 0;
+        cmsCloseIOhandler(MemIO);
+        return 0;
     }
 
+    // FIXME: No handling for TypeHandler == NULL here?
     // Serialize
-    TypeHandler ->ContextID  = Icc ->ContextID;
-    TypeHandler ->ICCVersion = Icc ->Version;
+    LocalTypeHandler = *TypeHandler;
+    LocalTypeHandler.ContextID  = Icc ->ContextID;
+    LocalTypeHandler.ICCVersion = Icc ->Version;
 
     if (!_cmsWriteTypeBase(MemIO, TypeHandler ->Signature)) {
         cmsCloseIOhandler(MemIO);
         return 0;
     }
 
-    if (!TypeHandler ->WritePtr(TypeHandler, MemIO, Object, TagDescriptor ->ElemCount)) {
+    if (!LocalTypeHandler.WritePtr(&LocalTypeHandler, MemIO, Object, TagDescriptor ->ElemCount)) {
         cmsCloseIOhandler(MemIO);
         return 0;
     }
@@ -1752,7 +1815,7 @@
 // Using this function you can collapse several tag entries to the same block in the profile
 cmsBool CMSEXPORT cmsLinkTag(cmsHPROFILE hProfile, cmsTagSignature sig, cmsTagSignature dest)
 {
-     _cmsICCPROFILE* Icc = (_cmsICCPROFILE*) hProfile;
+    _cmsICCPROFILE* Icc = (_cmsICCPROFILE*) hProfile;
     int i;
 
     if (!_cmsNewTag(Icc, sig, &i)) return FALSE;
--- ./jdk/src/share/native/sun/java2d/cmm/lcms/cmsio1.c	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/native/sun/java2d/cmm/lcms/cmsio1.c	Tue Mar 18 12:35:25 2014 -0700
@@ -129,7 +129,6 @@
     Tag = (cmsMAT3*) cmsReadTag(hProfile, cmsSigChromaticAdaptationTag);
 
     if (Tag != NULL) {
-
         *Dest = *Tag;
         return TRUE;
     }
@@ -193,7 +192,8 @@
     if (GrayTRC == NULL) return NULL;
 
     Lut = cmsPipelineAlloc(ContextID, 1, 3);
-    if (Lut == NULL) return NULL;
+    if (Lut == NULL)
+        goto Error;
 
     if (cmsGetPCS(hProfile) == cmsSigLabData) {
 
@@ -204,28 +204,35 @@
 
         EmptyTab = cmsBuildTabulatedToneCurve16(ContextID, 2, Zero);
 
-        if (EmptyTab == NULL) {
-
-                 cmsPipelineFree(Lut);
-                 return NULL;
-        }
+        if (EmptyTab == NULL)
+            goto Error;
 
         LabCurves[0] = GrayTRC;
         LabCurves[1] = EmptyTab;
         LabCurves[2] = EmptyTab;
 
-        cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocMatrix(ContextID, 3,  1, OneToThreeInputMatrix, NULL));
-        cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocToneCurves(ContextID, 3, LabCurves));
+        if (!cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocMatrix(ContextID, 3,  1, OneToThreeInputMatrix, NULL)) ||
+            !cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocToneCurves(ContextID, 3, LabCurves))) {
+                cmsFreeToneCurve(EmptyTab);
+                goto Error;
+        }
 
         cmsFreeToneCurve(EmptyTab);
 
     }
     else  {
-       cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocToneCurves(ContextID, 1, &GrayTRC));
-       cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocMatrix(ContextID, 3,  1, GrayInputMatrix, NULL));
+
+        if (!cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocToneCurves(ContextID, 1, &GrayTRC)) ||
+            !cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocMatrix(ContextID, 3,  1, GrayInputMatrix, NULL)))
+            goto Error;
     }
 
     return Lut;
+
+Error:
+    cmsFreeToneCurve(GrayTRC);
+    cmsPipelineFree(Lut);
+    return NULL;
 }
 
 // RGB Matrix shaper
@@ -259,49 +266,31 @@
     Lut = cmsPipelineAlloc(ContextID, 3, 3);
     if (Lut != NULL) {
 
-        cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocToneCurves(ContextID, 3, Shapes));
-        cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocMatrix(ContextID, 3, 3, (cmsFloat64Number*) &Mat, NULL));
+        if (!cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocToneCurves(ContextID, 3, Shapes)) ||
+            !cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocMatrix(ContextID, 3, 3, (cmsFloat64Number*) &Mat, NULL)))
+            goto Error;
 
         // Note that it is certainly possible a single profile would have a LUT based
         // tag for output working in lab and a matrix-shaper for the fallback cases.
         // This is not allowed by the spec, but this code is tolerant to those cases
         if (cmsGetPCS(hProfile) == cmsSigLabData) {
 
-             cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageAllocXYZ2Lab(ContextID));
+            if (!cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageAllocXYZ2Lab(ContextID)))
+                goto Error;
         }
 
     }
 
     return Lut;
+
+Error:
+    cmsPipelineFree(Lut);
+    return NULL;
 }
 
 
 
 // Read the DToAX tag, adjusting the encoding of Lab or XYZ if neded
-/*static
-cmsPipeline* _cmsReadFloatInputTag(cmsHPROFILE hProfile, cmsTagSignature tagFloat)
-{
-    cmsContext ContextID       = cmsGetProfileContextID(hProfile);
-    cmsPipeline* Lut           = cmsPipelineDup((cmsPipeline*) cmsReadTag(hProfile, tagFloat));
-    cmsColorSpaceSignature spc = cmsGetColorSpace(hProfile);
-
-    if (Lut == NULL) return NULL;
-
-    // If PCS is Lab or XYZ, the floating point tag is accepting data in the space encoding,
-    // and since the formatter has already accomodated to 0..1.0, we should undo this change
-    if ( spc == cmsSigLabData)
-    {
-        cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageNormalizeFromLabFloat(ContextID));
-    }
-    else
-        if (spc == cmsSigXYZData)
-        {
-            cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageNormalizeFromXyzFloat(ContextID));
-        }
-
-    return Lut;
-}
-*/
 static
 cmsPipeline* _cmsReadFloatInputTag(cmsHPROFILE hProfile, cmsTagSignature tagFloat)
 {
@@ -316,23 +305,31 @@
     //  these need to be normalized into the appropriate ranges (Lab = 100,0,0, XYZ=1.0,1.0,1.0)
     if ( spc == cmsSigLabData)
     {
-        cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageNormalizeToLabFloat(ContextID));
+        if (!cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageNormalizeToLabFloat(ContextID)))
+            goto Error;
     }
     else if (spc == cmsSigXYZData)
     {
-        cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageNormalizeToXyzFloat(ContextID));
+        if (!cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageNormalizeToXyzFloat(ContextID)))
+            goto Error;
     }
 
     if ( PCS == cmsSigLabData)
     {
-        cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageNormalizeFromLabFloat(ContextID));
+        if (!cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageNormalizeFromLabFloat(ContextID)))
+            goto Error;
     }
     else if( PCS == cmsSigXYZData)
     {
-        cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageNormalizeFromXyzFloat(ContextID));
+        if (!cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageNormalizeFromXyzFloat(ContextID)))
+            goto Error;
     }
 
     return Lut;
+
+Error:
+    cmsPipelineFree(Lut);
+    return NULL;
 }
 
 
@@ -359,8 +356,11 @@
             return NULL;
         }
 
-        cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageAllocNamedColor(nc, TRUE));
-        cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageAllocLabV2ToV4(ContextID));
+        if (!cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageAllocNamedColor(nc, TRUE)) ||
+            !cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageAllocLabV2ToV4(ContextID))) {
+            cmsPipelineFree(Lut);
+            return NULL;
+        }
         return Lut;
     }
 
@@ -395,12 +395,18 @@
             return Lut;
 
         // If the input is Lab, add also a conversion at the begin
-        if (cmsGetColorSpace(hProfile) == cmsSigLabData)
-            cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageAllocLabV4ToV2(ContextID));
+        if (cmsGetColorSpace(hProfile) == cmsSigLabData &&
+            !cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageAllocLabV4ToV2(ContextID)))
+            goto Error;
 
         // Add a matrix for conversion V2 to V4 Lab PCS
-        cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageAllocLabV2ToV4(ContextID));
+        if (!cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageAllocLabV2ToV4(ContextID)))
+            goto Error;
+
         return Lut;
+Error:
+        cmsPipelineFree(Lut);
+        return NULL;
     }
 
     // Lut was not found, try to create a matrix-shaper
@@ -445,21 +451,27 @@
 
     if (cmsGetPCS(hProfile) == cmsSigLabData) {
 
-        cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocMatrix(ContextID, 1,  3, PickLstarMatrix, NULL));
+        if (!cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocMatrix(ContextID, 1,  3, PickLstarMatrix, NULL)))
+            goto Error;
     }
     else  {
-        cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocMatrix(ContextID, 1,  3, PickYMatrix, NULL));
+        if (!cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocMatrix(ContextID, 1,  3, PickYMatrix, NULL)))
+            goto Error;
     }
 
-    cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocToneCurves(ContextID, 1, &RevGrayTRC));
+    if (!cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocToneCurves(ContextID, 1, &RevGrayTRC)))
+        goto Error;
+
     cmsFreeToneCurve(RevGrayTRC);
+    return Lut;
 
-    return Lut;
+Error:
+    cmsFreeToneCurve(RevGrayTRC);
+    cmsPipelineFree(Lut);
+    return NULL;
 }
 
 
-
-
 static
 cmsPipeline* BuildRGBOutputMatrixShaper(cmsHPROFILE hProfile)
 {
@@ -506,15 +518,21 @@
         // This is not allowed by the spec, but this code is tolerant to those cases
         if (cmsGetPCS(hProfile) == cmsSigLabData) {
 
-             cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageAllocLab2XYZ(ContextID));
+            if (!cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageAllocLab2XYZ(ContextID)))
+                goto Error;
         }
 
-        cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocMatrix(ContextID, 3, 3, (cmsFloat64Number*) &Inv, NULL));
-        cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocToneCurves(ContextID, 3, InvShapes));
+        if (!cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocMatrix(ContextID, 3, 3, (cmsFloat64Number*) &Inv, NULL)) ||
+            !cmsPipelineInsertStage(Lut, cmsAT_END, cmsStageAllocToneCurves(ContextID, 3, InvShapes)))
+            goto Error;
     }
 
     cmsFreeToneCurveTriple(InvShapes);
     return Lut;
+Error:
+    cmsFreeToneCurveTriple(InvShapes);
+    cmsPipelineFree(Lut);
+    return NULL;
 }
 
 
@@ -540,30 +558,6 @@
 
 
 // Read the DToAX tag, adjusting the encoding of Lab or XYZ if neded
-/*static
-cmsPipeline* _cmsReadFloatOutputTag(cmsHPROFILE hProfile, cmsTagSignature tagFloat)
-{
-    cmsContext ContextID       = cmsGetProfileContextID(hProfile);
-    cmsPipeline* Lut           = cmsPipelineDup((cmsPipeline*) cmsReadTag(hProfile, tagFloat));
-    cmsColorSpaceSignature PCS = cmsGetPCS(hProfile);
-
-    if (Lut == NULL) return NULL;
-
-    // If PCS is Lab or XYZ, the floating point tag is accepting data in the space encoding,
-    // and since the formatter has already accomodated to 0..1.0, we should undo this change
-    if ( PCS == cmsSigLabData)
-    {
-        cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageNormalizeToLabFloat(ContextID));
-    }
-    else
-        if (PCS == cmsSigXYZData)
-        {
-            cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageNormalizeToXyzFloat(ContextID));
-        }
-
-    return Lut;
-}*/
-
 static
 cmsPipeline* _cmsReadFloatOutputTag(cmsHPROFILE hProfile, cmsTagSignature tagFloat)
 {
@@ -578,25 +572,33 @@
     // and since the formatter has already accomodated to 0..1.0, we should undo this change
     if ( PCS == cmsSigLabData)
     {
-        cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageNormalizeToLabFloat(ContextID));
+        if (!cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageNormalizeToLabFloat(ContextID)))
+            goto Error;
     }
     else
         if (PCS == cmsSigXYZData)
         {
-            cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageNormalizeToXyzFloat(ContextID));
+            if (!cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageNormalizeToXyzFloat(ContextID)))
+                goto Error;
         }
 
     // the output can be Lab or XYZ, in which case normalisation is needed on the end of the pipeline
     if ( dataSpace == cmsSigLabData)
     {
-        cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageNormalizeFromLabFloat(ContextID));
+        if (!cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageNormalizeFromLabFloat(ContextID)))
+            goto Error;
     }
-    else if ( dataSpace == cmsSigXYZData)
+    else if (dataSpace == cmsSigXYZData)
     {
-        cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageNormalizeFromXyzFloat(ContextID));
+        if (!cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageNormalizeFromXyzFloat(ContextID)))
+            goto Error;
     }
 
     return Lut;
+
+Error:
+    cmsPipelineFree(Lut);
+    return NULL;
 }
 
 // Create an output MPE LUT from agiven profile. Version mismatches are handled here
@@ -636,30 +638,35 @@
         // Now it is time for a controversial stuff. I found that for 3D LUTS using
         // Lab used as indexer space,  trilinear interpolation should be used
         if (cmsGetPCS(hProfile) == cmsSigLabData)
-                             ChangeInterpolationToTrilinear(Lut);
+            ChangeInterpolationToTrilinear(Lut);
 
         // We need to adjust data only for Lab and Lut16 type
         if (OriginalType != cmsSigLut16Type || cmsGetPCS(hProfile) != cmsSigLabData)
             return Lut;
 
         // Add a matrix for conversion V4 to V2 Lab PCS
-        cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageAllocLabV4ToV2(ContextID));
+        if (!cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageAllocLabV4ToV2(ContextID)))
+            goto Error;
 
         // If the output is Lab, add also a conversion at the end
         if (cmsGetColorSpace(hProfile) == cmsSigLabData)
-            cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageAllocLabV2ToV4(ContextID));
+            if (!cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageAllocLabV2ToV4(ContextID)))
+                goto Error;
 
         return Lut;
+Error:
+        cmsPipelineFree(Lut);
+        return NULL;
     }
 
     // Lut not found, try to create a matrix-shaper
 
     // Check if this is a grayscale profile.
-     if (cmsGetColorSpace(hProfile) == cmsSigGrayData) {
+    if (cmsGetColorSpace(hProfile) == cmsSigGrayData) {
 
-              // if so, build appropiate conversion tables.
-              // The tables are the PCS iluminant, scaled across GrayTRC
-              return BuildGrayOutputPipeline(hProfile);
+        // if so, build appropiate conversion tables.
+        // The tables are the PCS iluminant, scaled across GrayTRC
+        return BuildGrayOutputPipeline(hProfile);
     }
 
     // Not gray, create a normal matrix-shaper, which only operates in XYZ space
@@ -681,25 +688,32 @@
 
     if (spc == cmsSigLabData)
     {
-        cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageNormalizeToLabFloat(ContextID));
+        if (!cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageNormalizeToLabFloat(ContextID)))
+            goto Error;
     }
     else
         if (spc == cmsSigXYZData)
         {
-            cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageNormalizeToXyzFloat(ContextID));
+            if (!cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageNormalizeToXyzFloat(ContextID)))
+                goto Error;
         }
 
         if (PCS == cmsSigLabData)
         {
-            cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageNormalizeFromLabFloat(ContextID));
+            if (!cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageNormalizeFromLabFloat(ContextID)))
+                goto Error;
         }
         else
             if (PCS == cmsSigXYZData)
             {
-                cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageNormalizeFromXyzFloat(ContextID));
+                if (!cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageNormalizeFromXyzFloat(ContextID)))
+                    goto Error;
             }
 
-            return Lut;
+    return Lut;
+Error:
+    cmsPipelineFree(Lut);
+    return NULL;
 }
 
 // This one includes abstract profiles as well. Matrix-shaper cannot be obtained on that device class. The
@@ -721,15 +735,21 @@
         if (nc == NULL) return NULL;
 
         Lut = cmsPipelineAlloc(ContextID, 0, 0);
-        if (Lut == NULL) {
-            cmsFreeNamedColorList(nc);
-            return NULL;
-        }
+        if (Lut == NULL)
+            goto Error;
 
-        cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageAllocNamedColor(nc, FALSE));
+        if (!cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageAllocNamedColor(nc, FALSE)))
+            goto Error;
+
         if (cmsGetColorSpace(hProfile) == cmsSigLabData)
-              cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageAllocLabV2ToV4(ContextID));
+            if (!cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageAllocLabV2ToV4(ContextID)))
+                goto Error;
+
         return Lut;
+Error:
+        cmsPipelineFree(Lut);
+        cmsFreeNamedColorList(nc);
+        return NULL;
     }
 
     if (cmsIsTag(hProfile, tagFloat)) {  // Float tag takes precedence
@@ -760,10 +780,10 @@
     Lut = cmsPipelineDup(Lut);
     if (Lut == NULL) return NULL;
 
-     // Now it is time for a controversial stuff. I found that for 3D LUTS using
-     // Lab used as indexer space,  trilinear interpolation should be used
+    // Now it is time for a controversial stuff. I found that for 3D LUTS using
+    // Lab used as indexer space,  trilinear interpolation should be used
     if (cmsGetColorSpace(hProfile) == cmsSigLabData)
-                        ChangeInterpolationToTrilinear(Lut);
+        ChangeInterpolationToTrilinear(Lut);
 
     // After reading it, we have info about the original type
     OriginalType =  _cmsGetTagTrueType(hProfile, tag16);
@@ -774,16 +794,20 @@
     // Here it is possible to get Lab on both sides
 
     if (cmsGetPCS(hProfile) == cmsSigLabData) {
-            cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageAllocLabV4ToV2(ContextID));
+        if(!cmsPipelineInsertStage(Lut, cmsAT_BEGIN, _cmsStageAllocLabV4ToV2(ContextID)))
+            goto Error2;
     }
 
     if (cmsGetColorSpace(hProfile) == cmsSigLabData) {
-            cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageAllocLabV2ToV4(ContextID));
+        if(!cmsPipelineInsertStage(Lut, cmsAT_END, _cmsStageAllocLabV2ToV4(ContextID)))
+            goto Error2;
     }
 
     return Lut;
 
-
+Error2:
+    cmsPipelineFree(Lut);
+    return NULL;
 }
 
 // ---------------------------------------------------------------------------------------------------------------
--- ./jdk/src/share/native/sun/java2d/cmm/lcms/cmslut.c	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/native/sun/java2d/cmm/lcms/cmslut.c	Tue Mar 18 12:35:25 2014 -0700
@@ -264,10 +264,10 @@
     if (NewElem ->TheCurves != NULL) {
         for (i=0; i < NewElem ->nCurves; i++) {
             if (NewElem ->TheCurves[i])
-                cmsFreeToneCurve(Data ->TheCurves[i]);
+                cmsFreeToneCurve(NewElem ->TheCurves[i]);
         }
     }
-    _cmsFree(mpe ->ContextID, Data ->TheCurves);
+    _cmsFree(mpe ->ContextID, NewElem ->TheCurves);
     _cmsFree(mpe ->ContextID, NewElem);
     return NULL;
 }
@@ -392,6 +392,8 @@
 void MatrixElemTypeFree(cmsStage* mpe)
 {
     _cmsStageMatrixData* Data = (_cmsStageMatrixData*) mpe ->Data;
+    if (Data == NULL)
+        return;
     if (Data ->Double)
         _cmsFree(mpe ->ContextID, Data ->Double);
 
@@ -526,10 +528,15 @@
 
     if (Data ->Tab.T) {
 
-        if (Data ->HasFloatValues)
+        if (Data ->HasFloatValues) {
             NewElem ->Tab.TFloat = (cmsFloat32Number*) _cmsDupMem(mpe ->ContextID, Data ->Tab.TFloat, Data ->nEntries * sizeof (cmsFloat32Number));
-        else
+            if (NewElem ->Tab.TFloat == NULL)
+                goto Error;
+        } else {
             NewElem ->Tab.T = (cmsUInt16Number*) _cmsDupMem(mpe ->ContextID, Data ->Tab.T, Data ->nEntries * sizeof (cmsUInt16Number));
+            if (NewElem ->Tab.TFloat == NULL)
+                goto Error;
+        }
     }
 
     NewElem ->Params   = _cmsComputeInterpParamsEx(mpe ->ContextID,
@@ -538,8 +545,14 @@
                                                    Data ->Params ->nOutputs,
                                                    NewElem ->Tab.T,
                                                    Data ->Params ->dwFlags);
-
-    return (void*) NewElem;
+    if (NewElem->Params != NULL)
+        return (void*) NewElem;
+ Error:
+    if (NewElem->Tab.T)
+        // This works for both types
+        _cmsFree(mpe ->ContextID, NewElem -> Tab.T);
+    _cmsFree(mpe ->ContextID, NewElem);
+    return NULL;
 }
 
 
@@ -636,7 +649,6 @@
     for (i=0; i < MAX_INPUT_DIMENSIONS; i++)
         Dimensions[i] = nGridPoints;
 
-
     return cmsStageAllocCLut16bitGranular(ContextID, Dimensions, inputChan, outputChan, Table);
 }
 
@@ -706,15 +718,12 @@
         }
     }
 
-
     NewElem ->Params = _cmsComputeInterpParamsEx(ContextID, clutPoints,  inputChan, outputChan, NewElem ->Tab.TFloat, CMS_LERP_FLAGS_FLOAT);
     if (NewElem ->Params == NULL) {
         cmsStageFree(NewMPE);
         return NULL;
     }
 
-
-
     return NewMPE;
 }
 
@@ -772,7 +781,7 @@
     int i, t, nTotalPoints, index, rest;
     int nInputs, nOutputs;
     cmsUInt32Number* nSamples;
-    cmsUInt16Number In[cmsMAXCHANNELS], Out[MAX_STAGE_CHANNELS];
+    cmsUInt16Number In[MAX_INPUT_DIMENSIONS+1], Out[MAX_STAGE_CHANNELS];
     _cmsStageCLutData* clut;
 
     if (mpe == NULL) return FALSE;
@@ -785,7 +794,9 @@
     nInputs  = clut->Params ->nInputs;
     nOutputs = clut->Params ->nOutputs;
 
-    if (nInputs >= cmsMAXCHANNELS) return FALSE;
+    if (nInputs <= 0) return FALSE;
+    if (nOutputs <= 0) return FALSE;
+    if (nInputs > MAX_INPUT_DIMENSIONS) return FALSE;
     if (nOutputs >= MAX_STAGE_CHANNELS) return FALSE;
 
     nTotalPoints = CubeSize(nSamples, nInputs);
@@ -832,14 +843,16 @@
     int i, t, nTotalPoints, index, rest;
     int nInputs, nOutputs;
     cmsUInt32Number* nSamples;
-    cmsFloat32Number In[cmsMAXCHANNELS], Out[MAX_STAGE_CHANNELS];
+    cmsFloat32Number In[MAX_INPUT_DIMENSIONS+1], Out[MAX_STAGE_CHANNELS];
     _cmsStageCLutData* clut = (_cmsStageCLutData*) mpe->Data;
 
     nSamples = clut->Params ->nSamples;
     nInputs  = clut->Params ->nInputs;
     nOutputs = clut->Params ->nOutputs;
 
-    if (nInputs >= cmsMAXCHANNELS) return FALSE;
+    if (nInputs <= 0) return FALSE;
+    if (nOutputs <= 0) return FALSE;
+    if (nInputs  > MAX_INPUT_DIMENSIONS) return FALSE;
     if (nOutputs >= MAX_STAGE_CHANNELS) return FALSE;
 
     nTotalPoints = CubeSize(nSamples, nInputs);
@@ -1021,7 +1034,7 @@
     mpe = cmsStageAllocToneCurves(ContextID, 3, LabTable);
     cmsFreeToneCurveTriple(LabTable);
 
-    if (mpe == NULL) return mpe;
+    if (mpe == NULL) return NULL;
     mpe ->Implements = cmsSigLabV2toV4;
     return mpe;
 }
@@ -1247,12 +1260,22 @@
                                      NULL);
     if (NewMPE == NULL) return NULL;
 
-    NewMPE ->Implements     = mpe ->Implements;
+    NewMPE ->Implements = mpe ->Implements;
 
-    if (mpe ->DupElemPtr)
-        NewMPE ->Data       = mpe ->DupElemPtr(mpe);
-    else
+    if (mpe ->DupElemPtr) {
+
+        NewMPE ->Data = mpe ->DupElemPtr(mpe);
+
+        if (NewMPE->Data == NULL) {
+
+            cmsStageFree(NewMPE);
+            return NULL;
+        }
+
+    } else {
+
         NewMPE ->Data       = NULL;
+    }
 
     return NewMPE;
 }
@@ -1465,12 +1488,12 @@
 }
 
 
-void CMSEXPORT cmsPipelineInsertStage(cmsPipeline* lut, cmsStageLoc loc, cmsStage* mpe)
+int CMSEXPORT cmsPipelineInsertStage(cmsPipeline* lut, cmsStageLoc loc, cmsStage* mpe)
 {
     cmsStage* Anterior = NULL, *pt;
 
-    _cmsAssert(lut != NULL);
-    _cmsAssert(mpe != NULL);
+    if (lut == NULL || mpe == NULL)
+        return FALSE;
 
     switch (loc) {
 
@@ -1494,9 +1517,11 @@
             }
             break;
         default:;
+            return FALSE;
     }
 
     BlessLUT(lut);
+    return TRUE;
 }
 
 // Unlink an element and return the pointer to it
@@ -1558,7 +1583,7 @@
 // Concatenate two LUT into a new single one
 cmsBool  CMSEXPORT cmsPipelineCat(cmsPipeline* l1, const cmsPipeline* l2)
 {
-    cmsStage* mpe, *NewMPE;
+    cmsStage* mpe;
 
     // If both LUTS does not have elements, we need to inherit
     // the number of channels
@@ -1573,17 +1598,12 @@
          mpe = mpe ->Next) {
 
             // We have to dup each element
-             NewMPE = cmsStageDup(mpe);
-
-             if (NewMPE == NULL) {
-                 return FALSE;
-             }
-
-             cmsPipelineInsertStage(l1, cmsAT_END, NewMPE);
+            if (!cmsPipelineInsertStage(l1, cmsAT_END, cmsStageDup(mpe)))
+                return FALSE;
     }
 
-  BlessLUT(l1);
-  return TRUE;
+    BlessLUT(l1);
+    return TRUE;
 }
 
 
@@ -1713,16 +1733,11 @@
     cmsFloat32Number  fx[4], x[4], xd[4], fxd[4];
     cmsVEC3 tmp, tmp2;
     cmsMAT3 Jacobian;
-    cmsFloat64Number LastResult[4];
-
 
     // Only 3->3 and 4->3 are supported
     if (lut ->InputChannels != 3 && lut ->InputChannels != 4) return FALSE;
     if (lut ->OutputChannels != 3) return FALSE;
 
-    // Mark result of -1
-    LastResult[0] = LastResult[1] = LastResult[2] = -1.0f;
-
     // Take the hint as starting point if specified
     if (Hint == NULL) {
 
--- ./jdk/src/share/native/sun/java2d/cmm/lcms/cmsmd5.c	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/native/sun/java2d/cmm/lcms/cmsmd5.c	Tue Mar 18 12:35:25 2014 -0700
@@ -338,7 +338,7 @@
 Error:
 
     // Free resources as something went wrong
-    if (MD5 != NULL) _cmsFree(ContextID, MD5);
+    // "MD5" cannot be other than NULL here, so no need to free it
     if (Mem != NULL) _cmsFree(ContextID, Mem);
     memmove(Icc, &Keep, sizeof(_cmsICCPROFILE));
     return FALSE;
--- ./jdk/src/share/native/sun/java2d/cmm/lcms/cmsnamed.c	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/native/sun/java2d/cmm/lcms/cmsnamed.c	Tue Mar 18 12:35:25 2014 -0700
@@ -359,9 +359,9 @@
     if (Best == -1)
         Best = 0;
 
-     v = mlu ->Entries + Best;
+    v = mlu ->Entries + Best;
 
-     if (UsedLanguageCode != NULL) *UsedLanguageCode = v ->Language;
+    if (UsedLanguageCode != NULL) *UsedLanguageCode = v ->Language;
     if (UsedCountryCode  != NULL) *UsedCountryCode = v ->Country;
 
     if (len != NULL) *len   = v ->Len;
@@ -475,6 +475,35 @@
 }
 
 
+
+// Get the number of translations in the MLU object
+cmsUInt32Number CMSEXPORT cmsMLUtranslationsCount(const cmsMLU* mlu)
+{
+    if (mlu == NULL) return 0;
+    return mlu->UsedEntries;
+}
+
+// Get the language and country codes for a specific MLU index
+cmsBool CMSEXPORT cmsMLUtranslationsCodes(const cmsMLU* mlu,
+                                          cmsUInt32Number idx,
+                                          char LanguageCode[3],
+                                          char CountryCode[3])
+{
+    _cmsMLUentry *entry;
+
+    if (mlu == NULL) return FALSE;
+
+    if (idx >= (cmsUInt32Number) mlu->UsedEntries) return FALSE;
+
+    entry = &mlu->Entries[idx];
+
+    *(cmsUInt16Number *)LanguageCode = _cmsAdjustEndianess16(entry->Language);
+    *(cmsUInt16Number *)CountryCode  = _cmsAdjustEndianess16(entry->Country);
+
+    return TRUE;
+}
+
+
 // Named color lists --------------------------------------------------------------------------------------------
 
 // Grow the list to keep at least NumElements
@@ -517,9 +546,9 @@
     while (v -> Allocated < n)
         GrowNamedColorList(v);
 
-    strncpy(v ->Prefix, Prefix, sizeof(v ->Prefix) - 1);
-    strncpy(v ->Suffix, Suffix, sizeof(v ->Suffix) - 1);
-    v->Prefix[sizeof(v ->Prefix) - 1] = v->Suffix[sizeof(v ->Suffix) - 1] = 0;
+    strncpy(v ->Prefix, Prefix, sizeof(v ->Prefix)-1);
+    strncpy(v ->Suffix, Suffix, sizeof(v ->Suffix)-1);
+    v->Prefix[32] = v->Suffix[32] = 0;
 
     v -> ColorantCount = ColorantCount;
 
@@ -529,8 +558,9 @@
 // Free a list
 void CMSEXPORT cmsFreeNamedColorList(cmsNAMEDCOLORLIST* v)
 {
+    if (v == NULL) return;
     if (v ->List) _cmsFree(v ->ContextID, v ->List);
-    if (v) _cmsFree(v ->ContextID, v);
+    _cmsFree(v ->ContextID, v);
 }
 
 cmsNAMEDCOLORLIST* CMSEXPORT cmsDupNamedColorList(const cmsNAMEDCOLORLIST* v)
@@ -576,11 +606,8 @@
 
     if (Name != NULL) {
 
-        strncpy(NamedColorList ->List[NamedColorList ->nColors].Name, Name,
-                    sizeof(NamedColorList ->List[NamedColorList ->nColors].Name) - 1);
-
-        NamedColorList ->List[NamedColorList ->nColors].
-            Name[sizeof(NamedColorList ->List[NamedColorList ->nColors].Name) - 1] = 0;
+        strncpy(NamedColorList ->List[NamedColorList ->nColors].Name, Name, cmsMAX_PATH-1);
+        NamedColorList ->List[NamedColorList ->nColors].Name[cmsMAX_PATH-1] = 0;
 
     }
     else
@@ -891,7 +918,6 @@
 {
     _cmsDICT* old_dict = (_cmsDICT*) hDict;
     cmsHANDLE hNew;
-    _cmsDICT* new_dict;
     cmsDICTentry *entry;
 
     _cmsAssert(old_dict != NULL);
@@ -899,8 +925,6 @@
     hNew  = cmsDictAlloc(old_dict ->ContextID);
     if (hNew == NULL) return NULL;
 
-    new_dict = (_cmsDICT*) hNew;
-
     // Walk the list freeing all nodes
     entry = old_dict ->head;
     while (entry != NULL) {
--- ./jdk/src/share/native/sun/java2d/cmm/lcms/cmsopt.c	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/native/sun/java2d/cmm/lcms/cmsopt.c	Tue Mar 18 12:35:25 2014 -0700
@@ -27,6 +27,7 @@
 // However, the following notice accompanied the original version of this
 // file:
 //
+
 //---------------------------------------------------------------------------------
 //
 //  Little Color Management System
@@ -81,10 +82,6 @@
     int nInputs;
     int nOutputs;
 
-    // Since there is no limitation of the output number of channels, this buffer holding the connexion CLUT-shaper
-    // has to be dynamically allocated. This is not the case of first step shaper-CLUT, which is limited to max inputs
-    cmsUInt16Number* StageDEF;
-
     _cmsInterpFn16 EvalCurveIn16[MAX_INPUT_DIMENSIONS];       // The maximum number of input channels is known in advance
     cmsInterpParams*  ParamsCurveIn16[MAX_INPUT_DIMENSIONS];
 
@@ -202,8 +199,6 @@
 {
     cmsBool AnyOpt = FALSE, Opt;
 
-    AnyOpt = FALSE;
-
     do {
 
         Opt = FALSE;
@@ -253,6 +248,7 @@
 {
     Prelin16Data* p16 = (Prelin16Data*) D;
     cmsUInt16Number  StageABC[MAX_INPUT_DIMENSIONS];
+    cmsUInt16Number  StageDEF[cmsMAXCHANNELS];
     int i;
 
     for (i=0; i < p16 ->nInputs; i++) {
@@ -260,11 +256,11 @@
         p16 ->EvalCurveIn16[i](&Input[i], &StageABC[i], p16 ->ParamsCurveIn16[i]);
     }
 
-    p16 ->EvalCLUT(StageABC, p16 ->StageDEF, p16 ->CLUTparams);
+    p16 ->EvalCLUT(StageABC, StageDEF, p16 ->CLUTparams);
 
     for (i=0; i < p16 ->nOutputs; i++) {
 
-        p16 ->EvalCurveOut16[i](&p16->StageDEF[i], &Output[i], p16 ->ParamsCurveOut16[i]);
+        p16 ->EvalCurveOut16[i](&StageDEF[i], &Output[i], p16 ->ParamsCurveOut16[i]);
     }
 }
 
@@ -274,7 +270,6 @@
 {
     Prelin16Data* p16 = (Prelin16Data*) ptr;
 
-    _cmsFree(ContextID, p16 ->StageDEF);
     _cmsFree(ContextID, p16 ->EvalCurveOut16);
     _cmsFree(ContextID, p16 ->ParamsCurveOut16);
 
@@ -289,7 +284,6 @@
 
     if (Duped == NULL) return NULL;
 
-    Duped ->StageDEF         = _cmsCalloc(ContextID, p16 ->nOutputs, sizeof(cmsUInt16Number));
     Duped ->EvalCurveOut16   = _cmsDupMem(ContextID, p16 ->EvalCurveOut16, p16 ->nOutputs * sizeof(_cmsInterpFn16));
     Duped ->ParamsCurveOut16 = _cmsDupMem(ContextID, p16 ->ParamsCurveOut16, p16 ->nOutputs * sizeof(cmsInterpParams* ));
 
@@ -328,7 +322,6 @@
     p16 ->EvalCLUT   = ColorMap ->Interpolation.Lerp16;
 
 
-    p16 -> StageDEF = _cmsCalloc(ContextID, p16 ->nOutputs, sizeof(cmsUInt16Number));
     p16 -> EvalCurveOut16 = (_cmsInterpFn16*) _cmsCalloc(ContextID, nOutputs, sizeof(_cmsInterpFn16));
     p16 -> ParamsCurveOut16 = (cmsInterpParams**) _cmsCalloc(ContextID, nOutputs, sizeof(cmsInterpParams* ));
 
@@ -413,7 +406,7 @@
     int        i, index;
 
     if (CLUT -> Type != cmsSigCLutElemType) {
-        cmsSignalError(CLUT->ContextID, cmsERROR_INTERNAL, "(internal) Attempt to PatchLUT on non-lut MPE");
+        cmsSignalError(CLUT->ContextID, cmsERROR_INTERNAL, "(internal) Attempt to PatchLUT on non-lut stage");
         return FALSE;
     }
 
@@ -548,6 +541,10 @@
         for (i=0; i < nOuts; i++) {
 
             cmsToneCurve* InversePostLin = cmsReverseToneCurve(Curves[i]);
+            if (InversePostLin == NULL) {
+                WhiteOut[i] = 0;
+                continue;
+            }
             WhiteOut[i] = cmsEvalToneCurve16(InversePostLin, WhitePointOut[i]);
             cmsFreeToneCurve(InversePostLin);
         }
@@ -575,8 +572,8 @@
 static
 cmsBool OptimizeByResampling(cmsPipeline** Lut, cmsUInt32Number Intent, cmsUInt32Number* InputFormat, cmsUInt32Number* OutputFormat, cmsUInt32Number* dwFlags)
 {
-    cmsPipeline* Src;
-    cmsPipeline* Dest;
+    cmsPipeline* Src = NULL;
+    cmsPipeline* Dest = NULL;
     cmsStage* mpe;
     cmsStage* CLUT;
     cmsStage *KeepPreLin = NULL, *KeepPostLin = NULL;
@@ -589,7 +586,6 @@
     cmsToneCurve** DataSetOut;
     Prelin16Data* p16;
 
-
     // This is a loosy optimization! does not apply in floating-point cases
     if (_cmsFormatterIsFloat(*InputFormat) || _cmsFormatterIsFloat(*OutputFormat)) return FALSE;
 
@@ -603,10 +599,10 @@
 
     Src = *Lut;
 
-   // Named color pipelines cannot be optimized either
-   for (mpe = cmsPipelineGetPtrToFirstStage(Src);
-         mpe != NULL;
-         mpe = cmsStageNext(mpe)) {
+    // Named color pipelines cannot be optimized either
+    for (mpe = cmsPipelineGetPtrToFirstStage(Src);
+        mpe != NULL;
+        mpe = cmsStageNext(mpe)) {
             if (cmsStageType(mpe) == cmsSigNamedColorElemType) return FALSE;
     }
 
@@ -628,7 +624,8 @@
 
                 // All seems ok, proceed.
                 NewPreLin = cmsStageDup(PreLin);
-                cmsPipelineInsertStage(Dest, cmsAT_BEGIN, NewPreLin);
+                if(!cmsPipelineInsertStage(Dest, cmsAT_BEGIN, NewPreLin))
+                    goto Error;
 
                 // Remove prelinearization. Since we have duplicated the curve
                 // in destination LUT, the sampling shoud be applied after this stage.
@@ -642,7 +639,9 @@
     if (CLUT == NULL) return FALSE;
 
     // Add the CLUT to the destination LUT
-    cmsPipelineInsertStage(Dest, cmsAT_END, CLUT);
+    if (!cmsPipelineInsertStage(Dest, cmsAT_END, CLUT)) {
+        goto Error;
+    }
 
     // Postlinearization tables are kept unless indicated by flags
     if (*dwFlags & cmsFLAGS_CLUT_POST_LINEARIZATION) {
@@ -658,7 +657,8 @@
 
                 // All seems ok, proceed.
                 NewPostLin = cmsStageDup(PostLin);
-                cmsPipelineInsertStage(Dest, cmsAT_END, NewPostLin);
+                if (!cmsPipelineInsertStage(Dest, cmsAT_END, NewPostLin))
+                    goto Error;
 
                 // In destination LUT, the sampling shoud be applied after this stage.
                 cmsPipelineUnlinkStage(Src, cmsAT_END, &KeepPostLin);
@@ -669,10 +669,18 @@
     // Now its time to do the sampling. We have to ignore pre/post linearization
     // The source LUT whithout pre/post curves is passed as parameter.
     if (!cmsStageSampleCLut16bit(CLUT, XFormSampler16, (void*) Src, 0)) {
-
+Error:
         // Ops, something went wrong, Restore stages
-        if (KeepPreLin != NULL)  cmsPipelineInsertStage(Src, cmsAT_BEGIN, KeepPreLin);
-        if (KeepPostLin != NULL) cmsPipelineInsertStage(Src, cmsAT_END,   KeepPostLin);
+        if (KeepPreLin != NULL) {
+            if (!cmsPipelineInsertStage(Src, cmsAT_BEGIN, KeepPreLin)) {
+                _cmsAssert(0); // This never happens
+            }
+        }
+        if (KeepPostLin != NULL) {
+            if (!cmsPipelineInsertStage(Src, cmsAT_END,   KeepPostLin)) {
+                _cmsAssert(0); // This never happens
+            }
+        }
         cmsPipelineFree(Dest);
         return FALSE;
     }
@@ -699,12 +707,11 @@
     else {
 
         p16 = PrelinOpt16alloc(Dest ->ContextID,
-                               DataCLUT ->Params,
-                               Dest ->InputChannels,
-                               DataSetIn,
-                               Dest ->OutputChannels,
-                               DataSetOut);
-
+            DataCLUT ->Params,
+            Dest ->InputChannels,
+            DataSetIn,
+            Dest ->OutputChannels,
+            DataSetOut);
 
         _cmsPipelineSetOptimizationParameters(Dest, PrelinEval16, (void*) p16, PrelinOpt16free, Prelin16dup);
     }
@@ -1058,7 +1065,8 @@
     LutPlusCurves = cmsPipelineDup(OriginalLut);
     if (LutPlusCurves == NULL) goto Error;
 
-    cmsPipelineInsertStage(LutPlusCurves, cmsAT_BEGIN, cmsStageAllocToneCurves(OriginalLut ->ContextID, OriginalLut ->InputChannels, TransReverse));
+    if (!cmsPipelineInsertStage(LutPlusCurves, cmsAT_BEGIN, cmsStageAllocToneCurves(OriginalLut ->ContextID, OriginalLut ->InputChannels, TransReverse)))
+        goto Error;
 
     // Create the result LUT
     OptimizedLUT = cmsPipelineAlloc(OriginalLut ->ContextID, OriginalLut ->InputChannels, OriginalLut ->OutputChannels);
@@ -1067,13 +1075,15 @@
     OptimizedPrelinMpe = cmsStageAllocToneCurves(OriginalLut ->ContextID, OriginalLut ->InputChannels, Trans);
 
     // Create and insert the curves at the beginning
-    cmsPipelineInsertStage(OptimizedLUT, cmsAT_BEGIN, OptimizedPrelinMpe);
+    if (!cmsPipelineInsertStage(OptimizedLUT, cmsAT_BEGIN, OptimizedPrelinMpe))
+        goto Error;
 
     // Allocate the CLUT for result
     OptimizedCLUTmpe = cmsStageAllocCLut16bit(OriginalLut ->ContextID, nGridPoints, OriginalLut ->InputChannels, OriginalLut ->OutputChannels, NULL);
 
     // Add the CLUT to the destination LUT
-    cmsPipelineInsertStage(OptimizedLUT, cmsAT_END, OptimizedCLUTmpe);
+    if (!cmsPipelineInsertStage(OptimizedLUT, cmsAT_END, OptimizedCLUTmpe))
+        goto Error;
 
     // Resample the LUT
     if (!cmsStageSampleCLut16bit(OptimizedCLUTmpe, XFormSampler16, (void*) LutPlusCurves, 0)) goto Error;
@@ -1201,13 +1211,14 @@
     for (i=0; i < nCurves; i++) {
 
         c16->Curves[i] = _cmsCalloc(ContextID, nElements, sizeof(cmsUInt16Number));
+
         if (c16->Curves[i] == NULL) {
+
             for (j=0; j < i; j++) {
                 _cmsFree(ContextID, c16->Curves[j]);
             }
             _cmsFree(ContextID, c16->Curves);
             _cmsFree(ContextID, c16);
-
             return NULL;
         }
 
@@ -1336,7 +1347,8 @@
     // Maybe the curves are linear at the end
     if (!AllCurvesAreLinear(ObtainedCurves)) {
 
-        cmsPipelineInsertStage(Dest, cmsAT_BEGIN, ObtainedCurves);
+        if (!cmsPipelineInsertStage(Dest, cmsAT_BEGIN, ObtainedCurves))
+            goto Error;
 
         // If the curves are to be applied in 8 bits, we can save memory
         if (_cmsFormatterIs8bit(*InputFormat)) {
@@ -1344,6 +1356,7 @@
             _cmsStageToneCurvesData* Data = (_cmsStageToneCurvesData*) ObtainedCurves ->Data;
              Curves16Data* c16 = CurvesAlloc(Dest ->ContextID, Data ->nCurves, 256, Data ->TheCurves);
 
+             if (c16 == NULL) goto Error;
              *dwFlags |= cmsFLAGS_NOCACHE;
             _cmsPipelineSetOptimizationParameters(Dest, FastEvaluateCurves8, c16, CurvesFree, CurvesDup);
 
@@ -1353,6 +1366,7 @@
             _cmsStageToneCurvesData* Data = (_cmsStageToneCurvesData*) cmsStageData(ObtainedCurves);
              Curves16Data* c16 = CurvesAlloc(Dest ->ContextID, Data ->nCurves, 65536, Data ->TheCurves);
 
+             if (c16 == NULL) goto Error;
              *dwFlags |= cmsFLAGS_NOCACHE;
             _cmsPipelineSetOptimizationParameters(Dest, FastEvaluateCurves16, c16, CurvesFree, CurvesDup);
         }
@@ -1362,7 +1376,8 @@
         // LUT optimizes to nothing. Set the identity LUT
         cmsStageFree(ObtainedCurves);
 
-        cmsPipelineInsertStage(Dest, cmsAT_BEGIN, cmsStageAllocIdentity(Dest ->ContextID, Src ->InputChannels));
+        if (!cmsPipelineInsertStage(Dest, cmsAT_BEGIN, cmsStageAllocIdentity(Dest ->ContextID, Src ->InputChannels)))
+            goto Error;
 
         *dwFlags |= cmsFLAGS_NOCACHE;
         _cmsPipelineSetOptimizationParameters(Dest, FastIdentity16, (void*) Dest, NULL, NULL);
@@ -1592,10 +1607,14 @@
     if (!Dest) return FALSE;
 
     // Assamble the new LUT
-    cmsPipelineInsertStage(Dest, cmsAT_BEGIN, cmsStageDup(Curve1));
+    if (!cmsPipelineInsertStage(Dest, cmsAT_BEGIN, cmsStageDup(Curve1)))
+        goto Error;
+
     if (!IdentityMat)
-        cmsPipelineInsertStage(Dest, cmsAT_END, cmsStageAllocMatrix(Dest ->ContextID, 3, 3, (const cmsFloat64Number*) &res, Data2 ->Offset));
-    cmsPipelineInsertStage(Dest, cmsAT_END, cmsStageDup(Curve2));
+        if (!cmsPipelineInsertStage(Dest, cmsAT_END, cmsStageAllocMatrix(Dest ->ContextID, 3, 3, (const cmsFloat64Number*) &res, Data2 ->Offset)))
+            goto Error;
+    if (!cmsPipelineInsertStage(Dest, cmsAT_END, cmsStageDup(Curve2)))
+        goto Error;
 
     // If identity on matrix, we can further optimize the curves, so call the join curves routine
     if (IdentityMat) {
@@ -1617,6 +1636,10 @@
     cmsPipelineFree(Src);
     *Lut = Dest;
     return TRUE;
+Error:
+    // Leave Src unchanged
+    cmsPipelineFree(Dest);
+    return FALSE;
 }
 
 
@@ -1646,7 +1669,7 @@
 static _cmsOptimizationCollection* OptimizationCollection = DefaultOptimization;
 
 // Register new ways to optimize
-cmsBool  _cmsRegisterOptimizationPlugin(cmsPluginBase* Data)
+cmsBool  _cmsRegisterOptimizationPlugin(cmsContext id, cmsPluginBase* Data)
 {
     cmsPluginOptimization* Plugin = (cmsPluginOptimization*) Data;
     _cmsOptimizationCollection* fl;
@@ -1660,7 +1683,7 @@
     // Optimizer callback is required
     if (Plugin ->OptimizePtr == NULL) return FALSE;
 
-    fl = (_cmsOptimizationCollection*) _cmsPluginMalloc(sizeof(_cmsOptimizationCollection));
+    fl = (_cmsOptimizationCollection*) _cmsPluginMalloc(id, sizeof(_cmsOptimizationCollection));
     if (fl == NULL) return FALSE;
 
     // Copy the parameters
--- ./jdk/src/share/native/sun/java2d/cmm/lcms/cmspack.c	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/native/sun/java2d/cmm/lcms/cmspack.c	Tue Mar 18 12:35:25 2014 -0700
@@ -317,6 +317,23 @@
 }
 
 static
+cmsUInt8Number* Unroll3BytesSkip1SwapSwapFirst(register _cmsTRANSFORM* info,
+                                              register cmsUInt16Number wIn[],
+                                              register cmsUInt8Number* accum,
+                                              register cmsUInt32Number Stride)
+{
+    wIn[2] = FROM_8_TO_16(*accum); accum++; // B
+    wIn[1] = FROM_8_TO_16(*accum); accum++; // G
+    wIn[0] = FROM_8_TO_16(*accum); accum++; // R
+    accum++; // A
+
+    return accum;
+
+    cmsUNUSED_PARAMETER(info);
+    cmsUNUSED_PARAMETER(Stride);
+}
+
+static
 cmsUInt8Number* Unroll3BytesSkip1SwapFirst(register _cmsTRANSFORM* info,
                                            register cmsUInt16Number wIn[],
                                            register cmsUInt8Number* accum,
@@ -2901,6 +2918,9 @@
     { CHANNELS_SH(3)|EXTRA_SH(1)|BYTES_SH(1)|DOSWAP_SH(1),     ANYSPACE,  Unroll3BytesSkip1Swap},
     { CHANNELS_SH(3)|EXTRA_SH(1)|BYTES_SH(1)|SWAPFIRST_SH(1),  ANYSPACE,  Unroll3BytesSkip1SwapFirst},
 
+    { CHANNELS_SH(3)|EXTRA_SH(1)|BYTES_SH(1)|DOSWAP_SH(1)|SWAPFIRST_SH(1),
+                                                               ANYSPACE,  Unroll3BytesSkip1SwapSwapFirst},
+
     { CHANNELS_SH(4)|BYTES_SH(1),                              ANYSPACE,  Unroll4Bytes},
     { CHANNELS_SH(4)|BYTES_SH(1)|FLAVOR_SH(1),                 ANYSPACE,  Unroll4BytesReverse},
     { CHANNELS_SH(4)|BYTES_SH(1)|SWAPFIRST_SH(1),              ANYSPACE,  Unroll4BytesSwapFirst},
@@ -3166,7 +3186,7 @@
 
 
 // Formatters management
-cmsBool  _cmsRegisterFormattersPlugin(cmsPluginBase* Data)
+cmsBool  _cmsRegisterFormattersPlugin(cmsContext id, cmsPluginBase* Data)
 {
     cmsPluginFormatters* Plugin = (cmsPluginFormatters*) Data;
     cmsFormattersFactoryList* fl ;
@@ -3178,7 +3198,7 @@
           return TRUE;
     }
 
-    fl = (cmsFormattersFactoryList*) _cmsPluginMalloc(sizeof(cmsFormattersFactoryList));
+    fl = (cmsFormattersFactoryList*) _cmsPluginMalloc(id, sizeof(cmsFormattersFactoryList));
     if (fl == NULL) return FALSE;
 
     fl ->Factory    = Plugin ->FormattersFactory;
--- ./jdk/src/share/native/sun/java2d/cmm/lcms/cmspcs.c	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/native/sun/java2d/cmm/lcms/cmspcs.c	Tue Mar 18 12:35:25 2014 -0700
@@ -898,9 +898,11 @@
 {
     switch (ColorSpace) {
 
+    case cmsSigMCH1Data:
     case cmsSig1colorData:
     case cmsSigGrayData: return 1;
 
+    case cmsSigMCH2Data:
     case cmsSig2colorData:  return 2;
 
     case cmsSigXYZData:
@@ -912,10 +914,12 @@
     case cmsSigHsvData:
     case cmsSigHlsData:
     case cmsSigCmyData:
+    case cmsSigMCH3Data:
     case cmsSig3colorData:  return 3;
 
     case cmsSigLuvKData:
     case cmsSigCmykData:
+    case cmsSigMCH4Data:
     case cmsSig4colorData:  return 4;
 
     case cmsSigMCH5Data:
--- ./jdk/src/share/native/sun/java2d/cmm/lcms/cmsplugin.c	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/native/sun/java2d/cmm/lcms/cmsplugin.c	Tue Mar 18 12:35:25 2014 -0700
@@ -125,10 +125,14 @@
     pOut[0] = pIn[7];
 
 #else
-
     _cmsAssert(Result != NULL);
 
+#  ifdef CMS_DONT_USE_INT64
+    (*Result)[0] = QWord[0];
+    (*Result)[1] = QWord[1];
+#  else
     *Result = *QWord;
+#  endif
 #endif
 }
 
@@ -543,10 +547,10 @@
 static _cmsSubAllocator* PluginPool = NULL;
 
 // Specialized malloc for plug-ins, that is freed upon exit.
-void* _cmsPluginMalloc(cmsUInt32Number size)
+void* _cmsPluginMalloc(cmsContext id, cmsUInt32Number size)
 {
     if (PluginPool == NULL)
-        PluginPool = _cmsCreateSubAlloc(0, 4*1024);
+        PluginPool = _cmsCreateSubAlloc(id, 4*1024);
 
     return _cmsSubAlloc(PluginPool, size);
 }
@@ -555,6 +559,11 @@
 // Main plug-in dispatcher
 cmsBool CMSEXPORT cmsPlugin(void* Plug_in)
 {
+  return cmsPluginTHR(NULL, Plug_in);
+}
+
+cmsBool CMSEXPORT cmsPluginTHR(cmsContext id, void* Plug_in)
+{
     cmsPluginBase* Plugin;
 
     for (Plugin = (cmsPluginBase*) Plug_in;
@@ -583,35 +592,35 @@
                     break;
 
                 case cmsPluginTagTypeSig:
-                    if (!_cmsRegisterTagTypePlugin(Plugin)) return FALSE;
+                    if (!_cmsRegisterTagTypePlugin(id, Plugin)) return FALSE;
                     break;
 
                 case cmsPluginTagSig:
-                    if (!_cmsRegisterTagPlugin(Plugin)) return FALSE;
+                    if (!_cmsRegisterTagPlugin(id, Plugin)) return FALSE;
                     break;
 
                 case cmsPluginFormattersSig:
-                    if (!_cmsRegisterFormattersPlugin(Plugin)) return FALSE;
+                    if (!_cmsRegisterFormattersPlugin(id, Plugin)) return FALSE;
                     break;
 
                 case cmsPluginRenderingIntentSig:
-                    if (!_cmsRegisterRenderingIntentPlugin(Plugin)) return FALSE;
+                    if (!_cmsRegisterRenderingIntentPlugin(id, Plugin)) return FALSE;
                     break;
 
                 case cmsPluginParametricCurveSig:
-                    if (!_cmsRegisterParametricCurvesPlugin(Plugin)) return FALSE;
+                    if (!_cmsRegisterParametricCurvesPlugin(id, Plugin)) return FALSE;
                     break;
 
                 case cmsPluginMultiProcessElementSig:
-                    if (!_cmsRegisterMultiProcessElementPlugin(Plugin)) return FALSE;
+                    if (!_cmsRegisterMultiProcessElementPlugin(id, Plugin)) return FALSE;
                     break;
 
                 case cmsPluginOptimizationSig:
-                    if (!_cmsRegisterOptimizationPlugin(Plugin)) return FALSE;
+                    if (!_cmsRegisterOptimizationPlugin(id, Plugin)) return FALSE;
                     break;
 
                 case cmsPluginTransformSig:
-                    if (!_cmsRegisterTransformPlugin(Plugin)) return FALSE;
+                    if (!_cmsRegisterTransformPlugin(id, Plugin)) return FALSE;
                     break;
 
                 default:
@@ -630,14 +639,14 @@
 {
     _cmsRegisterMemHandlerPlugin(NULL);
     _cmsRegisterInterpPlugin(NULL);
-    _cmsRegisterTagTypePlugin(NULL);
-    _cmsRegisterTagPlugin(NULL);
-    _cmsRegisterFormattersPlugin(NULL);
-    _cmsRegisterRenderingIntentPlugin(NULL);
-    _cmsRegisterParametricCurvesPlugin(NULL);
-    _cmsRegisterMultiProcessElementPlugin(NULL);
-    _cmsRegisterOptimizationPlugin(NULL);
-    _cmsRegisterTransformPlugin(NULL);
+    _cmsRegisterTagTypePlugin(NULL, NULL);
+    _cmsRegisterTagPlugin(NULL, NULL);
+    _cmsRegisterFormattersPlugin(NULL, NULL);
+    _cmsRegisterRenderingIntentPlugin(NULL, NULL);
+    _cmsRegisterParametricCurvesPlugin(NULL, NULL);
+    _cmsRegisterMultiProcessElementPlugin(NULL, NULL);
+    _cmsRegisterOptimizationPlugin(NULL, NULL);
+    _cmsRegisterTransformPlugin(NULL, NULL);
 
     if (PluginPool != NULL)
         _cmsSubAllocDestroy(PluginPool);
--- ./jdk/src/share/native/sun/java2d/cmm/lcms/cmsps2.c	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/native/sun/java2d/cmm/lcms/cmsps2.c	Tue Mar 18 12:35:25 2014 -0700
@@ -806,7 +806,6 @@
 
     mpe = Pipeline ->Elements;
 
-
     switch (cmsStageInputChannels(mpe)) {
     case 3:
 
@@ -838,8 +837,6 @@
         mpe = mpe ->Next;
     }
 
-
-
     if (cmsStageType(mpe) == cmsSigCLutElemType) {
 
             _cmsIOPrintf(m, "/Table ");
@@ -854,7 +851,6 @@
     _cmsIOPrintf(m, "   >>\n");
     _cmsIOPrintf(m, "]\n");
 
-
     return 1;
 }
 
@@ -950,6 +946,7 @@
 
             rc = EmitCIEBasedDEF(m, DeviceLink, Intent, &BlackPointAdaptedToD50);
             cmsPipelineFree(DeviceLink);
+            if (rc == 0) return 0;
             }
             break;
 
--- ./jdk/src/share/native/sun/java2d/cmm/lcms/cmssamp.c	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/native/sun/java2d/cmm/lcms/cmssamp.c	Tue Mar 18 12:35:25 2014 -0700
@@ -56,6 +56,8 @@
 #include "lcms2_internal.h"
 
 
+#define cmsmin(a, b) (((a) < (b)) ? (a) : (b))
+#define cmsmax(a, b) (((a) > (b)) ? (a) : (b))
 
 // This file contains routines for resampling and LUT optimization, black point detection
 // and black preservation.
@@ -67,13 +69,13 @@
 static
 cmsHTRANSFORM CreateRoundtripXForm(cmsHPROFILE hProfile, cmsUInt32Number nIntent)
 {
-    cmsHPROFILE hLab = cmsCreateLab4Profile(NULL);
+    cmsContext ContextID = cmsGetProfileContextID(hProfile);
+    cmsHPROFILE hLab = cmsCreateLab4ProfileTHR(ContextID, NULL);
     cmsHTRANSFORM xform;
     cmsBool BPC[4] = { FALSE, FALSE, FALSE, FALSE };
     cmsFloat64Number States[4] = { 1.0, 1.0, 1.0, 1.0 };
     cmsHPROFILE hProfiles[4];
     cmsUInt32Number Intents[4];
-    cmsContext ContextID = cmsGetProfileContextID(hProfile);
 
     hProfiles[0] = hLab; hProfiles[1] = hProfile; hProfiles[2] = hProfile; hProfiles[3] = hLab;
     Intents[0]   = INTENT_RELATIVE_COLORIMETRIC; Intents[1] = nIntent; Intents[2] = INTENT_RELATIVE_COLORIMETRIC; Intents[3] = INTENT_RELATIVE_COLORIMETRIC;
@@ -141,8 +143,8 @@
     cmsCloseProfile(hLab);
 
     if (xform == NULL) {
+
         // Something went wrong. Get rid of open resources and return zero as black
-
         BlackPoint -> X = BlackPoint ->Y = BlackPoint -> Z = 0.0;
         return FALSE;
     }
@@ -173,7 +175,6 @@
 // Lab (0, 0, 0) -> [Perceptual] Profile -> CMYK -> [Rel. colorimetric] Profile -> Lab
 static
 cmsBool BlackPointUsingPerceptualBlack(cmsCIEXYZ* BlackPoint, cmsHPROFILE hProfile)
-
 {
     cmsHTRANSFORM hRoundTrip;
     cmsCIELab LabIn, LabOut;
@@ -218,17 +219,27 @@
 // involves to turn BP to neutral and to use only L component.
 cmsBool CMSEXPORT cmsDetectBlackPoint(cmsCIEXYZ* BlackPoint, cmsHPROFILE hProfile, cmsUInt32Number Intent, cmsUInt32Number dwFlags)
 {
+    cmsProfileClassSignature devClass;
 
-    // Zero for black point
-    if (cmsGetDeviceClass(hProfile) == cmsSigLinkClass) {
+    // Make sure the device class is adequate
+    devClass = cmsGetDeviceClass(hProfile);
+    if (devClass == cmsSigLinkClass ||
+        devClass == cmsSigAbstractClass ||
+        devClass == cmsSigNamedColorClass) {
+            BlackPoint -> X = BlackPoint ->Y = BlackPoint -> Z = 0.0;
+            return FALSE;
+    }
 
-        BlackPoint -> X = BlackPoint ->Y = BlackPoint -> Z = 0.0;
-        return FALSE;
+    // Make sure intent is adequate
+    if (Intent != INTENT_PERCEPTUAL &&
+        Intent != INTENT_RELATIVE_COLORIMETRIC &&
+        Intent != INTENT_SATURATION) {
+            BlackPoint -> X = BlackPoint ->Y = BlackPoint -> Z = 0.0;
+            return FALSE;
     }
 
     // v4 + perceptual & saturation intents does have its own black point, and it is
     // well specified enough to use it. Black point tag is deprecated in V4.
-
     if ((cmsGetEncodedICCversion(hProfile) >= 0x4000000) &&
         (Intent == INTENT_PERCEPTUAL || Intent == INTENT_SATURATION)) {
 
@@ -303,7 +314,7 @@
 {
     double sum_x = 0, sum_x2 = 0, sum_x3 = 0, sum_x4 = 0;
     double sum_y = 0, sum_yx = 0, sum_yx2 = 0;
-    double disc;
+    double d, a, b, c;
     int i;
     cmsMAT3 m;
     cmsVEC3 v, res;
@@ -333,14 +344,32 @@
 
     if (!_cmsMAT3solve(&res, &m, &v)) return 0;
 
-    // y = t x2 + u x + c
-    // x = ( - u + Sqrt( u^2 - 4 t c ) ) / ( 2 t )
-    disc = res.n[1]*res.n[1] - 4.0 * res.n[0] * res.n[2];
-    if (disc < 0) return -1;
 
-    return ( -1.0 * res.n[1] + sqrt( disc )) / (2.0 * res.n[0]);
+    a = res.n[2];
+    b = res.n[1];
+    c = res.n[0];
+
+    if (fabs(a) < 1.0E-10) {
+
+        return cmsmin(0, cmsmax(50, -c/b ));
+    }
+    else {
+
+         d = b*b - 4.0 * a * c;
+         if (d <= 0) {
+             return 0;
+         }
+         else {
+
+             double rt = (-b + sqrt(d)) / (2.0 * a);
+
+             return cmsmax(0, cmsmin(50, rt));
+         }
+   }
+
 }
 
+/*
 static
 cmsBool IsMonotonic(int n, const cmsFloat64Number Table[])
 {
@@ -361,6 +390,7 @@
 
     return TRUE;
 }
+*/
 
 // Calculates the black point of a destination profile.
 // This algorithm comes from the Adobe paper disclosing its black point compensation method.
@@ -369,21 +399,30 @@
     cmsColorSpaceSignature ColorSpace;
     cmsHTRANSFORM hRoundTrip = NULL;
     cmsCIELab InitialLab, destLab, Lab;
+    cmsFloat64Number inRamp[256], outRamp[256];
+    cmsFloat64Number MinL, MaxL;
+    cmsBool NearlyStraightMidrange = TRUE;
+    cmsFloat64Number yRamp[256];
+    cmsFloat64Number x[256], y[256];
+    cmsFloat64Number lo, hi;
+    int n, l;
+    cmsProfileClassSignature devClass;
 
-    cmsFloat64Number MinL, MaxL;
-    cmsBool NearlyStraightMidRange = FALSE;
-    cmsFloat64Number L;
-    cmsFloat64Number x[101], y[101];
-    cmsFloat64Number lo, hi, NonMonoMin;
-    int n, l, i, NonMonoIndx;
-
+    // Make sure the device class is adequate
+    devClass = cmsGetDeviceClass(hProfile);
+    if (devClass == cmsSigLinkClass ||
+        devClass == cmsSigAbstractClass ||
+        devClass == cmsSigNamedColorClass) {
+            BlackPoint -> X = BlackPoint ->Y = BlackPoint -> Z = 0.0;
+            return FALSE;
+    }
 
     // Make sure intent is adequate
     if (Intent != INTENT_PERCEPTUAL &&
         Intent != INTENT_RELATIVE_COLORIMETRIC &&
         Intent != INTENT_SATURATION) {
-        BlackPoint -> X = BlackPoint ->Y = BlackPoint -> Z = 0.0;
-        return FALSE;
+            BlackPoint -> X = BlackPoint ->Y = BlackPoint -> Z = 0.0;
+            return FALSE;
     }
 
 
@@ -415,10 +454,8 @@
         return cmsDetectBlackPoint(BlackPoint, hProfile, Intent, dwFlags);
     }
 
-    // It is one of the valid cases!, presto chargo hocus pocus, go for the Adobe magic
+    // It is one of the valid cases!, use Adobe algorithm
 
-    // Step 1
-    // ======
 
     // Set a first guess, that should work on good profiles.
     if (Intent == INTENT_RELATIVE_COLORIMETRIC) {
@@ -449,71 +486,68 @@
     hRoundTrip = CreateRoundtripXForm(hProfile, Intent);
     if (hRoundTrip == NULL)  return FALSE;
 
-    // Calculate Min L*
-    Lab = InitialLab;
-    Lab.L = 0;
-    cmsDoTransform(hRoundTrip, &Lab, &destLab, 1);
-    MinL = destLab.L;
+    // Compute ramps
 
-    // Calculate Max L*
-    Lab = InitialLab;
-    Lab.L = 100;
-    cmsDoTransform(hRoundTrip, &Lab, &destLab, 1);
-    MaxL = destLab.L;
+    for (l=0; l < 256; l++) {
 
-    // Step 3
-    // ======
+        Lab.L = (cmsFloat64Number) (l * 100.0) / 255.0;
+        Lab.a = cmsmin(50, cmsmax(-50, InitialLab.a));
+        Lab.b = cmsmin(50, cmsmax(-50, InitialLab.b));
 
-    // check if quadratic estimation needs to be done.
+        cmsDoTransform(hRoundTrip, &Lab, &destLab, 1);
+
+        inRamp[l]  = Lab.L;
+        outRamp[l] = destLab.L;
+    }
+
+    // Make monotonic
+    for (l = 254; l > 0; --l) {
+        outRamp[l] = cmsmin(outRamp[l], outRamp[l+1]);
+    }
+
+    // Check
+    if (! (outRamp[0] < outRamp[255])) {
+
+        cmsDeleteTransform(hRoundTrip);
+        BlackPoint -> X = BlackPoint ->Y = BlackPoint -> Z = 0.0;
+        return FALSE;
+    }
+
+
+    // Test for mid range straight (only on relative colorimetric)
+
+    NearlyStraightMidrange = TRUE;
+    MinL = outRamp[0]; MaxL = outRamp[255];
     if (Intent == INTENT_RELATIVE_COLORIMETRIC) {
 
-        // Conceptually, this code tests how close the source l and converted L are to one another in the mid-range
-        // of the values. If the converted ramp of L values is close enough to a straight line y=x, then InitialLab
-        // is good enough to be the DestinationBlackPoint,
-        NearlyStraightMidRange = TRUE;
+        for (l=0; l < 256; l++) {
 
-        for (l=0; l <= 100; l++) {
+            if (! ((inRamp[l] <= MinL + 0.2 * (MaxL - MinL) ) ||
+                (fabs(inRamp[l] - outRamp[l]) < 4.0 )))
+                NearlyStraightMidrange = FALSE;
+        }
 
-            Lab.L = l;
-            Lab.a = InitialLab.a;
-            Lab.b = InitialLab.b;
+        // If the mid range is straight (as determined above) then the
+        // DestinationBlackPoint shall be the same as initialLab.
+        // Otherwise, the DestinationBlackPoint shall be determined
+        // using curve fitting.
 
-            cmsDoTransform(hRoundTrip, &Lab, &destLab, 1);
+        if (NearlyStraightMidrange) {
 
-            L = destLab.L;
-
-            // Check the mid range in 20% after MinL
-            if (L > (MinL + 0.2 * (MaxL - MinL))) {
-
-                // Is close enough?
-                if (fabs(L - l) > 4.0) {
-
-                    // Too far away, profile is buggy!
-                    NearlyStraightMidRange = FALSE;
-                    break;
-                }
-            }
+            cmsLab2XYZ(NULL, BlackPoint, &InitialLab);
+            cmsDeleteTransform(hRoundTrip);
+            return TRUE;
         }
     }
-    else {
-        // Check is always performed for perceptual and saturation intents
-        NearlyStraightMidRange = FALSE;
-    }
 
 
-    // If no furter checking is needed, we are done
-    if (NearlyStraightMidRange) {
-
-        cmsLab2XYZ(NULL, BlackPoint, &InitialLab);
-        cmsDeleteTransform(hRoundTrip);
-        return TRUE;
-    }
-
-    // The round-trip curve normally looks like a nearly constant section at the black point,
+    // curve fitting: The round-trip curve normally looks like a nearly constant section at the black point,
     // with a corner and a nearly straight line to the white point.
 
-    // STEP 4
-    // =======
+    for (l=0; l < 256; l++) {
+
+        yRamp[l] = (outRamp[l] - MinL) / (MaxL - MinL);
+    }
 
     // find the black point using the least squares error quadratic curve fitting
 
@@ -528,62 +562,32 @@
         hi = 0.25;
     }
 
-    // Capture points for the fitting.
+    // Capture shadow points for the fitting.
     n = 0;
-    for (l=0; l <= 100; l++) {
+    for (l=0; l < 256; l++) {
 
-        cmsFloat64Number ff;
-
-        Lab.L = (cmsFloat64Number) l;
-        Lab.a = InitialLab.a;
-        Lab.b = InitialLab.b;
-
-        cmsDoTransform(hRoundTrip, &Lab, &destLab, 1);
-
-        ff = (destLab.L - MinL)/(MaxL - MinL);
+        cmsFloat64Number ff = yRamp[l];
 
         if (ff >= lo && ff < hi) {
-
-            x[n] = Lab.L;
-            y[n] = ff;
+            x[n] = inRamp[l];
+            y[n] = yRamp[l];
             n++;
         }
-
-    }
-
-    // This part is not on the Adobe paper, but I found is necessary for getting any result.
-
-    if (IsMonotonic(n, y)) {
-
-        // Monotonic means lower point is stil valid
-        cmsLab2XYZ(NULL, BlackPoint, &InitialLab);
-        cmsDeleteTransform(hRoundTrip);
-        return TRUE;
-    }
-
-    // No suitable points, regret and use safer algorithm
-    if (n == 0) {
-        cmsDeleteTransform(hRoundTrip);
-        return cmsDetectBlackPoint(BlackPoint, hProfile, Intent, dwFlags);
-    }
-
-
-    NonMonoMin = 100;
-    NonMonoIndx = 0;
-    for (i=0; i < n; i++) {
-
-        if (y[i] < NonMonoMin) {
-            NonMonoIndx = i;
-            NonMonoMin = y[i];
-        }
     }
 
-    Lab.L = x[NonMonoIndx];
+
+    // No suitable points
+    if (n < 3 ) {
+        cmsDeleteTransform(hRoundTrip);
+        BlackPoint -> X = BlackPoint ->Y = BlackPoint -> Z = 0.0;
+        return FALSE;
+    }
+
 
     // fit and get the vertex of quadratic curve
     Lab.L = RootOfLeastSquaresFitQuadraticCurve(n, x, y);
 
-    if (Lab.L < 0.0 || Lab.L > 50.0) { // clip to zero L* if the vertex is negative
+    if (Lab.L < 0.0) { // clip to zero L* if the vertex is negative
         Lab.L = 0;
     }
 
--- ./jdk/src/share/native/sun/java2d/cmm/lcms/cmstypes.c	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/native/sun/java2d/cmm/lcms/cmstypes.c	Tue Mar 18 12:35:25 2014 -0700
@@ -91,7 +91,7 @@
 
 // Register a new type handler. This routine is shared between normal types and MPE
 static
-cmsBool RegisterTypesPlugin(cmsPluginBase* Data, _cmsTagTypeLinkedList* LinkedList, cmsUInt32Number DefaultListCount)
+cmsBool RegisterTypesPlugin(cmsContext id, cmsPluginBase* Data, _cmsTagTypeLinkedList* LinkedList, cmsUInt32Number DefaultListCount)
 {
     cmsPluginTagType* Plugin = (cmsPluginTagType*) Data;
     _cmsTagTypeLinkedList *pt, *Anterior = NULL;
@@ -118,7 +118,7 @@
     }
 
     // Registering happens in plug-in memory pool
-    pt = (_cmsTagTypeLinkedList*) _cmsPluginMalloc(sizeof(_cmsTagTypeLinkedList));
+    pt = (_cmsTagTypeLinkedList*) _cmsPluginMalloc(id, sizeof(_cmsTagTypeLinkedList));
     if (pt == NULL) return FALSE;
 
     pt ->Handler   = Plugin ->Handler;
@@ -208,10 +208,10 @@
     cmsUInt32Number *ElementOffsets = NULL, *ElementSizes = NULL;
 
     // Let's take the offsets to each element
-    ElementOffsets = (cmsUInt32Number *) _cmsCalloc(io ->ContextID, Count, sizeof(cmsUInt32Number *));
+    ElementOffsets = (cmsUInt32Number *) _cmsCalloc(io ->ContextID, Count, sizeof(cmsUInt32Number));
     if (ElementOffsets == NULL) goto Error;
 
-    ElementSizes = (cmsUInt32Number *) _cmsCalloc(io ->ContextID, Count, sizeof(cmsUInt32Number *));
+    ElementSizes = (cmsUInt32Number *) _cmsCalloc(io ->ContextID, Count, sizeof(cmsUInt32Number));
     if (ElementSizes == NULL) goto Error;
 
     for (i=0; i < Count; i++) {
@@ -257,10 +257,10 @@
     cmsUInt32Number *ElementOffsets = NULL, *ElementSizes = NULL;
 
      // Create table
-    ElementOffsets = (cmsUInt32Number *) _cmsCalloc(io ->ContextID, Count, sizeof(cmsUInt32Number *));
+    ElementOffsets = (cmsUInt32Number *) _cmsCalloc(io ->ContextID, Count, sizeof(cmsUInt32Number));
     if (ElementOffsets == NULL) goto Error;
 
-    ElementSizes = (cmsUInt32Number *) _cmsCalloc(io ->ContextID, Count, sizeof(cmsUInt32Number *));
+    ElementSizes = (cmsUInt32Number *) _cmsCalloc(io ->ContextID, Count, sizeof(cmsUInt32Number));
     if (ElementSizes == NULL) goto Error;
 
     // Keep starting position of curve offsets
@@ -456,6 +456,7 @@
 void* Type_Chromaticity_Dup(struct _cms_typehandler_struct* self, const void *Ptr, cmsUInt32Number n)
 {
     return _cmsDupMem(self ->ContextID, Ptr, sizeof(cmsCIExyYTRIPLE));
+
     cmsUNUSED_PARAMETER(n);
 }
 
@@ -1106,8 +1107,6 @@
 {
     cmsUInt32Number Count;
     cmsToneCurve* NewGamma;
-    cmsUInt16Number Linear[2] = { 0, 0xffff };
-
 
     *nItems = 0;
     if (!_cmsReadUInt32Number(io, &Count)) return NULL;
@@ -1115,11 +1114,14 @@
     switch (Count) {
 
            case 0:   // Linear.
-
-               NewGamma = cmsBuildTabulatedToneCurve16(self ->ContextID, 2, Linear);
-               if (!NewGamma) return NULL;
-               *nItems = 1;
-               return NewGamma;
+               {
+                   cmsFloat64Number SingleGamma = 1.0;
+
+                   NewGamma = cmsBuildParametricToneCurve(self ->ContextID, 1, &SingleGamma);
+                   if (!NewGamma) return NULL;
+                   *nItems = 1;
+                   return NewGamma;
+               }
 
            case 1:  // Specified as the exponent of gamma function
                {
@@ -1210,6 +1212,7 @@
     if (ICCVersion < 4.0) return cmsSigCurveType;
     if (Curve ->nSegments != 1) return cmsSigCurveType;          // Only 1-segment curves can be saved as parametric
     if (Curve ->Segments[0].Type < 0) return cmsSigCurveType;    // Only non-inverted curves
+    if (Curve ->Segments[0].Type > 5) return cmsSigCurveType;    // Only ICC parametric curves
 
     return cmsSigParametricCurveType;
 }
@@ -1386,6 +1389,9 @@
 {
     cmsICCMeasurementConditions mc;
 
+
+    memset(&mc, 0, sizeof(mc));
+
     if (!_cmsReadUInt32Number(io, &mc.Observer)) return NULL;
     if (!_cmsReadXYZNumber(io,    &mc.Backing)) return NULL;
     if (!_cmsReadUInt32Number(io, &mc.Geometry)) return NULL;
@@ -1640,7 +1646,6 @@
 static
 cmsBool  Read8bitTables(cmsContext ContextID, cmsIOHANDLER* io, cmsPipeline* lut, int nChannels)
 {
-    cmsStage* mpe;
     cmsUInt8Number* Temp = NULL;
     int i, j;
     cmsToneCurve* Tables[cmsMAXCHANNELS];
@@ -1669,11 +1674,8 @@
     _cmsFree(ContextID, Temp);
     Temp = NULL;
 
-
-    mpe = cmsStageAllocToneCurves(ContextID, nChannels, Tables);
-    if (mpe == NULL) goto Error;
-
-    cmsPipelineInsertStage(lut, cmsAT_END, mpe);
+    if (!cmsPipelineInsertStage(lut, cmsAT_END, cmsStageAllocToneCurves(ContextID, nChannels, Tables)))
+        goto Error;
 
     for (i=0; i < nChannels; i++)
         cmsFreeToneCurve(Tables[i]);
@@ -1701,21 +1703,30 @@
 
         if (Tables) {
 
-            if (Tables ->TheCurves[i]->nEntries != 256) {
-                cmsSignalError(ContextID, cmsERROR_RANGE, "LUT8 needs 256 entries on prelinearization");
-                return FALSE;
+            // Usual case of identity curves
+            if ((Tables ->TheCurves[i]->nEntries == 2) &&
+                (Tables->TheCurves[i]->Table16[0] == 0) &&
+                (Tables->TheCurves[i]->Table16[1] == 65535)) {
+
+                    for (j=0; j < 256; j++) {
+                        if (!_cmsWriteUInt8Number(io, (cmsUInt8Number) j)) return FALSE;
+                    }
             }
-
-        }
-
-        for (j=0; j < 256; j++) {
-
-            if (Tables != NULL)
-                val = (cmsUInt8Number) FROM_16_TO_8(Tables->TheCurves[i]->Table16[j]);
             else
-                val = (cmsUInt8Number) j;
-
-            if (!_cmsWriteUInt8Number(io, val)) return FALSE;
+                if (Tables ->TheCurves[i]->nEntries != 256) {
+                    cmsSignalError(ContextID, cmsERROR_RANGE, "LUT8 needs 256 entries on prelinearization");
+                    return FALSE;
+                }
+                else
+                    for (j=0; j < 256; j++) {
+
+                        if (Tables != NULL)
+                            val = (cmsUInt8Number) FROM_16_TO_8(Tables->TheCurves[i]->Table16[j]);
+                        else
+                            val = (cmsUInt8Number) j;
+
+                        if (!_cmsWriteUInt8Number(io, val)) return FALSE;
+                    }
         }
     }
     return TRUE;
@@ -1724,7 +1735,7 @@
 
 // Check overflow
 static
-size_t uipow(cmsUInt32Number n, cmsUInt32Number a, cmsUInt32Number b)
+cmsUInt32Number uipow(cmsUInt32Number n, cmsUInt32Number a, cmsUInt32Number b)
 {
     cmsUInt32Number rv = 1, rc;
 
@@ -1736,13 +1747,13 @@
         rv *= a;
 
         // Check for overflow
-        if (rv > UINT_MAX / a) return (size_t) -1;
+        if (rv > UINT_MAX / a) return (cmsUInt32Number) -1;
 
     }
 
     rc = rv * n;
 
-    if (rv != rc / n) return (size_t) -1;
+    if (rv != rc / n) return (cmsUInt32Number) -1;
     return rc;
 }
 
@@ -1757,7 +1768,6 @@
     cmsUInt8Number InputChannels, OutputChannels, CLUTpoints;
     cmsUInt8Number* Temp = NULL;
     cmsPipeline* NewLUT = NULL;
-    cmsStage *mpemat, *mpeclut;
     cmsUInt32Number nTabSize, i;
     cmsFloat64Number Matrix[3*3];
 
@@ -1796,9 +1806,8 @@
     // Only operates if not identity...
     if ((InputChannels == 3) && !_cmsMAT3isIdentity((cmsMAT3*) Matrix)) {
 
-        mpemat = cmsStageAllocMatrix(self ->ContextID, 3, 3, Matrix, NULL);
-        if (mpemat == NULL) goto Error;
-        cmsPipelineInsertStage(NewLUT, cmsAT_BEGIN, mpemat);
+        if (!cmsPipelineInsertStage(NewLUT, cmsAT_BEGIN, cmsStageAllocMatrix(self ->ContextID, 3, 3, Matrix, NULL)))
+            goto Error;
     }
 
     // Get input tables
@@ -1806,13 +1815,10 @@
 
     // Get 3D CLUT. Check the overflow....
     nTabSize = uipow(OutputChannels, CLUTpoints, InputChannels);
-    if (nTabSize == (size_t) -1) goto Error;
+    if (nTabSize == (cmsUInt32Number) -1) goto Error;
     if (nTabSize > 0) {
 
         cmsUInt16Number *PtrW, *T;
-        cmsUInt32Number Tsize;
-
-        Tsize = (cmsUInt32Number) nTabSize * sizeof(cmsUInt16Number);
 
         PtrW = T  = (cmsUInt16Number*) _cmsCalloc(self ->ContextID, nTabSize, sizeof(cmsUInt16Number));
         if (T  == NULL) goto Error;
@@ -1829,10 +1835,8 @@
         _cmsFree(self ->ContextID, Temp);
         Temp = NULL;
 
-
-        mpeclut = cmsStageAllocCLut16bit(self ->ContextID, CLUTpoints, InputChannels, OutputChannels, T);
-        if (mpeclut == NULL) goto Error;
-        cmsPipelineInsertStage(NewLUT, cmsAT_END, mpeclut);
+        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, cmsStageAllocCLut16bit(self ->ContextID, CLUTpoints, InputChannels, OutputChannels, T)))
+            goto Error;
         _cmsFree(self ->ContextID, T);
     }
 
@@ -1934,7 +1938,7 @@
     if (!Write8bitTables(self ->ContextID, io, NewLUT ->InputChannels, PreMPE)) return FALSE;
 
     nTabSize = uipow(NewLUT->OutputChannels, clutPoints, NewLUT ->InputChannels);
-    if (nTabSize == (size_t) -1) return FALSE;
+    if (nTabSize == (cmsUInt32Number) -1) return FALSE;
     if (nTabSize > 0) {
 
         // The 3D CLUT.
@@ -1983,7 +1987,6 @@
 static
 cmsBool  Read16bitTables(cmsContext ContextID, cmsIOHANDLER* io, cmsPipeline* lut, int nChannels, int nEntries)
 {
-    cmsStage* mpe;
     int i;
     cmsToneCurve* Tables[cmsMAXCHANNELS];
 
@@ -2007,10 +2010,8 @@
 
 
     // Add the table (which may certainly be an identity, but this is up to the optimizer, not the reading code)
-    mpe = cmsStageAllocToneCurves(ContextID, nChannels, Tables);
-    if (mpe == NULL) goto Error;
-
-    cmsPipelineInsertStage(lut, cmsAT_END, mpe);
+    if (!cmsPipelineInsertStage(lut, cmsAT_END, cmsStageAllocToneCurves(ContextID, nChannels, Tables)))
+        goto Error;
 
     for (i=0; i < nChannels; i++)
         cmsFreeToneCurve(Tables[i]);
@@ -2031,7 +2032,9 @@
     int j;
     cmsUInt32Number i;
     cmsUInt16Number val;
-    int nEntries = 256;
+    int nEntries;
+
+    _cmsAssert(Tables != NULL);
 
     nEntries = Tables->TheCurves[0]->nEntries;
 
@@ -2039,11 +2042,7 @@
 
         for (j=0; j < nEntries; j++) {
 
-            if (Tables != NULL)
-                val = Tables->TheCurves[i]->Table16[j];
-            else
-                val = _cmsQuantizeVal(j, nEntries);
-
+            val = Tables->TheCurves[i]->Table16[j];
             if (!_cmsWriteUInt16Number(io, val)) return FALSE;
         }
     }
@@ -2057,7 +2056,6 @@
 {
     cmsUInt8Number InputChannels, OutputChannels, CLUTpoints;
     cmsPipeline* NewLUT = NULL;
-    cmsStage *mpemat,  *mpeclut;
     cmsUInt32Number nTabSize;
     cmsFloat64Number Matrix[3*3];
     cmsUInt16Number InputEntries, OutputEntries;
@@ -2094,9 +2092,8 @@
     // Only operates on 3 channels
     if ((InputChannels == 3) && !_cmsMAT3isIdentity((cmsMAT3*) Matrix)) {
 
-        mpemat = cmsStageAllocMatrix(self ->ContextID, 3, 3, Matrix, NULL);
-        if (mpemat == NULL) goto Error;
-        cmsPipelineInsertStage(NewLUT, cmsAT_END, mpemat);
+        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, cmsStageAllocMatrix(self ->ContextID, 3, 3, Matrix, NULL)))
+            goto Error;
     }
 
     if (!_cmsReadUInt16Number(io, &InputEntries)) goto Error;
@@ -2110,7 +2107,7 @@
 
     // Get 3D CLUT
     nTabSize = uipow(OutputChannels, CLUTpoints, InputChannels);
-    if (nTabSize == (size_t) -1) goto Error;
+    if (nTabSize == (cmsUInt32Number) -1) goto Error;
     if (nTabSize > 0) {
 
         cmsUInt16Number *T;
@@ -2123,13 +2120,10 @@
             goto Error;
         }
 
-        mpeclut = cmsStageAllocCLut16bit(self ->ContextID, CLUTpoints, InputChannels, OutputChannels, T);
-        if (mpeclut == NULL) {
-             _cmsFree(self ->ContextID, T);
+        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, cmsStageAllocCLut16bit(self ->ContextID, CLUTpoints, InputChannels, OutputChannels, T))) {
+            _cmsFree(self ->ContextID, T);
             goto Error;
         }
-
-        cmsPipelineInsertStage(NewLUT, cmsAT_END, mpeclut);
         _cmsFree(self ->ContextID, T);
     }
 
@@ -2159,7 +2153,7 @@
     _cmsStageToneCurvesData* PreMPE = NULL, *PostMPE = NULL;
     _cmsStageMatrixData* MatMPE = NULL;
     _cmsStageCLutData* clut = NULL;
-    int InputChannels, OutputChannels, clutPoints;
+    int i, InputChannels, OutputChannels, clutPoints;
 
     // Disassemble the LUT into components.
     mpe = NewLUT -> Elements;
@@ -2234,13 +2228,13 @@
     if (PreMPE != NULL) {
         if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) PreMPE ->TheCurves[0]->nEntries)) return FALSE;
     } else {
-            if (!_cmsWriteUInt16Number(io, 0)) return FALSE;
+            if (!_cmsWriteUInt16Number(io, 2)) return FALSE;
     }
 
     if (PostMPE != NULL) {
         if (!_cmsWriteUInt16Number(io, (cmsUInt16Number) PostMPE ->TheCurves[0]->nEntries)) return FALSE;
     } else {
-        if (!_cmsWriteUInt16Number(io, 0)) return FALSE;
+        if (!_cmsWriteUInt16Number(io, 2)) return FALSE;
 
     }
 
@@ -2249,9 +2243,16 @@
     if (PreMPE != NULL) {
         if (!Write16bitTables(self ->ContextID, io, PreMPE)) return FALSE;
     }
+    else {
+        for (i=0; i < InputChannels; i++) {
+
+            if (!_cmsWriteUInt16Number(io, 0)) return FALSE;
+            if (!_cmsWriteUInt16Number(io, 0xffff)) return FALSE;
+        }
+    }
 
     nTabSize = uipow(OutputChannels, clutPoints, InputChannels);
-    if (nTabSize == (size_t) -1) return FALSE;
+    if (nTabSize == (cmsUInt32Number) -1) return FALSE;
     if (nTabSize > 0) {
         // The 3D CLUT.
         if (clut != NULL) {
@@ -2263,7 +2264,13 @@
     if (PostMPE != NULL) {
         if (!Write16bitTables(self ->ContextID, io, PostMPE)) return FALSE;
     }
-
+    else {
+        for (i=0; i < OutputChannels; i++) {
+
+            if (!_cmsWriteUInt16Number(io, 0)) return FALSE;
+            if (!_cmsWriteUInt16Number(io, 0xffff)) return FALSE;
+        }
+    }
 
     return TRUE;
 
@@ -2479,7 +2486,6 @@
     cmsUInt32Number      offsetM;        // Offset to first "M" curve
     cmsUInt32Number      offsetC;        // Offset to CLUT
     cmsUInt32Number      offsetA;        // Offset to first "A" curve
-    cmsStage* mpe;
     cmsPipeline* NewLUT = NULL;
 
 
@@ -2501,37 +2507,35 @@
     if (NewLUT == NULL) return NULL;
 
     if (offsetA!= 0) {
-        mpe = ReadSetOfCurves(self, io, BaseOffset + offsetA, inputChan);
-        if (mpe == NULL) { cmsPipelineFree(NewLUT); return NULL; }
-        cmsPipelineInsertStage(NewLUT, cmsAT_END, mpe);
+        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, ReadSetOfCurves(self, io, BaseOffset + offsetA, inputChan)))
+            goto Error;
     }
 
     if (offsetC != 0) {
-        mpe = ReadCLUT(self, io, BaseOffset + offsetC, inputChan, outputChan);
-        if (mpe == NULL) { cmsPipelineFree(NewLUT); return NULL; }
-        cmsPipelineInsertStage(NewLUT, cmsAT_END, mpe);
+        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, ReadCLUT(self, io, BaseOffset + offsetC, inputChan, outputChan)))
+            goto Error;
     }
 
     if (offsetM != 0) {
-        mpe = ReadSetOfCurves(self, io, BaseOffset + offsetM, outputChan);
-        if (mpe == NULL) { cmsPipelineFree(NewLUT); return NULL; }
-        cmsPipelineInsertStage(NewLUT, cmsAT_END, mpe);
+        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, ReadSetOfCurves(self, io, BaseOffset + offsetM, outputChan)))
+            goto Error;
     }
 
     if (offsetMat != 0) {
-        mpe = ReadMatrix(self, io, BaseOffset + offsetMat);
-        if (mpe == NULL) { cmsPipelineFree(NewLUT); return NULL; }
-        cmsPipelineInsertStage(NewLUT, cmsAT_END, mpe);
+        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, ReadMatrix(self, io, BaseOffset + offsetMat)))
+            goto Error;
     }
 
     if (offsetB != 0) {
-        mpe = ReadSetOfCurves(self, io, BaseOffset + offsetB, outputChan);
-        if (mpe == NULL) { cmsPipelineFree(NewLUT); return NULL; }
-        cmsPipelineInsertStage(NewLUT, cmsAT_END, mpe);
+        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, ReadSetOfCurves(self, io, BaseOffset + offsetB, outputChan)))
+            goto Error;
     }
 
     *nItems = 1;
     return NewLUT;
+Error:
+    cmsPipelineFree(NewLUT);
+    return NULL;
 
     cmsUNUSED_PARAMETER(SizeOfTag);
 }
@@ -2798,7 +2802,6 @@
     cmsUInt32Number      offsetM;        // Offset to first "M" curve
     cmsUInt32Number      offsetC;        // Offset to CLUT
     cmsUInt32Number      offsetA;        // Offset to first "A" curve
-    cmsStage* mpe;
     cmsPipeline* NewLUT = NULL;
 
 
@@ -2821,37 +2824,35 @@
     if (NewLUT == NULL) return NULL;
 
     if (offsetB != 0) {
-        mpe = ReadSetOfCurves(self, io, BaseOffset + offsetB, inputChan);
-        if (mpe == NULL) { cmsPipelineFree(NewLUT); return NULL; }
-        cmsPipelineInsertStage(NewLUT, cmsAT_END, mpe);
+        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, ReadSetOfCurves(self, io, BaseOffset + offsetB, inputChan)))
+            goto Error;
     }
 
     if (offsetMat != 0) {
-        mpe = ReadMatrix(self, io, BaseOffset + offsetMat);
-        if (mpe == NULL) { cmsPipelineFree(NewLUT); return NULL; }
-        cmsPipelineInsertStage(NewLUT, cmsAT_END, mpe);
+        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, ReadMatrix(self, io, BaseOffset + offsetMat)))
+            goto Error;
     }
 
     if (offsetM != 0) {
-        mpe = ReadSetOfCurves(self, io, BaseOffset + offsetM, inputChan);
-        if (mpe == NULL) { cmsPipelineFree(NewLUT); return NULL; }
-        cmsPipelineInsertStage(NewLUT, cmsAT_END, mpe);
+        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, ReadSetOfCurves(self, io, BaseOffset + offsetM, inputChan)))
+            goto Error;
     }
 
     if (offsetC != 0) {
-        mpe = ReadCLUT(self, io, BaseOffset + offsetC, inputChan, outputChan);
-        if (mpe == NULL) { cmsPipelineFree(NewLUT); return NULL; }
-        cmsPipelineInsertStage(NewLUT, cmsAT_END, mpe);
+        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, ReadCLUT(self, io, BaseOffset + offsetC, inputChan, outputChan)))
+            goto Error;
     }
 
     if (offsetA!= 0) {
-        mpe = ReadSetOfCurves(self, io, BaseOffset + offsetA, outputChan);
-        if (mpe == NULL) { cmsPipelineFree(NewLUT); return NULL; }
-        cmsPipelineInsertStage(NewLUT, cmsAT_END, mpe);
+        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, ReadSetOfCurves(self, io, BaseOffset + offsetA, outputChan)))
+            goto Error;
     }
 
     *nItems = 1;
     return NewLUT;
+Error:
+    cmsPipelineFree(NewLUT);
+    return NULL;
 
     cmsUNUSED_PARAMETER(SizeOfTag);
 }
@@ -3287,7 +3288,7 @@
         SizeOfTag -= sizeof(cmsUInt32Number);
 
         if (!_cmsReadUInt64Number(io, &sec ->attributes)) goto Error;
-        if (SizeOfTag < sizeof(cmsUInt32Number)) goto Error;
+        if (SizeOfTag < sizeof(cmsUInt64Number)) goto Error;
         SizeOfTag -= sizeof(cmsUInt64Number);
 
         if (!_cmsReadUInt32Number(io, (cmsUInt32Number *)&sec ->technology)) goto Error;
@@ -4292,6 +4293,9 @@
     if (!_cmsReadUInt16Number(io, &InputChans)) return NULL;
     if (!_cmsReadUInt16Number(io, &OutputChans)) return NULL;
 
+    if (InputChans == 0) goto Error;
+    if (OutputChans == 0) goto Error;
+
     if (io ->Read(io, Dimensions8, sizeof(cmsUInt8Number), 16) != 16)
         goto Error;
 
@@ -4381,7 +4385,6 @@
 {
     cmsStageSignature ElementSig;
     cmsTagTypeHandler* TypeHandler;
-    cmsStage *mpe = NULL;
     cmsUInt32Number nItems;
     cmsPipeline *NewLUT = (cmsPipeline *) Cargo;
 
@@ -4409,11 +4412,8 @@
     if (TypeHandler ->ReadPtr != NULL) {
 
         // This is a real element which should be read and processed
-        mpe = (cmsStage*) TypeHandler ->ReadPtr(self, io, &nItems, SizeOfTag);
-        if (mpe == NULL) return FALSE;
-
-        // All seems ok, insert element
-        cmsPipelineInsertStage(NewLUT, cmsAT_END, mpe);
+        if (!cmsPipelineInsertStage(NewLUT, cmsAT_END, (cmsStage*) TypeHandler ->ReadPtr(self, io, &nItems, SizeOfTag)))
+            return FALSE;
     }
 
     return TRUE;
@@ -4479,10 +4479,10 @@
     outputChan = cmsPipelineOutputChannels(Lut);
     ElemCount  = cmsPipelineStageCount(Lut);
 
-    ElementOffsets = (cmsUInt32Number *) _cmsCalloc(self ->ContextID, ElemCount, sizeof(cmsUInt32Number *));
+    ElementOffsets = (cmsUInt32Number *) _cmsCalloc(self ->ContextID, ElemCount, sizeof(cmsUInt32Number));
     if (ElementOffsets == NULL) goto Error;
 
-    ElementSizes = (cmsUInt32Number *) _cmsCalloc(self ->ContextID, ElemCount, sizeof(cmsUInt32Number *));
+    ElementSizes = (cmsUInt32Number *) _cmsCalloc(self ->ContextID, ElemCount, sizeof(cmsUInt32Number));
     if (ElementSizes == NULL) goto Error;
 
     // Write the head
@@ -4825,10 +4825,10 @@
 static
 cmsBool AllocElem(cmsContext ContextID, _cmsDICelem* e,  cmsUInt32Number Count)
 {
-    e->Offsets = (cmsUInt32Number *) _cmsCalloc(ContextID, Count, sizeof(cmsUInt32Number *));
+    e->Offsets = (cmsUInt32Number *) _cmsCalloc(ContextID, Count, sizeof(cmsUInt32Number));
     if (e->Offsets == NULL) return FALSE;
 
-    e->Sizes = (cmsUInt32Number *) _cmsCalloc(ContextID, Count, sizeof(cmsUInt32Number *));
+    e->Sizes = (cmsUInt32Number *) _cmsCalloc(ContextID, Count, sizeof(cmsUInt32Number));
     if (e->Sizes == NULL) {
 
         _cmsFree(ContextID, e -> Offsets);
@@ -4844,7 +4844,7 @@
 void FreeElem(_cmsDICelem* e)
 {
     if (e ->Offsets != NULL)  _cmsFree(e -> ContextID, e -> Offsets);
-    if (e ->Sizes   != NULL)  _cmsFree(e -> ContextID, e ->Sizes);
+    if (e ->Sizes   != NULL)  _cmsFree(e -> ContextID, e -> Sizes);
     e->Offsets = e ->Sizes = NULL;
 }
 
@@ -5084,7 +5084,7 @@
     if (!_cmsReadUInt32Number(io, &Count)) return NULL;
     SizeOfTag -= sizeof(cmsUInt32Number);
 
-    // Get rec lenghth
+    // Get rec length
     if (!_cmsReadUInt32Number(io, &Length)) return NULL;
     SizeOfTag -= sizeof(cmsUInt32Number);
 
@@ -5118,14 +5118,22 @@
             if (!ReadOneMLUC(self, io, &a.DisplayValue, i, &DisplayValueMLU)) goto Error;
         }
 
+        if (NameWCS == NULL || ValueWCS == NULL) {
+
+            cmsSignalError(self->ContextID, cmsERROR_CORRUPTION_DETECTED, "Bad dictionary Name/Value");
+            rc = FALSE;
+        }
+        else {
+
         rc = cmsDictAddEntry(hDict, NameWCS, ValueWCS, DisplayNameMLU, DisplayValueMLU);
+        }
 
         if (NameWCS != NULL) _cmsFree(self ->ContextID, NameWCS);
         if (ValueWCS != NULL) _cmsFree(self ->ContextID, ValueWCS);
         if (DisplayNameMLU != NULL) cmsMLUfree(DisplayNameMLU);
         if (DisplayValueMLU != NULL) cmsMLUfree(DisplayValueMLU);
 
-        if (!rc) return FALSE;
+        if (!rc) goto Error;
     }
 
    FreeArray(&a);
@@ -5277,14 +5285,14 @@
 #define DEFAULT_TAG_TYPE_COUNT  (sizeof(SupportedTagTypes) / sizeof(_cmsTagTypeLinkedList))
 
 // Both kind of plug-ins share same structure
-cmsBool  _cmsRegisterTagTypePlugin(cmsPluginBase* Data)
+cmsBool  _cmsRegisterTagTypePlugin(cmsContext id, cmsPluginBase* Data)
 {
-    return RegisterTypesPlugin(Data, SupportedTagTypes, DEFAULT_TAG_TYPE_COUNT);
+    return RegisterTypesPlugin(id, Data, SupportedTagTypes, DEFAULT_TAG_TYPE_COUNT);
 }
 
-cmsBool  _cmsRegisterMultiProcessElementPlugin(cmsPluginBase* Data)
+cmsBool  _cmsRegisterMultiProcessElementPlugin(cmsContext id, cmsPluginBase* Data)
 {
-    return RegisterTypesPlugin(Data, SupportedMPEtypes, DEFAULT_MPE_TYPE_COUNT);
+    return RegisterTypesPlugin(id, Data, SupportedMPEtypes, DEFAULT_MPE_TYPE_COUNT);
 }
 
 
@@ -5391,7 +5399,9 @@
     { cmsSigScreeningTag,           { 1, 1, { cmsSigScreeningType},          NULL }, &SupportedTags[59]},
     { cmsSigVcgtTag,                { 1, 1, { cmsSigVcgtType},               NULL }, &SupportedTags[60]},
     { cmsSigMetaTag,                { 1, 1, { cmsSigDictType},               NULL }, &SupportedTags[61]},
-    { cmsSigProfileSequenceIdTag,   { 1, 1, { cmsSigProfileSequenceIdType},  NULL},  NULL}
+    { cmsSigProfileSequenceIdTag,   { 1, 1, { cmsSigProfileSequenceIdType},  NULL },  &SupportedTags[62]},
+    { cmsSigProfileDescriptionMLTag,{ 1, 1, { cmsSigMultiLocalizedUnicodeType}, NULL}, NULL}
+
 
 };
 
@@ -5406,7 +5416,7 @@
 
 #define DEFAULT_TAG_COUNT  (sizeof(SupportedTags) / sizeof(_cmsTagLinkedList))
 
-cmsBool  _cmsRegisterTagPlugin(cmsPluginBase* Data)
+cmsBool  _cmsRegisterTagPlugin(cmsContext id, cmsPluginBase* Data)
 {
     cmsPluginTag* Plugin = (cmsPluginTag*) Data;
     _cmsTagLinkedList *pt, *Anterior;
@@ -5430,7 +5440,7 @@
         pt = pt ->Next;
     }
 
-    pt = (_cmsTagLinkedList*) _cmsPluginMalloc(sizeof(_cmsTagLinkedList));
+    pt = (_cmsTagLinkedList*) _cmsPluginMalloc(id, sizeof(_cmsTagLinkedList));
     if (pt == NULL) return FALSE;
 
     pt ->Signature  = Plugin ->Signature;
--- ./jdk/src/share/native/sun/java2d/cmm/lcms/cmsvirt.c	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/native/sun/java2d/cmm/lcms/cmsvirt.c	Tue Mar 18 12:35:25 2014 -0700
@@ -208,9 +208,26 @@
 
     if (TransferFunction) {
 
+        // Tries to minimize space. Thanks to Richard Hughes for this nice idea
         if (!cmsWriteTag(hICC, cmsSigRedTRCTag,   (void*) TransferFunction[0])) goto Error;
-        if (!cmsWriteTag(hICC, cmsSigGreenTRCTag, (void*) TransferFunction[1])) goto Error;
-        if (!cmsWriteTag(hICC, cmsSigBlueTRCTag,  (void*) TransferFunction[2])) goto Error;
+
+        if (TransferFunction[1] == TransferFunction[0]) {
+
+            if (!cmsLinkTag (hICC, cmsSigGreenTRCTag, cmsSigRedTRCTag)) goto Error;
+
+        } else {
+
+            if (!cmsWriteTag(hICC, cmsSigGreenTRCTag, (void*) TransferFunction[1])) goto Error;
+        }
+
+        if (TransferFunction[2] == TransferFunction[0]) {
+
+            if (!cmsLinkTag (hICC, cmsSigBlueTRCTag, cmsSigRedTRCTag)) goto Error;
+
+        } else {
+
+            if (!cmsWriteTag(hICC, cmsSigBlueTRCTag, (void*) TransferFunction[2])) goto Error;
+        }
     }
 
     if (Primaries) {
@@ -303,7 +320,6 @@
 {
     cmsHPROFILE hICC;
     cmsPipeline* Pipeline;
-    cmsStage* Lin;
     int nChannels;
 
     hICC = cmsCreateProfilePlaceholder(ContextID);
@@ -327,10 +343,8 @@
 
 
     // Copy tables to Pipeline
-    Lin = cmsStageAllocToneCurves(ContextID, nChannels, TransferFunctions);
-    if (Lin == NULL) goto Error;
-
-    cmsPipelineInsertStage(Pipeline, cmsAT_BEGIN, Lin);
+    if (!cmsPipelineInsertStage(Pipeline, cmsAT_BEGIN, cmsStageAllocToneCurves(ContextID, nChannels, TransferFunctions)))
+        goto Error;
 
     // Create tags
     if (!SetTextTags(hICC, L"Linearization built-in")) goto Error;
@@ -344,6 +358,7 @@
     return hICC;
 
 Error:
+    cmsPipelineFree(Pipeline);
     if (hICC)
         cmsCloseProfile(hICC);
 
@@ -451,9 +466,10 @@
 
     if (!cmsStageSampleCLut16bit(CLUT, InkLimitingSampler, (void*) &Limit, 0)) goto Error;
 
-    cmsPipelineInsertStage(LUT, cmsAT_BEGIN, _cmsStageAllocIdentityCurves(ContextID, nChannels));
-    cmsPipelineInsertStage(LUT, cmsAT_END, CLUT);
-    cmsPipelineInsertStage(LUT, cmsAT_END, _cmsStageAllocIdentityCurves(ContextID, nChannels));
+    if (!cmsPipelineInsertStage(LUT, cmsAT_BEGIN, _cmsStageAllocIdentityCurves(ContextID, nChannels)) ||
+        !cmsPipelineInsertStage(LUT, cmsAT_END, CLUT) ||
+        !cmsPipelineInsertStage(LUT, cmsAT_END, _cmsStageAllocIdentityCurves(ContextID, nChannels)))
+        goto Error;
 
     // Create tags
     if (!SetTextTags(hICC, L"ink-limiting built-in")) goto Error;
@@ -504,7 +520,8 @@
     LUT = cmsPipelineAlloc(ContextID, 3, 3);
     if (LUT == NULL) goto Error;
 
-    cmsPipelineInsertStage(LUT, cmsAT_BEGIN, _cmsStageAllocIdentityCLut(ContextID, 3));
+    if (!cmsPipelineInsertStage(LUT, cmsAT_BEGIN, _cmsStageAllocIdentityCLut(ContextID, 3)))
+        goto Error;
 
     if (!cmsWriteTag(hProfile, cmsSigAToB0Tag, LUT)) goto Error;
     cmsPipelineFree(LUT);
@@ -550,7 +567,8 @@
     LUT = cmsPipelineAlloc(ContextID, 3, 3);
     if (LUT == NULL) goto Error;
 
-    cmsPipelineInsertStage(LUT, cmsAT_BEGIN, _cmsStageAllocIdentityCurves(ContextID, 3));
+    if (!cmsPipelineInsertStage(LUT, cmsAT_BEGIN, _cmsStageAllocIdentityCurves(ContextID, 3)))
+        goto Error;
 
     if (!cmsWriteTag(hProfile, cmsSigAToB0Tag, LUT)) goto Error;
     cmsPipelineFree(LUT);
@@ -595,7 +613,8 @@
     LUT = cmsPipelineAlloc(ContextID, 3, 3);
     if (LUT == NULL) goto Error;
 
-    cmsPipelineInsertStage(LUT, cmsAT_BEGIN, _cmsStageAllocIdentityCurves(ContextID, 3));
+    if (!cmsPipelineInsertStage(LUT, cmsAT_BEGIN, _cmsStageAllocIdentityCurves(ContextID, 3)))
+        goto Error;
 
     if (!cmsWriteTag(hProfile, cmsSigAToB0Tag, LUT)) goto Error;
     cmsPipelineFree(LUT);
@@ -734,81 +753,83 @@
 // contrast, Saturation and white point displacement
 
 cmsHPROFILE CMSEXPORT cmsCreateBCHSWabstractProfileTHR(cmsContext ContextID,
-                                                     int nLUTPoints,
-                                                     cmsFloat64Number Bright,
-                                                     cmsFloat64Number Contrast,
-                                                     cmsFloat64Number Hue,
-                                                     cmsFloat64Number Saturation,
-                                                     int TempSrc,
-                                                     int TempDest)
+    int nLUTPoints,
+    cmsFloat64Number Bright,
+    cmsFloat64Number Contrast,
+    cmsFloat64Number Hue,
+    cmsFloat64Number Saturation,
+    int TempSrc,
+    int TempDest)
 {
-     cmsHPROFILE hICC;
-     cmsPipeline* Pipeline;
-     BCHSWADJUSTS bchsw;
-     cmsCIExyY WhitePnt;
-     cmsStage* CLUT;
-     cmsUInt32Number Dimensions[MAX_INPUT_DIMENSIONS];
-     int i;
+    cmsHPROFILE hICC;
+    cmsPipeline* Pipeline;
+    BCHSWADJUSTS bchsw;
+    cmsCIExyY WhitePnt;
+    cmsStage* CLUT;
+    cmsUInt32Number Dimensions[MAX_INPUT_DIMENSIONS];
+    int i;
 
+    bchsw.Brightness = Bright;
+    bchsw.Contrast   = Contrast;
+    bchsw.Hue        = Hue;
+    bchsw.Saturation = Saturation;
 
-     bchsw.Brightness = Bright;
-     bchsw.Contrast   = Contrast;
-     bchsw.Hue        = Hue;
-     bchsw.Saturation = Saturation;
+    cmsWhitePointFromTemp(&WhitePnt, TempSrc );
+    cmsxyY2XYZ(&bchsw.WPsrc, &WhitePnt);
 
-     cmsWhitePointFromTemp(&WhitePnt, TempSrc );
-     cmsxyY2XYZ(&bchsw.WPsrc, &WhitePnt);
+    cmsWhitePointFromTemp(&WhitePnt, TempDest);
+    cmsxyY2XYZ(&bchsw.WPdest, &WhitePnt);
 
-     cmsWhitePointFromTemp(&WhitePnt, TempDest);
-     cmsxyY2XYZ(&bchsw.WPdest, &WhitePnt);
+    hICC = cmsCreateProfilePlaceholder(ContextID);
+    if (!hICC)                          // can't allocate
+        return NULL;
 
-      hICC = cmsCreateProfilePlaceholder(ContextID);
-       if (!hICC)                          // can't allocate
-            return NULL;
 
+    cmsSetDeviceClass(hICC,      cmsSigAbstractClass);
+    cmsSetColorSpace(hICC,       cmsSigLabData);
+    cmsSetPCS(hICC,              cmsSigLabData);
 
-       cmsSetDeviceClass(hICC,      cmsSigAbstractClass);
-       cmsSetColorSpace(hICC,       cmsSigLabData);
-       cmsSetPCS(hICC,              cmsSigLabData);
+    cmsSetHeaderRenderingIntent(hICC,  INTENT_PERCEPTUAL);
 
-       cmsSetHeaderRenderingIntent(hICC,  INTENT_PERCEPTUAL);
+    // Creates a Pipeline with 3D grid only
+    Pipeline = cmsPipelineAlloc(ContextID, 3, 3);
+    if (Pipeline == NULL) {
+        cmsCloseProfile(hICC);
+        return NULL;
+    }
 
+    for (i=0; i < MAX_INPUT_DIMENSIONS; i++) Dimensions[i] = nLUTPoints;
+    CLUT = cmsStageAllocCLut16bitGranular(ContextID, Dimensions, 3, 3, NULL);
+    if (CLUT == NULL) return NULL;
 
-       // Creates a Pipeline with 3D grid only
-       Pipeline = cmsPipelineAlloc(ContextID, 3, 3);
-       if (Pipeline == NULL) {
-           cmsCloseProfile(hICC);
-           return NULL;
-           }
 
-       for (i=0; i < MAX_INPUT_DIMENSIONS; i++) Dimensions[i] = nLUTPoints;
-       CLUT = cmsStageAllocCLut16bitGranular(ContextID, Dimensions, 3, 3, NULL);
-       if (CLUT == NULL) return NULL;
+    if (!cmsStageSampleCLut16bit(CLUT, bchswSampler, (void*) &bchsw, 0)) {
 
+        // Shouldn't reach here
+        goto Error;
+    }
 
-       if (!cmsStageSampleCLut16bit(CLUT, bchswSampler, (void*) &bchsw, 0)) {
+    if (!cmsPipelineInsertStage(Pipeline, cmsAT_END, CLUT)) {
+        goto Error;
+    }
 
-                // Shouldn't reach here
-                cmsPipelineFree(Pipeline);
-                cmsCloseProfile(hICC);
-                return NULL;
-       }
+    // Create tags
+    if (!SetTextTags(hICC, L"BCHS built-in")) return NULL;
 
-       cmsPipelineInsertStage(Pipeline, cmsAT_END, CLUT);
+    cmsWriteTag(hICC, cmsSigMediaWhitePointTag, (void*) cmsD50_XYZ());
 
-       // Create tags
+    cmsWriteTag(hICC, cmsSigAToB0Tag, (void*) Pipeline);
 
-       if (!SetTextTags(hICC, L"BCHS built-in")) return NULL;
+    // Pipeline is already on virtual profile
+    cmsPipelineFree(Pipeline);
 
-       cmsWriteTag(hICC, cmsSigMediaWhitePointTag, (void*) cmsD50_XYZ());
+    // Ok, done
+    return hICC;
 
-       cmsWriteTag(hICC, cmsSigAToB0Tag, (void*) Pipeline);
-
-       // Pipeline is already on virtual profile
-       cmsPipelineFree(Pipeline);
-
-       // Ok, done
-       return hICC;
+Error:
+    cmsPipelineFree(Pipeline);
+    cmsCloseProfile(hICC);
+    return NULL;
 }
 
 
@@ -856,7 +877,8 @@
     PostLin = cmsStageAllocToneCurves(ContextID, 1, &EmptyTab);
     cmsFreeToneCurve(EmptyTab);
 
-    cmsPipelineInsertStage(LUT, cmsAT_END, PostLin);
+    if (!cmsPipelineInsertStage(LUT, cmsAT_END, PostLin))
+        goto Error;
 
     if (!cmsWriteTag(hProfile, cmsSigBToA0Tag, (void*) LUT)) goto Error;
     if (!cmsWriteTag(hProfile, cmsSigMediaWhitePointTag, cmsD50_XYZ())) goto Error;
@@ -999,6 +1021,7 @@
 
     { FALSE, 0,              cmsSigLut16Type,    4,  { cmsSigMatrixElemType,  cmsSigCurveSetElemType, cmsSigCLutElemType, cmsSigCurveSetElemType}},
     { FALSE, 0,              cmsSigLut16Type,    3,  { cmsSigCurveSetElemType, cmsSigCLutElemType, cmsSigCurveSetElemType}},
+    { FALSE, 0,              cmsSigLut16Type,    2,  { cmsSigCurveSetElemType, cmsSigCLutElemType}},
     { TRUE , 0,              cmsSigLutAtoBType,  1,  { cmsSigCurveSetElemType }},
     { TRUE , cmsSigAToB0Tag, cmsSigLutAtoBType,  3,  { cmsSigCurveSetElemType, cmsSigMatrixElemType, cmsSigCurveSetElemType } },
     { TRUE , cmsSigAToB0Tag, cmsSigLutAtoBType,  3,  { cmsSigCurveSetElemType, cmsSigCLutElemType, cmsSigCurveSetElemType   } },
@@ -1059,6 +1082,7 @@
     cmsContext ContextID = cmsGetTransformContextID(hTransform);
     const cmsAllowedLUT* AllowedLUT;
     cmsTagSignature DestinationTag;
+    cmsProfileClassSignature deviceClass;
 
     _cmsAssert(hTransform != NULL);
 
@@ -1080,13 +1104,15 @@
     // Time to fix the Lab2/Lab4 issue.
     if ((xform ->EntryColorSpace == cmsSigLabData) && (Version < 4.0)) {
 
-        cmsPipelineInsertStage(LUT, cmsAT_BEGIN, _cmsStageAllocLabV2ToV4curves(ContextID));
+        if (!cmsPipelineInsertStage(LUT, cmsAT_BEGIN, _cmsStageAllocLabV2ToV4curves(ContextID)))
+            goto Error;
     }
 
     // On the output side too
     if ((xform ->ExitColorSpace) == cmsSigLabData && (Version < 4.0)) {
 
-        cmsPipelineInsertStage(LUT, cmsAT_END, _cmsStageAllocLabV4ToV2(ContextID));
+        if (!cmsPipelineInsertStage(LUT, cmsAT_END, _cmsStageAllocLabV4ToV2(ContextID)))
+            goto Error;
     }
 
 
@@ -1108,8 +1134,9 @@
     FrmIn  = COLORSPACE_SH(ColorSpaceBitsIn) | CHANNELS_SH(ChansIn)|BYTES_SH(2);
     FrmOut = COLORSPACE_SH(ColorSpaceBitsOut) | CHANNELS_SH(ChansOut)|BYTES_SH(2);
 
+    deviceClass = cmsGetDeviceClass(hProfile);
 
-     if (cmsGetDeviceClass(hProfile) == cmsSigOutputClass)
+     if (deviceClass == cmsSigOutputClass)
          DestinationTag = cmsSigBToA0Tag;
      else
          DestinationTag = cmsSigAToB0Tag;
@@ -1136,10 +1163,12 @@
 
         // Put identity curves if needed
         if (cmsPipelineGetPtrToFirstStage(LUT) ->Type != cmsSigCurveSetElemType)
-             cmsPipelineInsertStage(LUT, cmsAT_BEGIN, _cmsStageAllocIdentityCurves(ContextID, ChansIn));
+             if (!cmsPipelineInsertStage(LUT, cmsAT_BEGIN, _cmsStageAllocIdentityCurves(ContextID, ChansIn)))
+                 goto Error;
 
         if (cmsPipelineGetPtrToLastStage(LUT) ->Type != cmsSigCurveSetElemType)
-             cmsPipelineInsertStage(LUT, cmsAT_END,   _cmsStageAllocIdentityCurves(ContextID, ChansOut));
+             if (!cmsPipelineInsertStage(LUT, cmsAT_END,   _cmsStageAllocIdentityCurves(ContextID, ChansOut)))
+                 goto Error;
 
         AllowedLUT = FindCombination(LUT, Version >= 4.0, DestinationTag);
     }
@@ -1168,10 +1197,22 @@
            if (!cmsWriteTag(hProfile, cmsSigColorantTableOutTag, xform->OutputColorant)) goto Error;
     }
 
-    if (xform ->Sequence != NULL) {
+    if ((deviceClass == cmsSigLinkClass) && (xform ->Sequence != NULL)) {
         if (!_cmsWriteProfileSequence(hProfile, xform ->Sequence)) goto Error;
     }
 
+    // Set the white point
+    if (deviceClass == cmsSigInputClass) {
+        if (!cmsWriteTag(hProfile, cmsSigMediaWhitePointTag, &xform ->EntryWhitePoint)) goto Error;
+    }
+    else {
+         if (!cmsWriteTag(hProfile, cmsSigMediaWhitePointTag, &xform ->ExitWhitePoint)) goto Error;
+    }
+
+
+    // Per 7.2.15 in spec 4.3
+    cmsSetHeaderRenderingIntent(hProfile, xform ->RenderingIntent);
+
     cmsPipelineFree(LUT);
     return hProfile;
 
--- ./jdk/src/share/native/sun/java2d/cmm/lcms/cmswtpnt.c	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/native/sun/java2d/cmm/lcms/cmswtpnt.c	Tue Mar 18 12:35:25 2014 -0700
@@ -30,7 +30,7 @@
 //---------------------------------------------------------------------------------
 //
 //  Little Color Management System
-//  Copyright (c) 1998-2010 Marti Maria Saguer
+//  Copyright (c) 1998-2012 Marti Maria Saguer
 //
 // Permission is hereby granted, free of charge, to any person obtaining
 // a copy of this software and associated documentation files (the "Software"),
@@ -76,48 +76,48 @@
 // Obtains WhitePoint from Temperature
 cmsBool  CMSEXPORT cmsWhitePointFromTemp(cmsCIExyY* WhitePoint, cmsFloat64Number TempK)
 {
-       cmsFloat64Number x, y;
-       cmsFloat64Number T, T2, T3;
-       // cmsFloat64Number M1, M2;
+    cmsFloat64Number x, y;
+    cmsFloat64Number T, T2, T3;
+    // cmsFloat64Number M1, M2;
 
-       _cmsAssert(WhitePoint != NULL);
+    _cmsAssert(WhitePoint != NULL);
 
-       T = TempK;
-       T2 = T*T;            // Square
-       T3 = T2*T;           // Cube
+    T = TempK;
+    T2 = T*T;            // Square
+    T3 = T2*T;           // Cube
 
-       // For correlated color temperature (T) between 4000K and 7000K:
+    // For correlated color temperature (T) between 4000K and 7000K:
 
-       if (T >= 4000. && T <= 7000.)
-       {
-              x = -4.6070*(1E9/T3) + 2.9678*(1E6/T2) + 0.09911*(1E3/T) + 0.244063;
-       }
-       else
-              // or for correlated color temperature (T) between 7000K and 25000K:
+    if (T >= 4000. && T <= 7000.)
+    {
+        x = -4.6070*(1E9/T3) + 2.9678*(1E6/T2) + 0.09911*(1E3/T) + 0.244063;
+    }
+    else
+        // or for correlated color temperature (T) between 7000K and 25000K:
 
-       if (T > 7000.0 && T <= 25000.0)
-       {
-              x = -2.0064*(1E9/T3) + 1.9018*(1E6/T2) + 0.24748*(1E3/T) + 0.237040;
-       }
-       else {
-              cmsSignalError(0, cmsERROR_RANGE, "cmsWhitePointFromTemp: invalid temp");
-              return FALSE;
-              }
+        if (T > 7000.0 && T <= 25000.0)
+        {
+            x = -2.0064*(1E9/T3) + 1.9018*(1E6/T2) + 0.24748*(1E3/T) + 0.237040;
+        }
+        else {
+            cmsSignalError(0, cmsERROR_RANGE, "cmsWhitePointFromTemp: invalid temp");
+            return FALSE;
+        }
 
-       // Obtain y(x)
+        // Obtain y(x)
 
-       y = -3.000*(x*x) + 2.870*x - 0.275;
+        y = -3.000*(x*x) + 2.870*x - 0.275;
 
-       // wave factors (not used, but here for futures extensions)
+        // wave factors (not used, but here for futures extensions)
 
-       // M1 = (-1.3515 - 1.7703*x + 5.9114 *y)/(0.0241 + 0.2562*x - 0.7341*y);
-       // M2 = (0.0300 - 31.4424*x + 30.0717*y)/(0.0241 + 0.2562*x - 0.7341*y);
+        // M1 = (-1.3515 - 1.7703*x + 5.9114 *y)/(0.0241 + 0.2562*x - 0.7341*y);
+        // M2 = (0.0300 - 31.4424*x + 30.0717*y)/(0.0241 + 0.2562*x - 0.7341*y);
 
-       WhitePoint -> x = x;
-       WhitePoint -> y = y;
-       WhitePoint -> Y = 1.0;
+        WhitePoint -> x = x;
+        WhitePoint -> y = y;
+        WhitePoint -> Y = 1.0;
 
-       return TRUE;
+        return TRUE;
 }
 
 
@@ -266,7 +266,7 @@
         {{  0.8951,  0.2664, -0.1614 }},
         {{ -0.7502,  1.7135,  0.0367 }},
         {{  0.0389, -0.0685,  1.0296 }}
-      }};
+    }};
 
     if (ConeMatrix == NULL)
         ConeMatrix = &LamRigg;
--- ./jdk/src/share/native/sun/java2d/cmm/lcms/cmsxform.c	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/native/sun/java2d/cmm/lcms/cmsxform.c	Tue Mar 18 12:35:25 2014 -0700
@@ -396,7 +396,7 @@
 static _cmsTransformCollection* TransformCollection = NULL;
 
 // Register new ways to transform
-cmsBool  _cmsRegisterTransformPlugin(cmsPluginBase* Data)
+cmsBool  _cmsRegisterTransformPlugin(cmsContext id, cmsPluginBase* Data)
 {
     cmsPluginTransform* Plugin = (cmsPluginTransform*) Data;
     _cmsTransformCollection* fl;
@@ -412,7 +412,7 @@
    if (Plugin ->Factory == NULL) return FALSE;
 
 
-    fl = (_cmsTransformCollection*) _cmsPluginMalloc(sizeof(_cmsTransformCollection));
+    fl = (_cmsTransformCollection*) _cmsPluginMalloc(id, sizeof(_cmsTransformCollection));
     if (fl == NULL) return FALSE;
 
       // Copy the parameters
@@ -651,6 +651,22 @@
 
 // ----------------------------------------------------------------------------------------------------------------
 
+static
+void SetWhitePoint(cmsCIEXYZ* wtPt, const cmsCIEXYZ* src)
+{
+    if (src == NULL) {
+        wtPt ->X = cmsD50X;
+        wtPt ->Y = cmsD50Y;
+        wtPt ->Z = cmsD50Z;
+    }
+    else {
+        wtPt ->X = src->X;
+        wtPt ->Y = src->Y;
+        wtPt ->Z = src->Z;
+    }
+
+}
+
 // New to lcms 2.0 -- have all parameters available.
 cmsHTRANSFORM CMSEXPORT cmsCreateExtendedTransform(cmsContext ContextID,
                                                    cmsUInt32Number nProfiles, cmsHPROFILE hProfiles[],
@@ -664,7 +680,6 @@
                                                    cmsUInt32Number dwFlags)
 {
     _cmsTRANSFORM* xform;
-    cmsBool  FloatTransform;
     cmsColorSpaceSignature EntryColorSpace;
     cmsColorSpaceSignature ExitColorSpace;
     cmsPipeline* Lut;
@@ -681,9 +696,7 @@
         if (hGamutProfile == NULL) dwFlags &= ~cmsFLAGS_GAMUTCHECK;
     }
 
-    // On floating point transforms, inhibit optimizations
-    FloatTransform = (_cmsFormatterIsFloat(InputFormat) && _cmsFormatterIsFloat(OutputFormat));
-
+    // On floating point transforms, inhibit cache
     if (_cmsFormatterIsFloat(InputFormat) || _cmsFormatterIsFloat(OutputFormat))
         dwFlags |= cmsFLAGS_NOCACHE;
 
@@ -730,6 +743,10 @@
     xform ->ExitColorSpace  = ExitColorSpace;
     xform ->RenderingIntent = Intents[nProfiles-1];
 
+    // Take white points
+    SetWhitePoint(&xform->EntryWhitePoint, (cmsCIEXYZ*) cmsReadTag(hProfiles[0], cmsSigMediaWhitePointTag));
+    SetWhitePoint(&xform->ExitWhitePoint,  (cmsCIEXYZ*) cmsReadTag(hProfiles[nProfiles-1], cmsSigMediaWhitePointTag));
+
 
     // Create a gamut check LUT if requested
     if (hGamutProfile != NULL && (dwFlags & cmsFLAGS_GAMUTCHECK))
--- ./jdk/src/share/native/sun/java2d/cmm/lcms/lcms2.h	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/native/sun/java2d/cmm/lcms/lcms2.h	Tue Mar 18 12:35:25 2014 -0700
@@ -30,7 +30,7 @@
 //---------------------------------------------------------------------------------
 //
 //  Little Color Management System
-//  Copyright (c) 1998-2011 Marti Maria Saguer
+//  Copyright (c) 1998-2013 Marti Maria Saguer
 //
 // Permission is hereby granted, free of charge, to any person obtaining
 // a copy of this software and associated documentation files (the "Software"),
@@ -52,7 +52,7 @@
 //
 //---------------------------------------------------------------------------------
 //
-// Version 2.4
+// Version 2.5
 //
 
 #ifndef _lcms2_H
@@ -101,7 +101,7 @@
 #endif
 
 // Version/release
-#define LCMS_VERSION        2040
+#define LCMS_VERSION        2050
 
 // I will give the chance of redefining basic types for compilers that are not fully C99 compliant
 #ifndef CMS_BASIC_TYPES_ALREADY_DEFINED
@@ -367,6 +367,7 @@
     cmsSigPreview1Tag                       = 0x70726531,  // 'pre1'
     cmsSigPreview2Tag                       = 0x70726532,  // 'pre2'
     cmsSigProfileDescriptionTag             = 0x64657363,  // 'desc'
+    cmsSigProfileDescriptionMLTag           = 0x6473636d,  // 'dscm'
     cmsSigProfileSequenceDescTag            = 0x70736571,  // 'pseq'
     cmsSigProfileSequenceIdTag              = 0x70736964,  // 'psid'
     cmsSigPs2CRD0Tag                        = 0x70736430,  // 'psd0'
@@ -1014,6 +1015,7 @@
 // Plug-In registering  ---------------------------------------------------------------------------------------------------
 
 CMSAPI cmsBool           CMSEXPORT cmsPlugin(void* Plugin);
+CMSAPI cmsBool           CMSEXPORT cmsPluginTHR(cmsContext ContextID, void* Plugin);
 CMSAPI void              CMSEXPORT cmsUnregisterPlugins(void);
 
 // Error logging ----------------------------------------------------------------------------------------------------------
@@ -1190,7 +1192,7 @@
 // Where to place/locate the stages in the pipeline chain
 typedef enum { cmsAT_BEGIN, cmsAT_END } cmsStageLoc;
 
-CMSAPI void              CMSEXPORT cmsPipelineInsertStage(cmsPipeline* lut, cmsStageLoc loc, cmsStage* mpe);
+CMSAPI int               CMSEXPORT cmsPipelineInsertStage(cmsPipeline* lut, cmsStageLoc loc, cmsStage* mpe);
 CMSAPI void              CMSEXPORT cmsPipelineUnlinkStage(cmsPipeline* lut, cmsStageLoc loc, cmsStage** mpe);
 
 // This function is quite useful to analyze the structure of a Pipeline and retrieve the Stage elements
@@ -1274,6 +1276,13 @@
                                                          const char LanguageCode[3], const char CountryCode[3],
                                                          char ObtainedLanguage[3], char ObtainedCountry[3]);
 
+CMSAPI cmsUInt32Number   CMSEXPORT cmsMLUtranslationsCount(const cmsMLU* mlu);
+
+CMSAPI cmsBool           CMSEXPORT cmsMLUtranslationsCodes(const cmsMLU* mlu,
+                                                             cmsUInt32Number idx,
+                                                             char LanguageCode[3],
+                                                             char CountryCode[3]);
+
 // Undercolorremoval & black generation -------------------------------------------------------------------------------------
 
 typedef struct {
@@ -1424,6 +1433,7 @@
 CMSAPI void              CMSEXPORT cmsSetHeaderFlags(cmsHPROFILE hProfile, cmsUInt32Number Flags);
 CMSAPI cmsUInt32Number   CMSEXPORT cmsGetHeaderManufacturer(cmsHPROFILE hProfile);
 CMSAPI void              CMSEXPORT cmsSetHeaderManufacturer(cmsHPROFILE hProfile, cmsUInt32Number manufacturer);
+CMSAPI cmsUInt32Number   CMSEXPORT cmsGetHeaderCreator(cmsHPROFILE hProfile);
 CMSAPI cmsUInt32Number   CMSEXPORT cmsGetHeaderModel(cmsHPROFILE hProfile);
 CMSAPI void              CMSEXPORT cmsSetHeaderModel(cmsHPROFILE hProfile, cmsUInt32Number model);
 CMSAPI void              CMSEXPORT cmsSetHeaderAttributes(cmsHPROFILE hProfile, cmsUInt64Number Flags);
--- ./jdk/src/share/native/sun/java2d/cmm/lcms/lcms2_internal.h	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/native/sun/java2d/cmm/lcms/lcms2_internal.h	Tue Mar 18 12:35:25 2014 -0700
@@ -27,7 +27,7 @@
 // However, the following notice accompanied the original version of this
 // file:
 //
-//---------------------------------------------------------------------------------
+
 //
 //  Little Color Management System
 //  Copyright (c) 1998-2011 Marti Maria Saguer
@@ -196,7 +196,7 @@
 // Plug-In registering ---------------------------------------------------------------
 
 // Specialized function for plug-in memory management. No pairing free() since whole pool is freed at once.
-void* _cmsPluginMalloc(cmsUInt32Number size);
+void* _cmsPluginMalloc(cmsContext ContextID, cmsUInt32Number size);
 
 // Memory management
 cmsBool   _cmsRegisterMemHandlerPlugin(cmsPluginBase* Plugin);
@@ -205,28 +205,28 @@
 cmsBool  _cmsRegisterInterpPlugin(cmsPluginBase* Plugin);
 
 // Parametric curves
-cmsBool  _cmsRegisterParametricCurvesPlugin(cmsPluginBase* Plugin);
+cmsBool  _cmsRegisterParametricCurvesPlugin(cmsContext ContextID, cmsPluginBase* Plugin);
 
 // Formatters management
-cmsBool  _cmsRegisterFormattersPlugin(cmsPluginBase* Plugin);
+cmsBool  _cmsRegisterFormattersPlugin(cmsContext ContextID, cmsPluginBase* Plugin);
 
 // Tag type management
-cmsBool  _cmsRegisterTagTypePlugin(cmsPluginBase* Plugin);
+cmsBool  _cmsRegisterTagTypePlugin(cmsContext ContextID, cmsPluginBase* Plugin);
 
 // Tag management
-cmsBool  _cmsRegisterTagPlugin(cmsPluginBase* Plugin);
+cmsBool  _cmsRegisterTagPlugin(cmsContext ContextID, cmsPluginBase* Plugin);
 
 // Intent management
-cmsBool  _cmsRegisterRenderingIntentPlugin(cmsPluginBase* Plugin);
+cmsBool  _cmsRegisterRenderingIntentPlugin(cmsContext ContextID, cmsPluginBase* Plugin);
 
 // Multi Process elements
-cmsBool  _cmsRegisterMultiProcessElementPlugin(cmsPluginBase* Plugin);
+cmsBool  _cmsRegisterMultiProcessElementPlugin(cmsContext ContextID, cmsPluginBase* Plugin);
 
 // Optimization
-cmsBool  _cmsRegisterOptimizationPlugin(cmsPluginBase* Plugin);
+cmsBool  _cmsRegisterOptimizationPlugin(cmsContext ContextID, cmsPluginBase* Plugin);
 
 // Transform
-cmsBool  _cmsRegisterTransformPlugin(cmsPluginBase* Plugin);
+cmsBool  _cmsRegisterTransformPlugin(cmsContext ContextID, cmsPluginBase* Plugin);
 
 // ---------------------------------------------------------------------------------------------------------
 
@@ -263,7 +263,7 @@
     cmsUInt16Number Country;
 
     cmsUInt32Number StrW;       // Offset to current unicode string
-    cmsUInt32Number Len;        // Lenght in bytes
+    cmsUInt32Number Len;        // Length in bytes
 
 } _cmsMLUentry;
 
@@ -330,9 +330,11 @@
     cmsColorSpaceSignature   ColorSpace;
     cmsColorSpaceSignature   PCS;
     cmsUInt32Number          RenderingIntent;
+
     cmsUInt32Number          flags;
     cmsUInt32Number          manufacturer, model;
     cmsUInt64Number          attributes;
+    cmsUInt32Number          creator;
 
     cmsProfileID             ProfileID;
 
@@ -585,6 +587,10 @@
     cmsColorSpaceSignature EntryColorSpace;
     cmsColorSpaceSignature ExitColorSpace;
 
+    // White points (informative only)
+    cmsCIEXYZ EntryWhitePoint;
+    cmsCIEXYZ ExitWhitePoint;
+
     // Profiles used to create the transform
     cmsSEQ* Sequence;
 
--- ./jdk/src/share/native/sun/management/Flag.c	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/native/sun/management/Flag.c	Tue Mar 18 12:35:25 2014 -0700
@@ -95,12 +95,12 @@
         return 0;
     }
 
-    if (count == 0) {
+    if (count <= 0) {
         JNU_ThrowIllegalArgumentException(env, 0);
         return 0;
     }
 
-    gsize = count * sizeof(jmmVMGlobal);
+    gsize = (size_t)count * sizeof(jmmVMGlobal);
     globals = (jmmVMGlobal*) malloc(gsize);
     if (globals == NULL) {
         JNU_ThrowOutOfMemoryError(env, 0);
--- ./jdk/src/share/native/sun/management/GcInfoBuilder.c	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/share/native/sun/management/GcInfoBuilder.c	Tue Mar 18 12:35:25 2014 -0700
@@ -59,12 +59,12 @@
         return;
     }
 
-    if (num_attributes == 0) {
+    if (num_attributes <= 0) {
         JNU_ThrowIllegalArgumentException(env, "Invalid num_attributes");
         return;
     }
 
-    ext_att_info = (jmmExtAttributeInfo*) malloc(num_attributes *
+    ext_att_info = (jmmExtAttributeInfo*) malloc((size_t)num_attributes *
                                                  sizeof(jmmExtAttributeInfo));
     if (ext_att_info == NULL) {
         JNU_ThrowOutOfMemoryError(env, 0);
@@ -78,7 +78,7 @@
         return;
     }
 
-    nativeTypes = (jchar*) malloc(num_attributes * sizeof(jchar));
+    nativeTypes = (jchar*) malloc((size_t)num_attributes * sizeof(jchar));
     if (nativeTypes == NULL) {
         free(ext_att_info);
         JNU_ThrowOutOfMemoryError(env, 0);
@@ -188,11 +188,16 @@
         return 0;
     }
 
+    if (ext_att_count <= 0) {
+        JNU_ThrowIllegalArgumentException(env, "Invalid ext_att_count");
+        return;
+    }
+
     gc_stat.usage_before_gc = usageBeforeGC;
     gc_stat.usage_after_gc = usageAfterGC;
     gc_stat.gc_ext_attribute_values_size = ext_att_count;
     if (ext_att_count > 0) {
-        gc_stat.gc_ext_attribute_values = (jvalue*) malloc(ext_att_count *
+        gc_stat.gc_ext_attribute_values = (jvalue*) malloc((size_t)ext_att_count *
                                                            sizeof(jvalue));
         if (gc_stat.gc_ext_attribute_values == NULL) {
             JNU_ThrowOutOfMemoryError(env, 0);
@@ -212,7 +217,7 @@
     }
 
     // convert the ext_att_types to native types
-    nativeTypes = (jchar*) malloc(ext_att_count * sizeof(jchar));
+    nativeTypes = (jchar*) malloc((size_t)ext_att_count * sizeof(jchar));
     if (nativeTypes == NULL) {
         if (gc_stat.gc_ext_attribute_values != NULL) {
             free(gc_stat.gc_ext_attribute_values);
--- ./jdk/src/solaris/classes/java/lang/UNIXProcess.java.bsd	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/solaris/classes/java/lang/UNIXProcess.java.bsd	Tue Mar 18 12:35:25 2014 -0700
@@ -63,11 +63,59 @@
     private /* final */ InputStream  stdout;
     private /* final */ InputStream  stderr;
 
+    private static enum LaunchMechanism {
+        FORK(1),
+        POSIX_SPAWN(2);
+
+        private int value;
+        LaunchMechanism(int x) {value = x;}
+    };
+
+    /* On BSD, the default is to spawn */
+    private static final LaunchMechanism launchMechanism;
+    private static byte[] helperpath;
+
+    private static byte[] toCString(String s) {
+        if (s == null)
+            return null;
+        byte[] bytes = s.getBytes();
+        byte[] result = new byte[bytes.length + 1];
+        System.arraycopy(bytes, 0,
+                         result, 0,
+                         bytes.length);
+        result[result.length-1] = (byte)0;
+        return result;
+    }
+
+    static {
+        launchMechanism = AccessController.doPrivileged(
+                new PrivilegedAction<LaunchMechanism>()
+        {
+            public LaunchMechanism run() {
+                String javahome = System.getProperty("java.home");
+
+                helperpath = toCString(javahome + "/lib/jspawnhelper");
+                String s = System.getProperty(
+                    "jdk.lang.Process.launchMechanism", "posix_spawn");
+
+                try {
+                    return LaunchMechanism.valueOf(s.toUpperCase());
+                } catch (IllegalArgumentException e) {
+                    throw new Error(s + " is not a supported " +
+                        "process launch mechanism on this platform.");
+                }
+            }
+        });
+    }
+
     /* this is for the reaping thread */
     private native int waitForProcessExit(int pid);
 
     /**
-     * Create a process using fork(2) and exec(2).
+     * Create a process. Depending on the mode flag, this is done by
+     * one of the following mechanisms.
+     * - fork(2) and exec(2)
+     * - posix_spawn(2)
      *
      * @param fds an array of three file descriptors.
      *        Indexes 0, 1, and 2 correspond to standard input,
@@ -80,7 +128,8 @@
      *        output.
      * @return the pid of the subprocess
      */
-    private native int forkAndExec(byte[] prog,
+    private native int forkAndExec(int mode, byte[] helperpath,
+                                   byte[] prog,
                                    byte[] argBlock, int argc,
                                    byte[] envBlock, int envc,
                                    byte[] dir,
@@ -132,7 +181,9 @@
                 final boolean redirectErrorStream)
             throws IOException {
 
-        pid = forkAndExec(prog,
+        pid = forkAndExec(launchMechanism.value,
+                          helperpath,
+                          prog,
                           argBlock, argc,
                           envBlock, envc,
                           dir,
@@ -236,11 +287,10 @@
         try { stderr.close(); } catch (IOException ignored) {}
     }
 
-    /* This routine initializes JNI field offsets for the class */
-    private static native void initIDs();
+    private static native void init();
 
     static {
-        initIDs();
+        init();
     }
 
     /**
--- ./jdk/src/solaris/classes/java/lang/UNIXProcess.java.linux	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/solaris/classes/java/lang/UNIXProcess.java.linux	Tue Mar 18 12:35:25 2014 -0700
@@ -63,11 +63,61 @@
     private /* final */ InputStream  stdout;
     private /* final */ InputStream  stderr;
 
+    private static enum LaunchMechanism {
+        FORK(1),
+        VFORK(3);
+
+        private int value;
+        LaunchMechanism(int x) {value = x;}
+    };
+
+    /* default is VFORK on Linux */
+    private static final LaunchMechanism launchMechanism;
+    private static byte[] helperpath;
+
+    private static byte[] toCString(String s) {
+        if (s == null)
+            return null;
+        byte[] bytes = s.getBytes();
+        byte[] result = new byte[bytes.length + 1];
+        System.arraycopy(bytes, 0,
+                         result, 0,
+                         bytes.length);
+        result[result.length-1] = (byte)0;
+        return result;
+    }
+
+    static {
+        launchMechanism = AccessController.doPrivileged(
+                new PrivilegedAction<LaunchMechanism>()
+        {
+            public LaunchMechanism run() {
+                String javahome = System.getProperty("java.home");
+                String osArch = System.getProperty("os.arch");
+
+                helperpath = toCString(javahome + "/lib/" + osArch + "/jspawnhelper");
+                String s = System.getProperty(
+                    "jdk.lang.Process.launchMechanism", "vfork");
+
+                try {
+                    return LaunchMechanism.valueOf(s.toUpperCase());
+                } catch (IllegalArgumentException e) {
+                    throw new Error(s + " is not a supported " +
+                        "process launch mechanism on this platform.");
+                }
+            }
+        });
+    }
+
     /* this is for the reaping thread */
     private native int waitForProcessExit(int pid);
 
     /**
-     * Create a process using fork(2) and exec(2).
+     * Create a process. Depending on the mode flag, this is done by
+     * one of the following mechanisms.
+     * - fork(2) and exec(2)
+     * - clone(2) and exec(2)
+     * - vfork(2) and exec(2)
      *
      * @param fds an array of three file descriptors.
      *        Indexes 0, 1, and 2 correspond to standard input,
@@ -80,7 +130,8 @@
      *        output.
      * @return the pid of the subprocess
      */
-    private native int forkAndExec(byte[] prog,
+    private native int forkAndExec(int mode, byte[] helperpath,
+                                   byte[] prog,
                                    byte[] argBlock, int argc,
                                    byte[] envBlock, int envc,
                                    byte[] dir,
@@ -132,7 +183,9 @@
                 final boolean redirectErrorStream)
             throws IOException {
 
-        pid = forkAndExec(prog,
+        pid = forkAndExec(launchMechanism.value,
+                          helperpath,
+                          prog,
                           argBlock, argc,
                           envBlock, envc,
                           dir,
@@ -236,11 +289,10 @@
         try { stderr.close(); } catch (IOException ignored) {}
     }
 
-    /* This routine initializes JNI field offsets for the class */
-    private static native void initIDs();
+    private static native void init();
 
     static {
-        initIDs();
+        init();
     }
 
     /**
--- ./jdk/src/solaris/classes/java/lang/UNIXProcess.java.solaris	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/solaris/classes/java/lang/UNIXProcess.java.solaris	Tue Mar 18 12:35:25 2014 -0700
@@ -26,6 +26,8 @@
 package java.lang;
 
 import java.io.*;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 
 /* java.lang.Process subclass in the UNIX environment.
  *
@@ -45,11 +47,65 @@
     private DeferredCloseInputStream stdout_inner_stream;
     private InputStream stderr_stream;
 
+    private static enum LaunchMechanism {
+        FORK(1),
+        POSIX_SPAWN(2);
+
+        private int value;
+        LaunchMechanism(int x) {value = x;}
+    };
+
+    /* On Solaris, the default is to spawn */
+    private static final LaunchMechanism launchMechanism;
+    private static byte[] helperpath;
+
+    private static byte[] toCString(String s) {
+        if (s == null)
+            return null;
+        byte[] bytes = s.getBytes();
+        byte[] result = new byte[bytes.length + 1];
+        System.arraycopy(bytes, 0,
+                         result, 0,
+                         bytes.length);
+        result[result.length-1] = (byte)0;
+        return result;
+    }
+
+    static {
+        launchMechanism = AccessController.doPrivileged(
+                new PrivilegedAction<LaunchMechanism>()
+        {
+            public LaunchMechanism run() {
+                String javahome = System.getProperty("java.home");
+                String osArch = System.getProperty("os.arch");
+                if (osArch.equals("x86")) {
+                    osArch = "i386";
+                } else if (osArch.equals("x86_64")) {
+                    osArch = "amd64";
+                }
+
+                helperpath = toCString(javahome + "/lib/" + osArch + "/jspawnhelper");
+                String s = System.getProperty(
+                    "jdk.lang.Process.launchMechanism", "fork");
+
+                try {
+                    return LaunchMechanism.valueOf(s.toUpperCase());
+                } catch (IllegalArgumentException e) {
+                    throw new Error(s + " is not a supported " +
+                        "process launch mechanism on this platform.");
+                }
+            }
+        });
+    }
+
     /* this is for the reaping thread */
     private native int waitForProcessExit(int pid);
 
     /**
-     * Create a process using fork(2) and exec(2).
+     * Create a process. Depending on the mode flag, this is done by
+     * one of the following mechanisms.
+     * - fork(2) and exec(2)
+     * - posix_spawn(2)
      *
      * @param std_fds array of file descriptors.  Indexes 0, 1, and
      *        2 correspond to standard input, standard output and
@@ -61,7 +117,8 @@
      *        if and only if it is <em>not</em> -1 on output.
      * @return the pid of the subprocess
      */
-    private native int forkAndExec(byte[] prog,
+    private native int forkAndExec(int mode, byte[] helperpath,
+                                   byte[] prog,
                                    byte[] argBlock, int argc,
                                    byte[] envBlock, int envc,
                                    byte[] dir,
@@ -76,7 +133,9 @@
                 final int[] std_fds,
                 final boolean redirectErrorStream)
     throws IOException {
-        pid = forkAndExec(prog,
+        pid = forkAndExec(launchMechanism.value,
+                          helperpath,
+                          prog,
                           argBlock, argc,
                           envBlock, envc,
                           dir,
@@ -294,10 +353,9 @@
 
     }
 
-    /* This routine initializes JNI field offsets for the class */
-    private static native void initIDs();
+    private static native void init();
 
     static {
-        initIDs();
+        init();
     }
 }
--- ./jdk/src/solaris/classes/sun/awt/X11/XClipboard.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/solaris/classes/sun/awt/X11/XClipboard.java	Tue Mar 18 12:35:25 2014 -0700
@@ -84,7 +84,7 @@
 
     protected synchronized void setContentsNative(Transferable contents) {
         SortedMap formatMap = DataTransferer.getInstance().getFormatsForTransferable
-                (contents, DataTransferer.adaptFlavorMap(flavorMap));
+                (contents, DataTransferer.adaptFlavorMap(getDefaultFlavorTable()));
         long[] formats = DataTransferer.keysToLongArray(formatMap);
 
         if (!selection.setOwner(contents, formatMap, formats,
@@ -123,7 +123,7 @@
     private void checkChangeHere(Transferable contents) {
         if (areFlavorListenersRegistered()) {
             checkChange(DataTransferer.getInstance().
-                        getFormatsForTransferableAsArray(contents, flavorMap));
+                        getFormatsForTransferableAsArray(contents, getDefaultFlavorTable()));
         }
     }
 
--- ./jdk/src/solaris/classes/sun/awt/X11/XToolkit.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/solaris/classes/sun/awt/X11/XToolkit.java	Tue Mar 18 12:35:25 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2002, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2002, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -49,6 +49,7 @@
 import sun.awt.*;
 import sun.font.FontConfigManager;
 import sun.misc.PerformanceLogger;
+import sun.misc.ThreadGroupUtils;
 import sun.print.PrintJob2D;
 import sun.security.action.GetPropertyAction;
 import sun.security.action.GetBooleanAction;
@@ -311,13 +312,7 @@
         }
         PrivilegedAction<Void> a = new PrivilegedAction<Void>() {
             public Void run() {
-                ThreadGroup mainTG = Thread.currentThread().getThreadGroup();
-                ThreadGroup parentTG = mainTG.getParent();
-                while (parentTG != null) {
-                    mainTG = parentTG;
-                    parentTG = mainTG.getParent();
-                }
-                Thread shutdownThread = new Thread(mainTG, "XToolkt-Shutdown-Thread") {
+                Thread shutdownThread = new Thread(ThreadGroupUtils.getRootThreadGroup(), "XToolkt-Shutdown-Thread") {
                         public void run() {
                             XSystemTrayPeer peer = XSystemTrayPeer.getPeerInstance();
                             if (peer != null) {
@@ -379,22 +374,16 @@
             init();
             XWM.init();
             SunToolkit.setDataTransfererClassName(DATA_TRANSFERER_CLASS_NAME);
-
-            PrivilegedAction<Thread> action = new PrivilegedAction() {
+            toolkitThread = AccessController.doPrivileged(new PrivilegedAction<Thread>() {
+                @Override
                 public Thread run() {
-                    ThreadGroup currentTG = Thread.currentThread().getThreadGroup();
-                    ThreadGroup parentTG = currentTG.getParent();
-                    while (parentTG != null) {
-                        currentTG = parentTG;
-                        parentTG = currentTG.getParent();
-                    }
-                    Thread thread = new Thread(currentTG, XToolkit.this, "AWT-XAWT");
+                    Thread thread = new Thread(ThreadGroupUtils.getRootThreadGroup(), XToolkit.this, "AWT-XAWT");
+                    thread.setContextClassLoader(null);
                     thread.setPriority(Thread.NORM_PRIORITY + 1);
                     thread.setDaemon(true);
                     return thread;
                 }
-            };
-            toolkitThread = AccessController.doPrivileged(action);
+            });
             toolkitThread.start();
         }
     }
--- ./jdk/src/solaris/classes/sun/awt/X11GraphicsDevice.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/solaris/classes/sun/awt/X11GraphicsDevice.java	Tue Mar 18 12:35:25 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -41,6 +41,7 @@
 import sun.java2d.opengl.GLXGraphicsConfig;
 import sun.java2d.xr.XRGraphicsConfig;
 import sun.java2d.loops.SurfaceType;
+import sun.misc.ThreadGroupUtils;
 
 /**
  * This is an implementation of a GraphicsDevice object for a single
@@ -424,23 +425,20 @@
             // hook will have no effect)
             shutdownHookRegistered = true;
             PrivilegedAction<Void> a = new PrivilegedAction<Void>() {
+                @Override
                 public Void run() {
-                    ThreadGroup mainTG = Thread.currentThread().getThreadGroup();
-                    ThreadGroup parentTG = mainTG.getParent();
-                    while (parentTG != null) {
-                        mainTG = parentTG;
-                        parentTG = mainTG.getParent();
-                    }
+                    ThreadGroup rootTG = ThreadGroupUtils.getRootThreadGroup();
                     Runnable r = new Runnable() {
-                            public void run() {
-                                Window old = getFullScreenWindow();
-                                if (old != null) {
-                                    exitFullScreenExclusive(old);
-                                    setDisplayMode(origDisplayMode);
-                                }
+                        @Override
+                        public void run() {
+                            Window old = getFullScreenWindow();
+                            if (old != null) {
+                                exitFullScreenExclusive(old);
+                                setDisplayMode(origDisplayMode);
                             }
-                        };
-                    Thread t = new Thread(mainTG, r,"Display-Change-Shutdown-Thread-"+screen);
+                        }
+                    };
+                    Thread t = new Thread(rootTG, r, "Display-Change-Shutdown-Thread-" + screen);
                     t.setContextClassLoader(null);
                     Runtime.getRuntime().addShutdownHook(t);
                     return null;
--- ./jdk/src/solaris/demo/jni/Poller/Poller.c	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/solaris/demo/jni/Poller/Poller.c	Tue Mar 18 12:35:25 2014 -0700
@@ -318,7 +318,7 @@
 
   ioevent_t *ioeh;
 
-  if (handle < 0 || handle > MAX_HANDLES)
+  if (handle < 0 || handle >= MAX_HANDLES)
     {
       STATE_EXCEPTION("DestroyPoller - handle out of range");
       return;
@@ -366,7 +366,7 @@
   int retval;
   ioevent_t *ioeh;
 
-  if (handle < 0 || handle > MAX_HANDLES)
+  if (handle < 0 || handle >= MAX_HANDLES)
     return STATE_EXCEPTION("AddFd - handle out of range");
 
   ioeh = &IOE_handles[handle];
@@ -459,7 +459,7 @@
   return fd;
 }
 
-/*
+/*
  * Class:     Poller
  * Method:    nativeRemoveFd
  * Signature: (II)I
@@ -469,7 +469,7 @@
 {
   ioevent_t *ioeh;
 
-  if (handle < 0 || handle > MAX_HANDLES)
+  if (handle < 0 || handle >= MAX_HANDLES)
     return STATE_EXCEPTION("RemoveFd - handle out of range");
 
   ioeh = &IOE_handles[handle];
@@ -576,7 +576,7 @@
   int i;
   ioevent_t *ioeh;
 
-  if (handle < 0 || handle > MAX_HANDLES)
+  if (handle < 0 || handle >= MAX_HANDLES)
     return STATE_EXCEPTION("IsMember - handle out of range");
 
   ioeh = &IOE_handles[handle];
@@ -629,7 +629,7 @@
   ioevent_t *ioeh;
   jboolean isCopy1,isCopy2;
 
-  if (handle < 0 || handle > MAX_HANDLES)
+  if (handle < 0 || handle >= MAX_HANDLES)
     return STATE_EXCEPTION("nativeWait - handle out of range");
 
   ioeh = &IOE_handles[handle];
--- ./jdk/src/solaris/native/com/sun/media/sound/PLATFORM_API_SolarisOS_Utils.c	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/solaris/native/com/sun/media/sound/PLATFORM_API_SolarisOS_Utils.c	Tue Mar 18 12:35:25 2014 -0700
@@ -76,7 +76,7 @@
             adPath[*count].st_ino = statBuf.st_ino;
             adPath[*count].st_dev = statBuf.st_dev;
             strncpy(adPath[*count].path, path, MAX_NAME_LENGTH);
-            adPath[*count].path[MAX_NAME_LENGTH] = 0;
+            adPath[*count].path[MAX_NAME_LENGTH - 1] = 0;
             (*count)++;
             TRACE1("Added audio device %s\n", path);
         }
--- ./jdk/src/solaris/native/java/lang/ProcessEnvironment_md.c	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/solaris/native/java/lang/ProcessEnvironment_md.c	Tue Mar 18 12:35:25 2014 -0700
@@ -31,21 +31,24 @@
 #ifdef __APPLE__
 #include <crt_externs.h>
 #define environ (*_NSGetEnviron())
+#else
+/* This is one of the rare times it's more portable to declare an
+ * external symbol explicitly, rather than via a system header.
+ * The declaration is standardized as part of UNIX98, but there is
+ * no standard (not even de-facto) header file where the
+ * declaration is to be found.  See:
+ * http://www.opengroup.org/onlinepubs/009695399/functions/environ.html
+ * http://www.opengroup.org/onlinepubs/009695399/functions/xsh_chap02_02.html
+ *
+ * "All identifiers in this volume of IEEE Std 1003.1-2001, except
+ * environ, are defined in at least one of the headers" (!)
+ */
+extern char **environ;
 #endif
 
 JNIEXPORT jobjectArray JNICALL
 Java_java_lang_ProcessEnvironment_environ(JNIEnv *env, jclass ign)
 {
-    /* This is one of the rare times it's more portable to declare an
-     * external symbol explicitly, rather than via a system header.
-     * The declaration is standardized as part of UNIX98, but there is
-     * no standard (not even de-facto) header file where the
-     * declaration is to be found.  See:
-     * http://www.opengroup.org/onlinepubs/007908799/xbd/envvar.html */
-#ifndef __APPLE__
-    extern char ** environ; /* environ[i] looks like: VAR=VALUE\0 */
-#endif
-
     jsize count = 0;
     jsize i, j;
     jobjectArray result;
--- ./jdk/src/solaris/native/java/lang/UNIXProcess_md.c	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/solaris/native/java/lang/UNIXProcess_md.c	Tue Mar 18 12:35:25 2014 -0700
@@ -47,19 +47,15 @@
 #endif
 #include <signal.h>
 #include <string.h>
-#include <errno.h>
-#include <dirent.h>
-#include <unistd.h>
-#include <fcntl.h>
-#include <limits.h>
 
-#ifdef __APPLE__
-#include <crt_externs.h>
-#define environ (*_NSGetEnviron())
+#if defined(__solaris__) || defined(_ALLBSD_SOURCE)
+#include <spawn.h>
 #endif
 
+#include "childproc.h"
+
 /*
- * There are 3 possible strategies we might use to "fork":
+ * There are 4 possible strategies we might use to "fork":
  *
  * - fork(2).  Very portable and reliable but subject to
  *   failure due to overcommit (see the documentation on
@@ -94,81 +90,21 @@
  *     http://sources.redhat.com/bugzilla/show_bug.cgi?id=10311
  *   but the glibc maintainers closed it as WONTFIX.
  *
+ * - posix_spawn(). While posix_spawn() is a fairly elaborate and
+ *   complicated system call, it can't quite do everything that the old
+ *   fork()/exec() combination can do, so the only feasible way to do
+ *   this, is to use posix_spawn to launch a new helper executable
+ *   "jprochelper", which in turn execs the target (after cleaning
+ *   up file-descriptors etc.) The end result is the same as before,
+ *   a child process linked to the parent in the same way, but it
+ *   avoids the problem of duplicating the parent (VM) process
+ *   address space temporarily, before launching the target command.
+ *
  * Based on the above analysis, we are currently using vfork() on
- * Linux and fork() on other Unix systems, but the code to use clone()
- * remains.
+ * Linux, posix_spawn() on Mac and fork() on Solaris, but the code to
+ * use clone() and fork() remains.
  */
 
-#define START_CHILD_USE_CLONE 0  /* clone() currently disabled; see above. */
-
-#ifndef START_CHILD_USE_CLONE
-  #ifdef __linux__
-    #define START_CHILD_USE_CLONE 1
-  #else
-    #define START_CHILD_USE_CLONE 0
-  #endif
-#endif
-
-/* By default, use vfork() on Linux. */
-#ifndef START_CHILD_USE_VFORK
-  #ifdef __linux__
-    #define START_CHILD_USE_VFORK 1
-  #else
-    #define START_CHILD_USE_VFORK 0
-  #endif
-#endif
-
-#if START_CHILD_USE_CLONE
-#include <sched.h>
-#define START_CHILD_SYSTEM_CALL "clone"
-#elif START_CHILD_USE_VFORK
-#define START_CHILD_SYSTEM_CALL "vfork"
-#else
-#define START_CHILD_SYSTEM_CALL "fork"
-#endif
-
-#ifndef STDIN_FILENO
-#define STDIN_FILENO 0
-#endif
-
-#ifndef STDOUT_FILENO
-#define STDOUT_FILENO 1
-#endif
-
-#ifndef STDERR_FILENO
-#define STDERR_FILENO 2
-#endif
-
-#ifndef SA_NOCLDSTOP
-#define SA_NOCLDSTOP 0
-#endif
-
-#ifndef SA_RESTART
-#define SA_RESTART 0
-#endif
-
-#define FAIL_FILENO (STDERR_FILENO + 1)
-
-/* TODO: Refactor. */
-#define RESTARTABLE(_cmd, _result) do { \
-  do { \
-    _result = _cmd; \
-  } while((_result == -1) && (errno == EINTR)); \
-} while(0)
-
-/* This is one of the rare times it's more portable to declare an
- * external symbol explicitly, rather than via a system header.
- * The declaration is standardized as part of UNIX98, but there is
- * no standard (not even de-facto) header file where the
- * declaration is to be found.  See:
- * http://www.opengroup.org/onlinepubs/009695399/functions/environ.html
- * http://www.opengroup.org/onlinepubs/009695399/functions/xsh_chap02_02.html
- *
- * "All identifiers in this volume of IEEE Std 1003.1-2001, except
- * environ, are defined in at least one of the headers" (!)
- */
-extern char **environ;
-
 
 static void
 setSIGCHLDHandler(JNIEnv *env)
@@ -245,53 +181,35 @@
 }
 
 static const char * const *
-splitPath(JNIEnv *env, const char *path)
+effectivePathv(JNIEnv *env)
 {
-    const char *p, *q;
-    char **pathv;
+    char *p;
     int i;
+    const char *path = effectivePath();
     int count = countOccurrences(path, ':') + 1;
+    size_t pathvsize = sizeof(const char *) * (count+1);
+    size_t pathsize = strlen(path) + 1;
+    const char **pathv = (const char **) xmalloc(env, pathvsize + pathsize);
 
-    pathv = NEW(char*, count+1);
+    if (pathv == NULL)
+        return NULL;
+    p = (char *) pathv + pathvsize;
+    memcpy(p, path, pathsize);
+    /* split PATH by replacing ':' with NULs; empty components => "." */
+    for (i = 0; i < count; i++) {
+        char *q = p + strcspn(p, ":");
+        pathv[i] = (p == q) ? "." : p;
+        *q = '\0';
+        p = q + 1;
+    }
     pathv[count] = NULL;
-    for (p = path, i = 0; i < count; i++, p = q + 1) {
-        for (q = p; (*q != ':') && (*q != '\0'); q++)
-            ;
-        if (q == p)             /* empty PATH component => "." */
-            pathv[i] = "./";
-        else {
-            int addSlash = ((*(q - 1)) != '/');
-            pathv[i] = NEW(char, q - p + addSlash + 1);
-            memcpy(pathv[i], p, q - p);
-            if (addSlash)
-                pathv[i][q - p] = '/';
-            pathv[i][q - p + addSlash] = '\0';
-        }
-    }
-    return (const char * const *) pathv;
+    return pathv;
 }
 
-/**
- * Cached value of JVM's effective PATH.
- * (We don't support putenv("PATH=...") in native code)
- */
-static const char *parentPath;
-
-/**
- * Split, canonicalized version of parentPath
- */
-static const char * const *parentPathv;
-
-static jfieldID field_exitcode;
-
 JNIEXPORT void JNICALL
-Java_java_lang_UNIXProcess_initIDs(JNIEnv *env, jclass clazz)
+Java_java_lang_UNIXProcess_init(JNIEnv *env, jclass clazz)
 {
-    field_exitcode = (*env)->GetFieldID(env, clazz, "exitcode", "I");
-
-    parentPath  = effectivePath();
-    parentPathv = splitPath(env, parentPath);
-
+    parentPathv = effectivePathv(env);
     setSIGCHLDHandler(env);
 }
 
@@ -358,96 +276,6 @@
     }
 }
 
-static ssize_t
-restartableWrite(int fd, const void *buf, size_t count)
-{
-    ssize_t result;
-    RESTARTABLE(write(fd, buf, count), result);
-    return result;
-}
-
-static int
-restartableDup2(int fd_from, int fd_to)
-{
-    int err;
-    RESTARTABLE(dup2(fd_from, fd_to), err);
-    return err;
-}
-
-static int
-restartableClose(int fd)
-{
-    int err;
-    RESTARTABLE(close(fd), err);
-    return err;
-}
-
-static int
-closeSafely(int fd)
-{
-    return (fd == -1) ? 0 : restartableClose(fd);
-}
-
-static int
-isAsciiDigit(char c)
-{
-  return c >= '0' && c <= '9';
-}
-
-#ifdef _ALLBSD_SOURCE
-#define FD_DIR "/dev/fd"
-#define dirent64 dirent
-#define readdir64 readdir
-#else
-#define FD_DIR "/proc/self/fd"
-#endif
-
-static int
-closeDescriptors(void)
-{
-    DIR *dp;
-    struct dirent64 *dirp;
-    int from_fd = FAIL_FILENO + 1;
-
-    /* We're trying to close all file descriptors, but opendir() might
-     * itself be implemented using a file descriptor, and we certainly
-     * don't want to close that while it's in use.  We assume that if
-     * opendir() is implemented using a file descriptor, then it uses
-     * the lowest numbered file descriptor, just like open().  So we
-     * close a couple explicitly.  */
-
-    restartableClose(from_fd);          /* for possible use by opendir() */
-    restartableClose(from_fd + 1);      /* another one for good luck */
-
-    if ((dp = opendir(FD_DIR)) == NULL)
-        return 0;
-
-    /* We use readdir64 instead of readdir to work around Solaris bug
-     * 6395699: /proc/self/fd fails to report file descriptors >= 1024 on Solaris 9
-     */
-    while ((dirp = readdir64(dp)) != NULL) {
-        int fd;
-        if (isAsciiDigit(dirp->d_name[0]) &&
-            (fd = strtol(dirp->d_name, NULL, 10)) >= from_fd + 2)
-            restartableClose(fd);
-    }
-
-    closedir(dp);
-
-    return 1;
-}
-
-static int
-moveDescriptor(int fd_from, int fd_to)
-{
-    if (fd_from != fd_to) {
-        if ((restartableDup2(fd_from, fd_to) == -1) ||
-            (restartableClose(fd_from) == -1))
-            return -1;
-    }
-    return 0;
-}
-
 static const char *
 getBytes(JNIEnv *env, jbyteArray arr)
 {
@@ -463,19 +291,6 @@
 }
 
 static void
-initVectorFromBlock(const char**vector, const char* block, int count)
-{
-    int i;
-    const char *p;
-    for (i = 0, p = block; i < count; i++) {
-        /* Invariant: p always points to the start of a C string. */
-        vector[i] = p;
-        while (*(p++));
-    }
-    vector[count] = NULL;
-}
-
-static void
 throwIOException(JNIEnv *env, int errnum, const char *defaultDetail)
 {
     static const char * const format = "error=%d, %s";
@@ -490,6 +305,9 @@
     }
     /* ASCII Decimal representation uses 2.4 times as many bits as binary. */
     errmsg = NEW(char, strlen(format) + strlen(detail) + 3 * sizeof(errnum));
+    if (errmsg == NULL)
+        return;
+
     sprintf(errmsg, format, errnum, detail);
     s = JNU_NewStringPlatform(env, errmsg);
     if (s != NULL) {
@@ -515,180 +333,6 @@
 }
 #endif /* DEBUG_PROCESS */
 
-/**
- * Exec FILE as a traditional Bourne shell script (i.e. one without #!).
- * If we could do it over again, we would probably not support such an ancient
- * misfeature, but compatibility wins over sanity.  The original support for
- * this was imported accidentally from execvp().
- */
-static void
-execve_as_traditional_shell_script(const char *file,
-                                   const char *argv[],
-                                   const char *const envp[])
-{
-    /* Use the extra word of space provided for us in argv by caller. */
-    const char *argv0 = argv[0];
-    const char *const *end = argv;
-    while (*end != NULL)
-        ++end;
-    memmove(argv+2, argv+1, (end-argv) * sizeof (*end));
-    argv[0] = "/bin/sh";
-    argv[1] = file;
-    execve(argv[0], (char **) argv, (char **) envp);
-    /* Can't even exec /bin/sh?  Big trouble, but let's soldier on... */
-    memmove(argv+1, argv+2, (end-argv) * sizeof (*end));
-    argv[0] = argv0;
-}
-
-/**
- * Like execve(2), except that in case of ENOEXEC, FILE is assumed to
- * be a shell script and the system default shell is invoked to run it.
- */
-static void
-execve_with_shell_fallback(const char *file,
-                           const char *argv[],
-                           const char *const envp[])
-{
-#if START_CHILD_USE_CLONE || START_CHILD_USE_VFORK
-    /* shared address space; be very careful. */
-    execve(file, (char **) argv, (char **) envp);
-    if (errno == ENOEXEC)
-        execve_as_traditional_shell_script(file, argv, envp);
-#else
-    /* unshared address space; we can mutate environ. */
-    environ = (char **) envp;
-    execvp(file, (char **) argv);
-#endif
-}
-
-/**
- * 'execvpe' should have been included in the Unix standards,
- * and is a GNU extension in glibc 2.10.
- *
- * JDK_execvpe is identical to execvp, except that the child environment is
- * specified via the 3rd argument instead of being inherited from environ.
- */
-static void
-JDK_execvpe(const char *file,
-            const char *argv[],
-            const char *const envp[])
-{
-    if (envp == NULL || (char **) envp == environ) {
-        execvp(file, (char **) argv);
-        return;
-    }
-
-    if (*file == '\0') {
-        errno = ENOENT;
-        return;
-    }
-
-    if (strchr(file, '/') != NULL) {
-        execve_with_shell_fallback(file, argv, envp);
-    } else {
-        /* We must search PATH (parent's, not child's) */
-        char expanded_file[PATH_MAX];
-        int filelen = strlen(file);
-        int sticky_errno = 0;
-        const char * const * dirs;
-        for (dirs = parentPathv; *dirs; dirs++) {
-            const char * dir = *dirs;
-            int dirlen = strlen(dir);
-            if (filelen + dirlen + 1 >= PATH_MAX) {
-                errno = ENAMETOOLONG;
-                continue;
-            }
-            memcpy(expanded_file, dir, dirlen);
-            memcpy(expanded_file + dirlen, file, filelen);
-            expanded_file[dirlen + filelen] = '\0';
-            execve_with_shell_fallback(expanded_file, argv, envp);
-            /* There are 3 responses to various classes of errno:
-             * return immediately, continue (especially for ENOENT),
-             * or continue with "sticky" errno.
-             *
-             * From exec(3):
-             *
-             * If permission is denied for a file (the attempted
-             * execve returned EACCES), these functions will continue
-             * searching the rest of the search path.  If no other
-             * file is found, however, they will return with the
-             * global variable errno set to EACCES.
-             */
-            switch (errno) {
-            case EACCES:
-                sticky_errno = errno;
-                /* FALLTHRU */
-            case ENOENT:
-            case ENOTDIR:
-#ifdef ELOOP
-            case ELOOP:
-#endif
-#ifdef ESTALE
-            case ESTALE:
-#endif
-#ifdef ENODEV
-            case ENODEV:
-#endif
-#ifdef ETIMEDOUT
-            case ETIMEDOUT:
-#endif
-                break; /* Try other directories in PATH */
-            default:
-                return;
-            }
-        }
-        if (sticky_errno != 0)
-            errno = sticky_errno;
-    }
-}
-
-/*
- * Reads nbyte bytes from file descriptor fd into buf,
- * The read operation is retried in case of EINTR or partial reads.
- *
- * Returns number of bytes read (normally nbyte, but may be less in
- * case of EOF).  In case of read errors, returns -1 and sets errno.
- */
-static ssize_t
-readFully(int fd, void *buf, size_t nbyte)
-{
-    ssize_t remaining = nbyte;
-    for (;;) {
-        ssize_t n = read(fd, buf, remaining);
-        if (n == 0) {
-            return nbyte - remaining;
-        } else if (n > 0) {
-            remaining -= n;
-            if (remaining <= 0)
-                return nbyte;
-            /* We were interrupted in the middle of reading the bytes.
-             * Unlikely, but possible. */
-            buf = (void *) (((char *)buf) + n);
-        } else if (errno == EINTR) {
-            /* Strange signals like SIGJVM1 are possible at any time.
-             * See http://www.dreamsongs.com/WorseIsBetter.html */
-        } else {
-            return -1;
-        }
-    }
-}
-
-typedef struct _ChildStuff
-{
-    int in[2];
-    int out[2];
-    int err[2];
-    int fail[2];
-    int fds[3];
-    const char **argv;
-    const char **envv;
-    const char *pdir;
-    jboolean redirectErrorStream;
-#if START_CHILD_USE_CLONE
-    void *clone_stack;
-#endif
-} ChildStuff;
-
 static void
 copyPipe(int from[2], int to[2])
 {
@@ -696,97 +340,67 @@
     to[1] = from[1];
 }
 
-/**
- * Child process after a successful fork() or clone().
- * This function must not return, and must be prepared for either all
- * of its address space to be shared with its parent, or to be a copy.
- * It must not modify global variables such as "environ".
+/* arg is an array of pointers to 0 terminated strings. array is terminated
+ * by a null element.
+ *
+ * *nelems and *nbytes receive the number of elements of array (incl 0)
+ * and total number of bytes (incl. 0)
+ * Note. An empty array will have one null element
+ * But if arg is null, then *nelems set to 0, and *nbytes to 0
  */
-static int
-childProcess(void *arg)
+static void arraysize(const char * const *arg, int *nelems, int *nbytes)
 {
-    const ChildStuff* p = (const ChildStuff*) arg;
+    int i, bytes, count;
+    const char * const *a = arg;
+    char *p;
+    int *q;
+    if (arg == 0) {
+        *nelems = 0;
+        *nbytes = 0;
+        return;
+    }
+    /* count the array elements and number of bytes */
+    for (count=0, bytes=0; *a != 0; count++, a++) {
+        bytes += strlen(*a)+1;
+    }
+    *nbytes = bytes;
+    *nelems = count+1;
+}
 
-    /* Close the parent sides of the pipes.
-       Closing pipe fds here is redundant, since closeDescriptors()
-       would do it anyways, but a little paranoia is a good thing. */
-    if ((closeSafely(p->in[1])   == -1) ||
-        (closeSafely(p->out[0])  == -1) ||
-        (closeSafely(p->err[0])  == -1) ||
-        (closeSafely(p->fail[0]) == -1))
-        goto WhyCantJohnnyExec;
+/* copy the strings from arg[] into buf, starting at given offset
+ * return new offset to next free byte
+ */
+static int copystrings(char *buf, int offset, const char * const *arg) {
+    char *p;
+    const char * const *a;
+    int count=0;
 
-    /* Give the child sides of the pipes the right fileno's. */
-    /* Note: it is possible for in[0] == 0 */
-    if ((moveDescriptor(p->in[0] != -1 ?  p->in[0] : p->fds[0],
-                        STDIN_FILENO) == -1) ||
-        (moveDescriptor(p->out[1]!= -1 ? p->out[1] : p->fds[1],
-                        STDOUT_FILENO) == -1))
-        goto WhyCantJohnnyExec;
-
-    if (p->redirectErrorStream) {
-        if ((closeSafely(p->err[1]) == -1) ||
-            (restartableDup2(STDOUT_FILENO, STDERR_FILENO) == -1))
-            goto WhyCantJohnnyExec;
-    } else {
-        if (moveDescriptor(p->err[1] != -1 ? p->err[1] : p->fds[2],
-                           STDERR_FILENO) == -1)
-            goto WhyCantJohnnyExec;
+    if (arg == 0) {
+        return offset;
     }
-
-    if (moveDescriptor(p->fail[1], FAIL_FILENO) == -1)
-        goto WhyCantJohnnyExec;
-
-    /* close everything */
-    if (closeDescriptors() == 0) { /* failed,  close the old way */
-        int max_fd = (int)sysconf(_SC_OPEN_MAX);
-        int fd;
-        for (fd = FAIL_FILENO + 1; fd < max_fd; fd++)
-            if (restartableClose(fd) == -1 && errno != EBADF)
-                goto WhyCantJohnnyExec;
+    for (p=buf+offset, a=arg; *a != 0; a++) {
+        int len = strlen(*a) +1;
+        memcpy(p, *a, len);
+        p += len;
+        count += len;
     }
-
-    /* change to the new working directory */
-    if (p->pdir != NULL && chdir(p->pdir) < 0)
-        goto WhyCantJohnnyExec;
-
-    if (fcntl(FAIL_FILENO, F_SETFD, FD_CLOEXEC) == -1)
-        goto WhyCantJohnnyExec;
-
-    JDK_execvpe(p->argv[0], p->argv, p->envv);
-
- WhyCantJohnnyExec:
-    /* We used to go to an awful lot of trouble to predict whether the
-     * child would fail, but there is no reliable way to predict the
-     * success of an operation without *trying* it, and there's no way
-     * to try a chdir or exec in the parent.  Instead, all we need is a
-     * way to communicate any failure back to the parent.  Easy; we just
-     * send the errno back to the parent over a pipe in case of failure.
-     * The tricky thing is, how do we communicate the *success* of exec?
-     * We use FD_CLOEXEC together with the fact that a read() on a pipe
-     * yields EOF when the write ends (we have two of them!) are closed.
-     */
-    {
-        int errnum = errno;
-        restartableWrite(FAIL_FILENO, &errnum, sizeof(errnum));
-    }
-    restartableClose(FAIL_FILENO);
-    _exit(-1);
-    return 0;  /* Suppress warning "no return value from function" */
+    return offset+count;
 }
 
 /**
- * Start a child process running function childProcess.
- * This function only returns in the parent.
  * We are unusually paranoid; use of clone/vfork is
  * especially likely to tickle gcc/glibc bugs.
  */
 #ifdef __attribute_noinline__  /* See: sys/cdefs.h */
 __attribute_noinline__
 #endif
+
+#define START_CHILD_USE_CLONE 0  /* clone() currently disabled; see above. */
+
+#ifdef START_CHILD_USE_CLONE
 static pid_t
-startChild(ChildStuff *c) {
-#if START_CHILD_USE_CLONE
+cloneChild(ChildStuff *c) {
+#ifdef __linux__
 #define START_CHILD_CLONE_STACK_SIZE (64 * 1024)
     /*
      * See clone(2).
@@ -800,33 +414,161 @@
                  c->clone_stack + START_CHILD_CLONE_STACK_SIZE,
                  CLONE_VFORK | CLONE_VM | SIGCHLD, c);
 #else
-  #if START_CHILD_USE_VFORK
+/* not available on Solaris / Mac */
+    assert(0);
+    return -1;
+#endif
+}
+#endif
+
+static pid_t
+vforkChild(ChildStuff *c) {
+    volatile pid_t resultPid;
+
     /*
      * We separate the call to vfork into a separate function to make
      * very sure to keep stack of child from corrupting stack of parent,
      * as suggested by the scary gcc warning:
      *  warning: variable 'foo' might be clobbered by 'longjmp' or 'vfork'
      */
-    volatile pid_t resultPid = vfork();
-  #else
+    resultPid = vfork();
+
+    if (resultPid == 0) {
+        childProcess(c);
+    }
+    assert(resultPid != 0);  /* childProcess never returns */
+    return resultPid;
+}
+
+static pid_t
+forkChild(ChildStuff *c) {
+    pid_t resultPid;
+
     /*
      * From Solaris fork(2): In Solaris 10, a call to fork() is
      * identical to a call to fork1(); only the calling thread is
      * replicated in the child process. This is the POSIX-specified
      * behavior for fork().
      */
-    pid_t resultPid = fork();
-  #endif
-    if (resultPid == 0)
+    resultPid = fork();
+
+    if (resultPid == 0) {
         childProcess(c);
+    }
     assert(resultPid != 0);  /* childProcess never returns */
     return resultPid;
-#endif /* ! START_CHILD_USE_CLONE */
+}
+
+#if defined(__solaris__) || defined(_ALLBSD_SOURCE)
+static pid_t
+spawnChild(JNIEnv *env, jobject process, ChildStuff *c, const char *helperpath) {
+    pid_t resultPid;
+    jboolean isCopy;
+    int i, offset, rval, bufsize, magic;
+    char *buf, buf1[16];
+    char *hlpargs[2];
+    SpawnInfo sp;
+
+    /* need to tell helper which fd is for receiving the childstuff
+     * and which fd to send response back on
+     */
+    snprintf(buf1, sizeof(buf1), "%d:%d", c->childenv[0], c->fail[1]);
+    /* put the fd string as argument to the helper cmd */
+    hlpargs[0] = buf1;
+    hlpargs[1] = 0;
+
+    /* Following items are sent down the pipe to the helper
+     * after it is spawned.
+     * All strings are null terminated. All arrays of strings
+     * have an empty string for termination.
+     * - the ChildStuff struct
+     * - the SpawnInfo struct
+     * - the argv strings array
+     * - the envv strings array
+     * - the home directory string
+     * - the parentPath string
+     * - the parentPathv array
+     */
+    /* First calculate the sizes */
+    arraysize(c->argv, &sp.nargv, &sp.argvBytes);
+    bufsize = sp.argvBytes;
+    arraysize(c->envv, &sp.nenvv, &sp.envvBytes);
+    bufsize += sp.envvBytes;
+    sp.dirlen = c->pdir == 0 ? 0 : strlen(c->pdir)+1;
+    bufsize += sp.dirlen;
+    arraysize(parentPathv, &sp.nparentPathv, &sp.parentPathvBytes);
+    bufsize += sp.parentPathvBytes;
+    /* We need to clear FD_CLOEXEC if set in the fds[].
+     * Files are created FD_CLOEXEC in Java.
+     * Otherwise, they will be closed when the target gets exec'd */
+    for (i=0; i<3; i++) {
+        if (c->fds[i] != -1) {
+            int flags = fcntl(c->fds[i], F_GETFD);
+            if (flags & FD_CLOEXEC) {
+                fcntl(c->fds[i], F_SETFD, flags & (~1));
+            }
+        }
+    }
+
+    rval = posix_spawn(&resultPid, helperpath, 0, 0, (char * const *) hlpargs, environ);
+
+    if (rval != 0) {
+        return -1;
+    }
+
+    /* now the lengths are known, copy the data */
+    buf = NEW(char, bufsize);
+    if (buf == 0) {
+        return -1;
+    }
+    offset = copystrings(buf, 0, &c->argv[0]);
+    offset = copystrings(buf, offset, &c->envv[0]);
+    memcpy(buf+offset, c->pdir, sp.dirlen);
+    offset += sp.dirlen;
+    offset = copystrings(buf, offset, parentPathv);
+    assert(offset == bufsize);
+
+    magic = magicNumber();
+
+    /* write the two structs and the data buffer */
+    write(c->childenv[1], (char *)&magic, sizeof(magic)); // magic number first
+    write(c->childenv[1], (char *)c, sizeof(*c));
+    write(c->childenv[1], (char *)&sp, sizeof(sp));
+    write(c->childenv[1], buf, bufsize);
+    free(buf);
+
+    /* In this mode an external main() in invoked which calls back into
+     * childProcess() in this file, rather than directly
+     * via the statement below */
+    return resultPid;
+}
+#endif
+
+/*
+ * Start a child process running function childProcess.
+ * This function only returns in the parent.
+ */
+static pid_t
+startChild(JNIEnv *env, jobject process, ChildStuff *c, const char *helperpath) {
+    switch (c->mode) {
+      case MODE_VFORK:
+        return vforkChild(c);
+      case MODE_FORK:
+        return forkChild(c);
+#if defined(__solaris__) || defined(_ALLBSD_SOURCE)
+      case MODE_POSIX_SPAWN:
+        return spawnChild(env, process, c, helperpath);
+#endif
+      default:
+        return -1;
+    }
 }
 
 JNIEXPORT jint JNICALL
 Java_java_lang_UNIXProcess_forkAndExec(JNIEnv *env,
                                        jobject process,
+                                       jint mode,
+                                       jbyteArray helperpath,
                                        jbyteArray prog,
                                        jbyteArray argBlock, jint argc,
                                        jbyteArray envBlock, jint envc,
@@ -836,32 +578,35 @@
 {
     int errnum;
     int resultPid = -1;
-    int in[2], out[2], err[2], fail[2];
+    int in[2], out[2], err[2], fail[2], childenv[2];
     jint *fds = NULL;
+    const char *phelperpath = NULL;
     const char *pprog = NULL;
     const char *pargBlock = NULL;
     const char *penvBlock = NULL;
     ChildStuff *c;
 
     in[0] = in[1] = out[0] = out[1] = err[0] = err[1] = fail[0] = fail[1] = -1;
+    childenv[0] = childenv[1] = -1;
 
     if ((c = NEW(ChildStuff, 1)) == NULL) return -1;
     c->argv = NULL;
     c->envv = NULL;
     c->pdir = NULL;
-#if START_CHILD_USE_CLONE
     c->clone_stack = NULL;
-#endif
 
     /* Convert prog + argBlock into a char ** argv.
      * Add one word room for expansion of argv for use by
      * execve_as_traditional_shell_script.
+     * This word is also used when using spawn mode
      */
     assert(prog != NULL && argBlock != NULL);
+    if ((phelperpath = getBytes(env, helperpath))   == NULL) goto Catch;
     if ((pprog     = getBytes(env, prog))       == NULL) goto Catch;
     if ((pargBlock = getBytes(env, argBlock))   == NULL) goto Catch;
     if ((c->argv = NEW(const char *, argc + 3)) == NULL) goto Catch;
     c->argv[0] = pprog;
+    c->argc = argc + 2;
     initVectorFromBlock(c->argv+1, pargBlock, argc);
 
     if (envBlock != NULL) {
@@ -882,6 +627,7 @@
     if ((fds[0] == -1 && pipe(in)  < 0) ||
         (fds[1] == -1 && pipe(out) < 0) ||
         (fds[2] == -1 && pipe(err) < 0) ||
+        (pipe(childenv) < 0) ||
         (pipe(fail) < 0)) {
         throwIOException(env, errno, "Bad file descriptor");
         goto Catch;
@@ -894,18 +640,29 @@
     copyPipe(out,  c->out);
     copyPipe(err,  c->err);
     copyPipe(fail, c->fail);
+    copyPipe(childenv, c->childenv);
 
     c->redirectErrorStream = redirectErrorStream;
+    c->mode = mode;
 
-    resultPid = startChild(c);
+    resultPid = startChild(env, process, c, phelperpath);
     assert(resultPid != 0);
 
     if (resultPid < 0) {
-        throwIOException(env, errno, START_CHILD_SYSTEM_CALL " failed");
+        switch (c->mode) {
+          case MODE_VFORK:
+            throwIOException(env, errno, "vfork failed");
+            break;
+          case MODE_FORK:
+            throwIOException(env, errno, "fork failed");
+            break;
+          case MODE_POSIX_SPAWN:
+            throwIOException(env, errno, "spawn failed");
+            break;
+        }
         goto Catch;
     }
-
-    restartableClose(fail[1]); fail[1] = -1; /* See: WhyCantJohnnyExec */
+    close(fail[1]); fail[1] = -1; /* See: WhyCantJohnnyExec  (childproc.c)  */
 
     switch (readFully(fail[0], &errnum, sizeof(errnum))) {
     case 0: break; /* Exec succeeded */
@@ -923,18 +680,18 @@
     fds[2] = (err[0] != -1) ? err[0] : -1;
 
  Finally:
-#if START_CHILD_USE_CLONE
     free(c->clone_stack);
-#endif
 
     /* Always clean up the child's side of the pipes */
     closeSafely(in [0]);
     closeSafely(out[1]);
     closeSafely(err[1]);
 
-    /* Always clean up fail descriptors */
+    /* Always clean up fail and childEnv descriptors */
     closeSafely(fail[0]);
     closeSafely(fail[1]);
+    closeSafely(childenv[0]);
+    closeSafely(childenv[1]);
 
     releaseBytes(env, prog,     pprog);
     releaseBytes(env, argBlock, pargBlock);
@@ -952,9 +709,9 @@
 
  Catch:
     /* Clean up the parent's side of the pipes in case of failure only */
-    closeSafely(in [1]);
-    closeSafely(out[0]);
-    closeSafely(err[0]);
+    closeSafely(in [1]); in[1] = -1;
+    closeSafely(out[0]); out[0] = -1;
+    closeSafely(err[0]); err[0] = -1;
     goto Finally;
 }
 
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/src/solaris/native/java/lang/childproc.c	Tue Mar 18 12:35:25 2014 -0700
@@ -0,0 +1,376 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#include <dirent.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <limits.h>
+
+#include "childproc.h"
+
+
+ssize_t
+restartableWrite(int fd, const void *buf, size_t count)
+{
+    ssize_t result;
+    RESTARTABLE(write(fd, buf, count), result);
+    return result;
+}
+
+int
+restartableDup2(int fd_from, int fd_to)
+{
+    int err;
+    RESTARTABLE(dup2(fd_from, fd_to), err);
+    return err;
+}
+
+int
+closeSafely(int fd)
+{
+    return (fd == -1) ? 0 : close(fd);
+}
+
+int
+isAsciiDigit(char c)
+{
+  return c >= '0' && c <= '9';
+}
+
+#ifdef _ALLBSD_SOURCE
+#define FD_DIR "/dev/fd"
+#define dirent64 dirent
+#define readdir64 readdir
+#else
+#define FD_DIR "/proc/self/fd"
+#endif
+
+int
+closeDescriptors(void)
+{
+    DIR *dp;
+    struct dirent64 *dirp;
+    int from_fd = FAIL_FILENO + 1;
+
+    /* We're trying to close all file descriptors, but opendir() might
+     * itself be implemented using a file descriptor, and we certainly
+     * don't want to close that while it's in use.  We assume that if
+     * opendir() is implemented using a file descriptor, then it uses
+     * the lowest numbered file descriptor, just like open().  So we
+     * close a couple explicitly.  */
+
+    close(from_fd);          /* for possible use by opendir() */
+    close(from_fd + 1);      /* another one for good luck */
+
+    if ((dp = opendir(FD_DIR)) == NULL)
+        return 0;
+
+    /* We use readdir64 instead of readdir to work around Solaris bug
+     * 6395699: /proc/self/fd fails to report file descriptors >= 1024 on Solaris 9
+     */
+    while ((dirp = readdir64(dp)) != NULL) {
+        int fd;
+        if (isAsciiDigit(dirp->d_name[0]) &&
+            (fd = strtol(dirp->d_name, NULL, 10)) >= from_fd + 2)
+            close(fd);
+    }
+
+    closedir(dp);
+
+    return 1;
+}
+
+int
+moveDescriptor(int fd_from, int fd_to)
+{
+    if (fd_from != fd_to) {
+        if ((restartableDup2(fd_from, fd_to) == -1) ||
+            (close(fd_from) == -1))
+            return -1;
+    }
+    return 0;
+}
+
+int
+magicNumber() {
+    return 43110;
+}
+
+/*
+ * Reads nbyte bytes from file descriptor fd into buf,
+ * The read operation is retried in case of EINTR or partial reads.
+ *
+ * Returns number of bytes read (normally nbyte, but may be less in
+ * case of EOF).  In case of read errors, returns -1 and sets errno.
+ */
+ssize_t
+readFully(int fd, void *buf, size_t nbyte)
+{
+    ssize_t remaining = nbyte;
+    for (;;) {
+        ssize_t n = read(fd, buf, remaining);
+        if (n == 0) {
+            return nbyte - remaining;
+        } else if (n > 0) {
+            remaining -= n;
+            if (remaining <= 0)
+                return nbyte;
+            /* We were interrupted in the middle of reading the bytes.
+             * Unlikely, but possible. */
+            buf = (void *) (((char *)buf) + n);
+        } else if (errno == EINTR) {
+            /* Strange signals like SIGJVM1 are possible at any time.
+             * See http://www.dreamsongs.com/WorseIsBetter.html */
+        } else {
+            return -1;
+        }
+    }
+}
+
+void
+initVectorFromBlock(const char**vector, const char* block, int count)
+{
+    int i;
+    const char *p;
+    for (i = 0, p = block; i < count; i++) {
+        /* Invariant: p always points to the start of a C string. */
+        vector[i] = p;
+        while (*(p++));
+    }
+    vector[count] = NULL;
+}
+
+/**
+ * Exec FILE as a traditional Bourne shell script (i.e. one without #!).
+ * If we could do it over again, we would probably not support such an ancient
+ * misfeature, but compatibility wins over sanity.  The original support for
+ * this was imported accidentally from execvp().
+ */
+void
+execve_as_traditional_shell_script(const char *file,
+                                   const char *argv[],
+                                   const char *const envp[])
+{
+    /* Use the extra word of space provided for us in argv by caller. */
+    const char *argv0 = argv[0];
+    const char *const *end = argv;
+    while (*end != NULL)
+        ++end;
+    memmove(argv+2, argv+1, (end-argv) * sizeof(*end));
+    argv[0] = "/bin/sh";
+    argv[1] = file;
+    execve(argv[0], (char **) argv, (char **) envp);
+    /* Can't even exec /bin/sh?  Big trouble, but let's soldier on... */
+    memmove(argv+1, argv+2, (end-argv) * sizeof(*end));
+    argv[0] = argv0;
+}
+
+/**
+ * Like execve(2), except that in case of ENOEXEC, FILE is assumed to
+ * be a shell script and the system default shell is invoked to run it.
+ */
+void
+execve_with_shell_fallback(int mode, const char *file,
+                           const char *argv[],
+                           const char *const envp[])
+{
+    if (mode == MODE_CLONE || mode == MODE_VFORK) {
+        /* shared address space; be very careful. */
+        execve(file, (char **) argv, (char **) envp);
+        if (errno == ENOEXEC)
+            execve_as_traditional_shell_script(file, argv, envp);
+    } else {
+        /* unshared address space; we can mutate environ. */
+        environ = (char **) envp;
+        execvp(file, (char **) argv);
+    }
+}
+
+/**
+ * 'execvpe' should have been included in the Unix standards,
+ * and is a GNU extension in glibc 2.10.
+ *
+ * JDK_execvpe is identical to execvp, except that the child environment is
+ * specified via the 3rd argument instead of being inherited from environ.
+ */
+void
+JDK_execvpe(int mode, const char *file,
+            const char *argv[],
+            const char *const envp[])
+{
+    if (envp == NULL || (char **) envp == environ) {
+        execvp(file, (char **) argv);
+        return;
+    }
+
+    if (*file == '\0') {
+        errno = ENOENT;
+        return;
+    }
+
+    if (strchr(file, '/') != NULL) {
+        execve_with_shell_fallback(mode, file, argv, envp);
+    } else {
+        /* We must search PATH (parent's, not child's) */
+        char expanded_file[PATH_MAX];
+        int filelen = strlen(file);
+        int sticky_errno = 0;
+        const char * const * dirs;
+        for (dirs = parentPathv; *dirs; dirs++) {
+            const char * dir = *dirs;
+            int dirlen = strlen(dir);
+            if (filelen + dirlen + 2 >= PATH_MAX) {
+                errno = ENAMETOOLONG;
+                continue;
+            }
+            memcpy(expanded_file, dir, dirlen);
+            if (expanded_file[dirlen - 1] != '/')
+                expanded_file[dirlen++] = '/';
+            memcpy(expanded_file + dirlen, file, filelen);
+            expanded_file[dirlen + filelen] = '\0';
+            execve_with_shell_fallback(mode, expanded_file, argv, envp);
+            /* There are 3 responses to various classes of errno:
+             * return immediately, continue (especially for ENOENT),
+             * or continue with "sticky" errno.
+             *
+             * From exec(3):
+             *
+             * If permission is denied for a file (the attempted
+             * execve returned EACCES), these functions will continue
+             * searching the rest of the search path.  If no other
+             * file is found, however, they will return with the
+             * global variable errno set to EACCES.
+             */
+            switch (errno) {
+            case EACCES:
+                sticky_errno = errno;
+                /* FALLTHRU */
+            case ENOENT:
+            case ENOTDIR:
+#ifdef ELOOP
+            case ELOOP:
+#endif
+#ifdef ESTALE
+            case ESTALE:
+#endif
+#ifdef ENODEV
+            case ENODEV:
+#endif
+#ifdef ETIMEDOUT
+            case ETIMEDOUT:
+#endif
+                break; /* Try other directories in PATH */
+            default:
+                return;
+            }
+        }
+        if (sticky_errno != 0)
+            errno = sticky_errno;
+    }
+}
+
+/**
+ * Child process after a successful fork() or clone().
+ * This function must not return, and must be prepared for either all
+ * of its address space to be shared with its parent, or to be a copy.
+ * It must not modify global variables such as "environ".
+ */
+int
+childProcess(void *arg)
+{
+    const ChildStuff* p = (const ChildStuff*) arg;
+
+    /* Close the parent sides of the pipes.
+       Closing pipe fds here is redundant, since closeDescriptors()
+       would do it anyways, but a little paranoia is a good thing. */
+    if ((closeSafely(p->in[1])   == -1) ||
+        (closeSafely(p->out[0])  == -1) ||
+        (closeSafely(p->err[0])  == -1) ||
+        (closeSafely(p->childenv[0])  == -1) ||
+        (closeSafely(p->childenv[1])  == -1) ||
+        (closeSafely(p->fail[0]) == -1))
+        goto WhyCantJohnnyExec;
+
+    /* Give the child sides of the pipes the right fileno's. */
+    /* Note: it is possible for in[0] == 0 */
+    if ((moveDescriptor(p->in[0] != -1 ?  p->in[0] : p->fds[0],
+                        STDIN_FILENO) == -1) ||
+        (moveDescriptor(p->out[1]!= -1 ? p->out[1] : p->fds[1],
+                        STDOUT_FILENO) == -1))
+        goto WhyCantJohnnyExec;
+
+    if (p->redirectErrorStream) {
+        if ((closeSafely(p->err[1]) == -1) ||
+            (restartableDup2(STDOUT_FILENO, STDERR_FILENO) == -1))
+            goto WhyCantJohnnyExec;
+    } else {
+        if (moveDescriptor(p->err[1] != -1 ? p->err[1] : p->fds[2],
+                           STDERR_FILENO) == -1)
+            goto WhyCantJohnnyExec;
+    }
+
+    if (moveDescriptor(p->fail[1], FAIL_FILENO) == -1)
+        goto WhyCantJohnnyExec;
+
+    /* close everything */
+    if (closeDescriptors() == 0) { /* failed,  close the old way */
+        int max_fd = (int)sysconf(_SC_OPEN_MAX);
+        int fd;
+        for (fd = FAIL_FILENO + 1; fd < max_fd; fd++)
+            if (close(fd) == -1 && errno != EBADF)
+                goto WhyCantJohnnyExec;
+    }
+
+    /* change to the new working directory */
+    if (p->pdir != NULL && chdir(p->pdir) < 0)
+        goto WhyCantJohnnyExec;
+
+    if (fcntl(FAIL_FILENO, F_SETFD, FD_CLOEXEC) == -1)
+        goto WhyCantJohnnyExec;
+
+    JDK_execvpe(p->mode, p->argv[0], p->argv, p->envv);
+
+ WhyCantJohnnyExec:
+    /* We used to go to an awful lot of trouble to predict whether the
+     * child would fail, but there is no reliable way to predict the
+     * success of an operation without *trying* it, and there's no way
+     * to try a chdir or exec in the parent.  Instead, all we need is a
+     * way to communicate any failure back to the parent.  Easy; we just
+     * send the errno back to the parent over a pipe in case of failure.
+     * The tricky thing is, how do we communicate the *success* of exec?
+     * We use FD_CLOEXEC together with the fact that a read() on a pipe
+     * yields EOF when the write ends (we have two of them!) are closed.
+     */
+    {
+        int errnum = errno;
+        restartableWrite(FAIL_FILENO, &errnum, sizeof(errnum));
+    }
+    close(FAIL_FILENO);
+    _exit(-1);
+    return 0;  /* Suppress warning "no return value from function" */
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/src/solaris/native/java/lang/childproc.h	Tue Mar 18 12:35:25 2014 -0700
@@ -0,0 +1,145 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#ifndef CHILDPROC_MD_H
+#define CHILDPROC_MD_H
+
+#include <sys/types.h>
+
+#ifdef __APPLE__
+#include <crt_externs.h>
+#define environ (*_NSGetEnviron())
+#else
+/* This is one of the rare times it's more portable to declare an
+ * external symbol explicitly, rather than via a system header.
+ * The declaration is standardized as part of UNIX98, but there is
+ * no standard (not even de-facto) header file where the
+ * declaration is to be found.  See:
+ * http://www.opengroup.org/onlinepubs/009695399/functions/environ.html
+ * http://www.opengroup.org/onlinepubs/009695399/functions/xsh_chap02_02.html
+ *
+ * "All identifiers in this volume of IEEE Std 1003.1-2001, except
+ * environ, are defined in at least one of the headers" (!)
+ */
+extern char **environ;
+#endif
+
+#ifdef __linux__
+#include <sched.h>
+#endif
+
+#ifndef STDIN_FILENO
+#define STDIN_FILENO 0
+#endif
+
+#ifndef STDOUT_FILENO
+#define STDOUT_FILENO 1
+#endif
+
+#ifndef STDERR_FILENO
+#define STDERR_FILENO 2
+#endif
+
+#ifndef SA_NOCLDSTOP
+#define SA_NOCLDSTOP 0
+#endif
+
+#ifndef SA_RESTART
+#define SA_RESTART 0
+#endif
+
+#define FAIL_FILENO (STDERR_FILENO + 1)
+
+/* TODO: Refactor. */
+#define RESTARTABLE(_cmd, _result) do { \
+  do { \
+    _result = _cmd; \
+  } while((_result == -1) && (errno == EINTR)); \
+} while(0)
+
+/* These numbers must be the same as the Enum in UNIXProcess.java
+ * Must be a better way of doing this.
+ */
+#define MODE_FORK 1
+#define MODE_POSIX_SPAWN 2
+#define MODE_VFORK 3
+#define MODE_CLONE 4
+
+typedef struct _ChildStuff
+{
+    int in[2];
+    int out[2];
+    int err[2];
+    int fail[2];
+    int childenv[2];
+    int fds[3];
+    int mode;
+    const char **argv;
+    int argc;
+    const char **envv;
+    const char *pdir;
+    int redirectErrorStream;
+    void *clone_stack;
+} ChildStuff;
+
+/* following used in addition when mode is SPAWN */
+typedef struct _SpawnInfo {
+    int nargv; /* number of argv array elements  */
+    int argvBytes; /* total number of bytes in argv array */
+    int nenvv; /* number of envv array elements  */
+    int envvBytes; /* total number of bytes in envv array */
+    int dirlen; /* length of home directory string */
+    int nparentPathv; /* number of elements in parentPathv array */
+    int parentPathvBytes; /* total number of bytes in parentPathv array */
+} SpawnInfo;
+
+/**
+ * The cached and split version of the JDK's effective PATH.
+ * (We don't support putenv("PATH=...") in native code)
+ */
+const char * const *parentPathv;
+
+ssize_t restartableWrite(int fd, const void *buf, size_t count);
+int restartableDup2(int fd_from, int fd_to);
+int closeSafely(int fd);
+int isAsciiDigit(char c);
+int closeDescriptors(void);
+int moveDescriptor(int fd_from, int fd_to);
+
+int magicNumber();
+ssize_t readFully(int fd, void *buf, size_t nbyte);
+void initVectorFromBlock(const char**vector, const char* block, int count);
+void execve_as_traditional_shell_script(const char *file,
+                                        const char *argv[],
+                                        const char *const envp[]);
+void execve_with_shell_fallback(int mode, const char *file,
+                                const char *argv[],
+                                const char *const envp[]);
+void JDK_execvpe(int mode, const char *file,
+                 const char *argv[],
+                 const char *const envp[]);
+int childProcess(void *arg);
+
+#endif
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/src/solaris/native/java/lang/jspawnhelper.c	Tue Mar 18 12:35:25 2014 -0700
@@ -0,0 +1,149 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+
+#include "childproc.h"
+
+extern int errno;
+
+#define ALLOC(X,Y) { \
+    void *mptr; \
+    mptr = malloc (Y); \
+    if (mptr == 0) { \
+        error (fdout, ERR_MALLOC); \
+    } \
+    X = mptr; \
+}
+
+#define ERR_MALLOC 1
+#define ERR_PIPE 2
+#define ERR_ARGS 3
+
+void error (int fd, int err) {
+    write (fd, &err, sizeof(err));
+    exit (1);
+}
+
+void shutItDown() {
+    fprintf(stdout, "This command is not for general use and should ");
+    fprintf(stdout, "only be run as the result of a call to\n");
+    fprintf(stdout, "ProcessBuilder.start() or Runtime.exec() in a java ");
+    fprintf(stdout, "application\n");
+    _exit(1);
+}
+
+/*
+ * read the following off the pipefd
+ * - the ChildStuff struct
+ * - the SpawnInfo struct
+ * - the data strings for fields in ChildStuff
+ */
+void initChildStuff (int fdin, int fdout, ChildStuff *c) {
+    int n;
+    int argvBytes, nargv, envvBytes, nenvv;
+    int dirlen;
+    char *buf;
+    SpawnInfo sp;
+    int bufsize, offset=0;
+    int magic;
+    int res;
+
+    res = readFully (fdin, &magic, sizeof(magic));
+    if (res != 4 || magic != magicNumber()) {
+        error (fdout, ERR_PIPE);
+    }
+
+    if (readFully (fdin, c, sizeof(*c)) == -1) {
+        error (fdout, ERR_PIPE);
+    }
+
+    if (readFully (fdin, &sp, sizeof(sp)) == -1) {
+        error (fdout, ERR_PIPE);
+    }
+
+    bufsize = sp.argvBytes + sp.envvBytes +
+              sp.dirlen + sp.parentPathvBytes;
+
+    ALLOC(buf, bufsize);
+
+    if (readFully (fdin, buf, bufsize) == -1) {
+        error (fdout, ERR_PIPE);
+    }
+
+    /* Initialize argv[] */
+    ALLOC(c->argv, sizeof(char *) * sp.nargv);
+    initVectorFromBlock (c->argv, buf+offset, sp.nargv-1);
+    offset += sp.argvBytes;
+
+    /* Initialize envv[] */
+    if (sp.nenvv == 0) {
+        c->envv = 0;
+    } else {
+        ALLOC(c->envv, sizeof(char *) * sp.nenvv);
+        initVectorFromBlock (c->envv, buf+offset, sp.nenvv-1);
+        offset += sp.envvBytes;
+    }
+
+    /* Initialize pdir */
+    if (sp.dirlen == 0) {
+        c->pdir = 0;
+    } else {
+        c->pdir = buf+offset;
+        offset += sp.dirlen;
+    }
+
+    /* Initialize parentPathv[] */
+    ALLOC(parentPathv, sizeof (char *) * sp.nparentPathv)
+    initVectorFromBlock ((const char**)parentPathv, buf+offset, sp.nparentPathv-1);
+    offset += sp.parentPathvBytes;
+}
+
+int main(int argc, char *argv[]) {
+    ChildStuff c;
+    int t;
+    struct stat buf;
+    /* argv[0] contains the fd number to read all the child info */
+    int r, fdin, fdout;
+
+    r = sscanf (argv[argc-1], "%d:%d", &fdin, &fdout);
+    if (r == 2 && fcntl(fdin, F_GETFD) != -1) {
+        fstat(fdin, &buf);
+        if (!S_ISFIFO(buf.st_mode))
+            shutItDown();
+    } else {
+        shutItDown();
+    }
+    initChildStuff (fdin, fdout, &c);
+
+    childProcess (&c);
+    return 0; /* NOT REACHED */
+}
--- ./jdk/src/solaris/native/sun/awt/awt_LoadLibrary.c	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/solaris/native/sun/awt/awt_LoadLibrary.c	Tue Mar 18 12:35:25 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000, 2005, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -96,7 +96,7 @@
     jvm = vm;
 
     /* Get address of this library and the directory containing it. */
-    dladdr((void *)JNI_OnLoad, &dlinfo);
+    dladdr((void *)AWT_OnLoad, &dlinfo);
     realpath((char *)dlinfo.dli_fname, buf);
     len = strlen(buf);
     p = strrchr(buf, '/');
--- ./jdk/src/windows/classes/sun/awt/shell/Win32ShellFolderManager2.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/windows/classes/sun/awt/shell/Win32ShellFolderManager2.java	Tue Mar 18 12:35:25 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -41,6 +41,7 @@
 
 import static sun.awt.shell.Win32ShellFolder2.*;
 import sun.awt.OSInfo;
+import sun.misc.ThreadGroupUtils;
 
 // NOTE: This class supersedes Win32ShellFolderManager, which was removed
 //       from distribution after version 1.4.2.
@@ -505,23 +506,19 @@
                     }
                 }
             };
-            comThread =
-                AccessController.doPrivileged(
-                    new PrivilegedAction<Thread>() {
-                        public Thread run() {
+            comThread =  AccessController.doPrivileged(new PrivilegedAction<Thread>() {
+                @Override
+                public Thread run() {
                             /* The thread must be a member of a thread group
                              * which will not get GCed before VM exit.
                              * Make its parent the top-level thread group.
                              */
-                            ThreadGroup tg = Thread.currentThread().getThreadGroup();
-                            for (ThreadGroup tgn = tg;
-                                 tgn != null;
-                                 tg = tgn, tgn = tg.getParent());
-                            Thread thread = new Thread(tg, comRun, "Swing-Shell");
-                            thread.setDaemon(true);
-                            return thread;
-                        }
-                    }
+                    ThreadGroup rootTG = ThreadGroupUtils.getRootThreadGroup();
+                    Thread thread = new Thread(rootTG, comRun, "Swing-Shell");
+                    thread.setDaemon(true);
+                    return thread;
+                }
+            }
                 );
             return comThread;
         }
--- ./jdk/src/windows/classes/sun/awt/windows/WClipboard.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/windows/classes/sun/awt/windows/WClipboard.java	Tue Mar 18 12:35:25 2014 -0700
@@ -63,7 +63,6 @@
     }
 
     protected void setContentsNative(Transferable contents) {
-
         // Don't use delayed Clipboard rendering for the Transferable's data.
         // If we did that, we would call Transferable.getTransferData on
         // the Toolkit thread, which is a security hole.
@@ -72,7 +71,7 @@
         // translated. Then, for each format, translate the data and post
         // it to the Clipboard.
         Map formatMap = WDataTransferer.getInstance().
-            getFormatsForTransferable(contents, flavorMap);
+            getFormatsForTransferable(contents, getDefaultFlavorTable());
 
         openClipboard(this);
 
--- ./jdk/src/windows/classes/sun/awt/windows/WToolkit.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/windows/classes/sun/awt/windows/WToolkit.java	Tue Mar 18 12:35:25 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -38,6 +38,7 @@
 import java.security.PrivilegedAction;
 import sun.awt.AWTAutoShutdown;
 import sun.awt.SunToolkit;
+import sun.misc.ThreadGroupUtils;
 import sun.awt.Win32GraphicsDevice;
 import sun.awt.Win32GraphicsEnvironment;
 import sun.java2d.d3d.D3DRenderQueue;
@@ -215,7 +216,7 @@
 
     private static native void postDispose();
 
-    private static native boolean startToolkitThread(Runnable thread);
+    private static native boolean startToolkitThread(Runnable thread, ThreadGroup rootThreadGroup);
 
     public WToolkit() {
         // Startup toolkit threads
@@ -232,8 +233,15 @@
          */
         AWTAutoShutdown.notifyToolkitThreadBusy();
 
-        if (!startToolkitThread(this)) {
-            Thread toolkitThread = new Thread(this, "AWT-Windows");
+        // Find a root TG and attach Appkit thread to it
+        ThreadGroup rootTG = AccessController.doPrivileged(new PrivilegedAction<ThreadGroup>() {
+                    @Override
+                    public ThreadGroup run() {
+                        return ThreadGroupUtils.getRootThreadGroup();
+                    }
+                });
+        if (!startToolkitThread(this, rootTG)) {
+            Thread toolkitThread = new Thread(rootTG, this, "AWT-Windows");
             toolkitThread.setDaemon(true);
             toolkitThread.start();
         }
@@ -263,14 +271,7 @@
     private final void registerShutdownHook() {
         AccessController.doPrivileged(new PrivilegedAction() {
             public Object run() {
-                ThreadGroup currentTG =
-                    Thread.currentThread().getThreadGroup();
-                ThreadGroup parentTG = currentTG.getParent();
-                while (parentTG != null) {
-                    currentTG = parentTG;
-                    parentTG = currentTG.getParent();
-                }
-                Thread shutdown = new Thread(currentTG, new Runnable() {
+                Thread shutdown = new Thread(ThreadGroupUtils.getRootThreadGroup(), new Runnable() {
                     public void run() {
                         shutdown();
                     }
@@ -283,7 +284,14 @@
      }
 
     public void run() {
-        Thread.currentThread().setPriority(Thread.NORM_PRIORITY+1);
+        AccessController.doPrivileged(new PrivilegedAction<Void>() {
+            @Override
+            public Void run() {
+                Thread.currentThread().setContextClassLoader(null);
+                return null;
+            }
+        });
+        Thread.currentThread().setPriority(Thread.NORM_PRIORITY + 1);
         boolean startPump = init();
 
         if (startPump) {
--- ./jdk/src/windows/classes/sun/java2d/d3d/D3DScreenUpdateManager.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/windows/classes/sun/java2d/d3d/D3DScreenUpdateManager.java	Tue Mar 18 12:35:25 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2007, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -36,8 +36,9 @@
 import java.security.PrivilegedAction;
 import java.util.ArrayList;
 import java.util.HashMap;
-import sun.awt.SunToolkit;
+
 import sun.awt.AWTAccessor;
+import sun.misc.ThreadGroupUtils;
 import sun.awt.Win32GraphicsConfig;
 import sun.awt.windows.WComponentPeer;
 import sun.java2d.InvalidPipeException;
@@ -92,30 +93,26 @@
     public D3DScreenUpdateManager() {
         done = false;
         AccessController.doPrivileged(
-            new PrivilegedAction() {
-                public Object run() {
-                    ThreadGroup currentTG =
-                        Thread.currentThread().getThreadGroup();
-                    ThreadGroup parentTG = currentTG.getParent();
-                    while (parentTG != null) {
-                        currentTG = parentTG;
-                        parentTG = currentTG.getParent();
-                    }
-                    Thread shutdown = new Thread(currentTG, new Runnable() {
+                new PrivilegedAction<Void>() {
+                    @Override
+                    public Void run() {
+                        ThreadGroup rootTG = ThreadGroupUtils.getRootThreadGroup();
+                        Thread shutdown = new Thread(rootTG, new Runnable() {
+                            @Override
                             public void run() {
                                 done = true;
                                 wakeUpUpdateThread();
                             }
                         });
-                    shutdown.setContextClassLoader(null);
-                    try {
-                        Runtime.getRuntime().addShutdownHook(shutdown);
-                    } catch (Exception e) {
-                        done = true;
+                        shutdown.setContextClassLoader(null);
+                        try {
+                            Runtime.getRuntime().addShutdownHook(shutdown);
+                        } catch (Exception e) {
+                            done = true;
+                        }
+                        return null;
                     }
-                    return null;
                 }
-            }
         );
     }
 
@@ -354,21 +351,20 @@
      */
     private synchronized void startUpdateThread() {
         if (screenUpdater == null) {
-            screenUpdater = (Thread)java.security.AccessController.doPrivileged(
-                new java.security.PrivilegedAction() {
-                    public Object run() {
-                        ThreadGroup tg =
-                            Thread.currentThread().getThreadGroup();
-                        for (ThreadGroup tgn = tg;
-                             tgn != null; tg = tgn, tgn = tg.getParent());
-                        Thread t = new Thread(tg, D3DScreenUpdateManager.this,
-                                              "D3D Screen Updater");
-                        // REMIND: should it be higher?
-                        t.setPriority(Thread.NORM_PRIORITY + 2);
-                        t.setDaemon(true);
-                        return t;
-                    }
-            });
+            screenUpdater = AccessController.doPrivileged(
+                    new PrivilegedAction<Thread>() {
+                        @Override
+                        public Thread run() {
+                            ThreadGroup rootTG = ThreadGroupUtils.getRootThreadGroup();
+                            Thread t = new Thread(rootTG,
+                                    D3DScreenUpdateManager.this,
+                                    "D3D Screen Updater");
+                            // REMIND: should it be higher?
+                            t.setPriority(Thread.NORM_PRIORITY + 2);
+                            t.setDaemon(true);
+                            return t;
+                        }
+                    });
             screenUpdater.start();
         } else {
             wakeUpUpdateThread();
--- ./jdk/src/windows/native/java/lang/java_props_md.c	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/windows/native/java/lang/java_props_md.c	Tue Mar 18 12:35:25 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1998, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -448,6 +448,7 @@
                     case  0: sprops.os_name = "Windows Vista";        break;
                     case  1: sprops.os_name = "Windows 7";            break;
                     case  2: sprops.os_name = "Windows 8";            break;
+                    case  3: sprops.os_name = "Windows 8.1";          break;
                     default: sprops.os_name = "Windows NT (unknown)";
                     }
                 } else {
@@ -455,6 +456,7 @@
                     case  0: sprops.os_name = "Windows Server 2008";    break;
                     case  1: sprops.os_name = "Windows Server 2008 R2"; break;
                     case  2: sprops.os_name = "Windows Server 2012";    break;
+                    case  3: sprops.os_name = "Windows Server 2012 R2"; break;
                     default: sprops.os_name = "Windows NT (unknown)";
                     }
                 }
--- ./jdk/src/windows/native/sun/font/fontpath.c	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/windows/native/sun/font/fontpath.c	Tue Mar 18 12:35:25 2014 -0700
@@ -185,6 +185,12 @@
     return 0;
 }
 
+/* This HDC is initialised and released in the populate family map
+ * JNI entry point, and used within the call which would otherwise
+ * create many DCs.
+ */
+static HDC screenDC = NULL;
+
 static int DifferentFamily(wchar_t *family, wchar_t* fullName) {
     LOGFONTW lfw;
     CheckFamilyInfo info;
@@ -202,7 +208,7 @@
     memset(&lfw, 0, sizeof(lfw));
     wcscpy(lfw.lfFaceName, fullName);
     lfw.lfCharSet = DEFAULT_CHARSET;
-    EnumFontFamiliesExW(GetDC(NULL), &lfw,
+    EnumFontFamiliesExW(screenDC, &lfw,
                         (FONTENUMPROCW)CheckFontFamilyProcW,
                         (LPARAM)(&info), 0L);
 
@@ -299,7 +305,7 @@
     memset(&lfa, 0, sizeof(lfa));
     strcpy(lfa.lfFaceName, lpelfe->elfLogFont.lfFaceName);
     lfa.lfCharSet = lpelfe->elfLogFont.lfCharSet;
-    EnumFontFamiliesExA(GetDC(NULL), &lfa,
+    EnumFontFamiliesExA(screenDC, &lfa,
                         (FONTENUMPROCA)EnumFontFacesInFamilyProcA,
                         lParam, 0L);
     return 1;
@@ -353,7 +359,7 @@
     memset(&lfw, 0, sizeof(lfw));
     wcscpy(lfw.lfFaceName, lpelfe->elfLogFont.lfFaceName);
     lfw.lfCharSet = lpelfe->elfLogFont.lfCharSet;
-    EnumFontFamiliesExW(GetDC(NULL), &lfw,
+    EnumFontFamiliesExW(screenDC, &lfw,
                         (FONTENUMPROCW)EnumFontFacesInFamilyProcW,
                         lParam, 0L);
     return 1;
@@ -613,13 +619,17 @@
         return;
     }
 
+    screenDC = GetDC(NULL);
+    if (screenDC == NULL) {
+        return;
+    }
     /* Enumerate fonts via GDI to build maps of fonts and families */
     if (IS_NT) {
         LOGFONTW lfw;
         memset(&lfw, 0, sizeof(lfw));
         lfw.lfCharSet = DEFAULT_CHARSET;  /* all charsets */
         wcscpy(lfw.lfFaceName, L"");      /* one face per family (CHECK) */
-        EnumFontFamiliesExW(GetDC(NULL), &lfw,
+        EnumFontFamiliesExW(screenDC, &lfw,
                             (FONTENUMPROCW)EnumFamilyNamesW,
                             (LPARAM)(&fmi), 0L);
     } else {
@@ -627,7 +637,7 @@
         memset(&lfa, 0, sizeof(lfa));
         lfa.lfCharSet = DEFAULT_CHARSET; /* all charsets */
         strcpy(lfa.lfFaceName, "");      /* one face per family */
-        ret = EnumFontFamiliesExA(GetDC(NULL), &lfa,
+        ret = EnumFontFamiliesExA(screenDC, &lfa,
                             (FONTENUMPROCA)EnumFamilyNamesA,
                             (LPARAM)(&fmi), 0L);
     }
@@ -637,6 +647,8 @@
     ret = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        fontKeyName, 0L, KEY_READ, &hkeyFonts);
     if (ret != ERROR_SUCCESS) {
+        ReleaseDC(NULL, screenDC);
+        screenDC = NULL;
         return;
     }
 
@@ -653,6 +665,8 @@
         dwMaxValueNameLen >= MAX_BUFFER ||
         dwMaxValueDataLen >= MAX_BUFFER) {
         RegCloseKey(hkeyFonts);
+        ReleaseDC(NULL, screenDC);
+        screenDC = NULL;
         return;
     }
     for (nval = 0; nval < dwNumValues; nval++ ) {
@@ -692,4 +706,6 @@
         }
     }
     RegCloseKey(hkeyFonts);
+    ReleaseDC(NULL, screenDC);
+    screenDC = NULL;
 }
--- ./jdk/src/windows/native/sun/windows/awt_Toolkit.cpp	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/windows/native/sun/windows/awt_Toolkit.cpp	Tue Mar 18 12:35:25 2014 -0700
@@ -365,6 +365,7 @@
     HANDLE hCompleted;
 
     jobject thread;
+    jobject threadGroup;
 };
 
 void ToolkitThreadProc(void *param)
@@ -377,7 +378,7 @@
     JavaVMAttachArgs attachArgs;
     attachArgs.version  = JNI_VERSION_1_2;
     attachArgs.name     = "AWT-Windows";
-    attachArgs.group    = NULL;
+    attachArgs.group    = data->threadGroup;
 
     jint res = jvm->AttachCurrentThreadAsDaemon((void **)&env, &attachArgs);
     if (res < 0) {
@@ -416,17 +417,18 @@
 /*
  * Class:     sun_awt_windows_WToolkit
  * Method:    startToolkitThread
- * Signature: (Ljava/lang/Runnable;)Z
+ * Signature: (Ljava/lang/Runnable;Ljava/lang/ThreadGroup)Z
  */
 JNIEXPORT jboolean JNICALL
-Java_sun_awt_windows_WToolkit_startToolkitThread(JNIEnv *env, jclass cls, jobject thread)
+Java_sun_awt_windows_WToolkit_startToolkitThread(JNIEnv *env, jclass cls, jobject thread, jobject threadGroup)
 {
     AwtToolkit& tk = AwtToolkit::GetInstance();
 
     ToolkitThreadProc_Data data;
     data.result = false;
     data.thread = env->NewGlobalRef(thread);
-    if (data.thread == NULL) {
+    data.threadGroup = env->NewGlobalRef(threadGroup);
+    if (data.thread == NULL || data.threadGroup == NULL) {
         return JNI_FALSE;
     }
     data.hCompleted = ::CreateEvent(NULL, FALSE, FALSE, NULL);
@@ -444,6 +446,7 @@
     ::CloseHandle(data.hCompleted);
 
     env->DeleteGlobalRef(data.thread);
+    env->DeleteGlobalRef(data.threadGroup);
 
     return result ? JNI_TRUE : JNI_FALSE;
 }
--- ./jdk/src/windows/resource/java.manifest	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/src/windows/resource/java.manifest	Tue Mar 18 12:35:25 2014 -0700
@@ -44,9 +44,15 @@
   <!-- Indicate this JDK version is Windows 7 compatible -->
    <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
       <application>
+        <!-- Windows Vista -->
+        <supportedOS Id="{e2011457-1546-43c5-a5fe-008deee3d3f0}"/>
+        <!-- Windows 7 -->
         <supportedOS Id="{35138b9a-5d96-4fbd-8e2d-a2440225f93a}"/>
-        <supportedOS Id="{e2011457-1546-43c5-a5fe-008deee3d3f0}"/>
+        <!-- Windows 8 -->
+        <supportedOS Id="{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}"/>
+        <!-- Windows 8.1 -->
+        <supportedOS Id="{1f676c76-80e1-4239-95bb-83d0f6d0da78}"/>
       </application>
-    </compatibility>
+   </compatibility>
 
 </assembly>
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/awt/Graphics2D/DrawString/DrawRotatedString.java	Tue Mar 18 12:35:25 2014 -0700
@@ -0,0 +1,81 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import java.awt.Color;
+import java.awt.Graphics2D;
+import java.awt.RenderingHints;
+import java.awt.image.BufferedImage;
+import java.io.File;
+import java.io.IOException;
+
+import javax.imageio.ImageIO;
+
+/**
+ * @test
+ * @bug 7190349
+ * @summary Verifies that we get correct direction, when draw rotated string.
+ * @author Sergey Bylokhov
+ * @run main/othervm DrawRotatedString
+ */
+public final class DrawRotatedString {
+
+    private static final int SIZE = 500;
+
+    public static void main(final String[] args) throws IOException {
+        BufferedImage bi = createBufferedImage(true);
+        verify(bi);
+        bi = createBufferedImage(false);
+        verify(bi);
+        System.out.println("Passed");
+    }
+
+    private static void verify(BufferedImage bi) throws IOException {
+        for (int i = 0; i < SIZE; ++i) {
+            for (int j = 0; j < 99; ++j) {
+                //Text should not appear before 100
+                if (bi.getRGB(i, j) != Color.RED.getRGB()) {
+                    ImageIO.write(bi, "png", new File("image.png"));
+                    throw new RuntimeException("Failed: wrong text location");
+                }
+            }
+        }
+    }
+
+    private static BufferedImage createBufferedImage(final boolean  aa) {
+        final BufferedImage bi = new BufferedImage(SIZE, SIZE,
+                                                   BufferedImage.TYPE_INT_RGB);
+        final Graphics2D bg = bi.createGraphics();
+        bg.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
+                            aa ? RenderingHints.VALUE_ANTIALIAS_ON
+                               : RenderingHints.VALUE_ANTIALIAS_OFF);
+        bg.setColor(Color.RED);
+        bg.fillRect(0, 0, SIZE, SIZE);
+        bg.translate(100, 100);
+        bg.rotate(Math.toRadians(90));
+        bg.setColor(Color.BLACK);
+        bg.setFont(bg.getFont().deriveFont(20.0f));
+        bg.drawString("MMMMMMMMMMMMMMMM", 0, 0);
+        bg.dispose();
+        return bi;
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/awt/Graphics2D/IncorrectTextSize/IncorrectTextSize.java	Tue Mar 18 12:35:25 2014 -0700
@@ -0,0 +1,77 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import java.awt.Color;
+import java.awt.Font;
+import java.awt.Graphics2D;
+import java.awt.image.BufferedImage;
+import java.io.File;
+import java.io.IOException;
+
+import javax.imageio.ImageIO;
+
+/**
+ * @test
+ * @bug 8013569
+ * @author Sergey Bylokhov
+ */
+public final class IncorrectTextSize {
+
+    static final int scale = 2;
+    static final int width = 1200;
+    static final int height = 100;
+    static BufferedImage bi = new BufferedImage(width, height,
+                                                BufferedImage.TYPE_INT_ARGB);
+    static final String TEXT = "The quick brown fox jumps over the lazy dog"
+            + "The quick brown fox jumps over the lazy dog";
+
+    public static void main(final String[] args) throws IOException {
+        for (int  point = 5; point < 11; ++point) {
+            Graphics2D g2d = bi.createGraphics();
+            g2d.setFont(new Font(Font.DIALOG, Font.PLAIN, point));
+            g2d.scale(scale, scale);
+            g2d.setColor(Color.WHITE);
+            g2d.fillRect(0, 0, width, height);
+            g2d.setColor(Color.green);
+            g2d.drawString(TEXT, 0, 20);
+            int length = g2d.getFontMetrics().stringWidth(TEXT);
+            if (length < 0) {
+                throw new RuntimeException("Negative length");
+            }
+            for (int i = (length + 1) * scale; i < width; ++i) {
+                for (int j = 0; j < height; ++j) {
+                    if (bi.getRGB(i, j) != Color.white.getRGB()) {
+                        g2d.drawLine(length, 0, length, height);
+                        ImageIO.write(bi, "png", new File("image.png"));
+                        System.out.println("length = " + length);
+                        System.err.println("Wrong color at x=" + i + ",y=" + j);
+                        System.err.println("Color is:" + new Color(bi.getRGB(i,
+                                                                             j)));
+                        throw new RuntimeException("Test failed.");
+                    }
+                }
+            }
+            g2d.dispose();
+        }
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/awt/Toolkit/LoadAWTCrashTest/LoadAWTCrashTest.java	Tue Mar 18 12:35:25 2014 -0700
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+  @test
+  @bug 8031477
+  @summary Crash while awt starting
+  @author Petr Pchelko
+  @run main/othervm LoadAWTCrashTest
+*/
+
+public class LoadAWTCrashTest {
+    public static void main(String[] args) {
+        System.loadLibrary("awt");
+        // If the bug is present JVM would crash or deadlock
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/awt/font/TextLayout/TestAATMorxFont.java	Tue Mar 18 12:35:25 2014 -0700
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+/* @test
+ * @summary verify rendering of MORX fonts on OS X.
+ * @bug 8031462
+ */
+
+import javax.swing.*;
+import javax.swing.border.LineBorder;
+import java.awt.*;
+import java.awt.event.ActionEvent;
+
+public class TestAATMorxFont extends JComponent {
+    public static void main(String[] args) {
+        String osName = System.getProperty("os.name");
+        System.out.println("OS is " + osName);
+        osName = osName.toLowerCase();
+        if (!osName.startsWith("mac")) {
+            return;
+        }
+        SwingUtilities.invokeLater(new Runnable() {
+            public void run() {
+                JFrame frame = new JFrame("Test Morx");
+                frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
+                TestAATMorxFont  panel = new TestAATMorxFont();
+                frame.add(panel);
+                frame.pack();
+                frame.setVisible(true);
+            }
+        });
+    }
+
+    public Dimension getPreferredSize() {
+        return new Dimension(1200, 400);
+    }
+
+    public void paintComponent(Graphics g) {
+        Graphics2D g2d = (Graphics2D)g;
+        g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,
+                             RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
+        int y = 50;
+        g.setFont(new Font("Gujarati MT", Font.PLAIN, 40));
+        System.out.println(g.getFont());
+        g.drawString("\u0A95\u0ACD \u0A95\u0A95\u0A95 \u0A95\u0ACD\u0A95\u0ACD\u0A95", 20, y);
+        y += 50;
+        g.setFont(new Font("Tamil Sangam MN", Font.PLAIN, 40));
+        System.out.println(g.getFont());
+        g.drawString("\u0b95\u0bCD \u0b95\u0b95\u0b95 \u0b95\u0bCD\u0b95\u0bCD\u0b95", 20, y);
+        y += 50;
+        g.setFont(new Font("Telugu Sangam MN", Font.PLAIN, 40));
+        System.out.println(g.getFont());
+        g.drawString("\u0c15\u0c4D \u0c15\u0c15\u0c15 \u0c15\u0c4D\u0c15\u0c4D\u0c15", 20, y);
+        y += 50;
+        g.setFont(new Font("Devanagari Sangam MN", Font.PLAIN, 40));
+        System.out.println(g.getFont());
+        g.drawString("\u0915\u0940 \u0915\u0947 \u0915\u0942", 20, y);
+        y += 50;
+        g.drawString("\u0907\u0930\u094D\u0915\u094D\u0915\u094D\u0915\u094D\u0915\u094D\u0915\u094D\u0915\u094D\u0915\u094D\u0915\u094D\u0915\u094D\u0915", 20, y);
+        y += 50;
+        g.drawString("\u0930\u093F\u0935\u094D\u092F\u0942 \u0915\u0947 \u092C\u093E\u0926 \u0935\u093F\u0915\u093E\u0938 \u0913\u0932\u0902\u092A\u093F\u0915 \u0938\u0947 \u092C\u093E\u0939\u0930 (\u0926\u0947\u0935\u0928\u093E\u0917\u0930\u0940) (\u0939\u093F\u0928\u094D\u0926\u0940) \u0907\u0930\u094D\u0915\u094D\u0915\u094D\u0915\u094D\u0915\u094D\u0915\u094D\u0915\u094D\u0915\u094D\u0915\u094D\u0915\u094D\u0915", 20, y);
+
+    }
+}
+
--- ./jdk/test/java/beans/Introspector/TestTypeResolver.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/test/java/beans/Introspector/TestTypeResolver.java	Tue Mar 18 12:35:25 2014 -0700
@@ -113,6 +113,8 @@
         // by private implementations of the various Type interfaces
         if (expect.equals(t) && t.equals(expect))
             System.out.println(", as expected");
+        else if ((expect.equals(t) || t.equals(expect)) && expect.toString().equals(t.toString()))
+            System.out.println(", as workaround of the 8023301 bug");
         else {
             System.out.println(" BUT SHOULD BE " + expect);
             failedCases.add(c);
--- ./jdk/test/java/lang/ProcessBuilder/Basic.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/test/java/lang/ProcessBuilder/Basic.java	Tue Mar 18 12:35:25 2014 -0700
@@ -29,6 +29,7 @@
  *      4947220 7018606 7034570
  * @summary Basic tests for Process and Environment Variable code
  * @run main/othervm/timeout=300 Basic
+ * @run main/othervm/timeout=300 -Djdk.lang.Process.launchMechanism=fork Basic
  * @author Martin Buchholz
  */
 
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/lang/ProcessBuilder/BasicLauncher.java	Tue Mar 18 12:35:25 2014 -0700
@@ -0,0 +1,99 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 5049299
+ * @summary (process) Use posix_spawn, not fork, on S10 to avoid swap exhaustion
+ * @compile BasicLauncher.java Basic.java
+ * @run main BasicLauncher
+ */
+
+import java.io.*;
+import java.nio.file.*;
+
+public class BasicLauncher {
+
+    private static boolean passed = false;
+
+    public static void main(String args[]) throws Exception {
+        String osName = System.getProperty("os.name");
+        if (osName.startsWith("SunOS")) {
+            BasicLauncher l = new BasicLauncher();
+            l.start();
+        }
+    }
+
+    private void start() throws Exception {
+        String separator = System.getProperty("file.separator");
+        String jdkpath = System.getProperty("test.jdk") + separator + "bin" + separator;
+        String srcpath = System.getProperty("test.src", ".") + separator;
+        String testClasses = System.getProperty("test.classes", ".");
+
+        ProcessBuilder builder = new ProcessBuilder(
+            jdkpath + "java",
+            "-cp",
+            testClasses,
+            "-Djdk.lang.Process.launchMechanism=posix_spawn",
+            "Basic");
+        builder.redirectErrorStream(true);
+        Process testProc = builder.start();
+        printProcessThread ppt =
+                new printProcessThread(testProc, "testproc");
+        ppt.start();
+        testProc.waitFor();
+        System.out.println("testproc done");
+
+        if (!passed)
+            throw new RuntimeException("Test Failed: ");
+    }
+
+
+    class printProcessThread extends Thread {
+        Process p;
+        String pName;
+
+        public printProcessThread(Process p, String pName) {
+            this.p = p;
+            this.pName = pName;
+        }
+
+        @Override
+        public void run() {
+            try (BufferedReader reader =
+                new BufferedReader(new InputStreamReader(p.getInputStream()))) {
+                String line;
+                while ((line = reader.readLine()) != null) {
+                    System.out.println("[Output: " + pName + "]" + line);
+                    if (line.contains("failed = 0")) {
+                        passed = true;
+                    }
+                }
+
+            } catch (Exception e) {
+                System.out.println("Exception encountered in " + pName
+                        + " thread\n" + e);
+            }
+        }
+    }
+}
--- ./jdk/test/java/util/logging/TestAppletLoggerContext.java	Thu Dec 19 09:01:16 2013 -0800
+++ ./jdk/test/java/util/logging/TestAppletLoggerContext.java	Tue Mar 18 12:35:25 2014 -0700
@@ -110,28 +110,19 @@
             }
 
             TestExc exc;
-            TestExc global = new TestExc();
 
             @Override
-            public Object getContext() { return active ? global : null; }
+            public Object getAppletContext() { return active ? exc : null; }
             @Override
-            public Object getExecutionContext() { return active ? exc : null; }
+            public Object get(Object o) { return exc.get(o); }
             @Override
-            public Object get(Object o, Object o1) { return TestExc.exc(o).get(o1); }
+            public void put(Object o, Object o1) { exc.put(o, o1); }
             @Override
-            public void put(Object o, Object o1, Object o2) { TestExc.exc(o).put(o1, o2); }
-            @Override
-            public void remove(Object o, Object o1) { TestExc.exc(o).remove(o1); }
-            @Override
-            public Object get(Object o) { return global.get(o); }
-            @Override
-            public void put(Object o, Object o1) { global.put(o, o1); }
-            @Override
-            public void remove(Object o) { global.remove(o); }
+            public void remove(Object o) { exc.remove(o); }
             @Override
             public boolean isDisposed() { return false; }
             @Override
-            public boolean isMainAppContext() { return exc == null; }
+            public boolean isMainAppContext() { return !active || exc == null; }
         }
 
         final static JavaAWTAccessStub javaAwtAccess = new JavaAWTAccessStub();
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/util/logging/TestLoggingWithMainAppContext.java	Tue Mar 18 12:35:25 2014 -0700
@@ -0,0 +1,75 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.util.logging.Logger;
+import javax.imageio.ImageIO;
+
+/**
+ * @test
+ * @bug 8019853 8023258
+ * @summary Test that the default user context is used when in the main
+ *          application context. This test must not be run in same VM or agent
+ *          VM mode: it would not test the intended behavior.
+ * @run main/othervm TestLoggingWithMainAppContext
+ */
+public class TestLoggingWithMainAppContext {
+
+    public static void main(String[] args) throws IOException {
+        System.out.println("Creating loggers.");
+
+        // These loggers will be created in the default user context.
+        final Logger foo1 = Logger.getLogger( "foo" );
+        final Logger bar1 = Logger.getLogger( "foo.bar" );
+        if (bar1.getParent() != foo1) {
+            throw new RuntimeException("Parent logger of bar1 "+bar1+" is not "+foo1);
+        }
+        System.out.println("bar1.getParent() is the same as foo1");
+
+        // Set a security manager
+        System.setSecurityManager(new SecurityManager());
+        System.out.println("Now running with security manager");
+
+        // Triggers the creation of the main AppContext
+        ByteArrayInputStream is = new ByteArrayInputStream(new byte[] { 0, 1 });
+        ImageIO.read(is); // triggers calls to system loggers & creation of main AppContext
+
+        // verify that we're still using the default user context
+        final Logger bar2 = Logger.getLogger( "foo.bar" );
+        if (bar1 != bar2) {
+            throw new RuntimeException("bar2 "+bar2+" is not the same as bar1 "+bar1);
+        }
+        System.out.println("bar2 is the same as bar1");
+        if (bar2.getParent() != foo1) {
+            throw new RuntimeException("Parent logger of bar2 "+bar2+" is not foo1 "+foo1);
+        }
+        System.out.println("bar2.getParent() is the same as foo1");
+        final Logger foo2 = Logger.getLogger("foo");
+        if (foo1 != foo2) {
+            throw new RuntimeException("foo2 "+foo2+" is not the same as foo1 "+foo1);
+        }
+        System.out.println("foo2 is the same as foo1");
+
+        System.out.println("Test passed.");
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/util/logging/TestMainAppContext.java	Tue Mar 18 12:35:25 2014 -0700
@@ -0,0 +1,85 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+import java.util.logging.Logger;
+import sun.awt.AppContext;
+import sun.awt.SunToolkit;
+
+
+/**
+ * @test
+ * @bug 8026404
+ * @summary checks that calling getLogger() from a Thread whose ThreadGroup is
+ *          a child of the main root group doesn't throw an exception.
+ * @build TestMainAppContext
+ * @run main/othervm TestMainAppContext
+ * @author danielfuchs
+ */
+public class TestMainAppContext {
+
+    static volatile Throwable thrown = null;
+
+    public static void main(String... args) throws Exception {
+        ThreadGroup rootTG = Thread.currentThread().getThreadGroup();
+        while (rootTG.getParent() != null) {
+            rootTG = rootTG.getParent();
+        }
+
+        ThreadGroup tg = new ThreadGroup(rootTG, "FakeApplet");
+        final Thread t1 = new Thread(tg, "createNewAppContext") {
+            @Override
+            public void run() {
+                try {
+                    AppContext context = SunToolkit.createNewAppContext();
+                } catch(Throwable t) {
+                    thrown = t;
+                }
+            }
+        };
+        t1.start();
+        t1.join();
+        if (thrown != null) {
+            throw new RuntimeException("Unexpected exception: " + thrown, thrown);
+        }
+        Thread t2 = new Thread(tg, "BugDetector") {
+
+            @Override
+            public void run() {
+                try {
+                    Logger.getLogger("foo").info("Done");
+                } catch (Throwable x) {
+                    thrown = x;
+                }
+            }
+
+        };
+
+        System.setSecurityManager(new SecurityManager());
+        t2.start();
+        t2.join();
+        if (thrown != null) {
+            throw new RuntimeException("Test failed: " + thrown, thrown);
+        }
+
+    }
+
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/javax/imageio/plugins/jpeg/TruncatedImageWarningTest.java	Tue Mar 18 12:35:25 2014 -0700
@@ -0,0 +1,58 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import java.io.File;
+import java.io.IOException;
+import javax.imageio.ImageIO;
+import javax.imageio.ImageReader;
+import javax.imageio.event.IIOReadWarningListener;
+import javax.imageio.stream.ImageInputStream;
+
+public class TruncatedImageWarningTest implements IIOReadWarningListener {
+
+    private static String fileName = "truncated.jpg";
+    boolean receivedWarning = false;
+
+    public static void main(String[] args) throws IOException {
+
+        String sep = System.getProperty("file.separator");
+        String dir = System.getProperty("test.src", ".");
+        String filePath = dir+sep+fileName;
+        System.out.println("Test file: " + filePath);
+        File f = new File(filePath);
+        ImageInputStream in = ImageIO.createImageInputStream(f);
+        ImageReader reader = ImageIO.getImageReaders(in).next();
+        TruncatedImageWarningTest twt = new TruncatedImageWarningTest();
+        reader.addIIOReadWarningListener(twt);
+        reader.setInput(in);
+        reader.read(0);
+        if (!twt.receivedWarning) {
+            throw new RuntimeException("No expected warning");
+        }
+    }
+
+    public void warningOccurred(ImageReader source, String warning) {
+        System.out.println("Expected warning: " + warning);
+        receivedWarning = true;
+    }
+}
Binary file test/javax/imageio/plugins/jpeg/truncated.jpg has changed
--- ./langtools/.hgtags	Thu Dec 19 09:01:27 2013 -0800
+++ ./langtools/.hgtags	Tue Mar 18 12:45:26 2014 -0700
@@ -381,6 +381,9 @@
 ba3ff27d4082f2cf0d06e635b2b6e01f80e78589 jdk7u45-b18
 164cf7491ba2f371354ba343a604eee4c61c529d jdk7u45-b30
 7f5cfaedb25c2c2774d6839810d6ae543557ca01 jdk7u45-b31
+ef7bdbe7f1fa42fd58723e541d9cdedcacb2649a jdk7u45-b33
+bcb3e939d046d75436c7c8511600b6edce42e6da jdk7u45-b34
+efbda7abd821f280ec3a3aa6819ad62d45595e55 jdk7u45-b35
 18d1864abca976ca68cb71612e9b20c908455d3d jdk7u51-b00
 14d1cf2630aea549cfba9d052200c7ebcabd875c jdk7u51-b01
 f0168ccf171ed6080267fe0a7f7aed0b46bd5713 jdk7u51-b02
@@ -395,3 +398,21 @@
 c9d8d8793d9330d592190c334260ccf26c986df6 jdk7u51-b11
 5b44df2114e466da85c3816627bfcd1b59c6499d jdk7u51-b12
 4d0807934c302f2e35e6a5acc6cdc720c82b5671 jdk7u51-b13
+ada23e55d76a378cb2fc2cd7ffae8c147aaf0055 jdk7u51-b30
+e3d4896d52ab4ad0fc0b7a45d60340dbdcb8826d jdk7u51-b31
+fb3ff30ecd8ea1637551461bfaf09fc8204b536c jdk7u51-b33
+4adc6c094545774b324d2e5511723ada2b32e6c4 jdk7u51-b34
+5b44df2114e466da85c3816627bfcd1b59c6499d jdk7u55-b00
+3e64e49131b88c839733c9869ff8aebcd15cf828 jdk7u55-b01
+2a9f5c00ba46f895bc9d16a584bf7d80c1822268 jdk7u55-b02
+0479d260ac835eb3f0c7f3d7d15be0599b92a20a jdk7u55-b03
+a244cc40ae0b29028ff8503ee516cb5f9e3db6e3 jdk7u55-b04
+25d63d986653d81522b01bbd2664083ae5fdc243 jdk7u55-b05
+76eeeaace70d38795eef5215f758493421cee0ac jdk7u55-b06
+08f7914d6aa947e73269b4e60110ed12573ffa28 jdk7u55-b07
+e64301b473b43609cb28d8cfe7e5db17d9bf8a4a jdk7u55-b08
+a296112a3fd774c258375912c7ada38daf8eee1e jdk7u55-b09
+faa9f8c51a6e3fcb444729012a798e3ad09c3da4 jdk7u55-b10
+2bdd105e433da7fbf7f37ec2f75fc4bed4e54280 jdk7u55-b11
+a3cdca5d3773f67a49091f9131a4d073bc6b83d9 jdk7u55-b12
+81bf1ca3a3a71c628b7d952ba47c6f200a223f27 jdk7u55-b13
--- ./langtools/src/share/classes/com/sun/tools/doclets/formats/html/ConfigurationImpl.java	Thu Dec 19 09:01:27 2013 -0800
+++ ./langtools/src/share/classes/com/sun/tools/doclets/formats/html/ConfigurationImpl.java	Tue Mar 18 12:45:26 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1998, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -235,7 +235,7 @@
             } else if (opt.equals("-doctitle")) {
                 doctitle = os[1];
             } else if (opt.equals("-windowtitle")) {
-                windowtitle = os[1];
+                windowtitle = os[1].replaceAll("\\<.*?>", "");
             } else if (opt.equals("-top")) {
                 top = os[1];
             } else if (opt.equals("-bottom")) {
--- ./langtools/test/com/sun/javadoc/testWindowTitle/TestWindowTitle.java	Thu Dec 19 09:01:27 2013 -0800
+++ ./langtools/test/com/sun/javadoc/testWindowTitle/TestWindowTitle.java	Tue Mar 18 12:45:26 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2013, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -23,7 +23,7 @@
 
 /*
  * @test
- * @bug 8016675
+ * @bug 8016675 8026736
  * @summary Test for window title.
  * @author Bhavesh Patel
  * @library ../lib/
@@ -34,26 +34,153 @@
 public class TestWindowTitle extends JavadocTester {
 
     private static final String BUG_ID = "8016675";
-    private static final String WIN_TITLE =
+    //Window title with JavaScript special characters.
+    private static final String TITLE_JS_CHARS =
             "Testing \"Window 'Title'\" with a \\ backslash and a / " +
             "forward slash and a \u00e8 unicode char also a    tab and also a " +
             "\t special character another \u0002 unicode)";
-    private static final String[][] TEST = {
-        {BUG_ID + FS  + "overview-summary.html",
+    private static final String[] ARGS_JS_CHARS = new String[]{
+        "-d", BUG_ID + "-1", "-windowtitle", TITLE_JS_CHARS, "-sourcepath", SRC_DIR, "p1", "p2"
+    };
+    private static final String[][] TEST_JS_CHARS = {
+        {BUG_ID + "-1" + FS + "overview-summary.html",
             "parent.document.title=\"Overview (Testing \\\"Window \\\'Title\\\'\\\" " +
             "with a \\\\ backslash and a / forward slash and a \\u00E8 unicode char " +
             "also a    tab and also a \\t special character another \\u0002 unicode))\";"
         },
     };
-    private static final String[][] NEG_TEST = {
-        {BUG_ID + FS + "overview-summary.html",
+    private static final String[][] NEG_TEST_JS_CHARS = {
+        {BUG_ID + "-1" + FS + "overview-summary.html",
             "parent.document.title=\"Overview (Testing \"Window \'Title\'\" " +
             "with a \\ backslash and a / forward slash and a \u00E8 unicode char " +
             "also a    tab and also a \t special character another \u0002 unicode))\";"
+        }
+    };
+
+    //Window title with a script tag.
+    private static final String TITLE_SCRIPT_TAG =
+            "Testing script tag in title </title><script>alert(\"Should not pop up\")</script>.";
+    private static final String[] ARGS_SCRIPT_TAG = new String[]{
+        "-d", BUG_ID + "-2", "-windowtitle", TITLE_SCRIPT_TAG, "-sourcepath", SRC_DIR, "p1", "p2"
+    };
+    private static final String[][] TEST_SCRIPT_TAG = {
+        {BUG_ID + "-2" + FS + "overview-summary.html",
+            "parent.document.title=\"Overview (Testing script tag in title alert" +
+            "(\\\"Should not pop up\\\").)\";"
         },
+        {BUG_ID + "-2" + FS + "p2" + FS + "C2.html",
+            "parent.document.title=\"C2 (Testing script tag in title alert" +
+            "(\\\"Should not pop up\\\").)\";"
+        }
     };
-    private static final String[] ARGS = new String[]{
-        "-d", BUG_ID, "-windowtitle", WIN_TITLE, "-sourcepath", SRC_DIR, "p1", "p2"
+    private static final String[][] NEG_TEST_SCRIPT_TAG = {
+        {BUG_ID + "-2" + FS + "overview-summary.html",
+            "parent.document.title=\"Overview (Testing script tag in title </title><script>" +
+            "alert(\\\"Should not pop up\\\")</script>.)\";"
+        },
+        {BUG_ID + "-2" + FS + "p2" + FS + "C2.html",
+            "parent.document.title=\"C2 (Testing script tag in title </title><script>" +
+            "alert(\\\"Should not pop up\\\")</script>.)\";"
+        }
+    };
+
+    //Window title with other HTML tags.
+    private static final String TITLE_HTML_TAGS =
+            "Testing another <p>HTML</p> tag. Another <h1>tag</h1>. A " +
+            "<span id=\"testTag\">tag with attributes</span>. <script and </p are not tags.";
+    private static final String[] ARGS_HTML_TAGS = new String[]{
+        "-d", BUG_ID + "-3", "-windowtitle", TITLE_HTML_TAGS, "-sourcepath", SRC_DIR, "p1", "p2"
+    };
+    private static final String[][] TEST_HTML_TAGS = {
+        {BUG_ID + "-3" + FS + "overview-summary.html",
+            "parent.document.title=\"Overview (Testing another HTML tag. Another tag. A " +
+            "tag with attributes. <script and </p are not tags.)\";"
+        }
+    };
+    private static final String[][] NEG_TEST_HTML_TAGS = {
+        {BUG_ID + "-3" + FS + "overview-summary.html",
+            "parent.document.title=\"Overview (Testing another <p>HTML</p> tag. Another " +
+            "<h1>tag</h1>. A <span id=\"testTag\">tag with attributes</span>. <script and " +
+            "</p are not tags.)\";"
+        }
+    };
+
+    //Window title using entities.
+    private static final String TITLE_HTML_ENTITIES =
+            "Testing entities &lt;script&gt;alert(\"Should not pop up\")&lt;/script&gt;.";
+    private static final String[] ARGS_HTML_ENTITIES = new String[]{
+        "-d", BUG_ID + "-4", "-windowtitle", TITLE_HTML_ENTITIES, "-sourcepath", SRC_DIR, "p1", "p2"
+    };
+    private static final String[][] TEST_HTML_ENTITIES = {
+        {BUG_ID + "-4" + FS + "overview-summary.html",
+            "parent.document.title=\"Overview (Testing entities &lt;script&gt;alert(\\\"Should " +
+            "not pop up\\\")&lt;/script&gt;.)\";"
+        }
+    };
+    private static final String[][] NEG_TEST_HTML_ENTITIES = {
+        {BUG_ID + "-4" + FS  + "overview-summary.html",
+            "parent.document.title=\"Overview (Testing entities alert(\\\"Should not pop up\\\").)\";"
+        }
+    };
+
+    //Window title with just empty HTML tags.
+    private static final String TITLE_EMPTY_TAGS =
+            "</title><script></script>";
+    private static final String[] ARGS_EMPTY_TAGS = new String[]{
+        "-d", BUG_ID + "-5", "-windowtitle", TITLE_EMPTY_TAGS, "-sourcepath", SRC_DIR, "p1", "p2"
+    };
+    private static final String[][] TEST_EMPTY_TAGS = {
+        {BUG_ID + "-5" + FS + "overview-summary.html",
+            "parent.document.title=\"Overview\";"
+        }
+    };
+    private static final String[][] NEG_TEST_EMPTY_TAGS = {
+        {BUG_ID + "-5" + FS + "overview-summary.html",
+            "parent.document.title=\"Overview (</title><script></script>)\";"
+        }
+    };
+
+    //Window title with unicode characters.
+    private static final String TITLE_UNICODE_CHARS =
+            "Testing unicode \u003cscript\u003ealert(\"Should not pop up\")\u003c/script\u003e.";
+    private static final String[] ARGS_UNICODE_CHARS = new String[]{
+        "-d", BUG_ID + "-6", "-windowtitle", TITLE_UNICODE_CHARS, "-sourcepath", SRC_DIR, "p1", "p2"
+    };
+    private static final String[][] TEST_UNICODE_CHARS = {
+        {BUG_ID + "-6" + FS + "overview-summary.html",
+            "parent.document.title=\"Overview (Testing unicode alert(\\\"Should " +
+            "not pop up\\\").)\";"
+        }
+    };
+    private static final String[][] NEG_TEST_UNICODE_CHARS = {
+        {BUG_ID + "-6" + FS + "overview-summary.html",
+            "parent.document.title=\"Overview (Testing unicode <script>alert(\\\"Should not pop up\\\")" +
+            "</script>.)\";"
+        }
+    };
+
+    //An empty window title.
+    private static final String TITLE_EMPTY =
+            "";
+    private static final String[] ARGS_EMPTY_TITLE = new String[]{
+        "-d", BUG_ID + "-7", "-windowtitle", TITLE_EMPTY, "-sourcepath", SRC_DIR, "p1", "p2"
+    };
+    private static final String[][] TEST_EMPTY = {
+        {BUG_ID + "-7" + FS + "overview-summary.html",
+            "parent.document.title=\"Overview\";"
+        }
+    };
+
+    //Test doctitle.
+    private static final String[] ARGS_DOCTITLE = new String[]{
+        "-d", BUG_ID + "-8", "-doctitle", TITLE_JS_CHARS, "-sourcepath", SRC_DIR, "p1", "p2"
+    };
+    private static final String[][] NEG_TEST_DOCTITLE = {
+        {BUG_ID + "-8" + FS + "overview-summary.html",
+            "parent.document.title=\"Overview (Testing \\\"Window \\\'Title\\\'\\\" " +
+            "with a \\\\ backslash and a / forward slash and a \\u00E8 unicode char " +
+            "also a    tab and also a \\t special character another \\u0002 unicode)\";"
+        },
     };
 
     /**
@@ -62,7 +189,14 @@
      */
     public static void main(String[] args) {
         TestWindowTitle tester = new TestWindowTitle();
-        run(tester, ARGS, TEST, NEG_TEST);
+        run(tester, ARGS_JS_CHARS, TEST_JS_CHARS, NEG_TEST_JS_CHARS);
+        run(tester, ARGS_SCRIPT_TAG, TEST_SCRIPT_TAG, NEG_TEST_SCRIPT_TAG);
+        run(tester, ARGS_HTML_TAGS, TEST_HTML_TAGS, NEG_TEST_HTML_TAGS);
+        run(tester, ARGS_HTML_ENTITIES, TEST_HTML_ENTITIES, NEG_TEST_HTML_ENTITIES);
+        run(tester, ARGS_EMPTY_TAGS, TEST_EMPTY_TAGS, NEG_TEST_EMPTY_TAGS);
+        run(tester, ARGS_UNICODE_CHARS, TEST_UNICODE_CHARS, NEG_TEST_UNICODE_CHARS);
+        run(tester, ARGS_EMPTY_TITLE, TEST_EMPTY, NO_TEST);
+        run(tester, ARGS_DOCTITLE, NO_TEST, NEG_TEST_DOCTITLE);
         tester.printSummary();
     }
 
