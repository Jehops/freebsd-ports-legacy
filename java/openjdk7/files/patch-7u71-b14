--- ./.hgtags	Wed Jun 25 09:01:10 2014 -0700
+++ ./.hgtags	Mon Sep 08 12:14:23 2014 -0700
@@ -418,6 +418,7 @@
 d972a2d9e4f3f864d26c33ccfdacd8269e0f29a8 jdk7u55-b13
 0820b4707cfa75f8211b88b0daa67bba8475f498 jdk7u55-b30
 997ab3897d6ede80b0decdda94b569e57dd7dd90 jdk7u55-b14
+744f7b17de89527bf639d5bff3533a9ce72dfa84 jdk7u55-b15
 1f52edec29fd44c8bacce11ba7440287b37d04d1 jdk7u55-b31
 5b15555172019b3c92484abff7c92f066e162d29 jdk7u55-b32
 fa5ead8cb7d2de49cd138d93fb86fa5a10b07037 jdk7u55-b33
@@ -466,3 +467,36 @@
 2c8b05ed9802cf4e5f61439a6d6286e7f7cd444e jdk7u65-b16
 927d8d3db13c5221237b51efe45206054ee6e3f3 jdk7u65-b17
 b51ccd32894662064192857007ef41175d433901 jdk7u65-b30
+fa242615607fa5f6cdd1ae93bc2fb9cc2100c179 jdk7u65-b18
+64dbd70735c775bef1faf873e4bec65d73d597cb jdk7u65-b19
+90f56be6f9d90f66e558c4e08084e2b169738fba jdk7u65-b32
+b6da128e8a7957f139933a48580e201e938c4684 jdk7u65-b20
+d6a1d32534d188e73f7962d40d21584c44e65acd jdk7u67-b01
+64dbd70735c775bef1faf873e4bec65d73d597cb jdk7u65-b40
+9dfdf107c6971cd30c7e1f656cddc6b8d495c290 jdk7u65-b31
+fe700de0735dc4e8ce5a50971ad3ea3dc052d21d jdk7u65-b33
+48eb3345e05fe904d2e92067da0abd04a9b375e4 jdk7u66-b00
+4fb9423d086d86d212257afd6fc79957f737af5b jdk7u66-b01
+964663d4303723fbcb16cf05e857576c08c237ae jdk7u66-b09
+6bf8128234ad7ffae0cfe53ba19202559743de97 jdk7u66-b10
+0d8c4e40851835989386c1b1db4041b6f18b037e jdk7u66-b11
+422f828e10beb3ca9e14b10774e624ec0c4fc84d jdk7u66-b12
+236545aa997a99b397e73dc9b13353231f20ea1e jdk7u66-b13
+d06bbfe19d6cefe62e359c2fd8bf9243a148a337 jdk7u66-b14
+df30693e9a66897ba0dced205bbaefc57dca7704 jdk7u66-b15
+6dc5eb9b70071b43cb0e287f30afd0348ae20ae1 jdk7u66-b16
+4f4905b6d3e837c50654bc432956a4a100246d4e jdk7u66-b17
+c779fbb7b87ec014a3371b0dd1e9317ba1280469 jdk7u71-b00
+4f0a225f8d383d22a890575b1206f916277c0a07 jdk7u71-b01
+94e1109f4cb79ba1c5369d93d0cdf300f1434a3a jdk7u71-b02
+91df9e49ab7d35ee61f88eedd4289aa33163287d jdk7u71-b03
+47c30fe92b9dad64f99d7aa72a2258bc3558f0a1 jdk7u71-b04
+d534e7f2caadd145b30dfda8b913c9a5fdb62553 jdk7u71-b05
+8821211202a58c0086e7cd57960a3f33e5c3d4a1 jdk7u71-b06
+6955561791886ef36236799794e4be79d0a65007 jdk7u71-b07
+fac69efbf4eb609e860c8c4a056dbe02b3679b87 jdk7u71-b08
+ac4596f9cdeb084af75884825e04dbcf1fd3d407 jdk7u71-b09
+38f4eee9c9387d3f683b86657fd6e3d4a90e5b0f jdk7u71-b10
+e9663e434024cb6e011013e774445a056417bb3b jdk7u71-b11
+78aa78b55b843697a630ed886962ab07d1b76358 jdk7u71-b12
+9fc5aeb0e0a8c97b1cd263a55f3aeb030cbcdf89 jdk7u71-b13
--- ./corba/.hgtags	Wed Jun 25 09:01:20 2014 -0700
+++ ./corba/.hgtags	Mon Sep 08 12:14:31 2014 -0700
@@ -420,6 +420,7 @@
 8efa6e66c13a5329c312d1a521ffab75d9a330e3 jdk7u55-b13
 e041c52fe69128ec3439d26afef9b0fcba00684c jdk7u55-b30
 a0bfd0e80ae0ae6e3a29bf527b5911c83163b3f5 jdk7u55-b14
+ae8120f628c237b18fa5c2610898659b49a60075 jdk7u55-b15
 55ff6957449cf6c79f5d5bb159df27f51ece1659 jdk7u55-b31
 fba15e177b15873e3c63b0efc7c0f5647a243a79 jdk7u55-b32
 6503115cbedda9216083fc1798e2fa5a2775f68a jdk7u55-b33
@@ -468,3 +469,36 @@
 d765ed30bd5ed2bdd71fda56c056333e1b4b0d7d jdk7u65-b16
 cd642d59aca29ff2b56e7ed016be758828f199cd jdk7u65-b17
 8740dc71b1ceb49c76470b46205c28c1302e864d jdk7u65-b30
+b7f66b9f9e8e099428ed7640a184f6135b77e40d jdk7u65-b18
+50ddba8882e7e95150418a30bfc3ee62e3c28c6c jdk7u65-b19
+dae3f20d2306622e39606d0dc967147de174afce jdk7u65-b32
+ac05dfedf008e83c2044666a70635cf82e932e41 jdk7u65-b20
+244756837ab4b214decd0e6f26b0071a483f143f jdk7u67-b01
+50ddba8882e7e95150418a30bfc3ee62e3c28c6c jdk7u65-b40
+d2f7358b01d3d8b877b2ec2ca2989bd1daf17472 jdk7u65-b31
+2067d7202adcedb80fa676dacb22a0b73d5e8548 jdk7u65-b33
+5b8210c41bc41135687028bcb000ca116e2090f6 jdk7u66-b00
+9f0f0bdd4cfb01a5d64f9528b7ffda3974171120 jdk7u66-b01
+596d979a5d4deb9d10b068479276cd4b2a12432e jdk7u66-b09
+fec514d46b860920690707e9d0538ad76ca3f886 jdk7u66-b10
+09655f16930ece8e7a8342f335726fe9ea327812 jdk7u66-b11
+dca36b02c6e10fa303023a62f51ea4bf0497ae94 jdk7u66-b12
+d0d039a1eca081bc05e833dfc027df1aa1bd018a jdk7u66-b13
+1e46e65dd58db00180f1ccaaae93ae7946b22d29 jdk7u66-b14
+f2c867d52b393e661216057f0b559ef3fd122530 jdk7u66-b15
+3039f266eef2ba54ec2869d87adac6e395c82fe9 jdk7u66-b16
+0b46b93a61966e8d2332f1d3899d7c858a653d91 jdk7u66-b17
+fd1c9030a08d513b5a477f82a46855bb6a9cacac jdk7u71-b00
+50e4090a8583a88875ab7323fc2e5b6ba2f1de7f jdk7u71-b01
+5bd7482913f6a498c2b2b6c80478b2af93dee805 jdk7u71-b02
+557d335eb4a358ffe7a8114685f11831da5d4510 jdk7u71-b03
+ccf59458d69f7fd0d6b119ee1ef16a2b131f84b8 jdk7u71-b04
+92d099fedc269d61dd10bba0f79a224c1bf40c25 jdk7u71-b05
+19de752151f6abfb477c72a92e59993a6c3c3f99 jdk7u71-b06
+36d628e53ebf7f6251395e6eb409239b473a7f16 jdk7u71-b07
+2fdf855f6d9fe27bcf102e64c120375f331ee75d jdk7u71-b08
+1655475001d914bc105959d94c24e0671591e845 jdk7u71-b09
+9508dd229246b82201fb7075ebfe2c913f89a196 jdk7u71-b10
+3e804dc3cea9ff145f375a50a161f3e173e8d3f6 jdk7u71-b11
+cc3072067ae8ac685d400ced4c0f144d6a1d9f1e jdk7u71-b12
+1616089899e25679d6cf70c77023f2a37ff85ad1 jdk7u71-b13
--- ./corba/src/share/classes/com/sun/corba/se/impl/orbutil/resources/sunorb_ja.properties	Wed Jun 25 09:01:20 2014 -0700
+++ ./corba/src/share/classes/com/sun/corba/se/impl/orbutil/resources/sunorb_ja.properties	Mon Sep 08 12:14:31 2014 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2000, 2005, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -95,7 +95,7 @@
 bootstrap.exception=\u30D7\u30ED\u30D1\u30C6\u30A3\u3092\u30D5\u30A1\u30A4\u30EB{0}\u306B\u4FDD\u5B58\u4E2D\u306B\u4F8B\u5916\u3092\u6355\u6349\u3057\u307E\u3057\u305F: \u4F8B\u5916{1}
 
 tnameserv.exception=\u30DD\u30FC\u30C8{0}\u3067\u30D6\u30FC\u30C8\u30B9\u30C8\u30E9\u30C3\u30D7\u30FB\u30B5\u30FC\u30D3\u30B9\u3092\u8D77\u52D5\u4E2D\u306B\u4F8B\u5916\u3092\u6355\u6349\u3057\u307E\u3057\u305F
-tnameserv.usage=\u30B3\u30DE\u30F3\u30C9\u30E9\u30A4\u30F3\u5F15\u6570-ORBInitialPort<portno>\u3092\u4F7F\u7528\u3057\u3066\u5225\u306E\u30DD\u30FC\u30C8\u3092\u4F7F\u7528\u3057\u3066\u304F\u3060\u3055\u3044
+tnameserv.usage=\u30B3\u30DE\u30F3\u30C9\u884C\u5F15\u6570-ORBInitialPort<portno>\u3092\u4F7F\u7528\u3057\u3066\u5225\u306E\u30DD\u30FC\u30C8\u3092\u4F7F\u7528\u3057\u3066\u304F\u3060\u3055\u3044
 tnameserv.invalidhostoption=ORBInitialHost\u306FNameService\u306B\u6709\u52B9\u306A\u30AA\u30D7\u30B7\u30E7\u30F3\u3067\u306F\u3042\u308A\u307E\u305B\u3093
 tnameserv.orbinitialport0=ORBInitialPort 0\u306FNameService\u306B\u6709\u52B9\u306A\u30AA\u30D7\u30B7\u30E7\u30F3\u3067\u306F\u3042\u308A\u307E\u305B\u3093
 tnameserv.hs1=\u521D\u671F\u30CD\u30FC\u30DF\u30F3\u30B0\u30FB\u30B3\u30F3\u30C6\u30AD\u30B9\u30C8:\n{0}
--- ./hotspot/.hgtags	Wed Jun 25 09:01:56 2014 -0700
+++ ./hotspot/.hgtags	Mon Sep 08 12:15:04 2014 -0700
@@ -629,6 +629,7 @@
 b021fd817a0177b31d1e3d65127a27458e85801e jdk7u55-b13
 d27b468d5f3be3329ff1ff342f3347e6b2e0303b jdk7u55-b30
 dff9147a781672f20bb0577a94233264ea4a95d1 jdk7u55-b14
+4e73c6403b44f86d579b1ba03ea636c52c4b559b jdk7u55-b15
 8175599864880938d68d0a515fa561043d7d5fd0 jdk7u55-b31
 ba9270b8fb1f4852ff1d9dab15571eb9e0714495 jdk7u55-b32
 0901a8cf66a0494b55bf104c9666d4e3c6ff93f0 jdk7u55-b33
@@ -686,3 +687,36 @@
 f1b2970a2564c3360db420431cfbba215da6ae43 jdk7u65-b16
 4c6df9a369cb9d54fe2d898452883a22b8ec6640 jdk7u65-b17
 aca05127f95b5704ee3a34104a8f86e36326f0c0 jdk7u65-b30
+d006213be74730453cf5c3ce31f1d1d505334419 jdk7u65-b18
+1d8226b3e9896656451801393eb3ae394faeb638 jdk7u65-b19
+c43b0b843f897a4d8cf0a3566b017b87230dd3b4 jdk7u65-b32
+d3c9265e12fa115052f18d1e3d379143b56bbf63 jdk7u65-b20
+39776d90970221dd260187acb4c37631e41a66a9 jdk7u67-b01
+1d8226b3e9896656451801393eb3ae394faeb638 jdk7u65-b40
+cf8b3a090e597e59177c5f67d44cdec12309777f jdk7u65-b31
+df855c3f4d31dd7db081d68e3054518380127893 jdk7u65-b33
+6b37a189944aaa09e81d97d394496464d16bee42 jdk7u66-b00
+121dc94194d9234e2b13c867d875e23e1bdd6abd jdk7u66-b01
+f28ea516eb0b9e99f1e342954ab4642456af4da1 jdk7u66-b09
+3dc6ae1972a45ba563518cc0e51f09885258f69d jdk7u66-b10
+8d2b3f7d5b3001d019832476d684679ca6be0c8d jdk7u66-b11
+5ee19b64ef208daaef91f063d800aa162427f8f6 jdk7u66-b12
+a1e6f9c4c1f47be1b0edef6bd92399f8f07b7d15 jdk7u66-b13
+b44baba406f2de6eeccc57dbfae653cf124b527b jdk7u66-b14
+d20b495c96d3f8899a64657aba0fc72799773cb3 jdk7u66-b15
+3bbfed065c601187449d319fd70bba6ae1ebb707 jdk7u66-b16
+4abb71ff14b2e6cf932e5c61900f480d5e1afedb jdk7u66-b17
+4ceb9c03fe8ee6b93d22854780ef8c737edd14b2 jdk7u71-b00
+f95d6d32e08006209f1798f82b60d7d05767a3e8 jdk7u71-b01
+1c760efe2d0795f4ce8260ec655b8870bfd77ca1 jdk7u71-b02
+0cb0b5abd0b5aa25fc8bd5920c8d61c5b85a10c6 jdk7u71-b03
+a491e5e52998c23502ebb1340955e3e726d44ad6 jdk7u71-b04
+c93efe6377ffd7484c50cba9a88a37bebf525114 jdk7u71-b05
+f95fa655cc119659686ba68c7242497fd209f9e1 jdk7u71-b06
+7f32b65fde34db41bf951ed81374240840ef88f4 jdk7u71-b07
+4e17bd4fb2304d068023d9d805e86d6b592d4230 jdk7u71-b08
+1ffc702334d960aa4015e5cc6f4fb9e971952b54 jdk7u71-b09
+9a17c184bcb99f13dc6ab714ad98976410429637 jdk7u71-b10
+d6cb97651f0bd8d61f4d22aa7550145bbe6fb051 jdk7u71-b11
+959b4e5d2e3111920c198187f3bc66eba3e457f1 jdk7u71-b12
+608f470d22689bab17bab0ea1dbee3e1a0802d5b jdk7u71-b13
--- ./hotspot/make/bsd/makefiles/mapfile-vers-debug	Wed Jun 25 09:01:56 2014 -0700
+++ ./hotspot/make/bsd/makefiles/mapfile-vers-debug	Mon Sep 08 12:15:04 2014 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2002, 2013, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2002, 2014, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -82,6 +82,7 @@
                 _JVM_EnableCompiler
                 _JVM_Exit
                 _JVM_FillInStackTrace
+                _JVM_FindClassFromCaller
                 _JVM_FindClassFromClass
                 _JVM_FindClassFromClassLoader
                 _JVM_FindClassFromBootLoader
--- ./hotspot/make/bsd/makefiles/mapfile-vers-product	Wed Jun 25 09:01:56 2014 -0700
+++ ./hotspot/make/bsd/makefiles/mapfile-vers-product	Mon Sep 08 12:15:04 2014 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2002, 2013, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2002, 2014, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -82,6 +82,7 @@
                 _JVM_EnableCompiler
                 _JVM_Exit
                 _JVM_FillInStackTrace
+                _JVM_FindClassFromCaller
                 _JVM_FindClassFromClass
                 _JVM_FindClassFromClassLoader
                 _JVM_FindClassFromBootLoader
--- ./hotspot/make/hotspot_version	Wed Jun 25 09:01:56 2014 -0700
+++ ./hotspot/make/hotspot_version	Mon Sep 08 12:15:04 2014 -0700
@@ -34,8 +34,8 @@
 HOTSPOT_VM_COPYRIGHT=Copyright 2014
 
 HS_MAJOR_VER=24
-HS_MINOR_VER=65
-HS_BUILD_NUMBER=04
+HS_MINOR_VER=71
+HS_BUILD_NUMBER=01
 
 JDK_MAJOR_VER=1
 JDK_MINOR_VER=7
--- ./hotspot/make/linux/makefiles/mapfile-vers-debug	Wed Jun 25 09:01:56 2014 -0700
+++ ./hotspot/make/linux/makefiles/mapfile-vers-debug	Mon Sep 08 12:15:04 2014 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2002, 2011, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2002, 2014, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -84,6 +84,7 @@
                 JVM_EnableCompiler;
                 JVM_Exit;
                 JVM_FillInStackTrace;
+                JVM_FindClassFromCaller;
                 JVM_FindClassFromClass;
                 JVM_FindClassFromClassLoader;
                 JVM_FindClassFromBootLoader;
--- ./hotspot/make/linux/makefiles/mapfile-vers-product	Wed Jun 25 09:01:56 2014 -0700
+++ ./hotspot/make/linux/makefiles/mapfile-vers-product	Mon Sep 08 12:15:04 2014 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2002, 2011, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2002, 2014, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -84,6 +84,7 @@
                 JVM_EnableCompiler;
                 JVM_Exit;
                 JVM_FillInStackTrace;
+                JVM_FindClassFromCaller;
                 JVM_FindClassFromClass;
                 JVM_FindClassFromClassLoader;
                 JVM_FindClassFromBootLoader;
--- ./hotspot/make/solaris/makefiles/mapfile-vers	Wed Jun 25 09:01:56 2014 -0700
+++ ./hotspot/make/solaris/makefiles/mapfile-vers	Mon Sep 08 12:15:04 2014 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -84,6 +84,7 @@
 		JVM_EnableCompiler;
 		JVM_Exit;
 		JVM_FillInStackTrace;
+		JVM_FindClassFromCaller;
 		JVM_FindClassFromClass;
 		JVM_FindClassFromClassLoader;
 		JVM_FindClassFromBootLoader;
--- ./hotspot/make/windows/makefiles/trace.make	Wed Jun 25 09:01:56 2014 -0700
+++ ./hotspot/make/windows/makefiles/trace.make	Mon Sep 08 12:15:04 2014 -0700
@@ -40,8 +40,7 @@
     traceEventIds.hpp     \
     traceTypes.hpp
 
-
-!if "$(OPENJDK)" != "true"
+!if EXISTS($(TraceAltSrcDir))
 TraceGeneratedNames = $(TraceGeneratedNames) \
     traceRequestables.hpp \
     traceEventControl.hpp \
@@ -56,7 +55,7 @@
 	$(TraceOutDir)/traceEventIds.hpp     \
 	$(TraceOutDir)/traceTypes.hpp
 
-!if "$(OPENJDK)" != "true"
+!if EXISTS($(TraceAltSrcDir))
 TraceGeneratedFiles = $(TraceGeneratedFiles) \
 	$(TraceOutDir)/traceRequestables.hpp \
     $(TraceOutDir)/traceEventControl.hpp \
@@ -68,7 +67,7 @@
 XML_DEPS = $(TraceSrcDir)/trace.xml $(TraceSrcDir)/tracetypes.xml \
     $(TraceSrcDir)/trace.dtd $(TraceSrcDir)/xinclude.mod
 
-!if "$(OPENJDK)" != "true"
+!if EXISTS($(TraceAltSrcDir))
 XML_DEPS = $(XML_DEPS) $(TraceAltSrcDir)/traceevents.xml
 !endif
 
@@ -87,7 +86,7 @@
 	@echo Generating $@
 	@$(XSLT) -IN $(TraceSrcDir)/trace.xml -XSL $(TraceSrcDir)/traceTypes.xsl -OUT $(TraceOutDir)/traceTypes.hpp
 
-!if "$(OPENJDK)" == "true"
+!if !EXISTS($(TraceAltSrcDir))
 
 $(TraceOutDir)/traceEventClasses.hpp: $(TraceSrcDir)/trace.xml $(TraceSrcDir)/traceEventClasses.xsl $(XML_DEPS)
 	@echo Generating $@
--- ./hotspot/src/share/vm/adlc/formssel.cpp	Wed Jun 25 09:01:56 2014 -0700
+++ ./hotspot/src/share/vm/adlc/formssel.cpp	Mon Sep 08 12:15:04 2014 -0700
@@ -536,12 +536,6 @@
   if( data_type != Form::none )
     rematerialize = true;
 
-  // Ugly: until a better fix is implemented, disable rematerialization for
-  // negD nodes because they are proved to be problematic.
-  if (is_ideal_negD()) {
-    return false;
-  }
-
   // Constants
   if( _components.count() == 1 && _components[0]->is(Component::USE_DEF) )
     rematerialize = true;
--- ./hotspot/src/share/vm/classfile/classFileParser.cpp	Wed Jun 25 09:01:56 2014 -0700
+++ ./hotspot/src/share/vm/classfile/classFileParser.cpp	Mon Sep 08 12:15:04 2014 -0700
@@ -2721,6 +2721,11 @@
       "bootstrap_method_index %u has bad constant type in class file %s",
       bootstrap_method_index,
       CHECK);
+
+    guarantee_property((operand_fill_index + 1 + argument_count) < operands->length(),
+      "Invalid BootstrapMethods num_bootstrap_methods or num_bootstrap_arguments value in class file %s",
+      CHECK);
+
     operands->short_at_put(operand_fill_index++, bootstrap_method_index);
     operands->short_at_put(operand_fill_index++, argument_count);
 
@@ -2738,7 +2743,6 @@
   }
 
   assert(operand_fill_index == operands()->length(), "exact fill");
-  assert(constantPoolOopDesc::operand_array_length(operands()) == attribute_array_length, "correct decode");
 
   u1* current_end = cfs->current();
   guarantee_property(current_end == current_start + attribute_byte_length,
--- ./hotspot/src/share/vm/classfile/verifier.cpp	Wed Jun 25 09:01:56 2014 -0700
+++ ./hotspot/src/share/vm/classfile/verifier.cpp	Mon Sep 08 12:15:04 2014 -0700
@@ -2224,6 +2224,181 @@
   }
 }
 
+// Look at the method's handlers.  If the bci is in the handler's try block
+// then check if the handler_pc is already on the stack.  If not, push it.
+void ClassVerifier::push_handlers(ExceptionTable* exhandlers,
+                                  GrowableArray<u4>* handler_stack,
+                                  u4 bci) {
+  int exlength = exhandlers->length();
+  for(int x = 0; x < exlength; x++) {
+    if (bci >= exhandlers->start_pc(x) && bci < exhandlers->end_pc(x)) {
+      handler_stack->append_if_missing(exhandlers->handler_pc(x));
+    }
+  }
+}
+
+// Return TRUE if all code paths starting with start_bc_offset end in
+// bytecode athrow or loop.
+bool ClassVerifier::ends_in_athrow(u4 start_bc_offset) {
+  ResourceMark rm;
+  // Create bytecode stream.
+  RawBytecodeStream bcs(method());
+  u4 code_length = method()->code_size();
+  bcs.set_start(start_bc_offset);
+  u4 target;
+  // Create stack for storing bytecode start offsets for if* and *switch.
+  GrowableArray<u4>* bci_stack = new GrowableArray<u4>(30);
+  // Create stack for handlers for try blocks containing this handler.
+  GrowableArray<u4>* handler_stack = new GrowableArray<u4>(30);
+  // Create list of visited branch opcodes (goto* and if*).
+  GrowableArray<u4>* visited_branches = new GrowableArray<u4>(30);
+  ExceptionTable exhandlers(_method());
+
+  while (true) {
+    if (bcs.is_last_bytecode()) {
+      // if no more starting offsets to parse or if at the end of the
+      // method then return false.
+      if ((bci_stack->is_empty()) || ((u4)bcs.end_bci() == code_length))
+        return false;
+      // Pop a bytecode starting offset and scan from there.
+      bcs.set_start(bci_stack->pop());
+    }
+    Bytecodes::Code opcode = bcs.raw_next();
+    u4 bci = bcs.bci();
+
+    // If the bytecode is in a TRY block, push its handlers so they
+    // will get parsed.
+    push_handlers(&exhandlers, handler_stack, bci);
+
+    switch (opcode) {
+      case Bytecodes::_if_icmpeq:
+      case Bytecodes::_if_icmpne:
+      case Bytecodes::_if_icmplt:
+      case Bytecodes::_if_icmpge:
+      case Bytecodes::_if_icmpgt:
+      case Bytecodes::_if_icmple:
+      case Bytecodes::_ifeq:
+      case Bytecodes::_ifne:
+      case Bytecodes::_iflt:
+      case Bytecodes::_ifge:
+      case Bytecodes::_ifgt:
+      case Bytecodes::_ifle:
+      case Bytecodes::_if_acmpeq:
+      case Bytecodes::_if_acmpne:
+      case Bytecodes::_ifnull:
+      case Bytecodes::_ifnonnull:
+        target = bcs.dest();
+        if (visited_branches->contains(bci)) {
+          if (bci_stack->is_empty()) return true;
+          // Pop a bytecode starting offset and scan from there.
+          bcs.set_start(bci_stack->pop());
+        } else {
+          if (target > bci) { // forward branch
+            if (target >= code_length) return false;
+            // Push the branch target onto the stack.
+            bci_stack->push(target);
+            // then, scan bytecodes starting with next.
+            bcs.set_start(bcs.next_bci());
+          } else { // backward branch
+            // Push bytecode offset following backward branch onto the stack.
+            bci_stack->push(bcs.next_bci());
+            // Check bytecodes starting with branch target.
+            bcs.set_start(target);
+          }
+          // Record target so we don't branch here again.
+          visited_branches->append(bci);
+        }
+        break;
+
+      case Bytecodes::_goto:
+      case Bytecodes::_goto_w:
+        target = (opcode == Bytecodes::_goto ? bcs.dest() : bcs.dest_w());
+        if (visited_branches->contains(bci)) {
+          if (bci_stack->is_empty()) return true;
+          // Been here before, pop new starting offset from stack.
+          bcs.set_start(bci_stack->pop());
+        } else {
+          if (target >= code_length) return false;
+          // Continue scanning from the target onward.
+          bcs.set_start(target);
+          // Record target so we don't branch here again.
+          visited_branches->append(bci);
+        }
+        break;
+
+      // Check that all switch alternatives end in 'athrow' bytecodes. Since it
+      // is  difficult to determine where each switch alternative ends, parse
+      // each switch alternative until either hit a 'return', 'athrow', or reach
+      // the end of the method's bytecodes.  This is gross but should be okay
+      // because:
+      // 1. tableswitch and lookupswitch byte codes in handlers for ctor explicit
+      //    constructor invocations should be rare.
+      // 2. if each switch alternative ends in an athrow then the parsing should be
+      //    short.  If there is no athrow then it is bogus code, anyway.
+      case Bytecodes::_lookupswitch:
+      case Bytecodes::_tableswitch:
+        {
+          address aligned_bcp = (address) round_to((intptr_t)(bcs.bcp() + 1), jintSize);
+          u4 default_offset = Bytes::get_Java_u4(aligned_bcp) + bci;
+          int keys, delta;
+          if (opcode == Bytecodes::_tableswitch) {
+            jint low = (jint)Bytes::get_Java_u4(aligned_bcp + jintSize);
+            jint high = (jint)Bytes::get_Java_u4(aligned_bcp + 2*jintSize);
+            // This is invalid, but let the regular bytecode verifier
+            // report this because the user will get a better error message.
+            if (low > high) return true;
+            keys = high - low + 1;
+            delta = 1;
+          } else {
+            keys = (int)Bytes::get_Java_u4(aligned_bcp + jintSize);
+            delta = 2;
+          }
+          // Invalid, let the regular bytecode verifier deal with it.
+          if (keys < 0) return true;
+
+          // Push the offset of the next bytecode onto the stack.
+          bci_stack->push(bcs.next_bci());
+
+          // Push the switch alternatives onto the stack.
+          for (int i = 0; i < keys; i++) {
+            u4 target = bci + (jint)Bytes::get_Java_u4(aligned_bcp+(3+i*delta)*jintSize);
+            if (target > code_length) return false;
+            bci_stack->push(target);
+          }
+
+          // Start bytecode parsing for the switch at the default alternative.
+          if (default_offset > code_length) return false;
+          bcs.set_start(default_offset);
+          break;
+        }
+
+      case Bytecodes::_return:
+        return false;
+
+      case Bytecodes::_athrow:
+        {
+          if (bci_stack->is_empty()) {
+            if (handler_stack->is_empty()) {
+              return true;
+            } else {
+              // Parse the catch handlers for try blocks containing athrow.
+              bcs.set_start(handler_stack->pop());
+            }
+          } else {
+            // Pop a bytecode offset and starting scanning from there.
+            bcs.set_start(bci_stack->pop());
+          }
+        }
+        break;
+
+      default:
+        ;
+    } // end switch
+  } // end while loop
+
+  return false;
+}
+
 void ClassVerifier::verify_invoke_init(
     RawBytecodeStream* bcs, u2 ref_class_index, VerificationType ref_class_type,
     StackMapFrame* current_frame, u4 code_length, bool *this_uninit,
@@ -2250,18 +2425,26 @@
       return;
     }
 
-    // Make sure that this call is not done from within a TRY block because
-    // that can result in returning an incomplete object.  Simply checking
-    // (bci >= start_pc) also ensures that this call is not done after a TRY
-    // block.  That is also illegal because this call must be the first Java
-    // statement in the constructor.
+    // Check if this call is done from inside of a TRY block.  If so, make
+    // sure that all catch clause paths end in a throw.  Otherwise, this
+    // can result in returning an incomplete object.
     ExceptionTable exhandlers(_method());
     int exlength = exhandlers.length();
     for(int i = 0; i < exlength; i++) {
-      if (bci >= exhandlers.start_pc(i)) {
-        verify_error(ErrorContext::bad_code(bci),
-                     "Bad <init> method call from after the start of a try block");
-        return;
+      u2 start_pc = exhandlers.start_pc(i);
+      u2 end_pc = exhandlers.end_pc(i);
+
+      if (bci >= start_pc && bci < end_pc) {
+        if (!ends_in_athrow(exhandlers.handler_pc(i))) {
+          verify_error(ErrorContext::bad_code(bci),
+            "Bad <init> method call from after the start of a try block");
+          return;
+        } else if (VerboseVerification) {
+          ResourceMark rm;
+          tty->print_cr(
+            "Survived call to ends_in_athrow(): %s",
+                        current_class()->name()->as_C_string());
+        }
       }
     }
 
--- ./hotspot/src/share/vm/classfile/verifier.hpp	Wed Jun 25 09:01:56 2014 -0700
+++ ./hotspot/src/share/vm/classfile/verifier.hpp	Mon Sep 08 12:15:04 2014 -0700
@@ -30,6 +30,7 @@
 #include "oops/klass.hpp"
 #include "oops/methodOop.hpp"
 #include "runtime/handles.hpp"
+#include "utilities/growableArray.hpp"
 #include "utilities/exceptions.hpp"
 
 // The verifier class
@@ -304,6 +305,16 @@
     StackMapFrame* current_frame, u4 code_length, bool* this_uninit,
     constantPoolHandle cp, TRAPS);
 
+  // Used by ends_in_athrow() to push all handlers that contain bci onto
+  // the handler_stack, if the handler is not already on the stack.
+  void push_handlers(ExceptionTable* exhandlers,
+                     GrowableArray<u4>* handler_stack,
+                     u4 bci);
+
+  // Returns true if all paths starting with start_bc_offset end in athrow
+  // bytecode or loop.
+  bool ends_in_athrow(u4 start_bc_offset);
+
   void verify_invoke_instructions(
     RawBytecodeStream* bcs, u4 code_length, StackMapFrame* current_frame,
     bool* this_uninit, VerificationType return_type,
--- ./hotspot/src/share/vm/interpreter/linkResolver.cpp	Wed Jun 25 09:01:56 2014 -0700
+++ ./hotspot/src/share/vm/interpreter/linkResolver.cpp	Mon Sep 08 12:15:04 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -187,6 +187,14 @@
 
 void LinkResolver::lookup_method_in_klasses(methodHandle& result, KlassHandle klass, Symbol* name, Symbol* signature, TRAPS) {
   methodOop result_oop = klass->uncached_lookup_method(name, signature);
+
+  //JDK 7 does not support default methods, but this code ported from JDK8 to keep code consistent for all JDK.
+  if (klass->oop_is_array()) {
+    // Only consider klass and super klass for arrays
+    result = methodHandle(THREAD, result_oop);
+    return;
+  }
+
   if (EnableInvokeDynamic && result_oop != NULL) {
     vmIntrinsics::ID iid = result_oop->intrinsic_id();
     if (MethodHandles::is_signature_polymorphic(iid)) {
@@ -421,7 +429,7 @@
   // 2. lookup method in resolved klass and its super klasses
   lookup_method_in_klasses(resolved_method, resolved_klass, method_name, method_signature, CHECK);
 
-  if (resolved_method.is_null()) { // not found in the class hierarchy
+  if (resolved_method.is_null() && !resolved_klass->oop_is_array()) { // not found in the class hierarchy
     // 3. lookup method in all the interfaces implemented by the resolved klass
     lookup_method_in_interfaces(resolved_method, resolved_klass, method_name, method_signature, CHECK);
 
@@ -434,16 +442,16 @@
         CLEAR_PENDING_EXCEPTION;
       }
     }
+  }
 
-    if (resolved_method.is_null()) {
-      // 4. method lookup failed
-      ResourceMark rm(THREAD);
-      THROW_MSG_CAUSE(vmSymbols::java_lang_NoSuchMethodError(),
-                      methodOopDesc::name_and_sig_as_C_string(Klass::cast(resolved_klass()),
-                                                              method_name,
-                                                              method_signature),
-                      nested_exception);
-    }
+  if (resolved_method.is_null()) {
+    // 4. method lookup failed
+    ResourceMark rm(THREAD);
+    THROW_MSG_CAUSE(vmSymbols::java_lang_NoSuchMethodError(),
+                    methodOopDesc::name_and_sig_as_C_string(Klass::cast(resolved_klass()),
+                                                            method_name,
+                                                            method_signature),
+                    nested_exception);
   }
 
   // 5. check if method is concrete
@@ -514,17 +522,18 @@
   // lookup method in this interface or its super, java.lang.Object
   lookup_instance_method_in_klasses(resolved_method, resolved_klass, method_name, method_signature, CHECK);
 
-  if (resolved_method.is_null()) {
+  if (resolved_method.is_null() && !resolved_klass->oop_is_array()) {
     // lookup method in all the super-interfaces
     lookup_method_in_interfaces(resolved_method, resolved_klass, method_name, method_signature, CHECK);
-    if (resolved_method.is_null()) {
-      // no method found
-      ResourceMark rm(THREAD);
-      THROW_MSG(vmSymbols::java_lang_NoSuchMethodError(),
-                methodOopDesc::name_and_sig_as_C_string(Klass::cast(resolved_klass()),
-                                                        method_name,
-                                                        method_signature));
-    }
+  }
+
+  if (resolved_method.is_null()) {
+    // no method found
+    ResourceMark rm(THREAD);
+    THROW_MSG(vmSymbols::java_lang_NoSuchMethodError(),
+              methodOopDesc::name_and_sig_as_C_string(Klass::cast(resolved_klass()),
+                                                      method_name,
+                                                      method_signature));
   }
 
   if (check_access) {
@@ -614,7 +623,7 @@
 
   // Resolve instance field
   fieldDescriptor fd; // find_field initializes fd if found
-  KlassHandle sel_klass(THREAD, instanceKlass::cast(resolved_klass())->find_field(field, sig, &fd));
+  KlassHandle sel_klass(THREAD, resolved_klass->find_field(field, sig, &fd));
   // check if field exists; i.e., if a klass containing the field def has been selected
   if (sel_klass.is_null()){
     ResourceMark rm(THREAD);
--- ./hotspot/src/share/vm/oops/arrayKlass.cpp	Wed Jun 25 09:01:56 2014 -0700
+++ ./hotspot/src/share/vm/oops/arrayKlass.cpp	Mon Sep 08 12:15:04 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -64,6 +64,13 @@
   return NULL;
 }
 
+// find field according to JVM spec 5.4.3.2, returns the klass in which the field is defined
+klassOop arrayKlass::find_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const {
+  // There are no fields in an array klass but look to the super class (Object)
+  assert(super(), "super klass must be present");
+  return Klass::cast(super())->find_field(name, sig, fd);
+}
+
 methodOop arrayKlass::uncached_lookup_method(Symbol* name, Symbol* signature) const {
   // There are no methods in an array klass but the super class (Object) has some
   assert(super(), "super klass must be present");
--- ./hotspot/src/share/vm/oops/arrayKlass.hpp	Wed Jun 25 09:01:56 2014 -0700
+++ ./hotspot/src/share/vm/oops/arrayKlass.hpp	Mon Sep 08 12:15:04 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -30,6 +30,8 @@
 #include "oops/klassOop.hpp"
 #include "oops/klassVtable.hpp"
 
+class fieldDescriptor;
+
 // arrayKlass is the abstract baseclass for all array classes
 
 class arrayKlass: public Klass {
@@ -83,6 +85,9 @@
   virtual oop multi_allocate(int rank, jint* sizes, TRAPS);
   objArrayOop allocate_arrayArray(int n, int length, TRAPS);
 
+  // find field according to JVM spec 5.4.3.2, returns the klass in which the field is defined
+  klassOop find_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const;
+
   // Lookup operations
   methodOop uncached_lookup_method(Symbol* name, Symbol* signature) const;
 
--- ./hotspot/src/share/vm/oops/klass.cpp	Wed Jun 25 09:01:56 2014 -0700
+++ ./hotspot/src/share/vm/oops/klass.cpp	Mon Sep 08 12:15:04 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -119,6 +119,15 @@
   return is_subclass_of(k);
 }
 
+klassOop Klass::find_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const {
+#ifdef ASSERT
+  tty->print_cr("Error: find_field called on a klass oop."
+                " Likely error: reflection method does not correctly"
+                " wrap return value in a mirror object.");
+#endif
+  ShouldNotReachHere();
+  return NULL;
+}
 
 methodOop Klass::uncached_lookup_method(Symbol* name, Symbol* signature) const {
 #ifdef ASSERT
--- ./hotspot/src/share/vm/oops/klass.hpp	Wed Jun 25 09:01:56 2014 -0700
+++ ./hotspot/src/share/vm/oops/klass.hpp	Mon Sep 08 12:15:04 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -88,6 +88,7 @@
 class klassVtable;
 class KlassHandle;
 class OrderAccess;
+class fieldDescriptor;
 
 // Holder (or cage) for the C++ vtable of each kind of Klass.
 // We want to tightly constrain the location of the C++ vtable in the overall layout.
@@ -514,6 +515,7 @@
   virtual void initialize(TRAPS);
   // lookup operation for MethodLookupCache
   friend class MethodLookupCache;
+  virtual klassOop find_field(Symbol* name, Symbol* signature, fieldDescriptor* fd) const;
   virtual methodOop uncached_lookup_method(Symbol* name, Symbol* signature) const;
  public:
   methodOop lookup_method(Symbol* name, Symbol* signature) const {
--- ./hotspot/src/share/vm/opto/reg_split.cpp	Wed Jun 25 09:01:56 2014 -0700
+++ ./hotspot/src/share/vm/opto/reg_split.cpp	Mon Sep 08 12:15:04 2014 -0700
@@ -51,15 +51,6 @@
 
 static const char out_of_nodes[] = "out of nodes during split";
 
-static bool contains_no_live_range_input(const Node* def) {
-  for (uint i = 1; i < def->req(); ++i) {
-    if (def->in(i) != NULL && def->in_RegMask(i).is_NotEmpty()) {
-      return false;
-    }
-  }
-  return true;
-}
-
 //------------------------------get_spillcopy_wide-----------------------------
 // Get a SpillCopy node with wide-enough masks.  Use the 'wide-mask', the
 // wide ideal-register spill-mask if possible.  If the 'wide-mask' does
@@ -326,10 +317,13 @@
   if( def->req() > 1 ) {
     for( uint i = 1; i < def->req(); i++ ) {
       Node *in = def->in(i);
-      // Check for single-def (LRG cannot redefined)
       uint lidx = n2lidx(in);
-      if( lidx >= _maxlrg ) continue; // Value is a recent spill-copy
-      if (lrgs(lidx).is_singledef()) continue;
+      // We do not need this for live ranges that are only defined once.
+      // However, this is not true for spill copies that are added in this
+      // Split() pass, since they might get coalesced later on in this pass.
+      if (lidx < _maxlrg && lrgs(lidx).is_singledef()) {
+         continue;
+       }
 
       Block *b_def = _cfg._bbs[def->_idx];
       int idx_def = b_def->find_node(def);
@@ -1303,7 +1297,7 @@
       Node *def = Reaches[pidx][slidx];
       assert( def, "must have reaching def" );
       // If input up/down sense and reg-pressure DISagree
-      if (def->rematerialize() && contains_no_live_range_input(def)) {
+      if (def->rematerialize()) {
         // Place the rematerialized node above any MSCs created during
         // phi node splitting.  end_idx points at the insertion point
         // so look at the node before it.
--- ./hotspot/src/share/vm/prims/jvm.cpp	Wed Jun 25 09:01:56 2014 -0700
+++ ./hotspot/src/share/vm/prims/jvm.cpp	Mon Sep 08 12:15:04 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -746,6 +746,7 @@
   return (jclass) JNIHandles::make_local(env, Klass::cast(k)->java_mirror());
 JVM_END
 
+// Not used; JVM_FindClassFromCaller replaces this.
 JVM_ENTRY(jclass, JVM_FindClassFromClassLoader(JNIEnv* env, const char* name,
                                                jboolean init, jobject loader,
                                                jboolean throwError))
@@ -772,6 +773,42 @@
   return result;
 JVM_END
 
+// Find a class with this name in this loader, using the caller's protection domain.
+JVM_ENTRY(jclass, JVM_FindClassFromCaller(JNIEnv* env, const char* name,
+                                          jboolean init, jobject loader,
+                                          jclass caller))
+  JVMWrapper2("JVM_FindClassFromCaller %s throws ClassNotFoundException", name);
+  // Java libraries should ensure that name is never null...
+  if (name == NULL || (int)strlen(name) > Symbol::max_length()) {
+    // It's impossible to create this class;  the name cannot fit
+    // into the constant pool.
+    THROW_MSG_0(vmSymbols::java_lang_ClassNotFoundException(), name);
+  }
+
+  TempNewSymbol h_name = SymbolTable::new_symbol(name, CHECK_NULL);
+
+  oop loader_oop = JNIHandles::resolve(loader);
+  oop from_class = JNIHandles::resolve(caller);
+  oop protection_domain = NULL;
+  // If loader is null, shouldn't call ClassLoader.checkPackageAccess; otherwise get
+  // NPE. Put it in another way, the bootstrap class loader has all permission and
+  // thus no checkPackageAccess equivalence in the VM class loader.
+  // The caller is also passed as NULL by the java code if there is no security
+  // manager to avoid the performance cost of getting the calling class.
+  if (from_class != NULL && loader_oop != NULL) {
+    protection_domain = instanceKlass::cast(java_lang_Class::as_klassOop(from_class))->protection_domain();
+  }
+
+  Handle h_loader(THREAD, loader_oop);
+  Handle h_prot(THREAD, protection_domain);
+  jclass result = find_class_from_class_loader(env, h_name, init, h_loader,
+                                               h_prot, false, THREAD);
+
+  if (TraceClassResolution && result != NULL) {
+    trace_class_resolution(java_lang_Class::as_klassOop(JNIHandles::resolve_non_null(result)));
+  }
+  return result;
+JVM_END
 
 JVM_ENTRY(jclass, JVM_FindClassFromClass(JNIEnv *env, const char *name,
                                          jboolean init, jclass from))
@@ -4098,10 +4135,15 @@
 
 // Shared JNI/JVM entry points //////////////////////////////////////////////////////////////
 
-jclass find_class_from_class_loader(JNIEnv* env, Symbol* name, jboolean init, Handle loader, Handle protection_domain, jboolean throwError, TRAPS) {
+jclass find_class_from_class_loader(JNIEnv* env, Symbol* name, jboolean init,
+                                    Handle loader, Handle protection_domain,
+                                    jboolean throwError, TRAPS) {
   // Security Note:
   //   The Java level wrapper will perform the necessary security check allowing
-  //   us to pass the NULL as the initiating class loader.
+  //   us to pass the NULL as the initiating class loader.  The VM is responsible for
+  //   the checkPackageAccess relative to the initiating class loader via the
+  //   protection_domain. The protection_domain is passed as NULL by the java code
+  //   if there is no security manager in 3-arg Class.forName().
   klassOop klass = SystemDictionary::resolve_or_fail(name, loader, protection_domain, throwError != 0, CHECK_NULL);
 
   KlassHandle klass_handle(THREAD, klass);
--- ./hotspot/src/share/vm/prims/jvm.h	Wed Jun 25 09:01:56 2014 -0700
+++ ./hotspot/src/share/vm/prims/jvm.h	Mon Sep 08 12:15:04 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -415,6 +415,19 @@
 JVM_FindClassFromBootLoader(JNIEnv *env, const char *name);
 
 /*
+ * Find a class from a given class loader.  Throws ClassNotFoundException.
+ *  name:   name of class
+ *  init:   whether initialization is done
+ *  loader: class loader to look up the class. This may not be the same as the caller's
+ *          class loader.
+ *  caller: initiating class. The initiating class may be null when a security
+ *          manager is not installed.
+ */
+JNIEXPORT jclass JNICALL
+JVM_FindClassFromCaller(JNIEnv *env, const char *name, jboolean init,
+                        jobject loader, jclass caller);
+
+/*
  * Find a class from a given class.
  */
 JNIEXPORT jclass JNICALL
--- ./hotspot/src/share/vm/runtime/arguments.cpp	Wed Jun 25 09:01:56 2014 -0700
+++ ./hotspot/src/share/vm/runtime/arguments.cpp	Mon Sep 08 12:15:04 2014 -0700
@@ -2057,6 +2057,10 @@
     PrintNMTStatistics = false;
   }
 
+#ifdef COMPILER1
+  status &= verify_interval(SafepointPollOffset, 0, os::vm_page_size() - BytesPerWord, "SafepointPollOffset");
+#endif
+
   return status;
 }
 
--- ./hotspot/src/share/vm/runtime/globals.hpp	Wed Jun 25 09:01:56 2014 -0700
+++ ./hotspot/src/share/vm/runtime/globals.hpp	Mon Sep 08 12:15:04 2014 -0700
@@ -1094,9 +1094,11 @@
           "Prevent spurious or premature wakeups from object.wait "         \
           "(Solaris only)")                                                 \
                                                                             \
-  product(intx, NativeMonitorTimeout, -1, "(Unstable)" )                    \
-  product(intx, NativeMonitorFlags, 0, "(Unstable)" )                       \
-  product(intx, NativeMonitorSpinLimit, 20, "(Unstable)" )                  \
+  experimental(intx, NativeMonitorTimeout, -1, "(Unstable)")                \
+                                                                            \
+  experimental(intx, NativeMonitorFlags, 0, "(Unstable)")                   \
+                                                                            \
+  experimental(intx, NativeMonitorSpinLimit, 20, "(Unstable)")              \
                                                                             \
   develop(bool, UsePthreads, false,                                         \
           "Use pthread-based instead of libthread-based synchronization "   \
--- ./hotspot/test/compiler/7141637/SpreadNullArg.java	Wed Jun 25 09:01:56 2014 -0700
+++ ./hotspot/test/compiler/7141637/SpreadNullArg.java	Mon Sep 08 12:15:04 2014 -0700
@@ -46,13 +46,17 @@
       mh_spread_target =
         MethodHandles.lookup().findStatic(SpreadNullArg.class, "target_spread_arg", mt_ref_arg);
       result = (int) mh_spreadInvoker.invokeExact(mh_spread_target, (Object[]) null);
-    } catch(NullPointerException e) {
-      // Expected exception - do nothing!
-    } catch(Throwable e) {
+      throw new Error("Expected IllegalArgumentException was not thrown");
+    } catch (IllegalArgumentException e) {
+      System.out.println("Expected exception : " + e);
+    } catch (Throwable e) {
       throw new Error(e);
     }
 
-    if (result != 42) throw new Error("Expected NullPointerException was not thrown");
+    if (result != 42) {
+      throw new Error("result [" + result
+        + "] != 42 : Expected IllegalArgumentException was not thrown?");
+    }
   }
 
   public static int target_spread_arg(Integer i1) {
--- ./hotspot/test/testlibrary/ClassFileInstaller.java	Wed Jun 25 09:01:56 2014 -0700
+++ ./hotspot/test/testlibrary/ClassFileInstaller.java	Mon Sep 08 12:15:04 2014 -0700
@@ -45,7 +45,9 @@
 
             // Create the class file's package directory
             Path p = Paths.get(pathName);
-            Files.createDirectories(p.getParent());
+            if (pathName.contains("/")) {
+                Files.createDirectories(p.getParent());
+            }
             // Create the class file
             Files.copy(is, p, StandardCopyOption.REPLACE_EXISTING);
         }
--- ./hotspot/test/testlibrary/OutputAnalyzerTest.java	Wed Jun 25 09:01:56 2014 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,193 +0,0 @@
-/*
- * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/*
- * @test
- * @summary Test the OutputAnalyzer utility class
- * @library /testlibrary
- */
-
-import com.oracle.java.testlibrary.OutputAnalyzer;
-
-public class OutputAnalyzerTest {
-
-  public static void main(String args[]) throws Exception {
-
-    String stdout = "aaaaaa";
-    String stderr = "bbbbbb";
-
-    // Regexps used for testing pattern matching of the test input
-    String stdoutPattern = "[a]";
-    String stderrPattern = "[b]";
-    String nonExistingPattern = "[c]";
-
-    OutputAnalyzer output = new OutputAnalyzer(stdout, stderr);
-
-    if (!stdout.equals(output.getStdout())) {
-      throw new Exception("getStdout() returned '" + output.getStdout() + "', expected '" + stdout + "'");
-    }
-
-    if (!stderr.equals(output.getStderr())) {
-      throw new Exception("getStderr() returned '" + output.getStderr() + "', expected '" + stderr + "'");
-    }
-
-    try {
-      output.shouldContain(stdout);
-      output.stdoutShouldContain(stdout);
-      output.shouldContain(stderr);
-      output.stderrShouldContain(stderr);
-    } catch (RuntimeException e) {
-      throw new Exception("shouldContain() failed", e);
-    }
-
-    try {
-      output.shouldContain("cccc");
-      throw new Exception("shouldContain() failed to throw exception");
-    } catch (RuntimeException e) {
-      // expected
-    }
-
-    try {
-      output.stdoutShouldContain(stderr);
-      throw new Exception("stdoutShouldContain() failed to throw exception");
-    } catch (RuntimeException e) {
-      // expected
-    }
-
-    try {
-      output.stderrShouldContain(stdout);
-      throw new Exception("stdoutShouldContain() failed to throw exception");
-    } catch (RuntimeException e) {
-      // expected
-    }
-
-    try {
-      output.shouldNotContain("cccc");
-      output.stdoutShouldNotContain("cccc");
-      output.stderrShouldNotContain("cccc");
-    } catch (RuntimeException e) {
-      throw new Exception("shouldNotContain() failed", e);
-    }
-
-    try {
-      output.shouldNotContain(stdout);
-      throw new Exception("shouldContain() failed to throw exception");
-    } catch (RuntimeException e) {
-      // expected
-    }
-
-    try {
-      output.stdoutShouldNotContain(stdout);
-      throw new Exception("shouldContain() failed to throw exception");
-    } catch (RuntimeException e) {
-      // expected
-    }
-
-    try {
-        output.stderrShouldNotContain(stderr);
-        throw new Exception("shouldContain() failed to throw exception");
-    } catch (RuntimeException e) {
-        // expected
-    }
-
-    // Should match
-    try {
-        output.shouldMatch(stdoutPattern);
-        output.stdoutShouldMatch(stdoutPattern);
-        output.shouldMatch(stderrPattern);
-        output.stderrShouldMatch(stderrPattern);
-    } catch (RuntimeException e) {
-        throw new Exception("shouldMatch() failed", e);
-    }
-
-    try {
-        output.shouldMatch(nonExistingPattern);
-        throw new Exception("shouldMatch() failed to throw exception");
-    } catch (RuntimeException e) {
-        // expected
-    }
-
-    try {
-        output.stdoutShouldMatch(stderrPattern);
-        throw new Exception(
-                "stdoutShouldMatch() failed to throw exception");
-    } catch (RuntimeException e) {
-        // expected
-    }
-
-    try {
-        output.stderrShouldMatch(stdoutPattern);
-        throw new Exception(
-                "stderrShouldMatch() failed to throw exception");
-    } catch (RuntimeException e) {
-        // expected
-    }
-
-    // Should not match
-    try {
-        output.shouldNotMatch(nonExistingPattern);
-        output.stdoutShouldNotMatch(nonExistingPattern);
-        output.stderrShouldNotMatch(nonExistingPattern);
-    } catch (RuntimeException e) {
-        throw new Exception("shouldNotMatch() failed", e);
-    }
-
-    try {
-        output.shouldNotMatch(stdoutPattern);
-        throw new Exception("shouldNotMatch() failed to throw exception");
-    } catch (RuntimeException e) {
-        // expected
-    }
-
-    try {
-        output.stdoutShouldNotMatch(stdoutPattern);
-        throw new Exception("shouldNotMatch() failed to throw exception");
-    } catch (RuntimeException e) {
-        // expected
-    }
-
-    try {
-        output.stderrShouldNotMatch(stderrPattern);
-        throw new Exception("shouldNotMatch() failed to throw exception");
-    } catch (RuntimeException e) {
-        // expected
-    }
-
-    {
-      String aaaa = "aaaa";
-      String result = output.firstMatch(aaaa);
-      if (!aaaa.equals(result)) {
-        throw new Exception("firstMatch(String) faild to match. Expected: " + aaaa + " got: " + result);
-      }
-    }
-
-    {
-      String aa = "aa";
-      String aa_grouped_aa = aa + "(" + aa + ")";
-      String result = output.firstMatch(aa_grouped_aa, 1);
-      if (!aa.equals(result)) {
-        throw new Exception("firstMatch(String, int) failed to match. Expected: " + aa + " got: " + result);
-      }
-    }
-  }
-}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/test/testlibrary/com/oracle/java/testlibrary/Asserts.java	Mon Sep 08 12:15:04 2014 -0700
@@ -0,0 +1,395 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.oracle.java.testlibrary;
+
+/**
+ * Asserts that can be used for verifying assumptions in tests.
+ *
+ * An assertion will throw a {@link RuntimeException} if the assertion isn't
+ * valid.  All the asserts can be imported into a test by using a static
+ * import:
+ *
+ * <pre>
+ * {@code
+ * import static com.oracle.java.testlibrary.Asserts.*;
+ * }
+ *
+ * Always provide a message describing the assumption if the line number of the
+ * failing assertion isn't enough to understand why the assumption failed. For
+ * example, if the assertion is in a loop or in a method that is called
+ * multiple times, then the line number won't provide enough context to
+ * understand the failure.
+ * </pre>
+ */
+public class Asserts {
+
+    /**
+     * Shorthand for {@link #assertLessThan(T, T)}.
+     *
+     * @see #assertLessThan(T, T)
+     */
+    public static <T extends Comparable<T>> void assertLT(T lhs, T rhs) {
+        assertLessThan(lhs, rhs);
+    }
+
+    /**
+     * Shorthand for {@link #assertLessThan(T, T, String)}.
+     *
+     * @see #assertLessThan(T, T, String)
+     */
+    public static <T extends Comparable<T>> void assertLT(T lhs, T rhs, String msg) {
+        assertLessThan(lhs, rhs, msg);
+    }
+
+    /**
+     * Calls {@link #assertLessThan(T, T, String)} with a default message.
+     *
+     * @see #assertLessThan(T, T, String)
+     */
+    public static <T extends Comparable<T>> void assertLessThan(T lhs, T rhs) {
+        String msg = "Expected that " + format(lhs) + " < " + format(rhs);
+        assertLessThan(lhs, rhs, msg);
+    }
+
+    /**
+     * Asserts that {@code lhs} is less than {@code rhs}.
+     *
+     * @param lhs The left hand side of the comparison.
+     * @param rhs The right hand side of the comparison.
+     * @param msg A description of the assumption.
+     * @throws RuntimeException if the assertion isn't valid.
+     */
+    public static <T extends Comparable<T>>void assertLessThan(T lhs, T rhs, String msg) {
+        assertTrue(compare(lhs, rhs, msg) < 0, msg);
+    }
+
+    /**
+     * Shorthand for {@link #assertLessThanOrEqual(T, T)}.
+     *
+     * @see #assertLessThanOrEqual(T, T)
+     */
+    public static <T extends Comparable<T>> void assertLTE(T lhs, T rhs) {
+        assertLessThanOrEqual(lhs, rhs);
+    }
+
+    /**
+     * Shorthand for {@link #assertLessThanOrEqual(T, T, String)}.
+     *
+     * @see #assertLessThanOrEqual(T, T, String)
+     */
+    public static <T extends Comparable<T>> void assertLTE(T lhs, T rhs, String msg) {
+        assertLessThanOrEqual(lhs, rhs, msg);
+    }
+
+    /**
+     * Calls {@link #assertLessThanOrEqual(T, T, String)} with a default message.
+     *
+     * @see #assertLessThanOrEqual(T, T, String)
+     */
+    public static <T extends Comparable<T>> void assertLessThanOrEqual(T lhs, T rhs) {
+        String msg = "Expected that " + format(lhs) + " <= " + format(rhs);
+        assertLessThanOrEqual(lhs, rhs, msg);
+    }
+
+    /**
+     * Asserts that {@code lhs} is less than or equal to {@code rhs}.
+     *
+     * @param lhs The left hand side of the comparison.
+     * @param rhs The right hand side of the comparison.
+     * @param msg A description of the assumption.
+     * @throws RuntimeException if the assertion isn't valid.
+     */
+    public static <T extends Comparable<T>> void assertLessThanOrEqual(T lhs, T rhs, String msg) {
+        assertTrue(compare(lhs, rhs, msg) <= 0, msg);
+    }
+
+    /**
+     * Shorthand for {@link #assertEquals(T, T)}.
+     *
+     * @see #assertEquals(T, T)
+     */
+    public static void assertEQ(Object lhs, Object rhs) {
+        assertEquals(lhs, rhs);
+    }
+
+    /**
+     * Shorthand for {@link #assertEquals(T, T, String)}.
+     *
+     * @see #assertEquals(T, T, String)
+     */
+    public static void assertEQ(Object lhs, Object rhs, String msg) {
+        assertEquals(lhs, rhs, msg);
+    }
+
+    /**
+     * Calls {@link #assertEquals(T, T, String)} with a default message.
+     *
+     * @see #assertEquals(T, T, String)
+     */
+    public static void assertEquals(Object lhs, Object rhs) {
+        String msg = "Expected " + format(lhs) + " to equal " + format(rhs);
+        assertEquals(lhs, rhs, msg);
+    }
+
+    /**
+     * Asserts that {@code lhs} is equal to {@code rhs}.
+     *
+     * @param lhs The left hand side of the comparison.
+     * @param rhs The right hand side of the comparison.
+     * @param msg A description of the assumption.
+     * @throws RuntimeException if the assertion isn't valid.
+     */
+    public static void assertEquals(Object lhs, Object rhs, String msg) {
+        if (lhs == null) {
+            if (rhs != null) {
+                error(msg);
+            }
+        } else {
+            assertTrue(lhs.equals(rhs), msg);
+        }
+    }
+
+    /**
+     * Shorthand for {@link #assertGreaterThanOrEqual(T, T)}.
+     *
+     * @see #assertGreaterThanOrEqual(T, T)
+     */
+    public static <T extends Comparable<T>> void assertGTE(T lhs, T rhs) {
+        assertGreaterThanOrEqual(lhs, rhs);
+    }
+
+    /**
+     * Shorthand for {@link #assertGreaterThanOrEqual(T, T, String)}.
+     *
+     * @see #assertGreaterThanOrEqual(T, T, String)
+     */
+    public static <T extends Comparable<T>> void assertGTE(T lhs, T rhs, String msg) {
+        assertGreaterThanOrEqual(lhs, rhs, msg);
+    }
+
+    /**
+     * Calls {@link #assertGreaterThanOrEqual(T, T, String)} with a default message.
+     *
+     * @see #assertGreaterThanOrEqual(T, T, String)
+     */
+    public static <T extends Comparable<T>> void assertGreaterThanOrEqual(T lhs, T rhs) {
+        String msg = "Expected that " + format(lhs) + " >= " + format(rhs);
+        assertGreaterThanOrEqual(lhs, rhs, msg);
+    }
+
+    /**
+     * Asserts that {@code lhs} is greater than or equal to {@code rhs}.
+     *
+     * @param lhs The left hand side of the comparison.
+     * @param rhs The right hand side of the comparison.
+     * @param msg A description of the assumption.
+     * @throws RuntimeException if the assertion isn't valid.
+     */
+    public static <T extends Comparable<T>> void assertGreaterThanOrEqual(T lhs, T rhs, String msg) {
+        assertTrue(compare(lhs, rhs, msg) >= 0, msg);
+    }
+
+    /**
+     * Shorthand for {@link #assertGreaterThan(T, T)}.
+     *
+     * @see #assertGreaterThan(T, T)
+     */
+    public static <T extends Comparable<T>> void assertGT(T lhs, T rhs) {
+        assertGreaterThan(lhs, rhs);
+    }
+
+    /**
+     * Shorthand for {@link #assertGreaterThan(T, T, String)}.
+     *
+     * @see #assertGreaterThan(T, T, String)
+     */
+    public static <T extends Comparable<T>> void assertGT(T lhs, T rhs, String msg) {
+        assertGreaterThan(lhs, rhs, msg);
+    }
+
+    /**
+     * Calls {@link #assertGreaterThan(T, T, String)} with a default message.
+     *
+     * @see #assertGreaterThan(T, T, String)
+     */
+    public static <T extends Comparable<T>> void assertGreaterThan(T lhs, T rhs) {
+        String msg = "Expected that " + format(lhs) + " > " + format(rhs);
+        assertGreaterThan(lhs, rhs, msg);
+    }
+
+    /**
+     * Asserts that {@code lhs} is greater than {@code rhs}.
+     *
+     * @param lhs The left hand side of the comparison.
+     * @param rhs The right hand side of the comparison.
+     * @param msg A description of the assumption.
+     * @throws RuntimeException if the assertion isn't valid.
+     */
+    public static <T extends Comparable<T>> void assertGreaterThan(T lhs, T rhs, String msg) {
+        assertTrue(compare(lhs, rhs, msg) > 0, msg);
+    }
+
+    /**
+     * Shorthand for {@link #assertNotEquals(T, T)}.
+     *
+     * @see #assertNotEquals(T, T)
+     */
+    public static void assertNE(Object lhs, Object rhs) {
+        assertNotEquals(lhs, rhs);
+    }
+
+    /**
+     * Shorthand for {@link #assertNotEquals(T, T, String)}.
+     *
+     * @see #assertNotEquals(T, T, String)
+     */
+    public static void assertNE(Object lhs, Object rhs, String msg) {
+        assertNotEquals(lhs, rhs, msg);
+    }
+
+    /**
+     * Calls {@link #assertNotEquals(T, T, String)} with a default message.
+     *
+     * @see #assertNotEquals(T, T, String)
+     */
+    public static void assertNotEquals(Object lhs, Object rhs) {
+        String msg = "Expected " + format(lhs) + " to not equal " + format(rhs);
+        assertNotEquals(lhs, rhs, msg);
+    }
+
+    /**
+     * Asserts that {@code lhs} is not equal to {@code rhs}.
+     *
+     * @param lhs The left hand side of the comparison.
+     * @param rhs The right hand side of the comparison.
+     * @param msg A description of the assumption.
+     * @throws RuntimeException if the assertion isn't valid.
+     */
+    public static void assertNotEquals(Object lhs, Object rhs, String msg) {
+        if (lhs == null) {
+            if (rhs == null) {
+                error(msg);
+            }
+        } else {
+            assertFalse(lhs.equals(rhs), msg);
+        }
+    }
+
+    /**
+     * Calls {@link #assertNull(Object, String)} with a default message.
+     *
+     * @see #assertNull(Object, String)
+     */
+    public static void assertNull(Object o) {
+        assertNull(o, "Expected " + format(o) + " to be null");
+    }
+
+    /**
+     * Asserts that {@code o} is null.
+     *
+     * @param o The reference assumed to be null.
+     * @param msg A description of the assumption.
+     * @throws RuntimeException if the assertion isn't valid.
+     */
+    public static void assertNull(Object o, String msg) {
+        assertEquals(o, null, msg);
+    }
+
+    /**
+     * Calls {@link #assertNotNull(Object, String)} with a default message.
+     *
+     * @see #assertNotNull(Object, String)
+     */
+    public static void assertNotNull(Object o) {
+        assertNotNull(o, "Expected non null reference");
+    }
+
+    /**
+     * Asserts that {@code o} is <i>not</i> null.
+     *
+     * @param o The reference assumed <i>not</i> to be null,
+     * @param msg A description of the assumption.
+     * @throws RuntimeException if the assertion isn't valid.
+     */
+    public static void assertNotNull(Object o, String msg) {
+        assertNotEquals(o, null, msg);
+    }
+
+    /**
+     * Calls {@link #assertFalse(boolean, String)} with a default message.
+     *
+     * @see #assertFalse(boolean, String)
+     */
+    public static void assertFalse(boolean value) {
+        assertFalse(value, "Expected value to be false");
+    }
+
+    /**
+     * Asserts that {@code value} is {@code false}.
+     *
+     * @param value The value assumed to be false.
+     * @param msg A description of the assumption.
+     * @throws RuntimeException if the assertion isn't valid.
+     */
+    public static void assertFalse(boolean value, String msg) {
+        assertTrue(!value, msg);
+    }
+
+    /**
+     * Calls {@link #assertTrue(boolean, String)} with a default message.
+     *
+     * @see #assertTrue(boolean, String)
+     */
+    public static void assertTrue(boolean value) {
+        assertTrue(value, "Expected value to be true");
+    }
+
+    /**
+     * Asserts that {@code value} is {@code true}.
+     *
+     * @param value The value assumed to be true.
+     * @param msg A description of the assumption.
+     * @throws RuntimeException if the assertion isn't valid.
+     */
+    public static void assertTrue(boolean value, String msg) {
+        if (!value) {
+            error(msg);
+        }
+    }
+
+    private static <T extends Comparable<T>> int compare(T lhs, T rhs, String msg) {
+        assertNotNull(lhs, msg);
+        assertNotNull(rhs, msg);
+        return lhs.compareTo(rhs);
+    }
+
+    private static String format(Object o) {
+        return o == null? "null" : o.toString();
+    }
+
+    private static void error(String msg) {
+        throw new RuntimeException(msg);
+    }
+
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/test/testlibrary/com/oracle/java/testlibrary/ByteCodeLoader.java	Mon Sep 08 12:15:04 2014 -0700
@@ -0,0 +1,74 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.oracle.java.testlibrary;
+
+import java.security.SecureClassLoader;
+
+/**
+ * {@code ByteCodeLoader} can be used for easy loading of byte code already
+ * present in memory.
+ *
+ * {@code InMemoryCompiler} can be used for compiling source code in a string
+ * into byte code, which then can be loaded with {@code ByteCodeLoader}.
+ *
+ * @see InMemoryCompiler
+ */
+public class ByteCodeLoader extends SecureClassLoader {
+    private final String className;
+    private final byte[] byteCode;
+
+    /**
+     * Creates a new {@code ByteCodeLoader} ready to load a class with the
+     * given name and the given byte code.
+     *
+     * @param className The name of the class
+     * @param byteCode The byte code of the class
+     */
+    public ByteCodeLoader(String className, byte[] byteCode) {
+        this.className = className;
+        this.byteCode = byteCode;
+    }
+
+    @Override
+    protected Class<?> findClass(String name) throws ClassNotFoundException {
+        if (!name.equals(className)) {
+            throw new ClassNotFoundException(name);
+        }
+
+        return defineClass(name, byteCode, 0, byteCode.length);
+    }
+
+    /**
+     * Utility method for creating a new {@code ByteCodeLoader} and then
+     * directly load the given byte code.
+     *
+     * @param className The name of the class
+     * @param byteCode The byte code for the class
+     * @throws ClassNotFoundException if the class can't be loaded
+     * @return A {@see Class} object representing the class
+     */
+    public static Class<?> load(String className, byte[] byteCode) throws ClassNotFoundException {
+        return new ByteCodeLoader(className, byteCode).loadClass(className);
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/test/testlibrary/com/oracle/java/testlibrary/InMemoryJavaCompiler.java	Mon Sep 08 12:15:04 2014 -0700
@@ -0,0 +1,154 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.oracle.java.testlibrary;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.OutputStream;
+
+import java.net.URI;
+import java.util.Arrays;
+
+import javax.tools.ForwardingJavaFileManager;
+import javax.tools.ForwardingJavaFileManager;
+import javax.tools.FileObject;
+import javax.tools.JavaCompiler;
+import javax.tools.JavaCompiler.CompilationTask;
+import javax.tools.JavaFileManager;
+import javax.tools.JavaFileObject;
+import javax.tools.JavaFileObject.Kind;
+import javax.tools.SimpleJavaFileObject;
+import javax.tools.ToolProvider;
+
+/**
+ * {@code InMemoryJavaCompiler} can be used for compiling a {@link
+ * CharSequence} to a {@code byte[]}.
+ *
+ * The compiler will not use the file system at all, instead using a {@link
+ * ByteArrayOutputStream} for storing the byte code. For the source code, any
+ * kind of {@link CharSequence} can be used, e.g. {@link String}, {@link
+ * StringBuffer} or {@link StringBuilder}.
+ *
+ * The {@code InMemoryCompiler} can easily be used together with a {@code
+ * ByteClassLoader} to easily compile and load source code in a {@link String}:
+ *
+ * <pre>
+ * {@code
+ * import com.oracle.java.testlibrary.InMemoryJavaCompiler;
+ * import com.oracle.java.testlibrary.ByteClassLoader;
+ *
+ * class Example {
+ *     public static void main(String[] args) {
+ *         String className = "Foo";
+ *         String sourceCode = "public class " + className + " {" +
+ *                             "    public void bar() {" +
+ *                             "        System.out.println("Hello from bar!");" +
+ *                             "    }" +
+ *                             "}";
+ *         byte[] byteCode = InMemoryJavaCompiler.compile(className, sourceCode);
+ *         Class fooClass = ByteClassLoader.load(className, byteCode);
+ *     }
+ * }
+ * }
+ * </pre>
+ */
+public class InMemoryJavaCompiler {
+    private static class MemoryJavaFileObject extends SimpleJavaFileObject {
+        private final String className;
+        private final CharSequence sourceCode;
+        private final ByteArrayOutputStream byteCode;
+
+        public MemoryJavaFileObject(String className, CharSequence sourceCode) {
+            super(URI.create("string:///" + className.replace('.','/') + Kind.SOURCE.extension), Kind.SOURCE);
+            this.className = className;
+            this.sourceCode = sourceCode;
+            this.byteCode = new ByteArrayOutputStream();
+        }
+
+        @Override
+        public CharSequence getCharContent(boolean ignoreEncodingErrors) {
+            return sourceCode;
+        }
+
+        @Override
+        public OutputStream openOutputStream() throws IOException {
+            return byteCode;
+        }
+
+        public byte[] getByteCode() {
+            return byteCode.toByteArray();
+        }
+
+        public String getClassName() {
+            return className;
+        }
+    }
+
+    private static class FileManagerWrapper extends ForwardingJavaFileManager {
+        private MemoryJavaFileObject file;
+
+        public FileManagerWrapper(MemoryJavaFileObject file) {
+            super(getCompiler().getStandardFileManager(null, null, null));
+            this.file = file;
+        }
+
+        @Override
+        public JavaFileObject getJavaFileForOutput(Location location, String className,
+                                                   Kind kind, FileObject sibling)
+            throws IOException {
+            if (!file.getClassName().equals(className)) {
+                throw new IOException("Expected class with name " + file.getClassName() +
+                                      ", but got " + className);
+            }
+            return file;
+        }
+    }
+
+    /**
+     * Compiles the class with the given name and source code.
+     *
+     * @param className The name of the class
+     * @param sourceCode The source code for the class with name {@code className}
+     * @throws RuntimeException if the compilation did not succeed
+     * @return The resulting byte code from the compilation
+     */
+    public static byte[] compile(String className, CharSequence sourceCode) {
+        MemoryJavaFileObject file = new MemoryJavaFileObject(className, sourceCode);
+        CompilationTask task = getCompilationTask(file);
+
+        if(!task.call()) {
+            throw new RuntimeException("Could not compile " + className + " with source code " + sourceCode);
+        }
+
+        return file.getByteCode();
+    }
+
+    private static JavaCompiler getCompiler() {
+        return ToolProvider.getSystemJavaCompiler();
+    }
+
+    private static CompilationTask getCompilationTask(MemoryJavaFileObject file) {
+        return getCompiler().getTask(null, new FileManagerWrapper(file), null, null, null, Arrays.asList(file));
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/test/testlibrary/com/oracle/java/testlibrary/InputArguments.java	Mon Sep 08 12:15:04 2014 -0700
@@ -0,0 +1,76 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.oracle.java.testlibrary;
+
+import java.lang.management.RuntimeMXBean;
+import java.lang.management.ManagementFactory;
+import java.util.List;
+
+/**
+ * This class provides access to the input arguments to the VM.
+ */
+public class InputArguments {
+    private static final List<String> args;
+
+    static {
+        RuntimeMXBean runtimeMxBean = ManagementFactory.getRuntimeMXBean();
+        args = runtimeMxBean.getInputArguments();
+    }
+
+    /**
+     * Returns true if {@code arg} is an input argument to the VM.
+     *
+     * This is useful for checking boolean flags such as -XX:+UseSerialGC or
+     * -XX:-UsePerfData.
+     *
+     * @param arg The name of the argument.
+     * @return {@code true} if the given argument is an input argument,
+     *         otherwise {@code false}.
+     */
+    public static boolean contains(String arg) {
+        return args.contains(arg);
+    }
+
+    /**
+     * Returns true if {@code prefix} is the start of an input argument to the
+     * VM.
+     *
+     * This is useful for checking if flags describing a quantity, such as
+     * -XX:+MaxMetaspaceSize=100m, is set without having to know the quantity.
+     * To check if the flag -XX:MaxMetaspaceSize is set, use
+     * {@code InputArguments.containsPrefix("-XX:MaxMetaspaceSize")}.
+     *
+     * @param prefix The start of the argument.
+     * @return {@code true} if the given argument is the start of an input
+     *         argument, otherwise {@code false}.
+     */
+    public static boolean containsPrefix(String prefix) {
+        for (String arg : args) {
+            if (arg.startsWith(prefix)) {
+                return true;
+            }
+        }
+        return false;
+    }
+}
--- ./hotspot/test/testlibrary/com/oracle/java/testlibrary/JDKToolFinder.java	Wed Jun 25 09:01:56 2014 -0700
+++ ./hotspot/test/testlibrary/com/oracle/java/testlibrary/JDKToolFinder.java	Mon Sep 08 12:15:04 2014 -0700
@@ -23,28 +23,84 @@
 
 package com.oracle.java.testlibrary;
 
-import java.io.File;
+import java.io.FileNotFoundException;
+import java.nio.file.Path;
+import java.nio.file.Paths;
 
 public final class JDKToolFinder {
 
-  private JDKToolFinder() {
-  }
-
-  /**
-   * Returns the full path to an executable in jdk/bin based on System property
-   * test.jdk (set by jtreg test suite)
-   *
-   * @return Full path to an executable in jdk/bin
-   */
-  public static String getJDKTool(String tool) {
-    String binPath = System.getProperty("test.jdk");
-    if (binPath == null) {
-      throw new RuntimeException("System property 'test.jdk' not set. This property is normally set by jtreg. "
-          + "When running test separately, set this property using '-Dtest.jdk=/path/to/jdk'.");
+    private JDKToolFinder() {
     }
 
-    binPath += File.separatorChar + "bin" + File.separatorChar + tool;
+    /**
+     * Returns the full path to an executable in jdk/bin based on System
+     * property {@code test.jdk} or {@code compile.jdk} (both are set by the jtreg test suite)
+     *
+     * @return Full path to an executable in jdk/bin
+     */
+    public static String getJDKTool(String tool) {
 
-    return binPath;
-  }
+        // First try to find the executable in test.jdk
+        try {
+            return getTool(tool, "test.jdk");
+        } catch (FileNotFoundException e) {
+
+        }
+
+        // Now see if it's available in compile.jdk
+        try {
+            return getTool(tool, "compile.jdk");
+        } catch (FileNotFoundException e) {
+            throw new RuntimeException("Failed to find " + tool +
+                    ", looked in test.jdk (" + System.getProperty("test.jdk") +
+                    ") and compile.jdk (" + System.getProperty("compile.jdk") + ")");
+        }
+    }
+
+    /**
+     * Returns the full path to an executable in jdk/bin based on System
+     * property {@code compile.jdk}
+     *
+     * @return Full path to an executable in jdk/bin
+     */
+    public static String getCompileJDKTool(String tool) {
+        try {
+            return getTool(tool, "compile.jdk");
+        } catch (FileNotFoundException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    /**
+     * Returns the full path to an executable in jdk/bin based on System
+     * property {@code test.jdk}
+     *
+     * @return Full path to an executable in jdk/bin
+     */
+    public static String getTestJDKTool(String tool) {
+        try {
+            return getTool(tool, "test.jdk");
+        } catch (FileNotFoundException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    private static String getTool(String tool, String property) throws FileNotFoundException {
+        String jdkPath = System.getProperty(property);
+
+        if (jdkPath == null) {
+            throw new RuntimeException(
+                    "System property '" + property + "' not set. This property is normally set by jtreg. "
+                    + "When running test separately, set this property using '-D" + property + "=/path/to/jdk'.");
+        }
+
+        Path toolName = Paths.get("bin", tool + (Platform.isWindows() ? ".exe" : ""));
+
+        Path jdkTool = Paths.get(jdkPath, toolName.toString());
+        if (!jdkTool.toFile().exists()) {
+            throw new FileNotFoundException("Could not find file " + jdkTool.toAbsolutePath());
+        }
+
+        return jdkTool.toAbsolutePath().toString();
+    }
 }
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/test/testlibrary/com/oracle/java/testlibrary/JDKToolLauncher.java	Mon Sep 08 12:15:04 2014 -0700
@@ -0,0 +1,134 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.oracle.java.testlibrary;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * A utility for constructing command lines for starting JDK tool processes.
+ *
+ * The JDKToolLauncher can in particular be combined with a
+ * java.lang.ProcessBuilder to easily run a JDK tool. For example, the following
+ * code run {@code jmap -heap} against a process with GC logging turned on for
+ * the {@code jmap} process:
+ *
+ * <pre>
+ * {@code
+ * JDKToolLauncher jmap = JDKToolLauncher.create("jmap")
+ *                                       .addVMArg("-XX:+PrintGC");
+ *                                       .addVMArg("-XX:+PrintGCDetails")
+ *                                       .addToolArg("-heap")
+ *                                       .addToolArg(pid);
+ * ProcessBuilder pb = new ProcessBuilder(jmap.getCommand());
+ * Process p = pb.start();
+ * }
+ * </pre>
+ */
+public class JDKToolLauncher {
+    private final String executable;
+    private final List<String> vmArgs = new ArrayList<String>();
+    private final List<String> toolArgs = new ArrayList<String>();
+
+    private JDKToolLauncher(String tool, boolean useCompilerJDK) {
+        if (useCompilerJDK) {
+            executable = JDKToolFinder.getJDKTool(tool);
+        } else {
+            executable = JDKToolFinder.getTestJDKTool(tool);
+        }
+        vmArgs.addAll(Arrays.asList(ProcessTools.getPlatformSpecificVMArgs()));
+    }
+
+    /**
+     * Creates a new JDKToolLauncher for the specified tool. Using tools path
+     * from the compiler JDK.
+     *
+     * @param tool
+     *            The name of the tool
+     * @return A new JDKToolLauncher
+     */
+    public static JDKToolLauncher create(String tool) {
+        return new JDKToolLauncher(tool, true);
+    }
+
+    /**
+     * Creates a new JDKToolLauncher for the specified tool in the Tested JDK.
+     *
+     * @param tool
+     *            The name of the tool
+     *
+     * @return A new JDKToolLauncher
+     */
+    public static JDKToolLauncher createUsingTestJDK(String tool) {
+        return new JDKToolLauncher(tool, false);
+    }
+
+    /**
+     * Adds an argument to the JVM running the tool.
+     *
+     * The JVM arguments are passed to the underlying JVM running the tool.
+     * Arguments will automatically be prepended with "-J".
+     *
+     * Any platform specific arguments required for running the tool are
+     * automatically added.
+     *
+     *
+     * @param arg
+     *            The argument to VM running the tool
+     * @return The JDKToolLauncher instance
+     */
+    public JDKToolLauncher addVMArg(String arg) {
+        vmArgs.add(arg);
+        return this;
+    }
+
+    /**
+     * Adds an argument to the tool.
+     *
+     * @param arg
+     *            The argument to the tool
+     * @return The JDKToolLauncher instance
+     */
+    public JDKToolLauncher addToolArg(String arg) {
+        toolArgs.add(arg);
+        return this;
+    }
+
+    /**
+     * Returns the command that can be used for running the tool.
+     *
+     * @return An array whose elements are the arguments of the command.
+     */
+    public String[] getCommand() {
+        List<String> command = new ArrayList<String>();
+        command.add(executable);
+        // Add -J in front of all vmArgs
+        for (String arg : vmArgs) {
+            command.add("-J" + arg);
+        }
+        command.addAll(toolArgs);
+        return command.toArray(new String[command.size()]);
+    }
+}
--- ./hotspot/test/testlibrary/com/oracle/java/testlibrary/OutputAnalyzer.java	Wed Jun 25 09:01:56 2014 -0700
+++ ./hotspot/test/testlibrary/com/oracle/java/testlibrary/OutputAnalyzer.java	Mon Sep 08 12:15:04 2014 -0700
@@ -76,7 +76,8 @@
    */
   public void shouldContain(String expectedString) {
     if (!stdout.contains(expectedString) && !stderr.contains(expectedString)) {
-      throw new RuntimeException("'" + expectedString + "' missing from stdout/stderr: [" + stdout + stderr + "]\n");
+        reportDiagnosticSummary();
+        throw new RuntimeException("'" + expectedString + "' missing from stdout/stderr \n");
     }
   }
 
@@ -88,7 +89,8 @@
    */
   public void stdoutShouldContain(String expectedString) {
     if (!stdout.contains(expectedString)) {
-      throw new RuntimeException("'" + expectedString + "' missing from stdout: [" + stdout + "]\n");
+        reportDiagnosticSummary();
+        throw new RuntimeException("'" + expectedString + "' missing from stdout \n");
     }
   }
 
@@ -100,7 +102,8 @@
    */
   public void stderrShouldContain(String expectedString) {
     if (!stderr.contains(expectedString)) {
-      throw new RuntimeException("'" + expectedString + "' missing from stderr: [" + stderr + "]\n");
+        reportDiagnosticSummary();
+        throw new RuntimeException("'" + expectedString + "' missing from stderr \n");
     }
   }
 
@@ -112,10 +115,12 @@
    */
   public void shouldNotContain(String notExpectedString) {
     if (stdout.contains(notExpectedString)) {
-      throw new RuntimeException("'" + notExpectedString + "' found in stdout: [" + stdout + "]\n");
+        reportDiagnosticSummary();
+        throw new RuntimeException("'" + notExpectedString + "' found in stdout \n");
     }
     if (stderr.contains(notExpectedString)) {
-      throw new RuntimeException("'" + notExpectedString + "' found in stderr: [" + stderr + "]\n");
+        reportDiagnosticSummary();
+        throw new RuntimeException("'" + notExpectedString + "' found in stderr \n");
     }
   }
 
@@ -127,7 +132,8 @@
    */
   public void stdoutShouldNotContain(String notExpectedString) {
     if (stdout.contains(notExpectedString)) {
-      throw new RuntimeException("'" + notExpectedString + "' found in stdout: [" + stdout + "]\n");
+        reportDiagnosticSummary();
+        throw new RuntimeException("'" + notExpectedString + "' found in stdout \n");
     }
   }
 
@@ -139,7 +145,8 @@
    */
   public void stderrShouldNotContain(String notExpectedString) {
     if (stderr.contains(notExpectedString)) {
-      throw new RuntimeException("'" + notExpectedString + "' found in stderr: [" + stderr + "]\n");
+        reportDiagnosticSummary();
+        throw new RuntimeException("'" + notExpectedString + "' found in stderr \n");
     }
   }
 
@@ -154,9 +161,9 @@
       Matcher stdoutMatcher = Pattern.compile(pattern, Pattern.MULTILINE).matcher(stdout);
       Matcher stderrMatcher = Pattern.compile(pattern, Pattern.MULTILINE).matcher(stderr);
       if (!stdoutMatcher.find() && !stderrMatcher.find()) {
+          reportDiagnosticSummary();
           throw new RuntimeException("'" + pattern
-                  + "' missing from stdout/stderr: [" + stdout + stderr
-                  + "]\n");
+                + "' missing from stdout/stderr \n");
       }
   }
 
@@ -170,8 +177,9 @@
   public void stdoutShouldMatch(String pattern) {
       Matcher matcher = Pattern.compile(pattern, Pattern.MULTILINE).matcher(stdout);
       if (!matcher.find()) {
+          reportDiagnosticSummary();
           throw new RuntimeException("'" + pattern
-                  + "' missing from stdout: [" + stdout + "]\n");
+                + "' missing from stdout \n");
       }
   }
 
@@ -185,8 +193,9 @@
   public void stderrShouldMatch(String pattern) {
       Matcher matcher = Pattern.compile(pattern, Pattern.MULTILINE).matcher(stderr);
       if (!matcher.find()) {
+          reportDiagnosticSummary();
           throw new RuntimeException("'" + pattern
-                  + "' missing from stderr: [" + stderr + "]\n");
+                + "' missing from stderr \n");
       }
   }
 
@@ -200,13 +209,15 @@
   public void shouldNotMatch(String pattern) {
       Matcher matcher = Pattern.compile(pattern, Pattern.MULTILINE).matcher(stdout);
       if (matcher.find()) {
+          reportDiagnosticSummary();
           throw new RuntimeException("'" + pattern
-                  + "' found in stdout: [" + stdout + "]\n");
+                  + "' found in stdout: '" + matcher.group() + "' \n");
       }
       matcher = Pattern.compile(pattern, Pattern.MULTILINE).matcher(stderr);
       if (matcher.find()) {
+          reportDiagnosticSummary();
           throw new RuntimeException("'" + pattern
-                  + "' found in stderr: [" + stderr + "]\n");
+                  + "' found in stderr: '" + matcher.group() + "' \n");
       }
   }
 
@@ -220,8 +231,9 @@
   public void stdoutShouldNotMatch(String pattern) {
       Matcher matcher = Pattern.compile(pattern, Pattern.MULTILINE).matcher(stdout);
       if (matcher.find()) {
+          reportDiagnosticSummary();
           throw new RuntimeException("'" + pattern
-                  + "' found in stdout: [" + stdout + "]\n");
+                  + "' found in stdout \n");
       }
   }
 
@@ -235,8 +247,9 @@
   public void stderrShouldNotMatch(String pattern) {
       Matcher matcher = Pattern.compile(pattern, Pattern.MULTILINE).matcher(stderr);
       if (matcher.find()) {
+          reportDiagnosticSummary();
           throw new RuntimeException("'" + pattern
-                  + "' found in stderr: [" + stderr + "]\n");
+                  + "' found in stderr \n");
       }
   }
 
@@ -279,10 +292,31 @@
    */
   public void shouldHaveExitValue(int expectedExitValue) {
       if (getExitValue() != expectedExitValue) {
-          throw new RuntimeException("Exit value " + getExitValue() + " , expected to get " + expectedExitValue);
+          reportDiagnosticSummary();
+          throw new RuntimeException("Expected to get exit value of ["
+                  + expectedExitValue + "]\n");
       }
   }
 
+
+  /**
+   * Report summary that will help to diagnose the problem
+   * Currently includes:
+   *  - standard input produced by the process under test
+   *  - standard output
+   *  - exit code
+   *  Note: the command line is printed by the ProcessTools
+   */
+    private void reportDiagnosticSummary() {
+        String msg =
+            " stdout: [" + stdout + "];\n" +
+            " stderr: [" + stderr + "]\n" +
+            " exitValue = " + getExitValue() + "\n";
+
+        System.err.println(msg);
+    }
+
+
   /**
    * Get the contents of the output buffer (stdout and stderr)
    *
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/test/testlibrary/com/oracle/java/testlibrary/PerfCounter.java	Mon Sep 08 12:15:04 2014 -0700
@@ -0,0 +1,70 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.oracle.java.testlibrary;
+
+import sun.jvmstat.monitor.Monitor;
+
+/**
+ * Represents a performance counter in the JVM.
+ *
+ * See http://openjdk.java.net/groups/hotspot/docs/Serviceability.html#bjvmstat
+ * for more details about performance counters.
+ */
+public class PerfCounter {
+    private final Monitor monitor;
+    private final String name;
+
+    PerfCounter(Monitor monitor, String name) {
+        this.monitor = monitor;
+        this.name = name;
+    }
+
+    /**
+     * Returns the value of this performance counter as a long.
+     *
+     * @return The long value of this performance counter
+     * @throws RuntimeException If the value of the performance counter isn't a long
+     */
+    public long longValue() {
+        Object value = monitor.getValue();
+        if (value instanceof Long) {
+            return ((Long) value).longValue();
+        }
+        throw new RuntimeException("Expected " + monitor.getName() + " to have a long value");
+    }
+
+    /**
+     * Returns the name of the performance counter.
+     *
+     * @return The name of the performance counter.
+     */
+    public String getName() {
+        return name;
+    }
+
+    @Override
+    public String toString() {
+        return name;
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/test/testlibrary/com/oracle/java/testlibrary/PerfCounters.java	Mon Sep 08 12:15:04 2014 -0700
@@ -0,0 +1,69 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.oracle.java.testlibrary;
+
+import sun.jvmstat.monitor.Monitor;
+import sun.jvmstat.monitor.MonitorException;
+import sun.jvmstat.monitor.MonitoredHost;
+import sun.jvmstat.monitor.MonitoredVm;
+import sun.jvmstat.monitor.VmIdentifier;
+
+/**
+ * PerfCounters can be used to get a performance counter from the currently
+ * executing VM.
+ *
+ * Throws a runtime exception if an error occurs while communicating with the
+ * currently executing VM.
+ */
+public class PerfCounters {
+    private final static MonitoredVm vm;
+
+    static {
+        try {
+            String pid = Integer.toString(ProcessTools.getProcessId());
+            VmIdentifier vmId = new VmIdentifier(pid);
+            MonitoredHost host = MonitoredHost.getMonitoredHost(vmId);
+            vm = host.getMonitoredVm(vmId);
+        } catch (Exception e) {
+            throw new RuntimeException("Could not connect to the VM");
+        }
+    }
+
+    /**
+     * Returns the performance counter with the given name.
+     *
+     * @param name The name of the performance counter.
+     * @throws IllegalArgumentException If no counter with the given name exists.
+     * @throws MonitorException If an error occurs while communicating with the VM.
+     * @return The performance counter with the given name.
+     */
+    public static PerfCounter findByName(String name)
+        throws MonitorException, IllegalArgumentException {
+        Monitor m = vm.findByName(name);
+        if (m == null) {
+            throw new IllegalArgumentException("Did not find a performance counter with name " + name);
+        }
+        return new PerfCounter(m, name);
+    }
+}
--- ./hotspot/test/testlibrary/com/oracle/java/testlibrary/Platform.java	Wed Jun 25 09:01:56 2014 -0700
+++ ./hotspot/test/testlibrary/com/oracle/java/testlibrary/Platform.java	Mon Sep 08 12:15:04 2014 -0700
@@ -24,39 +24,80 @@
 package com.oracle.java.testlibrary;
 
 public class Platform {
-  private static final String osName = System.getProperty("os.name");
-  private static final String dataModel = System.getProperty("sun.arch.data.model");
-  private static final String vmVersion = System.getProperty("java.vm.version");
+    private static final String osName      = System.getProperty("os.name");
+    private static final String dataModel   = System.getProperty("sun.arch.data.model");
+    private static final String vmVersion   = System.getProperty("java.vm.version");
+    private static final String osArch      = System.getProperty("os.arch");
 
-  public static boolean is64bit() {
-    return dataModel.equals("64");
-  }
+    public static boolean is32bit() {
+        return dataModel.equals("32");
+    }
 
-  public static boolean isSolaris() {
-    return osName.toLowerCase().startsWith("sunos");
-  }
+    public static boolean is64bit() {
+        return dataModel.equals("64");
+    }
 
-  public static boolean isWindows() {
-    return osName.toLowerCase().startsWith("win");
-  }
+    public static boolean isSolaris() {
+        return isOs("sunos");
+    }
 
-  public static boolean isOSX() {
-    return osName.toLowerCase().startsWith("mac");
-  }
+    public static boolean isWindows() {
+        return isOs("win");
+    }
 
-  public static boolean isLinux() {
-    return osName.toLowerCase().startsWith("linux");
-  }
+    public static boolean isOSX() {
+        return isOs("mac");
+    }
 
-  public static String getOsName() {
-    return osName;
-  }
+    public static boolean isLinux() {
+        return isOs("linux");
+    }
 
-  public static boolean isDebugBuild() {
-    return vmVersion.toLowerCase().contains("debug");
-  }
+    private static boolean isOs(String osname) {
+        return osName.toLowerCase().startsWith(osname.toLowerCase());
+    }
 
-  public static String getVMVersion() {
-    return vmVersion;
-  }
+    public static String getOsName() {
+        return osName;
+    }
+
+    public static boolean isDebugBuild() {
+        return vmVersion.toLowerCase().contains("debug");
+    }
+
+    public static String getVMVersion() {
+        return vmVersion;
+    }
+
+    // Returns true for sparc and sparcv9.
+    public static boolean isSparc() {
+        return isArch("sparc");
+    }
+
+    public static boolean isARM() {
+        return isArch("arm");
+    }
+
+    public static boolean isPPC() {
+        return isArch("ppc");
+    }
+
+    public static boolean isX86() {
+        // On Linux it's 'i386', Windows 'x86'
+        return (isArch("i386") || isArch("x86"));
+    }
+
+    public static boolean isX64() {
+        // On OSX it's 'x86_64' and on other (Linux, Windows and Solaris) platforms it's 'amd64'
+        return (isArch("amd64") || isArch("x86_64"));
+    }
+
+    private static boolean isArch(String archname) {
+        return osArch.toLowerCase().startsWith(archname.toLowerCase());
+    }
+
+    public static String getOsArch() {
+        return osArch;
+    }
+
 }
--- ./hotspot/test/testlibrary/com/oracle/java/testlibrary/ProcessTools.java	Wed Jun 25 09:01:56 2014 -0700
+++ ./hotspot/test/testlibrary/com/oracle/java/testlibrary/ProcessTools.java	Mon Sep 08 12:15:04 2014 -0700
@@ -31,6 +31,7 @@
 import java.lang.reflect.Method;
 import java.util.ArrayList;
 import java.util.Collections;
+import java.util.List;
 
 import sun.management.VMManagement;
 
@@ -107,15 +108,29 @@
   }
 
   /**
+   * Get the string containing input arguments passed to the VM
+   *
+   * @return arguments
+   */
+  public static String getVmInputArguments() {
+    RuntimeMXBean runtime = ManagementFactory.getRuntimeMXBean();
+
+    List<String> args = runtime.getInputArguments();
+    StringBuilder result = new StringBuilder();
+    for (String arg : args)
+        result.append(arg).append(' ');
+
+    return result.toString();
+  }
+
+  /**
    * Get platform specific VM arguments (e.g. -d64 on 64bit Solaris)
    *
    * @return String[] with platform specific arguments, empty if there are none
    */
   public static String[] getPlatformSpecificVMArgs() {
-    String osName = System.getProperty("os.name");
-    String dataModel = System.getProperty("sun.arch.data.model");
 
-    if (osName.equals("SunOS") && dataModel.equals("64")) {
+    if (Platform.is64bit() && Platform.isSolaris()) {
       return new String[] { "-d64" };
     }
 
@@ -134,8 +149,13 @@
     Collections.addAll(args, getPlatformSpecificVMArgs());
     Collections.addAll(args, command);
 
+    // Reporting
+    StringBuilder cmdLine = new StringBuilder();
+    for (String cmd : args)
+        cmdLine.append(cmd).append(' ');
+    System.out.println("Command line: [" + cmdLine.toString() + "]");
+
     return new ProcessBuilder(args.toArray(new String[args.size()]));
-
   }
 
 }
--- ./jaxp/.hgtags	Wed Jun 25 09:03:02 2014 -0700
+++ ./jaxp/.hgtags	Mon Sep 08 12:15:56 2014 -0700
@@ -421,6 +421,7 @@
 14719f73596f5c90e3f46c0f4312f32e5b105edd jdk7u55-b13
 01f26830f88cf4f10897416fe1f4f372efcdecf5 jdk7u55-b30
 26187a65c765b3177f1b7ff0638259bf66f9ec47 jdk7u55-b14
+b81309c6014182819d752a4517d48b201d91b154 jdk7u55-b15
 5be97f6c25d9eb3ef0a05fc860964cb3d27134b0 jdk7u55-b31
 94f3ad704f28d5ec65f7a3b1cbf5cfe7e42151f3 jdk7u55-b32
 476aad2c130e2b1b7033fa6789754c03151da95c jdk7u55-b33
@@ -469,3 +470,36 @@
 a34a9f6740955e1cd844c5b701d76dbe7290913a jdk7u65-b16
 178512d1bd9caf56d61811ad0d4b4269475407aa jdk7u65-b17
 be897d0fd2a0b5f43b0d0e48075e5b070ca584d4 jdk7u65-b30
+45db678253587755df4a00066e42e2fce04bbb71 jdk7u65-b18
+4e323af07c47061109fb5f585613b0cc4b4208ca jdk7u65-b19
+f3b7bb6f1924ab7f635cdd60db7fbab64576cd6d jdk7u65-b32
+d41f31b707c87675f3467e980b1ceef2e53b3b5d jdk7u65-b20
+d1f8566d39c56e40516a1afb304ed7c0681355d8 jdk7u67-b01
+4e323af07c47061109fb5f585613b0cc4b4208ca jdk7u65-b40
+a5f829d7fa05cf769402dfc82c94b737b8d011b0 jdk7u65-b31
+f33ea72260ca7480f4a1405d35a3709895b491a2 jdk7u65-b33
+86e93799766d67102a37559b3831abcc825d7e24 jdk7u66-b00
+d34839cb2f15dee01cdfb1fd93378849de34d662 jdk7u66-b01
+19e4e978c8212921104ba16d0db6bf18c6f8d0ab jdk7u66-b09
+533ecae83034da1e68ee9a414b690c9b6eead293 jdk7u66-b10
+763f80d4aae130a89efa4c6544ee98fcb7e6a2ca jdk7u66-b11
+0d91d2f038d19261e0085a76bb8974c3b7609c5d jdk7u66-b12
+cddc3774bebfe597228c7b3e386859b1fa775387 jdk7u66-b13
+15206a7046a97d0a0fd824bec8b0e4174a56d8eb jdk7u66-b14
+af60b8e3b9deb32d50552916e0afd38a30feaef0 jdk7u66-b15
+36bba6c72f866df5c65ba8678544bf0442a952b3 jdk7u66-b16
+9a777cc0d6b3b25d13feca1e610584d042565367 jdk7u66-b17
+174a2f822f4f600f798e9963f0c1496206dce471 jdk7u71-b00
+df8d93eddfc2de1046b8fb87204bc945c538a282 jdk7u71-b01
+153724c929075f0a741aacead679af39f03a0a80 jdk7u71-b02
+9e2007e23f356b7bc5d4d0c6c6350e9b3b3cd56b jdk7u71-b03
+f58a7f8db6c54cd76621d1f48d17102ffbe93983 jdk7u71-b04
+edab7f6d9a30feea45bf9185de0c65e11ab3a7b0 jdk7u71-b05
+ca2992ad734eaf8295e21351b0de329555e9e60a jdk7u71-b06
+5fbecd4c30c2e566e9b815818d51042e20d3ab83 jdk7u71-b07
+acf176ea76f904674228745c25af195e460f1240 jdk7u71-b08
+8a9f55d8d011ad6dc36f307dfac47981b676b379 jdk7u71-b09
+d82fd2f6c5c8ed03c75828033058b675f9239d4b jdk7u71-b10
+f7542072016b7972b383075f84df29bc05495d2e jdk7u71-b11
+109dd4c4a07a8adfaf59e11c29e502277b803c44 jdk7u71-b12
+df2c7c9a3609f8f4b30b09c29a9cfddc8b4b90ef jdk7u71-b13
--- ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/StringLengthCall.java	Wed Jun 25 09:03:02 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/StringLengthCall.java	Mon Sep 08 12:15:56 2014 -0700
@@ -26,7 +26,7 @@
 import java.util.Vector;
 
 import com.sun.org.apache.bcel.internal.generic.ConstantPoolGen;
-import com.sun.org.apache.bcel.internal.generic.INVOKEVIRTUAL;
+import com.sun.org.apache.bcel.internal.generic.INVOKESTATIC;
 import com.sun.org.apache.bcel.internal.generic.InstructionList;
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.ClassGenerator;
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.MethodGenerator;
@@ -51,7 +51,8 @@
             il.append(methodGen.loadContextNode());
             Type.Node.translateTo(classGen, methodGen, Type.String);
         }
-        il.append(new INVOKEVIRTUAL(cpg.addMethodref(STRING_CLASS,
-                                                     "length", "()I")));
+        il.append(new INVOKESTATIC(cpg.addMethodref(BASIS_LIBRARY_CLASS,
+                                                     "getStringLength",
+                                                     "(Ljava/lang/String;)I")));
     }
 }
--- ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/runtime/BasisLibrary.java	Wed Jun 25 09:03:02 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/runtime/BasisLibrary.java	Mon Sep 08 12:15:56 2014 -0700
@@ -1660,5 +1660,14 @@
 
     }
 
+    /**
+     *  Utility method to calculate string-length as a number of code points,
+     *  to avoid possible errors with string that contains
+     *  complementary characters
+     */
+    public static int getStringLength(String str) {
+        return str.codePointCount(0,str.length());
+    }
+
     //-- End utility functions
 }
--- ./jaxp/src/com/sun/org/apache/xerces/internal/impl/XML11EntityScanner.java	Wed Jun 25 09:03:02 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xerces/internal/impl/XML11EntityScanner.java	Mon Sep 08 12:15:56 2014 -0700
@@ -61,14 +61,13 @@
 
 package com.sun.org.apache.xerces.internal.impl;
 
-import java.io.IOException;
-
 import com.sun.org.apache.xerces.internal.impl.msg.XMLMessageFormatter;
+import com.sun.org.apache.xerces.internal.util.XML11Char;
 import com.sun.org.apache.xerces.internal.util.XMLChar;
-import com.sun.org.apache.xerces.internal.util.XML11Char;
 import com.sun.org.apache.xerces.internal.util.XMLStringBuffer;
 import com.sun.org.apache.xerces.internal.xni.QName;
 import com.sun.org.apache.xerces.internal.xni.XMLString;
+import java.io.IOException;
 
 /**
  * Implements the entity scanner methods in
@@ -78,6 +77,7 @@
  *
  * @author Michael Glavassevich, IBM
  * @author Neil Graham, IBM
+ * @version $Id: XML11EntityScanner.java,v 1.5 2010-11-01 04:39:40 joehw Exp $
  */
 
 public class XML11EntityScanner
@@ -108,7 +108,7 @@
 
         // load more characters, if needed
         if (fCurrentEntity.position == fCurrentEntity.count) {
-            load(0, true);
+            load(0, true, true);
         }
 
         // peek at character
@@ -136,7 +136,7 @@
 
         // load more characters, if needed
         if (fCurrentEntity.position == fCurrentEntity.count) {
-            load(0, true);
+            load(0, true, true);
         }
 
         // scan character
@@ -148,7 +148,7 @@
             fCurrentEntity.columnNumber = 1;
             if (fCurrentEntity.position == fCurrentEntity.count) {
                 fCurrentEntity.ch[0] = (char)c;
-                load(1, false);
+                load(1, false, true);
             }
             if (c == '\r' && external) {
                 int cc = fCurrentEntity.ch[fCurrentEntity.position++];
@@ -183,7 +183,7 @@
     public String scanNmtoken() throws IOException {
         // load more characters, if needed
         if (fCurrentEntity.position == fCurrentEntity.count) {
-            load(0, true);
+            load(0, true, true);
         }
 
         // scan nmtoken
@@ -194,6 +194,7 @@
             if (XML11Char.isXML11Name(ch)) {
                 if (++fCurrentEntity.position == fCurrentEntity.count) {
                     int length = fCurrentEntity.position - offset;
+                    invokeListeners(length);
                     if (length == fCurrentEntity.ch.length) {
                         // bad luck we have to resize our buffer
                         char[] tmp = new char[fCurrentEntity.ch.length << 1];
@@ -206,7 +207,7 @@
                                          fCurrentEntity.ch, 0, length);
                     }
                     offset = 0;
-                    if (load(length, false)) {
+                    if (load(length, false, false)) {
                         break;
                     }
                 }
@@ -214,6 +215,7 @@
             else if (XML11Char.isXML11NameHighSurrogate(ch)) {
                 if (++fCurrentEntity.position == fCurrentEntity.count) {
                     int length = fCurrentEntity.position - offset;
+                    invokeListeners(length);
                     if (length == fCurrentEntity.ch.length) {
                         // bad luck we have to resize our buffer
                         char[] tmp = new char[fCurrentEntity.ch.length << 1];
@@ -226,7 +228,7 @@
                                          fCurrentEntity.ch, 0, length);
                     }
                     offset = 0;
-                    if (load(length, false)) {
+                    if (load(length, false, false)) {
                         --fCurrentEntity.startPosition;
                         --fCurrentEntity.position;
                         break;
@@ -240,6 +242,7 @@
                 }
                 if (++fCurrentEntity.position == fCurrentEntity.count) {
                     int length = fCurrentEntity.position - offset;
+                    invokeListeners(length);
                     if (length == fCurrentEntity.ch.length) {
                         // bad luck we have to resize our buffer
                         char[] tmp = new char[fCurrentEntity.ch.length << 1];
@@ -252,7 +255,7 @@
                                          fCurrentEntity.ch, 0, length);
                     }
                     offset = 0;
-                    if (load(length, false)) {
+                    if (load(length, false, false)) {
                         break;
                     }
                 }
@@ -294,7 +297,7 @@
     public String scanName() throws IOException {
         // load more characters, if needed
         if (fCurrentEntity.position == fCurrentEntity.count) {
-            load(0, true);
+            load(0, true, true);
         }
 
         // scan name
@@ -305,7 +308,7 @@
             if (++fCurrentEntity.position == fCurrentEntity.count) {
                 fCurrentEntity.ch[0] = ch;
                 offset = 0;
-                if (load(1, false)) {
+                if (load(1, false, true)) {
                     fCurrentEntity.columnNumber++;
                     String symbol = fSymbolTable.addSymbol(fCurrentEntity.ch, 0, 1);
                     return symbol;
@@ -316,7 +319,7 @@
             if (++fCurrentEntity.position == fCurrentEntity.count) {
                 fCurrentEntity.ch[0] = ch;
                 offset = 0;
-                if (load(1, false)) {
+                if (load(1, false, true)) {
                     --fCurrentEntity.position;
                     --fCurrentEntity.startPosition;
                     return null;
@@ -332,7 +335,7 @@
                 fCurrentEntity.ch[0] = ch;
                 fCurrentEntity.ch[1] = ch2;
                 offset = 0;
-                if (load(2, false)) {
+                if (load(2, false, true)) {
                     fCurrentEntity.columnNumber += 2;
                     String symbol = fSymbolTable.addSymbol(fCurrentEntity.ch, 0, 2);
                     return symbol;
@@ -348,6 +351,7 @@
             if (XML11Char.isXML11Name(ch)) {
                 if (++fCurrentEntity.position == fCurrentEntity.count) {
                     int length = fCurrentEntity.position - offset;
+                    invokeListeners(length);
                     if (length == fCurrentEntity.ch.length) {
                         // bad luck we have to resize our buffer
                         char[] tmp = new char[fCurrentEntity.ch.length << 1];
@@ -360,7 +364,7 @@
                                          fCurrentEntity.ch, 0, length);
                     }
                     offset = 0;
-                    if (load(length, false)) {
+                    if (load(length, false, false)) {
                         break;
                     }
                 }
@@ -368,6 +372,7 @@
             else if (XML11Char.isXML11NameHighSurrogate(ch)) {
                 if (++fCurrentEntity.position == fCurrentEntity.count) {
                     int length = fCurrentEntity.position - offset;
+                    invokeListeners(length);
                     if (length == fCurrentEntity.ch.length) {
                         // bad luck we have to resize our buffer
                         char[] tmp = new char[fCurrentEntity.ch.length << 1];
@@ -380,7 +385,7 @@
                                          fCurrentEntity.ch, 0, length);
                     }
                     offset = 0;
-                    if (load(length, false)) {
+                    if (load(length, false, false)) {
                         --fCurrentEntity.position;
                         --fCurrentEntity.startPosition;
                         break;
@@ -394,6 +399,7 @@
                 }
                 if (++fCurrentEntity.position == fCurrentEntity.count) {
                     int length = fCurrentEntity.position - offset;
+                    invokeListeners(length);
                     if (length == fCurrentEntity.ch.length) {
                         // bad luck we have to resize our buffer
                         char[] tmp = new char[fCurrentEntity.ch.length << 1];
@@ -406,7 +412,7 @@
                                          fCurrentEntity.ch, 0, length);
                     }
                     offset = 0;
-                    if (load(length, false)) {
+                    if (load(length, false, false)) {
                         break;
                     }
                 }
@@ -449,7 +455,7 @@
 
         // load more characters, if needed
         if (fCurrentEntity.position == fCurrentEntity.count) {
-            load(0, true);
+            load(0, true, true);
         }
 
         // scan name
@@ -460,7 +466,7 @@
             if (++fCurrentEntity.position == fCurrentEntity.count) {
                 fCurrentEntity.ch[0] = ch;
                 offset = 0;
-                if (load(1, false)) {
+                if (load(1, false, true)) {
                     fCurrentEntity.columnNumber++;
                     String symbol = fSymbolTable.addSymbol(fCurrentEntity.ch, 0, 1);
                     return symbol;
@@ -471,7 +477,7 @@
             if (++fCurrentEntity.position == fCurrentEntity.count) {
                 fCurrentEntity.ch[0] = ch;
                 offset = 0;
-                if (load(1, false)) {
+                if (load(1, false, true)) {
                     --fCurrentEntity.position;
                     --fCurrentEntity.startPosition;
                     return null;
@@ -487,7 +493,7 @@
                 fCurrentEntity.ch[0] = ch;
                 fCurrentEntity.ch[1] = ch2;
                 offset = 0;
-                if (load(2, false)) {
+                if (load(2, false, true)) {
                     fCurrentEntity.columnNumber += 2;
                     String symbol = fSymbolTable.addSymbol(fCurrentEntity.ch, 0, 2);
                     return symbol;
@@ -503,6 +509,7 @@
             if (XML11Char.isXML11NCName(ch)) {
                 if (++fCurrentEntity.position == fCurrentEntity.count) {
                     int length = fCurrentEntity.position - offset;
+                    invokeListeners(length);
                     if (length == fCurrentEntity.ch.length) {
                         // bad luck we have to resize our buffer
                         char[] tmp = new char[fCurrentEntity.ch.length << 1];
@@ -515,7 +522,7 @@
                                          fCurrentEntity.ch, 0, length);
                     }
                     offset = 0;
-                    if (load(length, false)) {
+                    if (load(length, false, false)) {
                         break;
                     }
                 }
@@ -523,6 +530,7 @@
             else if (XML11Char.isXML11NameHighSurrogate(ch)) {
                 if (++fCurrentEntity.position == fCurrentEntity.count) {
                     int length = fCurrentEntity.position - offset;
+                    invokeListeners(length);
                     if (length == fCurrentEntity.ch.length) {
                         // bad luck we have to resize our buffer
                         char[] tmp = new char[fCurrentEntity.ch.length << 1];
@@ -535,7 +543,7 @@
                                          fCurrentEntity.ch, 0, length);
                     }
                     offset = 0;
-                    if (load(length, false)) {
+                    if (load(length, false, false)) {
                         --fCurrentEntity.startPosition;
                         --fCurrentEntity.position;
                         break;
@@ -549,6 +557,7 @@
                 }
                 if (++fCurrentEntity.position == fCurrentEntity.count) {
                     int length = fCurrentEntity.position - offset;
+                    invokeListeners(length);
                     if (length == fCurrentEntity.ch.length) {
                         // bad luck we have to resize our buffer
                         char[] tmp = new char[fCurrentEntity.ch.length << 1];
@@ -561,7 +570,7 @@
                                          fCurrentEntity.ch, 0, length);
                     }
                     offset = 0;
-                    if (load(length, false)) {
+                    if (load(length, false, false)) {
                         break;
                     }
                 }
@@ -610,7 +619,7 @@
 
         // load more characters, if needed
         if (fCurrentEntity.position == fCurrentEntity.count) {
-            load(0, true);
+            load(0, true, true);
         }
 
         // scan qualified name
@@ -621,7 +630,7 @@
             if (++fCurrentEntity.position == fCurrentEntity.count) {
                 fCurrentEntity.ch[0] = ch;
                 offset = 0;
-                if (load(1, false)) {
+                if (load(1, false, true)) {
                     fCurrentEntity.columnNumber++;
                     String name = fSymbolTable.addSymbol(fCurrentEntity.ch, 0, 1);
                     qname.setValues(null, name, name, null);
@@ -633,7 +642,7 @@
             if (++fCurrentEntity.position == fCurrentEntity.count) {
                 fCurrentEntity.ch[0] = ch;
                 offset = 0;
-                if (load(1, false)) {
+                if (load(1, false, true)) {
                     --fCurrentEntity.startPosition;
                     --fCurrentEntity.position;
                     return false;
@@ -649,7 +658,7 @@
                 fCurrentEntity.ch[0] = ch;
                 fCurrentEntity.ch[1] = ch2;
                 offset = 0;
-                if (load(2, false)) {
+                if (load(2, false, true)) {
                     fCurrentEntity.columnNumber += 2;
                     String name = fSymbolTable.addSymbol(fCurrentEntity.ch, 0, 2);
                     qname.setValues(null, name, name, null);
@@ -674,6 +683,7 @@
                 }
                 if (++fCurrentEntity.position == fCurrentEntity.count) {
                     int length = fCurrentEntity.position - offset;
+                    invokeListeners(length);
                     if (length == fCurrentEntity.ch.length) {
                         // bad luck we have to resize our buffer
                         char[] tmp = new char[fCurrentEntity.ch.length << 1];
@@ -689,7 +699,7 @@
                         index = index - offset;
                     }
                     offset = 0;
-                    if (load(length, false)) {
+                    if (load(length, false, false)) {
                         break;
                     }
                 }
@@ -697,6 +707,7 @@
             else if (XML11Char.isXML11NameHighSurrogate(ch)) {
                 if (++fCurrentEntity.position == fCurrentEntity.count) {
                     int length = fCurrentEntity.position - offset;
+                    invokeListeners(length);
                     if (length == fCurrentEntity.ch.length) {
                         // bad luck we have to resize our buffer
                         char[] tmp = new char[fCurrentEntity.ch.length << 1];
@@ -712,7 +723,7 @@
                         index = index - offset;
                     }
                     offset = 0;
-                    if (load(length, false)) {
+                    if (load(length, false, false)) {
                         sawIncompleteSurrogatePair = true;
                         --fCurrentEntity.startPosition;
                         --fCurrentEntity.position;
@@ -728,6 +739,7 @@
                 }
                 if (++fCurrentEntity.position == fCurrentEntity.count) {
                     int length = fCurrentEntity.position - offset;
+                    invokeListeners(length);
                     if (length == fCurrentEntity.ch.length) {
                         // bad luck we have to resize our buffer
                         char[] tmp = new char[fCurrentEntity.ch.length << 1];
@@ -743,7 +755,7 @@
                         index = index - offset;
                     }
                     offset = 0;
-                    if (load(length, false)) {
+                    if (load(length, false, false)) {
                         break;
                     }
                 }
@@ -820,11 +832,11 @@
 
         // load more characters, if needed
         if (fCurrentEntity.position == fCurrentEntity.count) {
-            load(0, true);
+            load(0, true, true);
         }
         else if (fCurrentEntity.position == fCurrentEntity.count - 1) {
             fCurrentEntity.ch[0] = fCurrentEntity.ch[fCurrentEntity.count - 1];
-            load(1, false);
+            load(1, false, true);
             fCurrentEntity.position = 0;
             fCurrentEntity.startPosition = 0;
         }
@@ -846,7 +858,7 @@
                         fCurrentEntity.baseCharOffset += (fCurrentEntity.position - fCurrentEntity.startPosition);
                         fCurrentEntity.position = newlines;
                         fCurrentEntity.startPosition = newlines;
-                        if (load(newlines, false)) {
+                        if (load(newlines, false, true)) {
                             break;
                         }
                     }
@@ -869,7 +881,7 @@
                         fCurrentEntity.baseCharOffset += (fCurrentEntity.position - fCurrentEntity.startPosition);
                         fCurrentEntity.position = newlines;
                         fCurrentEntity.startPosition = newlines;
-                        if (load(newlines, false)) {
+                        if (load(newlines, false, true)) {
                             break;
                         }
                     }
@@ -961,11 +973,11 @@
         throws IOException {
         // load more characters, if needed
         if (fCurrentEntity.position == fCurrentEntity.count) {
-            load(0, true);
+            load(0, true, true);
         }
         else if (fCurrentEntity.position == fCurrentEntity.count - 1) {
             fCurrentEntity.ch[0] = fCurrentEntity.ch[fCurrentEntity.count - 1];
-            load(1, false);
+            load(1, false, true);
             fCurrentEntity.startPosition = 0;
             fCurrentEntity.position = 0;
         }
@@ -987,7 +999,7 @@
                         fCurrentEntity.baseCharOffset += (fCurrentEntity.position - fCurrentEntity.startPosition);
                         fCurrentEntity.position = newlines;
                         fCurrentEntity.startPosition = newlines;
-                        if (load(newlines, false)) {
+                        if (load(newlines, false, true)) {
                             break;
                         }
                     }
@@ -1010,7 +1022,7 @@
                         fCurrentEntity.baseCharOffset += (fCurrentEntity.position - fCurrentEntity.startPosition);
                         fCurrentEntity.position = newlines;
                         fCurrentEntity.startPosition = newlines;
-                        if (load(newlines, false)) {
+                        if (load(newlines, false, true)) {
                             break;
                         }
                     }
@@ -1113,7 +1125,7 @@
         do {
             // load more characters, if needed
             if (fCurrentEntity.position == fCurrentEntity.count) {
-                load(0, true);
+                load(0, true, false);
             }
 
             boolean bNextEntity = false;
@@ -1127,7 +1139,7 @@
                                0,
                                fCurrentEntity.count - fCurrentEntity.position);
 
-              bNextEntity = load(fCurrentEntity.count - fCurrentEntity.position, false);
+              bNextEntity = load(fCurrentEntity.count - fCurrentEntity.position, false, false);
               fCurrentEntity.position = 0;
               fCurrentEntity.startPosition = 0;
             }
@@ -1140,7 +1152,7 @@
                 fCurrentEntity.baseCharOffset += (fCurrentEntity.position - fCurrentEntity.startPosition);
                 fCurrentEntity.position = fCurrentEntity.count;
                 fCurrentEntity.startPosition = fCurrentEntity.count;
-                load(0,true);
+                load(0,true, false);
                 return false;
             }
 
@@ -1160,7 +1172,7 @@
                             fCurrentEntity.baseCharOffset += (fCurrentEntity.position - fCurrentEntity.startPosition);
                             fCurrentEntity.position = newlines;
                             fCurrentEntity.startPosition = newlines;
-                            if (load(newlines, false)) {
+                            if (load(newlines, false, true)) {
                                 break;
                             }
                         }
@@ -1184,7 +1196,7 @@
                             fCurrentEntity.position = newlines;
                             fCurrentEntity.startPosition = newlines;
                             fCurrentEntity.count = newlines;
-                            if (load(newlines, false)) {
+                            if (load(newlines, false, true)) {
                                 break;
                             }
                         }
@@ -1309,7 +1321,7 @@
 
         // load more characters, if needed
         if (fCurrentEntity.position == fCurrentEntity.count) {
-            load(0, true);
+            load(0, true, true);
         }
 
         // skip character
@@ -1335,7 +1347,7 @@
             // handle newlines
             if (fCurrentEntity.position == fCurrentEntity.count) {
                 fCurrentEntity.ch[0] = (char)cc;
-                load(1, false);
+                load(1, false, true);
             }
             int ccc = fCurrentEntity.ch[++fCurrentEntity.position];
             if (ccc == '\n' || ccc == 0x85) {
@@ -1369,7 +1381,7 @@
 
         // load more characters, if needed
         if (fCurrentEntity.position == fCurrentEntity.count) {
-            load(0, true);
+            load(0, true, true);
         }
 
 
@@ -1397,7 +1409,7 @@
                         fCurrentEntity.columnNumber = 1;
                         if (fCurrentEntity.position == fCurrentEntity.count - 1) {
                             fCurrentEntity.ch[0] = (char)c;
-                            entityChanged = load(1, true);
+                            entityChanged = load(1, true, true);
                             if (!entityChanged) {
                                 // the load change the position to be 1,
                                 // need to restore it when entity not changed
@@ -1424,7 +1436,7 @@
                     if (!entityChanged)
                         fCurrentEntity.position++;
                     if (fCurrentEntity.position == fCurrentEntity.count) {
-                        load(0, true);
+                        load(0, true, true);
 
                         if(fCurrentEntity == null){
                         return true ;
@@ -1445,7 +1457,7 @@
                     fCurrentEntity.columnNumber = 1;
                     if (fCurrentEntity.position == fCurrentEntity.count - 1) {
                         fCurrentEntity.ch[0] = (char)c;
-                        entityChanged = load(1, true);
+                        entityChanged = load(1, true, true);
                         if (!entityChanged) {
                             // the load change the position to be 1,
                             // need to restore it when entity not changed
@@ -1463,7 +1475,7 @@
                 if (!entityChanged)
                     fCurrentEntity.position++;
                 if (fCurrentEntity.position == fCurrentEntity.count) {
-                    load(0, true);
+                    load(0, true, true);
 
                     if(fCurrentEntity == null){
                         return true ;
@@ -1496,7 +1508,7 @@
 
         // load more characters, if needed
         if (fCurrentEntity.position == fCurrentEntity.count) {
-            load(0, true);
+            load(0, true, true);
         }
 
         // skip string
@@ -1508,10 +1520,11 @@
                 return false;
             }
             if (i < length - 1 && fCurrentEntity.position == fCurrentEntity.count) {
+                invokeListeners(0);
                 System.arraycopy(fCurrentEntity.ch, fCurrentEntity.count - i - 1, fCurrentEntity.ch, 0, i + 1);
                 // REVISIT: Can a string to be skipped cross an
                 //          entity boundary? -Ac
-                if (load(i + 1, false)) {
+                if (load(i + 1, false, false)) {
                     fCurrentEntity.startPosition -= i + 1;
                     fCurrentEntity.position -= i + 1;
                     return false;
--- ./jaxp/src/com/sun/org/apache/xerces/internal/impl/XMLDocumentFragmentScannerImpl.java	Wed Jun 25 09:03:02 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xerces/internal/impl/XMLDocumentFragmentScannerImpl.java	Mon Sep 08 12:15:56 2014 -0700
@@ -612,9 +612,9 @@
         //fElementStack2.clear();
         //fReplaceEntityReferences = true;
         //fSupportExternalEntities = true;
-        Boolean bo = (Boolean)propertyManager.getProperty(XMLInputFactoryImpl.IS_REPLACING_ENTITY_REFERENCES);
+        Boolean bo = (Boolean)propertyManager.getProperty(XMLInputFactory.IS_REPLACING_ENTITY_REFERENCES);
         fReplaceEntityReferences = bo.booleanValue();
-        bo = (Boolean)propertyManager.getProperty(XMLInputFactoryImpl.IS_SUPPORTING_EXTERNAL_ENTITIES);
+        bo = (Boolean)propertyManager.getProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES);
         fSupportExternalEntities = bo.booleanValue();
         Boolean cdata = (Boolean)propertyManager.getProperty(Constants.ZEPHYR_PROPERTY_PREFIX + Constants.STAX_REPORT_CDATA_EVENT) ;
         if(cdata != null)
--- ./jaxp/src/com/sun/org/apache/xerces/internal/impl/XMLEntityManager.java	Wed Jun 25 09:03:02 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xerces/internal/impl/XMLEntityManager.java	Mon Sep 08 12:15:56 2014 -0700
@@ -50,6 +50,7 @@
 import java.util.Map;
 import java.util.Stack;
 import javax.xml.XMLConstants;
+import javax.xml.stream.XMLInputFactory;
 
 
 /**
@@ -302,6 +303,11 @@
     /** Property Manager. This is used from Stax */
     protected PropertyManager fPropertyManager ;
 
+    /** StAX properties */
+    boolean fSupportDTD = true;
+    boolean fReplaceEntityReferences = true;
+    boolean fSupportExternalEntities = true;
+
     /** used to restrict external access */
     protected String fAccessExternalDTD = EXTERNAL_ACCESS_DEFAULT;
 
@@ -1133,7 +1139,8 @@
             boolean parameter = entityName.startsWith("%");
             boolean general = !parameter;
             if (unparsed || (general && !fExternalGeneralEntities) ||
-                    (parameter && !fExternalParameterEntities)) {
+                    (parameter && !fExternalParameterEntities) ||
+                    !fSupportDTD || !fSupportExternalEntities) {
 
                 if (fEntityHandler != null) {
                     fResourceIdentifier.clear();
@@ -1428,6 +1435,10 @@
             fStaxEntityResolver = null;
         }
 
+        fSupportDTD = ((Boolean)propertyManager.getProperty(XMLInputFactory.SUPPORT_DTD)).booleanValue();
+        fReplaceEntityReferences = ((Boolean)propertyManager.getProperty(XMLInputFactory.IS_REPLACING_ENTITY_REFERENCES)).booleanValue();
+        fSupportExternalEntities = ((Boolean)propertyManager.getProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES)).booleanValue();
+
         // Zephyr feature ignore-external-dtd is the opposite of Xerces' load-external-dtd
         fLoadExternalDTD = !((Boolean)propertyManager.getProperty(Constants.ZEPHYR_PROPERTY_PREFIX + Constants.IGNORE_EXTERNAL_DTD)).booleanValue();
 
@@ -1499,6 +1510,11 @@
         fSecurityManager = (XMLSecurityManager)componentManager.getProperty(SECURITY_MANAGER, null);
         entityExpansionIndex = fSecurityManager.getIndex(Constants.JDK_ENTITY_EXPANSION_LIMIT);
 
+        //StAX Property
+        fSupportDTD = true;
+        fReplaceEntityReferences = true;
+        fSupportExternalEntities = true;
+
         // JAXP 1.5 feature
         XMLSecurityPropertyManager spm = (XMLSecurityPropertyManager) componentManager.getProperty(XML_SECURITY_PROPERTY_MANAGER, null);
         if (spm == null) {
--- ./jaxp/src/com/sun/org/apache/xerces/internal/impl/XMLEntityScanner.java	Wed Jun 25 09:03:02 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xerces/internal/impl/XMLEntityScanner.java	Mon Sep 08 12:15:56 2014 -0700
@@ -20,34 +20,28 @@
 
 package com.sun.org.apache.xerces.internal.impl;
 
-import java.io.EOFException;
-import java.io.IOException;
-import java.util.Locale;
-import java.util.Vector;
-
-import com.sun.xml.internal.stream.Entity;
-import com.sun.xml.internal.stream.XMLBufferListener;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.Reader;
 
 
 import com.sun.org.apache.xerces.internal.impl.io.ASCIIReader;
 import com.sun.org.apache.xerces.internal.impl.io.UCSReader;
 import com.sun.org.apache.xerces.internal.impl.io.UTF8Reader;
-
-
 import com.sun.org.apache.xerces.internal.impl.msg.XMLMessageFormatter;
 import com.sun.org.apache.xerces.internal.util.EncodingMap;
-
 import com.sun.org.apache.xerces.internal.util.SymbolTable;
 import com.sun.org.apache.xerces.internal.util.XMLChar;
 import com.sun.org.apache.xerces.internal.util.XMLStringBuffer;
-import com.sun.org.apache.xerces.internal.xni.QName;
-import com.sun.org.apache.xerces.internal.xni.XMLString;
+import com.sun.org.apache.xerces.internal.xni.*;
 import com.sun.org.apache.xerces.internal.xni.parser.XMLComponentManager;
 import com.sun.org.apache.xerces.internal.xni.parser.XMLConfigurationException;
-import com.sun.org.apache.xerces.internal.xni.*;
+import com.sun.xml.internal.stream.Entity;
+import com.sun.xml.internal.stream.XMLBufferListener;
+import java.io.EOFException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.Reader;
+import java.util.Locale;
+import java.util.Vector;
 
 /**
  * Implements the entity scanner methods.
@@ -493,8 +487,7 @@
 
         // load more characters, if needed
         if (fCurrentEntity.position == fCurrentEntity.count) {
-            invokeListeners(0);
-            load(0, true);
+            load(0, true, true);
         }
 
         // peek at character
@@ -535,8 +528,7 @@
 
         // load more characters, if needed
         if (fCurrentEntity.position == fCurrentEntity.count) {
-            invokeListeners(0);
-            load(0, true);
+            load(0, true, true);
         }
 
         // scan character
@@ -546,9 +538,8 @@
             fCurrentEntity.lineNumber++;
             fCurrentEntity.columnNumber = 1;
             if (fCurrentEntity.position == fCurrentEntity.count) {
-                invokeListeners(1);
                 fCurrentEntity.ch[0] = (char)c;
-                load(1, false);
+                load(1, false, true);
             }
             if (c == '\r' && isExternal) {
                 if (fCurrentEntity.ch[fCurrentEntity.position++] != '\n') {
@@ -593,8 +584,7 @@
 
         // load more characters, if needed
         if (fCurrentEntity.position == fCurrentEntity.count) {
-            invokeListeners(0);
-            load(0, true);
+            load(0, true, true);
         }
 
         // scan nmtoken
@@ -626,7 +616,7 @@
                             fCurrentEntity.ch, 0, length);
                 }
                 offset = 0;
-                if (load(length, false)) {
+                if (load(length, false, false)) {
                     break;
                 }
             }
@@ -673,18 +663,16 @@
 
         // load more characters, if needed
         if (fCurrentEntity.position == fCurrentEntity.count) {
-            invokeListeners(0);
-            load(0, true);
+            load(0, true, true);
         }
 
         // scan name
         int offset = fCurrentEntity.position;
         if (XMLChar.isNameStart(fCurrentEntity.ch[offset])) {
             if (++fCurrentEntity.position == fCurrentEntity.count) {
-                invokeListeners(1);
                 fCurrentEntity.ch[0] = fCurrentEntity.ch[offset];
                 offset = 0;
-                if (load(1, false)) {
+                if (load(1, false, true)) {
                     fCurrentEntity.columnNumber++;
                     String symbol = fSymbolTable.addSymbol(fCurrentEntity.ch, 0, 1);
 
@@ -721,7 +709,7 @@
                                 fCurrentEntity.ch, 0, length);
                     }
                     offset = 0;
-                    if (load(length, false)) {
+                    if (load(length, false, false)) {
                         break;
                     }
                 }
@@ -776,8 +764,7 @@
 
         // load more characters, if needed
         if (fCurrentEntity.position == fCurrentEntity.count) {
-            invokeListeners(0);
-            load(0, true);
+            load(0, true, true);
         }
 
         // scan qualified name
@@ -789,11 +776,10 @@
 
         if (XMLChar.isNameStart(fCurrentEntity.ch[offset])) {
             if (++fCurrentEntity.position == fCurrentEntity.count) {
-                invokeListeners(1);
                 fCurrentEntity.ch[0] = fCurrentEntity.ch[offset];
                 offset = 0;
 
-                if (load(1, false)) {
+                if (load(1, false, true)) {
                     fCurrentEntity.columnNumber++;
                     //adding into symbol table.
                     //XXX We are trying to add single character in SymbolTable??????
@@ -843,7 +829,7 @@
                         index = index - offset;
                     }
                     offset = 0;
-                    if (load(length, false)) {
+                    if (load(length, false, false)) {
                         break;
                     }
                 }
@@ -918,12 +904,10 @@
 
         // load more characters, if needed
         if (fCurrentEntity.position == fCurrentEntity.count) {
-            invokeListeners(0);
-            load(0, true);
+            load(0, true, true);
         } else if (fCurrentEntity.position == fCurrentEntity.count - 1) {
-            invokeListeners(0);
             fCurrentEntity.ch[0] = fCurrentEntity.ch[fCurrentEntity.count - 1];
-            load(1, false);
+            load(1, false, true);
             fCurrentEntity.position = 0;
         }
 
@@ -945,9 +929,8 @@
                     fCurrentEntity.columnNumber = 1;
                     if (fCurrentEntity.position == fCurrentEntity.count) {
                         offset = 0;
-                        invokeListeners(newlines);
                         fCurrentEntity.position = newlines;
-                        if (load(newlines, false)) {
+                        if (load(newlines, false, true)) {
                             break;
                         }
                     }
@@ -965,9 +948,8 @@
                     fCurrentEntity.columnNumber = 1;
                     if (fCurrentEntity.position == fCurrentEntity.count) {
                         offset = 0;
-                        invokeListeners(newlines);
                         fCurrentEntity.position = newlines;
-                        if (load(newlines, false)) {
+                        if (load(newlines, false, true)) {
                             break;
                         }
                     }
@@ -1070,13 +1052,10 @@
         }
         // load more characters, if needed
         if (fCurrentEntity.position == fCurrentEntity.count) {
-            invokeListeners(0);
-            load(0, true);
+            load(0, true, true);
         } else if (fCurrentEntity.position == fCurrentEntity.count - 1) {
-            invokeListeners(0);
             fCurrentEntity.ch[0] = fCurrentEntity.ch[fCurrentEntity.count - 1];
-
-            load(1, false);
+            load(1, false, true);
             fCurrentEntity.position = 0;
         }
 
@@ -1099,10 +1078,9 @@
                     fCurrentEntity.lineNumber++;
                     fCurrentEntity.columnNumber = 1;
                     if (fCurrentEntity.position == fCurrentEntity.count) {
-                        invokeListeners(newlines);
                         offset = 0;
                         fCurrentEntity.position = newlines;
-                        if (load(newlines, false)) {
+                        if (load(newlines, false, true)) {
                             break;
                         }
                     }
@@ -1121,9 +1099,8 @@
                     fCurrentEntity.columnNumber = 1;
                     if (fCurrentEntity.position == fCurrentEntity.count) {
                         offset = 0;
-                        invokeListeners(newlines);
                         fCurrentEntity.position = newlines;
-                        if (load(newlines, false)) {
+                        if (load(newlines, false, true)) {
                             break;
                         }
                     }
@@ -1249,7 +1226,7 @@
             // load more characters, if needed
 
             if (fCurrentEntity.position == fCurrentEntity.count) {
-                load(0, true);
+                load(0, true, false);
             }
 
             boolean bNextEntity = false;
@@ -1263,7 +1240,7 @@
                                0,
                                fCurrentEntity.count - fCurrentEntity.position);
 
-              bNextEntity = load(fCurrentEntity.count - fCurrentEntity.position, false);
+              bNextEntity = load(fCurrentEntity.count - fCurrentEntity.position, false, false);
               fCurrentEntity.position = 0;
               fCurrentEntity.startPosition = 0;
             }
@@ -1276,7 +1253,7 @@
                 fCurrentEntity.baseCharOffset += (fCurrentEntity.position - fCurrentEntity.startPosition);
                 fCurrentEntity.position = fCurrentEntity.count;
                 fCurrentEntity.startPosition = fCurrentEntity.count;
-                load(0, true);
+                load(0, true, false);
                 return false;
             }
 
@@ -1298,9 +1275,8 @@
                         fCurrentEntity.columnNumber = 1;
                         if (fCurrentEntity.position == fCurrentEntity.count) {
                             offset = 0;
-                            invokeListeners(newlines);
                             fCurrentEntity.position = newlines;
-                            if (load(newlines, false)) {
+                            if (load(newlines, false, true)) {
                                 break;
                             }
                         }
@@ -1318,10 +1294,9 @@
                         fCurrentEntity.columnNumber = 1;
                         if (fCurrentEntity.position == fCurrentEntity.count) {
                             offset = 0;
-                            invokeListeners(newlines);
                             fCurrentEntity.position = newlines;
                             fCurrentEntity.count = newlines;
-                            if (load(newlines, false)) {
+                            if (load(newlines, false, true)) {
                                 break;
                             }
                         }
@@ -1422,8 +1397,7 @@
 
         // load more characters, if needed
         if (fCurrentEntity.position == fCurrentEntity.count) {
-            invokeListeners(0);
-            load(0, true);
+            load(0, true, true);
         }
 
         // skip character
@@ -1445,9 +1419,8 @@
         } else if (c == '\n' && cc == '\r' && isExternal) {
             // handle newlines
             if (fCurrentEntity.position == fCurrentEntity.count) {
-                invokeListeners(1);
                 fCurrentEntity.ch[0] = (char)cc;
-                load(1, false);
+                load(1, false, true);
             }
             fCurrentEntity.position++;
             if (fCurrentEntity.ch[fCurrentEntity.position] == '\n') {
@@ -1498,8 +1471,7 @@
         //boolean entityChanged = false;
         // load more characters, if needed
         if (fCurrentEntity.position == fCurrentEntity.count) {
-            invokeListeners(0);
-            load(0, true);
+            load(0, true, true);
         }
 
         //we are doing this check only in skipSpace() because it is called by
@@ -1522,9 +1494,8 @@
                     fCurrentEntity.lineNumber++;
                     fCurrentEntity.columnNumber = 1;
                     if (fCurrentEntity.position == fCurrentEntity.count - 1) {
-                        invokeListeners(0);
                         fCurrentEntity.ch[0] = (char)c;
-                        entityChanged = load(1, true);
+                        entityChanged = load(1, true, true);
                         if (!entityChanged){
                             // the load change the position to be 1,
                             // need to restore it when entity not changed
@@ -1549,8 +1520,7 @@
                 }
 
                 if (fCurrentEntity.position == fCurrentEntity.count) {
-                    invokeListeners(0);
-                    load(0, true);
+                    load(0, true, true);
 
                     //we are doing this check only in skipSpace() because it is called by
                     //fMiscDispatcher and we want the parser to exit gracefully when document
@@ -1626,7 +1596,7 @@
             if((fCurrentEntity.count - fCurrentEntity.position) < length){
                 int pos = fCurrentEntity.position;
                 invokeListeners(pos);
-                entityChanged = load(fCurrentEntity.count, changeEntity);
+                entityChanged = load(fCurrentEntity.count, changeEntity, false);
                 fCurrentEntity.position = pos;
                 if(entityChanged)break;
             }
@@ -1731,17 +1701,22 @@
      *                     the current entity in place and the entity
      *                     boundary will be signaled by the return
      *                     value.
+     * @param notify       Determine whether to notify listeners of
+     *                     the event
      *
      * @returns Returns true if the entity changed as a result of this
      *          load operation.
      */
-    final boolean load(int offset, boolean changeEntity)
+    final boolean load(int offset, boolean changeEntity, boolean notify)
     throws IOException {
         if (DEBUG_BUFFER) {
             System.out.print("(load, "+offset+": ");
             print();
             System.out.println();
         }
+        if (notify) {
+            invokeListeners(offset);
+        }
         //maintaing the count till last load
         fCurrentEntity.fTotalCountTillLastLoad = fCurrentEntity.fTotalCountTillLastLoad + fCurrentEntity.fLastCount ;
         // read characters
@@ -1778,7 +1753,7 @@
                 }
                 // handle the trailing edges
                 if (fCurrentEntity.position == fCurrentEntity.count) {
-                    load(0, true);
+                    load(0, true, false);
                 }
             }
 
@@ -2075,7 +2050,7 @@
      *
      * @param loadPos Starting position from which new data is being loaded into scanner buffer.
      */
-    private void invokeListeners(int loadPos){
+    public void invokeListeners(int loadPos){
         for(int i=0;i<listeners.size();i++){
             XMLBufferListener listener =(XMLBufferListener) listeners.get(i);
             listener.refresh(loadPos);
@@ -2108,7 +2083,7 @@
 
         // load more characters, if needed
         if (fCurrentEntity.position == fCurrentEntity.count) {
-            load(0, true);
+            load(0, true, false);
         }
 
         // skip spaces
@@ -2123,7 +2098,7 @@
                     fCurrentEntity.columnNumber = 1;
                     if (fCurrentEntity.position == fCurrentEntity.count - 1) {
                         fCurrentEntity.ch[0] = (char)c;
-                        entityChanged = load(1, true);
+                        entityChanged = load(1, true, false);
                         if (!entityChanged)
                             // the load change the position to be 1,
                             // need to restore it when entity not changed
@@ -2151,7 +2126,7 @@
                 if (!entityChanged)
                     fCurrentEntity.position++;
                 if (fCurrentEntity.position == fCurrentEntity.count) {
-                    load(0, true);
+                    load(0, true, false);
                 }
             } while (XMLChar.isSpace(c = fCurrentEntity.ch[fCurrentEntity.position]));
             if (DEBUG_BUFFER) {
--- ./jaxws/.hgtags	Wed Jun 25 09:03:17 2014 -0700
+++ ./jaxws/.hgtags	Mon Sep 08 12:16:05 2014 -0700
@@ -420,6 +420,7 @@
 3b0da73591b1ea23c48aa7babc34ed776fc183f0 jdk7u55-b13
 5d726bf8fedc1f10d250e980653315919b7602f2 jdk7u55-b30
 81d0f297557c4a876727cabeb2bfcdf066a1fc9d jdk7u55-b14
+f616603ab693f6629c2994f6006ed4a21a428d8e jdk7u55-b15
 2d103c97c9bd0b3357e6d5e2b5b9ffb64c271288 jdk7u55-b31
 b15b4084288fa4ea9caf7f6b4e79d164c77bb1d6 jdk7u55-b32
 efd71c6ca0832e894b7e1619111860062fa96458 jdk7u55-b33
@@ -468,3 +469,36 @@
 198bf1acd262f2c16715d3be5e33d7b8de1e7776 jdk7u65-b16
 df4dc644fe344e973fc1692c28683eec8ba82600 jdk7u65-b17
 0e0ca87a6d5212a0885f0c8c00b8f7cf24a64d89 jdk7u65-b30
+dedfc93eeb5f4b28ad1a91902a0676aef0937e42 jdk7u65-b18
+db4cccbfd72fc265b736a273797963754434a7d2 jdk7u65-b19
+0cd66509e11335fac490076cbdcb2f47c592de86 jdk7u65-b32
+28d868d40df0d420b87698e1215e5039d24a8ae5 jdk7u65-b20
+1ef1681e21ca00edbc8727e849fef50637cc52d8 jdk7u67-b01
+db4cccbfd72fc265b736a273797963754434a7d2 jdk7u65-b40
+190d885fe83b5b1801ee6d7327161254545d55a8 jdk7u65-b31
+6cf7676aa11c053481c0806afda9fc91c2bfd782 jdk7u65-b33
+d63ca1c5bdb9fb2e36ec4afda431c0d1dfdfc07c jdk7u66-b00
+1dce52b208a9528266c26352e03e67ec0ddb4dd7 jdk7u66-b01
+04481967eff566b8a379a0315d2a3a255928d6ce jdk7u66-b09
+73d97ba8b2d94c904f2b087b9f28664eb19e9ce2 jdk7u66-b10
+7ecf8d9df00c185f381fa8cb92ea66fe1e5798ca jdk7u66-b11
+9ac1d99f712a04548d7e5d784f06c87e35023080 jdk7u66-b12
+f562dd8fb2b211a11b9a84849995d61b541723c3 jdk7u66-b13
+ae584331109f291e03af72cc9fcbbe5f8f789ab1 jdk7u66-b14
+36461c772d3101a8cb1eca16a9c81ed53218a4c9 jdk7u66-b15
+19ed8a653a3e8c6536fd1090c14f93e690eda7a3 jdk7u66-b16
+ea1e6f01f95c9a0984378643754d0f493bfa4484 jdk7u66-b17
+6092d0059338df25e82fbc69cc749b95e2565547 jdk7u71-b00
+814a3f0bb13071666375dd35bab7c9cc44c62448 jdk7u71-b01
+ba22fdc22c0410b91f6f992e480d9e8b4c5e85d0 jdk7u71-b02
+30edf4d8760f96b420bd40a2d9552826435356d4 jdk7u71-b03
+22cc8b125a119f9c23d0e81fc6627af330a27e4a jdk7u71-b04
+f612dbc0589894463f569fba245a98f842182d7a jdk7u71-b05
+15bdfc8b209a7c5b4e06907df11d3f795d326c14 jdk7u71-b06
+26ad03c06f31c516329059c5f053330570455887 jdk7u71-b07
+8d9d92a8e6d8610994d1596961395a4ce2bc5a69 jdk7u71-b08
+9ad7bbe28aecaf22c4f5c9ab905207ae963ec2c2 jdk7u71-b09
+32406b446fd458c6d0d8bd610eeb12d96a5f20a4 jdk7u71-b10
+b37043cee55ed025b04a3420908897e69c6c687f jdk7u71-b11
+3a432d7f01ed998ee6ca2ed04e818849a3d1e0c7 jdk7u71-b12
+9dd0dea849dd2550b58346977d9111717c1f38b2 jdk7u71-b13
--- ./jdk/.hgtags	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/.hgtags	Mon Sep 08 12:16:34 2014 -0700
@@ -404,6 +404,7 @@
 92fd166252c2701092a510002f4cf9285a20473d jdk7u55-b13
 4a5651c84b1e6cf26dc9b19f00747e5004efba68 jdk7u55-b30
 ffd99c5975217a14609851602c5f5dc005234aba jdk7u55-b14
+a015a0971dacd536f1ab92bf9bcf0dafb7684e61 jdk7u55-b15
 88f1bf248cc520e0bf7ef17bc862f87aab958373 jdk7u55-b31
 b83f5194edf23b752fe2c0a9be361455f87196df jdk7u55-b32
 01a4cd03a6c85abb62eb5d1c2b5bf7d2f544c04e jdk7u55-b33
@@ -452,3 +453,36 @@
 190017413768f02addea8b2c5106157e3c4076c7 jdk7u65-b16
 23e78e36bc39f4f761ac2b0e055c562c3ff204f5 jdk7u65-b17
 96d1fa382dda17ae105f28083bda41f79fc3093f jdk7u65-b30
+7f7430459adfe7b7fb65da8c3fac2ac5e3495ea1 jdk7u65-b18
+ba6cef21c369076be97dd8133fd4a158cd486bd8 jdk7u65-b19
+c3a56021fc22f886106f123d4f25b385ac6b79d7 jdk7u65-b32
+8b9d926bd35adceb99f244b7b068fedb0f220f03 jdk7u65-b20
+5cf343beab2ce73d299d4f1a8f3b95892f9fd818 jdk7u67-b01
+ba6cef21c369076be97dd8133fd4a158cd486bd8 jdk7u65-b40
+7b47a34063e94e1ab5636b11231d33fae92754c9 jdk7u65-b31
+4cb63f8ca9ee8c60d6f3d0051b69acc8392bd8de jdk7u65-b33
+9ccfe70cee626ac7831cfa7b7a7eb7a88fe1cd42 jdk7u66-b00
+fc87b55d62fc1e81aaf61ff21175129b8ccc302e jdk7u66-b01
+c67e394e49429565540f04c5c2a5544f750658bb jdk7u66-b09
+257fd79cdef52511db18e1bab8967d94a03920bc jdk7u66-b10
+6f38c929df1b9d6df7760b2eb9bf3e4681a27c56 jdk7u66-b11
+d4f0008cdf6d3ec8e8e210c03e55aaa751647e8d jdk7u66-b12
+24b7c3d0942766af3415dd6125b9b8da059dbccc jdk7u66-b13
+74d01c3385b915490255cd7467a3740aa3dce310 jdk7u66-b14
+07fc91c550da6ba689e3abc9e688edcb73f9c95c jdk7u66-b15
+d4814cafa25f5b076be9e99be2a8c0d98929476d jdk7u66-b16
+69adfb3ccee5373438a6c394646c2c5ab93c89ee jdk7u66-b17
+ee0cedc50d3250edf24e96aecc785580dd61944f jdk7u71-b00
+6c865d8ab14093e4ef95e7c548c432e4bf887760 jdk7u71-b01
+829ca47df2ced2d0dc330391bf7578363369b92b jdk7u71-b02
+5b9e9506bd57763c958ea6fcff99b03d47942b9d jdk7u71-b03
+347bc2b7831097ea373ef7be72bfbf0ba3de4b7f jdk7u71-b04
+3019595da91688c79f617cf737431a2acee3ef71 jdk7u71-b05
+0a05fabc719fe6c1ed02678d255f1250b32c30ed jdk7u71-b06
+48db48aab05e47cafc37b277f68a0e2ff5f1f0b6 jdk7u71-b07
+9ff013674339cb269280bfb4eaba40bba0584c40 jdk7u71-b08
+7e47a971eff7d78a459c23ee0d44b8f6c6c4c812 jdk7u71-b09
+919e84964279a058da2c8d4088c570c19543979f jdk7u71-b10
+1108ab8e3dce0318529b4bcda46ce895659bb09b jdk7u71-b11
+ae4e88c495851c43862e2fc3d1ff7b64c68f368c jdk7u71-b12
+a6cbc82d62f915cdcd6037c8b40a4590585553c7 jdk7u71-b13
--- ./jdk/make/java/net/FILES_c.gmk	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/make/java/net/FILES_c.gmk	Mon Sep 08 12:16:34 2014 -0700
@@ -24,6 +24,7 @@
 #
 
 FILES_c = \
+        AbstractPlainDatagramSocketImpl.c \
         DatagramPacket.c \
         InetAddress.c \
         Inet4Address.c \
--- ./jdk/make/java/net/mapfile-vers	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/make/java/net/mapfile-vers	Mon Sep 08 12:16:34 2014 -0700
@@ -28,6 +28,8 @@
 SUNWprivate_1.1 {
         global:
                 JNI_OnLoad;
+                Java_java_net_AbstractPlainDatagramSocketImpl_init;
+                Java_java_net_AbstractPlainDatagramSocketImpl_dataAvailable;
                 Java_java_net_PlainSocketImpl_socketListen;
                 Java_java_net_PlainDatagramSocketImpl_getTTL;
                 Java_java_net_PlainDatagramSocketImpl_init;
--- ./jdk/src/macosx/classes/sun/lwawt/macosx/CPlatformWindow.java	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/macosx/classes/sun/lwawt/macosx/CPlatformWindow.java	Mon Sep 08 12:16:34 2014 -0700
@@ -580,7 +580,12 @@
         if (visible) {
             // Apply the extended state as expected in shared code
             if (target instanceof Frame) {
-                switch (((Frame)target).getExtendedState()) {
+                int frameState = ((Frame)target).getExtendedState();
+                if ((frameState & Frame.ICONIFIED) != 0) {
+                    // Treat all state bit masks with ICONIFIED bit as ICONIFIED state.
+                    frameState = Frame.ICONIFIED;
+                }
+                switch (frameState) {
                     case Frame.ICONIFIED:
                         CWrapper.NSWindow.miniaturize(nsWindowPtr);
                         break;
@@ -806,6 +811,10 @@
         if (prevWindowState == windowState) return;
 
         final long nsWindowPtr = getNSWindowPtr();
+        if ((windowState & Frame.ICONIFIED) != 0) {
+            // Treat all state bit masks with ICONIFIED bit as ICONIFIED state.
+            windowState = Frame.ICONIFIED;
+        }
         switch (windowState) {
             case Frame.ICONIFIED:
                 if (prevWindowState == Frame.MAXIMIZED_BOTH) {
--- ./jdk/src/share/classes/com/sun/accessibility/internal/resources/accessibility_zh_TW.properties	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/classes/com/sun/accessibility/internal/resources/accessibility_zh_TW.properties	Mon Sep 08 12:16:34 2014 -0700
@@ -44,7 +44,7 @@
 popupmenu=\u5373\u73FE\u5F0F\u529F\u80FD\u8868
 progressbar=\u9032\u5EA6\u5217
 pushbutton=\u4E0B\u58D3\u6309\u9215
-radiobutton=\u55AE\u9078\u9215
+radiobutton=\u5713\u9215
 rootpane=root \u7A97\u683C
 rowheader=\u5217\u6A19\u984C
 scrollbar=\u6372\u8EF8
--- ./jdk/src/share/classes/com/sun/java/swing/plaf/windows/resources/windows_sv.properties	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/classes/com/sun/java/swing/plaf/windows/resources/windows_sv.properties	Mon Sep 08 12:16:34 2014 -0700
@@ -22,7 +22,7 @@
 FileChooser.saveInLabel.textAndMnemonic=Spara i:
 FileChooser.fileNameLabel.textAndMnemonic=Fil&namn:
 FileChooser.folderNameLabel.textAndMnemonic=Mapp&namn:
-FileChooser.filesOfTypeLabel.textAndMnemonic=Filer av &typ:
+FileChooser.filesOfTypeLabel.textAndMnemonic=Filer av &typen:
 FileChooser.upFolderToolTip.textAndMnemonic=Upp en niv\u00E5
 FileChooser.upFolderAccessibleName=Upp
 FileChooser.homeFolderToolTip.textAndMnemonic=Hem
--- ./jdk/src/share/classes/com/sun/org/apache/xml/internal/security/Init.java	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/classes/com/sun/org/apache/xml/internal/security/Init.java	Mon Sep 08 12:16:34 2014 -0700
@@ -25,6 +25,8 @@
 import java.io.InputStream;
 import java.security.AccessController;
 import java.security.PrivilegedAction;
+import java.security.PrivilegedActionException;
+import java.security.PrivilegedExceptionAction;
 import java.util.ArrayList;
 import java.util.List;
 
@@ -35,6 +37,7 @@
 import com.sun.org.apache.xml.internal.security.algorithms.JCEMapper;
 import com.sun.org.apache.xml.internal.security.algorithms.SignatureAlgorithm;
 import com.sun.org.apache.xml.internal.security.c14n.Canonicalizer;
+import com.sun.org.apache.xml.internal.security.exceptions.XMLSecurityException;
 import com.sun.org.apache.xml.internal.security.keys.keyresolver.KeyResolver;
 import com.sun.org.apache.xml.internal.security.transforms.Transform;
 import com.sun.org.apache.xml.internal.security.utils.ElementProxy;
@@ -118,43 +121,50 @@
             log.log(java.util.logging.Level.FINE, "Registering default algorithms");
         }
         try {
-            //
-            // Bind the default prefixes
-            //
-            ElementProxy.registerDefaultPrefixes();
+            AccessController.doPrivileged(new PrivilegedExceptionAction<Void>(){
+                @Override public Void run() throws XMLSecurityException {
+                    //
+                    // Bind the default prefixes
+                    //
+                    ElementProxy.registerDefaultPrefixes();
 
-            //
-            // Set the default Transforms
-            //
-            Transform.registerDefaultAlgorithms();
+                    //
+                    // Set the default Transforms
+                    //
+                    Transform.registerDefaultAlgorithms();
 
-            //
-            // Set the default signature algorithms
-            //
-            SignatureAlgorithm.registerDefaultAlgorithms();
+                    //
+                    // Set the default signature algorithms
+                    //
+                    SignatureAlgorithm.registerDefaultAlgorithms();
 
-            //
-            // Set the default JCE algorithms
-            //
-            JCEMapper.registerDefaultAlgorithms();
+                    //
+                    // Set the default JCE algorithms
+                    //
+                    JCEMapper.registerDefaultAlgorithms();
 
-            //
-            // Set the default c14n algorithms
-            //
-            Canonicalizer.registerDefaultAlgorithms();
+                    //
+                    // Set the default c14n algorithms
+                    //
+                    Canonicalizer.registerDefaultAlgorithms();
 
-            //
-            // Register the default resolvers
-            //
-            ResourceResolver.registerDefaultResolvers();
+                    //
+                    // Register the default resolvers
+                    //
+                    ResourceResolver.registerDefaultResolvers();
 
-            //
-            // Register the default key resolvers
-            //
-            KeyResolver.registerDefaultResolvers();
-        } catch (Exception ex) {
-            log.log(java.util.logging.Level.SEVERE, ex.getMessage(), ex);
-            ex.printStackTrace();
+                    //
+                    // Register the default key resolvers
+                    //
+                    KeyResolver.registerDefaultResolvers();
+
+                    return null;
+                }
+           });
+        } catch (PrivilegedActionException ex) {
+            XMLSecurityException xse = (XMLSecurityException)ex.getException();
+            log.log(java.util.logging.Level.SEVERE, xse.getMessage(), xse);
+            xse.printStackTrace();
         }
     }
 
--- ./jdk/src/share/classes/com/sun/org/apache/xml/internal/security/algorithms/JCEMapper.java	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/classes/com/sun/org/apache/xml/internal/security/algorithms/JCEMapper.java	Mon Sep 08 12:16:34 2014 -0700
@@ -27,6 +27,7 @@
 
 import com.sun.org.apache.xml.internal.security.encryption.XMLCipher;
 import com.sun.org.apache.xml.internal.security.signature.XMLSignature;
+import com.sun.org.apache.xml.internal.security.utils.JavaUtils;
 import org.w3c.dom.Element;
 
 
@@ -49,8 +50,11 @@
      *
      * @param id
      * @param algorithm
+     * @throws SecurityException if a security manager is installed and the
+     *    caller does not have permission to register the JCE algorithm
      */
     public static void register(String id, Algorithm algorithm) {
+        JavaUtils.checkRegisterPermission();
         algorithmsMap.put(id, algorithm);
     }
 
@@ -264,8 +268,11 @@
     /**
      * Sets the default Provider for obtaining the security algorithms
      * @param provider the default providerId.
+     * @throws SecurityException if a security manager is installed and the
+     *    caller does not have permission to set the JCE provider
      */
     public static void setProviderId(String provider) {
+        JavaUtils.checkRegisterPermission();
         providerName = provider;
     }
 
--- ./jdk/src/share/classes/com/sun/org/apache/xml/internal/security/algorithms/SignatureAlgorithm.java	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/classes/com/sun/org/apache/xml/internal/security/algorithms/SignatureAlgorithm.java	Mon Sep 08 12:16:34 2014 -0700
@@ -37,6 +37,7 @@
 import com.sun.org.apache.xml.internal.security.signature.XMLSignature;
 import com.sun.org.apache.xml.internal.security.signature.XMLSignatureException;
 import com.sun.org.apache.xml.internal.security.utils.Constants;
+import com.sun.org.apache.xml.internal.security.utils.JavaUtils;
 import org.w3c.dom.Attr;
 import org.w3c.dom.Document;
 import org.w3c.dom.Element;
@@ -314,18 +315,21 @@
     }
 
     /**
-     * Registers implementing class of the Transform algorithm with algorithmURI
+     * Registers implementing class of the SignatureAlgorithm with algorithmURI
      *
-     * @param algorithmURI algorithmURI URI representation of <code>Transform algorithm</code>.
+     * @param algorithmURI algorithmURI URI representation of <code>SignatureAlgorithm</code>.
      * @param implementingClass <code>implementingClass</code> the implementing class of
      * {@link SignatureAlgorithmSpi}
      * @throws AlgorithmAlreadyRegisteredException if specified algorithmURI is already registered
      * @throws XMLSignatureException
+     * @throws SecurityException if a security manager is installed and the
+     *    caller does not have permission to register the signature algorithm
      */
     @SuppressWarnings("unchecked")
     public static void register(String algorithmURI, String implementingClass)
        throws AlgorithmAlreadyRegisteredException, ClassNotFoundException,
            XMLSignatureException {
+        JavaUtils.checkRegisterPermission();
         if (log.isLoggable(java.util.logging.Level.FINE)) {
             log.log(java.util.logging.Level.FINE, "Try to register " + algorithmURI + " " + implementingClass);
         }
@@ -352,15 +356,18 @@
     /**
      * Registers implementing class of the Transform algorithm with algorithmURI
      *
-     * @param algorithmURI algorithmURI URI representation of <code>Transform algorithm</code>.
+     * @param algorithmURI algorithmURI URI representation of <code>SignatureAlgorithm</code>.
      * @param implementingClass <code>implementingClass</code> the implementing class of
      * {@link SignatureAlgorithmSpi}
      * @throws AlgorithmAlreadyRegisteredException if specified algorithmURI is already registered
      * @throws XMLSignatureException
+     * @throws SecurityException if a security manager is installed and the
+     *    caller does not have permission to register the signature algorithm
      */
     public static void register(String algorithmURI, Class<? extends SignatureAlgorithmSpi> implementingClass)
        throws AlgorithmAlreadyRegisteredException, ClassNotFoundException,
            XMLSignatureException {
+        JavaUtils.checkRegisterPermission();
         if (log.isLoggable(java.util.logging.Level.FINE)) {
             log.log(java.util.logging.Level.FINE, "Try to register " + algorithmURI + " " + implementingClass);
         }
--- ./jdk/src/share/classes/com/sun/org/apache/xml/internal/security/c14n/Canonicalizer.java	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/classes/com/sun/org/apache/xml/internal/security/c14n/Canonicalizer.java	Mon Sep 08 12:16:34 2014 -0700
@@ -40,6 +40,7 @@
 import com.sun.org.apache.xml.internal.security.c14n.implementations.Canonicalizer20010315OmitComments;
 import com.sun.org.apache.xml.internal.security.c14n.implementations.Canonicalizer20010315WithComments;
 import com.sun.org.apache.xml.internal.security.exceptions.AlgorithmAlreadyRegisteredException;
+import com.sun.org.apache.xml.internal.security.utils.JavaUtils;
 import org.w3c.dom.Document;
 import org.w3c.dom.Node;
 import org.w3c.dom.NodeList;
@@ -136,10 +137,13 @@
      * @param algorithmURI
      * @param implementingClass
      * @throws AlgorithmAlreadyRegisteredException
+     * @throws SecurityException if a security manager is installed and the
+     *    caller does not have permission to register the canonicalizer
      */
     @SuppressWarnings("unchecked")
     public static void register(String algorithmURI, String implementingClass)
         throws AlgorithmAlreadyRegisteredException, ClassNotFoundException {
+        JavaUtils.checkRegisterPermission();
         // check whether URI is already registered
         Class<? extends CanonicalizerSpi> registeredClass =
             canonicalizerHash.get(algorithmURI);
@@ -160,9 +164,12 @@
      * @param algorithmURI
      * @param implementingClass
      * @throws AlgorithmAlreadyRegisteredException
+     * @throws SecurityException if a security manager is installed and the
+     *    caller does not have permission to register the canonicalizer
      */
-    public static void register(String algorithmURI, Class<CanonicalizerSpi> implementingClass)
+    public static void register(String algorithmURI, Class<? extends CanonicalizerSpi> implementingClass)
         throws AlgorithmAlreadyRegisteredException, ClassNotFoundException {
+        JavaUtils.checkRegisterPermission();
         // check whether URI is already registered
         Class<? extends CanonicalizerSpi> registeredClass = canonicalizerHash.get(algorithmURI);
 
--- ./jdk/src/share/classes/com/sun/org/apache/xml/internal/security/keys/keyresolver/KeyResolver.java	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/classes/com/sun/org/apache/xml/internal/security/keys/keyresolver/KeyResolver.java	Mon Sep 08 12:16:34 2014 -0700
@@ -39,6 +39,7 @@
 import com.sun.org.apache.xml.internal.security.keys.keyresolver.implementations.X509SKIResolver;
 import com.sun.org.apache.xml.internal.security.keys.keyresolver.implementations.X509SubjectNameResolver;
 import com.sun.org.apache.xml.internal.security.keys.storage.StorageResolver;
+import com.sun.org.apache.xml.internal.security.utils.JavaUtils;
 import org.w3c.dom.Element;
 import org.w3c.dom.Node;
 
@@ -172,9 +173,12 @@
      * @throws InstantiationException
      * @throws IllegalAccessException
      * @throws ClassNotFoundException
+     * @throws SecurityException if a security manager is installed and the
+     *    caller does not have permission to register the key resolver
      */
     public static void register(String className, boolean globalResolver)
         throws ClassNotFoundException, IllegalAccessException, InstantiationException {
+        JavaUtils.checkRegisterPermission();
         KeyResolverSpi keyResolverSpi =
             (KeyResolverSpi) Class.forName(className).newInstance();
         keyResolverSpi.setGlobalResolver(globalResolver);
@@ -192,8 +196,11 @@
      *
      * @param className
      * @param globalResolver Whether the KeyResolverSpi is a global resolver or not
+     * @throws SecurityException if a security manager is installed and the
+     *    caller does not have permission to register the key resolver
      */
     public static void registerAtStart(String className, boolean globalResolver) {
+        JavaUtils.checkRegisterPermission();
         KeyResolverSpi keyResolverSpi = null;
         Exception ex = null;
         try {
@@ -225,11 +232,14 @@
      *
      * @param keyResolverSpi a KeyResolverSpi instance to register
      * @param start whether to register the KeyResolverSpi at the start of the list or not
+     * @throws SecurityException if a security manager is installed and the
+     *    caller does not have permission to register the key resolver
      */
     public static void register(
         KeyResolverSpi keyResolverSpi,
         boolean start
     ) {
+        JavaUtils.checkRegisterPermission();
         KeyResolver resolver = new KeyResolver(keyResolverSpi);
         if (start) {
             resolverVector.add(0, resolver);
@@ -251,9 +261,12 @@
      * @throws InstantiationException
      * @throws IllegalAccessException
      * @throws ClassNotFoundException
+     * @throws SecurityException if a security manager is installed and the
+     *    caller does not have permission to register the key resolver
      */
     public static void registerClassNames(List<String> classNames)
         throws ClassNotFoundException, IllegalAccessException, InstantiationException {
+        JavaUtils.checkRegisterPermission();
         List<KeyResolver> keyResolverList = new ArrayList<KeyResolver>(classNames.size());
         for (String className : classNames) {
             KeyResolverSpi keyResolverSpi =
--- ./jdk/src/share/classes/com/sun/org/apache/xml/internal/security/transforms/Transform.java	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/classes/com/sun/org/apache/xml/internal/security/transforms/Transform.java	Mon Sep 08 12:16:34 2014 -0700
@@ -46,6 +46,7 @@
 import com.sun.org.apache.xml.internal.security.transforms.implementations.TransformXSLT;
 import com.sun.org.apache.xml.internal.security.utils.Constants;
 import com.sun.org.apache.xml.internal.security.utils.HelperNodeList;
+import com.sun.org.apache.xml.internal.security.utils.JavaUtils;
 import com.sun.org.apache.xml.internal.security.utils.SignatureElementProxy;
 import com.sun.org.apache.xml.internal.security.utils.XMLUtils;
 import org.w3c.dom.Document;
@@ -181,11 +182,14 @@
      * class of {@link TransformSpi}
      * @throws AlgorithmAlreadyRegisteredException if specified algorithmURI
      * is already registered
+     * @throws SecurityException if a security manager is installed and the
+     *    caller does not have permission to register the transform
      */
     @SuppressWarnings("unchecked")
     public static void register(String algorithmURI, String implementingClass)
         throws AlgorithmAlreadyRegisteredException, ClassNotFoundException,
             InvalidTransformException {
+        JavaUtils.checkRegisterPermission();
         // are we already registered?
         Class<? extends TransformSpi> transformSpi = transformSpiHash.get(algorithmURI);
         if (transformSpi != null) {
@@ -206,9 +210,12 @@
      * class of {@link TransformSpi}
      * @throws AlgorithmAlreadyRegisteredException if specified algorithmURI
      * is already registered
+     * @throws SecurityException if a security manager is installed and the
+     *    caller does not have permission to register the transform
      */
     public static void register(String algorithmURI, Class<? extends TransformSpi> implementingClass)
         throws AlgorithmAlreadyRegisteredException {
+        JavaUtils.checkRegisterPermission();
         // are we already registered?
         Class<? extends TransformSpi> transformSpi = transformSpiHash.get(algorithmURI);
         if (transformSpi != null) {
--- ./jdk/src/share/classes/com/sun/org/apache/xml/internal/security/utils/ElementProxy.java	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/classes/com/sun/org/apache/xml/internal/security/utils/ElementProxy.java	Mon Sep 08 12:16:34 2014 -0700
@@ -468,9 +468,12 @@
      * @param namespace
      * @param prefix
      * @throws XMLSecurityException
+     * @throws SecurityException if a security manager is installed and the
+     *    caller does not have permission to set the default prefix
      */
     public static void setDefaultPrefix(String namespace, String prefix)
         throws XMLSecurityException {
+        JavaUtils.checkRegisterPermission();
         if (prefixMappings.containsValue(prefix)) {
             String storedPrefix = prefixMappings.get(namespace);
             if (!storedPrefix.equals(prefix)) {
--- ./jdk/src/share/classes/com/sun/org/apache/xml/internal/security/utils/JavaUtils.java	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/classes/com/sun/org/apache/xml/internal/security/utils/JavaUtils.java	Mon Sep 08 12:16:34 2014 -0700
@@ -26,6 +26,7 @@
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
+import java.security.SecurityPermission;
 
 /**
  * A collection of different, general-purpose methods for JAVA-specific things
@@ -37,6 +38,10 @@
     static java.util.logging.Logger log =
         java.util.logging.Logger.getLogger(JavaUtils.class.getName());
 
+    private static final SecurityPermission REGISTER_PERMISSION =
+        new SecurityPermission(
+            "com.sun.org.apache.xml.internal.security.register");
+
     private JavaUtils() {
         // we don't allow instantiation
     }
@@ -128,4 +133,21 @@
         refBytes = baos.toByteArray();
         return refBytes;
     }
+
+    /**
+     * Throws a {@code SecurityException} if a security manager is installed
+     * and the caller is not allowed to register an implementation of an
+     * algorithm, transform, or other security sensitive XML Signature function.
+     *
+     * @throws SecurityException if a security manager is installed and the
+     *    caller has not been granted the
+     *    {@literal "com.sun.org.apache.xml.internal.security.register"}
+     *    {@code SecurityPermission}
+     */
+    public static void checkRegisterPermission() {
+        SecurityManager sm = System.getSecurityManager();
+        if (sm != null) {
+            sm.checkPermission(REGISTER_PERMISSION);
+        }
+    }
 }
--- ./jdk/src/share/classes/com/sun/org/apache/xml/internal/security/utils/XMLUtils.java	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/classes/com/sun/org/apache/xml/internal/security/utils/XMLUtils.java	Mon Sep 08 12:16:34 2014 -0700
@@ -79,16 +79,22 @@
     /**
      * Set the prefix for the digital signature namespace
      * @param prefix the new prefix for the digital signature namespace
+     * @throws SecurityException if a security manager is installed and the
+     *    caller does not have permission to set the prefix
      */
     public static void setDsPrefix(String prefix) {
+        JavaUtils.checkRegisterPermission();
         dsPrefix = prefix;
     }
 
     /**
      * Set the prefix for the encryption namespace
      * @param prefix the new prefix for the encryption namespace
+     * @throws SecurityException if a security manager is installed and the
+     *    caller does not have permission to set the prefix
      */
     public static void setXencPrefix(String prefix) {
+        JavaUtils.checkRegisterPermission();
         xencPrefix = prefix;
     }
 
--- ./jdk/src/share/classes/com/sun/org/apache/xml/internal/security/utils/resolver/ResourceResolver.java	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/classes/com/sun/org/apache/xml/internal/security/utils/resolver/ResourceResolver.java	Mon Sep 08 12:16:34 2014 -0700
@@ -27,6 +27,7 @@
 import java.util.Map;
 
 import com.sun.org.apache.xml.internal.security.signature.XMLSignatureInput;
+import com.sun.org.apache.xml.internal.security.utils.JavaUtils;
 import com.sun.org.apache.xml.internal.security.utils.resolver.implementations.ResolverDirectHTTP;
 import com.sun.org.apache.xml.internal.security.utils.resolver.implementations.ResolverFragment;
 import com.sun.org.apache.xml.internal.security.utils.resolver.implementations.ResolverLocalFilesystem;
@@ -192,9 +193,12 @@
      * the class cannot be registered.
      *
      * @param className the name of the ResourceResolverSpi class to be registered
+     * @throws SecurityException if a security manager is installed and the
+     *    caller does not have permission to register a resource resolver
      */
     @SuppressWarnings("unchecked")
     public static void register(String className) {
+        JavaUtils.checkRegisterPermission();
         try {
             Class<ResourceResolverSpi> resourceResolverClass =
                 (Class<ResourceResolverSpi>) Class.forName(className);
@@ -209,9 +213,12 @@
      * list. This method logs a warning if the class cannot be registered.
      *
      * @param className the name of the ResourceResolverSpi class to be registered
+     * @throws SecurityException if a security manager is installed and the
+     *    caller does not have permission to register a resource resolver
      */
     @SuppressWarnings("unchecked")
     public static void registerAtStart(String className) {
+        JavaUtils.checkRegisterPermission();
         try {
             Class<ResourceResolverSpi> resourceResolverClass =
                 (Class<ResourceResolverSpi>) Class.forName(className);
@@ -226,8 +233,11 @@
      * cannot be registered.
      * @param className
      * @param start
+     * @throws SecurityException if a security manager is installed and the
+     *    caller does not have permission to register a resource resolver
      */
     public static void register(Class<? extends ResourceResolverSpi> className, boolean start) {
+        JavaUtils.checkRegisterPermission();
         try {
             ResourceResolverSpi resourceResolverSpi = className.newInstance();
             register(resourceResolverSpi, start);
@@ -243,8 +253,11 @@
      * cannot be registered.
      * @param resourceResolverSpi
      * @param start
+     * @throws SecurityException if a security manager is installed and the
+     *    caller does not have permission to register a resource resolver
      */
     public static void register(ResourceResolverSpi resourceResolverSpi, boolean start) {
+        JavaUtils.checkRegisterPermission();
         synchronized(resolverList) {
             if (start) {
                 resolverList.add(0, new ResourceResolver(resourceResolverSpi));
--- ./jdk/src/share/classes/com/sun/rowset/RowSetResourceBundle_pt_BR.properties	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/classes/com/sun/rowset/RowSetResourceBundle_pt_BR.properties	Mon Sep 08 12:16:34 2014 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2005, 2014, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -153,7 +153,7 @@
 xmlrch.errmetadata = Erro ao definir metadados : {0}
 xmlrch.errinsertval = Erro ao inserir valores : {0}
 xmlrch.errconstr = Erro ao construir a linha : {0}
-xmlrch.errdel = Erro ao deletar a linha : {0}
+xmlrch.errdel = Erro ao excluir a linha : {0}
 xmlrch.errinsert = Erro ao construir a linha de inser\u00E7\u00E3o : {0}
 xmlrch.errinsdel = Erro ao construir a linha insdel : {0}
 xmlrch.errupdate = Erro ao construir a linha de atualiza\u00E7\u00E3o : {0}
--- ./jdk/src/share/classes/com/sun/swing/internal/plaf/metal/resources/metal_sv.properties	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/classes/com/sun/swing/internal/plaf/metal/resources/metal_sv.properties	Mon Sep 08 12:16:34 2014 -0700
@@ -22,7 +22,7 @@
 FileChooser.saveInLabel.textAndMnemonic=Spara i:
 FileChooser.fileNameLabel.textAndMnemonic=&Fil:
 FileChooser.folderNameLabel.textAndMnemonic=&Mapp:
-FileChooser.filesOfTypeLabel.textAndMnemonic=Mapp&namn:
+FileChooser.filesOfTypeLabel.textAndMnemonic=Filer av &typen:
 FileChooser.upFolderToolTip.textAndMnemonic=Upp en niv\u00E5
 FileChooser.upFolderAccessibleName=Upp
 FileChooser.homeFolderToolTip.textAndMnemonic=Hem
--- ./jdk/src/share/classes/com/sun/swing/internal/plaf/synth/resources/synth_sv.properties	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/classes/com/sun/swing/internal/plaf/synth/resources/synth_sv.properties	Mon Sep 08 12:16:34 2014 -0700
@@ -22,7 +22,7 @@
 FileChooser.saveInLabel.textAndMnemonic=Spara i:
 FileChooser.fileNameLabel.textAndMnemonic=Fil&namn:
 FileChooser.folderNameLabel.textAndMnemonic=Mapp&namn:
-FileChooser.filesOfTypeLabel.textAndMnemonic=Filer av &typ:
+FileChooser.filesOfTypeLabel.textAndMnemonic=Filer av &typen:
 FileChooser.upFolderToolTip.textAndMnemonic=Upp en niv\u00E5
 FileChooser.upFolderAccessibleName=Upp
 FileChooser.homeFolderToolTip.textAndMnemonic=Hem
--- ./jdk/src/share/classes/com/sun/tools/example/debug/tty/TTYResources_ja.java	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/classes/com/sun/tools/example/debug/tty/TTYResources_ja.java	Mon Sep 08 12:16:34 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -82,7 +82,7 @@
         {"Can only trace", "'methods'\u3001'method exit'\u307E\u305F\u306F'method exits'\u306E\u307F\u30C8\u30EC\u30FC\u30B9\u3067\u304D\u307E\u3059"},
         {"cannot redefine existing connection", "{0}\u306F\u65E2\u5B58\u306E\u63A5\u7D9A\u3092\u518D\u5B9A\u7FA9\u3067\u304D\u307E\u305B\u3093"},
         {"Cannot assign to a method invocation", "\u30E1\u30BD\u30C3\u30C9\u547C\u51FA\u3057\u306B\u5272\u5F53\u3066\u3067\u304D\u307E\u305B\u3093"},
-        {"Cannot specify command line with connector:", "\u30B3\u30CD\u30AF\u30BF\u3067\u30B3\u30DE\u30F3\u30C9\u30E9\u30A4\u30F3\u3092\u6307\u5B9A\u3067\u304D\u307E\u305B\u3093: {0}"},
+        {"Cannot specify command line with connector:", "\u30B3\u30CD\u30AF\u30BF\u3067\u30B3\u30DE\u30F3\u30C9\u884C\u3092\u6307\u5B9A\u3067\u304D\u307E\u305B\u3093: {0}"},
         {"Cannot specify target vm arguments with connector:", "\u30B3\u30CD\u30AF\u30BF\u3067\u30BF\u30FC\u30B2\u30C3\u30C8VM\u5F15\u6570\u3092\u6307\u5B9A\u3067\u304D\u307E\u305B\u3093: {0}"},
         {"Class containing field must be specified.", "\u30D5\u30A3\u30FC\u30EB\u30C9\u3092\u542B\u3080\u30AF\u30E9\u30B9\u3092\u6307\u5B9A\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059\u3002"},
         {"Class:", "\u30AF\u30E9\u30B9: {0}"},
--- ./jdk/src/share/classes/com/sun/tools/jdi/resources/jdi_ja.properties	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/classes/com/sun/tools/jdi/resources/jdi_ja.properties	Mon Sep 08 12:16:34 2014 -0700
@@ -5,9 +5,9 @@
 raw.command.label = \u30B3\u30DE\u30F3\u30C9
 raw.address = raw\u30B3\u30DE\u30F3\u30C9\u5B9F\u884C\u5F8C\u306B\u63A5\u7D9A\u3092\u30EA\u30B9\u30CB\u30F3\u30B0\u3059\u308B\u30A2\u30C9\u30EC\u30B9
 raw.address.label = \u30A2\u30C9\u30EC\u30B9
-raw.quote = \u5358\u4E00\u306E\u30B3\u30DE\u30F3\u30C9\u30E9\u30A4\u30F3\u5F15\u6570\u5185\u306B\u30B9\u30DA\u30FC\u30B9\u3067\u533A\u5207\u3089\u308C\u305F\u30C6\u30AD\u30B9\u30C8\u3092\u7D50\u3073\u4ED8\u3051\u308B\u305F\u3081\u306B\u4F7F\u7528\u3055\u308C\u308B\u6587\u5B57
+raw.quote = \u5358\u4E00\u306E\u30B3\u30DE\u30F3\u30C9\u884C\u5F15\u6570\u5185\u306B\u30B9\u30DA\u30FC\u30B9\u3067\u533A\u5207\u3089\u308C\u305F\u30C6\u30AD\u30B9\u30C8\u3092\u7D50\u3073\u4ED8\u3051\u308B\u305F\u3081\u306B\u4F7F\u7528\u3055\u308C\u308B\u6587\u5B57
 raw.quote.label = \u5F15\u7528\u7B26
-raw.description = \u30E6\u30FC\u30B6\u30FC\u304C\u6307\u5B9A\u3057\u305F\u30B3\u30DE\u30F3\u30C9\u30E9\u30A4\u30F3\u3092\u4F7F\u7528\u3057\u3066\u30BF\u30FC\u30B2\u30C3\u30C8\u3092\u8D77\u52D5\u3057\u3001\u63A5\u7D9A\u3057\u307E\u3059
+raw.description = \u30E6\u30FC\u30B6\u30FC\u304C\u6307\u5B9A\u3057\u305F\u30B3\u30DE\u30F3\u30C9\u884C\u3092\u4F7F\u7528\u3057\u3066\u30BF\u30FC\u30B2\u30C3\u30C8\u3092\u8D77\u52D5\u3057\u3001\u63A5\u7D9A\u3057\u307E\u3059
 sun.home = SDK\u306E\u30DB\u30FC\u30E0\u30FB\u30C7\u30A3\u30EC\u30AF\u30C8\u30EA\u307E\u305F\u306F\u3001\u30A2\u30D7\u30EA\u30B1\u30FC\u30B7\u30E7\u30F3\u306E\u8D77\u52D5\u306B\u4F7F\u7528\u3055\u308C\u308B\u5B9F\u884C\u74B0\u5883
 sun.home.label = \u30DB\u30FC\u30E0 
 sun.options = \u8D77\u52D5\u3059\u308BVM\u306E\u30AA\u30D7\u30B7\u30E7\u30F3
@@ -16,11 +16,11 @@
 sun.main.label = \u30E1\u30A4\u30F3
 sun.init_suspend = \u30E1\u30A4\u30F3\u306E\u5B9F\u884C\u524D\u306B\u3059\u3079\u3066\u306E\u30B9\u30EC\u30C3\u30C9\u304C\u4E2D\u65AD\u3055\u308C\u307E\u3059\u3002
 sun.init_suspend.label = \u4E2D\u65AD
-sun.quote = \u5358\u4E00\u306E\u30B3\u30DE\u30F3\u30C9\u30E9\u30A4\u30F3\u5F15\u6570\u5185\u306B\u30B9\u30DA\u30FC\u30B9\u3067\u533A\u5207\u3089\u308C\u305F\u30C6\u30AD\u30B9\u30C8\u3092\u7D50\u3073\u4ED8\u3051\u308B\u305F\u3081\u306B\u4F7F\u7528\u3055\u308C\u308B\u6587\u5B57
+sun.quote = \u5358\u4E00\u306E\u30B3\u30DE\u30F3\u30C9\u884C\u5F15\u6570\u5185\u306B\u30B9\u30DA\u30FC\u30B9\u3067\u533A\u5207\u3089\u308C\u305F\u30C6\u30AD\u30B9\u30C8\u3092\u7D50\u3073\u4ED8\u3051\u308B\u305F\u3081\u306B\u4F7F\u7528\u3055\u308C\u308B\u6587\u5B57
 sun.quote.label = \u5F15\u7528\u7B26
 sun.vm_exec = Java VM\u8D77\u52D5\u30C4\u30FC\u30EB\u540D
 sun.vm_exec.label = \u8D77\u52D5\u30C4\u30FC\u30EB
-sun.description = Sun\u306EJava VM\u30B3\u30DE\u30F3\u30C9\u30E9\u30A4\u30F3\u3092\u4F7F\u7528\u3057\u3066\u30BF\u30FC\u30B2\u30C3\u30C8\u3092\u8D77\u52D5\u3057\u3001\u63A5\u7D9A\u3057\u307E\u3059
+sun.description = Sun\u306EJava VM\u30B3\u30DE\u30F3\u30C9\u884C\u3092\u4F7F\u7528\u3057\u3066\u30BF\u30FC\u30B2\u30C3\u30C8\u3092\u8D77\u52D5\u3057\u3001\u63A5\u7D9A\u3057\u307E\u3059
 generic_attaching.address = VM\u306B\u63A5\u7D9A\u3059\u308B\u30A2\u30C9\u30EC\u30B9
 generic_attaching.address.label = \u30A2\u30C9\u30EC\u30B9
 generic_attaching.timeout = \u63A5\u7D9A\u3092\u5F85\u3064\u9593\u306E\u30BF\u30A4\u30E0\u30A2\u30A6\u30C8 
--- ./jdk/src/share/classes/java/lang/Class.java	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/classes/java/lang/Class.java	Mon Sep 08 12:16:34 2014 -0700
@@ -187,8 +187,8 @@
     @CallerSensitive
     public static Class<?> forName(String className)
                 throws ClassNotFoundException {
-        return forName0(className, true,
-                        ClassLoader.getClassLoader(Reflection.getCallerClass()));
+        Class<?> caller = Reflection.getCallerClass();
+        return forName0(className, true, ClassLoader.getClassLoader(caller), caller);
     }
 
 
@@ -257,22 +257,27 @@
                                    ClassLoader loader)
         throws ClassNotFoundException
     {
-        if (loader == null) {
-            SecurityManager sm = System.getSecurityManager();
-            if (sm != null) {
-                ClassLoader ccl = ClassLoader.getClassLoader(Reflection.getCallerClass());
+        Class<?> caller = null;
+        SecurityManager sm = System.getSecurityManager();
+        if (sm != null) {
+            // Reflective call to get caller class is only needed if a security manager
+            // is present.  Avoid the overhead of making this call otherwise.
+            caller = Reflection.getCallerClass();
+            if (loader == null) {
+                ClassLoader ccl = ClassLoader.getClassLoader(caller);
                 if (ccl != null) {
                     sm.checkPermission(
                         SecurityConstants.GET_CLASSLOADER_PERMISSION);
                 }
             }
         }
-        return forName0(name, initialize, loader);
+        return forName0(name, initialize, loader, caller);
     }
 
-    /** Called after security checks have been made. */
+    /** Called after security check for system loader access checks have been made. */
     private static native Class<?> forName0(String name, boolean initialize,
-                                            ClassLoader loader)
+                                            ClassLoader loader,
+                                            Class<?> caller)
         throws ClassNotFoundException;
 
     /**
--- ./jdk/src/share/classes/java/lang/invoke/InvokerBytecodeGenerator.java	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/classes/java/lang/invoke/InvokerBytecodeGenerator.java	Mon Sep 08 12:16:34 2014 -0700
@@ -661,6 +661,12 @@
             refKind = REF_invokeVirtual;
         }
 
+        if (member.getDeclaringClass().isInterface() && refKind == REF_invokeVirtual) {
+            // Methods from Object declared in an interface can be resolved by JVM to invokevirtual kind.
+            // Need to convert it back to invokeinterface to pass verification and make the invocation works as expected.
+            refKind = REF_invokeInterface;
+        }
+
         // push arguments
         for (int i = 0; i < name.arguments.length; i++) {
             emitPushArgument(name, i);
--- ./jdk/src/share/classes/java/lang/invoke/MethodHandle.java	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/classes/java/lang/invoke/MethodHandle.java	Mon Sep 08 12:16:34 2014 -0700
@@ -1260,8 +1260,6 @@
     /*non-public*/
     MethodHandle viewAsType(MethodType newType) {
         // No actual conversions, just a new view of the same method.
-        if (!type.isViewableAs(newType))
-            throw new InternalError();
         return MethodHandleImpl.makePairwiseConvert(this, newType, 0);
     }
 
--- ./jdk/src/share/classes/java/lang/invoke/MethodHandles.java	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/classes/java/lang/invoke/MethodHandles.java	Mon Sep 08 12:16:34 2014 -0700
@@ -1268,9 +1268,30 @@
             int allowedModes = this.allowedModes;
             if (allowedModes == TRUSTED)  return;
             int mods = m.getModifiers();
-            if (Modifier.isProtected(mods) && refKind == REF_newInvokeSpecial) {
-                // cannot "new" a protected ctor in a different package
-                mods ^= Modifier.PROTECTED;
+            if (Modifier.isProtected(mods)) {
+                if (refKind == REF_invokeVirtual &&
+                        m.getDeclaringClass() == Object.class &&
+                        m.getName().equals("clone") &&
+                        refc.isArray()) {
+                    // The JVM does this hack also.
+                    // (See ClassVerifier::verify_invoke_instructions
+                    // and LinkResolver::check_method_accessability.)
+                    // Because the JVM does not allow separate methods on array types,
+                    // there is no separate method for int[].clone.
+                    // All arrays simply inherit Object.clone.
+                    // But for access checking logic, we make Object.clone
+                    // (normally protected) appear to be public.
+                    // Later on, when the DirectMethodHandle is created,
+                    // its leading argument will be restricted to the
+                    // requested array type.
+                    // N.B. The return type is not adjusted, because
+                    // that is *not* the bytecode behavior.
+                    mods ^= Modifier.PROTECTED | Modifier.PUBLIC;
+                }
+                if (refKind == REF_newInvokeSpecial) {
+                    // cannot "new" a protected ctor in a different package
+                    mods ^= Modifier.PROTECTED;
+                }
             }
             if (Modifier.isFinal(mods) &&
                     MethodHandleNatives.refKindIsSetter(refKind))
--- ./jdk/src/share/classes/java/lang/invoke/MethodType.java	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/classes/java/lang/invoke/MethodType.java	Mon Sep 08 12:16:34 2014 -0700
@@ -628,7 +628,7 @@
      * @return the parameter types (as an immutable list)
      */
     public List<Class<?>> parameterList() {
-        return Collections.unmodifiableList(Arrays.asList(ptypes));
+        return Collections.unmodifiableList(Arrays.asList(ptypes.clone()));
     }
 
     /*non-public*/ Class<?> lastParameterType() {
--- ./jdk/src/share/classes/java/net/AbstractPlainDatagramSocketImpl.java	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/classes/java/net/AbstractPlainDatagramSocketImpl.java	Mon Sep 08 12:16:34 2014 -0700
@@ -70,6 +70,7 @@
     static {
         java.security.AccessController.doPrivileged(
                   new sun.security.action.LoadLibraryAction("net"));
+        init();
     }
 
     /**
@@ -362,4 +363,7 @@
     protected boolean nativeConnectDisabled() {
         return connectDisabled;
     }
+
+    native int dataAvailable();
+    private static native void init();
 }
--- ./jdk/src/share/classes/java/net/DatagramSocket.java	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/classes/java/net/DatagramSocket.java	Mon Sep 08 12:16:34 2014 -0700
@@ -85,6 +85,17 @@
      */
     boolean oldImpl = false;
 
+    /**
+     * Set when a socket is ST_CONNECTED until we are certain
+     * that any packets which might have been received prior
+     * to calling connect() but not read by the application
+     * have been read. During this time we check the source
+     * address of all packets received to be sure they are from
+     * the connected destination. Other packets are read but
+     * silently dropped.
+     */
+    private boolean explicitFilter = false;
+    private int bytesLeftToFilter;
     /*
      * Connection state:
      * ST_NOT_CONNECTED = socket not connected
@@ -144,6 +155,15 @@
 
                 // socket is now connected by the impl
                 connectState = ST_CONNECTED;
+                // Do we need to filter some packets?
+                int avail = getImpl().dataAvailable();
+                if (avail == -1) {
+                    throw new SocketException();
+                }
+                explicitFilter = avail > 0;
+                if (explicitFilter) {
+                    bytesLeftToFilter = getReceiveBufferSize();
+                }
             } catch (SocketException se) {
 
                 // connection will be emulated by DatagramSocket
@@ -494,6 +514,7 @@
             connectedAddress = null;
             connectedPort = -1;
             connectState = ST_NOT_CONNECTED;
+            explicitFilter = false;
         }
     }
 
@@ -752,10 +773,13 @@
                     } // end of while
                 }
             }
-            if (connectState == ST_CONNECTED_NO_IMPL) {
+            DatagramPacket tmp = null;
+            if ((connectState == ST_CONNECTED_NO_IMPL) || explicitFilter) {
                 // We have to do the filtering the old fashioned way since
                 // the native impl doesn't support connect or the connect
-                // via the impl failed.
+                // via the impl failed, or .. "explicitFilter" may be set when
+                // a socket is connected via the impl, for a period of time
+                // when packets from other sources might be queued on socket.
                 boolean stop = false;
                 while (!stop) {
                     InetAddress peekAddress = null;
@@ -774,8 +798,14 @@
                     if ((!connectedAddress.equals(peekAddress)) ||
                         (connectedPort != peekPort)) {
                         // throw the packet away and silently continue
-                        DatagramPacket tmp = new DatagramPacket(new byte[1], 1);
+                        tmp = new DatagramPacket(
+                                                new byte[1024], 1024);
                         getImpl().receive(tmp);
+                        if (explicitFilter) {
+                            if (checkFiltering(tmp)) {
+                                stop = true;
+                            }
+                        }
                     } else {
                         stop = true;
                     }
@@ -784,9 +814,23 @@
             // If the security check succeeds, or the datagram is
             // connected then receive the packet
             getImpl().receive(p);
+            if (explicitFilter && tmp == null) {
+                // packet was not filtered, account for it here
+                checkFiltering(p);
+            }
         }
     }
 
+    // Update the filter information and return true if finished
+    private boolean checkFiltering(DatagramPacket p) throws SocketException {
+        bytesLeftToFilter -= p.getLength();
+        if (bytesLeftToFilter <= 0 || getImpl().dataAvailable() <= 0) {
+            explicitFilter = false;
+            return true;
+        }
+        return false;
+    }
+
     /**
      * Gets the local address to which the socket is bound.
      *
--- ./jdk/src/share/classes/java/net/DatagramSocketImpl.java	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/classes/java/net/DatagramSocketImpl.java	Mon Sep 08 12:16:34 2014 -0700
@@ -47,6 +47,12 @@
      */
     protected FileDescriptor fd;
 
+    int dataAvailable() {
+        // default impl returns zero, which disables the calling
+        // functionality
+        return 0;
+    }
+
     /**
      * Creates a datagram socket.
      * @exception SocketException if there is an error in the
--- ./jdk/src/share/classes/java/security/DigestOutputStream.java	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/classes/java/security/DigestOutputStream.java	Mon Sep 08 12:16:34 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 1999, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -112,10 +112,10 @@
      * @see MessageDigest#update(byte)
      */
     public void write(int b) throws IOException {
+        out.write(b);
         if (on) {
             digest.update((byte)b);
         }
-        out.write(b);
     }
 
     /**
@@ -142,10 +142,10 @@
      * @see MessageDigest#update(byte[], int, int)
      */
     public void write(byte[] b, int off, int len) throws IOException {
+        out.write(b, off, len);
         if (on) {
             digest.update(b, off, len);
         }
-        out.write(b, off, len);
     }
 
     /**
--- ./jdk/src/share/classes/java/security/Signature.java	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/classes/java/security/Signature.java	Mon Sep 08 12:16:34 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -589,6 +589,9 @@
         if (outbuf == null) {
             throw new IllegalArgumentException("No output buffer given");
         }
+        if (offset < 0 || len < 0) {
+            throw new IllegalArgumentException("offset or len is less than 0");
+        }
         if (outbuf.length - offset < len) {
             throw new IllegalArgumentException
                 ("Output buffer too small for specified offset and length");
@@ -657,9 +660,16 @@
     public final boolean verify(byte[] signature, int offset, int length)
         throws SignatureException {
         if (state == VERIFY) {
-            if ((signature == null) || (offset < 0) || (length < 0) ||
-                (length > signature.length - offset)) {
-                throw new IllegalArgumentException("Bad arguments");
+            if (signature == null) {
+                throw new IllegalArgumentException("signature is null");
+            }
+            if (offset < 0 || length < 0) {
+                throw new IllegalArgumentException
+                    ("offset or length is less than 0");
+            }
+            if (signature.length - offset < length) {
+                throw new IllegalArgumentException
+                    ("signature too small for specified offset and length");
             }
 
             return engineVerify(signature, offset, length);
@@ -712,6 +722,16 @@
     public final void update(byte[] data, int off, int len)
             throws SignatureException {
         if (state == SIGN || state == VERIFY) {
+            if (data == null) {
+                throw new IllegalArgumentException("data is null");
+            }
+            if (off < 0 || len < 0) {
+                throw new IllegalArgumentException("off or len is less than 0");
+            }
+            if (data.length - off < len) {
+                throw new IllegalArgumentException
+                    ("data too small for specified offset and length");
+            }
             engineUpdate(data, off, len);
         } else {
             throw new SignatureException("object not initialized for "
--- ./jdk/src/share/classes/java/security/cert/CertificateRevokedException.java	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/classes/java/security/cert/CertificateRevokedException.java	Mon Sep 08 12:16:34 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2007, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -95,7 +95,10 @@
         this.revocationDate = new Date(revocationDate.getTime());
         this.reason = reason;
         this.authority = authority;
-        this.extensions = new HashMap(extensions);
+        // make sure Map only contains correct types
+        this.extensions = Collections.checkedMap(new HashMap<String, Extension>(),
+                                                 String.class, Extension.class);
+        this.extensions.putAll(extensions);
     }
 
     /**
@@ -174,7 +177,8 @@
     public String getMessage() {
         return "Certificate has been revoked, reason: "
                + reason + ", revocation date: " + revocationDate
-               + ", authority: " + authority + ", extensions: " + extensions;
+               + ", authority: " + authority + ", extension OIDs: "
+               + extensions.keySet();
     }
 
     /**
--- ./jdk/src/share/classes/java/util/ResourceBundle.java	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/classes/java/util/ResourceBundle.java	Mon Sep 08 12:16:34 2014 -0700
@@ -2577,7 +2577,10 @@
                 } catch (ClassNotFoundException e) {
                 }
             } else if (format.equals("java.properties")) {
-                final String resourceName = toResourceName(bundleName, "properties");
+                final String resourceName = toResourceName0(bundleName, "properties");
+                if (resourceName == null) {
+                    return bundle;
+                }
                 final ClassLoader classLoader = loader;
                 final boolean reloadFlag = reload;
                 InputStream stream = null;
@@ -2731,7 +2734,10 @@
             }
             boolean result = false;
             try {
-                String resourceName = toResourceName(toBundleName(baseName, locale), format);
+                String resourceName = toResourceName0(toBundleName(baseName, locale), format);
+                if (resourceName == null) {
+                    return result;
+                }
                 URL url = loader.getResource(resourceName);
                 if (url != null) {
                     long lastModified = 0;
@@ -2865,6 +2871,15 @@
             sb.append(bundleName.replace('.', '/')).append('.').append(suffix);
             return sb.toString();
         }
+
+        private String toResourceName0(String bundleName, String suffix) {
+            // application protocol check
+            if (bundleName.contains("://")) {
+                return null;
+            } else {
+                return toResourceName(bundleName, suffix);
+            }
+        }
     }
 
     private static class SingleFormatControl extends Control {
--- ./jdk/src/share/classes/java/util/logging/LogRecord.java	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/classes/java/util/logging/LogRecord.java	Mon Sep 08 12:16:34 2014 -0700
@@ -510,7 +510,13 @@
         // If necessary, try to regenerate the resource bundle.
         if (resourceBundleName != null) {
             try {
-                resourceBundle = ResourceBundle.getBundle(resourceBundleName);
+                // use system class loader to ensure the ResourceBundle
+                // instance is a different instance than null loader uses
+                final ResourceBundle bundle =
+                        ResourceBundle.getBundle(resourceBundleName,
+                                Locale.getDefault(),
+                                ClassLoader.getSystemClassLoader());
+                resourceBundle = bundle;
             } catch (MissingResourceException ex) {
                 // This is not a good place to throw an exception,
                 // so we simply leave the resourceBundle null.
--- ./jdk/src/share/classes/java/util/logging/Logger.java	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/classes/java/util/logging/Logger.java	Mon Sep 08 12:16:34 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -1526,6 +1526,9 @@
         }
 
         setCallersClassLoaderRef(callersClass);
+        if (isSystemLogger && getCallersClassLoader() != null) {
+            checkPermission();
+        }
         if (findResourceBundle(name, true) == null) {
             // We've failed to find an expected ResourceBundle.
             // unset the caller's ClassLoader since we were unable to find the
@@ -1689,7 +1692,9 @@
         Logger target = this;
         while (target != null) {
             final String rbn = isSystemLogger
-                ? target.resourceBundleName
+                // ancestor of a system logger is expected to be a system logger.
+                // ignore resource bundle name if it's not.
+                ? (target.isSystemLogger ? target.resourceBundleName : null)
                 : target.getResourceBundleName();
             if (rbn != null) {
                 return rbn;
--- ./jdk/src/share/classes/javax/crypto/CipherInputStream.java	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/classes/javax/crypto/CipherInputStream.java	Mon Sep 08 12:16:34 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -86,6 +86,10 @@
     private int ostart = 0;
     // the offset pointing to the last "new" byte
     private int ofinish = 0;
+    // stream status
+    private boolean closed = false;
+    // The stream has been read from.  False if the stream has never been read.
+    private boolean read = false;
 
     /**
      * private convenience function.
@@ -101,13 +105,15 @@
     private int getMoreData() throws IOException {
         if (done) return -1;
         int readin = input.read(ibuffer);
+        read = true;
         if (readin == -1) {
             done = true;
             try {
                 obuffer = cipher.doFinal();
+            } catch (IllegalBlockSizeException | BadPaddingException e) {
+                obuffer = null;
+                throw new IOException(e);
             }
-            catch (IllegalBlockSizeException e) {obuffer = null;}
-            catch (BadPaddingException e) {obuffer = null;}
             if (obuffer == null)
                 return -1;
             else {
@@ -118,7 +124,10 @@
         }
         try {
             obuffer = cipher.update(ibuffer, 0, readin);
-        } catch (IllegalStateException e) {obuffer = null;};
+        } catch (IllegalStateException e) {
+            obuffer = null;
+            throw e;
+        }
         ostart = 0;
         if (obuffer == null)
             ofinish = 0;
@@ -293,14 +302,24 @@
      * @since JCE1.2
      */
     public void close() throws IOException {
+        if (closed) {
+            return;
+        }
+
+        closed = true;
         input.close();
         try {
             // throw away the unprocessed data
-            cipher.doFinal();
+            if (!done) {
+                cipher.doFinal();
+            }
         }
-        catch (BadPaddingException ex) {
-        }
-        catch (IllegalBlockSizeException ex) {
+        catch (BadPaddingException | IllegalBlockSizeException ex) {
+            /* If no data has been read from the stream to be en/decrypted,
+               we supress any exceptions, and close quietly. */
+            if (read) {
+                throw new IOException(ex);
+            }
         }
         ostart = 0;
         ofinish = 0;
--- ./jdk/src/share/classes/javax/crypto/CipherOutputStream.java	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/classes/javax/crypto/CipherOutputStream.java	Mon Sep 08 12:16:34 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -74,6 +74,9 @@
     // the buffer holding data ready to be written out
     private byte[] obuffer;
 
+    // stream status
+    private boolean closed = false;
+
     /**
      *
      * Constructs a CipherOutputStream from an OutputStream and a
@@ -198,11 +201,14 @@
      * @since      JCE1.2
      */
     public void close() throws IOException {
+        if (closed) {
+            return;
+        }
+
+        closed = true;
         try {
             obuffer = cipher.doFinal();
-        } catch (IllegalBlockSizeException e) {
-            obuffer = null;
-        } catch (BadPaddingException e) {
+        } catch (IllegalBlockSizeException | BadPaddingException e) {
             obuffer = null;
         }
         try {
--- ./jdk/src/share/classes/javax/swing/JDesktopPane.java	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/classes/javax/swing/JDesktopPane.java	Mon Sep 08 12:16:34 2014 -0700
@@ -43,6 +43,7 @@
 import java.beans.PropertyVetoException;
 import java.util.Set;
 import java.util.TreeSet;
+import java.util.LinkedHashSet;
 /**
  * A container used to create a multiple-document interface or a virtual desktop.
  * You create <code>JInternalFrame</code> objects and add them to the
@@ -266,7 +267,7 @@
 
     private static Collection<JInternalFrame> getAllFrames(Container parent) {
         int i, count;
-        Collection<JInternalFrame> results = new ArrayList<JInternalFrame>();
+        Collection<JInternalFrame> results = new LinkedHashSet<>();
         count = parent.getComponentCount();
         for (i = 0; i < count; i++) {
             Component next = parent.getComponent(i);
--- ./jdk/src/share/classes/sun/awt/image/BytePackedRaster.java	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/classes/sun/awt/image/BytePackedRaster.java	Mon Sep 08 12:16:34 2014 -0700
@@ -1408,10 +1408,10 @@
             }
         }
 
-        int lastbit = (dataBitOffset
-                       + (height-1) * scanlineStride * 8
-                       + (width-1) * pixelBitStride
-                       + pixelBitStride - 1);
+        long lastbit = (long) dataBitOffset
+                       + (long) (height - 1) * (long) scanlineStride * 8
+                       + (long) (width - 1) * (long) pixelBitStride
+                       + (long) pixelBitStride - 1;
         if (lastbit < 0 || lastbit / 8 >= data.length) {
             throw new RasterFormatException("raster dimensions overflow " +
                                             "array bounds");
--- ./jdk/src/share/classes/sun/awt/image/FileImageSource.java	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/classes/sun/awt/image/FileImageSource.java	Mon Sep 08 12:16:34 2014 -0700
@@ -48,6 +48,10 @@
     }
 
     protected ImageDecoder getDecoder() {
+        if (imagefile == null) {
+            return null;
+        }
+
         InputStream is;
         try {
             is = new BufferedInputStream(new FileInputStream(imagefile));
--- ./jdk/src/share/classes/sun/awt/resources/awt_pt_BR.properties	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/classes/sun/awt/resources/awt_pt_BR.properties	Mon Sep 08 12:16:34 2014 -0700
@@ -44,7 +44,7 @@
 AWT.subtract=Teclado Num\u00E9rico -
 AWT.decimal=Teclado Num\u00E9rico .
 AWT.divide=Teclado Num\u00E9rico /
-AWT.delete=Deletar
+AWT.delete=Excluir
 AWT.numLock=Num Lock
 AWT.scrollLock=Scroll Lock
 AWT.f1=F1
--- ./jdk/src/share/classes/sun/net/www/http/ChunkedOutputStream.java	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/classes/sun/net/www/http/ChunkedOutputStream.java	Mon Sep 08 12:16:34 2014 -0700
@@ -125,7 +125,7 @@
         completeHeader = getHeader(preferredChunkDataSize);
 
         /* start with an initial buffer */
-        buf = new byte[preferredChunkDataSize + 32];
+        buf = new byte[preferredChunkGrossSize];
         reset();
     }
 
--- ./jdk/src/share/classes/sun/nio/ch/DatagramChannelImpl.java	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/classes/sun/nio/ch/DatagramChannelImpl.java	Mon Sep 08 12:16:34 2014 -0700
@@ -751,6 +751,26 @@
 
                     // set or refresh local address
                     localAddress = Net.localAddress(fd);
+
+                    // flush any packets already received.
+                    boolean blocking = false;
+                    synchronized (blockingLock()) {
+                        try {
+                            blocking = isBlocking();
+                            // remainder of each packet thrown away
+                            ByteBuffer tmpBuf = ByteBuffer.allocate(1);
+                            if (blocking) {
+                                configureBlocking(false);
+                            }
+                            do {
+                                tmpBuf.clear();
+                            } while (receive(tmpBuf) != null);
+                        } finally {
+                            if (blocking) {
+                                configureBlocking(true);
+                            }
+                        }
+                    }
                 }
             }
         }
--- ./jdk/src/share/classes/sun/reflect/annotation/AnnotationInvocationHandler.java	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/classes/sun/reflect/annotation/AnnotationInvocationHandler.java	Mon Sep 08 12:16:34 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -29,7 +29,6 @@
 import java.lang.reflect.*;
 import java.io.Serializable;
 import java.util.*;
-import java.lang.annotation.*;
 import java.security.AccessController;
 import java.security.PrivilegedAction;
 
@@ -45,6 +44,11 @@
     private final Map<String, Object> memberValues;
 
     AnnotationInvocationHandler(Class<? extends Annotation> type, Map<String, Object> memberValues) {
+        Class<?>[] superInterfaces = type.getInterfaces();
+        if (!type.isAnnotation() ||
+            superInterfaces.length != 1 ||
+            superInterfaces[0] != java.lang.annotation.Annotation.class)
+            throw new AnnotationFormatError("Attempt to create proxy for a non-annotation type.");
         this.type = type;
         this.memberValues = memberValues;
     }
@@ -57,13 +61,17 @@
         if (member.equals("equals") && paramTypes.length == 1 &&
             paramTypes[0] == Object.class)
             return equalsImpl(args[0]);
-        assert paramTypes.length == 0;
-        if (member.equals("toString"))
+        if (paramTypes.length != 0)
+            throw new AssertionError("Too many parameters for an annotation method");
+
+        switch(member) {
+        case "toString":
             return toStringImpl();
-        if (member.equals("hashCode"))
+        case "hashCode":
             return hashCodeImpl();
-        if (member.equals("annotationType"))
+        case "annotationType":
             return type;
+        }
 
         // Handle annotation member accessors
         Object result = memberValues.get(member);
@@ -129,7 +137,7 @@
      * Implementation of dynamicProxy.toString()
      */
     private String toStringImpl() {
-        StringBuffer result = new StringBuffer(128);
+        StringBuilder result = new StringBuilder(128);
         result.append('@');
         result.append(type.getName());
         result.append('(');
@@ -277,6 +285,7 @@
                 new PrivilegedAction<Method[]>() {
                     public Method[] run() {
                         final Method[] mm = type.getDeclaredMethods();
+                        validateAnnotationMethods(mm);
                         AccessibleObject.setAccessible(mm, true);
                         return mm;
                     }
@@ -287,6 +296,93 @@
     private transient volatile Method[] memberMethods = null;
 
     /**
+     * Validates that a method is structurally appropriate for an
+     * annotation type. As of Java SE 7, annotation types cannot
+     * contain static methods and the declared methods of an
+     * annotation type must take zero arguments and there are
+     * restrictions on the return type.
+     */
+    private void validateAnnotationMethods(Method[] memberMethods) {
+        /*
+         * Specification citations below are from JLS
+         * 9.6.1. Annotation Type Elements
+         */
+        boolean valid = true;
+        for(Method method : memberMethods) {
+            /*
+             * "By virtue of the AnnotationTypeElementDeclaration
+             * production, a method declaration in an annotation type
+             * declaration cannot have formal parameters, type
+             * parameters, or a throws clause.
+             *
+             * "By virtue of the AnnotationTypeElementModifier
+             * production, a method declaration in an annotation type
+             * declaration cannot be default or static."
+             */
+            if (method.getModifiers() != (Modifier.PUBLIC | Modifier.ABSTRACT) ||
+                method.getParameterTypes().length != 0 ||
+                method.getExceptionTypes().length != 0) {
+                valid = false;
+                break;
+            }
+
+            /*
+             * "It is a compile-time error if the return type of a
+             * method declared in an annotation type is not one of the
+             * following: a primitive type, String, Class, any
+             * parameterized invocation of Class, an enum type
+             * (section 8.9), an annotation type, or an array type
+             * (chapter 10) whose element type is one of the preceding
+             * types."
+             */
+            Class<?> returnType = method.getReturnType();
+            if (returnType.isArray()) {
+                returnType = returnType.getComponentType();
+                if (returnType.isArray()) { // Only single dimensional arrays
+                    valid = false;
+                    break;
+                }
+            }
+
+            if (!((returnType.isPrimitive() && returnType != void.class) ||
+                  returnType == java.lang.String.class ||
+                  returnType == java.lang.Class.class ||
+                  returnType.isEnum() ||
+                  returnType.isAnnotation())) {
+                valid = false;
+                break;
+            }
+
+            /*
+             * "It is a compile-time error if any method declared in an
+             * annotation type has a signature that is
+             * override-equivalent to that of any public or protected
+             * method declared in class Object or in the interface
+             * java.lang.annotation.Annotation."
+             *
+             * The methods in Object or Annotation meeting the other
+             * criteria (no arguments, contrained return type, etc.)
+             * above are:
+             *
+             * String toString()
+             * int hashCode()
+             * Class<? extends Annotation> annotationType()
+             */
+            String methodName = method.getName();
+            if ((methodName.equals("toString") && returnType == java.lang.String.class) ||
+                (methodName.equals("hashCode") && returnType == int.class) ||
+                (methodName.equals("annotationType") && returnType == java.lang.Class.class)) {
+                valid = false;
+                break;
+            }
+        }
+        if (valid)
+            return;
+        else
+            throw new AnnotationFormatError("Malformed method on an annotation type");
+    }
+
+    /**
      * Implementation of dynamicProxy.hashCode()
      */
     private int hashCodeImpl() {
@@ -330,7 +426,6 @@
         throws java.io.IOException, ClassNotFoundException {
         s.defaultReadObject();
 
-
         // Check to make sure that types have not evolved incompatibly
 
         AnnotationType annotationType = null;
@@ -343,7 +438,6 @@
 
         Map<String, Class<?>> memberTypes = annotationType.memberTypes();
 
-
         // If there are annotation members without values, that
         // situation is handled by the invoke method.
         for (Map.Entry<String, Object> memberValue : memberValues.entrySet()) {
--- ./jdk/src/share/classes/sun/rmi/rmic/resources/rmic_ja.properties	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/classes/sun/rmi/rmic/resources/rmic_ja.properties	Mon Sep 08 12:16:34 2014 -0700
@@ -1,6 +1,6 @@
 #
 #
-# Copyright (c) 1996, 2010, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -91,8 +91,8 @@
 rmic.warnings=\u8B66\u544A{0}\u500B
 rmic.1warning=\u8B66\u544A1\u500B
 rmic.done_in=[{0}\u30DF\u30EA\u79D2\u3067\u5B8C\u4E86]
-rmic.no.memory=\u30B3\u30F3\u30D1\u30A4\u30E9\u306B\u30E1\u30E2\u30EA\u30FC\u304C\u4E0D\u8DB3\u3057\u3066\u3044\u307E\u3059\u3002"-J-Xmx<size>"\u30B3\u30DE\u30F3\u30C9\u30E9\u30A4\u30F3\u30FB\u30AA\u30D7\u30B7\u30E7\u30F3\u3092\u4F7F\u7528\u3057\u3066\u3001\u6700\u5927\u30D2\u30FC\u30D7\u30FB\u30B5\u30A4\u30BA\u3092\u5897\u3084\u3057\u3066\u304F\u3060\u3055\u3044\u3002
-rmic.stack.overflow=\u30B3\u30F3\u30D1\u30A4\u30E9\u306B\u30B9\u30BF\u30C3\u30AF\u7A7A\u9593\u304C\u4E0D\u8DB3\u3057\u3066\u3044\u307E\u3059\u3002"-J-Xss<size>"\u30B3\u30DE\u30F3\u30C9\u30E9\u30A4\u30F3\u30FB\u30AA\u30D7\u30B7\u30E7\u30F3\u3092\u4F7F\u7528\u3057\u3066\u3001Java\u30B9\u30BF\u30C3\u30AF\u306B\u5272\u308A\u5F53\u3066\u308B\u30E1\u30E2\u30EA\u30FC\u3092\u5897\u3084\u3057\u3066\u304F\u3060\u3055\u3044\u3002
+rmic.no.memory=\u30B3\u30F3\u30D1\u30A4\u30E9\u306B\u30E1\u30E2\u30EA\u30FC\u304C\u4E0D\u8DB3\u3057\u3066\u3044\u307E\u3059\u3002"-J-Xmx<size>"\u30B3\u30DE\u30F3\u30C9\u884C\u30AA\u30D7\u30B7\u30E7\u30F3\u3092\u4F7F\u7528\u3057\u3066\u3001\u6700\u5927\u30D2\u30FC\u30D7\u30FB\u30B5\u30A4\u30BA\u3092\u5897\u3084\u3057\u3066\u304F\u3060\u3055\u3044\u3002
+rmic.stack.overflow=\u30B3\u30F3\u30D1\u30A4\u30E9\u306B\u30B9\u30BF\u30C3\u30AF\u7A7A\u9593\u304C\u4E0D\u8DB3\u3057\u3066\u3044\u307E\u3059\u3002"-J-Xss<size>"\u30B3\u30DE\u30F3\u30C9\u884C\u30AA\u30D7\u30B7\u30E7\u30F3\u3092\u4F7F\u7528\u3057\u3066\u3001Java\u30B9\u30BF\u30C3\u30AF\u306B\u5272\u308A\u5F53\u3066\u308B\u30E1\u30E2\u30EA\u30FC\u3092\u5897\u3084\u3057\u3066\u304F\u3060\u3055\u3044\u3002
 rmic.class.not.found=\u30AF\u30E9\u30B9{0}\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093\u3002
 rmic.missing.property=\u30D7\u30ED\u30D1\u30C6\u30A3generator.class.{0}\u304C\u3042\u308A\u307E\u305B\u3093
 rmic.cannot.instantiate=\u30AF\u30E9\u30B9{0}\u306E\u30A4\u30F3\u30B9\u30BF\u30F3\u30B9\u3092\u751F\u6210\u3067\u304D\u307E\u305B\u3093
--- ./jdk/src/share/classes/sun/security/ssl/ClientHandshaker.java	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/classes/sun/security/ssl/ClientHandshaker.java	Mon Sep 08 12:16:34 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -36,6 +36,8 @@
 
 import java.security.cert.X509Certificate;
 import java.security.cert.CertificateException;
+import java.security.cert.CertificateParsingException;
+import javax.security.auth.x500.X500Principal;
 
 import javax.crypto.SecretKey;
 import javax.crypto.spec.SecretKeySpec;
@@ -93,6 +95,60 @@
             Debug.getBooleanProperty("jsse.enableSNIExtension", true);
 
     /*
+     * Allow unsafe server certificate change?
+     *
+     * Server certificate change during SSL/TLS renegotiation may be considered
+     * unsafe, as described in the Triple Handshake attacks:
+     *
+     *    https://secure-resumption.com/tlsauth.pdf
+     *
+     * Endpoint identification (See
+     * SSLParameters.getEndpointIdentificationAlgorithm()) is a pretty nice
+     * guarantee that the server certificate change in the renegotiation is legal.
+     * However, endpoint identification is only enabled for HTTPS and LDAP
+     * over SSL/TLS by default. It is not enough to protect SSL/TLS
+     * connections other than HTTPS and LDAP.
+     *
+     * The renegotiation indication extension (See RFC 5764) is a pretty
+     * strong guarantee that the endpoints on both client and server sides
+     * are identical on the same connection. However, the Triple Handshake
+     * attacks can bypass this guarantee if there is a session-resumption
+     * handshake between the initial full handshake and the renegotiation
+     * full handshake.
+     *
+     * Server certificate change may be unsafe and should be restricted if
+     * endpoint identification is not enabled and the previous handshake is
+     * a session-resumption abbreviated initial handshake, unless the
+     * identities reproesented by both certificates can be regraded as the
+     * same (See isIdentityEquivalent()).
+     *
+     * Considering the compatibility impact and the actual requirements to
+     * support server certificate change in practice, the system property,
+     * jdk.tls.allowUnsafeServerCertChange, is used to define whether unsafe
+     * server certificate change in renegotiation is allowed or not. The
+     * default value of the system property is "false". To mitigate the
+     * compatibility impact, applications may want to set the system
+     * property to "true" at their own risk.
+     *
+     * If the value of the system property is "false", server certificate
+     * change in renegotiation after a session-resumption abbreviated initial
+     * handshake is restricted (See isIdentityEuivalent()).
+     *
+     * If the system property is set to "truie" explicitly, the restriction on
+     * server certificate change in renegotiation is disabled.
+     */
+    private final static boolean allowUnsafeServerCertChange =
+        Debug.getBooleanProperty("jdk.tls.allowUnsafeServerCertChange", false);
+
+    /*
+     * the reserved server certificate chain in previous handshaking
+     *
+     * The server certificate chain is only reserved if the previous
+     * handshake is a session-resumption abbreviated initial handshake.
+     */
+    private X509Certificate[] reservedServerCerts = null;
+
+    /*
      * Constructors
      */
     ClientHandshaker(SSLSocketImpl socket, SSLContextImpl context,
@@ -551,8 +607,7 @@
                 // we wanted to resume, but the server refused
                 session = null;
                 if (!enableNewSession) {
-                    throw new SSLException
-                        ("New session creation is disabled");
+                    throw new SSLException("New session creation is disabled");
                 }
             }
         }
@@ -563,6 +618,11 @@
             }
 
             setHandshakeSessionSE(session);
+            // Reserve the handshake state if this is a session-resumption
+            // abbreviated initial handshake.
+            if (isInitialHandshake) {
+                session.setAsSessionResumption(true);
+            }
             return;
         }
 
@@ -1035,6 +1095,13 @@
         }
 
         /*
+         * Reset the handshake state if this is not an initial handshake.
+         */
+        if (!isInitialHandshake) {
+            session.setAsSessionResumption(false);
+        }
+
+        /*
          * OK, it verified.  If we're doing the fast handshake, add that
          * "Finished" message to the hash of handshake messages, then send
          * our own change_cipher_spec and Finished message for the server
@@ -1131,8 +1198,22 @@
                 System.out.println("%% No cached client session");
             }
         }
-        if ((session != null) && (session.isRejoinable() == false)) {
-            session = null;
+        if (session != null) {
+            // If unsafe server certificate change is not allowed, reserve
+            // current server certificates if the preious handshake is a
+            // session-resumption abbreviated initial handshake.
+            if (!allowUnsafeServerCertChange && session.isSessionResumption()) {
+                try {
+                    // If existing, peer certificate chain cannot be null.
+                    reservedServerCerts =
+                        (X509Certificate[])session.getPeerCertificates();
+                } catch (SSLPeerUnverifiedException puve) {
+                    // Maybe not certificate-based, ignore the exception.
+                }
+            }
+            if (!session.isRejoinable()) {
+                session = null;
+            }
         }
 
         if (session != null) {
@@ -1303,8 +1384,25 @@
         }
         X509Certificate[] peerCerts = mesg.getCertificateChain();
         if (peerCerts.length == 0) {
-            fatalSE(Alerts.alert_bad_certificate,
-                "empty certificate chain");
+            fatalSE(Alerts.alert_bad_certificate, "empty certificate chain");
+        }
+
+        // Allow server certificate change in client side during renegotiation
+        // after session-resumption abbreviated initial handshake ?
+        //
+        // DO NOT need to check allowUnsafeServerCertChange here. We only
+        // reserve server certificates when allowUnsafeServerCertChange is
+        // false.
+        if (reservedServerCerts != null) {
+            // It is not necessary to check the certificate update if endpoint
+            // identification is enabled.
+            String identityAlg = getEndpointIdentificationAlgorithmSE();
+            if ((identityAlg == null || identityAlg.length() == 0) &&
+                !isIdentityEquivalent(peerCerts[0], reservedServerCerts[0])) {
+                fatalSE(Alerts.alert_bad_certificate,
+                        "server certificate change is restricted" +
+                        "during renegotiation");
+            }
         }
         // ask the trust manager to verify the chain
         X509TrustManager tm = sslContext.getX509TrustManager();
@@ -1342,4 +1440,82 @@
         }
         session.setPeerCertificates(peerCerts);
     }
+
+    /*
+     * Whether the certificates can represent the same identity?
+     *
+     * The certificates can be used to represent the same identity:
+     *     1. If the subject alternative names of IP address are present in
+     *        both certificates, they should be identical; otherwise,
+     *     2. if the subject alternative names of DNS name are present in
+     *        both certificates, they should be identical; otherwise,
+     *     3. if the subject fields are present in both certificates, the
+     *        certificate subjects and issuers should be identical.
+     */
+
+    private static boolean isIdentityEquivalent(X509Certificate thisCert,
+            X509Certificate prevCert) {
+        if (thisCert.equals(prevCert)) {
+            return true;
+        }
+
+        // check the iPAddress field in subjectAltName extension
+        Object thisIPAddress = getSubjectAltName(thisCert, 7);  // 7: iPAddress
+        Object prevIPAddress = getSubjectAltName(prevCert, 7);
+        if (thisIPAddress != null && prevIPAddress!= null) {
+            // only allow the exactly match
+            return Objects.equals(thisIPAddress, prevIPAddress);
+        }
+
+        // check the dNSName field in subjectAltName extension
+        Object thisDNSName = getSubjectAltName(thisCert, 2);    // 2: dNSName
+        Object prevDNSName = getSubjectAltName(prevCert, 2);
+        if (thisDNSName != null && prevDNSName!= null) {
+            // only allow the exactly match
+            return Objects.equals(thisDNSName, prevDNSName);
+        }
+
+        // check the certificate subject and issuer
+        X500Principal thisSubject = thisCert.getSubjectX500Principal();
+        X500Principal prevSubject = prevCert.getSubjectX500Principal();
+        X500Principal thisIssuer = thisCert.getIssuerX500Principal();
+        X500Principal prevIssuer = prevCert.getIssuerX500Principal();
+        if (!thisSubject.getName().isEmpty() &&
+                !prevSubject.getName().isEmpty() &&
+                thisSubject.equals(prevSubject) &&
+                thisIssuer.equals(prevIssuer)) {
+            return true;
+        }
+
+        return false;
+    }
+
+    /*
+     * Returns the subject alternative name of the specified type in the
+     * subjectAltNames extension of a certificate.
+     */
+    private static Object getSubjectAltName(X509Certificate cert, int type) {
+        Collection<List<?>> subjectAltNames;
+
+        try {
+            subjectAltNames = cert.getSubjectAlternativeNames();
+        } catch (CertificateParsingException cpe) {
+            if (debug != null && Debug.isOn("handshake")) {
+                System.out.println(
+                        "Attempt to obtain subjectAltNames extension failed!");
+            }
+            return null;
+        }
+
+        if (subjectAltNames != null) {
+            for (List<?> subjectAltName : subjectAltNames) {
+                int subjectAltNameType = (Integer)subjectAltName.get(0);
+                if (subjectAltNameType == type) {
+                    return subjectAltName.get(1);
+                }
+            }
+        }
+
+        return null;
+    }
 }
--- ./jdk/src/share/classes/sun/security/ssl/Handshaker.java	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/classes/sun/security/ssl/Handshaker.java	Mon Sep 08 12:16:34 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -348,6 +348,16 @@
         }
     }
 
+    String getEndpointIdentificationAlgorithmSE() {
+        SSLParameters paras;
+        if (conn != null) {
+            paras = conn.getSSLParameters();
+        } else {
+            paras = engine.getSSLParameters();
+        }
+        return paras.getEndpointIdentificationAlgorithm();
+    }
+
     private void setVersionSE(ProtocolVersion protocolVersion) {
         if (conn != null) {
             conn.setVersion(protocolVersion);
--- ./jdk/src/share/classes/sun/security/ssl/SSLSessionImpl.java	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/classes/sun/security/ssl/SSLSessionImpl.java	Mon Sep 08 12:16:34 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -117,6 +117,14 @@
     private Principal localPrincipal;
 
     /*
+     * Is the session currently re-established with a session-resumption
+     * abbreviated initial handshake?
+     *
+     * Note that currently we only set this variable in client side.
+     */
+    private boolean isSessionResumption = false;
+
+    /*
      * We count session creations, eventually for statistical data but
      * also since counters make shorter debugging IDs than the big ones
      * we use in the protocol for uniqueness-over-time.
@@ -320,6 +328,22 @@
     }
 
     /**
+     * Return true if the session is currently re-established with a
+     * session-resumption abreviated initial handshake.
+     */
+    boolean isSessionResumption() {
+        return isSessionResumption;
+    }
+
+    /**
+     * Resets whether the session is re-established with a session-resumption
+     * abbreviated initial handshake.
+     */
+    void setAsSessionResumption(boolean flag) {
+        isSessionResumption = flag;
+    }
+
+    /**
      * Returns the name of the cipher suite in use on this session
      */
     public String getCipherSuite() {
--- ./jdk/src/share/classes/sun/security/util/Resources_de.java	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/classes/sun/security/util/Resources_de.java	Mon Sep 08 12:16:34 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -75,7 +75,7 @@
         {"Imports.entries.from.a.JDK.1.1.x.style.identity.database",
                 "Importiert Eintr\u00E4ge aus einer Identity-Datenbank im JDK 1.1.x-Stil"}, //-identitydb
         {"Imports.a.certificate.or.a.certificate.chain",
-                "Importiert ein Zertifikat oder eine Zertifikatkette"}, //-importcert
+                "Importiert ein Zertifikat oder eine Zertifikatskette"}, //-importcert
         {"Imports.one.or.all.entries.from.another.keystore",
                 "Importiert einen oder alle Eintr\u00E4ge aus einem anderen Keystore"}, //-importkeystore
         {"Clones.a.key.entry",
@@ -301,7 +301,7 @@
                 "{0}, {1,date}, "},
         {"alias.", "{0}, "},
         {"Entry.type.type.", "Eintragstyp: {0}"},
-        {"Certificate.chain.length.", "Zertifikatkettenl\u00E4nge: "},
+        {"Certificate.chain.length.", "Zertifikatskettenl\u00E4nge: "},
         {"Certificate.i.1.", "Zertifikat[{0,number,integer}]:"},
         {"Certificate.fingerprint.SHA1.", "Zertifikat-Fingerprint (SHA1): "},
         {"Keystore.type.", "Keystore-Typ: "},
@@ -384,9 +384,9 @@
         {"Certificate.reply.does.not.contain.public.key.for.alias.",
                 "Zertifikatantwort enth\u00E4lt keinen Public Key f\u00FCr <{0}>"},
         {"Incomplete.certificate.chain.in.reply",
-                "Unvollst\u00E4ndige Zertifikatkette in Antwort"},
+                "Unvollst\u00E4ndige Zertifikatskette in Antwort"},
         {"Certificate.chain.in.reply.does.not.verify.",
-                "Zertifikatkette in Antwort verifiziert nicht: "},
+                "Zertifikatskette in Antwort verifiziert nicht: "},
         {"Top.level.certificate.in.reply.",
                 "Zertifikat der obersten Ebene in Antwort:\n"},
         {".is.not.trusted.", "... ist nicht vertrauensw\u00FCrdig. "},
--- ./jdk/src/share/classes/sun/security/util/Resources_fr.java	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/classes/sun/security/util/Resources_fr.java	Mon Sep 08 12:16:34 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -444,7 +444,7 @@
         {"Retain", "Conserver"},
 
         {"Warning.File.name.may.include.escaped.backslash.characters.It.is.not.necessary.to.escape.backslash.characters.the.tool.escapes",
-            "Avertissement : il se peut que le nom de fichier contienne des barres obliques inverses avec caract\u00E8re d'\u00E9chappement. Il n'est pas n\u00E9cessaire d'ajouter un caract\u00E8re d'\u00E9chappement aux barres obliques inverses. L'outil proc\u00E8de \u00E0 l'\u00E9chappement si n\u00E9cessaire lorsqu'il \u00E9crit le contenu des r\u00E8gles dans la zone de stockage persistant).\n\nCliquez sur Conserver pour garder le nom saisi ou sur Modifier pour le remplacer."},
+            "Avertissement : il se peut que le nom de fichier contienne des barres obliques inverses avec caract\u00E8re d'\u00E9chappement. Il n'est pas n\u00E9cessaire d'ajouter un caract\u00E8re d'\u00E9chappement aux barres obliques inverses. (L'outil proc\u00E8de \u00E0 l'\u00E9chappement si n\u00E9cessaire lorsqu'il \u00E9crit le contenu des r\u00E8gles dans la zone de stockage persistant).\n\nCliquez sur Conserver pour garder le nom saisi ou sur Modifier pour le remplacer."},
 
         {"Add.Public.Key.Alias", "Ajouter un alias de cl\u00E9 publique"},
         {"Remove.Public.Key.Alias", "Enlever un alias de cl\u00E9 publique"},
--- ./jdk/src/share/classes/sun/security/util/Resources_it.java	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/classes/sun/security/util/Resources_it.java	Mon Sep 08 12:16:34 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -340,7 +340,7 @@
                  "Immettere un nuovo nome alias\t(premere INVIO per annullare l'importazione della voce):  "},
         {"Enter.alias.name.", "Immettere nome alias:  "},
         {".RETURN.if.same.as.for.otherAlias.",
-                "\t(INVIO se corrisponde al nome di <{0}>"},
+                "\t(INVIO se corrisponde al nome di <{0}>)"},
         {".PATTERN.printX509Cert",
                 "Proprietario: {0}\nAutorit\u00E0 emittente: {1}\nNumero di serie: {2}\nValido da: {3} a: {4}\nImpronte digitali certificato:\n\t MD5:  {5}\n\t SHA1: {6}\n\t SHA256: {7}\n\t Nome algoritmo firma: {8}\n\t Versione: {9}"},
         {"What.is.your.first.and.last.name.",
--- ./jdk/src/share/classes/sun/security/util/Resources_pt_BR.java	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/classes/sun/security/util/Resources_pt_BR.java	Mon Sep 08 12:16:34 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -62,7 +62,7 @@
         {"Changes.an.entry.s.alias",
                 "Altera um alias de entrada"}, //-changealias
         {"Deletes.an.entry",
-                "Deleta uma entrada"}, //-delete
+                "Exclui uma entrada"}, //-delete
         {"Exports.certificate",
                 "Exporta o certificado"}, //-exportcert
         {"Generates.a.key.pair",
--- ./jdk/src/share/classes/sun/tools/jconsole/resources/messages_ja.properties	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/classes/sun/tools/jconsole/resources/messages_ja.properties	Mon Sep 08 12:16:34 2014 -0700
@@ -31,7 +31,7 @@
 CPU_USAGE=CPU\u4F7F\u7528\u7387
 CPU_USAGE_FORMAT=CPU\u4F7F\u7528\u7387: {0}%
 CANCEL=\u53D6\u6D88
-CASCADE=\u91CD\u306D\u3066\u8868\u793A(&C)
+CASCADE=\u30AB\u30B9\u30B1\u30FC\u30C9\u8868\u793A(&C)
 CHART_COLON=\u30C1\u30E3\u30FC\u30C8(&C):
 CLASS_PATH=\u30AF\u30E9\u30B9\u30D1\u30B9
 CLASS_NAME=ClassName
@@ -227,7 +227,7 @@
 THREAD_TAB_THREAD_INFO_ACCESSIBLE_NAME=\u30B9\u30EC\u30C3\u30C9\u60C5\u5831
 THREAD_TAB_THREAD_PLOTTER_ACCESSIBLE_NAME=\u30B9\u30EC\u30C3\u30C9\u6570\u306E\u30C1\u30E3\u30FC\u30C8\u3002
 THRESHOLD=\u3057\u304D\u3044\u5024
-TILE=\u4E26\u3079\u3066\u8868\u793A(&T)
+TILE=\u30BF\u30A4\u30EB\u8868\u793A(&T)
 TIME_RANGE_COLON=\u6642\u9593\u7BC4\u56F2(&T):
 TIME=\u6642\u9593
 TIME_STAMP=TimeStamp
@@ -252,7 +252,7 @@
 USER_DATA=UserData
 VIRTUAL_MACHINE=\u4EEE\u60F3\u30DE\u30B7\u30F3
 VM_ARGUMENTS=VM\u5F15\u6570
-VMINTERNAL_FRAME_ACCESSIBLE_DESCRIPTION=Java\u4EEE\u60F3\u30DE\u30B7\u30F3\u306E\u30E2\u30CB\u30BF\u30FC\u7528\u306E\u5185\u90E8\u30D5\u30EC\u30FC\u30E0
+VMINTERNAL_FRAME_ACCESSIBLE_DESCRIPTION=Java\u4EEE\u60F3\u30DE\u30B7\u30F3\u306E\u30E2\u30CB\u30BF\u30EA\u30F3\u30B0\u7528\u306E\u5185\u90E8\u30D5\u30EC\u30FC\u30E0
 VALUE=\u5024
 VENDOR=\u30D9\u30F3\u30C0\u30FC
 VERBOSE_OUTPUT=\u8A73\u7D30\u51FA\u529B
@@ -274,4 +274,4 @@
 KBYTES={0} KB
 PLOT=\u30D7\u30ED\u30C3\u30C8
 VISUALIZE=\u8996\u899A\u5316
-ZZ_USAGE_TEXT=\u4F7F\u7528\u65B9\u6CD5: {0} [ -interval=n ] [ -notile ] [ -pluginpath <path> ] [ -version ] [ connection ... ]\n\n  -interval   \u66F4\u65B0\u9593\u9694\u3092n\u79D2\u306B\u8A2D\u5B9A\u3059\u308B(\u30C7\u30D5\u30A9\u30EB\u30C8\u306F4\u79D2)\n  -notile     \u30A6\u30A3\u30F3\u30C9\u30A6\u3092\u6700\u521D\u306B\u4E26\u3079\u3066\u8868\u793A\u3057\u306A\u3044(2\u3064\u4EE5\u4E0A\u306E\u63A5\u7D9A\u306B\u3064\u3044\u3066)\n  -pluginpath JConsole\u304C\u30D7\u30E9\u30B0\u30A4\u30F3\u3092\u53C2\u7167\u3059\u308B\u305F\u3081\u306B\u4F7F\u7528\u3059\u308B\u30D1\u30B9\u3092\u6307\u5B9A\u3059\u308B\n  -version    \u30D7\u30ED\u30B0\u30E9\u30E0\u30FB\u30D0\u30FC\u30B8\u30E7\u30F3\u3092\u51FA\u529B\u3059\u308B\n\n  connection = pid || host:port || JMX URL (service:jmx:<protocol>://...)\n  pid         \u30BF\u30FC\u30B2\u30C3\u30C8\u30FB\u30D7\u30ED\u30BB\u30B9\u306E\u30D7\u30ED\u30BB\u30B9ID\n  host        \u30EA\u30E2\u30FC\u30C8\u30FB\u30DB\u30B9\u30C8\u540D\u307E\u305F\u306FIP\u30A2\u30C9\u30EC\u30B9\n  port        \u30EA\u30E2\u30FC\u30C8\u63A5\u7D9A\u7528\u306E\u30DD\u30FC\u30C8\u756A\u53F7\n\n  -J          JConsole\u304C\u5B9F\u884C\u4E2D\u306EJava\u4EEE\u60F3\u30DE\u30B7\u30F3\u3078\u306E\n              \u5165\u529B\u5F15\u6570\u3092\u6307\u5B9A\u3059\u308B
+ZZ_USAGE_TEXT=\u4F7F\u7528\u65B9\u6CD5: {0} [ -interval=n ] [ -notile ] [ -pluginpath <path> ] [ -version ] [ connection ... ]\n\n  -interval   \u66F4\u65B0\u9593\u9694\u3092n\u79D2\u306B\u8A2D\u5B9A\u3059\u308B(\u30C7\u30D5\u30A9\u30EB\u30C8\u306F4\u79D2)\n  -notile     \u30A6\u30A3\u30F3\u30C9\u30A6\u3092\u6700\u521D\u306B\u30BF\u30A4\u30EB\u8868\u793A\u3057\u306A\u3044(2\u3064\u4EE5\u4E0A\u306E\u63A5\u7D9A\u306B\u3064\u3044\u3066)\n  -pluginpath JConsole\u304C\u30D7\u30E9\u30B0\u30A4\u30F3\u3092\u53C2\u7167\u3059\u308B\u305F\u3081\u306B\u4F7F\u7528\u3059\u308B\u30D1\u30B9\u3092\u6307\u5B9A\u3059\u308B\n  -version    \u30D7\u30ED\u30B0\u30E9\u30E0\u30FB\u30D0\u30FC\u30B8\u30E7\u30F3\u3092\u51FA\u529B\u3059\u308B\n\n  connection = pid || host:port || JMX URL (service:jmx:<protocol>://...)\n  pid         \u30BF\u30FC\u30B2\u30C3\u30C8\u30FB\u30D7\u30ED\u30BB\u30B9\u306E\u30D7\u30ED\u30BB\u30B9ID\n  host        \u30EA\u30E2\u30FC\u30C8\u30FB\u30DB\u30B9\u30C8\u540D\u307E\u305F\u306FIP\u30A2\u30C9\u30EC\u30B9\n  port        \u30EA\u30E2\u30FC\u30C8\u63A5\u7D9A\u7528\u306E\u30DD\u30FC\u30C8\u756A\u53F7\n\n  -J          JConsole\u304C\u5B9F\u884C\u4E2D\u306EJava\u4EEE\u60F3\u30DE\u30B7\u30F3\u3078\u306E\n              \u5165\u529B\u5F15\u6570\u3092\u6307\u5B9A\u3059\u308B
--- ./jdk/src/share/classes/sun/util/locale/BaseLocale.java	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/classes/sun/util/locale/BaseLocale.java	Mon Sep 08 12:16:34 2014 -0700
@@ -31,6 +31,7 @@
  */
 
 package sun.util.locale;
+import java.lang.ref.SoftReference;
 
 
 public final class BaseLocale {
@@ -163,11 +164,11 @@
         return h;
     }
 
-    private static final class Key implements Comparable<Key> {
-        private final String lang;
-        private final String scrt;
-        private final String regn;
-        private final String vart;
+    private static final class Key {
+        private final SoftReference<String> lang;
+        private final SoftReference<String> scrt;
+        private final SoftReference<String> regn;
+        private final SoftReference<String> vart;
         private final boolean normalized;
         private final int hash;
 
@@ -179,10 +180,10 @@
             assert language.intern() == language
                    && region.intern() == region;
 
-            lang = language;
-            scrt = "";
-            regn = region;
-            vart = "";
+            lang = new SoftReference(language);
+            scrt = new SoftReference("");
+            regn = new SoftReference(region);
+            vart = new SoftReference("");
             this.normalized = true;
 
             int h = language.hashCode();
@@ -203,40 +204,40 @@
                     String variant, boolean normalized) {
             int h = 0;
             if (language != null) {
-                lang = language;
+                lang = new SoftReference(language);
                 int len = language.length();
                 for (int i = 0; i < len; i++) {
                     h = 31*h + LocaleUtils.toLower(language.charAt(i));
                 }
             } else {
-                lang = "";
+                lang = new SoftReference("");
             }
             if (script != null) {
-                scrt = script;
+                scrt = new SoftReference(script);
                 int len = script.length();
                 for (int i = 0; i < len; i++) {
                     h = 31*h + LocaleUtils.toLower(script.charAt(i));
                 }
             } else {
-                scrt = "";
+                scrt = new SoftReference("");
             }
             if (region != null) {
-                regn = region;
+                regn = new SoftReference(region);
                 int len = region.length();
                 for (int i = 0; i < len; i++) {
                     h = 31*h + LocaleUtils.toLower(region.charAt(i));
                 }
             } else {
-                regn = "";
+                regn = new SoftReference("");
             }
             if (variant != null) {
-                vart = variant;
+                vart = new SoftReference(variant);
                 int len = variant.length();
                 for (int i = 0; i < len; i++) {
                     h = 31*h + variant.charAt(i);
                 }
             } else {
-                vart = "";
+                vart = new SoftReference("");
             }
             hash = h;
             this.normalized = normalized;
@@ -244,28 +245,31 @@
 
         @Override
         public boolean equals(Object obj) {
-            return (this == obj) ||
-                    (obj instanceof Key)
-                    && this.hash == ((Key)obj).hash
-                    && LocaleUtils.caseIgnoreMatch(((Key)obj).lang, this.lang)
-                    && LocaleUtils.caseIgnoreMatch(((Key)obj).scrt, this.scrt)
-                    && LocaleUtils.caseIgnoreMatch(((Key)obj).regn, this.regn)
-                    && ((Key)obj).vart.equals(vart); // variant is case sensitive in JDK!
+            if (this == obj) {
+                return true;
         }
 
-        @Override
-        public int compareTo(Key other) {
-            int res = LocaleUtils.caseIgnoreCompare(this.lang, other.lang);
-            if (res == 0) {
-                res = LocaleUtils.caseIgnoreCompare(this.scrt, other.scrt);
-                if (res == 0) {
-                    res = LocaleUtils.caseIgnoreCompare(this.regn, other.regn);
-                    if (res == 0) {
-                        res = this.vart.compareTo(other.vart);
+            if (obj instanceof Key && this.hash == ((Key)obj).hash) {
+                String tl = this.lang.get();
+                String ol = ((Key)obj).lang.get();
+                if (tl != null && ol != null &&
+                    LocaleUtils.caseIgnoreMatch(ol, tl)) {
+                    String ts = this.scrt.get();
+                    String os = ((Key)obj).scrt.get();
+                    if (ts != null && os != null &&
+                        LocaleUtils.caseIgnoreMatch(os, ts)) {
+                        String tr = this.regn.get();
+                        String or = ((Key)obj).regn.get();
+                        if (tr != null && or != null &&
+                            LocaleUtils.caseIgnoreMatch(or, tr)) {
+                            String tv = this.vart.get();
+                            String ov = ((Key)obj).vart.get();
+                            return (ov != null && ov.equals(tv));
                     }
                 }
             }
-            return res;
+            }
+            return false;
         }
 
         @Override
@@ -278,10 +282,10 @@
                 return key;
             }
 
-            String lang = LocaleUtils.toLowerString(key.lang).intern();
-            String scrt = LocaleUtils.toTitleString(key.scrt).intern();
-            String regn = LocaleUtils.toUpperString(key.regn).intern();
-            String vart = key.vart.intern(); // preserve upper/lower cases
+            String lang = LocaleUtils.toLowerString(key.lang.get()).intern();
+            String scrt = LocaleUtils.toTitleString(key.scrt.get()).intern();
+            String regn = LocaleUtils.toUpperString(key.regn.get()).intern();
+            String vart = key.vart.get().intern(); // preserve upper/lower cases
 
             return new Key(lang, scrt, regn, vart, true);
         }
@@ -294,12 +298,18 @@
 
         @Override
         protected Key normalizeKey(Key key) {
+            assert key.lang.get() != null &&
+                   key.scrt.get() != null &&
+                   key.regn.get() != null &&
+                   key.vart.get() != null;
+
             return Key.normalize(key);
         }
 
         @Override
         protected BaseLocale createObject(Key key) {
-            return new BaseLocale(key.lang, key.scrt, key.regn, key.vart);
+            return new BaseLocale(key.lang.get(), key.scrt.get(),
+                                  key.regn.get(), key.vart.get());
         }
     }
 }
--- ./jdk/src/share/classes/sun/util/locale/LocaleObjectCache.java	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/classes/sun/util/locale/LocaleObjectCache.java	Mon Sep 08 12:16:34 2014 -0700
@@ -57,8 +57,10 @@
             value = entry.get();
         }
         if (value == null) {
+            V newVal = createObject(key);
+            // make sure key is normalized *after* the object creation
+            // so that newVal is assured to be created from a valid key.
             key = normalizeKey(key);
-            V newVal = createObject(key);
             if (key == null || newVal == null) {
                 // subclass must return non-null key/value object
                 return null;
--- ./jdk/src/share/javavm/export/jvm.h	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/javavm/export/jvm.h	Mon Sep 08 12:16:34 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -384,6 +384,19 @@
 JVM_FindClassFromBootLoader(JNIEnv *env, const char *name);
 
 /*
+ * Find a class from a given class loader.  Throws ClassNotFoundException.
+ *  name:   name of class
+ *  init:   whether initialization is done
+ *  loader: class loader to look up the class. This may not be the same as the caller's
+ *          class loader.
+ *  caller: initiating class. The initiating class may be null when a security
+ *          manager is not installed.
+ */
+JNIEXPORT jclass JNICALL
+JVM_FindClassFromCaller(JNIEnv *env, const char *name, jboolean init,
+                        jobject loader, jclass caller);
+
+/*
  * Find a class from a given class loader. Throw ClassNotFoundException
  * or NoClassDefFoundError depending on the value of the last
  * argument.
--- ./jdk/src/share/native/java/lang/Class.c	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/native/java/lang/Class.c	Mon Sep 08 12:16:34 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1994, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1994, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -97,7 +97,7 @@
 
 JNIEXPORT jclass JNICALL
 Java_java_lang_Class_forName0(JNIEnv *env, jclass this, jstring classname,
-                              jboolean initialize, jobject loader)
+                              jboolean initialize, jobject loader, jclass caller)
 {
     char *clname;
     jclass cls = 0;
@@ -135,8 +135,7 @@
         goto done;
     }
 
-    cls = JVM_FindClassFromClassLoader(env, clname, initialize,
-                                       loader, JNI_FALSE);
+    cls = JVM_FindClassFromCaller(env, clname, initialize, loader, caller);
 
  done:
     if (clname != buf) {
--- ./jdk/src/share/native/sun/font/layout/ContextualSubstSubtables.cpp	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/native/sun/font/layout/ContextualSubstSubtables.cpp	Mon Sep 08 12:16:34 2014 -0700
@@ -243,12 +243,22 @@
         le_uint16 srSetCount = SWAPW(subRuleSetCount);
 
         if (coverageIndex < srSetCount) {
+            LEReferenceToArrayOf<Offset> subRuleSetTableOffsetArrayRef(base, success,
+                    &subRuleSetTableOffsetArray[coverageIndex], 1);
+            if (LE_FAILURE(success)) {
+                return 0;
+            }
             Offset subRuleSetTableOffset = SWAPW(subRuleSetTableOffsetArray[coverageIndex]);
             LEReferenceTo<SubRuleSetTable>
                  subRuleSetTable(base, success, (const SubRuleSetTable *) ((char *) this + subRuleSetTableOffset));
             le_uint16 subRuleCount = SWAPW(subRuleSetTable->subRuleCount);
             le_int32 position = glyphIterator->getCurrStreamPosition();
 
+            LEReferenceToArrayOf<Offset> subRuleTableOffsetArrayRef(base, success,
+                    subRuleSetTable->subRuleTableOffsetArray, subRuleCount);
+            if (LE_FAILURE(success)) {
+                return 0;
+            }
             for (le_uint16 subRule = 0; subRule < subRuleCount; subRule += 1) {
                 Offset subRuleTableOffset =
                     SWAPW(subRuleSetTable->subRuleTableOffsetArray[subRule]);
@@ -301,13 +311,22 @@
                                                                 glyphIterator->getCurrGlyphID(),
                                                                 success);
 
-        if (setClass < scSetCount && subClassSetTableOffsetArray[setClass] != 0) {
+        if (setClass < scSetCount) {
+            LEReferenceToArrayOf<Offset>
+                 subClassSetTableOffsetArrayRef(base, success, subClassSetTableOffsetArray, setClass);
+            if (LE_FAILURE(success)) { return 0; }
+            if (subClassSetTableOffsetArray[setClass] != 0) {
+
             Offset subClassSetTableOffset = SWAPW(subClassSetTableOffsetArray[setClass]);
             LEReferenceTo<SubClassSetTable>
                  subClassSetTable(base, success, (const SubClassSetTable *) ((char *) this + subClassSetTableOffset));
             le_uint16 subClassRuleCount = SWAPW(subClassSetTable->subClassRuleCount);
             le_int32 position = glyphIterator->getCurrStreamPosition();
-
+                LEReferenceToArrayOf<Offset>
+                    subClassRuleTableOffsetArrayRef(base, success, subClassSetTable->subClassRuleTableOffsetArray, subClassRuleCount);
+                if (LE_FAILURE(success)) {
+                    return 0;
+                }
             for (le_uint16 scRule = 0; scRule < subClassRuleCount; scRule += 1) {
                 Offset subClassRuleTableOffset =
                     SWAPW(subClassSetTable->subClassRuleTableOffsetArray[scRule]);
@@ -331,6 +350,7 @@
                 glyphIterator->setCurrStreamPosition(position);
             }
         }
+        }
 
         // XXX If we get here, the table is mal-formed...
     }
@@ -442,13 +462,22 @@
         le_uint16 srSetCount = SWAPW(chainSubRuleSetCount);
 
         if (coverageIndex < srSetCount) {
+            LEReferenceToArrayOf<Offset>
+                chainSubRuleSetTableOffsetArrayRef(base, success, chainSubRuleSetTableOffsetArray, coverageIndex);
+            if (LE_FAILURE(success)) {
+                return 0;
+            }
             Offset chainSubRuleSetTableOffset = SWAPW(chainSubRuleSetTableOffsetArray[coverageIndex]);
             LEReferenceTo<ChainSubRuleSetTable>
                  chainSubRuleSetTable(base, success, (const ChainSubRuleSetTable *) ((char *) this + chainSubRuleSetTableOffset));
             le_uint16 chainSubRuleCount = SWAPW(chainSubRuleSetTable->chainSubRuleCount);
             le_int32 position = glyphIterator->getCurrStreamPosition();
             GlyphIterator tempIterator(*glyphIterator, emptyFeatureList);
-
+            LEReferenceToArrayOf<Offset>
+                chainSubRuleTableOffsetArrayRef(base, success, chainSubRuleSetTable->chainSubRuleTableOffsetArray, chainSubRuleCount);
+            if (LE_FAILURE(success)) {
+                return 0;
+            }
             for (le_uint16 subRule = 0; subRule < chainSubRuleCount; subRule += 1) {
                 Offset chainSubRuleTableOffset =
                     SWAPW(chainSubRuleSetTable->chainSubRuleTableOffsetArray[subRule]);
@@ -530,6 +559,11 @@
         le_int32 setClass = inputClassDefinitionTable->getGlyphClass(inputClassDefinitionTable,
                                                                      glyphIterator->getCurrGlyphID(),
                                                                      success);
+        LEReferenceToArrayOf<Offset>
+            chainSubClassSetTableOffsetArrayRef(base, success, chainSubClassSetTableOffsetArray, setClass);
+        if (LE_FAILURE(success)) {
+            return 0;
+        }
 
         if (setClass < scSetCount && chainSubClassSetTableOffsetArray[setClass] != 0) {
             Offset chainSubClassSetTableOffset = SWAPW(chainSubClassSetTableOffsetArray[setClass]);
@@ -538,7 +572,11 @@
             le_uint16 chainSubClassRuleCount = SWAPW(chainSubClassSetTable->chainSubClassRuleCount);
             le_int32 position = glyphIterator->getCurrStreamPosition();
             GlyphIterator tempIterator(*glyphIterator, emptyFeatureList);
-
+            LEReferenceToArrayOf<Offset>
+                chainSubClassRuleTableOffsetArrayRef(base, success, chainSubClassSetTable->chainSubClassRuleTableOffsetArray, chainSubClassRuleCount);
+            if (LE_FAILURE(success)) {
+                return 0;
+            }
             for (le_uint16 scRule = 0; scRule < chainSubClassRuleCount; scRule += 1) {
                 Offset chainSubClassRuleTableOffset =
                     SWAPW(chainSubClassSetTable->chainSubClassRuleTableOffsetArray[scRule]);
@@ -603,12 +641,14 @@
     }
 
     le_uint16 backtrkGlyphCount = SWAPW(backtrackGlyphCount);
+    LEReferenceToArrayOf<Offset> backtrackGlyphArrayRef(base, success, backtrackCoverageTableOffsetArray, backtrkGlyphCount);
+    if (LE_FAILURE(success)) {
+        return 0;
+    }
     le_uint16 inputGlyphCount = (le_uint16) SWAPW(backtrackCoverageTableOffsetArray[backtrkGlyphCount]);
     LEReferenceToArrayOf<Offset>   inputCoverageTableOffsetArray(base, success, &backtrackCoverageTableOffsetArray[backtrkGlyphCount + 1], inputGlyphCount+2); // offset
     if (LE_FAILURE(success)) { return 0; }
     const le_uint16 lookaheadGlyphCount = (le_uint16) SWAPW(inputCoverageTableOffsetArray[inputGlyphCount]);
-
-    if( LE_FAILURE(success) ) { return 0; }
     LEReferenceToArrayOf<Offset>   lookaheadCoverageTableOffsetArray(base, success, inputCoverageTableOffsetArray.getAlias(inputGlyphCount + 1, success), lookaheadGlyphCount+2);
 
     if( LE_FAILURE(success) ) { return 0; }
--- ./jdk/src/share/native/sun/font/layout/LEScripts.h	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/share/native/sun/font/layout/LEScripts.h	Mon Sep 08 12:16:34 2014 -0700
@@ -263,12 +263,6 @@
     tirhScriptCode = 158,
 
 /**
- * @stable ICU 52
- */
-    aghbScriptCode = 159,
-    mahjScriptCode = 160,
-
-/**
  * @stable ICU 2.2
  */
     scriptCodeCount
--- ./jdk/src/solaris/classes/sun/print/CUPSPrinter.java	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/solaris/classes/sun/print/CUPSPrinter.java	Mon Sep 08 12:16:34 2014 -0700
@@ -121,7 +121,7 @@
     /**
      * Returns array of MediaSizeNames derived from PPD.
      */
-    public MediaSizeName[] getMediaSizeNames() {
+    MediaSizeName[] getMediaSizeNames() {
         initMedia();
         return cupsMediaSNames;
     }
@@ -130,7 +130,7 @@
     /**
      * Returns array of Custom MediaSizeNames derived from PPD.
      */
-    public CustomMediaSizeName[] getCustomMediaSizeNames() {
+    CustomMediaSizeName[] getCustomMediaSizeNames() {
         initMedia();
         return cupsCustomMediaSNames;
     }
@@ -139,7 +139,7 @@
     /**
      * Returns array of MediaPrintableArea derived from PPD.
      */
-    public MediaPrintableArea[] getMediaPrintableArea() {
+    MediaPrintableArea[] getMediaPrintableArea() {
         initMedia();
         return cupsMediaPrintables;
     }
@@ -147,7 +147,7 @@
     /**
      * Returns array of MediaTrays derived from PPD.
      */
-    public MediaTray[] getMediaTrays() {
+    MediaTray[] getMediaTrays() {
         initMedia();
         return cupsMediaTrays;
     }
--- ./jdk/src/solaris/classes/sun/print/IPPPrintService.java	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/solaris/classes/sun/print/IPPPrintService.java	Mon Sep 08 12:16:34 2014 -0700
@@ -991,7 +991,9 @@
 
     public synchronized Class[] getSupportedAttributeCategories() {
         if (supportedCats != null) {
-            return supportedCats;
+            Class<?> [] copyCats = new Class<?>[supportedCats.length];
+            System.arraycopy(supportedCats, 0, copyCats, 0, copyCats.length);
+            return copyCats;
         }
 
         initAttributes();
@@ -1048,7 +1050,9 @@
         }
         supportedCats = new Class[catList.size()];
         catList.toArray(supportedCats);
-        return supportedCats;
+        Class<?>[] copyCats = new Class<?>[supportedCats.length];
+        System.arraycopy(supportedCats, 0, copyCats, 0, copyCats.length);
+        return copyCats;
     }
 
 
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/src/solaris/native/java/net/AbstractPlainDatagramSocketImpl.c	Mon Sep 08 12:16:34 2014 -0700
@@ -0,0 +1,89 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#include <sys/types.h>
+#include <sys/socket.h>
+
+#ifdef __solaris__
+#include <unistd.h>
+#include <stropts.h>
+
+#ifndef BSD_COMP
+#define BSD_COMP
+#endif
+
+#endif
+
+#include <sys/ioctl.h>
+
+#include "jvm.h"
+#include "jni_util.h"
+#include "net_util.h"
+
+#include "java_net_AbstractPlainDatagramSocketImpl.h"
+
+static jfieldID IO_fd_fdID;
+
+static jfieldID apdsi_fdID;
+
+
+/*
+ * Class:     java_net_AbstractPlainDatagramSocketImpl
+ * Method:    init
+ * Signature: ()V
+ */
+JNIEXPORT void JNICALL
+Java_java_net_AbstractPlainDatagramSocketImpl_init(JNIEnv *env, jclass cls) {
+
+    apdsi_fdID = (*env)->GetFieldID(env, cls, "fd",
+                                   "Ljava/io/FileDescriptor;");
+    CHECK_NULL(apdsi_fdID);
+
+    IO_fd_fdID = NET_GetFileDescriptorID(env);
+}
+
+/*
+ * Class:     java_net_AbstractPlainDatagramSocketImpl
+ * Method:    dataAvailable
+ * Signature: ()I
+ */
+JNIEXPORT jint JNICALL Java_java_net_AbstractPlainDatagramSocketImpl_dataAvailable
+(JNIEnv *env, jobject this) {
+    int fd, retval;
+
+    jobject fdObj = (*env)->GetObjectField(env, this, apdsi_fdID);
+
+    if (IS_NULL(fdObj)) {
+        JNU_ThrowByName(env, JNU_JAVANETPKG "SocketException",
+                        "Socket closed");
+        return -1;
+    }
+    fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);
+
+    if (ioctl(fd, FIONREAD, &retval) < 0) {
+        return -1;
+    }
+    return retval;
+}
--- ./jdk/src/solaris/native/java/util/FileSystemPreferences.c	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/solaris/native/java/util/FileSystemPreferences.c	Mon Sep 08 12:16:34 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001, 2004, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -38,12 +38,14 @@
 JNIEXPORT jint JNICALL
 Java_java_util_prefs_FileSystemPreferences_chmod(JNIEnv *env,
                        jclass thisclass, jstring java_fname, jint permission) {
-    const char *fname = JNU_GetStringPlatformChars(env, java_fname, JNI_FALSE);
-    int result;
-    result =  chmod(fname, permission);
-    if (result != 0)
-       result = errno;
-    JNU_ReleaseStringPlatformChars(env, java_fname, fname);
+    const char *fname = JNU_GetStringPlatformChars(env, java_fname, NULL);
+    int result = -1;
+    if (fname) {
+        result =  chmod(fname, permission);
+        if (result != 0)
+            result = errno;
+        JNU_ReleaseStringPlatformChars(env, java_fname, fname);
+    }
     return (jint) result;
 }
 
@@ -61,13 +63,16 @@
 JNIEXPORT jintArray JNICALL
 Java_java_util_prefs_FileSystemPreferences_lockFile0(JNIEnv *env,
     jclass thisclass, jstring java_fname, jint permission, jboolean shared) {
-    const char *fname = JNU_GetStringPlatformChars(env, java_fname, JNI_FALSE);
+    const char *fname = JNU_GetStringPlatformChars(env, java_fname, NULL);
     int fd, rc;
     int result[2];
-    jintArray javaResult;
+    jintArray javaResult = NULL;
     int old_umask;
     FLOCK fl;
 
+    if (!fname)
+        return javaResult;
+
     fl.l_whence = SEEK_SET;
     fl.l_len = 0;
     fl.l_start = 0;
@@ -104,7 +109,8 @@
     }
     JNU_ReleaseStringPlatformChars(env, java_fname, fname);
     javaResult = (*env)->NewIntArray(env,2);
-    (*env)->SetIntArrayRegion(env, javaResult, 0, 2, result);
+    if (javaResult)
+        (*env)->SetIntArrayRegion(env, javaResult, 0, 2, result);
     return javaResult;
 }
 
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/src/windows/native/java/net/AbstractPlainDatagramSocketImpl.c	Mon Sep 08 12:16:34 2014 -0700
@@ -0,0 +1,111 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#include <windows.h>
+#include <winsock2.h>
+
+#include "jvm.h"
+#include "jni_util.h"
+#include "net_util.h"
+
+#include "java_net_AbstractPlainDatagramSocketImpl.h"
+
+static jfieldID IO_fd_fdID = NULL;
+static jfieldID apdsi_fdID = NULL;
+
+static jfieldID apdsi_fd1ID = NULL;
+static jclass two_stacks_clazz = NULL;
+
+
+/*
+ * Class:     java_net_AbstractPlainDatagramSocketImpl
+ * Method:    init
+ * Signature: ()V
+ */
+JNIEXPORT void JNICALL
+Java_java_net_AbstractPlainDatagramSocketImpl_init(JNIEnv *env, jclass cls) {
+
+    apdsi_fdID = (*env)->GetFieldID(env, cls, "fd",
+                                   "Ljava/io/FileDescriptor;");
+    CHECK_NULL(apdsi_fdID);
+    IO_fd_fdID = NET_GetFileDescriptorID(env);
+    CHECK_NULL(IO_fd_fdID);
+
+    two_stacks_clazz = (*env)->FindClass(env, "java/net/TwoStacksPlainDatagramSocketImpl");
+    CHECK_NULL(two_stacks_clazz);
+
+    /* Handle both TwoStacks and DualStack here */
+
+    if (JNU_Equals(env, cls, two_stacks_clazz)) {
+        /* fd1 present only in TwoStack.. */
+        apdsi_fd1ID = (*env)->GetFieldID(env, cls, "fd1",
+                                   "Ljava/io/FileDescriptor;");
+        CHECK_NULL(apdsi_fd1ID);
+    }
+}
+
+/*
+ * Class:     java_net_AbstractPlainDatagramSocketImpl
+ * Method:    dataAvailable
+ * Signature: ()I
+ */
+JNIEXPORT jint JNICALL Java_java_net_AbstractPlainDatagramSocketImpl_dataAvailable
+(JNIEnv *env, jobject this) {
+    SOCKET fd;
+    SOCKET fd1;
+    int  rv = -1, rv1 = -1;
+    jobject fdObj = (*env)->GetObjectField(env, this, apdsi_fdID);
+
+    if (!IS_NULL(fdObj)) {
+        int retval = 0;
+        fd = (SOCKET)(*env)->GetIntField(env, fdObj, IO_fd_fdID);
+        rv = ioctlsocket(fd, FIONREAD, &retval);
+        if (retval > 0) {
+            return retval;
+        }
+    }
+
+    if (!IS_NULL(apdsi_fd1ID)) {
+        /* TwoStacks */
+        jobject fd1Obj = (*env)->GetObjectField(env, this, apdsi_fd1ID);
+        if (!IS_NULL(fd1Obj)) {
+            int retval = 0;
+            fd1 = (SOCKET)(*env)->GetIntField(env, fd1Obj, IO_fd_fdID);
+            rv1 = ioctlsocket(fd1, FIONREAD, &retval);
+            if (retval > 0) {
+                return retval;
+            }
+        }
+    }
+
+    if (rv < 0 && rv1 < 0) {
+        JNU_ThrowByName(env, JNU_JAVANETPKG "SocketException",
+                            "Socket closed");
+        return -1;
+    }
+
+    return 0;
+}
+
--- ./jdk/src/windows/native/java/net/NetworkInterface_winXP.c	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/windows/native/java/net/NetworkInterface_winXP.c	Mon Sep 08 12:16:34 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -145,8 +145,12 @@
     ptr = adapterInfo;
     ret = NULL;
     while (ptr != NULL) {
-      // IPv4 interface
-      if (ptr->Ipv6IfIndex == index) {
+      // in theory the IPv4 index and the IPv6 index can be the same
+      // where an interface is enabled for v4 and v6
+      // IfIndex == 0 IPv4 not available on this interface
+      // Ipv6IfIndex == 0 IPv6 not available on this interface
+      if (((ptr->IfIndex != 0)&&(ptr->IfIndex == index)) ||
+          ((ptr->Ipv6IfIndex !=0) && (ptr->Ipv6IfIndex == index))) {
         ret = (IP_ADAPTER_ADDRESSES *) malloc(sizeof(IP_ADAPTER_ADDRESSES));
         memcpy(ret, ptr, sizeof(IP_ADAPTER_ADDRESSES));
       }
@@ -241,7 +245,7 @@
                          * set the index to the IPv6 index and add the
                          * IPv6 addresses
                          */
-                        nif->index = ptr->Ipv6IfIndex;
+                        nif->ipv6Index = ptr->Ipv6IfIndex;
                         c = getAddrsFromAdapter(ptr, &nif->addrs);
                         nif->naddrs += c;
                         break;
@@ -286,6 +290,9 @@
                     strcpy (nif->name, newname);
                     wcscpy ((PWCHAR)nif->displayName, ptr->FriendlyName);
                     nif->dNameIsUnicode = TRUE;
+
+                    // the java.net.NetworkInterface abstraction only has index
+                    // so the Ipv6IfIndex needs to map onto index
                     nif->index = ptr->Ipv6IfIndex;
                     nif->ipv6Index = ptr->Ipv6IfIndex;
                     nif->hasIpv6Address = TRUE;
@@ -442,7 +449,6 @@
     (*env)->SetObjectField(env, netifObj, ni_nameID, name);
     (*env)->SetObjectField(env, netifObj, ni_displayNameID, displayName);
     (*env)->SetIntField(env, netifObj, ni_indexID, ifs->index);
-
     /*
      * Get the IP addresses for this interface if necessary
      * Note that 0 is a valid number of addresses.
--- ./jdk/src/windows/native/sun/awt/splashscreen/splashscreen_sys.c	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/src/windows/native/sun/awt/splashscreen/splashscreen_sys.c	Mon Sep 08 12:16:34 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -213,6 +213,14 @@
 void
 SplashRedrawWindow(Splash * splash)
 {
+    if (!SplashIsStillLooping(splash)) {
+        KillTimer(splash->hWnd, 0);
+    }
+
+    if (splash->currentFrame < 0) {
+        return;
+    }
+
     SplashUpdateScreenData(splash);
     if (splash->isLayered) {
         BLENDFUNCTION bf;
@@ -303,9 +311,6 @@
             time = 0;
         SetTimer(splash->hWnd, 0, time, NULL);
     }
-    else {
-        KillTimer(splash->hWnd, 0);
-    }
 }
 
 void SplashReconfigureNow(Splash * splash) {
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/awt/Frame/ExceptionOnSetExtendedStateTest/ExceptionOnSetExtendedStateTest.java	Mon Sep 08 12:16:34 2014 -0700
@@ -0,0 +1,104 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/* @test
+   @bug 8032078
+   @summary Frame.setExtendedState throws RuntimeException, if
+            windowState=ICONIFIED|MAXIMIZED_BOTH, on OS X
+   @author Anton Litvinov
+*/
+
+import java.awt.*;
+
+import sun.awt.SunToolkit;
+
+public class ExceptionOnSetExtendedStateTest {
+    private static final int[] frameStates = { Frame.NORMAL, Frame.ICONIFIED, Frame.MAXIMIZED_BOTH };
+    private static final SunToolkit toolkit = (SunToolkit)Toolkit.getDefaultToolkit();
+
+    private static boolean validatePlatform() {
+        String osName = System.getProperty("os.name");
+        if (osName == null) {
+            throw new RuntimeException("Name of the current OS could not be retrieved.");
+        }
+        return osName.startsWith("Mac");
+    }
+
+    private static void testStateChange(int oldState, int newState, boolean decoratedFrame) {
+        System.out.println(String.format(
+            "testStateChange: oldState='%d', newState='%d', decoratedFrame='%b'",
+            oldState, newState, decoratedFrame));
+
+        Frame frame = new Frame("ExceptionOnSetExtendedStateTest");
+        frame.setSize(200, 200);
+        frame.setUndecorated(!decoratedFrame);
+        frame.setVisible(true);
+        toolkit.realSync();
+
+        frame.setExtendedState(oldState);
+        sleep(1000);
+        frame.setExtendedState(newState);
+
+        boolean stateWasNotChanged = true;
+        int currentState = 0;
+        for (int i = 0; (i < 3) && stateWasNotChanged; i++) {
+            sleep(1000);
+            currentState = frame.getExtendedState();
+            if ((currentState == newState) ||
+                (((newState & Frame.ICONIFIED) != 0) && ((currentState & Frame.ICONIFIED) != 0))) {
+                stateWasNotChanged = false;
+            }
+        }
+        frame.dispose();
+
+        if (stateWasNotChanged) {
+            throw new RuntimeException(String.format(
+                "Frame state was not changed. currentState='%d'", currentState));
+        }
+    }
+
+    private static void sleep(int millis) {
+        try {
+            Thread.sleep(millis);
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static void main(String[] args) {
+        if (!validatePlatform()) {
+            System.out.println("This test is only for OS X.");
+            return;
+        }
+
+        // Verify that changing states of decorated/undecorated frame to/from supported states
+        // and the state bit mask ICONIFIED | MAXIMIZED_BOTH does not raise RuntimeException.
+        for (int i = 0; i < frameStates.length; i++) {
+            testStateChange(frameStates[i], Frame.ICONIFIED | Frame.MAXIMIZED_BOTH, true);
+            testStateChange(frameStates[i], Frame.ICONIFIED | Frame.MAXIMIZED_BOTH, false);
+            testStateChange(Frame.ICONIFIED | Frame.MAXIMIZED_BOTH, frameStates[i], true);
+            // Uncomment the line below, when 8026143 is ported to JDK 7.
+            //testStateChange(Frame.ICONIFIED | Frame.MAXIMIZED_BOTH, frameStates[i], false);
+        }
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/awt/image/ImageIconHang.java	Mon Sep 08 12:16:34 2014 -0700
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import java.awt.*;
+
+/*
+ * @test
+ * @bug     8032788
+ * @summary Checks that null filename argument is processed correctly
+ *
+ * @run     main ImageIconHang
+ */
+public class ImageIconHang {
+    public static void main(String[] args) throws Exception {
+        Image image = Toolkit.getDefaultToolkit().getImage((String) null);
+        MediaTracker mt = new MediaTracker(new Component() {});
+        mt.addImage(image, 1);
+        mt.waitForID(1, 5000);
+
+        int status = mt.statusID(1, false);
+
+        System.out.println("Status: " + status);
+
+        if (status != MediaTracker.ERRORED) {
+            throw new RuntimeException("MediaTracker.waitForID() hung.");
+        }
+    }
+}
--- ./jdk/test/java/lang/invoke/MethodHandlesTest.java	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/test/java/lang/invoke/MethodHandlesTest.java	Mon Sep 08 12:16:34 2014 -0700
@@ -140,7 +140,7 @@
         Object actual   = calledLog.get(calledLog.size() - 1);
         if (expected.equals(actual) && verbosity < 9)  return;
         System.out.println("assertCalled "+name+":");
-        System.out.println("expected:   "+expected);
+        System.out.println("expected:   "+deepToString(expected));
         System.out.println("actual:     "+actual);
         System.out.println("ex. types:  "+getClasses(expected));
         System.out.println("act. types: "+getClasses(actual));
@@ -148,7 +148,25 @@
     }
     static void printCalled(MethodHandle target, String name, Object... args) {
         if (verbosity >= 3)
-            System.out.println("calling MH="+target+" to "+name+Arrays.toString(args));
+            System.out.println("calling MH="+target+" to "+name+deepToString(args));
+    }
+    static String deepToString(Object x) {
+        if (x == null)  return "null";
+        if (x instanceof Collection)
+            x = ((Collection)x).toArray();
+        if (x instanceof Object[]) {
+            Object[] ax = (Object[]) x;
+            ax = Arrays.copyOf(ax, ax.length, Object[].class);
+            for (int i = 0; i < ax.length; i++)
+                ax[i] = deepToString(ax[i]);
+            x = Arrays.deepToString(ax);
+        }
+        if (x.getClass().isArray())
+            try {
+                x = Arrays.class.getMethod("toString", x.getClass()).invoke(null, x);
+            } catch (ReflectiveOperationException ex) { throw new Error(ex); }
+        assert(!(x instanceof Object[]));
+        return x.toString();
     }
 
     static Object castToWrapper(Object value, Class<?> dst) {
@@ -230,6 +248,12 @@
                     { param = c; break; }
             }
         }
+        if (param.isArray()) {
+            Class<?> ctype = param.getComponentType();
+            Object arg = Array.newInstance(ctype, 2);
+            Array.set(arg, 0, randomArg(ctype));
+            return arg;
+        }
         if (param.isInterface() && param.isAssignableFrom(List.class))
             return Arrays.asList("#"+nextArg());
         if (param.isInterface() || param.isAssignableFrom(String.class))
@@ -584,6 +608,16 @@
         testFindVirtual(IntExample.Impl.class, IntExample.class, void.class, "Int/v0");
     }
 
+    @Test
+    public void testFindVirtualClone() throws Throwable {
+        // test some ad hoc system methods
+        testFindVirtual(false, PUBLIC, Object.class, Object.class, "clone");
+        testFindVirtual(true, PUBLIC, Object[].class, Object.class, "clone");
+        testFindVirtual(true, PUBLIC, int[].class, Object.class, "clone");
+        for (Class<?> cls : new Class<?>[]{ boolean[].class, long[].class, float[].class, char[].class })
+            testFindVirtual(true, PUBLIC, cls, Object.class, "clone");
+    }
+
     void testFindVirtual(Class<?> defc, Class<?> ret, String name, Class<?>... params) throws Throwable {
         Class<?> rcvc = defc;
         testFindVirtual(rcvc, defc, ret, name, params);
@@ -596,6 +630,9 @@
     void testFindVirtual(Lookup lookup, Class<?> rcvc, Class<?> defc, Class<?> ret, String name, Class<?>... params) throws Throwable {
         testFindVirtual(true, lookup, rcvc, defc, ret, name, params);
     }
+    void testFindVirtual(boolean positive, Lookup lookup, Class<?> defc, Class<?> ret, String name, Class<?>... params) throws Throwable {
+        testFindVirtual(positive, lookup, defc, defc, ret, name, params);
+    }
     void testFindVirtual(boolean positive, Lookup lookup, Class<?> rcvc, Class<?> defc, Class<?> ret, String name, Class<?>... params) throws Throwable {
         countTest(positive);
         String methodName = name.substring(1 + name.indexOf('/'));  // foo/bar => foo
@@ -635,8 +672,21 @@
         Object[] argsWithSelf = randomArgs(paramsWithSelf);
         if (selfc.isAssignableFrom(rcvc) && rcvc != selfc)  argsWithSelf[0] = randomArg(rcvc);
         printCalled(target, name, argsWithSelf);
-        target.invokeWithArguments(argsWithSelf);
-        assertCalled(name, argsWithSelf);
+        Object res = target.invokeWithArguments(argsWithSelf);
+        if (Example.class.isAssignableFrom(defc) || IntExample.class.isAssignableFrom(defc)) {
+            assertCalled(name, argsWithSelf);
+        } else if (name.equals("clone")) {
+            // Ad hoc method call outside Example.  For Object[].clone.
+            printCalled(target, name, argsWithSelf);
+            assertEquals(MethodType.methodType(Object.class, rcvc), target.type());
+            Object orig = argsWithSelf[0];
+            assertEquals(orig.getClass(), res.getClass());
+            if (res instanceof Object[])
+                assertArrayEquals((Object[])res, (Object[])argsWithSelf[0]);
+            assert(Arrays.deepEquals(new Object[]{res}, new Object[]{argsWithSelf[0]}));
+        } else {
+            assert(false) : Arrays.asList(positive, lookup, rcvc, defc, ret, name, deepToString(params));
+        }
         if (verbosity >= 1)
             System.out.print(':');
     }
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/lang/invoke/ObjectMethodInInterfaceTest.java	Mon Sep 08 12:16:34 2014 -0700
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/* @test
+ * @bug 8031502
+ * @summary JSR292: IncompatibleClassChangeError in LambdaForm for CharSequence.toString() method handle type converter
+ * @compile ObjectMethodInInterfaceTest.java
+ * @run main/othervm -Djava.lang.invoke.MethodHandle.COMPILE_THRESHOLD=0 test.java.lang.invoke.ObjectMethodInInterfaceTest
+ */
+package test.java.lang.invoke;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodType;
+
+public class ObjectMethodInInterfaceTest {
+    public static void main(String[] args) throws Throwable {
+        MethodHandle mh = MethodHandles.lookup().findVirtual(CharSequence.class, "toString", MethodType.methodType(String.class));
+        MethodType mt = MethodType.methodType(Object.class, CharSequence.class);
+        mh = mh.asType(mt);
+
+        Object res = mh.invokeExact((CharSequence)"123");
+
+        System.out.println("TEST PASSED");
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/net/NetworkInterface/UniqueMacAddressesTest.java	Mon Sep 08 12:16:34 2014 -0700
@@ -0,0 +1,129 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import java.net.InetAddress;
+import java.net.NetworkInterface;
+import java.net.SocketException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Enumeration;
+import java.util.List;
+
+
+/*
+ * @test
+ * @bug 8021372
+ * @summary Tests that the MAC addresses returned by NetworkInterface.getNetworkInterfaces are unique for each adapter.
+ *
+ */
+public class UniqueMacAddressesTest {
+
+    public static void main(String[] args) throws Exception {
+        new UniqueMacAddressesTest().execute();
+        System.out.println("UniqueMacAddressesTest: OK");
+    }
+
+    public UniqueMacAddressesTest() {
+        System.out.println("UniqueMacAddressesTest: start ");
+    }
+
+    public void execute() throws Exception {
+        Enumeration<NetworkInterface> networkInterfaces;
+        boolean areMacAddressesUnique = false;
+        List<NetworkInterface> networkInterfaceList = new ArrayList<NetworkInterface>();
+            networkInterfaces = NetworkInterface.getNetworkInterfaces();
+
+        // build a list of NetworkInterface objects to test MAC address
+        // uniqueness
+        createNetworkInterfaceList(networkInterfaces, networkInterfaceList);
+        areMacAddressesUnique = checkMacAddressesAreUnique(networkInterfaceList);
+        if (!areMacAddressesUnique) {
+            throw new RuntimeException("mac address uniqueness test failed");
+        }
+    }
+
+    private boolean checkMacAddressesAreUnique (
+            List<NetworkInterface> networkInterfaces) throws Exception {
+        boolean uniqueMacAddresses = true;
+        for (NetworkInterface networkInterface : networkInterfaces) {
+            for (NetworkInterface comparisonNetIf : networkInterfaces) {
+                System.out.println("Comparing netif "
+                        + networkInterface.getName() + " and netif "
+                        + comparisonNetIf.getName());
+                if (testMacAddressesEqual(networkInterface, comparisonNetIf)) {
+                    uniqueMacAddresses = false;
+                    break;
+                }
+            }
+            if (uniqueMacAddresses != true)
+                break;
+        }
+        return uniqueMacAddresses;
+    }
+
+    private boolean testMacAddressesEqual(NetworkInterface netIf1,
+            NetworkInterface netIf2) throws Exception {
+
+        byte[] rawMacAddress1 = null;
+        byte[] rawMacAddress2 = null;
+        boolean macAddressesEqual = false;
+        if (!netIf1.getName().equals(netIf2.getName())) {
+            System.out.println("compare hardware addresses "
+                +  createMacAddressString(netIf1) + " and " + createMacAddressString(netIf2));
+            rawMacAddress1 = netIf1.getHardwareAddress();
+            rawMacAddress2 = netIf2.getHardwareAddress();
+            macAddressesEqual = Arrays.equals(rawMacAddress1, rawMacAddress2);
+        } else {
+            // same interface
+            macAddressesEqual = false;
+        }
+        return macAddressesEqual;
+    }
+
+    private String createMacAddressString (NetworkInterface netIf) throws Exception {
+        byte[] macAddr = netIf.getHardwareAddress();
+        StringBuilder sb =  new StringBuilder();
+        if (macAddr != null) {
+            for (int i = 0; i < macAddr.length; i++) {
+                sb.append(String.format("%02X%s", macAddr[i],
+                        (i < macAddr.length - 1) ? "-" : ""));
+            }
+        }
+        return sb.toString();
+    }
+
+    private void createNetworkInterfaceList(Enumeration<NetworkInterface> nis,
+            List<NetworkInterface> networkInterfaceList) throws Exception {
+        byte[] macAddr = null;
+        NetworkInterface netIf = null;
+        while (nis.hasMoreElements()) {
+            netIf = (NetworkInterface) nis.nextElement();
+            macAddr = netIf.getHardwareAddress();
+            if (macAddr != null) {
+                System.out
+                        .println("Adding NetworkInterface " + netIf.getName());
+                networkInterfaceList.add(netIf);
+            }
+        }
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/javax/crypto/Cipher/CipherStreamClose.java	Mon Sep 08 12:16:34 2014 -0700
@@ -0,0 +1,167 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 7160837
+ * @summary Make sure Cipher IO streams doesn't call extra doFinal if close()
+ * is called multiple times.  Additionally, verify the input and output streams
+ * match with encryption and decryption with non-stream crypto.
+ */
+
+import java.io.*;
+import java.security.DigestOutputStream;
+import java.security.DigestInputStream;
+import java.security.MessageDigest;
+import java.util.Arrays;
+
+import javax.crypto.Cipher;
+import javax.crypto.CipherOutputStream;
+import javax.crypto.CipherInputStream;
+import javax.crypto.SecretKey;
+import javax.crypto.spec.SecretKeySpec;
+import javax.xml.bind.DatatypeConverter;
+
+public class CipherStreamClose {
+    private static final String message = "This is the sample message";
+    static boolean debug = false;
+
+    /*
+     * This method does encryption by cipher.doFinal(), and not with
+     * CipherOutputStream
+     */
+    public static byte[] blockEncrypt(String message, SecretKey key)
+        throws Exception {
+
+        byte[] data;
+        Cipher encCipher = Cipher.getInstance("AES/ECB/PKCS5Padding");
+        encCipher.init(Cipher.ENCRYPT_MODE, key);
+        try (ByteArrayOutputStream bos = new ByteArrayOutputStream()) {
+            try (ObjectOutputStream oos = new ObjectOutputStream(bos)) {
+                oos.writeObject(message);
+            }
+            data = bos.toByteArray();
+        }
+
+        if (debug) {
+            System.out.println(DatatypeConverter.printHexBinary(data));
+        }
+        return encCipher.doFinal(data);
+
+    }
+
+    /*
+     * This method does decryption by cipher.doFinal(), and not with
+     * CipherIntputStream
+     */
+    public static Object blockDecrypt(byte[] data, SecretKey key)
+        throws Exception {
+
+        Cipher c = Cipher.getInstance("AES/ECB/PKCS5Padding");
+        c.init(Cipher.DECRYPT_MODE, key);
+        data = c.doFinal(data);
+        try (ByteArrayInputStream bis = new ByteArrayInputStream(data)) {
+            try (ObjectInputStream ois = new ObjectInputStream(bis)) {
+                return ois.readObject();
+            }
+        }
+    }
+
+    public static byte[] streamEncrypt(String message, SecretKey key,
+        MessageDigest digest)
+        throws Exception {
+
+        byte[] data;
+        Cipher encCipher = Cipher.getInstance("AES/ECB/PKCS5Padding");
+        encCipher.init(Cipher.ENCRYPT_MODE, key);
+        try (ByteArrayOutputStream bos = new ByteArrayOutputStream();
+            DigestOutputStream dos = new DigestOutputStream(bos, digest);
+            CipherOutputStream cos = new CipherOutputStream(dos, encCipher)) {
+            try (ObjectOutputStream oos = new ObjectOutputStream(cos)) {
+                oos.writeObject(message);
+            }
+            data = bos.toByteArray();
+        }
+
+        if (debug) {
+            System.out.println(DatatypeConverter.printHexBinary(data));
+        }
+        return data;
+    }
+
+    public static Object streamDecrypt(byte[] data, SecretKey key,
+        MessageDigest digest) throws Exception {
+
+        Cipher decCipher = Cipher.getInstance("AES/ECB/PKCS5Padding");
+        decCipher.init(Cipher.DECRYPT_MODE, key);
+        digest.reset();
+        try (ByteArrayInputStream bis = new ByteArrayInputStream(data);
+            DigestInputStream dis = new DigestInputStream(bis, digest);
+            CipherInputStream cis = new CipherInputStream(dis, decCipher)) {
+
+            try (ObjectInputStream ois = new ObjectInputStream(cis)) {
+                return ois.readObject();
+            }
+        }
+    }
+
+    public static void main(String[] args) throws Exception {
+        MessageDigest digest = MessageDigest.getInstance("SHA1");
+        SecretKeySpec key = new SecretKeySpec(
+            DatatypeConverter.parseHexBinary(
+            "12345678123456781234567812345678"), "AES");
+
+        // Run 'message' through streamEncrypt
+        byte[] se = streamEncrypt(message, key, digest);
+        // 'digest' already has the value from the stream, just finish the op
+        byte[] sd = digest.digest();
+        digest.reset();
+        // Run 'message' through blockEncrypt
+        byte[] be = blockEncrypt(message, key);
+        // Take digest of encrypted blockEncrypt result
+        byte[] bd = digest.digest(be);
+        // Verify both returned the same value
+        if (!Arrays.equals(sd, bd)) {
+            System.err.println("Stream: "+DatatypeConverter.printHexBinary(se)+
+                "\t Digest: "+DatatypeConverter.printHexBinary(sd));
+            System.err.println("Block : "+DatatypeConverter.printHexBinary(be)+
+                "\t Digest: "+DatatypeConverter.printHexBinary(bd));
+            throw new Exception("stream & block encryption does not match");
+        }
+
+        digest.reset();
+        // Sanity check: Decrypt separately from stream to verify operations
+        String bm = (String) blockDecrypt(be, key);
+        if (message.compareTo(bm) != 0) {
+            System.err.println("Expected: "+message+"\nBlock:    "+bm);
+            throw new Exception("Block decryption does not match expected");
+        }
+
+        // Have decryption and digest included in the object stream
+        String sm = (String) streamDecrypt(se, key, digest);
+        if (message.compareTo(sm) != 0) {
+            System.err.println("Expected: "+message+"\nStream:   "+sm);
+            throw new Exception("Stream decryption does not match expected.");
+        }
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/javax/xml/jaxp/parsers/8027359/XML11EntityScannerTest.java	Mon Sep 08 12:16:34 2014 -0700
@@ -0,0 +1,184 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/**
+ * @test
+ * @bug 8027359
+ * @summary test that the XML11EntityScanner refreshes cache when it loads new data
+ * @run main XML11EntityScannerTest
+ */
+
+import java.io.*;
+import java.util.regex.Pattern;
+import javax.xml.parsers.DocumentBuilderFactory;
+import org.w3c.dom.*;
+
+
+/**
+ * XML11EntityScanner functions similarly as XMLEntityScanner in handling data
+ * cache
+ */
+public class XML11EntityScannerTest {
+    static final String rawXML =
+            "<?xml version=\"1.1\" encoding=\"UTF-8\" standalone=\"no\"?>"
+            + "<WebOfTrustRC2 Version=\"4004\">"
+            + "<Identity Name=\"maggot\" PublishesTrustList=\"true\" Version=\"1\">"
+            + "<Context Name=\"Introduction\"/>"
+            + "<Context Name=\"FreetalkRC2\"/>"
+            + "<Property Name=\"IntroductionPuzzleCount\" Value=\"10\"/>"
+            + "<TrustList>"
+            + "<Trust Comment=\"\" Identity=\"USK@fdZ2In5mnLVG6RTc5hq9P~M1EG0WuH-itZ7mnQx2iuM,aUG-57VqxQLhQ4N1uNmH9kSI2syEfVFrVOIPAKTY2Yg,AQACAAE/WebOfTrustRC2/5\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@YwwRkHSo-xU8CvSFcLqlU2FFsQ3ztjr0X~xPXkX-klY,poB3tdcXrBU9naI0pyNVYp~zQmHaFkRRTj8xB8tuiPc,AQACAAE/WebOfTrustRC2/7\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@lsd~~79wrGvfb99FnAEY4VhJg2b5KFUloCOUff-Q2fk,71eV-F580euOtaCgim69Yw~2Rjh43DT49sl6zNamjk0,AQACAAE/WebOfTrustRC2/47\" Value=\"100\"/>"
+            + "<Trust Comment=\"Automatically assigned trust to a seed identity.\" Identity=\"USK@xyzElfFQnwBb4ZuSEh1aSNsbRjEGCTa-2rcjeW58A4E,TiYrXSCcoGETPf0TWLNthaimJEP1PW7nJ2tYXKxdC4s,AQACAAE/WebOfTrustRC2/456\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@pTtYoCsMO-~~2Grqya6Y7cf7nIU3VlL4168-c6EIwA8,QabBgrH1LYKKyBROnWz1r6iI8N7WFTt-mKD-0Qxsw1w,AQACAAE/WebOfTrustRC2/133\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@m~lDSvnetPNy77wsoxDZDUf7OkgX6ZAd7ob9orm3J4Y,SEX20g148KGJg3bsxvXNPNbUsVs1yQ5LfVUOGMh~1Q0,AQACAAE/WebOfTrustRC2/7\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@ss5yQit~bQL5easM68d4sImnPAxHNUbi99XtDMhpzgQ,CnpuD8dO29KvpkQyxtz1llAxHCB7yXfqrQLNRIELZow,AQACAAE/WebOfTrustRC2/2\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@krPcyGts~~wZTbABTAJ59nSplmum2~EkSD5IzinrFko,7YEbm-YEx1LFoZVHtGmIa5q0KbEjw48Rgwx2NqwrH~o,AQACAAE/WebOfTrustRC2/15\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@Usl-yNWc3VtuQWQ9srowZaWyfB6MiD9fzM5WexrlKE8,qMS83aGFsN~aFGajUmGrnbXvRIYZMd8N8IjnGmEvi-s,AQACAAE/WebOfTrustRC2/68\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@St0yKRdQJ3Lq17yoVt9h08bMfhqRhH1vtrcVVInoZVU,BaYM72qM3CYO1yzfVyO1UDUobL56CMbt9EQt3sEXabA,AQACAAE/WebOfTrustRC2/7\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@P8v4ZHUBPYGylYC-KHeWmeu5ZvB6RPYGgKcI5639Wz8,OM9PvjwMlt4L6jKRhqpvyblwpVMYumUgYFrAu3NxY~o,AQACAAE/WebOfTrustRC2/54\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@u2vn3Lh6Kte2-TgBSNKorbsKkuAt34ckoLmgx0ndXO0,4~q8q~3wIHjX9DT0yCNfQmr9oxmYrDZoQVLOdNg~yk0,AQACAAE/WebOfTrustRC2/2\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@MotrIucaZk37pJNS~HHpW5Vea3q0EZpfENPNGSjWh9s,RkFyDjl6-l7V-xYMWtGypmDYk-VehAU1LXmNYdIlHJs,AQACAAE/WebOfTrustRC2/108\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@KXAWN8DJxJ48XzZu7IBBpZ7SFc4n-OXqu4HhQC0V9Ww,DyklyACbgDCZyFpq-LeNqmuve7KWv-WDvJicd37ycn4,AQACAAE/WebOfTrustRC2/11\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@D6BZ1sSEmDMKNMPUN9I~7AalkkXockAdtbxONEN315w,0LiGUSSv4Ln4O7Xe4GQjpMEflNN7okKAH42Vlpv8d8s,AQACAAE/WebOfTrustRC2/56\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@sDehmSJoiaKYT455GIGHIVNKMs7KmiiwXXcCIcDhZ3o,upypWy-ze9Cz7WiCnbbJmoZOh7Xtveitftc5bE~p0Ug,AQACAAE/WebOfTrustRC2/6\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@GsTGXzIm9BTM5~KSZJknfTcPpJtlRs62aJtkNp05T5A,wuQcDjsdPQD9Fa21zWGB5GiiDlmf56vI9Niu5jl8eiM,AQACAAE/WebOfTrustRC2/31\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@eLFdT9VWP60iPNf8a3AkZrzgkcgje2n3Ca1yS8Tc5HU,5D0PISp19VkgzD4VSrRFTmo2CCvRoIuxlQzgMZBmj74,AQACAAE/WebOfTrustRC2/62\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@rz12UCXn-lG53i-6JswD98Kk9Zp0kt05gqIMNYc~9d0,42hoYZ5f~1fPuyvTOVYGJ~28MgYBSfoyzceR8-u1Z2I,AQACAAE/WebOfTrustRC2/126\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@5CYp3t28N5ZbPss9XhOkwUjD~T65q6-nc4aGwbV~-O0,CBfwMjYBiqKunzj3k6Ofpo9pyQsVFPz0OUWVzfd5a0c,AQACAAE/WebOfTrustRC2/0\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@dSSrRL9BY7JmTQD0dCpcIgVaLFF7pqU8EJzVUp1BYPA,EkTPkLrhEBQLPq-dRVPB1f2CAVdFGbXbUBlIww6re60,AQACAAE/WebOfTrustRC2/5\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@cw2rrCAcYTBjlO-I8DfEj-txttebZMG2LwuPGJV3Qlg,5ZcXLJW8G-R2SFqg4TEQX7IMs~e3Q4DjxUXGuHr9fxA,AQACAAE/WebOfTrustRC2/7\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@7zpRmhkkd5XcAUY6yUwp-53t7to3UN96w98~KQEwha0,30VpXev32s2mhmM5aBRJ---I0OlYbbN6~18j8rJ6qMU,AQACAAE/WebOfTrustRC2/8\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@YmCWYwlaSeE8o~8GawGYWeuPwsgVQtlBwlBkhGQFX04,H3DthY0MZXTe4rL0vsUOOMQDaj6UB9wK59yEwG8Q6No,AQACAAE/WebOfTrustRC2/13\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@aO9svsQEWmib~UyF1ihRUHA8i6uZprGy-tIS-Od9MMk,kwaMemPMVp-jcIRgGLAdF6PZimNE2cZFbvM6ShXAuZw,AQACAAE/WebOfTrustRC2/7\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@6J7FWPHwiCElTRXAO77tMGYAiLxerNF~5olAG0alQxQ,cz72iTz9FT~H57TgroVFv1eZlN5Ia5dhCtRa8bLh1KQ,AQACAAE/WebOfTrustRC2/0\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@kukYpNG56TNUnQzQe1RZvSYoqQ5B9lcoMZyDlh7xfO4,DNybejZVcWBAaByMRYYLZlgzUjQg28V8j6Zu1CtBc~g,AQACAAE/WebOfTrustRC2/27\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@a-tin0kMl1I~8xn5lkQDqYZRExKLzJITrxcNsr4T~fY,0VmnI67gAzIpdXlZFq~hYD8ikR5IEAg5QTwQv5Ifv5M,AQACAAE/WebOfTrustRC2/24\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@g~4XXw0hjp9TLocYZzunYWX6Don2AQhG-zplmzoCmY0,lyNjClSjRCrBZXVcmPKEAfvH01ySPgv1NWqL8wd11L8,AQACAAE/WebOfTrustRC2/115\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@UXgNMPe1YbVpXHOBXgMlcm9XcGY0G3gUtu43IO-YLLA,7EHSp20GHupg0rWrGPRY1g0TFJcRs-kubVtAcQRMxAc,AQACAAE/WebOfTrustRC2/69\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@lHrF2trsC9gyVeT2zpoL6IlZMz0aKlhN4xa2Ig70rmA,niASdKFC3nDfW6KMvzcv6VmRoHakE7GQAFpfz~2-v3Y,AQACAAE/WebOfTrustRC2/0\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@hp7IFNYSA97cHNAnHcreTJjQE5fF5sbsFlvbcZXaoxQ,O5h6cAcl5MvxuE2-xOkuvUP4JkT59NQNtaSmtuAS2Y8,AQACAAE/WebOfTrustRC2/16\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@QKPxALYrv6UyAGJs7tor8YlcikFzmy2msZ~42JMT~80,vx01piijkj0o3K8gzNaAOIIZ7NAtQVvPBxlRKtc4iP0,AQACAAE/WebOfTrustRC2/35\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@NmNfUNIr2WwIb9Ej1038Pk0M5gS1M0eHKvxdWqRUfTg,JUJYTsWuNQPOHK039Rczp6oPZDbfPdbO62gSaCuBXFQ,AQACAAE/WebOfTrustRC2/69\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@ONB7kRFo7mI0O3~QLRWlTbo1oB91XmGGS7KtSzz4XVI,yGiqMWRwR~i6ffAXOTBvrngHGC6nYOETUXj4L6Izj64,AQACAAE/WebOfTrustRC2/122\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@k-i0PmxoxO6Mahx8s850Rd7TEe0r4cnEohqC66aMDKw,IlTVYmQ9OSHjiu5pOLq4t-8r50SsVPNMlXn56zfpfDI,AQACAAE/WebOfTrustRC2/0\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@GtzvV-VHMGQILkpZ3O4CWBTWlhB423UUwpIlzRDgBLs,HUxBDT-Hhy6GqjBV24NRMjlK-o76YGMEgO~ZS6yighU,AQACAAE/WebOfTrustRC2/6\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@Ws0yzkcOYw6ax~kCtnzyX4MgLBHiQd5a6u9FMUmqLG4,zqNjNNGLz7HE4pdSPTovX2AwzGQWJ3-LI7YZt7aq3gg,AQACAAE/WebOfTrustRC2/30\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@6brkdrKlglWHnqMjWG6wrdLMWGPooc~7wQ7ID-PIsJk,X3RRBIdOQ5zthpkk8FjLL33LyoVVI4csJ1~g~sZ1msc,AQACAAE/WebOfTrustRC2/63\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@4DO0Yp1a3RZeAUAjeoPVu~GqpKhaX8RYqe~mwcWgjsM,klsqky963KI6uG3JqE1crihSeBbKBgkJHkIZ2xkWJ4A,AQACAAE/WebOfTrustRC2/36\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@axtoU6zHIkx3bicWK-hLNOj0br4xi0HW1qZ8H6CEv0U,SuPIncAHyYXmR9jQkTFUJd-QgGm0g9lW5ESUjzFOl~Q,AQACAAE/WebOfTrustRC2/8\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@BYsosP8TA22rSz1uA0KGbp6OVFZXhdgAlpH4R4hX9zE,o~qV5IzMR3m7ZOnnG5FPnDqpdffEpu7yOM7VEU9j6lQ,AQACAAE/WebOfTrustRC2/7\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@EilKmVin5cVL7b4FoEQ7ZoHS932O8OI880Qkd~tmzWs,8WK34lo95u~b60GLVczYU6EiRpY0LH7130~ASP9F6dU,AQACAAE/WebOfTrustRC2/75\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@xDYiCplSPLvFGC2dQjAC6eeaYVyQMtV-HmkpuKIJPgQ,CYKZcPacSNfB67IK10xlq7~bAqR-aOnZIA~yhHs2Hj0,AQACAAE/WebOfTrustRC2/71\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@DfCUA1sEJgiGzijEO0BWgeGjjHi28GGgv76H4rLujp8,1lnaOtPiXmvhpRZkBamZNF47uETNKIBgjSzElxcLhZc,AQACAAE/WebOfTrustRC2/0\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@F45FWNz9rs6TmafG~6n5Bg3Sr69YCHY9v01KTyK17lw,ikIvUS079Qw3aQknvdM8yKgr0XwjcqHgW0pWLu-1osA,AQACAAE/WebOfTrustRC2/13\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@VTDWbj9C5FUEXZBQRXmSsV1aEdOfsB9QHKzZ7-CnCh4,aDjtAVMuGPpCmw1rnCAj5myEnq9HYZeIzrfrhJO2JNw,AQACAAE/WebOfTrustRC2/52\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@dhYMUELq~HtJOweiV2JkGcoFS6hulHd9O~7a9LpGIxM,M-H3ySL8BdCctDUvwvbFNwHUyO1zghSNyotLqkKowi8,AQACAAE/WebOfTrustRC2/20\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@oRpTFVvCqp8qFWiZyCh2QhQ85eh3eP8C8G4YTFhm~rw,kyyeUPuksdt7omGFYFxoWPz3lu6e0q~G1HBx8wFztFc,AQACAAE/WebOfTrustRC2/0\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@RINL4YHPkTUGBWSoohAoO7Knzk89XSnqnQ6pUZkRY~w,OvIyTUUf4T2Tm46-em~A7zn1zBksIwe-hJP3KKdCe6s,AQACAAE/WebOfTrustRC2/4\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@sEZ-eWgUcQSj-To7lClNN6QNoKuvt0Cz3iTGKv63wQo,krEwvob7MhJ-pGvIk-RM8pVDPFSuXYTZw58oc2Lc49o,AQACAAE/WebOfTrustRC2/1\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@gNTVpdblFLSKMzUBEQM8YTfrO2fQQNIZeV7yJRTqYTQ,EKJhCmbQ5hpMU3cd-J91uneBF7CxTLPqffPs6DxoSMs,AQACAAE/WebOfTrustRC2/21\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@AV8Ubs8pbsMQ1F028a~pSJqtatznLjvhnwfSAtm1QKg,lUHPp~mgzV-pVoG9lYpceL6oOUtFRpvyQjGQdfx1GjY,AQACAAE/WebOfTrustRC2/41\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@xb3QGWdoUpeX9Fn1ZKeDwGN884c2XAMTpYLM9z4OIKo,aWNEDvjhhacFKAjiYJLaUnK1e7dQ9sCk-cnqkGZd7F8,AQACAAE/WebOfTrustRC2/9\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@MrxyFFM~n-kZ4kYvOOZodsvAA2vwp2XtAQJCrkEEU6s,tSHvx3u7uJN8ciaTqBIzt3lLmonM9mj6I7pz88MtBXc,AQACAAE/WebOfTrustRC2/0\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@-tpkd0enlFMTnjANRjzMKyfE3uyXU-WDX8VUqk3MXEg,J6h7edIdQCsiuc53qahzMzxsyNayXL~9IR0x5QoJVxk,AQACAAE/WebOfTrustRC2/15\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@gBQsXbnA9HX6wQB8x7DIEJT6e7lOxq5jGF353Po~p90,HjdyCLfG9r-zSBN6-AXwA1he9blIO2WEN9u7dMQ7H1w,AQACAAE/WebOfTrustRC2/13\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@ye~rQ4m~pu2Iu3O2TH-GOLBbSeKoQ~QR~vC6tJbKmDg,YSuI-J1nKZjGB2zmIa9Bh2Wtud~jzYBuR7OVhXYh7qM,AQACAAE/WebOfTrustRC2/99\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@HwgX8mU9A7bd2sCsM9And7fotpMGqfba9LzxZtOHHOU,10nYjjfKDH5RB3YvCCi5bpq4GPR-myd8ea7n8DRvx~c,AQACAAE/WebOfTrustRC2/0\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@qQArPJZuODDeM6C2ndbSczsFLWmLDm2SoaE-9F1hwQU,E3x6TbIvBj~6D9GrMUWSYgnNkLRg85BXXy5~mncoNEI,AQACAAE/WebOfTrustRC2/7\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@4hm9fo4IN0akORyJECttbEGZ~rPCPQ9KKAAH2AWMy8E,klvTyVp-GJznJq8Sln4W2GUfV6tVX2TI2sPCGBFU4tM,AQACAAE/WebOfTrustRC2/0\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@x7SDH5rL2-tGOaOKFFNMRrylCq94OfiZTWt4t3nwRHk,~E-kX9VqlANo4MeccvNlXDIjJ5xTWTEDNW-Qk04Ke6U,AQACAAE/WebOfTrustRC2/17\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@A9RAAKmky5yroigSupz6Bvrmc4q5FN1SXSrSXa6oRUg,s3RfurouqPnKmlGRkERao6jOJv9kcrVBBKAHqZVuQH4,AQACAAE/WebOfTrustRC2/1\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@yEstdNIW54-3~YA7QnYodpyWgPZStskrN9WXLHujUrE,j4PciAtpUHOjR2wmaaCKwiryJAi~exjETJ13UPGJLTg,AQACAAE/WebOfTrustRC2/58\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@NZSwPe8RJQOTSQ-~cAuxy97ieuX9reSft0cyD0vfbJg,99y8KOdRJmVLCWqryDzB8NdBrQGY7V9JDFtgCQBuGsU,AQACAAE/WebOfTrustRC2/0\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@Nq6iEvHP0B2VCszLCenQrfyJmkD0vas~00-9MoWgcTA,6dI2kB1z9mtjwITkhc9~V86QE5gM9CJBMjdpvRzKAoY,AQACAAE/WebOfTrustRC2/29\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@ZaNXnLCT7OQrwhp4I9V-rI1ZAV9WzegFj0HSaEJQ-Z4,i23K-dQupDenVE8O3xGv92vVanfDeyjLYWescevMbGg,AQACAAE/WebOfTrustRC2/14\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@53e9r9zEkJ0TRW~Tq8XIWjZ3WkL7Jv5Ez8LDhdwwzwM,7a0vL0OmWkHy3gC5Zs~MxB4k0QppwK4igrH6iuwls68,AQACAAE/WebOfTrustRC2/7\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@W1c~RYRC09xIHiHIucfV~Rj4J8uKAGrUeHmrH-q-U1c,niOrI75WMQ-Dtl9luIbKBmnvf6chkQEKvUvoKvSjhxI,AQACAAE/WebOfTrustRC2/4\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@G6zv74PaPcVZcf78lWp-e1TfrCSNZa1ZaPvmjm7DVzk,f4Ft3sLQ6cUEwpumpTMt5N17UORfZoXjGfmke5PJbdc,AQACAAE/WebOfTrustRC2/5\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@m5ILsPVAlcOY5D91J2iQu~PIntZb3L-B1VkONjEZs2k,592dl39JXIF1kpC4OMkw7ELOhdPrn~WXBsZln20pM7Q,AQACAAE/WebOfTrustRC2/0\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@iK69tf7gzQ53oZV60rF6ZSwwCfADMRsJeG2YmODdmJc,5czI5ZmWbWLDr2L9JdDmkt7qrr8fs55VDt3tXnrFw0E,AQACAAE/WebOfTrustRC2/0\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@bloE1LJ~qzSYUkU2nt7sB9kq060D4HTQC66pk5Q8NpA,DOOASUnp0kj6tOdhZJ-h5Tk7Ka50FSrUgsH7tCG1usU,AQACAAE/WebOfTrustRC2/58\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@0j-H~zKeP9mh6LEJUl4HSJYC-lQWstYRJeC~5E2F5~c,VbjnSixETRzKp80jYYXD-bqsTUWzxwcYmI9ZSWsBrik,AQACAAE/WebOfTrustRC2/13\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@~4ZW0eji3~hYAakiCI056soETGPf9O94GtoIpE2NGEg,GdtKsS~WeDlBS~OL1egxqZ4pr-iPXHjT2zcy8pjvEK4,AQACAAE/WebOfTrustRC2/88\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@YommlOi4fTYx9axhnl9iAi9BNHRvnM5XWjl21i0563k,5FswxS7hPf2erR8KkrBobG8R9bekaakeY1tM8DDNsjI,AQACAAE/WebOfTrustRC2/2\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@-ucM1bn8sICGRAemM8wZ~BVHgX3ZPUoutjZY64mBIcQ,Ko~kC54wZ-joCpfdc67Vds8LkAIxvTJGpMtfQSl4mAA,AQACAAE/WebOfTrustRC2/2\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@VwcZEhjtMuFcYIa8r0yksTs~FvMWB7swEz6tK67Vmsw,0blSLTQDms-WWbw1IBuKIoR2ZvSHpI21lMFeByQPuII,AQACAAE/WebOfTrustRC2/56\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@HAoXk-dW6~j5eLdAZCEjyKTVC974wkdl-4QqrPcbyzE,NlS05DkGK8QzL~EVUOfb~Jl1EZoVJTQBQBzA6N2qMn4,AQACAAE/WebOfTrustRC2/7\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@2PK-12eJFcVziT6eMpiUpOpTlmDNAoVOKZvA~8s7VSg,EaHdnKfKoWQDclX1mwcQeGr5jo1ijxyExYqL7Vsf-o8,AQACAAE/WebOfTrustRC2/33\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@8D3L5TDTyp5jnbT4imUWK12QC-B0iaSxFPOstMX2URg,ZtSShNkEVV8whaGQtIxiJ3FBroihw8YDyZrWvqncs0s,AQACAAE/WebOfTrustRC2/12\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@HKv7Hp94hFz8CKlINXCImq~XIBL9VfsPSgqfR0QIZFQ,vFM45qVvCajf3iqZm~ykZYwqM0KhaUSkU3RGaxJzHLI,AQACAAE/WebOfTrustRC2/4\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@NJu4xYtC3cgZo8s2xqmap3eh1dy60tFQFoxU8aeSnq8,fp~WLcrSSUKnr9wDDz-geb8FDwADCMCA9fjKt04Cyg8,AQACAAE/WebOfTrustRC2/4\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@IazjsmIK8VnIjDkq3-ecMEKHmi0dBT1QsNBq2mp2Fuo,uu24sWwNW~tjszdw19Mz18NBGx1MSADi03BHZnttwFo,AQACAAE/WebOfTrustRC2/8\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@IfxF-y7PNV97WUiHLqlIwXQyfVsHjI-Am4unZ0AK-Qk,Xm78gNC236A3wZ1RWBnft4oBGHU1R88Yt9AlphmtJPo,AQACAAE/WebOfTrustRC2/36\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@i1YvNnlMkd0i~0SiXiDHlGaxbtYd8ZqEUij~VzxyXmM,rxi19mph9KtHA6~gVGJ1rZ6kytff~kJDm6~NrA4YQaI,AQACAAE/WebOfTrustRC2/9\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@nXf5sbMSDqE~OkCQ~8JaMgPbj2LQJcuouvO56ADo28s,uEMqVaBzpA06TaC8A0cqKuv~lSfqZBiijasA3nlQ0Fc,AQACAAE/WebOfTrustRC2/8\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@Y8fLVylNs~pB6sdA5Dl1l6T~hXQrLNZLMgfDl5-E5Z0,n0zdN5XUa-D5Puf0L9wu~xQQmU~A5TpfqJ4RFHJLjLs,AQACAAE/WebOfTrustRC2/1\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@F0ixRao2hQlvTQDkN6rPcwLTG2nA6x0r8RrTQ0443IQ,LxN-gYvq4eWRuhjAgejmgNqYJdIw0q8IJ2XNwwVHhmQ,AQACAAE/WebOfTrustRC2/12\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@Pgk~nJzSVNAjFHh-qTovvm6muY08igdOCEWuyUrbFvk,NlwUDwfQlbXRjIaFAVljD5E1loXi31Xq6dG8YC7JOR0,AQACAAE/WebOfTrustRC2/5\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@m9gYemmVNXe32Ao6jeUgW8ttgGlMSIAW1608YZ19olE,LnEWPRzsPlPfq2~gIYQ5SVV-V2lthAx254dht9EZgyU,AQACAAE/WebOfTrustRC2/0\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@Pwiulr-xlPJelS5CO4~do78zZHTL5TNIChF5hpz8nkY,z77V~KhcKZRWLSWtVzaWO-dt~TzCCJFCHUDhHXI715M,AQACAAE/WebOfTrustRC2/8\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@OH3ZkrLAkMJbQTjVW3e9ioH04F7jpUVNMekiQAAvRjs,J6qOC05GoqRgST93M1V90HWxq9VK4PCKIpltkL8GAhg,AQACAAE/WebOfTrustRC2/5\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@nirNdzBgVyqMpnuT5UrmX~TU354qDIY7XAp04Kutysg,vpf1npG3nUARPSkFRx9xbVT~w1ELw0jQhdiXbxWcafg,AQACAAE/WebOfTrustRC2/1\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@ozK579KUDjjxkve1gKeV8IDd5qe0NPtxlFVV2-8iXrM,hlU82qnHi5ZnIfSD5~hr4wmUjNFJjQYted7FJWBj8z8,AQACAAE/WebOfTrustRC2/12\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@D6JSlrnlDDXfnGhijswHC5a4-EBuYNFhg2IyoFhzRRM,tCJy6EvZRhk-Og9CIkR3jfLD4VYxwOY5Wf991XMLdmE,AQACAAE/WebOfTrustRC2/0\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@Bn1Ozb4~Q639N~GvSXrbzZoVx9ziFfbkiKf1akXr9dQ,DrwwRjH~WrErR595BqxyDeisgcTLRZjCsQUBQSdnPLk,AQACAAE/WebOfTrustRC2/10\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@~aHztTNobVhKiaJ2eE-k6LLMy3qrRzL0zvk1UZp1xAU,xs3tuQsYRrTgxoU5qrayiwoOYEOLE6bTHvIKBQLIwco,AQACAAE/WebOfTrustRC2/3\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@jr3FrHPhtxP-IYQ-A12A3jjNNK4-KcHsUH8qNpBGHJ0,WK9IlZuG17JZ3YvaRUR-3uHf1YqkxxyGxkpkLW56ZTY,AQACAAE/WebOfTrustRC2/1\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@iBBjdbuuabx3v7iy-Pt3WZjWuixqo2-rzH~2kV4FkwE,Hll6SNQ~FXY5mrOY2W0GTfyNhJSlOrYutJmoXeSKseE,AQACAAE/WebOfTrustRC2/4\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@TKOVixP3xx6nA3-cgl2fksatQzxg4LlReoK0GFl7uAo,r~MCdO2rhGxBgRYv2EPuIE-tP7-0z6vuwbS04oyoAyI,AQACAAE/WebOfTrustRC2/0\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@bK9LQT2mqilUY4DxwmlKvKi5Jfwf4Brr~EQGa8RLIRU,Ni90~c4q-VNFrxFS7cDimQwCcRsqdScHoElWQgBpoT8,AQACAAE/WebOfTrustRC2/6\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@DYXv~V1jDo0XBhaiaGeRvy-~snqMbBiFR~R8TK8VBNg,4YYHZfVVYZmudSCOetDlNxnvbLy6IULV1SOgeC1zXmI,AQACAAE/WebOfTrustRC2/4\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@CSWvDlm9RM31O9NPpZomFvpTVM8cV0brixDXxpwnJ7A,4wfD~qxb5hFgCBN0JWgK6p11wUCpOHGOWhJ4i2FgFhY,AQACAAE/WebOfTrustRC2/0\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@sFsqYnIVQ9FwULsp3e-q0M46fRw2jVsLJYF9PUyHVME,aDhfrzYPt4O0BTuuRF3aCPTR0A~zr2rqHtPpJXeSqFU,AQACAAE/WebOfTrustRC2/4\" Value=\"100\"/>"
+            + "<Trust Comment=\"\" Identity=\"USK@1QwMtp0oc4jIh6DFUjec~U0O3ldWHrRmhh5OZd41MMo,GZ-QOMc4mAkHhG4LwJWU~-rl0zJIp90YcB5hn3M9tlg,AQACAAE/WebOfTrustRC2/4\" Value=\"100\"/>"
+            + "</TrustList>"
+            + "</Identity>"
+            + "</WebOfTrustRC2>";
+
+    /**
+     * main method.
+     *
+     * @param args Standard args.
+     */
+    public static void main(String[] args) {
+        try {
+            final Document xmlDoc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(new ByteArrayInputStream(rawXML.getBytes("UTF-8")));
+            final Element identityElement = (Element) xmlDoc.getElementsByTagName("Identity").item(0);
+            final Element trustListElement = (Element) identityElement.getElementsByTagName("TrustList").item(0);
+            final NodeList trustList = trustListElement.getElementsByTagName("Trust");
+            final Pattern keyPattern = Pattern.compile("USK@[%,~" + "*-_./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz" + "]+");
+            for (int i = 0; i < trustList.getLength(); ++i) {
+                Element trustElement = (Element) trustList.item(i);
+                final String identity = trustElement.getAttribute("Identity");
+                if (!keyPattern.matcher(identity).matches()) {
+                    throw new RuntimeException("Parsing failure: Instead of USK URI I got: " + identity);
+                }
+            }
+        } catch (Exception ex) {
+            throw new RuntimeException(ex.getMessage());
+        }
+    }
+
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/javax/xml/jaxp/parsers/8032909/XSLT.java	Mon Sep 08 12:16:34 2014 -0700
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/**
+ * @test
+ * @bug 8032909
+ * @summary Test for XSLT string-length function with complementary chars
+ * @compile XSLT.java
+ * @run main/othervm XSLT a_utf16.xml a_utf16.xsl 1270
+ * @run main/othervm XSLT a_utf8.xml a_utf8.xsl 130
+ * @run main/othervm XSLT a_windows1252.xml a_windows1252.xsl 200
+ */
+
+import java.io.ByteArrayOutputStream;
+import javax.xml.transform.stream.StreamResult;
+import javax.xml.transform.stream.StreamSource;
+import javax.xml.transform.Transformer;
+import javax.xml.transform.TransformerFactory;
+
+public class XSLT {
+    public static void main(String[] args) throws Exception {
+
+        ByteArrayOutputStream resStream = new ByteArrayOutputStream();
+        TransformerFactory trf = TransformerFactory.newInstance();
+        Transformer tr = trf.newTransformer(new StreamSource(System.getProperty("test.src", ".")+"/"+args[1]));
+        String res, expectedRes;
+        tr.transform( new StreamSource(System.getProperty("test.src", ".")+"/"+args[0]), new StreamResult(resStream));
+        res = resStream.toString();
+        System.out.println("Transformation completed. Result:"+res);
+
+        if (!res.replaceAll("\\s","").equals(args[2]))
+            throw new RuntimeException("Incorrect transformation result. Expected:"+args[2]+" Observed:"+res);
+    }
+}
Binary file test/javax/xml/jaxp/parsers/8032909/a_utf16.xml has changed
Binary file test/javax/xml/jaxp/parsers/8032909/a_utf16.xsl has changed
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/javax/xml/jaxp/parsers/8032909/a_utf8.xml	Mon Sep 08 12:16:34 2014 -0700
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<testxml>
+<Element>UTF-8_Element</Element>
+<Element2></Element2>
+</testxml>
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/javax/xml/jaxp/parsers/8032909/a_utf8.xsl	Mon Sep 08 12:16:34 2014 -0700
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
+
+<xsl:output method="text" />
+
+<xsl:template match="Element">
+<xsl:value-of select="string-length(.)"/>
+</xsl:template>
+<xsl:template match="Element2">
+<xsl:value-of select="string-length(.)"/>
+</xsl:template>
+
+</xsl:stylesheet>
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/javax/xml/jaxp/parsers/8032909/a_windows1252.xml	Mon Sep 08 12:16:34 2014 -0700
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="windows-1252"?>
+<testxml>
+<Element>Windows-1252_Element</Element>
+<Element2></Element2>
+</testxml>
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/javax/xml/jaxp/parsers/8032909/a_windows1252.xsl	Mon Sep 08 12:16:34 2014 -0700
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="windows-1252"?>
+<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
+
+<xsl:output method="text" />
+
+<xsl:template match="Element">
+<xsl:value-of select="string-length(.)"/>
+</xsl:template>
+<xsl:template match="Element2">
+<xsl:value-of select="string-length(.)"/>
+</xsl:template>
+
+</xsl:stylesheet>
--- ./jdk/test/sun/java2d/cmm/ColorConvertOp/ColConvCCMTest.java	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/test/sun/java2d/cmm/ColorConvertOp/ColConvCCMTest.java	Mon Sep 08 12:16:34 2014 -0700
@@ -23,7 +23,7 @@
 
 /**
  * @test
- * @bug 6476665 7033534
+ * @bug 6476665 7033534 8052162
  * @summary Verifies color conversion of Component Color Model based images
  * @run main ColConvCCMTest
  */
--- ./jdk/test/sun/tools/native2ascii/NativeErrors.java	Wed Apr 16 12:37:49 2014 +0400
+++ ./jdk/test/sun/tools/native2ascii/NativeErrors.java	Mon Sep 08 12:16:34 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1998, 1999, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,12 +25,18 @@
  * @test
  * @bug 4136352
  * @summary Test Native2ASCII error messages
- *
+ * @library /lib/testlibrary
+ * @build jdk.testlibrary.* NativeErrors
+ * @run main NativeErrors
  */
 
-import java.io.*;
-import sun.tools.native2ascii.*;
-import java.util.*;
+
+import java.io.File;
+import java.util.ResourceBundle;
+import java.util.MissingResourceException;
+import jdk.testlibrary.OutputAnalyzer;
+import jdk.testlibrary.JDKToolLauncher;
+import jdk.testlibrary.ProcessTools;
 
 public class NativeErrors {
 
@@ -45,30 +51,18 @@
         }
     }
 
-    public static void main(String args[]) throws Exception {
-        String[] command;
-        Process p = null;
-        BufferedReader in = null;
+    public static void main(String args[]) throws Throwable {
+        // Execute command in another vm. Verify stdout for expected err msg.
 
-        // Construct a command that runs the test in other vm
-        // Exec another vm to run test in
-        // Read the result to determine if test failed
-
-        command = getComString("-encoding");
-        p = Runtime.getRuntime().exec(command);
-        in = new BufferedReader(new InputStreamReader(p.getInputStream()));
-        checkResult(in, "err.bad.arg");
+        // Test with no input file given.
+        checkResult(executeCmd("-encoding"), "err.bad.arg");
 
         File f0 = new File(System.getProperty("test.src", "."), "test123");
         String path0 = f0.getPath();
         if ( f0.exists() ) {
             throw new Error("Input file should not exist: " + path0);
         }
-
-        command = getComString(path0);
-        p = Runtime.getRuntime().exec(command);
-        in = new BufferedReader(new InputStreamReader(p.getInputStream()));
-        checkResult(in, "err.cannot.read");
+        checkResult(executeCmd(path0), "err.cannot.read");
 
         File f1 = new File(System.getProperty("test.src", "."), "test1");
         File f2 = File.createTempFile("test2", ".tmp");
@@ -81,71 +75,38 @@
             throw new Error("Output file cannot be made read only: " + path2);
         }
         f2.deleteOnExit();
-
-        command = getComString(path1, path2);
-        p = Runtime.getRuntime().exec(command);
-        in = new BufferedReader(new InputStreamReader(p.getInputStream()));
-        checkResult(in, "err.cannot.write");
+        checkResult(executeCmd(path1, path2), "err.cannot.write");
     }
 
-
-    private static void checkResult(BufferedReader in, String errorExpected)
-                                                           throws Exception {
-        String errorReceived;
-        errorReceived = in.readLine();
-        assert errorReceived != null : "First readline cannot be null";
-        errorExpected = rsrc.getString(errorExpected);
-        assert errorExpected != null : "Expected message cannot be null";
-        StringBuffer error = new StringBuffer(errorExpected);
-        int start = errorExpected.indexOf("{0}");
-        if (start >= 0) {
-            error.delete(start, start+3);
-            errorExpected = error.toString();
+    private static String executeCmd(String... toolArgs) throws Throwable {
+        JDKToolLauncher cmd = JDKToolLauncher.createUsingTestJDK("native2ascii");
+        for (String s : toolArgs) {
+            cmd.addToolArg(s);
         }
-        //System.out.println("received: " + errorReceived);
-        //System.out.println("expected: " + errorExpected);
-        if (!errorReceived.endsWith(errorExpected))
-            throw new RuntimeException("Native2ascii bad arg error broken.");
+        OutputAnalyzer output = ProcessTools.executeProcess(cmd.getCommand());
+        if (output == null || output.getStdout() == null) {
+            throw new Exception("Output was null. Process did not finish correctly.");
+        }
+        if (output.getExitValue() == 0) {
+            throw new Exception("Process exit code was 0, but error was expected.");
+        }
+        return output.getStdout();
     }
 
-    private static String[] getComString(String arg2) {
-        String[] coms = new String[2];
-        coms[0] = getPathString();
-        coms[1] = arg2;
-        return coms;
-    }
+    private static void checkResult(
+            String errorReceived, String errorKey) throws Exception {
+        String errorExpected = rsrc.getString(errorKey);
+        if (errorExpected == null) {
+            throw new Exception("No error message for key: " + errorKey);
+        }
+        // Remove template tag from error message.
+        errorExpected = errorExpected.replaceAll("\\{0\\}", "");
 
-    private static String[] getComString(String arg2, String arg3) {
-        String[] coms = new String[3];
-        coms[0] = getPathString();
-        coms[1] = arg2;
-        coms[2] = arg3;
-        return coms;
-    }
-
-    /*
-     * Search for path to native2ascii
-     */
-    private static String getPathString() {
-        String path = System.getProperty("java.home") + File.separator +
-            "bin" + File.separator + "native2ascii";
-        if (File.separatorChar == '\\') {
-            path = path + ".exe";
+        System.out.println("received: " + errorReceived);
+        System.out.println("expected: " + errorExpected);
+        if (errorReceived.indexOf(errorExpected) < 0) {
+            throw new RuntimeException("Native2ascii bad arg error broken.");
         }
-        File f = new File(path);
-        if (!f.exists()) {
-            System.out.println("Cannot find native2ascii at "+path);
-            path = System.getProperty("java.home") + File.separator + ".." +
-                   File.separator + "bin" + File.separator + "native2ascii";
-            if (File.separatorChar == '\\') {
-                path = path + ".exe";
-            }
-            f = new File(path);
-            if (!f.exists())
-                throw new RuntimeException("Cannot find native2ascii at "+path);
-            System.out.println("Using native2ascii at "+path);
-        }
-        return path;
     }
 
 }
--- ./langtools/.hgtags	Wed Jun 25 09:05:13 2014 -0700
+++ ./langtools/.hgtags	Mon Sep 08 12:17:52 2014 -0700
@@ -420,6 +420,7 @@
 81bf1ca3a3a71c628b7d952ba47c6f200a223f27 jdk7u55-b13
 96d55b4d88fea1d9f8227e70003210a6c10a1dba jdk7u55-b30
 c1964a222000b4884b992fdbaf8f62a45fb893c9 jdk7u55-b14
+56c12a84e86eb47e24e4bc50a4602a276e6b4e4b jdk7u55-b15
 4f6115ba266e5489b5e1968a28304f82be1f5641 jdk7u55-b31
 ec8793f5aa4fb0aff4aa2f02f458fa6720f3ec6f jdk7u55-b32
 13fed9e9f022e4a7f914c8410cbaa6f6564d4efd jdk7u55-b33
@@ -468,3 +469,36 @@
 dea7e67840b68ae6752b37e69e242dae2765b878 jdk7u65-b16
 15a051dfadb6a7d014f0d2739ccf0a63ade56313 jdk7u65-b17
 576e2fd21368ba67f1f19d3180f78bc440b795a1 jdk7u65-b30
+0f809f893588548a3b5c8441e28c9e0a62bc13ef jdk7u65-b18
+eae289997f58ef6396dc323c3d5b93a56fb43573 jdk7u65-b19
+afc940d62b49059f565f87c83343fa3d28df883b jdk7u65-b32
+114c4fc53777e4067a26f6510fe72fa770a9253c jdk7u65-b20
+8a09cca8f12027ba59df4bb18d49e855c4db4811 jdk7u67-b01
+eae289997f58ef6396dc323c3d5b93a56fb43573 jdk7u65-b40
+5e4cc118e2d1f7a8eefca5dd7146d46a1b0ca911 jdk7u65-b31
+59575d1928f98d1e26ea548ff4d5e2415dfe9b57 jdk7u65-b33
+684f0285b699d304d1efff487b550ff2e1679e98 jdk7u66-b00
+a927daae851fa81d0470d2b67f52e8156e4d423c jdk7u66-b01
+6f229fda19bdabf7a3d1caad9d809dd713cce65d jdk7u66-b09
+77e053e3a41f254d99e7a1151b6cf874265132e5 jdk7u66-b10
+596cf48685bcf7970275ce637ea2e58b16e9816e jdk7u66-b11
+021fb086f47f6f3659f0fe2de824c3b5548530c4 jdk7u66-b12
+b9801badec029e241a580aa52db27e03fc5e2b88 jdk7u66-b13
+3ceea3a91e4cbc29a435519747c22dfb02e68f67 jdk7u66-b14
+2918f02cde3e0fd134e2051e67296c3f935825e6 jdk7u66-b15
+9442596a63f000f4290265aa0574ee5fa8865808 jdk7u66-b16
+bd740cf100e1f7f866bd902fb668e77dcd866251 jdk7u66-b17
+df0aa7e382459053c7fa92f133080cdf679c6100 jdk7u71-b00
+46244a1e94b97b324a9ab97322b710af63b2f20b jdk7u71-b01
+29583e3ca6f9cb337fb203a84be70d234e667c1d jdk7u71-b02
+8a5c2c7dd6dce2c0540ace9c4372cf984ad62b9b jdk7u71-b03
+c4b7f94c483e9092ab634067095f4f325f9648a9 jdk7u71-b04
+103784a125a4a4fa40981f524a64cfd5b0c61722 jdk7u71-b05
+6d6a78b11de79b7f38c95e597ea0f33952716e99 jdk7u71-b06
+6c6763cce51e8e888130033350dc37114b17b6a5 jdk7u71-b07
+a5e828c017c4371d7a8cd0be812e7282dc5b7772 jdk7u71-b08
+42d1ec856f73bf3378346d66ad42cd5c57a5f8f2 jdk7u71-b09
+1579a3e24c494de0ee63bed2a4c3fbd176e95abc jdk7u71-b10
+df957022bc94fc84c3d9e6f1f23af29b6afeb63d jdk7u71-b11
+a8fd0637a601ee2747e785bd5e9e2a0262acf280 jdk7u71-b12
+1cefc4b498a60ebc86b76eb2e9e861dbb072bd85 jdk7u71-b13
--- ./langtools/src/share/classes/com/sun/tools/javac/resources/compiler_ja.properties	Wed Jun 25 09:05:13 2014 -0700
+++ ./langtools/src/share/classes/com/sun/tools/javac/resources/compiler_ja.properties	Mon Sep 08 12:17:52 2014 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 1999, 2011, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 1999, 2014, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -98,11 +98,11 @@
 
 compiler.err.annotation.value.not.allowable.type=\u4F7F\u7528\u3067\u304D\u306A\u3044\u578B\u306E\u6CE8\u91C8\u306E\u5024\u3067\u3059
 
-compiler.err.anon.class.impl.intf.no.args=\u540D\u524D\u306E\u306A\u3044\u30AF\u30E9\u30B9\u304C\u30A4\u30F3\u30BF\u30D5\u30A7\u30FC\u30B9\u3092\u5B9F\u88C5\u3057\u3066\u3044\u307E\u3059\u3002\u5F15\u6570\u3092\u6301\u3064\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093
+compiler.err.anon.class.impl.intf.no.args=\u533F\u540D\u30AF\u30E9\u30B9\u304C\u30A4\u30F3\u30BF\u30D5\u30A7\u30FC\u30B9\u3092\u5B9F\u88C5\u3057\u3066\u3044\u307E\u3059\u3002\u5F15\u6570\u3092\u6301\u3064\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093
 
-compiler.err.anon.class.impl.intf.no.typeargs=\u540D\u524D\u306E\u306A\u3044\u30AF\u30E9\u30B9\u304C\u30A4\u30F3\u30BF\u30D5\u30A7\u30FC\u30B9\u3092\u5B9F\u88C5\u3057\u3066\u3044\u307E\u3059\u3002\u578B\u5F15\u6570\u3092\u6301\u3064\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093
+compiler.err.anon.class.impl.intf.no.typeargs=\u533F\u540D\u30AF\u30E9\u30B9\u304C\u30A4\u30F3\u30BF\u30D5\u30A7\u30FC\u30B9\u3092\u5B9F\u88C5\u3057\u3066\u3044\u307E\u3059\u3002\u578B\u5F15\u6570\u3092\u6301\u3064\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093
 
-compiler.err.anon.class.impl.intf.no.qual.for.new=\u540D\u524D\u306E\u306A\u3044\u30AF\u30E9\u30B9\u304C\u30A4\u30F3\u30BF\u30D5\u30A7\u30FC\u30B9\u3092\u5B9F\u88C5\u3057\u3066\u3044\u307E\u3059\u3002new\u306B\u4FEE\u98FE\u5B50\u3092\u6301\u3064\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093\u3002
+compiler.err.anon.class.impl.intf.no.qual.for.new=\u533F\u540D\u30AF\u30E9\u30B9\u304C\u30A4\u30F3\u30BF\u30D5\u30A7\u30FC\u30B9\u3092\u5B9F\u88C5\u3057\u3066\u3044\u307E\u3059\u3002new\u306B\u4FEE\u98FE\u5B50\u3092\u6301\u3064\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093\u3002
 
 # 0: symbol, 1: symbol, 2: symbol
 compiler.err.array.and.varargs={2}\u3067{0}\u3068{1}\u306E\u4E21\u65B9\u3092\u5BA3\u8A00\u3059\u308B\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093
--- ./langtools/src/share/classes/com/sun/tools/javac/resources/javac_ja.properties	Wed Jun 25 09:05:13 2014 -0700
+++ ./langtools/src/share/classes/com/sun/tools/javac/resources/javac_ja.properties	Mon Sep 08 12:17:52 2014 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 1999, 2011, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 1999, 2014, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -115,7 +115,7 @@
 
 javac.msg.usage.nonstandard.footer=\u3053\u308C\u3089\u306F\u975E\u6A19\u6E96\u30AA\u30D7\u30B7\u30E7\u30F3\u3067\u3042\u308A\u4E88\u544A\u306A\u3057\u306B\u5909\u66F4\u3055\u308C\u308B\u3053\u3068\u304C\u3042\u308A\u307E\u3059\u3002
 
-javac.msg.bug=\u30B3\u30F3\u30D1\u30A4\u30E9\u3067\u4F8B\u5916\u304C\u767A\u751F\u3057\u307E\u3057\u305F({0})\u3002Bug Parade\u306B\u540C\u3058\u30D0\u30B0\u304C\u767B\u9332\u3055\u308C\u3066\u3044\u306A\u3044\u3053\u3068\u3092\u3054\u78BA\u8A8D\u306E\u4E0A\u3001Java Developer Connection (http://java.sun.com/webapps/bugreport)\u3067\u30D0\u30B0\u306E\u767B\u9332\u3092\u304A\u9858\u3044\u3044\u305F\u3057\u307E\u3059\u3002\u30EC\u30DD\u30FC\u30C8\u306B\u306F\u3001\u305D\u306E\u30D7\u30ED\u30B0\u30E9\u30E0\u3068\u4E0B\u8A18\u306E\u8A3A\u65AD\u5185\u5BB9\u3092\u542B\u3081\u3066\u304F\u3060\u3055\u3044\u3002\u3054\u5354\u529B\u3042\u308A\u304C\u3068\u3046\u3054\u3056\u3044\u307E\u3059\u3002
+javac.msg.bug=\u30B3\u30F3\u30D1\u30A4\u30E9\u3067\u4F8B\u5916\u304C\u767A\u751F\u3057\u307E\u3057\u305F({0})\u3002Bug Parade\u3067\u91CD\u8907\u304C\u306A\u3044\u304B\u3092\u3054\u78BA\u8A8D\u306E\u3046\u3048\u3001Java Developer Connection (http://java.sun.com/webapps/bugreport)\u3067bug\u306E\u767B\u9332\u3092\u304A\u9858\u3044\u3044\u305F\u3057\u307E\u3059\u3002\u30EC\u30DD\u30FC\u30C8\u306B\u306F\u3001\u305D\u306E\u30D7\u30ED\u30B0\u30E9\u30E0\u3068\u4E0B\u8A18\u306E\u8A3A\u65AD\u5185\u5BB9\u3092\u542B\u3081\u3066\u304F\u3060\u3055\u3044\u3002\u3054\u5354\u529B\u3042\u308A\u304C\u3068\u3046\u3054\u3056\u3044\u307E\u3059\u3002
 
 javac.msg.io=\n\n\u5165\u51FA\u529B\u30A8\u30E9\u30FC\u304C\u767A\u751F\u3057\u307E\u3057\u305F\u3002\n\u8A73\u7D30\u306F\u6B21\u306E\u30B9\u30BF\u30C3\u30AF\u30FB\u30C8\u30EC\u30FC\u30B9\u3067\u8ABF\u67FB\u3057\u3066\u304F\u3060\u3055\u3044\u3002\n
 
--- ./langtools/src/share/classes/com/sun/tools/javadoc/resources/javadoc_ja.properties	Wed Jun 25 09:05:13 2014 -0700
+++ ./langtools/src/share/classes/com/sun/tools/javadoc/resources/javadoc_ja.properties	Mon Sep 08 12:17:52 2014 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -31,7 +31,7 @@
 main.Xusage=-Xmaxerrs <number>        \u51FA\u529B\u3059\u308B\u30A8\u30E9\u30FC\u306E\u6700\u5927\u6570\u3092\u8A2D\u5B9A\u3059\u308B\n-Xmaxwarns <number>       \u51FA\u529B\u3059\u308B\u8B66\u544A\u306E\u6700\u5927\u6570\u3092\u8A2D\u5B9A\u3059\u308B\n\n\u3053\u308C\u3089\u306F\u975E\u6A19\u6E96\u30AA\u30D7\u30B7\u30E7\u30F3\u3067\u3042\u308A\u4E88\u544A\u306A\u3057\u306B\u5909\u66F4\u3055\u308C\u308B\u3053\u3068\u304C\u3042\u308A\u307E\u3059\u3002
 main.option.already.seen={0}\u30AA\u30D7\u30B7\u30E7\u30F3\u304C\u8907\u6570\u6307\u5B9A\u3055\u308C\u3066\u3044\u307E\u3059\u3002
 main.requires_argument=\u30AA\u30D7\u30B7\u30E7\u30F3{0}\u306B\u306F\u5F15\u6570\u304C\u5FC5\u8981\u3067\u3059\u3002
-main.locale_first=\u30AA\u30D7\u30B7\u30E7\u30F3-locale\u306F\u3001\u30B3\u30DE\u30F3\u30C9\u30E9\u30A4\u30F3\u306E\u6700\u521D\u306B\u6307\u5B9A\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059\u3002
+main.locale_first=\u30AA\u30D7\u30B7\u30E7\u30F3-locale\u306F\u3001\u30B3\u30DE\u30F3\u30C9\u884C\u306E\u6700\u521D\u306B\u6307\u5B9A\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059\u3002
 main.invalid_flag={0}\u306F\u7121\u52B9\u306A\u30D5\u30E9\u30B0\u3067\u3059
 main.No_packages_or_classes_specified=\u30D1\u30C3\u30B1\u30FC\u30B8\u307E\u305F\u306F\u30AF\u30E9\u30B9\u304C\u6307\u5B9A\u3055\u308C\u3066\u3044\u307E\u305B\u3093\u3002
 main.incompatible.access.flags=-public\u3001-private\u3001-package\u307E\u305F\u306F-protected\u306E\u3046\u3061\u306E2\u3064\u4EE5\u4E0A\u3092\u6307\u5B9A\u3057\u307E\u3057\u305F\u3002
--- ./langtools/src/share/classes/com/sun/tools/javah/resources/l10n_ja.properties	Wed Jun 25 09:05:13 2014 -0700
+++ ./langtools/src/share/classes/com/sun/tools/javah/resources/l10n_ja.properties	Mon Sep 08 12:17:52 2014 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 1998, 2010, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 1998, 2014, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -27,9 +27,9 @@
 # User errors, command line errors.
 #
 cant.create.dir=\u51FA\u529B\u7528\u306E\u30C7\u30A3\u30EC\u30AF\u30C8\u30EA{0}\u3092\u4F5C\u6210\u3067\u304D\u307E\u305B\u3093\u3002
-at.args.cant.read=\u30D5\u30A1\u30A4\u30EB{1}\u304B\u3089\u30B3\u30DE\u30F3\u30C9\u30E9\u30A4\u30F3\u5F15\u6570\u3092\u8AAD\u307F\u8FBC\u3081\u307E\u305B\u3093\u3002
+at.args.cant.read=\u30D5\u30A1\u30A4\u30EB{1}\u304B\u3089\u30B3\u30DE\u30F3\u30C9\u884C\u5F15\u6570\u3092\u8AAD\u307F\u8FBC\u3081\u307E\u305B\u3093\u3002
 at.args.file.not.found=\u30D5\u30A1\u30A4\u30EB{0}\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093\u3002
-at.args.io.exception=\u30B3\u30DE\u30F3\u30C9\u30E9\u30A4\u30F3\u306E@\u5F15\u6570\u306E\u51E6\u7406\u4E2D\u306B\u3001\u6B21\u306E\u5165\u51FA\u529B\u306E\u554F\u984C\u304C\u767A\u751F\u3057\u307E\u3057\u305F: {0}\u3002
+at.args.io.exception=\u30B3\u30DE\u30F3\u30C9\u884C\u306E@\u5F15\u6570\u306E\u51E6\u7406\u4E2D\u306B\u3001\u6B21\u306E\u5165\u51FA\u529B\u306E\u554F\u984C\u304C\u767A\u751F\u3057\u307E\u3057\u305F: {0}\u3002
 old.jni.mixed=\u30AA\u30D7\u30B7\u30E7\u30F3-jni\u3068-old\u3092\u540C\u6642\u306B\u4F7F\u7528\u3059\u308B\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093\u3002-help\u3067\u78BA\u8A8D\u3057\u3066\u304F\u3060\u3055\u3044\u3002
 old.llni.mixed=\u30AA\u30D7\u30B7\u30E7\u30F3-old\u3068-llni\u3092\u540C\u6642\u306B\u4F7F\u7528\u3059\u308B\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093\u3002-help\u3067\u78BA\u8A8D\u3057\u3066\u304F\u3060\u3055\u3044\u3002
 old.not.supported=\u3053\u306E\u30D0\u30FC\u30B8\u30E7\u30F3\u306Ejavah\u3067\u306F\u30AA\u30D7\u30B7\u30E7\u30F3-old\u306F\u30B5\u30DD\u30FC\u30C8\u3055\u308C\u3066\u3044\u307E\u305B\u3093\u3002
@@ -38,11 +38,11 @@
 jni.no.stubs=JNI\u306F\u30B9\u30BF\u30D6\u3092\u5FC5\u8981\u3068\u3057\u307E\u305B\u3093\u3002JNI\u306E\u30C9\u30AD\u30E5\u30E1\u30F3\u30C8\u3092\u53C2\u7167\u3057\u3066\u304F\u3060\u3055\u3044\u3002
 jni.sigerror={0}\u306E\u30B7\u30B0\u30CD\u30C1\u30E3\u3092\u5224\u5225\u3067\u304D\u307E\u305B\u3093
 dir.file.mixed=\u30AA\u30D7\u30B7\u30E7\u30F3-d\u3068-o\u3092\u540C\u6642\u306B\u4F7F\u7528\u3059\u308B\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093\u3002-help\u3067\u78BA\u8A8D\u3057\u3066\u304F\u3060\u3055\u3044\u3002
-no.classes.specified=\u30B3\u30DE\u30F3\u30C9\u30E9\u30A4\u30F3\u3067\u30AF\u30E9\u30B9\u304C\u6307\u5B9A\u3055\u308C\u307E\u305B\u3093\u3067\u3057\u305F\u3002-help\u3067\u78BA\u8A8D\u3057\u3066\u304F\u3060\u3055\u3044\u3002
-no.outputfile.specified=\u30B3\u30DE\u30F3\u30C9\u30E9\u30A4\u30F3\u3067\u51FA\u529B\u30D5\u30A1\u30A4\u30EB\u304C\u6307\u5B9A\u3055\u308C\u307E\u305B\u3093\u3067\u3057\u305F\u3002-help\u3067\u78BA\u8A8D\u3057\u3066\u304F\u3060\u3055\u3044\u3002
-no.outputdir.specified=\u30B3\u30DE\u30F3\u30C9\u30E9\u30A4\u30F3\u3067\u51FA\u529B\u30C7\u30A3\u30EC\u30AF\u30C8\u30EA\u304C\u6307\u5B9A\u3055\u308C\u307E\u305B\u3093\u3067\u3057\u305F\u3002-help\u3067\u78BA\u8A8D\u3057\u3066\u304F\u3060\u3055\u3044\u3002
-no.classpath.specified=\u30B3\u30DE\u30F3\u30C9\u30E9\u30A4\u30F3\u3067\u30AF\u30E9\u30B9\u30D1\u30B9\u304C\u6307\u5B9A\u3055\u308C\u307E\u305B\u3093\u3067\u3057\u305F\u3002-help\u3067\u78BA\u8A8D\u3057\u3066\u304F\u3060\u3055\u3044\u3002
-no.bootclasspath.specified=\u30B3\u30DE\u30F3\u30C9\u30E9\u30A4\u30F3\u3067\u30D6\u30FC\u30C8\u30FB\u30AF\u30E9\u30B9\u30D1\u30B9\u304C\u6307\u5B9A\u3055\u308C\u307E\u305B\u3093\u3067\u3057\u305F\u3002-help\u3067\u78BA\u8A8D\u3057\u3066\u304F\u3060\u3055\u3044\u3002
+no.classes.specified=\u30B3\u30DE\u30F3\u30C9\u884C\u3067\u30AF\u30E9\u30B9\u304C\u6307\u5B9A\u3055\u308C\u307E\u305B\u3093\u3067\u3057\u305F\u3002-help\u3067\u78BA\u8A8D\u3057\u3066\u304F\u3060\u3055\u3044\u3002
+no.outputfile.specified=\u30B3\u30DE\u30F3\u30C9\u884C\u3067\u51FA\u529B\u30D5\u30A1\u30A4\u30EB\u304C\u6307\u5B9A\u3055\u308C\u307E\u305B\u3093\u3067\u3057\u305F\u3002-help\u3067\u78BA\u8A8D\u3057\u3066\u304F\u3060\u3055\u3044\u3002
+no.outputdir.specified=\u30B3\u30DE\u30F3\u30C9\u884C\u3067\u51FA\u529B\u30C7\u30A3\u30EC\u30AF\u30C8\u30EA\u304C\u6307\u5B9A\u3055\u308C\u307E\u305B\u3093\u3067\u3057\u305F\u3002-help\u3067\u78BA\u8A8D\u3057\u3066\u304F\u3060\u3055\u3044\u3002
+no.classpath.specified=\u30B3\u30DE\u30F3\u30C9\u884C\u3067\u30AF\u30E9\u30B9\u30D1\u30B9\u304C\u6307\u5B9A\u3055\u308C\u307E\u305B\u3093\u3067\u3057\u305F\u3002-help\u3067\u78BA\u8A8D\u3057\u3066\u304F\u3060\u3055\u3044\u3002
+no.bootclasspath.specified=\u30B3\u30DE\u30F3\u30C9\u884C\u3067\u30D6\u30FC\u30C8\u30FB\u30AF\u30E9\u30B9\u30D1\u30B9\u304C\u6307\u5B9A\u3055\u308C\u307E\u305B\u3093\u3067\u3057\u305F\u3002-help\u3067\u78BA\u8A8D\u3057\u3066\u304F\u3060\u3055\u3044\u3002
 unknown.option={0}\u306F\u4E0D\u6B63\u306A\u5F15\u6570\u3067\u3059\n
 tracing.not.supported=\u8B66\u544A: \u30C8\u30EC\u30FC\u30B9\u306F\u73FE\u5728\u306F\u30B5\u30DD\u30FC\u30C8\u3055\u308C\u3066\u3044\u307E\u305B\u3093\u3002\u304B\u308F\u308A\u306B\u3001Virtual Machine\u306E-verbose:jni\u30AA\u30D7\u30B7\u30E7\u30F3\u3092\u4F7F\u7528\u3057\u3066\u304F\u3060\u3055\u3044\u3002
 
--- ./langtools/src/share/classes/com/sun/tools/javap/resources/javap_ja.properties	Wed Jun 25 09:05:13 2014 -0700
+++ ./langtools/src/share/classes/com/sun/tools/javap/resources/javap_ja.properties	Mon Sep 08 12:17:52 2014 -0700
@@ -3,7 +3,7 @@
 
 err.bad.constant.pool={0}\u306E\u5B9A\u6570\u30D7\u30FC\u30EB\u306E\u8AAD\u53D6\u308A\u4E2D\u306B\u30A8\u30E9\u30FC\u304C\u767A\u751F\u3057\u307E\u3057\u305F: {1}
 err.class.not.found=\u30AF\u30E9\u30B9\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093: {0}
-err.crash=\u91CD\u5927\u306A\u5185\u90E8\u30A8\u30E9\u30FC\u304C\u767A\u751F\u3057\u307E\u3057\u305F: {0}\n\u6B21\u306E\u60C5\u5831\u3092\u542B\u3080\u30D0\u30B0\u30FB\u30EC\u30DD\u30FC\u30C8\u3092\u30D5\u30A1\u30A4\u30EB\u3057\u3066\u304F\u3060\u3055\u3044:\n{1}
+err.crash=\u91CD\u5927\u306A\u5185\u90E8\u30A8\u30E9\u30FC\u304C\u767A\u751F\u3057\u307E\u3057\u305F: {0}\n\u6B21\u306E\u60C5\u5831\u3092\u542B\u3080bug\u30EC\u30DD\u30FC\u30C8\u3092\u30D5\u30A1\u30A4\u30EB\u3057\u3066\u304F\u3060\u3055\u3044:\n{1}
 err.end.of.file={0}\u306E\u8AAD\u53D6\u308A\u4E2D\u306B\u4E88\u671F\u3057\u306A\u3044\u30D5\u30A1\u30A4\u30EB\u306E\u7D42\u308F\u308A\u304C\u691C\u51FA\u3055\u308C\u307E\u3057\u305F
 err.file.not.found=\u30D5\u30A1\u30A4\u30EB\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093: {0}
 err.h.not.supported=-h\u306F\u4F7F\u7528\u53EF\u80FD\u3067\u306A\u304F\u306A\u308A\u307E\u3057\u305F - 'javah'\u30D7\u30ED\u30B0\u30E9\u30E0\u3092\u4F7F\u7528\u3057\u3066\u304F\u3060\u3055\u3044
