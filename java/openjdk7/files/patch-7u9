diff -r e4def733cc8c -r d9c8fa0606fd .hgtags
--- .hgtags	Tue Aug 07 12:09:29 2012 -0700
+++ .hgtags	Thu Sep 20 14:22:08 2012 -0700
@@ -197,3 +197,17 @@
 29f6fb1833eb2a696b95e8985126f2d70f511a82 jdk7u6-b21
 31cdab09d719fe60876c7f3a472386c1455d93e2 jdk7u6-b22
 d1c709f1196a73d1df10d04a221b10e30fd2eb48 jdk7u6-b23
+e4def733cc8c58e83b7cefa7edd89a3e2b793520 jdk7u6-b24
+f5f546dba006778854e7a81141fc1b44acd257a4 jdk7u6-b30
+43775eae8df6c874fb3631c86009505cf3821b1f jdk7u7-b10
+a380c75873bfb578e605d4362edb18c08698cc3e jdk7u7-b30
+d7f2b3949f9c9ff1115ea61c496d3cd4c62e2759 jdk7u7-b11
+82c51e6a3bea0dd8feb1bd3033e847dbdc5d9f99 jdk7u7-b31
+5ca487420f9c2cf6d39acf1e842d13bf8ef0ca07 jdk7u7-b01
+dbfa9c57853c2dd9cd4e4a139d83b519573d8031 jdk7u7-b02
+bae912f95f2aa1d22dbc0ff62816b71861965cd6 jdk7u9-b03
+0000000000000000000000000000000000000000 jdk7u7-b01
+5ca487420f9c2cf6d39acf1e842d13bf8ef0ca07 jdk7u9-b01
+0000000000000000000000000000000000000000 jdk7u7-b02
+dbfa9c57853c2dd9cd4e4a139d83b519573d8031 jdk7u9-b02
+3159fbe20e2d9501007aae8ca3db58978d754561 jdk7u9-b04
diff -r 02512f61591f -r a5dced409c4b .hgtags
--- corba/.hgtags	Tue Aug 07 12:09:37 2012 -0700
+++ corba/.hgtags	Thu Sep 20 14:22:12 2012 -0700
@@ -197,3 +197,17 @@
 353c15c4bc371f2f8258344c988d1403477cc140 jdk7u6-b21
 793b80c0316fcafa18668bced26acb41af3be07d jdk7u6-b22
 2a8376123fbb81bc4b2f643ff7cfaf7f87b21c35 jdk7u6-b23
+02512f61591f55d84458d1ea4ce84eecb7324f89 jdk7u6-b24
+8b20875b3faa01ef56331045de88747df278eaeb jdk7u6-b30
+d7fe6c13adf9e06d98c061449d171bc06c2ba0a3 jdk7u7-b10
+496baf62d0550c704505b0ff6f390279f6a569e0 jdk7u7-b30
+e57e4274a3575f278115cc8ef03c5bdf3c43a7ed jdk7u7-b11
+06cbc4af754ea8f2e3b7d0b1701d1a69ce9d5075 jdk7u7-b31
+8737f43e092ea52dd85dcf164736eea3b9b364e6 jdk7u7-b01
+ec602836c4e173927911673d253bb8baa1e3d170 jdk7u7-b02
+a163e56c6679d10dc64ec48f35e67c3a5942afba jdk7u9-b03
+0000000000000000000000000000000000000000 jdk7u7-b01
+8737f43e092ea52dd85dcf164736eea3b9b364e6 jdk7u9-b01
+0000000000000000000000000000000000000000 jdk7u7-b02
+ec602836c4e173927911673d253bb8baa1e3d170 jdk7u9-b02
+268470f3f0d0d7e9b04c579c551571097f0b0305 jdk7u9-b04
diff -r b03c2687fb16 -r da4aa289ac10 .hgtags
--- hotspot/.hgtags	Tue Aug 07 12:09:51 2012 -0700
+++ hotspot/.hgtags	Mon Sep 24 12:07:44 2012 -0700
@@ -318,3 +318,17 @@
 02a6c89432d724119565f9ba25672829b136fc5f jdk7u6-b21
 a79d86eef6ac995a1fc35554f082f3a61abe9ae0 jdk7u6-b22
 df57f6208cb76b4e8d1a0bd0eea3d2ad577cb79b jdk7u6-b23
+b03c2687fb16514652e79261ad68d2c601dcee62 jdk7u6-b24
+cffde29ea7cc8647f17002a4d0e94065dcd82839 jdk7u6-b30
+f7933fecea9aa494e4032e17ff07e5fcec4b5961 jdk7u7-b10
+eeef33dc4b40f9ba50c4c9b1ac61b30f0f2523bf jdk7u7-b30
+f1551c70c7f598b7049bcc33e530fc738a81c7a4 jdk7u7-b11
+6b9db7216dd4b7846faf372f19566a418c8e391f jdk7u7-b31
+b66bb0e3224ff15259361a5b501bf8fa6b346113 jdk7u7-b01
+ca6943c94e6075fc28353d52ac6ea52c80aef9bb jdk7u7-b02
+e043d96d767d8ba4d74d53c477af8e07b78b6128 jdk7u9-b03
+0000000000000000000000000000000000000000 jdk7u7-b01
+b66bb0e3224ff15259361a5b501bf8fa6b346113 jdk7u9-b01
+0000000000000000000000000000000000000000 jdk7u7-b02
+ca6943c94e6075fc28353d52ac6ea52c80aef9bb jdk7u9-b02
+ed42837374ac730ddaf2fd28814017c665634a8b jdk7u9-b04
diff -r b03c2687fb16 -r da4aa289ac10 make/hotspot_version
--- hotspot/make/hotspot_version	Tue Aug 07 12:09:51 2012 -0700
+++ hotspot/make/hotspot_version	Mon Sep 24 12:07:44 2012 -0700
@@ -34,8 +34,8 @@
 HOTSPOT_VM_COPYRIGHT=Copyright 2012
 
 HS_MAJOR_VER=23
-HS_MINOR_VER=2
-HS_BUILD_NUMBER=09
+HS_MINOR_VER=5
+HS_BUILD_NUMBER=02
 
 JDK_MAJOR_VER=1
 JDK_MINOR_VER=7
diff -r b03c2687fb16 -r da4aa289ac10 src/cpu/sparc/vm/methodHandles_sparc.cpp
--- hotspot/src/cpu/sparc/vm/methodHandles_sparc.cpp	Tue Aug 07 12:09:51 2012 -0700
+++ hotspot/src/cpu/sparc/vm/methodHandles_sparc.cpp	Mon Sep 24 12:07:44 2012 -0700
@@ -698,6 +698,17 @@
   if (arg_slots.is_constant() && arg_slots.as_constant() == 0)
     return;
 
+  // We have to insert at least one word, so bang the stack.
+  if (UseStackBanging) {
+    // Save G3_method_handle since bang_stack_with_offset uses it as a temp register
+    __ mov(G3_method_handle, temp_reg);
+    int frame_size = (arg_slots.is_constant() ? -1 * arg_slots.as_constant() * wordSize : 0);
+    if (frame_size <= 0)
+      frame_size = 256 * Interpreter::stackElementSize;  // conservative
+    __ generate_stack_overflow_check(frame_size);
+    __ mov(temp_reg, G3_method_handle);
+  }
+
   assert_different_registers(argslot_reg, temp_reg, temp2_reg, temp3_reg,
                              (!arg_slots.is_register() ? Gargs : arg_slots.as_register()));
 
@@ -1702,6 +1713,14 @@
                         "copied argument(s) must fall within current frame");
       }
 
+      if (UseStackBanging) {
+        // Save G3_method_handle since bang_stack_with_offset uses it as a temp register
+        __ mov(G3_method_handle, O3_scratch);
+         // Bang the stack before pushing args.
+        int frame_size = 256 * Interpreter::stackElementSize;  // conservative
+        __ generate_stack_overflow_check(frame_size + sizeof(RicochetFrame));
+        __ mov(O3_scratch, G3_method_handle);
+      }
       // insert location is always the bottom of the argument list:
       __ neg(O1_stack_move);
       push_arg_slots(_masm, O0_argslot, O1_stack_move, O2_scratch, O3_scratch);
@@ -2118,6 +2137,18 @@
       // The return handler will further cut back the stack when it takes
       // down the RF.  Perhaps there is a way to streamline this further.
 
+      if (UseStackBanging) {
+        // Save G3_method_handle since bang_stack_with_offset uses it as a temp register
+        __ mov(G3_method_handle, O4_scratch);
+        // Bang the stack before recursive call.
+        // Even if slots == 0, we are inside a RicochetFrame.
+        int frame_size = collect_count.is_constant() ? collect_count.as_constant() * wordSize : -1;
+        if (frame_size < 0) {
+          frame_size = 256 * Interpreter::stackElementSize;  // conservative
+        }
+        __ generate_stack_overflow_check(frame_size + sizeof(RicochetFrame));
+        __ mov(O4_scratch, G3_method_handle);
+      }
       // State during recursive call:
       // ... keep1 | dest | dest=42 | keep3 | RF... | collect | bounce_pc |
       __ jump_to_method_handle_entry(G3_method_handle, O1_scratch);
diff -r b03c2687fb16 -r da4aa289ac10 src/cpu/x86/vm/methodHandles_x86.cpp
--- hotspot/src/cpu/x86/vm/methodHandles_x86.cpp	Tue Aug 07 12:09:51 2012 -0700
+++ hotspot/src/cpu/x86/vm/methodHandles_x86.cpp	Mon Sep 24 12:07:44 2012 -0700
@@ -691,6 +691,14 @@
   if (VerifyMethodHandles)
     verify_stack_move(_masm, arg_slots, -1);
 
+  // We have to insert at least one word, so bang the stack.
+  if (UseStackBanging) {
+    int frame_size = (arg_slots.is_constant() ? -1 * arg_slots.as_constant() * wordSize : 0);
+    if (frame_size <= 0)
+      frame_size = 256 * Interpreter::stackElementSize;  // conservative
+    __ generate_stack_overflow_check(frame_size);
+  }
+
   // Make space on the stack for the inserted argument(s).
   // Then pull down everything shallower than rax_argslot.
   // The stacked return address gets pulled down with everything else.
@@ -1769,6 +1777,11 @@
                         "copied argument(s) must fall within current frame");
       }
 
+      if (UseStackBanging) {
+        // Bang the stack before pushing args.
+        int frame_size = 256 * Interpreter::stackElementSize;  // conservative
+        __ generate_stack_overflow_check(frame_size + sizeof(RicochetFrame));
+      }
       // insert location is always the bottom of the argument list:
       Address insert_location = __ argument_address(constant(0));
       int pre_arg_words = insert_location.disp() / wordSize;   // return PC is pushed
@@ -2206,6 +2219,15 @@
       // The return handler will further cut back the stack when it takes
       // down the RF.  Perhaps there is a way to streamline this further.
 
+      if (UseStackBanging) {
+        // Bang the stack before recursive call.
+        // Even if slots == 0, we are inside a RicochetFrame.
+        int frame_size = collect_count.is_constant() ? collect_count.as_constant() * wordSize : -1;
+        if (frame_size < 0) {
+          frame_size = 256 * Interpreter::stackElementSize;  // conservative
+        }
+        __ generate_stack_overflow_check(frame_size + sizeof(RicochetFrame));
+      }
       // State during recursive call:
       // ... keep1 | dest | dest=42 | keep3 | RF... | collect | bounce_pc |
       __ jump_to_method_handle_entry(rcx_recv, rdx_temp);
@@ -2366,10 +2388,15 @@
         // case in a 32-bit version of the VM) we have to save 'rsi'
         // on the stack because later on (at 'L_array_is_empty') 'rsi'
         // will be overwritten.
-        { if (rsi_temp == saved_last_sp)  __ push(saved_last_sp); }
+        if (rsi_temp == saved_last_sp) {
+          __ push(saved_last_sp);
+          // Need to re-push return PC to keep it on stack top.
+          __ lea(saved_last_sp, ExternalAddress(SharedRuntime::ricochet_blob()->bounce_addr()).addr());
+          __ push(saved_last_sp);
+        }
         // Also prepare a handy macro which restores 'rsi' if required.
 #define UNPUSH_RSI                                                      \
-        { if (rsi_temp == saved_last_sp)  __ pop(saved_last_sp); }
+        { if (rsi_temp == saved_last_sp) { __ pop(saved_last_sp); __ pop(saved_last_sp); } }
 
         __ jmp(L_array_is_empty);
         __ bind(L_skip);
@@ -2382,7 +2409,12 @@
       // called in the case of a null pointer exception will not be
       // confused by the extra value on the stack (it expects the
       // return pointer on top of the stack)
-      { if (rsi_temp == saved_last_sp)  __ push(saved_last_sp); }
+      if (rsi_temp == saved_last_sp) {
+        __ push(saved_last_sp);
+        // Need to re-push return PC to keep it on stack top.
+        __ lea(saved_last_sp, ExternalAddress(SharedRuntime::ricochet_blob()->bounce_addr()).addr());
+        __ push(saved_last_sp);
+      }
 
       // Check the array type.
       Register rbx_klass = rbx_temp;
diff -r b03c2687fb16 -r da4aa289ac10 src/share/vm/compiler/compilerOracle.cpp
--- hotspot/src/share/vm/compiler/compilerOracle.cpp	Tue Aug 07 12:09:51 2012 -0700
+++ hotspot/src/share/vm/compiler/compilerOracle.cpp	Mon Sep 24 12:07:44 2012 -0700
@@ -575,7 +575,7 @@
   char token[1024];
   int  pos = 0;
   int  c = getc(stream);
-  while(c != EOF) {
+  while(c != EOF && pos < (int)(sizeof(token)-1)) {
     if (c == '\n') {
       token[pos++] = '\0';
       parse_from_line(token);
@@ -596,7 +596,7 @@
   int  pos = 0;
   const char* sp = str;
   int  c = *sp++;
-  while (c != '\0') {
+  while (c != '\0' && pos < (int)(sizeof(token)-1)) {
     if (c == '\n') {
       token[pos++] = '\0';
       parse_line(token);
diff -r b03c2687fb16 -r da4aa289ac10 src/share/vm/opto/loopTransform.cpp
--- hotspot/src/share/vm/opto/loopTransform.cpp	Tue Aug 07 12:09:51 2012 -0700
+++ hotspot/src/share/vm/opto/loopTransform.cpp	Mon Sep 24 12:07:44 2012 -0700
@@ -2733,6 +2733,8 @@
   result_mem = new (C, 1) ProjNode(call,TypeFunc::Memory);
   _igvn.register_new_node_with_optimizer(result_mem);
 
+/* Disable following optimization until proper fix (add missing checks).
+
   // If this fill is tightly coupled to an allocation and overwrites
   // the whole body, allow it to take over the zeroing.
   AllocateNode* alloc = AllocateNode::Ideal_allocation(base, this);
@@ -2756,6 +2758,7 @@
 #endif
     }
   }
+*/
 
   // Redirect the old control and memory edges that are outside the loop.
   Node* exit = head->loopexit()->proj_out(0);
diff -r b03c2687fb16 -r da4aa289ac10 src/share/vm/runtime/arguments.cpp
--- hotspot/src/share/vm/runtime/arguments.cpp	Tue Aug 07 12:09:51 2012 -0700
+++ hotspot/src/share/vm/runtime/arguments.cpp	Mon Sep 24 12:07:44 2012 -0700
@@ -857,7 +857,7 @@
   bool result         = true;
 
   int c = getc(stream);
-  while(c != EOF) {
+  while(c != EOF && pos < (int)(sizeof(token)-1)) {
     if (in_white_space) {
       if (in_comment) {
         if (c == '\n') in_comment = false;
diff -r 378f719cfb94 -r ab4bbb93b383 .hgtags
--- jaxp/.hgtags	Tue Aug 07 12:10:13 2012 -0700
+++ jaxp/.hgtags	Thu Sep 20 14:22:51 2012 -0700
@@ -197,3 +197,17 @@
 7403701aa75848ca2a7b297909908b858134e132 jdk7u6-b21
 fcf35906d1d88583878cd2e2d7c63dfba4e9f679 jdk7u6-b22
 8824bcbfd7cd8059ededf70f1e7f2b06f02cb33f jdk7u6-b23
+378f719cfb9491b766cd9f7cd47ad7fa3503e141 jdk7u6-b24
+5f1b80e8baec46fc28826a3a6ab8e1913c872f4c jdk7u6-b30
+2eafa8a6fd8fdb54b10045e247d1a57f9817f473 jdk7u7-b10
+c4aa15da8529451cc678d5747e7b82e9cc38627e jdk7u7-b30
+f6e11679b12e1548f407b78a940c568401dd2a19 jdk7u7-b11
+7840a267c777e22004912ad0aadd5258ac3d36c6 jdk7u7-b31
+61fc72e9fe26b3acf1572866143c22719c088b62 jdk7u7-b01
+78d9e4853388a2e7be18ff18c0b5330c074cb514 jdk7u7-b02
+fc7c5aa8c722f28c59560ce83140e803d853afc9 jdk7u9-b03
+0000000000000000000000000000000000000000 jdk7u7-b01
+61fc72e9fe26b3acf1572866143c22719c088b62 jdk7u9-b01
+0000000000000000000000000000000000000000 jdk7u7-b02
+78d9e4853388a2e7be18ff18c0b5330c074cb514 jdk7u9-b02
+b12a2d557c5e302b614c5f7e25ad6c8a0e138742 jdk7u9-b04
diff -r b8b85e62d2c5 -r f3e42e044584 .hgtags
--- jaxws/.hgtags	Tue Aug 07 12:10:23 2012 -0700
+++ jaxws/.hgtags	Thu Sep 20 14:22:56 2012 -0700
@@ -197,3 +197,17 @@
 55dcda93e8c8b5c3170def946de35dd0407eab59 jdk7u6-b21
 0fec2efe2452aed9736da39add4c7f71be561838 jdk7u6-b22
 afb6d773328fa76cea65dc024a448cd931d111f2 jdk7u6-b23
+b8b85e62d2c5347df8cf2e825e51e3de178508ea jdk7u6-b24
+fb03d08f73e98f0dd67cb81632eb9b685de49b7e jdk7u6-b30
+739ffa9dffad4cc2febe66ca1c2d86496e80741a jdk7u7-b10
+e9a5a78329d0518efafd9f6f6149f359a7db4e2e jdk7u7-b30
+ed6262e7bb0db4cd116c31f3c88cbd7c0288de40 jdk7u7-b11
+538c248de3ef0fcb34c28295c1eab61269708137 jdk7u7-b31
+dc2e6882056c2d400d4cf3c78d67da8e20fc37cc jdk7u7-b01
+45cf55bc1732e8495425dceb385740c6852c0fc8 jdk7u7-b02
+0289894a64a628133bb63f1dc48b45593f96a14d jdk7u9-b03
+0000000000000000000000000000000000000000 jdk7u7-b01
+dc2e6882056c2d400d4cf3c78d67da8e20fc37cc jdk7u9-b01
+0000000000000000000000000000000000000000 jdk7u7-b02
+45cf55bc1732e8495425dceb385740c6852c0fc8 jdk7u9-b02
+66a2e01550a9e84e907a7f7b96e64ee90a4ec0e4 jdk7u9-b04
diff -r 1c775da99873 -r ffad06d70095 .hgtags
--- jdk/.hgtags	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/.hgtags	Sun Sep 23 23:43:31 2012 +0400
@@ -197,3 +197,17 @@
 243717d7fe9589148951ffb5551264af0e446314 jdk7u6-b21
 d78f2b600d393f45d6ace8ca0f29ad677624a775 jdk7u6-b22
 0ae89e53f5300da1961984a7d81c220c7cf717d7 jdk7u6-b23
+1c775da998735711853cfe1ae1d6baddc5f12a66 jdk7u6-b24
+4bd0528374971157afd6372890f4250e1cf712d9 jdk7u6-b30
+78e01a6ca8d30e8fc4eb297d297a098edfb3fec6 jdk7u7-b10
+9666d4e4bbf3f80614e246d5c15df86154544013 jdk7u7-b30
+94154c14973aee7c5ff4846af7bcb71fe7a82fa5 jdk7u7-b11
+f93d2e3b2610b612401c95dd56d1a1122d35f676 jdk7u7-b31
+94a7d51992ae6fd31f9adc15c4976d6354dca14d jdk7u7-b01
+901c290c9c8b495a2696f10a87523363239d001b jdk7u7-b02
+0e2200a8762c1fdbd1ea812ba3f6535245372c81 jdk7u9-b03
+0000000000000000000000000000000000000000 jdk7u7-b01
+94a7d51992ae6fd31f9adc15c4976d6354dca14d jdk7u9-b01
+0000000000000000000000000000000000000000 jdk7u7-b02
+901c290c9c8b495a2696f10a87523363239d001b jdk7u9-b02
+7302c386ca9c6cd20c27d0a2adb0b142f679d6b3 jdk7u9-b04
diff -r 1c775da99873 -r ffad06d70095 make/com/oracle/security/ucrypto/Makefile
--- jdk/make/com/oracle/security/ucrypto/Makefile	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/make/com/oracle/security/ucrypto/Makefile	Sun Sep 23 23:43:31 2012 +0400
@@ -198,9 +198,9 @@
   #
   # Build ucrypto.jar.
   #
-  $(UNSIGNED_DIR)/ucrypto.jar: build
+  $(UNSIGNED_DIR)/ucrypto.jar: build $(JCE_MANIFEST_FILE)
 	$(prep-target)
-	$(BOOT_JAR_CMD) cf $@ $(JAR_DIRS) \
+	$(BOOT_JAR_CMD) cmf $(JCE_MANIFEST_FILE) $@ $(JAR_DIRS) \
 	    $(BOOT_JAR_JFLAGS)
 	@$(java-vm-cleanup)
 
diff -r 1c775da99873 -r ffad06d70095 make/common/Release.gmk
--- jdk/make/common/Release.gmk	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/make/common/Release.gmk	Sun Sep 23 23:43:31 2012 +0400
@@ -399,10 +399,29 @@
 	sun/tools/jinfo         \
 	sun/tools/jmap
 
+JFR_SRCDIRS_EXIST := $(shell \
+  if [ -d $(CLOSED_SHARE_SRC)/classes/com/oracle/jrockit/jfr ] ; then \
+   echo true; \
+  else \
+   echo false; \
+  fi)
+
+BUILD_JFR=
+ifndef OPENJDK
+ifndef JAVASE_EMBEDDED
+ifeq ($(JFR_SRCDIRS_EXIST), true)
+BUILD_JFR=true
+endif
+endif
+endif
+
 # classes that go into jfr.jar
+JFR_CLASSES_DIRS=
+ifdef BUILD_JFR
 JFR_CLASSES_DIRS= \
 	com/oracle/jrockit/jfr \
 	oracle/jrockit/jfr
+endif
 
 # classes that go into jsse.jar
 JSSE_CLASSES_DIRS = \
@@ -606,8 +625,7 @@
 	$(ECHO) "sun/tools/jstack/" >> $@
 	$(ECHO) "sun/tools/jinfo/" >> $@
 	$(ECHO) "sun/tools/jmap/" >> $@
-ifndef OPENJDK
-ifndef JAVASE_EMBEDDED
+ifdef BUILD_JFR
 	$(ECHO) "com/oracle/jrockit/jfr/" >> $@
 	$(ECHO) "com/oracle/jrockit/jfr/client/" >> $@
 	$(ECHO) "com/oracle/jrockit/jfr/management/" >> $@
@@ -618,7 +636,7 @@
 	$(ECHO) "oracle/jrockit/jfr/settings/" >> $@
 	$(ECHO) "oracle/jrockit/jfr/tools/" >> $@
 endif
-endif
+
 
 
 # File order list for rt.jar
@@ -645,8 +663,7 @@
 
 # Create jfr.jar
 JFR_JAR=
-ifndef OPENJDK
-ifndef JAVASE_EMBEDDED
+ifdef BUILD_JFR
 JFR_JAR=$(ABS_TEMPDIR)/jfr-orig.jar
 $(JFR_JAR): $(OTHER_JAR_MANIFEST_FILE)
 	$(prep-target)
@@ -655,7 +672,6 @@
 		$(JFR_CLASSES_DIRS) $(BOOT_JAR_JFLAGS)
 	@$(CD) $(CLASSBINDIR) && $(java-vm-cleanup)
 endif
-endif
 
 # Create the rt.jar file list & non-class files list
 
diff -r 1c775da99873 -r ffad06d70095 make/java/java/FILES_java.gmk
--- jdk/make/java/java/FILES_java.gmk	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/make/java/java/FILES_java.gmk	Sun Sep 23 23:43:31 2012 +0400
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 1996, 2011, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 1996, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -476,6 +476,7 @@
     sun/misc/MessageUtils.java \
     sun/misc/GC.java \
     sun/misc/Service.java \
+    sun/misc/JavaAWTAccess.java \
     sun/misc/JavaLangAccess.java \
     sun/misc/JavaIOAccess.java \
     sun/misc/JavaIOFileDescriptorAccess.java \
diff -r 1c775da99873 -r ffad06d70095 make/javax/crypto/Defs-jce.gmk
--- jdk/make/javax/crypto/Defs-jce.gmk	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/make/javax/crypto/Defs-jce.gmk	Sun Sep 23 23:43:31 2012 +0400
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2007, 2011, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2007, 2012, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -31,7 +31,7 @@
 JCE_MANIFEST_FILE    = $(TEMPDIR)/manifest.mf
 $(JCE_MANIFEST_FILE): $(MAINMANIFEST)
 	$(prep-target)
-	$(SED) -e "s#@@RELEASE@@#$(RELEASE)#"           \
+	$(SED) -e "s#@@RELEASE@@#$(JDK_VERSION)#"       \
                -e "s#@@COMPANY_NAME@@#$(COMPANY_NAME)#" \
                $(MAINMANIFEST) >> $@
 	$(ECHO) "Extension-Name: javax.crypto" >> $@
diff -r 1c775da99873 -r ffad06d70095 make/sun/security/ec/Makefile
--- jdk/make/sun/security/ec/Makefile	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/make/sun/security/ec/Makefile	Sun Sep 23 23:43:31 2012 +0400
@@ -245,9 +245,9 @@
 #
 # Build sunec.jar.
 #
-$(UNSIGNED_DIR)/sunec.jar: build
+$(UNSIGNED_DIR)/sunec.jar: build $(JCE_MANIFEST_FILE)
 	$(prep-target)
-	$(BOOT_JAR_CMD) cf $@ $(JAR_DIRS) \
+	$(BOOT_JAR_CMD) cmf $(JCE_MANIFEST_FILE) $@ $(JAR_DIRS) \
 	    $(BOOT_JAR_JFLAGS)
 	@$(java-vm-cleanup)
 
diff -r 1c775da99873 -r ffad06d70095 make/sun/security/mscapi/Makefile
--- jdk/make/sun/security/mscapi/Makefile	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/make/sun/security/mscapi/Makefile	Sun Sep 23 23:43:31 2012 +0400
@@ -210,9 +210,9 @@
 #
 # Build sunmscapi.jar.
 #
-$(UNSIGNED_DIR)/sunmscapi.jar: build
+$(UNSIGNED_DIR)/sunmscapi.jar: build $(JCE_MANIFEST_FILE)
 	$(prep-target)
-	$(BOOT_JAR_CMD) cf $@ $(JAR_DIRS) \
+	$(BOOT_JAR_CMD) cmf $(JCE_MANIFEST_FILE) $@ $(JAR_DIRS) \
 	    $(BOOT_JAR_JFLAGS)
 	@$(java-vm-cleanup)
 
diff -r 1c775da99873 -r ffad06d70095 make/sun/security/pkcs11/Makefile
--- jdk/make/sun/security/pkcs11/Makefile	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/make/sun/security/pkcs11/Makefile	Sun Sep 23 23:43:31 2012 +0400
@@ -224,9 +224,9 @@
 #
 # Build sunpkcs11.jar.
 #
-$(UNSIGNED_DIR)/sunpkcs11.jar: build
+$(UNSIGNED_DIR)/sunpkcs11.jar: build $(JCE_MANIFEST_FILE)
 	$(prep-target)
-	$(BOOT_JAR_CMD) cf $@ $(JAR_DIRS) \
+	$(BOOT_JAR_CMD) cmf $(JCE_MANIFEST_FILE) $@ $(JAR_DIRS) \
 	    $(BOOT_JAR_JFLAGS)
 	@$(java-vm-cleanup)
 
diff -r 1c775da99873 -r ffad06d70095 src/macosx/classes/sun/lwawt/macosx/LWCToolkit.java
--- jdk/src/macosx/classes/sun/lwawt/macosx/LWCToolkit.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/macosx/classes/sun/lwawt/macosx/LWCToolkit.java	Sun Sep 23 23:43:31 2012 +0400
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -42,6 +42,7 @@
 import sun.awt.*;
 import sun.lwawt.*;
 import sun.lwawt.LWWindowPeer.PeerType;
+import sun.security.action.GetBooleanAction;
 
 
 class NamedCursor extends Cursor {
@@ -90,14 +91,6 @@
         }
     }
 
-    static String getSystemProperty(final String name, final String deflt) {
-        return AccessController.doPrivileged (new PrivilegedAction<String>() {
-            public String run() {
-                return System.getProperty(name, deflt);
-            }
-        });
-    }
-
     public LWCToolkit() {
         SunToolkit.setDataTransfererClassName("sun.lwawt.macosx.CDataTransferer");
 
@@ -709,8 +702,8 @@
      */
     public synchronized static boolean getSunAwtDisableCALayers() {
         if (sunAwtDisableCALayers == null) {
-            sunAwtDisableCALayers =
-            getBooleanSystemProperty("sun.awt.disableCALayers");
+            sunAwtDisableCALayers = AccessController.doPrivileged(
+                new GetBooleanAction("sun.awt.disableCALayers"));
         }
         return sunAwtDisableCALayers.booleanValue();
     }
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/com/sun/beans/decoder/DocumentHandler.java
--- jdk/src/share/classes/com/sun/beans/decoder/DocumentHandler.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/com/sun/beans/decoder/DocumentHandler.java	Sun Sep 23 23:43:31 2012 +0400
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -37,6 +37,9 @@
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.security.AccessControlContext;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 
 import javax.xml.parsers.ParserConfigurationException;
 import javax.xml.parsers.SAXParserFactory;
@@ -46,6 +49,8 @@
 import org.xml.sax.SAXException;
 import org.xml.sax.helpers.DefaultHandler;
 
+import sun.misc.SharedSecrets;
+
 /**
  * The main class to parse JavaBeans XML archive.
  *
@@ -56,11 +61,10 @@
  * @see ElementHandler
  */
 public final class DocumentHandler extends DefaultHandler {
-    private final Map<String, Class<? extends ElementHandler>> handlers = new HashMap<String, Class<? extends ElementHandler>>();
-
-    private final Map<String, Object> environment = new HashMap<String, Object>();
-
-    private final List<Object> objects = new ArrayList<Object>();
+    private final AccessControlContext acc = AccessController.getContext();
+    private final Map<String, Class<? extends ElementHandler>> handlers = new HashMap<>();
+    private final Map<String, Object> environment = new HashMap<>();
+    private final List<Object> objects = new ArrayList<>();
 
     private Reference<ClassLoader> loader;
     private ExceptionListener listener;
@@ -351,23 +355,32 @@
      *
      * @param input  the input source to parse
      */
-    public void parse(InputSource input) {
-        try {
-            SAXParserFactory.newInstance().newSAXParser().parse(input, this);
+    public void parse(final InputSource input) {
+        if ((this.acc == null) && (null != System.getSecurityManager())) {
+            throw new SecurityException("AccessControlContext is not set");
         }
-        catch (ParserConfigurationException exception) {
-            handleException(exception);
-        }
-        catch (SAXException wrapper) {
-            Exception exception = wrapper.getException();
-            if (exception == null) {
-                exception = wrapper;
+        AccessControlContext stack = AccessController.getContext();
+        SharedSecrets.getJavaSecurityAccess().doIntersectionPrivilege(new PrivilegedAction<Void>() {
+            public Void run() {
+                try {
+                    SAXParserFactory.newInstance().newSAXParser().parse(input, DocumentHandler.this);
+                }
+                catch (ParserConfigurationException exception) {
+                    handleException(exception);
+                }
+                catch (SAXException wrapper) {
+                    Exception exception = wrapper.getException();
+                    if (exception == null) {
+                        exception = wrapper;
+                    }
+                    handleException(exception);
+                }
+                catch (IOException exception) {
+                    handleException(exception);
+                }
+                return null;
             }
-            handleException(exception);
-        }
-        catch (IOException exception) {
-            handleException(exception);
-        }
+        }, stack, this.acc);
     }
 
     /**
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/com/sun/beans/decoder/MethodElementHandler.java
--- jdk/src/share/classes/com/sun/beans/decoder/MethodElementHandler.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/com/sun/beans/decoder/MethodElementHandler.java	Sun Sep 23 23:43:31 2012 +0400
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -28,6 +28,8 @@
 
 import java.lang.reflect.Method;
 
+import sun.reflect.misc.MethodUtil;
+
 /**
  * This class is intended to handle &lt;method&gt; element.
  * It describes invocation of the method.
@@ -101,7 +103,7 @@
         if (method.isVarArgs()) {
             args = getArguments(args, method.getParameterTypes());
         }
-        Object value = method.invoke(bean, args);
+        Object value = MethodUtil.invoke(method, bean, args);
         return method.getReturnType().equals(void.class)
                 ? ValueObjectImpl.VOID
                 : ValueObjectImpl.create(value);
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/com/sun/beans/decoder/PropertyElementHandler.java
--- jdk/src/share/classes/com/sun/beans/decoder/PropertyElementHandler.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/com/sun/beans/decoder/PropertyElementHandler.java	Sun Sep 23 23:43:31 2012 +0400
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -35,6 +35,8 @@
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 
+import sun.reflect.misc.MethodUtil;
+
 /**
  * This class is intended to handle &lt;property&gt; element.
  * This element simplifies access to the properties.
@@ -168,11 +170,11 @@
     private static Object getPropertyValue(Object bean, String name, Integer index) throws IllegalAccessException, IntrospectionException, InvocationTargetException, NoSuchMethodException {
         Class<?> type = bean.getClass();
         if (index == null) {
-            return findGetter(type, name).invoke(bean);
+            return MethodUtil.invoke(findGetter(type, name), bean, new Object[] {});
         } else if (type.isArray() && (name == null)) {
             return Array.get(bean, index);
         } else {
-            return findGetter(type, name, int.class).invoke(bean, index);
+            return MethodUtil.invoke(findGetter(type, name, int.class), bean, new Object[] {index});
         }
     }
 
@@ -197,11 +199,11 @@
                 : null;
 
         if (index == null) {
-            findSetter(type, name, param).invoke(bean, value);
+            MethodUtil.invoke(findSetter(type, name, param), bean, new Object[] {value});
         } else if (type.isArray() && (name == null)) {
             Array.set(bean, index, value);
         } else {
-            findSetter(type, name, int.class, param).invoke(bean, index, value);
+            MethodUtil.invoke(findSetter(type, name, int.class, param), bean, new Object[] {index, value});
         }
     }
 
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/com/sun/beans/editors/BooleanEditor.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ jdk/src/share/classes/com/sun/beans/editors/BooleanEditor.java	Sun Sep 23 23:43:31 2012 +0400
@@ -0,0 +1,76 @@
+/*
+ * Copyright (c) 2006, 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.sun.beans.editors;
+
+/**
+ * Property editor for a java builtin "boolean" type.
+ */
+
+import java.beans.*;
+
+public class BooleanEditor extends PropertyEditorSupport {
+
+
+    public String getJavaInitializationString() {
+        Object value = getValue();
+        return (value != null)
+                ? value.toString()
+                : "null";
+    }
+
+    public String getAsText() {
+        Object value = getValue();
+        return (value instanceof Boolean)
+             ? getValidName((Boolean) value)
+             : null;
+    }
+
+    public void setAsText(String text) throws java.lang.IllegalArgumentException {
+        if (text == null) {
+            setValue(null);
+        } else if (isValidName(true, text)) {
+            setValue(Boolean.TRUE);
+        } else if (isValidName(false, text)) {
+            setValue(Boolean.FALSE);
+        } else {
+            throw new java.lang.IllegalArgumentException(text);
+        }
+    }
+
+    public String[] getTags() {
+        return new String[] {getValidName(true), getValidName(false)};
+    }
+
+    // the following method should be localized (4890258)
+
+    private String getValidName(boolean value) {
+        return value ? "True" : "False";
+    }
+
+    private boolean isValidName(boolean value, String name) {
+        return getValidName(value).equalsIgnoreCase(name);
+    }
+}
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/com/sun/beans/editors/ByteEditor.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ jdk/src/share/classes/com/sun/beans/editors/ByteEditor.java	Sun Sep 23 23:43:31 2012 +0400
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 1996, 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.sun.beans.editors;
+
+/**
+ * Property editor for a java builtin "byte" type.
+ *
+ */
+
+import java.beans.*;
+
+public class ByteEditor extends NumberEditor {
+
+    public String getJavaInitializationString() {
+        Object value = getValue();
+        return (value != null)
+                ? "((byte)" + value + ")"
+                : "null";
+    }
+
+    public void setAsText(String text) throws IllegalArgumentException {
+        setValue((text == null) ? null : Byte.decode(text));
+    }
+
+}
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/com/sun/beans/editors/ColorEditor.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ jdk/src/share/classes/com/sun/beans/editors/ColorEditor.java	Sun Sep 23 23:43:31 2012 +0400
@@ -0,0 +1,214 @@
+/*
+ * Copyright (c) 1996, 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.sun.beans.editors;
+
+import java.awt.*;
+import java.beans.*;
+
+public class ColorEditor extends Panel implements PropertyEditor {
+    private static final long serialVersionUID = 1781257185164716054L;
+
+    public ColorEditor() {
+        setLayout(null);
+
+        ourWidth = hPad;
+
+        // Create a sample color block bordered in black
+        Panel p = new Panel();
+        p.setLayout(null);
+        p.setBackground(Color.black);
+        sample = new Canvas();
+        p.add(sample);
+        sample.reshape(2, 2, sampleWidth, sampleHeight);
+        add(p);
+        p.reshape(ourWidth, 2, sampleWidth+4, sampleHeight+4);
+        ourWidth += sampleWidth + 4 + hPad;
+
+        text = new TextField("", 14);
+        add(text);
+        text.reshape(ourWidth,0,100,30);
+        ourWidth += 100 + hPad;
+
+        choser = new Choice();
+        int active = 0;
+        for (int i = 0; i < colorNames.length; i++) {
+            choser.addItem(colorNames[i]);
+        }
+        add(choser);
+        choser.reshape(ourWidth,0,100,30);
+        ourWidth += 100 + hPad;
+
+        resize(ourWidth,40);
+    }
+
+    public void setValue(Object o) {
+        Color c = (Color)o;
+        changeColor(c);
+    }
+
+    public Dimension preferredSize() {
+        return new Dimension(ourWidth, 40);
+    }
+
+    public boolean keyUp(Event e, int key) {
+        if (e.target == text) {
+            try {
+                setAsText(text.getText());
+            } catch (IllegalArgumentException ex) {
+                // Quietly ignore.
+            }
+        }
+        return (false);
+    }
+
+    public void setAsText(String s) throws java.lang.IllegalArgumentException {
+        if (s == null) {
+            changeColor(null);
+            return;
+        }
+        int c1 = s.indexOf(',');
+        int c2 = s.indexOf(',', c1+1);
+        if (c1 < 0 || c2 < 0) {
+            // Invalid string.
+            throw new IllegalArgumentException(s);
+        }
+        try {
+            int r = Integer.parseInt(s.substring(0,c1));
+            int g = Integer.parseInt(s.substring(c1+1, c2));
+            int b = Integer.parseInt(s.substring(c2+1));
+            Color c = new Color(r,g,b);
+            changeColor(c);
+        } catch (Exception ex) {
+            throw new IllegalArgumentException(s);
+        }
+
+    }
+
+    public boolean action(Event e, Object arg) {
+        if (e.target == choser) {
+            changeColor(colors[choser.getSelectedIndex()]);
+        }
+        return false;
+    }
+
+    public String getJavaInitializationString() {
+        return (this.color != null)
+                ? "new java.awt.Color(" + this.color.getRGB() + ",true)"
+                : "null";
+    }
+
+
+    private void changeColor(Color c) {
+
+        if (c == null) {
+            this.color = null;
+            this.text.setText("");
+            return;
+        }
+
+        color = c;
+
+        text.setText("" + c.getRed() + "," + c.getGreen() + "," + c.getBlue());
+
+        int active = 0;
+        for (int i = 0; i < colorNames.length; i++) {
+            if (color.equals(colors[i])) {
+                active = i;
+            }
+        }
+        choser.select(active);
+
+        sample.setBackground(color);
+        sample.repaint();
+
+        support.firePropertyChange("", null, null);
+    }
+
+    public Object getValue() {
+        return color;
+    }
+
+    public boolean isPaintable() {
+        return true;
+    }
+
+    public void paintValue(java.awt.Graphics gfx, java.awt.Rectangle box) {
+        Color oldColor = gfx.getColor();
+        gfx.setColor(Color.black);
+        gfx.drawRect(box.x, box.y, box.width-3, box.height-3);
+        gfx.setColor(color);
+        gfx.fillRect(box.x+1, box.y+1, box.width-4, box.height-4);
+        gfx.setColor(oldColor);
+    }
+
+    public String getAsText() {
+        return (this.color != null)
+                ? this.color.getRed() + "," + this.color.getGreen() + "," + this.color.getBlue()
+                : null;
+    }
+
+    public String[] getTags() {
+        return null;
+    }
+
+    public java.awt.Component getCustomEditor() {
+        return this;
+    }
+
+    public boolean supportsCustomEditor() {
+        return true;
+    }
+
+    public void addPropertyChangeListener(PropertyChangeListener l) {
+        support.addPropertyChangeListener(l);
+    }
+
+    public void removePropertyChangeListener(PropertyChangeListener l) {
+        support.removePropertyChangeListener(l);
+    }
+
+
+    private String colorNames[] = { " ", "white", "lightGray", "gray", "darkGray",
+                        "black", "red", "pink", "orange",
+                        "yellow", "green", "magenta", "cyan",
+                        "blue"};
+    private Color colors[] = { null, Color.white, Color.lightGray, Color.gray, Color.darkGray,
+                        Color.black, Color.red, Color.pink, Color.orange,
+                        Color.yellow, Color.green, Color.magenta, Color.cyan,
+                        Color.blue};
+
+    private Canvas sample;
+    private int sampleHeight = 20;
+    private int sampleWidth = 40;
+    private int hPad = 5;
+    private int ourWidth;
+
+    private Color color;
+    private TextField text;
+    private Choice choser;
+
+    private PropertyChangeSupport support = new PropertyChangeSupport(this);
+}
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/com/sun/beans/editors/DoubleEditor.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ jdk/src/share/classes/com/sun/beans/editors/DoubleEditor.java	Sun Sep 23 23:43:31 2012 +0400
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 1996, 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.sun.beans.editors;
+
+/**
+ * Property editor for a java builtin "double" type.
+ *
+ */
+
+import java.beans.*;
+
+public class DoubleEditor extends NumberEditor {
+
+    public void setAsText(String text) throws IllegalArgumentException {
+        setValue((text == null) ? null : Double.valueOf(text));
+    }
+
+}
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/com/sun/beans/editors/EnumEditor.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ jdk/src/share/classes/com/sun/beans/editors/EnumEditor.java	Sun Sep 23 23:43:31 2012 +0400
@@ -0,0 +1,143 @@
+/*
+ * Copyright (c) 2006, 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package com.sun.beans.editors;
+
+import java.awt.Component;
+import java.awt.Graphics;
+import java.awt.Rectangle;
+import java.beans.PropertyChangeEvent;
+import java.beans.PropertyChangeListener;
+import java.beans.PropertyEditor;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Property editor for java.lang.Enum subclasses.
+ *
+ * @see PropertyEditor
+ *
+ * @since 1.7
+ *
+ * @author Sergey A. Malenkov
+ */
+public class EnumEditor implements PropertyEditor {
+    private final List<PropertyChangeListener> listeners = new ArrayList<PropertyChangeListener>();
+
+    private final Class type;
+    private final String[] tags;
+
+    private Object value;
+
+    public EnumEditor( Class type ) {
+        Object[] values = type.getEnumConstants();
+        if ( values == null ) {
+            throw new IllegalArgumentException( "Unsupported " + type );
+        }
+        this.type = type;
+        this.tags = new String[values.length];
+        for ( int i = 0; i < values.length; i++ ) {
+            this.tags[i] = ( ( Enum )values[i] ).name();
+        }
+    }
+
+    public Object getValue() {
+        return this.value;
+    }
+
+    public void setValue( Object value ) {
+        if ( ( value != null ) && !this.type.isInstance( value ) ) {
+            throw new IllegalArgumentException( "Unsupported value: " + value );
+        }
+        Object oldValue;
+        PropertyChangeListener[] listeners;
+        synchronized ( this.listeners ) {
+            oldValue = this.value;
+            this.value = value;
+
+            if ( ( value == null ) ? oldValue == null : value.equals( oldValue ) ) {
+                return; // do not fire event if value is not changed
+            }
+            int size = this.listeners.size();
+            if ( size == 0 ) {
+                return; // do not fire event if there are no any listener
+            }
+            listeners = this.listeners.toArray( new PropertyChangeListener[size] );
+        }
+        PropertyChangeEvent event = new PropertyChangeEvent( this, null, oldValue, value );
+        for ( PropertyChangeListener listener : listeners ) {
+            listener.propertyChange( event );
+        }
+    }
+
+    public String getAsText() {
+        return ( this.value != null )
+                ? ( ( Enum )this.value ).name()
+                : null;
+    }
+
+    public void setAsText( String text ) {
+        setValue( ( text != null )
+                ? Enum.valueOf( this.type, text )
+                : null );
+    }
+
+    public String[] getTags() {
+        return this.tags.clone();
+    }
+
+    public String getJavaInitializationString() {
+        String name = getAsText();
+        return ( name != null )
+                ? this.type.getName() + '.' + name
+                : "null";
+    }
+
+    public boolean isPaintable() {
+        return false;
+    }
+
+    public void paintValue( Graphics gfx, Rectangle box ) {
+    }
+
+    public boolean supportsCustomEditor() {
+        return false;
+    }
+
+    public Component getCustomEditor() {
+        return null;
+    }
+
+    public void addPropertyChangeListener( PropertyChangeListener listener ) {
+        synchronized ( this.listeners ) {
+            this.listeners.add( listener );
+        }
+    }
+
+    public void removePropertyChangeListener( PropertyChangeListener listener ) {
+        synchronized ( this.listeners ) {
+            this.listeners.remove( listener );
+        }
+    }
+}
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/com/sun/beans/editors/FloatEditor.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ jdk/src/share/classes/com/sun/beans/editors/FloatEditor.java	Sun Sep 23 23:43:31 2012 +0400
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 1996, 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.sun.beans.editors;
+
+/**
+ * Property editor for a java builtin "float" type.
+ *
+ */
+
+import java.beans.*;
+
+public class FloatEditor extends NumberEditor {
+
+    public String getJavaInitializationString() {
+        Object value = getValue();
+        return (value != null)
+                ? value + "F"
+                : "null";
+    }
+
+    public void setAsText(String text) throws IllegalArgumentException {
+        setValue((text == null) ? null : Float.valueOf(text));
+    }
+
+}
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/com/sun/beans/editors/FontEditor.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ jdk/src/share/classes/com/sun/beans/editors/FontEditor.java	Sun Sep 23 23:43:31 2012 +0400
@@ -0,0 +1,219 @@
+/*
+ * Copyright (c) 1996, 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.sun.beans.editors;
+
+import java.awt.*;
+import java.beans.*;
+
+public class FontEditor extends Panel implements java.beans.PropertyEditor {
+    private static final long serialVersionUID = 6732704486002715933L;
+
+    public FontEditor() {
+        setLayout(null);
+
+        toolkit = Toolkit.getDefaultToolkit();
+        fonts = toolkit.getFontList();
+
+        familyChoser = new Choice();
+        for (int i = 0; i < fonts.length; i++) {
+            familyChoser.addItem(fonts[i]);
+        }
+        add(familyChoser);
+        familyChoser.reshape(20, 5, 100, 30);
+
+        styleChoser = new Choice();
+        for (int i = 0; i < styleNames.length; i++) {
+            styleChoser.addItem(styleNames[i]);
+        }
+        add(styleChoser);
+        styleChoser.reshape(145, 5, 70, 30);
+
+        sizeChoser = new Choice();
+        for (int i = 0; i < pointSizes.length; i++) {
+            sizeChoser.addItem("" + pointSizes[i]);
+        }
+        add(sizeChoser);
+        sizeChoser.reshape(220, 5, 70, 30);
+
+        resize(300,40);
+    }
+
+
+    public Dimension preferredSize() {
+        return new Dimension(300, 40);
+    }
+
+    public void setValue(Object o) {
+        font = (Font) o;
+        if (this.font == null)
+            return;
+
+        changeFont(font);
+        // Update the current GUI choices.
+        for (int i = 0; i < fonts.length; i++) {
+            if (fonts[i].equals(font.getFamily())) {
+                familyChoser.select(i);
+                break;
+            }
+        }
+        for (int i = 0; i < styleNames.length; i++) {
+            if (font.getStyle() == styles[i]) {
+                styleChoser.select(i);
+                break;
+            }
+        }
+        for (int i = 0; i < pointSizes.length; i++) {
+            if (font.getSize() <= pointSizes[i]) {
+                sizeChoser.select(i);
+                break;
+            }
+        }
+    }
+
+    private void changeFont(Font f) {
+        font = f;
+        if (sample != null) {
+            remove(sample);
+        }
+        sample = new Label(sampleText);
+        sample.setFont(font);
+        add(sample);
+        Component p = getParent();
+        if (p != null) {
+            p.invalidate();
+            p.layout();
+        }
+        invalidate();
+        layout();
+        repaint();
+        support.firePropertyChange("", null, null);
+    }
+
+    public Object getValue() {
+        return (font);
+    }
+
+    public String getJavaInitializationString() {
+        if (this.font == null)
+            return "null";
+
+        return "new java.awt.Font(\"" + font.getName() + "\", " +
+                   font.getStyle() + ", " + font.getSize() + ")";
+    }
+
+    public boolean action(Event e, Object arg) {
+        String family = familyChoser.getSelectedItem();
+        int style = styles[styleChoser.getSelectedIndex()];
+        int size = pointSizes[sizeChoser.getSelectedIndex()];
+        try {
+            Font f = new Font(family, style, size);
+            changeFont(f);
+        } catch (Exception ex) {
+            System.err.println("Couldn't create font " + family + "-" +
+                        styleNames[style] + "-" + size);
+        }
+        return (false);
+    }
+
+
+    public boolean isPaintable() {
+        return true;
+    }
+
+    public void paintValue(java.awt.Graphics gfx, java.awt.Rectangle box) {
+        // Silent noop.
+        Font oldFont = gfx.getFont();
+        gfx.setFont(font);
+        FontMetrics fm = gfx.getFontMetrics();
+        int vpad = (box.height - fm.getAscent())/2;
+        gfx.drawString(sampleText, 0, box.height-vpad);
+        gfx.setFont(oldFont);
+    }
+
+    public String getAsText() {
+        if (this.font == null) {
+            return null;
+        }
+        StringBuilder sb = new StringBuilder();
+        sb.append(this.font.getName());
+        sb.append(' ');
+
+        boolean b = this.font.isBold();
+        if (b) {
+            sb.append("BOLD");
+        }
+        boolean i = this.font.isItalic();
+        if (i) {
+            sb.append("ITALIC");
+        }
+        if (b || i) {
+            sb.append(' ');
+        }
+        sb.append(this.font.getSize());
+        return sb.toString();
+    }
+
+    public void setAsText(String text) throws IllegalArgumentException {
+        setValue((text == null) ? null : Font.decode(text));
+    }
+
+    public String[] getTags() {
+        return null;
+    }
+
+    public java.awt.Component getCustomEditor() {
+        return this;
+    }
+
+    public boolean supportsCustomEditor() {
+        return true;
+    }
+
+    public void addPropertyChangeListener(PropertyChangeListener l) {
+        support.addPropertyChangeListener(l);
+    }
+
+    public void removePropertyChangeListener(PropertyChangeListener l) {
+        support.removePropertyChangeListener(l);
+    }
+
+    private Font font;
+    private Toolkit toolkit;
+    private String sampleText = "Abcde...";
+
+    private Label sample;
+    private Choice familyChoser;
+    private Choice styleChoser;
+    private Choice sizeChoser;
+
+    private String fonts[];
+    private String[] styleNames = { "plain", "bold", "italic" };
+    private int[] styles = { Font.PLAIN, Font.BOLD, Font.ITALIC };
+    private int[] pointSizes = { 3, 5, 8, 10, 12, 14, 18, 24, 36, 48 };
+
+    private PropertyChangeSupport support = new PropertyChangeSupport(this);
+
+}
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/com/sun/beans/editors/IntegerEditor.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ jdk/src/share/classes/com/sun/beans/editors/IntegerEditor.java	Sun Sep 23 23:43:31 2012 +0400
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) 2006, 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.sun.beans.editors;
+
+/**
+ * Property editor for a java builtin "int" type.
+ *
+ */
+
+import java.beans.*;
+
+public class IntegerEditor extends NumberEditor {
+
+
+    public void setAsText(String text) throws IllegalArgumentException {
+        setValue((text == null) ? null : Integer.decode(text));
+    }
+
+}
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/com/sun/beans/editors/LongEditor.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ jdk/src/share/classes/com/sun/beans/editors/LongEditor.java	Sun Sep 23 23:43:31 2012 +0400
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 1996, 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.sun.beans.editors;
+
+/**
+ * Property editor for a java builtin "long" type.
+ *
+ */
+
+import java.beans.*;
+
+public class LongEditor extends NumberEditor {
+
+    public String getJavaInitializationString() {
+        Object value = getValue();
+        return (value != null)
+                ? value + "L"
+                : "null";
+    }
+
+    public void setAsText(String text) throws IllegalArgumentException {
+        setValue((text == null) ? null : Long.decode(text));
+    }
+
+}
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/com/sun/beans/editors/NumberEditor.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ jdk/src/share/classes/com/sun/beans/editors/NumberEditor.java	Sun Sep 23 23:43:31 2012 +0400
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 1996, 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.sun.beans.editors;
+
+/**
+ * Abstract Property editor for a java builtin number types.
+ *
+ */
+
+import java.beans.*;
+
+abstract public class NumberEditor extends PropertyEditorSupport {
+
+    public String getJavaInitializationString() {
+        Object value = getValue();
+        return (value != null)
+                ? value.toString()
+                : "null";
+    }
+
+}
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/com/sun/beans/editors/ShortEditor.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ jdk/src/share/classes/com/sun/beans/editors/ShortEditor.java	Sun Sep 23 23:43:31 2012 +0400
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 1996, 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+
+package com.sun.beans.editors;
+
+/**
+ * Property editor for a java builtin "short" type.
+ *
+ */
+
+import java.beans.*;
+
+public class ShortEditor extends NumberEditor {
+
+    public String getJavaInitializationString() {
+        Object value = getValue();
+        return (value != null)
+                ? "((short)" + value + ")"
+                : "null";
+    }
+
+    public void setAsText(String text) throws IllegalArgumentException {
+        setValue((text == null) ? null : Short.decode(text));
+    }
+
+}
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/com/sun/beans/editors/StringEditor.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ jdk/src/share/classes/com/sun/beans/editors/StringEditor.java	Sun Sep 23 23:43:31 2012 +0400
@@ -0,0 +1,74 @@
+/*
+ * Copyright (c) 1996, 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+
+package com.sun.beans.editors;
+
+import java.beans.*;
+
+public class StringEditor extends PropertyEditorSupport {
+
+    public String getJavaInitializationString() {
+        Object value = getValue();
+        if (value == null)
+            return "null";
+
+        String str = value.toString();
+        int length = str.length();
+        StringBuilder sb = new StringBuilder(length + 2);
+        sb.append('"');
+        for (int i = 0; i < length; i++) {
+            char ch = str.charAt(i);
+            switch (ch) {
+            case '\b': sb.append("\\b");  break;
+            case '\t': sb.append("\\t");  break;
+            case '\n': sb.append("\\n");  break;
+            case '\f': sb.append("\\f");  break;
+            case '\r': sb.append("\\r");  break;
+            case '\"': sb.append("\\\""); break;
+            case '\\': sb.append("\\\\"); break;
+            default:
+                if ((ch < ' ') || (ch > '~')) {
+                    sb.append("\\u");
+                    String hex = Integer.toHexString((int) ch);
+                    for (int len = hex.length(); len < 4; len++) {
+                        sb.append('0');
+                    }
+                    sb.append(hex);
+                } else {
+                    sb.append(ch);
+                }
+                break;
+            }
+        }
+        sb.append('"');
+        return sb.toString();
+    }
+
+    public void setAsText(String text) {
+        setValue(text);
+    }
+
+}
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/com/sun/beans/finder/BeanInfoFinder.java
--- jdk/src/share/classes/com/sun/beans/finder/BeanInfoFinder.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/com/sun/beans/finder/BeanInfoFinder.java	Sun Sep 23 23:43:31 2012 +0400
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2009, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2009, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -42,6 +42,7 @@
         extends InstanceFinder<BeanInfo> {
 
     private static final String DEFAULT = "sun.beans.infos";
+    private static final String DEFAULT_NEW = "com.sun.beans.infos";
 
     public BeanInfoFinder() {
         super(BeanInfo.class, true, "BeanInfo", DEFAULT);
@@ -53,10 +54,13 @@
 
     @Override
     protected BeanInfo instantiate(Class<?> type, String prefix, String name) {
+        if (DEFAULT.equals(prefix)) {
+            prefix = DEFAULT_NEW;
+        }
         // this optimization will only use the BeanInfo search path
         // if is has changed from the original
         // or trying to get the ComponentBeanInfo
-        BeanInfo info = !DEFAULT.equals(prefix) || "ComponentBeanInfo".equals(name)
+        BeanInfo info = !DEFAULT_NEW.equals(prefix) || "ComponentBeanInfo".equals(name)
                 ? super.instantiate(type, prefix, name)
                 : null;
 
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/com/sun/beans/finder/ClassFinder.java
--- jdk/src/share/classes/com/sun/beans/finder/ClassFinder.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/com/sun/beans/finder/ClassFinder.java	Sun Sep 23 23:43:31 2012 +0400
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2006, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -24,6 +24,8 @@
  */
 package com.sun.beans.finder;
 
+import static sun.reflect.misc.ReflectUtil.checkPackageAccess;
+
 /**
  * This is utility class that provides {@code static} methods
  * to find a class with the specified name using the specified class loader.
@@ -54,6 +56,7 @@
      * @see Thread#getContextClassLoader()
      */
     public static Class<?> findClass(String name) throws ClassNotFoundException {
+        checkPackageAccess(name);
         try {
             ClassLoader loader = Thread.currentThread().getContextClassLoader();
             if (loader == null) {
@@ -94,6 +97,7 @@
      * @see Class#forName(String,boolean,ClassLoader)
      */
     public static Class<?> findClass(String name, ClassLoader loader) throws ClassNotFoundException {
+        checkPackageAccess(name);
         if (loader != null) {
             try {
                 return Class.forName(name, false, loader);
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/com/sun/beans/finder/ConstructorFinder.java
--- jdk/src/share/classes/com/sun/beans/finder/ConstructorFinder.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/com/sun/beans/finder/ConstructorFinder.java	Sun Sep 23 23:43:31 2012 +0400
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -29,6 +29,8 @@
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Modifier;
 
+import static sun.reflect.misc.ReflectUtil.isPackageAccessible;
+
 /**
  * This utility class provides {@code static} methods
  * to find a public constructor with specified parameter types
@@ -61,7 +63,7 @@
         if (Modifier.isAbstract(type.getModifiers())) {
             throw new NoSuchMethodException("Abstract class cannot be instantiated");
         }
-        if (!Modifier.isPublic(type.getModifiers())) {
+        if (!Modifier.isPublic(type.getModifiers()) || !isPackageAccessible(type)) {
             throw new NoSuchMethodException("Class is not accessible");
         }
         PrimitiveWrapperMap.replacePrimitivesWithWrappers(args);
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/com/sun/beans/finder/FieldFinder.java
--- jdk/src/share/classes/com/sun/beans/finder/FieldFinder.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/com/sun/beans/finder/FieldFinder.java	Sun Sep 23 23:43:31 2012 +0400
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,6 +27,8 @@
 import java.lang.reflect.Field;
 import java.lang.reflect.Modifier;
 
+import static sun.reflect.misc.ReflectUtil.isPackageAccessible;
+
 /**
  * This utility class provides {@code static} methods
  * to find a public field with specified name
@@ -56,7 +58,8 @@
         if (!Modifier.isPublic(field.getModifiers())) {
             throw new NoSuchFieldException("Field '" + name + "' is not public");
         }
-        if (!Modifier.isPublic(field.getDeclaringClass().getModifiers())) {
+        type = field.getDeclaringClass();
+        if (!Modifier.isPublic(type.getModifiers()) || !isPackageAccessible(type)) {
             throw new NoSuchFieldException("Field '" + name + "' is not accessible");
         }
         return field;
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/com/sun/beans/finder/MethodFinder.java
--- jdk/src/share/classes/com/sun/beans/finder/MethodFinder.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/com/sun/beans/finder/MethodFinder.java	Sun Sep 23 23:43:31 2012 +0400
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -33,6 +33,8 @@
 import java.lang.reflect.Type;
 import java.util.Arrays;
 
+import static sun.reflect.misc.ReflectUtil.isPackageAccessible;
+
 /**
  * This utility class provides {@code static} methods
  * to find a public method with specified name and parameter types
@@ -120,7 +122,7 @@
      */
     public static Method findAccessibleMethod(Method method) throws NoSuchMethodException {
         Class<?> type = method.getDeclaringClass();
-        if (Modifier.isPublic(type.getModifiers())) {
+        if (Modifier.isPublic(type.getModifiers()) && isPackageAccessible(type)) {
             return method;
         }
         if (Modifier.isStatic(method.getModifiers())) {
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/com/sun/beans/finder/PropertyEditorFinder.java
--- jdk/src/share/classes/com/sun/beans/finder/PropertyEditorFinder.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/com/sun/beans/finder/PropertyEditorFinder.java	Sun Sep 23 23:43:31 2012 +0400
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2009, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2009, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -28,14 +28,14 @@
 
 import java.beans.PropertyEditor;
 
-import sun.beans.editors.BooleanEditor;
-import sun.beans.editors.ByteEditor;
-import sun.beans.editors.DoubleEditor;
-import sun.beans.editors.EnumEditor;
-import sun.beans.editors.FloatEditor;
-import sun.beans.editors.IntegerEditor;
-import sun.beans.editors.LongEditor;
-import sun.beans.editors.ShortEditor;
+import com.sun.beans.editors.BooleanEditor;
+import com.sun.beans.editors.ByteEditor;
+import com.sun.beans.editors.DoubleEditor;
+import com.sun.beans.editors.EnumEditor;
+import com.sun.beans.editors.FloatEditor;
+import com.sun.beans.editors.IntegerEditor;
+import com.sun.beans.editors.LongEditor;
+import com.sun.beans.editors.ShortEditor;
 
 /**
  * This is utility class that provides functionality
@@ -48,10 +48,13 @@
 public final class PropertyEditorFinder
         extends InstanceFinder<PropertyEditor> {
 
+    private static final String DEFAULT = "sun.beans.editors";
+    private static final String DEFAULT_NEW = "com.sun.beans.editors";
+
     private final WeakCache<Class<?>, Class<?>> registry;
 
     public PropertyEditorFinder() {
-        super(PropertyEditor.class, false, "Editor", "sun.beans.editors");
+        super(PropertyEditor.class, false, "Editor", DEFAULT);
 
         this.registry = new WeakCache<Class<?>, Class<?>>();
         this.registry.put(Byte.TYPE, ByteEditor.class);
@@ -84,4 +87,9 @@
         }
         return editor;
     }
+
+    @Override
+    protected PropertyEditor instantiate(Class<?> type, String prefix, String name) {
+        return super.instantiate(type, DEFAULT.equals(prefix) ? DEFAULT_NEW : prefix, name);
+    }
 }
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/com/sun/beans/infos/ComponentBeanInfo.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ jdk/src/share/classes/com/sun/beans/infos/ComponentBeanInfo.java	Sun Sep 23 23:43:31 2012 +0400
@@ -0,0 +1,62 @@
+/*
+ * Copyright (c) 1996, 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.sun.beans.infos;
+
+import java.beans.*;
+
+/**
+ * BeanInfo descriptor for a standard AWT component.
+ */
+
+public class ComponentBeanInfo extends SimpleBeanInfo {
+    private static final Class beanClass = java.awt.Component.class;
+
+    public PropertyDescriptor[] getPropertyDescriptors() {
+        try {
+            PropertyDescriptor
+                      name = new PropertyDescriptor("name",       beanClass),
+                background = new PropertyDescriptor("background", beanClass),
+                foreground = new PropertyDescriptor("foreground", beanClass),
+                      font = new PropertyDescriptor("font",       beanClass),
+                   enabled = new PropertyDescriptor("enabled",    beanClass),
+                   visible = new PropertyDescriptor("visible",    beanClass),
+                 focusable = new PropertyDescriptor("focusable",  beanClass);
+
+            enabled.setExpert(true);
+            visible.setHidden(true);
+
+            background.setBound(true);
+            foreground.setBound(true);
+            font.setBound(true);
+            focusable.setBound(true);
+
+            PropertyDescriptor[] rv = {name, background, foreground, font, enabled, visible, focusable };
+            return rv;
+        } catch (IntrospectionException e) {
+            throw new Error(e.toString());
+        }
+    }
+}
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/com/sun/jmx/remote/internal/ServerNotifForwarder.java
--- jdk/src/share/classes/com/sun/jmx/remote/internal/ServerNotifForwarder.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/com/sun/jmx/remote/internal/ServerNotifForwarder.java	Sun Sep 23 23:43:31 2012 +0400
@@ -68,9 +68,9 @@
         this.notifBuffer = notifBuffer;
         this.connectionId = connectionId;
         connectionTimeout = EnvHelp.getServerConnectionTimeout(env);
-        checkNotificationEmission = EnvHelp.computeBooleanFromString(
-            env,
-            "jmx.remote.x.check.notification.emission",false);
+
+        String stringBoolean = (String) env.get("jmx.remote.x.check.notification.emission");
+        checkNotificationEmission = EnvHelp.computeBooleanFromString( stringBoolean );
         notificationAccessController =
                 EnvHelp.getNotificationAccessController(env);
     }
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/com/sun/jmx/remote/util/EnvHelp.java
--- jdk/src/share/classes/com/sun/jmx/remote/util/EnvHelp.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/com/sun/jmx/remote/util/EnvHelp.java	Sun Sep 23 23:43:31 2012 +0400
@@ -665,97 +665,57 @@
      * Computes a boolean value from a string value retrieved from a
      * property in the given map.
      *
-     * @param env the environment map.
-     * @param prop the name of the property in the environment map whose
-     * returned string value must be converted into a boolean value.
-     * @param systemProperty if true, consult a system property of the
-     * same name if there is no entry in the environment map.
+     * @param stringBoolean the string value that must be converted
+     * into a boolean value.
      *
      * @return
      *   <ul>
-     *   <li>{@code false} if {@code env.get(prop)} is {@code null}</li>
+     *   <li>{@code false} if {@code stringBoolean} is {@code null}</li>
      *   <li>{@code false} if
-     *       {@code ((String)env.get(prop)).equalsIgnoreCase("false")}
+     *       {@code stringBoolean.equalsIgnoreCase("false")}
      *       is {@code true}</li>
      *   <li>{@code true} if
-     *       {@code ((String)env.get(prop)).equalsIgnoreCase("true")}
+     *       {@code stringBoolean.equalsIgnoreCase("true")}
      *       is {@code true}</li>
      *   </ul>
      *
-     * @throws IllegalArgumentException if {@code env} is {@code null} or
-     * {@code env.get(prop)} is not {@code null} and
+     * @throws IllegalArgumentException if
      * {@code ((String)env.get(prop)).equalsIgnoreCase("false")} and
      * {@code ((String)env.get(prop)).equalsIgnoreCase("true")} are
      * {@code false}.
-     * @throws ClassCastException if {@code env.get(prop)} cannot be cast
-     * to {@code String}.
      */
-    public static boolean computeBooleanFromString(
-            Map<String, ?> env, String prop, boolean systemProperty) {
-
-        if (env == null)
-            throw new IllegalArgumentException("env map cannot be null");
-
+    public static boolean computeBooleanFromString(String stringBoolean) {
         // returns a default value of 'false' if no property is found...
-        return computeBooleanFromString(env,prop,systemProperty,false);
+        return computeBooleanFromString(stringBoolean,false);
     }
 
     /**
      * Computes a boolean value from a string value retrieved from a
      * property in the given map.
      *
-     * @param env the environment map.
-     * @param prop the name of the property in the environment map whose
-     * returned string value must be converted into a boolean value.
-     * @param systemProperty if true, consult a system property of the
-     * same name if there is no entry in the environment map.
+     * @param stringBoolean the string value that must be converted
+     * into a boolean value.
      * @param defaultValue a default value to return in case no property
      *        was defined.
      *
      * @return
      *   <ul>
-     *   <li>{@code defaultValue} if {@code env.get(prop)} is {@code null}
-     *       and {@code systemProperty} is {@code false}</li>
-     *   <li>{@code defaultValue} if {@code env.get(prop)} is {@code null}
-     *       and {@code systemProperty} is {@code true} and
-     *       {@code System.getProperty(prop)} is {@code null}</li>
-     *   <li>{@code false} if {@code env.get(prop)} is {@code null}
-     *       and {@code systemProperty} is {@code true} and
-     *       {@code System.getProperty(prop).equalsIgnoreCase("false")}
-     *       is {@code true}</li>
-     *   <li>{@code true} if {@code env.get(prop)} is {@code null}
-     *       and {@code systemProperty} is {@code true} and
-     *       {@code System.getProperty(prop).equalsIgnoreCase("true")}
-     *       is {@code true}</li>
+     *   <li>{@code defaultValue} if {@code stringBoolean}
+     *   is {@code null}</li>
      *   <li>{@code false} if
-     *       {@code ((String)env.get(prop)).equalsIgnoreCase("false")}
+     *       {@code stringBoolean.equalsIgnoreCase("false")}
      *       is {@code true}</li>
      *   <li>{@code true} if
-     *       {@code ((String)env.get(prop)).equalsIgnoreCase("true")}
+     *       {@code stringBoolean.equalsIgnoreCase("true")}
      *       is {@code true}</li>
      *   </ul>
      *
-     * @throws IllegalArgumentException if {@code env} is {@code null} or
-     * {@code env.get(prop)} is not {@code null} and
+     * @throws IllegalArgumentException if
      * {@code ((String)env.get(prop)).equalsIgnoreCase("false")} and
      * {@code ((String)env.get(prop)).equalsIgnoreCase("true")} are
      * {@code false}.
-     * @throws ClassCastException if {@code env.get(prop)} cannot be cast
-     * to {@code String}.
      */
-    public static boolean computeBooleanFromString(
-            Map<String, ?> env, String prop,
-            boolean systemProperty, boolean defaultValue) {
-
-        if (env == null)
-            throw new IllegalArgumentException("env map cannot be null");
-
-        String stringBoolean = (String) env.get(prop);
-        if (stringBoolean == null && systemProperty) {
-            stringBoolean =
-                    AccessController.doPrivileged(new GetPropertyAction(prop));
-        }
-
+    public static boolean computeBooleanFromString( String stringBoolean, boolean defaultValue) {
         if (stringBoolean == null)
             return defaultValue;
         else if (stringBoolean.equalsIgnoreCase("true"))
@@ -763,8 +723,8 @@
         else if (stringBoolean.equalsIgnoreCase("false"))
             return false;
         else
-            throw new IllegalArgumentException(prop +
-                " must be \"true\" or \"false\" instead of \"" +
+            throw new IllegalArgumentException(
+                "Property value must be \"true\" or \"false\" instead of \"" +
                 stringBoolean + "\"");
     }
 
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/com/sun/org/apache/xml/internal/security/Init.java
--- jdk/src/share/classes/com/sun/org/apache/xml/internal/security/Init.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/com/sun/org/apache/xml/internal/security/Init.java	Sun Sep 23 23:43:31 2012 +0400
@@ -154,7 +154,7 @@
                 }
             }
                         for (Node el=config.getFirstChild();el!=null;el=el.getNextSibling()) {
-                if (!(el instanceof Element)) {
+                if (el.getNodeType() != Node.ELEMENT_NODE) {
                         continue;
                 }
                 String tag=el.getLocalName();
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/com/sun/org/apache/xml/internal/security/c14n/implementations/CanonicalizerBase.java
--- jdk/src/share/classes/com/sun/org/apache/xml/internal/security/c14n/implementations/CanonicalizerBase.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/com/sun/org/apache/xml/internal/security/c14n/implementations/CanonicalizerBase.java	Sun Sep 23 23:43:31 2012 +0400
@@ -202,7 +202,7 @@
         try {
          NameSpaceSymbTable ns=new NameSpaceSymbTable();
          int nodeLevel=NODE_BEFORE_DOCUMENT_ELEMENT;
-         if (rootNode instanceof Element) {
+         if (rootNode != null && rootNode.getNodeType() == Node.ELEMENT_NODE) {
                 //Fills the nssymbtable with the definitions of the parent of the root subnode
                 getParentNameSpaces((Element)rootNode,ns);
                 nodeLevel=NODE_NOT_BEFORE_OR_AFTER_DOCUMENT_ELEMENT;
@@ -332,7 +332,7 @@
                                 return;
                         sibling=parentNode.getNextSibling();
                         parentNode=parentNode.getParentNode();
-                        if (!(parentNode instanceof Element)) {
+                        if (parentNode !=null && parentNode.getNodeType() != Node.ELEMENT_NODE) {
                                 documentLevel=NODE_AFTER_DOCUMENT_ELEMENT;
                                 parentNode=null;
                         }
@@ -388,7 +388,7 @@
                 return;
         boolean currentNodeIsVisible = false;
         NameSpaceSymbTable ns=new  NameSpaceSymbTable();
-        if (currentNode instanceof Element)
+        if (currentNode != null && currentNode.getNodeType() == Node.ELEMENT_NODE)
                 getParentNameSpaces((Element)currentNode,ns);
         Node sibling=null;
         Node parentNode=null;
@@ -509,7 +509,7 @@
                                 return;
                         sibling=parentNode.getNextSibling();
                         parentNode=parentNode.getParentNode();
-                        if (!(parentNode instanceof Element)) {
+                        if (parentNode != null && parentNode.getNodeType() != Node.ELEMENT_NODE) {
                                 parentNode=null;
                                 documentLevel=NODE_AFTER_DOCUMENT_ELEMENT;
                         }
@@ -591,18 +591,14 @@
         final void getParentNameSpaces(Element el,NameSpaceSymbTable ns)  {
                 List parents=new ArrayList(10);
                 Node n1=el.getParentNode();
-                if (!(n1 instanceof Element)) {
+                if (n1 == null || n1.getNodeType() != Node.ELEMENT_NODE) {
                         return;
                 }
                 //Obtain all the parents of the elemnt
-                Element parent=(Element) n1;
-                while (parent!=null) {
-                        parents.add(parent);
-                        Node n=parent.getParentNode();
-                        if (!(n instanceof Element )) {
-                                break;
-                        }
-                        parent=(Element)n;
+                Node parent = n1;
+                while (parent!=null && parent.getNodeType() == Node.ELEMENT_NODE) {
+                        parents.add((Element)parent);
+                        parent = parent.getParentNode();
                 }
                 //Visit them in reverse order.
                 ListIterator it=parents.listIterator(parents.size());
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/com/sun/org/apache/xml/internal/security/encryption/XMLCipher.java
--- jdk/src/share/classes/com/sun/org/apache/xml/internal/security/encryption/XMLCipher.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/com/sun/org/apache/xml/internal/security/encryption/XMLCipher.java	Sun Sep 23 23:43:31 2012 +0400
@@ -1445,7 +1445,7 @@
                 // The de-serialiser returns a fragment whose children we need to
                 // take on.
 
-                if (sourceParent instanceof Document) {
+                if (sourceParent != null && sourceParent.getNodeType() == Node.DOCUMENT_NODE) {
 
                     // If this is a content decryption, this may have problems
 
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/com/sun/org/apache/xml/internal/security/keys/keyresolver/implementations/RetrievalMethodResolver.java
--- jdk/src/share/classes/com/sun/org/apache/xml/internal/security/keys/keyresolver/implementations/RetrievalMethodResolver.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/com/sun/org/apache/xml/internal/security/keys/keyresolver/implementations/RetrievalMethodResolver.java	Sun Sep 23 23:43:31 2012 +0400
@@ -283,7 +283,7 @@
            Element e=null;
            while (it.hasNext()) {
                    Node currentNode=(Node)it.next();
-                   if (currentNode instanceof Element) {
+                   if (currentNode != null && currentNode.getNodeType() == Node.ELEMENT_NODE) {
                            e=(Element)currentNode;
                            break;
                    }
@@ -292,14 +292,14 @@
            List parents=new ArrayList(10);
 
                 //Obtain all the parents of the elemnt
-                do {
+                while (e != null) {
                         parents.add(e);
                         Node n=e.getParentNode();
-                        if (!(n instanceof Element )) {
+                        if (n == null || n.getNodeType() != Node.ELEMENT_NODE) {
                                 break;
                         }
                         e=(Element)n;
-                } while (e!=null);
+                }
                 //Visit them in reverse order.
                 ListIterator it2=parents.listIterator(parents.size()-1);
                 Element ele=null;
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/com/sun/org/apache/xml/internal/security/utils/IdResolver.java
--- jdk/src/share/classes/com/sun/org/apache/xml/internal/security/utils/IdResolver.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/com/sun/org/apache/xml/internal/security/utils/IdResolver.java	Sun Sep 23 23:43:31 2012 +0400
@@ -223,7 +223,7 @@
         } while (sibling==null  && parentNode!=null) {
                         sibling=parentNode.getNextSibling();
                         parentNode=parentNode.getParentNode();
-                        if (!(parentNode instanceof Element)) {
+                        if (parentNode != null && parentNode.getNodeType() != Node.ELEMENT_NODE) {
                                 parentNode=null;
                         }
                 }
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/com/sun/script/javascript/RhinoScriptEngine.java
--- jdk/src/share/classes/com/sun/script/javascript/RhinoScriptEngine.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/com/sun/script/javascript/RhinoScriptEngine.java	Sun Sep 23 23:43:31 2012 +0400
@@ -146,7 +146,11 @@
      */
     public RhinoScriptEngine() {
         if (System.getSecurityManager() != null) {
-            accCtxt = AccessController.getContext();
+            try {
+                AccessController.checkPermission(new AllPermission());
+            } catch (AccessControlException ace) {
+                accCtxt = AccessController.getContext();
+            }
         }
 
         Context cx = enterContext();
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/java/awt/AWTEvent.java
--- jdk/src/share/classes/java/awt/AWTEvent.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/java/awt/AWTEvent.java	Sun Sep 23 23:43:31 2012 +0400
@@ -35,8 +35,6 @@
 
 import java.security.AccessControlContext;
 import java.security.AccessController;
-import java.io.ObjectInputStream;
-import java.io.IOException;
 
 /**
  * The root event class for all AWT events.
@@ -262,9 +260,11 @@
                 public void setPosted(AWTEvent ev) {
                     ev.isPosted = true;
                 }
+
                 public void setSystemGenerated(AWTEvent ev) {
                     ev.isSystemGenerated = true;
                 }
+
                 public boolean isSystemGenerated(AWTEvent ev) {
                     return ev.isSystemGenerated;
                 }
@@ -272,6 +272,15 @@
                 public AccessControlContext getAccessControlContext(AWTEvent ev) {
                     return ev.getAccessControlContext();
                 }
+
+                public byte[] getBData(AWTEvent ev) {
+                    return ev.bdata;
+                }
+
+                public void setBData(AWTEvent ev, byte[] bdata) {
+                    ev.bdata = bdata;
+                }
+
             });
     }
 
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/java/awt/CheckboxMenuItem.java
--- jdk/src/share/classes/java/awt/CheckboxMenuItem.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/java/awt/CheckboxMenuItem.java	Sun Sep 23 23:43:31 2012 +0400
@@ -31,6 +31,7 @@
 import java.io.ObjectInputStream;
 import java.io.IOException;
 import javax.accessibility.*;
+import sun.awt.AWTAccessor;
 
 
 /**
@@ -68,6 +69,13 @@
         if (!GraphicsEnvironment.isHeadless()) {
             initIDs();
         }
+
+        AWTAccessor.setCheckboxMenuItemAccessor(
+            new AWTAccessor.CheckboxMenuItemAccessor() {
+                public boolean getState(CheckboxMenuItem cmi) {
+                    return cmi.state;
+                }
+            });
     }
 
    /**
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/java/awt/Cursor.java
--- jdk/src/share/classes/java/awt/Cursor.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/java/awt/Cursor.java	Sun Sep 23 23:43:31 2012 +0400
@@ -24,10 +24,6 @@
  */
 package java.awt;
 
-import java.awt.AWTException;
-import java.awt.Point;
-import java.awt.Toolkit;
-
 import java.io.File;
 import java.io.FileInputStream;
 
@@ -39,6 +35,7 @@
 import java.security.AccessController;
 
 import sun.util.logging.PlatformLogger;
+import sun.awt.AWTAccessor;
 
 /**
  * A class to encapsulate the bitmap representation of the mouse cursor.
@@ -199,6 +196,21 @@
         if (!GraphicsEnvironment.isHeadless()) {
             initIDs();
         }
+
+        AWTAccessor.setCursorAccessor(
+            new AWTAccessor.CursorAccessor() {
+                public long getPData(Cursor cursor) {
+                    return cursor.pData;
+                }
+
+                public void setPData(Cursor cursor, long pData) {
+                    cursor.pData = pData;
+                }
+
+                public int getType(Cursor cursor) {
+                    return cursor.type;
+                }
+            });
     }
 
     /**
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/java/awt/DefaultKeyboardFocusManager.java
--- jdk/src/share/classes/java/awt/DefaultKeyboardFocusManager.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/java/awt/DefaultKeyboardFocusManager.java	Sun Sep 23 23:43:31 2012 +0400
@@ -39,6 +39,7 @@
 
 import sun.awt.AppContext;
 import sun.awt.SunToolkit;
+import sun.awt.AWTAccessor;
 import sun.awt.CausedFocusEvent;
 
 /**
@@ -75,6 +76,15 @@
         typeAheadMarkers = new LinkedList();
     private boolean consumeNextKeyTyped;
 
+    static {
+        AWTAccessor.setDefaultKeyboardFocusManagerAccessor(
+            new AWTAccessor.DefaultKeyboardFocusManagerAccessor() {
+                public void consumeNextKeyTyped(DefaultKeyboardFocusManager dkfm, KeyEvent e) {
+                    dkfm.consumeNextKeyTyped(e);
+                }
+            });
+    }
+
     private static class TypeAheadMarker {
         long after;
         Component untilFocused;
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/java/awt/EventQueue.java
--- jdk/src/share/classes/java/awt/EventQueue.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/java/awt/EventQueue.java	Sun Sep 23 23:43:31 2012 +0400
@@ -52,7 +52,6 @@
 import java.util.concurrent.atomic.AtomicInteger;
 
 import java.security.AccessControlContext;
-import java.security.ProtectionDomain;
 
 import sun.misc.SharedSecrets;
 import sun.misc.JavaSecurityAccess;
@@ -188,6 +187,17 @@
                 public boolean isDispatchThreadImpl(EventQueue eventQueue) {
                     return eventQueue.isDispatchThreadImpl();
                 }
+                public void removeSourceEvents(EventQueue eventQueue,
+                                               Object source,
+                                               boolean removeAllEvents) {
+                    eventQueue.removeSourceEvents(source, removeAllEvents);
+                }
+                public boolean noEvents(EventQueue eventQueue) {
+                    return eventQueue.noEvents();
+                }
+                public void wakeup(EventQueue eventQueue, boolean isShutdown) {
+                    eventQueue.wakeup(isShutdown);
+                }
             });
     }
 
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/java/awt/KeyboardFocusManager.java
--- jdk/src/share/classes/java/awt/KeyboardFocusManager.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/java/awt/KeyboardFocusManager.java	Sun Sep 23 23:43:31 2012 +0400
@@ -56,7 +56,6 @@
 import sun.util.logging.PlatformLogger;
 
 import sun.awt.AppContext;
-import sun.awt.HeadlessToolkit;
 import sun.awt.SunToolkit;
 import sun.awt.CausedFocusEvent;
 import sun.awt.KeyboardFocusManagerPeerProvider;
@@ -148,6 +147,9 @@
                 public KeyboardFocusManager getCurrentKeyboardFocusManager(AppContext ctx) {
                     return KeyboardFocusManager.getCurrentKeyboardFocusManager(ctx);
                 }
+                public Container getCurrentFocusCycleRoot() {
+                    return KeyboardFocusManager.currentFocusCycleRoot;
+                }
             }
         );
     }
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/java/awt/Menu.java
--- jdk/src/share/classes/java/awt/Menu.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/java/awt/Menu.java	Sun Sep 23 23:43:31 2012 +0400
@@ -31,6 +31,7 @@
 import java.awt.peer.MenuPeer;
 import java.awt.event.KeyEvent;
 import javax.accessibility.*;
+import sun.awt.AWTAccessor;
 
 /**
  * A <code>Menu</code> object is a pull-down menu component
@@ -62,6 +63,13 @@
         if (!GraphicsEnvironment.isHeadless()) {
             initIDs();
         }
+
+        AWTAccessor.setMenuAccessor(
+            new AWTAccessor.MenuAccessor() {
+                public Vector getItems(Menu menu) {
+                    return menu.items;
+                }
+            });
     }
 
     /**
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/java/awt/MenuBar.java
--- jdk/src/share/classes/java/awt/MenuBar.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/java/awt/MenuBar.java	Sun Sep 23 23:43:31 2012 +0400
@@ -28,6 +28,7 @@
 import java.io.ObjectInputStream;
 import java.util.Vector;
 import java.util.Enumeration;
+import sun.awt.AWTAccessor;
 import java.awt.peer.MenuBarPeer;
 import java.awt.event.KeyEvent;
 import javax.accessibility.*;
@@ -74,6 +75,16 @@
         if (!GraphicsEnvironment.isHeadless()) {
             initIDs();
         }
+        AWTAccessor.setMenuBarAccessor(
+            new AWTAccessor.MenuBarAccessor() {
+                public Menu getHelpMenu(MenuBar menuBar) {
+                    return menuBar.helpMenu;
+                }
+
+                public Vector getMenus(MenuBar menuBar) {
+                    return menuBar.menus;
+                }
+            });
     }
 
     /**
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/java/awt/MenuComponent.java
--- jdk/src/share/classes/java/awt/MenuComponent.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/java/awt/MenuComponent.java	Sun Sep 23 23:43:31 2012 +0400
@@ -29,7 +29,6 @@
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import sun.awt.AppContext;
-import sun.awt.SunToolkit;
 import sun.awt.AWTAccessor;
 import javax.accessibility.*;
 
@@ -143,6 +142,9 @@
                 public MenuContainer getParent(MenuComponent menuComp) {
                     return menuComp.parent;
                 }
+                public Font getFont_NoClientCode(MenuComponent menuComp) {
+                    return menuComp.getFont_NoClientCode();
+                }
             });
     }
 
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/java/awt/MenuItem.java
--- jdk/src/share/classes/java/awt/MenuItem.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/java/awt/MenuItem.java	Sun Sep 23 23:43:31 2012 +0400
@@ -31,7 +31,7 @@
 import java.io.ObjectInputStream;
 import java.io.IOException;
 import javax.accessibility.*;
-
+import sun.awt.AWTAccessor;
 
 /**
  * All items in a menu must belong to the class
@@ -76,6 +76,29 @@
         if (!GraphicsEnvironment.isHeadless()) {
             initIDs();
         }
+
+        AWTAccessor.setMenuItemAccessor(
+            new AWTAccessor.MenuItemAccessor() {
+                public boolean isEnabled(MenuItem item) {
+                    return item.enabled;
+                }
+
+                public String getLabel(MenuItem item) {
+                    return item.label;
+                }
+
+                public MenuShortcut getShortcut(MenuItem item) {
+                    return item.shortcut;
+                }
+
+                public String getActionCommandImpl(MenuItem item) {
+                    return item.getActionCommandImpl();
+                }
+
+                public boolean isItemEnabled(MenuItem item) {
+                    return item.isItemEnabled();
+                }
+            });
     }
 
     /**
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/java/awt/ScrollPaneAdjustable.java
--- jdk/src/share/classes/java/awt/ScrollPaneAdjustable.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/java/awt/ScrollPaneAdjustable.java	Sun Sep 23 23:43:31 2012 +0400
@@ -24,6 +24,8 @@
  */
 package java.awt;
 
+import sun.awt.AWTAccessor;
+
 import java.awt.event.AdjustmentEvent;
 import java.awt.event.AdjustmentListener;
 import java.awt.peer.ScrollPanePeer;
@@ -156,6 +158,13 @@
         if (!GraphicsEnvironment.isHeadless()) {
             initIDs();
         }
+        AWTAccessor.setScrollPaneAdjustableAccessor(
+                new AWTAccessor.ScrollPaneAdjustableAccessor() {
+            public void setTypedValue(final ScrollPaneAdjustable adj,
+                                      final int v, final int type) {
+                adj.setTypedValue(v, type);
+            }
+        });
     }
 
     /**
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/java/awt/SystemTray.java
--- jdk/src/share/classes/java/awt/SystemTray.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/java/awt/SystemTray.java	Sun Sep 23 23:43:31 2012 +0400
@@ -33,6 +33,7 @@
 import sun.awt.SunToolkit;
 import sun.awt.HeadlessToolkit;
 import sun.security.util.SecurityConstants;
+import sun.awt.AWTAccessor;
 
 /**
  * The <code>SystemTray</code> class represents the system tray for a
@@ -127,6 +128,18 @@
 
     private static final TrayIcon[] EMPTY_TRAY_ARRAY = new TrayIcon[0];
 
+    static {
+        AWTAccessor.setSystemTrayAccessor(
+            new AWTAccessor.SystemTrayAccessor() {
+                public void firePropertyChange(SystemTray tray,
+                                               String propertyName,
+                                               Object oldValue,
+                                               Object newValue) {
+                    tray.firePropertyChange(propertyName, oldValue, newValue);
+                }
+            });
+    }
+
     /**
      * Private <code>SystemTray</code> constructor.
      *
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/java/awt/TrayIcon.java
--- jdk/src/share/classes/java/awt/TrayIcon.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/java/awt/TrayIcon.java	Sun Sep 23 23:43:31 2012 +0400
@@ -25,19 +25,11 @@
 
 package java.awt;
 
-import java.awt.Point;
-import java.awt.Toolkit;
-import java.awt.GraphicsEnvironment;
 import java.awt.event.*;
-import java.awt.AWTEvent;
-import java.awt.AWTEventMulticaster;
-import java.awt.EventQueue;
-import java.awt.PopupMenu;
-import java.awt.Image;
-import java.util.EventListener;
 import java.awt.peer.TrayIconPeer;
 import sun.awt.AppContext;
 import sun.awt.SunToolkit;
+import sun.awt.AWTAccessor;
 import sun.awt.HeadlessToolkit;
 import java.util.EventObject;
 import java.security.AccessControlContext;
@@ -129,6 +121,16 @@
         if (!GraphicsEnvironment.isHeadless()) {
             initIDs();
         }
+
+        AWTAccessor.setTrayIconAccessor(
+            new AWTAccessor.TrayIconAccessor() {
+                public void addNotify(TrayIcon trayIcon) throws AWTException {
+                    trayIcon.addNotify();
+                }
+                public void removeNotify(TrayIcon trayIcon) {
+                    trayIcon.removeNotify();
+                }
+            });
     }
 
     private TrayIcon()
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/java/awt/event/KeyEvent.java
--- jdk/src/share/classes/java/awt/event/KeyEvent.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/java/awt/event/KeyEvent.java	Sun Sep 23 23:43:31 2012 +0400
@@ -25,12 +25,12 @@
 
 package java.awt.event;
 
-import java.awt.Event;
 import java.awt.Component;
 import java.awt.GraphicsEnvironment;
 import java.awt.Toolkit;
 import java.io.IOException;
 import java.io.ObjectInputStream;
+import sun.awt.AWTAccessor;
 
 /**
  * An event which indicates that a keystroke occurred in a component.
@@ -914,6 +914,23 @@
         if (!GraphicsEnvironment.isHeadless()) {
             initIDs();
         }
+
+        AWTAccessor.setKeyEventAccessor(
+            new AWTAccessor.KeyEventAccessor() {
+                public void setRawCode(KeyEvent ev, long rawCode) {
+                    ev.rawCode = rawCode;
+                }
+
+                public void setPrimaryLevelUnicode(KeyEvent ev,
+                                                   long primaryLevelUnicode) {
+                    ev.primaryLevelUnicode = primaryLevelUnicode;
+                }
+
+                public void setExtendedKeyCode(KeyEvent ev,
+                                               long extendedKeyCode) {
+                    ev.extendedKeyCode = extendedKeyCode;
+                }
+            });
     }
 
     /**
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/java/beans/XMLDecoder.java
--- jdk/src/share/classes/java/beans/XMLDecoder.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/java/beans/XMLDecoder.java	Sun Sep 23 23:43:31 2012 +0400
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -29,6 +29,9 @@
 import java.io.Closeable;
 import java.io.InputStream;
 import java.io.IOException;
+import java.security.AccessControlContext;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 
 import org.xml.sax.InputSource;
 import org.xml.sax.helpers.DefaultHandler;
@@ -61,6 +64,7 @@
  * @author Philip Milne
  */
 public class XMLDecoder implements AutoCloseable {
+    private final AccessControlContext acc = AccessController.getContext();
     private final DocumentHandler handler = new DocumentHandler();
     private final InputSource input;
     private Object owner;
@@ -189,7 +193,15 @@
             return false;
         }
         if (this.array == null) {
-            this.handler.parse(this.input);
+            if ((this.acc == null) && (null != System.getSecurityManager())) {
+                throw new SecurityException("AccessControlContext is not set");
+            }
+            AccessController.doPrivileged(new PrivilegedAction<Void>() {
+                public Void run() {
+                    XMLDecoder.this.handler.parse(XMLDecoder.this.input);
+                    return null;
+                }
+            }, this.acc);
             this.array = this.handler.getObjects();
         }
         return true;
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/java/io/FilePermission.java
--- jdk/src/share/classes/java/io/FilePermission.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/java/io/FilePermission.java	Sun Sep 23 23:43:31 2012 +0400
@@ -418,7 +418,7 @@
      */
 
     public int hashCode() {
-        return this.cpath.hashCode();
+        return 0;
     }
 
     /**
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/java/lang/invoke/MethodHandleImpl.java
--- jdk/src/share/classes/java/lang/invoke/MethodHandleImpl.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/java/lang/invoke/MethodHandleImpl.java	Sun Sep 23 23:43:31 2012 +0400
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,7 +25,6 @@
 
 package java.lang.invoke;
 
-import sun.invoke.util.VerifyType;
 import java.security.AccessController;
 import java.security.PrivilegedAction;
 import java.util.ArrayList;
@@ -35,6 +34,7 @@
 import java.util.List;
 import sun.invoke.empty.Empty;
 import sun.invoke.util.ValueConversions;
+import sun.invoke.util.VerifyType;
 import sun.invoke.util.Wrapper;
 import sun.misc.Unsafe;
 import static java.lang.invoke.MethodHandleStatics.*;
@@ -1258,4 +1258,169 @@
         return THROW_EXCEPTION;
     }
     static <T extends Throwable> Empty throwException(T t) throws T { throw t; }
+
+    /**
+     * Create an alias for the method handle which, when called,
+     * appears to be called from the same class loader and protection domain
+     * as hostClass.
+     * This is an expensive no-op unless the method which is called
+     * is sensitive to its caller.  A small number of system methods
+     * are in this category, including Class.forName and Method.invoke.
+     */
+    static
+    MethodHandle bindCaller(MethodHandle mh, Class<?> hostClass) {
+        return BindCaller.bindCaller(mh, hostClass);
+    }
+
+    // Put the whole mess into its own nested class.
+    // That way we can lazily load the code and set up the constants.
+    private static class BindCaller {
+        static
+        MethodHandle bindCaller(MethodHandle mh, Class<?> hostClass) {
+            // Do not use this function to inject calls into system classes.
+            if (hostClass == null) {
+                hostClass = C_Trampoline;
+            } else if (hostClass.isArray() ||
+                       hostClass.isPrimitive() ||
+                       hostClass.getName().startsWith("java.") ||
+                       hostClass.getName().startsWith("sun.")) {
+                throw new InternalError();  // does not happen, and should not anyway
+            }
+            // For simplicity, convert mh to a varargs-like method.
+            MethodHandle vamh = prepareForInvoker(mh);
+            // Cache the result of makeInjectedInvoker once per argument class.
+            MethodHandle bccInvoker = CV_makeInjectedInvoker.get(hostClass);
+            return restoreToType(bccInvoker.bindTo(vamh), mh.type());
+        }
+
+        // This class ("Trampoline") is known to be inside a dead-end class loader.
+        // Inject all doubtful calls into this class.
+        private static Class<?> C_Trampoline;
+        static {
+            Class<?> tramp = null;
+            try {
+                final int FRAME_COUNT_ARG = 1;  // [0] Reflection [1] Trampoline
+                java.lang.reflect.Method gcc = sun.reflect.Reflection.class.getMethod("getCallerClass", int.class);
+                tramp = (Class<?>) sun.reflect.misc.MethodUtil.invoke(gcc, null, new Object[]{ FRAME_COUNT_ARG });
+                if (tramp.getClassLoader() == BindCaller.class.getClassLoader())
+                    throw new RuntimeException(tramp.getName()+" class loader");
+            } catch (Throwable ex) {
+                throw new InternalError(ex.toString());
+            }
+            C_Trampoline = tramp;
+        }
+
+        private static final Unsafe UNSAFE = Unsafe.getUnsafe();
+
+        private static MethodHandle makeInjectedInvoker(Class<?> hostClass) {
+            Class<?> bcc = UNSAFE.defineAnonymousClass(hostClass, T_BYTES, null);
+            if (hostClass.getClassLoader() != bcc.getClassLoader())
+                throw new InternalError(hostClass.getName()+" (CL)");
+            try {
+                if (hostClass.getProtectionDomain() != bcc.getProtectionDomain())
+                    throw new InternalError(hostClass.getName()+" (PD)");
+            } catch (SecurityException ex) {
+                // Self-check was blocked by security manager.  This is OK.
+                // In fact the whole try body could be turned into an assertion.
+            }
+            try {
+                MethodHandle init = IMPL_LOOKUP.findStatic(bcc, "init", MethodType.methodType(void.class));
+                init.invokeExact();  // force initialization of the class
+            } catch (Throwable ex) {
+                throw uncaughtException(ex);
+            }
+            MethodHandle bccInvoker;
+            try {
+                MethodType invokerMT = MethodType.methodType(Object.class, MethodHandle.class, Object[].class);
+                bccInvoker = IMPL_LOOKUP.findStatic(bcc, "invoke_V", invokerMT);
+            } catch (ReflectiveOperationException ex) {
+                throw uncaughtException(ex);
+            }
+            // Test the invoker, to ensure that it really injects into the right place.
+            try {
+                MethodHandle vamh = prepareForInvoker(MH_checkCallerClass);
+                Object ok = bccInvoker.invokeExact(vamh, new Object[]{hostClass, bcc});
+            } catch (Throwable ex) {
+                throw new InternalError(ex.toString());
+            }
+            return bccInvoker;
+        }
+        private static ClassValue<MethodHandle> CV_makeInjectedInvoker = new ClassValue<MethodHandle>() {
+            @Override protected MethodHandle computeValue(Class<?> hostClass) {
+                return makeInjectedInvoker(hostClass);
+            }
+        };
+
+        // Adapt mh so that it can be called directly from an injected invoker:
+        private static MethodHandle prepareForInvoker(MethodHandle mh) {
+            mh = mh.asFixedArity();
+            MethodType mt = mh.type();
+            int arity = mt.parameterCount();
+            MethodHandle vamh = mh.asType(mt.generic());
+            vamh = vamh.asSpreader(Object[].class, arity);
+            return vamh;
+        }
+
+        // Undo the adapter effect of prepareForInvoker:
+        private static MethodHandle restoreToType(MethodHandle vamh, MethodType type) {
+            return vamh.asCollector(Object[].class, type.parameterCount()).asType(type);
+        }
+
+        private static final MethodHandle MH_checkCallerClass;
+        static {
+            final Class<?> THIS_CLASS = BindCaller.class;
+            assert(checkCallerClass(THIS_CLASS, THIS_CLASS));
+            try {
+                MH_checkCallerClass = IMPL_LOOKUP
+                    .findStatic(THIS_CLASS, "checkCallerClass",
+                                MethodType.methodType(boolean.class, Class.class, Class.class));
+                assert((boolean) MH_checkCallerClass.invokeExact(THIS_CLASS, THIS_CLASS));
+            } catch (Throwable ex) {
+                throw new InternalError(ex.toString());
+            }
+        }
+
+        private static boolean checkCallerClass(Class<?> expected, Class<?> expected2) {
+            final int FRAME_COUNT_ARG = 2;  // [0] Reflection [1] BindCaller [2] Expected
+            Class<?> actual = sun.reflect.Reflection.getCallerClass(FRAME_COUNT_ARG);
+            if (actual != expected && actual != expected2)
+                throw new InternalError("found "+actual.getName()+", expected "+expected.getName()
+                                        +(expected == expected2 ? "" : ", or else "+expected2.getName()));
+            return true;
+        }
+
+        private static final byte[] T_BYTES;
+        static {
+            final Object[] values = {null};
+            AccessController.doPrivileged(new PrivilegedAction<Void>() {
+                    public Void run() {
+                        try {
+                            Class<T> tClass = T.class;
+                            String tName = tClass.getName();
+                            String tResource = tName.substring(tName.lastIndexOf('.')+1)+".class";
+                            java.net.URLConnection uconn = tClass.getResource(tResource).openConnection();
+                            int len = uconn.getContentLength();
+                            byte[] bytes = new byte[len];
+                            try (java.io.InputStream str = uconn.getInputStream()) {
+                                int nr = str.read(bytes);
+                                if (nr != len)  throw new java.io.IOException(tResource);
+                            }
+                            values[0] = bytes;
+                        } catch (java.io.IOException ex) {
+                            throw new InternalError(ex.toString());
+                        }
+                        return null;
+                    }
+                });
+            T_BYTES = (byte[]) values[0];
+        }
+
+        // The following class is used as a template for Unsafe.defineAnonymousClass:
+        private static class T {
+            static void init() { }  // side effect: initializes this class
+            static Object invoke_V(MethodHandle vamh, Object[] args) throws Throwable {
+                return vamh.invokeExact(args);
+            }
+        }
+    }
 }
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/java/lang/invoke/MethodHandleNatives.java
--- jdk/src/share/classes/java/lang/invoke/MethodHandleNatives.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/java/lang/invoke/MethodHandleNatives.java	Sun Sep 23 23:43:31 2012 +0400
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -401,4 +401,101 @@
         assert(!HAVE_RICOCHET_FRAMES) : "this code should not be executed if `-XX:+UseRicochetFrames is enabled";
         return true;
     }
+
+    /**
+     * Is this method a caller-sensitive method?
+     * I.e., does it call Reflection.getCallerClass or a similer method
+     * to ask about the identity of its caller?
+     */
+    // FIXME: Replace this pattern match by an annotation @sun.reflect.CallerSensitive.
+    static boolean isCallerSensitive(MemberName mem) {
+        assert(mem.isInvocable());
+        Class<?> defc = mem.getDeclaringClass();
+        switch (mem.getName()) {
+        case "doPrivileged":
+            return defc == java.security.AccessController.class;
+        case "getUnsafe":
+            return defc == sun.misc.Unsafe.class;
+        case "lookup":
+            return defc == java.lang.invoke.MethodHandles.class;
+        case "invoke":
+            return defc == java.lang.reflect.Method.class;
+        case "get":
+        case "getBoolean":
+        case "getByte":
+        case "getChar":
+        case "getShort":
+        case "getInt":
+        case "getLong":
+        case "getFloat":
+        case "getDouble":
+        case "set":
+        case "setBoolean":
+        case "setByte":
+        case "setChar":
+        case "setShort":
+        case "setInt":
+        case "setLong":
+        case "setFloat":
+        case "setDouble":
+            return defc == java.lang.reflect.Field.class;
+        case "newInstance":
+            if (defc == java.lang.reflect.Constructor.class)  return true;
+            if (defc == java.lang.Class.class)  return true;
+            break;
+        case "forName":
+        case "getClassLoader":
+        case "getClasses":
+        case "getFields":
+        case "getMethods":
+        case "getConstructors":
+        case "getDeclaredClasses":
+        case "getDeclaredFields":
+        case "getDeclaredMethods":
+        case "getDeclaredConstructors":
+        case "getField":
+        case "getMethod":
+        case "getConstructor":
+        case "getDeclaredField":
+        case "getDeclaredMethod":
+        case "getDeclaredConstructor":
+            return defc == java.lang.Class.class;
+        case "getConnection":
+        case "getDriver":
+        case "getDrivers":
+        case "deregisterDriver":
+            return defc == java.sql.DriverManager.class;
+        case "newUpdater":
+            if (defc == java.util.concurrent.atomic.AtomicIntegerFieldUpdater.class)  return true;
+            if (defc == java.util.concurrent.atomic.AtomicLongFieldUpdater.class)  return true;
+            if (defc == java.util.concurrent.atomic.AtomicReferenceFieldUpdater.class)  return true;
+            break;
+        case "getContextClassLoader":
+            return defc == java.lang.Thread.class;
+        case "getPackage":
+        case "getPackages":
+            return defc == java.lang.Package.class;
+        case "getParent":
+        case "getSystemClassLoader":
+            return defc == java.lang.ClassLoader.class;
+        case "load":
+        case "loadLibrary":
+            if (defc == java.lang.Runtime.class)  return true;
+            if (defc == java.lang.System.class)  return true;
+            break;
+        case "getCallerClass":
+            if (defc == sun.reflect.Reflection.class)  return true;
+            if (defc == java.lang.System.class)  return true;
+            break;
+        case "getCallerClassLoader":
+            return defc == java.lang.ClassLoader.class;
+        case "getProxyClass":
+        case "newProxyInstance":
+            return defc == java.lang.reflect.Proxy.class;
+        case "getBundle":
+        case "clearCache":
+            return defc == java.util.ResourceBundle.class;
+        }
+        return false;
+    }
 }
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/java/lang/invoke/MethodHandleStatics.java
--- jdk/src/share/classes/java/lang/invoke/MethodHandleStatics.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/java/lang/invoke/MethodHandleStatics.java	Sun Sep 23 23:43:31 2012 +0400
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -107,7 +107,7 @@
     /*non-public*/ static RuntimeException newIllegalArgumentException(String message, Object obj, Object obj2) {
         return new IllegalArgumentException(message(message, obj, obj2));
     }
-    /*non-public*/ static Error uncaughtException(Exception ex) {
+    /*non-public*/ static Error uncaughtException(Throwable ex) {
         Error err = new InternalError("uncaught exception");
         err.initCause(ex);
         return err;
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/java/lang/invoke/MethodHandles.java
--- jdk/src/share/classes/java/lang/invoke/MethodHandles.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/java/lang/invoke/MethodHandles.java	Sun Sep 23 23:43:31 2012 +0400
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -589,7 +589,9 @@
         private
         MethodHandle accessStatic(Class<?> refc, MemberName method) throws IllegalAccessException {
             checkMethod(refc, method, true);
-            return MethodHandleImpl.findMethod(method, false, lookupClassOrNull());
+            MethodHandle mh = MethodHandleImpl.findMethod(method, false, lookupClassOrNull());
+            mh = maybeBindCaller(method, mh);
+            return mh;
         }
         private
         MethodHandle resolveStatic(Class<?> refc, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {
@@ -647,6 +649,7 @@
         private MethodHandle accessVirtual(Class<?> refc, MemberName method) throws IllegalAccessException {
             checkMethod(refc, method, false);
             MethodHandle mh = MethodHandleImpl.findMethod(method, true, lookupClassOrNull());
+            mh = maybeBindCaller(method, mh);
             return restrictProtectedReceiver(method, mh);
         }
 
@@ -687,6 +690,7 @@
             checkAccess(refc, ctor);
             MethodHandle rawMH = MethodHandleImpl.findMethod(ctor, false, lookupClassOrNull());
             MethodHandle allocMH = MethodHandleImpl.makeAllocator(rawMH);
+            assert(!MethodHandleNatives.isCallerSensitive(ctor));  // maybeBindCaller not relevant here
             return fixVarargs(allocMH, rawMH);
         }
         private MethodHandle resolveConstructor(Class<?> refc, MethodType type) throws NoSuchMethodException, IllegalAccessException {
@@ -755,6 +759,7 @@
                                            Class<?> specialCaller) throws NoSuchMethodException, IllegalAccessException {
             checkMethod(refc, method, false);
             MethodHandle mh = MethodHandleImpl.findMethod(method, false, specialCaller);
+            mh = maybeBindCaller(method, mh);
             return restrictReceiver(method, mh, specialCaller);
         }
         private MethodHandle resolveSpecial(Class<?> refc, String name, MethodType type) throws NoSuchMethodException, IllegalAccessException {
@@ -922,6 +927,8 @@
             checkSecurityManager(refc, method);  // stack walk magic: do not refactor
             checkMethod(refc, method, false);
             MethodHandle dmh = MethodHandleImpl.findMethod(method, true, lookupClassOrNull());
+            MethodHandle bcmh = maybeBindCaller(method, dmh);
+            if (bcmh != dmh)  return fixVarargs(bcmh.bindTo(receiver), dmh);
             MethodHandle bmh = MethodHandleImpl.bindReceiver(dmh, receiver);
             if (bmh == null)
                 throw method.makeAccessException("no access", this);
@@ -956,6 +963,7 @@
                 return MethodHandleImpl.findMethod(method, true, /*no lookupClass*/ null);
             checkMethod(method.getDeclaringClass(), method, method.isStatic());
             MethodHandle mh = MethodHandleImpl.findMethod(method, true, lookupClassOrNull());
+            mh = maybeBindCaller(method, mh);
             return restrictProtectedReceiver(method, mh);
         }
 
@@ -987,6 +995,7 @@
             // ignore m.isAccessible:  this is a new kind of access
             checkMethod(m.getDeclaringClass(), method, false);
             MethodHandle mh = MethodHandleImpl.findMethod(method, false, lookupClassOrNull());
+            mh = maybeBindCaller(method, mh);
             return restrictReceiver(method, mh, specialCaller);
         }
 
@@ -1021,6 +1030,7 @@
                 checkAccess(c.getDeclaringClass(), ctor);
                 rawCtor = MethodHandleImpl.findMethod(ctor, false, lookupClassOrNull());
             }
+            assert(!MethodHandleNatives.isCallerSensitive(ctor));  // maybeBindCaller not relevant here
             MethodHandle allocator = MethodHandleImpl.makeAllocator(rawCtor);
             return fixVarargs(allocator, rawCtor);
         }
@@ -1232,6 +1242,16 @@
             MethodHandle narrowMH = MethodHandleImpl.convertArguments(mh, narrowType, rawType, 0);
             return fixVarargs(narrowMH, mh);
         }
+        private MethodHandle maybeBindCaller(MemberName method, MethodHandle mh) throws IllegalAccessException {
+            if (allowedModes == TRUSTED || !MethodHandleNatives.isCallerSensitive(method))
+                return mh;
+            Class<?> hostClass = lookupClass;
+            if ((allowedModes & PRIVATE) == 0)  // caller must use full-power lookup
+                hostClass = null;
+            MethodHandle cbmh = MethodHandleImpl.bindCaller(mh, hostClass);
+            cbmh = fixVarargs(cbmh, mh);  // in JDK 7 version, varargs happens earlier and must be repaired
+            return cbmh;
+        }
 
         MethodHandle makeAccessor(Class<?> refc, MemberName field,
                                   boolean trusted, boolean isSetter,
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/java/net/URL.java
--- jdk/src/share/classes/java/net/URL.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/java/net/URL.java	Sun Sep 23 23:43:31 2012 +0400
@@ -28,6 +28,8 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 import java.util.Hashtable;
 import java.util.StringTokenizer;
 import sun.security.util.SecurityConstants;
@@ -1116,6 +1118,22 @@
     static Hashtable handlers = new Hashtable();
     private static Object streamHandlerLock = new Object();
 
+    // special case the gopher protocol, disabled by default
+    private static final String GOPHER = "gopher";
+    private static final String ENABLE_GOPHER_PROP = "jdk.net.registerGopherProtocol";
+    private static final boolean enableGopher = AccessController.doPrivileged(
+                new PrivilegedAction<Boolean>() {
+                    @Override
+                    public Boolean run() {
+                        String prop = System.getProperty(ENABLE_GOPHER_PROP);
+                        return prop == null ? false :
+                                   (prop.equalsIgnoreCase("false") ? false : true);
+                    }
+                });
+
+    // package name of the JDK implementation protocol handlers
+    private static final String JDK_PACKAGE_PREFIX =  "sun.net.www.protocol";
+
     /**
      * Returns the Stream Handler.
      * @param protocol the protocol to use
@@ -1147,7 +1165,7 @@
 
                 // REMIND: decide whether to allow the "null" class prefix
                 // or not.
-                packagePrefixList += "sun.net.www.protocol";
+                packagePrefixList += JDK_PACKAGE_PREFIX;
 
                 StringTokenizer packagePrefixIter =
                     new StringTokenizer(packagePrefixList, "|");
@@ -1157,6 +1175,14 @@
 
                     String packagePrefix =
                       packagePrefixIter.nextToken().trim();
+
+                    // do not try to instantiate the JDK gopher handler
+                    // unless the system property had been explicitly set
+                    if (protocol.equalsIgnoreCase(GOPHER) &&
+                        packagePrefix.equals(JDK_PACKAGE_PREFIX) &&
+                        !enableGopher) {
+                            continue;
+                    }
                     try {
                         String clsName = packagePrefix + "." + protocol +
                           ".Handler";
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/java/security/AccessController.java
--- jdk/src/share/classes/java/security/AccessController.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/java/security/AccessController.java	Sun Sep 23 23:43:31 2012 +0400
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -290,11 +290,11 @@
      */
     public static <T> T doPrivilegedWithCombiner(PrivilegedAction<T> action) {
 
-        DomainCombiner dc = null;
         AccessControlContext acc = getStackAccessControlContext();
-        if (acc == null || (dc = acc.getAssignedCombiner()) == null) {
+        if (acc == null) {
             return AccessController.doPrivileged(action);
         }
+        DomainCombiner dc = acc.getAssignedCombiner();
         return AccessController.doPrivileged(action, preserveCombiner(dc));
     }
 
@@ -386,11 +386,11 @@
     public static <T> T doPrivilegedWithCombiner
         (PrivilegedExceptionAction<T> action) throws PrivilegedActionException {
 
-        DomainCombiner dc = null;
         AccessControlContext acc = getStackAccessControlContext();
-        if (acc == null || (dc = acc.getAssignedCombiner()) == null) {
+        if (acc == null) {
             return AccessController.doPrivileged(action);
         }
+        DomainCombiner dc = acc.getAssignedCombiner();
         return AccessController.doPrivileged(action, preserveCombiner(dc));
     }
 
@@ -417,7 +417,12 @@
         // perform 'combine' on the caller of doPrivileged,
         // even if the caller is from the bootclasspath
         ProtectionDomain[] pds = new ProtectionDomain[] {callerPd};
-        return new AccessControlContext(combiner.combine(pds, null), combiner);
+        if (combiner == null) {
+            return new AccessControlContext(pds);
+        } else {
+            return new AccessControlContext(combiner.combine(pds, null),
+                                            combiner);
+        }
     }
 
 
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/java/util/ServiceLoader.java
--- jdk/src/share/classes/java/util/ServiceLoader.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/java/util/ServiceLoader.java	Sun Sep 23 23:43:31 2012 +0400
@@ -358,14 +358,21 @@
             }
             String cn = nextName;
             nextName = null;
+            Class<?> c = null;
             try {
-                S p = service.cast(Class.forName(cn, true, loader)
-                                   .newInstance());
-                providers.put(cn, p);
-                return p;
+                c = Class.forName(cn, false, loader);
             } catch (ClassNotFoundException x) {
                 fail(service,
                      "Provider " + cn + " not found");
+            }
+            if (!service.isAssignableFrom(c)) {
+                fail(service,
+                     "Provider " + cn  + " not a subtype");
+            }
+            try {
+                S p = service.cast(c.newInstance());
+                providers.put(cn, p);
+                return p;
             } catch (Throwable x) {
                 fail(service,
                      "Provider " + cn + " could not be instantiated: " + x,
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/java/util/TimeZone.java
--- jdk/src/share/classes/java/util/TimeZone.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/java/util/TimeZone.java	Sun Sep 23 23:43:31 2012 +0400
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -43,7 +43,8 @@
 import java.security.AccessController;
 import java.security.PrivilegedAction;
 import java.util.concurrent.ConcurrentHashMap;
-import sun.awt.AppContext;
+import sun.misc.SharedSecrets;
+import sun.misc.JavaAWTAccess;
 import sun.security.action.GetPropertyAction;
 import sun.util.TimeZoneNameUtility;
 import sun.util.calendar.ZoneInfo;
@@ -161,6 +162,16 @@
     private static final int ONE_HOUR   = 60*ONE_MINUTE;
     private static final int ONE_DAY    = 24*ONE_HOUR;
 
+    /*
+     * Provides access implementation-private methods without using reflection
+     *
+     * Note that javaAWTAccess may be null if sun.awt.AppContext class hasn't
+     * been loaded. If so, it implies that AWTSecurityManager is not our
+     * SecurityManager and we can use a local static variable.
+     * This works around a build time issue.
+     */
+    private static JavaAWTAccess javaAWTAccess;
+
     // Proclaim serialization compatibility with JDK 1.1
     static final long serialVersionUID = 3581463369166924961L;
 
@@ -720,13 +731,19 @@
      * used or if the AppContext doesn't have the default TimeZone.
      */
     private synchronized static TimeZone getDefaultInAppContext() {
-        if (!hasSetInAppContext) {
-            return null;
-        }
-
-        AppContext ac = AppContext.getAppContext();
-        if (ac != null && !ac.isDisposed()) {
-            return (TimeZone) ac.get(TimeZone.class);
+        javaAWTAccess = SharedSecrets.getJavaAWTAccess();
+        if (javaAWTAccess == null) {
+            return mainAppContextDefault;
+        } else {
+            if (!javaAWTAccess.isDisposed()) {
+                TimeZone tz = (TimeZone)
+                    javaAWTAccess.get(TimeZone.class);
+                if (tz == null && javaAWTAccess.isMainAppContext()) {
+                    return mainAppContextDefault;
+                } else {
+                    return tz;
+                }
+            }
         }
         return null;
     }
@@ -738,17 +755,15 @@
      * AppContext otherwise.
      */
     private synchronized static void setDefaultInAppContext(TimeZone tz) {
-        if (!hasSetInAppContext && tz == null) {
-            return;
-        }
-
-        AppContext ac = AppContext.getAppContext();
-        if (ac != null && !ac.isDisposed()) {
-            if (tz != null) {
-                ac.put(TimeZone.class, tz);
-                hasSetInAppContext = true;
-            } else {
-                ac.remove(TimeZone.class);
+        javaAWTAccess = SharedSecrets.getJavaAWTAccess();
+        if (javaAWTAccess == null) {
+            mainAppContextDefault = tz;
+        } else {
+            if (!javaAWTAccess.isDisposed()) {
+                javaAWTAccess.put(TimeZone.class, tz);
+                if (javaAWTAccess.isMainAppContext()) {
+                    mainAppContextDefault = null;
+                }
             }
         }
     }
@@ -804,8 +819,8 @@
     static final String         GMT_ID        = "GMT";
     private static final int    GMT_ID_LENGTH = 3;
 
-    // true if the default TimeZone has been set in any AppContext
-    private static boolean hasSetInAppContext;
+    // a static TimeZone we can reference if no AppContext is in place
+    private static TimeZone mainAppContextDefault;
 
     /**
      * Parses a custom time zone identifier and returns a corresponding zone.
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/java/util/concurrent/Executors.java
--- jdk/src/share/classes/java/util/concurrent/Executors.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/java/util/concurrent/Executors.java	Sun Sep 23 23:43:31 2012 +0400
@@ -530,18 +530,17 @@
                 return AccessController.doPrivileged(
                     new PrivilegedExceptionAction<T>() {
                         public T run() throws Exception {
-                            ClassLoader savedcl = null;
                             Thread t = Thread.currentThread();
-                            try {
-                                ClassLoader cl = t.getContextClassLoader();
-                                if (ccl != cl) {
-                                    t.setContextClassLoader(ccl);
-                                    savedcl = cl;
+                            ClassLoader cl = t.getContextClassLoader();
+                            if (ccl == cl) {
+                                return task.call();
+                            } else {
+                                t.setContextClassLoader(ccl);
+                                try {
+                                    return task.call();
+                                } finally {
+                                    t.setContextClassLoader(cl);
                                 }
-                                return task.call();
-                            } finally {
-                                if (savedcl != null)
-                                    t.setContextClassLoader(savedcl);
                             }
                         }
                     }, acc);
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/java/util/logging/FileHandler.java
--- jdk/src/share/classes/java/util/logging/FileHandler.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/java/util/logging/FileHandler.java	Sun Sep 23 23:43:31 2012 +0400
@@ -220,7 +220,7 @@
      * @exception  NullPointerException if pattern property is an empty String.
      */
     public FileHandler() throws IOException, SecurityException {
-        checkAccess();
+        checkPermission();
         configure();
         openFiles();
     }
@@ -246,7 +246,7 @@
         if (pattern.length() < 1 ) {
             throw new IllegalArgumentException();
         }
-        checkAccess();
+        checkPermission();
         configure();
         this.pattern = pattern;
         this.limit = 0;
@@ -278,7 +278,7 @@
         if (pattern.length() < 1 ) {
             throw new IllegalArgumentException();
         }
-        checkAccess();
+        checkPermission();
         configure();
         this.pattern = pattern;
         this.limit = 0;
@@ -315,7 +315,7 @@
         if (limit < 0 || count < 1 || pattern.length() < 1) {
             throw new IllegalArgumentException();
         }
-        checkAccess();
+        checkPermission();
         configure();
         this.pattern = pattern;
         this.limit = limit;
@@ -354,7 +354,7 @@
         if (limit < 0 || count < 1 || pattern.length() < 1) {
             throw new IllegalArgumentException();
         }
-        checkAccess();
+        checkPermission();
         configure();
         this.pattern = pattern;
         this.limit = limit;
@@ -367,7 +367,7 @@
     // configured instance variables.
     private void openFiles() throws IOException {
         LogManager manager = LogManager.getLogManager();
-        manager.checkAccess();
+        manager.checkPermission();
         if (count < 1) {
            throw new IllegalArgumentException("file count = " + count);
         }
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/java/util/logging/Handler.java
--- jdk/src/share/classes/java/util/logging/Handler.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/java/util/logging/Handler.java	Sun Sep 23 23:43:31 2012 +0400
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000, 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -111,7 +111,7 @@
      *             the caller does not have <tt>LoggingPermission("control")</tt>.
      */
     public void setFormatter(Formatter newFormatter) throws SecurityException {
-        checkAccess();
+        checkPermission();
         // Check for a null pointer:
         newFormatter.getClass();
         formatter = newFormatter;
@@ -140,7 +140,7 @@
      */
     public void setEncoding(String encoding)
                         throws SecurityException, java.io.UnsupportedEncodingException {
-        checkAccess();
+        checkPermission();
         if (encoding != null) {
             try {
                 if(!java.nio.charset.Charset.isSupported(encoding)) {
@@ -175,7 +175,7 @@
      *             the caller does not have <tt>LoggingPermission("control")</tt>.
      */
     public void setFilter(Filter newFilter) throws SecurityException {
-        checkAccess();
+        checkPermission();
         filter = newFilter;
     }
 
@@ -199,7 +199,7 @@
      *             the caller does not have <tt>LoggingPermission("control")</tt>.
      */
     public void setErrorManager(ErrorManager em) {
-        checkAccess();
+        checkPermission();
         if (em == null) {
            throw new NullPointerException();
         }
@@ -213,7 +213,7 @@
      *             the caller does not have <tt>LoggingPermission("control")</tt>.
      */
     public ErrorManager getErrorManager() {
-        checkAccess();
+        checkPermission();
         return errorManager;
     }
 
@@ -253,7 +253,7 @@
         if (newLevel == null) {
             throw new NullPointerException();
         }
-        checkAccess();
+        checkPermission();
         logLevel = newLevel;
     }
 
@@ -296,9 +296,9 @@
     // If "sealed" is true, we check that the caller has
     // appropriate security privileges to update Handler
     // state and if not throw a SecurityException.
-    void checkAccess() throws SecurityException {
+    void checkPermission() throws SecurityException {
         if (sealed) {
-            manager.checkAccess();
+            manager.checkPermission();
         }
     }
 }
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/java/util/logging/LogManager.java
--- jdk/src/share/classes/java/util/logging/LogManager.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/java/util/logging/LogManager.java	Sun Sep 23 23:43:31 2012 +0400
@@ -314,7 +314,7 @@
         if (l == null) {
             throw new NullPointerException();
         }
-        checkAccess();
+        checkPermission();
         changes.addPropertyChangeListener(l);
     }
 
@@ -333,7 +333,7 @@
      *             the caller does not have LoggingPermission("control").
      */
     public void removePropertyChangeListener(PropertyChangeListener l) throws SecurityException {
-        checkAccess();
+        checkPermission();
         changes.removePropertyChangeListener(l);
     }
 
@@ -772,7 +772,7 @@
      * @exception  IOException if there are IO problems reading the configuration.
      */
     public void readConfiguration() throws IOException, SecurityException {
-        checkAccess();
+        checkPermission();
 
         // if a configuration class is specified, load it and use it.
         String cname = System.getProperty("java.util.logging.config.class");
@@ -830,7 +830,7 @@
      */
 
     public void reset() throws SecurityException {
-        checkAccess();
+        checkPermission();
         synchronized (this) {
             props = new Properties();
             // Since we are doing a reset we no longer want to initialize
@@ -915,7 +915,7 @@
      * @exception  IOException if there are problems reading from the stream.
      */
     public void readConfiguration(InputStream ins) throws IOException, SecurityException {
-        checkAccess();
+        checkPermission();
         reset();
 
         // Load the properties
@@ -1077,7 +1077,13 @@
     }
 
 
-    private Permission ourPermission = new LoggingPermission("control", null);
+    private final Permission controlPermission = new LoggingPermission("control", null);
+
+    void checkPermission() {
+        SecurityManager sm = System.getSecurityManager();
+        if (sm != null)
+            sm.checkPermission(controlPermission);
+    }
 
     /**
      * Check that the current context is trusted to modify the logging
@@ -1090,11 +1096,7 @@
      *             the caller does not have LoggingPermission("control").
      */
     public void checkAccess() throws SecurityException {
-        SecurityManager sm = System.getSecurityManager();
-        if (sm == null) {
-            return;
-        }
-        sm.checkPermission(ourPermission);
+        checkPermission();
     }
 
     // Nested class to represent a node in our tree of named loggers.
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/java/util/logging/Logger.java
--- jdk/src/share/classes/java/util/logging/Logger.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/java/util/logging/Logger.java	Sun Sep 23 23:43:31 2012 +0400
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -273,13 +273,13 @@
         this.manager = manager;
     }
 
-    private void checkAccess() throws SecurityException {
+    private void checkPermission() throws SecurityException {
         if (!anonymous) {
             if (manager == null) {
                 // Complete initialization of the global Logger.
                 manager = LogManager.getLogManager();
             }
-            manager.checkAccess();
+            manager.checkPermission();
         }
     }
 
@@ -482,7 +482,7 @@
      *             the caller does not have LoggingPermission("control").
      */
     public void setFilter(Filter newFilter) throws SecurityException {
-        checkAccess();
+        checkPermission();
         filter = newFilter;
     }
 
@@ -1168,7 +1168,7 @@
      *             the caller does not have LoggingPermission("control").
      */
     public void setLevel(Level newLevel) throws SecurityException {
-        checkAccess();
+        checkPermission();
         synchronized (treeLock) {
             levelObject = newLevel;
             updateEffectiveLevel();
@@ -1223,7 +1223,7 @@
     public void addHandler(Handler handler) throws SecurityException {
         // Check for null handler
         handler.getClass();
-        checkAccess();
+        checkPermission();
         handlers.add(handler);
     }
 
@@ -1237,7 +1237,7 @@
      *             the caller does not have LoggingPermission("control").
      */
     public void removeHandler(Handler handler) throws SecurityException {
-        checkAccess();
+        checkPermission();
         if (handler == null) {
             return;
         }
@@ -1265,7 +1265,7 @@
      *             the caller does not have LoggingPermission("control").
      */
     public void setUseParentHandlers(boolean useParentHandlers) {
-        checkAccess();
+        checkPermission();
         this.useParentHandlers = useParentHandlers;
     }
 
@@ -1405,7 +1405,7 @@
         if (parent == null) {
             throw new NullPointerException();
         }
-        manager.checkAccess();
+        manager.checkPermission();
         doSetParent(parent);
     }
 
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/java/util/logging/MemoryHandler.java
--- jdk/src/share/classes/java/util/logging/MemoryHandler.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/java/util/logging/MemoryHandler.java	Sun Sep 23 23:43:31 2012 +0400
@@ -238,7 +238,7 @@
             throw new NullPointerException();
         }
         LogManager manager = LogManager.getLogManager();
-        checkAccess();
+        checkPermission();
         pushLevel = newLevel;
     }
 
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/java/util/logging/StreamHandler.java
--- jdk/src/share/classes/java/util/logging/StreamHandler.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/java/util/logging/StreamHandler.java	Sun Sep 23 23:43:31 2012 +0400
@@ -249,7 +249,7 @@
     }
 
     private synchronized void flushAndClose() throws SecurityException {
-        checkAccess();
+        checkPermission();
         if (writer != null) {
             try {
                 if (!doneHeader) {
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/javax/management/modelmbean/DescriptorSupport.java
--- jdk/src/share/classes/javax/management/modelmbean/DescriptorSupport.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/javax/management/modelmbean/DescriptorSupport.java	Sun Sep 23 23:43:31 2012 +0400
@@ -1245,13 +1245,12 @@
             return s.substring(1, s.length() - 1);
         }
         final String className = s.substring(1, slash);
+
         final Constructor<?> constr;
         try {
+            ReflectUtil.checkPackageAccess(className);
             final ClassLoader contextClassLoader =
                 Thread.currentThread().getContextClassLoader();
-            if (contextClassLoader == null) {
-                ReflectUtil.checkPackageAccess(className);
-            }
             final Class<?> c =
                 Class.forName(className, false, contextClassLoader);
             constr = c.getConstructor(new Class<?>[] {String.class});
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/javax/management/remote/rmi/RMIConnectionImpl.java
--- jdk/src/share/classes/javax/management/remote/rmi/RMIConnectionImpl.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/javax/management/remote/rmi/RMIConnectionImpl.java	Sun Sep 23 23:43:31 2012 +0400
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2002, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2002, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -39,11 +39,17 @@
 import java.rmi.MarshalledObject;
 import java.rmi.UnmarshalException;
 import java.rmi.server.Unreferenced;
+
 import java.security.AccessControlContext;
 import java.security.AccessController;
+import java.security.Permission;
+import java.security.PermissionCollection;
+import java.security.Permissions;
 import java.security.PrivilegedAction;
 import java.security.PrivilegedActionException;
 import java.security.PrivilegedExceptionAction;
+import java.security.ProtectionDomain;
+
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.Map;
@@ -60,6 +66,7 @@
 import javax.management.MBeanException;
 import javax.management.MBeanInfo;
 import javax.management.MBeanRegistrationException;
+import javax.management.MBeanPermission;
 import javax.management.MBeanServer;
 import javax.management.NotCompliantMBeanException;
 import javax.management.NotificationFilter;
@@ -143,6 +150,7 @@
         this.mbeanServer = rmiServer.getMBeanServer();
 
         final ClassLoader dcl = defaultClassLoader;
+
         this.classLoaderWithRepository =
             AccessController.doPrivileged(
                 new PrivilegedAction<ClassLoaderWithRepository>() {
@@ -151,13 +159,40 @@
                                       mbeanServer.getClassLoaderRepository(),
                                       dcl);
                     }
+                },
+
+                withPermissions( new MBeanPermission("*", "getClassLoaderRepository"),
+                                 new RuntimePermission("createClassLoader"))
+            );
+
+
+        this.defaultContextClassLoader =
+            AccessController.doPrivileged(
+                new PrivilegedAction<ClassLoader>() {
+            @Override
+                    public ClassLoader run() {
+                        return new CombinedClassLoader(Thread.currentThread().getContextClassLoader(),
+                                dcl);
+                    }
                 });
+
         serverCommunicatorAdmin = new
           RMIServerCommunicatorAdmin(EnvHelp.getServerConnectionTimeout(env));
 
         this.env = env;
     }
 
+    private static AccessControlContext withPermissions(Permission ... perms){
+        Permissions col = new Permissions();
+
+        for (Permission thePerm : perms ) {
+            col.add(thePerm);
+        }
+
+        final ProtectionDomain pd = new ProtectionDomain(null, col);
+        return new AccessControlContext( new ProtectionDomain[] { pd });
+    }
+
     private synchronized ServerNotifForwarder getServerNotifFwd() {
         // Lazily created when first use. Mainly when
         // addNotificationListener is first called.
@@ -507,7 +542,7 @@
                  "connectionId=" + connectionId
                  +" unwrapping query with defaultClassLoader.");
 
-        queryValue = unwrap(query, defaultClassLoader, QueryExp.class);
+        queryValue = unwrap(query, defaultContextClassLoader, QueryExp.class);
 
         try {
             final Object params[] = new Object[] { name, queryValue };
@@ -542,7 +577,7 @@
                  "connectionId=" + connectionId
                  +" unwrapping query with defaultClassLoader.");
 
-        queryValue = unwrap(query, defaultClassLoader, QueryExp.class);
+        queryValue = unwrap(query, defaultContextClassLoader, QueryExp.class);
 
         try {
             final Object params[] = new Object[] { name, queryValue };
@@ -1330,7 +1365,9 @@
                         public ClassLoader run() throws InstanceNotFoundException {
                             return mbeanServer.getClassLoader(name);
                         }
-                    });
+                    },
+                    withPermissions(new MBeanPermission("*", "getClassLoader"))
+            );
         } catch (PrivilegedActionException pe) {
             throw (InstanceNotFoundException) extractException(pe);
         }
@@ -1345,7 +1382,9 @@
                         public Object run() throws InstanceNotFoundException {
                             return mbeanServer.getClassLoaderFor(name);
                         }
-                    });
+                    },
+                    withPermissions(new MBeanPermission("*", "getClassLoaderFor"))
+            );
         } catch (PrivilegedActionException pe) {
             throw (InstanceNotFoundException) extractException(pe);
         }
@@ -1572,7 +1611,8 @@
             ClassLoader orderCL = AccessController.doPrivileged(
                 new PrivilegedExceptionAction<ClassLoader>() {
                     public ClassLoader run() throws Exception {
-                        return new OrderClassLoaders(cl1, cl2);
+                        return new CombinedClassLoader(Thread.currentThread().getContextClassLoader(),
+                                new OrderClassLoaders(cl1, cl2));
                     }
                 }
             );
@@ -1664,6 +1704,8 @@
 
     private final ClassLoader defaultClassLoader;
 
+    private final ClassLoader defaultContextClassLoader;
+
     private final ClassLoaderWithRepository classLoaderWithRepository;
 
     private boolean terminated = false;
@@ -1746,4 +1788,43 @@
 
     private static final ClassLogger logger =
         new ClassLogger("javax.management.remote.rmi", "RMIConnectionImpl");
+
+    private static final class CombinedClassLoader extends ClassLoader {
+
+        private final static class ClassLoaderWrapper extends ClassLoader {
+            ClassLoaderWrapper(ClassLoader cl) {
+                super(cl);
+            }
+
+            @Override
+            protected Class<?> loadClass(String name, boolean resolve)
+                    throws ClassNotFoundException {
+                return super.loadClass(name, resolve);
+            }
+        };
+
+        final ClassLoaderWrapper defaultCL;
+
+        private CombinedClassLoader(ClassLoader parent, ClassLoader defaultCL) {
+            super(parent);
+            this.defaultCL = new ClassLoaderWrapper(defaultCL);
+        }
+
+        @Override
+        protected Class<?> loadClass(String name, boolean resolve)
+        throws ClassNotFoundException {
+            try {
+                super.loadClass(name, resolve);
+            } catch(Exception e) {
+                for(Throwable t = e; t != null; t = t.getCause()) {
+                    if(t instanceof SecurityException) {
+                        throw t==e?(SecurityException)t:new SecurityException(t.getMessage(), e);
+                    }
+                }
+            }
+            final Class<?> cl = defaultCL.loadClass(name, resolve);
+            return cl;
+        }
+
+    }
 }
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/javax/management/remote/rmi/RMIConnector.java
--- jdk/src/share/classes/javax/management/remote/rmi/RMIConnector.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/javax/management/remote/rmi/RMIConnector.java	Sun Sep 23 23:43:31 2012 +0400
@@ -277,9 +277,9 @@
             // Check for secure RMIServer stub if the corresponding
             // client-side environment property is set to "true".
             //
-            boolean checkStub = EnvHelp.computeBooleanFromString(
-                    usemap,
-                    "jmx.remote.x.check.stub",false);
+            String stringBoolean =  (String) usemap.get("jmx.remote.x.check.stub");
+            boolean checkStub = EnvHelp.computeBooleanFromString(stringBoolean);
+
             if (checkStub) checkStub(stub, rmiServerImplStubClass);
 
             // Connect IIOP Stub if needed.
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/javax/management/remote/rmi/RMIConnectorServer.java
--- jdk/src/share/classes/javax/management/remote/rmi/RMIConnectorServer.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/javax/management/remote/rmi/RMIConnectorServer.java	Sun Sep 23 23:43:31 2012 +0400
@@ -412,9 +412,8 @@
                 if (tracing)
                     logger.trace("start", "Using external directory: " + jndiUrl);
 
-                final boolean rebind = EnvHelp.computeBooleanFromString(
-                    attributes,
-                    JNDI_REBIND_ATTRIBUTE,false);
+                String stringBoolean = (String) attributes.get(JNDI_REBIND_ATTRIBUTE);
+                final boolean rebind = EnvHelp.computeBooleanFromString( stringBoolean );
 
                 if (tracing)
                     logger.trace("start", JNDI_REBIND_ATTRIBUTE + "=" + rebind);
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/javax/swing/ClientPropertyKey.java
--- jdk/src/share/classes/javax/swing/ClientPropertyKey.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/javax/swing/ClientPropertyKey.java	Sun Sep 23 23:43:31 2012 +0400
@@ -25,6 +25,8 @@
 
 package javax.swing;
 
+import sun.awt.AWTAccessor;
+
 /**
  * An enumeration for keys used as client properties within the Swing
  * implementation.
@@ -86,6 +88,15 @@
      */
     private final boolean reportValueNotSerializable;
 
+    static {
+        AWTAccessor.setClientPropertyKeyAccessor(
+            new AWTAccessor.ClientPropertyKeyAccessor() {
+                public Object getJComponent_TRANSFER_HANDLER() {
+                    return JComponent_TRANSFER_HANDLER;
+                }
+            });
+    }
+
     /**
      * Constructs a key with the {@code reportValueNotSerializable} property
      * set to {@code false}.
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/javax/swing/text/DefaultFormatter.java
--- jdk/src/share/classes/javax/swing/text/DefaultFormatter.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/javax/swing/text/DefaultFormatter.java	Sun Sep 23 23:43:31 2012 +0400
@@ -24,6 +24,8 @@
  */
 package javax.swing.text;
 
+import sun.reflect.misc.ConstructorUtil;
+
 import java.io.Serializable;
 import java.lang.reflect.*;
 import java.text.ParseException;
@@ -245,7 +247,7 @@
             Constructor cons;
 
             try {
-                cons = vc.getConstructor(new Class[] { String.class });
+                cons = ConstructorUtil.getConstructor(vc, new Class[]{String.class});
 
             } catch (NoSuchMethodException nsme) {
                 cons = null;
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/sun/awt/AWTAccessor.java
--- jdk/src/share/classes/sun/awt/AWTAccessor.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/sun/awt/AWTAccessor.java	Sun Sep 23 23:43:31 2012 +0400
@@ -27,17 +27,18 @@
 
 import java.awt.*;
 import java.awt.KeyboardFocusManager;
+import java.awt.DefaultKeyboardFocusManager;
 import java.awt.event.InputEvent;
+import java.awt.event.KeyEvent;
 import java.awt.geom.Point2D;
-import java.awt.image.BufferedImage;
 
 import sun.misc.Unsafe;
 import java.awt.peer.ComponentPeer;
 
-import java.security.AccessController;
 import java.security.AccessControlContext;
 
 import java.io.File;
+import java.util.Vector;
 
 /**
  * The AWTAccessor utility class.
@@ -317,7 +318,7 @@
         void setTrayIconWindow(Window w, boolean isTrayIconWindow);
     }
 
-    /*
+    /**
      * An accessor for the AWTEvent class.
      */
     public interface AWTEventAccessor {
@@ -337,12 +338,20 @@
          */
         boolean isSystemGenerated(AWTEvent ev);
 
-
-        /*
+        /**
          * Returns the acc this event was constructed with.
          */
         AccessControlContext getAccessControlContext(AWTEvent ev);
 
+        /**
+         * Returns binary data associated with this event;
+         */
+        byte[] getBData(AWTEvent ev);
+
+        /**
+         * Associates binary data with this event;
+         */
+        void setBData(AWTEvent ev, byte[] bdata);
     }
 
     public interface InputEventAccessor {
@@ -370,11 +379,11 @@
        Rectangle getMaximizedBounds(Frame frame);
     }
 
-    /*
+    /**
      * An interface of accessor for the java.awt.KeyboardFocusManager class.
      */
     public interface KeyboardFocusManagerAccessor {
-        /*
+        /**
          * Indicates whether the native implementation should
          * proceed with a pending focus request for the heavyweight.
          */
@@ -384,7 +393,7 @@
                                            boolean focusedWindowChangeAllowed,
                                            long time,
                                            CausedFocusEvent.Cause cause);
-        /*
+        /**
          * Delivers focus for the lightweight descendant of the heavyweight
          * synchronously.
          */
@@ -393,23 +402,28 @@
                                                       boolean temporary,
                                                       boolean focusedWindowChangeAllowed,
                                                       long time);
-        /*
+        /**
          * Removes the last focus request for the heavyweight from the queue.
          */
         void removeLastFocusRequest(Component heavyweight);
 
-        /*
+        /**
          * Sets the most recent focus owner in the window.
          */
         void setMostRecentFocusOwner(Window window, Component component);
 
-        /*
+        /**
          * Returns current KFM of the specified AppContext.
          */
         KeyboardFocusManager getCurrentKeyboardFocusManager(AppContext ctx);
+
+        /**
+         * Return the current focus cycle root
+         */
+        Container getCurrentFocusCycleRoot();
     }
 
-    /*
+    /**
      * An accessor for the MenuComponent class.
      */
     public interface MenuComponentAccessor {
@@ -427,20 +441,42 @@
          * Returns the menu container of the menu component
          */
         MenuContainer getParent(MenuComponent menuComp);
+
+        /**
+         * Gets the font used for this menu component.
+         */
+        Font getFont_NoClientCode(MenuComponent menuComp);
     }
 
-    /*
+    /**
      * An accessor for the EventQueue class
      */
     public interface EventQueueAccessor {
-        /*
+        /**
          * Gets the event dispatch thread.
          */
         Thread getDispatchThread(EventQueue eventQueue);
-        /*
+
+        /**
          * Checks if the current thread is EDT for the given EQ.
          */
         public boolean isDispatchThreadImpl(EventQueue eventQueue);
+
+        /**
+         * Removes any pending events for the specified source object.
+         */
+        void removeSourceEvents(EventQueue eventQueue, Object source, boolean removeAllEvents);
+
+        /**
+         * Returns whether an event is pending on any of the separate Queues.
+         */
+        boolean noEvents(EventQueue eventQueue);
+
+        /**
+         * Called from PostEventQueue.postEvent to notify that a new event
+         * appeared.
+         */
+        void wakeup(EventQueue eventQueue, boolean isShutdown);
     }
 
     /*
@@ -478,6 +514,159 @@
         boolean isMultipleMode(FileDialog fileDialog);
     }
 
+    /**
+     * An accessor for the ScrollPaneAdjustable class.
+     */
+    public interface ScrollPaneAdjustableAccessor {
+        /**
+         * Sets the value of this scrollbar to the specified value.
+         */
+        void setTypedValue(final ScrollPaneAdjustable adj, final int v,
+                           final int type);
+    }
+
+    /**
+     * An accessor for the CheckboxMenuItem class
+     */
+    public interface CheckboxMenuItemAccessor {
+        /**
+         * Returns whether menu item is checked
+         */
+        boolean getState(CheckboxMenuItem cmi);
+    }
+
+    /**
+     * An accessor for the Cursor class
+     */
+    public interface CursorAccessor {
+        /**
+         * Returns pData of the Cursor class
+         */
+        long getPData(Cursor cursor);
+
+        /**
+         * Sets pData to the Cursor class
+         */
+        void setPData(Cursor cursor, long pData);
+
+        /**
+         * Return type of the Cursor class
+         */
+        int getType(Cursor cursor);
+    }
+
+    /**
+     * An accessor for the MenuBar class
+     */
+    public interface MenuBarAccessor {
+        /**
+         * Returns help menu
+         */
+        Menu getHelpMenu(MenuBar menuBar);
+
+        /**
+         * Returns menus
+         */
+        Vector getMenus(MenuBar menuBar);
+    }
+
+    /**
+     * An accessor for the MenuItem class
+     */
+    public interface MenuItemAccessor {
+        /**
+         * Returns whether menu item is enabled
+         */
+        boolean isEnabled(MenuItem item);
+
+        /**
+         * Gets the command name of the action event that is fired
+         * by this menu item.
+         */
+        String getActionCommandImpl(MenuItem item);
+
+        /**
+         * Returns true if the item and all its ancestors are
+         * enabled, false otherwise
+         */
+        boolean isItemEnabled(MenuItem item);
+
+        /**
+         * Returns label
+         */
+        String getLabel(MenuItem item);
+
+        /**
+         * Returns shortcut
+         */
+        MenuShortcut getShortcut(MenuItem item);
+    }
+
+    /**
+     * An accessor for the Menu class
+     */
+    public interface MenuAccessor {
+        /**
+         * Returns vector of the items that are part of the Menu
+         */
+        Vector getItems(Menu menu);
+    }
+
+    /**
+     * An accessor for the KeyEvent class
+     */
+    public interface KeyEventAccessor {
+        /**
+         * Sets rawCode field for KeyEvent
+         */
+        void setRawCode(KeyEvent ev, long rawCode);
+
+        /**
+         * Sets primaryLevelUnicode field for KeyEvent
+         */
+        void setPrimaryLevelUnicode(KeyEvent ev, long primaryLevelUnicode);
+
+        /**
+         * Sets extendedKeyCode field for KeyEvent
+         */
+        void setExtendedKeyCode(KeyEvent ev, long extendedKeyCode);
+    }
+
+    /**
+     * An accessor for the ClientPropertyKey class
+     */
+    public interface ClientPropertyKeyAccessor {
+        /**
+         * Retrieves JComponent_TRANSFER_HANDLER enum object
+         */
+        Object getJComponent_TRANSFER_HANDLER();
+    }
+
+    /**
+     * An accessor for the SystemTray class
+     */
+    public interface SystemTrayAccessor {
+        /**
+         * Support for reporting bound property changes for Object properties.
+         */
+        void firePropertyChange(SystemTray tray, String propertyName, Object oldValue, Object newValue);
+    }
+
+    /**
+     * An accessor for the TrayIcon class
+     */
+    public interface TrayIconAccessor {
+        void addNotify(TrayIcon trayIcon) throws AWTException;
+        void removeNotify(TrayIcon trayIcon);
+    }
+
+    /**
+     * An accessor for the DefaultKeyboardFocusManager class
+     */
+    public interface DefaultKeyboardFocusManagerAccessor {
+        public void consumeNextKeyTyped(DefaultKeyboardFocusManager dkfm, KeyEvent e);
+    }
+
     /*
      * Accessor instances are initialized in the static initializers of
      * corresponding AWT classes by using setters defined below.
@@ -493,6 +682,17 @@
     private static EventQueueAccessor eventQueueAccessor;
     private static PopupMenuAccessor popupMenuAccessor;
     private static FileDialogAccessor fileDialogAccessor;
+    private static ScrollPaneAdjustableAccessor scrollPaneAdjustableAccessor;
+    private static CheckboxMenuItemAccessor checkboxMenuItemAccessor;
+    private static CursorAccessor cursorAccessor;
+    private static MenuBarAccessor menuBarAccessor;
+    private static MenuItemAccessor menuItemAccessor;
+    private static MenuAccessor menuAccessor;
+    private static KeyEventAccessor keyEventAccessor;
+    private static ClientPropertyKeyAccessor clientPropertyKeyAccessor;
+    private static SystemTrayAccessor systemTrayAccessor;
+    private static TrayIconAccessor trayIconAccessor;
+    private static DefaultKeyboardFocusManagerAccessor defaultKeyboardFocusManagerAccessor;
 
     /*
      * Set an accessor object for the java.awt.Component class.
@@ -683,4 +883,192 @@
         return fileDialogAccessor;
     }
 
+    /**
+     * Set an accessor object for the java.awt.ScrollPaneAdjustable class.
+     */
+    public static void setScrollPaneAdjustableAccessor(ScrollPaneAdjustableAccessor adj) {
+        scrollPaneAdjustableAccessor = adj;
+    }
+
+    /**
+     * Retrieve the accessor object for the java.awt.ScrollPaneAdjustable
+     * class.
+     */
+    public static ScrollPaneAdjustableAccessor getScrollPaneAdjustableAccessor() {
+        if (scrollPaneAdjustableAccessor == null) {
+            unsafe.ensureClassInitialized(ScrollPaneAdjustable.class);
+        }
+        return scrollPaneAdjustableAccessor;
+    }
+
+    /**
+     * Set an accessor object for the java.awt.CheckboxMenuItem class.
+     */
+    public static void setCheckboxMenuItemAccessor(CheckboxMenuItemAccessor cmia) {
+        checkboxMenuItemAccessor = cmia;
+    }
+
+    /**
+     * Retrieve the accessor object for the java.awt.CheckboxMenuItem class.
+     */
+    public static CheckboxMenuItemAccessor getCheckboxMenuItemAccessor() {
+        if (checkboxMenuItemAccessor == null) {
+            unsafe.ensureClassInitialized(CheckboxMenuItemAccessor.class);
+        }
+        return checkboxMenuItemAccessor;
+    }
+
+    /**
+     * Set an accessor object for the java.awt.Cursor class.
+     */
+    public static void setCursorAccessor(CursorAccessor ca) {
+        cursorAccessor = ca;
+    }
+
+    /**
+     * Retrieve the accessor object for the java.awt.Cursor class.
+     */
+    public static CursorAccessor getCursorAccessor() {
+        if (cursorAccessor == null) {
+            unsafe.ensureClassInitialized(CursorAccessor.class);
+        }
+        return cursorAccessor;
+    }
+
+    /**
+     * Set an accessor object for the java.awt.MenuBar class.
+     */
+    public static void setMenuBarAccessor(MenuBarAccessor mba) {
+        menuBarAccessor = mba;
+    }
+
+    /**
+     * Retrieve the accessor object for the java.awt.MenuBar class.
+     */
+    public static MenuBarAccessor getMenuBarAccessor() {
+        if (menuBarAccessor == null) {
+            unsafe.ensureClassInitialized(MenuBarAccessor.class);
+        }
+        return menuBarAccessor;
+    }
+
+    /**
+     * Set an accessor object for the java.awt.MenuItem class.
+     */
+    public static void setMenuItemAccessor(MenuItemAccessor mia) {
+        menuItemAccessor = mia;
+    }
+
+    /**
+     * Retrieve the accessor object for the java.awt.MenuItem class.
+     */
+    public static MenuItemAccessor getMenuItemAccessor() {
+        if (menuItemAccessor == null) {
+            unsafe.ensureClassInitialized(MenuItemAccessor.class);
+        }
+        return menuItemAccessor;
+    }
+
+    /**
+     * Set an accessor object for the java.awt.Menu class.
+     */
+    public static void setMenuAccessor(MenuAccessor ma) {
+        menuAccessor = ma;
+    }
+
+    /**
+     * Retrieve the accessor object for the java.awt.Menu class.
+     */
+    public static MenuAccessor getMenuAccessor() {
+        if (menuAccessor == null) {
+            unsafe.ensureClassInitialized(MenuAccessor.class);
+        }
+        return menuAccessor;
+    }
+
+    /**
+     * Set an accessor object for the java.awt.event.KeyEvent class.
+     */
+    public static void setKeyEventAccessor(KeyEventAccessor kea) {
+        keyEventAccessor = kea;
+    }
+
+    /**
+     * Retrieve the accessor object for the java.awt.event.KeyEvent class.
+     */
+    public static KeyEventAccessor getKeyEventAccessor() {
+        if (keyEventAccessor == null) {
+            unsafe.ensureClassInitialized(KeyEventAccessor.class);
+        }
+        return keyEventAccessor;
+    }
+
+    /**
+     * Set an accessor object for the javax.swing.ClientPropertyKey class.
+     */
+    public static void setClientPropertyKeyAccessor(ClientPropertyKeyAccessor cpka) {
+        clientPropertyKeyAccessor = cpka;
+    }
+
+    /**
+     * Retrieve the accessor object for the javax.swing.ClientPropertyKey class.
+     */
+    public static ClientPropertyKeyAccessor getClientPropertyKeyAccessor() {
+        if (clientPropertyKeyAccessor == null) {
+            unsafe.ensureClassInitialized(ClientPropertyKeyAccessor.class);
+        }
+        return clientPropertyKeyAccessor;
+    }
+
+    /**
+     * Set an accessor object for the java.awt.SystemTray class.
+     */
+    public static void setSystemTrayAccessor(SystemTrayAccessor sta) {
+        systemTrayAccessor = sta;
+    }
+
+    /**
+     * Retrieve the accessor object for the java.awt.SystemTray class.
+     */
+    public static SystemTrayAccessor getSystemTrayAccessor() {
+        if (systemTrayAccessor == null) {
+            unsafe.ensureClassInitialized(SystemTrayAccessor.class);
+        }
+        return systemTrayAccessor;
+    }
+
+    /**
+     * Set an accessor object for the java.awt.TrayIcon class.
+     */
+    public static void setTrayIconAccessor(TrayIconAccessor tia) {
+        trayIconAccessor = tia;
+    }
+
+    /**
+     * Retrieve the accessor object for the java.awt.TrayIcon class.
+     */
+    public static TrayIconAccessor getTrayIconAccessor() {
+        if (trayIconAccessor == null) {
+            unsafe.ensureClassInitialized(TrayIconAccessor.class);
+        }
+        return trayIconAccessor;
+    }
+
+    /**
+     * Set an accessor object for the java.awt.DefaultKeyboardFocusManager class.
+     */
+    public static void setDefaultKeyboardFocusManagerAccessor(DefaultKeyboardFocusManagerAccessor dkfma) {
+        defaultKeyboardFocusManagerAccessor = dkfma;
+    }
+
+    /**
+     * Retrieve the accessor object for the java.awt.DefaultKeyboardFocusManager class.
+     */
+    public static DefaultKeyboardFocusManagerAccessor getDefaultKeyboardFocusManagerAccessor() {
+        if (defaultKeyboardFocusManagerAccessor == null) {
+            unsafe.ensureClassInitialized(DefaultKeyboardFocusManagerAccessor.class);
+        }
+        return defaultKeyboardFocusManagerAccessor;
+    }
+
 }
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/sun/awt/AppContext.java
--- jdk/src/share/classes/sun/awt/AppContext.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/sun/awt/AppContext.java	Sun Sep 23 23:43:31 2012 +0400
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1998, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -787,6 +787,27 @@
         }
         return changeSupport.getPropertyChangeListeners(propertyName);
     }
+
+    // Set up JavaAWTAccess in SharedSecrets
+    static {
+        sun.misc.SharedSecrets.setJavaAWTAccess(new sun.misc.JavaAWTAccess() {
+            public Object get(Object key) {
+                return getAppContext().get(key);
+            }
+            public void put(Object key, Object value) {
+                getAppContext().put(key, value);
+            }
+            public void remove(Object key) {
+                getAppContext().remove(key);
+            }
+            public boolean isDisposed() {
+                return getAppContext().isDisposed();
+            }
+            public boolean isMainAppContext() {
+                return (numAppContexts == 1);
+            }
+        });
+    }
 }
 
 final class MostRecentKeyValue {
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/sun/awt/EmbeddedFrame.java
--- jdk/src/share/classes/sun/awt/EmbeddedFrame.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/sun/awt/EmbeddedFrame.java	Sun Sep 23 23:43:31 2012 +0400
@@ -29,12 +29,6 @@
 import java.awt.event.*;
 import java.awt.image.*;
 import java.awt.peer.*;
-import java.security.AccessController;
-import java.security.PrivilegedAction;
-import java.lang.reflect.Constructor;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Modifier;
-import java.lang.reflect.Field;
 import java.beans.PropertyChangeListener;
 import java.beans.PropertyChangeEvent;
 import java.util.Set;
@@ -63,8 +57,6 @@
                           implements KeyEventDispatcher, PropertyChangeListener {
 
     private boolean isCursorAllowed = true;
-    private static Field fieldPeer;
-    private static Field currentCycleRoot;
     private boolean supportsXEmbed = false;
     private KeyboardFocusManager appletKFM;
     // JDK 1.1 compatibility
@@ -208,39 +200,8 @@
      */
     public boolean dispatchKeyEvent(KeyEvent e) {
 
-        // We can't guarantee that this is called on the same AppContext as EmbeddedFrame
-        // belongs to. That's why we can't use public methods to find current focus cycle
-        // root. Instead, we access KFM's private field directly.
-        if (currentCycleRoot == null) {
-            currentCycleRoot = (Field)AccessController.doPrivileged(new PrivilegedAction() {
-                public Object run() {
-                    try {
-                        Field unaccessibleRoot = KeyboardFocusManager.class.
-                                                     getDeclaredField("currentFocusCycleRoot");
-                        if (unaccessibleRoot != null) {
-                            unaccessibleRoot.setAccessible(true);
-                        }
-                        return unaccessibleRoot;
-                    } catch (NoSuchFieldException e1) {
-                        assert false;
-                    } catch (SecurityException e2) {
-                        assert false;
-                    }
-                    return null;
-                }
-            });
-        }
-
-        Container currentRoot = null;
-        if (currentCycleRoot != null) {
-            try {
-                // The field is static, so we can pass null to Field.get() as the argument.
-                currentRoot = (Container)currentCycleRoot.get(null);
-            } catch (IllegalAccessException e3) {
-                // This is impossible: currentCycleRoot would be null if setAccessible failed.
-                assert false;
-            }
-        }
+        Container currentRoot = AWTAccessor.getKeyboardFocusManagerAccessor()
+                                    .getCurrentFocusCycleRoot();
 
         // if we are not in EmbeddedFrame's cycle, we should not try to leave.
         if (this != currentRoot) {
@@ -381,32 +342,8 @@
     }
 
     protected  void setPeer(final ComponentPeer p){
-        if (fieldPeer == null) {
-            fieldPeer = (Field)AccessController.doPrivileged(new PrivilegedAction() {
-                    public Object run() {
-                        try {
-                            Field lnkPeer = Component.class.getDeclaredField("peer");
-                            if (lnkPeer != null) {
-                                lnkPeer.setAccessible(true);
-                            }
-                            return lnkPeer;
-                        } catch (NoSuchFieldException e) {
-                            assert false;
-                        } catch (SecurityException e) {
-                            assert false;
-                        }
-                        return null;
-                    }//run
-                });
-        }
-        try{
-            if (fieldPeer !=null){
-                fieldPeer.set(EmbeddedFrame.this, p);
-            }
-        } catch (IllegalAccessException e) {
-            assert false;
-        }
-    };  //setPeer method ends
+        AWTAccessor.getComponentAccessor().setPeer(EmbeddedFrame.this, p);
+    };
 
     /**
      * Synthesize native message to activate or deactivate EmbeddedFrame window
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/sun/awt/SunToolkit.java
--- jdk/src/share/classes/sun/awt/SunToolkit.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/sun/awt/SunToolkit.java	Sun Sep 23 23:43:31 2012 +0400
@@ -51,14 +51,8 @@
 import sun.awt.image.*;
 import sun.security.action.GetPropertyAction;
 import sun.security.action.GetBooleanAction;
-import java.lang.reflect.Field;
-import java.lang.reflect.Method;
-import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
 import java.security.AccessController;
-import java.security.PrivilegedAction;
-import java.security.PrivilegedActionException;
-import java.security.PrivilegedExceptionAction;
 
 public abstract class SunToolkit extends Toolkit
     implements WindowClosingSupport, WindowClosingListener,
@@ -80,7 +74,6 @@
      */
     public static final int GRAB_EVENT_MASK = 0x80000000;
 
-    private static Method  wakeupMethod;
     /* The key to put()/get() the PostEventQueue into/from the AppContext.
      */
     private static final String POST_EVENT_QUEUE_KEY = "PostEventQueue";
@@ -294,52 +287,8 @@
         return appContext;
     }
 
-    public static Field getField(final Class klass, final String fieldName) {
-        return AccessController.doPrivileged(new PrivilegedAction<Field>() {
-            public Field run() {
-                try {
-                    Field field = klass.getDeclaredField(fieldName);
-                    assert (field != null);
-                    field.setAccessible(true);
-                    return field;
-                } catch (SecurityException e) {
-                    assert false;
-                } catch (NoSuchFieldException e) {
-                    assert false;
-                }
-                return null;
-            }//run
-        });
-    }
-
     static void wakeupEventQueue(EventQueue q, boolean isShutdown){
-        if (wakeupMethod == null){
-            wakeupMethod = (Method)AccessController.doPrivileged(new PrivilegedAction(){
-                    public Object run(){
-                        try {
-                            Method method  = EventQueue.class.getDeclaredMethod("wakeup",new Class [] {Boolean.TYPE} );
-                            if (method != null) {
-                                method.setAccessible(true);
-                            }
-                            return method;
-                        } catch (NoSuchMethodException e) {
-                            assert false;
-                        } catch (SecurityException e) {
-                            assert false;
-                        }
-                        return null;
-                    }//run
-                });
-        }
-        try{
-            if (wakeupMethod != null){
-                wakeupMethod.invoke(q, new Object[]{Boolean.valueOf(isShutdown)});
-            }
-        } catch (InvocationTargetException e){
-            assert false;
-        } catch (IllegalAccessException e) {
-            assert false;
-        }
+        AWTAccessor.getEventQueueAccessor().wakeup(q, isShutdown);
     }
 
     /*
@@ -1455,22 +1404,6 @@
             || comp instanceof Window);
     }
 
-    public static Method getMethod(final Class clz, final String methodName, final Class[] params) {
-        Method res = null;
-        try {
-            res = AccessController.doPrivileged(new PrivilegedExceptionAction<Method>() {
-                    public Method run() throws Exception {
-                        Method m = clz.getDeclaredMethod(methodName, params);
-                        m.setAccessible(true);
-                        return m;
-                    }
-                });
-        } catch (PrivilegedActionException ex) {
-            ex.printStackTrace();
-        }
-        return res;
-    }
-
     public static class OperationTimedOut extends RuntimeException {
         public OperationTimedOut(String msg) {
             super(msg);
@@ -1613,21 +1546,9 @@
     private boolean queueEmpty = false;
     private final Object waitLock = "Wait Lock";
 
-    static Method eqNoEvents;
-
     private boolean isEQEmpty() {
         EventQueue queue = getSystemEventQueueImpl();
-        synchronized(SunToolkit.class) {
-            if (eqNoEvents == null) {
-                eqNoEvents = getMethod(java.awt.EventQueue.class, "noEvents", null);
-            }
-        }
-        try {
-            return (Boolean)eqNoEvents.invoke(queue);
-        } catch (Exception e) {
-            e.printStackTrace();
-            return false;
-        }
+        return AWTAccessor.getEventQueueAccessor().noEvents(queue);
     }
 
     /**
@@ -1882,20 +1803,14 @@
      * consumeNextKeyTyped() method is not currently used,
      * however Swing could use it in the future.
      */
-    private static Method consumeNextKeyTypedMethod = null;
     public static synchronized void consumeNextKeyTyped(KeyEvent keyEvent) {
-        if (consumeNextKeyTypedMethod == null) {
-            consumeNextKeyTypedMethod = getMethod(DefaultKeyboardFocusManager.class,
-                                                  "consumeNextKeyTyped",
-                                                  new Class[] {KeyEvent.class});
-        }
         try {
-            consumeNextKeyTypedMethod.invoke(KeyboardFocusManager.getCurrentKeyboardFocusManager(),
-                                             keyEvent);
-        } catch (IllegalAccessException iae) {
-            iae.printStackTrace();
-        } catch (InvocationTargetException ite) {
-            ite.printStackTrace();
+            AWTAccessor.getDefaultKeyboardFocusManagerAccessor().consumeNextKeyTyped(
+                (DefaultKeyboardFocusManager)KeyboardFocusManager.
+                    getCurrentKeyboardFocusManager(),
+                keyEvent);
+        } catch (ClassCastException cce) {
+             cce.printStackTrace();
         }
     }
 
@@ -1915,25 +1830,6 @@
         return (Window)comp;
     }
 
-    /**
-     * Returns the value of the system property indicated by the specified key.
-     */
-    public static String getSystemProperty(final String key) {
-        return (String)AccessController.doPrivileged(new PrivilegedAction() {
-                public Object run() {
-                    return System.getProperty(key);
-                }
-            });
-    }
-
-    /**
-     * Returns the boolean value of the system property indicated by the specified key.
-     */
-    protected static Boolean getBooleanSystemProperty(String key) {
-        return Boolean.valueOf(AccessController.
-                   doPrivileged(new GetBooleanAction(key)));
-    }
-
     private static Boolean sunAwtDisableMixing = null;
 
     /**
@@ -1942,7 +1838,8 @@
      */
     public synchronized static boolean getSunAwtDisableMixing() {
         if (sunAwtDisableMixing == null) {
-            sunAwtDisableMixing = getBooleanSystemProperty("sun.awt.disableMixing");
+            sunAwtDisableMixing = AccessController.doPrivileged(
+                                      new GetBooleanAction("sun.awt.disableMixing"));
         }
         return sunAwtDisableMixing.booleanValue();
     }
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/sun/beans/editors/BooleanEditor.java
--- jdk/src/share/classes/sun/beans/editors/BooleanEditor.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/sun/beans/editors/BooleanEditor.java	Sun Sep 23 23:43:31 2012 +0400
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -26,51 +26,7 @@
 package sun.beans.editors;
 
 /**
- * Property editor for a java builtin "boolean" type.
+ * FOR BACKWARD COMPATIBILITY ONLY - DO NOT USE.
  */
-
-import java.beans.*;
-
-public class BooleanEditor extends PropertyEditorSupport {
-
-
-    public String getJavaInitializationString() {
-        Object value = getValue();
-        return (value != null)
-                ? value.toString()
-                : "null";
-    }
-
-    public String getAsText() {
-        Object value = getValue();
-        return (value instanceof Boolean)
-             ? getValidName((Boolean) value)
-             : null;
-    }
-
-    public void setAsText(String text) throws java.lang.IllegalArgumentException {
-        if (text == null) {
-            setValue(null);
-        } else if (isValidName(true, text)) {
-            setValue(Boolean.TRUE);
-        } else if (isValidName(false, text)) {
-            setValue(Boolean.FALSE);
-        } else {
-            throw new java.lang.IllegalArgumentException(text);
-        }
-    }
-
-    public String[] getTags() {
-        return new String[] {getValidName(true), getValidName(false)};
-    }
-
-    // the following method should be localized (4890258)
-
-    private String getValidName(boolean value) {
-        return value ? "True" : "False";
-    }
-
-    private boolean isValidName(boolean value, String name) {
-        return getValidName(value).equalsIgnoreCase(name);
-    }
+public class BooleanEditor extends com.sun.beans.editors.BooleanEditor {
 }
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/sun/beans/editors/ByteEditor.java
--- jdk/src/share/classes/sun/beans/editors/ByteEditor.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/sun/beans/editors/ByteEditor.java	Sun Sep 23 23:43:31 2012 +0400
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -26,23 +26,7 @@
 package sun.beans.editors;
 
 /**
- * Property editor for a java builtin "byte" type.
- *
+ * FOR BACKWARD COMPATIBILITY ONLY - DO NOT USE.
  */
-
-import java.beans.*;
-
-public class ByteEditor extends NumberEditor {
-
-    public String getJavaInitializationString() {
-        Object value = getValue();
-        return (value != null)
-                ? "((byte)" + value + ")"
-                : "null";
-    }
-
-    public void setAsText(String text) throws IllegalArgumentException {
-        setValue((text == null) ? null : Byte.decode(text));
-    }
-
+public class ByteEditor extends com.sun.beans.editors.ByteEditor {
 }
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/sun/beans/editors/ColorEditor.java
--- jdk/src/share/classes/sun/beans/editors/ColorEditor.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/sun/beans/editors/ColorEditor.java	Sun Sep 23 23:43:31 2012 +0400
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2009, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,190 +25,8 @@
 
 package sun.beans.editors;
 
-import java.awt.*;
-import java.beans.*;
-
-public class ColorEditor extends Panel implements PropertyEditor {
-    private static final long serialVersionUID = 1781257185164716054L;
-
-    public ColorEditor() {
-        setLayout(null);
-
-        ourWidth = hPad;
-
-        // Create a sample color block bordered in black
-        Panel p = new Panel();
-        p.setLayout(null);
-        p.setBackground(Color.black);
-        sample = new Canvas();
-        p.add(sample);
-        sample.reshape(2, 2, sampleWidth, sampleHeight);
-        add(p);
-        p.reshape(ourWidth, 2, sampleWidth+4, sampleHeight+4);
-        ourWidth += sampleWidth + 4 + hPad;
-
-        text = new TextField("", 14);
-        add(text);
-        text.reshape(ourWidth,0,100,30);
-        ourWidth += 100 + hPad;
-
-        choser = new Choice();
-        int active = 0;
-        for (int i = 0; i < colorNames.length; i++) {
-            choser.addItem(colorNames[i]);
-        }
-        add(choser);
-        choser.reshape(ourWidth,0,100,30);
-        ourWidth += 100 + hPad;
-
-        resize(ourWidth,40);
-    }
-
-    public void setValue(Object o) {
-        Color c = (Color)o;
-        changeColor(c);
-    }
-
-    public Dimension preferredSize() {
-        return new Dimension(ourWidth, 40);
-    }
-
-    public boolean keyUp(Event e, int key) {
-        if (e.target == text) {
-            try {
-                setAsText(text.getText());
-            } catch (IllegalArgumentException ex) {
-                // Quietly ignore.
-            }
-        }
-        return (false);
-    }
-
-    public void setAsText(String s) throws java.lang.IllegalArgumentException {
-        if (s == null) {
-            changeColor(null);
-            return;
-        }
-        int c1 = s.indexOf(',');
-        int c2 = s.indexOf(',', c1+1);
-        if (c1 < 0 || c2 < 0) {
-            // Invalid string.
-            throw new IllegalArgumentException(s);
-        }
-        try {
-            int r = Integer.parseInt(s.substring(0,c1));
-            int g = Integer.parseInt(s.substring(c1+1, c2));
-            int b = Integer.parseInt(s.substring(c2+1));
-            Color c = new Color(r,g,b);
-            changeColor(c);
-        } catch (Exception ex) {
-            throw new IllegalArgumentException(s);
-        }
-
-    }
-
-    public boolean action(Event e, Object arg) {
-        if (e.target == choser) {
-            changeColor(colors[choser.getSelectedIndex()]);
-        }
-        return false;
-    }
-
-    public String getJavaInitializationString() {
-        return (this.color != null)
-                ? "new java.awt.Color(" + this.color.getRGB() + ",true)"
-                : "null";
-    }
-
-
-    private void changeColor(Color c) {
-
-        if (c == null) {
-            this.color = null;
-            this.text.setText("");
-            return;
-        }
-
-        color = c;
-
-        text.setText("" + c.getRed() + "," + c.getGreen() + "," + c.getBlue());
-
-        int active = 0;
-        for (int i = 0; i < colorNames.length; i++) {
-            if (color.equals(colors[i])) {
-                active = i;
-            }
-        }
-        choser.select(active);
-
-        sample.setBackground(color);
-        sample.repaint();
-
-        support.firePropertyChange("", null, null);
-    }
-
-    public Object getValue() {
-        return color;
-    }
-
-    public boolean isPaintable() {
-        return true;
-    }
-
-    public void paintValue(java.awt.Graphics gfx, java.awt.Rectangle box) {
-        Color oldColor = gfx.getColor();
-        gfx.setColor(Color.black);
-        gfx.drawRect(box.x, box.y, box.width-3, box.height-3);
-        gfx.setColor(color);
-        gfx.fillRect(box.x+1, box.y+1, box.width-4, box.height-4);
-        gfx.setColor(oldColor);
-    }
-
-    public String getAsText() {
-        return (this.color != null)
-                ? this.color.getRed() + "," + this.color.getGreen() + "," + this.color.getBlue()
-                : null;
-    }
-
-    public String[] getTags() {
-        return null;
-    }
-
-    public java.awt.Component getCustomEditor() {
-        return this;
-    }
-
-    public boolean supportsCustomEditor() {
-        return true;
-    }
-
-    public void addPropertyChangeListener(PropertyChangeListener l) {
-        support.addPropertyChangeListener(l);
-    }
-
-    public void removePropertyChangeListener(PropertyChangeListener l) {
-        support.removePropertyChangeListener(l);
-    }
-
-
-    private String colorNames[] = { " ", "white", "lightGray", "gray", "darkGray",
-                        "black", "red", "pink", "orange",
-                        "yellow", "green", "magenta", "cyan",
-                        "blue"};
-    private Color colors[] = { null, Color.white, Color.lightGray, Color.gray, Color.darkGray,
-                        Color.black, Color.red, Color.pink, Color.orange,
-                        Color.yellow, Color.green, Color.magenta, Color.cyan,
-                        Color.blue};
-
-    private Canvas sample;
-    private int sampleHeight = 20;
-    private int sampleWidth = 40;
-    private int hPad = 5;
-    private int ourWidth;
-
-    private Color color;
-    private TextField text;
-    private Choice choser;
-
-    private PropertyChangeSupport support = new PropertyChangeSupport(this);
+/**
+ * FOR BACKWARD COMPATIBILITY ONLY - DO NOT USE.
+ */
+public class ColorEditor extends com.sun.beans.editors.ColorEditor {
 }
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/sun/beans/editors/DoubleEditor.java
--- jdk/src/share/classes/sun/beans/editors/DoubleEditor.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/sun/beans/editors/DoubleEditor.java	Sun Sep 23 23:43:31 2012 +0400
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -26,16 +26,7 @@
 package sun.beans.editors;
 
 /**
- * Property editor for a java builtin "double" type.
- *
+ * FOR BACKWARD COMPATIBILITY ONLY - DO NOT USE.
  */
-
-import java.beans.*;
-
-public class DoubleEditor extends NumberEditor {
-
-    public void setAsText(String text) throws IllegalArgumentException {
-        setValue((text == null) ? null : Double.valueOf(text));
-    }
-
+public class DoubleEditor extends com.sun.beans.editors.DoubleEditor {
 }
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/sun/beans/editors/EnumEditor.java
--- jdk/src/share/classes/sun/beans/editors/EnumEditor.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/sun/beans/editors/EnumEditor.java	Sun Sep 23 23:43:31 2012 +0400
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -22,122 +22,14 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
+
 package sun.beans.editors;
 
-import java.awt.Component;
-import java.awt.Graphics;
-import java.awt.Rectangle;
-import java.beans.PropertyChangeEvent;
-import java.beans.PropertyChangeListener;
-import java.beans.PropertyEditor;
-import java.util.ArrayList;
-import java.util.List;
-
 /**
- * Property editor for java.lang.Enum subclasses.
- *
- * @see PropertyEditor
- *
- * @since 1.7
- *
- * @author Sergey A. Malenkov
+ * FOR BACKWARD COMPATIBILITY ONLY - DO NOT USE.
  */
-public final class EnumEditor implements PropertyEditor {
-    private final List<PropertyChangeListener> listeners = new ArrayList<PropertyChangeListener>();
-
-    private final Class type;
-    private final String[] tags;
-
-    private Object value;
-
-    public EnumEditor( Class type ) {
-        Object[] values = type.getEnumConstants();
-        if ( values == null ) {
-            throw new IllegalArgumentException( "Unsupported " + type );
-        }
-        this.type = type;
-        this.tags = new String[values.length];
-        for ( int i = 0; i < values.length; i++ ) {
-            this.tags[i] = ( ( Enum )values[i] ).name();
-        }
-    }
-
-    public Object getValue() {
-        return this.value;
-    }
-
-    public void setValue( Object value ) {
-        if ( ( value != null ) && !this.type.isInstance( value ) ) {
-            throw new IllegalArgumentException( "Unsupported value: " + value );
-        }
-        Object oldValue;
-        PropertyChangeListener[] listeners;
-        synchronized ( this.listeners ) {
-            oldValue = this.value;
-            this.value = value;
-
-            if ( ( value == null ) ? oldValue == null : value.equals( oldValue ) ) {
-                return; // do not fire event if value is not changed
-            }
-            int size = this.listeners.size();
-            if ( size == 0 ) {
-                return; // do not fire event if there are no any listener
-            }
-            listeners = this.listeners.toArray( new PropertyChangeListener[size] );
-        }
-        PropertyChangeEvent event = new PropertyChangeEvent( this, null, oldValue, value );
-        for ( PropertyChangeListener listener : listeners ) {
-            listener.propertyChange( event );
-        }
-    }
-
-    public String getAsText() {
-        return ( this.value != null )
-                ? ( ( Enum )this.value ).name()
-                : null;
-    }
-
-    public void setAsText( String text ) {
-        setValue( ( text != null )
-                ? Enum.valueOf( this.type, text )
-                : null );
-    }
-
-    public String[] getTags() {
-        return this.tags.clone();
-    }
-
-    public String getJavaInitializationString() {
-        String name = getAsText();
-        return ( name != null )
-                ? this.type.getName() + '.' + name
-                : "null";
-    }
-
-    public boolean isPaintable() {
-        return false;
-    }
-
-    public void paintValue( Graphics gfx, Rectangle box ) {
-    }
-
-    public boolean supportsCustomEditor() {
-        return false;
-    }
-
-    public Component getCustomEditor() {
-        return null;
-    }
-
-    public void addPropertyChangeListener( PropertyChangeListener listener ) {
-        synchronized ( this.listeners ) {
-            this.listeners.add( listener );
-        }
-    }
-
-    public void removePropertyChangeListener( PropertyChangeListener listener ) {
-        synchronized ( this.listeners ) {
-            this.listeners.remove( listener );
-        }
+public class EnumEditor extends com.sun.beans.editors.EnumEditor {
+    public EnumEditor(Class type) {
+        super(type);
     }
 }
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/sun/beans/editors/FloatEditor.java
--- jdk/src/share/classes/sun/beans/editors/FloatEditor.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/sun/beans/editors/FloatEditor.java	Sun Sep 23 23:43:31 2012 +0400
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -26,23 +26,7 @@
 package sun.beans.editors;
 
 /**
- * Property editor for a java builtin "float" type.
- *
+ * FOR BACKWARD COMPATIBILITY ONLY - DO NOT USE.
  */
-
-import java.beans.*;
-
-public class FloatEditor extends NumberEditor {
-
-    public String getJavaInitializationString() {
-        Object value = getValue();
-        return (value != null)
-                ? value + "F"
-                : "null";
-    }
-
-    public void setAsText(String text) throws IllegalArgumentException {
-        setValue((text == null) ? null : Float.valueOf(text));
-    }
-
+public class FloatEditor extends com.sun.beans.editors.FloatEditor {
 }
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/sun/beans/editors/FontEditor.java
--- jdk/src/share/classes/sun/beans/editors/FontEditor.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/sun/beans/editors/FontEditor.java	Sun Sep 23 23:43:31 2012 +0400
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2009, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,195 +25,8 @@
 
 package sun.beans.editors;
 
-import java.awt.*;
-import java.beans.*;
-
-public class FontEditor extends Panel implements java.beans.PropertyEditor {
-    private static final long serialVersionUID = 6732704486002715933L;
-
-    public FontEditor() {
-        setLayout(null);
-
-        toolkit = Toolkit.getDefaultToolkit();
-        fonts = toolkit.getFontList();
-
-        familyChoser = new Choice();
-        for (int i = 0; i < fonts.length; i++) {
-            familyChoser.addItem(fonts[i]);
-        }
-        add(familyChoser);
-        familyChoser.reshape(20, 5, 100, 30);
-
-        styleChoser = new Choice();
-        for (int i = 0; i < styleNames.length; i++) {
-            styleChoser.addItem(styleNames[i]);
-        }
-        add(styleChoser);
-        styleChoser.reshape(145, 5, 70, 30);
-
-        sizeChoser = new Choice();
-        for (int i = 0; i < pointSizes.length; i++) {
-            sizeChoser.addItem("" + pointSizes[i]);
-        }
-        add(sizeChoser);
-        sizeChoser.reshape(220, 5, 70, 30);
-
-        resize(300,40);
-    }
-
-
-    public Dimension preferredSize() {
-        return new Dimension(300, 40);
-    }
-
-    public void setValue(Object o) {
-        font = (Font) o;
-        if (this.font == null)
-            return;
-
-        changeFont(font);
-        // Update the current GUI choices.
-        for (int i = 0; i < fonts.length; i++) {
-            if (fonts[i].equals(font.getFamily())) {
-                familyChoser.select(i);
-                break;
-            }
-        }
-        for (int i = 0; i < styleNames.length; i++) {
-            if (font.getStyle() == styles[i]) {
-                styleChoser.select(i);
-                break;
-            }
-        }
-        for (int i = 0; i < pointSizes.length; i++) {
-            if (font.getSize() <= pointSizes[i]) {
-                sizeChoser.select(i);
-                break;
-            }
-        }
-    }
-
-    private void changeFont(Font f) {
-        font = f;
-        if (sample != null) {
-            remove(sample);
-        }
-        sample = new Label(sampleText);
-        sample.setFont(font);
-        add(sample);
-        Component p = getParent();
-        if (p != null) {
-            p.invalidate();
-            p.layout();
-        }
-        invalidate();
-        layout();
-        repaint();
-        support.firePropertyChange("", null, null);
-    }
-
-    public Object getValue() {
-        return (font);
-    }
-
-    public String getJavaInitializationString() {
-        if (this.font == null)
-            return "null";
-
-        return "new java.awt.Font(\"" + font.getName() + "\", " +
-                   font.getStyle() + ", " + font.getSize() + ")";
-    }
-
-    public boolean action(Event e, Object arg) {
-        String family = familyChoser.getSelectedItem();
-        int style = styles[styleChoser.getSelectedIndex()];
-        int size = pointSizes[sizeChoser.getSelectedIndex()];
-        try {
-            Font f = new Font(family, style, size);
-            changeFont(f);
-        } catch (Exception ex) {
-            System.err.println("Couldn't create font " + family + "-" +
-                        styleNames[style] + "-" + size);
-        }
-        return (false);
-    }
-
-
-    public boolean isPaintable() {
-        return true;
-    }
-
-    public void paintValue(java.awt.Graphics gfx, java.awt.Rectangle box) {
-        // Silent noop.
-        Font oldFont = gfx.getFont();
-        gfx.setFont(font);
-        FontMetrics fm = gfx.getFontMetrics();
-        int vpad = (box.height - fm.getAscent())/2;
-        gfx.drawString(sampleText, 0, box.height-vpad);
-        gfx.setFont(oldFont);
-    }
-
-    public String getAsText() {
-        if (this.font == null) {
-            return null;
-        }
-        StringBuilder sb = new StringBuilder();
-        sb.append(this.font.getName());
-        sb.append(' ');
-
-        boolean b = this.font.isBold();
-        if (b) {
-            sb.append("BOLD");
-        }
-        boolean i = this.font.isItalic();
-        if (i) {
-            sb.append("ITALIC");
-        }
-        if (b || i) {
-            sb.append(' ');
-        }
-        sb.append(this.font.getSize());
-        return sb.toString();
-    }
-
-    public void setAsText(String text) throws IllegalArgumentException {
-        setValue((text == null) ? null : Font.decode(text));
-    }
-
-    public String[] getTags() {
-        return null;
-    }
-
-    public java.awt.Component getCustomEditor() {
-        return this;
-    }
-
-    public boolean supportsCustomEditor() {
-        return true;
-    }
-
-    public void addPropertyChangeListener(PropertyChangeListener l) {
-        support.addPropertyChangeListener(l);
-    }
-
-    public void removePropertyChangeListener(PropertyChangeListener l) {
-        support.removePropertyChangeListener(l);
-    }
-
-    private Font font;
-    private Toolkit toolkit;
-    private String sampleText = "Abcde...";
-
-    private Label sample;
-    private Choice familyChoser;
-    private Choice styleChoser;
-    private Choice sizeChoser;
-
-    private String fonts[];
-    private String[] styleNames = { "plain", "bold", "italic" };
-    private int[] styles = { Font.PLAIN, Font.BOLD, Font.ITALIC };
-    private int[] pointSizes = { 3, 5, 8, 10, 12, 14, 18, 24, 36, 48 };
-
-    private PropertyChangeSupport support = new PropertyChangeSupport(this);
-
+/**
+ * FOR BACKWARD COMPATIBILITY ONLY - DO NOT USE.
+ */
+public class FontEditor extends com.sun.beans.editors.FontEditor {
 }
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/sun/beans/editors/IntegerEditor.java
--- jdk/src/share/classes/sun/beans/editors/IntegerEditor.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/sun/beans/editors/IntegerEditor.java	Sun Sep 23 23:43:31 2012 +0400
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -26,17 +26,7 @@
 package sun.beans.editors;
 
 /**
- * Property editor for a java builtin "int" type.
- *
+ * FOR BACKWARD COMPATIBILITY ONLY - DO NOT USE.
  */
-
-import java.beans.*;
-
-public class IntegerEditor extends NumberEditor {
-
-
-    public void setAsText(String text) throws IllegalArgumentException {
-        setValue((text == null) ? null : Integer.decode(text));
-    }
-
+public class IntegerEditor extends com.sun.beans.editors.IntegerEditor {
 }
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/sun/beans/editors/LongEditor.java
--- jdk/src/share/classes/sun/beans/editors/LongEditor.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/sun/beans/editors/LongEditor.java	Sun Sep 23 23:43:31 2012 +0400
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -26,23 +26,7 @@
 package sun.beans.editors;
 
 /**
- * Property editor for a java builtin "long" type.
- *
+ * FOR BACKWARD COMPATIBILITY ONLY - DO NOT USE.
  */
-
-import java.beans.*;
-
-public class LongEditor extends NumberEditor {
-
-    public String getJavaInitializationString() {
-        Object value = getValue();
-        return (value != null)
-                ? value + "L"
-                : "null";
-    }
-
-    public void setAsText(String text) throws IllegalArgumentException {
-        setValue((text == null) ? null : Long.decode(text));
-    }
-
+public class LongEditor extends com.sun.beans.editors.LongEditor {
 }
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/sun/beans/editors/NumberEditor.java
--- jdk/src/share/classes/sun/beans/editors/NumberEditor.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/sun/beans/editors/NumberEditor.java	Sun Sep 23 23:43:31 2012 +0400
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -26,19 +26,7 @@
 package sun.beans.editors;
 
 /**
- * Abstract Property editor for a java builtin number types.
- *
+ * FOR BACKWARD COMPATIBILITY ONLY - DO NOT USE.
  */
-
-import java.beans.*;
-
-abstract public class NumberEditor extends PropertyEditorSupport {
-
-    public String getJavaInitializationString() {
-        Object value = getValue();
-        return (value != null)
-                ? value.toString()
-                : "null";
-    }
-
+abstract public class NumberEditor extends com.sun.beans.editors.NumberEditor {
 }
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/sun/beans/editors/ShortEditor.java
--- jdk/src/share/classes/sun/beans/editors/ShortEditor.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/sun/beans/editors/ShortEditor.java	Sun Sep 23 23:43:31 2012 +0400
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -23,27 +23,10 @@
  * questions.
  */
 
-
 package sun.beans.editors;
 
 /**
- * Property editor for a java builtin "short" type.
- *
+ * FOR BACKWARD COMPATIBILITY ONLY - DO NOT USE.
  */
-
-import java.beans.*;
-
-public class ShortEditor extends NumberEditor {
-
-    public String getJavaInitializationString() {
-        Object value = getValue();
-        return (value != null)
-                ? "((short)" + value + ")"
-                : "null";
-    }
-
-    public void setAsText(String text) throws IllegalArgumentException {
-        setValue((text == null) ? null : Short.decode(text));
-    }
-
+public class ShortEditor extends com.sun.beans.editors.ShortEditor {
 }
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/sun/beans/editors/StringEditor.java
--- jdk/src/share/classes/sun/beans/editors/StringEditor.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/sun/beans/editors/StringEditor.java	Sun Sep 23 23:43:31 2012 +0400
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -23,52 +23,10 @@
  * questions.
  */
 
-
 package sun.beans.editors;
 
-import java.beans.*;
-
-public class StringEditor extends PropertyEditorSupport {
-
-    public String getJavaInitializationString() {
-        Object value = getValue();
-        if (value == null)
-            return "null";
-
-        String str = value.toString();
-        int length = str.length();
-        StringBuilder sb = new StringBuilder(length + 2);
-        sb.append('"');
-        for (int i = 0; i < length; i++) {
-            char ch = str.charAt(i);
-            switch (ch) {
-            case '\b': sb.append("\\b");  break;
-            case '\t': sb.append("\\t");  break;
-            case '\n': sb.append("\\n");  break;
-            case '\f': sb.append("\\f");  break;
-            case '\r': sb.append("\\r");  break;
-            case '\"': sb.append("\\\""); break;
-            case '\\': sb.append("\\\\"); break;
-            default:
-                if ((ch < ' ') || (ch > '~')) {
-                    sb.append("\\u");
-                    String hex = Integer.toHexString((int) ch);
-                    for (int len = hex.length(); len < 4; len++) {
-                        sb.append('0');
-                    }
-                    sb.append(hex);
-                } else {
-                    sb.append(ch);
-                }
-                break;
-            }
-        }
-        sb.append('"');
-        return sb.toString();
-    }
-
-    public void setAsText(String text) {
-        setValue(text);
-    }
-
+/**
+ * FOR BACKWARD COMPATIBILITY ONLY - DO NOT USE.
+ */
+public class StringEditor extends com.sun.beans.editors.StringEditor {
 }
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/sun/beans/infos/ComponentBeanInfo.java
--- jdk/src/share/classes/sun/beans/infos/ComponentBeanInfo.java	Tue Aug 07 12:10:45 2012 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,62 +0,0 @@
-/*
- * Copyright (c) 1996, 2002, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package sun.beans.infos;
-
-import java.beans.*;
-
-/**
- * BeanInfo descriptor for a standard AWT component.
- */
-
-public class ComponentBeanInfo extends SimpleBeanInfo {
-    private static final Class beanClass = java.awt.Component.class;
-
-    public PropertyDescriptor[] getPropertyDescriptors() {
-        try {
-            PropertyDescriptor
-                      name = new PropertyDescriptor("name",       beanClass),
-                background = new PropertyDescriptor("background", beanClass),
-                foreground = new PropertyDescriptor("foreground", beanClass),
-                      font = new PropertyDescriptor("font",       beanClass),
-                   enabled = new PropertyDescriptor("enabled",    beanClass),
-                   visible = new PropertyDescriptor("visible",    beanClass),
-                 focusable = new PropertyDescriptor("focusable",  beanClass);
-
-            enabled.setExpert(true);
-            visible.setHidden(true);
-
-            background.setBound(true);
-            foreground.setBound(true);
-            font.setBound(true);
-            focusable.setBound(true);
-
-            PropertyDescriptor[] rv = {name, background, foreground, font, enabled, visible, focusable };
-            return rv;
-        } catch (IntrospectionException e) {
-            throw new Error(e.toString());
-        }
-    }
-}
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/sun/invoke/anon/AnonymousClassLoader.java
--- jdk/src/share/classes/sun/invoke/anon/AnonymousClassLoader.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/sun/invoke/anon/AnonymousClassLoader.java	Sun Sep 23 23:43:31 2012 +0400
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -73,74 +73,14 @@
 public class AnonymousClassLoader {
     final Class<?> hostClass;
 
-    // Note: Do not refactor the calls to checkHostClass unless you
-    //       also adjust this constant:
-    private static int CHC_CALLERS = 3;
-
-    public AnonymousClassLoader() {
-        this.hostClass = checkHostClass(null);
-    }
-    public AnonymousClassLoader(Class<?> hostClass) {
-        this.hostClass = checkHostClass(hostClass);
+    // Privileged constructor.
+    private AnonymousClassLoader(Class<?> hostClass) {
+        this.hostClass = hostClass;
     }
 
-    private static Class<?> getTopLevelClass(Class<?> clazz) {
-      for(Class<?> outer = clazz.getDeclaringClass(); outer != null;
-          outer = outer.getDeclaringClass()) {
-        clazz = outer;
-      }
-      return clazz;
-    }
-
-    private static Class<?> checkHostClass(Class<?> hostClass) {
-        // called only from the constructor
-        // does a context-sensitive check on caller class
-        // CC[0..3] = {Reflection, this.checkHostClass, this.<init>, caller}
-        Class<?> caller = sun.reflect.Reflection.getCallerClass(CHC_CALLERS);
-
-        if (caller == null) {
-            // called from the JVM directly
-            if (hostClass == null)
-                return AnonymousClassLoader.class; // anything central will do
-            return hostClass;
-        }
-
-        if (hostClass == null)
-            hostClass = caller; // default value is caller itself
-
-        // anonymous class will access hostClass on behalf of caller
-        Class<?> callee = hostClass;
-
-        if (caller == callee)
-            // caller can always nominate itself to grant caller's own access rights
-            return hostClass;
-
-        // normalize caller and callee to their top-level classes:
-        caller = getTopLevelClass(caller);
-        callee = getTopLevelClass(callee);
-        if (caller == callee)
-            return caller;
-
-        ClassLoader callerCL = caller.getClassLoader();
-        if (callerCL == null) {
-            // caller is trusted code, so accept the proposed hostClass
-            return hostClass;
-        }
-
-        // %%% should do something with doPrivileged, because trusted
-        // code should have a way to execute on behalf of
-        // partially-trusted clients
-
-        // Does the caller have the right to access the private
-        // members of the callee?  If not, raise an error.
-        final int ACC_PRIVATE = 2;
-        try {
-            sun.reflect.Reflection.ensureMemberAccess(caller, callee, null, ACC_PRIVATE);
-        } catch (IllegalAccessException ee) {
-            throw new IllegalArgumentException(ee);
-        }
-
-        return hostClass;
+    public static AnonymousClassLoader make(sun.misc.Unsafe unsafe, Class<?> hostClass) {
+        if (unsafe == null)  throw new NullPointerException();
+        return new AnonymousClassLoader(hostClass);
     }
 
     public Class<?> loadClass(byte[] classFile) {
@@ -249,7 +189,7 @@
     private static int fakeNameCounter = 99999;
 
     // ignore two warnings on this line:
-    static sun.misc.Unsafe unsafe = sun.misc.Unsafe.getUnsafe();
+    private static sun.misc.Unsafe unsafe = sun.misc.Unsafe.getUnsafe();
     // preceding line requires that this class be on the boot class path
 
     static private final Method defineAnonymousClass;
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/sun/misc/JavaAWTAccess.java
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ jdk/src/share/classes/sun/misc/JavaAWTAccess.java	Sun Sep 23 23:43:31 2012 +0400
@@ -0,0 +1,34 @@
+/*
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package sun.misc;
+
+public interface JavaAWTAccess {
+    public Object get(Object key);
+    public void put(Object key, Object value);
+    public void remove(Object key);
+    public boolean isDisposed();
+    public boolean isMainAppContext();
+}
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/sun/misc/Service.java
--- jdk/src/share/classes/sun/misc/Service.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/sun/misc/Service.java	Sun Sep 23 23:43:31 2012 +0400
@@ -284,12 +284,20 @@
             }
             String cn = nextName;
             nextName = null;
+            Class<?> c = null;
             try {
-                return Class.forName(cn, true, loader).newInstance();
+                c = Class.forName(cn, false, loader);
             } catch (ClassNotFoundException x) {
                 fail(service,
                      "Provider " + cn + " not found");
-            } catch (Exception x) {
+            }
+            if (!service.isAssignableFrom(c)) {
+                fail(service,
+                     "Provider " + cn  + " not a subtype");
+            }
+            try {
+                return service.cast(c.newInstance());
+            } catch (Throwable x) {
                 fail(service,
                      "Provider " + cn + " could not be instantiated: " + x,
                      x);
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/sun/misc/SharedSecrets.java
--- jdk/src/share/classes/sun/misc/SharedSecrets.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/sun/misc/SharedSecrets.java	Sun Sep 23 23:43:31 2012 +0400
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2002, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2002, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -56,6 +56,7 @@
     private static JavaSecurityAccess javaSecurityAccess;
     private static JavaxSecurityAuthKerberosAccess javaxSecurityAuthKerberosAccess;
     private static JavaUtilZipAccess javaUtilZipAccess;
+    private static JavaAWTAccess javaAWTAccess;
 
     public static JavaUtilJarAccess javaUtilJarAccess() {
         if (javaUtilJarAccess == null) {
@@ -177,4 +178,14 @@
         }
         return javaUtilZipAccess;
     }
+
+    public static void setJavaAWTAccess(JavaAWTAccess jaa) {
+        javaAWTAccess = jaa;
+    }
+
+    public static JavaAWTAccess getJavaAWTAccess() {
+        // this may return null in which case calling code needs to
+        // provision for.
+        return javaAWTAccess;
+    }
 }
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/sun/rmi/registry/RegistryImpl.java
--- jdk/src/share/classes/sun/rmi/registry/RegistryImpl.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/sun/rmi/registry/RegistryImpl.java	Sun Sep 23 23:43:31 2012 +0400
@@ -405,7 +405,8 @@
          */
         perms.add(new SocketPermission("*", "connect,accept"));
 
-        perms.add(new RuntimePermission("accessClassInPackage.sun.*"));
+        perms.add(new RuntimePermission("accessClassInPackage.sun.jvmstat.*"));
+        perms.add(new RuntimePermission("accessClassInPackage.sun.jvm.hotspot.*"));
 
         perms.add(new FilePermission("<<ALL FILES>>", "read"));
 
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/sun/security/provider/SecureRandom.java
--- jdk/src/share/classes/sun/security/provider/SecureRandom.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/sun/security/provider/SecureRandom.java	Sun Sep 23 23:43:31 2012 +0400
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1998, 2003, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -56,12 +56,6 @@
 
     private static final long serialVersionUID = 3581829991155417889L;
 
-    /**
-     * This static object will be seeded by SeedGenerator, and used
-     * to seed future instances of SecureRandom
-     */
-    private static SecureRandom seeder;
-
     private static final int DIGEST_SIZE = 20;
     private transient MessageDigest digest;
     private byte[] state;
@@ -173,6 +167,28 @@
     }
 
     /**
+     * This static object will be seeded by SeedGenerator, and used
+     * to seed future instances of SHA1PRNG SecureRandoms.
+     *
+     * Bloch, Effective Java Second Edition: Item 71
+     */
+    private static class SeederHolder {
+
+        private static final SecureRandom seeder;
+
+        static {
+            /*
+             * Call to SeedGenerator.generateSeed() to add additional
+             * seed material (likely from the Native implementation).
+             */
+            seeder = new SecureRandom(SeedGenerator.getSystemEntropy());
+            byte [] b = new byte[DIGEST_SIZE];
+            SeedGenerator.generateSeed(b);
+            seeder.engineSetSeed(b);
+        }
+    }
+
+    /**
      * Generates a user-specified number of random bytes.
      *
      * @param bytes the array to be filled in with random bytes.
@@ -183,13 +199,8 @@
         byte[] output = remainder;
 
         if (state == null) {
-            if (seeder == null) {
-                seeder = new SecureRandom(SeedGenerator.getSystemEntropy());
-                seeder.engineSetSeed(engineGenerateSeed(DIGEST_SIZE));
-            }
-
             byte[] seed = new byte[DIGEST_SIZE];
-            seeder.engineNextBytes(seed);
+            SeederHolder.seeder.engineNextBytes(seed);
             state = digest.digest(seed);
         }
 
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/sun/security/ssl/HandshakeInStream.java
--- jdk/src/share/classes/sun/security/ssl/HandshakeInStream.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/sun/security/ssl/HandshakeInStream.java	Sun Sep 23 23:43:31 2012 +0400
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2009, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -190,6 +190,7 @@
 
     byte[] getBytes8() throws IOException {
         int len = getInt8();
+        verifyLength(len);
         byte b[] = new byte[len];
 
         read(b, 0, len);
@@ -198,6 +199,7 @@
 
     public byte[] getBytes16() throws IOException {
         int len = getInt16();
+        verifyLength(len);
         byte b[] = new byte[len];
 
         read(b, 0, len);
@@ -206,10 +208,19 @@
 
     byte[] getBytes24() throws IOException {
         int len = getInt24();
+        verifyLength(len);
         byte b[] = new byte[len];
 
         read(b, 0, len);
         return b;
     }
 
+    // Is a length greater than available bytes in the record?
+    private void verifyLength(int len) throws SSLException {
+        if (len > available()) {
+            throw new SSLException(
+                        "Not enough data to fill declared vector size");
+        }
+    }
+
 }
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/sun/security/ssl/Handshaker.java
--- jdk/src/share/classes/sun/security/ssl/Handshaker.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/sun/security/ssl/Handshaker.java	Sun Sep 23 23:43:31 2012 +0400
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -1063,7 +1063,6 @@
             if (debug != null && Debug.isOn("handshake")) {
                 System.out.println("RSA master secret generation error:");
                 e.printStackTrace(System.out);
-                System.out.println("Generating new random premaster secret");
             }
 
             if (requestedVersion != null) {
@@ -1130,7 +1129,6 @@
             System.out.println("RSA PreMasterSecret version error: expected"
                 + protocolVersion + " or " + requestedVersion + ", decrypted: "
                 + premasterVersion);
-            System.out.println("Generating new random premaster secret");
         }
         preMasterSecret =
             RSAClientKeyExchange.generateDummySecret(requestedVersion);
diff -r 1c775da99873 -r ffad06d70095 src/share/classes/sun/security/ssl/RSAClientKeyExchange.java
--- jdk/src/share/classes/sun/security/ssl/RSAClientKeyExchange.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/classes/sun/security/ssl/RSAClientKeyExchange.java	Sun Sep 23 23:43:31 2012 +0400
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -36,6 +36,7 @@
 import javax.net.ssl.*;
 
 import sun.security.internal.spec.TlsRsaPremasterSecretParameterSpec;
+import sun.security.util.KeyLength;
 
 /**
  * This is the client key exchange message (CLIENT --> SERVER) used with
@@ -192,26 +193,38 @@
                         "unable to get the plaintext of the premaster secret");
                 }
 
-                // We are not always able to get the encoded key of the
-                // premaster secret. Pass the cheking to master secret
+                int keySize = KeyLength.getKeySize(secretKey);
+                if (keySize > 0 && keySize != 384) {       // 384 = 48 * 8
+                    if (debug != null && Debug.isOn("handshake")) {
+                        System.out.println(
+                            "incorrect length of premaster secret: " +
+                            (keySize/8));
+                    }
+
+                    return generateDummySecret(clientHelloVersion);
+                }
+
+                // The key size is exactly 48 bytes or not accessible.
+                //
+                // Conservatively, pass the checking to master secret
                 // calculation.
                 return secretKey;
             } else if (encoded.length == 48) {
                 // check the version
                 if (clientHelloVersion.major == encoded[0] &&
                     clientHelloVersion.minor == encoded[1]) {
+
                     return secretKey;
-                } else if (clientHelloVersion.v <= ProtocolVersion.TLS10.v) {
+                } else if (clientHelloVersion.v <= ProtocolVersion.TLS10.v &&
+                           currentVersion.major == encoded[0] &&
+                           currentVersion.minor == encoded[1]) {
                     /*
-                     * we never checked the client_version in server side
-                     * for TLS v1.0 and SSL v3.0. For compatibility, we
-                     * maintain this behavior.
+                     * For compatibility, we maintain the behavior that the
+                     * version in pre_master_secret can be the negotiated
+                     * version for TLS v1.0 and SSL v3.0.
                      */
-                    if (currentVersion.major == encoded[0] &&
-                        currentVersion.minor == encoded[1]) {
-                        this.protocolVersion = currentVersion;
-                        return secretKey;
-                    }
+                    this.protocolVersion = currentVersion;
+                    return secretKey;
                 }
 
                 if (debug != null && Debug.isOn("handshake")) {
@@ -220,22 +233,23 @@
                         ", while PreMasterSecret.client_version is " +
                         ProtocolVersion.valueOf(encoded[0], encoded[1]));
                 }
+
+                return generateDummySecret(clientHelloVersion);
             } else {
                 if (debug != null && Debug.isOn("handshake")) {
                     System.out.println(
                         "incorrect length of premaster secret: " +
                         encoded.length);
                 }
+
+                return generateDummySecret(clientHelloVersion);
             }
         }
 
-        if (debug != null && Debug.isOn("handshake")) {
-            if (failoverException != null) {
-                System.out.println("Error decrypting premaster secret:");
-                failoverException.printStackTrace(System.out);
-            }
-
-            System.out.println("Generating random secret");
+        if (debug != null && Debug.isOn("handshake") &&
+                    failoverException != null) {
+            System.out.println("Error decrypting premaster secret:");
+            failoverException.printStackTrace(System.out);
         }
 
         return generateDummySecret(clientHelloVersion);
@@ -243,6 +257,10 @@
 
     // generate a premaster secret with the specified version number
     static SecretKey generateDummySecret(ProtocolVersion version) {
+        if (debug != null && Debug.isOn("handshake")) {
+            System.out.println("Generating a random fake premaster secret");
+        }
+
         try {
             String s = ((version.v >= ProtocolVersion.TLS12.v) ?
                 "SunTls12RsaPremasterSecret" : "SunTlsRsaPremasterSecret");
diff -r 1c775da99873 -r ffad06d70095 src/share/lib/security/java.security
--- jdk/src/share/lib/security/java.security	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/lib/security/java.security	Sun Sep 23 23:43:31 2012 +0400
@@ -123,7 +123,7 @@
 # passed to checkPackageAccess unless the
 # corresponding RuntimePermission ("accessClassInPackage."+package) has
 # been granted.
-package.access=sun.,com.sun.xml.internal.ws.,com.sun.xml.internal.bind.,com.sun.imageio.,com.sun.org.apache.xerces.internal.utils.,com.sun.org.apache.xalan.internal.utils.
+package.access=sun.,com.sun.xml.internal.ws.,com.sun.xml.internal.bind.,com.sun.imageio.,com.sun.org.apache.xerces.internal.utils.,com.sun.org.apache.xalan.internal.utils.,com.sun.org.glassfish.external.,com.sun.org.glassfish.gmbal.
 
 #
 # List of comma-separated packages that start with or equal this string
@@ -135,7 +135,7 @@
 # by default, none of the class loaders supplied with the JDK call
 # checkPackageDefinition.
 #
-package.definition=sun.,com.sun.xml.internal.ws.,com.sun.xml.internal.bind.,com.sun.imageio.,com.sun.org.apache.xerces.internal.utils.,com.sun.org.apache.xalan.internal.utils.
+package.definition=sun.,com.sun.xml.internal.ws.,com.sun.xml.internal.bind.,com.sun.imageio.,com.sun.org.apache.xerces.internal.utils.,com.sun.org.apache.xalan.internal.utils.,com.sun.org.glassfish.external.,com.sun.org.glassfish.gmbal.
 
 #
 # Determines whether this properties file can be appended to
diff -r 1c775da99873 -r ffad06d70095 src/share/lib/security/java.security-macosx
--- jdk/src/share/lib/security/java.security-macosx	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/lib/security/java.security-macosx	Sun Sep 23 23:43:31 2012 +0400
@@ -124,7 +124,7 @@
 # passed to checkPackageAccess unless the
 # corresponding RuntimePermission ("accessClassInPackage."+package) has
 # been granted.
-package.access=sun.,com.sun.xml.internal.ws.,com.sun.xml.internal.bind.,com.sun.imageio.,com.sun.org.apache.xerces.internal.utils.,com.sun.org.apache.xalan.internal.utils.,apple.
+package.access=sun.,com.sun.xml.internal.ws.,com.sun.xml.internal.bind.,com.sun.imageio.,com.sun.org.apache.xerces.internal.utils.,com.sun.org.apache.xalan.internal.utils.,com.sun.org.glassfish.external.,com.sun.org.glassfish.gmbal.,apple.
 
 #
 # List of comma-separated packages that start with or equal this string
@@ -136,7 +136,7 @@
 # by default, none of the class loaders supplied with the JDK call
 # checkPackageDefinition.
 #
-package.definition=sun.,com.sun.xml.internal.ws.,com.sun.xml.internal.bind.,com.sun.imageio.,com.sun.org.apache.xerces.internal.utils.,com.sun.org.apache.xalan.internal.utils.,apple.
+package.definition=sun.,com.sun.xml.internal.ws.,com.sun.xml.internal.bind.,com.sun.imageio.,com.sun.org.apache.xerces.internal.utils.,com.sun.org.apache.xalan.internal.utils.,com.sun.org.glassfish.external.,com.sun.org.glassfish.gmbal.,apple.
 
 #
 # Determines whether this properties file can be appended to
diff -r 1c775da99873 -r ffad06d70095 src/share/lib/security/java.security-solaris
--- jdk/src/share/lib/security/java.security-solaris	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/lib/security/java.security-solaris	Sun Sep 23 23:43:31 2012 +0400
@@ -125,7 +125,7 @@
 # passed to checkPackageAccess unless the
 # corresponding RuntimePermission ("accessClassInPackage."+package) has
 # been granted.
-package.access=sun.,com.sun.xml.internal.ws.,com.sun.xml.internal.bind.,com.sun.imageio.,com.sun.org.apache.xerces.internal.utils.,com.sun.org.apache.xalan.internal.utils.
+package.access=sun.,com.sun.xml.internal.ws.,com.sun.xml.internal.bind.,com.sun.imageio.,com.sun.org.apache.xerces.internal.utils.,com.sun.org.apache.xalan.internal.utils.,com.sun.org.glassfish.external.,com.sun.org.glassfish.gmbal.
 
 #
 # List of comma-separated packages that start with or equal this string
@@ -137,7 +137,7 @@
 # by default, none of the class loaders supplied with the JDK call
 # checkPackageDefinition.
 #
-package.definition=sun.,com.sun.xml.internal.ws.,com.sun.xml.internal.bind.,com.sun.imageio.,com.sun.org.apache.xerces.internal.utils.,com.sun.org.apache.xalan.internal.utils.
+package.definition=sun.,com.sun.xml.internal.ws.,com.sun.xml.internal.bind.,com.sun.imageio.,com.sun.org.apache.xerces.internal.utils.,com.sun.org.apache.xalan.internal.utils.,com.sun.org.glassfish.external.,com.sun.org.glassfish.gmbal.
 
 #
 # Determines whether this properties file can be appended to
diff -r 1c775da99873 -r ffad06d70095 src/share/lib/security/java.security-windows
--- jdk/src/share/lib/security/java.security-windows	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/share/lib/security/java.security-windows	Sun Sep 23 23:43:31 2012 +0400
@@ -124,7 +124,7 @@
 # passed to checkPackageAccess unless the
 # corresponding RuntimePermission ("accessClassInPackage."+package) has
 # been granted.
-package.access=sun.,com.sun.xml.internal.ws.,com.sun.xml.internal.bind.,com.sun.imageio.,com.sun.org.apache.xerces.internal.utils.,com.sun.org.apache.xalan.internal.utils.
+package.access=sun.,com.sun.xml.internal.ws.,com.sun.xml.internal.bind.,com.sun.imageio.,com.sun.org.apache.xerces.internal.utils.,com.sun.org.apache.xalan.internal.utils.,com.sun.org.glassfish.external.,com.sun.org.glassfish.gmbal.
 
 #
 # List of comma-separated packages that start with or equal this string
@@ -136,7 +136,7 @@
 # by default, none of the class loaders supplied with the JDK call
 # checkPackageDefinition.
 #
-package.definition=sun.,com.sun.xml.internal.ws.,com.sun.xml.internal.bind.,com.sun.imageio.,com.sun.org.apache.xerces.internal.utils.,com.sun.org.apache.xalan.internal.utils.
+package.definition=sun.,com.sun.xml.internal.ws.,com.sun.xml.internal.bind.,com.sun.imageio.,com.sun.org.apache.xerces.internal.utils.,com.sun.org.apache.xalan.internal.utils.,com.sun.org.glassfish.external.,com.sun.org.glassfish.gmbal.
 
 #
 # Determines whether this properties file can be appended to
diff -r 1c775da99873 -r ffad06d70095 src/solaris/classes/sun/awt/X11/XCheckboxMenuItemPeer.java
--- jdk/src/solaris/classes/sun/awt/X11/XCheckboxMenuItemPeer.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/solaris/classes/sun/awt/X11/XCheckboxMenuItemPeer.java	Sun Sep 23 23:43:31 2012 +0400
@@ -29,27 +29,12 @@
 import java.awt.peer.*;
 import java.awt.event.*;
 
-import java.lang.reflect.Field;
-import sun.awt.SunToolkit;
+import sun.awt.AWTAccessor;
 
 class XCheckboxMenuItemPeer extends XMenuItemPeer implements CheckboxMenuItemPeer {
 
     /************************************************
      *
-     * Data members
-     *
-     ************************************************/
-
-    /*
-     * CheckboxMenuItem's fields
-     */
-    private final static Field f_state;
-    static {
-        f_state = SunToolkit.getField(CheckboxMenuItem.class, "state");
-    }
-
-    /************************************************
-     *
      * Construction
      *
      ************************************************/
@@ -74,16 +59,8 @@
      *
      ************************************************/
     boolean getTargetState() {
-        MenuItem target = getTarget();
-        if (target == null) {
-            return false;
-        }
-        try {
-            return f_state.getBoolean(target);
-        } catch (IllegalAccessException e) {
-            e.printStackTrace();
-        }
-        return false;
+        return AWTAccessor.getCheckboxMenuItemAccessor()
+                   .getState((CheckboxMenuItem)getTarget());
     }
 
     /************************************************
diff -r 1c775da99873 -r ffad06d70095 src/solaris/classes/sun/awt/X11/XEmbedCanvasPeer.java
--- jdk/src/solaris/classes/sun/awt/X11/XEmbedCanvasPeer.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/solaris/classes/sun/awt/X11/XEmbedCanvasPeer.java	Sun Sep 23 23:43:31 2012 +0400
@@ -29,14 +29,8 @@
 import java.awt.dnd.DropTarget;
 import java.awt.dnd.DropTargetListener;
 import java.awt.event.*;
-import java.awt.image.ColorModel;
-import java.awt.image.ImageObserver;
-import java.awt.image.ImageProducer;
-import java.awt.image.VolatileImage;
-import java.awt.peer.*;
 import sun.awt.*;
-import sun.awt.motif.X11FontMetrics;
-import java.lang.reflect.*;
+import sun.awt.AWTAccessor;
 import sun.util.logging.PlatformLogger;
 import java.util.*;
 import static sun.awt.X11.XEmbedHelper.*;
@@ -455,16 +449,8 @@
         }
     }
 
-    static Field bdataField;
     static byte[] getBData(KeyEvent e) {
-        try {
-            if (bdataField == null) {
-                bdataField = SunToolkit.getField(java.awt.AWTEvent.class, "bdata");
-            }
-            return (byte[])bdataField.get(e);
-        } catch (IllegalAccessException ex) {
-            return null;
-        }
+        return AWTAccessor.getAWTEventAccessor().getBData(e);
     }
 
     void forwardKeyEvent(KeyEvent e) {
diff -r 1c775da99873 -r ffad06d70095 src/solaris/classes/sun/awt/X11/XEmbeddingContainer.java
--- jdk/src/solaris/classes/sun/awt/X11/XEmbeddingContainer.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/solaris/classes/sun/awt/X11/XEmbeddingContainer.java	Sun Sep 23 23:43:31 2012 +0400
@@ -29,7 +29,7 @@
 import java.util.HashMap;
 import java.awt.event.KeyEvent;
 import java.lang.reflect.*;
-import sun.awt.SunToolkit;
+import sun.awt.AWTAccessor;
 
 public class XEmbeddingContainer extends XEmbedHelper implements XEventDispatcher {
     HashMap children = new HashMap();
@@ -127,20 +127,8 @@
         }
     }
 
-    static Field bdata;
-    byte[] getBData(KeyEvent e) {
-        try {
-            if (bdata == null) {
-                bdata = SunToolkit.getField(java.awt.AWTEvent.class, "bdata");
-            }
-            return (byte[])bdata.get(e);
-        } catch (IllegalAccessException ex) {
-            return null;
-        }
-    }
-
     void forwardKeyEvent(long child, KeyEvent e) {
-        byte[] bdata = getBData(e);
+        byte[] bdata = AWTAccessor.getAWTEventAccessor().getBData(e);
         long data = Native.toData(bdata);
         if (data == 0) {
             return;
diff -r 1c775da99873 -r ffad06d70095 src/solaris/classes/sun/awt/X11/XGlobalCursorManager.java
--- jdk/src/solaris/classes/sun/awt/X11/XGlobalCursorManager.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/solaris/classes/sun/awt/X11/XGlobalCursorManager.java	Sun Sep 23 23:43:31 2012 +0400
@@ -27,10 +27,7 @@
 
 import java.awt.*;
 import java.awt.peer.ComponentPeer;
-import java.awt.peer.LightweightPeer;
 import java.lang.ref.WeakReference;
-import java.lang.reflect.Field;
-import java.lang.reflect.Method;
 import sun.awt.AWTAccessor;
 
 import sun.awt.GlobalCursorManager;
@@ -38,23 +35,6 @@
 
 public final class XGlobalCursorManager extends GlobalCursorManager {
 
-    private static Field  field_pData;
-    private static Field  field_type;
-    private static Class  cursorClass;
-    private static Method method_setPData;
-    static {
-        cursorClass = java.awt.Cursor.class;
-        field_pData = SunToolkit.getField(cursorClass, "pData");
-        field_type  = SunToolkit.getField(cursorClass, "type");
-        method_setPData = SunToolkit.getMethod(cursorClass, "setPData", new Class[] {long.class});
-        if (field_pData == null || field_type == null || method_setPData == null) {
-            System.out.println("Unable to initialize XGlobalCursorManager: ");
-            Thread.dumpStack();
-
-        }
-    }
-
-
     // cached nativeContainer
     private WeakReference<Component> nativeContainer;
 
@@ -213,8 +193,8 @@
         long pData = 0;
         int type = 0;
         try {
-            pData = field_pData.getLong(c);
-            type = field_type.getInt(c);
+            pData = AWTAccessor.getCursorAccessor().getPData(c);
+            type = AWTAccessor.getCursorAccessor().getType(c);
         }
         catch (Exception e)
         {
@@ -284,7 +264,7 @@
 
     static void setPData(Cursor c, long pData) {
         try {
-            method_setPData.invoke(c, pData);
+            AWTAccessor.getCursorAccessor().setPData(c, pData);
         }
         catch (Exception e)
         {
diff -r 1c775da99873 -r ffad06d70095 src/solaris/classes/sun/awt/X11/XMenuBarPeer.java
--- jdk/src/solaris/classes/sun/awt/X11/XMenuBarPeer.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/solaris/classes/sun/awt/X11/XMenuBarPeer.java	Sun Sep 23 23:43:31 2012 +0400
@@ -28,10 +28,9 @@
 import java.awt.peer.*;
 import java.awt.event.*;
 
-import java.lang.reflect.Field;
 import java.util.Vector;
 import sun.util.logging.PlatformLogger;
-import sun.awt.SunToolkit;
+import sun.awt.AWTAccessor;
 
 public class XMenuBarPeer extends XBaseMenuWindow implements MenuBarPeer {
 
@@ -67,15 +66,6 @@
     private final static int BAR_ITEM_MARGIN_TOP = 2;
     private final static int BAR_ITEM_MARGIN_BOTTOM = 2;
 
-    //fields
-    private static Field f_helpMenu;
-    private static Field f_menus;
-
-    static {
-        f_helpMenu = SunToolkit.getField(MenuBar.class, "helpMenu");
-        f_menus = SunToolkit.getField(MenuBar.class, "menus");
-    }
-
     /************************************************
      *
      * Mapping data
@@ -204,16 +194,12 @@
      */
     void postInit(XCreateWindowParams params) {
         super.postInit(params);
-        Vector targetMenuVector = null;
-        Menu targetHelpMenu = null;
-        try {
-            // Get menus from the target.
-            targetMenuVector = (Vector)f_menus.get(menuBarTarget);
-            targetHelpMenu = (Menu)f_helpMenu.get(menuBarTarget);
-            reloadItems(targetMenuVector);
-        } catch (IllegalAccessException iae) {
-            iae.printStackTrace();
-        }
+        // Get menus from the target.
+        Vector targetMenuVector = AWTAccessor.getMenuBarAccessor()
+                                      .getMenus(menuBarTarget);
+        Menu targetHelpMenu = AWTAccessor.getMenuBarAccessor()
+                                  .getHelpMenu(menuBarTarget);
+        reloadItems(targetMenuVector);
         if (targetHelpMenu != null) {
             addHelpMenu(targetHelpMenu);
         }
diff -r 1c775da99873 -r ffad06d70095 src/solaris/classes/sun/awt/X11/XMenuItemPeer.java
--- jdk/src/solaris/classes/sun/awt/X11/XMenuItemPeer.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/solaris/classes/sun/awt/X11/XMenuItemPeer.java	Sun Sep 23 23:43:31 2012 +0400
@@ -28,10 +28,7 @@
 import java.awt.peer.*;
 import java.awt.event.*;
 
-import java.lang.reflect.Field;
-import java.lang.reflect.Method;
-import java.lang.reflect.InvocationTargetException;
-import sun.awt.SunToolkit;
+import sun.awt.AWTAccessor;
 
 public class XMenuItemPeer implements MenuItemPeer {
 
@@ -81,24 +78,6 @@
     private final static int SEPARATOR_WIDTH = 20;
     private final static int SEPARATOR_HEIGHT = 5;
 
-    /*
-     * MenuItem's fields & methods
-     */
-    private final static Field f_enabled;
-    private final static Field f_label;
-    private final static Field f_shortcut;
-    private final static Method m_getFont;
-    private final static Method m_isItemEnabled;
-    private final static Method m_getActionCommand;
-    static {
-        f_enabled = SunToolkit.getField(MenuItem.class, "enabled");
-        f_label = SunToolkit.getField(MenuItem.class, "label");
-        f_shortcut = SunToolkit.getField(MenuItem.class, "shortcut");
-
-        m_getFont = SunToolkit.getMethod(MenuComponent.class, "getFont_NoClientCode", null);
-        m_getActionCommand = SunToolkit.getMethod(MenuItem.class, "getActionCommandImpl", null);
-        m_isItemEnabled = SunToolkit.getMethod(MenuItem.class, "isItemEnabled", null);
-    }
     /************************************************
      *
      * Text Metrics
@@ -216,39 +195,22 @@
         if (target == null) {
             return XWindow.getDefaultFont();
         }
-        try {
-            return (Font)m_getFont.invoke(target, new Object[0]);
-        } catch (IllegalAccessException e) {
-            e.printStackTrace();
-        } catch (InvocationTargetException e) {
-            e.printStackTrace();
-        }
-        return XWindow.getDefaultFont();
+        return AWTAccessor.getMenuComponentAccessor().getFont_NoClientCode(target);
     }
 
     String getTargetLabel() {
         if (target == null) {
             return "";
         }
-        try {
-            String label = (String)f_label.get(target);
-            return (label == null) ? "" : label;
-        } catch (IllegalAccessException e) {
-            e.printStackTrace();
-        }
-        return "";
+        String label = AWTAccessor.getMenuItemAccessor().getLabel(target);
+        return (label == null) ? "" : label;
     }
 
     boolean isTargetEnabled() {
         if (target == null) {
             return false;
         }
-        try {
-            return f_enabled.getBoolean(target);
-        } catch (IllegalAccessException e) {
-            e.printStackTrace();
-        }
-        return false;
+        return AWTAccessor.getMenuItemAccessor().isEnabled(target);
     }
 
     /**
@@ -260,40 +222,21 @@
         if (target == null) {
             return false;
         }
-        try {
-            return ((Boolean)m_isItemEnabled.invoke(target, new Object[0])).booleanValue();
-        } catch (IllegalAccessException e) {
-            e.printStackTrace();
-        } catch (InvocationTargetException e) {
-            e.printStackTrace();
-        }
-        return false;
+        return AWTAccessor.getMenuItemAccessor().isItemEnabled(target);
     }
 
     String getTargetActionCommand() {
         if (target == null) {
             return "";
         }
-        try {
-            return (String) m_getActionCommand.invoke(target,(Object[]) null);
-        } catch (IllegalAccessException e) {
-            e.printStackTrace();
-        } catch (InvocationTargetException e) {
-            e.printStackTrace();
-        }
-        return "";
+        return AWTAccessor.getMenuItemAccessor().getActionCommandImpl(target);
     }
 
     MenuShortcut getTargetShortcut() {
         if (target == null) {
             return null;
         }
-        try {
-            return (MenuShortcut)f_shortcut.get(target);
-        } catch (IllegalAccessException e) {
-            e.printStackTrace();
-        }
-        return null;
+        return AWTAccessor.getMenuItemAccessor().getShortcut(target);
     }
 
     String getShortcutText() {
diff -r 1c775da99873 -r ffad06d70095 src/solaris/classes/sun/awt/X11/XMenuPeer.java
--- jdk/src/solaris/classes/sun/awt/X11/XMenuPeer.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/solaris/classes/sun/awt/X11/XMenuPeer.java	Sun Sep 23 23:43:31 2012 +0400
@@ -27,10 +27,9 @@
 import java.awt.*;
 import java.awt.peer.*;
 
-import java.lang.reflect.Field;
 import java.util.Vector;
 import sun.util.logging.PlatformLogger;
-import sun.awt.SunToolkit;
+import sun.awt.AWTAccessor;
 
 public class XMenuPeer extends XMenuItemPeer implements MenuPeer {
 
@@ -46,16 +45,6 @@
      */
     XMenuWindow menuWindow;
 
-
-    /*
-     * Menu's fields & methods
-     */
-    private final static Field f_items;
-
-    static {
-        f_items = SunToolkit.getField(Menu.class, "items");
-    }
-
     /************************************************
      *
      * Construction
@@ -153,12 +142,7 @@
      *
      ************************************************/
     Vector getTargetItems() {
-        try {
-            return (Vector)f_items.get(getTarget());
-        } catch (IllegalAccessException iae) {
-            iae.printStackTrace();
-            return null;
-        }
+        return AWTAccessor.getMenuAccessor().getItems((Menu)getTarget());
     }
 
     /************************************************
diff -r 1c775da99873 -r ffad06d70095 src/solaris/classes/sun/awt/X11/XPopupMenuPeer.java
--- jdk/src/solaris/classes/sun/awt/X11/XPopupMenuPeer.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/solaris/classes/sun/awt/X11/XPopupMenuPeer.java	Sun Sep 23 23:43:31 2012 +0400
@@ -28,15 +28,10 @@
 import java.awt.peer.*;
 import java.awt.event.*;
 
-import java.lang.reflect.Field;
-import java.lang.reflect.Method;
-import java.lang.reflect.InvocationTargetException;
-
 import java.util.Vector;
+import sun.awt.AWTAccessor;
 import sun.util.logging.PlatformLogger;
 
-import sun.awt.SunToolkit;
-
 public class XPopupMenuPeer extends XMenuWindow implements PopupMenuPeer {
 
     /************************************************
@@ -66,24 +61,6 @@
     private final static int CAPTION_MARGIN_TOP = 4;
     private final static int CAPTION_SEPARATOR_HEIGHT = 6;
 
-    /*
-     * Menu's fields & methods
-     */
-    //Fix for 6184485: Popup menu is not disabled on XToolkit even when calling setEnabled (false)
-    private final static Field f_enabled;
-    //Fix for 6267144: PIT: Popup menu label is not shown, XToolkit
-    private final static Field f_label;
-    private final static Method m_getFont;
-    private final static Field f_items;
-
-    static {
-        f_enabled = SunToolkit.getField(MenuItem.class, "enabled");
-        f_label = SunToolkit.getField(MenuItem.class, "label");
-        f_items = SunToolkit.getField(Menu.class, "items");
-        m_getFont = SunToolkit.getMethod(MenuComponent.class, "getFont_NoClientCode", null);
-    }
-
-
     /************************************************
      *
      * Construction
@@ -96,7 +73,7 @@
 
     /************************************************
      *
-     * Implementaion of interface methods
+     * Implementation of interface methods
      *
      ************************************************/
     /*
@@ -189,27 +166,16 @@
         if (popupMenuTarget == null) {
             return XWindow.getDefaultFont();
         }
-        try {
-            return (Font)m_getFont.invoke(popupMenuTarget, new Object[0]);
-        } catch (IllegalAccessException e) {
-            e.printStackTrace();
-        } catch (InvocationTargetException e) {
-            e.printStackTrace();
-        }
-        return XWindow.getDefaultFont();
+        return AWTAccessor.getMenuComponentAccessor()
+                   .getFont_NoClientCode(popupMenuTarget);
     }
 
+    //Fix for 6267144: PIT: Popup menu label is not shown, XToolkit
     String getTargetLabel() {
         if (target == null) {
             return "";
         }
-        try {
-            String label = (String)f_label.get(popupMenuTarget);
-            return (label == null) ? "" : label;
-        } catch (IllegalAccessException e) {
-            e.printStackTrace();
-        }
-        return "";
+        return AWTAccessor.getMenuItemAccessor().getLabel(popupMenuTarget);
     }
 
     //Fix for 6184485: Popup menu is not disabled on XToolkit even when calling setEnabled (false)
@@ -217,21 +183,14 @@
         if (popupMenuTarget == null) {
             return false;
         }
-        try {
-            return f_enabled.getBoolean(popupMenuTarget);
-        } catch (IllegalAccessException e) {
-            e.printStackTrace();
-        }
-        return false;
+        return AWTAccessor.getMenuItemAccessor().isEnabled(popupMenuTarget);
     }
 
     Vector getMenuTargetItems() {
-        try {
-            return (Vector)f_items.get(popupMenuTarget);
-        } catch (IllegalAccessException iae) {
-            iae.printStackTrace();
+        if (popupMenuTarget == null) {
             return null;
         }
+        return AWTAccessor.getMenuAccessor().getItems(popupMenuTarget);
     }
 
     /************************************************
diff -r 1c775da99873 -r ffad06d70095 src/solaris/classes/sun/awt/X11/XScrollPanePeer.java
--- jdk/src/solaris/classes/sun/awt/X11/XScrollPanePeer.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/solaris/classes/sun/awt/X11/XScrollPanePeer.java	Sun Sep 23 23:43:31 2012 +0400
@@ -29,7 +29,7 @@
 import java.awt.event.*;
 import java.awt.peer.*;
 import java.lang.reflect.*;
-import sun.awt.SunToolkit;
+import sun.awt.AWTAccessor;
 
 class XScrollPanePeer extends XComponentPeer implements ScrollPanePeer, XScrollbarClient {
 
@@ -41,9 +41,7 @@
     public final static int     VERTICAL = 1 << 0;
     public final static int     HORIZONTAL = 1 << 1;
 
-    private static Method m_setValue;
     static {
-        m_setValue = SunToolkit.getMethod(ScrollPaneAdjustable.class, "setTypedValue", new Class[] {Integer.TYPE, Integer.TYPE});
         SCROLLBAR = XToolkit.getUIDefaults().getInt("ScrollBar.defaultWidth");
     }
 
@@ -316,19 +314,9 @@
     }
 
     void setAdjustableValue(ScrollPaneAdjustable adj, int value, int type) {
-        try {
-            m_setValue.invoke(adj, new Object[] {Integer.valueOf(value), Integer.valueOf(type)});
-        } catch (IllegalAccessException iae) {
-            adj.setValue(value);
-        } catch (IllegalArgumentException iae2) {
-            adj.setValue(value);
-        } catch (InvocationTargetException ite) {
-            adj.setValue(value);
-            ite.getCause().printStackTrace();
-        }
+        AWTAccessor.getScrollPaneAdjustableAccessor().setTypedValue(adj, value, type);
     }
 
-
     public void paint(Graphics g) {
         paintComponent(g);
     }
diff -r 1c775da99873 -r ffad06d70095 src/solaris/classes/sun/awt/X11/XSystemTrayPeer.java
--- jdk/src/solaris/classes/sun/awt/X11/XSystemTrayPeer.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/solaris/classes/sun/awt/X11/XSystemTrayPeer.java	Sun Sep 23 23:43:31 2012 +0400
@@ -27,10 +27,9 @@
 
 import java.awt.*;
 import java.awt.peer.SystemTrayPeer;
-import java.lang.reflect.Method;
-import java.lang.reflect.InvocationTargetException;
 import sun.awt.SunToolkit;
 import sun.awt.AppContext;
+import sun.awt.AWTAccessor;
 import sun.util.logging.PlatformLogger;
 
 public class XSystemTrayPeer implements SystemTrayPeer, XMSelectionListener {
@@ -42,11 +41,6 @@
     private volatile boolean available;
     private final XMSelection selection = new XMSelection("_NET_SYSTEM_TRAY");
 
-    private static final Method firePropertyChangeMethod =
-        XToolkit.getMethod(SystemTray.class, "firePropertyChange", new Class[] {String.class, Object.class, Object.class});
-    private static final Method addNotifyMethod = XToolkit.getMethod(TrayIcon.class, "addNotify", null);
-    private static final Method removeNotifyMethod = XToolkit.getMethod(TrayIcon.class, "removeNotify", null);
-
     private static final int SCREEN = 0;
     private static final String SYSTEM_TRAY_PROPERTY_NAME = "systemTray";
     private static final XAtom _NET_SYSTEM_TRAY = XAtom.get("_NET_SYSTEM_TRAY_S" + SCREEN);
@@ -157,44 +151,43 @@
         return peerInstance;
     }
 
-    private void firePropertyChange(final String propertyName, final Object oldValue, final Object newValue) {
+    private void firePropertyChange(final String propertyName,
+                                    final Object oldValue,
+                                    final Object newValue) {
         Runnable runnable = new Runnable() {
                 public void run() {
-                    Object[] args = new Object[] {propertyName, oldValue, newValue};
-                    invokeMethod(firePropertyChangeMethod, target, args);
+                    AWTAccessor.getSystemTrayAccessor()
+                        .firePropertyChange(target, propertyName, oldValue, newValue);
                 }
             };
         invokeOnEachAppContext(runnable);
     }
 
     private void createTrayPeers() {
-        invokeOnEachTrayIcon(addNotifyMethod);
-    }
-
-    private void removeTrayPeers() {
-        invokeOnEachTrayIcon(removeNotifyMethod);
-    }
-
-    private void invokeOnEachTrayIcon(final Method method) {
         Runnable runnable = new Runnable() {
                 public void run() {
                     TrayIcon[] icons = target.getTrayIcons();
-                    for (TrayIcon ti : icons) {
-                        invokeMethod(method, ti, (Object[]) null);
+                    try {
+                        for (TrayIcon ti : icons) {
+                            AWTAccessor.getTrayIconAccessor().addNotify(ti);
+                        }
+                    } catch (AWTException e) {
                     }
                 }
             };
         invokeOnEachAppContext(runnable);
     }
 
-    private void invokeMethod(Method method, Object obj, Object[] args) {
-        try{
-            method.invoke(obj, args);
-        } catch (InvocationTargetException e){
-            e.printStackTrace();
-        } catch (IllegalAccessException e) {
-            e.printStackTrace();
-        }
+    private void removeTrayPeers() {
+        Runnable runnable = new Runnable() {
+                public void run() {
+                    TrayIcon[] icons = target.getTrayIcons();
+                    for (TrayIcon ti : icons) {
+                        AWTAccessor.getTrayIconAccessor().removeNotify(ti);
+                    }
+                }
+            };
+        invokeOnEachAppContext(runnable);
     }
 
     private void invokeOnEachAppContext(Runnable runnable) {
diff -r 1c775da99873 -r ffad06d70095 src/solaris/classes/sun/awt/X11/XTextAreaPeer.java
--- jdk/src/solaris/classes/sun/awt/X11/XTextAreaPeer.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/solaris/classes/sun/awt/X11/XTextAreaPeer.java	Sun Sep 23 23:43:31 2012 +0400
@@ -1015,8 +1015,10 @@
         // loading SystemFlavorMap and associated classes.
         public void setTransferHandler(TransferHandler newHandler) {
             TransferHandler oldHandler = (TransferHandler)
-                getClientProperty(XTextTransferHelper.getTransferHandlerKey());
-            putClientProperty(XTextTransferHelper.getTransferHandlerKey(),
+                getClientProperty(AWTAccessor.getClientPropertyKeyAccessor()
+                                      .getJComponent_TRANSFER_HANDLER());
+            putClientProperty(AWTAccessor.getClientPropertyKeyAccessor()
+                                  .getJComponent_TRANSFER_HANDLER(),
                               newHandler);
 
             firePropertyChange("transferHandler", oldHandler, newHandler);
diff -r 1c775da99873 -r ffad06d70095 src/solaris/classes/sun/awt/X11/XTextFieldPeer.java
--- jdk/src/solaris/classes/sun/awt/X11/XTextFieldPeer.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/solaris/classes/sun/awt/X11/XTextFieldPeer.java	Sun Sep 23 23:43:31 2012 +0400
@@ -716,8 +716,10 @@
         // loading SystemFlavorMap and associated classes.
         public void setTransferHandler(TransferHandler newHandler) {
             TransferHandler oldHandler = (TransferHandler)
-                getClientProperty(XTextTransferHelper.getTransferHandlerKey());
-            putClientProperty(XTextTransferHelper.getTransferHandlerKey(),
+                getClientProperty(AWTAccessor.getClientPropertyKeyAccessor()
+                                      .getJComponent_TRANSFER_HANDLER());
+            putClientProperty(AWTAccessor.getClientPropertyKeyAccessor()
+                                  .getJComponent_TRANSFER_HANDLER(),
                               newHandler);
 
             firePropertyChange("transferHandler", oldHandler, newHandler);
diff -r 1c775da99873 -r ffad06d70095 src/solaris/classes/sun/awt/X11/XTextTransferHelper.java
--- jdk/src/solaris/classes/sun/awt/X11/XTextTransferHelper.java	Tue Aug 07 12:10:45 2012 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,47 +0,0 @@
-/*
- * Copyright (c) 2003, 2007, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package sun.awt.X11;
-
-import java.lang.reflect.Field;
-import sun.awt.SunToolkit;
-
-class XTextTransferHelper {
-    private static Object transferHandlerKey = null;
-    static Object getTransferHandlerKey() {
-        if (transferHandlerKey == null) {
-            try {
-                Class clazz = Class.forName("javax.swing.ClientPropertyKey");
-                Field field = SunToolkit.getField(clazz, "JComponent_TRANSFER_HANDLER");
-                transferHandlerKey = field.get(null);
-            } catch (IllegalAccessException ex) {
-                return null;
-            } catch (ClassNotFoundException cnfe) {
-                cnfe.printStackTrace();
-            }
-        }
-        return transferHandlerKey;
-    }
-}
diff -r 1c775da99873 -r ffad06d70095 src/solaris/classes/sun/awt/X11/XToolkit.java
--- jdk/src/solaris/classes/sun/awt/X11/XToolkit.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/solaris/classes/sun/awt/X11/XToolkit.java	Sun Sep 23 23:43:31 2012 +0400
@@ -41,8 +41,6 @@
 import java.awt.image.ColorModel;
 import java.awt.peer.*;
 import java.beans.PropertyChangeListener;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
 import java.security.AccessController;
 import java.security.PrivilegedAction;
 import java.util.*;
@@ -50,9 +48,9 @@
 import javax.swing.UIDefaults;
 import sun.awt.*;
 import sun.font.FontConfigManager;
-import sun.font.FontManager;
 import sun.misc.PerformanceLogger;
 import sun.print.PrintJob2D;
+import sun.security.action.GetPropertyAction;
 import sun.security.action.GetBooleanAction;
 import sun.util.logging.PlatformLogger;
 
@@ -112,7 +110,6 @@
     private static int screenWidth = -1, screenHeight = -1; // Dimensions of default screen
     static long awt_defaultFg; // Pixel
     private static XMouseInfoPeer xPeer;
-    private static Method m_removeSourceEvents;
 
     static {
         initSecurityWarning();
@@ -130,8 +127,6 @@
             initIDs();
             setBackingStoreType();
         }
-        m_removeSourceEvents = SunToolkit.getMethod(EventQueue.class, "removeSourceEvents", new Class[] {Object.class, Boolean.TYPE}) ;
-
         noisyAwtHandler = AccessController.doPrivileged(new GetBooleanAction("sun.awt.noisyerrorhandler"));
     }
 
@@ -222,7 +217,8 @@
 
     static void initSecurityWarning() {
         // Enable warning only for internal builds
-        String runtime = getSystemProperty("java.runtime.version");
+        String runtime = AccessController.doPrivileged(
+                             new GetPropertyAction("java.runtime.version"));
         securityWarningEnabled = (runtime != null && runtime.contains("internal"));
     }
 
@@ -1067,8 +1063,8 @@
      */
     public synchronized static boolean getSunAwtDisableGtkFileDialogs() {
         if (sunAwtDisableGtkFileDialogs == null) {
-            sunAwtDisableGtkFileDialogs =
-                getBooleanSystemProperty("sun.awt.disableGtkFileDialogs");
+            sunAwtDisableGtkFileDialogs = AccessController.doPrivileged(
+                                              new GetBooleanAction("sun.awt.disableGtkFileDialogs"));
         }
         return sunAwtDisableGtkFileDialogs.booleanValue();
     }
@@ -2056,17 +2052,11 @@
         return null;
     }
 
-    static void removeSourceEvents(EventQueue queue, Object source, boolean removeAllEvents) {
-        try {
-            m_removeSourceEvents.invoke(queue, source, removeAllEvents);
-        }
-        catch (IllegalAccessException e)
-        {
-            e.printStackTrace();
-        }
-        catch (InvocationTargetException e) {
-            e.printStackTrace();
-        }
+    static void removeSourceEvents(EventQueue queue,
+                                   Object source,
+                                   boolean removeAllEvents) {
+        AWTAccessor.getEventQueueAccessor()
+            .removeSourceEvents(queue, source, removeAllEvents);
     }
 
     public boolean isAlwaysOnTopSupported() {
diff -r 1c775da99873 -r ffad06d70095 src/solaris/classes/sun/awt/X11/XWindow.java
--- jdk/src/solaris/classes/sun/awt/X11/XWindow.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/solaris/classes/sun/awt/X11/XWindow.java	Sun Sep 23 23:43:31 2012 +0400
@@ -126,10 +126,6 @@
     native void getWindowBounds(long window, long x, long y, long width, long height);
     private native static void initIDs();
 
-    private static Field isPostedField;
-    private static Field rawCodeField;
-    private static Field primaryLevelUnicodeField;
-    private static Field extendedKeyCodeField;
     static {
         initIDs();
     }
@@ -398,20 +394,11 @@
 
     static Method m_sendMessage;
     static void sendEvent(final AWTEvent e) {
-        if (isPostedField == null) {
-            isPostedField = SunToolkit.getField(AWTEvent.class, "isPosted");
-        }
         // The uses of this method imply that the incoming event is system-generated
         SunToolkit.setSystemGenerated(e);
         PeerEvent pe = new PeerEvent(Toolkit.getDefaultToolkit(), new Runnable() {
                 public void run() {
-                    try {
-                        isPostedField.setBoolean(e, true);
-                    } catch (IllegalArgumentException e) {
-                        assert(false);
-                    } catch (IllegalAccessException e) {
-                        assert(false);
-                    }
+                    AWTAccessor.getAWTEventAccessor().setPosted(e);
                     ((Component)e.getSource()).dispatchEvent(e);
                 }
             }, PeerEvent.ULTIMATE_PRIORITY_EVENT);
@@ -1427,16 +1414,8 @@
     }
 
 
-    static Field bdata;
     static void setBData(KeyEvent e, byte[] data) {
-        try {
-            if (bdata == null) {
-                bdata = SunToolkit.getField(java.awt.AWTEvent.class, "bdata");
-            }
-            bdata.set(e, data);
-        } catch (IllegalAccessException ex) {
-            assert false;
-        }
+        AWTAccessor.getAWTEventAccessor().setBData(e, data);
     }
 
     public void postKeyEvent(int id, long when, int keyCode, int keyChar,
@@ -1446,15 +1425,6 @@
     {
         long jWhen = XToolkit.nowMillisUTC_offset(when);
         int modifiers = getModifiers(state, 0, keyCode);
-        if (rawCodeField == null) {
-            rawCodeField = XToolkit.getField(KeyEvent.class, "rawCode");
-        }
-        if (primaryLevelUnicodeField == null) {
-            primaryLevelUnicodeField = XToolkit.getField(KeyEvent.class, "primaryLevelUnicode");
-        }
-        if (extendedKeyCodeField == null) {
-            extendedKeyCodeField = XToolkit.getField(KeyEvent.class, "extendedKeyCode");
-        }
 
         KeyEvent ke = new KeyEvent((Component)getEventSource(), id, jWhen,
                                    modifiers, keyCode, (char)keyChar, keyLocation);
@@ -1462,15 +1432,11 @@
             byte[] data = Native.toBytes(event, eventSize);
             setBData(ke, data);
         }
-        try {
-            rawCodeField.set(ke, rawCode);
-            primaryLevelUnicodeField.set(ke, (long)unicodeFromPrimaryKeysym);
-            extendedKeyCodeField.set(ke, (long)extendedKeyCode);
-        } catch (IllegalArgumentException e) {
-            assert(false);
-        } catch (IllegalAccessException e) {
-            assert(false);
-        }
+
+        AWTAccessor.KeyEventAccessor kea = AWTAccessor.getKeyEventAccessor();
+        kea.setRawCode(ke, rawCode);
+        kea.setPrimaryLevelUnicode(ke, (long)unicodeFromPrimaryKeysym);
+        kea.setExtendedKeyCode(ke, (long)extendedKeyCode);
         postEventToEventQueue(ke);
     }
 
diff -r 1c775da99873 -r ffad06d70095 src/solaris/classes/sun/awt/X11/XlibWrapper.java
--- jdk/src/solaris/classes/sun/awt/X11/XlibWrapper.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/solaris/classes/sun/awt/X11/XlibWrapper.java	Sun Sep 23 23:43:31 2012 +0400
@@ -27,6 +27,7 @@
 
 import java.security.AccessController;
 import java.security.PrivilegedAction;
+import sun.security.action.GetPropertyAction;
 import sun.misc.*;
 
 final public class XlibWrapper
@@ -590,12 +591,8 @@
     static final boolean isBuildInternal;
 
     static {
-        String dataModelProp = (String)AccessController.doPrivileged(
-            new PrivilegedAction() {
-                    public Object run() {
-                        return System.getProperty("sun.arch.data.model");
-                    }
-                });
+        String dataModelProp = AccessController.doPrivileged(
+            new GetPropertyAction("sun.arch.data.model"));
         try {
             dataModel = Integer.parseInt(dataModelProp);
         } catch (Exception e) {
@@ -647,7 +644,8 @@
     }
 
     private static boolean getBuildInternal() {
-        String javaVersion = XToolkit.getSystemProperty("java.version");
+        String javaVersion = AccessController.doPrivileged(
+                                 new GetPropertyAction("java.version"));
         return javaVersion != null && javaVersion.contains("internal");
     }
 
diff -r 1c775da99873 -r ffad06d70095 src/windows/classes/sun/awt/windows/WCanvasPeer.java
--- jdk/src/windows/classes/sun/awt/windows/WCanvasPeer.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/windows/classes/sun/awt/windows/WCanvasPeer.java	Sun Sep 23 23:43:31 2012 +0400
@@ -27,7 +27,6 @@
 import java.awt.*;
 import java.awt.peer.*;
 import java.lang.ref.WeakReference;
-import java.lang.reflect.Method;
 import sun.awt.SunToolkit;
 import sun.awt.Win32GraphicsDevice;
 import sun.awt.PaintEventDispatcher;
diff -r 1c775da99873 -r ffad06d70095 src/windows/classes/sun/awt/windows/WMouseDragGestureRecognizer.java
--- jdk/src/windows/classes/sun/awt/windows/WMouseDragGestureRecognizer.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/windows/classes/sun/awt/windows/WMouseDragGestureRecognizer.java	Sun Sep 23 23:43:31 2012 +0400
@@ -39,8 +39,6 @@
 import java.awt.event.MouseListener;
 import java.awt.event.MouseMotionListener;
 
-import java.lang.reflect.*;
-
 import sun.awt.dnd.SunDragSourceContextPeer;
 
 /**
diff -r 1c775da99873 -r ffad06d70095 src/windows/classes/sun/awt/windows/WPopupMenuPeer.java
--- jdk/src/windows/classes/sun/awt/windows/WPopupMenuPeer.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/windows/classes/sun/awt/windows/WPopupMenuPeer.java	Sun Sep 23 23:43:31 2012 +0400
@@ -26,9 +26,7 @@
 
 import java.awt.*;
 import java.awt.peer.*;
-import java.lang.reflect.Field;
 
-import sun.awt.SunToolkit;
 import sun.awt.AWTAccessor;
 
 public class WPopupMenuPeer extends WMenuPeer implements PopupMenuPeer {
diff -r 1c775da99873 -r ffad06d70095 src/windows/classes/sun/awt/windows/WWindowPeer.java
--- jdk/src/windows/classes/sun/awt/windows/WWindowPeer.java	Tue Aug 07 12:10:45 2012 -0700
+++ jdk/src/windows/classes/sun/awt/windows/WWindowPeer.java	Sun Sep 23 23:43:31 2012 +0400
@@ -31,8 +31,6 @@
 
 import java.beans.*;
 
-import java.lang.reflect.*;
-
 import java.util.*;
 import java.util.List;
 import sun.util.logging.PlatformLogger;
diff -r 6aac89e84fc9 -r 1de4a0865a71 .hgtags
--- langtools/.hgtags	Tue Aug 07 12:11:16 2012 -0700
+++ langtools/.hgtags	Thu Sep 20 14:23:55 2012 -0700
@@ -197,3 +197,17 @@
 a35ca56cf8d09b92511f0cd71208a2ea05c8a338 jdk7u6-b21
 4f3aafa690d1fcb18693fc4085049eeffe4778f7 jdk7u6-b22
 dd3e29d8892fcaba6d76431d5fa9d49e7c088f76 jdk7u6-b23
+6aac89e84fc96d15bb78b13aa71c9e6b73d7237e jdk7u6-b24
+bcd1d067d525065630deb98b678bc00b499adbe1 jdk7u6-b30
+2d6017454236d4e95aad7feaff5fc92a612598f4 jdk7u7-b10
+27041587508dbc4e08c956ba98a11ce0d5608dc4 jdk7u7-b30
+b92a9f4f6bce4ec500ed3adb8203e6424b579f94 jdk7u7-b11
+f0fd7463f02ea681ca53022d6d0d425ec1584b34 jdk7u7-b31
+6bfc26fc14a0650805dd6583048db0b4f8669844 jdk7u7-b01
+0d4cb328938002fa9a2efc8190ea97beae3230a9 jdk7u7-b02
+04848e261e42c697cb70401f8059186434855f33 jdk7u9-b03
+0000000000000000000000000000000000000000 jdk7u7-b01
+6bfc26fc14a0650805dd6583048db0b4f8669844 jdk7u9-b01
+0000000000000000000000000000000000000000 jdk7u7-b02
+0d4cb328938002fa9a2efc8190ea97beae3230a9 jdk7u9-b02
+9148cdb9a18b55ad7d51bb9644b6db812de34eea jdk7u9-b04
