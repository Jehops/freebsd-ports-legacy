--- ./.hgtags	2010-03-18 01:40:42.000000000 -0700
+++ ./.hgtags	2010-03-20 11:11:41.000000000 -0700
@@ -60,3 +60,4 @@
 6880a3af9addb41541e80ebe8cde6f79ec402a58 jdk7-b83
 2f3ea057d1ad56cf3b269cdc4de2741411151982 jdk7-b84
 cf26288a114be67c39f2758959ce50b60f5ae330 jdk7-b85
+433a60a9c0bf1b26ee7e65cebaa89c541f497aed jdk7-b86
--- ./.jcheck/conf	2010-03-18 01:40:42.000000000 -0700
+++ ./.jcheck/conf	1969-12-31 16:00:00.000000000 -0800
@@ -1 +0,0 @@
-project=jdk7
--- ./corba/.hgtags	2010-03-18 01:40:50.000000000 -0700
+++ ./corba/.hgtags	2010-03-20 11:11:48.000000000 -0700
@@ -60,3 +60,4 @@
 fde0df7a2384f7fe33204a79678989807d9c2b98 jdk7-b83
 68c8961a82e4a3ad2a67991e5d834192a81eb4cd jdk7-b84
 c67a9df7bc0ca291f08f9a9cc05cb78ea15d25e6 jdk7-b85
+6253e28826d16cf1aecc39ce04c8de1f6bf2df5f jdk7-b86
--- ./corba/.jcheck/conf	2010-03-18 01:40:50.000000000 -0700
+++ ./corba/.jcheck/conf	1969-12-31 16:00:00.000000000 -0800
@@ -1 +0,0 @@
-project=jdk7
--- ./corba/make/common/Defs-bsd.gmk	2010-03-27 11:09:14.000000000 -0700
+++ ./corba/make/common/Defs-bsd.gmk	2009-11-14 12:49:01.000000000 -0800
@@ -25,7 +25,7 @@
 
 #
 # Makefile to specify compiler flags for programs and libraries
-# targeted to Bsd.  Should not contain any rules.
+# targeted to BSD.  Should not contain any rules.
 #
 
 # Warning: the following variables are overriden by Defs.gmk. Set
@@ -51,7 +51,7 @@
 endif # PLATFORM_SRC
 
 # platform specific include files
-PLATFORM_INCLUDE_NAME = $(PLATFORM)
+PLATFORM_INCLUDE_NAME = $(OS_NAME)
 PLATFORM_INCLUDE      = $(INCLUDEDIR)/$(PLATFORM_INCLUDE_NAME)
 
 # suffix used for make dependencies files.
@@ -92,9 +92,12 @@
 #    We need this frame pointer to make it easy to walk the stacks.
 #    This should be the default on X86, but ia64 and amd64 may not have this
 #    as the default.
-CFLAGS_REQUIRED_amd64   += -fno-omit-frame-pointer -D_LITTLE_ENDIAN
-CFLAGS_REQUIRED_i586    += -fno-omit-frame-pointer -D_LITTLE_ENDIAN
-CFLAGS_REQUIRED_ia64    += -fno-omit-frame-pointer -D_LITTLE_ENDIAN
+CFLAGS_REQUIRED_amd64   += -m64 -fno-omit-frame-pointer -D_LITTLE_ENDIAN
+LDFLAGS_COMMON_amd64    += -m64
+CFLAGS_REQUIRED_i586    += -m32 -fno-omit-frame-pointer -D_LITTLE_ENDIAN
+LDFLAGS_COMMON_i586     += -m32
+CFLAGS_REQUIRED_ia64    += -m64 -fno-omit-frame-pointer -D_LITTLE_ENDIAN
+LDFLAGS_COMMON_ia64     += -m64
 CFLAGS_REQUIRED_sparcv9 += -m64 -mcpu=v9
 LDFLAGS_COMMON_sparcv9  += -m64 -mcpu=v9
 CFLAGS_REQUIRED_sparc   += -m32 -mcpu=v9
@@ -109,6 +112,10 @@
   CFLAGS_REQUIRED       =  $(CFLAGS_REQUIRED_$(ARCH))
   LDFLAGS_COMMON        += $(LDFLAGS_COMMON_$(ARCH))
 endif
+ifeq ($(OS_VENDOR),Apple)
+  # 16-byte stack re-alignment on 32-bit Darwin
+  CFLAGS_REQUIRED_i586 += -mstackrealign
+endif
 
 # Add in platform specific optimizations for all opt levels
 CC_HIGHEST_OPT += $(_OPT_$(ARCH))
@@ -153,7 +160,7 @@
    CFLAGS_COMMON   += $(GLOBAL_KPIC) $(GCC_WARNINGS)
 endif
 
-# Bsd 64bit machines use Dwarf2, which can be HUGE, have fastdebug use -g1
+# BSD 64bit machines use Dwarf2, which can be HUGE, have fastdebug use -g1
 DEBUG_FLAG = -g
 ifeq ($(FASTDEBUG), true)
   ifeq ($(ARCH_DATA_MODEL), 64)
@@ -176,7 +183,7 @@
   CXXFLAGS_DBG	+= $(CC_LOWER_OPT)
 endif
 
-CPPFLAGS_COMMON = -D$(ARCH) -DARCH='"$(ARCH)"' -DBSD $(VERSION_DEFINES) \
+CPPFLAGS_COMMON = -D$(ARCH) -DARCH='"$(ARCH)"' -D_ALLBSD_SOURCE $(VERSION_DEFINES) \
 		  -D_LARGEFILE64_SOURCE -D_GNU_SOURCE -D_REENTRANT
 
 ifeq ($(ARCH_DATA_MODEL), 64)
@@ -186,33 +193,15 @@
 CPPFLAGS_OPT    = 
 CPPFLAGS_DBG    = -DDEBUG
 
-ifdef LIBRARY
-  # Libraries need to locate other libraries at runtime, and you can tell
-  #   a library where to look by way of the dynamic runpaths (RPATH or RUNPATH)
-  #   buried inside the .so. The $ORIGIN says to look relative to where
-  #   the library itself is and it can be followed with relative paths from
-  #   that. By default we always look in $ORIGIN, optionally we add relative
-  #   paths if the Makefile sets LD_RUNPATH_EXTRAS to those relative paths.
-  #   On Bsd we add a flag -z origin, not sure if this is necessary, but 
-  #   doesn't seem to hurt.
-  #   The environment variable LD_LIBRARY_PATH will over-ride these runpaths.
-  #   Try: 'readelf -d lib*.so' to see these settings in a library.
-  #
-  LDFLAGS_COMMON += -Xlinker -z -Xlinker origin -Xlinker -rpath -Xlinker \$$ORIGIN
-  LDFLAGS_COMMON += $(LD_RUNPATH_EXTRAS:%=-Xlinker -z -Xlinker origin -Xlinker -rpath -Xlinker \$$ORIGIN/%)
-endif
-
-EXTRA_LIBS += -lc
-
-LDFLAGS_DEFS_OPTION  = -Xlinker -z -Xlinker defs
-LDFLAGS_COMMON  += $(LDFLAGS_DEFS_OPTION)
-
 #
 # -L paths for finding and -ljava
 #
-LDFLAGS_OPT     = -Xlinker -O1
 LDFLAGS_COMMON += -L$(LIBDIR)/$(LIBARCH)
+
+ifneq ($(OS_VENDOR), Apple)
+LDFLAGS_OPT     = -Xlinker -O1
 LDFLAGS_COMMON += -Wl,-soname=$(LIB_PREFIX)$(LIBRARY).$(LIBRARY_SUFFIX)
+endif
 
 #
 # -static-libgcc is a gcc-3 flag to statically link libgcc, gcc-2.9x always
@@ -243,6 +232,11 @@
 #
 LD_MAPFILE_FLAG = -Xlinker --version-script -Xlinker
 
+# Darwin does not support linker map files.
+ifeq ($(OS_VENDOR), Apple)
+LDNOMAP=true
+endif
+
 #
 # Support for Quantify.
 #
@@ -278,7 +272,9 @@
 override HAVE_FILIOH             = false
 override HAVE_GETHRTIME          = false
 override HAVE_GETHRVTIME         = false
+ifeq ($(OS_VENDOR),Apple)
 override HAVE_SIGIGNORE          = true
+endif
 override LEX_LIBRARY             = -lfl
 ifeq ($(STATIC_CXX),true)
 override LIBCXX                  = -Wl,-Bstatic -lstdc++ -lgcc -Wl,-Bdynamic
@@ -290,12 +286,8 @@
 override LIBTHREAD               =
 override MOOT_PRIORITIES         = true
 override NO_INTERRUPTIBLE_IO     = true
-override OPENWIN_HOME            = /usr/X11R6
-ifeq ($(ARCH), amd64)
-override OPENWIN_LIB             = $(OPENWIN_HOME)/lib64
-else
+override OPENWIN_HOME            = $(X11_PATH)
 override OPENWIN_LIB             = $(OPENWIN_HOME)/lib
-endif
 override OTHER_M4FLAGS           = -D__GLIBC__ -DGNU_ASSEMBLER
 override SUN_CMM_SUBDIR          =
 override THREADS_FLAG            = native
--- ./corba/make/common/Defs-linux.gmk	2010-03-18 01:40:51.000000000 -0700
+++ ./corba/make/common/Defs-linux.gmk	2009-11-13 00:07:56.000000000 -0800
@@ -290,7 +290,7 @@
 override LIBTHREAD               =
 override MOOT_PRIORITIES         = true
 override NO_INTERRUPTIBLE_IO     = true
-override OPENWIN_HOME            = /usr/X11R6
+override OPENWIN_HOME            = $(X11_PATH)
 ifeq ($(ARCH), amd64)
 override OPENWIN_LIB             = $(OPENWIN_HOME)/lib64
 else
--- ./corba/make/common/Defs.gmk	2010-03-18 01:40:51.000000000 -0700
+++ ./corba/make/common/Defs.gmk	2009-10-05 22:35:11.000000000 -0700
@@ -53,6 +53,28 @@
 
 _OUTPUTDIR=$(TOPDIR)/build/$(PLATFORM)-$(ARCH)
 
+ifneq ($(PLATFORM), windows)
+  ifdef ALT_X11_PATH
+    X11_PATH = $(ALT_X11_PATH)
+  else
+    X11_PATH = /usr/X11R6
+  endif 
+
+  ifdef ALT_PACKAGE_PATH
+    PACKAGE_PATH = $(ALT_PACKAGE_PATH)
+  else
+    ifeq ($(PLATFORM), linux)
+      PACKAGE_PATH = /usr
+    else
+      ifeq ($(OS_VENDOR), Apple)
+        PACKAGE_PATH = /opt/local
+      else
+        PACKAGE_PATH = /usr/local
+      endif
+    endif
+  endif
+endif
+
 #
 # Get platform definitions
 #
@@ -97,6 +119,9 @@
     LDLIBS_COMMON = -ldl
   endif
 
+  ifeq ($(PLATFORM), bsd)
+    LDLIBS_COMMON = -pthread
+  endif
 endif # PROGRAM
 
 LDLIBS_COMMON += $(EXTRA_LIBS)
--- ./corba/make/common/Mapfile-vers.gmk	2010-03-18 01:40:51.000000000 -0700
+++ ./corba/make/common/Mapfile-vers.gmk	2009-06-06 16:47:35.000000000 -0700
@@ -77,7 +77,7 @@
 endif # PLATFORM
 
 
-ifeq ($(PLATFORM), linux)
+ifneq (,$(findstring $(PLATFORM), linux bsd))
 
 ifeq ($(VARIANT), OPT)
   # OPT build MUST have a mapfile?
--- ./corba/make/common/shared/Compiler-gcc.gmk	2010-03-18 01:40:51.000000000 -0700
+++ ./corba/make/common/shared/Compiler-gcc.gmk	2009-11-13 00:07:56.000000000 -0800
@@ -100,6 +100,23 @@
 
 endif
 
+ifeq ($(PLATFORM), bsd)
+  # Settings specific to BSD
+  CC             = $(COMPILER_PATH)gcc
+  CPP            = $(COMPILER_PATH)gcc -E
+  CXX            = $(COMPILER_PATH)g++
+  REQUIRED_CC_VER = 3.2
+
+# Option used to create a shared library
+ifeq ($(OS_VENDOR), Apple)
+  SHARED_LIBRARY_FLAG = -dynamiclib
+else
+  SHARED_LIBRARY_FLAG = -shared
+endif
+
+  SUN_COMP_VER := $(shell $(CC) --verbose 2>&1 )
+endif
+
 ifeq ($(PLATFORM), solaris)
 
   # Settings specific to Solaris
--- ./corba/make/common/shared/Compiler.gmk	2010-03-18 01:40:51.000000000 -0700
+++ ./corba/make/common/shared/Compiler.gmk	2009-06-06 16:47:35.000000000 -0700
@@ -42,6 +42,11 @@
   override CC_VERSION = gcc
 endif
 
+# BSD uses GNU compilers by default
+ifeq ($(PLATFORM), bsd)
+  override CC_VERSION = gcc
+endif
+
 # Get the compiler specific settings
 include $(BUILDDIR)/common/shared/Compiler-$(CC_VERSION).gmk
 
--- ./corba/make/common/shared/Defs-bsd.gmk	2010-03-27 11:09:14.000000000 -0700
+++ ./corba/make/common/shared/Defs-bsd.gmk	2009-06-06 16:47:35.000000000 -0700
@@ -54,7 +54,7 @@
 endef
 
 # Location on system where jdk installs might be
-USRJDKINSTANCES_PATH =/opt/java
+USRJDKINSTANCES_PATH =$(PACKAGE_PATH)
 
 # UNIXCOMMAND_PATH: path to where the most common Unix commands are.
 #  NOTE: Must end with / so that it could be empty, allowing PATH usage.
@@ -107,7 +107,7 @@
 ifneq "$(origin ALT_DEVTOOLS_PATH)" "undefined"
   DEVTOOLS_PATH :=$(call PrefixPath,$(ALT_DEVTOOLS_PATH))
 else
-  DEVTOOLS_PATH =/usr/bin/
+  DEVTOOLS_PATH =$(PACKAGE_PATH)/bin/
 endif
 
 # _BOOTDIR1: First choice for a Bootstrap JDK, previous released JDK.
--- ./corba/make/common/shared/Defs-utils.gmk	2010-03-18 01:40:51.000000000 -0700
+++ ./corba/make/common/shared/Defs-utils.gmk	2009-10-05 22:35:11.000000000 -0700
@@ -53,6 +53,13 @@
   UTILS_DEVTOOL_PATH=$(USRBIN_PATH)
 endif
 
+ifeq ($(PLATFORM),bsd)
+  UTILS_COMMAND_PATH=$(UNIXCOMMAND_PATH)
+  UTILS_USR_BIN_PATH=$(USRBIN_PATH)
+  UTILS_CCS_BIN_PATH=$(USRBIN_PATH)
+  UTILS_DEVTOOL_PATH=$(DEVTOOLS_PATH)
+endif
+
 ifeq ($(PLATFORM),solaris)
   UTILS_COMMAND_PATH=$(UNIXCOMMAND_PATH)
   UTILS_USR_BIN_PATH=$(UNIXCOMMAND_PATH)
@@ -198,3 +205,32 @@
   ECHO           = /usr/bin/echo
 endif
 
+# BSD specific
+ifeq ($(PLATFORM),bsd)
+  BASENAME     = $(UTILS_USR_BIN_PATH)basename
+  EGREP        = $(UTILS_USR_BIN_PATH)egrep
+  EXPR         = $(UTILS_COMMAND_PATH)expr
+  FMT          = $(UTILS_USR_BIN_PATH)fmt
+  GREP         = $(UTILS_USR_BIN_PATH)grep
+  GUNZIP       = $(UTILS_USR_BIN_PATH)gunzip
+  ID           = $(UTILS_USR_BIN_PATH)id
+  MSGFMT       = $(UTILS_DEVTOOL_PATH)msgfmt
+  SED          = $(UTILS_USR_BIN_PATH)sed
+  SORT         = $(UTILS_USR_BIN_PATH)sort
+  TEST         = $(UTILS_COMMAND_PATH)test
+  TOUCH        = $(UTILS_USR_BIN_PATH)touch
+  TRUE         = $(UTILS_USR_BIN_PATH)true
+  UNAME        = $(UTILS_USR_BIN_PATH)uname
+  # BSD OS_VENDOR specific
+  ifeq ($(OS_VENDOR), Apple)
+    NAWK       = $(UTILS_USR_BIN_PATH)awk
+    UNZIPSFX   = $(UTILS_USR_BIN_PATH)unzipsfx
+    ZIPEXE     = $(UTILS_USR_BIN_PATH)zip
+  else
+    UNZIP      = $(UTILS_DEVTOOL_PATH)unzip
+  endif
+  ifneq ($(OS_VENDOR), OpenBSD)
+    CPIO       = $(UTILS_USR_BIN_PATH)cpio
+    TAR        = $(UTILS_USR_BIN_PATH)tar
+  endif
+endif
--- ./corba/make/common/shared/Platform.gmk	2010-03-18 01:40:51.000000000 -0700
+++ ./corba/make/common/shared/Platform.gmk	2009-12-20 19:49:46.000000000 -0800
@@ -258,6 +258,101 @@
   MB_OF_MEMORY := $(shell free -m | fgrep Mem: | sed -e 's@\ \ *@ @g' | cut -d' ' -f2)
 endif
 
+ifeq ($(SYSTEM_UNAME), FreeBSD)
+  PLATFORM = bsd
+  OS_NAME = freebsd
+  OS_VENDOR = FreeBSD
+  REQUIRED_OS_VERSION = 6.0
+endif
+
+ifeq ($(SYSTEM_UNAME), Darwin)
+  PLATFORM = bsd
+  OS_NAME = darwin
+  OS_VENDOR = Apple
+  REQUIRED_OS_VERSION = 8.0
+endif
+
+ifeq ($(SYSTEM_UNAME), NetBSD)
+  PLATFORM = bsd
+  OS_NAME = netbsd
+  OS_VENDOR = NetBSD
+  REQUIRED_OS_VERSION = 3.0
+endif
+
+ifeq ($(SYSTEM_UNAME), OpenBSD)
+  PLATFORM = bsd
+  OS_NAME = openbsd
+  OS_VENDOR = OpenBSD
+  REQUIRED_OS_VERSION = 4.2
+endif
+
+# Platform settings specific to BSD
+ifeq ($(PLATFORM), bsd)
+  OS_VERSION := $(shell uname -r)
+  # Arch and OS name/version
+  mach := $(shell uname -m)
+  archExpr = case "$(mach)" in \
+                i[3-9]86) \
+                    echo i586 \
+                    ;; \
+                sparc64) \
+                    echo sparcv9 \
+                    ;; \
+                sparc*) \
+                    echo sparc \
+                    ;; \
+                x86_64) \
+                    echo amd64 \
+                    ;; \
+                "Power Macintosh") \
+                    echo ppc \
+                    ;; \
+                *) \
+                    echo $(mach) \
+                    ;; \
+      esac
+  ARCH        := $(shell $(archExpr) )
+  ARCH_FAMILY := $(ARCH)
+
+  # Darwin builds may be 32-bit or 64-bit data model.
+  ifeq ($(SYSTEM_UNAME), Darwin)
+    ifeq ($(ARCH), i586)
+      ifeq ($(ARCH_DATA_MODEL), 64)
+        ARCH=amd64
+      endif
+    endif
+  endif
+
+  # i586, sparc, and ppc are 32 bit, amd64 and sparc64 are 64
+  ifneq (,$(findstring $(ARCH), i586 sparc ppc))
+    ARCH_DATA_MODEL=32
+  else
+    ARCH_DATA_MODEL=64
+  endif
+
+  # Need to maintain the jre/lib/i386 location for 32-bit Intel
+  ifeq ($(ARCH), i586)
+    LIBARCH = i386
+  else
+    LIBARCH = $(ARCH)
+  endif
+
+  # Value of Java os.arch property
+  ARCHPROP  = $(LIBARCH)
+
+  # Suffix for file bundles used in previous release
+  BUNDLE_FILE_SUFFIX=.tar.gz
+  # Minimum disk space needed as determined by running 'du -sk' on 
+  #    a fully built workspace.
+  REQUIRED_FREE_SPACE=1500000
+  # How much RAM does this machine have:
+  ifeq ($(OS_VENDOR), OpenBSD)
+    MB_OF_MEMORY=$(shell sysctl -n hw.physmem | awk '{print int($$NF / 1048576); }' )
+  else
+    MB_OF_MEMORY=$(shell (sysctl -n hw.physmem64 2> /dev/null || sysctl -n hw.physmem) | awk '{print int($$NF / 1048576); }' )
+  endif
+endif
+
 # Windows with and without CYGWIN will be slightly different
 ifeq ($(SYSTEM_UNAME), Windows_NT)
   PLATFORM = windows
@@ -418,6 +513,18 @@
   export MAX_VM_MEMORY
 endif
 
+# for OpenBSD/i386 limit to 736 max
+ifeq ($(OS_VENDOR), OpenBSD)
+  ifeq ($(ARCH_DATA_MODEL), 32)
+    MAX_VM_MEMORY := $(shell \
+      if [ $(MAX_VM_MEMORY) -gt 736 ] ; then \
+        echo "736"; \
+      else \
+        echo "$(MAX_VM_MEMORY)" ; \
+      fi)
+  endif
+endif
+
 REQUIRED_ZIP_VER = 2.2
 REQUIRED_UNZIP_VER = 5.12
 REQUIRED_MAKE_VER = 3.78
--- ./corba/make/sun/corba/core/Makefile	2010-03-18 01:40:51.000000000 -0700
+++ ./corba/make/sun/corba/core/Makefile	2009-06-06 16:47:35.000000000 -0700
@@ -53,11 +53,19 @@
 ifdef STANDALONE_CORBA_WS
 # FIXUP: What is this all about?
 OTHER_LDFLAGS=-L$(BOOTDIR)/jre/lib/$(ARCH) -L$(BOOTDIR)/jre/lib/$(LIBARCH)/native_threads -ljvm
+ifeq ($(PLATFORM), bsd)
+OTHER_INCLUDES+=-ICClassHeaders -I$(BOOTDIR)/include -I$(BOOTDIR)/include/$(OS_NAME)
+else
 OTHER_INCLUDES+=-ICClassHeaders -I$(BOOTDIR)/include -I$(BOOTDIR)/include/$(PLATFORM)
+endif
 else
 OTHER_LDLIBS=$(JVMLIB)
+ifeq ($(PLATFORM), bsd)
+OTHER_INCLUDES+=-ICClassHeaders -I$(BOOTDIR)/include -I$(BOOTDIR)/include/$(OS_NAME)
+else
 OTHER_INCLUDES+=-ICClassHeaders -I$(BOOTDIR)/include -I$(BOOTDIR)/include/$(PLATFORM)
 endif
+endif
 
 
 FILES_c = ioser.c
--- ./corba/src/share/native/com/sun/corba/se/internal/io/ioser.c	2010-03-18 01:40:54.000000000 -0700
+++ ./corba/src/share/native/com/sun/corba/se/internal/io/ioser.c	2009-06-06 16:47:41.000000000 -0700
@@ -24,6 +24,7 @@
  */
 
 #include "jni.h"
+#include <stdint.h>
 
 #include "com_sun_corba_se_internal_io_IIOPInputStream.h"
 #include "com_sun_corba_se_internal_io_IIOPOutputStream.h"
@@ -643,7 +644,7 @@
 JNIEXPORT jobject JNICALL Java_com_sun_corba_se_internal_io_IIOPOutputStream_getObjectFieldOpt
   (JNIEnv *env, jobject this, jobject obj, jlong fieldID)
 {
-    return (*env)->GetObjectField(env, obj, (jfieldID)fieldID);
+    return (*env)->GetObjectField(env, obj, (jfieldID)(intptr_t)fieldID);
 }
 
 /*
@@ -654,7 +655,7 @@
 JNIEXPORT jboolean JNICALL Java_com_sun_corba_se_internal_io_IIOPOutputStream_getBooleanFieldOpt
   (JNIEnv *env, jobject this, jobject obj, jlong fieldID)
 {
-    return (*env)->GetBooleanField(env, obj, (jfieldID)fieldID);
+    return (*env)->GetBooleanField(env, obj, (jfieldID)(intptr_t)fieldID);
 }
 
 /*
@@ -665,7 +666,7 @@
 JNIEXPORT jbyte JNICALL Java_com_sun_corba_se_internal_io_IIOPOutputStream_getByteFieldOpt
   (JNIEnv *env, jobject this, jobject obj, jlong fieldID)
 {
-    return (*env)->GetByteField(env, obj, (jfieldID)fieldID);
+    return (*env)->GetByteField(env, obj, (jfieldID)(intptr_t)fieldID);
 
 }
 
@@ -677,7 +678,7 @@
 JNIEXPORT jchar JNICALL Java_com_sun_corba_se_internal_io_IIOPOutputStream_getCharFieldOpt
   (JNIEnv *env, jobject this, jobject obj, jlong fieldID)
 {
-    return (*env)->GetCharField(env, obj, (jfieldID)fieldID);
+    return (*env)->GetCharField(env, obj, (jfieldID)(intptr_t)fieldID);
 
 }
 
@@ -689,7 +690,7 @@
 JNIEXPORT jshort JNICALL Java_com_sun_corba_se_internal_io_IIOPOutputStream_getShortFieldOpt
   (JNIEnv *env, jobject this, jobject obj, jlong fieldID)
 {
-    return (*env)->GetShortField(env, obj, (jfieldID)fieldID);
+    return (*env)->GetShortField(env, obj, (jfieldID)(intptr_t)fieldID);
 }
 
 /*
@@ -700,7 +701,7 @@
 JNIEXPORT jint JNICALL Java_com_sun_corba_se_internal_io_IIOPOutputStream_getIntFieldOpt
   (JNIEnv *env, jobject this, jobject obj, jlong fieldID)
 {
-    return (*env)->GetIntField(env, obj, (jfieldID)fieldID);
+    return (*env)->GetIntField(env, obj, (jfieldID)(intptr_t)fieldID);
 
 }
 
@@ -713,7 +714,7 @@
 JNIEXPORT jlong JNICALL Java_com_sun_corba_se_internal_io_IIOPOutputStream_getLongFieldOpt
   (JNIEnv *env, jobject this, jobject obj, jlong fieldID)
 {
-    return (*env)->GetLongField(env, obj, (jfieldID)fieldID);
+    return (*env)->GetLongField(env, obj, (jfieldID)(intptr_t)fieldID);
 
 }
 
@@ -725,7 +726,7 @@
 JNIEXPORT jfloat JNICALL Java_com_sun_corba_se_internal_io_IIOPOutputStream_getFloatFieldOpt
   (JNIEnv *env, jobject this, jobject obj, jlong fieldID)
 {
-    return (*env)->GetFloatField(env, obj, (jfieldID)fieldID);
+    return (*env)->GetFloatField(env, obj, (jfieldID)(intptr_t)fieldID);
 
 }
 
@@ -737,7 +738,7 @@
 JNIEXPORT jdouble JNICALL Java_com_sun_corba_se_internal_io_IIOPOutputStream_getDoubleFieldOpt
   (JNIEnv *env, jobject this, jobject obj, jlong fieldID)
 {
-    return (*env)->GetDoubleField(env, obj, (jfieldID)fieldID);
+    return (*env)->GetDoubleField(env, obj, (jfieldID)(intptr_t)fieldID);
 
 }
 
@@ -751,7 +752,7 @@
 JNIEXPORT void JNICALL Java_com_sun_corba_se_internal_io_IIOPInputStream_setObjectFieldOpt
   (JNIEnv *env, jobject this, jobject obj, jlong fieldID, jobject v)
 {
-    (*env)->SetObjectField(env, obj, (jfieldID)fieldID, v);
+    (*env)->SetObjectField(env, obj, (jfieldID)(intptr_t)fieldID, v);
 }
 
 /*
@@ -762,7 +763,7 @@
 JNIEXPORT void JNICALL Java_com_sun_corba_se_internal_io_IIOPInputStream_setBooleanFieldOpt
   (JNIEnv *env, jobject this, jobject obj, jlong fieldID, jboolean v)
 {
-    (*env)->SetBooleanField(env, obj, (jfieldID)fieldID, v);
+    (*env)->SetBooleanField(env, obj, (jfieldID)(intptr_t)fieldID, v);
 }
 
 /*
@@ -773,7 +774,7 @@
 JNIEXPORT void JNICALL Java_com_sun_corba_se_internal_io_IIOPInputStream_setByteFieldOpt
   (JNIEnv *env, jobject this, jobject obj, jlong fieldID, jbyte v)
 {
-    (*env)->SetByteField(env, obj, (jfieldID)fieldID, v);
+    (*env)->SetByteField(env, obj, (jfieldID)(intptr_t)fieldID, v);
 }
 
 /*
@@ -784,7 +785,7 @@
 JNIEXPORT void JNICALL Java_com_sun_corba_se_internal_io_IIOPInputStream_setCharFieldOpt
   (JNIEnv *env, jobject this, jobject obj, jlong fieldID, jchar v)
 {
-    (*env)->SetCharField(env, obj, (jfieldID)fieldID, v);
+    (*env)->SetCharField(env, obj, (jfieldID)(intptr_t)fieldID, v);
 }
 
 /*
@@ -795,7 +796,7 @@
 JNIEXPORT void JNICALL Java_com_sun_corba_se_internal_io_IIOPInputStream_setShortFieldOpt
   (JNIEnv *env, jobject this, jobject obj, jlong fieldID, jshort v)
 {
-    (*env)->SetShortField(env, obj, (jfieldID)fieldID, v);
+    (*env)->SetShortField(env, obj, (jfieldID)(intptr_t)fieldID, v);
 }
 
 /*
@@ -806,7 +807,7 @@
 JNIEXPORT void JNICALL Java_com_sun_corba_se_internal_io_IIOPInputStream_setIntFieldOpt
   (JNIEnv *env, jobject this, jobject obj, jlong fieldID, jint v)
 {
-  (*env)->SetIntField(env, obj, (jfieldID)fieldID, v);
+  (*env)->SetIntField(env, obj, (jfieldID)(intptr_t)fieldID, v);
 }
 
 /*
@@ -817,7 +818,7 @@
 JNIEXPORT void JNICALL Java_com_sun_corba_se_internal_io_IIOPInputStream_setLongFieldOpt
   (JNIEnv *env, jobject this, jobject obj, jlong fieldID, jlong v)
 {
-    (*env)->SetLongField(env, obj, (jfieldID)fieldID, v);
+    (*env)->SetLongField(env, obj, (jfieldID)(intptr_t)fieldID, v);
 }
 
 /*
@@ -828,7 +829,7 @@
 JNIEXPORT void JNICALL Java_com_sun_corba_se_internal_io_IIOPInputStream_setFloatFieldOpt
   (JNIEnv *env, jobject this, jobject obj, jlong fieldID, jfloat v)
 {
-    (*env)->SetFloatField(env, obj, (jfieldID)fieldID, v);
+    (*env)->SetFloatField(env, obj, (jfieldID)(intptr_t)fieldID, v);
 }
 
 /*
@@ -839,7 +840,7 @@
 JNIEXPORT void JNICALL Java_com_sun_corba_se_internal_io_IIOPInputStream_setDoubleFieldOpt
   (JNIEnv *env, jobject this, jobject obj, jlong fieldID, jdouble v)
 {
-    (*env)->SetDoubleField(env, obj, (jfieldID)fieldID, v);
+    (*env)->SetDoubleField(env, obj, (jfieldID)(intptr_t)fieldID, v);
 }
 
 /*
@@ -858,5 +859,5 @@
     (*env)->ReleaseStringUTFChars(env, fieldName, strFieldName);
     (*env)->ReleaseStringUTFChars(env, fieldSig, strFieldSig);
 
-    return (jlong)fieldID;
+    return (jlong)(intptr_t)fieldID;
 }
--- ./hotspot/.hgtags	2010-03-18 01:41:32.000000000 -0700
+++ ./hotspot/.hgtags	2010-03-20 11:11:57.000000000 -0700
@@ -83,3 +83,4 @@
 ffc8d176b84bcfb5ac21302b4feb3b0c0d69b97c jdk7-b84
 6c9796468b91dcbb39e09dfa1baf9779ac45eb66 jdk7-b85
 418bc80ce13995149eadc9eecbba21d7a9fa02ae hs17-b10
+bf823ef06b4f211e66988d76a2e2669be5c0820e jdk7-b86
--- ./hotspot/.jcheck/conf	2010-03-18 01:41:32.000000000 -0700
+++ ./hotspot/.jcheck/conf	1969-12-31 16:00:00.000000000 -0800
@@ -1 +0,0 @@
-project=jdk7
--- ./hotspot/agent/make/Makefile	2010-03-18 01:41:32.000000000 -0700
+++ ./hotspot/agent/make/Makefile	2009-06-06 16:53:52.000000000 -0700
@@ -52,6 +52,9 @@
 sun.jvm.hotspot.compiler \
 sun.jvm.hotspot.debugger \
 sun.jvm.hotspot.debugger.amd64 \
+sun.jvm.hotspot.debugger.bsd \
+sun.jvm.hotspot.debugger.bsd.amd64 \
+sun.jvm.hotspot.debugger.bsd.x86 \
 sun.jvm.hotspot.debugger.cdbg \
 sun.jvm.hotspot.debugger.cdbg.basic \
 sun.jvm.hotspot.debugger.cdbg.basic.amd64 \
@@ -94,6 +97,9 @@
 sun.jvm.hotspot.oops \
 sun.jvm.hotspot.runtime \
 sun.jvm.hotspot.runtime.amd64 \
+sun.jvm.hotspot.runtime.bsd \
+sun.jvm.hotspot.runtime.bsd_amd64 \
+sun.jvm.hotspot.runtime.bsd_x86 \
 sun.jvm.hotspot.runtime.ia64 \
 sun.jvm.hotspot.runtime.linux \
 sun.jvm.hotspot.runtime.linux_amd64 \
@@ -143,6 +149,8 @@
 sun/jvm/hotspot/compiler/*.java \
 sun/jvm/hotspot/debugger/*.java \
 sun/jvm/hotspot/debugger/amd64/*.java \
+sun/jvm/hotspot/debugger/bsd/*.java \
+sun/jvm/hotspot/debugger/bsd/x86/*.java \
 sun/jvm/hotspot/debugger/cdbg/*.java \
 sun/jvm/hotspot/debugger/cdbg/basic/*.java \
 sun/jvm/hotspot/debugger/cdbg/basic/amd64/*.java \
--- ./hotspot/agent/src/os/bsd/BsdDebuggerLocal.c	2010-03-27 11:09:09.000000000 -0700
+++ ./hotspot/agent/src/os/bsd/BsdDebuggerLocal.c	2009-06-06 16:53:52.000000000 -0700
@@ -22,6 +22,7 @@
  *
  */
 
+#include <stdlib.h>
 #include <jni.h>
 #include "libproc.h"
 
@@ -73,7 +74,7 @@
   (JNIEnv *env, jclass cls) {
   jclass listClass;
 
-  if (init_libproc(getenv("LIBSAPROC_DEBUG")) != true) {
+  if (init_libproc(getenv("LIBSAPROC_DEBUG") != NULL) != true) {
      THROW_NEW_DEBUGGER_EXCEPTION("can't initialize libproc");
   }
 
@@ -275,7 +276,7 @@
   bufPtr = (*env)->GetByteArrayElements(env, array, &isCopy);
   CHECK_EXCEPTION_(0);
 
-  err = ps_pdread(get_proc_handle(env, this_obj), (psaddr_t) (uintptr_t)addr, bufPtr, numBytes);
+  err = ps_pread(get_proc_handle(env, this_obj), (psaddr_t) (uintptr_t)addr, bufPtr, numBytes);
   (*env)->ReleaseByteArrayElements(env, array, bufPtr, 0);
   return (err == PS_OK)? array : 0;
 }
@@ -283,11 +284,10 @@
 JNIEXPORT jlongArray JNICALL Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_getThreadIntegerRegisterSet0
   (JNIEnv *env, jobject this_obj, jint lwp_id) {
 
-  struct user_regs_struct gregs;
+  struct reg gregs;
   jboolean isCopy;
   jlongArray array;
   jlong *regs;
-  int i;
 
   struct ps_prochandle* ph = get_proc_handle(env, this_obj);
   if (get_lwp_regs(ph, lwp_id, &gregs) != true) {
@@ -317,26 +317,27 @@
 #ifdef i386
 #define REG_INDEX(reg) sun_jvm_hotspot_debugger_x86_X86ThreadContext_##reg
 
-  regs[REG_INDEX(GS)]  = (uintptr_t) gregs.xgs;
-  regs[REG_INDEX(FS)]  = (uintptr_t) gregs.xfs;
-  regs[REG_INDEX(ES)]  = (uintptr_t) gregs.xes;
-  regs[REG_INDEX(DS)]  = (uintptr_t) gregs.xds;
-  regs[REG_INDEX(EDI)] = (uintptr_t) gregs.edi;
-  regs[REG_INDEX(ESI)] = (uintptr_t) gregs.esi;
-  regs[REG_INDEX(FP)] = (uintptr_t) gregs.ebp;
-  regs[REG_INDEX(SP)] = (uintptr_t) gregs.esp;
-  regs[REG_INDEX(EBX)] = (uintptr_t) gregs.ebx;
-  regs[REG_INDEX(EDX)] = (uintptr_t) gregs.edx;
-  regs[REG_INDEX(ECX)] = (uintptr_t) gregs.ecx;
-  regs[REG_INDEX(EAX)] = (uintptr_t) gregs.eax;
-  regs[REG_INDEX(PC)] = (uintptr_t) gregs.eip;
-  regs[REG_INDEX(CS)]  = (uintptr_t) gregs.xcs;
-  regs[REG_INDEX(SS)]  = (uintptr_t) gregs.xss;
+  regs[REG_INDEX(GS)]  = (uintptr_t) gregs.r_gs;
+  regs[REG_INDEX(FS)]  = (uintptr_t) gregs.r_fs;
+  regs[REG_INDEX(ES)]  = (uintptr_t) gregs.r_es;
+  regs[REG_INDEX(DS)]  = (uintptr_t) gregs.r_ds;
+  regs[REG_INDEX(EDI)] = (uintptr_t) gregs.r_edi;
+  regs[REG_INDEX(ESI)] = (uintptr_t) gregs.r_esi;
+  regs[REG_INDEX(FP)] = (uintptr_t) gregs.r_ebp;
+  regs[REG_INDEX(SP)] = (uintptr_t) gregs.r_isp;
+  regs[REG_INDEX(EBX)] = (uintptr_t) gregs.r_ebx;
+  regs[REG_INDEX(EDX)] = (uintptr_t) gregs.r_edx;
+  regs[REG_INDEX(ECX)] = (uintptr_t) gregs.r_ecx;
+  regs[REG_INDEX(EAX)] = (uintptr_t) gregs.r_eax;
+  regs[REG_INDEX(PC)] = (uintptr_t) gregs.r_eip;
+  regs[REG_INDEX(CS)]  = (uintptr_t) gregs.r_cs;
+  regs[REG_INDEX(SS)]  = (uintptr_t) gregs.r_ss;
 
 #endif /* i386 */
 
 #if ia64
   regs = (*env)->GetLongArrayElements(env, array, &isCopy);
+  int i;
   for (i = 0; i < NPRGREG; i++ ) {
     regs[i] = 0xDEADDEAD;
   }
@@ -345,31 +346,31 @@
 #ifdef amd64
 #define REG_INDEX(reg) sun_jvm_hotspot_debugger_amd64_AMD64ThreadContext_##reg
 
-  regs[REG_INDEX(R15)] = gregs.r15;
-  regs[REG_INDEX(R14)] = gregs.r14;
-  regs[REG_INDEX(R13)] = gregs.r13;
-  regs[REG_INDEX(R12)] = gregs.r12;
-  regs[REG_INDEX(RBP)] = gregs.rbp;
-  regs[REG_INDEX(RBX)] = gregs.rbx;
-  regs[REG_INDEX(R11)] = gregs.r11;
-  regs[REG_INDEX(R10)] = gregs.r10;
-  regs[REG_INDEX(R9)] = gregs.r9;
-  regs[REG_INDEX(R8)] = gregs.r8;
-  regs[REG_INDEX(RAX)] = gregs.rax;
-  regs[REG_INDEX(RCX)] = gregs.rcx;
-  regs[REG_INDEX(RDX)] = gregs.rdx;
-  regs[REG_INDEX(RSI)] = gregs.rsi;
-  regs[REG_INDEX(RDI)] = gregs.rdi;
-  regs[REG_INDEX(RIP)] = gregs.rip;
-  regs[REG_INDEX(CS)] = gregs.cs;
-  regs[REG_INDEX(RSP)] = gregs.rsp;
-  regs[REG_INDEX(SS)] = gregs.ss;
-  regs[REG_INDEX(FSBASE)] = gregs.fs_base;
-  regs[REG_INDEX(GSBASE)] = gregs.gs_base;
-  regs[REG_INDEX(DS)] = gregs.ds;
-  regs[REG_INDEX(ES)] = gregs.es;
-  regs[REG_INDEX(FS)] = gregs.fs;
-  regs[REG_INDEX(GS)] = gregs.gs;
+  regs[REG_INDEX(R15)] = gregs.r_r15;
+  regs[REG_INDEX(R14)] = gregs.r_r14;
+  regs[REG_INDEX(R13)] = gregs.r_r13;
+  regs[REG_INDEX(R12)] = gregs.r_r12;
+  regs[REG_INDEX(RBP)] = gregs.r_rbp;
+  regs[REG_INDEX(RBX)] = gregs.r_rbx;
+  regs[REG_INDEX(R11)] = gregs.r_r11;
+  regs[REG_INDEX(R10)] = gregs.r_r10;
+  regs[REG_INDEX(R9)] = gregs.r_r9;
+  regs[REG_INDEX(R8)] = gregs.r_r8;
+  regs[REG_INDEX(RAX)] = gregs.r_rax;
+  regs[REG_INDEX(RCX)] = gregs.r_rcx;
+  regs[REG_INDEX(RDX)] = gregs.r_rdx;
+  regs[REG_INDEX(RSI)] = gregs.r_rsi;
+  regs[REG_INDEX(RDI)] = gregs.r_rdi;
+  regs[REG_INDEX(RIP)] = gregs.r_rip;
+  regs[REG_INDEX(CS)] = gregs.r_cs;
+  regs[REG_INDEX(RSP)] = gregs.r_rsp;
+  regs[REG_INDEX(SS)] = gregs.r_ss;
+//  regs[REG_INDEX(FSBASE)] = gregs.fs_base;
+//  regs[REG_INDEX(GSBASE)] = gregs.gs_base;
+//  regs[REG_INDEX(DS)] = gregs.ds;
+//  regs[REG_INDEX(ES)] = gregs.es;
+//  regs[REG_INDEX(FS)] = gregs.fs;
+//  regs[REG_INDEX(GS)] = gregs.gs;
 
 #endif /* amd64 */
 
--- ./hotspot/agent/src/os/bsd/Makefile	2010-03-27 11:09:09.000000000 -0700
+++ ./hotspot/agent/src/os/bsd/Makefile	2009-10-05 21:49:06.000000000 -0700
@@ -19,10 +19,10 @@
 # Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
 # CA 95054 USA or visit www.sun.com if you need additional information or
 # have any questions.
-#  
+# 
 #
 
-ARCH := $(shell if ([ `uname -m` = "ia64" ])  ; then echo ia64 ; elif ([ `uname -m` = "x86_64" ]) ; then echo amd64; elif ([ `uname -m` = "sparc64" ]) ; then echo sparc; else echo i386 ; fi )
+ARCH := $(shell if ([ `uname -m` = "ia64" ])  ; then echo ia64 ; elif ([ `uname -m` = "amd64" ]) ; then echo amd64; elif ([ `uname -m` = "sparc64" ]) ; then echo sparc; else echo i386 ; fi )
 GCC      = gcc
 
 JAVAH    = ${JAVA_HOME}/bin/javah
@@ -32,25 +32,25 @@
 	libproc_impl.c  \
 	ps_proc.c       \
 	ps_core.c       \
-	BsdDebuggerLocal.c 
+	hsearch_r.c     \
+	BsdDebuggerLocal.c
 
-INCLUDES = -I${JAVA_HOME}/include -I${JAVA_HOME}/include/bsd 
+INCLUDES = -I${JAVA_HOME}/include -I${JAVA_HOME}/include/$(shell uname -s | tr "[:upper:]" "[:lower:]")
 
 OBJS     = $(SOURCES:.c=.o)
 
-LIBS     = -lthread_db
+LIBS     = -lutil -lthread_db
 
-CFLAGS   = -c -fPIC -g -D_GNU_SOURCE -D$(ARCH) $(INCLUDES)
+CFLAGS   = -c -fPIC -g -Wall -D_ALLBSD_SOURCE -D_GNU_SOURCE -D$(ARCH) $(INCLUDES)
 
 LIBSA = $(ARCH)/libsaproc.so
 
 all: $(LIBSA)
 
 BsdDebuggerLocal.o: BsdDebuggerLocal.c
-	$(JAVAH) -jni -classpath ../../../build/classes  \
+	$(JAVAH) -jni -classpath ../../../../../build/bsd-i586/hotspot/outputdir/bsd_i486_compiler2/generated/saclasses  \
 		sun.jvm.hotspot.debugger.x86.X86ThreadContext \
-		sun.jvm.hotspot.debugger.sparc.SPARCThreadContext \
-		sun.jvm.hotspot.debugger.amd64.AMD64ThreadContext 
+		sun.jvm.hotspot.debugger.amd64.AMD64ThreadContext
 	$(GCC) $(CFLAGS) $<
 
 .c.obj:
@@ -60,26 +60,19 @@
   LFLAGS_LIBSA = -Xlinker --version-script=mapfile
 endif
 
-# If this is a --hash-style=gnu system, use --hash-style=both
-#   The gnu .hash section won't work on some Bsd systems like SuSE 10.
-_HAS_HASH_STYLE_GNU:=$(shell $(CC) -dumpspecs | grep -- '--hash-style=gnu')
-ifneq ($(_HAS_HASH_STYLE_GNU),)
-  LDFLAGS_HASH_STYLE = -Wl,--hash-style=both
-endif
-LFLAGS_LIBSA += $(LDFLAGS_HASH_STYLE)
-
 $(LIBSA): $(OBJS) mapfile
 	if [ ! -d $(ARCH) ] ; then mkdir $(ARCH) ; fi
 	$(GCC) -shared $(LFLAGS_LIBSA) -o $(LIBSA) $(OBJS) $(LIBS)
 
-test.o: test.c
+test.o: $(LIBSA) test.c
 	$(GCC) -c -o test.o -g -D_GNU_SOURCE -D$(ARCH) $(INCLUDES) test.c
 
 test: test.o
 	$(GCC) -o test test.o -L$(ARCH) -lsaproc $(LIBS)
 
 clean:
-	rm -rf $(LIBSA)
-	rm -rf $(OBJS)
-	rmdir $(ARCH)
+	rm -f $(LIBSA)
+	rm -f $(OBJS)
+	rm -f test.o
+	-rmdir $(ARCH)
 
--- ./hotspot/agent/src/os/bsd/StubDebuggerLocal.c	1969-12-31 16:00:00.000000000 -0800
+++ ./hotspot/agent/src/os/bsd/StubDebuggerLocal.c	2009-06-06 16:53:52.000000000 -0700
@@ -0,0 +1,120 @@
+/*
+ * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
+ * CA 95054 USA or visit www.sun.com if you need additional information or
+ * have any questions.
+ *
+ */
+
+#include <stdlib.h>
+#include <jni.h>
+
+#define CHECK_EXCEPTION_(value) if ((*env)->ExceptionOccurred(env)) { return value; }
+#define CHECK_EXCEPTION if ((*env)->ExceptionOccurred(env)) { return;}
+#define THROW_NEW_DEBUGGER_EXCEPTION_(str, value) { throw_new_debugger_exception(env, str); return value; }
+#define THROW_NEW_DEBUGGER_EXCEPTION(str) { throw_new_debugger_exception(env, str); return;}
+
+static void throw_new_debugger_exception(JNIEnv* env, const char* errMsg) {
+  (*env)->ThrowNew(env, (*env)->FindClass(env, "sun/jvm/hotspot/debugger/DebuggerException"), errMsg);
+}
+
+/*
+ * Class:     sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal
+ * Method:    init0
+ * Signature: ()V
+ */
+JNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_init0
+  (JNIEnv *env, jclass cls) {
+}
+
+JNIEXPORT jint JNICALL Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_getAddressSize
+  (JNIEnv *env, jclass cls)
+{
+#ifdef _LP64
+ return 8;
+#else
+ return 4;
+#endif
+
+}
+
+/*
+ * Class:     sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal
+ * Method:    attach0
+ * Signature: (I)V
+ */
+JNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_attach0__I
+  (JNIEnv *env, jobject this_obj, jint jpid) {
+
+  THROW_NEW_DEBUGGER_EXCEPTION("Can't attach to the process");
+}
+
+/*
+ * Class:     sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal
+ * Method:    attach0
+ * Signature: (Ljava/lang/String;Ljava/lang/String;)V
+ */
+JNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_attach0__Ljava_lang_String_2Ljava_lang_String_2
+  (JNIEnv *env, jobject this_obj, jstring execName, jstring coreName) {
+  THROW_NEW_DEBUGGER_EXCEPTION("Can't attach to the core file");
+}
+
+/*
+ * Class:     sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal
+ * Method:    detach0
+ * Signature: ()V
+ */
+JNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_detach0
+  (JNIEnv *env, jobject this_obj) {
+}
+
+/*
+ * Class:     sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal
+ * Method:    lookupByName0
+ * Signature: (Ljava/lang/String;Ljava/lang/String;)J
+ */
+JNIEXPORT jlong JNICALL Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_lookupByName0
+  (JNIEnv *env, jobject this_obj, jstring objectName, jstring symbolName) {
+  return 0;
+}
+
+/*
+ * Class:     sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal
+ * Method:    lookupByAddress0
+ * Signature: (J)Lsun/jvm/hotspot/debugger/cdbg/ClosestSymbol;
+ */
+JNIEXPORT jobject JNICALL Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_lookupByAddress0
+  (JNIEnv *env, jobject this_obj, jlong addr) {
+  return 0;
+}
+
+/*
+ * Class:     sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal
+ * Method:    readBytesFromProcess0
+ * Signature: (JJ)Lsun/jvm/hotspot/debugger/ReadResult;
+ */
+JNIEXPORT jbyteArray JNICALL Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_readBytesFromProcess0
+  (JNIEnv *env, jobject this_obj, jlong addr, jlong numBytes) {
+  return 0;
+}
+
+JNIEXPORT jlongArray JNICALL Java_sun_jvm_hotspot_debugger_bsd_BsdDebuggerLocal_getThreadIntegerRegisterSet0
+  (JNIEnv *env, jobject this_obj, jint lwp_id) {
+  return 0;
+}
--- ./hotspot/agent/src/os/bsd/elfmacros.h	2010-03-27 11:09:09.000000000 -0700
+++ ./hotspot/agent/src/os/bsd/elfmacros.h	2009-06-06 16:53:52.000000000 -0700
@@ -25,16 +25,19 @@
 #ifndef _ELFMACROS_H_
 #define _ELFMACROS_H_
 
+#define ELF_NHDR        Elf_Note
+
 #if defined(_LP64)
 #define ELF_EHDR        Elf64_Ehdr
 #define ELF_SHDR        Elf64_Shdr
 #define ELF_PHDR        Elf64_Phdr
 #define ELF_SYM         Elf64_Sym
-#define ELF_NHDR        Elf64_Nhdr
 #define ELF_DYN         Elf64_Dyn
 #define ELF_ADDR        Elf64_Addr
 
+#ifndef ELF_ST_TYPE
 #define ELF_ST_TYPE     ELF64_ST_TYPE
+#endif
 
 #else
 
@@ -42,11 +45,12 @@
 #define ELF_SHDR        Elf32_Shdr
 #define ELF_PHDR        Elf32_Phdr
 #define ELF_SYM         Elf32_Sym
-#define ELF_NHDR        Elf32_Nhdr
 #define ELF_DYN         Elf32_Dyn
 #define ELF_ADDR        Elf32_Addr
 
+#ifndef ELF_ST_TYPE
 #define ELF_ST_TYPE     ELF32_ST_TYPE
+#endif
 
 #endif
 
--- ./hotspot/agent/src/os/bsd/hsearch_r.c	1969-12-31 16:00:00.000000000 -0800
+++ ./hotspot/agent/src/os/bsd/hsearch_r.c	2009-06-06 16:53:52.000000000 -0700
@@ -0,0 +1,217 @@
+/* Copyright (C) 1993,1995-1997,2002,2005,2007,2008
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@gnu.ai.mit.edu>, 1993.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <search.h>
+
+#include "hsearch_r.h"
+
+#define __set_errno(ERRNO) errno = ERRNO
+
+/* [Aho,Sethi,Ullman] Compilers: Principles, Techniques and Tools, 1986
+   [Knuth]            The Art of Computer Programming, part 3 (6.4)  */
+
+
+/* The reentrant version has no static variables to maintain the state.
+   Instead the interface of all functions is extended to take an argument
+   which describes the current status.  */
+typedef struct _ENTRY
+{
+  unsigned int used;
+  ENTRY entry;
+}
+_ENTRY;
+
+
+/* For the used double hash method the table size has to be a prime. To
+   correct the user given table size we need a prime test.  This trivial
+   algorithm is adequate because
+   a)  the code is (most probably) called a few times per program run and
+   b)  the number is small because the table must fit in the core  */
+static int
+isprime (unsigned int number)
+{
+  /* no even number will be passed */
+  unsigned int div = 3;
+
+  while (div * div < number && number % div != 0)
+    div += 2;
+
+  return number % div != 0;
+}
+
+
+/* Before using the hash table we must allocate memory for it.
+   Test for an existing table are done. We allocate one element
+   more as the found prime number says. This is done for more effective
+   indexing as explained in the comment for the hsearch function.
+   The contents of the table is zeroed, especially the field used
+   becomes zero.  */
+int
+hcreate_r (size_t nel, struct hsearch_data *htab)
+{
+  /* Test for correct arguments.  */
+  if (htab == NULL)
+    {
+      __set_errno (EINVAL);
+      return 0;
+    }
+
+  /* There is still another table active. Return with error. */
+  if (htab->table != NULL)
+    return 0;
+
+  /* Change nel to the first prime number not smaller as nel. */
+  nel |= 1;      /* make odd */
+  while (!isprime (nel))
+    nel += 2;
+
+  htab->size = nel;
+  htab->filled = 0;
+
+  /* allocate memory and zero out */
+  htab->table = (_ENTRY *) calloc (htab->size + 1, sizeof (_ENTRY));
+  if (htab->table == NULL)
+    return 0;
+
+  /* everything went alright */
+  return 1;
+}
+
+
+/* After using the hash table it has to be destroyed. The used memory can
+   be freed and the local static variable can be marked as not used.  */
+void
+hdestroy_r (struct hsearch_data *htab)
+{
+  /* Test for correct arguments.  */
+  if (htab == NULL)
+    {
+      __set_errno (EINVAL);
+      return;
+    }
+
+  /* Free used memory.  */
+  free (htab->table);
+
+  /* the sign for an existing table is an value != NULL in htable */
+  htab->table = NULL;
+}
+
+
+/* This is the search function. It uses double hashing with open addressing.
+   The argument item.key has to be a pointer to an zero terminated, most
+   probably strings of chars. The function for generating a number of the
+   strings is simple but fast. It can be replaced by a more complex function
+   like ajw (see [Aho,Sethi,Ullman]) if the needs are shown.
+
+   We use an trick to speed up the lookup. The table is created by hcreate
+   with one more element available. This enables us to use the index zero
+   special. This index will never be used because we store the first hash
+   index in the field used where zero means not used. Every other value
+   means used. The used field can be used as a first fast comparison for
+   equality of the stored and the parameter value. This helps to prevent
+   unnecessary expensive calls of strcmp.  */
+int
+hsearch_r (ENTRY item, ACTION action, ENTRY **retval, struct hsearch_data *htab)
+{
+  unsigned int hval;
+  unsigned int count;
+  unsigned int len = strlen (item.key);
+  unsigned int idx;
+
+  /* Compute an value for the given string. Perhaps use a better method. */
+  hval = len;
+  count = len;
+  while (count-- > 0)
+    {
+      hval <<= 4;
+      hval += item.key[count];
+    }
+
+  /* First hash function: simply take the modul but prevent zero. */
+  idx = hval % htab->size + 1;
+
+  if (htab->table[idx].used)
+    {
+      /* Further action might be required according to the action value. */
+      if (htab->table[idx].used == hval
+	  && strcmp (item.key, htab->table[idx].entry.key) == 0)
+	{
+	  *retval = &htab->table[idx].entry;
+	  return 1;
+	}
+
+      /* Second hash function, as suggested in [Knuth] */
+      unsigned int hval2 = 1 + hval % (htab->size - 2);
+      unsigned int first_idx = idx;
+
+      do
+	{
+	  /* Because SIZE is prime this guarantees to step through all
+             available indeces.  */
+          if (idx <= hval2)
+	    idx = htab->size + idx - hval2;
+	  else
+	    idx -= hval2;
+
+	  /* If we visited all entries leave the loop unsuccessfully.  */
+	  if (idx == first_idx)
+	    break;
+
+            /* If entry is found use it. */
+          if (htab->table[idx].used == hval
+	      && strcmp (item.key, htab->table[idx].entry.key) == 0)
+	    {
+	      *retval = &htab->table[idx].entry;
+	      return 1;
+	    }
+	}
+      while (htab->table[idx].used);
+    }
+
+  /* An empty bucket has been found. */
+  if (action == ENTER)
+    {
+      /* If table is full and another entry should be entered return
+	 with error.  */
+      if (htab->filled == htab->size)
+	{
+	  __set_errno (ENOMEM);
+	  *retval = NULL;
+	  return 0;
+	}
+
+      htab->table[idx].used  = hval;
+      htab->table[idx].entry = item;
+
+      ++htab->filled;
+
+      *retval = &htab->table[idx].entry;
+      return 1;
+    }
+
+  __set_errno (ESRCH);
+  *retval = NULL;
+  return 0;
+}
--- ./hotspot/agent/src/os/bsd/hsearch_r.h	1969-12-31 16:00:00.000000000 -0800
+++ ./hotspot/agent/src/os/bsd/hsearch_r.h	2009-06-06 16:53:52.000000000 -0700
@@ -0,0 +1,42 @@
+/* Declarations for System V style searching functions.
+   Copyright (C) 1995-1999, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _HSEARCH_R_H_
+#define _HSEARCH_R_H_
+
+#include <search.h>
+
+struct _ENTRY;
+
+/* Data type for reentrant functions.  */
+struct hsearch_data
+  {
+    struct _ENTRY *table;
+    unsigned int size;
+    unsigned int filled;
+  };
+
+/* Reentrant versions which can handle multiple hashing tables at the
+   same time.  */
+extern int hsearch_r (ENTRY __item, ACTION __action, ENTRY **__retval,
+                      struct hsearch_data *__htab);
+extern int hcreate_r (size_t __nel, struct hsearch_data *__htab);
+extern void hdestroy_r (struct hsearch_data *__htab);
+
+#endif /* _HSEARCH_R_H_ */
--- ./hotspot/agent/src/os/bsd/libproc.h	2010-03-27 11:09:09.000000000 -0700
+++ ./hotspot/agent/src/os/bsd/libproc.h	2009-06-06 16:53:52.000000000 -0700
@@ -27,7 +27,8 @@
 
 #include <unistd.h>
 #include <stdint.h>
-#include "proc_service.h"
+#include <machine/reg.h>
+#include <proc_service.h>
 
 #if defined(sparc) || defined(sparcv9)
 /*
@@ -50,14 +51,11 @@
 adds Pgrab__ and some missing stuff. We hide the difference b/w live process and core
 file by this interface.
 
-1. pthread_id unique in both NPTL & BsdThreads. We store this in
-OSThread::_pthread_id in JVM code.
+1. pthread_id is unique. We store this in OSThread::_pthread_id in JVM code.
 
-2. All threads see the same pid when they call getpid() under NPTL.
-Threads receive different pid under BsdThreads. We used to save the result of
-::getpid() call in OSThread::_thread_id. This way uniqueness of OSThread::_thread_id
-was lost under NPTL. Now, we store the result of ::gettid() call in
-OSThread::_thread_id. Because gettid returns actual pid of thread (lwp id), this is
+2. All threads see the same pid when they call getpid().
+We used to save the result of ::getpid() call in OSThread::_thread_id.
+Because gettid returns actual pid of thread (lwp id), this is
 unique again. We therefore use OSThread::_thread_id as unique identifier.
 
 3. There is a unique LWP id under both thread libraries. libthread_db  maps pthread_id
@@ -74,20 +72,7 @@
 
 *************************************************************************************/
 
-#ifdef ia64
-struct user_regs_struct {
-/* copied from user.h which doesn't define this in a struct */
-
-#define IA64_REG_COUNT (EF_SIZE/8+32)   /* integer and fp regs */
-unsigned long   regs[IA64_REG_COUNT];     /* integer and fp regs */
-};
-#endif
-
-#if defined(sparc)  || defined(sparcv9)
-#define user_regs_struct  pt_regs
-#endif
-
-// This C bool type must be int for compatibility with Bsd calls and
+// This C bool type must be int for compatibility with BSD calls and
 // it would be a mistake to equivalence it to C++ bool on many platforms
 
 typedef int bool;
@@ -118,7 +103,7 @@
 lwpid_t get_lwp_id(struct ps_prochandle* ph, int index);
 
 // get regs for a given lwp
-bool get_lwp_regs(struct ps_prochandle* ph, lwpid_t lid, struct user_regs_struct* regs);
+bool get_lwp_regs(struct ps_prochandle* ph, lwpid_t lid, struct reg* regs);
 
 // get number of shared objects
 int get_num_libs(struct ps_prochandle* ph);
--- ./hotspot/agent/src/os/bsd/libproc_impl.c	2010-03-27 11:09:09.000000000 -0700
+++ ./hotspot/agent/src/os/bsd/libproc_impl.c	2009-06-06 16:53:52.000000000 -0700
@@ -178,6 +178,9 @@
    if (newlib->symtab == NULL) {
       print_debug("symbol table build failed for %s\n", newlib->name);
    }
+   else {
+      print_debug("built symbol table for %s\n", newlib->name);
+   }
 
    // even if symbol table building fails, we add the lib_info.
    // This is because we may need to read from the ELF file for core file
@@ -272,7 +275,7 @@
 
   print_debug("thread_db : pthread %d (lwp %d)\n", ti.ti_tid, ti.ti_lid);
 
-  if (ptr->callback(ptr->ph, ti.ti_tid, ti.ti_lid) != true)
+  if (ptr->callback(ptr->ph, (pthread_t)ti.ti_tid, ti.ti_lid) != true)
     return TD_ERR;
 
   return TD_OK;
@@ -324,7 +327,7 @@
 }
 
 // get regs for a given lwp
-bool get_lwp_regs(struct ps_prochandle* ph, lwpid_t lwp_id, struct user_regs_struct* regs) {
+bool get_lwp_regs(struct ps_prochandle* ph, lwpid_t lwp_id, struct reg* regs) {
   return ph->ops->get_lwp_regs(ph, lwp_id, regs);
 }
 
@@ -375,11 +378,6 @@
 //--------------------------------------------------------------------------
 // proc service functions
 
-// get process id
-pid_t ps_getpid(struct ps_prochandle *ph) {
-   return ph->pid;
-}
-
 // ps_pglobal_lookup() looks up the symbol sym_name in the symbol table
 // of the load object object_name in the target process identified by ph.
 // It returns the symbol's value as an address in the target process in
@@ -392,17 +390,33 @@
 }
 
 // read "size" bytes info "buf" from address "addr"
-ps_err_e ps_pdread(struct ps_prochandle *ph, psaddr_t  addr,
-                   void *buf, size_t size) {
+ps_err_e ps_pread(struct ps_prochandle *ph, psaddr_t  addr,
+                  void *buf, size_t size) {
   return ph->ops->p_pread(ph, (uintptr_t) addr, buf, size)? PS_OK: PS_ERR;
 }
 
 // write "size" bytes of data to debuggee at address "addr"
-ps_err_e ps_pdwrite(struct ps_prochandle *ph, psaddr_t addr,
-                    const void *buf, size_t size) {
+ps_err_e ps_pwrite(struct ps_prochandle *ph, psaddr_t addr,
+                   const void *buf, size_t size) {
   return ph->ops->p_pwrite(ph, (uintptr_t)addr, buf, size)? PS_OK: PS_ERR;
 }
 
+// fill in ptrace_lwpinfo for lid
+ps_err_e ps_linfo(struct ps_prochandle *ph, lwpid_t lwp_id, void *linfo) {
+  return ph->ops->get_lwp_info(ph, lwp_id, linfo)? PS_OK: PS_ERR;
+}
+
+// needed for when libthread_db is compiled with TD_DEBUG defined
+void
+ps_plog (const char *format, ...)
+{
+  va_list alist;
+
+  va_start(alist, format);
+  vfprintf(stderr, format, alist);
+  va_end(alist);
+}
+
 // ------------------------------------------------------------------------
 // Functions below this point are not yet implemented. They are here only
 // to make the linker happy.
@@ -427,8 +441,12 @@
   return PS_OK;
 }
 
-// new libthread_db of NPTL seem to require this symbol
-ps_err_e ps_get_thread_area() {
-  print_debug("ps_get_thread_area not implemented\n");
+ps_err_e ps_lstop(struct ps_prochandle *ph, lwpid_t lid) {
+  print_debug("ps_lstop not implemented\n");
+  return PS_OK;
+}
+
+ps_err_e ps_pcontinue(struct ps_prochandle *ph) {
+  print_debug("ps_pcontinue not implemented\n");
   return PS_OK;
 }
--- ./hotspot/agent/src/os/bsd/libproc_impl.h	2010-03-27 11:09:09.000000000 -0700
+++ ./hotspot/agent/src/os/bsd/libproc_impl.h	2009-06-06 16:53:52.000000000 -0700
@@ -47,7 +47,7 @@
 typedef struct thread_info {
    lwpid_t                  lwp_id;
    pthread_t                pthread_id; // not used cores, always -1
-   struct user_regs_struct  regs;       // not for process, core uses for caching regset
+   struct reg               regs;       // not for process, core uses for caching regset
    struct thread_info*      next;
 } thread_info;
 
@@ -71,7 +71,9 @@
    bool (*p_pwrite)(struct ps_prochandle *ph,
             uintptr_t addr, const char *buf , size_t size);
    // get integer regset of a thread
-   bool (*get_lwp_regs)(struct ps_prochandle* ph, lwpid_t lwp_id, struct user_regs_struct* regs);
+   bool (*get_lwp_regs)(struct ps_prochandle* ph, lwpid_t lwp_id, struct reg* regs);
+   // get info on thread
+   bool (*get_lwp_info)(struct ps_prochandle *ph, lwpid_t lwp_id, void *linfo);
 } ps_prochandle_ops;
 
 // the ps_prochandle
@@ -79,7 +81,7 @@
 struct core_data {
    int                core_fd;   // file descriptor of core file
    int                exec_fd;   // file descriptor of exec file
-   int                interp_fd; // file descriptor of interpreter (ld-bsd.so.2)
+   int                interp_fd; // file descriptor of interpreter (ld-elf.so.1)
    // part of the class sharing workaround
    int                classes_jsa_fd; // file descriptor of class share archive
    uintptr_t          dynamic_addr;  // address of dynamic section of a.out
--- ./hotspot/agent/src/os/bsd/mapfile	2010-03-27 11:09:09.000000000 -0700
+++ ./hotspot/agent/src/os/bsd/mapfile	2009-06-06 16:53:52.000000000 -0700
@@ -43,13 +43,17 @@
 		# proc_service.h functions - to be used by libthread_db
 		ps_getpid;
 		ps_pglobal_lookup;
-		ps_pdread;
-		ps_pdwrite;
+		ps_pread;
+		ps_pwrite;
 		ps_lsetfpregs;
 		ps_lsetregs;
 		ps_lgetfpregs;
 		ps_lgetregs;
-		ps_get_thread_area;
+		ps_lcontinue;
+		ps_lgetxmmregs;
+		ps_lsetxmmregs;
+		ps_lstop;
+		ps_linfo;
 
                 # used by attach test program
                 init_libproc;
--- ./hotspot/agent/src/os/bsd/proc_service.h	2010-03-27 11:09:09.000000000 -0700
+++ ./hotspot/agent/src/os/bsd/proc_service.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,76 +0,0 @@
-/*
- * Copyright 2003 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- *
- */
-
-#ifndef _PROC_SERVICE_H_
-#define _PROC_SERVICE_H_
-
-#include <stdio.h>
-#include <thread_db.h>
-
-// Bsd does not have the proc service library, though it does provide the
-// thread_db library which can be used to manipulate threads without having
-// to know the details of BsdThreads or NPTL
-
-// copied from Solaris "proc_service.h"
-typedef enum {
-        PS_OK,          /* generic "call succeeded" */
-        PS_ERR,         /* generic error */
-        PS_BADPID,      /* bad process handle */
-        PS_BADLID,      /* bad lwp identifier */
-        PS_BADADDR,     /* bad address */
-        PS_NOSYM,       /* p_lookup() could not find given symbol */
-        PS_NOFREGS      /* FPU register set not available for given lwp */
-} ps_err_e;
-
-// ps_getpid() is only defined on Bsd to return a thread's process ID
-pid_t ps_getpid(struct ps_prochandle *ph);
-
-// ps_pglobal_lookup() looks up the symbol sym_name in the symbol table
-// of the load object object_name in the target process identified by ph.
-// It returns the symbol's value as an address in the target process in
-// *sym_addr.
-
-ps_err_e ps_pglobal_lookup(struct ps_prochandle *ph, const char *object_name,
-                    const char *sym_name, psaddr_t *sym_addr);
-
-// read "size" bytes of data from debuggee at address "addr"
-ps_err_e ps_pdread(struct ps_prochandle *ph, psaddr_t  addr,
-                   void *buf, size_t size);
-
-// write "size" bytes of data to debuggee at address "addr"
-ps_err_e ps_pdwrite(struct ps_prochandle *ph, psaddr_t addr,
-                    const void *buf, size_t size);
-
-ps_err_e ps_lsetfpregs(struct ps_prochandle *ph, lwpid_t lid, const prfpregset_t *fpregs);
-
-ps_err_e ps_lsetregs(struct ps_prochandle *ph, lwpid_t lid, const prgregset_t gregset);
-
-ps_err_e  ps_lgetfpregs(struct  ps_prochandle  *ph,  lwpid_t lid, prfpregset_t *fpregs);
-
-ps_err_e ps_lgetregs(struct ps_prochandle *ph, lwpid_t lid, prgregset_t gregset);
-
-// new libthread_db of NPTL seem to require this symbol
-ps_err_e ps_get_thread_area();
-
-#endif /* _PROC_SERVICE_H_ */
--- ./hotspot/agent/src/os/bsd/ps_core.c	2010-03-27 11:09:09.000000000 -0700
+++ ./hotspot/agent/src/os/bsd/ps_core.c	2009-10-05 21:49:06.000000000 -0700
@@ -142,6 +142,7 @@
 
    map->next = ph->core->class_share_maps;
    ph->core->class_share_maps = map;
+   return map;
 }
 
 // Return the map_info for the given virtual address.  We keep a sorted
@@ -228,8 +229,8 @@
 
     // 4991491 NOTICE These are C++ bool's in filemap.hpp and must match up with
     // the C type matching the C++ bool type on any given platform. For
-    // Hotspot on Bsd we assume the corresponding C type is char but
-    // licensees on Bsd versions may need to adjust the type of these fields.
+    // Hotspot on BSD we assume the corresponding C type is char but
+    // licensees on BSD versions may need to adjust the type of these fields.
     char   _read_only;       // read only space?
     char   _allow_exec;      // executable code in space?
 
@@ -240,7 +241,7 @@
 
 static bool read_jboolean(struct ps_prochandle* ph, uintptr_t addr, jboolean* pvalue) {
    jboolean i;
-   if (ps_pdread(ph, (psaddr_t) addr, &i, sizeof(i)) == PS_OK) {
+   if (ps_pread(ph, (psaddr_t) addr, &i, sizeof(i)) == PS_OK) {
       *pvalue = i;
       return true;
    } else {
@@ -250,7 +251,7 @@
 
 static bool read_pointer(struct ps_prochandle* ph, uintptr_t addr, uintptr_t* pvalue) {
    uintptr_t uip;
-   if (ps_pdread(ph, (psaddr_t) addr, &uip, sizeof(uip)) == PS_OK) {
+   if (ps_pread(ph, (psaddr_t) addr, &uip, sizeof(uip)) == PS_OK) {
       *pvalue = uip;
       return true;
    } else {
@@ -264,7 +265,7 @@
    char  c = ' ';
 
    while (c != '\0') {
-     if (ps_pdread(ph, (psaddr_t) addr, &c, sizeof(char)) != PS_OK)
+     if (ps_pread(ph, (psaddr_t) addr, &c, sizeof(char)) != PS_OK)
          return false;
       if (i < size - 1)
          buf[i] = c;
@@ -296,7 +297,6 @@
          uintptr_t base = 0, useSharedSpacesAddr = 0;
          uintptr_t sharedArchivePathAddrAddr = 0, sharedArchivePathAddr = 0;
          jboolean useSharedSpaces = 0;
-         map_info* mi = 0;
 
          memset(classes_jsa, 0, sizeof(classes_jsa));
          jvm_name = lib->name;
@@ -306,9 +306,9 @@
             return false;
          }
 
-         // Hotspot vm types are not exported to build this library. So
-         // using equivalent type jboolean to read the value of
-         // UseSharedSpaces which is same as hotspot type "bool".
+	 // Hotspot vm types are not exported to build this library. So
+	 // using equivalent type jboolean to read the value of
+	 // UseSharedSpaces which is same as hotspot type "bool".
          if (read_jboolean(ph, useSharedSpacesAddr, &useSharedSpaces) != true) {
             print_debug("can't read the value of 'UseSharedSpaces' flag\n");
             return false;
@@ -507,12 +507,12 @@
 }
 
 static bool core_get_lwp_regs(struct ps_prochandle* ph, lwpid_t lwp_id,
-                          struct user_regs_struct* regs) {
+                          struct reg* regs) {
    // for core we have cached the lwp regs from NOTE section
    thread_info* thr = ph->threads;
    while (thr) {
      if (thr->lwp_id == lwp_id) {
-       memcpy(regs, &thr->regs, sizeof(struct user_regs_struct));
+       memcpy(regs, &thr->regs, sizeof(struct reg));
        return true;
      }
      thr = thr->next;
@@ -520,11 +520,17 @@
    return false;
 }
 
+static bool core_get_lwp_info(struct ps_prochandle *ph, lwpid_t lwp_id, void *linfo) {
+   print_debug("core_get_lwp_info not implemented\n");
+   return false;
+}
+
 static ps_prochandle_ops core_ops = {
    .release=  core_release,
    .p_pread=  core_read_data,
    .p_pwrite= core_write_data,
-   .get_lwp_regs= core_get_lwp_regs
+   .get_lwp_regs= core_get_lwp_regs,
+   .get_lwp_info= core_get_lwp_info
 };
 
 // read regs and create thread from NT_PRSTATUS entries from core file
@@ -539,52 +545,52 @@
       return false;
 
    // copy regs
-   memcpy(&newthr->regs, prstat->pr_reg, sizeof(struct user_regs_struct));
+   memcpy(&newthr->regs, &prstat->pr_reg, sizeof(struct reg));
 
    if (is_debug()) {
       print_debug("integer regset\n");
 #ifdef i386
       // print the regset
-      print_debug("\teax = 0x%x\n", newthr->regs.eax);
-      print_debug("\tebx = 0x%x\n", newthr->regs.ebx);
-      print_debug("\tecx = 0x%x\n", newthr->regs.ecx);
-      print_debug("\tedx = 0x%x\n", newthr->regs.edx);
-      print_debug("\tesp = 0x%x\n", newthr->regs.esp);
-      print_debug("\tebp = 0x%x\n", newthr->regs.ebp);
-      print_debug("\tesi = 0x%x\n", newthr->regs.esi);
-      print_debug("\tedi = 0x%x\n", newthr->regs.edi);
-      print_debug("\teip = 0x%x\n", newthr->regs.eip);
+      print_debug("\teax = 0x%x\n", newthr->regs.r_eax);
+      print_debug("\tebx = 0x%x\n", newthr->regs.r_ebx);
+      print_debug("\tecx = 0x%x\n", newthr->regs.r_ecx);
+      print_debug("\tedx = 0x%x\n", newthr->regs.r_edx);
+      print_debug("\tesp = 0x%x\n", newthr->regs.r_esp);
+      print_debug("\tebp = 0x%x\n", newthr->regs.r_ebp);
+      print_debug("\tesi = 0x%x\n", newthr->regs.r_esi);
+      print_debug("\tedi = 0x%x\n", newthr->regs.r_edi);
+      print_debug("\teip = 0x%x\n", newthr->regs.r_eip);
 #endif
 
 #if defined(amd64) || defined(x86_64)
       // print the regset
-      print_debug("\tr15 = 0x%lx\n", newthr->regs.r15);
-      print_debug("\tr14 = 0x%lx\n", newthr->regs.r14);
-      print_debug("\tr13 = 0x%lx\n", newthr->regs.r13);
-      print_debug("\tr12 = 0x%lx\n", newthr->regs.r12);
-      print_debug("\trbp = 0x%lx\n", newthr->regs.rbp);
-      print_debug("\trbx = 0x%lx\n", newthr->regs.rbx);
-      print_debug("\tr11 = 0x%lx\n", newthr->regs.r11);
-      print_debug("\tr10 = 0x%lx\n", newthr->regs.r10);
-      print_debug("\tr9 = 0x%lx\n", newthr->regs.r9);
-      print_debug("\tr8 = 0x%lx\n", newthr->regs.r8);
-      print_debug("\trax = 0x%lx\n", newthr->regs.rax);
-      print_debug("\trcx = 0x%lx\n", newthr->regs.rcx);
-      print_debug("\trdx = 0x%lx\n", newthr->regs.rdx);
-      print_debug("\trsi = 0x%lx\n", newthr->regs.rsi);
-      print_debug("\trdi = 0x%lx\n", newthr->regs.rdi);
-      print_debug("\torig_rax = 0x%lx\n", newthr->regs.orig_rax);
-      print_debug("\trip = 0x%lx\n", newthr->regs.rip);
-      print_debug("\tcs = 0x%lx\n", newthr->regs.cs);
-      print_debug("\teflags = 0x%lx\n", newthr->regs.eflags);
-      print_debug("\trsp = 0x%lx\n", newthr->regs.rsp);
-      print_debug("\tss = 0x%lx\n", newthr->regs.ss);
-      print_debug("\tfs_base = 0x%lx\n", newthr->regs.fs_base);
-      print_debug("\tgs_base = 0x%lx\n", newthr->regs.gs_base);
-      print_debug("\tds = 0x%lx\n", newthr->regs.ds);
-      print_debug("\tes = 0x%lx\n", newthr->regs.es);
-      print_debug("\tfs = 0x%lx\n", newthr->regs.fs);
-      print_debug("\tgs = 0x%lx\n", newthr->regs.gs);
+      print_debug("\tr15 = 0x%lx\n", newthr->regs.r_r15);
+      print_debug("\tr14 = 0x%lx\n", newthr->regs.r_r14);
+      print_debug("\tr13 = 0x%lx\n", newthr->regs.r_r13);
+      print_debug("\tr12 = 0x%lx\n", newthr->regs.r_r12);
+      print_debug("\trbp = 0x%lx\n", newthr->regs.r_rbp);
+      print_debug("\trbx = 0x%lx\n", newthr->regs.r_rbx);
+      print_debug("\tr11 = 0x%lx\n", newthr->regs.r_r11);
+      print_debug("\tr10 = 0x%lx\n", newthr->regs.r_r10);
+      print_debug("\tr9 = 0x%lx\n", newthr->regs.r_r9);
+      print_debug("\tr8 = 0x%lx\n", newthr->regs.r_r8);
+      print_debug("\trax = 0x%lx\n", newthr->regs.r_rax);
+      print_debug("\trcx = 0x%lx\n", newthr->regs.r_rcx);
+      print_debug("\trdx = 0x%lx\n", newthr->regs.r_rdx);
+      print_debug("\trsi = 0x%lx\n", newthr->regs.r_rsi);
+      print_debug("\trdi = 0x%lx\n", newthr->regs.r_rdi);
+      //print_debug("\torig_rax = 0x%lx\n", newthr->regs.orig_rax);
+      print_debug("\trip = 0x%lx\n", newthr->regs.r_rip);
+      print_debug("\tcs = 0x%lx\n", newthr->regs.r_cs);
+      //print_debug("\teflags = 0x%lx\n", newthr->regs.eflags);
+      print_debug("\trsp = 0x%lx\n", newthr->regs.r_rsp);
+      print_debug("\tss = 0x%lx\n", newthr->regs.r_ss);
+      //print_debug("\tfs_base = 0x%lx\n", newthr->regs.fs_base);
+      //print_debug("\tgs_base = 0x%lx\n", newthr->regs.gs_base);
+      //print_debug("\tds = 0x%lx\n", newthr->regs.ds);
+      //print_debug("\tes = 0x%lx\n", newthr->regs.es);
+      //print_debug("\tfs = 0x%lx\n", newthr->regs.fs);
+      //print_debug("\tgs = 0x%lx\n", newthr->regs.gs);
 #endif
    }
 
@@ -656,7 +662,7 @@
     * contains a set of saved /proc structures), and PT_LOAD (which
     * represents a memory mapping from the process's address space).
     *
-    * Difference b/w Solaris PT_NOTE and Bsd PT_NOTE:
+    * Difference b/w Solaris PT_NOTE and BSD PT_NOTE:
     *
     *     In Solaris there are two PT_NOTE segments the first PT_NOTE (if present)
     *     contains /proc structs in the pre-2.6 unstructured /proc format. the last
@@ -666,10 +672,10 @@
     *     integer register set among other stuff. For each LWP, we have one lwpstatus
     *     entry that has integer regset for that LWP.
     *
-    *     Bsd threads are actually 'clone'd processes. To support core analysis
-    *     of "multithreaded" process, Bsd creates more than one pstatus (called
+    *     Linux threads are actually 'clone'd processes. To support core analysis
+    *     of "multithreaded" process, Linux creates more than one pstatus (called
     *     "prstatus") entry in PT_NOTE. Each prstatus entry has integer regset for one
-    *     "thread". Please refer to Bsd kernel src file 'fs/binfmt_elf.c', in particular
+    *     "thread". Please refer to Linux kernel src file 'fs/binfmt_elf.c', in particular
     *     function "elf_core_dump".
     */
 
@@ -725,7 +731,7 @@
    return false;
 }
 
-// process segments from interpreter (ld.so or ld-bsd.so)
+// process segments from interpreter (ld-elf.so.1)
 static bool read_interp_segments(struct ps_prochandle* ph) {
    ELF_EHDR interp_ehdr;
 
@@ -826,7 +832,7 @@
 
    dyn.d_tag = DT_NULL;
    while (dyn.d_tag != DT_DEBUG) {
-      if (ps_pdread(ph, (psaddr_t) addr, &dyn, sizeof(ELF_DYN)) != PS_OK) {
+      if (ps_pread(ph, (psaddr_t) addr, &dyn, sizeof(ELF_DYN)) != PS_OK) {
          print_debug("can't read debug info from _DYNAMIC\n");
          return false;
       }
@@ -836,23 +842,27 @@
    // we have got Dyn entry with DT_DEBUG
    debug_base = dyn.d_un.d_ptr;
    // at debug_base we have struct r_debug. This has first link map in r_map field
-   if (ps_pdread(ph, (psaddr_t) debug_base + FIRST_LINK_MAP_OFFSET,
+   if (ps_pread(ph, (psaddr_t) debug_base + FIRST_LINK_MAP_OFFSET,
                  &first_link_map_addr, sizeof(uintptr_t)) != PS_OK) {
       print_debug("can't read first link map address\n");
       return false;
    }
 
    // read ld_base address from struct r_debug
-   if (ps_pdread(ph, (psaddr_t) debug_base + LD_BASE_OFFSET, &ld_base_addr,
+   // XXX: There is no r_ldbase member on BSD
+/*
+   if (ps_pread(ph, (psaddr_t) debug_base + LD_BASE_OFFSET, &ld_base_addr,
                  sizeof(uintptr_t)) != PS_OK) {
       print_debug("can't read ld base address\n");
       return false;
    }
    ph->core->ld_base_addr = ld_base_addr;
+*/
+   ph->core->ld_base_addr = 0;
 
    print_debug("interpreter base address is 0x%lx\n", ld_base_addr);
 
-   // now read segments from interp (i.e ld.so or ld-bsd.so)
+   // now read segments from interp (i.e ld-elf.so.1)
    if (read_interp_segments(ph) != true)
       return false;
 
@@ -870,14 +880,14 @@
       // address mentioned in shared object and the actual virtual base where runtime
       // linker loaded it. We use "base diff" in read_lib_segments call below.
 
-      if (ps_pdread(ph, (psaddr_t) link_map_addr + LINK_MAP_ADDR_OFFSET,
+      if (ps_pread(ph, (psaddr_t) link_map_addr + LINK_MAP_ADDR_OFFSET,
                    &lib_base_diff, sizeof(uintptr_t)) != PS_OK) {
          print_debug("can't read shared object base address diff\n");
          return false;
       }
 
       // read address of the name
-      if (ps_pdread(ph, (psaddr_t) link_map_addr + LINK_MAP_NAME_OFFSET,
+      if (ps_pread(ph, (psaddr_t) link_map_addr + LINK_MAP_NAME_OFFSET,
                     &lib_name_addr, sizeof(uintptr_t)) != PS_OK) {
          print_debug("can't read address of shared object name\n");
          return false;
@@ -921,7 +931,7 @@
       }
 
       // read next link_map address
-      if (ps_pdread(ph, (psaddr_t) link_map_addr + LINK_MAP_NEXT_OFFSET,
+      if (ps_pread(ph, (psaddr_t) link_map_addr + LINK_MAP_NEXT_OFFSET,
                         &link_map_addr, sizeof(uintptr_t)) != PS_OK) {
          print_debug("can't read next link in link_map\n");
          return false;
@@ -935,7 +945,6 @@
 struct ps_prochandle* Pgrab_core(const char* exec_file, const char* core_file) {
    ELF_EHDR core_ehdr;
    ELF_EHDR exec_ehdr;
-   ELF_EHDR lib_ehdr;
 
    struct ps_prochandle* ph = (struct ps_prochandle*) calloc(1, sizeof(struct ps_prochandle));
    if (ph == NULL) {
--- ./hotspot/agent/src/os/bsd/ps_proc.c	2010-03-27 11:09:09.000000000 -0700
+++ ./hotspot/agent/src/os/bsd/ps_proc.c	2009-10-05 21:49:06.000000000 -0700
@@ -22,20 +22,22 @@
  *
  */
 
+#include <limits.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <errno.h>
+#include <sys/types.h>
+#include <sys/wait.h>
 #include <sys/ptrace.h>
+#include <sys/param.h>
+#include <sys/user.h>
+#include <elf.h>
+#include <sys/elf_common.h>
+#include <sys/link_elf.h>
+#include <libutil.h>
 #include "libproc_impl.h"
-
-#if defined(x86_64) && !defined(amd64)
-#define amd64 1
-#endif
-
-#ifndef __WALL
-#define __WALL          0x40000000  // Copied from /usr/include/bsd/wait.h
-#endif
+#include "elfmacros.h"
 
 // This file has the libproc implementation specific to live process
 // For core files, refer to ps_core.c
@@ -50,251 +52,359 @@
 
 // read "size" bytes of data from "addr" within the target process.
 // unlike the standard ptrace() function, process_read_data() can handle
-// unaligned address - alignment check, if required, should be done
+// unaligned address - alignment check, if required, should be done 
 // before calling process_read_data.
 
 static bool process_read_data(struct ps_prochandle* ph, uintptr_t addr, char *buf, size_t size) {
-  long rslt;
+  int rslt;
   size_t i, words;
   uintptr_t end_addr = addr + size;
-  uintptr_t aligned_addr = align(addr, sizeof(long));
+  uintptr_t aligned_addr = align(addr, sizeof(int));
 
   if (aligned_addr != addr) {
     char *ptr = (char *)&rslt;
     errno = 0;
-    rslt = ptrace(PTRACE_PEEKDATA, ph->pid, aligned_addr, 0);
+    rslt = ptrace(PT_READ_D, ph->pid, (caddr_t) aligned_addr, 0);
     if (errno) {
-      print_debug("ptrace(PTRACE_PEEKDATA, ..) failed for %d bytes @ %lx\n", size, addr);
+      print_debug("ptrace(PT_READ_D, ..) failed for %d bytes @ %lx\n", size, addr);
       return false;
     }
     for (; aligned_addr != addr; aligned_addr++, ptr++);
-    for (; ((intptr_t)aligned_addr % sizeof(long)) && aligned_addr < end_addr;
-        aligned_addr++)
+    for (; ((intptr_t)aligned_addr % sizeof(int)) && aligned_addr < end_addr; 
+        aligned_addr++) 
        *(buf++) = *(ptr++);
   }
 
-  words = (end_addr - aligned_addr) / sizeof(long);
+  words = (end_addr - aligned_addr) / sizeof(int);
 
-  // assert((intptr_t)aligned_addr % sizeof(long) == 0);
+  // assert((intptr_t)aligned_addr % sizeof(int) == 0);
   for (i = 0; i < words; i++) {
     errno = 0;
-    rslt = ptrace(PTRACE_PEEKDATA, ph->pid, aligned_addr, 0);
+    rslt = ptrace(PT_READ_D, ph->pid, (caddr_t) aligned_addr, 0);
     if (errno) {
-      print_debug("ptrace(PTRACE_PEEKDATA, ..) failed for %d bytes @ %lx\n", size, addr);
+      print_debug("ptrace(PT_READ_D, ..) failed for %d bytes @ %lx\n", size, addr);
       return false;
     }
-    *(long *)buf = rslt;
-    buf += sizeof(long);
-    aligned_addr += sizeof(long);
+    *(int *)buf = rslt;
+    buf += sizeof(int);
+    aligned_addr += sizeof(int);
   }
 
   if (aligned_addr != end_addr) {
     char *ptr = (char *)&rslt;
     errno = 0;
-    rslt = ptrace(PTRACE_PEEKDATA, ph->pid, aligned_addr, 0);
+    rslt = ptrace(PT_READ_D, ph->pid, (caddr_t) aligned_addr, 0);
     if (errno) {
-      print_debug("ptrace(PTRACE_PEEKDATA, ..) failed for %d bytes @ %lx\n", size, addr);
+      print_debug("ptrace(PT_READ_D, ..) failed for %d bytes @ %lx\n", size, addr);
       return false;
     }
-    for (; aligned_addr != end_addr; aligned_addr++)
+    for (; aligned_addr != end_addr; aligned_addr++) 
        *(buf++) = *(ptr++);
   }
   return true;
 }
 
 // null implementation for write
-static bool process_write_data(struct ps_prochandle* ph,
+static bool process_write_data(struct ps_prochandle* ph, 
                              uintptr_t addr, const char *buf , size_t size) {
   return false;
 }
 
-// "user" should be a pointer to a user_regs_struct
-static bool process_get_lwp_regs(struct ps_prochandle* ph, pid_t pid, struct user_regs_struct *user) {
+// "user" should be a pointer to a reg
+static bool process_get_lwp_regs(struct ps_prochandle* ph, pid_t pid, struct reg *user) {
   // we have already attached to all thread 'pid's, just use ptrace call
   // to get regset now. Note that we don't cache regset upfront for processes.
-// Bsd on x86 and sparc are different.  On x86 ptrace(PTRACE_GETREGS, ...)
-// uses pointer from 4th argument and ignores 3rd argument.  On sparc it uses
-// pointer from 3rd argument and ignores 4th argument
-#if defined(sparc) || defined(sparcv9)
-#define ptrace_getregs(request, pid, addr, data) ptrace(request, pid, addr, data)
-#else
-#define ptrace_getregs(request, pid, addr, data) ptrace(request, pid, data, addr)
-#endif
-
-#ifdef _LP64
-#ifdef PTRACE_GETREGS64
-#define PTRACE_GETREGS_REQ PTRACE_GETREGS64
-#endif
-#else
-#if defined(PTRACE_GETREGS) || defined(PT_GETREGS)
-#define PTRACE_GETREGS_REQ PTRACE_GETREGS
-#endif
-#endif /* _LP64 */
-
-#ifdef PTRACE_GETREGS_REQ
- if (ptrace_getregs(PTRACE_GETREGS_REQ, pid, user, NULL) < 0) {
+ if (ptrace(PT_GETREGS, pid, (caddr_t) user, 0) < 0) {
    print_debug("ptrace(PTRACE_GETREGS, ...) failed for lwp %d\n", pid);
    return false;
  }
  return true;
-#else
- print_debug("ptrace(PTRACE_GETREGS, ...) not supported\n");
- return false;
-#endif
+}
+
+// fill in ptrace_lwpinfo for lid
+static bool process_get_lwp_info(struct ps_prochandle *ph, lwpid_t lwp_id, void *linfo) {
+  errno = 0;
+  ptrace(PT_LWPINFO, lwp_id, linfo, sizeof(struct ptrace_lwpinfo));
 
+  return (errno == 0)? true: false;
 }
 
 // attach to a process/thread specified by "pid"
 static bool ptrace_attach(pid_t pid) {
-  if (ptrace(PTRACE_ATTACH, pid, NULL, NULL) < 0) {
+  if (ptrace(PT_ATTACH, pid, NULL, 0) < 0) {
     print_debug("ptrace(PTRACE_ATTACH, ..) failed for %d\n", pid);
     return false;
   } else {
     int ret;
     int status;
     do {
-      // Wait for debuggee to stop.
+      // Wait for debuggee to stop. 
       ret = waitpid(pid, &status, 0);
-      if (ret == -1 && errno == ECHILD) {
-        // try cloned process.
-        ret = waitpid(pid, &status, __WALL);
-      }
       if (ret >= 0) {
-        if (WIFSTOPPED(status)) {
-          // Debuggee stopped.
-          return true;
+	if (WIFSTOPPED(status)) {
+	  // Debuggee stopped.
+	  return true;
         } else {
-          print_debug("waitpid(): Child process exited/terminated (status = 0x%x)\n", status);
-          return false;
-        }
+    	  print_debug("waitpid(): Child process exited/terminated (status = 0x%x)\n", status);
+	  return false;
+	}
       } else {
-        switch (errno) {
-          case EINTR:
+	switch (errno) {
+	  case EINTR: 
             continue;
-            break;
-          case ECHILD:
-            print_debug("waitpid() failed. Child process pid (%d) does not exist \n", pid);
-            break;
-          case EINVAL:
-            print_debug("waitpid() failed. Invalid options argument.\n");
-            break;
-          default:
-            print_debug("waitpid() failed. Unexpected error %d\n",errno);
+	    break;
+	  case ECHILD:
+    	    print_debug("waitpid() failed. Child process pid (%d) does not exist \n", pid);
+	    break;
+	  case EINVAL:
+    	    print_debug("waitpid() failed. Invalid options argument.\n");
+	    break;
+	  default:
+    	    print_debug("waitpid() failed. Unexpected error %d\n",errno);
         }
         return false;
-      }
+      } 
     } while(true);
-  }
-}
-
+  } 
+} 
+  
 // -------------------------------------------------------
 // functions for obtaining library information
 // -------------------------------------------------------
 
-/*
- * splits a string _str_ into substrings with delimiter _delim_ by replacing old * delimiters with _new_delim_ (ideally, '\0'). the address of each substring
- * is stored in array _ptrs_ as the return value. the maximum capacity of _ptrs_ * array is specified by parameter _n_.
- * RETURN VALUE: total number of substrings (always <= _n_)
- * NOTE: string _str_ is modified if _delim_!=_new_delim_
- */
-static int split_n_str(char * str, int n, char ** ptrs, char delim, char new_delim)
-{
-   int i;
-   for(i = 0; i < n; i++) ptrs[i] = NULL;
-   if (str == NULL || n < 1 ) return 0;
-
-   i = 0;
-
-   // skipping leading blanks
-   while(*str&&*str==delim) str++;
-
-   while(*str&&i<n){
-     ptrs[i++] = str;
-     while(*str&&*str!=delim) str++;
-     while(*str&&*str==delim) *(str++) = new_delim;
-   }
-
-   return i;
+// callback for read_thread_info
+static bool add_new_thread(struct ps_prochandle* ph, pthread_t pthread_id, lwpid_t lwp_id) {
+  return add_thread_info(ph, pthread_id, lwp_id) != NULL;
 }
 
+#if defined(__FreeBSD__) && __FreeBSD_version < 701000
 /*
- * fgets without storing '\n' at the end of the string
+ * TEXT_START_ADDR from binutils/ld/emulparams/<arch_spec>.sh
+ * Not the most robust but good enough.
  */
-static char * fgets_no_cr(char * buf, int n, FILE *fp)
-{
-   char * rslt = fgets(buf, n, fp);
-   if (rslt && buf && *buf){
-       char *p = strchr(buf, '\0');
-       if (*--p=='\n') *p='\0';
-   }
-   return rslt;
-}
 
-// callback for read_thread_info
-static bool add_new_thread(struct ps_prochandle* ph, pthread_t pthread_id, lwpid_t lwp_id) {
-  return add_thread_info(ph, pthread_id, lwp_id) != NULL;
+#if defined(amd64) || defined(x86_64)
+#define TEXT_START_ADDR 0x400000
+#elif defined(i386)
+#define TEXT_START_ADDR 0x8048000
+#else
+#error TEXT_START_ADDR not defined
+#endif
+
+#define BUF_SIZE (PATH_MAX + NAME_MAX + 1)
+
+uintptr_t linkmap_addr(struct ps_prochandle *ph) {
+  uintptr_t ehdr_addr, phdr_addr, dyn_addr, dmap_addr, lmap_addr;
+  ELF_EHDR ehdr;
+  ELF_PHDR *phdrs, *phdr;
+  ELF_DYN *dyns, *dyn;
+  struct r_debug dmap;
+  unsigned long hdrs_size;
+  unsigned int i;
+
+  /* read ELF_EHDR at TEXT_START_ADDR and validate */
+
+  ehdr_addr = (uintptr_t)TEXT_START_ADDR;
+
+  if (process_read_data(ph, ehdr_addr, (char *)&ehdr, sizeof(ehdr)) != true) {
+    print_debug("process_read_data failed for ehdr_addr %p\n", ehdr_addr);
+    return (0);
+  }
+
+  if (!IS_ELF(ehdr) ||
+        ehdr.e_ident[EI_CLASS] != ELF_TARG_CLASS ||
+        ehdr.e_ident[EI_DATA] != ELF_TARG_DATA ||
+        ehdr.e_ident[EI_VERSION] != EV_CURRENT ||
+        ehdr.e_phentsize != sizeof(ELF_PHDR) ||
+        ehdr.e_version != ELF_TARG_VER ||
+        ehdr.e_machine != ELF_TARG_MACH) {
+    print_debug("not an ELF_EHDR at %p\n", ehdr_addr);
+    return (0);
+  }
+
+  /* allocate space for all ELF_PHDR's and read */
+
+  phdr_addr = ehdr_addr + ehdr.e_phoff;
+  hdrs_size = ehdr.e_phnum * sizeof(ELF_PHDR);
+
+  if ((phdrs = malloc(hdrs_size)) == NULL)
+    return (0);
+
+  if (process_read_data(ph, phdr_addr, (char *)phdrs, hdrs_size) != true) {
+    print_debug("process_read_data failed for phdr_addr %p\n", phdr_addr);
+    return (0);
+  }
+
+  /* find PT_DYNAMIC section */
+
+  for (i = 0, phdr = phdrs; i < ehdr.e_phnum; i++, phdr++) {
+    if (phdr->p_type == PT_DYNAMIC)
+      break;
+  }
+
+  if (i >= ehdr.e_phnum) {
+    print_debug("PT_DYNAMIC section not found!\n");
+    free(phdrs);
+    return (0);
+  }
+
+  /* allocate space and read in ELF_DYN headers */
+
+  dyn_addr = phdr->p_vaddr;
+  hdrs_size = phdr->p_memsz;
+  free(phdrs);
+
+  if ((dyns = malloc(hdrs_size)) == NULL)
+    return (0);
+
+  if (process_read_data(ph, dyn_addr, (char *)dyns, hdrs_size) != true) {
+    print_debug("process_read_data failed for dyn_addr %p\n", dyn_addr);
+    free(dyns);
+    return (0);
+  }
+
+  /* find DT_DEBUG */
+  
+  dyn = dyns;
+  while (dyn->d_tag != DT_DEBUG && dyn->d_tag != DT_NULL) {
+    dyn++;
+  }
+
+  if (dyn->d_tag != DT_DEBUG) {
+    print_debug("failed to find DT_DEBUG\n");
+    free(dyns);
+    return (0);
+  }
+
+  /* read struct r_debug into dmap */
+
+  dmap_addr = (uintptr_t)dyn->d_un.d_ptr;
+  free(dyns);
+
+  if (process_read_data(ph, dmap_addr, (char *)&dmap, sizeof(dmap)) != true) {
+    print_debug("process_read_data failed for dmap_addr %p\n", dmap_addr);
+    return (0);
+  }
+
+  lmap_addr = (uintptr_t)dmap.r_map;
+
+  return (lmap_addr);
 }
+#endif // __FreeBSD__ && __FreeBSD_version < 701000
 
 static bool read_lib_info(struct ps_prochandle* ph) {
-  char fname[32];
-  char buf[256];
-  FILE *fp = NULL;
-
-  sprintf(fname, "/proc/%d/maps", ph->pid);
-  fp = fopen(fname, "r");
-  if (fp == NULL) {
-    print_debug("can't open /proc/%d/maps file\n", ph->pid);
-    return false;
+#if defined(__FreeBSD__) && __FreeBSD_version >= 701000
+  struct kinfo_vmentry *freep, *kve;
+  int i, cnt;
+
+  freep = kinfo_getvmmap(ph->pid, &cnt);
+  if (freep == NULL) {
+      print_debug("can't get vm map for pid\n", ph->pid);
+      return false;
   }
 
-  while(fgets_no_cr(buf, 256, fp)){
-    char * word[6];
-    int nwords = split_n_str(buf, 6, word, ' ', '\0');
-    if (nwords > 5 && find_lib(ph, word[5]) == false) {
-       intptr_t base;
-       lib_info* lib;
-       sscanf(word[0], "%lx", &base);
-       if ((lib = add_lib_info(ph, word[5], (uintptr_t)base)) == NULL)
+  for (i = 0; i < cnt; i++) {
+    kve = &freep[i];
+    if ((kve->kve_flags & KVME_FLAG_COW) &&
+        kve->kve_path != NULL &&
+        strlen(kve->kve_path) > 0) {
+
+      if (find_lib(ph, kve->kve_path) == false) {
+        lib_info* lib;
+        if ((lib = add_lib_info(ph, kve->kve_path,
+                                (uintptr_t) kve->kve_start)) == NULL)
           continue; // ignore, add_lib_info prints error
 
-       // we don't need to keep the library open, symtab is already
-       // built. Only for core dump we need to keep the fd open.
-       close(lib->fd);
-       lib->fd = -1;
+        // we don't need to keep the library open, symtab is already
+        // built. Only for core dump we need to keep the fd open.
+        close(lib->fd);
+        lib->fd = -1;
+      }
     }
   }
-  fclose(fp);
+
+  free(freep);
+
   return true;
+#else
+  char *l_name;
+  struct link_map *lmap;
+  uintptr_t lmap_addr;
+
+  if ((l_name = malloc(BUF_SIZE)) == NULL)
+    return false;
+
+  if ((lmap = malloc(sizeof(*lmap))) == NULL) {
+    free(l_name);
+    return false;
+  }
+
+  lmap_addr = linkmap_addr(ph);
+
+  if (lmap_addr == 0) {
+    free(l_name);
+    free(lmap);
+    return false;
+  }
+
+  do {
+    if (process_read_data(ph, lmap_addr, (char *)lmap, sizeof(*lmap)) != true) {
+      print_debug("process_read_data failed for lmap_addr %p\n", lmap_addr);
+      free (l_name);
+      free (lmap);
+      return false;
+    }
+
+    if (process_read_data(ph, (uintptr_t)lmap->l_name, l_name,
+        BUF_SIZE) != true) {
+      print_debug("process_read_data failed for lmap->l_name %p\n",
+          lmap->l_name);
+      free (l_name);
+      free (lmap);
+      return false;
+    }
+
+    if (find_lib(ph, l_name) == false) {
+      lib_info* lib;
+      if ((lib = add_lib_info(ph, l_name,
+                              (uintptr_t) lmap->l_addr)) == NULL)
+        continue; // ignore, add_lib_info prints error
+
+      // we don't need to keep the library open, symtab is already
+      // built. Only for core dump we need to keep the fd open.
+      close(lib->fd);
+      lib->fd = -1;
+    }
+    lmap_addr = (uintptr_t)lmap->l_next;
+  } while (lmap->l_next != NULL);
+
+  free (l_name);
+  free (lmap);
+
+  return true;
+#endif
 }
 
 // detach a given pid
 static bool ptrace_detach(pid_t pid) {
-  if (pid && ptrace(PTRACE_DETACH, pid, NULL, NULL) < 0) {
+  if (pid && ptrace(PT_DETACH, pid, (caddr_t)1, 0) < 0) {
     print_debug("ptrace(PTRACE_DETACH, ..) failed for %d\n", pid);
     return false;
   } else {
     return true;
-  }
-}
-
-// detach all pids of a ps_prochandle
-static void detach_all_pids(struct ps_prochandle* ph) {
-  thread_info* thr = ph->threads;
-  while (thr) {
-     ptrace_detach(thr->lwp_id);
-     thr = thr->next;
-  }
+  } 
 }
 
 static void process_cleanup(struct ps_prochandle* ph) {
-  detach_all_pids(ph);
+  ptrace_detach(ph->pid);
 }
 
 static ps_prochandle_ops process_ops = {
   .release=  process_cleanup,
   .p_pread=  process_read_data,
   .p_pwrite= process_write_data,
-  .get_lwp_regs= process_get_lwp_regs
+  .get_lwp_regs= process_get_lwp_regs,
+  .get_lwp_info= process_get_lwp_info
 };
 
 // attach to the process. One and only one exposed stuff
@@ -321,21 +431,14 @@
   // read library info and symbol tables, must do this before attaching threads,
   // as the symbols in the pthread library will be used to figure out
   // the list of threads within the same process.
-  read_lib_info(ph);
-
+  if (read_lib_info(ph) != true) {
+     ptrace_detach(pid);
+     free(ph);
+     return NULL;
+  }
+ 
   // read thread info
   read_thread_info(ph, add_new_thread);
 
-  // attach to the threads
-  thr = ph->threads;
-  while (thr) {
-     // don't attach to the main thread again
-     if (ph->pid != thr->lwp_id && ptrace_attach(thr->lwp_id) != true) {
-        // even if one attach fails, we get return NULL
-        Prelease(ph);
-        return NULL;
-     }
-     thr = thr->next;
-  }
   return ph;
 }
--- ./hotspot/agent/src/os/bsd/salibelf.c	2010-03-27 11:09:09.000000000 -0700
+++ ./hotspot/agent/src/os/bsd/salibelf.c	2009-06-06 16:53:52.000000000 -0700
@@ -25,6 +25,7 @@
 #include "salibelf.h"
 #include <stdlib.h>
 #include <unistd.h>
+#include <string.h>
 
 extern void print_debug(const char*,...);
 
--- ./hotspot/agent/src/os/bsd/symtab.c	2010-03-27 11:09:09.000000000 -0700
+++ ./hotspot/agent/src/os/bsd/symtab.c	2009-06-06 16:53:52.000000000 -0700
@@ -23,10 +23,10 @@
  */
 
 #include <unistd.h>
-#include <sys/procfs.h>
 #include <search.h>
 #include <stdlib.h>
 #include <string.h>
+#include "hsearch_r.h"
 #include "symtab.h"
 #include "salibelf.h"
 
@@ -56,7 +56,6 @@
 // read symbol table from given fd.
 struct symtab* build_symtab(int fd) {
   ELF_EHDR ehdr;
-  char *names = NULL;
   struct symtab* symtab = NULL;
 
   // Reading of elf header
@@ -65,7 +64,9 @@
   ELF_SHDR* shbuf = NULL;
   ELF_SHDR* cursct = NULL;
   ELF_PHDR* phbuf = NULL;
-  ELF_PHDR* phdr = NULL;
+  int symtab_found = 0;
+  int dynsym_found = 0;
+  uint32_t symsection = SHT_SYMTAB;
 
   uintptr_t baseaddr = (uintptr_t)-1;
 
@@ -90,18 +91,30 @@
 
   for (cursct = shbuf, cnt = 0; cnt < ehdr.e_shnum; cnt++) {
     scn_cache[cnt].c_shdr = cursct;
-    if (cursct->sh_type == SHT_SYMTAB || cursct->sh_type == SHT_STRTAB) {
+    if (cursct->sh_type == SHT_SYMTAB ||
+        cursct->sh_type == SHT_STRTAB ||
+        cursct->sh_type == SHT_DYNSYM) {
       if ( (scn_cache[cnt].c_data = read_section_data(fd, &ehdr, cursct)) == NULL) {
          goto quit;
       }
     }
+
+    if (cursct->sh_type == SHT_SYMTAB)
+       symtab_found++;
+
+    if (cursct->sh_type == SHT_DYNSYM)
+       dynsym_found++;
+
     cursct++;
   }
 
+  if (!symtab_found && dynsym_found)
+     symsection = SHT_DYNSYM;
+
   for (cnt = 1; cnt < ehdr.e_shnum; cnt++) {
     ELF_SHDR *shdr = scn_cache[cnt].c_shdr;
 
-    if (shdr->sh_type == SHT_SYMTAB) {
+    if (shdr->sh_type == symsection) {
       ELF_SYM  *syms;
       int j, n, rslt;
       size_t size;
--- ./hotspot/agent/src/os/bsd/test.c	2010-03-27 11:09:09.000000000 -0700
+++ ./hotspot/agent/src/os/bsd/test.c	2009-06-06 16:53:52.000000000 -0700
@@ -44,7 +44,7 @@
       }
 
       default: {
-        printf("usage %s <pid> or %s <exec file> <core file>\n");
+        fprintf(stderr, "usage %s <pid> or %s <exec file> <core file>\n", argv[0], argv[0]);
         return 1;
       }
    }
--- ./hotspot/agent/src/share/classes/sun/jvm/hotspot/HotSpotAgent.java	2010-03-18 01:41:33.000000000 -0700
+++ ./hotspot/agent/src/share/classes/sun/jvm/hotspot/HotSpotAgent.java	2009-06-06 16:53:53.000000000 -0700
@@ -28,6 +28,7 @@
 import java.net.*;
 import java.rmi.*;
 import sun.jvm.hotspot.debugger.*;
+import sun.jvm.hotspot.debugger.bsd.*;
 import sun.jvm.hotspot.debugger.dbx.*;
 import sun.jvm.hotspot.debugger.proc.*;
 import sun.jvm.hotspot.debugger.remote.*;
@@ -337,6 +338,8 @@
                 setupDebuggerWin32();
             } else if (os.equals("linux")) {
                 setupDebuggerLinux();
+            } else if (os.equals("bsd")) {
+                setupDebuggerBsd();
             } else {
                 // Add support for more operating systems here
                 throw new DebuggerException("Operating system " + os + " not yet supported");
@@ -392,6 +395,10 @@
                 db = new HotSpotTypeDataBase(machDesc,
                 new LinuxVtblAccess(debugger, jvmLibNames),
                 debugger, jvmLibNames);
+            } else if (os.equals("bsd")) {
+                db = new HotSpotTypeDataBase(machDesc,
+                new BsdVtblAccess(debugger, jvmLibNames),
+                debugger, jvmLibNames);
             } else {
                 throw new DebuggerException("OS \"" + os + "\" not yet supported (no VtblAccess yet)");
             }
@@ -557,6 +564,8 @@
             setupJVMLibNamesWin32();
         } else if (os.equals("linux")) {
             setupJVMLibNamesLinux();
+        } else if (os.equals("bsd")) {
+            setupJVMLibNamesBsd();
         } else {
             throw new RuntimeException("Unknown OS type");
         }
@@ -638,6 +647,31 @@
         jvmLibNames = new String[] { "libjvm.so", "libjvm_g.so" };
     }
 
+    //
+    // BSD
+    //
+
+    private void setupDebuggerBsd() {
+        setupJVMLibNamesBsd();
+
+        if (cpu.equals("x86")) {
+            machDesc = new MachineDescriptionIntelX86();
+        } else if (cpu.equals("amd64")) {
+            machDesc = new MachineDescriptionAMD64();
+        } else {
+            throw new DebuggerException("BSD only supported on x86/amd64");
+        }
+
+        BsdDebuggerLocal dbg = new BsdDebuggerLocal(machDesc, !isServer);
+        debugger = dbg;
+
+        attachDebugger();
+    }
+
+    private void setupJVMLibNamesBsd() {
+        jvmLibNames = new String[] { "libjvm.so", "libjvm_g.so" };
+    }
+
     /** Convenience routine which should be called by per-platform
       debugger setup. Should not be called when startupMode is
       REMOTE_MODE. */
--- ./hotspot/agent/src/share/classes/sun/jvm/hotspot/bugspot/BugSpotAgent.java	2010-03-18 01:41:33.000000000 -0700
+++ ./hotspot/agent/src/share/classes/sun/jvm/hotspot/bugspot/BugSpotAgent.java	2009-06-06 16:53:54.000000000 -0700
@@ -29,6 +29,7 @@
 import java.rmi.*;
 import sun.jvm.hotspot.*;
 import sun.jvm.hotspot.debugger.*;
+import sun.jvm.hotspot.debugger.bsd.*;
 import sun.jvm.hotspot.debugger.dbx.*;
 import sun.jvm.hotspot.debugger.proc.*;
 import sun.jvm.hotspot.debugger.cdbg.*;
@@ -516,6 +517,8 @@
                 setupDebuggerWin32();
             } else if (os.equals("linux")) {
                 setupDebuggerLinux();
+            } else if (os.equals("bsd")) {
+                setupDebuggerBsd();
             } else {
                 // Add support for more operating systems here
                 throw new DebuggerException("Operating system " + os + " not yet supported");
@@ -567,6 +570,9 @@
             } else if (os.equals("linux")) {
                 db = new HotSpotTypeDataBase(machDesc, new LinuxVtblAccess(debugger, jvmLibNames),
                 debugger, jvmLibNames);
+            } else if (os.equals("bsd")) {
+                db = new HotSpotTypeDataBase(machDesc, new BsdVtblAccess(debugger, jvmLibNames),
+                debugger, jvmLibNames);
             } else {
                 throw new DebuggerException("OS \"" + os + "\" not yet supported (no VtblAccess implemented yet)");
             }
@@ -739,6 +745,8 @@
             setupJVMLibNamesWin32();
         } else if (os.equals("linux")) {
             setupJVMLibNamesLinux();
+        } else if (os.equals("bsd")) {
+            setupJVMLibNamesBsd();
         } else {
             throw new RuntimeException("Unknown OS type");
         }
@@ -822,6 +830,34 @@
         setupJVMLibNamesSolaris();
     }
 
+    //
+    // BSD
+    //
+
+    private void setupDebuggerBsd() {
+        setupJVMLibNamesBsd();
+
+        if (cpu.equals("x86")) {
+            machDesc = new MachineDescriptionIntelX86();
+        } else if (cpu.equals("amd64")) {
+            machDesc = new MachineDescriptionAMD64();
+        } else {
+            throw new DebuggerException("Bsd only supported on x86/amd64");
+        }
+
+        // Note we do not use a cache for the local debugger in server
+        // mode; it will be taken care of on the client side (once remote
+        // debugging is implemented).
+
+        debugger = new BsdDebuggerLocal(machDesc, !isServer);
+        attachDebugger();
+    }
+
+    private void setupJVMLibNamesBsd() {
+        // same as solaris
+        setupJVMLibNamesSolaris();
+    }
+
     /** Convenience routine which should be called by per-platform
       debugger setup. Should not be called when startupMode is
       REMOTE_MODE. */
--- ./hotspot/agent/src/share/classes/sun/jvm/hotspot/debugger/bsd/BsdCDebugger.java	2010-03-27 11:09:09.000000000 -0700
+++ ./hotspot/agent/src/share/classes/sun/jvm/hotspot/debugger/bsd/BsdCDebugger.java	2009-06-06 16:53:54.000000000 -0700
@@ -30,10 +30,8 @@
 import sun.jvm.hotspot.debugger.cdbg.*;
 import sun.jvm.hotspot.debugger.x86.*;
 import sun.jvm.hotspot.debugger.amd64.*;
-import sun.jvm.hotspot.debugger.sparc.*;
 import sun.jvm.hotspot.debugger.bsd.x86.*;
 import sun.jvm.hotspot.debugger.bsd.amd64.*;
-import sun.jvm.hotspot.debugger.bsd.sparc.*;
 import sun.jvm.hotspot.utilities.*;
 
 class BsdCDebugger implements CDebugger {
@@ -99,13 +97,6 @@
        Address pc  = context.getRegisterAsAddress(AMD64ThreadContext.RIP);
        if (pc == null) return null;
        return new BsdAMD64CFrame(dbg, rbp, pc);
-    } else if (cpu.equals("sparc")) {
-       SPARCThreadContext context = (SPARCThreadContext) thread.getContext();
-       Address sp = context.getRegisterAsAddress(SPARCThreadContext.R_SP);
-       if (sp == null) return null;
-       Address pc  = context.getRegisterAsAddress(SPARCThreadContext.R_O7);
-       if (pc == null) return null;
-       return new BsdSPARCCFrame(dbg, sp, pc, BsdDebuggerLocal.getAddressSize());
     } else {
        throw new DebuggerException(cpu + " is not yet supported");
     }
--- ./hotspot/agent/src/share/classes/sun/jvm/hotspot/debugger/bsd/BsdThreadContextFactory.java	2010-03-27 11:09:09.000000000 -0700
+++ ./hotspot/agent/src/share/classes/sun/jvm/hotspot/debugger/bsd/BsdThreadContextFactory.java	2009-06-06 16:53:54.000000000 -0700
@@ -26,9 +26,7 @@
 
 import sun.jvm.hotspot.debugger.*;
 import sun.jvm.hotspot.debugger.bsd.amd64.*;
-import sun.jvm.hotspot.debugger.bsd.ia64.*;
 import sun.jvm.hotspot.debugger.bsd.x86.*;
-import sun.jvm.hotspot.debugger.bsd.sparc.*;
 
 class BsdThreadContextFactory {
    static ThreadContext createThreadContext(BsdDebugger dbg) {
@@ -37,10 +35,6 @@
          return new BsdX86ThreadContext(dbg);
       } else if (cpu.equals("amd64")) {
          return new BsdAMD64ThreadContext(dbg);
-      } else if (cpu.equals("ia64")) {
-         return new BsdIA64ThreadContext(dbg);
-      } else if (cpu.equals("sparc")) {
-         return new BsdSPARCThreadContext(dbg);
       } else {
          throw new RuntimeException("cpu " + cpu + " is not yet supported");
       }
--- ./hotspot/agent/src/share/classes/sun/jvm/hotspot/debugger/bsd/ia64/BsdIA64ThreadContext.java	2010-03-27 11:09:09.000000000 -0700
+++ ./hotspot/agent/src/share/classes/sun/jvm/hotspot/debugger/bsd/ia64/BsdIA64ThreadContext.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,46 +0,0 @@
-/*
- * Copyright 2003 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- *
- */
-
-package sun.jvm.hotspot.debugger.bsd.ia64;
-
-import sun.jvm.hotspot.debugger.*;
-import sun.jvm.hotspot.debugger.ia64.*;
-import sun.jvm.hotspot.debugger.bsd.*;
-
-public class BsdIA64ThreadContext extends IA64ThreadContext {
-  private BsdDebugger debugger;
-
-  public BsdIA64ThreadContext(BsdDebugger debugger) {
-    super();
-    this.debugger = debugger;
-  }
-
-  public void setRegisterAsAddress(int index, Address value) {
-    setRegister(index, debugger.getAddressValue(value));
-  }
-
-  public Address getRegisterAsAddress(int index) {
-    return debugger.newAddress(getRegister(index));
-  }
-}
--- ./hotspot/agent/src/share/classes/sun/jvm/hotspot/debugger/bsd/sparc/BsdSPARCCFrame.java	2010-03-27 11:09:09.000000000 -0700
+++ ./hotspot/agent/src/share/classes/sun/jvm/hotspot/debugger/bsd/sparc/BsdSPARCCFrame.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,81 +0,0 @@
-/*
- * Copyright 2006 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- *
- */
-
-package sun.jvm.hotspot.debugger.bsd.sparc;
-
-import sun.jvm.hotspot.debugger.*;
-import sun.jvm.hotspot.debugger.sparc.*;
-import sun.jvm.hotspot.debugger.bsd.*;
-import sun.jvm.hotspot.debugger.cdbg.*;
-import sun.jvm.hotspot.debugger.cdbg.basic.*;
-
-final public class BsdSPARCCFrame extends BasicCFrame {
-   // package/class internals only
-
-   public BsdSPARCCFrame(BsdDebugger dbg, Address sp, Address pc, int address_size) {
-      super(dbg.getCDebugger());
-      this.sp = sp;
-      this.pc = pc;
-      this.dbg = dbg;
-      this.address_size=address_size;
-      if (address_size==8) SPARC_STACK_BIAS = 0x7ff;
-      else SPARC_STACK_BIAS = 0x0;
-   }
-
-   // override base class impl to avoid ELF parsing
-   public ClosestSymbol closestSymbolToPC() {
-      // try native lookup in debugger.
-      return dbg.lookup(dbg.getAddressValue(pc()));
-   }
-
-   public Address pc() {
-      return     pc;
-   }
-
-   public Address localVariableBase() {
-      return sp;
-   }
-
-   public CFrame sender() {
-      if (sp == null) {
-        return null;
-      }
-
-      Address nextSP = sp.getAddressAt( SPARCThreadContext.R_SP * address_size + SPARC_STACK_BIAS);
-      if (nextSP == null) {
-        return null;
-      }
-      Address nextPC  = sp.getAddressAt(SPARCThreadContext.R_O7 * address_size + SPARC_STACK_BIAS);
-      if (nextPC == null) {
-        return null;
-      }
-      return new BsdSPARCCFrame(dbg, nextSP, nextPC,address_size);
-   }
-
-   public static int SPARC_STACK_BIAS;
-   private static int address_size;
-   private Address pc;
-   private Address sp;
-   private BsdDebugger dbg;
-}
--- ./hotspot/agent/src/share/classes/sun/jvm/hotspot/debugger/bsd/sparc/BsdSPARCThreadContext.java	2010-03-27 11:09:09.000000000 -0700
+++ ./hotspot/agent/src/share/classes/sun/jvm/hotspot/debugger/bsd/sparc/BsdSPARCThreadContext.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,46 +0,0 @@
-/*
- * Copyright 2006-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- *
- */
-
-package sun.jvm.hotspot.debugger.bsd.sparc;
-
-import sun.jvm.hotspot.debugger.*;
-import sun.jvm.hotspot.debugger.sparc.*;
-import sun.jvm.hotspot.debugger.bsd.*;
-
-public class BsdSPARCThreadContext extends SPARCThreadContext {
-  private BsdDebugger debugger;
-
-  public BsdSPARCThreadContext(BsdDebugger debugger) {
-    super();
-    this.debugger = debugger;
-  }
-
-  public void setRegisterAsAddress(int index, Address value) {
-    setRegister(index, debugger.getAddressValue(value));
-  }
-
-  public Address getRegisterAsAddress(int index) {
-    return debugger.newAddress(getRegister(index));
-  }
-}
--- ./hotspot/agent/src/share/classes/sun/jvm/hotspot/runtime/Threads.java	2010-03-18 01:41:35.000000000 -0700
+++ ./hotspot/agent/src/share/classes/sun/jvm/hotspot/runtime/Threads.java	2009-09-07 10:57:21.000000000 -0700
@@ -37,6 +37,8 @@
 import sun.jvm.hotspot.runtime.linux_ia64.LinuxIA64JavaThreadPDAccess;
 import sun.jvm.hotspot.runtime.linux_amd64.LinuxAMD64JavaThreadPDAccess;
 import sun.jvm.hotspot.runtime.linux_sparc.LinuxSPARCJavaThreadPDAccess;
+import sun.jvm.hotspot.runtime.bsd_x86.BsdX86JavaThreadPDAccess;
+import sun.jvm.hotspot.runtime.bsd_amd64.BsdAMD64JavaThreadPDAccess;
 import sun.jvm.hotspot.utilities.*;
 
 public class Threads {
@@ -90,7 +92,12 @@
             } else if (cpu.equals("sparc")) {
                 access = new LinuxSPARCJavaThreadPDAccess();
             }
-
+        } else if (os.equals("bsd")) {
+            if (cpu.equals("x86")) {
+                access = new BsdX86JavaThreadPDAccess();
+            } else if (cpu.equals("amd64")) {
+                access = new BsdAMD64JavaThreadPDAccess();
+            }
         }
 
         if (access == null) {
--- ./hotspot/agent/src/share/classes/sun/jvm/hotspot/runtime/bsd/BsdSignals.java	2010-03-27 11:09:09.000000000 -0700
+++ ./hotspot/agent/src/share/classes/sun/jvm/hotspot/runtime/bsd/BsdSignals.java	2009-06-06 16:53:56.000000000 -0700
@@ -28,37 +28,36 @@
   private static String[] signalNames = {
     "",           /* No signal 0 */
     "SIGHUP",     /* hangup */
-    "SIGINT",     /* interrupt (rubout) */
-    "SIGQUIT",    /* quit (ASCII FS) */
-    "SIGILL",     /* illegal instruction (not reset when caught) */
+    "SIGINT",     /* interrupt */
+    "SIGQUIT",    /* quit */
+    "SIGILL",     /* illegal instr. (not reset when caught) */
     "SIGTRAP",    /* trace trap (not reset when caught) */
-    "SIGABRT",    /* used by abort, replace SIGIOT in the future */
-    "SIGIOT",
-    "SIGBUS",
+    "SIGABRT",    /* abort() */
+    "SIGEMT",     /* EMT instruction */
     "SIGFPE",     /* floating point exception */
     "SIGKILL",    /* kill (cannot be caught or ignored) */
-    "SIGUSR1",    /* user defined signal 1 */
+    "SIGBUS",     /* bus error */
     "SIGSEGV",    /* segmentation violation */
-    "SIGUSR2",    /* user defined signal 2 */
+    "SIGSYS",     /* non-existent system call invoked */
     "SIGPIPE",    /* write on a pipe with no one to read it */
     "SIGALRM",    /* alarm clock */
     "SIGTERM",    /* software termination signal from kill */
-    "SIGSTKFLT",
-    "SIGCHLD",    /* child status change alias */
-    "SIGCONT",    /* stopped process has been continued */
-    "SIGSTOP",    /* stop (cannot be caught or ignored) */
-    "SIGTSTP",    /* user stop requested from tty */
-    "SIGTTIN",    /* background tty read attempted */
-    "SIGTTOU",    /* background tty write attempted */
-    "SIGURG",     /* urgent socket condition */
-    "SIGXCPU",    /* exceeded cpu limit */
+    "SIGURG",     /* urgent condition on IO channel */
+    "SIGSTOP",    /* sendable stop signal not from tty */
+    "SIGTSTP",    /* stop signal from tty */
+    "SIGCONT",    /* continue a stopped process */
+    "SIGCHLD",    /* to parent on child stop or exit */
+    "SIGTTIN",    /* to readers pgrp upon background tty read */
+    "SIGTTOU",    /* like TTIN if (tp->t_local&LTOSTOP) */
+    "SIGIO",      /* input/output possible signal */
+    "SIGXCPU",    /* exceeded CPU time limit */
     "SIGXFSZ",    /* exceeded file size limit */
-    "SIGVTALRM",  /* virtual timer expired */
-    "SIGPROF",    /* profiling timer expired */
-    "SIGWINCH",   /* window size change */
-    "SIGPOLL",    /* pollable event occured */
-    "SIGPWR",     /* power-fail restart */
-    "SIGSYS"
+    "SIGVTALRM",  /* virtual time alarm */
+    "SIGPROF",    /* profiling time alarm */
+    "SIGWINCH",   /* window size changes */
+    "SIGINFO",    /* information request */
+    "SIGUSR1",    /* user defined signal 1 */
+    "SIGUSR2"     /* user defined signal 2 */
   };
 
   public static String getSignalName(int sigNum) {
--- ./hotspot/agent/src/share/classes/sun/jvm/hotspot/runtime/bsd_ia64/BsdIA64JavaThreadPDAccess.java	2010-03-27 11:09:09.000000000 -0700
+++ ./hotspot/agent/src/share/classes/sun/jvm/hotspot/runtime/bsd_ia64/BsdIA64JavaThreadPDAccess.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,137 +0,0 @@
-/*
- * Copyright 2003 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- *
- */
-
-package sun.jvm.hotspot.runtime.bsd_ia64;
-
-import java.io.*;
-import java.util.*;
-import sun.jvm.hotspot.debugger.*;
-import sun.jvm.hotspot.debugger.ia64.*;
-import sun.jvm.hotspot.runtime.*;
-import sun.jvm.hotspot.runtime.ia64.*;
-import sun.jvm.hotspot.types.*;
-import sun.jvm.hotspot.utilities.*;
-
-public class BsdIA64JavaThreadPDAccess implements JavaThreadPDAccess {
-  // private static AddressField  lastJavaPCField;
-  // private static AddressField  lastJavaFPField;
-  private static AddressField  lastJavaIFrameField;
-  private static AddressField  osThreadField;
-
-  // Field from OSThread
-  private static CIntegerField osThreadPThreadIDField;
-
-  // This is currently unneeded but is being kept in case we change
-  // the currentFrameGuess algorithm
-  private static final long GUESS_SCAN_RANGE = 128 * 1024;
-
-  static {
-    VM.registerVMInitializedObserver(new Observer() {
-        public void update(Observable o, Object data) {
-          initialize(VM.getVM().getTypeDataBase());
-        }
-      });
-  }
-
-  private static synchronized void initialize(TypeDataBase db) {
-    Type type = db.lookupType("JavaThread");
-
-    lastJavaIFrameField     = type.getAddressField("_last_Java_iframe");
-    osThreadField           = type.getAddressField("_osthread");
-
-    type = db.lookupType("OSThread");
-    osThreadPThreadIDField   = type.getCIntegerField("_pthread_id");
-  }
-
-  public    Address getLastJavaIFrame(Address addr) {
-    return lastJavaIFrameField.getValue(addr);
-  }
-
-
-  public    Address getBaseOfStackPointer(Address addr) {
-    return null;
-  }
-
-  public Address getLastJavaFP(Address addr) {
-    return null; // Not in 1.4.1
-  }
-
-  public    Address getLastJavaPC(Address addr) {
-    return null; // Not in 1.4.1
-  }
-
-  public boolean isInterpretedFrame() {
-
-    // In 1.4.1 there are only interpreted frames
-    // and there is no pc
-    return true;
-  }
-
-  public    Frame getLastFramePD(JavaThread thread, Address addr) {
-    // The thread is the JavaThread that contains "this"
-    // so we don't need any new accessor at the JavaThread level
-    Address iframe = getLastJavaIFrame(addr);
-    Address pc = thread.getLastJavaPC();
-    if (iframe == null) {
-      return null; // no information
-    }
-    return new IA64Frame(thread.getLastJavaSP(), iframe, pc);
-  }
-
-  public    RegisterMap newRegisterMap(JavaThread thread, boolean updateMap) {
-    return new IA64RegisterMap(thread, updateMap);
-  }
-
-  public    Frame getCurrentFrameGuess(JavaThread thread, Address addr) {
-    return getLastFramePD(thread, addr);
-  }
-
-  public    void printThreadIDOn(Address addr, PrintStream tty) {
-    tty.print(getThreadProxy(addr));
-  }
-
-  public    void printInfoOn(Address threadAddr, PrintStream tty) {
-    tty.print("Thread id: ");
-    printThreadIDOn(threadAddr, tty);
-    tty.println("\nLastJavaIFrame: " + getLastJavaIFrame(threadAddr));
-  }
-
-  public    Address getLastSP(Address addr) {
-    ThreadProxy t = getThreadProxy(addr);
-    IA64ThreadContext context = (IA64ThreadContext) t.getContext();
-    return context.getRegisterAsAddress(IA64ThreadContext.SP);
-  }
-
-  public    ThreadProxy getThreadProxy(Address addr) {
-    // Addr is the address of the JavaThread.
-    // Fetch the OSThread (for now and for simplicity, not making a
-    // separate "OSThread" class in this package)
-    Address osThreadAddr = osThreadField.getValue(addr);
-    // Get the address of the _pthread_id from the OSThread
-    Address pthreadIdAddr = osThreadAddr.addOffsetTo(osThreadPThreadIDField.getOffset());
-
-    JVMDebugger debugger = VM.getVM().getDebugger();
-    return debugger.getThreadForIdentifierAddress(pthreadIdAddr);
-  }
-}
--- ./hotspot/agent/src/share/classes/sun/jvm/hotspot/runtime/bsd_sparc/BsdSPARCJavaThreadPDAccess.java	2010-03-27 11:09:09.000000000 -0700
+++ ./hotspot/agent/src/share/classes/sun/jvm/hotspot/runtime/bsd_sparc/BsdSPARCJavaThreadPDAccess.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,165 +0,0 @@
-/*
- * Copyright 2006-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- *
- */
-
-package sun.jvm.hotspot.runtime.bsd_sparc;
-
-import java.io.*;
-import java.util.*;
-import sun.jvm.hotspot.debugger.*;
-import sun.jvm.hotspot.debugger.sparc.*;
-import sun.jvm.hotspot.runtime.*;
-import sun.jvm.hotspot.runtime.sparc.*;
-import sun.jvm.hotspot.types.*;
-import sun.jvm.hotspot.utilities.*;
-
-public class BsdSPARCJavaThreadPDAccess implements JavaThreadPDAccess {
-  private static AddressField baseOfStackPointerField;
-  private static AddressField postJavaStateField;
-  private static AddressField osThreadField;
-  private static int          isPC;
-  private static int          hasFlushed;
-
-  // Field from OSThread
-  private static CIntegerField osThreadThreadIDField;
-
-  static {
-    VM.registerVMInitializedObserver(new Observer() {
-        public void update(Observable o, Object data) {
-          initialize(VM.getVM().getTypeDataBase());
-        }
-      });
-  }
-
-  private static synchronized void initialize(TypeDataBase db) {
-    Type type = db.lookupType("JavaThread");
-    Type anchorType = db.lookupType("JavaFrameAnchor");
-
-    osThreadField           = type.getAddressField("_osthread");
-    hasFlushed              = db.lookupIntConstant("JavaFrameAnchor::flushed").intValue();
-
-    type = db.lookupType("OSThread");
-    osThreadThreadIDField   = type.getCIntegerField("_thread_id");
-  }
-
-  public    Address getLastJavaFP(Address addr) {
-        return null;
-
-  }
-
-  public    Address getLastJavaPC(Address addr) {
-    return null;
-  }
-
-  public Address getBaseOfStackPointer(Address addr) {
-    return baseOfStackPointerField.getValue(addr);
-  }
-
-  public Frame getLastFramePD(JavaThread thread, Address addr) {
-
-    // This assert doesn't work in the debugging case for threads
-    // which are running Java code and which haven't re-entered the
-    // runtime (e.g., through a Method.invoke() or otherwise). They
-    // haven't yet "decached" their last Java stack pointer to the
-    // thread.
-
-    //    if (Assert.ASSERTS_ENABLED) {
-    //      Assert.that(hasLastJavaFrame(), "must have last_Java_sp() when suspended");
-    //      // FIXME: add assertion about flushing register windows for runtime system
-    //      // (not appropriate for debugging system, though, unless at safepoin t)
-    //    }
-
-    // FIXME: I don't think this is necessary, but might be useful
-    // while debugging
-    if (thread.getLastJavaSP() == null) {
-      return null;
-    }
-
-    // sparc does a lazy window flush. The _flags field of the JavaFrameAnchor
-    // encodes whether the windows have flushed. Whenever the windows have flushed
-    // there will be a last_Java_pc.
-    // In a relective system we'd have to  do something to force the thread to flush
-    // its windows and give us the pc (or the younger_sp so we can find it ourselves)
-    // In a debugger situation (process or core) the flush should have happened and
-    // so if we don't have the younger sp we can find it
-    //
-    if (thread.getLastJavaPC() != null) {
-      return new SPARCFrame(SPARCFrame.biasSP(thread.getLastJavaSP()), thread.getLastJavaPC());
-    } else {
-      Frame top = getCurrentFrameGuess(thread, addr);
-      return new SPARCFrame(SPARCFrame.biasSP(thread.getLastJavaSP()),
-                            SPARCFrame.biasSP(SPARCFrame.findYoungerSP(top.getSP(), thread.getLastJavaSP())),
-                            false);
-    }
-
-
-  }
-
-  public RegisterMap newRegisterMap(JavaThread thread, boolean updateMap) {
-    return new SPARCRegisterMap(thread, updateMap);
-  }
-
-  public Frame getCurrentFrameGuess(JavaThread thread, Address addr) {
-    ThreadProxy t = getThreadProxy(addr);
-    SPARCThreadContext context = (SPARCThreadContext) t.getContext();
-    // For now, let's see what happens if we do a similar thing to
-    // what the runtime code does. I suspect this may cause us to lose
-    // the top frame from the stack.
-    Address sp = context.getRegisterAsAddress(SPARCThreadContext.R_SP);
-    Address pc = context.getRegisterAsAddress(SPARCThreadContext.R_PC);
-
-    if ((sp == null) || (pc == null)) {
-      // Problems (have not hit this case so far, but would be bad to continue if we did)
-      return null;
-    }
-
-    return new SPARCFrame(sp, pc);
-  }
-
-
-  public void printThreadIDOn(Address addr, PrintStream tty) {
-    tty.print(getThreadProxy(addr));
-  }
-
-  public Address getLastSP(Address addr) {
-    ThreadProxy t = getThreadProxy(addr);
-    SPARCThreadContext context = (SPARCThreadContext) t.getContext();
-    return SPARCFrame.unBiasSP(context.getRegisterAsAddress(SPARCThreadContext.R_SP));
-  }
-
-  public void printInfoOn(Address threadAddr, PrintStream tty) {
-  }
-
-  public ThreadProxy getThreadProxy(Address addr) {
-    // Fetch the OSThread (for now and for simplicity, not making a
-    // separate "OSThread" class in this package)
-    Address osThreadAddr = osThreadField.getValue(addr);
-    // Get the address of the thread ID from the OSThread
-    Address tidAddr = osThreadAddr.addOffsetTo(osThreadThreadIDField.getOffset());
-
-    JVMDebugger debugger = VM.getVM().getDebugger();
-    return debugger.getThreadForIdentifierAddress(tidAddr);
-  }
-
-
-}
--- ./hotspot/agent/src/share/classes/sun/jvm/hotspot/runtime/bsd_x86/BsdSignals.java	2010-03-27 11:09:09.000000000 -0700
+++ ./hotspot/agent/src/share/classes/sun/jvm/hotspot/runtime/bsd_x86/BsdSignals.java	2009-06-06 16:53:56.000000000 -0700
@@ -28,37 +28,36 @@
   private static String[] signalNames = {
     "",           /* No signal 0 */
     "SIGHUP",     /* hangup */
-    "SIGINT",     /* interrupt (rubout) */
-    "SIGQUIT",    /* quit (ASCII FS) */
-    "SIGILL",     /* illegal instruction (not reset when caught) */
+    "SIGINT",     /* interrupt */
+    "SIGQUIT",    /* quit */
+    "SIGILL",     /* illegal instr. (not reset when caught) */
     "SIGTRAP",    /* trace trap (not reset when caught) */
-    "SIGABRT",    /* used by abort, replace SIGIOT in the future */
-    "SIGIOT",
-    "SIGBUS",
+    "SIGABRT",    /* abort() */
+    "SIGEMT",     /* EMT instruction */
     "SIGFPE",     /* floating point exception */
     "SIGKILL",    /* kill (cannot be caught or ignored) */
-    "SIGUSR1",    /* user defined signal 1 */
+    "SIGBUS",     /* bus error */
     "SIGSEGV",    /* segmentation violation */
-    "SIGUSR2",    /* user defined signal 2 */
+    "SIGSYS",     /* non-existent system call invoked */
     "SIGPIPE",    /* write on a pipe with no one to read it */
     "SIGALRM",    /* alarm clock */
     "SIGTERM",    /* software termination signal from kill */
-    "SIGSTKFLT",
-    "SIGCHLD",    /* child status change alias */
-    "SIGCONT",    /* stopped process has been continued */
-    "SIGSTOP",    /* stop (cannot be caught or ignored) */
-    "SIGTSTP",    /* user stop requested from tty */
-    "SIGTTIN",    /* background tty read attempted */
-    "SIGTTOU",    /* background tty write attempted */
-    "SIGURG",     /* urgent socket condition */
-    "SIGXCPU",    /* exceeded cpu limit */
+    "SIGURG",     /* urgent condition on IO channel */
+    "SIGSTOP",    /* sendable stop signal not from tty */
+    "SIGTSTP",    /* stop signal from tty */
+    "SIGCONT",    /* continue a stopped process */
+    "SIGCHLD",    /* to parent on child stop or exit */
+    "SIGTTIN",    /* to readers pgrp upon background tty read */
+    "SIGTTOU",    /* like TTIN if (tp->t_local&LTOSTOP) */
+    "SIGIO",      /* input/output possible signal */
+    "SIGXCPU",    /* exceeded CPU time limit */
     "SIGXFSZ",    /* exceeded file size limit */
-    "SIGVTALRM",  /* virtual timer expired */
-    "SIGPROF",    /* profiling timer expired */
-    "SIGWINCH",   /* window size change */
-    "SIGPOLL",    /* pollable event occured */
-    "SIGPWR",     /* power-fail restart */
-    "SIGSYS"
+    "SIGVTALRM",  /* virtual time alarm */
+    "SIGPROF",    /* profiling time alarm */
+    "SIGWINCH",   /* window size changes */
+    "SIGINFO",    /* information request */
+    "SIGUSR1",    /* user defined signal 1 */
+    "SIGUSR2"     /* user defined signal 2 */
   };
 
   public static String getSignalName(int sigNum) {
--- ./hotspot/agent/src/share/classes/sun/jvm/hotspot/utilities/PlatformInfo.java	2010-03-18 01:41:36.000000000 -0700
+++ ./hotspot/agent/src/share/classes/sun/jvm/hotspot/utilities/PlatformInfo.java	2009-06-06 16:53:57.000000000 -0700
@@ -37,6 +37,14 @@
       return "solaris";
     } else if (os.equals("Linux")) {
       return "linux";
+    } else if (os.equals("FreeBSD")) {
+      return "bsd";
+    } else if (os.equals("NetBSD")) {
+      return "bsd";
+    } else if (os.equals("OpenBSD")) {
+      return "bsd";
+    } else if (os.equals("Darwin")) {
+      return "bsd";
     } else if (os.startsWith("Windows")) {
       return "win32";
     } else {
--- ./hotspot/make/Makefile	2010-03-18 01:41:36.000000000 -0700
+++ ./hotspot/make/Makefile	2010-02-15 08:08:22.000000000 -0800
@@ -290,20 +290,20 @@
 # Shared Library
 ifneq ($(OSNAME),windows)
   ifeq ($(ZERO_BUILD), true)
-$(EXPORT_JRE_LIB_ARCH_DIR)/%.so: $(ZERO_DIR)/%.so
+$(EXPORT_JRE_LIB_ARCH_DIR)/%.$(LIBRARY_SUFFIX): $(ZERO_DIR)/%.$(LIBRARY_SUFFIX)
 	$(install-file)
-$(EXPORT_SERVER_DIR)/%.so:       $(ZERO_DIR)/%.so
+$(EXPORT_SERVER_DIR)/%.$(LIBRARY_SUFFIX):       $(ZERO_DIR)/%.$(LIBRARY_SUFFIX)
 	$(install-file)
   else
-$(EXPORT_JRE_LIB_ARCH_DIR)/%.so: $(C2_DIR)/%.so
+$(EXPORT_JRE_LIB_ARCH_DIR)/%.$(LIBRARY_SUFFIX): $(C2_DIR)/%.$(LIBRARY_SUFFIX)
 	$(install-file)
-$(EXPORT_CLIENT_DIR)/%.so:       $(C1_DIR)/%.so
+$(EXPORT_CLIENT_DIR)/%.$(LIBRARY_SUFFIX):       $(C1_DIR)/%.$(LIBRARY_SUFFIX)
 	$(install-file)
-$(EXPORT_CLIENT_DIR)/64/%.so:    $(C1_DIR)/%.so
+$(EXPORT_CLIENT_DIR)/64/%.$(LIBRARY_SUFFIX):    $(C1_DIR)/%.$(LIBRARY_SUFFIX)
 	$(install-file)
-$(EXPORT_SERVER_DIR)/%.so:       $(C2_DIR)/%.so
+$(EXPORT_SERVER_DIR)/%.$(LIBRARY_SUFFIX):       $(C2_DIR)/%.$(LIBRARY_SUFFIX)
 	$(install-file)
-$(EXPORT_SERVER_DIR)/64/%.so:    $(C2_DIR)/%.so
+$(EXPORT_SERVER_DIR)/64/%.$(LIBRARY_SUFFIX):    $(C2_DIR)/%.$(LIBRARY_SUFFIX)
 	$(install-file)
   endif
 endif
--- ./hotspot/make/bsd/Makefile	2010-03-27 11:09:09.000000000 -0700
+++ ./hotspot/make/bsd/Makefile	2009-11-04 19:52:29.000000000 -0800
@@ -39,11 +39,11 @@
 # One can set ALT_BOOTDIR or BOOTDIR to point to a jdk that runs on
 # an architecture that differs from the target architecture, as long
 # as the bootstrap jdk runs under the same flavor of OS as the target
-# (i.e., if the target is bsd, point to a jdk that runs on a bsd
+# (i.e., if the target is linux, point to a jdk that runs on a linux
 # box).  In order to use such a bootstrap jdk, set the make variable
 # REMOTE to the desired remote command mechanism, e.g.,
 #
-#    make REMOTE="rsh -l me myotherbsdbox"
+#    make REMOTE="rsh -l me myotherlinuxbox"
 
 # Along with VM, Serviceability Agent (SA) is built for SA/JDI binding. 
 # JDI binding on SA produces two binaries: 
@@ -94,7 +94,7 @@
 #
 # We only do this on SunOS variants, for a couple of reasons:
 #  * It is extremely rare that source trees exist on other systems
-#  * It has been claimed that the Bsd automounter is flakey, so
+#  * It has been claimed that the Linux automounter is flakey, so
 #    changing GAMMADIR in a way that exercises the automounter could
 #    prove to be a source of unreliability in the build process.
 # Obviously, this Makefile is only relevant on SunOS boxes to begin
@@ -216,11 +216,12 @@
 
 checks: check_os_version check_j2se_version
 
-# We do not want people accidentally building on old systems (e.g. Bsd 2.2.x,
+# We do not want people accidentally building on old systems (e.g. Linux 2.2.x,
 # Solaris 2.5.1, 2.6).
 # Disable this check by setting DISABLE_HOTSPOT_OS_VERSION_CHECK=ok.
 
-SUPPORTED_OS_VERSION = 2.4% 2.5% 2.6% 2.7%
+#SUPPORTED_OS_VERSION = 2.4% 2.5% 2.6% 2.7%
+DISABLE_HOTSPOT_OS_VERSION_CHECK = ok
 OS_VERSION := $(shell uname -r)
 EMPTY_IF_NOT_SUPPORTED = $(filter $(SUPPORTED_OS_VERSION),$(OS_VERSION))
 
--- ./hotspot/make/bsd/makefiles/buildtree.make	2010-03-27 11:09:09.000000000 -0700
+++ ./hotspot/make/bsd/makefiles/buildtree.make	2009-11-04 19:52:29.000000000 -0800
@@ -287,10 +287,11 @@
 	[ -n "$$JAVA_HOME" ] && { echo ": \$${JAVA_HOME:=$${JAVA_HOME}}"; }; \
 	{ \
 	echo "LD_LIBRARY_PATH=.:$${LD_LIBRARY_PATH:+$$LD_LIBRARY_PATH:}\$${JAVA_HOME}/jre/lib/${LIBARCH}/native_threads:\$${JAVA_HOME}/jre/lib/${LIBARCH}:${GCC_LIB}"; \
+	echo "DYLD_LIBRARY_PATH=.:$${DYLD_LIBRARY_PATH:+$$DYLD_LIBRARY_PATH:}\$${JAVA_HOME}/jre/lib/${LIBARCH}/native_threads:\$${JAVA_HOME}/jre/lib/${LIBARCH}:${GCC_LIB}"; \
 	echo "CLASSPATH=$${CLASSPATH:+$$CLASSPATH:}.:\$${JAVA_HOME}/jre/lib/rt.jar:\$${JAVA_HOME}/jre/lib/i18n.jar"; \
 	} | sed s:$${JAVA_HOME:--------}:\$${JAVA_HOME}:g; \
 	echo "HOTSPOT_BUILD_USER=\"$${LOGNAME:-$$USER} in `basename $(GAMMADIR)`\""; \
-	echo "export JAVA_HOME LD_LIBRARY_PATH CLASSPATH HOTSPOT_BUILD_USER"; \
+	echo "export JAVA_HOME LD_LIBRARY_PATH DYLD_LIBRARY_PATH CLASSPATH HOTSPOT_BUILD_USER"; \
 	) > $@
 
 env.csh: env.sh
--- ./hotspot/make/bsd/makefiles/cscope.make	2010-03-27 11:09:09.000000000 -0700
+++ ./hotspot/make/bsd/makefiles/cscope.make	2009-06-06 16:53:58.000000000 -0700
@@ -71,7 +71,7 @@
 # OS-specific files for other systems are excluded by default.  Use CS_OS=yes
 # to include platform-specific files for other platforms.
 ifndef	CS_OS
-CS_OS		= bsd macos solaris win32
+CS_OS		= linux macos solaris win32 bsd
 CS_PRUNE_OS	= $(patsubst %,-o -name '*%*',$(filter-out ${OS},${CS_OS}))
 endif
 
--- ./hotspot/make/bsd/makefiles/defs.make	2010-03-27 11:09:09.000000000 -0700
+++ ./hotspot/make/bsd/makefiles/defs.make	2009-11-04 21:25:27.000000000 -0800
@@ -72,8 +72,8 @@
   HS_ARCH            = sparc
 endif
 
-# x86_64
-ifeq ($(ARCH), x86_64) 
+# amd64
+ifeq ($(ARCH), amd64) 
   ifeq ($(ARCH_DATA_MODEL), 64)
     ARCH_DATA_MODEL = 64
     MAKE_ARGS       += LP64=1
@@ -85,43 +85,61 @@
     PLATFORM        = bsd-i586
     VM_PLATFORM     = bsd_i486
     HS_ARCH         = x86
-    # We have to reset ARCH to i686 since SRCARCH relies on it
-    ARCH            = i686   
+    # We have to reset ARCH to i386 since SRCARCH relies on it
+    ARCH            = i386   
   endif
 endif
 
-# i686
-ifeq ($(ARCH), i686)
-  ARCH_DATA_MODEL  = 32
-  PLATFORM         = bsd-i586
-  VM_PLATFORM      = bsd_i486
-  HS_ARCH          = x86
+# i386
+ifeq ($(ARCH), i386)
+  ifeq ($(ARCH_DATA_MODEL), 64)
+    ARCH_DATA_MODEL = 64
+    MAKE_ARGS       += LP64=1
+    PLATFORM        = bsd-amd64
+    VM_PLATFORM     = bsd_amd64
+    HS_ARCH         = x86
+    # We have to reset ARCH to amd64 since SRCARCH relies on it
+    ARCH            = amd64
+  else
+    ARCH_DATA_MODEL  = 32
+    PLATFORM         = bsd-i586
+    VM_PLATFORM      = bsd_i486
+    HS_ARCH          = x86
+  endif
 endif
 
 JDK_INCLUDE_SUBDIR=bsd
 
+# Library suffix
+OS_VENDOR:=$(shell uname -s)
+ifeq ($(OS_VENDOR),Darwin)
+  LIBRARY_SUFFIX=dylib
+else
+  LIBRARY_SUFFIX=so
+endif
+
 # FIXUP: The subdirectory for a debug build is NOT the same on all platforms
 VM_DEBUG=jvmg
 
 EXPORT_LIST += $(EXPORT_DOCS_DIR)/platform/jvmti/jvmti.html
 
 # client and server subdirectories have symbolic links to ../libjsig.so
-EXPORT_LIST += $(EXPORT_JRE_LIB_ARCH_DIR)/libjsig.so
+EXPORT_LIST += $(EXPORT_JRE_LIB_ARCH_DIR)/libjsig.$(LIBRARY_SUFFIX)
 
 EXPORT_SERVER_DIR = $(EXPORT_JRE_LIB_ARCH_DIR)/server
 EXPORT_LIST += $(EXPORT_SERVER_DIR)/Xusage.txt
-EXPORT_LIST += $(EXPORT_SERVER_DIR)/libjvm.so
+EXPORT_LIST += $(EXPORT_SERVER_DIR)/libjvm.$(LIBRARY_SUFFIX)
 ifneq ($(ZERO_BUILD), true)
   ifeq ($(ARCH_DATA_MODEL), 32)
     EXPORT_CLIENT_DIR = $(EXPORT_JRE_LIB_ARCH_DIR)/client
     EXPORT_LIST += $(EXPORT_CLIENT_DIR)/Xusage.txt
-    EXPORT_LIST += $(EXPORT_CLIENT_DIR)/libjvm.so 
-    EXPORT_LIST += $(EXPORT_JRE_LIB_ARCH_DIR)/libsaproc.so
-    EXPORT_LIST += $(EXPORT_LIB_DIR)/sa-jdi.jar 
+    EXPORT_LIST += $(EXPORT_CLIENT_DIR)/libjvm.$(LIBRARY_SUFFIX)
+    EXPORT_LIST += $(EXPORT_JRE_LIB_ARCH_DIR)/libsaproc.$(LIBRARY_SUFFIX)
+    EXPORT_LIST += $(EXPORT_LIB_DIR)/sa-jdi.jar
   else
     ifeq ($(ARCH),ia64)
       else
-        EXPORT_LIST += $(EXPORT_JRE_LIB_ARCH_DIR)/libsaproc.so
+        EXPORT_LIST += $(EXPORT_JRE_LIB_ARCH_DIR)/libsaproc.$(LIBRARY_SUFFIX)
         EXPORT_LIST += $(EXPORT_LIB_DIR)/sa-jdi.jar
     endif
   endif
--- ./hotspot/make/bsd/makefiles/gcc.make	2010-03-27 11:09:09.000000000 -0700
+++ ./hotspot/make/bsd/makefiles/gcc.make	2009-11-04 19:52:29.000000000 -0800
@@ -22,12 +22,15 @@
 #  
 #
 
+OS_VENDOR = $(shell uname -s)
+
 #------------------------------------------------------------------------
 # CC, CPP & AS
 
-CPP = g++
-CC  = gcc
-AS  = $(CC) -c
+CXX ?= g++
+CPP  = $(CXX)
+CC  ?= gcc
+AS   = $(CC) -c -x assembler-with-cpp
 
 # -dumpversion in gcc-2.91 shows "egcs-2.91.66". In later version, it only
 # prints the numbers (e.g. "2.95", "3.2.1")
@@ -58,7 +61,7 @@
 CFLAGS += $(VM_PICFLAG)
 CFLAGS += -fno-rtti
 CFLAGS += -fno-exceptions
-CFLAGS += -D_REENTRANT
+CFLAGS += -pthread
 CFLAGS += -fcheck-new
 
 ARCHFLAG = $(ARCHFLAG/$(BUILDARCH))
@@ -69,6 +72,12 @@
 ARCHFLAG/sparcv9 = -m64 -mcpu=v9
 ARCHFLAG/zero    = $(ZERO_ARCHFLAG)
 
+# Darwin-specific build flags
+ifeq ($(OS_VENDOR), Darwin)
+  # Ineffecient 16-byte stack re-alignment on Darwin/IA32
+  ARCHFLAG/i486 += -mstackrealign
+endif
+
 CFLAGS     += $(ARCHFLAG)
 AOUT_FLAGS += $(ARCHFLAG)
 LFLAGS     += $(ARCHFLAG)
@@ -102,6 +111,11 @@
 CFLAGS_WARN/DEFAULT = $(WARNINGS_ARE_ERRORS) $(ACCEPTABLE_WARNINGS)
 # Special cases
 CFLAGS_WARN/BYFILE = $(CFLAGS_WARN/$@)$(CFLAGS_WARN/DEFAULT$(CFLAGS_WARN/$@)) 
+# XXXDARWIN: for _dyld_bind_fully_image_containing_address
+ifeq ($(OS_VENDOR), Darwin)
+  CFLAGS_WARN/os_bsd.o = $(CFLAGS_WARN/DEFAULT) -Wno-deprecated-declarations
+endif
+
 
 # The flags to use for an Optimized g++ build
 OPT_CFLAGS += -O3
@@ -137,28 +151,40 @@
 LFLAGS += -Wl,-relax
 endif
 
-# Enable linker optimization
-LFLAGS += -Xlinker -O1
-
-# If this is a --hash-style=gnu system, use --hash-style=both
-#   The gnu .hash section won't work on some Bsd systems like SuSE 10.
-_HAS_HASH_STYLE_GNU:=$(shell $(CC) -dumpspecs | grep -- '--hash-style=gnu')
-ifneq ($(_HAS_HASH_STYLE_GNU),)
-  LDFLAGS_HASH_STYLE = -Wl,--hash-style=both
-endif
-LFLAGS += $(LDFLAGS_HASH_STYLE)
-
 # Use $(MAPFLAG:FILENAME=real_file_name) to specify a map file.
 MAPFLAG = -Xlinker --version-script=FILENAME
 
-# Use $(SONAMEFLAG:SONAME=soname) to specify the intrinsic name of a shared obj
-SONAMEFLAG = -Xlinker -soname=SONAME
+#
+# Shared Library
+#
+ifeq ($(OS_VENDOR), Darwin)
+  # Standard linker flags
+  LFLAGS +=
+
+  # Darwin doesn't use ELF and doesn't support version scripts
+  LDNOMAP = true
+
+  # Use $(SONAMEFLAG:SONAME=soname) to specify the intrinsic name of a shared obj
+  SONAMEFLAG =
+
+  # Build shared library
+  SHARED_FLAG = -dynamiclib $(VM_PICFLAG)
 
-# Build shared library
-SHARED_FLAG = -shared
+  # Keep symbols even they are not used
+  #AOUT_FLAGS += -export-dynamic
+else
+  # Enable linker optimization
+  LFLAGS += -Xlinker -O1
+
+  # Use $(SONAMEFLAG:SONAME=soname) to specify the intrinsic name of a shared obj
+  SONAMEFLAG = -Xlinker -soname=SONAME
 
-# Keep symbols even they are not used
-AOUT_FLAGS += -export-dynamic
+  # Build shared library
+  SHARED_FLAG = -shared $(VM_PICFLAG)
+
+  # Keep symbols even they are not used
+  AOUT_FLAGS += -export-dynamic
+endif
 
 #------------------------------------------------------------------------
 # Debug flags
--- ./hotspot/make/bsd/makefiles/jsig.make	2010-03-27 11:09:10.000000000 -0700
+++ ./hotspot/make/bsd/makefiles/jsig.make	2010-01-16 14:17:37.000000000 -0800
@@ -25,11 +25,16 @@
 # Rules to build signal interposition library, used by vm.make
 
 # libjsig[_g].so: signal interposition library
-JSIG = jsig
-LIBJSIG = lib$(JSIG).so
+JSIG   = jsig
+JSIG_G = $(JSIG)$(G_SUFFIX)
 
-JSIG_G    = $(JSIG)$(G_SUFFIX)
-LIBJSIG_G = lib$(JSIG_G).so
+ifeq ($(OS_VENDOR), Darwin)
+  LIBJSIG   = lib$(JSIG).dylib
+  LIBJSIG_G = lib$(JSIG_G).dylib
+else
+  LIBJSIG   = lib$(JSIG).so
+  LIBJSIG_G = lib$(JSIG_G).so
+endif
 
 JSIGSRCDIR = $(GAMMADIR)/src/os/$(Platform_os_family)/vm
 
@@ -42,7 +47,7 @@
 # cause problems with interposing. See CR: 6466665
 # LFLAGS_JSIG += $(MAPFLAG:FILENAME=$(LIBJSIG_MAPFILE))
 
-LFLAGS_JSIG += -D_GNU_SOURCE -D_REENTRANT $(LDFLAGS_HASH_STYLE)
+LFLAGS_JSIG += -D_GNU_SOURCE -pthread $(LDFLAGS_HASH_STYLE)
 
 # DEBUG_BINARIES overrides everything, use full -g debug information
 ifeq ($(DEBUG_BINARIES), true)
@@ -52,7 +57,7 @@
 $(LIBJSIG): $(JSIGSRCDIR)/jsig.c $(LIBJSIG_MAPFILE)
 	@echo Making signal interposition lib...
 	$(QUIETLY) $(CC) $(SYMFLAG) $(ARCHFLAG) $(SHARED_FLAG) $(PICFLAG) \
-                         $(LFLAGS_JSIG) $(JSIG_DEBUG_CFLAGS) -o $@ $< -ldl
+                         $(LFLAGS_JSIG) $(JSIG_DEBUG_CFLAGS) -o $@ $<
 	$(QUIETLY) [ -f $(LIBJSIG_G) ] || { ln -s $@ $(LIBJSIG_G); }
 
 install_jsig: $(LIBJSIG)
--- ./hotspot/make/bsd/makefiles/launcher.make	2010-03-27 11:09:10.000000000 -0700
+++ ./hotspot/make/bsd/makefiles/launcher.make	2010-01-16 14:12:37.000000000 -0800
@@ -46,7 +46,7 @@
   LIBS_LAUNCHER             += $(STATIC_STDCXX) $(LIBS)
 else
   LAUNCHER.o                 = launcher.o
-  LFLAGS_LAUNCHER           += -L `pwd`
+  LFLAGS_LAUNCHER           += -L`pwd`
   LIBS_LAUNCHER             += -l$(JVM) $(LIBS)
 endif
 
--- ./hotspot/make/bsd/makefiles/sa.make	2010-03-27 11:09:10.000000000 -0700
+++ ./hotspot/make/bsd/makefiles/sa.make	2009-11-04 19:52:29.000000000 -0800
@@ -42,8 +42,8 @@
 
 # gnumake 3.78.1 does not accept the *s that
 # are in AGENT_FILES1 and AGENT_FILES2, so use the shell to expand them
-AGENT_FILES1 := $(shell /usr/bin/test -d $(AGENT_DIR) && /bin/ls $(AGENT_FILES1))
-AGENT_FILES2 := $(shell /usr/bin/test -d $(AGENT_DIR) && /bin/ls $(AGENT_FILES2))
+AGENT_FILES1 := $(shell /bin/test -d $(AGENT_DIR) && /bin/ls $(AGENT_FILES1))
+AGENT_FILES2 := $(shell /bin/test -d $(AGENT_DIR) && /bin/ls $(AGENT_FILES2))
 
 SA_CLASSDIR = $(GENERATED)/saclasses
 
--- ./hotspot/make/bsd/makefiles/saproc.make	2010-03-27 11:09:10.000000000 -0700
+++ ./hotspot/make/bsd/makefiles/saproc.make	2010-01-16 14:19:38.000000000 -0800
@@ -25,23 +25,34 @@
 # Rules to build serviceability agent library, used by vm.make
 
 # libsaproc[_g].so: serviceability agent
-
-SAPROC = saproc
-LIBSAPROC = lib$(SAPROC).so
-
+SAPROC   = saproc
 SAPROC_G = $(SAPROC)$(G_SUFFIX)
-LIBSAPROC_G = lib$(SAPROC_G).so
+
+ifeq ($(OS_VENDOR), Darwin)
+  LIBSAPROC   = lib$(SAPROC).dylib
+  LIBSAPROC_G = lib$(SAPROC_G).dylib
+else
+  LIBSAPROC   = lib$(SAPROC).so
+  LIBSAPROC_G = lib$(SAPROC_G).so
+endif
 
 AGENT_DIR = $(GAMMADIR)/agent
 
 SASRCDIR = $(AGENT_DIR)/src/os/$(Platform_os_family)
 
+ifeq ($(OS_VENDOR), FreeBSD)
 SASRCFILES = $(SASRCDIR)/salibelf.c                   \
              $(SASRCDIR)/symtab.c                     \
              $(SASRCDIR)/libproc_impl.c               \
              $(SASRCDIR)/ps_proc.c                    \
              $(SASRCDIR)/ps_core.c                    \
+             $(SASRCDIR)/hsearch_r.c                  \
              $(SASRCDIR)/BsdDebuggerLocal.c
+SALIBS = -lutil -lthread_db
+else
+SASRCFILES = $(SASRCDIR)/StubDebuggerLocal.c
+SALIBS = 
+endif
 
 SAMAPFILE = $(SASRCDIR)/mapfile
 
@@ -60,7 +71,10 @@
 	   $(MAKE) -f vm.make $(LIBSAPROC); \
 	fi
 
-SA_LFLAGS = $(MAPFLAG:FILENAME=$(SAMAPFILE)) $(LDFLAGS_HASH_STYLE)
+ifneq ($(OS_VENDOR), Darwin)
+SA_LFLAGS = $(MAPFLAG:FILENAME=$(SAMAPFILE))
+endif
+SA_LFLAGS += $(LDFLAGS_HASH_STYLE)
 
 $(LIBSAPROC): $(SASRCFILES) $(SAMAPFILE)
 	$(QUIETLY) if [ "$(BOOT_JAVA_HOME)" = "" ]; then \
@@ -73,12 +87,12 @@
 	           -I$(SASRCDIR)                                        \
 	           -I$(GENERATED)                                       \
 	           -I$(BOOT_JAVA_HOME)/include                          \
-	           -I$(BOOT_JAVA_HOME)/include/$(Platform_os_family)    \
+	           -I$(BOOT_JAVA_HOME)/include/$(shell uname -s | tr "[:upper:]" "[:lower:]") \
 	           $(SASRCFILES)                                        \
 	           $(SA_LFLAGS)                                         \
 	           $(SA_DEBUG_CFLAGS)                                   \
 	           -o $@                                                \
-	           -lthread_db
+	           $(SALIBS)
 	$(QUIETLY) [ -f $(LIBSAPROC_G) ] || { ln -s $@ $(LIBSAPROC_G); }
 
 install_saproc: checkAndBuildSA
--- ./hotspot/make/bsd/makefiles/vm.make	2010-03-27 11:09:10.000000000 -0700
+++ ./hotspot/make/bsd/makefiles/vm.make	2010-01-30 19:00:06.000000000 -0800
@@ -99,7 +99,7 @@
 # Extra flags from gnumake's invocation or environment
 CFLAGS += $(EXTRA_CFLAGS)
 
-LIBS += -lm -ldl -lpthread
+LIBS += -lm -pthread
 
 # By default, link the *.o into the library, not the executable.
 LINK_INTO$(LINK_INTO) = LIBJVM
@@ -113,9 +113,15 @@
 #----------------------------------------------------------------------
 # JVM
 
-JVM      = jvm
-LIBJVM   = lib$(JVM).so
-LIBJVM_G = lib$(JVM)$(G_SUFFIX).so
+JVM    = jvm
+ifeq ($(OS_VENDOR), Darwin)
+  LIBJVM   = lib$(JVM).dylib
+  LIBJVM_G = lib$(JVM)$(G_SUFFIX).dylib
+  CFLAGS  += -D_XOPEN_SOURCE -D_DARWIN_C_SOURCE
+else
+  LIBJVM   = lib$(JVM).so
+  LIBJVM_G = lib$(JVM)$(G_SUFFIX).so
+endif
 
 JVM_OBJ_FILES = $(Obj_Files)
 
@@ -129,11 +135,7 @@
 	rm -f $@
 	cat $^ > $@
 
-ifeq ($(ZERO_LIBARCH), ppc64)
-  STATIC_CXX = false
-else
-  STATIC_CXX = true
-endif
+STATIC_CXX = false
 
 ifeq ($(LINK_INTO),AOUT)
   LIBJVM.o                 =
@@ -145,14 +147,21 @@
   LFLAGS_VM$(LDNOMAP)      += $(MAPFLAG:FILENAME=$(LIBJVM_MAPFILE))
   LFLAGS_VM                += $(SONAMEFLAG:SONAME=$(LIBJVM))
 
+  ifeq ($(OS_VENDOR), Darwin)
+    LFLAGS_VM += -Xlinker -rpath -Xlinker @loader_path/.
+    LFLAGS_VM += -Xlinker -rpath -Xlinker @loader_path/..
+    LFLAGS_VM += -Xlinker -install_name -Xlinker @rpath/$(@F)
+  endif
+
   # JVM is statically linked with libgcc[_s] and libstdc++; this is needed to
   # get around library dependency and compatibility issues. Must use gcc not
   # g++ to link.
   ifeq ($(STATIC_CXX), true)
     LFLAGS_VM              += $(STATIC_LIBGCC)
     LIBS_VM                += $(STATIC_STDCXX)
+    LINK_VM                = $(LINK_LIB.c)
   else
-    LIBS_VM                += -lstdc++
+    LINK_VM                = $(LINK_LIB.CC)
   endif
 
   LIBS_VM                  += $(LIBS)
@@ -161,7 +170,6 @@
   LIBS_VM += $(LIBFFI_LIBS)
 endif
 
-LINK_VM = $(LINK_LIB.c)
 
 # rule for building precompiled header
 $(PRECOMPILED_HEADER): $(Precompiled_Files)
@@ -189,11 +197,6 @@
 LD_SCRIPT_FLAG = -Wl,-T,$(LD_SCRIPT)
 endif
 
-# With more recent Redhat releases (or the cutting edge version Fedora), if
-# SEBsd is configured to be enabled, the runtime linker will fail to apply
-# the text relocation to libjvm.so considering that it is built as a non-PIC
-# DSO. To workaround that, we run chcon to libjvm.so after it is built. See 
-# details in bug 6538311.
 $(LIBJVM): $(LIBJVM.o) $(LIBJVM_MAPFILE) $(LD_SCRIPT)
 	$(QUIETLY) {                                                    \
 	    echo Linking vm...;                                         \
@@ -203,15 +206,6 @@
 	    $(LINK_LIB.CC/POST_HOOK)                                    \
 	    rm -f $@.1; ln -s $@ $@.1;                                  \
 	    [ -f $(LIBJVM_G) ] || { ln -s $@ $(LIBJVM_G); ln -s $@.1 $(LIBJVM_G).1; }; \
-	    if [ -x /usr/sbin/sebsdenabled ] ; then                   \
-	      /usr/sbin/sebsdenabled;                                 \
-              if [ $$? = 0 ] ; then					\
-		/usr/bin/chcon -t textrel_shlib_t $@;                   \
-		if [ $$? != 0 ]; then                                   \
-		  echo "ERROR: Cannot chcon $@";			\
-		fi							\
-	      fi							\
-	    fi                                                          \
 	}
 
 DEST_JVM = $(JDK_LIBDIR)/$(VM_SUBDIR)/$(LIBJVM)
--- ./hotspot/make/bsd/makefiles/zeroshark.make	2010-03-27 11:09:10.000000000 -0700
+++ ./hotspot/make/bsd/makefiles/zeroshark.make	2009-12-20 19:41:23.000000000 -0800
@@ -40,4 +40,23 @@
   CFLAGS += -D_LP64=1
 endif
 
+# Specify the path to the FFI headers
+ifdef ALT_PACKAGE_PATH
+  PACKAGE_PATH = $(ALT_PACKAGE_PATH)
+else
+  ifeq ($(OS_VENDOR),Apple)
+    PACKAGE_PATH = /opt/local
+  else
+    ifeq ($(OS_VENDOR),NetBSD)
+      PACKAGE_PATH = /usr/pkg
+      LIBS += -Wl,-R${PACKAGE_PATH}/lib
+    else
+      PACKAGE_PATH = /usr/local
+    endif
+  endif
+endif
+
+CFLAGS += -I$(PACKAGE_PATH)/include
+LIBS += -L$(PACKAGE_PATH)/lib -lffi
+
 OPT_CFLAGS/compactingPermGenGen.o = -O1
--- ./hotspot/make/bsd/platform_amd64	2010-03-27 11:09:10.000000000 -0700
+++ ./hotspot/make/bsd/platform_amd64	2009-06-06 16:53:58.000000000 -0700
@@ -12,4 +12,4 @@
 
 compiler = gcc
 
-sysdefs = -DBSD -D_GNU_SOURCE -DAMD64
+sysdefs = -D_ALLBSD_SOURCE -D_GNU_SOURCE -DAMD64
--- ./hotspot/make/bsd/platform_amd64.suncc	2010-03-27 11:09:10.000000000 -0700
+++ ./hotspot/make/bsd/platform_amd64.suncc	2010-01-17 15:46:11.000000000 -0800
@@ -14,4 +14,4 @@
 
 gnu_dis_arch = amd64
 
-sysdefs = -DBSD -DSPARC_WORKS -D_GNU_SOURCE -DAMD64
+sysdefs = -D_ALLBSD_SOURCE -DSPARC_WORKS -D_GNU_SOURCE -DAMD64
--- ./hotspot/make/bsd/platform_i486	2010-03-27 11:09:10.000000000 -0700
+++ ./hotspot/make/bsd/platform_i486	2009-06-06 16:53:58.000000000 -0700
@@ -12,4 +12,4 @@
 
 compiler = gcc
 
-sysdefs = -DBSD -D_GNU_SOURCE -DIA32
+sysdefs = -D_ALLBSD_SOURCE -D_GNU_SOURCE -DIA32
--- ./hotspot/make/bsd/platform_i486.suncc	2010-03-27 11:09:10.000000000 -0700
+++ ./hotspot/make/bsd/platform_i486.suncc	2010-01-17 15:46:11.000000000 -0800
@@ -14,4 +14,4 @@
 
 gnu_dis_arch = i386
 
-sysdefs = -DBSD -DSPARC_WORKS -D_GNU_SOURCE -DIA32
+sysdefs = -D_ALLBSD_SOURCE -DSPARC_WORKS -D_GNU_SOURCE -DIA32
--- ./hotspot/make/bsd/platform_ia64	2010-03-27 11:09:10.000000000 -0700
+++ ./hotspot/make/bsd/platform_ia64	2010-01-17 15:46:11.000000000 -0800
@@ -10,6 +10,6 @@
 
 gnu_dis_arch = ia64
 
-sysdefs = -DBSD -D_GNU_SOURCE -DIA64 -DCC_INTERP
+sysdefs = -D_ALLBSD_SOURCE -D_GNU_SOURCE -DIA64 -DCC_INTERP
 
 mark_style = alignment
--- ./hotspot/make/bsd/platform_sparc	2010-03-27 11:09:10.000000000 -0700
+++ ./hotspot/make/bsd/platform_sparc	2009-06-06 16:53:58.000000000 -0700
@@ -12,4 +12,4 @@
 
 compiler = gcc
 
-sysdefs = -DBSD -D_GNU_SOURCE -DSPARC
+sysdefs = -D_ALLBSD_SOURCE -D_GNU_SOURCE -DSPARC
--- ./hotspot/make/bsd/platform_sparcv9	2010-03-27 11:09:10.000000000 -0700
+++ ./hotspot/make/bsd/platform_sparcv9	2010-01-17 15:46:11.000000000 -0800
@@ -12,4 +12,4 @@
 
 compiler = gcc
 
-sysdefs = -DBSD -D_GNU_SOURCE -DSPARC
+sysdefs = -D_ALLBSD_SOURCE -D_GNU_SOURCE -DSPARC
--- ./hotspot/make/bsd/platform_zero.in	2010-03-27 11:09:10.000000000 -0700
+++ ./hotspot/make/bsd/platform_zero.in	2009-11-04 19:52:29.000000000 -0800
@@ -14,4 +14,4 @@
 
 gnu_dis_arch = zero
 
-sysdefs = -DBSD -D_GNU_SOURCE -DCC_INTERP -DZERO -D@ZERO_ARCHDEF@ -DZERO_LIBARCH=\"@ZERO_LIBARCH@\"
+sysdefs = -D_ALLBSD_SOURCE -D_GNU_SOURCE -DCC_INTERP -DZERO -D@ZERO_ARCHDEF@ -DZERO_LIBARCH=\"@ZERO_LIBARCH@\"
--- ./hotspot/make/defs.make	2010-03-18 01:41:36.000000000 -0700
+++ ./hotspot/make/defs.make	2010-02-15 08:08:22.000000000 -0800
@@ -119,13 +119,23 @@
 # Windows should have OS predefined
 ifeq ($(OS),)
   OS   := $(shell uname -s)
+  ifneq ($(findstring BSD,$(OS)),)
+    OS=bsd
+  endif
+  ifeq ($(OS), Darwin)
+    OS=bsd
+  endif
   HOST := $(shell uname -n)
 endif
 
-# If not SunOS and not Linux, assume Windows
+# If not SunOS, not Linux and not BSD, assume Windows
 ifneq ($(OS), Linux)
   ifneq ($(OS), SunOS)
-    OSNAME=windows
+    ifneq ($(OS), bsd)
+      OSNAME=windows
+    else
+      OSNAME=bsd
+    endif
   else
     OSNAME=solaris
   endif
--- ./hotspot/make/linux/makefiles/defs.make	2010-03-18 01:41:36.000000000 -0700
+++ ./hotspot/make/linux/makefiles/defs.make	2009-11-02 22:51:00.000000000 -0800
@@ -100,28 +100,31 @@
 
 JDK_INCLUDE_SUBDIR=linux
 
+# Library suffix
+LIBRARY_SUFFIX=so
+
 # FIXUP: The subdirectory for a debug build is NOT the same on all platforms
 VM_DEBUG=jvmg
 
 EXPORT_LIST += $(EXPORT_DOCS_DIR)/platform/jvmti/jvmti.html
 
 # client and server subdirectories have symbolic links to ../libjsig.so
-EXPORT_LIST += $(EXPORT_JRE_LIB_ARCH_DIR)/libjsig.so
+EXPORT_LIST += $(EXPORT_JRE_LIB_ARCH_DIR)/libjsig.$(LIBRARY_SUFFIX)
 
 EXPORT_SERVER_DIR = $(EXPORT_JRE_LIB_ARCH_DIR)/server
 EXPORT_LIST += $(EXPORT_SERVER_DIR)/Xusage.txt
-EXPORT_LIST += $(EXPORT_SERVER_DIR)/libjvm.so
+EXPORT_LIST += $(EXPORT_SERVER_DIR)/libjvm.$(LIBRARY_SUFFIX)
 ifneq ($(ZERO_BUILD), true)
   ifeq ($(ARCH_DATA_MODEL), 32)
     EXPORT_CLIENT_DIR = $(EXPORT_JRE_LIB_ARCH_DIR)/client
     EXPORT_LIST += $(EXPORT_CLIENT_DIR)/Xusage.txt
-    EXPORT_LIST += $(EXPORT_CLIENT_DIR)/libjvm.so 
-    EXPORT_LIST += $(EXPORT_JRE_LIB_ARCH_DIR)/libsaproc.so
+    EXPORT_LIST += $(EXPORT_CLIENT_DIR)/libjvm.$(LIBRARY_SUFFIX) 
+    EXPORT_LIST += $(EXPORT_JRE_LIB_ARCH_DIR)/libsaproc.$(LIBRARY_SUFFIX)
     EXPORT_LIST += $(EXPORT_LIB_DIR)/sa-jdi.jar 
   else
     ifeq ($(ARCH),ia64)
       else
-        EXPORT_LIST += $(EXPORT_JRE_LIB_ARCH_DIR)/libsaproc.so
+        EXPORT_LIST += $(EXPORT_JRE_LIB_ARCH_DIR)/libsaproc.$(LIBRARY_SUFFIX)
         EXPORT_LIST += $(EXPORT_LIB_DIR)/sa-jdi.jar
     endif
   endif
--- ./hotspot/make/sa.files	2010-03-18 01:41:37.000000000 -0700
+++ ./hotspot/make/sa.files	2009-06-06 16:53:58.000000000 -0700
@@ -50,6 +50,9 @@
 $(AGENT_SRC_DIR)/sun/jvm/hotspot/compiler/*.java \
 $(AGENT_SRC_DIR)/sun/jvm/hotspot/debugger/*.java \
 $(AGENT_SRC_DIR)/sun/jvm/hotspot/debugger/amd64/*.java \
+$(AGENT_SRC_DIR)/sun/jvm/hotspot/debugger/bsd/*.java \
+$(AGENT_SRC_DIR)/sun/jvm/hotspot/debugger/bsd/amd64/*.java \
+$(AGENT_SRC_DIR)/sun/jvm/hotspot/debugger/bsd/x86/*.java \
 $(AGENT_SRC_DIR)/sun/jvm/hotspot/debugger/cdbg/*.java \
 $(AGENT_SRC_DIR)/sun/jvm/hotspot/debugger/cdbg/basic/*.java \
 $(AGENT_SRC_DIR)/sun/jvm/hotspot/debugger/cdbg/basic/x86/*.java \
@@ -95,6 +98,9 @@
 AGENT_FILES2 = \
 $(AGENT_SRC_DIR)/sun/jvm/hotspot/runtime/*.java \
 $(AGENT_SRC_DIR)/sun/jvm/hotspot/runtime/amd64/*.java \
+$(AGENT_SRC_DIR)/sun/jvm/hotspot/runtime/bsd/*.java \
+$(AGENT_SRC_DIR)/sun/jvm/hotspot/runtime/bsd_amd64/*.java \
+$(AGENT_SRC_DIR)/sun/jvm/hotspot/runtime/bsd_x86/*.java \
 $(AGENT_SRC_DIR)/sun/jvm/hotspot/runtime/ia64/*.java \
 $(AGENT_SRC_DIR)/sun/jvm/hotspot/runtime/linux/*.java \
 $(AGENT_SRC_DIR)/sun/jvm/hotspot/runtime/linux_amd64/*.java \
--- ./hotspot/make/solaris/makefiles/defs.make	2010-03-18 01:41:37.000000000 -0700
+++ ./hotspot/make/solaris/makefiles/defs.make	2009-11-04 19:52:29.000000000 -0800
@@ -61,32 +61,35 @@
 
 JDK_INCLUDE_SUBDIR=solaris
 
+# Library suffix
+LIBRARY_SUFFIX=so
+
 # FIXUP: The subdirectory for a debug build is NOT the same on all platforms
 VM_DEBUG=jvmg
 
 EXPORT_LIST += $(EXPORT_DOCS_DIR)/platform/jvmti/jvmti.html
 
 # client and server subdirectories have symbolic links to ../libjsig.so
-EXPORT_LIST += $(EXPORT_JRE_LIB_ARCH_DIR)/libjsig.so
+EXPORT_LIST += $(EXPORT_JRE_LIB_ARCH_DIR)/libjsig.$(LIBRARY_SUFFIX)
 
 EXPORT_SERVER_DIR = $(EXPORT_JRE_LIB_ARCH_DIR)/server
 EXPORT_LIST += $(EXPORT_SERVER_DIR)/Xusage.txt
-EXPORT_LIST += $(EXPORT_SERVER_DIR)/libjvm.so
-EXPORT_LIST += $(EXPORT_SERVER_DIR)/libjvm_db.so
-EXPORT_LIST += $(EXPORT_SERVER_DIR)/libjvm_dtrace.so
+EXPORT_LIST += $(EXPORT_SERVER_DIR)/libjvm.$(LIBRARY_SUFFIX)
+EXPORT_LIST += $(EXPORT_SERVER_DIR)/libjvm_db.$(LIBRARY_SUFFIX)
+EXPORT_LIST += $(EXPORT_SERVER_DIR)/libjvm_dtrace.$(LIBRARY_SUFFIX)
 ifeq ($(ARCH_DATA_MODEL), 32)
   EXPORT_CLIENT_DIR = $(EXPORT_JRE_LIB_ARCH_DIR)/client
   EXPORT_LIST += $(EXPORT_CLIENT_DIR)/Xusage.txt
-  EXPORT_LIST += $(EXPORT_CLIENT_DIR)/libjvm.so 
-  EXPORT_LIST += $(EXPORT_CLIENT_DIR)/libjvm_db.so 
-  EXPORT_LIST += $(EXPORT_CLIENT_DIR)/libjvm_dtrace.so 
+  EXPORT_LIST += $(EXPORT_CLIENT_DIR)/libjvm.$(LIBRARY_SUFFIX) 
+  EXPORT_LIST += $(EXPORT_CLIENT_DIR)/libjvm_db.$(LIBRARY_SUFFIX) 
+  EXPORT_LIST += $(EXPORT_CLIENT_DIR)/libjvm_dtrace.$(LIBRARY_SUFFIX) 
   ifeq ($(ARCH),sparc)
-    EXPORT_LIST += $(EXPORT_SERVER_DIR)/64/libjvm_db.so
-    EXPORT_LIST += $(EXPORT_CLIENT_DIR)/64/libjvm_db.so
-    EXPORT_LIST += $(EXPORT_SERVER_DIR)/64/libjvm_dtrace.so
-    EXPORT_LIST += $(EXPORT_CLIENT_DIR)/64/libjvm_dtrace.so
+    EXPORT_LIST += $(EXPORT_SERVER_DIR)/64/libjvm_db.$(LIBRARY_SUFFIX)
+    EXPORT_LIST += $(EXPORT_CLIENT_DIR)/64/libjvm_db.$(LIBRARY_SUFFIX)
+    EXPORT_LIST += $(EXPORT_SERVER_DIR)/64/libjvm_dtrace.$(LIBRARY_SUFFIX)
+    EXPORT_LIST += $(EXPORT_CLIENT_DIR)/64/libjvm_dtrace.$(LIBRARY_SUFFIX)
   endif
 endif
 
-EXPORT_LIST += $(EXPORT_JRE_LIB_ARCH_DIR)/libsaproc.so
+EXPORT_LIST += $(EXPORT_JRE_LIB_ARCH_DIR)/libsaproc.$(LIBRARY_SUFFIX)
 EXPORT_LIST += $(EXPORT_LIB_DIR)/sa-jdi.jar 
--- ./hotspot/make/windows/makefiles/defs.make	2010-03-18 01:41:37.000000000 -0700
+++ ./hotspot/make/windows/makefiles/defs.make	2009-11-02 22:49:17.000000000 -0800
@@ -69,6 +69,9 @@
 
 JDK_INCLUDE_SUBDIR=win32
 
+# Library suffix
+LIBRARY_SUFFIX=dll
+
 # HOTSPOT_RELEASE_VERSION and HOTSPOT_BUILD_VERSION are defined
 # and added to MAKE_ARGS list in $(GAMMADIR)/make/defs.make.
 
@@ -132,26 +135,26 @@
 
 EXPORT_SERVER_DIR = $(EXPORT_JRE_BIN_DIR)/server
 EXPORT_LIST += $(EXPORT_SERVER_DIR)/Xusage.txt
-EXPORT_LIST += $(EXPORT_SERVER_DIR)/jvm.dll
+EXPORT_LIST += $(EXPORT_SERVER_DIR)/jvm.$(LIBRARY_SUFFIX)
 EXPORT_LIST += $(EXPORT_SERVER_DIR)/jvm.pdb
 EXPORT_LIST += $(EXPORT_SERVER_DIR)/jvm.map
 EXPORT_LIST += $(EXPORT_LIB_DIR)/jvm.lib
 ifeq ($(ARCH_DATA_MODEL), 32)
   EXPORT_CLIENT_DIR = $(EXPORT_JRE_BIN_DIR)/client
   EXPORT_LIST += $(EXPORT_CLIENT_DIR)/Xusage.txt
-  EXPORT_LIST += $(EXPORT_CLIENT_DIR)/jvm.dll
+  EXPORT_LIST += $(EXPORT_CLIENT_DIR)/jvm.$(LIBRARY_SUFFIX)
   EXPORT_LIST += $(EXPORT_CLIENT_DIR)/jvm.pdb
   EXPORT_LIST += $(EXPORT_CLIENT_DIR)/jvm.map
   # kernel vm
   EXPORT_KERNEL_DIR = $(EXPORT_JRE_BIN_DIR)/kernel
   EXPORT_LIST += $(EXPORT_KERNEL_DIR)/Xusage.txt
-  EXPORT_LIST += $(EXPORT_KERNEL_DIR)/jvm.dll
+  EXPORT_LIST += $(EXPORT_KERNEL_DIR)/jvm.$(LIBRARY_SUFFIX)
   EXPORT_LIST += $(EXPORT_KERNEL_DIR)/jvm.pdb
   EXPORT_LIST += $(EXPORT_KERNEL_DIR)/jvm.map
 endif
 
 ifeq ($(BUILD_WIN_SA), 1)
-  EXPORT_LIST += $(EXPORT_JRE_BIN_DIR)/sawindbg.dll
+  EXPORT_LIST += $(EXPORT_JRE_BIN_DIR)/sawindbg.$(LIBRARY_SUFFIX)
   EXPORT_LIST += $(EXPORT_JRE_BIN_DIR)/sawindbg.pdb
   EXPORT_LIST += $(EXPORT_JRE_BIN_DIR)/sawindbg.map
   EXPORT_LIST += $(EXPORT_LIB_DIR)/sa-jdi.jar
--- ./hotspot/src/cpu/x86/vm/interp_masm_x86_32.cpp	2010-03-18 01:41:38.000000000 -0700
+++ ./hotspot/src/cpu/x86/vm/interp_masm_x86_32.cpp	2010-03-08 21:37:50.000000000 -0800
@@ -455,10 +455,10 @@
 void InterpreterMacroAssembler::tag_local(frame::Tag tag, int n) {
   if (TaggedStackInterpreter) {
     if (tag == frame::TagCategory2) {
-      movptr(Address(rdi, Interpreter::local_tag_offset_in_bytes(n+1)), (int32_t)frame::TagValue);
-      movptr(Address(rdi, Interpreter::local_tag_offset_in_bytes(n)), (int32_t)frame::TagValue);
+      movptr(Address(rdi, Interpreter::local_tag_offset_in_bytes(n+1)), (intptr_t)frame::TagValue);
+      movptr(Address(rdi, Interpreter::local_tag_offset_in_bytes(n)), (intptr_t)frame::TagValue);
     } else {
-      movptr(Address(rdi, Interpreter::local_tag_offset_in_bytes(n)), (int32_t)tag);
+      movptr(Address(rdi, Interpreter::local_tag_offset_in_bytes(n)), (intptr_t)tag);
     }
   }
 }
@@ -467,12 +467,12 @@
   if (TaggedStackInterpreter) {
     if (tag == frame::TagCategory2) {
       movptr(Address(rdi, idx, Interpreter::stackElementScale(),
-                  Interpreter::local_tag_offset_in_bytes(1)), (int32_t)frame::TagValue);
+                  Interpreter::local_tag_offset_in_bytes(1)), (intptr_t)frame::TagValue);
       movptr(Address(rdi, idx, Interpreter::stackElementScale(),
-                    Interpreter::local_tag_offset_in_bytes(0)), (int32_t)frame::TagValue);
+                    Interpreter::local_tag_offset_in_bytes(0)), (intptr_t)frame::TagValue);
     } else {
       movptr(Address(rdi, idx, Interpreter::stackElementScale(),
-                               Interpreter::local_tag_offset_in_bytes(0)), (int32_t)tag);
+                               Interpreter::local_tag_offset_in_bytes(0)), (intptr_t)tag);
     }
   }
 }
@@ -1336,7 +1336,7 @@
   int recvr_offset = in_bytes(VirtualCallData::receiver_offset(start_row));
   set_mdp_data_at(mdp, recvr_offset, receiver);
   int count_offset = in_bytes(VirtualCallData::receiver_count_offset(start_row));
-  movptr(reg2, (int32_t)DataLayout::counter_increment);
+  movptr(reg2, (intptr_t)DataLayout::counter_increment);
   set_mdp_data_at(mdp, count_offset, reg2);
   if (start_row > 0) {
     jmp(done);
@@ -1479,7 +1479,7 @@
     test_method_data_pointer(mdp, profile_continue);
 
     // Build the base (index * per_case_size_in_bytes()) + case_array_offset_in_bytes()
-    movptr(reg2, (int32_t)in_bytes(MultiBranchData::per_case_size()));
+    movptr(reg2, (intptr_t)in_bytes(MultiBranchData::per_case_size()));
     // index is positive and so should have correct value if this code were
     // used on 64bits
     imulptr(index, reg2);
--- ./hotspot/src/cpu/x86/vm/jni_x86.h	2010-03-18 01:41:38.000000000 -0700
+++ ./hotspot/src/cpu/x86/vm/jni_x86.h	2009-06-06 16:54:00.000000000 -0700
@@ -26,7 +26,7 @@
 #ifndef _JAVASOFT_JNI_MD_H_
 #define _JAVASOFT_JNI_MD_H_
 
-#if defined(SOLARIS) || defined(LINUX)
+#if defined(SOLARIS) || defined(LINUX) || defined(_ALLBSD_SOURCE)
   #define JNIEXPORT
   #define JNIIMPORT
   #define JNICALL
--- ./hotspot/src/os/bsd/launcher/java_md.c	2010-03-27 11:09:10.000000000 -0700
+++ ./hotspot/src/os/bsd/launcher/java_md.c	2009-12-20 19:41:24.000000000 -0800
@@ -45,8 +45,15 @@
 #include "version_comp.h"
 #endif
 
+#ifdef __APPLE__
+#define JVM_DLL "libjvm.dylib"
+#define JAVA_DLL "libjava.dylib"
+#define LD_LIBRARY_PATH "DYLD_LIBRARY_PATH"
+#else
 #define JVM_DLL "libjvm.so"
 #define JAVA_DLL "libjava.so"
+#define LD_LIBRARY_PATH "LD_LIBRARY_PATH"
+#endif
 
 #ifndef GAMMA   /* launcher.make defines ARCH */
 
@@ -112,7 +119,7 @@
  *      A collection of useful strings. One should think of these as #define
  *      entries, but actual strings can be more efficient (with many compilers).
  */
-#ifdef __bsd__
+#ifdef _ALLBSD_SOURCE
 static const char *system_dir   = "/usr/java";
 static const char *user_dir     = "/java";
 #else /* Solaris */
@@ -456,10 +463,10 @@
        * If not on Solaris, assume only a single LD_LIBRARY_PATH
        * variable.
        */
-      runpath = getenv("LD_LIBRARY_PATH");
+      runpath = getenv(LD_LIBRARY_PATH);
 #endif /* __sun */
 
-#ifdef __bsd
+#ifdef _ALLBSD_SOURCE
       /*
        * On bsd, if a binary is running as sgid or suid, glibc sets
        * LD_LIBRARY_PATH to the empty string for security purposes.  (In
@@ -472,7 +479,7 @@
        * return from the function now.  Getting the right libraries to
        * be found must be handled through other mechanisms.
        */
-      if((getgid() != getegid()) || (getuid() != geteuid()) ) {
+      if(issetugid()) {
         return;
       }
 #endif
@@ -483,7 +490,7 @@
       new_runpath = MemAlloc( ((runpath!=NULL)?strlen(runpath):0) +
                               2*strlen(jrepath) + 2*strlen(arch) +
                               strlen(jvmpath) + 52);
-      newpath = new_runpath + strlen("LD_LIBRARY_PATH=");
+      newpath = new_runpath + strlen(LD_LIBRARY_PATH "=");
 
 
       /*
@@ -498,7 +505,7 @@
 
         /* jvmpath, ((running != wanted)?((wanted==64)?"/"BIG_ARCH:"/.."):""), */
 
-        sprintf(new_runpath, "LD_LIBRARY_PATH="
+        sprintf(new_runpath, LD_LIBRARY_PATH "="
                 "%s:"
                 "%s/lib/%s:"
                 "%s/../lib/%s",
@@ -836,7 +843,7 @@
 jboolean
 GetApplicationHome(char *buf, jint bufsize)
 {
-#ifdef __bsd__
+#ifdef _ALLBSD_SOURCE
     char *execname = GetExecname();
     if (execname) {
         strncpy(buf, execname, bufsize-1);
@@ -1005,7 +1012,7 @@
             }
         }
     }
-#elif defined(__bsd__)
+#elif defined(__linux__)
     {
         const char* self = "/proc/self/exe";
         char buf[PATH_MAX+1];
@@ -1015,7 +1022,7 @@
             exec_path = strdup(buf);
         }
     }
-#else /* !__sun && !__bsd */
+#else /* !__sun && !__linux */
     {
         /* Not implemented */
     }
@@ -1220,7 +1227,7 @@
 
 #endif /* __sun && i586 */
 
-#if defined(__bsd__) && defined(i586)
+#if defined(_ALLBSD_SOURCE) && defined(i586)
 
 /*
  * A utility method for asking the CPU about itself.
@@ -1286,7 +1293,7 @@
 #endif
 }
 
-#endif /* __bsd__ && i586 */
+#endif /* _ALLBSD_SOURCE && i586 */
 
 #ifdef i586
 /*
@@ -1465,7 +1472,7 @@
 
 #endif /* __sun && i586 */
 
-#if defined(__bsd__) && defined(i586)
+#if defined(_ALLBSD_SOURCE) && defined(i586)
 
 /* The definition of a server-class machine for bsd-i586 */
 jboolean
@@ -1496,7 +1503,7 @@
   return result;
 }
 
-#endif /* __bsd__ && i586 */
+#endif /* _ALLBSD_SOURCE && i586 */
 
 /* Dispatch to the platform-specific definition of "server-class" */
 jboolean
@@ -1506,7 +1513,7 @@
   result = solaris_sparc_ServerClassMachine();
 #elif defined(__sun) && defined(i586)
   result = solaris_i586_ServerClassMachine();
-#elif defined(__bsd__) && defined(i586)
+#elif defined(_ALLBSD_SOURCE) && defined(i586)
   result = bsd_i586_ServerClassMachine();
 #else
   if (_launcher_debug) {
--- ./hotspot/src/os/bsd/vm/attachListener_bsd.cpp	2010-03-27 11:09:10.000000000 -0700
+++ ./hotspot/src/os/bsd/vm/attachListener_bsd.cpp	2009-06-06 16:54:01.000000000 -0700
@@ -179,32 +179,19 @@
   struct sockaddr_un addr;
   addr.sun_family = AF_UNIX;
 
-  // FIXME: Prior to b39 the tool-side API expected to find the well
-  // known file in the working directory. To allow this libjvm.so work with
-  // a pre-b39 SDK we create it in the working directory if
-  // +StartAttachListener is used is used. All unit tests for this feature
-  // currently used this flag. Once b39 SDK has been promoted we can remove
-  // this code.
-  if (StartAttachListener) {
-    sprintf(path, ".java_pid%d", os::current_process_id());
-    strcpy(addr.sun_path, path);
-    ::unlink(path);
-    res = ::bind(listener, (struct sockaddr*)&addr, sizeof(addr));
-  }
-  if (res == -1) {
-    sprintf(path, "%s/.java_pid%d", os::get_temp_directory(), os::current_process_id());
-    strcpy(addr.sun_path, path);
-    ::unlink(path);
-    res = ::bind(listener, (struct sockaddr*)&addr, sizeof(addr));
-  }
+  sprintf(path, "%s/.java_pid%d", os::get_temp_directory(), os::current_process_id());
+  strcpy(addr.sun_path, path);
+  ::unlink(path);
+  res = ::bind(listener, (struct sockaddr*)&addr, sizeof(addr));
   if (res == -1) {
     RESTARTABLE(::close(listener), res);
     return -1;
   }
   set_path(path);
 
-  // put in listen mode and set permission
-  if ((::listen(listener, 5) == -1) || (::chmod(path, S_IREAD|S_IWRITE) == -1)) {
+  // put in listen mode and set permission and ownership
+  if ((::listen(listener, 5) == -1) || (::chmod(path, S_IREAD|S_IWRITE) == -1) ||
+      (::chown(path, geteuid(), getegid()) == -1)) {
     RESTARTABLE(::close(listener), res);
     ::unlink(path);
     set_path(NULL);
@@ -330,6 +317,15 @@
 
     // get the credentials of the peer and check the effective uid/guid
     // - check with jeff on this.
+#ifdef _ALLBSD_SOURCE
+    uid_t puid;
+    gid_t pgid;
+    if (::getpeereid(s, &puid, &pgid) != 0) {
+      int res;
+      RESTARTABLE(::close(s), res);
+      continue;
+    }
+#else
     struct ucred cred_info;
     socklen_t optlen = sizeof(cred_info);
     if (::getsockopt(s, SOL_SOCKET, SO_PEERCRED, (void*)&cred_info, &optlen) == -1) {
@@ -337,10 +333,13 @@
       RESTARTABLE(::close(s), res);
       continue;
     }
+    uid_t puid = cred_info.uid;
+    gid_t pgid = cred_info.gid;
+#endif
     uid_t euid = geteuid();
     gid_t egid = getegid();
 
-    if (cred_info.uid != euid || cred_info.gid != egid) {
+    if (puid != euid || pgid != egid) {
       int res;
       RESTARTABLE(::close(s), res);
       continue;
@@ -460,15 +459,12 @@
   if (init_at_startup() || is_initialized()) {
     return false;               // initialized at startup or already initialized
   }
-  char fn[32];
-  sprintf(fn, ".attach_pid%d", os::current_process_id());
+  char path[PATH_MAX + 1];
   int ret;
-  struct stat64 st;
-  RESTARTABLE(::stat64(fn, &st), ret);
-  if (ret == -1) {
-    sprintf(fn, "/tmp/.attach_pid%d", os::current_process_id());
-    RESTARTABLE(::stat64(fn, &st), ret);
-  }
+  struct stat st;
+
+  sprintf(path, "%s/.attach_pid%d", os::get_temp_directory(), os::current_process_id());
+  RESTARTABLE(::stat(path, &st), ret);
   if (ret == 0) {
     // simple check to avoid starting the attach mechanism when
     // a bogus user creates the file
--- ./hotspot/src/os/bsd/vm/hpi_bsd.cpp	2010-03-27 11:09:10.000000000 -0700
+++ ./hotspot/src/os/bsd/vm/hpi_bsd.cpp	2009-06-06 16:54:01.000000000 -0700
@@ -28,6 +28,14 @@
 # include <sys/param.h>
 # include <dlfcn.h>
 
+#ifdef __APPLE__
+#define HPI_LIB "libhpi.dylib"
+#define HPI_G_LIB "libhpi.dylib"
+#else
+#define HPI_LIB "libhpi.so"
+#define HPI_G_LIB "libhpi.so"
+#endif
+
 typedef jint (JNICALL *init_t)(GetInterfaceFunc *, void *);
 
 void hpi::initialize_get_interface(vm_calls_t *callbacks) {
@@ -45,11 +53,11 @@
       os::jvm_path(buf, JVM_MAXPATHLEN);
 
 #ifdef PRODUCT
-      const char * hpi_lib = "/libhpi.so";
+      const char * hpi_lib = "/" HPI_LIB;
 #else
       char * ptr = strrchr(buf, '/');
       assert(strstr(ptr, "/libjvm") == ptr, "invalid library name");
-      const char * hpi_lib = strstr(ptr, "_g") ? "/libhpi_g.so" : "/libhpi.so";
+      const char * hpi_lib = strstr(ptr, "_g") ? "/" HPI_G_LIB : "/" HPI_LIB;
 #endif
 
       *(strrchr(buf, '/')) = '\0';  /* get rid of /libjvm.so */
--- ./hotspot/src/os/bsd/vm/hpi_bsd.hpp	2010-03-27 11:09:10.000000000 -0700
+++ ./hotspot/src/os/bsd/vm/hpi_bsd.hpp	2009-06-28 17:53:14.000000000 -0700
@@ -36,7 +36,7 @@
 // HPI_FileInterface
 
 inline int hpi::close(int fd) {
-  return ::close(fd);
+  RESTARTABLE_RETURN_INT(::close(fd)); 
 }
 
 inline size_t hpi::read(int fd, void *buf, unsigned int nBytes) {
@@ -55,7 +55,7 @@
 // HPI_SocketInterface
 
 inline int hpi::socket_close(int fd) {
-  return ::close(fd);
+  RESTARTABLE_RETURN_INT(::close(fd));
 }
 
 inline int hpi::socket(int domain, int type, int protocol) {
@@ -120,9 +120,9 @@
   // fetch it's value, this cast is safe for now. The java.net group
   // may need and want to change this interface someday if socklen_t goes
   // to 64 bits on some platform that we support.
-  // Bsd doc says this can't return EINTR, unlike accept() on Solaris
+  // At least OpenBSD and FreeBSD can return EINTR from accept.
 
-  return ::accept(fd, him, (socklen_t *)len);
+  RESTARTABLE_RETURN_INT(::accept(fd, him, (socklen_t *)len));
 }
 
 inline int hpi::recvfrom(int fd, char *buf, int nBytes, int flags,
@@ -136,12 +136,16 @@
 }
 
 inline int hpi::socket_available(int fd, jint *pbytes) {
-  // Bsd doc says EINTR not returned, unlike Solaris
-  int ret = ::ioctl(fd, FIONREAD, pbytes);
+  int ret;
+
+  if (fd < 0)
+    return OS_OK;
+
+  RESTARTABLE(::ioctl(fd, FIONREAD, pbytes), ret);
 
   //%% note ioctl can return 0 when successful, JVM_SocketAvailable
   // is expected to return 0 on failure and 1 on success to the jdk.
-  return (ret < 0) ? 0 : 1;
+  return (ret == OS_ERR) ? 0 : 1;
 }
 
 
--- ./hotspot/src/os/bsd/vm/jsig.c	2010-03-27 11:09:10.000000000 -0700
+++ ./hotspot/src/os/bsd/vm/jsig.c	2009-06-06 16:54:01.000000000 -0700
@@ -143,7 +143,8 @@
 }
 
 sa_handler_t sigset(int sig, sa_handler_t disp) {
-  return set_signal(sig, disp, true);
+  printf("sigset() is not supported by BSD");
+  exit(0);
  }
 
 static int call_os_sigaction(int sig, const struct sigaction  *act,
--- ./hotspot/src/os/bsd/vm/jvm_bsd.cpp	2010-03-27 11:09:10.000000000 -0700
+++ ./hotspot/src/os/bsd/vm/jvm_bsd.cpp	2009-06-06 16:54:01.000000000 -0700
@@ -144,38 +144,31 @@
   "ILL",        SIGILL,         /* Illegal instruction (ANSI).  */
   "TRAP",       SIGTRAP,        /* Trace trap (POSIX).  */
   "ABRT",       SIGABRT,        /* Abort (ANSI).  */
-  "IOT",        SIGIOT,         /* IOT trap (4.2 BSD).  */
-  "BUS",        SIGBUS,         /* BUS error (4.2 BSD).  */
+  "EMT",	SIGEMT,		/* EMT trap  */
   "FPE",        SIGFPE,         /* Floating-point exception (ANSI).  */
   "KILL",       SIGKILL,        /* Kill, unblockable (POSIX).  */
-  "USR1",       SIGUSR1,        /* User-defined signal 1 (POSIX).  */
+  "BUS",	SIGBUS,		/* BUS error (4.2 BSD).  */
   "SEGV",       SIGSEGV,        /* Segmentation violation (ANSI).  */
-  "USR2",       SIGUSR2,        /* User-defined signal 2 (POSIX).  */
+  "SYS",	SIGSYS,		/* Bad system call. Only on some Bsden! */
   "PIPE",       SIGPIPE,        /* Broken pipe (POSIX).  */
   "ALRM",       SIGALRM,        /* Alarm clock (POSIX).  */
   "TERM",       SIGTERM,        /* Termination (ANSI).  */
-#ifdef SIGSTKFLT
-  "STKFLT",     SIGSTKFLT,      /* Stack fault.  */
-#endif
-  "CLD",        SIGCLD,         /* Same as SIGCHLD (System V).  */
-  "CHLD",       SIGCHLD,        /* Child status has changed (POSIX).  */
-  "CONT",       SIGCONT,        /* Continue (POSIX).  */
+  "URG",	SIGURG,		/* Urgent condition on socket (4.2 BSD).  */
   "STOP",       SIGSTOP,        /* Stop, unblockable (POSIX).  */
   "TSTP",       SIGTSTP,        /* Keyboard stop (POSIX).  */
+  "CONT",	SIGCONT,	/* Continue (POSIX).  */
+  "CHLD",	SIGCHLD,	/* Child status has changed (POSIX).  */
   "TTIN",       SIGTTIN,        /* Background read from tty (POSIX).  */
   "TTOU",       SIGTTOU,        /* Background write to tty (POSIX).  */
-  "URG",        SIGURG,         /* Urgent condition on socket (4.2 BSD).  */
+  "IO",		SIGIO,		/* I/O now possible (4.2 BSD).  */
   "XCPU",       SIGXCPU,        /* CPU limit exceeded (4.2 BSD).  */
   "XFSZ",       SIGXFSZ,        /* File size limit exceeded (4.2 BSD).  */
   "VTALRM",     SIGVTALRM,      /* Virtual alarm clock (4.2 BSD).  */
   "PROF",       SIGPROF,        /* Profiling alarm clock (4.2 BSD).  */
   "WINCH",      SIGWINCH,       /* Window size change (4.3 BSD, Sun).  */
-  "POLL",       SIGPOLL,        /* Pollable event occurred (System V).  */
-  "IO",         SIGIO,          /* I/O now possible (4.2 BSD).  */
-  "PWR",        SIGPWR,         /* Power failure restart (System V).  */
-#ifdef SIGSYS
-  "SYS",        SIGSYS          /* Bad system call. Only on some Bsden! */
-#endif
+  "INFO",	SIGINFO,	/* Information request.  */
+  "USR1",	SIGUSR1,	/* User-defined signal 1 (POSIX).  */
+  "USR2",	SIGUSR2		/* User-defined signal 2 (POSIX).  */
   };
 
 JVM_ENTRY_NO_ENV(jint, JVM_FindSignal(const char *name))
--- ./hotspot/src/os/bsd/vm/jvm_bsd.h	2010-03-27 11:09:10.000000000 -0700
+++ ./hotspot/src/os/bsd/vm/jvm_bsd.h	2009-06-06 16:54:01.000000000 -0700
@@ -51,7 +51,11 @@
 #define AGENT_ONATTACH_SYMBOLS  {"Agent_OnAttach"}
 
 #define JNI_LIB_PREFIX "lib"
+#ifdef __APPLE__
+#define JNI_LIB_SUFFIX ".dylib"
+#else
 #define JNI_LIB_SUFFIX ".so"
+#endif
 
 // Hack: MAXPATHLEN is 4095 on some Bsd and 4096 on others. This may
 //       cause problems if JVM and the rest of JDK are built on different
@@ -90,6 +94,20 @@
 #define SHUTDOWN2_SIGNAL SIGINT
 #define SHUTDOWN3_SIGNAL SIGTERM
 
+#ifndef SIGRTMIN
+#ifdef __OpenBSD__
+#define SIGRTMIN	1
+#else
+#define SIGRTMIN	33
+#endif
+#endif
+#ifndef SIGRTMAX
+#ifdef __OpenBSD__
+#define SIGRTMAX	31
+#else
+#define SIGRTMAX	63
+#endif
+#endif
 #endif /* JVM_MD_H */
 
 // Reconciliation History
--- ./hotspot/src/os/bsd/vm/osThread_bsd.cpp	2010-03-27 11:09:10.000000000 -0700
+++ ./hotspot/src/os/bsd/vm/osThread_bsd.cpp	2009-06-06 16:54:01.000000000 -0700
@@ -28,8 +28,8 @@
 
 void OSThread::pd_initialize() {
   assert(this != NULL, "check");
-  _thread_id        = 0;
-  _pthread_id       = 0;
+  _thread_id        = NULL;
+  _pthread_id       = NULL;
   _siginfo = NULL;
   _ucontext = NULL;
   _expanding_stack = 0;
--- ./hotspot/src/os/bsd/vm/osThread_bsd.hpp	2010-03-27 11:09:10.000000000 -0700
+++ ./hotspot/src/os/bsd/vm/osThread_bsd.hpp	2009-06-28 17:53:14.000000000 -0700
@@ -36,6 +36,12 @@
 
  private:
 
+#ifdef _ALLBSD_SOURCE
+  // _thread_id and _pthread_id are the same on BSD
+  // keep both to minimize code divergence in os_bsd.cpp
+  pthread_t _thread_id;
+  pthread_t _pthread_id;
+#else
   // _thread_id is kernel thread id (similar to LWP id on Solaris). Each
   // thread has a unique thread_id (BsdThreads or NPTL). It can be used
   // to access /proc.
@@ -44,6 +50,7 @@
   // _pthread_id is the pthread id, which is used by library calls
   // (e.g. pthread_kill).
   pthread_t _pthread_id;
+#endif
 
   sigset_t _caller_sigmask; // Caller's signal mask
 
@@ -53,12 +60,18 @@
   sigset_t  caller_sigmask() const       { return _caller_sigmask; }
   void    set_caller_sigmask(sigset_t sigmask)  { _caller_sigmask = sigmask; }
 
+#ifdef _ALLBSD_SOURCE
+  pthread_t thread_id() const {
+    return _thread_id;
+  }
+#else
   pid_t thread_id() const {
     return _thread_id;
   }
+#endif
 #ifndef PRODUCT
   // Used for debugging, return a unique integer for each thread.
-  int thread_identifier() const   { return _thread_id; }
+  intptr_t thread_identifier() const   { return (intptr_t)_pthread_id; }
 #endif
 #ifdef ASSERT
   // We expect no reposition failures so kill vm if we get one.
@@ -67,9 +80,15 @@
     return false;
   }
 #endif // ASSERT
+#ifdef _ALLBSD_SOURCE
+  void set_thread_id(pthread_t id) {
+    _thread_id = id;
+  }
+#else
   void set_thread_id(pid_t id) {
     _thread_id = id;
   }
+#endif
   pthread_t pthread_id() const {
     return _pthread_id;
   }
--- ./hotspot/src/os/bsd/vm/os_bsd.cpp	2010-03-27 11:09:10.000000000 -0700
+++ ./hotspot/src/os/bsd/vm/os_bsd.cpp	2010-01-16 14:25:14.000000000 -0800
@@ -42,17 +42,39 @@
 # include <sys/utsname.h>
 # include <sys/socket.h>
 # include <sys/wait.h>
+# include <time.h>
 # include <pwd.h>
 # include <poll.h>
 # include <semaphore.h>
 # include <fcntl.h>
 # include <string.h>
+#ifdef _ALLBSD_SOURCE
+# include <sys/param.h>
+# include <sys/sysctl.h>
+#else
 # include <syscall.h>
 # include <sys/sysinfo.h>
 # include <gnu/libc-version.h>
+#endif
 # include <sys/ipc.h>
 # include <sys/shm.h>
+
+#ifndef __APPLE__
 # include <link.h>
+#endif
+
+#if defined(__FreeBSD__) || defined(__NetBSD__)
+# include <elf.h>
+#endif
+
+#ifdef __APPLE__
+#include <mach/mach.h> // semaphore_* API
+#include <mach-o/dyld.h>
+#endif
+
+#ifndef MAP_ANONYMOUS
+#define MAP_ANONYMOUS MAP_ANON
+#endif
 
 #define MAX_PATH    (2 * K)
 
@@ -64,19 +86,25 @@
 // global variables
 julong os::Bsd::_physical_memory = 0;
 
+#ifndef _ALLBSD_SOURCE
 address   os::Bsd::_initial_thread_stack_bottom = NULL;
 uintptr_t os::Bsd::_initial_thread_stack_size   = 0;
+#endif
 
 int (*os::Bsd::_clock_gettime)(clockid_t, struct timespec *) = NULL;
+#ifndef _ALLBSD_SOURCE
 int (*os::Bsd::_pthread_getcpuclockid)(pthread_t, clockid_t *) = NULL;
 Mutex* os::Bsd::_createThread_lock = NULL;
+#endif
 pthread_t os::Bsd::_main_thread;
 int os::Bsd::_page_size = -1;
+#ifndef _ALLBSD_SOURCE
 bool os::Bsd::_is_floating_stack = false;
 bool os::Bsd::_is_NPTL = false;
 bool os::Bsd::_supports_fast_thread_cpu_time = false;
 const char * os::Bsd::_glibc_version = NULL;
 const char * os::Bsd::_libpthread_version = NULL;
+#endif
 
 static jlong initial_time_count=0;
 
@@ -94,8 +122,6 @@
 static int SR_signum = SIGUSR2;
 sigset_t SR_sigset;
 
-/* Used to protect dlsym() calls */
-static pthread_mutex_t dl_mutex;
 
 ////////////////////////////////////////////////////////////////////////////////
 // utility functions
@@ -108,11 +134,16 @@
 }
 
 julong os::Bsd::available_memory() {
+#ifdef _ALLBSD_SOURCE
+  // XXXBSD: this is just a stopgap implementation
+  return physical_memory() >> 2;
+#else
   // values in struct sysinfo are "unsigned long"
   struct sysinfo si;
   sysinfo(&si);
 
   return (julong)si.freeram * si.mem_unit;
+#endif
 }
 
 julong os::physical_memory() {
@@ -160,6 +191,7 @@
 }
 
 
+#ifndef _ALLBSD_SOURCE
 #ifndef SYS_gettid
 // i386: 224, ia64: 1105, amd64: 186, sparc 143
 #ifdef __ia64__
@@ -174,6 +206,7 @@
 #error define gettid for the arch
 #endif
 #endif
+#endif
 
 // Cpu architecture string
 #if   defined(ZERO)
@@ -195,6 +228,7 @@
 #endif
 
 
+#ifndef _ALLBSD_SOURCE
 // pid_t gettid()
 //
 // Returns the kernel thread id of the currently running thread. Kernel
@@ -221,7 +255,48 @@
 static const char *unstable_chroot_error = "/proc file system not found.\n"
                      "Java may be unstable running multithreaded in a chroot "
                      "environment on Bsd when /proc filesystem is not mounted.";
+#endif
+
+#ifdef _ALLBSD_SOURCE
+void os::Bsd::initialize_system_info() {
+  int mib[2];
+  size_t len;
+  int cpu_val;
+  u_long mem_val;
+
+  /* get processors count via hw.ncpus sysctl */
+  mib[0] = CTL_HW;
+  mib[1] = HW_NCPU;
+  len = sizeof(cpu_val);
+  if (sysctl(mib, 2, &cpu_val, &len, NULL, 0) != -1 && cpu_val >= 1) {
+       set_processor_count(cpu_val);
+  }
+  else {
+       set_processor_count(1);   // fallback
+  }
+
+  /* get physical memory via hw.usermem sysctl (hw.usermem is used
+   * instead of hw.physmem because we need size of allocatable memory
+   */
+  mib[0] = CTL_HW;
+  mib[1] = HW_USERMEM;
+  len = sizeof(mem_val);
+  if (sysctl(mib, 2, &mem_val, &len, NULL, 0) != -1)
+       _physical_memory = mem_val;
+  else
+       _physical_memory = 256*1024*1024;       // fallback (XXXBSD?)
 
+#ifdef __OpenBSD__
+  {
+       // limit _physical_memory memory view on OpenBSD since
+       // datasize rlimit restricts us anyway.
+       struct rlimit limits;
+       getrlimit(RLIMIT_DATA, &limits);
+       _physical_memory = MIN2(_physical_memory, (julong)limits.rlim_cur);
+  }
+#endif
+}
+#else
 void os::Bsd::initialize_system_info() {
   set_processor_count(sysconf(_SC_NPROCESSORS_CONF));
   if (processor_count() == 1) {
@@ -238,6 +313,7 @@
   _physical_memory = (julong)sysconf(_SC_PHYS_PAGES) * (julong)sysconf(_SC_PAGESIZE);
   assert(processor_count() > 0, "bsd error");
 }
+#endif
 
 void os::init_system_properties_values() {
 //  char arch[12];
@@ -281,9 +357,7 @@
  *        ...
  *        7: The default directories, normally /lib and /usr/lib.
  */
-#if defined(AMD64) || defined(_LP64) && (defined(SPARC) || defined(PPC) || defined(S390))
-#define DEFAULT_LIBPATH "/usr/lib64:/lib64:/lib:/usr/lib"
-#else
+#ifndef DEFAULT_LIBPATH
 #define DEFAULT_LIBPATH "/lib:/usr/lib"
 #endif
 
@@ -362,7 +436,11 @@
          * should always exist (until the legacy problem cited above is
          * addressed).
          */
+#ifdef __APPLE__
+        char *v = getenv("DYLD_LIBRARY_PATH");
+#else
         char *v = getenv("LD_LIBRARY_PATH");
+#endif
         if (v != NULL) {
             char *t = ld_library_path;
             /* That's +1 for the colon and +1 for the trailing '\0' */
@@ -521,6 +599,7 @@
   }
 }
 
+#ifndef _ALLBSD_SOURCE
 //////////////////////////////////////////////////////////////////////////////
 // detecting pthread library
 
@@ -684,6 +763,7 @@
   }
   return false;
 }
+#endif
 
 //////////////////////////////////////////////////////////////////////////////
 // create new thread
@@ -692,6 +772,9 @@
 
 // check if it's safe to start a new thread
 static bool _thread_safety_check(Thread* thread) {
+#ifdef _ALLBSD_SOURCE
+    return true;
+#else
   if (os::Bsd::is_BsdThreads() && !os::Bsd::is_floating_stack()) {
     // Fixed stack BsdThreads (SuSE Bsd/x86, and some versions of Redhat)
     //   Heap is mmap'ed at lower end of memory space. Thread stacks are
@@ -725,6 +808,7 @@
     //   here, that means enough space has been reserved for stack.
     return true;
   }
+#endif
 }
 
 // Thread start routine for all newly created threads
@@ -752,6 +836,10 @@
     return NULL;
   }
 
+#ifdef _ALLBSD_SOURCE
+  // thread_id is pthread_id on BSD
+  osthread->set_thread_id(::pthread_self());
+#else
   // thread_id is kernel thread id (similar to Solaris LWP id)
   osthread->set_thread_id(os::Bsd::gettid());
 
@@ -761,6 +849,7 @@
       thread->set_lgrp_id(lgrp_id);
     }
   }
+#endif
   // initialize signal mask for this thread
   os::Bsd::hotspot_sigmask(thread);
 
@@ -841,17 +930,22 @@
     // let pthread_create() pick the default value.
   }
 
+#ifndef _ALLBSD_SOURCE
   // glibc guard page
   pthread_attr_setguardsize(&attr, os::Bsd::default_guard_size(thr_type));
+#endif
 
   ThreadState state;
 
   {
+
+#ifndef _ALLBSD_SOURCE
     // Serialize thread creation if we are running with fixed stack BsdThreads
     bool lock = os::Bsd::is_BsdThreads() && !os::Bsd::is_floating_stack();
     if (lock) {
       os::Bsd::createThread_lock()->lock_without_safepoint_check();
     }
+#endif
 
     pthread_t tid;
     int ret = pthread_create(&tid, &attr, (void* (*)(void*)) java_start, thread);
@@ -865,7 +959,9 @@
       // Need to clean up stuff we've allocated so far
       thread->set_osthread(NULL);
       delete osthread;
+#ifndef _ALLBSD_SOURCE
       if (lock) os::Bsd::createThread_lock()->unlock();
+#endif
       return false;
     }
 
@@ -881,9 +977,11 @@
       }
     }
 
+#ifndef _ALLBSD_SOURCE
     if (lock) {
       os::Bsd::createThread_lock()->unlock();
     }
+#endif
   }
 
   // Aborted due to thread limit being reached
@@ -921,7 +1019,11 @@
   }
 
   // Store pthread info into the OSThread
+#ifdef _ALLBSD_SOURCE
+  osthread->set_thread_id(::pthread_self());
+#else
   osthread->set_thread_id(os::Bsd::gettid());
+#endif
   osthread->set_pthread_id(::pthread_self());
 
   // initialize floating point control register
@@ -932,6 +1034,7 @@
 
   thread->set_osthread(osthread);
 
+#ifndef _ALLBSD_SOURCE
   if (UseNUMA) {
     int lgrp_id = os::numa_get_group_id();
     if (lgrp_id != -1) {
@@ -958,6 +1061,7 @@
     os::Bsd::manually_expand_stack(jt, addr);
     osthread->clear_expanding_stack();
   }
+#endif
 
   // initialize signal mask for this thread
   // and save the caller's signal mask
@@ -1016,6 +1120,7 @@
 //////////////////////////////////////////////////////////////////////////////
 // initial thread
 
+#ifndef _ALLBSD_SOURCE
 // Check if current thread is the initial thread, similar to Solaris thr_main.
 bool os::Bsd::is_initial_thread(void) {
   char dummy;
@@ -1249,6 +1354,7 @@
   _initial_thread_stack_size = align_size_down(_initial_thread_stack_size, page_size());
   _initial_thread_stack_bottom = (address)stack_top - _initial_thread_stack_size;
 }
+#endif
 
 ////////////////////////////////////////////////////////////////////////////////
 // time support
@@ -1270,9 +1376,7 @@
   return (1000 * 1000);
 }
 
-// For now, we say that bsd does not support vtime.  I have no idea
-// whether it can actually be made to (DLD, 9/13/05).
-
+// XXX: For now, code this as if BSD does not support vtime.
 bool os::supports_vtime() { return false; }
 bool os::enable_vtime()   { return false; }
 bool os::vtime_enabled()  { return false; }
@@ -1292,6 +1396,21 @@
 #define CLOCK_MONOTONIC (1)
 #endif
 
+#ifdef __APPLE__
+void os::Bsd::clock_init() {
+	// XXXDARWIN: Investigate replacement monotonic clock
+}
+#elif defined(_ALLBSD_SOURCE)
+void os::Bsd::clock_init() {
+  struct timespec res;
+  struct timespec tp;
+  if (::clock_getres(CLOCK_MONOTONIC, &res) == 0 &&
+      ::clock_gettime(CLOCK_MONOTONIC, &tp)  == 0) {
+    // yes, monotonic clock is supported
+    _clock_gettime = ::clock_gettime;
+  }
+}
+#else
 void os::Bsd::clock_init() {
   // we do dlopen's in this particular order due to bug in bsd
   // dynamical loader (see 6348968) leading to crash on exit
@@ -1327,7 +1446,9 @@
     }
   }
 }
+#endif
 
+#ifndef _ALLBSD_SOURCE
 #ifndef SYS_clock_getres
 
 #if defined(IA32) || defined(AMD64)
@@ -1366,6 +1487,7 @@
     _pthread_getcpuclockid = pthread_getcpuclockid_func;
   }
 }
+#endif
 
 jlong os::javaTimeNanos() {
   if (Bsd::supports_monotonic_clock()) {
@@ -1516,7 +1638,14 @@
 
 // DLL functions
 
-const char* os::dll_file_extension() { return ".so"; }
+#define JNI_LIB_PREFIX "lib"
+#ifdef __APPLE__
+#define JNI_LIB_SUFFIX ".dylib"
+#else
+#define JNI_LIB_SUFFIX ".so"
+#endif
+
+const char* os::dll_file_extension() { return JNI_LIB_SUFFIX; }
 
 const char* os::get_temp_directory() { return "/tmp/"; }
 
@@ -1534,13 +1663,13 @@
   const size_t pnamelen = pname ? strlen(pname) : 0;
 
   // Quietly truncate on buffer overflow.  Should be an error.
-  if (pnamelen + strlen(fname) + 10 > (size_t) buflen) {
+  if (pnamelen + strlen(fname) + strlen(JNI_LIB_PREFIX) + strlen(JNI_LIB_SUFFIX) + 2 > buflen) {
       *buffer = '\0';
       return;
   }
 
   if (pnamelen == 0) {
-    snprintf(buffer, buflen, "lib%s.so", fname);
+    snprintf(buffer, buflen, JNI_LIB_PREFIX "%s" JNI_LIB_SUFFIX, fname);
   } else if (strchr(pname, *os::path_separator()) != NULL) {
     int n;
     char** pelements = split_path(pname, &n);
@@ -1549,7 +1678,8 @@
       if (pelements[i] == NULL || strlen(pelements[i]) == 0) {
         continue; // skip the empty path values
       }
-      snprintf(buffer, buflen, "%s/lib%s.so", pelements[i], fname);
+      snprintf(buffer, buflen, "%s/" JNI_LIB_PREFIX "%s" JNI_LIB_SUFFIX,
+          pelements[i], fname);
       if (file_exists(buffer)) {
         break;
       }
@@ -1564,7 +1694,7 @@
       FREE_C_HEAP_ARRAY(char*, pelements);
     }
   } else {
-    snprintf(buffer, buflen, "%s/lib%s.so", pname, fname);
+    snprintf(buffer, buflen, "%s/" JNI_LIB_PREFIX "%s" JNI_LIB_SUFFIX, pname, fname);
   }
 }
 
@@ -1605,6 +1735,23 @@
   }
 }
 
+#ifdef _ALLBSD_SOURCE
+// ported from solaris version
+bool os::dll_address_to_library_name(address addr, char* buf,
+                                     int buflen, int* offset) {
+  Dl_info dlinfo;
+
+  if (dladdr((void*)addr, &dlinfo)){
+     if (buf) jio_snprintf(buf, buflen, "%s", dlinfo.dli_fname);
+     if (offset) *offset = addr - (address)dlinfo.dli_fbase;
+     return true;
+  } else {
+     if (buf) buf[0] = '\0';
+     if (offset) *offset = -1;
+     return false;
+  }
+}
+#else
 struct _address_to_library_name {
   address addr;          // input : memory address
   size_t  buflen;        //         size of fname
@@ -1679,11 +1826,27 @@
      return false;
   }
 }
+#endif
 
   // Loads .dll/.so and
   // in case of error it checks if .dll/.so was built for the
   // same architecture as Hotspot is running on
+ 
+#ifdef __APPLE__
+void * os::dll_load(const char *filename, char *ebuf, int ebuflen) {
+  void * result= ::dlopen(filename, RTLD_LAZY);
+  if (result != NULL) {
+    // Successful loading
+    return result;
+  }
 
+  // Read system error message into ebuf
+  ::strncpy(ebuf, ::dlerror(), ebuflen-1);
+  ebuf[ebuflen-1]='\0';
+
+  return NULL;
+}
+#else
 void * os::dll_load(const char *filename, char *ebuf, int ebuflen)
 {
   void * result= ::dlopen(filename, RTLD_LAZY);
@@ -1736,6 +1899,26 @@
   #define EM_486          6               /* Intel 80486 */
   #endif
 
+  #ifndef EM_MIPS_RS3_LE
+  #define EM_MIPS_RS3_LE  10              /* MIPS */
+  #endif
+
+  #ifndef EM_PPC64
+  #define EM_PPC64        21              /* PowerPC64 */
+  #endif
+
+  #ifndef EM_S390
+  #define EM_S390         22              /* IBM System/390 */
+  #endif
+
+  #ifndef EM_IA_64
+  #define EM_IA_64        50              /* HP/Intel IA-64 */ 
+  #endif
+
+  #ifndef EM_X86_64
+  #define EM_X86_64       62              /* AMD x86-64 */ 
+  #endif
+
   static const arch_t arch_array[]={
     {EM_386,         EM_386,     ELFCLASS32, ELFDATA2LSB, (char*)"IA 32"},
     {EM_486,         EM_386,     ELFCLASS32, ELFDATA2LSB, (char*)"IA 32"},
@@ -1839,17 +2022,11 @@
 
   return NULL;
 }
+#endif /* !__APPLE__ */
 
-/*
- * glibc-2.0 libdl is not MT safe.  If you are building with any glibc,
- * chances are you might want to run the generated bits against glibc-2.0
- * libdl.so, so always use locking for any version of glibc.
- */
+// XXX: Do we need a lock around this as per Linux?
 void* os::dll_lookup(void* handle, const char* name) {
-  pthread_mutex_lock(&dl_mutex);
-  void* res = dlsym(handle, name);
-  pthread_mutex_unlock(&dl_mutex);
-  return res;
+  return dlsym(handle, name);
 }
 
 
@@ -1872,7 +2049,51 @@
 
 void os::print_dll_info(outputStream *st) {
    st->print_cr("Dynamic libraries:");
-
+#ifdef _ALLBSD_SOURCE
+#ifdef RTLD_DI_LINKMAP
+    Dl_info dli;
+    void *handle;
+    Link_map *map;
+    Link_map *p;
+
+    if (!dladdr(CAST_FROM_FN_PTR(void *, os::print_dll_info), &dli)) {
+        st->print_cr("Error: Cannot print dynamic libraries.");
+        return;
+    }
+    handle = dlopen(dli.dli_fname, RTLD_LAZY);
+    if (handle == NULL) {
+        st->print_cr("Error: Cannot print dynamic libraries.");
+        return;
+    }
+    dlinfo(handle, RTLD_DI_LINKMAP, &map);
+    if (map == NULL) {
+        st->print_cr("Error: Cannot print dynamic libraries.");
+        return;
+    }
+
+    while (map->l_prev != NULL)
+        map = map->l_prev;
+
+    while (map != NULL) {
+        st->print_cr(PTR_FORMAT " \t%s", map->l_addr, map->l_name);
+        map = map->l_next;
+    }
+
+    dlclose(handle);
+#elif defined(__APPLE__)
+    uint32_t count;
+    uint32_t i;
+
+    count = _dyld_image_count();
+    for (i = 1; i < count; i++) {
+        const char *name = _dyld_get_image_name(i);
+        intptr_t slide = _dyld_get_image_vmaddr_slide(i);
+        st->print_cr(PTR_FORMAT " \t%s", slide, name);
+    }
+#else
+   st->print_cr("Error: Cannot print dynamic libraries.");
+#endif
+#else
    char fname[32];
    pid_t pid = os::Bsd::gettid();
 
@@ -1881,6 +2102,7 @@
    if (!_print_ascii_file(fname, st)) {
      st->print("Can not get library information for pid = %d\n", pid);
    }
+#endif
 }
 
 
@@ -1913,6 +2135,7 @@
   st->print(name.machine);
   st->cr();
 
+#ifndef _ALLBSD_SOURCE
   // Print warning if unsafe chroot environment detected
   if (unsafe_chroot_detected) {
     st->print("WARNING!! ");
@@ -1927,6 +2150,7 @@
      st->print("(%s stack)", os::Bsd::is_floating_stack() ? "floating" : "fixed");
   }
   st->cr();
+#endif
 
   // rlimit
   st->print("rlimit:");
@@ -1952,6 +2176,7 @@
   if (rlim.rlim_cur == RLIM_INFINITY) st->print("infinity");
   else st->print("%d", rlim.rlim_cur);
 
+#ifndef _ALLBSD_SOURCE
   st->print(", AS ");
   getrlimit(RLIMIT_AS, &rlim);
   if (rlim.rlim_cur == RLIM_INFINITY) st->print("infinity");
@@ -1964,6 +2189,7 @@
   os::loadavg(loadavg, 3);
   st->print("%0.02f %0.02f %0.02f", loadavg[0], loadavg[1], loadavg[2]);
   st->cr();
+#endif
 }
 
 void os::print_memory_info(outputStream* st) {
@@ -1971,18 +2197,22 @@
   st->print("Memory:");
   st->print(" %dk page", os::vm_page_size()>>10);
 
+#ifndef _ALLBSD_SOURCE
   // values in struct sysinfo are "unsigned long"
   struct sysinfo si;
   sysinfo(&si);
+#endif
 
   st->print(", physical " UINT64_FORMAT "k",
             os::physical_memory() >> 10);
   st->print("(" UINT64_FORMAT "k free)",
             os::available_memory() >> 10);
+#ifndef _ALLBSD_SOURCE
   st->print(", swap " UINT64_FORMAT "k",
             ((jlong)si.totalswap * si.mem_unit) >> 10);
   st->print("(" UINT64_FORMAT "k free)",
             ((jlong)si.freeswap * si.mem_unit) >> 10);
+#endif
   st->cr();
 }
 
@@ -2209,19 +2439,29 @@
 static volatile jint pending_signals[NSIG+1] = { 0 };
 
 // Bsd(POSIX) specific hand shaking semaphore.
+#ifdef __APPLE__
+static semaphore_t sig_sem;
+#define SEM_INIT(sem, value)	semaphore_create(mach_task_self(), &sem, SYNC_POLICY_FIFO, value)
+#define SEM_WAIT(sem)		semaphore_wait(sem);
+#define SEM_POST(sem)		semaphore_signal(sem);
+#else
 static sem_t sig_sem;
+#define SEM_INIT(sem, value)	sem_init(&sem, 0, value)
+#define SEM_WAIT(sem)		sem_wait(&sem);
+#define SEM_POST(sem)		sem_post(&sem);
+#endif
 
 void os::signal_init_pd() {
   // Initialize signal structures
   ::memset((void*)pending_signals, 0, sizeof(pending_signals));
 
   // Initialize signal semaphore
-  ::sem_init(&sig_sem, 0, 0);
+  ::SEM_INIT(sig_sem, 0);
 }
 
 void os::signal_notify(int sig) {
   Atomic::inc(&pending_signals[sig]);
-  ::sem_post(&sig_sem);
+  ::SEM_POST(sig_sem);
 }
 
 static int check_pending_signals(bool wait) {
@@ -2243,7 +2483,7 @@
     do {
       thread->set_suspend_equivalent();
       // cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()
-      ::sem_wait(&sig_sem);
+      ::SEM_WAIT(sig_sem);
 
       // were we externally suspended while we were waiting?
       threadIsSuspended = thread->handle_special_suspend_equivalent_condition();
@@ -2254,7 +2494,7 @@
         // while suspended because that would surprise the thread that
         // suspended us.
         //
-        ::sem_post(&sig_sem);
+        ::SEM_POST(sig_sem);
 
         thread->java_suspend_self();
       }
@@ -2326,9 +2566,14 @@
 //       problem.
 bool os::commit_memory(char* addr, size_t size, bool exec) {
   int prot = exec ? PROT_READ|PROT_WRITE|PROT_EXEC : PROT_READ|PROT_WRITE;
+#ifdef __OpenBSD__
+  // XXX: Work-around mmap/MAP_FIXED bug temporarily on OpenBSD
+  return ::mprotect(addr, size, prot) == 0;
+#else
   uintptr_t res = (uintptr_t) ::mmap(addr, size, prot,
                                    MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0);
   return res != (uintptr_t) MAP_FAILED;
+#endif
 }
 
 bool os::commit_memory(char* addr, size_t size, size_t alignment_hint,
@@ -2344,36 +2589,27 @@
 }
 
 void os::numa_make_global(char *addr, size_t bytes) {
-  Bsd::numa_interleave_memory(addr, bytes);
 }
 
 void os::numa_make_local(char *addr, size_t bytes, int lgrp_hint) {
-  Bsd::numa_tonode_memory(addr, bytes, lgrp_hint);
 }
 
 bool os::numa_topology_changed()   { return false; }
 
 size_t os::numa_get_groups_num() {
-  int max_node = Bsd::numa_max_node();
-  return max_node > 0 ? max_node + 1 : 1;
+  return 1;
 }
 
 int os::numa_get_group_id() {
-  int cpu_id = Bsd::sched_getcpu();
-  if (cpu_id != -1) {
-    int lgrp_id = Bsd::get_node_by_cpu(cpu_id);
-    if (lgrp_id != -1) {
-      return lgrp_id;
-    }
-  }
   return 0;
 }
 
 size_t os::numa_get_leaf_groups(int *ids, size_t size) {
-  for (size_t i = 0; i < size; i++) {
-    ids[i] = i;
+  if (size > 0) {
+    ids[0] = 0;
+    return 1;
   }
-  return size;
+  return 0;
 }
 
 bool os::get_page_info(char *start, page_info* info) {
@@ -2384,6 +2620,7 @@
   return end;
 }
 
+#ifndef _ALLBSD_SOURCE
 extern "C" void numa_warn(int number, char *where, ...) { }
 extern "C" void numa_error(char *where) { }
 
@@ -2485,11 +2722,18 @@
 os::Bsd::numa_tonode_memory_func_t os::Bsd::_numa_tonode_memory;
 os::Bsd::numa_interleave_memory_func_t os::Bsd::_numa_interleave_memory;
 unsigned long* os::Bsd::_numa_all_nodes;
+#endif
 
 bool os::uncommit_memory(char* addr, size_t size) {
-  return ::mmap(addr, size, PROT_NONE,
+#ifdef __OpenBSD__
+  // XXX: Work-around mmap/MAP_FIXED bug temporarily on OpenBSD
+  return ::mprotect(addr, size, PROT_NONE) == 0;
+#else
+  return ::mmap(addr, size,
+                PROT_READ|PROT_WRITE|PROT_EXEC,
                 MAP_PRIVATE|MAP_FIXED|MAP_NORESERVE|MAP_ANONYMOUS, -1, 0)
     != MAP_FAILED;
+#endif
 }
 
 static address _highest_vm_reserved_address = NULL;
@@ -2593,6 +2837,9 @@
 static size_t _large_page_size = 0;
 
 bool os::large_page_init() {
+#ifdef _ALLBSD_SOURCE
+  return false;
+#else
   if (!UseLargePages) return false;
 
   if (LargePageSizeInBytes) {
@@ -2649,6 +2896,7 @@
   // We optimistically assume the support is available. If later it turns out
   // not true, VM will automatically switch to use regular page size.
   return true;
+#endif
 }
 
 #ifndef SHM_HUGETLB
@@ -2825,7 +3073,7 @@
 }
 
 size_t os::read(int fd, void *buf, unsigned int nBytes) {
-  return ::read(fd, buf, nBytes);
+  RESTARTABLE_RETURN_INT(::read(fd, buf, nBytes));
 }
 
 // TODO-FIXME: reconcile Solaris' os::sleep with the bsd variation.
@@ -2961,6 +3209,44 @@
 // this reason, the code should not be used as default (ThreadPriorityPolicy=0).
 // It is only used when ThreadPriorityPolicy=1 and requires root privilege.
 
+#if defined(_ALLBSD_SOURCE) && !defined(__APPLE__)
+int os::java_to_os_priority[MaxPriority + 1] = {
+  19,              // 0 Entry should never be used
+
+   0,              // 1 MinPriority
+   3,              // 2
+   6,              // 3
+
+   10,              // 4
+   15,              // 5 NormPriority
+   18,              // 6
+
+   21,              // 7
+   25,              // 8
+   28,              // 9 NearMaxPriority
+
+   31              // 10 MaxPriority
+};
+#elif defined(__APPLE__)
+/* Using Mach high-level priority assignments */
+int os::java_to_os_priority[MaxPriority + 1] = {
+   0,              // 0 Entry should never be used (MINPRI_USER)
+
+  27,              // 1 MinPriority
+  28,              // 2
+  29,              // 3
+
+  30,              // 4
+  31,              // 5 NormPriority (BASEPRI_DEFAULT)
+  32,              // 6
+
+  33,              // 7
+  34,              // 8
+  35,              // 9 NearMaxPriority
+
+  36               // 10 MaxPriority
+};
+#else
 int os::java_to_os_priority[MaxPriority + 1] = {
   19,              // 0 Entry should never be used
 
@@ -2978,6 +3264,7 @@
 
   -5               // 10 MaxPriority
 };
+#endif
 
 static int prio_init() {
   if (ThreadPriorityPolicy == 1) {
@@ -2997,8 +3284,28 @@
 OSReturn os::set_native_priority(Thread* thread, int newpri) {
   if ( !UseThreadPriorities || ThreadPriorityPolicy == 0 ) return OS_OK;
 
+#ifdef __OpenBSD__
+  // OpenBSD pthread_setprio starves low priority threads
+  return OS_OK;
+#elif defined(__FreeBSD__)
+  int ret = pthread_setprio(thread->osthread()->pthread_id(), newpri);
+#elif defined(__APPLE__) || defined(__NetBSD__)
+  struct sched_param sp;
+  int policy;
+  pthread_t self = pthread_self();
+
+  if (pthread_getschedparam(self, &policy, &sp) != 0)
+    return OS_ERR;
+
+  sp.sched_priority = newpri;
+  if (pthread_setschedparam(self, policy, &sp) != 0)
+    return OS_ERR;
+
+  return OS_OK;
+#else
   int ret = setpriority(PRIO_PROCESS, thread->osthread()->thread_id(), newpri);
   return (ret == 0) ? OS_OK : OS_ERR;
+#endif
 }
 
 OSReturn os::get_native_priority(const Thread* const thread, int *priority_ptr) {
@@ -3008,7 +3315,17 @@
   }
 
   errno = 0;
+#if defined(__OpenBSD__) || defined(__FreeBSD__)
+  *priority_ptr = pthread_getprio(thread->osthread()->pthread_id());
+#elif defined(__APPLE__) || defined(__NetBSD__)
+  int policy;
+  struct sched_param sp;
+
+  pthread_getschedparam(pthread_self(), &policy, &sp);
+  *priority_ptr = sp.sched_priority;
+#else
   *priority_ptr = getpriority(PRIO_PROCESS, thread->osthread()->thread_id());
+#endif
   return (*priority_ptr != -1 || errno == 0 ? OS_OK : OS_ERR);
 }
 
@@ -3118,7 +3435,7 @@
   /* Get signal number to use for suspend/resume */
   if ((s = ::getenv("_JAVA_SR_SIGNUM")) != 0) {
     int sig = ::strtol(s, 0, 10);
-    if (sig > 0 || sig < _NSIG) {
+    if (sig > 0 || sig < NSIG) {
         SR_signum = sig;
     }
   }
@@ -3461,6 +3778,28 @@
     set_signal_handler(SIGFPE, true);
     set_signal_handler(SIGXFSZ, true);
 
+#if defined(__APPLE__)
+    // In Mac OS X 10.4, CrashReporter will write a crash log for all 'fatal' signals, including
+    // signals caught and handled by the JVM. To work around this, we reset the mach task
+    // signal handler that's placed on our process by CrashReporter. This disables
+    // CrashReporter-based reporting.
+    //
+    // This work-around is not necessary for 10.5+, as CrashReporter no longer intercedes
+    // on caught fatal signals.
+    //
+    // Additionally, gdb installs both standard BSD signal handlers, and mach exception
+    // handlers. By replacing the existing task exception handler, we disable gdb's mach
+    // exception handling, while leaving the standard BSD signal handlers functional.
+    kern_return_t kr;
+    kr = task_set_exception_ports(mach_task_self(),
+        EXC_MASK_BAD_ACCESS | EXC_MASK_ARITHMETIC,
+        MACH_PORT_NULL,
+        EXCEPTION_STATE_IDENTITY,
+        MACHINE_THREAD_STATE);
+
+    assert(kr == KERN_SUCCESS, "could not set mach task signal handler");
+#endif
+
     if (libjsig_is_loaded) {
       // Tell libjsig jvm finishes setting signal handlers
       (*end_signal_setting)();
@@ -3481,6 +3820,7 @@
   }
 }
 
+#ifndef _ALLBSD_SOURCE
 // This is the fastest way to get thread cpu time on Bsd.
 // Returns cpu time (user+sys) for any thread, not only for current.
 // POSIX compliant clocks are implemented in the kernels 2.6.16+.
@@ -3495,6 +3835,7 @@
 
   return (tp.tv_sec * SEC_IN_NANOSECS) + tp.tv_nsec;
 }
+#endif
 
 /////
 // glibc on Bsd platform uses non-documented flag
@@ -3716,13 +4057,13 @@
 
   _initial_pid = (java_launcher_pid > 0) ? java_launcher_pid : getpid();
 
-  clock_tics_per_sec = sysconf(_SC_CLK_TCK);
+  clock_tics_per_sec = CLK_TCK;
 
   init_random(1234567);
 
   ThreadCritical::initialize();
 
-  Bsd::set_page_size(sysconf(_SC_PAGESIZE));
+  Bsd::set_page_size(getpagesize());
   if (Bsd::page_size() == -1) {
     fatal1("os_bsd.cpp: os::init: sysconf failed (%s)", strerror(errno));
   }
@@ -3735,7 +4076,16 @@
 
   Bsd::clock_init();
   initial_time_count = os::elapsed_counter();
-  pthread_mutex_init(&dl_mutex, NULL);
+
+#ifdef __APPLE__
+  // XXXDARWIN
+  // Work around the unaligned VM callbacks in hotspot's
+  // sharedRuntime. The callbacks don't use SSE2 instructions, and work on
+  // Linux, Solaris, and FreeBSD. On Mac OS X, dyld (rightly so) enforces
+  // alignment when doing symbol lookup. To work around this, we force early
+  // binding of all symbols now, thus binding when alignment is known-good.
+  _dyld_bind_fully_image_containing_address((const void *) &os::init);
+#endif
 }
 
 // To install functions for atexit system call
@@ -3748,7 +4098,9 @@
 // this is called _after_ the global arguments have been parsed
 jint os::init_2(void)
 {
+#ifndef _ALLBSD_SOURCE
   Bsd::fast_thread_clock_init();
+#endif
 
   // Allocate a single page and mark it as readable for safepoint polling
   address polling_page = (address) ::mmap(NULL, Bsd::page_size(), PROT_READ, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);
@@ -3797,6 +4149,7 @@
   JavaThread::set_stack_size_at_create(round_to(threadStackSizeInBytes,
         vm_page_size()));
 
+#ifndef _ALLBSD_SOURCE
   Bsd::capture_initial_stack(JavaThread::stack_size_at_create());
 
   Bsd::libpthread_init();
@@ -3819,6 +4172,7 @@
       UseNUMA = true;
     }
   }
+#endif
 
   if (MaxFDLimit) {
     // set the number of file descriptors to max. print out error
@@ -3830,6 +4184,14 @@
         perror("os::init_2 getrlimit failed");
     } else {
       nbr_files.rlim_cur = nbr_files.rlim_max;
+      
+#ifdef __APPLE__
+      // Darwin returns RLIM_INFINITY for rlim_max, but fails with EINVAL if
+      // you attempt to use RLIM_INFINITY. As per setrlimit(2), OPEN_MAX must
+      // be used instead
+      nbr_files.rlim_cur = MIN(OPEN_MAX, nbr_files.rlim_cur);
+#endif
+
       status = setrlimit(RLIMIT_NOFILE, &nbr_files);
       if (status != 0) {
         if (PrintMiscellaneous && (Verbose || WizardMode))
@@ -3838,8 +4200,10 @@
     }
   }
 
+#ifndef _ALLBSD_SOURCE
   // Initialize lock used to serialize thread creation (see os::create_thread)
   Bsd::set_createThread_lock(new Mutex(Mutex::leaf, "createThread_lock", false));
+#endif
 
   // Initialize HPI.
   jint hpi_result = hpi::initialize();
@@ -3887,11 +4251,15 @@
 };
 
 int os::active_processor_count() {
+#ifdef _ALLBSD_SOURCE
+  return _processor_count;
+#else
   // Bsd doesn't yet have a (official) notion of processor sets,
   // so just return the number of online processors.
   int online_cpus = ::sysconf(_SC_NPROCESSORS_ONLN);
   assert(online_cpus > 0 && online_cpus <= processor_count(), "sanity check");
   return online_cpus;
+#endif
 }
 
 bool os::distribute_processes(uint length, uint* distribution) {
@@ -3933,6 +4301,9 @@
 
 int os::Bsd::safe_cond_timedwait(pthread_cond_t *_cond, pthread_mutex_t *_mutex, const struct timespec *_abstime)
 {
+#ifdef _ALLBSD_SOURCE
+  return pthread_cond_timedwait(_cond, _mutex, _abstime);
+#else
    if (is_NPTL()) {
       return pthread_cond_timedwait(_cond, _mutex, _abstime);
    } else {
@@ -3948,6 +4319,7 @@
 #endif // IA64
       return status;
    }
+#endif
 }
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -4083,17 +4455,17 @@
   if (!rewrite_existing) {
     oflags |= O_EXCL;
   }
-  return ::open64(path, oflags, S_IREAD | S_IWRITE);
+  return ::open(path, oflags, S_IREAD | S_IWRITE);
 }
 
 // return current position of file pointer
 jlong os::current_file_offset(int fd) {
-  return (jlong)::lseek64(fd, (off64_t)0, SEEK_CUR);
+  return (jlong)::lseek(fd, (off_t)0, SEEK_CUR);
 }
 
 // move file pointer to the specified offset
 jlong os::seek_to_file_offset(int fd, jlong offset) {
-  return (jlong)::lseek64(fd, (off64_t)offset, SEEK_SET);
+  return (jlong)::lseek(fd, (off_t)offset, SEEK_SET);
 }
 
 // Map a block of memory.
@@ -4143,6 +4515,7 @@
   return munmap(addr, bytes) == 0;
 }
 
+#ifndef _ALLBSD_SOURCE
 static jlong slow_thread_cpu_time(Thread *thread, bool user_sys_cpu_time);
 
 static clockid_t thread_cpu_clockid(Thread* thread) {
@@ -4154,6 +4527,7 @@
   assert(rc == 0, "pthread_getcpuclockid is expected to return 0 code");
   return clockid;
 }
+#endif
 
 // current_thread_cpu_time(bool) and thread_cpu_time(Thread*, bool)
 // are used by JVM M&M and JVMTI to get user+sys or user CPU time
@@ -4163,39 +4537,71 @@
 // the fast estimate available on the platform.
 
 jlong os::current_thread_cpu_time() {
+#ifdef __APPLE__
+  return os::thread_cpu_time(Thread::current(), true /* user + sys */);
+#elif !defined(_ALLBSD_SOURCE)
   if (os::Bsd::supports_fast_thread_cpu_time()) {
     return os::Bsd::fast_thread_cpu_time(CLOCK_THREAD_CPUTIME_ID);
   } else {
     // return user + sys since the cost is the same
     return slow_thread_cpu_time(Thread::current(), true /* user + sys */);
   }
+#endif
 }
 
 jlong os::thread_cpu_time(Thread* thread) {
+#ifndef _ALLBSD_SOURCE
   // consistent with what current_thread_cpu_time() returns
   if (os::Bsd::supports_fast_thread_cpu_time()) {
     return os::Bsd::fast_thread_cpu_time(thread_cpu_clockid(thread));
   } else {
     return slow_thread_cpu_time(thread, true /* user + sys */);
   }
+#endif
 }
 
 jlong os::current_thread_cpu_time(bool user_sys_cpu_time) {
+#ifdef __APPLE__
+  return os::thread_cpu_time(Thread::current(), user_sys_cpu_time);
+#elif !defined(_ALLBSD_SOURCE)
   if (user_sys_cpu_time && os::Bsd::supports_fast_thread_cpu_time()) {
     return os::Bsd::fast_thread_cpu_time(CLOCK_THREAD_CPUTIME_ID);
   } else {
     return slow_thread_cpu_time(Thread::current(), user_sys_cpu_time);
   }
+#endif
 }
 
 jlong os::thread_cpu_time(Thread *thread, bool user_sys_cpu_time) {
+#ifdef __APPLE__
+  struct thread_basic_info tinfo;
+  mach_msg_type_number_t tcount = THREAD_INFO_MAX;
+  kern_return_t kr;
+  mach_port_t mach_thread;
+
+  mach_thread = pthread_mach_thread_np(thread->osthread()->thread_id());
+  kr = thread_info(mach_thread, THREAD_BASIC_INFO, (thread_info_t)&tinfo, &tcount);
+  if (kr != KERN_SUCCESS)
+    return -1;
+
+  if (user_sys_cpu_time) {
+    jlong nanos;
+    nanos = ((jlong) tinfo.system_time.seconds + tinfo.user_time.seconds) * (jlong)1000000000;
+    nanos += ((jlong) tinfo.system_time.microseconds + (jlong) tinfo.user_time.microseconds) * (jlong)1000;
+    return nanos;
+  } else {
+    return ((jlong)tinfo.user_time.seconds * 1000000000) + ((jlong)tinfo.user_time.microseconds * (jlong)1000);
+  }
+#elif !defined(_ALLBSD_SOURCE)
   if (user_sys_cpu_time && os::Bsd::supports_fast_thread_cpu_time()) {
     return os::Bsd::fast_thread_cpu_time(thread_cpu_clockid(thread));
   } else {
     return slow_thread_cpu_time(thread, user_sys_cpu_time);
   }
+#endif
 }
 
+#ifndef _ALLBSD_SOURCE
 //
 //  -1 on error.
 //
@@ -4284,6 +4690,7 @@
     return (jlong)user_time * (1000000000 / clock_tics_per_sec);
   }
 }
+#endif
 
 void os::current_thread_cpu_time_info(jvmtiTimerInfo *info_ptr) {
   info_ptr->max_value = ALL_64_BITS;       // will not wrap in less than 64 bits
@@ -4300,7 +4707,13 @@
 }
 
 bool os::is_thread_cpu_time_supported() {
+#ifdef __APPLE__
+  return true;
+#elif defined(_ALLBSD_SOURCE)
+  return false;
+#else
   return true;
+#endif
 }
 
 // System loadavg support.  Returns -1 if load average cannot be obtained.
@@ -4433,7 +4846,7 @@
 // abstime will be the absolute timeout time
 // TODO: replace compute_abstime() with unpackTime()
 
-static struct timespec* compute_abstime(timespec* abstime, jlong millis) {
+static struct timespec* compute_abstime(struct timespec* abstime, jlong millis) {
   if (millis < 0)  millis = 0;
   struct timeval now;
   int status = gettimeofday(&now, NULL);
@@ -4485,7 +4898,7 @@
         status = pthread_cond_wait(_cond, _mutex);
         // for some reason, under 2.7 lwp_cond_wait() may return ETIME ...
         // Treat this the same as if the wait was interrupted
-        if (status == ETIME) { status = EINTR; }
+        if (status == ETIMEDOUT) { status = EINTR; } 
         assert_status(status == 0 || status == EINTR, status, "cond_wait");
      }
      -- _nParked ;
@@ -4543,10 +4956,10 @@
       pthread_cond_init (_cond, NULL) ;
     }
     assert_status(status == 0 || status == EINTR ||
-                  status == ETIME || status == ETIMEDOUT,
+		  status == ETIMEDOUT, 
                   status, "cond_timedwait");
     if (!FilterSpuriousWakeups) break ;                 // previous semantics
-    if (status == ETIME || status == ETIMEDOUT) break ;
+    if (status == ETIMEDOUT) break ; 
     // We consume and ignore EINTR and spurious wakeups.
   }
   --_nParked ;
@@ -4638,7 +5051,7 @@
  * years from "now".
  */
 
-static void unpackTime(timespec* absTime, bool isAbsolute, jlong time) {
+static void unpackTime(struct timespec* absTime, bool isAbsolute, jlong time) {
   assert (time > 0, "convertTime");
 
   struct timeval now;
@@ -4698,7 +5111,7 @@
   }
 
   // Next, demultiplex/decode time arguments
-  timespec absTime;
+  struct timespec absTime;
   if (time < 0) { // don't wait at all
     return;
   }
@@ -4752,7 +5165,7 @@
     }
   }
   assert_status(status == 0 || status == EINTR ||
-                status == ETIME || status == ETIMEDOUT,
+                status == ETIMEDOUT, 
                 status, "cond_timedwait");
 
 #ifdef ASSERT
@@ -4795,14 +5208,12 @@
 }
 
 
+/* Darwin has no "environ" in a dynamic library. */
+#ifdef __APPLE__
+#include <crt_externs.h>
+#define environ (*_NSGetEnviron())
+#else
 extern char** environ;
-
-#ifndef __NR_fork
-#define __NR_fork IA32_ONLY(2) IA64_ONLY(not defined) AMD64_ONLY(57)
-#endif
-
-#ifndef __NR_execve
-#define __NR_execve IA32_ONLY(11) IA64_ONLY(1033) AMD64_ONLY(59)
 #endif
 
 // Run the specified command in a separate process. Return its exit value,
@@ -4817,8 +5228,7 @@
   // separate process to execve. Make a direct syscall to fork process.
   // On IA64 there's no fork syscall, we have to use fork() and hope for
   // the best...
-  pid_t pid = NOT_IA64(syscall(__NR_fork);)
-              IA64_ONLY(fork();)
+  pid_t pid = fork();
 
   if (pid < 0) {
     // fork failed
@@ -4834,8 +5244,7 @@
     // in the new process, so make a system call directly.
     // IA64 should use normal execve() from glibc to match the glibc fork()
     // above.
-    NOT_IA64(syscall(__NR_execve, "/bin/sh", argv, environ);)
-    IA64_ONLY(execve("/bin/sh", (char* const*)argv, environ);)
+    execve("/bin/sh", (char* const*)argv, environ);
 
     // execve failed
     _exit(-1);
--- ./hotspot/src/os/bsd/vm/os_bsd.hpp	2010-03-27 11:09:10.000000000 -0700
+++ ./hotspot/src/os/bsd/vm/os_bsd.hpp	2009-10-05 21:49:06.000000000 -0700
@@ -27,6 +27,12 @@
 /* pthread_getattr_np comes with BsdThreads-0.9-7 on RedHat 7.1 */
 typedef int (*pthread_getattr_func_type) (pthread_t, pthread_attr_t *);
 
+#ifdef __APPLE__
+// Mac OS X doesn't support clock_gettime. Stub out the type, it is
+// unused
+typedef int clockid_t;
+#endif
+
 class Bsd {
   friend class os;
 
@@ -47,6 +53,7 @@
   static int sigflags[MAXSIGNUM];
 
   static int (*_clock_gettime)(clockid_t, struct timespec *);
+#ifndef _ALLBSD_SOURCE
   static int (*_pthread_getcpuclockid)(pthread_t, clockid_t *);
 
   static address   _initial_thread_stack_bottom;
@@ -58,6 +65,7 @@
   static bool _is_floating_stack;
   static bool _is_NPTL;
   static bool _supports_fast_thread_cpu_time;
+#endif
 
   static GrowableArray<int>* _cpu_to_node;
 
@@ -65,38 +73,52 @@
 
   static julong _physical_memory;
   static pthread_t _main_thread;
+#ifndef _ALLBSD_SOURCE
   static Mutex* _createThread_lock;
+#endif
   static int _page_size;
 
   static julong available_memory();
   static julong physical_memory() { return _physical_memory; }
   static void initialize_system_info();
 
+#ifndef _ALLBSD_SOURCE
   static void set_glibc_version(const char *s)      { _glibc_version = s; }
   static void set_libpthread_version(const char *s) { _libpthread_version = s; }
+#endif
 
   static bool supports_variable_stack_size();
 
+#ifndef _ALLBSD_SOURCE
   static void set_is_NPTL()                   { _is_NPTL = true;  }
   static void set_is_BsdThreads()           { _is_NPTL = false; }
   static void set_is_floating_stack()         { _is_floating_stack = true; }
+#endif
 
   static void rebuild_cpu_to_node_map();
   static GrowableArray<int>* cpu_to_node()    { return _cpu_to_node; }
  public:
+
   static void init_thread_fpu_state();
+#ifndef _ALLBSD_SOURCE
   static int  get_fpu_control_word();
   static void set_fpu_control_word(int fpu_control);
+#endif
   static pthread_t main_thread(void)                                { return _main_thread; }
+
+#ifndef _ALLBSD_SOURCE
   // returns kernel thread id (similar to LWP id on Solaris), which can be
   // used to access /proc
   static pid_t gettid();
   static void set_createThread_lock(Mutex* lk)                      { _createThread_lock = lk; }
   static Mutex* createThread_lock(void)                             { return _createThread_lock; }
+#endif
   static void hotspot_sigmask(Thread* thread);
 
+#ifndef _ALLBSD_SOURCE
   static address   initial_thread_stack_bottom(void)                { return _initial_thread_stack_bottom; }
   static uintptr_t initial_thread_stack_size(void)                  { return _initial_thread_stack_size; }
+#endif
   static bool is_initial_thread(void);
 
   static int page_size(void)                                        { return _page_size; }
@@ -133,6 +155,7 @@
   static struct sigaction *get_chained_signal_action(int sig);
   static bool chained_handler(int sig, siginfo_t* siginfo, void* context);
 
+#ifndef _ALLBSD_SOURCE
   // GNU libc and libpthread version strings
   static const char *glibc_version()          { return _glibc_version; }
   static const char *libpthread_version()     { return _libpthread_version; }
@@ -148,6 +171,7 @@
   static void libpthread_init();
   static bool libnuma_init();
   static void* libnuma_dlsym(void* handle, const char* name);
+#endif
   // Minimum stack size a thread can be created with (allowing
   // the VM to completely create the thread and enter user code)
   static size_t min_stack_allowed;
@@ -156,17 +180,21 @@
   static size_t default_stack_size(os::ThreadType thr_type);
   static size_t default_guard_size(os::ThreadType thr_type);
 
+#ifndef _ALLBSD_SOURCE
   static void capture_initial_stack(size_t max_size);
 
   // Stack overflow handling
   static bool manually_expand_stack(JavaThread * t, address addr);
   static int max_register_window_saves_before_flushing();
+#endif
 
   // Real-time clock functions
   static void clock_init(void);
 
+#ifndef _ALLBSD_SOURCE
   // fast POSIX clocks support
   static void fast_thread_clock_init(void);
+#endif
 
   static bool supports_monotonic_clock() {
     return _clock_gettime != NULL;
@@ -176,6 +204,7 @@
     return _clock_gettime ? _clock_gettime(clock_id, tp) : -1;
   }
 
+#ifndef _ALLBSD_SOURCE
   static int pthread_getcpuclockid(pthread_t tid, clockid_t *clock_id) {
     return _pthread_getcpuclockid ? _pthread_getcpuclockid(tid, clock_id) : -1;
   }
@@ -185,6 +214,7 @@
   }
 
   static jlong fast_thread_cpu_time(clockid_t clockid);
+#endif
 
   // Stack repair handling
 
--- ./hotspot/src/os/bsd/vm/os_bsd.inline.hpp	2010-03-27 11:09:10.000000000 -0700
+++ ./hotspot/src/os/bsd/vm/os_bsd.inline.hpp	2009-06-28 17:53:14.000000000 -0700
@@ -61,7 +61,15 @@
 
 inline bool os::allocate_stack_guard_pages() {
   assert(uses_stack_guard_pages(), "sanity check");
+#if !defined(__FreeBSD__) || __FreeBSD__ < 5
+  // Since FreeBSD 4 uses malloc() for allocating the thread stack
+  // there is no need to do anything extra to allocate the guard pages
+  return false;
+#else
+  // FreeBSD 5+ uses mmap MAP_STACK for allocating the thread stacks.
+  // Must 'allocate' them or guard pages are ignored.
   return true;
+#endif
 }
 
 
--- ./hotspot/src/os/bsd/vm/perfMemory_bsd.cpp	2010-03-27 11:09:10.000000000 -0700
+++ ./hotspot/src/os/bsd/vm/perfMemory_bsd.cpp	2009-06-06 16:54:01.000000000 -0700
@@ -241,7 +241,7 @@
 
   char* pwbuf = NEW_C_HEAP_ARRAY(char, bufsize);
 
-  // POSIX interface to getpwuid_r is used on BSD
+  // POSIX interface to getpwuid_r is used on LINUX
   struct passwd* p;
   int result = getpwuid_r(uid, &pwent, pwbuf, (size_t)bufsize, &p);
 
--- ./hotspot/src/os_cpu/bsd_sparc/vm/assembler_bsd_sparc.cpp	2010-03-27 11:09:10.000000000 -0700
+++ ./hotspot/src/os_cpu/bsd_sparc/vm/assembler_bsd_sparc.cpp	1969-12-31 16:00:00.000000000 -0800
@@ -1,45 +0,0 @@
-/*
- * Copyright 1999-2008 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- *
- */
-
-#include "incls/_precompiled.incl"
-#include "incls/_assembler_bsd_sparc.cpp.incl"
-
-#include <asm-sparc/traps.h>
-
-void MacroAssembler::read_ccr_trap(Register ccr_save) {
-  // No implementation
-  breakpoint_trap();
-}
-
-void MacroAssembler::write_ccr_trap(Register ccr_save, Register scratch1, Register scratch2) {
-  // No implementation
-  breakpoint_trap();
-}
-
-void MacroAssembler::flush_windows_trap() { trap(SP_TRAP_FWIN); }
-void MacroAssembler::clean_windows_trap() { trap(SP_TRAP_CWIN); }
-
-// Use software breakpoint trap until we figure out how to do this on Bsd
-void MacroAssembler::get_psr_trap()       { trap(SP_TRAP_SBPT); }
-void MacroAssembler::set_psr_trap()       { trap(SP_TRAP_SBPT); }
--- ./hotspot/src/os_cpu/bsd_sparc/vm/atomic_bsd_sparc.inline.hpp	2010-03-27 11:09:10.000000000 -0700
+++ ./hotspot/src/os_cpu/bsd_sparc/vm/atomic_bsd_sparc.inline.hpp	1969-12-31 16:00:00.000000000 -0800
@@ -1,206 +0,0 @@
-/*
- * Copyright 1999-2008 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- *
- */
-
-// Implementation of class atomic
-
-inline void Atomic::store    (jbyte    store_value, jbyte*    dest) { *dest = store_value; }
-inline void Atomic::store    (jshort   store_value, jshort*   dest) { *dest = store_value; }
-inline void Atomic::store    (jint     store_value, jint*     dest) { *dest = store_value; }
-inline void Atomic::store    (jlong    store_value, jlong*    dest) { *dest = store_value; }
-inline void Atomic::store_ptr(intptr_t store_value, intptr_t* dest) { *dest = store_value; }
-inline void Atomic::store_ptr(void*    store_value, void*     dest) { *(void**)dest = store_value; }
-
-inline void Atomic::store    (jbyte    store_value, volatile jbyte*    dest) { *dest = store_value; }
-inline void Atomic::store    (jshort   store_value, volatile jshort*   dest) { *dest = store_value; }
-inline void Atomic::store    (jint     store_value, volatile jint*     dest) { *dest = store_value; }
-inline void Atomic::store    (jlong    store_value, volatile jlong*    dest) { *dest = store_value; }
-inline void Atomic::store_ptr(intptr_t store_value, volatile intptr_t* dest) { *dest = store_value; }
-inline void Atomic::store_ptr(void*    store_value, volatile void*     dest) { *(void* volatile *)dest = store_value; }
-
-inline void Atomic::inc    (volatile jint*     dest) { (void)add    (1, dest); }
-inline void Atomic::inc_ptr(volatile intptr_t* dest) { (void)add_ptr(1, dest); }
-inline void Atomic::inc_ptr(volatile void*     dest) { (void)add_ptr(1, dest); }
-
-inline void Atomic::dec    (volatile jint*     dest) { (void)add    (-1, dest); }
-inline void Atomic::dec_ptr(volatile intptr_t* dest) { (void)add_ptr(-1, dest); }
-inline void Atomic::dec_ptr(volatile void*     dest) { (void)add_ptr(-1, dest); }
-
-inline jint     Atomic::add    (jint     add_value, volatile jint*     dest) {
-  intptr_t rv;
-  __asm__ volatile(
-    "1: \n\t"
-    " ld     [%2], %%o2\n\t"
-    " add    %1, %%o2, %%o3\n\t"
-    " cas    [%2], %%o2, %%o3\n\t"
-    " cmp    %%o2, %%o3\n\t"
-    " bne    1b\n\t"
-    "  nop\n\t"
-    " add    %1, %%o2, %0\n\t"
-    : "=r" (rv)
-    : "r" (add_value), "r" (dest)
-    : "memory", "o2", "o3");
-  return rv;
-}
-
-inline intptr_t Atomic::add_ptr(intptr_t add_value, volatile intptr_t* dest) {
-  intptr_t rv;
-#ifdef _LP64
-  __asm__ volatile(
-    "1: \n\t"
-    " ldx    [%2], %%o2\n\t"
-    " add    %0, %%o2, %%o3\n\t"
-    " casx   [%2], %%o2, %%o3\n\t"
-    " cmp    %%o2, %%o3\n\t"
-    " bne    %%xcc, 1b\n\t"
-    "  nop\n\t"
-    " add    %0, %%o2, %0\n\t"
-    : "=r" (rv)
-    : "r" (add_value), "r" (dest)
-    : "memory", "o2", "o3");
-#else
-  __asm__ volatile(
-    "1: \n\t"
-    " ld     [%2], %%o2\n\t"
-    " add    %1, %%o2, %%o3\n\t"
-    " cas    [%2], %%o2, %%o3\n\t"
-    " cmp    %%o2, %%o3\n\t"
-    " bne    1b\n\t"
-    "  nop\n\t"
-    " add    %1, %%o2, %0\n\t"
-    : "=r" (rv)
-    : "r" (add_value), "r" (dest)
-    : "memory", "o2", "o3");
-#endif // _LP64
-  return rv;
-}
-
-inline void*    Atomic::add_ptr(intptr_t add_value, volatile void*     dest) {
-  return (void*)add_ptr((intptr_t)add_value, (volatile intptr_t*)dest);
-}
-
-
-inline jint     Atomic::xchg    (jint     exchange_value, volatile jint*     dest) {
-  intptr_t rv = exchange_value;
-  __asm__ volatile(
-    " swap   [%2],%1\n\t"
-    : "=r" (rv)
-    : "0" (exchange_value) /* we use same register as for return value */, "r" (dest)
-    : "memory");
-  return rv;
-}
-
-inline intptr_t Atomic::xchg_ptr(intptr_t exchange_value, volatile intptr_t* dest) {
-  intptr_t rv = exchange_value;
-#ifdef _LP64
-  __asm__ volatile(
-    "1:\n\t"
-    " mov    %1, %%o3\n\t"
-    " ldx    [%2], %%o2\n\t"
-    " casx   [%2], %%o2, %%o3\n\t"
-    " cmp    %%o2, %%o3\n\t"
-    " bne    %%xcc, 1b\n\t"
-    "  nop\n\t"
-    " mov    %%o2, %0\n\t"
-    : "=r" (rv)
-    : "r" (exchange_value), "r" (dest)
-    : "memory", "o2", "o3");
-#else
-  __asm__ volatile(
-    "swap    [%2],%1\n\t"
-    : "=r" (rv)
-    : "0" (exchange_value) /* we use same register as for return value */, "r" (dest)
-    : "memory");
-#endif // _LP64
-  return rv;
-}
-
-inline void*    Atomic::xchg_ptr(void*    exchange_value, volatile void*     dest) {
-  return (void*)xchg_ptr((intptr_t)exchange_value, (volatile intptr_t*)dest);
-}
-
-
-inline jint     Atomic::cmpxchg    (jint     exchange_value, volatile jint*     dest, jint     compare_value) {
-  jint rv;
-  __asm__ volatile(
-    " cas    [%2], %3, %0"
-    : "=r" (rv)
-    : "0" (exchange_value), "r" (dest), "r" (compare_value)
-    : "memory");
-  return rv;
-}
-
-inline jlong    Atomic::cmpxchg    (jlong    exchange_value, volatile jlong*    dest, jlong    compare_value) {
-#ifdef _LP64
-  jlong rv;
-  __asm__ volatile(
-    " casx   [%2], %3, %0"
-    : "=r" (rv)
-    : "0" (exchange_value), "r" (dest), "r" (compare_value)
-    : "memory");
-  return rv;
-#else
-  assert(VM_Version::v9_instructions_work(), "cas only supported on v9");
-  volatile jlong_accessor evl, cvl, rv;
-  evl.long_value = exchange_value;
-  cvl.long_value = compare_value;
-
-  __asm__ volatile(
-    " sllx   %2, 32, %2\n\t"
-    " srl    %3, 0,  %3\n\t"
-    " or     %2, %3, %2\n\t"
-    " sllx   %5, 32, %5\n\t"
-    " srl    %6, 0,  %6\n\t"
-    " or     %5, %6, %5\n\t"
-    " casx   [%4], %5, %2\n\t"
-    " srl    %2, 0, %1\n\t"
-    " srlx   %2, 32, %0\n\t"
-    : "=r" (rv.words[0]), "=r" (rv.words[1])
-    : "r"  (evl.words[0]), "r" (evl.words[1]), "r" (dest), "r" (cvl.words[0]), "r" (cvl.words[1])
-    : "memory");
-
-  return rv.long_value;
-#endif
-}
-
-inline intptr_t Atomic::cmpxchg_ptr(intptr_t exchange_value, volatile intptr_t* dest, intptr_t compare_value) {
-  intptr_t rv;
-#ifdef _LP64
-  __asm__ volatile(
-    " casx    [%2], %3, %0"
-    : "=r" (rv)
-    : "0" (exchange_value), "r" (dest), "r" (compare_value)
-    : "memory");
-#else
-  __asm__ volatile(
-    " cas     [%2], %3, %0"
-    : "=r" (rv)
-    : "0" (exchange_value), "r" (dest), "r" (compare_value)
-    : "memory");
-#endif // _LP64
-  return rv;
-}
-
-inline void*    Atomic::cmpxchg_ptr(void*    exchange_value, volatile void*     dest, void*    compare_value) {
-  return (void*)cmpxchg_ptr((intptr_t)exchange_value, (volatile intptr_t*)dest, (intptr_t)compare_value);
-}
--- ./hotspot/src/os_cpu/bsd_sparc/vm/bsd_sparc.ad	2010-03-27 11:09:10.000000000 -0700
+++ ./hotspot/src/os_cpu/bsd_sparc/vm/bsd_sparc.ad	1969-12-31 16:00:00.000000000 -0800
@@ -1,27 +0,0 @@
-//
-// Copyright 1999-2008 Sun Microsystems, Inc.  All Rights Reserved.
-// DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
-//
-// This code is free software; you can redistribute it and/or modify it
-// under the terms of the GNU General Public License version 2 only, as
-// published by the Free Software Foundation.
-//
-// This code is distributed in the hope that it will be useful, but WITHOUT
-// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-// version 2 for more details (a copy is included in the LICENSE file that
-// accompanied this code).
-//
-// You should have received a copy of the GNU General Public License version
-// 2 along with this work; if not, write to the Free Software Foundation,
-// Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
-//
-// Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
-// CA 95054 USA or visit www.sun.com if you need additional information or
-// have any questions.
-//
-
-//
-//
-
-// SPARC Bsd Architecture Description File
--- ./hotspot/src/os_cpu/bsd_sparc/vm/bsd_sparc.s	2010-03-27 11:09:10.000000000 -0700
+++ ./hotspot/src/os_cpu/bsd_sparc/vm/bsd_sparc.s	1969-12-31 16:00:00.000000000 -0800
@@ -1,105 +0,0 @@
-#
-# Copyright 2005-2008 Sun Microsystems, Inc.  All Rights Reserved.
-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
-#
-# This code is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License version 2 only, as
-# published by the Free Software Foundation.
-#
-# This code is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# version 2 for more details (a copy is included in the LICENSE file that
-# accompanied this code).
-#
-# You should have received a copy of the GNU General Public License version
-# 2 along with this work; if not, write to the Free Software Foundation,
-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
-#
-# Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
-# CA 95054 USA or visit www.sun.com if you need additional information or
-# have any questions.
-#
-
-    # Prototype: int SafeFetch32 (int * adr, int ErrValue)
-    # The "ld" at Fetch32 is potentially faulting instruction.
-    # If the instruction traps the trap handler will arrange
-    # for control to resume at Fetch32Resume.  
-    # By convention with the trap handler we ensure there is a non-CTI
-    # instruction in the trap shadow.  
-        
-
-    .globl  SafeFetch32, Fetch32PFI, Fetch32Resume
-    .globl  SafeFetchN
-    .align  32
-    .type    SafeFetch32,@function
-SafeFetch32:        
-    mov     %o0, %g1
-    mov     %o1, %o0
-Fetch32PFI:
-    # <-- Potentially faulting instruction
-    ld      [%g1], %o0         
-Fetch32Resume:
-    nop
-    retl
-    nop
-
-    .globl  SafeFetchN, FetchNPFI, FetchNResume
-    .type    SafeFetchN,@function
-    .align  32
-SafeFetchN:
-    mov     %o0, %g1
-    mov     %o1, %o0
-FetchNPFI:
-    ldn     [%g1], %o0
-FetchNResume:
-    nop
-    retl
-    nop
-
-    # Possibilities:
-    # -- membar
-    # -- CAS (SP + BIAS, G0, G0)
-    # -- wr %g0, %asi
-
-    .globl SpinPause
-    .type   SpinPause,@function
-    .align  32
-SpinPause:      
-    retl
-    mov %g0, %o0
-
-   .globl _Copy_conjoint_jlongs_atomic
-   .type   _Copy_conjoint_jlongs_atomic,@function
-_Copy_conjoint_jlongs_atomic:
-        cmp     %o0, %o1
-	bleu    4f
-	sll     %o2, 3, %o4
-        ba      2f
-   1:
-	subcc   %o4, 8, %o4
-	std     %o2, [%o1]
-	add     %o0, 8, %o0
-	add     %o1, 8, %o1
-   2:
-	bge,a   1b
-	ldd     [%o0], %o2
-	ba      5f
-        nop
-   3:
-	std     %o2, [%o1+%o4]
-   4:
-	subcc   %o4, 8, %o4
-	bge,a   3b
-	ldd     [%o0+%o4], %o2
-   5:      
-	retl
-	nop
-
-
-    .globl _flush_reg_windows
-    .align 32
- _flush_reg_windows:
-        ta 0x03
-        retl
-        mov     %fp, %o0
--- ./hotspot/src/os_cpu/bsd_sparc/vm/globals_bsd_sparc.hpp	2010-03-27 11:09:10.000000000 -0700
+++ ./hotspot/src/os_cpu/bsd_sparc/vm/globals_bsd_sparc.hpp	1969-12-31 16:00:00.000000000 -0800
@@ -1,36 +0,0 @@
-/*
- * Copyright 2000-2009 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- *
- */
-
-//
-// Sets the default values for platform dependent flags used by the
-// runtime system.  (see globals.hpp)
-//
-
-define_pd_global(uintx, JVMInvokeMethodSlack,    12288);
-define_pd_global(intx, CompilerThreadStackSize,  0);
-
-// Only used on 64 bit platforms
-define_pd_global(uintx, HeapBaseMinAddress,      4*G);
-// Only used on 64 bit Windows platforms
-define_pd_global(bool, UseVectoredExceptions, false);
--- ./hotspot/src/os_cpu/bsd_sparc/vm/orderAccess_bsd_sparc.inline.hpp	2010-03-27 11:09:10.000000000 -0700
+++ ./hotspot/src/os_cpu/bsd_sparc/vm/orderAccess_bsd_sparc.inline.hpp	1969-12-31 16:00:00.000000000 -0800
@@ -1,102 +0,0 @@
-/*
- * Copyright 2003-2008 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- *
- */
-
-// Implementation of class OrderAccess.
-
-// Assume TSO.
-
-inline void OrderAccess::loadload()   { acquire(); }
-inline void OrderAccess::storestore() { release(); }
-inline void OrderAccess::loadstore()  { acquire(); }
-inline void OrderAccess::storeload()  { fence(); }
-
-inline void OrderAccess::acquire() {
-  __asm__ volatile ("nop" : : :);
-}
-
-inline void OrderAccess::release() {
-  jint* dummy = (jint*)&dummy;
-  __asm__ volatile("stw %%g0, [%0]" : : "r" (dummy) : "memory");
-}
-
-inline void OrderAccess::fence() {
-  __asm__ volatile ("membar  #StoreLoad" : : :);
-}
-
-inline jbyte    OrderAccess::load_acquire(volatile jbyte*   p) { return *p; }
-inline jshort   OrderAccess::load_acquire(volatile jshort*  p) { return *p; }
-inline jint     OrderAccess::load_acquire(volatile jint*    p) { return *p; }
-inline jlong    OrderAccess::load_acquire(volatile jlong*   p) { return *p; }
-inline jubyte   OrderAccess::load_acquire(volatile jubyte*  p) { return *p; }
-inline jushort  OrderAccess::load_acquire(volatile jushort* p) { return *p; }
-inline juint    OrderAccess::load_acquire(volatile juint*   p) { return *p; }
-inline julong   OrderAccess::load_acquire(volatile julong*  p) { return *p; }
-inline jfloat   OrderAccess::load_acquire(volatile jfloat*  p) { return *p; }
-inline jdouble  OrderAccess::load_acquire(volatile jdouble* p) { return *p; }
-
-inline intptr_t OrderAccess::load_ptr_acquire(volatile intptr_t*   p) { return *p; }
-inline void*    OrderAccess::load_ptr_acquire(volatile void*       p) { return *(void* volatile *)p; }
-inline void*    OrderAccess::load_ptr_acquire(const volatile void* p) { return *(void* const volatile *)p; }
-
-inline void     OrderAccess::release_store(volatile jbyte*   p, jbyte   v) { *p = v; }
-inline void     OrderAccess::release_store(volatile jshort*  p, jshort  v) { *p = v; }
-inline void     OrderAccess::release_store(volatile jint*    p, jint    v) { *p = v; }
-inline void     OrderAccess::release_store(volatile jlong*   p, jlong   v) { *p = v; }
-inline void     OrderAccess::release_store(volatile jubyte*  p, jubyte  v) { *p = v; }
-inline void     OrderAccess::release_store(volatile jushort* p, jushort v) { *p = v; }
-inline void     OrderAccess::release_store(volatile juint*   p, juint   v) { *p = v; }
-inline void     OrderAccess::release_store(volatile julong*  p, julong  v) { *p = v; }
-inline void     OrderAccess::release_store(volatile jfloat*  p, jfloat  v) { *p = v; }
-inline void     OrderAccess::release_store(volatile jdouble* p, jdouble v) { *p = v; }
-
-inline void     OrderAccess::release_store_ptr(volatile intptr_t* p, intptr_t v) { *p = v; }
-inline void     OrderAccess::release_store_ptr(volatile void*     p, void*    v) { *(void* volatile *)p = v; }
-
-inline void     OrderAccess::store_fence(jbyte*   p, jbyte   v) { *p = v; fence(); }
-inline void     OrderAccess::store_fence(jshort*  p, jshort  v) { *p = v; fence(); }
-inline void     OrderAccess::store_fence(jint*    p, jint    v) { *p = v; fence(); }
-inline void     OrderAccess::store_fence(jlong*   p, jlong   v) { *p = v; fence(); }
-inline void     OrderAccess::store_fence(jubyte*  p, jubyte  v) { *p = v; fence(); }
-inline void     OrderAccess::store_fence(jushort* p, jushort v) { *p = v; fence(); }
-inline void     OrderAccess::store_fence(juint*   p, juint   v) { *p = v; fence(); }
-inline void     OrderAccess::store_fence(julong*  p, julong  v) { *p = v; fence(); }
-inline void     OrderAccess::store_fence(jfloat*  p, jfloat  v) { *p = v; fence(); }
-inline void     OrderAccess::store_fence(jdouble* p, jdouble v) { *p = v; fence(); }
-
-inline void     OrderAccess::store_ptr_fence(intptr_t* p, intptr_t v) { *p = v; fence(); }
-inline void     OrderAccess::store_ptr_fence(void**    p, void*    v) { *p = v; fence(); }
-
-inline void     OrderAccess::release_store_fence(volatile jbyte*   p, jbyte   v) { *p = v; fence(); }
-inline void     OrderAccess::release_store_fence(volatile jshort*  p, jshort  v) { *p = v; fence(); }
-inline void     OrderAccess::release_store_fence(volatile jint*    p, jint    v) { *p = v; fence(); }
-inline void     OrderAccess::release_store_fence(volatile jlong*   p, jlong   v) { *p = v; fence(); }
-inline void     OrderAccess::release_store_fence(volatile jubyte*  p, jubyte  v) { *p = v; fence(); }
-inline void     OrderAccess::release_store_fence(volatile jushort* p, jushort v) { *p = v; fence(); }
-inline void     OrderAccess::release_store_fence(volatile juint*   p, juint   v) { *p = v; fence(); }
-inline void     OrderAccess::release_store_fence(volatile julong*  p, julong  v) { *p = v; fence(); }
-inline void     OrderAccess::release_store_fence(volatile jfloat*  p, jfloat  v) { *p = v; fence(); }
-inline void     OrderAccess::release_store_fence(volatile jdouble* p, jdouble v) { *p = v; fence(); }
-
-inline void     OrderAccess::release_store_ptr_fence(volatile intptr_t* p, intptr_t v) { *p = v; fence(); }
-inline void     OrderAccess::release_store_ptr_fence(volatile void*     p, void*    v) { *(void* volatile *)p = v; fence(); }
--- ./hotspot/src/os_cpu/bsd_sparc/vm/os_bsd_sparc.cpp	2010-03-27 11:09:10.000000000 -0700
+++ ./hotspot/src/os_cpu/bsd_sparc/vm/os_bsd_sparc.cpp	1969-12-31 16:00:00.000000000 -0800
@@ -1,648 +0,0 @@
-/*
- * Copyright 1999-2008 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- *
- */
-
-// do not include  precompiled  header file
-
-#include "incls/_os_bsd_sparc.cpp.incl"
-
-// Bsd/Sparc has rather obscure naming of registers in sigcontext
-// different between 32 and 64 bits
-#ifdef _LP64
-#define SIG_PC(x) ((x)->sigc_regs.tpc)
-#define SIG_NPC(x) ((x)->sigc_regs.tnpc)
-#define SIG_REGS(x) ((x)->sigc_regs)
-#else
-#define SIG_PC(x) ((x)->si_regs.pc)
-#define SIG_NPC(x) ((x)->si_regs.npc)
-#define SIG_REGS(x) ((x)->si_regs)
-#endif
-
-// those are to reference registers in sigcontext
-enum {
-  CON_G0 = 0,
-  CON_G1,
-  CON_G2,
-  CON_G3,
-  CON_G4,
-  CON_G5,
-  CON_G6,
-  CON_G7,
-  CON_O0,
-  CON_O1,
-  CON_O2,
-  CON_O3,
-  CON_O4,
-  CON_O5,
-  CON_O6,
-  CON_O7,
-};
-
-static inline void set_cont_address(sigcontext* ctx, address addr) {
-  SIG_PC(ctx)  = (intptr_t)addr;
-  SIG_NPC(ctx) = (intptr_t)(addr+4);
-}
-
-// For Forte Analyzer AsyncGetCallTrace profiling support - thread is
-// currently interrupted by SIGPROF.
-// os::Solaris::fetch_frame_from_ucontext() tries to skip nested
-// signal frames. Currently we don't do that on Bsd, so it's the
-// same as os::fetch_frame_from_context().
-ExtendedPC os::Bsd::fetch_frame_from_ucontext(Thread* thread,
-                                                ucontext_t* uc,
-                                                intptr_t** ret_sp,
-                                                intptr_t** ret_fp) {
-  assert(thread != NULL, "just checking");
-  assert(ret_sp != NULL, "just checking");
-  assert(ret_fp != NULL, "just checking");
-
-  return os::fetch_frame_from_context(uc, ret_sp, ret_fp);
-}
-
-ExtendedPC os::fetch_frame_from_context(void* ucVoid,
-                                        intptr_t** ret_sp,
-                                        intptr_t** ret_fp) {
-  ucontext_t* uc = (ucontext_t*) ucVoid;
-  ExtendedPC  epc;
-
-  if (uc != NULL) {
-    epc = ExtendedPC(os::Bsd::ucontext_get_pc(uc));
-    if (ret_sp) {
-      *ret_sp = os::Bsd::ucontext_get_sp(uc);
-    }
-    if (ret_fp) {
-      *ret_fp = os::Bsd::ucontext_get_fp(uc);
-    }
-  } else {
-    // construct empty ExtendedPC for return value checking
-    epc = ExtendedPC(NULL);
-    if (ret_sp) {
-      *ret_sp = (intptr_t*) NULL;
-    }
-    if (ret_fp) {
-      *ret_fp = (intptr_t*) NULL;
-    }
-  }
-
-  return epc;
-}
-
-frame os::fetch_frame_from_context(void* ucVoid) {
-  intptr_t* sp;
-  intptr_t* fp;
-  ExtendedPC epc = fetch_frame_from_context(ucVoid, &sp, &fp);
-  return frame(sp, fp, epc.pc());
-}
-
-frame os::get_sender_for_C_frame(frame* fr) {
-  return frame(fr->sender_sp(), fr->link(), fr->sender_pc());
-}
-
-frame os::current_frame() {
-  fprintf(stderr, "current_frame()");
-
-  intptr_t* sp = StubRoutines::Sparc::flush_callers_register_windows_func()();
-  frame myframe(sp, frame::unpatchable,
-                CAST_FROM_FN_PTR(address, os::current_frame));
-  if (os::is_first_C_frame(&myframe)) {
-    // stack is not walkable
-    return frame(NULL, frame::unpatchable, NULL);
-  } else {
-    return os::get_sender_for_C_frame(&myframe);
-  }
-}
-
-address os::current_stack_pointer() {
-  register void *sp __asm__ ("sp");
-  return (address)sp;
-}
-
-static void current_stack_region(address* bottom, size_t* size) {
-  if (os::Bsd::is_initial_thread()) {
-    // initial thread needs special handling because pthread_getattr_np()
-    // may return bogus value.
-    *bottom = os::Bsd::initial_thread_stack_bottom();
-    *size = os::Bsd::initial_thread_stack_size();
-  } else {
-    pthread_attr_t attr;
-
-    int rslt = pthread_getattr_np(pthread_self(), &attr);
-
-    // JVM needs to know exact stack location, abort if it fails
-    if (rslt != 0) {
-      if (rslt == ENOMEM) {
-        vm_exit_out_of_memory(0, "pthread_getattr_np");
-      } else {
-        fatal1("pthread_getattr_np failed with errno = %d", rslt);
-      }
-    }
-
-    if (pthread_attr_getstack(&attr, (void**)bottom, size) != 0) {
-      fatal("Can not locate current stack attributes!");
-    }
-
-    pthread_attr_destroy(&attr);
-  }
-  assert(os::current_stack_pointer() >= *bottom &&
-         os::current_stack_pointer() < *bottom + *size, "just checking");
-}
-
-address os::current_stack_base() {
-  address bottom;
-  size_t size;
-  current_stack_region(&bottom, &size);
-  return bottom + size;
-}
-
-size_t os::current_stack_size() {
-  // stack size includes normal stack and HotSpot guard pages
-  address bottom;
-  size_t size;
-  current_stack_region(&bottom, &size);
-  return size;
-}
-
-char* os::non_memory_address_word() {
-  // Must never look like an address returned by reserve_memory,
-  // even in its subfields (as defined by the CPU immediate fields,
-  // if the CPU splits constants across multiple instructions).
-  // On SPARC, 0 != %hi(any real address), because there is no
-  // allocation in the first 1Kb of the virtual address space.
-  return (char*) 0;
-}
-
-void os::initialize_thread() {}
-
-void os::print_context(outputStream *st, void *context) {
-  if (context == NULL) return;
-
-  ucontext_t* uc = (ucontext_t*)context;
-  sigcontext* sc = (sigcontext*)context;
-  st->print_cr("Registers:");
-
-  st->print_cr(" O0=" INTPTR_FORMAT " O1=" INTPTR_FORMAT
-               " O2=" INTPTR_FORMAT " O3=" INTPTR_FORMAT,
-               SIG_REGS(sc).u_regs[CON_O0],
-               SIG_REGS(sc).u_regs[CON_O1],
-               SIG_REGS(sc).u_regs[CON_O2],
-               SIG_REGS(sc).u_regs[CON_O3]);
-  st->print_cr(" O4=" INTPTR_FORMAT " O5=" INTPTR_FORMAT
-               " O6=" INTPTR_FORMAT " O7=" INTPTR_FORMAT,
-               SIG_REGS(sc).u_regs[CON_O4],
-               SIG_REGS(sc).u_regs[CON_O5],
-               SIG_REGS(sc).u_regs[CON_O6],
-               SIG_REGS(sc).u_regs[CON_O7]);
-
-  st->print_cr(" G1=" INTPTR_FORMAT " G2=" INTPTR_FORMAT
-               " G3=" INTPTR_FORMAT " G4=" INTPTR_FORMAT,
-               SIG_REGS(sc).u_regs[CON_G1],
-               SIG_REGS(sc).u_regs[CON_G2],
-               SIG_REGS(sc).u_regs[CON_G3],
-               SIG_REGS(sc).u_regs[CON_G4]);
-  st->print_cr(" G5=" INTPTR_FORMAT " G6=" INTPTR_FORMAT
-               " G7=" INTPTR_FORMAT " Y=" INTPTR_FORMAT,
-               SIG_REGS(sc).u_regs[CON_G5],
-               SIG_REGS(sc).u_regs[CON_G6],
-               SIG_REGS(sc).u_regs[CON_G7],
-               SIG_REGS(sc).y);
-
-  st->print_cr(" PC=" INTPTR_FORMAT " nPC=" INTPTR_FORMAT,
-               SIG_PC(sc),
-               SIG_NPC(sc));
-  st->cr();
-  st->cr();
-
-  intptr_t *sp = (intptr_t *)os::Bsd::ucontext_get_sp(uc);
-  st->print_cr("Top of Stack: (sp=" PTR_FORMAT ")", sp);
-  print_hex_dump(st, (address)sp, (address)(sp + 32), sizeof(intptr_t));
-  st->cr();
-
-  // Note: it may be unsafe to inspect memory near pc. For example, pc may
-  // point to garbage if entry point in an nmethod is corrupted. Leave
-  // this at the end, and hope for the best.
-  address pc = os::Bsd::ucontext_get_pc(uc);
-  st->print_cr("Instructions: (pc=" PTR_FORMAT ")", pc);
-  print_hex_dump(st, pc - 16, pc + 16, sizeof(char));
-}
-
-
-address os::Bsd::ucontext_get_pc(ucontext_t* uc) {
-  return (address) SIG_PC((sigcontext*)uc);
-}
-
-intptr_t* os::Bsd::ucontext_get_sp(ucontext_t *uc) {
-  return (intptr_t*)
-    ((intptr_t)SIG_REGS((sigcontext*)uc).u_regs[CON_O6] + STACK_BIAS);
-}
-
-// not used on Sparc
-intptr_t* os::Bsd::ucontext_get_fp(ucontext_t *uc) {
-  ShouldNotReachHere();
-  return NULL;
-}
-
-// Utility functions
-
-extern "C" void Fetch32PFI();
-extern "C" void Fetch32Resume();
-extern "C" void FetchNPFI();
-extern "C" void FetchNResume();
-
-inline static bool checkPrefetch(sigcontext* uc, address pc) {
-  if (pc == (address) Fetch32PFI) {
-    set_cont_address(uc, address(Fetch32Resume));
-    return true;
-  }
-  if (pc == (address) FetchNPFI) {
-    set_cont_address(uc, address(FetchNResume));
-    return true;
-  }
-  return false;
-}
-
-inline static bool checkOverflow(sigcontext* uc,
-                                 address pc,
-                                 address addr,
-                                 JavaThread* thread,
-                                 address* stub) {
-  // check if fault address is within thread stack
-  if (addr < thread->stack_base() &&
-      addr >= thread->stack_base() - thread->stack_size()) {
-    // stack overflow
-    if (thread->in_stack_yellow_zone(addr)) {
-      thread->disable_stack_yellow_zone();
-      if (thread->thread_state() == _thread_in_Java) {
-        // Throw a stack overflow exception.  Guard pages will be reenabled
-        // while unwinding the stack.
-        *stub =
-          SharedRuntime::continuation_for_implicit_exception(thread,
-                                                             pc,
-                                                             SharedRuntime::STACK_OVERFLOW);
-      } else {
-        // Thread was in the vm or native code.  Return and try to finish.
-        return true;
-      }
-    } else if (thread->in_stack_red_zone(addr)) {
-      // Fatal red zone violation.  Disable the guard pages and fall through
-      // to handle_unexpected_exception way down below.
-      thread->disable_stack_red_zone();
-      tty->print_raw_cr("An irrecoverable stack overflow has occurred.");
-    } else {
-      // Accessing stack address below sp may cause SEGV if current
-      // thread has MAP_GROWSDOWN stack. This should only happen when
-      // current thread was created by user code with MAP_GROWSDOWN flag
-      // and then attached to VM. See notes in os_bsd.cpp.
-      if (thread->osthread()->expanding_stack() == 0) {
-        thread->osthread()->set_expanding_stack();
-        if (os::Bsd::manually_expand_stack(thread, addr)) {
-          thread->osthread()->clear_expanding_stack();
-          return true;
-        }
-        thread->osthread()->clear_expanding_stack();
-      } else {
-        fatal("recursive segv. expanding stack.");
-      }
-    }
-  }
-  return false;
-}
-
-inline static bool checkPollingPage(address pc, address fault, address* stub) {
-  if (fault == os::get_polling_page()) {
-    *stub = SharedRuntime::get_poll_stub(pc);
-    return true;
-  }
-  return false;
-}
-
-inline static bool checkByteBuffer(address pc, address* stub) {
-  // BugId 4454115: A read from a MappedByteBuffer can fault
-  // here if the underlying file has been truncated.
-  // Do not crash the VM in such a case.
-  CodeBlob* cb = CodeCache::find_blob_unsafe(pc);
-  nmethod* nm = cb->is_nmethod() ? (nmethod*)cb : NULL;
-  if (nm != NULL && nm->has_unsafe_access()) {
-    *stub = StubRoutines::handler_for_unsafe_access();
-    return true;
-  }
-  return false;
-}
-
-inline static bool checkVerifyOops(address pc, address fault, address* stub) {
-  if (pc >= MacroAssembler::_verify_oop_implicit_branch[0]
-      && pc <  MacroAssembler::_verify_oop_implicit_branch[1] ) {
-    *stub     =  MacroAssembler::_verify_oop_implicit_branch[2];
-    warning("fixed up memory fault in +VerifyOops at address "
-            INTPTR_FORMAT, fault);
-    return true;
-  }
-  return false;
-}
-
-inline static bool checkFPFault(address pc, int code,
-                                JavaThread* thread, address* stub) {
-  if (code == FPE_INTDIV || code == FPE_FLTDIV) {
-    *stub =
-      SharedRuntime::
-      continuation_for_implicit_exception(thread,
-                                          pc,
-                                          SharedRuntime::IMPLICIT_DIVIDE_BY_ZERO);
-    return true;
-  }
-  return false;
-}
-
-inline static bool checkNullPointer(address pc, intptr_t fault,
-                                    JavaThread* thread, address* stub) {
-  if (!MacroAssembler::needs_explicit_null_check(fault)) {
-    // Determination of interpreter/vtable stub/compiled code null
-    // exception
-    *stub =
-      SharedRuntime::
-      continuation_for_implicit_exception(thread, pc,
-                                          SharedRuntime::IMPLICIT_NULL);
-    return true;
-  }
-  return false;
-}
-
-inline static bool checkFastJNIAccess(address pc, address* stub) {
-  address addr = JNI_FastGetField::find_slowcase_pc(pc);
-  if (addr != (address)-1) {
-    *stub = addr;
-    return true;
-  }
-  return false;
-}
-
-inline static bool checkSerializePage(JavaThread* thread, address addr) {
-  return os::is_memory_serialize_page(thread, addr);
-}
-
-inline static bool checkZombie(sigcontext* uc, address* pc, address* stub) {
-  if (nativeInstruction_at(*pc)->is_zombie()) {
-    // zombie method (ld [%g0],%o7 instruction)
-    *stub = SharedRuntime::get_handle_wrong_method_stub();
-
-    // At the stub it needs to look like a call from the caller of this
-    // method (not a call from the segv site).
-    *pc = (address)SIG_REGS(uc).u_regs[CON_O7];
-    return true;
-  }
-  return false;
-}
-
-inline static bool checkICMiss(sigcontext* uc, address* pc, address* stub) {
-#ifdef COMPILER2
-  if (nativeInstruction_at(*pc)->is_ic_miss_trap()) {
-#ifdef ASSERT
-#ifdef TIERED
-    CodeBlob* cb = CodeCache::find_blob_unsafe(pc);
-    assert(cb->is_compiled_by_c2(), "Wrong compiler");
-#endif // TIERED
-#endif // ASSERT
-    // Inline cache missed and user trap "Tne G0+ST_RESERVED_FOR_USER_0+2" taken.
-    *stub = SharedRuntime::get_ic_miss_stub();
-    // At the stub it needs to look like a call from the caller of this
-    // method (not a call from the segv site).
-    *pc = (address)SIG_REGS(uc).u_regs[CON_O7];
-    return true;
-  }
-#endif  // COMPILER2
-  return false;
-}
-
-extern "C" int
-JVM_handle_bsd_signal(int sig,
-                        siginfo_t* info,
-                        void* ucVoid,
-                        int abort_if_unrecognized) {
-  // in fact this isn't ucontext_t* at all, but struct sigcontext*
-  // but Bsd porting layer uses ucontext_t, so to minimize code change
-  // we cast as needed
-  ucontext_t* ucFake = (ucontext_t*) ucVoid;
-  sigcontext* uc = (sigcontext*)ucVoid;
-
-  Thread* t = ThreadLocalStorage::get_thread_slow();
-
-  SignalHandlerMark shm(t);
-
-  // Note: it's not uncommon that JNI code uses signal/sigset to install
-  // then restore certain signal handler (e.g. to temporarily block SIGPIPE,
-  // or have a SIGILL handler when detecting CPU type). When that happens,
-  // JVM_handle_bsd_signal() might be invoked with junk info/ucVoid. To
-  // avoid unnecessary crash when libjsig is not preloaded, try handle signals
-  // that do not require siginfo/ucontext first.
-
-  if (sig == SIGPIPE || sig == SIGXFSZ) {
-    // allow chained handler to go first
-    if (os::Bsd::chained_handler(sig, info, ucVoid)) {
-      return true;
-    } else {
-      if (PrintMiscellaneous && (WizardMode || Verbose)) {
-        char buf[64];
-        warning("Ignoring %s - see bugs 4229104 or 646499219",
-                os::exception_name(sig, buf, sizeof(buf)));
-      }
-      return true;
-    }
-  }
-
-  JavaThread* thread = NULL;
-  VMThread* vmthread = NULL;
-  if (os::Bsd::signal_handlers_are_installed) {
-    if (t != NULL ){
-      if(t->is_Java_thread()) {
-        thread = (JavaThread*)t;
-      }
-      else if(t->is_VM_thread()){
-        vmthread = (VMThread *)t;
-      }
-    }
-  }
-
-  // decide if this trap can be handled by a stub
-  address stub = NULL;
-  address pc = NULL;
-  address npc = NULL;
-
-  //%note os_trap_1
-  if (info != NULL && uc != NULL && thread != NULL) {
-    pc = address(SIG_PC(uc));
-    npc = address(SIG_NPC(uc));
-
-    // Check to see if we caught the safepoint code in the
-    // process of write protecting the memory serialization page.
-    // It write enables the page immediately after protecting it
-    // so we can just return to retry the write.
-    if ((sig == SIGSEGV) && checkSerializePage(thread, (address)info->si_addr)) {
-      // Block current thread until the memory serialize page permission restored.
-      os::block_on_serialize_page_trap();
-      return 1;
-    }
-
-    if (checkPrefetch(uc, pc)) {
-      return 1;
-    }
-
-    // Handle ALL stack overflow variations here
-    if (sig == SIGSEGV) {
-      if (checkOverflow(uc, pc, (address)info->si_addr, thread, &stub)) {
-        return 1;
-      }
-    }
-
-    if (sig == SIGBUS &&
-        thread->thread_state() == _thread_in_vm &&
-        thread->doing_unsafe_access()) {
-      stub = StubRoutines::handler_for_unsafe_access();
-    }
-
-    if (thread->thread_state() == _thread_in_Java) {
-      do {
-        // Java thread running in Java code => find exception handler if any
-        // a fault inside compiled code, the interpreter, or a stub
-
-        if ((sig == SIGSEGV) && checkPollingPage(pc, (address)info->si_addr, &stub)) {
-          break;
-        }
-
-        if ((sig == SIGBUS) && checkByteBuffer(pc, &stub)) {
-          break;
-        }
-
-        if ((sig == SIGSEGV || sig == SIGBUS) &&
-            checkVerifyOops(pc, (address)info->si_addr, &stub)) {
-          break;
-        }
-
-        if ((sig == SIGSEGV) && checkZombie(uc, &pc, &stub)) {
-          break;
-        }
-
-        if ((sig == SIGILL) && checkICMiss(uc, &pc, &stub)) {
-          break;
-        }
-
-        if ((sig == SIGFPE) && checkFPFault(pc, info->si_code, thread, &stub)) {
-          break;
-        }
-
-        if ((sig == SIGSEGV) &&
-            checkNullPointer(pc, (intptr_t)info->si_addr, thread, &stub)) {
-          break;
-        }
-      } while (0);
-
-      // jni_fast_Get<Primitive>Field can trap at certain pc's if a GC kicks in
-      // and the heap gets shrunk before the field access.
-      if ((sig == SIGSEGV) || (sig == SIGBUS)) {
-        checkFastJNIAccess(pc, &stub);
-      }
-    }
-
-    if (stub != NULL) {
-      // save all thread context in case we need to restore it
-      thread->set_saved_exception_pc(pc);
-      thread->set_saved_exception_npc(npc);
-      set_cont_address(uc, stub);
-      return true;
-    }
-  }
-
-  // signal-chaining
-  if (os::Bsd::chained_handler(sig, info, ucVoid)) {
-    return true;
-  }
-
-  if (!abort_if_unrecognized) {
-    // caller wants another chance, so give it to him
-    return false;
-  }
-
-  if (pc == NULL && uc != NULL) {
-    pc = os::Bsd::ucontext_get_pc((ucontext_t*)uc);
-  }
-
-  // unmask current signal
-  sigset_t newset;
-  sigemptyset(&newset);
-  sigaddset(&newset, sig);
-  sigprocmask(SIG_UNBLOCK, &newset, NULL);
-
-  VMError err(t, sig, pc, info, ucVoid);
-  err.report_and_die();
-
-  ShouldNotReachHere();
-}
-
-void os::Bsd::init_thread_fpu_state(void) {
-  // Nothing to do
-}
-
-int os::Bsd::get_fpu_control_word() {
-  return 0;
-}
-
-void os::Bsd::set_fpu_control_word(int fpu) {
-  // nothing
-}
-
-bool os::is_allocatable(size_t bytes) {
-#ifdef _LP64
-  return true;
-#else
-  if (bytes < 2 * G) {
-    return true;
-  }
-
-  char* addr = reserve_memory(bytes, NULL);
-
-  if (addr != NULL) {
-    release_memory(addr, bytes);
-  }
-
-  return addr != NULL;
-#endif // _LP64
-}
-
-///////////////////////////////////////////////////////////////////////////////
-// thread stack
-
-size_t os::Bsd::min_stack_allowed  = 128 * K;
-
-// pthread on Ubuntu is always in floating stack mode
-bool os::Bsd::supports_variable_stack_size() {  return true; }
-
-// return default stack size for thr_type
-size_t os::Bsd::default_stack_size(os::ThreadType thr_type) {
-  // default stack size (compiler thread needs larger stack)
-  size_t s = (thr_type == os::compiler_thread ? 4 * M : 1 * M);
-  return s;
-}
-
-size_t os::Bsd::default_guard_size(os::ThreadType thr_type) {
-  // Creating guard page is very expensive. Java thread has HotSpot
-  // guard page, only enable glibc guard page for non-Java threads.
-  return (thr_type == java_thread ? 0 : page_size());
-}
--- ./hotspot/src/os_cpu/bsd_sparc/vm/os_bsd_sparc.hpp	2010-03-27 11:09:10.000000000 -0700
+++ ./hotspot/src/os_cpu/bsd_sparc/vm/os_bsd_sparc.hpp	1969-12-31 16:00:00.000000000 -0800
@@ -1,44 +0,0 @@
-/*
- * Copyright 1999-2009 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- *
- */
-
-  //
-  // NOTE: we are back in class os here, not Bsd
-  //
-  static jint  (*atomic_xchg_func)        (jint,  volatile jint*);
-  static jint  (*atomic_cmpxchg_func)     (jint,  volatile jint*,  jint);
-  static jlong (*atomic_cmpxchg_long_func)(jlong, volatile jlong*, jlong);
-  static jint  (*atomic_add_func)         (jint,  volatile jint*);
-
-  static jint  atomic_xchg_bootstrap        (jint,  volatile jint*);
-  static jint  atomic_cmpxchg_bootstrap     (jint,  volatile jint*,  jint);
-  static jlong atomic_cmpxchg_long_bootstrap(jlong, volatile jlong*, jlong);
-  static jint  atomic_add_bootstrap         (jint,  volatile jint*);
-
-  static void setup_fpu() {}
-
-  static bool is_allocatable(size_t bytes);
-
-  // Used to register dynamic code cache area with the OS
-  // Note: Currently only used in 64 bit Windows implementations
-  static bool register_code_area(char *low, char *high) { return true; }
--- ./hotspot/src/os_cpu/bsd_sparc/vm/prefetch_bsd_sparc.inline.hpp	2010-03-27 11:09:10.000000000 -0700
+++ ./hotspot/src/os_cpu/bsd_sparc/vm/prefetch_bsd_sparc.inline.hpp	1969-12-31 16:00:00.000000000 -0800
@@ -1,40 +0,0 @@
-/*
- * Copyright 2003-2008 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- *
- */
-
-#if defined(COMPILER2) || defined(_LP64)
-
-inline void Prefetch::read(void *loc, intx interval) {
-  __asm__ volatile("prefetch [%0+%1], 0" : : "r" (loc), "r" (interval) : "memory" );
-}
-
-inline void Prefetch::write(void *loc, intx interval) {
-  __asm__ volatile("prefetch [%0+%1], 2" : : "r" (loc), "r" (interval) : "memory" );
-}
-
-#else
-
-inline void Prefetch::read (void *loc, intx interval) {}
-inline void Prefetch::write(void *loc, intx interval) {}
-
-#endif
--- ./hotspot/src/os_cpu/bsd_sparc/vm/threadLS_bsd_sparc.cpp	2010-03-27 11:09:10.000000000 -0700
+++ ./hotspot/src/os_cpu/bsd_sparc/vm/threadLS_bsd_sparc.cpp	1969-12-31 16:00:00.000000000 -0800
@@ -1,37 +0,0 @@
-/*
- * Copyright 1998-2008 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- *
- */
-
-#include "incls/_precompiled.incl"
-#include "incls/_threadLS_bsd_sparc.cpp.incl"
-
-void ThreadLocalStorage::generate_code_for_get_thread() {
-}
-
-void ThreadLocalStorage::pd_init() {
-   // Nothing to do
-}
-
-void ThreadLocalStorage::pd_set_thread(Thread* thread) {
-  os::thread_local_storage_at_put(ThreadLocalStorage::thread_index(), thread);
-}
--- ./hotspot/src/os_cpu/bsd_sparc/vm/threadLS_bsd_sparc.hpp	2010-03-27 11:09:10.000000000 -0700
+++ ./hotspot/src/os_cpu/bsd_sparc/vm/threadLS_bsd_sparc.hpp	1969-12-31 16:00:00.000000000 -0800
@@ -1,28 +0,0 @@
-/*
- * Copyright 1998-2008 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- *
- */
-
-public:
-  static Thread* thread() {
-    return (Thread*) os::thread_local_storage_at(thread_index());
-  }
--- ./hotspot/src/os_cpu/bsd_sparc/vm/thread_bsd_sparc.cpp	2010-03-27 11:09:10.000000000 -0700
+++ ./hotspot/src/os_cpu/bsd_sparc/vm/thread_bsd_sparc.cpp	1969-12-31 16:00:00.000000000 -0800
@@ -1,107 +0,0 @@
-/*
- * Copyright 2003-2008 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- *
- */
-
-#include "incls/_precompiled.incl"
-#include "incls/_thread_bsd_sparc.cpp.incl"
-
-// For Forte Analyzer AsyncGetCallTrace profiling support - thread is
-// currently interrupted by SIGPROF
-bool JavaThread::pd_get_top_frame_for_signal_handler(frame* fr_addr,
-                                                     void* ucontext,
-                                                     bool isInJava) {
-  assert(Thread::current() == this, "caller must be current thread");
-  assert(this->is_Java_thread(), "must be JavaThread");
-
-  JavaThread* jt = (JavaThread *)this;
-
-  if (!isInJava) {
-    // make_walkable flushes register windows and grabs last_Java_pc
-    // which can not be done if the ucontext sp matches last_Java_sp
-    // stack walking utilities assume last_Java_pc set if marked flushed
-    jt->frame_anchor()->make_walkable(jt);
-  }
-
-  // If we have a walkable last_Java_frame, then we should use it
-  // even if isInJava == true. It should be more reliable than
-  // ucontext info.
-  if (jt->has_last_Java_frame() && jt->frame_anchor()->walkable()) {
-    *fr_addr = jt->pd_last_frame();
-    return true;
-  }
-
-  ucontext_t* uc = (ucontext_t*) ucontext;
-
-  // At this point, we don't have a walkable last_Java_frame, so
-  // we try to glean some information out of the ucontext.
-  intptr_t* ret_sp;
-  ExtendedPC addr =
-    os::fetch_frame_from_context(uc, &ret_sp,
-                                 NULL /* ret_fp only used on X86 */);
-  if (addr.pc() == NULL || ret_sp == NULL) {
-    // ucontext wasn't useful
-    return false;
-  }
-
-  // we were running Java code when SIGPROF came in
-  if (isInJava) {
-    // If we have a last_Java_sp, then the SIGPROF signal caught us
-    // right when we were transitioning from _thread_in_Java to a new
-    // JavaThreadState. We use last_Java_sp instead of the sp from
-    // the ucontext since it should be more reliable.
-    if (jt->has_last_Java_frame()) {
-      ret_sp = jt->last_Java_sp();
-    }
-    // Implied else: we don't have a last_Java_sp so we use what we
-    // got from the ucontext.
-
-    frame ret_frame(ret_sp, frame::unpatchable, addr.pc());
-    if (!ret_frame.safe_for_sender(jt)) {
-      // nothing else to try if the frame isn't good
-      return false;
-    }
-    *fr_addr = ret_frame;
-    return true;
-  }
-
-  // At this point, we know we weren't running Java code. We might
-  // have a last_Java_sp, but we don't have a walkable frame.
-  // However, we might still be able to construct something useful
-  // if the thread was running native code.
-  if (jt->has_last_Java_frame()) {
-    assert(!jt->frame_anchor()->walkable(), "case covered above");
-
-    if (jt->thread_state() == _thread_in_native) {
-      frame ret_frame(jt->last_Java_sp(), frame::unpatchable, addr.pc());
-      if (!ret_frame.safe_for_sender(jt)) {
-        // nothing else to try if the frame isn't good
-        return false;
-      }
-      *fr_addr = ret_frame;
-      return true;
-    }
-  }
-
-  // nothing else to try
-  return false;
-}
--- ./hotspot/src/os_cpu/bsd_sparc/vm/thread_bsd_sparc.hpp	2010-03-27 11:09:10.000000000 -0700
+++ ./hotspot/src/os_cpu/bsd_sparc/vm/thread_bsd_sparc.hpp	1969-12-31 16:00:00.000000000 -0800
@@ -1,98 +0,0 @@
-/*
- * Copyright 1998-2008 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- *
- */
-
-private:
-
-  void pd_initialize() {
-    _anchor.clear();
-    _base_of_stack_pointer        = NULL;
-  }
-
-  frame pd_last_frame() {
-    assert(has_last_Java_frame(), "must have last_Java_sp() when suspended");
-    assert(_anchor.walkable(), "thread has not dumped its register windows yet");
-
-    assert(_anchor.last_Java_pc() != NULL, "Ack no pc!");
-    return frame(last_Java_sp(), frame::unpatchable, _anchor.last_Java_pc());
-  }
-
-  // Sometimes the trap handler needs to record both PC and NPC.
-  // This is a SPARC-specific companion to Thread::set_saved_exception_pc.
-  address _saved_exception_npc;
-
-  // In polling_page_safepoint_handler_blob(s) we have to tail call other
-  // blobs without blowing any registers.  A tail call requires some
-  // register to jump with and we can't blow any registers, so it must
-  // be restored in the delay slot.  'restore' cannot be used as it
-  // will chop the heads off of 64-bit %o registers in the 32-bit
-  // build.  Instead we reload the registers using G2_thread and this
-  // location.  Must be 64bits in the 32-bit LION build.
-  jdouble _o_reg_temps[6];
-
-  // a stack pointer older than any java frame stack pointer.  It is
-  // used to validate stack pointers in frame::next_younger_sp (it
-  // provides the upper bound in the range check).  This is necessary
-  // on Solaris/SPARC since the ucontext passed to a signal handler is
-  // sometimes corrupt and we need a way to check the extracted sp.
-  intptr_t* _base_of_stack_pointer;
-
-public:
-
-  static int o_reg_temps_offset_in_bytes() { return offset_of(JavaThread, _o_reg_temps); }
-
-#ifndef _LP64
-  address o_reg_temps(int i) { return (address)&_o_reg_temps[i]; }
-#endif
-
-  static int saved_exception_npc_offset_in_bytes() { return offset_of(JavaThread,_saved_exception_npc); }
-
-  address  saved_exception_npc()             { return _saved_exception_npc; }
-  void set_saved_exception_npc(address a)    { _saved_exception_npc = a; }
-
-
-public:
-
-  intptr_t* base_of_stack_pointer() { return _base_of_stack_pointer; }
-
-  void set_base_of_stack_pointer(intptr_t* base_sp) {
-    _base_of_stack_pointer = base_sp;
-  }
-
-  void record_base_of_stack_pointer() {
-    intptr_t *sp = (intptr_t *)(((intptr_t)StubRoutines::Sparc::flush_callers_register_windows_func()()));
-    intptr_t *ysp;
-    while((ysp = (intptr_t*)sp[FP->sp_offset_in_saved_window()]) != NULL) {
-      sp = (intptr_t *)((intptr_t)ysp + STACK_BIAS);
-    }
-    _base_of_stack_pointer = sp;
-  }
-
-  bool pd_get_top_frame_for_signal_handler(frame* fr_addr, void* ucontext,
-    bool isInJava);
-
-  // These routines are only used on cpu architectures that
-  // have separate register stacks (Itanium).
-  static bool register_stack_overflow() { return false; }
-  static void enable_register_stack_guard() {}
-  static void disable_register_stack_guard() {}
--- ./hotspot/src/os_cpu/bsd_sparc/vm/vmStructs_bsd_sparc.hpp	2010-03-27 11:09:10.000000000 -0700
+++ ./hotspot/src/os_cpu/bsd_sparc/vm/vmStructs_bsd_sparc.hpp	1969-12-31 16:00:00.000000000 -0800
@@ -1,69 +0,0 @@
-/*
- * Copyright 2000-2008 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- *
- */
-
-// These are the OS and CPU-specific fields, types and integer
-// constants required by the Serviceability Agent. This file is
-// referenced by vmStructs.cpp.
-
-#define VM_STRUCTS_OS_CPU(nonstatic_field, static_field, unchecked_nonstatic_field, volatile_nonstatic_field, nonproduct_nonstatic_field, c2_nonstatic_field, unchecked_c1_static_field, unchecked_c2_static_field, last_entry) \
-                                                                                                                                     \
-  /******************************/                                                                                                   \
-  /* Threads (NOTE: incomplete) */                                                                                                   \
-  /******************************/                                                                                                   \
-                                                                                                                                     \
-  nonstatic_field(JavaThread,                  _base_of_stack_pointer,                        intptr_t*)                             \
-  nonstatic_field(OSThread,                    _thread_id,                                    pid_t)                                 \
-  nonstatic_field(OSThread,                    _pthread_id,                                   pthread_t)                             \
-  /* This must be the last entry, and must be present */                                                                             \
-  last_entry()
-
-
-#define VM_TYPES_OS_CPU(declare_type, declare_toplevel_type, declare_oop_type, declare_integer_type, declare_unsigned_integer_type, declare_c1_toplevel_type, declare_c2_type, declare_c2_toplevel_type, last_entry) \
-                                                                          \
-  /**********************/                                                \
-  /* POSIX Thread IDs */                                                  \
-  /**********************/                                                \
-                                                                          \
-  declare_integer_type(pid_t)                                             \
-  declare_unsigned_integer_type(pthread_t)                                \
-                                                                          \
-  /* This must be the last entry, and must be present */                  \
-  last_entry()
-
-
-#define VM_INT_CONSTANTS_OS_CPU(declare_constant, declare_preprocessor_constant, declare_c1_constant, declare_c2_constant, declare_c2_preprocessor_constant, last_entry) \
-                                                                        \
-  /************************/                                            \
-  /* JavaThread constants */                                            \
-  /************************/                                            \
-                                                                        \
-  declare_constant(JavaFrameAnchor::flushed)                            \
-                                                                        \
-  /* This must be the last entry, and must be present */                \
-  last_entry()
-
-#define VM_LONG_CONSTANTS_OS_CPU(declare_constant, declare_preprocessor_constant, declare_c1_constant, declare_c2_constant, declare_c2_preprocessor_constant, last_entry) \
-                                                                        \
-  /* This must be the last entry, and must be present */                \
-  last_entry()
--- ./hotspot/src/os_cpu/bsd_sparc/vm/vm_version_bsd_sparc.cpp	2010-03-27 11:09:10.000000000 -0700
+++ ./hotspot/src/os_cpu/bsd_sparc/vm/vm_version_bsd_sparc.cpp	1969-12-31 16:00:00.000000000 -0800
@@ -1,61 +0,0 @@
-/*
- * Copyright 2006-2008 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- *
- */
-
-# include "incls/_precompiled.incl"
-# include "incls/_vm_version_bsd_sparc.cpp.incl"
-
-static bool detect_niagara() {
-  char cpu[128];
-  bool rv = false;
-
-  FILE* fp = fopen("/proc/cpuinfo", "r");
-  if (fp == NULL) {
-    return rv;
-  }
-
-  while (!feof(fp)) {
-    if (fscanf(fp, "cpu\t\t: %100[^\n]", &cpu) == 1) {
-      if (strstr(cpu, "Niagara") != NULL) {
-        rv = true;
-      }
-      break;
-    }
-  }
-
-  fclose(fp);
-
-  return rv;
-}
-
-int VM_Version::platform_features(int features) {
-  // Default to generic v9
-  features = generic_v9_m;
-
-  if (detect_niagara()) {
-    NOT_PRODUCT(if (PrintMiscellaneous && Verbose) tty->print_cr("Detected Bsd on Niagara");)
-    features = niagara1_m;
-  }
-
-  return features;
-}
--- ./hotspot/src/os_cpu/bsd_x86/vm/bsd_x86_32.s	2010-03-27 11:09:11.000000000 -0700
+++ ./hotspot/src/os_cpu/bsd_x86/vm/bsd_x86_32.s	2009-06-06 16:54:01.000000000 -0700
@@ -19,8 +19,19 @@
 # Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
 # CA 95054 USA or visit www.sun.com if you need additional information or
 # have any questions.
-# 
+#
 
+ 
+#ifdef __APPLE__
+# Darwin uses _ prefixed global symbols
+#define SYMBOL(s) _ ## s
+#define ELF_TYPE(name, description)
+#else
+#define SYMBOL(s) s
+#define ELF_TYPE(name, description) .type name,description
+#endif
+
+	.globl SYMBOL(fixcw)
 	
         # NOTE WELL!  The _Copy functions are called directly
 	# from server-compiler-generated code via CallLeafNoFP,
@@ -28,41 +39,61 @@
 	# point or use it in the same manner as does the server
 	# compiler.
 	
-        .globl _Copy_conjoint_bytes
-        .globl _Copy_arrayof_conjoint_bytes
-        .globl _Copy_conjoint_jshorts_atomic
-	.globl _Copy_arrayof_conjoint_jshorts
-        .globl _Copy_conjoint_jints_atomic
-        .globl _Copy_arrayof_conjoint_jints
-	.globl _Copy_conjoint_jlongs_atomic
-	.globl _mmx_Copy_arrayof_conjoint_jshorts
+        .globl SYMBOL(_Copy_conjoint_bytes)
+        .globl SYMBOL(_Copy_arrayof_conjoint_bytes)
+        .globl SYMBOL(_Copy_conjoint_jshorts_atomic)
+	.globl SYMBOL(_Copy_arrayof_conjoint_jshorts)
+        .globl SYMBOL(_Copy_conjoint_jints_atomic)
+        .globl SYMBOL(_Copy_arrayof_conjoint_jints)
+	.globl SYMBOL(_Copy_conjoint_jlongs_atomic)
+	.globl SYMBOL(_mmx_Copy_arrayof_conjoint_jshorts)
 
-        .globl _Atomic_cmpxchg_long
+        .globl SYMBOL(_Atomic_cmpxchg_long)
 
 	.text
 
-        .globl  SafeFetch32, Fetch32PFI, Fetch32Resume
-        .globl  SafeFetchN
+# Support for void os::Solaris::init_thread_fpu_state() in os_solaris_i486.cpp
+# Set fpu to 53 bit precision.  This happens too early to use a stub.
+# ported from solaris_x86_32.s
+#ifdef __APPLE__
+        .align   4
+#else
+	.align   16
+#endif
+SYMBOL(fixcw):
+	pushl    $0x27f
+	fldcw    0(%esp)
+	popl     %eax
+	ret
+
+#ifdef __APPLE__
+        .align   4
+#else
+        .align   16
+#endif
+
+        .globl  SYMBOL(SafeFetch32), SYMBOL(Fetch32PFI), SYMBOL(Fetch32Resume)
+        .globl  SYMBOL(SafeFetchN)
         ## TODO: avoid exposing Fetch32PFI and Fetch32Resume.
         ## Instead, the signal handler would call a new SafeFetchTriage(FaultingEIP)
         ## routine to vet the address.  If the address is the faulting LD then
         ## SafeFetchTriage() would return the resume-at EIP, otherwise null.
-	.type    SafeFetch32,@function
+	ELF_TYPE(SafeFetch32,@function)
         .p2align 4,,15
-SafeFetch32:
-SafeFetchN:
+SYMBOL(SafeFetch32):
+SYMBOL(SafeFetchN):
          movl    0x8(%esp), %eax
          movl    0x4(%esp), %ecx
-Fetch32PFI:
+SYMBOL(Fetch32PFI):
          movl    (%ecx), %eax
-Fetch32Resume:
+SYMBOL(Fetch32Resume):
          ret
 
 
-        .globl  SpinPause
-	.type   SpinPause,@function
+        .globl  SYMBOL(SpinPause)
+	ELF_TYPE(SpinPause,@function)
         .p2align 4,,15
-SpinPause:
+SYMBOL(SpinPause):
         rep
         nop
         movl    $1, %eax
@@ -72,8 +103,8 @@
         #                                       void* to,
         #                                       size_t count)
         .p2align 4,,15
-	.type    _Copy_conjoint_bytes,@function
-_Copy_conjoint_bytes:
+	ELF_TYPE(_Copy_conjoint_bytes,@function)
+SYMBOL(_Copy_conjoint_bytes):
         pushl    %esi
         movl     4+12(%esp),%ecx      # count
         pushl    %edi
@@ -180,8 +211,8 @@
         #
         # Same as _Copy_conjoint_bytes, except no source alignment check.
         .p2align 4,,15
-	.type    _Copy_arrayof_conjoint_bytes,@function
-_Copy_arrayof_conjoint_bytes:
+	ELF_TYPE(_Copy_arrayof_conjoint_bytes,@function)
+SYMBOL(_Copy_arrayof_conjoint_bytes):
         pushl    %esi
         movl     4+12(%esp),%ecx      # count
         pushl    %edi
@@ -268,8 +299,8 @@
         #                                                void* to,
         #                                                size_t count)
         .p2align 4,,15
-	.type    _Copy_conjoint_jshorts_atomic,@function
-_Copy_conjoint_jshorts_atomic:
+	ELF_TYPE(_Copy_conjoint_jshorts_atomic,@function)
+SYMBOL(_Copy_conjoint_jshorts_atomic):
         pushl    %esi
         movl     4+12(%esp),%ecx      # count
         pushl    %edi
@@ -354,8 +385,8 @@
         #                                                 void* to,
         #                                                 size_t count)
         .p2align 4,,15
-	.type    _Copy_arrayof_conjoint_jshorts,@function
-_Copy_arrayof_conjoint_jshorts:
+	ELF_TYPE(_Copy_arrayof_conjoint_jshorts,@function)
+SYMBOL(_Copy_arrayof_conjoint_jshorts):
         pushl    %esi
         movl     4+12(%esp),%ecx      # count
         pushl    %edi
@@ -431,10 +462,10 @@
         # Equivalent to
         #   arrayof_conjoint_jints
         .p2align 4,,15
-	.type    _Copy_conjoint_jints_atomic,@function
-	.type    _Copy_arrayof_conjoint_jints,@function
-_Copy_conjoint_jints_atomic:
-_Copy_arrayof_conjoint_jints:
+	ELF_TYPE(_Copy_conjoint_jints_atomic,@function)
+	ELF_TYPE(_Copy_arrayof_conjoint_jints,@function)
+SYMBOL(_Copy_conjoint_jints_atomic):
+SYMBOL(_Copy_arrayof_conjoint_jints):
         pushl    %esi
         movl     4+12(%esp),%ecx      # count
         pushl    %edi
@@ -494,7 +525,7 @@
         #
         # count treated as signed
         #
-        # if (from > to) {
+        # // if (from > to) {
         #   while (--count >= 0) {
         #     *to++ = *from++;
         #   }
@@ -504,8 +535,8 @@
         #   }
         # }
         .p2align 4,,15
-	.type    _Copy_conjoint_jlongs_atomic,@function
-_Copy_conjoint_jlongs_atomic:
+	ELF_TYPE(_Copy_conjoint_jlongs_atomic,@function)
+SYMBOL(_Copy_conjoint_jlongs_atomic):
         movl     4+8(%esp),%ecx       # count
         movl     4+0(%esp),%eax       # from
         movl     4+4(%esp),%edx       # to
@@ -533,8 +564,8 @@
         #                                                 void* to,
         #                                                 size_t count)
         .p2align 4,,15
-	.type    _mmx_Copy_arrayof_conjoint_jshorts,@function
-_mmx_Copy_arrayof_conjoint_jshorts:
+	ELF_TYPE(_mmx_Copy_arrayof_conjoint_jshorts,@function)
+SYMBOL(_mmx_Copy_arrayof_conjoint_jshorts):
         pushl    %esi
         movl     4+12(%esp),%ecx
         pushl    %edi
@@ -632,8 +663,8 @@
         #                                   bool is_MP)
         #
         .p2align 4,,15
-	.type    _Atomic_cmpxchg_long,@function
-_Atomic_cmpxchg_long:
+	ELF_TYPE(_Atomic_cmpxchg_long,@function)
+SYMBOL(_Atomic_cmpxchg_long):
                                    #  8(%esp) : return PC
         pushl    %ebx              #  4(%esp) : old %ebx
         pushl    %edi              #  0(%esp) : old %edi
--- ./hotspot/src/os_cpu/bsd_x86/vm/bsd_x86_64.s	2010-03-27 11:09:11.000000000 -0700
+++ ./hotspot/src/os_cpu/bsd_x86/vm/bsd_x86_64.s	2009-06-06 16:54:01.000000000 -0700
@@ -21,6 +21,14 @@
 # have any questions.
 #
 
+#ifdef __APPLE__
+# Darwin uses _ prefixed global symbols
+#define SYMBOL(s) _ ## s
+#define ELF_TYPE(name, description)
+#else
+#define SYMBOL(s) s
+#define ELF_TYPE(name, description) .type name,description
+#endif
 
         # NOTE WELL!  The _Copy functions are called directly
 	# from server-compiler-generated code via CallLeafNoFP,
@@ -28,42 +36,54 @@
 	# point or use it in the same manner as does the server
 	# compiler.
 	
-        .globl _Copy_arrayof_conjoint_bytes
-	.globl _Copy_arrayof_conjoint_jshorts
-        .globl _Copy_conjoint_jshorts_atomic
-        .globl _Copy_arrayof_conjoint_jints
-        .globl _Copy_conjoint_jints_atomic
-        .globl _Copy_arrayof_conjoint_jlongs
-        .globl _Copy_conjoint_jlongs_atomic
+        .globl SYMBOL(_Copy_arrayof_conjoint_bytes)
+	.globl SYMBOL(_Copy_arrayof_conjoint_jshorts)
+        .globl SYMBOL(_Copy_conjoint_jshorts_atomic)
+        .globl SYMBOL(_Copy_arrayof_conjoint_jints)
+        .globl SYMBOL(_Copy_conjoint_jints_atomic)
+        .globl SYMBOL(_Copy_arrayof_conjoint_jlongs)
+        .globl SYMBOL(_Copy_conjoint_jlongs_atomic)
 
 	.text
 
-        .globl SafeFetch32, Fetch32PFI, Fetch32Resume
+        .globl SYMBOL(SafeFetch32), SYMBOL(Fetch32PFI), SYMBOL(Fetch32Resume)
+#ifdef __APPLE__
+        .align  4
+#else
         .align  16
-        .type   SafeFetch32,@function
+#endif
+        ELF_TYPE(SafeFetch32,@function)
         // Prototype: int SafeFetch32 (int * Adr, int ErrValue) 
-SafeFetch32:
+SYMBOL(SafeFetch32):
         movl    %esi, %eax
-Fetch32PFI:
+SYMBOL(Fetch32PFI):
         movl    (%rdi), %eax
-Fetch32Resume:
+SYMBOL(Fetch32Resume):
         ret
 
-        .globl SafeFetchN, FetchNPFI, FetchNResume
+        .globl SYMBOL(SafeFetchN), SYMBOL(FetchNPFI), SYMBOL(FetchNResume)
+#ifdef __APPLE__
+        .align  4
+#else
         .align  16
-        .type   SafeFetchN,@function
+#endif
+        ELF_TYPE(SafeFetchN,@function)
         // Prototype: intptr_t SafeFetchN (intptr_t * Adr, intptr_t ErrValue) 
-SafeFetchN:
+SYMBOL(SafeFetchN):
         movq    %rsi, %rax
-FetchNPFI:
+SYMBOL(FetchNPFI):
         movq    (%rdi), %rax
-FetchNResume:
+SYMBOL(FetchNResume):
         ret
 
-        .globl SpinPause
-        .align 16
-        .type  SpinPause,@function
-SpinPause:
+        .globl SYMBOL(SpinPause)
+#ifdef __APPLE__
+        .align  4
+#else
+        .align  16
+#endif
+        ELF_TYPE(SpinPause,@function)
+SYMBOL(SpinPause):
         rep
         nop
         movq   $1, %rax
@@ -77,8 +97,8 @@
         # rdx - count, treated as ssize_t
         #
         .p2align 4,,15
-	.type    _Copy_arrayof_conjoint_bytes,@function
-_Copy_arrayof_conjoint_bytes:
+	ELF_TYPE(_Copy_arrayof_conjoint_bytes,@function)
+SYMBOL(_Copy_arrayof_conjoint_bytes):
         movq     %rdx,%r8             # byte count
         shrq     $3,%rdx              # qword count
         cmpq     %rdi,%rsi
@@ -179,10 +199,10 @@
         # rdx - count, treated as ssize_t
         #
         .p2align 4,,15
-	.type    _Copy_arrayof_conjoint_jshorts,@function
-	.type    _Copy_conjoint_jshorts_atomic,@function
-_Copy_arrayof_conjoint_jshorts:
-_Copy_conjoint_jshorts_atomic:
+	ELF_TYPE(_Copy_arrayof_conjoint_jshorts,@function)
+	ELF_TYPE(_Copy_conjoint_jshorts_atomic,@function)
+SYMBOL(_Copy_arrayof_conjoint_jshorts):
+SYMBOL(_Copy_conjoint_jshorts_atomic):
         movq     %rdx,%r8             # word count
         shrq     $2,%rdx              # qword count
         cmpq     %rdi,%rsi
@@ -269,10 +289,10 @@
         # rdx - count, treated as ssize_t
         #
         .p2align 4,,15
-	.type    _Copy_arrayof_conjoint_jints,@function
-	.type    _Copy_conjoint_jints_atomic,@function
-_Copy_arrayof_conjoint_jints:
-_Copy_conjoint_jints_atomic:
+	ELF_TYPE(_Copy_arrayof_conjoint_jints,@function)
+	ELF_TYPE(_Copy_conjoint_jints_atomic,@function)
+SYMBOL(_Copy_arrayof_conjoint_jints):
+SYMBOL(_Copy_conjoint_jints_atomic):
         movq     %rdx,%r8             # dword count
         shrq     %rdx                 # qword count
         cmpq     %rdi,%rsi
@@ -348,10 +368,10 @@
         # rdx - count, treated as ssize_t
         #
         .p2align 4,,15
-	.type    _Copy_arrayof_conjoint_jlongs,@function
-	.type    _Copy_conjoint_jlongs_atomic,@function
-_Copy_arrayof_conjoint_jlongs:
-_Copy_conjoint_jlongs_atomic:
+	ELF_TYPE(_Copy_arrayof_conjoint_jlongs,@function)
+	ELF_TYPE(_Copy_conjoint_jlongs_atomic,@function)
+SYMBOL(_Copy_arrayof_conjoint_jlongs):
+SYMBOL(_Copy_conjoint_jlongs_atomic):
         cmpq     %rdi,%rsi
         leaq     -8(%rdi,%rdx,8),%rax # from + count*8 - 8
         jbe      acl_CopyRight
--- ./hotspot/src/os_cpu/bsd_x86/vm/bytes_bsd_x86.inline.hpp	2010-03-27 11:09:11.000000000 -0700
+++ ./hotspot/src/os_cpu/bsd_x86/vm/bytes_bsd_x86.inline.hpp	2009-06-06 16:54:01.000000000 -0700
@@ -22,7 +22,33 @@
  *
  */
 
+#ifndef _ALLBSD_SOURCE
 #include <byteswap.h>
+#endif
+
+#ifdef __APPLE__
+#include <libkern/OSByteOrder.h>
+#endif
+
+#if defined(AMD64)
+#  if defined(__APPLE__)
+#    define bswap_16(x)	OSSwapInt16(x)
+#    define bswap_32(x)	OSSwapInt32(x)
+#    define bswap_64(x)	OSSwapInt64(x)
+#  elif defined(__OpenBSD__)
+#    define bswap_16(x)	swap16(x)
+#    define bswap_32(x)	swap32(x)
+#    define bswap_64(x)	swap64(x)
+#  elif defined(__NetBSD__)
+#    define bswap_16(x)	bswap16(x)
+#    define bswap_32(x)	bswap32(x)
+#    define bswap_64(x)	bswap64(x)
+#  else
+#    define bswap_16(x) __bswap16(x)
+#    define bswap_32(x) __bswap32(x)
+#    define bswap_64(x) __bswap64(x)
+#  endif
+#endif
 
 // Efficient swapping of data bytes from Java byte
 // ordering to native byte ordering and vice versa.
--- ./hotspot/src/os_cpu/bsd_x86/vm/globals_bsd_x86.hpp	2010-03-27 11:09:11.000000000 -0700
+++ ./hotspot/src/os_cpu/bsd_x86/vm/globals_bsd_x86.hpp	2009-10-05 21:49:06.000000000 -0700
@@ -22,9 +22,10 @@
  *
  */
 
+//
 // Sets the default values for platform dependent flags used by the runtime system.
 // (see globals.hpp)
-
+//
 define_pd_global(bool, DontYieldALot,            false);
 #ifdef AMD64
 define_pd_global(intx, ThreadStackSize,          1024); // 0 => use system default
@@ -38,10 +39,11 @@
 #endif // AMD64
 
 define_pd_global(intx, CompilerThreadStackSize,  0);
+define_pd_global(intx, SurvivorRatio,            8);
 
-define_pd_global(uintx,JVMInvokeMethodSlack,     8192);
+define_pd_global(uintx, JVMInvokeMethodSlack,    8192);
 
 // Only used on 64 bit platforms
-define_pd_global(uintx,HeapBaseMinAddress,       2*G);
+define_pd_global(uintx, HeapBaseMinAddress,      2*G);
 // Only used on 64 bit Windows platforms
 define_pd_global(bool, UseVectoredExceptions,    false);
--- ./hotspot/src/os_cpu/bsd_x86/vm/os_bsd_x86.cpp	2010-03-27 11:09:11.000000000 -0700
+++ ./hotspot/src/os_cpu/bsd_x86/vm/os_bsd_x86.cpp	2009-06-06 16:54:01.000000000 -0700
@@ -44,23 +44,202 @@
 # include <sys/wait.h>
 # include <pwd.h>
 # include <poll.h>
+#ifndef __OpenBSD__
 # include <ucontext.h>
-# include <fpu_control.h>
+#endif
+
+#if defined(_ALLBSD_SOURCE) && !defined(__APPLE__) && !defined(__NetBSD__)
+# include <pthread_np.h>
+#endif
 
 #ifdef AMD64
-#define REG_SP REG_RSP
-#define REG_PC REG_RIP
-#define REG_FP REG_RBP
 #define SPELL_REG_SP "rsp"
 #define SPELL_REG_FP "rbp"
 #else
-#define REG_SP REG_UESP
-#define REG_PC REG_EIP
-#define REG_FP REG_EBP
 #define SPELL_REG_SP "esp"
 #define SPELL_REG_FP "ebp"
 #endif // AMD64
 
+#ifdef __FreeBSD__
+# define context_trapno uc_mcontext.mc_trapno
+# ifdef AMD64
+#  define context_pc uc_mcontext.mc_rip
+#  define context_sp uc_mcontext.mc_rsp
+#  define context_fp uc_mcontext.mc_rbp
+#  define context_rip uc_mcontext.mc_rip
+#  define context_rsp uc_mcontext.mc_rsp
+#  define context_rbp uc_mcontext.mc_rbp
+#  define context_rax uc_mcontext.mc_rax
+#  define context_rbx uc_mcontext.mc_rbx
+#  define context_rcx uc_mcontext.mc_rcx
+#  define context_rdx uc_mcontext.mc_rdx
+#  define context_rsi uc_mcontext.mc_rsi
+#  define context_rdi uc_mcontext.mc_rdi
+#  define context_r8  uc_mcontext.mc_r8
+#  define context_r9  uc_mcontext.mc_r9
+#  define context_r10 uc_mcontext.mc_r10
+#  define context_r11 uc_mcontext.mc_r11
+#  define context_r12 uc_mcontext.mc_r12
+#  define context_r13 uc_mcontext.mc_r13
+#  define context_r14 uc_mcontext.mc_r14
+#  define context_r15 uc_mcontext.mc_r15
+#  define context_flags uc_mcontext.mc_flags
+#  define context_err uc_mcontext.mc_err
+# else
+#  define context_pc uc_mcontext.mc_eip
+#  define context_sp uc_mcontext.mc_esp
+#  define context_fp uc_mcontext.mc_ebp
+#  define context_eip uc_mcontext.mc_eip
+#  define context_esp uc_mcontext.mc_esp
+#  define context_eax uc_mcontext.mc_eax
+#  define context_ebx uc_mcontext.mc_ebx
+#  define context_ecx uc_mcontext.mc_ecx
+#  define context_edx uc_mcontext.mc_edx
+#  define context_ebp uc_mcontext.mc_ebp
+#  define context_esi uc_mcontext.mc_esi
+#  define context_edi uc_mcontext.mc_edi
+#  define context_eflags uc_mcontext.mc_eflags
+#  define context_trapno uc_mcontext.mc_trapno
+# endif
+#endif
+
+#ifdef __APPLE__ 
+# if __DARWIN_UNIX03 && (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
+  // 10.5 UNIX03 member name prefixes
+  #define DU3_PREFIX(s, m) __ ## s.__ ## m
+# else
+  #define DU3_PREFIX(s, m) s ## . ## m
+# endif
+
+# ifdef AMD64
+#  define context_pc context_rip
+#  define context_sp context_rsp
+#  define context_fp context_rbp
+#  define context_rip uc_mcontext->DU3_PREFIX(ss,rip)
+#  define context_rsp uc_mcontext->DU3_PREFIX(ss,rsp)
+#  define context_rax uc_mcontext->DU3_PREFIX(ss,rax)
+#  define context_rbx uc_mcontext->DU3_PREFIX(ss,rbx)
+#  define context_rcx uc_mcontext->DU3_PREFIX(ss,rcx)
+#  define context_rdx uc_mcontext->DU3_PREFIX(ss,rdx)
+#  define context_rbp uc_mcontext->DU3_PREFIX(ss,rbp)
+#  define context_rsi uc_mcontext->DU3_PREFIX(ss,rsi)
+#  define context_rdi uc_mcontext->DU3_PREFIX(ss,rdi)
+#  define context_r8  uc_mcontext->DU3_PREFIX(ss,r8)
+#  define context_r9  uc_mcontext->DU3_PREFIX(ss,r9)
+#  define context_r10 uc_mcontext->DU3_PREFIX(ss,r10)
+#  define context_r11 uc_mcontext->DU3_PREFIX(ss,r11)
+#  define context_r12 uc_mcontext->DU3_PREFIX(ss,r12)
+#  define context_r13 uc_mcontext->DU3_PREFIX(ss,r13)
+#  define context_r14 uc_mcontext->DU3_PREFIX(ss,r14)
+#  define context_r15 uc_mcontext->DU3_PREFIX(ss,r15)
+#  define context_flags uc_mcontext->DU3_PREFIX(ss,rflags)
+#  define context_trapno uc_mcontext->DU3_PREFIX(es,trapno)
+#  define context_err uc_mcontext->DU3_PREFIX(es,err)
+# else
+#  define context_pc context_eip
+#  define context_sp context_esp
+#  define context_fp context_ebp
+#  define context_eip uc_mcontext->DU3_PREFIX(ss,eip)
+#  define context_esp uc_mcontext->DU3_PREFIX(ss,esp)
+#  define context_eax uc_mcontext->DU3_PREFIX(ss,eax)
+#  define context_ebx uc_mcontext->DU3_PREFIX(ss,ebx)
+#  define context_ecx uc_mcontext->DU3_PREFIX(ss,ecx)
+#  define context_edx uc_mcontext->DU3_PREFIX(ss,edx)
+#  define context_ebp uc_mcontext->DU3_PREFIX(ss,ebp)
+#  define context_esi uc_mcontext->DU3_PREFIX(ss,esi)
+#  define context_edi uc_mcontext->DU3_PREFIX(ss,edi)
+#  define context_eflags uc_mcontext->DU3_PREFIX(ss,eflags)
+#  define context_trapno uc_mcontext->DU3_PREFIX(es,trapno)
+# endif
+#endif
+
+#ifdef __OpenBSD__
+# define context_trapno sc_trapno
+# ifdef AMD64
+#  define context_pc sc_rip
+#  define context_sp sc_rsp
+#  define context_fp sc_rbp
+#  define context_rip sc_rip
+#  define context_rsp sc_rsp
+#  define context_rbp sc_rbp
+#  define context_rax sc_rax
+#  define context_rbx sc_rbx
+#  define context_rcx sc_rcx
+#  define context_rdx sc_rdx
+#  define context_rsi sc_rsi
+#  define context_rdi sc_rdi
+#  define context_r8  sc_r8
+#  define context_r9  sc_r9
+#  define context_r10 sc_r10
+#  define context_r11 sc_r11
+#  define context_r12 sc_r12
+#  define context_r13 sc_r13
+#  define context_r14 sc_r14
+#  define context_r15 sc_r15
+#  define context_flags sc_rflags
+#  define context_err sc_err
+# else
+#  define context_pc sc_eip
+#  define context_sp sc_esp
+#  define context_fp sc_ebp
+#  define context_eip sc_eip
+#  define context_esp sc_esp
+#  define context_eax sc_eax
+#  define context_ebx sc_ebx
+#  define context_ecx sc_ecx
+#  define context_edx sc_edx
+#  define context_ebp sc_ebp
+#  define context_esi sc_esi
+#  define context_edi sc_edi
+#  define context_eflags sc_eflags
+#  define context_trapno sc_trapno
+# endif
+#endif
+
+#ifdef __NetBSD__
+# define context_trapno uc_mcontext.__gregs[_REG_TRAPNO]
+# ifdef AMD64
+#  define __register_t __greg_t
+#  define context_pc uc_mcontext.__gregs[_REG_RIP]
+#  define context_sp uc_mcontext.__gregs[_REG_URSP]
+#  define context_fp uc_mcontext.__gregs[_REG_RBP]
+#  define context_rip uc_mcontext.__gregs[_REG_RIP]
+#  define context_rsp uc_mcontext.__gregs[_REG_URSP]
+#  define context_rax uc_mcontext.__gregs[_REG_RAX]
+#  define context_rbx uc_mcontext.__gregs[_REG_RBX]
+#  define context_rcx uc_mcontext.__gregs[_REG_RCX]
+#  define context_rdx uc_mcontext.__gregs[_REG_RDX]
+#  define context_rbp uc_mcontext.__gregs[_REG_RBP]
+#  define context_rsi uc_mcontext.__gregs[_REG_RSI]
+#  define context_rdi uc_mcontext.__gregs[_REG_RDI]
+#  define context_r8  uc_mcontext.__gregs[_REG_R8]
+#  define context_r9  uc_mcontext.__gregs[_REG_R9]
+#  define context_r10 uc_mcontext.__gregs[_REG_R10]
+#  define context_r11 uc_mcontext.__gregs[_REG_R11]
+#  define context_r12 uc_mcontext.__gregs[_REG_R12]
+#  define context_r13 uc_mcontext.__gregs[_REG_R13]
+#  define context_r14 uc_mcontext.__gregs[_REG_R14]
+#  define context_r15 uc_mcontext.__gregs[_REG_R15]
+#  define context_flags uc_mcontext.__gregs[_REG_RFL]
+#  define context_err uc_mcontext.__gregs[_REG_ERR]
+# else
+#  define context_pc uc_mcontext.__gregs[_REG_EIP]
+#  define context_sp uc_mcontext.__gregs[_REG_UESP]
+#  define context_fp uc_mcontext.__gregs[_REG_EBP]
+#  define context_eip uc_mcontext.__gregs[_REG_EIP]
+#  define context_esp uc_mcontext.__gregs[_REG_UESP]
+#  define context_eax uc_mcontext.__gregs[_REG_EAX]
+#  define context_ebx uc_mcontext.__gregs[_REG_EBX]
+#  define context_ecx uc_mcontext.__gregs[_REG_ECX]
+#  define context_edx uc_mcontext.__gregs[_REG_EDX]
+#  define context_ebp uc_mcontext.__gregs[_REG_EBP]
+#  define context_esi uc_mcontext.__gregs[_REG_ESI]
+#  define context_edi uc_mcontext.__gregs[_REG_EDI]
+#  define context_eflags uc_mcontext.__gregs[_REG_EFL]
+#  define context_trapno uc_mcontext.__gregs[_REG_TRAPNO]
+# endif
+#endif
+
 address os::current_stack_pointer() {
 #ifdef SPARC_WORKS
   register void *esp;
@@ -85,15 +264,15 @@
 }
 
 address os::Bsd::ucontext_get_pc(ucontext_t * uc) {
-  return (address)uc->uc_mcontext.gregs[REG_PC];
+  return (address)uc->context_pc;
 }
 
 intptr_t* os::Bsd::ucontext_get_sp(ucontext_t * uc) {
-  return (intptr_t*)uc->uc_mcontext.gregs[REG_SP];
+  return (intptr_t*)uc->context_sp;
 }
 
 intptr_t* os::Bsd::ucontext_get_fp(ucontext_t * uc) {
-  return (intptr_t*)uc->uc_mcontext.gregs[REG_FP];
+  return (intptr_t*)uc->context_fp;
 }
 
 // For Forte Analyzer AsyncGetCallTrace profiling support - thread
@@ -245,18 +424,18 @@
     pc = (address) os::Bsd::ucontext_get_pc(uc);
 
     if (pc == (address) Fetch32PFI) {
-       uc->uc_mcontext.gregs[REG_PC] = intptr_t(Fetch32Resume) ;
+       uc->context_pc = intptr_t(Fetch32Resume) ;
        return 1 ;
     }
 #ifdef AMD64
     if (pc == (address) FetchNPFI) {
-       uc->uc_mcontext.gregs[REG_PC] = intptr_t (FetchNResume) ;
+       uc->context_pc = intptr_t (FetchNResume) ;
        return 1 ;
     }
 #endif // AMD64
 
     // Handle ALL stack overflow variations here
-    if (sig == SIGSEGV) {
+    if (sig == SIGSEGV || sig == SIGBUS) {
       address addr = (address) info->si_addr;
 
       // check if fault address is within thread stack
@@ -278,6 +457,7 @@
           // to handle_unexpected_exception way down below.
           thread->disable_stack_red_zone();
           tty->print_raw_cr("An irrecoverable stack overflow has occurred.");
+#ifndef _ALLBSD_SOURCE
         } else {
           // Accessing stack address below sp may cause SEGV if current
           // thread has MAP_GROWSDOWN stack. This should only happen when
@@ -293,6 +473,7 @@
           } else {
              fatal("recursive segv. expanding stack.");
           }
+#endif
         }
       }
     }
@@ -301,9 +482,16 @@
       // Java thread running in Java code => find exception handler if any
       // a fault inside compiled code, the interpreter, or a stub
 
-      if (sig == SIGSEGV && os::is_poll_address((address)info->si_addr)) {
+      if ((sig == SIGSEGV || sig == SIGBUS) && os::is_poll_address((address)info->si_addr)) {
         stub = SharedRuntime::get_poll_stub(pc);
+#if defined(__APPLE__) && !defined(AMD64)
+      // 32-bit Darwin reports a SIGBUS for nearly all memory access exceptions.
+      // Catching SIGBUS here prevents the implicit SIGBUS NULL check below from
+      // being called, so only do so if the implicit NULL check is not necessary.
+      } else if (sig == SIGBUS && MacroAssembler::needs_explicit_null_check((int)info->si_addr)) {
+#else
       } else if (sig == SIGBUS /* && info->si_code == BUS_OBJERR */) {
+#endif
         // BugId 4454115: A read from a MappedByteBuffer can fault
         // here if the underlying file has been truncated.
         // Do not crash the VM in such a case.
@@ -324,6 +512,28 @@
                                               pc,
                                               SharedRuntime::
                                               IMPLICIT_DIVIDE_BY_ZERO);
+#ifdef __APPLE__
+      } else if (sig == SIGFPE && info->si_code == FPE_NOOP) {
+        int op = pc[0];
+
+        // Skip REX
+        if ((pc[0] & 0xf0) == 0x40) {
+          op = pc[1];
+        } else {
+          op = pc[0];
+        }
+
+        // Check for IDIV
+        if (op == 0xF7) {
+          stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime:: IMPLICIT_DIVIDE_BY_ZERO);
+        } else {
+          // TODO: handle more cases if we are using other x86 instructions
+          //   that can generate SIGFPE signal.
+          tty->print_cr("unknown opcode 0x%X with SIGFPE.", op);
+          fatal("please update this code.");
+        }
+#endif /* __APPLE__ */
+
 #else
       if (sig == SIGFPE /* && info->si_code == FPE_INTDIV */) {
         // HACK: si_code does not work on bsd 2.2.12-20!!!
@@ -351,7 +561,7 @@
           fatal("please update this code.");
         }
 #endif // AMD64
-      } else if (sig == SIGSEGV &&
+      } else if ((sig == SIGSEGV || sig == SIGBUS) &&
                !MacroAssembler::needs_explicit_null_check((intptr_t)info->si_addr)) {
           // Determination of interpreter/vtable stub/compiled code null exception
           stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);
@@ -375,7 +585,7 @@
     // process of write protecting the memory serialization page.
     // It write enables the page immediately after protecting it
     // so we can just return to retry the write.
-    if ((sig == SIGSEGV) &&
+    if ((sig == SIGSEGV || sig == SIGBUS) &&
         os::is_memory_serialize_page(thread, (address) info->si_addr)) {
       // Block current thread until the memory serialize page permission restored.
       os::block_on_serialize_page_trap();
@@ -396,7 +606,7 @@
   // Furthermore, a false-positive should be harmless.
   if (UnguardOnExecutionViolation > 0 &&
       (sig == SIGSEGV || sig == SIGBUS) &&
-      uc->uc_mcontext.gregs[REG_TRAPNO] == trap_page_fault) {
+      uc->context_trapno == trap_page_fault) {
     int page_size = os::vm_page_size();
     address addr = (address) info->si_addr;
     address pc = os::Bsd::ucontext_get_pc(uc);
@@ -466,7 +676,7 @@
     // save all thread context in case we need to restore it
     if (thread != NULL) thread->set_saved_exception_pc(pc);
 
-    uc->uc_mcontext.gregs[REG_PC] = (greg_t)stub;
+    uc->context_pc = (intptr_t)stub;
     return true;
   }
 
@@ -496,13 +706,24 @@
   ShouldNotReachHere();
 }
 
+#ifdef _ALLBSD_SOURCE
+// From solaris_i486.s ported to bsd_i486.s
+extern "C" void fixcw();
+#endif
+
 void os::Bsd::init_thread_fpu_state(void) {
 #ifndef AMD64
+# ifdef _ALLBSD_SOURCE
+  // Set fpu to 53 bit precision. This happens too early to use a stub.
+  fixcw();
+# else
   // set fpu to 53 bit precision
   set_fpu_control_word(0x27f);
+# endif
 #endif // !AMD64
 }
 
+#ifndef _ALLBSD_SOURCE
 int os::Bsd::get_fpu_control_word(void) {
 #ifdef AMD64
   return 0;
@@ -518,11 +739,12 @@
   _FPU_SETCW(fpu_control);
 #endif // !AMD64
 }
+#endif
 
 // Check that the bsd kernel version is 2.4 or higher since earlier
 // versions do not support SSE without patches.
 bool os::supports_sse() {
-#ifdef AMD64
+#if defined(AMD64) || defined(_ALLBSD_SOURCE)
   return true;
 #else
   struct utsname uts;
@@ -576,6 +798,9 @@
 #define GET_GS() ({int gs; __asm__ volatile("movw %%gs, %w0":"=q"(gs)); gs&0xffff;})
 #endif
 
+#ifdef _ALLBSD_SOURCE
+bool os::Bsd::supports_variable_stack_size() { return true; }
+#else
 // Test if pthread library can support variable thread stack size. BsdThreads
 // in fixed stack mode allocates 2M fixed slot for each thread. BsdThreads
 // in floating stack mode and NPTL support variable stack size.
@@ -612,6 +837,7 @@
 #endif
   }
 }
+#endif
 #endif // AMD64
 
 // return default stack size for thr_type
@@ -665,6 +891,41 @@
 //    pthread_attr_getstack()
 
 static void current_stack_region(address * bottom, size_t * size) {
+#ifdef __APPLE__
+  pthread_t self = pthread_self();
+  void *stacktop = pthread_get_stackaddr_np(self);
+  *size = pthread_get_stacksize_np(self);
+  *bottom = (address) stacktop - *size;
+#elif defined(__OpenBSD__)
+  stack_t ss;
+  int rslt = pthread_stackseg_np(pthread_self(), &ss);
+
+  if (rslt != 0)
+    fatal1("pthread_stackseg_np failed with err = %d", rslt);
+
+  *bottom = (address)((char *)ss.ss_sp - ss.ss_size);
+  *size   = ss.ss_size;
+#elif defined(_ALLBSD_SOURCE)
+  pthread_attr_t attr;
+
+  int rslt = pthread_attr_init(&attr);
+
+  // JVM needs to know exact stack location, abort if it fails
+  if (rslt != 0)
+    fatal1("pthread_attr_init failed with err = %d", rslt);
+
+  rslt = pthread_attr_get_np(pthread_self(), &attr);
+
+  if (rslt != 0)
+    fatal1("pthread_attr_get_np failed with err = %d", rslt);
+
+  if (pthread_attr_getstackaddr(&attr, (void **)bottom) != 0 ||
+    pthread_attr_getstacksize(&attr, size) != 0) {
+    fatal("Can not locate current stack attributes!");
+  }
+
+  pthread_attr_destroy(&attr);
+#else
   if (os::Bsd::is_initial_thread()) {
      // initial thread needs special handling because pthread_getattr_np()
      // may return bogus value.
@@ -691,6 +952,7 @@
      pthread_attr_destroy(&attr);
 
   }
+#endif
   assert(os::current_stack_pointer() >= *bottom &&
          os::current_stack_pointer() < *bottom + *size, "just checking");
 }
@@ -719,46 +981,44 @@
   ucontext_t *uc = (ucontext_t*)context;
   st->print_cr("Registers:");
 #ifdef AMD64
-  st->print(  "RAX=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RAX]);
-  st->print(", RBX=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RBX]);
-  st->print(", RCX=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RCX]);
-  st->print(", RDX=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RDX]);
+  st->print(  "RAX=" INTPTR_FORMAT, uc->context_rax);
+  st->print(", RBX=" INTPTR_FORMAT, uc->context_rbx);
+  st->print(", RCX=" INTPTR_FORMAT, uc->context_rcx);
+  st->print(", RDX=" INTPTR_FORMAT, uc->context_rdx);
   st->cr();
-  st->print(  "RSP=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RSP]);
-  st->print(", RBP=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RBP]);
-  st->print(", RSI=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RSI]);
-  st->print(", RDI=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RDI]);
+  st->print(  "RSP=" INTPTR_FORMAT, uc->context_rsp);
+  st->print(", RBP=" INTPTR_FORMAT, uc->context_rbp);
+  st->print(", RSI=" INTPTR_FORMAT, uc->context_rsi);
+  st->print(", RDI=" INTPTR_FORMAT, uc->context_rdi);
   st->cr();
-  st->print(  "R8 =" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_R8]);
-  st->print(", R9 =" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_R9]);
-  st->print(", R10=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_R10]);
-  st->print(", R11=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_R11]);
+  st->print(  "R8 =" INTPTR_FORMAT, uc->context_r8);
+  st->print(", R9 =" INTPTR_FORMAT, uc->context_r9);
+  st->print(", R10=" INTPTR_FORMAT, uc->context_r10);
+  st->print(", R11=" INTPTR_FORMAT, uc->context_r11);
   st->cr();
-  st->print(  "R12=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_R12]);
-  st->print(", R13=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_R13]);
-  st->print(", R14=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_R14]);
-  st->print(", R15=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_R15]);
+  st->print(  "R12=" INTPTR_FORMAT, uc->context_r12);
+  st->print(", R13=" INTPTR_FORMAT, uc->context_r13);
+  st->print(", R14=" INTPTR_FORMAT, uc->context_r14);
+  st->print(", R15=" INTPTR_FORMAT, uc->context_r15);
   st->cr();
-  st->print(  "RIP=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_RIP]);
-  st->print(", EFL=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_EFL]);
-  st->print(", CSGSFS=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_CSGSFS]);
-  st->print(", ERR=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_ERR]);
+  st->print(  "RIP=" INTPTR_FORMAT, uc->context_rip);
+  st->print(", EFL=" INTPTR_FORMAT, uc->context_flags);
+  st->print(", ERR=" INTPTR_FORMAT, uc->context_err);
   st->cr();
-  st->print("  TRAPNO=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_TRAPNO]);
+  st->print("  TRAPNO=" INTPTR_FORMAT, uc->context_trapno);
 #else
-  st->print(  "EAX=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_EAX]);
-  st->print(", EBX=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_EBX]);
-  st->print(", ECX=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_ECX]);
-  st->print(", EDX=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_EDX]);
+  st->print(  "EAX=" INTPTR_FORMAT, uc->context_eax);
+  st->print(", EBX=" INTPTR_FORMAT, uc->context_ebx);
+  st->print(", ECX=" INTPTR_FORMAT, uc->context_ecx);
+  st->print(", EDX=" INTPTR_FORMAT, uc->context_edx);
   st->cr();
-  st->print(  "ESP=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_UESP]);
-  st->print(", EBP=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_EBP]);
-  st->print(", ESI=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_ESI]);
-  st->print(", EDI=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_EDI]);
+  st->print(  "ESP=" INTPTR_FORMAT, uc->context_esp);
+  st->print(", EBP=" INTPTR_FORMAT, uc->context_ebp);
+  st->print(", ESI=" INTPTR_FORMAT, uc->context_esi);
+  st->print(", EDI=" INTPTR_FORMAT, uc->context_edi);
   st->cr();
-  st->print(  "EIP=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_EIP]);
-  st->print(", CR2=" INTPTR_FORMAT, uc->uc_mcontext.cr2);
-  st->print(", EFLAGS=" INTPTR_FORMAT, uc->uc_mcontext.gregs[REG_EFL]);
+  st->print(  "EIP=" INTPTR_FORMAT, uc->context_eip);
+  st->print(", EFLAGS=" INTPTR_FORMAT, uc->context_eflags);
 #endif // AMD64
   st->cr();
   st->cr();
--- ./hotspot/src/os_cpu/bsd_x86/vm/threadLS_bsd_x86.hpp	2010-03-27 11:09:11.000000000 -0700
+++ ./hotspot/src/os_cpu/bsd_x86/vm/threadLS_bsd_x86.hpp	2009-06-06 16:54:01.000000000 -0700
@@ -27,8 +27,10 @@
 #ifndef AMD64
   // map stack pointer to thread pointer - see notes in threadLS_bsd_x86.cpp
   #define SP_BITLENGTH  32
+#ifndef PAGE_SHIFT
   #define PAGE_SHIFT    12
   #define PAGE_SIZE     (1UL << PAGE_SHIFT)
+#endif
   static Thread* _sp_map[1UL << (SP_BITLENGTH - PAGE_SHIFT)];
 #endif // !AMD64
 
--- ./hotspot/src/os_cpu/bsd_x86/vm/vmStructs_bsd_x86.hpp	2010-03-27 11:09:11.000000000 -0700
+++ ./hotspot/src/os_cpu/bsd_x86/vm/vmStructs_bsd_x86.hpp	2009-06-06 16:54:01.000000000 -0700
@@ -31,7 +31,7 @@
   /******************************/                                                                                                   \
   /* Threads (NOTE: incomplete) */                                                                                                   \
   /******************************/                                                                                                   \
-  nonstatic_field(OSThread,                      _thread_id,                                      pid_t)                             \
+  nonstatic_field(OSThread,                      _thread_id,                                      pthread_t)                             \
   nonstatic_field(OSThread,                      _pthread_id,                                     pthread_t)                         \
   /* This must be the last entry, and must be present */                                                                             \
   last_entry()
--- ./hotspot/src/os_cpu/bsd_zero/vm/atomic_bsd_zero.inline.hpp	2010-03-27 11:09:11.000000000 -0700
+++ ./hotspot/src/os_cpu/bsd_zero/vm/atomic_bsd_zero.inline.hpp	2009-12-20 19:41:24.000000000 -0800
@@ -23,136 +23,441 @@
  *
  */
 
-// Implementation of class atomic
-
-#ifdef M68K
+#include <sys/types.h>
+#ifdef __NetBSD__
+#include <sys/atomic.h>
+#elif __FreeBSD__
+
+#include <sys/types.h>
+#ifndef SPARC
+#include <machine/atomic.h>
+#else
 
 /*
- * __m68k_cmpxchg
+ * On FreeBSD/sparc64, <machine/atomic.h> pulls in <machine/cpufunc.h>
+ * which includes definitions which cause conflicts with various
+ * definitions within HotSpot source.  To avoid that, pull in those
+ * definitions verbatim instead of including the header.  Yuck.
+ */
+
+/*-
+ * Copyright (c) 1998 Doug Rabson.
+ * Copyright (c) 2001 Jake Burkholder.
+ * All rights reserved.
  *
- * Atomically store newval in *ptr if *ptr is equal to oldval for user space.
- * Returns newval on success and oldval if no exchange happened.
- * This implementation is processor specific and works on
- * 68020 68030 68040 and 68060.
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
  *
- * It will not work on ColdFire, 68000 and 68010 since they lack the CAS
- * instruction.
- * Using a kernelhelper would be better for arch complete implementation.
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
  *
  */
 
-static inline int __m68k_cmpxchg(int oldval, int newval, volatile int *ptr) {
-  int ret;
-  __asm __volatile ("cas%.l %0,%2,%1"
-                   : "=d" (ret), "+m" (*(ptr))
-                   : "d" (newval), "0" (oldval));
-  return ret;
-}
-
-/* Perform an atomic compare and swap: if the current value of `*PTR'
-   is OLDVAL, then write NEWVAL into `*PTR'.  Return the contents of
-   `*PTR' before the operation.*/
-static inline int m68k_compare_and_swap(volatile int *ptr,
-                                        int oldval,
-                                        int newval) {
-  for (;;) {
-      int prev = *ptr;
-      if (prev != oldval)
-        return prev;
-
-      if (__m68k_cmpxchg (prev, newval, ptr) == newval)
-        // Success.
-        return prev;
-
-      // We failed even though prev == oldval.  Try again.
-    }
-}
-
-/* Atomically add an int to memory.  */
-static inline int m68k_add_and_fetch(volatile int *ptr, int add_value) {
-  for (;;) {
-      // Loop until success.
-
-      int prev = *ptr;
-
-      if (__m68k_cmpxchg (prev, prev + add_value, ptr) == prev + add_value)
-        return prev + add_value;
-    }
-}
-
-/* Atomically write VALUE into `*PTR' and returns the previous
-   contents of `*PTR'.  */
-static inline int m68k_lock_test_and_set(volatile int *ptr, int newval) {
-  for (;;) {
-      // Loop until success.
-      int prev = *ptr;
-
-      if (__m68k_cmpxchg (prev, newval, ptr) == prev)
-        return prev;
-    }
-}
-#endif // M68K
+#include <machine/asi.h>
 
-#ifdef ARM
+/*
+ * Membar operand macros for use in other macros when # is a special
+ * character.  Keep these in sync with what the hardware expects.
+ */
+#define	M_LoadLoad	(0)
+#define	M_StoreLoad	(1)
+#define	M_LoadStore	(2)
+#define	M_StoreStore	(3)
+
+#define	CMASK_SHIFT	(4)
+#define	MMASK_SHIFT	(0)
+
+#define	CMASK_GEN(bit)	((1 << (bit)) << CMASK_SHIFT)
+#define	MMASK_GEN(bit)	((1 << (bit)) << MMASK_SHIFT)
+
+#define	LoadLoad	MMASK_GEN(M_LoadLoad)
+#define	StoreLoad	MMASK_GEN(M_StoreLoad)
+#define	LoadStore	MMASK_GEN(M_LoadStore)
+#define	StoreStore	MMASK_GEN(M_StoreStore)
+
+#define	casa(rs1, rs2, rd, asi) ({					\
+	u_int __rd = (uint32_t)(rd);					\
+	__asm __volatile("casa [%2] %3, %4, %0"				\
+	    : "+r" (__rd), "=m" (*rs1)					\
+	    : "r" (rs1), "n" (asi), "r" (rs2), "m" (*rs1));		\
+	__rd;								\
+})
+
+#define	casxa(rs1, rs2, rd, asi) ({					\
+	u_long __rd = (uint64_t)(rd);					\
+	__asm __volatile("casxa [%2] %3, %4, %0"			\
+	    : "+r" (__rd), "=m" (*rs1)					\
+	    : "r" (rs1), "n" (asi), "r" (rs2), "m" (*rs1));		\
+	__rd;								\
+})
+
+#define	membar(mask) do {						\
+	__asm __volatile("membar %0" : : "n" (mask) : "memory");	\
+} while (0)
+
+#ifdef _KERNEL
+#define	__ASI_ATOMIC	ASI_N
+#else
+#define	__ASI_ATOMIC	ASI_P
+#endif
+
+#define mb()	__asm__ __volatile__ ("membar #MemIssue": : :"memory")
+#define wmb()	mb()
+#define rmb()	mb()
 
 /*
- * __kernel_cmpxchg
+ * Various simple arithmetic on memory which is atomic in the presence
+ * of interrupts and multiple processors.  See atomic(9) for details.
+ * Note that efficient hardware support exists only for the 32 and 64
+ * bit variants; the 8 and 16 bit versions are not provided and should
+ * not be used in MI code.
+ *
+ * This implementation takes advantage of the fact that the sparc64
+ * cas instruction is both a load and a store.  The loop is often coded
+ * as follows:
  *
- * Atomically store newval in *ptr if *ptr is equal to oldval for user space.
- * Return zero if *ptr was changed or non-zero if no exchange happened.
- * The C flag is also set if *ptr was changed to allow for assembly
- * optimization in the calling code.
+ *	do {
+ *		expect = *p;
+ *		new = expect + 1;
+ *	} while (cas(p, expect, new) != expect);
  *
+ * which performs an unnnecessary load on each iteration that the cas
+ * operation fails.  Modified as follows:
+ *
+ *	expect = *p;
+ *	for (;;) {
+ *		new = expect + 1;
+ *		result = cas(p, expect, new);
+ *		if (result == expect)
+ *			break;
+ *		expect = result;
+ *	}
+ *
+ * the return value of cas is used to avoid the extra reload.
+ *
+ * The memory barriers provided by the acq and rel variants are intended
+ * to be sufficient for use of relaxed memory ordering.  Due to the
+ * suggested assembly syntax of the membar operands containing a #
+ * character, they cannot be used in macros.  The cmask and mmask bits
+ * are hard coded in machine/cpufunc.h and used here through macros.
+ * Hopefully sun will choose not to change the bit numbers.
  */
 
-typedef int (__kernel_cmpxchg_t)(int oldval, int newval, volatile int *ptr);
-#define __kernel_cmpxchg (*(__kernel_cmpxchg_t *) 0xffff0fc0)
-
-
-
-/* Perform an atomic compare and swap: if the current value of `*PTR'
-   is OLDVAL, then write NEWVAL into `*PTR'.  Return the contents of
-   `*PTR' before the operation.*/
-static inline int arm_compare_and_swap(volatile int *ptr,
-                                       int oldval,
-                                       int newval) {
-  for (;;) {
-      int prev = *ptr;
-      if (prev != oldval)
-        return prev;
-
-      if (__kernel_cmpxchg (prev, newval, ptr) == 0)
-        // Success.
-        return prev;
-
-      // We failed even though prev == oldval.  Try again.
-    }
-}
+#define	itype(sz)	uint ## sz ## _t
 
-/* Atomically add an int to memory.  */
-static inline int arm_add_and_fetch(volatile int *ptr, int add_value) {
-  for (;;) {
-      // Loop until a __kernel_cmpxchg succeeds.
+#define	atomic_cas_32(p, e, s)	casa(p, e, s, __ASI_ATOMIC)
+#define	atomic_cas_64(p, e, s)	casxa(p, e, s, __ASI_ATOMIC)
 
-      int prev = *ptr;
+#define	atomic_cas(p, e, s, sz)						\
+	atomic_cas_ ## sz(p, e, s)
 
-      if (__kernel_cmpxchg (prev, prev + add_value, ptr) == 0)
-        return prev + add_value;
-    }
+#define	atomic_cas_acq(p, e, s, sz) ({					\
+	itype(sz) v;							\
+	v = atomic_cas(p, e, s, sz);					\
+	membar(LoadLoad | LoadStore);					\
+	v;								\
+})
+
+#define	atomic_cas_rel(p, e, s, sz) ({					\
+	itype(sz) v;							\
+	membar(LoadStore | StoreStore);					\
+	v = atomic_cas(p, e, s, sz);					\
+	v;								\
+})
+
+#define	atomic_op(p, op, v, sz) ({					\
+	itype(sz) e, r, s;						\
+	for (e = *(volatile itype(sz) *)p;; e = r) {			\
+		s = e op v;						\
+		r = atomic_cas_ ## sz(p, e, s);				\
+		if (r == e)						\
+			break;						\
+	}								\
+	e;								\
+})
+
+#define	atomic_op_acq(p, op, v, sz) ({					\
+	itype(sz) t;							\
+	t = atomic_op(p, op, v, sz);					\
+	membar(LoadLoad | LoadStore);					\
+	t;								\
+})
+
+#define	atomic_op_rel(p, op, v, sz) ({					\
+	itype(sz) t;							\
+	membar(LoadStore | StoreStore);					\
+	t = atomic_op(p, op, v, sz);					\
+	t;								\
+})
+
+#define	atomic_load(p, sz)						\
+	atomic_cas(p, 0, 0, sz)
+
+#define	atomic_load_acq(p, sz) ({					\
+	itype(sz) v;							\
+	v = atomic_load(p, sz);						\
+	membar(LoadLoad | LoadStore);					\
+	v;								\
+})
+
+#define	atomic_load_clear(p, sz) ({					\
+	itype(sz) e, r;							\
+	for (e = *(volatile itype(sz) *)p;; e = r) {			\
+		r = atomic_cas(p, e, 0, sz);				\
+		if (r == e)						\
+			break;						\
+	}								\
+	e;								\
+})
+
+#define	atomic_store(p, v, sz) do {					\
+	itype(sz) e, r;							\
+	for (e = *(volatile itype(sz) *)p;; e = r) {			\
+		r = atomic_cas(p, e, v, sz);				\
+		if (r == e)						\
+			break;						\
+	}								\
+} while (0)
+
+#define	atomic_store_rel(p, v, sz) do {					\
+	membar(LoadStore | StoreStore);					\
+	atomic_store(p, v, sz);						\
+} while (0)
+
+#define	ATOMIC_GEN(name, ptype, vtype, atype, sz)			\
+									\
+static __inline vtype							\
+atomic_add_ ## name(volatile ptype p, atype v)				\
+{									\
+	return ((vtype)atomic_op(p, +, v, sz));				\
+}									\
+static __inline vtype							\
+atomic_add_acq_ ## name(volatile ptype p, atype v)			\
+{									\
+	return ((vtype)atomic_op_acq(p, +, v, sz));			\
+}									\
+static __inline vtype							\
+atomic_add_rel_ ## name(volatile ptype p, atype v)			\
+{									\
+	return ((vtype)atomic_op_rel(p, +, v, sz));			\
+}									\
+									\
+static __inline int							\
+atomic_cmpset_ ## name(volatile ptype p, vtype e, vtype s)		\
+{									\
+	return (((vtype)atomic_cas(p, e, s, sz)) == e);			\
+}									\
+static __inline int							\
+atomic_cmpset_acq_ ## name(volatile ptype p, vtype e, vtype s)		\
+{									\
+	return (((vtype)atomic_cas_acq(p, e, s, sz)) == e);		\
+}									\
+static __inline int							\
+atomic_cmpset_rel_ ## name(volatile ptype p, vtype e, vtype s)		\
+{									\
+	return (((vtype)atomic_cas_rel(p, e, s, sz)) == e);		\
+}									\
+									\
+static __inline vtype							\
+atomic_load_ ## name(volatile ptype p)					\
+{									\
+	return ((vtype)atomic_cas(p, 0, 0, sz));			\
+}									\
+static __inline vtype							\
+atomic_load_acq_ ## name(volatile ptype p)				\
+{									\
+	return ((vtype)atomic_cas_acq(p, 0, 0, sz));			\
+}									\
+									\
+static __inline void							\
+atomic_store_ ## name(volatile ptype p, vtype v)			\
+{									\
+	atomic_store(p, v, sz);						\
+}									\
+static __inline void							\
+atomic_store_rel_ ## name(volatile ptype p, vtype v)			\
+{									\
+	atomic_store_rel(p, v, sz);					\
+}
+
+ATOMIC_GEN(int, u_int *, u_int, u_int, 32);
+ATOMIC_GEN(32, uint32_t *, uint32_t, uint32_t, 32);
+
+ATOMIC_GEN(long, u_long *, u_long, u_long, 64);
+ATOMIC_GEN(64, uint64_t *, uint64_t, uint64_t, 64);
+
+ATOMIC_GEN(ptr, uintptr_t *, uintptr_t, uintptr_t, 64);
+
+#define	atomic_fetchadd_int	atomic_add_int
+#define	atomic_fetchadd_32	atomic_add_32
+#define	atomic_fetchadd_long	atomic_add_long
+
+#undef ATOMIC_GEN
+#undef atomic_cas
+#undef atomic_cas_acq
+#undef atomic_cas_rel
+#undef atomic_op
+#undef atomic_op_acq
+#undef atomic_op_rel
+#undef atomic_load_acq
+#undef atomic_store_rel
+#undef atomic_load_clear
+#endif
+
+static __inline __attribute__((__always_inline__))
+unsigned int atomic_add_int_nv(volatile unsigned int* dest, unsigned int add_value)
+{
+  atomic_add_acq_int(dest, add_value);
+  return *dest;
+}
+
+static __inline __attribute__((__always_inline__))
+uintptr_t atomic_add_ptr_nv(volatile intptr_t* dest, intptr_t add_value)
+{
+  atomic_add_acq_ptr((volatile uintptr_t*) dest, (uintptr_t) add_value);
+  return *((volatile uintptr_t*) dest);
+}
+
+static __inline __attribute__((__always_inline__))
+unsigned int
+atomic_swap_uint(volatile unsigned int *dest, unsigned int exchange_value)
+{
+  jint prev = *dest;
+  atomic_store_rel_int(dest, exchange_value);
+  return prev;
+}
+
+static __inline __attribute__((__always_inline__))
+void *
+atomic_swap_ptr(volatile void *dest, void *exchange_value)
+{
+  void *prev = *(void **)dest;
+  atomic_store_rel_ptr((volatile uintptr_t*) dest, (uintptr_t) exchange_value);
+  return prev;
+}
+
+static __inline __attribute__((__always_inline__))
+unsigned int
+atomic_cas_uint(volatile unsigned int *dest, unsigned int compare_value,
+  unsigned int exchange_value)
+{
+  unsigned int prev = *dest;
+  atomic_cmpset_acq_int(dest, compare_value, exchange_value);
+  return prev;
+}
+
+static __inline __attribute__((__always_inline__))
+unsigned long
+atomic_cas_ulong(volatile unsigned long *dest, unsigned long compare_value,
+  unsigned long exchange_value)
+{
+  unsigned long prev = *dest;
+  atomic_cmpset_acq_long(dest, compare_value, exchange_value);
+  return prev;
+}
+
+static __inline __attribute__((__always_inline__))
+void *
+atomic_cas_ptr(volatile void *dest, void *compare_value, void *exchange_value)
+{
+  void *prev = *(void **)dest;
+  atomic_cmpset_acq_ptr((volatile uintptr_t*) dest, (uintptr_t) compare_value, (uintptr_t) exchange_value);
+  return prev;
+}
+
+#elif defined(__APPLE__)
+
+#include <libkern/OSAtomic.h>
+
+static __inline __attribute__((__always_inline__))
+unsigned int
+atomic_add_int_nv(volatile unsigned int *target, int delta) {
+  return (unsigned int) OSAtomicAdd32Barrier(delta, (volatile int32_t *) target);
+}
+
+static __inline __attribute__((__always_inline__))
+void *
+atomic_add_ptr_nv(volatile void *target, ssize_t delta) {
+#ifdef __LP64__
+  return (void *) OSAtomicAdd64Barrier(delta, (volatile int64_t *) target);
+#else
+  return (void *) OSAtomicAdd32Barrier(delta, (volatile int32_t *) target);
+#endif
+}
+
+
+static __inline __attribute__((__always_inline__))
+unsigned int
+atomic_swap_uint(volatile unsigned int *dest, unsigned int exchange_value)
+{
+  /* No xchg support in OSAtomic */
+  unsigned int prev;
+  do {
+    prev = *dest;
+  } while (!OSAtomicCompareAndSwapIntBarrier((int) prev, (int) exchange_value, (volatile int *) dest));
+
+  return prev;
+}
+
+static __inline __attribute__((__always_inline__))
+void *
+atomic_swap_ptr(volatile void *dest, void *exchange_value)
+{
+  /* No xchg support in OSAtomic */
+  void *prev;
+  do {
+    prev = *((void * volatile *) dest);
+  } while (!OSAtomicCompareAndSwapPtrBarrier(prev, exchange_value, (void * volatile *) dest));
+
+  return prev;
+}
+
+static __inline __attribute__((__always_inline__))
+unsigned int
+atomic_cas_uint(volatile unsigned int *dest, unsigned int compare_value,
+  unsigned int exchange_value)
+{
+  unsigned int prev = *dest;
+  OSAtomicCompareAndSwapIntBarrier(compare_value, exchange_value, (volatile int *) dest);
+  return prev;
+}
+
+static __inline __attribute__((__always_inline__))
+unsigned long
+atomic_cas_ulong(volatile unsigned long *dest, unsigned long compare_value,
+  unsigned long exchange_value)
+{
+  unsigned long prev = *dest;
+  OSAtomicCompareAndSwapLongBarrier(compare_value, exchange_value, (volatile long *) dest);
+  return prev;
+}
+
+static __inline __attribute__((__always_inline__))
+void *
+atomic_cas_ptr(volatile void *dest, void *compare_value, void *exchange_value)
+{
+  void *prev = *(void **)dest;
+  OSAtomicCompareAndSwapPtrBarrier(compare_value, exchange_value, (void * volatile *) dest);
+  return prev;
 }
 
-/* Atomically write VALUE into `*PTR' and returns the previous
-   contents of `*PTR'.  */
-static inline int arm_lock_test_and_set(volatile int *ptr, int newval) {
-  for (;;) {
-      // Loop until a __kernel_cmpxchg succeeds.
-      int prev = *ptr;
 
-      if (__kernel_cmpxchg (prev, newval, ptr) == 0)
-        return prev;
-    }
-}
-#endif // ARM
+#endif
 
 inline void Atomic::store(jint store_value, volatile jint* dest) {
   *dest = store_value;
@@ -163,27 +468,11 @@
 }
 
 inline jint Atomic::add(jint add_value, volatile jint* dest) {
-#ifdef ARM
-  return arm_add_and_fetch(dest, add_value);
-#else
-#ifdef M68K
-  return m68k_add_and_fetch(dest, add_value);
-#else
-  return __sync_add_and_fetch(dest, add_value);
-#endif // M68K
-#endif // ARM
+  return (jint)atomic_add_int_nv((volatile unsigned int*) dest, add_value);
 }
 
 inline intptr_t Atomic::add_ptr(intptr_t add_value, volatile intptr_t* dest) {
-#ifdef ARM
-  return arm_add_and_fetch(dest, add_value);
-#else
-#ifdef M68K
-  return m68k_add_and_fetch(dest, add_value);
-#else
-  return __sync_add_and_fetch(dest, add_value);
-#endif // M68K
-#endif // ARM
+  return (intptr_t)atomic_add_ptr_nv(dest, add_value);
 }
 
 inline void* Atomic::add_ptr(intptr_t add_value, volatile void* dest) {
@@ -215,79 +504,41 @@
 }
 
 inline jint Atomic::xchg(jint exchange_value, volatile jint* dest) {
-#ifdef ARM
-  return arm_lock_test_and_set(dest, exchange_value);
-#else
-#ifdef M68K
-  return m68k_lock_test_and_set(dest, exchange_value);
-#else
-  // __sync_lock_test_and_set is a bizarrely named atomic exchange
-  // operation.  Note that some platforms only support this with the
-  // limitation that the only valid value to store is the immediate
-  // constant 1.  There is a test for this in JNI_CreateJavaVM().
-  return __sync_lock_test_and_set (dest, exchange_value);
-#endif // M68K
-#endif // ARM
+  return (jint)atomic_swap_uint((volatile u_int *)dest, (u_int)exchange_value);
 }
 
 inline intptr_t Atomic::xchg_ptr(intptr_t exchange_value,
                                  volatile intptr_t* dest) {
-#ifdef ARM
-  return arm_lock_test_and_set(dest, exchange_value);
-#else
-#ifdef M68K
-  return m68k_lock_test_and_set(dest, exchange_value);
-#else
-  return __sync_lock_test_and_set (dest, exchange_value);
-#endif // M68K
-#endif // ARM
+  return (intptr_t)atomic_swap_ptr((volatile void *)dest,
+    (void *)exchange_value);
 }
 
 inline void* Atomic::xchg_ptr(void* exchange_value, volatile void* dest) {
-  return (void *) xchg_ptr((intptr_t) exchange_value,
-                           (volatile intptr_t*) dest);
+  return atomic_swap_ptr(dest, exchange_value);
 }
 
 inline jint Atomic::cmpxchg(jint exchange_value,
                             volatile jint* dest,
                             jint compare_value) {
-#ifdef ARM
-  return arm_compare_and_swap(dest, compare_value, exchange_value);
-#else
-#ifdef M68K
-  return m68k_compare_and_swap(dest, compare_value, exchange_value);
-#else
-  return __sync_val_compare_and_swap(dest, compare_value, exchange_value);
-#endif // M68K
-#endif // ARM
+  return atomic_cas_uint((volatile u_int *)dest, compare_value, exchange_value);
 }
 
 inline jlong Atomic::cmpxchg(jlong exchange_value,
                              volatile jlong* dest,
                              jlong compare_value) {
-
-  return __sync_val_compare_and_swap(dest, compare_value, exchange_value);
+  return atomic_cas_ulong((volatile u_long *)dest, compare_value,
+    exchange_value);
 }
 
 inline intptr_t Atomic::cmpxchg_ptr(intptr_t exchange_value,
                                     volatile intptr_t* dest,
                                     intptr_t compare_value) {
-#ifdef ARM
-  return arm_compare_and_swap(dest, compare_value, exchange_value);
-#else
-#ifdef M68K
-  return m68k_compare_and_swap(dest, compare_value, exchange_value);
-#else
-  return __sync_val_compare_and_swap(dest, compare_value, exchange_value);
-#endif // M68K
-#endif // ARM
+  return (intptr_t)atomic_cas_ptr((volatile void *)dest, (void *)compare_value,
+      (void *)exchange_value);
 }
 
 inline void* Atomic::cmpxchg_ptr(void* exchange_value,
                                  volatile void* dest,
                                  void* compare_value) {
-
-  return (void *) cmpxchg_ptr((intptr_t) exchange_value,
-                              (volatile intptr_t*) dest,
-                              (intptr_t) compare_value);
+  return atomic_cas_ptr((volatile void *)dest, compare_value, exchange_value);
 }
--- ./hotspot/src/os_cpu/bsd_zero/vm/bytes_bsd_zero.inline.hpp	2010-03-27 11:09:11.000000000 -0700
+++ ./hotspot/src/os_cpu/bsd_zero/vm/bytes_bsd_zero.inline.hpp	2009-12-20 19:41:24.000000000 -0800
@@ -25,16 +25,23 @@
 // Efficient swapping of data bytes from Java byte
 // ordering to native byte ordering and vice versa.
 
-#include <byteswap.h>
+#ifdef __APPLE__
+#include <libkern/OSByteOrder.h>
+#define bswap16(x) OSSwapInt16(x)
+#define bswap32(x) OSSwapInt32(x)
+#define bswap64(x) OSSwapInt64(x)
+#else
+#  include <sys/endian.h>
+#endif
 
 inline u2 Bytes::swap_u2(u2 x) {
-  return bswap_16(x);
+  return bswap16(x);
 }
 
 inline u4 Bytes::swap_u4(u4 x) {
-  return bswap_32(x);
+  return bswap32(x);
 }
 
 inline u8 Bytes::swap_u8(u8 x) {
-  return bswap_64(x);
+  return bswap64(x);
 }
--- ./hotspot/src/os_cpu/bsd_zero/vm/orderAccess_bsd_zero.inline.hpp	2010-03-27 11:09:11.000000000 -0700
+++ ./hotspot/src/os_cpu/bsd_zero/vm/orderAccess_bsd_zero.inline.hpp	2009-12-20 19:41:24.000000000 -0800
@@ -40,7 +40,12 @@
 
 #else // ARM
 
+#ifdef __APPLE__
+#include <libkern/OSAtomic.h>
+#define FULL_MEM_BARRIER OSMemoryBarrier()
+#else
 #define FULL_MEM_BARRIER __sync_synchronize()
+#endif // __APPLE__
 
 #ifdef PPC
 
--- ./hotspot/src/os_cpu/bsd_zero/vm/os_bsd_zero.cpp	2010-03-27 11:09:11.000000000 -0700
+++ ./hotspot/src/os_cpu/bsd_zero/vm/os_bsd_zero.cpp	2010-01-30 13:26:37.000000000 -0800
@@ -23,6 +23,10 @@
  *
  */
 
+#if defined(_ALLBSD_SOURCE) && !defined(__APPLE__) && !defined(__NetBSD__)
+# include <pthread_np.h> /* For pthread_attr_get_np */
+#endif
+
 // do not include precompiled header file
 #include "incls/_os_bsd_zero.cpp.incl"
 
@@ -145,6 +149,7 @@
           thread->disable_stack_red_zone();
           ShouldNotCallThis();
         }
+#ifndef _ALLBSD_SOURCE
         else {
           // Accessing stack address below sp may cause SEGV if
           // current thread has MAP_GROWSDOWN stack. This should
@@ -163,6 +168,7 @@
             fatal("recursive segv. expanding stack.");
           }
         }
+#endif
       }
     }
 
@@ -230,6 +236,7 @@
   // Nothing to do
 }
 
+#ifndef _ALLBSD_SOURCE
 int os::Bsd::get_fpu_control_word() {
   ShouldNotCallThis();
 }
@@ -237,6 +244,7 @@
 void os::Bsd::set_fpu_control_word(int fpu) {
   ShouldNotCallThis();
 }
+#endif
 
 bool os::is_allocatable(size_t bytes) {
 #ifdef _LP64
@@ -281,6 +289,48 @@
 }
 
 static void current_stack_region(address *bottom, size_t *size) {
+  address stack_bottom;
+  address stack_top;
+  size_t stack_bytes;
+
+#ifdef __APPLE__
+  pthread_t self = pthread_self();
+  stack_top = (address) pthread_get_stackaddr_np(self);
+  stack_bytes = pthread_get_stacksize_np(self);
+  stack_bottom = stack_top - stack_bytes;
+#elif defined(__OpenBSD__)
+  stack_t ss;
+  int rslt = pthread_stackseg_np(pthread_self(), &ss);
+
+  if (rslt != 0)
+    fatal1("pthread_stackseg_np failed with err = %d", rslt);
+
+  stack_top = (address) ss.ss_sp;
+  stack_bytes  = ss.ss_size;
+  stack_bottom = stacktop - stack_bytes;
+#elif defined(_ALLBSD_SOURCE)
+  pthread_attr_t attr;
+
+  int rslt = pthread_attr_init(&attr);
+
+  // JVM needs to know exact stack location, abort if it fails
+  if (rslt != 0)
+    fatal1("pthread_attr_init failed with err = %d", rslt);
+
+  rslt = pthread_attr_get_np(pthread_self(), &attr);
+
+  if (rslt != 0)
+    fatal1("pthread_attr_get_np failed with err = %d", rslt);
+
+  if (pthread_attr_getstackaddr(&attr, (void **) &stack_bottom) != 0 ||
+      pthread_attr_getstacksize(&attr, &stack_bytes) != 0) {
+    fatal("Can not locate current stack attributes!");
+  }
+
+  pthread_attr_destroy(&attr);
+
+  stack_top = stack_bottom + stack_bytes;
+#else /* Linux */
   pthread_attr_t attr;
   int res = pthread_getattr_np(pthread_self(), &attr);
   if (res != 0) {
@@ -292,13 +342,11 @@
     }
   }
 
-  address stack_bottom;
-  size_t stack_bytes;
   res = pthread_attr_getstack(&attr, (void **) &stack_bottom, &stack_bytes);
   if (res != 0) {
     fatal1("pthread_attr_getstack failed with errno = %d", res);
   }
-  address stack_top = stack_bottom + stack_bytes;
+  stack_top = stack_bottom + stack_bytes;
 
   // The block of memory returned by pthread_attr_getstack() includes
   // guard pages where present.  We need to trim these off.
@@ -340,6 +388,7 @@
 
     stack_bottom = stack_top - stack_bytes;
   }
+#endif
 
   assert(os::current_stack_pointer() >= stack_bottom, "should do");
   assert(os::current_stack_pointer() < stack_top, "should do");
--- ./hotspot/src/share/vm/adlc/adlc.hpp	2010-03-18 01:41:40.000000000 -0700
+++ ./hotspot/src/share/vm/adlc/adlc.hpp	2009-09-07 10:57:21.000000000 -0700
@@ -69,9 +69,9 @@
 #endif
 #endif // _WIN32
 
-#ifdef LINUX
+#if defined(LINUX) || defined(_ALLBSD_SOURCE)
   #include <inttypes.h>
-#endif // LINUX
+#endif // LINUX || _ALLBSD_SOURCE
 
 // Macros
 #define uint32 unsigned int
--- ./hotspot/src/share/vm/classfile/javaClasses.cpp	2010-03-18 01:41:41.000000000 -0700
+++ ./hotspot/src/share/vm/classfile/javaClasses.cpp	2010-03-08 21:37:50.000000000 -0800
@@ -952,7 +952,7 @@
     }
     nmethod* nm = method->code();
     if (WizardMode && nm != NULL) {
-      sprintf(buf + (int)strlen(buf), "(nmethod " PTR_FORMAT ")", (intptr_t)nm);
+      sprintf(buf + (int)strlen(buf), "(nmethod " INTPTR_FORMAT ")", (intptr_t)nm);
     }
   }
 
--- ./hotspot/src/share/vm/interpreter/bytecodeTracer.cpp	2010-03-18 01:41:42.000000000 -0700
+++ ./hotspot/src/share/vm/interpreter/bytecodeTracer.cpp	2010-01-22 10:54:50.000000000 -0800
@@ -77,7 +77,7 @@
       // the incoming method.  We could lose a line of trace output.
       // This is acceptable in a debug-only feature.
       st->cr();
-      st->print("[%d] ", (int) Thread::current()->osthread()->thread_id());
+      st->print("[%ld] ", (long) Thread::current()->osthread()->thread_id());
       method->print_name(st);
       st->cr();
       _current_method = method();
@@ -90,7 +90,7 @@
       code = Bytecodes::code_at(bcp);
     }
     int bci = bcp - method->code_base();
-    st->print("[%d] ", (int) Thread::current()->osthread()->thread_id());
+    st->print("[%ld] ", (long) Thread::current()->osthread()->thread_id());
     if (Verbose) {
       st->print("%8d  %4d  " INTPTR_FORMAT " " INTPTR_FORMAT " %s",
            BytecodeCounter::counter_value(), bci, tos, tos2, Bytecodes::name(code));
--- ./hotspot/src/share/vm/prims/forte.cpp	2010-03-18 01:41:43.000000000 -0700
+++ ./hotspot/src/share/vm/prims/forte.cpp	2009-06-06 16:54:08.000000000 -0700
@@ -626,6 +626,11 @@
 // Method to let libcollector know about a dynamically loaded function.
 // Because it is weakly bound, the calls become NOP's when the library
 // isn't present.
+#ifdef __APPLE__
+// XXXDARWIN: Link errors occur even when __attribute__((weak_import))
+// is added
+#define collector_func_load(x0,x1,x2,x3,x4,x5,x6) (0)
+#else
 void    collector_func_load(char* name,
                             void* null_argument_1,
                             void* null_argument_2,
@@ -636,6 +641,7 @@
 #pragma weak collector_func_load
 #define collector_func_load(x0,x1,x2,x3,x4,x5,x6) \
         ( collector_func_load ? collector_func_load(x0,x1,x2,x3,x4,x5,x6),0 : 0 )
+#endif // __APPLE__
 #endif // !_WINDOWS
 
 } // end extern "C"
--- ./hotspot/src/share/vm/runtime/globals.hpp	2010-03-18 01:41:44.000000000 -0700
+++ ./hotspot/src/share/vm/runtime/globals.hpp	2010-02-15 08:08:24.000000000 -0800
@@ -324,7 +324,7 @@
   /* UseMembar is theoretically a temp flag used for memory barrier         \
    * removal testing.  It was supposed to be removed before FCS but has     \
    * been re-added (see 6401008) */                                         \
-  product(bool, UseMembar, false,                                           \
+  product(bool, UseMembar, true,                                            \
           "(Unstable) Issues membars on thread state transitions")          \
                                                                             \
   diagnostic(bool, UnlockDiagnosticVMOptions, trueInDebug,                  \
--- ./hotspot/src/share/vm/runtime/os.cpp	2010-03-18 01:41:44.000000000 -0700
+++ ./hotspot/src/share/vm/runtime/os.cpp	2010-01-22 10:54:51.000000000 -0800
@@ -79,7 +79,11 @@
     assert(false, "Failed localtime_pd");
     return NULL;
   }
+#if defined(_ALLBSD_SOURCE)
+  const time_t zone = (time_t) time_struct.tm_gmtoff;
+#else
   const time_t zone = timezone;
+#endif
 
   // If daylight savings time is in effect,
   // we are 1 hour East of our time zone
--- ./hotspot/src/share/vm/runtime/vm_version.cpp	2010-03-18 01:41:44.000000000 -0700
+++ ./hotspot/src/share/vm/runtime/vm_version.cpp	2009-10-31 08:51:25.000000000 -0700
@@ -144,7 +144,8 @@
 
 #define OS       LINUX_ONLY("linux")             \
                  WINDOWS_ONLY("windows")         \
-                 SOLARIS_ONLY("solaris")
+                 SOLARIS_ONLY("solaris")         \
+                 BSD_ONLY("bsd")
 
 #ifdef ZERO
 #define CPU      ZERO_LIBARCH
--- ./hotspot/src/share/vm/utilities/globalDefinitions_gcc.hpp	2010-03-18 01:41:44.000000000 -0700
+++ ./hotspot/src/share/vm/utilities/globalDefinitions_gcc.hpp	2009-06-06 16:54:10.000000000 -0700
@@ -71,12 +71,25 @@
 # include <sys/procfs.h>
 # endif
 
-#ifdef LINUX
+#if defined(LINUX) || defined(_ALLBSD_SOURCE)
 #include <inttypes.h>
 #include <signal.h>
+#ifndef __OpenBSD__
 #include <ucontext.h>
+#endif
+#ifdef __APPLE__
+  #include <AvailabilityMacros.h>
+  #if (MAC_OS_X_VERSION_MAX_ALLOWED <= MAC_OS_X_VERSION_10_4)
+    // Mac OS X 10.4 defines EFL_AC and EFL_ID,
+    // which conflict with hotspot variable names.
+    //
+    // This has been fixed in Mac OS X 10.5.
+    #undef EFL_AC
+    #undef EFL_ID
+  #endif
+#endif
 #include <sys/time.h>
-#endif // LINUX
+#endif // LINUX || _ALLBSD_SOURCE
 
 // 4810578: varargs unsafe on 32-bit integer/64-bit pointer architectures
 // When __cplusplus is defined, NULL is defined as 0 (32-bit constant) in
@@ -112,7 +125,7 @@
 // pointer is stored as integer value.  On some platforms, sizeof(intptr_t) >
 // sizeof(void*), so here we want something which is integer type, but has the
 // same size as a pointer.
-#ifdef LINUX
+#ifdef __GNUC__
   #ifdef _LP64
     #define NULL_WORD  0L
   #else
@@ -124,7 +137,7 @@
   #define NULL_WORD  NULL
 #endif
 
-#ifndef LINUX
+#if !defined(LINUX) && !defined(_ALLBSD_SOURCE)
 // Compiler-specific primitive types
 typedef unsigned short     uint16_t;
 #ifndef _UINT32_T
@@ -144,7 +157,7 @@
 // prior definition of intptr_t, and add "&& !defined(XXX)" above.
 #endif // _SYS_INT_TYPES_H
 
-#endif // !LINUX
+#endif // !LINUX && !_ALLBSD_SOURCE
 
 // Additional Java basic types
 
@@ -228,7 +241,9 @@
 inline int g_isnan(float  f) { return isnand(f); }
 #endif
 inline int g_isnan(double f) { return isnand(f); }
-#elif LINUX
+#elif defined(__APPLE__)
+inline int g_isnan(double f) { return isnan(f); }
+#elif defined(LINUX) || defined(_ALLBSD_SOURCE)
 inline int g_isnan(float  f) { return isnanf(f); }
 inline int g_isnan(double f) { return isnan(f); }
 #else
--- ./hotspot/src/share/vm/utilities/macros.hpp	2010-03-18 01:41:44.000000000 -0700
+++ ./hotspot/src/share/vm/utilities/macros.hpp	2009-09-07 10:57:23.000000000 -0700
@@ -148,6 +148,14 @@
 #define NOT_WINDOWS(code) code
 #endif
 
+#if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__APPLE__)
+#define BSD_ONLY(code) code
+#define NOT_BSD(code)
+#else
+#define BSD_ONLY(code)
+#define NOT_BSD(code) code
+#endif
+
 #if defined(IA32) || defined(AMD64)
 #define X86
 #define X86_ONLY(code) code
--- ./hotspot/src/share/vm/utilities/ostream.cpp	2010-03-18 01:41:44.000000000 -0700
+++ ./hotspot/src/share/vm/utilities/ostream.cpp	2009-06-06 16:54:10.000000000 -0700
@@ -827,7 +827,7 @@
 
 #ifndef PRODUCT
 
-#if defined(SOLARIS) || defined(LINUX)
+#if defined(SOLARIS) || defined(LINUX) || defined(_ALLBSD_SOURCE)
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <netinet/in.h>
--- ./hotspot/src/share/vm/utilities/vmError.cpp	2010-03-18 01:41:44.000000000 -0700
+++ ./hotspot/src/share/vm/utilities/vmError.cpp	2010-01-16 12:50:23.000000000 -0800
@@ -31,13 +31,18 @@
   "JAVA_HOME", "JRE_HOME", "JAVA_TOOL_OPTIONS", "_JAVA_OPTIONS", "CLASSPATH",
   "JAVA_COMPILER", "PATH", "USERNAME",
 
-  // Env variables that are defined on Solaris/Linux
+  // Env variables that are defined on Solaris/Linux/BSD
   "LD_LIBRARY_PATH", "LD_PRELOAD", "SHELL", "DISPLAY",
   "HOSTTYPE", "OSTYPE", "ARCH", "MACHTYPE",
 
   // defined on Linux
   "LD_ASSUME_KERNEL", "_JAVA_SR_SIGNUM",
 
+  // defined on Darwin
+  "DYLD_LIBRARY_PATH", "DYLD_FALLBACK_LIBRARY_PATH",
+  "DYLD_FRAMEWORK_PATH", "DYLD_FALLBACK_FRAMEWORK_PATH",
+  "DYLD_INSERT_LIBRARIES",
+
   // defined on Windows
   "OS", "PROCESSOR_IDENTIFIER", "_ALT_JAVA_HOME_DIR",
 
@@ -851,7 +856,7 @@
     const char* ptr = OnError;
     while ((cmd = next_OnError_command(buffer, sizeof(buffer), &ptr)) != NULL){
       out.print_raw   ("#   Executing ");
-#if defined(LINUX)
+#if defined(LINUX) || defined(_ALLBSD_SOURCE)
       out.print_raw   ("/bin/sh -c ");
 #elif defined(SOLARIS)
       out.print_raw   ("/usr/bin/sh -c ");
--- ./hotspot/test/Makefile	2010-03-18 01:41:44.000000000 -0700
+++ ./hotspot/test/Makefile	2009-06-28 17:58:24.000000000 -0700
@@ -44,6 +44,22 @@
     ARCH = i586
   endif
 endif
+ifeq ($(OSNAME), Darwin)
+  PLATFORM = bsd
+  SLASH_JAVA = /java
+  ARCH = $(shell uname -m)
+  ifeq ($(ARCH), i386)
+    ARCH = i586
+  endif
+endif
+ifeq ($(findstring BSD,$(OSNAME)), BSD)
+  PLATFORM = bsd
+  SLASH_JAVA = /java
+  ARCH = $(shell uname -m)
+  ifeq ($(ARCH), i386)
+    ARCH = i586
+  endif
+endif
 ifeq ($(OSNAME), Windows_NT)
   PLATFORM = windows
   SLASH_JAVA = J:
@@ -78,7 +94,7 @@
 TEST_ROOT := $(shell pwd)
 
 # Root of all test results
-ABS_BUILD_ROOT = $(TEST_ROOT)/../build/$(PLATFORM)-$(ARCH)
+ABS_BUILD_ROOT = $(TEST_ROOT)/../../build/$(PLATFORM)-$(ARCH)
 ABS_TEST_OUTPUT_DIR = $(ABS_BUILD_ROOT)/testoutput
 
 # Expect JPRT to set PRODUCT_HOME (the product or jdk in this case to test)
@@ -139,7 +155,7 @@
 endif
 
 # Expect JPRT to set TESTDIRS to the jtreg test dirs
-JTREG_TESTDIRS = demo/jvmti/gctest demo/jvmti/hprof
+JTREG_TESTDIRS = compiler
 ifdef TESTDIRS
   JTREG_TESTDIRS = $(TESTDIRS)
 endif
--- ./hotspot/test/jprt.config	2010-03-18 01:41:45.000000000 -0700
+++ ./hotspot/test/jprt.config	2009-06-06 16:54:10.000000000 -0700
@@ -75,8 +75,8 @@
 
 # Uses 'uname -s', but only expect SunOS or Linux, assume Windows otherwise.
 osname=`uname -s`
-if [ "${osname}" = SunOS ] ; then
-   
+case "${osname}" in
+  SunOS )
     # SOLARIS: Sparc or X86
     osarch=`uname -p`
     if [ "${osarch}" = sparc ] ; then
@@ -100,9 +100,9 @@
 
     # File creation mask
     umask 002
+    ;;
 
-elif [ "${osname}" = Linux ] ; then
-   
+  Linux | Darwin )
     # Add basic paths
     path4sdk=/usr/bin:/bin:/usr/sbin:/sbin
 
@@ -111,9 +111,31 @@
     fileMustExist "${make}" make
 
     umask 002
+    ;;
+
+  FreeBSD | OpenBSD )
+    # Add basic paths
+    path4sdk=/usr/bin:/bin:/usr/sbin:/sbin
+
+    # Find GNU make
+    make=/usr/local/bin/gmake
+    fileMustExist "${make}" make
+
+    umask 002
+    ;;
 
-else
+  NetBSD )
+    # Add basic paths
+    path4sdk=/usr/bin:/bin:/usr/sbin:/sbin
 
+    # Find GNU make
+    make=/usr/pkg/bin/gmake
+    fileMustExist "${make}" make
+
+    umask 002
+    ;;
+
+  * )
     # Windows: Differs on CYGWIN vs. MKS.
    
     # We need to determine if we are running a CYGWIN shell or an MKS shell
@@ -154,8 +176,8 @@
     if [ "${unix_toolset}" = CYGWIN ] ; then
 	path4sdk="`/usr/bin/cygpath -p ${path4sdk}`"
     fi
-
-fi
+    ;;
+esac
 
 # Export PATH setting
 PATH="${path4sdk}"
--- ./jaxp/.hgtags	2010-03-18 01:41:59.000000000 -0700
+++ ./jaxp/.hgtags	2010-03-20 11:12:05.000000000 -0700
@@ -60,3 +60,4 @@
 309a0a7fc6ceb1c9fc3a85b3608e97ef8f7b0dfd jdk7-b83
 32c0cf01d555747918529a6ff9e06b0090c7a474 jdk7-b84
 6c0ccabb430dacdcd4479f8b197980d5da4eeb66 jdk7-b85
+81c0f115bbe5d3bcf59864465b5eca5538567c79 jdk7-b86
--- ./jaxp/.jcheck/conf	2010-03-18 01:41:59.000000000 -0700
+++ ./jaxp/.jcheck/conf	1969-12-31 16:00:00.000000000 -0800
@@ -1 +0,0 @@
-project=jdk7
--- ./jaxws/.hgtags	2010-03-18 01:42:17.000000000 -0700
+++ ./jaxws/.hgtags	2010-03-20 11:12:13.000000000 -0700
@@ -60,3 +60,4 @@
 371e3ded591d09112a9f231e37cb072781c486ac jdk7-b83
 8bc02839eee4ef02cd1b50e87638874368a26535 jdk7-b84
 8424512588ff95362c1f1e5f11c6efd4e7f7db6e jdk7-b85
+512b0e924a5ae0c0b7ad326182cae0dc0e4d1aa8 jdk7-b86
--- ./jaxws/.jcheck/conf	2010-03-18 01:42:17.000000000 -0700
+++ ./jaxws/.jcheck/conf	1969-12-31 16:00:00.000000000 -0800
@@ -1 +0,0 @@
-project=jdk7
--- ./jdk/.hgtags	2010-03-18 01:44:55.000000000 -0700
+++ ./jdk/.hgtags	2010-03-20 11:12:37.000000000 -0700
@@ -60,3 +60,4 @@
 9027c6b9d7e2c9ca04a1add691b5b50d0f22b1aa jdk7-b83
 7cb9388bb1a16365fa5118c5efa38b1cd58be40d jdk7-b84
 b396584a3e64988839cca21ea1f7fbdcc9248783 jdk7-b85
+eae6e9ab26064d9ba0e7665dd646a1fd2506fcc1 jdk7-b86
--- ./jdk/.jcheck/conf	2010-03-18 01:44:55.000000000 -0700
+++ ./jdk/.jcheck/conf	1969-12-31 16:00:00.000000000 -0800
@@ -1 +0,0 @@
-project=jdk7
--- ./jdk/make/com/sun/java/pack/Makefile	2010-03-18 01:44:56.000000000 -0700
+++ ./jdk/make/com/sun/java/pack/Makefile	2010-01-30 09:39:59.000000000 -0800
@@ -62,6 +62,7 @@
 
 
 ifeq ($(STANDALONE),true)
+ ifneq ($(SYSTEM_ZLIB),true)
   ZIPOBJDIR = $(OUTPUTDIR)/tmp/sun/java.util.zip/zip/$(OBJDIRNAME)
 
   ZIPOBJS =  $(ZIPOBJDIR)/zcrc32.$(OBJECT_SUFFIX) \
@@ -78,6 +79,10 @@
   ZINCLUDE=-I$(SHARE_SRC)/native/java/util/zip/zlib-$(ZLIB_VERSION)
   OTHER_CXXFLAGS += $(ZINCLUDE)
   LDDFLAGS += $(ZIPOBJS)
+ else
+  LDDFLAGS += -lz
+  OTHER_CXXFLAGS += -DSYSTEM_ZLIB
+ endif
 else
   OTHER_CXXFLAGS += -DNO_ZLIB -DUNPACK_JNI
   OTHER_LDLIBS += $(JVMLIB)
@@ -99,7 +104,11 @@
   RES = $(OBJDIR)/$(PGRM).res
 else
   LDOUTPUT = -o #Have a space 
+ifeq ($(PLATFORM), bsd)
+  LDDFLAGS += -pthread
+else
   LDDFLAGS += -lc
+endif
   OTHER_LDLIBS  += $(LIBCXX)
 # setup the list of libraries to link in...
 ifeq ($(PLATFORM), linux)
--- ./jdk/make/com/sun/nio/Makefile	2010-03-18 01:44:56.000000000 -0700
+++ ./jdk/make/com/sun/nio/Makefile	2010-03-14 21:36:30.000000000 -0700
@@ -30,7 +30,16 @@
 BUILDDIR = ../../..
 include $(BUILDDIR)/common/Defs.gmk
 
+ifneq ($(PLATFORM), bsd)
 SUBDIRS = sctp
+else
+ifeq ($(OS_VENDOR), FreeBSD)
+# FreeBSD 5.x and lower are unsupported, 6.x has no sctp support.
+ifneq ($(call MajorVersion,$(shell uname -r)), 6)
+SUBDIRS = sctp
+endif
+endif
+endif
 include $(BUILDDIR)/common/Subdirs.gmk
 
 all build clean clobber::
--- ./jdk/make/com/sun/nio/sctp/Makefile	2010-03-18 01:44:56.000000000 -0700
+++ ./jdk/make/com/sun/nio/sctp/Makefile	2010-01-30 09:39:59.000000000 -0800
@@ -69,6 +69,9 @@
 #LIBSCTP = -lsctp
 OTHER_LDLIBS += $(LIBSOCKET) -L$(LIBDIR)/$(LIBARCH) -lnet -lnio
 endif # PLATFORM
+ifeq ($(PLATFORM), bsd)
+OTHER_LDLIBS += $(LIBSOCKET) -L$(LIBDIR)/$(LIBARCH) -lnet -lnio
+endif
 
 else # windows
 include $(BUILDDIR)/common/Classes.gmk
--- ./jdk/make/com/sun/security/auth/module/Makefile	2010-03-18 01:44:56.000000000 -0700
+++ ./jdk/make/com/sun/security/auth/module/Makefile	2010-01-30 09:39:59.000000000 -0800
@@ -68,7 +68,7 @@
   include FILES_c_solaris.gmk
 endif # solaris
 
-ifeq ($(PLATFORM), linux)
+ifneq (,$(findstring $(PLATFORM), linux bsd))
   LIBRARY = jaas_unix
   include FILES_export_unix.gmk
   include FILES_c_unix.gmk
--- ./jdk/make/com/sun/tools/attach/Exportedfiles.gmk	2010-03-18 01:44:56.000000000 -0700
+++ ./jdk/make/com/sun/tools/attach/Exportedfiles.gmk	2010-01-30 09:27:22.000000000 -0800
@@ -43,5 +43,7 @@
 	sun/tools/attach/LinuxVirtualMachine.java
 endif
 
-
-
+ifeq ($(PLATFORM), bsd)
+FILES_export = \
+	sun/tools/attach/BsdVirtualMachine.java
+endif
--- ./jdk/make/com/sun/tools/attach/FILES_c.gmk	2010-03-18 01:44:56.000000000 -0700
+++ ./jdk/make/com/sun/tools/attach/FILES_c.gmk	2010-01-30 09:27:22.000000000 -0800
@@ -39,4 +39,7 @@
 	LinuxVirtualMachine.c
 endif
 
-
+ifeq ($(PLATFORM),bsd)
+FILES_c = \
+	BsdVirtualMachine.c
+endif
--- ./jdk/make/com/sun/tools/attach/FILES_java.gmk	2010-03-18 01:44:56.000000000 -0700
+++ ./jdk/make/com/sun/tools/attach/FILES_java.gmk	2010-01-30 09:27:22.000000000 -0800
@@ -43,6 +43,11 @@
 	sun/tools/attach/LinuxAttachProvider.java
 endif
 
+ifeq ($(PLATFORM), bsd)
+FILES_java += \
+	sun/tools/attach/BsdAttachProvider.java
+endif
+
 #
 # Files that need to be copied
 #
--- ./jdk/make/com/sun/tools/attach/Makefile	2010-03-18 01:44:56.000000000 -0700
+++ ./jdk/make/com/sun/tools/attach/Makefile	2010-01-30 09:39:59.000000000 -0800
@@ -37,6 +37,9 @@
 ifeq ($(PLATFORM), linux)
 FILES_m = mapfile-linux
 endif
+ifeq ($(PLATFORM), bsd)
+FILES_m = mapfile-bsd
+endif
 include $(BUILDDIR)/common/Mapfile-vers.gmk
 
 #
--- ./jdk/make/com/sun/tools/attach/mapfile-bsd	2010-03-27 11:09:14.000000000 -0700
+++ ./jdk/make/com/sun/tools/attach/mapfile-bsd	2010-01-30 09:27:22.000000000 -0800
@@ -30,14 +30,12 @@
 	    Java_sun_tools_attach_BsdVirtualMachine_checkPermissions;
 	    Java_sun_tools_attach_BsdVirtualMachine_close;
 	    Java_sun_tools_attach_BsdVirtualMachine_connect;
-	    Java_sun_tools_attach_BsdVirtualMachine_getBsdThreadsManager;
-	    Java_sun_tools_attach_BsdVirtualMachine_isBsdThreads;
 	    Java_sun_tools_attach_BsdVirtualMachine_open;
 	    Java_sun_tools_attach_BsdVirtualMachine_sendQuitTo;
-            Java_sun_tools_attach_BsdVirtualMachine_sendQuitToChildrenOf;
 	    Java_sun_tools_attach_BsdVirtualMachine_socket;
 	    Java_sun_tools_attach_BsdVirtualMachine_read;
 	    Java_sun_tools_attach_BsdVirtualMachine_write;
+	    Java_sun_tools_attach_BsdVirtualMachine_createAttachFile;
 	local:
 		*;
 };
--- ./jdk/make/common/Defs-bsd.gmk	2010-03-27 11:09:14.000000000 -0700
+++ ./jdk/make/common/Defs-bsd.gmk	2010-01-30 19:08:28.000000000 -0800
@@ -25,7 +25,7 @@
 
 #
 # Makefile to specify compiler flags for programs and libraries
-# targeted to Bsd.  Should not contain any rules.
+# targeted to BSD.  Should not contain any rules.
 #
 # WARNING: This file is shared with other workspaces. 
 #          So when it includes other files, it must use JDK_TOPDIR.
@@ -61,7 +61,7 @@
 endif
 
 # platform specific include files
-PLATFORM_INCLUDE_NAME = $(PLATFORM)
+PLATFORM_INCLUDE_NAME = $(OS_NAME)
 PLATFORM_INCLUDE      = $(INCLUDEDIR)/$(PLATFORM_INCLUDE_NAME)
 
 # suffix used for make dependencies files.
@@ -109,9 +109,11 @@
 #    We need this frame pointer to make it easy to walk the stacks.
 #    This should be the default on X86, but ia64 and amd64 may not have this
 #    as the default.
-CFLAGS_REQUIRED_amd64   += -fno-omit-frame-pointer -D_LITTLE_ENDIAN
-CFLAGS_REQUIRED_i586    += -fno-omit-frame-pointer -D_LITTLE_ENDIAN
-CFLAGS_REQUIRED_ia64    += -fno-omit-frame-pointer -D_LITTLE_ENDIAN
+CFLAGS_REQUIRED_amd64   += -m64 -fno-omit-frame-pointer -D_LITTLE_ENDIAN
+LDFLAGS_COMMON_amd64    += -m64
+CFLAGS_REQUIRED_i586    += -m32 -fno-omit-frame-pointer -D_LITTLE_ENDIAN
+LDFLAGS_COMMON_i586     += -m32
+CFLAGS_REQUIRED_ia64    += -m64 -fno-omit-frame-pointer -D_LITTLE_ENDIAN
 CFLAGS_REQUIRED_sparcv9 += -m64 -mcpu=v9
 LDFLAGS_COMMON_sparcv9  += -m64 -mcpu=v9
 CFLAGS_REQUIRED_sparc   += -m32 -mcpu=v9
@@ -126,9 +128,13 @@
   CFLAGS_REQUIRED       =  $(CFLAGS_REQUIRED_$(ARCH))
   LDFLAGS_COMMON        += $(LDFLAGS_COMMON_$(ARCH))
 endif
+ifeq ($(OS_VENDOR),Apple)
+  # 16-byte stack re-alignment on 32-bit Darwin
+  CFLAGS_REQUIRED_i586 += -mstackrealign
+endif
 
 # If this is a --hash-style=gnu system, use --hash-style=both
-#   The gnu .hash section won't work on some Bsd systems like SuSE 10.
+#   The gnu .hash section won't work on some Linux systems like SuSE 10.
 _HAS_HASH_STYLE_GNU:=$(shell $(CC) -dumpspecs | $(GREP) -- '--hash-style=gnu')
 ifneq ($(_HAS_HASH_STYLE_GNU),)
   LDFLAGS_HASH_STYLE = -Wl,--hash-style=both
@@ -165,7 +171,7 @@
  CFLAGS_COMMON += -pipe
 endif
 
-# Bsd 64bit machines use Dwarf2, which can be HUGE, have fastdebug use -g1
+# BSD 64bit machines use Dwarf2, which can be HUGE, have fastdebug use -g1
 DEBUG_FLAG = -g
 ifeq ($(FASTDEBUG), true)
   ifeq ($(ARCH_DATA_MODEL), 64)
@@ -194,7 +200,7 @@
   CXXFLAGS_DBG	+= $(CC_OPT/$(FASTDEBUG_OPTIMIZATION_LEVEL))
 endif
 
-CPPFLAGS_COMMON = -D$(ARCH) -DARCH='"$(ARCH)"' -DBSD $(VERSION_DEFINES) \
+CPPFLAGS_COMMON = -D$(ARCH) -DARCH='"$(ARCH)"' -D_ALLBSD_SOURCE $(VERSION_DEFINES) \
 		  -D_LARGEFILE64_SOURCE -D_GNU_SOURCE -D_REENTRANT
 
 ifeq ($(ARCH_DATA_MODEL), 64)
@@ -207,33 +213,37 @@
   CPPFLAGS_DBG    += -DLOGGING 
 endif
 
-ifdef LIBRARY
-  # Libraries need to locate other libraries at runtime, and you can tell
-  #   a library where to look by way of the dynamic runpaths (RPATH or RUNPATH)
-  #   buried inside the .so. The $ORIGIN says to look relative to where
-  #   the library itself is and it can be followed with relative paths from
-  #   that. By default we always look in $ORIGIN, optionally we add relative
-  #   paths if the Makefile sets LD_RUNPATH_EXTRAS to those relative paths.
-  #   On Bsd we add a flag -z origin, not sure if this is necessary, but 
-  #   doesn't seem to hurt.
-  #   The environment variable LD_LIBRARY_PATH will over-ride these runpaths.
-  #   Try: 'readelf -d lib*.so' to see these settings in a library.
-  #
+# Libraries need to locate other libraries at runtime, and you can tell
+#   a library where to look by way of the dynamic runpaths (RPATH or RUNPATH)
+#   buried inside the .{so,dylib}. The {$ORIGIN,@loader_path/} says to look
+#   relative to where the library itself is and it can be followed
+#   with relative paths from that. By default we always look in
+#   {$ORIGIN,@loader_path/}, optionally we add relative paths if the Makefile
+#   sets LD_RUNPATH_EXTRAS to those relative paths.
+#   Except on MacOS X we add a flag -z origin, not sure if this is necessary,
+#   but doesn't seem to hurt.
+#   The environment variable LD_LIBRARY_PATH will over-ride these runpaths.
+#   See 'man {dyld,rtld}' for more information.
+#   Try: 'readelf -d lib*.so' to see these settings in a library.
+#
+ifeq ($(OS_VENDOR), Apple)
+  LDFLAGS_COMMON += -Xlinker -rpath -Xlinker @loader_path/.
+  LDFLAGS_COMMON += $(LD_RUNPATH_EXTRAS:%=-Xlinker -rpath -Xlinker @loader_path/%)
+  LDFLAGS_COMMON += -Xlinker -install_name -Xlinker @rpath/$(@F)
+else
   LDFLAGS_COMMON += -Xlinker -z -Xlinker origin -Xlinker -rpath -Xlinker \$$ORIGIN
   LDFLAGS_COMMON += $(LD_RUNPATH_EXTRAS:%=-Xlinker -z -Xlinker origin -Xlinker -rpath -Xlinker \$$ORIGIN/%)
 endif
 
-EXTRA_LIBS += -lc
-
-LDFLAGS_DEFS_OPTION  = -Xlinker -z -Xlinker defs
-LDFLAGS_COMMON  += $(LDFLAGS_DEFS_OPTION)
-
 #
 # -L paths for finding and -ljava
 #
-LDFLAGS_OPT     = -Xlinker -O1
 LDFLAGS_COMMON += -L$(LIBDIR)/$(LIBARCH)
+
+ifneq ($(OS_VENDOR), Apple)
+LDFLAGS_OPT     = -Xlinker -O1
 LDFLAGS_COMMON += -Wl,-soname=$(LIB_PREFIX)$(LIBRARY).$(LIBRARY_SUFFIX)
+endif
 
 #
 # -static-libgcc is a gcc-3 flag to statically link libgcc, gcc-2.9x always
@@ -255,9 +265,9 @@
 ifeq ($(VARIANT), OPT)
   ifneq ($(NO_STRIP), true)
     ifneq ($(DEBUG_BINARIES), true)
-      # Debug 'strip -g' leaves local function Elf symbols (better stack
+      # Debug 'strip -S' leaves local function Elf symbols (better stack
       # traces)
-      POST_STRIP_PROCESS = $(STRIP) -g
+      POST_STRIP_PROCESS = $(STRIP) -S
     endif
   endif
 endif
@@ -276,6 +286,11 @@
 LINK_PRE_CMD = $(QUANTIFY_CMD) $(QUANTIFY_OPTIONS)
 endif
 
+# Darwin does not support linker map files.
+ifeq ($(OS_VENDOR), Apple)
+LDNOMAP=true
+endif
+
 #
 # Path and option to link against the VM, if you have to.  Note that
 # there are libraries that link against only -ljava, but they do get
@@ -302,7 +317,9 @@
 override HAVE_FILIOH             = false
 override HAVE_GETHRTIME          = false
 override HAVE_GETHRVTIME         = false
+ifeq ($(OS_VENDOR),Apple)
 override HAVE_SIGIGNORE          = true
+endif
 override LEX_LIBRARY             = -lfl
 ifeq ($(STATIC_CXX),true)
 override LIBCXX                  = -Wl,-Bstatic -lstdc++ -lgcc -Wl,-Bdynamic
@@ -314,12 +331,8 @@
 override LIBTHREAD               =
 override MOOT_PRIORITIES         = true
 override NO_INTERRUPTIBLE_IO     = true
-override OPENWIN_HOME            = /usr/X11R6
-ifeq ($(ARCH), amd64)
-override OPENWIN_LIB             = $(OPENWIN_HOME)/lib64
-else
+override OPENWIN_HOME            = $(X11_PATH)
 override OPENWIN_LIB             = $(OPENWIN_HOME)/lib
-endif
 override OTHER_M4FLAGS           = -D__GLIBC__ -DGNU_ASSEMBLER
 override SUN_CMM_SUBDIR          =
 override THREADS_FLAG            = native
@@ -340,6 +353,14 @@
 # DPS (Displayable PostScript) is available on Solaris machines
 HAVE_DPS = no
 
+ifeq ($(OS_VENDOR), FreeBSD)
+  SYSTEM_ZLIB = true
+endif
+
+ifeq ($(OS_VENDOR), OpenBSD)
+  SYSTEM_ZLIB = true
+endif
+
 #
 # Japanese manpages
 #
@@ -351,7 +372,7 @@
 SALIB_NAME = $(LIB_PREFIX)saproc.$(LIBRARY_SUFFIX)
 
 # The JDI - Serviceability Agent binding is not currently supported
-# on Bsd-ia64.
+# on ia64.
 ifeq ($(ARCH), ia64)
   INCLUDE_SA = false
 else
--- ./jdk/make/common/Defs-linux.gmk	2010-03-18 01:44:56.000000000 -0700
+++ ./jdk/make/common/Defs-linux.gmk	2010-01-30 09:27:22.000000000 -0800
@@ -314,7 +314,7 @@
 override LIBTHREAD               =
 override MOOT_PRIORITIES         = true
 override NO_INTERRUPTIBLE_IO     = true
-override OPENWIN_HOME            = /usr/X11R6
+override OPENWIN_HOME            = $(X11_PATH)
 ifeq ($(ARCH), amd64)
 override OPENWIN_LIB             = $(OPENWIN_HOME)/lib64
 else
--- ./jdk/make/common/Defs.gmk	2010-03-18 01:44:56.000000000 -0700
+++ ./jdk/make/common/Defs.gmk	2010-03-08 21:38:21.000000000 -0800
@@ -181,6 +181,36 @@
   endif
 endif # OPENJDK
 
+ifneq ($(PLATFORM), windows)
+  ifdef ALT_X11_PATH
+    X11_PATH = $(ALT_X11_PATH)
+  else
+    ifneq ($(OS_VENDOR), NetBSD)
+      X11_PATH = /usr/X11R6
+    else
+      X11_PATH = /usr/X11R7
+    endif
+  endif 
+
+  ifdef ALT_PACKAGE_PATH
+    PACKAGE_PATH = $(ALT_PACKAGE_PATH)
+  else
+    ifeq ($(PLATFORM), linux)
+      PACKAGE_PATH = /usr
+    else
+      ifeq ($(OS_VENDOR), Apple)
+        PACKAGE_PATH = /opt/local
+      else
+	ifeq ($(OS_NAME), netbsd)
+	  PACKAGE_PATH = /usr/pkg
+	else
+          PACKAGE_PATH = /usr/local
+	endif
+      endif
+    endif
+  endif
+endif
+
 #
 # Get platform definitions
 #
@@ -216,6 +246,7 @@
 
   ifdef ALT_FREETYPE_LIB_PATH
     FREETYPE_LIB_PATH = $(ALT_FREETYPE_LIB_PATH)
+    USING_SYSTEM_FT_LIB=true
   else
     ifeq ($(DEVTOOLS_FT_DIR_EXISTS), true)
       FREETYPE_LIB_PATH = $(DEVTOOLS_FT_DIR)/lib
@@ -280,6 +311,10 @@
     LDLIBS_COMMON = -ldl
   endif
 
+  ifeq ($(PLATFORM), bsd)
+    LDLIBS_COMMON = -pthread
+  endif
+
 endif # PROGRAM
 
 LDLIBS_COMMON += $(EXTRA_LIBS)
--- ./jdk/make/common/Program.gmk	2010-03-18 01:44:56.000000000 -0700
+++ ./jdk/make/common/Program.gmk	2010-01-30 09:39:59.000000000 -0800
@@ -65,11 +65,27 @@
 # Create a dependency on libjli (Java Launcher Infrastructure)
 #
 # On UNIX, this is a relative dependency using $ORIGIN. Unfortunately, to
-# do this reliably on Linux takes a different syntax than Solaris.
+# do this reliably on Linux takes a different syntax than Solaris. BSD's
+# don't support $ORIGIN so build an archive instead.
 #
 # On Windows, this is done by using the same directory as the executable
 # itself, as with all the Windows libraries.
 #
+ifeq ($(PLATFORM), bsd)
+  ifeq ($(OS_VENDOR), Apple)
+    LDFLAGS += -Wl,-all_load
+    LDFLAGS += $(OUTPUTDIR)/tmp/java/jli/$(OBJDIRNAME)/static/libjli.a
+  else
+    LDFLAGS += -Wl,--whole-archive
+    LDFLAGS += $(OUTPUTDIR)/tmp/java/jli/$(OBJDIRNAME)/static/libjli.a
+    LDFLAGS += -Wl,--no-whole-archive
+# Work-around an dlsym(RTLD_DEFAULT) bug in at least FreeBSD & OpenBSD
+    LDFLAGS += -Wl,--export-dynamic
+  endif
+  ifeq ($(SYSTEM_ZLIB),true)
+      OTHER_LDLIBS += -lz
+  endif
+endif
 ifneq (,$(findstring $(PLATFORM), linux solaris))	# UNIX systems
     LDFLAGS += -L $(LIBDIR)/$(LIBARCH)/jli
     OTHER_LDLIBS += -ljli
@@ -178,6 +194,10 @@
   THREADLIBS = $(LIBTHREAD)
 endif # USE_PTHREADS
 
+ifeq ($(PLATFORM), bsd)
+THREADLIBS = -pthread
+endif
+
 #
 # This rule only applies on unix.  It supports quantify and its ilk.
 #
@@ -247,15 +267,19 @@
 
 
 ifneq ($(PLATFORM), windows)
+ifneq ($(PLATFORM), bsd)
 HAVE_GETHRTIME=true
 endif
+endif
 
 ifeq ($(HAVE_GETHRTIME),true)
 OTHER_CPPFLAGS += -DHAVE_GETHRTIME
 endif
 
 OTHER_INCLUDES += -I$(LAUNCHER_SHARE_SRC)/bin -I$(LAUNCHER_PLATFORM_SRC)/bin
+ifneq ($(SYSTEM_ZLIB),true)
 OTHER_INCLUDES += -I$(SHARE_SRC)/native/java/util/zip/zlib-1.1.3
+endif
 
 OTHER_CPPFLAGS += -DPROGNAME='"$(PROGRAM)"'
 VERSION_DEFINES += -DFULL_VERSION='"$(FULL_VERSION)"'
--- ./jdk/make/common/Release.gmk	2010-03-18 01:44:56.000000000 -0700
+++ ./jdk/make/common/Release.gmk	2010-01-30 09:27:22.000000000 -0800
@@ -148,14 +148,13 @@
 	tnameserv.1     \
 	unpack200.1
 
-ifeq ($(ARCH_DATA_MODEL),32)
+ifeq ($(BUILD_DEPLOY), true)
   JRE_MAN_PAGES += javaws.1
 endif
 
 JDK_MAN_PAGES =            \
 	$(JRE_MAN_PAGES)   \
 	appletviewer.1     \
-        apt.1              \
 	extcheck.1         \
 	idlj.1             \
 	jar.1              \
@@ -194,6 +193,11 @@
   JA_DIRNAME=ja_JP.$(JA_SOURCE_ENCODING)
 endif # linux
 
+ifeq ($(PLATFORM), bsd)
+  MANBASEDIRS=$(JDK_TOPDIR)/src/bsd/doc $(IMPORTDOCDIR)
+  MAN1SUBDIR = man
+endif
+
 define copy-man-pages
 $(MKDIR) -p $1/man/man1
 for manbase in $(MANBASEDIRS:%=%/$(MAN1SUBDIR)) ; do \
@@ -326,6 +330,12 @@
   SOURCE_DIRS += $(CLOSED_SRC)/share/classes
 endif
 
+ifeq ($(OS_VENDOR), OpenBSD)
+  FILES_FROM_ARG=-I
+else
+  FILES_FROM_ARG=-T
+endif
+
 
 #
 # Specific files and directories that will be filtered out from above areas.
@@ -984,7 +994,7 @@
 	@# generated by the more efficient solaris/windows method of copying files.
 	@# So for Linux, make use of the -T option (like Solaris' -I option) of
 	@# obtaining the list of files from a file. MKS tar has no such option.
-  ifeq ($(PLATFORM), linux)
+  ifneq (,$(findstring $(PLATFORM), linux bsd))
 	for d in $(SOURCE_DIRS); do \
 	  $(RM) $(ABS_TEMPDIR)/src-files.list; \
 	  ($(CD) $$d &&  \
@@ -997,7 +1007,7 @@
 	    done ; \
 	  ) ; \
 	  if [ -f  $(ABS_TEMPDIR)/src-files.list ] ; then \
-	    ($(CD) $$d && $(TAR) cf - -T $(ABS_TEMPDIR)/src-files.list ) \
+	    ($(CD) $$d && $(TAR) cf - $(FILES_FROM_ARG) $(ABS_TEMPDIR)/src-files.list ) \
 	       | ($(CD) $(JDK_IMAGE_DIR)/src && $(TAR) xf -); \
 	  fi; \
 	done
--- ./jdk/make/common/internal/BinaryPlugs.gmk	2010-03-18 01:44:56.000000000 -0700
+++ ./jdk/make/common/internal/BinaryPlugs.gmk	2010-01-30 09:39:59.000000000 -0800
@@ -49,8 +49,6 @@
 com/sun/jmx/snmp/SnmpDataTypeEnums.class \
 com/sun/jmx/snmp/SnmpDefinitions.class \
 com/sun/jmx/snmp/SnmpOid.class \
-com/sun/jmx/snmp/SnmpOidDatabase.class \
-com/sun/jmx/snmp/SnmpOidDatabaseSupport.class \
 com/sun/jmx/snmp/SnmpOidRecord.class \
 com/sun/jmx/snmp/SnmpOidTable.class \
 com/sun/jmx/snmp/SnmpOidTableSupport.class \
@@ -60,22 +58,16 @@
 com/sun/jmx/snmp/SnmpTimeticks.class \
 com/sun/jmx/snmp/SnmpVarBind.class \
 com/sun/jmx/snmp/SnmpVarBindList.class \
-com/sun/jmx/snmp/Timestamp.class \
 com/sun/jmx/snmp/daemon/SendQ.class \
 com/sun/jmx/snmp/daemon/SnmpInformRequest.class \
-com/sun/jmx/snmp/daemon/SnmpQManager.class \
-com/sun/jmx/snmp/daemon/SnmpRequestCounter.class \
-com/sun/jmx/snmp/daemon/SnmpResponseHandler.class \
-com/sun/jmx/snmp/daemon/SnmpSendServer.class \
-com/sun/jmx/snmp/daemon/SnmpSession.class \
-com/sun/jmx/snmp/daemon/SnmpSocket.class \
-com/sun/jmx/snmp/daemon/SnmpTimerServer.class \
-com/sun/jmx/snmp/daemon/WaitQ.class
+com/sun/jmx/snmp/daemon/SnmpSession.class
+
+PLUG_GNU_CLASS_NAMES = gnu
 
 # Class list temp files (used by both import and export of plugs)
 
 PLUG_TEMPDIR=$(ABS_TEMPDIR)/plugs
-PLUG_CLASS_AREAS = jmf
+PLUG_CLASS_AREAS = jmf gnu
 PLUG_CLISTS = $(PLUG_CLASS_AREAS:%=$(PLUG_TEMPDIR)/%.clist)
 
 # Create jargs file command
@@ -93,11 +85,18 @@
 	@for i in $(PLUG_JMF_CLASS_NAMES) ; do \
 	  $(ECHO) "$$i" >> $@; \
 	done
+$(PLUG_TEMPDIR)/gnu.clist:
+	@$(prep-target)
+	@for i in $(PLUG_GNU_CLASS_NAMES) ; do \
+	  $(ECHO) "$$i" >> $@ ; \
+	done
 $(PLUG_TEMPDIR)/all.clist: $(PLUG_CLISTS)
 	@$(prep-target)
 	$(CAT) $(PLUG_CLISTS) > $@
 $(PLUG_TEMPDIR)/jmf.jargs: $(PLUG_TEMPDIR)/jmf.clist
 	$(plug-create-jargs)
+$(PLUG_TEMPDIR)/gnu.jargs: $(PLUG_TEMPDIR)/gnu.clist
+	$(plug-create-jargs)
 $(PLUG_TEMPDIR)/all.jargs: $(PLUG_TEMPDIR)/all.clist
 	$(plug-create-jargs)
 
@@ -133,10 +132,14 @@
 import-binary-plug-jmf-classes: $(PLUG_IMPORT_JARFILE) $(PLUG_TEMPDIR)/jmf.clist
 	$(call import-binary-plug-classes,$(PLUG_TEMPDIR)/jmf.clist)
 
+import-binary-plug-gnu-classes: $(PLUG_IMPORT_JARFILE) $(PLUG_TEMPDIR)/gnu.clist
+	$(call import-binary-plug-classes,$(PLUG_TEMPDIR)/gnu.clist)
+
 # Import all classes from the jar file
 
 import-binary-plug-jar: \
-	     import-binary-plug-jmf-classes
+	     import-binary-plug-jmf-classes \
+	     import-binary-plug-gnu-classes
 
 # Binary plug start/complete messages
 
@@ -148,14 +151,12 @@
 
 # Import lib files (only if they don't exist already)
 
-import-binary-plugs-libs: \
-    $(PLUG_LIBRARY_NAMES:%=$(LIB_LOCATION)/%)
+import-binary-plugs-libs:
 
 # Import everything
 
 import-binary-plugs: \
     import-binary-plugs-started \
-    import-binary-plugs-libs \
     import-binary-plug-jar \
     import-binary-plugs-completed
 
--- ./jdk/make/common/shared/Compiler-gcc.gmk	2010-03-18 01:44:56.000000000 -0700
+++ ./jdk/make/common/shared/Compiler-gcc.gmk	2010-01-30 09:27:23.000000000 -0800
@@ -72,6 +72,24 @@
 
 endif
 
+ifeq ($(PLATFORM), bsd)
+
+  # Settings specific to BSD
+  CC             = $(COMPILER_PATH)gcc
+  CPP            = $(COMPILER_PATH)gcc -E
+  CXX            = $(COMPILER_PATH)g++
+  REQUIRED_CC_VER = 3.2
+
+  # Option used to create a shared library
+  # Option used to create a shared library
+  ifeq ($(OS_VENDOR), Apple)
+    SHARED_LIBRARY_FLAG = -dynamiclib 
+  else
+    SHARED_LIBRARY_FLAG = -shared
+  endif
+  SUN_COMP_VER := $(shell $(CC) --verbose 2>&1 )
+endif
+
 ifeq ($(PLATFORM), solaris)
 
   # Settings specific to Solaris
--- ./jdk/make/common/shared/Defs-bsd.gmk	2010-03-27 11:09:14.000000000 -0700
+++ ./jdk/make/common/shared/Defs-bsd.gmk	2010-01-30 09:27:23.000000000 -0800
@@ -54,7 +54,7 @@
 endef
 
 # Location on system where jdk installs might be
-USRJDKINSTANCES_PATH =/opt/java
+USRJDKINSTANCES_PATH = $(PACKAGE_PATH)
 
 # UNIXCOMMAND_PATH: path to where the most common Unix commands are.
 #  NOTE: Must end with / so that it could be empty, allowing PATH usage.
@@ -107,7 +107,7 @@
 ifneq "$(origin ALT_DEVTOOLS_PATH)" "undefined"
   DEVTOOLS_PATH :=$(call PrefixPath,$(ALT_DEVTOOLS_PATH))
 else
-  DEVTOOLS_PATH =/usr/bin/
+  DEVTOOLS_PATH =$(PACKAGE_PATH)/bin/
 endif
 
 # _BOOTDIR1: First choice for a Bootstrap JDK, previous released JDK.
@@ -121,16 +121,12 @@
 BUILD_HEADLESS = true
 LIBM=-lm
 
-# GCC29_COMPILER_PATH: is the path to where the gcc 2.9 compiler is installed
-#  NOTE: Must end with / so that it could be empty, allowing PATH usage.
-ifneq "$(origin ALT_GCC29_COMPILER_PATH)" "undefined"
-  GCC29_COMPILER_PATH :=$(call PrefixPath,$(ALT_GCC29_COMPILER_PATH))
+ifeq ($(OS_VENDOR), Apple)
+  _CUPS_HEADERS_PATH=/usr/include
 else
-  GCC29_COMPILER_PATH = $(JDK_DEVTOOLS_DIR)/$(PLATFORM)/gcc29/usr/
+  _CUPS_HEADERS_PATH=$(PACKAGE_PATH)/include
 endif
 
-_CUPS_HEADERS_PATH=/usr/include
-
 # Import JDK images allow for partial builds, components not built are
 #    imported (or copied from) these import areas when needed.
 
--- ./jdk/make/common/shared/Defs-utils.gmk	2010-03-18 01:44:56.000000000 -0700
+++ ./jdk/make/common/shared/Defs-utils.gmk	2010-01-30 09:27:23.000000000 -0800
@@ -67,6 +67,13 @@
   UTILS_DEVTOOL_PATH=$(DEVTOOLS_PATH)
 endif
 
+ifeq ($(PLATFORM),bsd)
+  UTILS_COMMAND_PATH=$(UNIXCOMMAND_PATH)
+  UTILS_USR_BIN_PATH=$(USRBIN_PATH)
+  UTILS_CCS_BIN_PATH=$(USRBIN_PATH)
+  UTILS_DEVTOOL_PATH=$(DEVTOOLS_PATH)
+endif
+
 # Utilities
 ADB            = $(UTILS_COMMAND_PATH)adb
 AR             = $(UTILS_CCS_BIN_PATH)ar
@@ -203,3 +210,37 @@
   ECHO           = /usr/bin/echo
 endif
 
+# BSD specific
+ifeq ($(PLATFORM),bsd)
+  BASENAME     = $(UTILS_USR_BIN_PATH)basename
+  EGREP        = $(UTILS_USR_BIN_PATH)egrep
+  EXPR         = $(UTILS_COMMAND_PATH)expr
+  FMT          = $(UTILS_USR_BIN_PATH)fmt
+  GREP         = $(UTILS_USR_BIN_PATH)grep
+  GUNZIP       = $(UTILS_USR_BIN_PATH)gunzip
+  ID           = $(UTILS_USR_BIN_PATH)id
+  MSGFMT       = $(UTILS_DEVTOOL_PATH)msgfmt
+  SED          = $(UTILS_USR_BIN_PATH)sed
+  SORT         = $(UTILS_USR_BIN_PATH)sort
+  TEST         = $(UTILS_COMMAND_PATH)test
+  TOUCH        = $(UTILS_USR_BIN_PATH)touch
+  TRUE         = $(UTILS_USR_BIN_PATH)true
+  UNAME        = $(UTILS_USR_BIN_PATH)uname
+  # BSD OS_VENDOR specific
+  ifeq ($(OS_VENDOR), Apple)
+    NAWK       = $(UTILS_USR_BIN_PATH)awk
+    UNZIPSFX   = $(UTILS_USR_BIN_PATH)unzipsfx
+    ZIPEXE     = $(UTILS_USR_BIN_PATH)zip
+  else
+    UNZIP      = $(UTILS_DEVTOOL_PATH)unzip
+  endif
+  ifneq ($(OS_VENDOR), OpenBSD)
+    CPIO       = $(UTILS_USR_BIN_PATH)cpio
+    TAR        = $(UTILS_USR_BIN_PATH)tar
+  endif
+  ifeq ($(OS_VENDOR), NetBSD)
+    NAWK       = $(UTILS_USR_BIN_PATH)awk
+    ZIPEXE     = $(UTILS_DEVTOOL_PATH)zip
+    UNZIP      = $(UTILS_DEVTOOL_PATH)unzip
+  endif
+endif
--- ./jdk/make/common/shared/Defs.gmk	2010-03-18 01:44:56.000000000 -0700
+++ ./jdk/make/common/shared/Defs.gmk	2010-01-30 09:27:23.000000000 -0800
@@ -589,8 +589,8 @@
   override CC_VERSION = sun
 endif
 
-# Linux uses GNU compilers by default
-ifeq ($(PLATFORM), linux)
+# Linux & BSD uses GNU compilers by default
+ifneq (,$(findstring $(PLATFORM), linux bsd))
   override CC_VERSION = gcc
 endif
 
--- ./jdk/make/common/shared/Platform.gmk	2010-03-18 01:44:56.000000000 -0700
+++ ./jdk/make/common/shared/Platform.gmk	2010-01-30 09:27:23.000000000 -0800
@@ -82,7 +82,7 @@
 SCM_DIRs = .hg .svn CVS RCS SCCS Codemgr_wsdata deleted_files .hgignore .hgtags
 # When changing SCM_DIRs also change SCM_DIRS_rexp and SCM_DIRS_prune:
 SCM_DIRS_rexp = ".hg|.svn|CVS|RCS|SCCS|Codemgr_wsdata|deleted_files|.hgignore|.hgtags"
-SCM_DIRS_prune = \( -name .hg -o -name .svn -o -name CVS -o -name RCS -o -name SCCS -o -name Codemgr_wsdata -o -name deleted_files -o -name .hgignore -o -name .hgtags \) -prune
+SCM_DIRS_prune = \( -name .hg -o -name .svn -o -name CVS -o -name RCS -o -name SCCS -o -name Codemgr_wsdata -o -name deleted_files -o -name .hgignore -o -name .hgtags -o -name \*.orig \) -prune
 
 # Don't define this unless it's not defined
 ifndef VARIANT
@@ -214,6 +214,101 @@
   MB_OF_MEMORY := $(shell free -m | fgrep Mem: | awk '{print $$2;}' )
 endif
 
+ifeq ($(SYSTEM_UNAME), FreeBSD)
+  PLATFORM = bsd
+  OS_NAME = freebsd
+  OS_VENDOR = FreeBSD
+  REQUIRED_OS_VERSION = 6.0
+endif
+
+ifeq ($(SYSTEM_UNAME), Darwin)
+  PLATFORM = bsd
+  OS_NAME = darwin
+  OS_VENDOR = Apple
+  REQUIRED_OS_VERSION = 8.0
+endif
+
+ifeq ($(SYSTEM_UNAME), NetBSD)
+  PLATFORM = bsd
+  OS_NAME = netbsd
+  OS_VENDOR = NetBSD
+  REQUIRED_OS_VERSION = 3.0
+endif
+
+ifeq ($(SYSTEM_UNAME), OpenBSD)
+  PLATFORM = bsd
+  OS_NAME = openbsd
+  OS_VENDOR = OpenBSD
+  REQUIRED_OS_VERSION = 4.2
+endif
+
+# Platform settings specific to BSD
+ifeq ($(PLATFORM), bsd)
+  OS_VERSION := $(shell uname -r)
+  # Arch and OS name/version
+  mach := $(shell uname -m)
+  archExpr = case "$(mach)" in \
+                i[3-9]86) \
+                    echo i586 \
+                    ;; \
+                sparc64) \
+                    echo sparcv9 \
+                    ;; \
+                sparc*) \
+                    echo sparc \
+                    ;; \
+                x86_64) \
+                    echo amd64 \
+                    ;; \
+                "Power Macintosh") \
+                    echo ppc \
+                    ;; \
+                *) \
+                    echo $(mach) \
+                    ;; \
+      esac
+  ARCH        := $(shell $(archExpr) )
+  ARCH_FAMILY := $(ARCH)
+
+  # Darwin builds may be 32-bit or 64-bit data model.
+  ifeq ($(SYSTEM_UNAME), Darwin)
+    ifeq ($(ARCH), i586)
+      ifeq ($(ARCH_DATA_MODEL), 64)
+        ARCH=amd64
+      endif
+    endif
+  endif
+
+  # i586, sparc, and ppc are 32 bit, amd64 and sparc64 are 64
+  ifneq (,$(findstring $(ARCH), i586 sparc ppc))
+    ARCH_DATA_MODEL=32
+  else
+    ARCH_DATA_MODEL=64
+  endif
+
+  # Need to maintain the jre/lib/i386 location for 32-bit Intel
+  ifeq ($(ARCH), i586)
+    LIBARCH = i386
+  else
+    LIBARCH = $(ARCH)
+  endif
+
+  # Value of Java os.arch property
+  ARCHPROP  = $(LIBARCH)
+
+  # Suffix for file bundles used in previous release
+  BUNDLE_FILE_SUFFIX=.tar.gz
+  # Minimum disk space needed as determined by running 'du -sk' on 
+  #    a fully built workspace.
+  REQUIRED_FREE_SPACE=1500000
+  # How much RAM does this machine have:
+  ifeq ($(OS_VENDOR), OpenBSD)
+    MB_OF_MEMORY=$(shell sysctl -n hw.physmem | awk '{print int($$NF / 1048576); }' )
+  else
+    MB_OF_MEMORY=$(shell (sysctl -n hw.physmem64 2> /dev/null || sysctl -n hw.physmem) | awk '{print int($$NF / 1048576); }' )
+  endif
+endif
+
 # Windows with and without CYGWIN will be slightly different
 ifeq ($(SYSTEM_UNAME), Windows_NT)
   PLATFORM = windows
@@ -379,6 +474,14 @@
   ARCH_VM_SUBDIR=jre/lib/$(LIBARCH)
 endif
 
+# Darwin-specific Overrides
+ifeq ($(SYSTEM_UNAME),Darwin)
+  # The suffix applied to runtime libraries
+  LIBRARY_SUFFIX = dylib
+  # The suffix applied to link libraries
+  LIB_SUFFIX = dylib
+endif
+
 # Machines with 512Mb or less of real memory are considered low memory
 #    build machines and adjustments will be made to prevent excessing
 #    system swapping during the build.
@@ -418,6 +521,18 @@
   export MIN_VM_MEMORY
 endif
 
+# for OpenBSD/i386 limit to 736 max
+ifeq ($(OS_VENDOR), OpenBSD)
+  ifeq ($(ARCH_DATA_MODEL), 32)
+    MAX_VM_MEMORY := $(shell \
+      if [ $(MAX_VM_MEMORY) -gt 736 ] ; then \
+        echo "736"; \
+      else \
+        echo "$(MAX_VM_MEMORY)" ; \
+      fi)
+  endif
+endif
+
 # If blanks in the username, use the first 4 words and pack them together
 _USER1:=$(subst ', ,$(_USER))
 _USER2:=$(subst ", ,$(_USER1))
--- ./jdk/make/common/shared/Sanity-Settings.gmk	2010-03-18 01:44:56.000000000 -0700
+++ ./jdk/make/common/shared/Sanity-Settings.gmk	2010-01-30 09:27:23.000000000 -0800
@@ -244,6 +244,7 @@
   ALL_SETTINGS+=$(call addHeading,OpenJDK-specific settings)
   ALL_SETTINGS+=$(call addAltSetting,FREETYPE_HEADERS_PATH)
   ALL_SETTINGS+=$(call addAltSetting,FREETYPE_LIB_PATH)
+  ALL_SETTINGS+=$(call addAltSetting,X11_PATH)
   ALL_SETTINGS+=$(call addHeading,OPENJDK Import Binary Plug Settings)
   ALL_SETTINGS+=$(call addOptionalSetting,IMPORT_BINARY_PLUGS)
   ALL_SETTINGS+=$(call addAltSetting,BINARY_PLUGS_JARFILE)
--- ./jdk/make/common/shared/Sanity.gmk	2010-03-18 01:44:56.000000000 -0700
+++ ./jdk/make/common/shared/Sanity.gmk	2010-03-20 11:12:37.000000000 -0700
@@ -142,6 +142,11 @@
     $(EGREP) "\#define" | $(NAWK) '{print $$3}')
 endif
 
+ifeq ($(PLATFORM), bsd)
+  FREE_SPACE := $(shell BLOCKSIZE=512 $(DF) $(OUTPUTDIR) | $(TAIL) -1 | $(NAWK) '{print $$2;}')
+  TEMP_FREE_SPACE := $(shell BLOCKSIZE=512 $(DF) $(TEMP_DISK) | $(TAIL) -1 | $(NAWK) '{print $$2;}')
+endif
+
 # Get the version numbers of what we are using
 _MAKE_VER  :=$(shell $(MAKE) --version 2>&1 | $(HEAD) -n 1)
 _ZIP_VER   :=$(shell $(ZIPEXE) -help 2>&1 | $(HEAD) -n 4 | $(EGREP) '^Zip')
@@ -878,8 +883,10 @@
 
 ######################################################
 # Check for existence of DEVTOOLS_PATH
+# All needed tools come with base system on Apple
 ######################################################
 sane-devtools_path:
+ifneq ($(OS_VENDOR), Apple)
 	@if [ "$(DEVTOOLS_PATH)" != "" -a ! -r "$(DEVTOOLS_PATH)" ]; then \
 	  $(ECHO) "ERROR: You do not have a valid DEVTOOLS_PATH setting. \n" \
 	    "      Please check your access to \n" \
@@ -887,6 +894,7 @@
 	    "      and/or check your value of ALT_DEVTOOLS_PATH. \n" \
 	    "" >> $(ERROR_FILE) ; \
 	fi
+endif
 
 ######################################################
 # Check for existence of MS_RUNTIME_LIBRARIES
--- ./jdk/make/docs/Makefile	2010-03-18 01:44:56.000000000 -0700
+++ ./jdk/make/docs/Makefile	2010-02-06 10:17:32.000000000 -0800
@@ -214,7 +214,7 @@
 #       you get "No packages or classes specified." due to $(CLASSPATH_SEPARATOR)
 #       being interpreted as an end of command (newline)
 
-JAAS_SOURCEPATH  = "$(TOPDIR)/src/share/classes$(CLASSPATH_SEPARATOR)$(TOPDIR)/src/solaris/classes$(CLASSPATH_SEPARATOR)$(TOPDIR)/src/windows/classes$(CLASSPATH_SEPARATOR)$(TOPDIR)/src/linux/classes"
+JAAS_SOURCEPATH  = "$(TOPDIR)/src/share/classes$(CLASSPATH_SEPARATOR)$(TOPDIR)/src/solaris/classes$(CLASSPATH_SEPARATOR)$(TOPDIR)/src/windows/classes$(CLASSPATH_SEPARATOR)$(TOPDIR)/src/linux/classes$(CLASSPATH_SEPARATOR)$(TOPDIR)/src/bsd/classes"
 JAAS_DOCDIR	 = $(DOCSDIR)/jre/api/security/jaas/spec
 JAAS_JAVADOCFLAGS = $(COMMON_JAVADOCFLAGS)			 \
 		   -encoding ascii			         \
--- ./jdk/make/java/Makefile	2010-03-18 01:44:56.000000000 -0700
+++ ./jdk/make/java/Makefile	2010-03-08 21:38:21.000000000 -0800
@@ -53,7 +53,7 @@
   endif
 endif # PLATFORM
 
-ifeq ($(PLATFORM), linux)
+ifneq (,$(findstring $(PLATFORM), linux bsd))
   SUBDIRS += jexec
 endif # PLATFORM
 
--- ./jdk/make/java/hpi/hpi_common.gmk	2010-03-18 01:44:56.000000000 -0700
+++ ./jdk/make/java/hpi/hpi_common.gmk	2010-01-30 09:27:23.000000000 -0800
@@ -86,5 +86,9 @@
 # Things that must be linked in.
 #
 ifneq ($(PLATFORM), windows)
+ifeq ($(PLATFORM), bsd)
+OTHER_LDLIBS += $(LIBM)
+else
 OTHER_LDLIBS += $(LIBSOCKET) -lnsl $(LIBM) -ldl
 endif
+endif
--- ./jdk/make/java/hpi/native/Makefile	2010-03-18 01:44:56.000000000 -0700
+++ ./jdk/make/java/hpi/native/Makefile	2010-01-30 09:39:59.000000000 -0800
@@ -73,16 +73,25 @@
 ifeq ($(MOOT_PRIORITIES),true)
 OTHER_CPPFLAGS += -DMOOT_PRIORITIES
 endif
+ifeq ($(PLATFORM), bsd)
+LIBPOSIX4      =
+OTHER_LDLIBS   += -pthread
+else
 LIBPOSIX4	= -lposix4
 OTHER_LDLIBS   += -lpthread $(LIBPOSIX4)
 endif
+endif
 
+ifneq ($(PLATFORM), bsd)
 HAVE_GETHRVTIME=true
+endif
 ifeq ($(HAVE_GETHRVTIME),true)
 OTHER_CPPFLAGS += -DHAVE_GETHRVTIME
 endif
 
+ifneq ($(OS_VENDOR), OpenBSD)
 HAVE_FILIOH=true
+endif
 ifeq ($(HAVE_FILIOH),true)
 OTHER_CPPFLAGS += -DHAVE_FILIOH
 endif
--- ./jdk/make/java/instrument/Makefile	2010-03-18 01:44:56.000000000 -0700
+++ ./jdk/make/java/instrument/Makefile	2010-01-30 09:39:59.000000000 -0800
@@ -103,6 +103,26 @@
   # equivalent of strcasecmp is stricmp on Windows
   CPPFLAGS_COMMON += -Dstrcasecmp=stricmp
 else
+ifeq ($(PLATFORM), bsd)
+  ifeq ($(OS_VENDOR), Apple)
+    LDFLAGS += -Wl,-all_load
+    LDFLAGS += $(OUTPUTDIR)/tmp/java/jli/$(OBJDIRNAME)/static/libjli.a
+    OTHER_LDLIBS += -liconv
+  else
+    LDFLAGS += -Wl,--whole-archive
+    LDFLAGS += $(OUTPUTDIR)/tmp/java/jli/$(OBJDIRNAME)/static/libjli.a
+    LDFLAGS += -Wl,--no-whole-archive
+    ifneq ($(OS_NAME), netbsd)
+# Use CPPFLAGS instead of OTHER_INCLUDES to force this last
+      CPPFLAGS += -I$(PACKAGE_PATH)/include
+      OTHER_LDLIBS += -L$(PACKAGE_PATH)/lib -liconv
+    endif
+  endif
+
+  ifeq ($(SYSTEM_ZLIB), true)
+    OTHER_LDLIBS += -lz
+  endif
+else
   LDFLAGS += -L $(LIBDIR)/$(LIBARCH)/jli
   OTHER_LDLIBS += -ljli
   OTHER_LDLIBS += -ldl 
@@ -115,6 +135,7 @@
     LDFLAGS += -Wl,-rpath -Wl,\$$ORIGIN/jli
   endif
 endif
+endif
 
 #
 # Library to compile.
--- ./jdk/make/java/java/Makefile	2010-03-18 01:44:56.000000000 -0700
+++ ./jdk/make/java/java/Makefile	2010-03-08 21:38:21.000000000 -0800
@@ -166,8 +166,10 @@
 # Is the altzone extern documented in ctime(3C) available?
 #
 ifneq ($(PLATFORM), windows)
+ifneq ($(PLATFORM), bsd)
 HAVE_ALTZONE=true
 endif
+endif
 
 ifeq ($(HAVE_ALTZONE),true)
 OTHER_CPPFLAGS += -DHAVE_ALTZONE
@@ -204,9 +206,14 @@
 OTHER_LDLIBS += $(JVMLIB) -libpath:$(OBJDIR)/../../../fdlibm/$(OBJDIRNAME) fdlibm.lib \
 		       -libpath:$(OBJDIR)/../../../verify/$(OBJDIRNAME) verify.lib
 else
+ifeq ($(PLATFORM), bsd)
+OTHER_LDLIBS += $(JVMLIB) -lverify \
+		-L$(OBJDIR)/../../../fdlibm/$(OBJDIRNAME) -lfdlibm.$(ARCH)
+else
 OTHER_LDLIBS += $(JVMLIB) -lverify $(LIBSOCKET) -lnsl -ldl \
 		-L$(OBJDIR)/../../../fdlibm/$(OBJDIRNAME) -lfdlibm.$(ARCH)
 endif
+endif
 
 #
 # Rules.
--- ./jdk/make/java/java/genlocales.gmk	2010-03-18 01:44:56.000000000 -0700
+++ ./jdk/make/java/java/genlocales.gmk	2010-03-08 21:38:21.000000000 -0800
@@ -76,10 +76,14 @@
 $(LocaleDataMetaInfo_Dest):$(LocaleDataMetaInfo_Src) $(LOCALEGEN_SH)
 	@$(RM) $@.tmp.euro $@.tmp.noneuro;
 	@$(prep-target) 
-	@$(ECHO) $(subst .properties,'\n',$(Euro_Resources_properties)) > $@.tmp.euro;
-	@$(ECHO) $(subst .java,'\n',$(Euro_Resources_java)) >> $@.tmp.euro;	
-	@$(ECHO) $(subst .properties,'\n',$(NonEuro_Resources_properties)) > $@.tmp.noneuro;
-	@$(ECHO) $(subst .java,'\n',$(NonEuro_Resources_java)) >> $@.tmp.noneuro;
+	@$(ECHO) $(Euro_Resources_properties) | $(SED) -e s@.properties@'\
+'@g > $@.tmp.euro;
+	@$(ECHO) $(Euro_Resources_java) | $(SED) -e s@.java@'\
+'@g >> $@.tmp.euro;
+	@$(ECHO) $(NonEuro_Resources_properties) | $(SED) -e s@.properties@'\
+'@g > $@.tmp.noneuro;
+	@$(ECHO) $(NonEuro_Resources_java) | $(SED) -e s@.java@'\
+'@g >> $@.tmp.noneuro;
 	NAWK="$(NAWK)" SED="$(SED)" SORT="$(SORT)" \
 	     $(SH) $(LOCALEGEN_SH) $(RESOURCE_NAMES) $@.tmp.euro \
 		$@.tmp.noneuro $< $@
--- ./jdk/make/java/java/localegen.sh	2010-03-18 01:44:56.000000000 -0700
+++ ./jdk/make/java/java/localegen.sh	2010-01-30 09:27:23.000000000 -0800
@@ -55,9 +55,9 @@
 for FILE in $RESOURCE_NAMES 
 do
     getlocalelist $FILE $EURO_FILES_LIST
-    sed_script=$sed_script"-e \"s/#"$FILE"_EuroLocales#/$localelist/g\" "
+    sed_script=$sed_script"-e \"s@#"$FILE"_EuroLocales#@$localelist@g\" "
     getlocalelist $FILE $NONEURO_FILES_LIST
-    sed_script=$sed_script"-e \"s/#"$FILE"_NonEuroLocales#/$localelist/g\" "
+    sed_script=$sed_script"-e \"s@#"$FILE"_NonEuroLocales#@$localelist@g\" "
 done
 
 sed_script=$sed_script"$INPUT_FILE > $OUTPUT_FILE"
--- ./jdk/make/java/java_hprof_demo/Makefile	2010-03-18 01:44:56.000000000 -0700
+++ ./jdk/make/java/java_hprof_demo/Makefile	2010-01-30 09:40:00.000000000 -0800
@@ -84,8 +84,10 @@
 ifeq ($(PLATFORM), windows)
   OTHER_LDLIBS += wsock32.lib winmm.lib
 else
+ifneq ($(PLATFORM), bsd)
   OTHER_LDLIBS += $(LIBSOCKET) -lnsl -ldl
 endif
+endif
 
 #
 # Tell library.gmk to copy the txt file first
--- ./jdk/make/java/jli/Makefile	2010-03-18 01:44:56.000000000 -0700
+++ ./jdk/make/java/jli/Makefile	2010-01-30 09:40:00.000000000 -0800
@@ -45,7 +45,9 @@
 
 include $(BUILDDIR)/common/Defs.gmk
 
+ifneq ($(SYSTEM_ZLIB),true)
 ZIP_SRC = $(SHARE_SRC)/native/java/util/zip/zlib-$(ZLIB_VERSION)
+endif
 LAUNCHER_SHARE_SRC = $(SHARE_SRC)/bin
 LAUNCHER_PLATFORM_SRC = $(PLATFORM_SRC)/bin
 
@@ -70,13 +72,17 @@
 	parse_manifest.c \
 	version_comp.c \
 	wildcard.c \
-	jli_util.c \
+	jli_util.c
+
+ifneq ($(SYSTEM_ZLIB),true)
+FILES_c += \
 	inflate.c \
 	inftrees.c \
 	inffast.c \
 	zadler32.c \
 	zcrc32.c \
 	zutil.c
+endif
 
 ifneq ($(PLATFORM), windows)
 
@@ -93,16 +99,18 @@
   LIBARCH_DEFINES += -DLIBARCH64NAME='"$(LIBARCH64)"'
 endif
 
-OTHER_CPPFLAGS += $(LIBARCH_DEFINES)
+OTHER_CPPFLAGS += $(LIBARCH_DEFINES) -DPACKAGE_PATH=\"$(PACKAGE_PATH)\"
 
 
 ifneq ($(PLATFORM), windows)	# UNIX systems
         LD_RUNPATH_EXTRAS += ..
 	LIB_LOCATION = $(LIBDIR)/$(LIBARCH)/jli
+ifneq ($(PLATFORM), bsd)	# other UNIX systems
 	# Note: its important to keep this order meaning -lc is the
 	# last library otherwise it could cause compatibility issues
 	# by pulling in SUNW_private symbols from libc
 	LDLIBS = -ldl -lc
+endif # !bsd
 ifeq ($(USE_PTHREADS),true)
 	LDLIBS += -lpthread
 endif # USE_PTHREADS 
@@ -126,7 +134,11 @@
 
 OTHER_INCLUDES += -I$(LAUNCHER_SHARE_SRC)
 OTHER_INCLUDES += -I$(LAUNCHER_PLATFORM_SRC)
-OTHER_INCLUDES += -I$(ZIP_SRC)
+ifneq ($(SYSTEM_ZLIB),true)
+  OTHER_INCLUDES += -I$(ZIP_SRC)
+else
+  LDLIBS += -lz
+endif
 
 #
 # Library to compile.
@@ -163,7 +175,28 @@
 
 endif	# PLATFORM
 
+ifeq ($(PLATFORM), bsd)
+
+STATIC_LIBRARY_DIR = $(OBJDIR)/static
+STATIC_LIBRARY_NAME = lib$(LIBRARY).a
+STATIC_LIBRARY = $(STATIC_LIBRARY_DIR)/$(STATIC_LIBRARY_NAME)
+
+$(STATIC_LIBRARY_DIR): $(OBJDIR)
+	@$(MKDIR) $(STATIC_LIBRARY_DIR)
+
+$(STATIC_LIBRARY): $(STATIC_LIBRARY_DIR)
+	@$(prep-target)
+	$(AR) -r $@ $(FILES_o)
+
+library:: $(STATIC_LIBRARY)
+
+endif  # PLATFORM
+
 #
 # Add to ambient vpath so we pick up the library files
 #
-vpath %.c $(LAUNCHER_SHARE_SRC) $(ZIP_SRC) $(LAUNCHER_PLATFORM_SRC)
+vpath %.c $(LAUNCHER_SHARE_SRC) $(LAUNCHER_PLATFORM_SRC)
+ifneq ($(SYSTEM_ZLIB),true)
+  vpath %.c $(ZIP_SRC)
+endif
+
--- ./jdk/make/java/management/Makefile	2010-03-18 01:44:56.000000000 -0700
+++ ./jdk/make/java/management/Makefile	2010-01-30 09:40:00.000000000 -0800
@@ -86,6 +86,11 @@
 OTHER_INCLUDES += \
   -I$(SHARE_SRC)/native/sun/management 
 
+ifeq ($(PLATFORM),bsd)
+OTHER_INCLUDES += \
+  -I$(PLATFORM_SRC)/hpi/include
+endif
+
 ifeq ($(PLATFORM),windows)
   OTHER_LDLIBS += $(JVMLIB)
 endif
--- ./jdk/make/java/net/FILES_c.gmk	2010-03-18 01:44:56.000000000 -0700
+++ ./jdk/make/java/net/FILES_c.gmk	2010-01-30 09:27:23.000000000 -0800
@@ -47,6 +47,10 @@
     FILES_c += linux_close.c
 endif
 
+ifeq ($(OS_VENDOR), FreeBSD)
+    FILES_c += $(CTARGDIR)bsd_close.c
+endif
+
 ifeq ($(PLATFORM), windows)
     FILES_c += TwoStacksPlainSocketImpl.c
     FILES_c += DualStackPlainSocketImpl.c
--- ./jdk/make/java/net/Makefile	2010-03-18 01:44:56.000000000 -0700
+++ ./jdk/make/java/net/Makefile	2010-01-30 09:40:00.000000000 -0800
@@ -93,6 +93,12 @@
 
 include $(BUILDDIR)/common/Library.gmk
 
+ifeq ($(PLATFORM), bsd)
+ifdef DONT_ENABLE_IPV6
+  OTHER_CFLAGS += -DDONT_ENABLE_IPV6
+endif
+  OTHER_LDLIBS = $(JVMLIB) -pthread
+else
 ifeq ($(PLATFORM), windows)
   OTHER_LDLIBS = ws2_32.lib $(JVMLIB)
 else
@@ -101,6 +107,7 @@
 ifeq ($(PLATFORM), linux)
   OTHER_LDLIBS += -lpthread
 endif
+endif # PLATFORM == bsd
 
 CLASSES.export += java.lang.Integer java.io.FileDescriptor java.net.InetAddressImplFactory java.net.Inet4AddressImpl java.net.Inet6AddressImpl
 
--- ./jdk/make/java/nio/Makefile	2010-03-18 01:44:56.000000000 -0700
+++ ./jdk/make/java/nio/Makefile	2010-03-08 21:38:21.000000000 -0800
@@ -261,6 +261,69 @@
 	sun/nio/fs/UnixConstants.java
 endif # PLATFORM = linux
 
+ifeq ($(PLATFORM), bsd)
+FILES_java += \
+        sun/nio/ch/AbstractPollSelectorImpl.java \
+	sun/nio/ch/InheritedChannel.java \
+        sun/nio/ch/PollSelectorProvider.java \
+        sun/nio/ch/PollSelectorImpl.java \
+	sun/nio/ch/Port.java \
+	sun/nio/ch/SimpleAsynchronousFileChannelImpl.java \
+	sun/nio/ch/UnixAsynchronousServerSocketChannelImpl.java \
+	sun/nio/ch/UnixAsynchronousSocketChannelImpl.java \
+	\
+	sun/nio/fs/GnomeFileTypeDetector.java \
+	sun/nio/fs/BsdFileStore.java \
+	sun/nio/fs/BsdFileSystem.java \
+	sun/nio/fs/BsdFileSystemProvider.java \
+	sun/nio/fs/BsdNativeDispatcher.java \
+	sun/nio/fs/PollingWatchService.java \
+	sun/nio/fs/UnixChannelFactory.java \
+	sun/nio/fs/UnixCopyFile.java \
+	sun/nio/fs/UnixDirectoryStream.java \
+	sun/nio/fs/UnixException.java \
+	sun/nio/fs/UnixFileAttributeViews.java \
+	sun/nio/fs/UnixFileAttributes.java \
+	sun/nio/fs/UnixFileKey.java \
+	sun/nio/fs/UnixFileModeAttribute.java \
+	sun/nio/fs/UnixFileStore.java \
+	sun/nio/fs/UnixFileStoreAttributes.java \
+	sun/nio/fs/UnixFileSystem.java \
+	sun/nio/fs/UnixFileSystemProvider.java \
+	sun/nio/fs/UnixMountEntry.java \
+	sun/nio/fs/UnixNativeDispatcher.java \
+	sun/nio/fs/UnixPath.java \
+	sun/nio/fs/UnixSecureDirectoryStream.java \
+	sun/nio/fs/UnixUriUtils.java \
+	sun/nio/fs/UnixUserPrincipals.java
+
+FILES_c += \
+	InheritedChannel.c \
+	NativeThread.c \
+        PollArrayWrapper.c \
+	UnixAsynchronousServerSocketChannelImpl.c \
+	UnixAsynchronousSocketChannelImpl.c \
+	\
+	GnomeFileTypeDetector.c \
+	BsdNativeDispatcher.c \
+	UnixCopyFile.c \
+	UnixNativeDispatcher.c
+
+FILES_export += \
+	sun/nio/ch/InheritedChannel.java \
+	sun/nio/ch/NativeThread.java \
+	sun/nio/ch/UnixAsynchronousServerSocketChannelImpl.java \
+	sun/nio/ch/UnixAsynchronousSocketChannelImpl.java \
+	\
+	sun/nio/fs/GnomeFileTypeDetector.java \
+	sun/nio/fs/BsdNativeDispatcher.java \
+	sun/nio/fs/UnixCopyFile.java \
+	sun/nio/fs/UnixNativeDispatcher.java
+	
+FILES_gen += \
+	sun/nio/fs/UnixConstants.java
+endif # PLATFORM = bsd
+
 #
 # Find platform-specific C source files
 #
@@ -285,6 +348,11 @@
   -I$(PLATFORM_SRC)/native/java/net \
   -I$(CLASSHDRDIR)/../../../java.lang/java/CClassHeaders
 
+ifeq ($(PLATFORM), bsd)
+OTHER_INCLUDES += \
+  -I$(PLATFORM_SRC)/hpi/include
+endif
+
 ifeq ($(PLATFORM),windows)
   OTHER_LDLIBS += $(JVMLIB) ws2_32.lib \
      -libpath:$(LIBDIR) java.lib \
@@ -295,6 +363,9 @@
 ifeq ($(PLATFORM), linux)
 OTHER_LDLIBS += -L$(LIBDIR)/$(LIBARCH) -ljava -lnet -lpthread -ldl
 endif
+ifeq ($(PLATFORM), bsd)
+OTHER_LDLIBS += -L$(LIBDIR)/$(LIBARCH) -ljava -lnet -pthread
+endif
 ifeq ($(PLATFORM), solaris)
 OTHER_LDLIBS += $(JVMLIB) $(LIBSOCKET) -lposix4 -ldl \
 		-L$(LIBDIR)/$(LIBARCH) -ljava -lnet
@@ -321,6 +392,9 @@
 ifeq ($(PLATFORM), linux)
 FILES_m = mapfile-linux
 endif
+ifeq ($(PLATFORM), bsd)
+FILES_m = mapfile-bsd
+endif
 include $(BUILDDIR)/common/Mapfile-vers.gmk
 include $(BUILDDIR)/common/Library.gmk
 
--- ./jdk/make/java/nio/mapfile-bsd	2010-03-27 11:09:14.000000000 -0700
+++ ./jdk/make/java/nio/mapfile-bsd	2010-01-30 09:27:23.000000000 -0800
@@ -36,25 +36,6 @@
                 Java_sun_nio_ch_DatagramDispatcher_readv0;
                 Java_sun_nio_ch_DatagramDispatcher_write0;
                 Java_sun_nio_ch_DatagramDispatcher_writev0;
-                Java_sun_nio_ch_EPollArrayWrapper_epollCreate;
-                Java_sun_nio_ch_EPollArrayWrapper_epollCtl;
-                Java_sun_nio_ch_EPollArrayWrapper_epollWait;
-		Java_sun_nio_ch_EPollArrayWrapper_fdLimit;
-		Java_sun_nio_ch_EPollArrayWrapper_init;
-		Java_sun_nio_ch_EPollArrayWrapper_interrupt;
-		Java_sun_nio_ch_EPollArrayWrapper_offsetofData;
-		Java_sun_nio_ch_EPollArrayWrapper_sizeofEPollEvent;
-		Java_sun_nio_ch_EPoll_init;
-		Java_sun_nio_ch_EPoll_eventSize;
-		Java_sun_nio_ch_EPoll_eventsOffset;
-		Java_sun_nio_ch_EPoll_dataOffset;
-		Java_sun_nio_ch_EPoll_epollCreate;
-		Java_sun_nio_ch_EPoll_epollCtl;
-		Java_sun_nio_ch_EPoll_epollWait;
-		Java_sun_nio_ch_EPollPort_close0;
-		Java_sun_nio_ch_EPollPort_drain1;
-		Java_sun_nio_ch_EPollPort_interrupt;
-		Java_sun_nio_ch_EPollPort_socketpair;
                 Java_sun_nio_ch_FileChannelImpl_close0;
                 Java_sun_nio_ch_FileChannelImpl_initIDs;
                 Java_sun_nio_ch_FileChannelImpl_map0;
@@ -122,26 +103,14 @@
 		Java_sun_nio_ch_UnixAsynchronousServerSocketChannelImpl_accept0;
 		Java_sun_nio_ch_UnixAsynchronousServerSocketChannelImpl_initIDs;
 		Java_sun_nio_ch_UnixAsynchronousSocketChannelImpl_checkConnect;
+		Java_sun_nio_fs_BsdNativeDispatcher_initIDs;
+		Java_sun_nio_fs_BsdNativeDispatcher_getfsstat;
+		Java_sun_nio_fs_BsdNativeDispatcher_fsstatEntry;
+		Java_sun_nio_fs_BsdNativeDispatcher_endfsstat;
 		Java_sun_nio_fs_GnomeFileTypeDetector_initializeGio;
 		Java_sun_nio_fs_GnomeFileTypeDetector_probeUsingGio;
 		Java_sun_nio_fs_GnomeFileTypeDetector_initializeGnomeVfs;
 		Java_sun_nio_fs_GnomeFileTypeDetector_probeUsingGnomeVfs;
-		Java_sun_nio_fs_BsdWatchService_init;
-		Java_sun_nio_fs_BsdWatchService_eventSize;
-		Java_sun_nio_fs_BsdWatchService_eventOffsets;
-		Java_sun_nio_fs_BsdWatchService_inotifyInit;
-		Java_sun_nio_fs_BsdWatchService_inotifyAddWatch;
-		Java_sun_nio_fs_BsdWatchService_inotifyRmWatch;
-		Java_sun_nio_fs_BsdWatchService_configureBlocking;
-		Java_sun_nio_fs_BsdWatchService_socketpair;
-		Java_sun_nio_fs_BsdWatchService_poll;
-		Java_sun_nio_fs_BsdNativeDispatcher_init;
-		Java_sun_nio_fs_BsdNativeDispatcher_fgetxattr0;
-		Java_sun_nio_fs_BsdNativeDispatcher_flistxattr;
-		Java_sun_nio_fs_BsdNativeDispatcher_fsetxattr0;
-		Java_sun_nio_fs_BsdNativeDispatcher_fremovexattr0;
-		Java_sun_nio_fs_BsdNativeDispatcher_setmntent0;
-		Java_sun_nio_fs_BsdNativeDispatcher_endmntent;
 		Java_sun_nio_fs_UnixNativeDispatcher_init;
 		Java_sun_nio_fs_UnixNativeDispatcher_getcwd;
 		Java_sun_nio_fs_UnixNativeDispatcher_strerror;
--- ./jdk/make/java/npt/Makefile	2010-03-18 01:44:56.000000000 -0700
+++ ./jdk/make/java/npt/Makefile	2010-01-30 09:40:00.000000000 -0800
@@ -68,6 +68,18 @@
   OTHER_LCF += -export:nptInitialize -export:nptTerminate
 endif
 
+# Add location of iconv headers
+ifeq ($(PLATFORM), bsd)
+  ifeq ($(OS_VENDOR), Apple)
+    OTHER_LDLIBS += -liconv
+  else
+    ifneq ($(OS_NAME), netbsd)
+      CPPFLAGS += -I$(PACKAGE_PATH)/include
+      OTHER_LDLIBS += -L$(PACKAGE_PATH)/lib -liconv
+    endif
+  endif
+endif
+
 #
 # Add to ambient vpath so we pick up the library files
 #
--- ./jdk/make/java/redist/fonts/Makefile	2010-03-18 01:44:56.000000000 -0700
+++ ./jdk/make/java/redist/fonts/Makefile	2010-01-30 13:42:52.000000000 -0800
@@ -43,7 +43,7 @@
 	$(LIBDIR)/fonts/LucidaSansRegular.ttf       	\
 	$(LIBDIR)/fonts/LucidaSansDemiBold.ttf       	\
 
-ifeq ($(PLATFORM), linux)
+ifneq (,$(findstring $(PLATFORM), linux bsd))
 
 # The oblique versions of the font are derived from the base versions
 # and since 2D can do this derivation on the fly at run time there is no
@@ -83,7 +83,7 @@
 $(FONTSDIRFILE): $(PLATFORM_SRC)/classes/sun/awt/motif/java.fonts.dir
 	$(install-file)
 
-ifeq ($(PLATFORM), linux)
+ifneq (,$(findstring $(PLATFORM), linux bsd))
 
 # The oblique fonts are only needed/wanted on Linux.
 
@@ -97,7 +97,7 @@
 $(OBLFONTSDIRFILE): $(PLATFORM_SRC)/classes/sun/awt/motif/java.oblique-fonts.dir
 	$(install-file)
 
-endif # linux
+endif # linux || bsd
 
 all build : $(INTERNAL_IMPORT_LIST)
 
--- ./jdk/make/java/security/Makefile	2010-03-18 01:44:56.000000000 -0700
+++ ./jdk/make/java/security/Makefile	2010-01-30 09:40:00.000000000 -0800
@@ -50,7 +50,15 @@
   ifneq ($(ARCH_DATA_MODEL), 64)
     PROPS_SRC   = $(TOPDIR)/src/share/lib/security/java.security-windows
   endif
+
+else # windows
+
+ifeq ($(PLATFORM), bsd)
+  ifeq ($(OS_VENDOR), OpenBSD)
+    PROPS_SRC   = $(TOPDIR)/src/share/lib/security/java.security-openbsd
+  endif
 endif
+endif # windows
 endif # PLATFORM
 
 
--- ./jdk/make/java/zip/FILES_c.gmk	2010-03-18 01:44:56.000000000 -0700
+++ ./jdk/make/java/zip/FILES_c.gmk	2010-01-30 09:27:23.000000000 -0800
@@ -29,7 +29,10 @@
 	Deflater.c \
 	Inflater.c \
 	ZipFile.c \
-	zip_util.c \
+	zip_util.c
+
+ifneq ($(SYSTEM_ZLIB),true)
+FILES_c += \
 	compress.c \
 	deflate.c \
 	gzio.c \
@@ -41,4 +44,5 @@
 	uncompr.c \
 	zadler32.c \
 	zcrc32.c \
-	zutil.c 
+	zutil.c
+endif
--- ./jdk/make/java/zip/Makefile	2010-03-18 01:44:56.000000000 -0700
+++ ./jdk/make/java/zip/Makefile	2010-01-30 09:40:00.000000000 -0800
@@ -72,16 +72,28 @@
 CPPFLAGS += -UDEBUG 
 endif
 
-CPPFLAGS += -I$(SHARE_SRC)/native/java/util/zip/zlib-$(ZLIB_VERSION)
 CPPFLAGS += -I$(SHARE_SRC)/native/java/io
 CPPFLAGS += -I$(PLATFORM_SRC)/native/java/io
 
+ifeq ($(PLATFORM),bsd)
+CPPFLAGS += -I$(PLATFORM_SRC)/hpi/include
+endif
+
+ifneq ($(SYSTEM_ZLIB),true)
+CPPFLAGS += -I$(SHARE_SRC)/native/java/util/zip/zlib-$(ZLIB_VERSION)
+
 #
 # Add to ambient vpath so we pick up the library files
 #
 vpath %.c $(SHARE_SRC)/native/$(PKGDIR)/zlib-$(ZLIB_VERSION)
+endif
 
 #
 # Link to JVM library for JVM_Zip* functions
 #
+ifeq ($(SYSTEM_ZLIB),true)
+OTHER_LDLIBS = -lz
+else
 OTHER_LDLIBS = $(JVMLIB)
+endif
+
--- ./jdk/make/javax/sound/FILES_c.gmk	2010-03-18 01:44:56.000000000 -0700
+++ ./jdk/make/javax/sound/FILES_c.gmk	2010-01-30 09:27:23.000000000 -0800
@@ -34,6 +34,8 @@
 
 FILES_linux = 
 
+FILES_bsd =
+
 FILES_windows = \
 	PLATFORM_API_WinOS_MidiIn.c \
 	PLATFORM_API_WinOS_MidiOut.c \
--- ./jdk/make/javax/sound/Makefile	2010-03-18 01:44:56.000000000 -0700
+++ ./jdk/make/javax/sound/Makefile	2010-03-08 21:38:21.000000000 -0800
@@ -108,6 +108,16 @@
   #MXSPP_ADD = $(PLATFORM)-$(ARCH)/
 endif # PLATFORM linux
 
+# XXXBSD: ???
+ifeq ($(PLATFORM), bsd)
+    # build with empty MIDI i/o
+    INCLUDE_MIDI = TRUE
+    # build with empty ports
+    INCLUDE_PORTS = TRUE
+    # build with empty direct audio
+    INCLUDE_DAUDIO = TRUE
+endif # PLATFORM bsd
+
 ifeq ($(PLATFORM), solaris)
   # build with ports and direct audio
   CPPFLAGS += -DUSE_PORTS=TRUE 	\
--- ./jdk/make/javax/sound/SoundDefs.gmk	2010-03-18 01:44:56.000000000 -0700
+++ ./jdk/make/javax/sound/SoundDefs.gmk	2010-01-30 09:27:23.000000000 -0800
@@ -40,6 +40,10 @@
   CPPFLAGS += -DX_PLATFORM=X_LINUX
 endif # PLATFORM linux
 
+ifeq ($(PLATFORM), bsd)
+  CPPFLAGS += -DX_PLATFORM=X_BSD
+endif # PLATFORM bsd
+
 ifeq ($(PLATFORM), solaris)
   CPPFLAGS += -DX_PLATFORM=X_SOLARIS
 
--- ./jdk/make/jpda/back/Makefile	2010-03-18 01:44:56.000000000 -0700
+++ ./jdk/make/jpda/back/Makefile	2010-01-30 09:40:00.000000000 -0800
@@ -50,8 +50,10 @@
                  -I$(GENNATIVESRCDIR)/jdwp
 
 ifneq ($(PLATFORM), windows)
+ifneq ($(PLATFORM), bsd)
   OTHER_LDLIBS += -ldl
 endif # PLATFORM
+endif # PLATFORM
 
 #
 # This controls the ability to do logging in the library.
--- ./jdk/make/jpda/transport/socket/Makefile	2010-03-18 01:44:56.000000000 -0700
+++ ./jdk/make/jpda/transport/socket/Makefile	2010-01-30 09:40:00.000000000 -0800
@@ -41,6 +41,11 @@
   OTHER_LDLIBS += -lnsl $(LIBSOCKET) -lpthread
 endif
 
+ifeq ($(PLATFORM), bsd)
+  LIBSOCKET =
+  OTHER_LDLIBS += -pthread
+endif
+
 ifeq ($(PLATFORM), solaris)
   OTHER_LDLIBS += -lnsl $(LIBSOCKET)
 endif
--- ./jdk/make/sun/awt/Makefile	2010-03-18 01:44:57.000000000 -0700
+++ ./jdk/make/sun/awt/Makefile	2010-02-19 08:02:41.000000000 -0800
@@ -124,6 +124,13 @@
 OTHER_LDLIBS = $(JVMLIB) $(LIBM) -ldl
 endif
 
+ifeq  ($(PLATFORM), bsd)
+FILES_c = $(FILES_2D_c)
+FILES_c += awt_LoadLibrary.c
+OTHER_CFLAGS += -DMLIB_NO_LIBSUNMATH
+OTHER_LDLIBS = $(JVMLIB) $(LIBM)
+endif
+
 FILES_c += initIDs.c
 
 # ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SOLARIS/LINUX
@@ -237,7 +244,7 @@
 # ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ WINDOWS
 endif # PLATFORM
 
-ifeq ($(PLATFORM), linux)
+ifneq (,$(findstring $(PLATFORM), linux bsd))
 # vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv LINUX
 vpath %.c   $(SHARE_SRC)/native/$(PKGDIR)/../java2d/opengl
 vpath %.c   $(PLATFORM_SRC)/native/$(PKGDIR)/../java2d/opengl
@@ -392,6 +399,19 @@
 # ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ SOLARIS
 endif # PLATFORM
 
+ifeq ($(PLATFORM), bsd)
+# vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv BSD
+
+FONTCONFIGS_SRC = $(PLATFORM_SRC)/classes/sun/awt/fontconfigs
+_FONTCONFIGS   = \
+       fontconfig.properties
+
+FONTCONFIGS_SRC_PREFIX = $(PLATFORM).
+
+# ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ BSD
+endif # PLATFORM
+
+
 FONTCONFIGS     = $(_FONTCONFIGS:%=$(LIBDIR)/%.src)
 BINARYFONTCONFIGS = $(_FONTCONFIGS:%.properties=$(LIBDIR)/%.bfc)
 
@@ -485,6 +505,9 @@
             -I$(OPENWIN_HOME)/include/X11/extensions \
             -I$(PLATFORM_SRC)/native/$(PKGDIR)/font 
 endif
+ifeq ($(PLATFORM), bsd)
+CPPFLAGS += -I$(PLATFORM_SRC)/native/$(PKGDIR)/font 
+endif
 CPPFLAGS += -I$(SHARE_SRC)/native/$(PKGDIR)/debug \
             -I$(SHARE_SRC)/native/$(PKGDIR)/../font \
             -I$(PLATFORM_SRC)/native/$(PKGDIR)/../font \
@@ -506,7 +529,13 @@
             -I$(PLATFORM_SRC)/native/$(PKGDIR) \
 	    $(EVENT_MODEL)
 
-ifeq ($(PLATFORM), linux)
+# include these last so we don't pick up unintentional includes
+ifeq ($(PLATFORM), bsd)
+CPPFLAGS += -I$(OPENWIN_HOME)/include \
+            -I$(OPENWIN_HOME)/include/X11/extensions
+endif
+
+ifneq (,$(findstring $(PLATFORM), linux bsd))
 LDFLAGS += -L$(OPENWIN_LIB)
 endif
 
--- ./jdk/make/sun/awt/mapfile-vers-bsd	2010-03-27 11:09:14.000000000 -0700
+++ ./jdk/make/sun/awt/mapfile-vers-bsd	2010-01-30 09:27:25.000000000 -0800
@@ -532,11 +532,11 @@
 
 		X11SurfaceData_GetOps;
 		getDefaultConfig;
-                Java_sun_font_FontConfigManager_getFontConfig;
-                Java_sun_font_FontConfigManager_getFontConfigAASettings;
-		Java_sun_awt_X11FontManager_getFontPath;
-		Java_sun_awt_X11FontManager_setNativeFontPath;
-		Java_sun_font_SunFontManager_populateFontFileNameMap;
+                Java_sun_font_FontManager_getFontConfig;
+                Java_sun_font_FontManager_getFontConfigAASettings;
+		Java_sun_font_FontManager_getFontPath;
+		Java_sun_font_FontManager_setNativeFontPath;
+		Java_sun_font_FontManager_populateFontFileNameMap;
 
 		# CDE private entry point
 		Java_sun_awt_motif_XsessionWMcommand;
--- ./jdk/make/sun/awt/mawt.gmk	2010-03-18 01:44:57.000000000 -0700
+++ ./jdk/make/sun/awt/mawt.gmk	2010-01-30 09:27:25.000000000 -0800
@@ -169,7 +169,7 @@
 OTHER_LDLIBS = -lXt -lXext $(LIBXTST) $(LIBXMU) -lX11 -lXi
 endif
 
-ifeq ($(PLATFORM), linux)
+ifneq (,$(findstring $(PLATFORM), linux bsd))
 OTHER_CFLAGS += -DMLIB_NO_LIBSUNMATH
 # XXX what is this define below? Isn't it motif-related?
 OTHER_CFLAGS += -DXMSTRINGDEFINES=1
@@ -180,7 +180,11 @@
 # !HEADLESS
 
 OTHER_LDLIBS += $(JVMLIB) $(LIBCXX) \
-                -lawt $(LIBM) -ldl
+                -lawt $(LIBM)
+
+ifneq ($(PLATFORM), bsd)
+OTHER_LDLIBS += -ldl
+endif
 
 #
 # Sun CC with -Xa misdefines __STDC__ to 0 (zero).
@@ -198,6 +202,9 @@
 ifndef HEADLESS
 CPPFLAGS += -I$(OPENWIN_HOME)/include 
 LDFLAGS  += -L$(OPENWIN_LIB)
+ifeq ($(OS_NAME), netbsd)
+LDFLAGS  += -Wl,-R$(OPENWIN_LIB)
+endif
 
 endif # !HEADLESS
 
@@ -223,16 +230,33 @@
         -I$(PLATFORM_SRC)/native/$(PKGDIR) \
         $(EVENT_MODEL)
 
+CPPFLAGS += -I$(CUPS_HEADERS_PATH)
+
+ifndef HEADLESS
+CPPFLAGS += -I$(MOTIF_DIR)/include \
+            -I$(OPENWIN_HOME)/include 
+LDFLAGS  += -L$(MOTIF_LIB) -L$(OPENWIN_LIB)
+
+endif # !HEADLESS
+
 ifeq ($(PLATFORM), linux)
 # Checking for the X11/extensions headers at the additional location
   CPPFLAGS += -I/X11R6/include/X11/extensions \
               -I/usr/include/X11/extensions
 endif
 
+ifeq ($(PLATFORM), bsd)
+  CPPFLAGS += -I$(OPENWIN_HOME)/include/X11/extensions \
+              -I$(OPENWIN_HOME)/include 
+endif
+
 ifeq ($(PLATFORM), solaris)
   CPPFLAGS += -I$(OPENWIN_HOME)/include/X11/extensions
 endif
 
+ifneq ($(PLATFORM), windows)
+  CPPFLAGS += -DX11_PATH=\"$(X11_PATH)\" -DPACKAGE_PATH=\"$(PACKAGE_PATH)\"
+endif
 
 LDFLAGS += -L$(LIBDIR)/$(LIBARCH)/$(TSOBJDIR) \
 	   $(AWT_RUNPATH)
--- ./jdk/make/sun/font/Makefile	2010-03-18 01:44:57.000000000 -0700
+++ ./jdk/make/sun/font/Makefile	2010-01-30 09:40:00.000000000 -0800
@@ -174,6 +174,15 @@
 # Libraries to link, and other C flags.
 #
 
+ifeq ($(PLATFORM), bsd)
+OTHER_INCLUDES += -I$(X11_PATH)/include
+OTHER_LDLIBS  += -lawt $(LIBM) $(LIBCXX)
+ ifeq ($(OS_VENDOR),Apple)
+   # XXXDARWIN Match BSD/Linux behavior -- the mawt.dylib symbols will
+   # be available at runtime.
+   OTHER_LDLIBS += -flat_namespace -undefined suppress
+ endif
+else
 ifeq ($(PLATFORM), solaris)
   # Note that on Solaris, fontmanager is built against the headless library.
   LDFLAGS      += -L$(LIBDIR)/$(LIBARCH)/headless
@@ -184,6 +193,7 @@
     OTHER_LDLIBS  += -Wl,-Bstatic -lgcc_eh -Wl,-Bdynamic
   endif                           
 endif
+endif
 
 endif # PLATFORM
 
--- ./jdk/make/sun/image/generic/Makefile	2010-03-18 01:44:57.000000000 -0700
+++ ./jdk/make/sun/image/generic/Makefile	2010-01-30 09:40:00.000000000 -0800
@@ -69,5 +69,9 @@
             -I$(PLATFORM_SRC)/native/$(PKGDIR)/medialib 
 
 OTHER_CFLAGS += -D__USE_J2D_NAMES -D__MEDIALIB_OLD_NAMES
-OTHER_LDLIBS = $(LIBM) -ldl
+OTHER_LDLIBS = $(LIBM)
+ifneq ($(PLATFORM), bsd)
+OTHER_LDLIBS += -ldl
+endif
+
 
--- ./jdk/make/sun/jawt/Makefile	2010-03-18 01:44:57.000000000 -0700
+++ ./jdk/make/sun/jawt/Makefile	2010-01-30 09:40:00.000000000 -0800
@@ -93,8 +93,7 @@
 #
 # Other extra flags needed for compiling.
 #
-CPPFLAGS += -I$(OPENWIN_HOME)/include \
-	    -I$(SHARE_SRC)/native/$(PKGDIR)/debug \
+CPPFLAGS += -I$(SHARE_SRC)/native/$(PKGDIR)/debug \
             -I$(SHARE_SRC)/native/$(PKGDIR)/image \
 	    -I$(SHARE_SRC)/native/$(PKGDIR)/image/cvutils \
 	    -I$(SHARE_SRC)/native/$(PKGDIR)/alphacomposite \
@@ -108,6 +107,7 @@
 	    -I$(SHARE_SRC)/native/$(PKGDIR)/../dc/doe \
 	    -I$(SHARE_SRC)/native/$(PKGDIR)/../dc/path \
             -I$(PLATFORM_SRC)/native/$(PKGDIR)/../jdga \
+	    -I$(OPENWIN_HOME)/include \
 	    $(EVENT_MODEL)
 #
 # Libraries to link in.
@@ -116,7 +116,7 @@
 OTHER_LDLIBS = -L$(LIBDIR)/$(LIBARCH) -L$(OPENWIN_LIB) -L$(LIBDIR)/$(LIBARCH)/xawt -lmawt
 endif # PLATFORM
 
-ifeq ($(PLATFORM), linux)
+ifneq (,$(findstring $(PLATFORM), linux bsd))
 OTHER_LDLIBS = -L$(LIBDIR)/$(LIBARCH) -lawt -L$(LIBDIR)/$(LIBARCH)/xawt -lmawt
 endif # PLATFORM
 
--- ./jdk/make/sun/security/ec/Makefile	2010-03-18 01:44:57.000000000 -0700
+++ ./jdk/make/sun/security/ec/Makefile	2010-01-30 09:40:01.000000000 -0800
@@ -193,7 +193,11 @@
   ifeq ($(PLATFORM), windows)
     OTHER_LDLIBS += $(JVMLIB)
   else
-    OTHER_LDLIBS = -ldl $(JVMLIB) $(LIBCXX)
+    ifeq ($(PLATFORM), bsd)
+      OTHER_LDLIBS = $(JVMLIB) $(LIBCXX)
+    else
+      OTHER_LDLIBS = -ldl $(JVMLIB) $(LIBCXX)
+    endif
   endif
 
   include $(BUILDDIR)/common/Mapfile-vers.gmk
--- ./jdk/make/sun/security/jgss/wrapper/Makefile	2010-03-18 01:44:57.000000000 -0700
+++ ./jdk/make/sun/security/jgss/wrapper/Makefile	2010-01-30 09:40:01.000000000 -0800
@@ -72,6 +72,10 @@
 #
 # Libraries to link
 #
-ifneq ($(PLATFORM), windows)
+ifneq (,$(findstring $(PLATFORM), linux solaris))
   OTHER_LDLIBS = -ldl $(JVMLIB)
 endif
+
+ifeq ($(PLATFORM), bsd)
+  OTHER_LDLIBS = $(JVMLIB)
+endif
--- ./jdk/make/sun/security/pkcs11/Makefile	2010-03-18 01:44:57.000000000 -0700
+++ ./jdk/make/sun/security/pkcs11/Makefile	2010-01-30 09:40:01.000000000 -0800
@@ -156,7 +156,7 @@
 #
 # Libraries to link
 #
-ifeq ($(PLATFORM), windows)
+ifneq (,$(findstring $(PLATFORM), windows bsd))
   OTHER_LDLIBS = $(JVMLIB)
 else
   OTHER_LDLIBS = -ldl $(JVMLIB)
--- ./jdk/make/sun/security/smartcardio/Makefile	2010-03-18 01:44:57.000000000 -0700
+++ ./jdk/make/sun/security/smartcardio/Makefile	2010-01-30 09:40:01.000000000 -0800
@@ -76,6 +76,10 @@
 ifeq ($(PLATFORM), windows)
   OTHER_LDLIBS = $(JVMLIB) winscard.lib
 else
-  OTHER_LDLIBS = -ldl $(JVMLIB)
+  ifeq ($(PLATFORM), bsd)
+    OTHER_LDLIBS = $(JVMLIB)
+  else
+    OTHER_LDLIBS = -ldl $(JVMLIB)
+  endif
   OTHER_CFLAGS = -D__sun_jdk
 endif
--- ./jdk/make/sun/splashscreen/FILES_c.gmk	2010-03-18 01:44:57.000000000 -0700
+++ ./jdk/make/sun/splashscreen/FILES_c.gmk	2010-01-30 09:27:26.000000000 -0800
@@ -49,18 +49,6 @@
 	dgif_lib.c \
 	gif_err.c \
 	gifalloc.c \
-	compress.c \
-	deflate.c \
-	gzio.c \
-	infback.c \
-	inffast.c \
-	inflate.c \
-	inftrees.c \
-	trees.c \
-	uncompr.c \
-	zadler32.c \
-	zcrc32.c \
-	zutil.c \
 	jcomapi.c \
 	jdapimin.c \
 	jdapistd.c \
@@ -106,3 +94,18 @@
 	jfdctfst.c \
 	jfdctint.c
 
+ifneq ($(SYSTEM_ZLIB),true)
+  FILES_c += \
+	compress.c \
+	deflate.c \
+	gzio.c \
+	infback.c \
+	inffast.c \
+	inflate.c \
+	inftrees.c \
+	trees.c \
+	uncompr.c \
+	zadler32.c \
+	zcrc32.c \
+	zutil.c
+endif
--- ./jdk/make/sun/splashscreen/Makefile	2010-03-18 01:44:57.000000000 -0700
+++ ./jdk/make/sun/splashscreen/Makefile	2010-01-30 09:40:01.000000000 -0800
@@ -64,8 +64,24 @@
 
 ifneq ($(PLATFORM), windows)
   CFLAGS += -DWITH_X11
-  CPPFLAGS += -I$(OPENWIN_HOME)/include -I$(OPENWIN_HOME)/include/X11/extensions
-  OTHER_LDLIBS += -L$(OPENWIN_LIB) -lX11 -lXext $(LIBM) -lpthread
+  ifeq ($(PLATFORM), bsd)
+    ifeq ($(OS_VENDOR), Apple)
+      OTHER_LDLIBS += -liconv
+    else
+      ifneq ($(OS_NAME), netbsd)
+        CPPFLAGS += -I$(PACKAGE_PATH)/include
+        OTHER_LDLIBS += -L$(PACKAGE_PATH)/lib -liconv
+      else
+        OTHER_LDLIBS += -Wl,-R$(OPENWIN_LIB)
+      endif
+    endif
+    CPPFLAGS += -I$(OPENWIN_HOME)/include \
+                -I$(OPENWIN_HOME)/include/X11/extensions
+    OTHER_LDLIBS += -L$(OPENWIN_LIB) -lX11 -lXext $(LIBM) -pthread
+  else
+    CPPFLAGS += -I$(OPENWIN_HOME)/include -I$(OPENWIN_HOME)/include/X11/extensions
+    OTHER_LDLIBS += -L$(OPENWIN_LIB) -lX11 -lXext $(LIBM) -lpthread
+  endif
 else # PLATFORM
   CFLAGS += -DWITH_WIN32
   OTHER_LDLIBS += kernel32.lib user32.lib gdi32.lib delayimp.lib /DELAYLOAD:user32.dll
@@ -78,13 +94,20 @@
 vpath %.c   $(SHARE_SRC)/native/$(PKGDIR)/splashscreen
 vpath %.c   $(SHARE_SRC)/native/$(PKGDIR)
 vpath %.c   $(SHARE_SRC)/native/$(PKGDIR)/giflib
-vpath %.c   $(SHARE_SRC)/native/java/util/zip/zlib-$(ZLIB_VERSION)
+ifneq ($(SYSTEM_ZLIB),true)
+  vpath %.c   $(SHARE_SRC)/native/java/util/zip/zlib-$(ZLIB_VERSION)
+endif
 vpath %.c   $(SHARE_SRC)/native/$(PKGDIR)/libpng
 vpath %.c   $(SHARE_SRC)/native/$(PKGDIR)/image/jpeg
 vpath %.c   $(PLATFORM_SRC)/native/$(PKGDIR)/splashscreen
 
 CPPFLAGS += -I$(PLATFORM_SRC)/native/$(PKGDIR)/splashscreen -I$(SHARE_SRC)/native/$(PKGDIR)/splashscreen
-CPPFLAGS += -I$(SHARE_SRC)/native/$(PKGDIR)/image/jpeg -I$(SHARE_SRC)/native/java/util/zip/zlib-$(ZLIB_VERSION)
+CPPFLAGS += -I$(SHARE_SRC)/native/$(PKGDIR)/image/jpeg
+ifneq ($(SYSTEM_ZLIB),true)
+  CPPFLAGS += -I$(SHARE_SRC)/native/java/util/zip/zlib-$(ZLIB_VERSION)
+else
+  OTHER_LDLIBS += -lz
+endif
 
 # Shun the less than portable MMX assembly code in pnggccrd.c,
 # and use alternative implementations in C.
--- ./jdk/make/sun/xawt/Makefile	2010-03-18 01:44:57.000000000 -0700
+++ ./jdk/make/sun/xawt/Makefile	2010-01-30 09:40:01.000000000 -0800
@@ -48,12 +48,20 @@
 AUTO_JAVA_PRUNE = WrapperGenerator.java
 
 LDFLAGS += -L$(OPENWIN_LIB)
+ifeq ($(OS_NAME), netbsd)
+LDFLAGS += -Wl,-R$(OPENWIN_LIB)
+endif
 
 ifeq ($(PLATFORM), linux)
 LDFLAGS += -lpthread
 dummy := $(shell $(MKDIR) -p $(LIB_LOCATION))
 endif
 
+ifeq ($(PLATFORM), bsd)
+LDFLAGS += -pthread
+dummy := $(shell $(MKDIR) -p $(LIB_LOCATION))
+endif
+
 # Since this library will be living in a subdirectory below the other libraries
 #   we need to add an extra runpath so that libraries in the upper directory
 #   are found at runtime.
@@ -88,7 +96,12 @@
 vpath %.c   $(PLATFORM_SRC)/native/sun/java2d/opengl
 vpath %.c   $(PLATFORM_SRC)/native/sun/java2d/x11
 
-OTHER_LDLIBS = $(LIBM) -lawt -lXext -lX11 -ldl \
+ifeq ($(PLATFORM), bsd)
+LIBDL=
+else
+LIBDL=-ldl
+endif
+OTHER_LDLIBS = $(LIBM) -lawt -lXext -lX11 $(LIBDL) \
                    $(LDFLAGS_COMMON) $(AWT_RUNPATH) $(OTHER_LDFLAGS) -lXtst -lXi
 
 ifeq  ($(PLATFORM), solaris)
@@ -96,8 +109,6 @@
 dummy := $(shell $(MKDIR) -p $(LIB_LOCATION))
 endif
 
-CPPFLAGS += -I$(CUPS_HEADERS_PATH)
-
 CPPFLAGS += -DXAWT -DXAWT_HACK \
         -I$(TEMPDIR)/../../sun.awt/awt/CClassHeaders \
         -I$(PLATFORM_SRC)/native/sun/awt \
@@ -124,9 +135,11 @@
         -I$(SHARE_SRC)/native/sun/awt \
         -I$(PLATFORM_SRC)/native/sun/awt 
 
+CPPFLAGS += -I$(CUPS_HEADERS_PATH)
+
 ifeq ($(PLATFORM), linux)
 # Allows for builds on Debian GNU Linux, X11 is in a different place 
-  CPPFLAGS += -I/usr/X11R6/include/X11/extensions \
+  CPPFLAGS += -I$(OPENWIN_HOME)/include/X11/extensions \
               -I/usr/include/X11/extensions \
               -I$(OPENWIN_HOME)/include 
 endif
@@ -135,6 +148,14 @@
   CPPFLAGS += -I$(OPENWIN_HOME)/include/X11/extensions
 endif
 
+ifeq ($(PLATFORM), bsd)
+  CPPFLAGS += -I$(OPENWIN_HOME)/include/X11/extensions -I$(OPENWIN_HOME)/include
+endif
+
+ifneq ($(PLATFORM), windows)
+  CPPFLAGS += -DX11_PATH=\"$(X11_PATH)\" -DPACKAGE_PATH=\"$(PACKAGE_PATH)\"
+endif
+
 ifeq ($(MILESTONE), internal)
   CPPFLAGS += -DINTERNAL_BUILD
 endif
--- ./jdk/make/tools/freetypecheck/Makefile	2010-03-18 01:44:59.000000000 -0700
+++ ./jdk/make/tools/freetypecheck/Makefile	2010-01-30 09:27:28.000000000 -0800
@@ -49,8 +49,15 @@
   # Add runtime lib search path to ensure test will be runnable
   ifeq ($(PLATFORM), solaris)
     FT_LD_OPTIONS += -R $(FREETYPE_LIB_PATH) -lfreetype
-  else #linux
+  else 
+    ifeq ($(PLATFORM), bsd)
+      ifeq ($(OS_NAME), netbsd)
+        FT_LD_OPTIONS += -Wl,-R$(FREETYPE_LIB_PATH)
+      endif
+      FT_LD_OPTIONS += -lfreetype -lz
+    else # linux
       FT_LD_OPTIONS += -Wl,-rpath -Wl,$(FREETYPE_LIB_PATH) -lfreetype
+    endif
   endif
 endif
 FT_OPTIONS += -I$(FREETYPE_HEADERS_PATH)
--- ./jdk/src/share/back/commonRef.c	2010-03-18 01:45:00.000000000 -0700
+++ ./jdk/src/share/back/commonRef.c	2010-01-30 09:27:31.000000000 -0800
@@ -23,6 +23,10 @@
  * have any questions.
  */
 
+#if defined(_ALLBSD_SOURCE)
+#include <stdint.h>			/* for uintptr_t */
+#endif
+
 #include "util.h"
 #include "commonRef.h"
 
--- ./jdk/src/share/bin/java.c	2010-03-18 01:45:00.000000000 -0700
+++ ./jdk/src/share/bin/java.c	2010-01-30 09:27:31.000000000 -0800
@@ -66,6 +66,10 @@
 static jboolean printUsage = JNI_FALSE;   /* print and exit*/
 static jboolean printXUsage = JNI_FALSE;  /* print and exit*/
 
+#ifdef __APPLE__
+static jboolean continueInSameThread = JNI_FALSE; /* start VM in current thread */
+#endif
+
 static const char *_program_name;
 static const char *_launcher_name;
 static jboolean _is_java_args = JNI_FALSE;
@@ -115,6 +119,10 @@
 static void DumpState();
 static jboolean RemovableOption(char *option);
 
+#ifdef __APPLE__
+static int ContinueInSameThread(InvocationFunctions* ifn, int argc, char **argv, char *jarfile, char *classname, int ret);
+#endif
+
 /* Maximum supported entries from jvm.cfg. */
 #define INIT_MAX_KNOWN_VMS      10
 
@@ -297,9 +305,16 @@
 
     /* Show the splash screen if needed */
     ShowSplashScreen();
-
+   
+#ifdef __APPLE__
+    if (continueInSameThread == JNI_TRUE) {
+        return ContinueInSameThread(&ifn, argc, argv, jarfile, classname, ret);
+    } else {
+        return ContinueInNewThread(&ifn, argc, argv, jarfile, classname, ret);
+    }
+#else
     return ContinueInNewThread(&ifn, argc, argv, jarfile, classname, ret);
-
+#endif
 }
 
 #define CHECK_EXCEPTION_NULL_LEAVE(e) \
@@ -1015,6 +1030,12 @@
         } else if (JLI_StrCmp(arg, "-X") == 0) {
             printXUsage = JNI_TRUE;
             return JNI_TRUE;
+#ifdef __APPLE__
+        } else if (JLI_StrCmp(arg, "-XstartOnFirstThread") == 0) {
+            continueInSameThread = JNI_TRUE;
+        } else if (JLI_StrCCmp(arg, "-Xdock:") == 0) {
+           // XXXDARWIN: Apple VM supports configuration of Dock icon and name via -Xdock:
+#endif            
 /*
  * The following case provide backward compatibility with old-style
  * command line options.
@@ -1902,6 +1923,44 @@
     }
 }
 
+#ifdef __APPLE__
+static int
+ContinueInSameThread(InvocationFunctions* ifn, int argc,
+                    char **argv, char *jarfile, char *classname, int ret)
+{
+        
+    /*
+     * If user doesn't specify stack size, check if VM has a preference.
+     * Note that HotSpot no longer supports JNI_VERSION_1_1 but it will
+     * return its default stack size through the init args structure.
+     */
+    if (threadStackSize == 0) {
+        struct JDK1_1InitArgs args1_1;
+        memset((void*)&args1_1, 0, sizeof(args1_1));
+        args1_1.version = JNI_VERSION_1_1;
+        ifn->GetDefaultJavaVMInitArgs(&args1_1);  /* ignore return value */
+        if (args1_1.javaStackSize > 0) {
+            threadStackSize = args1_1.javaStackSize;
+        }
+    }
+    
+    { /* Create create JVM and invoke main method */
+        JavaMainArgs args;
+        int rslt;
+        
+        args.argc = argc;
+        args.argv = argv;
+        args.jarfile = jarfile;
+        args.classname = classname;
+        args.ifn = *ifn;
+        
+        rslt = JavaMain((void*)&args);
+        
+        return (ret != 0) ? ret : rslt;
+    }
+}
+#endif
+
 static void
 DumpState()
 {
--- ./jdk/src/share/classes/com/sun/java/swing/plaf/gtk/Metacity.java	2010-03-18 01:45:01.000000000 -0700
+++ ./jdk/src/share/classes/com/sun/java/swing/plaf/gtk/Metacity.java	2010-01-30 09:27:33.000000000 -0800
@@ -477,6 +477,10 @@
                 String[] dirs = new String[] {
                     userHome + sep + ".themes",
                     System.getProperty("swing.metacitythemedir"),
+		    "/usr/X11R6/share/themes",
+		    "/usr/X11R6/share/gnome/themes",
+		    "/usr/local/share/themes",
+		    "/usr/local/share/gnome/themes",
                     "/usr/share/themes",
                     "/usr/gnome/share/themes",  // Debian/Redhat/Solaris
                     "/opt/gnome2/share/themes"  // SuSE
--- ./jdk/src/share/classes/com/sun/jmx/snmp/SnmpPduTrap.java	2010-03-18 01:45:02.000000000 -0700
+++ ./jdk/src/share/classes/com/sun/jmx/snmp/SnmpPduTrap.java	2010-01-30 09:27:35.000000000 -0800
@@ -78,6 +78,9 @@
      */
     public long            timeStamp ;
 
+    // TODO: IcedTea: I am a stub.
+    static public int trapAuthenticationFailure = 0;
+
 
 
     /**
--- ./jdk/src/share/classes/com/sun/media/sound/services/bsd-i586/javax.sound.sampled.spi.MixerProvider	2010-03-27 11:09:12.000000000 -0700
+++ ./jdk/src/share/classes/com/sun/media/sound/services/bsd-i586/javax.sound.sampled.spi.MixerProvider	1969-12-31 16:00:00.000000000 -0800
@@ -1,6 +0,0 @@
-# service provider file for Bsd: with DirectAudioDeviceProvider
-# last mixer is default mixer
-com.sun.media.sound.PortMixerProvider
-com.sun.media.sound.SimpleInputDeviceProvider
-com.sun.media.sound.DirectAudioDeviceProvider
-com.sun.media.sound.HeadspaceMixerProvider
--- ./jdk/src/share/classes/com/sun/servicetag/BsdSystemEnvironment.java	2010-03-27 11:09:14.000000000 -0700
+++ ./jdk/src/share/classes/com/sun/servicetag/BsdSystemEnvironment.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,193 +0,0 @@
-/*
- * Copyright 2008 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-
-package com.sun.servicetag;
-
-// This class is a copy of the com.sun.scn.servicetags.BsdSystemEnvironment
-// class from the Sun Connection source.
-//
-// The Service Tags team maintains the latest version of the implementation
-// for system environment data collection.  JDK will include a copy of
-// the most recent released version for a JDK release. We rename
-// the package to com.sun.servicetag so that the Sun Connection
-// product always uses the latest version from the com.sun.scn.servicetags
-// package. JDK and users of the com.sun.servicetag API
-// (e.g. NetBeans and SunStudio) will use the version in JDK.
-//
-// So we keep this class in src/share/classes instead of src/<os>/classes.
-
-import java.io.*;
-
-/**
- * Bsd implementation of the SystemEnvironment class.
- */
-class BsdSystemEnvironment extends SystemEnvironment {
-    BsdSystemEnvironment() {
-        setHostId(getBsdHostId());
-        setSystemModel(getCommandOutput("/bin/uname", "-i"));
-        setSystemManufacturer(getBsdSystemManufacturer());
-        setCpuManufacturer(getBsdCpuManufacturer());
-        setSerialNumber(getBsdSN());
-    }
-    private String dmiInfo = null;
-
-    private static final int SN  = 1;
-    private static final int SYS = 2;
-    private static final int CPU = 3;
-
-    private String getBsdHostId() {
-        String output = getCommandOutput("/usr/bin/hostid");
-        // trim off the leading 0x
-        if (output.startsWith("0x")) {
-            output = output.substring(2);
-        }
-        return output;
-    }
-
-    /**
-     * Tries to obtain and return the cpu manufacturer.
-     * @return The cpu manufacturer (an empty string if not found or an error occurred)
-     */
-    private String getBsdCpuManufacturer() {
-        String tmp = getBsdPSNInfo(CPU);
-        if (tmp.length() > 0) {
-            return tmp;
-        }
-
-        String contents = getFileContent("/proc/cpuinfo");
-        for (String line : contents.split("\n")) {
-            if (line.contains("vendor_id")) {
-                String[] ss = line.split(":", 2);
-                if (ss.length > 1) {
-                    return ss[1].trim();
-                }
-            }
-        }
-
-        // returns an empty string if it can't be found or an error happened
-        return getBsdDMIInfo("dmi type 4", "manufacturer");
-    }
-
-
-    /**
-     * Tries to obtain and return the system manufacturer.
-     * @return The system manufacturer (an empty string if not found or an error occurred)
-     */
-    private String getBsdSystemManufacturer() {
-        String tmp = getBsdPSNInfo(SYS);
-        if (tmp.length() > 0) {
-            return tmp;
-        }
-
-        // returns an empty string if it can't be found or an error happened
-        return getBsdDMIInfo("dmi type 1", "manufacturer");
-    }
-
-    /**
-     * Tries to obtain and return the serial number of the system.
-     * @return The serial number (an empty string if not found or an error occurred)
-     */
-    private String getBsdSN() {
-        String tmp = getBsdPSNInfo(SN);
-        if (tmp.length() > 0) {
-            return tmp;
-        }
-
-        // returns an empty string if it can't be found or an error happened
-        return getBsdDMIInfo("dmi type 1", "serial number");
-    }
-
-    private String getBsdPSNInfo(int target) {
-        // try to read from the psn file if it exists
-        String contents = getFileContent("/var/run/psn");
-        String[] ss = contents.split("\n");
-        if (target <= ss.length) {
-            return ss[target-1];
-        }
-
-        // default case is to return ""
-        return "";
-    }
-
-    // reads from dmidecode with the given type and target
-    // returns an empty string if nothing was found or an error occurred
-    //
-    // Sample output segment:
-    // Handle 0x0001
-    //         DMI type 1, 25 bytes.
-    //         System Information
-    //                 Manufacturer: System manufacturer
-    //                 Product Name: System Product Name
-    //                 Version: System Version
-    //                 Serial Number: System Serial Number
-    //                 UUID: 3091D719-B25B-D911-959D-6D1B12C7686E
-    //                 Wake-up Type: Power Switch
-
-    private synchronized String getBsdDMIInfo(String dmiType, String target) {
-        // only try to get dmidecode information once, after that, we can
-        // reuse the output
-        if (dmiInfo == null) {
-            Thread dmidecodeThread = new Thread() {
-                public void run() {
-                    dmiInfo = getCommandOutput("/usr/sbin/dmidecode");
-                }
-            };
-            dmidecodeThread.start();
-
-            try {
-                dmidecodeThread.join(2000);
-                if (dmidecodeThread.isAlive()) {
-                    dmidecodeThread.interrupt();
-                    dmiInfo = "";
-                }
-            } catch (InterruptedException ie) {
-                dmidecodeThread.interrupt();
-            }
-        }
-
-        if (dmiInfo.length() == 0) {
-            return "";
-        }
-        boolean dmiFlag = false;
-        for (String s : dmiInfo.split("\n")) {
-            String line = s.toLowerCase();
-            if (dmiFlag) {
-                if (line.contains(target)) {
-                    String key = target + ":";
-                    int indx = line.indexOf(key) + key.length();
-                    if (line.contains(key) && indx < line.length()) {
-                        return line.substring(indx).trim();
-                    }
-                    String[] ss = line.split(":");
-                    return ss[ss.length-1];
-                }
-            } else if (line.contains(dmiType)) {
-                dmiFlag = true;
-            }
-        }
-        return "";
-    }
-
-}
--- ./jdk/src/share/classes/java/awt/GraphicsEnvironment.java	2010-03-18 01:45:06.000000000 -0700
+++ ./jdk/src/share/classes/java/awt/GraphicsEnvironment.java	2010-02-19 08:02:41.000000000 -0800
@@ -172,7 +172,12 @@
                         } else {
                             String osName = System.getProperty("os.name");
                             headless = defaultHeadless =
-                                Boolean.valueOf(("Linux".equals(osName) || "SunOS".equals(osName)) &&
+                                Boolean.valueOf(("Linux".equals(osName) ||
+                                                "SunOS".equals(osName) ||
+                                                "FreeBSD".equals(osName) ||
+                                                "NetBSD".equals(osName) ||
+                                                "OpenBSD".equals(osName) ||
+                                                "Darwin".equals(osName)) &&
                                                 (System.getenv("DISPLAY") == null));
                         }
                     } else if (nm.equals("true")) {
--- ./jdk/src/share/classes/java/util/TimeZone.java	2010-03-18 01:45:11.000000000 -0700
+++ ./jdk/src/share/classes/java/util/TimeZone.java	2010-01-30 09:27:51.000000000 -0800
@@ -776,15 +776,13 @@
         }
         int gmtOffset =  (hours * 60 + num) * 60 * 1000;
 
+        zi = ZoneInfoFile.getCustomTimeZone(id, negative ? -gmtOffset : gmtOffset);
         if (gmtOffset == 0) {
-            zi = ZoneInfoFile.getZoneInfo(GMT_ID);
             if (negative) {
                 zi.setID("GMT-00:00");
             } else {
                 zi.setID("GMT+00:00");
             }
-        } else {
-            zi = ZoneInfoFile.getCustomTimeZone(id, negative ? -gmtOffset : gmtOffset);
         }
         return zi;
     }
--- ./jdk/src/share/classes/sun/awt/FontConfiguration.java	2010-03-18 01:45:18.000000000 -0700
+++ ./jdk/src/share/classes/sun/awt/FontConfiguration.java	2010-01-30 09:28:04.000000000 -0800
@@ -1122,7 +1122,7 @@
      */
     HashMap<String, Boolean> existsMap;
     public boolean needToSearchForFile(String fileName) {
-        if (!FontUtilities.isLinux) {
+        if (!FontUtilities.isLinux || FontUtilities.isBSD) {
             return false;
         } else if (existsMap == null) {
            existsMap = new HashMap<String, Boolean>();
@@ -1362,7 +1362,7 @@
                                    + "<filename."
                                    + getString(table_componentFontNameIDs[ii])
                                    + "> entry is missing!!!");
-                if (!osName.contains("Linux")) {
+                if (!osName.contains("Linux") && !osName.contains("BSD") && !osName.contains("Darwin")) {
                     errors++;
                 }
             }
--- ./jdk/src/share/classes/sun/awt/OSInfo.java	2010-03-18 01:45:18.000000000 -0700
+++ ./jdk/src/share/classes/sun/awt/OSInfo.java	2010-01-30 09:28:04.000000000 -0800
@@ -39,6 +39,7 @@
         WINDOWS,
         LINUX,
         SOLARIS,
+        BSD,
         UNKNOWN
     }
 
@@ -100,6 +101,14 @@
                 return SOLARIS;
             }
 
+            if (osName.contains("BSD")) {
+                return BSD;
+            }
+
+            if (osName.contains("Darwin")) {
+                return BSD;
+            }
+
             // determine another OS here
         }
 
--- ./jdk/src/share/classes/sun/font/FontUtilities.java	2010-03-18 01:45:18.000000000 -0700
+++ ./jdk/src/share/classes/sun/font/FontUtilities.java	2010-02-21 16:55:52.000000000 -0800
@@ -46,6 +46,8 @@
 
     public static boolean isLinux;
 
+    public static boolean isBSD;
+
     public static boolean isSolaris8;
 
     public static boolean isSolaris9;
@@ -70,6 +72,11 @@
 
                 isLinux = osName.startsWith("Linux");
 
+	        isBSD = (osName.startsWith("FreeBSD") ||
+	                 osName.startsWith("NetBSD") ||
+	                 osName.startsWith("OpenBSD") ||
+	                 osName.startsWith("Darwin"));
+
                 String t2kStr = System.getProperty("sun.java2d.font.scaler");
                 if (t2kStr != null) {
                     useT2K = "t2k".equals(t2kStr);
--- ./jdk/src/share/classes/sun/font/SunFontManager.java	2010-03-18 01:45:18.000000000 -0700
+++ ./jdk/src/share/classes/sun/font/SunFontManager.java	2010-03-20 11:12:38.000000000 -0700
@@ -409,7 +409,7 @@
                          * registerFonts method as on-screen these JRE fonts
                          * always go through the T2K rasteriser.
                          */
-                        if (FontUtilities.isLinux) {
+                        if (FontUtilities.isLinux || FontUtilities.isBSD) {
                             /* Linux font configuration uses these fonts */
                             registerFontDir(jreFontDirName);
                         }
--- ./jdk/src/share/classes/sun/io/ByteToCharEUC_JP_BSD.java	2010-03-27 11:09:14.000000000 -0700
+++ ./jdk/src/share/classes/sun/io/ByteToCharEUC_JP_BSD.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,190 +0,0 @@
-/*
- * Copyright 2000 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-
-package sun.io;
-
-/**
- * Class for converting bytes to characters for the EUC-JP encoding in
- * bsd. This converter supports the JIS0201 and the JIS0208 encoding and
- * omits support for the JIS212 encoding.
- *
- * @author Naveen Sanjeeva
- */
-
-public class ByteToCharEUC_JP_BSD extends  ByteToCharJIS0208 {
-    private byte savedSecond = 0;
-    ByteToCharJIS0201 bcJIS0201 = new ByteToCharJIS0201();
-
-    public ByteToCharEUC_JP_BSD() {
-        super();
-        start = 0xA1;
-        end = 0xFE;
-        savedSecond = 0;
-    }
-
-    public int flush(char[] output, int outStart, int outEnd)
-        throws MalformedInputException
-    {
-        if (savedSecond != 0) {
-            reset();
-            throw new MalformedInputException();
-        }
-        reset();
-        return 0;
-    }
-
-    /**
-     * Resets the converter.
-     * Call this method to reset the converter to its initial state
-     */
-    public void reset() {
-        super.reset();
-        savedSecond = 0;
-    }
-
-    public String getCharacterEncoding() {
-        return "EUC_JP_BSD";
-    }
-
-    protected char convSingleByte(int b) {
-        if (b < 0 || b > 0x7F)
-            return REPLACE_CHAR;
-        return bcJIS0201.getUnicode(b);
-    }
-
-    protected char getUnicode(int byte1, int byte2) {
-        if (byte1 == 0x8E) {
-            return bcJIS0201.getUnicode(byte2 - 256);
-        }
-        // Fix for bug 4121358 - similar fix for bug 4117820 put
-        // into ByteToCharDoubleByte.getUnicode()
-        if (((byte1 < 0) || (byte1 > index1.length))
-            || ((byte2 < start) || (byte2 > end)))
-            return REPLACE_CHAR;
-
-        int n = (index1[byte1 - 0x80] & 0xf) * (end - start + 1)
-                + (byte2 - start);
-        return index2[index1[byte1 - 0x80] >> 4].charAt(n);
-    }
-
-    /**
-     * Converts sequences of bytes to characters.
-     * Conversions that result in Exceptions can be restarted by calling
-     * convert again, with appropriately modified parameters.
-     * @return the characters written to output.
-     * @param input byte array containing text in Double/single Byte
-     * @param inStart offset in input array
-     * @param inEnd offset of last byte to be converted
-     * @param output character array to receive conversion result
-     * @param outStart starting offset
-     * @param outEnd offset of last byte to be written to
-     * @throw UnsupportedCharacterException for any bytes
-     * that cannot be converted to the external character set.
-     */
-    public int convert(byte[] input, int inOff, int inEnd,
-                       char[] output, int outOff, int outEnd)
-        throws UnknownCharacterException,
-               ConversionBufferFullException
-    {
-        char    outputChar = REPLACE_CHAR;
-        int     inputSize = 0;          // Size of input
-
-        // Record beginning offsets
-        charOff = outOff;
-        byteOff = inOff;
-
-        // Loop until we hit the end of the input
-        while (byteOff < inEnd) {
-            int byte1, byte2;
-
-            if (savedByte == 0) {
-                byte1 = input[byteOff];
-                inputSize = 1;
-            } else {
-                byte1 = savedByte;
-                savedByte = 0;
-                inputSize = 0;
-            }
-
-            outputChar = convSingleByte(byte1);
-
-            if (outputChar == REPLACE_CHAR) {   // Multibyte char
-                if ((byte1 & 0xff) != 0x8F) {   // JIS0208
-                    if (byteOff + inputSize >= inEnd) {
-                        // split in the middle of a character
-                        // save the first byte for next time around
-                        savedByte = (byte) byte1;
-                        byteOff += inputSize;
-                        break;
-                    }
-                    byte1 &= 0xff;
-                    byte2 = input[byteOff + inputSize] & 0xff;
-                    inputSize++;
-                    outputChar = getUnicode(byte1, byte2);
-                } else if ((byte1 & 0xff) == 0x8F) {   // JIS0212
-                    // Handling of 3-byte sequences for this converter involves
-                    // just ignoring the relevant bytes and returning a
-                    // suitable substitute char if one exists.
-                    if (byteOff + inputSize + 1 >= inEnd) {
-                        // split in the middle of a character
-                        // save the first 2 bytes for next time around
-                        savedByte = (byte) byte1;
-                        byteOff += inputSize;
-                        if (byteOff < inEnd) {
-                            savedSecond = input[byteOff];
-                            byteOff++;
-                        }
-                        break;
-                    }
-
-                    // Skip over the saved bytes if any
-                    if (savedSecond != 0) {
-                        savedSecond = 0;
-                    } else {
-                        inputSize++;
-                    }
-                    inputSize++;
-                }
-            }
-
-            if (outputChar == REPLACE_CHAR) {
-                if (subMode)
-                    outputChar = subChars[0];
-                else {
-                    badInputLength = inputSize;
-                    throw new UnknownCharacterException();
-                }
-            }
-
-            if (charOff >= outEnd)
-                throw new ConversionBufferFullException();
-
-            output[charOff++] = outputChar;
-            byteOff += inputSize;
-        }
-
-        return charOff - outOff;
-    }
-}
--- ./jdk/src/share/classes/sun/io/CharToByteEUC_JP_BSD.java	2010-03-27 11:09:14.000000000 -0700
+++ ./jdk/src/share/classes/sun/io/CharToByteEUC_JP_BSD.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,193 +0,0 @@
-/*
- * Copyright 2000 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-
-package sun.io;
-
-/**
- * Class for converting characters to bytes for the EUC-JP encoding in
- * bsd. This converter supports the JIS0201 and the JIS0208 encoding and
- * omits support for the JIS212 encoding.
- *
- * @author Naveen Sanjeeva
- */
-
-public class CharToByteEUC_JP_BSD extends CharToByteJIS0208 {
-    CharToByteJIS0201 cbJIS0201 = new CharToByteJIS0201();
-
-    public String getCharacterEncoding() {
-        return "EUC_JP_BSD";
-    }
-
-    protected int convSingleByte(char inputChar, byte[] outputByte) {
-        byte b;
-
-        if (inputChar == 0) {
-            outputByte[0] = (byte)0;
-            return 1;
-        }
-
-        if ((b = cbJIS0201.getNative(inputChar)) == 0)
-            return 0;
-
-        if (b > 0 && b < 128) {
-            outputByte[0] = b;
-            return 1;
-        }
-        outputByte[0] = (byte)0x8E;
-        outputByte[1] = b;
-        return 2;
-    }
-
-    protected int getNative(char ch) {
-        int offset = index1[((ch & 0xff00) >> 8 )] << 8;
-        int r = index2[offset >> 12].charAt((offset & 0xfff) + (ch & 0xff));
-        if (r != 0)
-            return r + 0x8080;
-        return r;
-    }
-
-    /**
-     * Converts characters to sequences of bytes.
-     * Conversions that result in Exceptions can be restarted by calling
-     * convert again, with appropriately modified parameters.
-     * @return the characters written to output.
-     * @param input char array containing text in Unicode
-     * @param inStart offset in input array
-     * @param inEnd offset of last byte to be converted
-     * @param output byte array to receive conversion result
-     * @param outStart starting offset
-     * @param outEnd offset of last byte to be written to
-     * @throw UnsupportedCharacterException for any character
-     * that cannot be converted to the external character set.
-     */
-    public int convert(char[] input, int inOff, int inEnd,
-                       byte[] output, int outOff, int outEnd)
-        throws MalformedInputException, UnknownCharacterException,
-               ConversionBufferFullException
-    {
-        char    inputChar;                 // Input character to be converted
-        byte[]  outputByte;                // Output byte written to output
-        int     inputSize = 0;             // Size of input
-        int     outputSize = 0;            // Size of output
-        byte[]  tmpbuf = new byte[4];
-
-        // Record beginning offsets
-        charOff = inOff;
-        byteOff = outOff;
-
-        if (highHalfZoneCode != 0) {
-            inputChar = highHalfZoneCode;
-            highHalfZoneCode = 0;
-            if (input[inOff] >= 0xdc00 && input[inOff] <= 0xdfff) {
-                // This is legal UTF16 sequence.
-                badInputLength = 1;
-                throw new UnknownCharacterException();
-            } else {
-                // This is illegal UTF16 sequence.
-                badInputLength = 0;
-                throw new MalformedInputException();
-            }
-        }
-
-        // Loop until we hit the end of the input
-        while(charOff < inEnd) {
-            inputSize = 1;
-            outputByte = tmpbuf;
-            inputChar = input[charOff]; // Get the input character
-
-            // Is this a high surrogate?
-            if(inputChar >= '\uD800' && inputChar <= '\uDBFF') {
-                // Is this the last character of the input?
-                if (charOff + 1 >= inEnd) {
-                    highHalfZoneCode = inputChar;
-                    break;
-                }
-
-                // Is there a low surrogate following?
-                inputChar = input[charOff + 1];
-                if (inputChar >= '\uDC00' && inputChar <= '\uDFFF') {
-                    // We have a valid surrogate pair.  Too bad we don't do
-                    // surrogates.  Is substitution enabled?
-                    if (subMode) {
-                        outputByte = subBytes;
-                        outputSize = subBytes.length;
-                        inputSize = 2;
-                    } else {
-                        badInputLength = 2;
-                        throw new UnknownCharacterException();
-                    }
-                } else {
-                    // We have a malformed surrogate pair
-                    badInputLength = 1;
-                    throw new MalformedInputException();
-                }
-            }
-            // Is this an unaccompanied low surrogate?
-            else if (inputChar >= '\uDC00' && inputChar <= '\uDFFF') {
-                badInputLength = 1;
-                throw new MalformedInputException();
-            } else {
-                outputSize = convSingleByte(inputChar, outputByte);
-                if (outputSize == 0) { // DoubleByte
-                    int ncode = getNative(inputChar);
-                    if (ncode != 0 && ((ncode & 0xFF0000) == 0)) {
-                            outputByte[0] = (byte) ((ncode & 0xff00) >> 8);
-                            outputByte[1] = (byte) (ncode & 0xff);
-                            outputSize = 2;
-                    } else {
-                        if (subMode) {
-                            outputByte = subBytes;
-                            outputSize = subBytes.length;
-                        } else {
-                            badInputLength = 1;
-                            throw new UnknownCharacterException();
-                        }
-                    }
-                }
-            }
-
-            // If we don't have room for the output, throw an exception
-            if (byteOff + outputSize > outEnd)
-                throw new ConversionBufferFullException();
-
-            // Put the byte in the output buffer
-            for (int i = 0; i < outputSize; i++) {
-                output[byteOff++] = outputByte[i];
-            }
-            charOff += inputSize;
-        }
-        // Return the length written to the output buffer
-        return byteOff - outOff;
-    }
-
-
-    /**
-     * the maximum number of bytes needed to hold a converted char
-     * @returns the maximum number of bytes needed for a converted char
-     */
-    public int getMaxBytesPerChar() {
-        return 2;
-    }
-}
--- ./jdk/src/share/classes/sun/nio/cs/ext/EUC_JP_BSD.java	2010-03-27 11:09:14.000000000 -0700
+++ ./jdk/src/share/classes/sun/nio/cs/ext/EUC_JP_BSD.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,374 +0,0 @@
-/*
- * Copyright 2002-2006 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-
-/*
- */
-
-package sun.nio.cs.ext;
-
-import java.nio.ByteBuffer;
-import java.nio.CharBuffer;
-import java.nio.charset.Charset;
-import java.nio.charset.CharsetDecoder;
-import java.nio.charset.CharsetEncoder;
-import java.nio.charset.CoderResult;
-import sun.nio.cs.HistoricallyNamedCharset;
-import sun.nio.cs.Surrogate;
-
-public class EUC_JP_BSD
-    extends Charset
-    implements HistoricallyNamedCharset
-{
-    public EUC_JP_BSD() {
-        super("x-euc-jp-bsd", ExtendedCharsets.aliasesFor("x-euc-jp-bsd"));
-    }
-
-    public String historicalName() {
-        return "EUC_JP_BSD";
-    }
-
-    public boolean contains(Charset cs) {
-        return ((cs instanceof JIS_X_0201)
-               || (cs.name().equals("US-ASCII"))
-               || (cs instanceof EUC_JP_BSD));
-    }
-
-    public CharsetDecoder newDecoder() {
-        return new Decoder(this);
-    }
-
-    public CharsetEncoder newEncoder() {
-        return new Encoder(this);
-    }
-
-    private static class Decoder extends CharsetDecoder {
-        JIS_X_0201.Decoder decoderJ0201;
-        JIS_X_0208_Decoder decodeMappingJ0208;
-        protected final char REPLACE_CHAR='\uFFFD';
-
-        short[] jis0208Index1;
-        String[] jis0208Index2;
-
-        private Decoder(Charset cs) {
-            super(cs, 1.0f, 1.0f);
-            decoderJ0201 = new JIS_X_0201.Decoder(cs);
-            decodeMappingJ0208 = new JIS_X_0208_Decoder(cs);
-            decodeMappingJ0208.start = 0xa1;
-            decodeMappingJ0208.end = 0xfe;
-            jis0208Index1 = decodeMappingJ0208.getIndex1();
-            jis0208Index2 = decodeMappingJ0208.getIndex2();
-        }
-
-        protected char convSingleByte(int b) {
-            if (b < 0 || b > 0x7f)
-                return REPLACE_CHAR;
-            return decoderJ0201.decode(b);
-        }
-
-        protected char decodeDouble(int byte1, int byte2) {
-            if (byte1 == 0x8e) {
-                return decoderJ0201.decode(byte2 - 256);
-            }
-
-            if (((byte1 < 0) || (byte1 > jis0208Index1.length))
-                || ((byte2 < decodeMappingJ0208.start) || (byte2 > decodeMappingJ0208.end)))
-                return REPLACE_CHAR;
-
-            int n = (jis0208Index1[byte1 - 0x80] & 0xf) * (decodeMappingJ0208.end - decodeMappingJ0208.start + 1)
-                    + (byte2 - decodeMappingJ0208.start);
-            return jis0208Index2[jis0208Index1[byte1 - 0x80] >> 4].charAt(n);
-        }
-
-        private CoderResult decodeArrayLoop(ByteBuffer src,
-                                            CharBuffer dst)
-        {
-            byte[] sa = src.array();
-            int sp = src.arrayOffset() + src.position();
-            int sl = src.arrayOffset() + src.limit();
-            assert (sp <= sl);
-            sp = (sp <= sl ? sp : sl);
-
-            char[] da = dst.array();
-            int dp = dst.arrayOffset() + dst.position();
-            int dl = dst.arrayOffset() + dst.limit();
-            assert (dp <= dl);
-            dp = (dp <= dl ? dp : dl);
-
-            int b1 = 0, b2 = 0;
-            int inputSize = 0;
-            char outputChar = REPLACE_CHAR; // U+FFFD;
-
-            try {
-                while (sp < sl) {
-                    b1 = sa[sp] & 0xff;
-                    inputSize = 1;
-                    if ((b1 & 0x80) == 0) {
-                        outputChar = (char)b1;
-                    }
-                    else {      // Multibyte char
-                        if ((b1 & 0xff) == 0x8f) {   // JIS0212
-                            if (sp + 3 > sl)
-                               return CoderResult.UNDERFLOW;
-                            inputSize = 3;
-                            return CoderResult.unmappableForLength(inputSize); // substitute
-                        } else {
-                          // JIS0208
-                            if (sp + 2 > sl)
-                               return CoderResult.UNDERFLOW;
-                            b2 = sa[sp + 1] & 0xff;
-                            inputSize = 2;
-                            outputChar = decodeDouble(b1, b2);
-                        }
-                    }
-                    if (outputChar == REPLACE_CHAR) { // can't be decoded
-                        return CoderResult.unmappableForLength(inputSize);
-                    }
-                    if (dp + 1 > dl)
-                        return CoderResult.OVERFLOW;
-                    da[dp++] = outputChar;
-                    sp += inputSize;
-                }
-                return CoderResult.UNDERFLOW;
-            } finally {
-                src.position(sp - src.arrayOffset());
-                dst.position(dp - dst.arrayOffset());
-            }
-        }
-
-        private CoderResult decodeBufferLoop(ByteBuffer src,
-                                             CharBuffer dst)
-        {
-            int mark = src.position();
-            char outputChar = REPLACE_CHAR; // U+FFFD;
-
-            try {
-                while (src.hasRemaining()) {
-                    int b1 = src.get() & 0xff;
-                    int inputSize = 1;
-
-                    if ((b1 & 0x80) == 0) {
-                        outputChar = (char)b1;
-                    } else {    // Multibyte char
-
-                        if ((b1 & 0xff) == 0x8f) { // JIS0212 not supported
-                            if (src.remaining() < 2)
-                                return CoderResult.UNDERFLOW;
-                            return CoderResult.unmappableForLength(3);
-                        } else {
-                            // JIS0208
-                            if (src.remaining() < 1)
-                                return CoderResult.UNDERFLOW;
-                            int b2 = src.get() & 0xff;
-                            inputSize++;
-                            outputChar = decodeDouble(b1, b2);
-                        }
-                    }
-
-                    if (outputChar == REPLACE_CHAR)
-                        return CoderResult.unmappableForLength(inputSize);
-                    if (dst.remaining() < 1)
-                        return CoderResult.OVERFLOW;
-                    dst.put(outputChar);
-                    mark += inputSize;
-                }
-                return CoderResult.UNDERFLOW;
-            } finally {
-                src.position(mark);
-            }
-        }
-
-        protected CoderResult decodeLoop(ByteBuffer src,
-                                         CharBuffer dst)
-        {
-            if (src.hasArray() && dst.hasArray())
-                return decodeArrayLoop(src, dst);
-            else
-                return decodeBufferLoop(src, dst);
-        }
-    }
-
-
-    private static class Encoder extends CharsetEncoder {
-
-        JIS_X_0201.Encoder encoderJ0201;
-        JIS_X_0208_Encoder encoderJ0208;
-
-        private final Surrogate.Parser sgp = new Surrogate.Parser();
-        short[] jis0208Index1;
-        String[] jis0208Index2;
-
-        private Encoder(Charset cs) {
-            super(cs, 2.0f, 2.0f);
-            encoderJ0201 = new JIS_X_0201.Encoder(cs);
-            encoderJ0208 = new JIS_X_0208_Encoder(cs);
-            jis0208Index1 = encoderJ0208.getIndex1();
-            jis0208Index2 = encoderJ0208.getIndex2();
-        }
-
-        public boolean canEncode(char c) {
-            byte[]  encodedBytes = new byte[2];
-
-            if (encodeSingle(c, encodedBytes) == 0) { //doublebyte
-                if (encodeDouble(c) == 0)
-                    return false;
-            }
-            return true;
-        }
-
-        protected int encodeSingle(char inputChar, byte[] outputByte) {
-            byte b;
-
-            if (inputChar == 0) {
-                outputByte[0] = (byte)0;
-                return 1;
-            }
-
-            if ((b = encoderJ0201.encode(inputChar)) == 0)
-                return 0;
-
-            if (b > 0 && b < 128) {
-                outputByte[0] = b;
-                return 1;
-            }
-            outputByte[0] = (byte)0x8e;
-            outputByte[1] = b;
-            return 2;
-        }
-
-        protected int encodeDouble(char ch) {
-            int offset = jis0208Index1[((ch & 0xff00) >> 8 )] << 8;
-            int r = jis0208Index2[offset >> 12].charAt((offset & 0xfff) + (ch & 0xff));
-            if (r != 0)
-                return r + 0x8080;
-            return r;
-        }
-
-        private CoderResult encodeArrayLoop(CharBuffer src,
-                                            ByteBuffer dst)
-        {
-            char[] sa = src.array();
-            int sp = src.arrayOffset() + src.position();
-            int sl = src.arrayOffset() + src.limit();
-            assert (sp <= sl);
-            sp = (sp <= sl ? sp : sl);
-            byte[] da = dst.array();
-            int dp = dst.arrayOffset() + dst.position();
-            int dl = dst.arrayOffset() + dst.limit();
-            assert (dp <= dl);
-            dp = (dp <= dl ? dp : dl);
-
-            final byte[]  outputByte = new byte[2];
-
-            try {
-                while (sp < sl) {
-                    char c = sa[sp];
-
-                    if (Character.isSurrogate(c)) {
-                        if (sgp.parse(c, sa, sp, sl) < 0)
-                            return sgp.error();
-                        return sgp.unmappableResult();
-                    }
-
-                    int outputSize = encodeSingle(c, outputByte);
-                    if (outputSize == 0) { // DoubleByte
-                        int ncode = encodeDouble(c);
-                        if (ncode != 0 && ((ncode & 0xFF0000) == 0)) {
-                                outputByte[0] = (byte) ((ncode & 0xff00) >> 8);
-                                outputByte[1] = (byte) (ncode & 0xff);
-                                outputSize = 2;
-                        } else {
-                                return CoderResult.unmappableForLength(1);
-                        }
-                    }
-
-                    if (dl - dp < outputSize)
-                        return CoderResult.OVERFLOW;
-                    // Put the byte in the output buffer
-                    for (int i = 0; i < outputSize; i++) {
-                        da[dp++] = outputByte[i];
-                    }
-                    sp++;
-                }
-                return CoderResult.UNDERFLOW;
-            } finally {
-                src.position(sp - src.arrayOffset());
-                dst.position(dp - dst.arrayOffset());
-            }
-        }
-
-        private CoderResult encodeBufferLoop(CharBuffer src,
-                                             ByteBuffer dst)
-        {
-            final byte[]  outputByte = new byte[4];
-            int mark = src.position();
-
-            try {
-                while (src.hasRemaining()) {
-                    char c = src.get();
-                    if (Character.isSurrogate(c)) {
-                        if (sgp.parse(c, src) < 0)
-                            return sgp.error();
-                        return sgp.unmappableResult();
-                    }
-
-                    int outputSize = encodeSingle(c, outputByte);
-                    if (outputSize == 0) { // DoubleByte
-                        int ncode = encodeDouble(c);
-                        if (ncode != 0 ) {
-                            if ((ncode & 0xFF0000) == 0) {
-                                outputByte[0] = (byte) ((ncode & 0xff00) >> 8);
-                                outputByte[1] = (byte) (ncode & 0xff);
-                                outputSize = 2;
-                            }
-                        } else {
-                                return CoderResult.unmappableForLength(1);
-                        }
-                    }
-
-                    if (dst.remaining() < outputSize)
-                        return CoderResult.OVERFLOW;
-
-                    // Put the byte in the output buffer
-                    for (int i = 0; i < outputSize; i++) {
-                        dst.put(outputByte[i]);
-                    }
-                    mark++;
-                }
-                return CoderResult.UNDERFLOW;
-            } finally {
-                src.position(mark);
-            }
-        }
-
-        protected CoderResult encodeLoop(CharBuffer src,
-                                         ByteBuffer dst)
-        {
-            if (src.hasArray() && dst.hasArray())
-                return encodeArrayLoop(src, dst);
-            else
-                return encodeBufferLoop(src, dst);
-        }
-    }
-}
--- ./jdk/src/share/classes/sun/print/PSPrinterJob.java	2010-03-18 01:45:22.000000000 -0700
+++ ./jdk/src/share/classes/sun/print/PSPrinterJob.java	2010-01-30 09:28:12.000000000 -0800
@@ -1534,7 +1534,9 @@
             pFlags |= NOSHEET;
             ncomps+=1;
         }
-       if (System.getProperty("os.name").equals("Linux")) {
+
+       String osname = System.getProperty("os.name");
+       if (osname.equals("Linux") || osname.equals("FreeBSD") || osname.equals("NetBSD") || osname.equals("OpenBSD") || osname.equals("Darwin")) {
             execCmd = new String[ncomps];
             execCmd[n++] = "/usr/bin/lpr";
             if ((pFlags & PRINTER) != 0) {
--- ./jdk/src/share/classes/sun/tools/attach/META-INF/services/com.sun.tools.attach.spi.AttachProvider	2010-03-18 01:45:27.000000000 -0700
+++ ./jdk/src/share/classes/sun/tools/attach/META-INF/services/com.sun.tools.attach.spi.AttachProvider	2010-01-30 09:28:18.000000000 -0800
@@ -30,3 +30,4 @@
 #[solaris]sun.tools.attach.SolarisAttachProvider
 #[windows]sun.tools.attach.WindowsAttachProvider
 #[linux]sun.tools.attach.LinuxAttachProvider
+#[bsd]sun.tools.attach.BsdAttachProvider
--- ./jdk/src/share/classes/sun/tools/jar/Main.java	2010-03-18 01:45:27.000000000 -0700
+++ ./jdk/src/share/classes/sun/tools/jar/Main.java	2010-01-30 09:28:18.000000000 -0800
@@ -50,6 +50,7 @@
     String zname = "";
     String[] files;
     String rootjar = null;
+    String cwd;
 
     // An entryName(path)->File map generated during "expand", it helps to
     // decide whether or not an existing entry in a jar file needs to be
@@ -862,6 +863,19 @@
      * Extracts specified entries from JAR file.
      */
     void extract(InputStream in, String files[]) throws IOException {
+        // Current working directory
+
+        cwd = System.getProperty("user.dir");
+        if (cwd == null) {
+            fatalError(getMsg("error.no.cwd"));
+        }
+        cwd = (new File(cwd)).getCanonicalPath();
+        if (!cwd.endsWith(File.separator)) {
+            cwd += File.separator;
+        }
+
+        // Extract the files
+
         ZipInputStream zis = new ZipInputStream(in);
         ZipEntry e;
         // Set of all directory entries specified in archive.  Disallows
@@ -892,6 +906,19 @@
      * Extracts specified entries from JAR file, via ZipFile.
      */
     void extract(String fname, String files[]) throws IOException {
+        // Current working directory
+
+        cwd = System.getProperty("user.dir");
+        if (cwd == null) {
+             fatalError(getMsg("error.no.cwd"));
+        }
+        cwd = (new File(cwd)).getCanonicalPath();
+        if (!cwd.endsWith(File.separator)) {
+            cwd += File.separator;
+        }
+
+        // Extract the files
+
         ZipFile zf = new ZipFile(fname);
         Set<ZipEntry> dirs = newDirSet();
         Enumeration<? extends ZipEntry> zes = zf.entries();
@@ -923,6 +950,10 @@
         ZipEntry rc = null;
         String name = e.getName();
         File f = new File(e.getName().replace('/', File.separatorChar));
+        if (!f.getCanonicalPath().startsWith(cwd)) {
+            output(formatMsg("out.ignore.entry", name));
+            return null;
+        }
         if (e.isDirectory()) {
             if (f.exists()) {
                 if (!f.isDirectory()) {
@@ -944,6 +975,10 @@
         } else {
             if (f.getParent() != null) {
                 File d = new File(f.getParent());
+                if (!d.getCanonicalPath().startsWith(cwd)) {
+                    output(formatMsg("out.ignore.entry", name));
+                    return null;
+                }
                 if (!d.exists() && !d.mkdirs() || !d.isDirectory()) {
                     throw new IOException(formatMsg(
                         "error.create.dir", d.getPath()));
--- ./jdk/src/share/classes/sun/tools/jar/resources/jar.properties	2010-03-18 01:45:27.000000000 -0700
+++ ./jdk/src/share/classes/sun/tools/jar/resources/jar.properties	2010-01-30 09:28:18.000000000 -0800
@@ -44,6 +44,8 @@
         {0} : could not create directory
 error.incorrect.length=\
         incorrect length while processing: {0}
+error.no.cwd=\
+	{0} : could not determine current working directory
 out.added.manifest=\
         added manifest
 out.update.manifest=\
--- ./jdk/src/share/demo/jvmti/compiledMethodLoad/sample.makefile.txt	2010-03-18 01:45:29.000000000 -0700
+++ ./jdk/src/share/demo/jvmti/compiledMethodLoad/sample.makefile.txt	2010-02-21 17:29:35.000000000 -0800
@@ -38,6 +38,7 @@
 #       gnumake JDK=<java_home> OSNAME=solaris [OPT=true] [LIBARCH=sparcv9]
 #       gnumake JDK=<java_home> OSNAME=linux   [OPT=true]
 #       gnumake JDK=<java_home> OSNAME=win32   [OPT=true]
+#       gnumake JDK=<java_home> OSNAME=bsd     [OPT=true]
 #
 ########################################################################
 
@@ -120,6 +121,29 @@
     LINK_SHARED=link -dll -out:$@
 endif
 
+# BSD GNU C Compiler
+ifeq ($(OSNAME), bsd)
+    # GNU Compiler options needed to build it
+    COMMON_FLAGS=-fno-strict-aliasing -fPIC -fno-omit-frame-pointer
+    # Options that help find errors
+    COMMON_FLAGS+= -W -Wall  -Wno-unused -Wno-parentheses
+    ifeq ($(OPT), true)
+        CFLAGS=-O2 $(COMMON_FLAGS)
+    else
+        CFLAGS=-g $(COMMON_FLAGS)
+    endif
+    # Object files needed to create library
+    OBJECTS=$(SOURCES:%.c=%.o)
+    # Library name and options needed to build it
+    # XXX: Needs to be fixed for MacOS X
+    LIBRARY=lib$(LIBNAME).so
+    LDFLAGS=-Wl,-soname=$(LIBRARY) -static-libgcc -mimpure-text
+    # Libraries we are dependent on
+    LIBRARIES=-lc
+    # Building a shared library
+    LINK_SHARED=$(LINK.c) -shared -o $@
+endif
+
 # Common -I options
 CFLAGS += -I.
 CFLAGS += -I../agent_util
--- ./jdk/src/share/hpi/include/hpi_impl.h	2010-03-18 01:45:30.000000000 -0700
+++ ./jdk/src/share/hpi/include/hpi_impl.h	2010-01-30 09:28:24.000000000 -0800
@@ -138,7 +138,11 @@
 int sysBind(int fd, struct sockaddr *him, int len);
 int sysAccept(int fd, struct sockaddr *him, int *len);
 int sysGetSockName(int fd, struct sockaddr *him, int *len);
-#ifdef _LP64
+#if defined(_LP64) || defined(_ALLBSD_SOURCE)
+// XXXBSD: The implementations all use ssize_t, except on Windows,
+// regardless of _LP64. The resulting mismatch between "int" and "ssize_t"
+// causes gcc on Darwin to report a conflicting types error.
+// Appears to be an upstream issue introduced in 1.7
 ssize_t sysSendTo(int fd, char *buf, int len, int flags, struct sockaddr *to,
               int tolen);
 ssize_t sysRecvFrom(int fd, char *buf, int nbytes, int flags,
--- ./jdk/src/share/lib/security/java.security-openbsd	1969-12-31 16:00:00.000000000 -0800
+++ ./jdk/src/share/lib/security/java.security-openbsd	2010-01-30 09:28:24.000000000 -0800
@@ -0,0 +1,269 @@
+#
+# This is the "master security properties file".
+#
+# In this file, various security properties are set for use by
+# java.security classes. This is where users can statically register
+# Cryptography Package Providers ("providers" for short). The term
+# "provider" refers to a package or set of packages that supply a
+# concrete implementation of a subset of the cryptography aspects of
+# the Java Security API. A provider may, for example, implement one or
+# more digital signature algorithms or message digest algorithms.
+#
+# Each provider must implement a subclass of the Provider class.
+# To register a provider in this master security properties file,
+# specify the Provider subclass name and priority in the format
+#
+#    security.provider.<n>=<className>
+#
+# This declares a provider, and specifies its preference
+# order n. The preference order is the order in which providers are
+# searched for requested algorithms (when no specific provider is
+# requested). The order is 1-based; 1 is the most preferred, followed
+# by 2, and so on.
+#
+# <className> must specify the subclass of the Provider class whose
+# constructor sets the values of various properties that are required
+# for the Java Security API to look up the algorithms or other
+# facilities implemented by the provider.
+#
+# There must be at least one provider specification in java.security.
+# There is a default provider that comes standard with the JDK. It
+# is called the "SUN" provider, and its Provider subclass
+# named Sun appears in the sun.security.provider package. Thus, the
+# "SUN" provider is registered via the following:
+#
+#    security.provider.1=sun.security.provider.Sun
+#
+# (The number 1 is used for the default provider.)
+#
+# Note: Providers can be dynamically registered instead by calls to
+# either the addProvider or insertProviderAt method in the Security
+# class.
+
+#
+# List of providers and their preference orders (see above):
+#
+security.provider.1=sun.security.provider.Sun
+security.provider.2=sun.security.rsa.SunRsaSign
+security.provider.3=sun.security.ec.SunEC
+security.provider.4=com.sun.net.ssl.internal.ssl.Provider
+security.provider.5=com.sun.crypto.provider.SunJCE
+security.provider.6=sun.security.jgss.SunProvider
+security.provider.7=com.sun.security.sasl.Provider
+security.provider.8=org.jcp.xml.dsig.internal.dom.XMLDSigRI
+security.provider.9=sun.security.smartcardio.SunPCSC
+
+#
+# Select the source of seed data for SecureRandom. By default an
+# attempt is made to use the entropy gathering device specified by 
+# the securerandom.source property. If an exception occurs when
+# accessing the URL then the traditional system/thread activity 
+# algorithm is used. 
+#
+# On Solaris and Linux systems, if file:/dev/urandom is specified and it
+# exists, a special SecureRandom implementation is activated by default.
+# This "NativePRNG" reads random bytes directly from /dev/urandom.
+#
+# On Windows systems, the URLs file:/dev/random and file:/dev/urandom
+# enables use of the Microsoft CryptoAPI seed functionality.
+#
+# On OpenBSD use file:///dev/srandom for strong but blocking random
+# generator, file:/dev/random for hardware random generators,
+# file:///dev/arandom for non-blocking high-quality pseudo-random
+# data and file:///dev/urandom for non-blocking random data that
+# does not guarantee the data to be strong. See random(4) for more
+# info.
+#
+securerandom.source=file:///dev/arandom
+#
+# The entropy gathering device is described as a URL and can also
+# be specified with the system property "java.security.egd". For example,
+#   -Djava.security.egd=file:/dev/urandom
+# Specifying this system property will override the securerandom.source 
+# setting.
+
+#
+# Class to instantiate as the javax.security.auth.login.Configuration
+# provider.
+#
+login.configuration.provider=com.sun.security.auth.login.ConfigFile
+
+#
+# Default login configuration file
+#
+#login.config.url.1=file:${user.home}/.java.login.config
+
+#
+# Class to instantiate as the system Policy. This is the name of the class
+# that will be used as the Policy object.
+#
+policy.provider=sun.security.provider.PolicyFile
+
+# The default is to have a single system-wide policy file,
+# and a policy file in the user's home directory.
+policy.url.1=file:${java.home}/lib/security/java.policy
+policy.url.2=file:${user.home}/.java.policy
+
+# whether or not we expand properties in the policy file
+# if this is set to false, properties (${...}) will not be expanded in policy
+# files.
+policy.expandProperties=true
+
+# whether or not we allow an extra policy to be passed on the command line
+# with -Djava.security.policy=somefile. Comment out this line to disable
+# this feature.
+policy.allowSystemProperty=true
+
+# whether or not we look into the IdentityScope for trusted Identities
+# when encountering a 1.1 signed JAR file. If the identity is found
+# and is trusted, we grant it AllPermission.
+policy.ignoreIdentityScope=false
+
+#
+# Default keystore type.
+#
+keystore.type=jks
+
+#
+# Class to instantiate as the system scope:
+#
+system.scope=sun.security.provider.IdentityDatabase
+
+#
+# List of comma-separated packages that start with or equal this string
+# will cause a security exception to be thrown when
+# passed to checkPackageAccess unless the
+# corresponding RuntimePermission ("accessClassInPackage."+package) has
+# been granted.
+package.access=sun.,com.sun.imageio.
+
+#
+# List of comma-separated packages that start with or equal this string
+# will cause a security exception to be thrown when
+# passed to checkPackageDefinition unless the
+# corresponding RuntimePermission ("defineClassInPackage."+package) has
+# been granted.
+#
+# by default, no packages are restricted for definition, and none of
+# the class loaders supplied with the JDK call checkPackageDefinition.
+#
+#package.definition=
+
+#
+# Determines whether this properties file can be appended to
+# or overridden on the command line via -Djava.security.properties
+#
+security.overridePropertiesFile=true
+
+#
+# Determines the default key and trust manager factory algorithms for 
+# the javax.net.ssl package.
+#
+ssl.KeyManagerFactory.algorithm=SunX509
+ssl.TrustManagerFactory.algorithm=PKIX
+
+#
+# The Java-level namelookup cache policy for successful lookups:
+#
+# any negative value: caching forever
+# any positive value: the number of seconds to cache an address for
+# zero: do not cache
+#
+# default value is forever (FOREVER). For security reasons, this
+# caching is made forever when a security manager is set. When a security
+# manager is not set, the default behavior in this implementation
+# is to cache for 30 seconds.
+#
+# NOTE: setting this to anything other than the default value can have
+#       serious security implications. Do not set it unless 
+#       you are sure you are not exposed to DNS spoofing attack.
+#
+#networkaddress.cache.ttl=-1 
+
+# The Java-level namelookup cache policy for failed lookups:
+#
+# any negative value: cache forever
+# any positive value: the number of seconds to cache negative lookup results
+# zero: do not cache
+#
+# In some Microsoft Windows networking environments that employ
+# the WINS name service in addition to DNS, name service lookups
+# that fail may take a noticeably long time to return (approx. 5 seconds).
+# For this reason the default caching policy is to maintain these
+# results for 10 seconds. 
+#
+#
+networkaddress.cache.negative.ttl=10
+
+#
+# Properties to configure OCSP for certificate revocation checking
+#
+
+# Enable OCSP 
+#
+# By default, OCSP is not used for certificate revocation checking.
+# This property enables the use of OCSP when set to the value "true".
+#
+# NOTE: SocketPermission is required to connect to an OCSP responder.
+#
+# Example,
+#   ocsp.enable=true
+ 
+#
+# Location of the OCSP responder
+#
+# By default, the location of the OCSP responder is determined implicitly
+# from the certificate being validated. This property explicitly specifies
+# the location of the OCSP responder. The property is used when the
+# Authority Information Access extension (defined in RFC 3280) is absent
+# from the certificate or when it requires overriding.
+#
+# Example,
+#   ocsp.responderURL=http://ocsp.example.net:80
+ 
+#
+# Subject name of the OCSP responder's certificate
+#
+# By default, the certificate of the OCSP responder is that of the issuer
+# of the certificate being validated. This property identifies the certificate
+# of the OCSP responder when the default does not apply. Its value is a string 
+# distinguished name (defined in RFC 2253) which identifies a certificate in 
+# the set of certificates supplied during cert path validation. In cases where 
+# the subject name alone is not sufficient to uniquely identify the certificate
+# then both the "ocsp.responderCertIssuerName" and
+# "ocsp.responderCertSerialNumber" properties must be used instead. When this
+# property is set then those two properties are ignored.
+#
+# Example,
+#   ocsp.responderCertSubjectName="CN=OCSP Responder, O=XYZ Corp"
+
+#
+# Issuer name of the OCSP responder's certificate
+#
+# By default, the certificate of the OCSP responder is that of the issuer
+# of the certificate being validated. This property identifies the certificate
+# of the OCSP responder when the default does not apply. Its value is a string
+# distinguished name (defined in RFC 2253) which identifies a certificate in
+# the set of certificates supplied during cert path validation. When this 
+# property is set then the "ocsp.responderCertSerialNumber" property must also 
+# be set. When the "ocsp.responderCertSubjectName" property is set then this 
+# property is ignored.
+#
+# Example,
+#   ocsp.responderCertIssuerName="CN=Enterprise CA, O=XYZ Corp"
+ 
+#
+# Serial number of the OCSP responder's certificate
+#
+# By default, the certificate of the OCSP responder is that of the issuer
+# of the certificate being validated. This property identifies the certificate
+# of the OCSP responder when the default does not apply. Its value is a string
+# of hexadecimal digits (colon or space separators may be present) which
+# identifies a certificate in the set of certificates supplied during cert path
+# validation. When this property is set then the "ocsp.responderCertIssuerName"
+# property must also be set. When the "ocsp.responderCertSubjectName" property
+# is set then this property is ignored.
+#
+# Example,
+#   ocsp.responderCertSerialNumber=2A:FF:00
+ 
--- ./jdk/src/share/native/com/sun/java/util/jar/pack/defines.h	2010-03-18 01:45:30.000000000 -0700
+++ ./jdk/src/share/native/com/sun/java/util/jar/pack/defines.h	2010-01-30 09:28:24.000000000 -0800
@@ -32,6 +32,10 @@
 #include <unistd.h>
 #endif
 
+#ifndef NO_ZLIB
+#      include <zconf.h>
+#endif
+
 #ifndef FULL
 #define FULL 1 /* Adds <500 bytes to the zipped final product. */
 #endif
@@ -89,11 +93,13 @@
 // bytes and byte arrays
 
 typedef unsigned int uint;
+#ifdef NO_ZLIB
 #ifdef _LP64
 typedef unsigned int uLong; // Historical zlib, should be 32-bit.
 #else
 typedef unsigned long uLong;
 #endif
+#endif
 #ifdef _MSC_VER
 typedef LONGLONG        jlong;
 typedef DWORDLONG       julong;
--- ./jdk/src/share/native/com/sun/java/util/jar/pack/main.cpp	2010-03-18 01:45:30.000000000 -0700
+++ ./jdk/src/share/native/com/sun/java/util/jar/pack/main.cpp	2010-01-30 09:28:24.000000000 -0800
@@ -22,6 +22,9 @@
  * CA 95054 USA or visit www.sun.com if you need additional information or
  * have any questions.
  */
+#ifdef _ALLBSD_SOURCE
+#include <stdint.h>
+#endif
 #include <sys/types.h>
 
 #include <stdio.h>
@@ -35,7 +38,7 @@
 
 #if defined(unix) && !defined(PRODUCT)
 #include "pthread.h"
-#define THREAD_SELF ((int)pthread_self())
+#define THREAD_SELF ((intptr_t) pthread_self())
 #endif
 
 #include "defines.h"
@@ -58,9 +61,9 @@
 // Single-threaded, implementation, not reentrant.
 // Includes a weak error check against MT access.
 #ifndef THREAD_SELF
-#define THREAD_SELF (0)
+#define THREAD_SELF ((intptr_t) 0)
 #endif
-NOT_PRODUCT(static int uThread = -1;)
+NOT_PRODUCT(static intptr_t uThread = -1;)
 
 unpacker* unpacker::non_mt_current = null;
 unpacker* unpacker::current() {
@@ -69,7 +72,7 @@
 }
 static void set_current_unpacker(unpacker* u) {
   unpacker::non_mt_current = u;
-  assert(((uThread = (u == null) ? -1 : THREAD_SELF),
+  assert(((uThread = (u == null) ? ((intptr_t) -1) : THREAD_SELF),
           true));
 }
 
--- ./jdk/src/share/native/com/sun/media/sound/DirectAudioDevice.c	2010-03-18 01:45:30.000000000 -0700
+++ ./jdk/src/share/native/com/sun/media/sound/DirectAudioDevice.c	2010-01-30 09:28:24.000000000 -0800
@@ -33,7 +33,11 @@
 
 #include <jni.h>
 // for malloc
+#ifdef _ALLBSD_SOURCE
+#include <stdlib.h>
+#else
 #include <malloc.h>
+#endif
 #include "SoundDefs.h"
 #include "DirectAudio.h"
 #include "Utilities.h"
--- ./jdk/src/share/native/com/sun/media/sound/Platform.c	2010-03-18 01:45:30.000000000 -0700
+++ ./jdk/src/share/native/com/sun/media/sound/Platform.c	2010-01-30 09:28:24.000000000 -0800
@@ -99,5 +99,17 @@
         return com_sun_media_sound_Platform_LIB_ALSA;
     }
 #endif
+#if (X_PLATFORM == X_BSD)
+    switch (feature) {
+    case com_sun_media_sound_Platform_FEATURE_MIDIIO:
+       return com_sun_media_sound_Platform_LIB_MAIN;
+    case com_sun_media_sound_Platform_FEATURE_PORTS:
+       return com_sun_media_sound_Platform_LIB_MAIN;
+    case com_sun_media_sound_Platform_FEATURE_DIRECT_AUDIO:
+       // XXXBSD: When native Direct Audio support is ported change
+       // this back to returning com_sun_media_sound_Platform_LIB_MAIN
+       return 0;
+    }
+#endif
     return 0;
 }
--- ./jdk/src/share/native/com/sun/media/sound/SoundDefs.h	2010-03-18 01:45:30.000000000 -0700
+++ ./jdk/src/share/native/com/sun/media/sound/SoundDefs.h	2010-01-30 09:28:24.000000000 -0800
@@ -31,6 +31,7 @@
 #define X_WINDOWS       1
 #define X_SOLARIS       2
 #define X_LINUX         3
+#define X_BSD           4
 
 // types for X_ARCH
 #define X_I586          1
@@ -50,7 +51,7 @@
 
 
 // following is needed for _LP64
-#if ((X_PLATFORM == X_SOLARIS) || (X_PLATFORM == X_LINUX))
+#if ((X_PLATFORM == X_SOLARIS) || (X_PLATFORM == X_LINUX) || (X_PLATFORM == X_BSD))
 #include <sys/types.h>
 #endif
 
@@ -130,4 +131,9 @@
 #endif
 
 
+#if X_PLATFORM == X_BSD
+#define INLINE          inline
+#endif
+
+
 #endif  // __SOUNDDEFS_INCLUDED__
--- ./jdk/src/share/native/common/check_code.c	2010-03-18 01:45:30.000000000 -0700
+++ ./jdk/src/share/native/common/check_code.c	2010-01-30 09:28:25.000000000 -0800
@@ -1065,7 +1065,7 @@
  * Make sure that branches don't go into the middle of nowhere.
  */
 
-static jint ntohl(jint n)
+static jint _ck_ntohl(jint n)
 {
     unsigned char *p = (unsigned char *)&n;
     return (p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3];
@@ -1144,26 +1144,26 @@
             }
         }
         if (opcode == JVM_OPC_tableswitch) {
-            keys = ntohl(lpc[2]) -  ntohl(lpc[1]) + 1;
+            keys = _ck_ntohl(lpc[2]) -  _ck_ntohl(lpc[1]) + 1;
             delta = 1;
         } else {
-            keys = ntohl(lpc[1]); /* number of pairs */
+            keys = _ck_ntohl(lpc[1]); /* number of pairs */
             delta = 2;
             /* Make sure that the tableswitch items are sorted */
             for (k = keys - 1, lptr = &lpc[2]; --k >= 0; lptr += 2) {
-                int this_key = ntohl(lptr[0]);  /* NB: ntohl may be unsigned */
-                int next_key = ntohl(lptr[2]);
+                int this_key = _ck_ntohl(lptr[0]);  /* NB: ntohl may be unsigned */
+                int next_key = _ck_ntohl(lptr[2]);
                 if (this_key >= next_key) {
                     CCerror(context, "Unsorted lookup switch");
                 }
             }
         }
         saved_operand = NEW(int, keys + 2);
-        if (!isLegalTarget(context, offset + ntohl(lpc[0])))
+        if (!isLegalTarget(context, offset + _ck_ntohl(lpc[0])))
             CCerror(context, "Illegal default target in switch");
-        saved_operand[keys + 1] = code_data[offset + ntohl(lpc[0])];
+        saved_operand[keys + 1] = code_data[offset + _ck_ntohl(lpc[0])];
         for (k = keys, lptr = &lpc[3]; --k >= 0; lptr += delta) {
-            int target = offset + ntohl(lptr[0]);
+            int target = offset + _ck_ntohl(lptr[0]);
             if (!isLegalTarget(context, target))
                 CCerror(context, "Illegal branch in tableswitch");
             saved_operand[k + 1] = code_data[target];
@@ -1624,7 +1624,7 @@
             if (lpc + 2 >= (int *)end) {
                 return -1; /* do not read pass the end */
             }
-            index = ntohl(lpc[2]) - ntohl(lpc[1]);
+	    index = _ck_ntohl(lpc[2]) - _ck_ntohl(lpc[1]);
             if ((index < 0) || (index > 65535)) {
                 return -1;      /* illegal */
             } else {
@@ -1637,7 +1637,7 @@
             int npairs;
             if (lpc + 1 >= (int *)end)
                 return -1; /* do not read pass the end */
-            npairs = ntohl(lpc[1]);
+	    npairs = _ck_ntohl(lpc[1]);
             /* There can't be more than 64K labels because of the limit
              * on per-method byte code length.
              */
--- ./jdk/src/share/native/java/io/io_util.h	2010-03-18 01:45:30.000000000 -0700
+++ ./jdk/src/share/native/java/io/io_util.h	2010-01-30 09:28:25.000000000 -0800
@@ -29,7 +29,15 @@
 extern jfieldID IO_fd_fdID;
 extern jfieldID IO_handle_fdID;
 
-#if !defined(O_DSYNC) || !defined(O_SYNC)
+#ifdef _ALLBSD_SOURCE
+#include <fcntl.h>
+#ifndef O_SYNC
+#define O_SYNC  O_FSYNC
+#endif
+#ifndef O_DSYNC
+#define O_DSYNC O_FSYNC
+#endif
+#elif !defined(O_DSYNC) || !defined(O_SYNC)
 #define O_SYNC  (0x0800)
 #define O_DSYNC (0x2000)
 #endif
--- ./jdk/src/share/native/java/lang/fdlibm/include/fdlibm.h	2010-03-18 01:45:30.000000000 -0700
+++ ./jdk/src/share/native/java/lang/fdlibm/include/fdlibm.h	2010-01-30 09:28:25.000000000 -0800
@@ -24,6 +24,15 @@
  * have any questions.
  */
 
+#ifdef __OpenBSD__
+#include <sys/types.h>
+#endif
+#ifdef _ALLBSD_SOURCE
+#include <machine/endian.h>
+#elif __linux__
+#define __USE_BSD 1
+#include <endian.h>
+#endif
 #include "jfdlibm.h"
 
 #ifdef __NEWVALID       /* special setup for Sun test regime */
@@ -34,7 +43,8 @@
 #endif
 #endif
 
-#ifdef _LITTLE_ENDIAN
+#if (defined(__solaris__) && defined(_LITTLE_ENDIAN)) || \
+    BYTE_ORDER == LITTLE_ENDIAN
 #define __HI(x) *(1+(int*)&x)
 #define __LO(x) *(int*)&x
 #define __HIp(x) *(1+(int*)x)
@@ -46,11 +56,13 @@
 #define __LOp(x) *(1+(int*)x)
 #endif
 
+#ifndef __P
 #ifdef __STDC__
 #define __P(p)  p
 #else
 #define __P(p)  ()
 #endif
+#endif
 
 /*
  * ANSI/POSIX
--- ./jdk/src/share/native/java/lang/fdlibm/include/jfdlibm.h	2010-03-18 01:45:30.000000000 -0700
+++ ./jdk/src/share/native/java/lang/fdlibm/include/jfdlibm.h	2010-01-30 09:28:25.000000000 -0800
@@ -61,7 +61,7 @@
 #define log1p   jlog1p
 #define expm1   jexpm1
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #define __ieee754_sqrt          __j__ieee754_sqrt
 #define __ieee754_acos          __j__ieee754_acos
 #define __ieee754_acosh         __j__ieee754_acosh
--- ./jdk/src/share/native/java/util/zip/Inflater.c	2010-03-18 01:45:30.000000000 -0700
+++ ./jdk/src/share/native/java/util/zip/Inflater.c	2010-01-30 09:28:25.000000000 -0800
@@ -67,6 +67,10 @@
         return jlong_zero;
     } else {
         char *msg;
+// BSDXXX needed for FreeBSD 5.4 and below with system zlib
+#if defined(__FreeBSD__) && __FreeBSD__ < 6
+	strm->adler = 1;
+#endif
         switch (inflateInit2(strm, nowrap ? -MAX_WBITS : MAX_WBITS)) {
           case Z_OK:
             return ptr_to_jlong(strm);
@@ -204,6 +208,10 @@
     if (inflateReset(jlong_to_ptr(strm)) != Z_OK) {
         JNU_ThrowInternalError(env, 0);
     }
+// BSDXXX needed for FreeBSD 5.4 and below with system zlib
+#if defined(__FreeBSD__) && __FreeBSD__ < 6
+    ((z_stream *)jlong_to_ptr(strm))->adler = 1;
+#endif
 }
 
 JNIEXPORT void JNICALL
--- ./jdk/src/share/native/java/util/zip/zip_util.c	2010-03-18 01:45:30.000000000 -0700
+++ ./jdk/src/share/native/java/util/zip/zip_util.c	2010-01-30 09:28:25.000000000 -0800
@@ -46,6 +46,10 @@
 #include "zip_util.h"
 #include "zlib.h"
 
+#ifdef _ALLBSD_SOURCE
+#include "largefile_bsd.h"
+#endif
+
 /* USE_MMAP means mmap the CEN & ENDHDR part of the zip file. */
 #ifdef USE_MMAP
 #include <sys/mman.h>
--- ./jdk/src/share/native/sun/awt/debug/debug_util.h	2010-03-18 01:45:30.000000000 -0700
+++ ./jdk/src/share/native/sun/awt/debug/debug_util.h	2010-01-30 09:28:25.000000000 -0800
@@ -50,7 +50,9 @@
 #include <stdio.h>
 #include <string.h>
 #include <assert.h>
+#if !defined(_ALLBSD_SOURCE)
 #include <malloc.h>
+#endif
 #include <limits.h>
 
 /* keep these after the other headers */
--- ./jdk/src/share/native/sun/awt/image/BufImgSurfaceData.c	2010-03-18 01:45:30.000000000 -0700
+++ ./jdk/src/share/native/sun/awt/image/BufImgSurfaceData.c	2010-01-30 09:28:26.000000000 -0800
@@ -24,7 +24,11 @@
  */
 
 #include "BufImgSurfaceData.h"
+#ifdef _ALLBSD_SOURCE
+#include <stdlib.h>
+#else
 #include "malloc.h"
+#endif
 
 #include "sun_awt_image_BufImgSurfaceData.h"
 
--- ./jdk/src/share/native/sun/awt/image/DataBufferNative.c	2010-03-18 01:45:30.000000000 -0700
+++ ./jdk/src/share/native/sun/awt/image/DataBufferNative.c	2010-01-30 09:28:26.000000000 -0800
@@ -23,7 +23,11 @@
  * have any questions.
  */
 
+#ifdef _ALLBSD_SOURCE
+#include <stdlib.h>
+#else
 #include "malloc.h"
+#endif
 
 #include "SurfaceData.h"
 #include "sun_awt_image_DataBufferNative.h"
--- ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv2x2_f.c	2010-03-18 01:45:31.000000000 -0700
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv2x2_f.c	2010-01-30 09:28:26.000000000 -0800
@@ -86,7 +86,7 @@
 #endif /* MLIB_USE_FTOI_CLAMPING */
 
 /***************************************************************/
-#if defined(_LITTLE_ENDIAN) && !defined(_NO_LONGLONG)
+#if (BYTE_ORDER == LITTLE_ENDIAN) && !defined(_NO_LONGLONG)
 
 /* NB: Explicit cast to DTYPE is necessary to avoid warning from Microsoft VC compiler.
       And we need to explicitly define cast behavior if source exceeds destination range.
@@ -103,7 +103,7 @@
   dp[0    ] = (DTYPE) ((res0) & DTYPE_MASK);                      \
   dp[chan1] = (DTYPE) ((res1) & DTYPE_MASK)
 
-#endif /* defined(_LITTLE_ENDIAN) && !defined(_NO_LONGLONG) */
+#endif /* (BYTE_ORDER == LITTLE_ENDIAN) && !defined(_NO_LONGLONG) */
 
 /***************************************************************/
 #ifdef _NO_LONGLONG
@@ -114,17 +114,17 @@
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[chan1]) << 32) | ((mlib_s64)sp[0] & 0xffffffff)
 
-#else /* _LITTLE_ENDIAN */
+#else
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[0]) << 32) | ((mlib_s64)sp[chan1] & 0xffffffff)
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
 #endif /* _NO_LONGLONG */
 
--- ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_16ext.c	2010-03-18 01:45:31.000000000 -0700
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_16ext.c	2010-01-30 09:28:26.000000000 -0800
@@ -126,7 +126,7 @@
 #define D2I(x) CLAMP_S32((x) SAT_OFF)
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define STORE2(res0, res1)                                      \
   dp[0    ] = res1;                                             \
@@ -138,7 +138,7 @@
   dp[0    ] = res0;                                             \
   dp[chan1] = res1
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
 /***************************************************************/
 #ifdef _NO_LONGLONG
@@ -149,17 +149,17 @@
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[chan1]) << 32) | S64TOS32((mlib_s64)sp[0])
 
-#else /* _LITTLE_ENDIAN */
+#else
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[0]) << 32) | S64TOS32((mlib_s64)sp[chan1])
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 #endif /* _NO_LONGLONG */
 
 /***************************************************************/
--- ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_16nw.c	2010-03-18 01:45:31.000000000 -0700
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_16nw.c	2010-01-30 09:28:26.000000000 -0800
@@ -94,7 +94,7 @@
 #define D2I(x) CLAMP_S32((x) SAT_OFF)
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define STORE2(res0, res1)                                      \
   dp[0    ] = res1;                                             \
@@ -106,7 +106,7 @@
   dp[0    ] = res0;                                             \
   dp[chan1] = res1
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
 /***************************************************************/
 #ifdef _NO_LONGLONG
@@ -117,17 +117,17 @@
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[chan1]) << 32) | S64TOS32((mlib_s64)sp[0])
 
-#else /* _LITTLE_ENDIAN */
+#else
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[0]) << 32) | S64TOS32((mlib_s64)sp[chan1])
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 #endif /* _NO_LONGLONG */
 
 /***************************************************************/
--- ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_8ext.c	2010-03-18 01:45:31.000000000 -0700
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_8ext.c	2010-01-30 09:28:26.000000000 -0800
@@ -126,7 +126,7 @@
 #define D2I(x) CLAMP_S32((x) SAT_OFF)
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define STORE2(res0, res1)                                      \
   dp[0    ] = res1;                                             \
@@ -138,7 +138,7 @@
   dp[0    ] = res0;                                             \
   dp[chan1] = res1
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
 /***************************************************************/
 #ifdef _NO_LONGLONG
@@ -149,17 +149,17 @@
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[chan1]) << 32) | S64TOS32((mlib_s64)sp[0])
 
-#else /* _LITTLE_ENDIAN */
+#else
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[0]) << 32) | S64TOS32((mlib_s64)sp[chan1])
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 #endif /* _NO_LONGLONG */
 
 /***************************************************************/
--- ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_8nw.c	2010-03-18 01:45:31.000000000 -0700
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_8nw.c	2010-01-30 09:28:26.000000000 -0800
@@ -95,7 +95,7 @@
 #define D2I(x) CLAMP_S32((x) SAT_OFF)
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define STORE2(res0, res1)                                      \
   dp[0    ] = res1;                                             \
@@ -107,7 +107,7 @@
   dp[0    ] = res0;                                             \
   dp[chan1] = res1
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
 /***************************************************************/
 #ifdef _NO_LONGLONG
@@ -118,17 +118,17 @@
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[chan1]) << 32) | S64TOS32((mlib_s64)sp[0])
 
-#else /* _LITTLE_ENDIAN */
+#else
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[0]) << 32) | S64TOS32((mlib_s64)sp[chan1])
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 #endif /* _NO_LONGLONG */
 
 /***************************************************************/
--- ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_u16ext.c	2010-03-18 01:45:31.000000000 -0700
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_u16ext.c	2010-01-30 09:28:26.000000000 -0800
@@ -126,7 +126,7 @@
 #define D2I(x) CLAMP_S32((x) SAT_OFF)
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define STORE2(res0, res1)                                      \
   dp[0    ] = res1;                                             \
@@ -138,7 +138,7 @@
   dp[0    ] = res0;                                             \
   dp[chan1] = res1
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
 /***************************************************************/
 #ifdef _NO_LONGLONG
@@ -149,17 +149,17 @@
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[chan1]) << 32) | S64TOS32((mlib_s64)sp[0])
 
-#else /* _LITTLE_ENDIAN */
+#else
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[0]) << 32) | S64TOS32((mlib_s64)sp[chan1])
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 #endif /* _NO_LONGLONG */
 
 /***************************************************************/
--- ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_u16nw.c	2010-03-18 01:45:31.000000000 -0700
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_ImageConv_u16nw.c	2010-01-30 09:28:26.000000000 -0800
@@ -94,7 +94,7 @@
 #define D2I(x) CLAMP_S32((x) SAT_OFF)
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define STORE2(res0, res1)                                      \
   dp[0    ] = res1;                                             \
@@ -106,7 +106,7 @@
   dp[0    ] = res0;                                             \
   dp[chan1] = res1
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
 /***************************************************************/
 #ifdef _NO_LONGLONG
@@ -117,17 +117,17 @@
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[chan1]) << 32) | S64TOS32((mlib_s64)sp[0])
 
-#else /* _LITTLE_ENDIAN */
+#else
 
 #define LOAD_BUFF(buff)                                         \
   *(mlib_s64*)(buff + i) = (((mlib_s64)sp[0]) << 32) | S64TOS32((mlib_s64)sp[chan1])
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 #endif /* _NO_LONGLONG */
 
 /***************************************************************/
--- ./jdk/src/share/native/sun/awt/medialib/mlib_ImageCopy_Bit.c	2010-03-18 01:45:31.000000000 -0700
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_ImageCopy_Bit.c	2010-01-30 09:28:26.000000000 -0800
@@ -95,7 +95,7 @@
     dst = dp[0];
     if (ld_offset + size < 32) {
       dmask = (mask0 << (32 - size)) >> ld_offset;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
       src = (src0 >> (ld_offset - ls_offset));
       dst = (dst << 24) | ((dst & 0xFF00) << 8) | ((dst >> 8) & 0xFF00) | (dst >> 24);
@@ -104,12 +104,12 @@
 #else
       src = (src0 >> (ld_offset - ls_offset));
       dp[0] = (dst & (~dmask)) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       return;
     }
 
     dmask = mask0 >> ld_offset;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
     src = (src0 >> (ld_offset - ls_offset));
     dst = (dst << 24) | ((dst & 0xFF00) << 8) | ((dst >> 8) & 0xFF00) | (dst >> 24);
@@ -118,7 +118,7 @@
 #else
     src = (src0 >> (ld_offset - ls_offset));
     dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     j = 32 - ld_offset;
     dp++;
     ls_offset += j;
@@ -131,7 +131,7 @@
 
     if (ld_offset + size < 32) {
       dmask = (mask0 << (32 - size)) >> ld_offset;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
       src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
       src = (src0 << shift) | (src1 >> (32 - shift));
@@ -141,12 +141,12 @@
 #else
       src = (src0 << shift) | (src1 >> (32 - shift));
       dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       return;
     }
 
     dmask = mask0 >> ld_offset;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
     src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
     src = (src0 << shift) | (src1 >> (32 - shift));
@@ -156,7 +156,7 @@
 #else
     src = (src0 << shift) | (src1 >> (32 - shift));
     dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     j = 32 - ld_offset;
     dp++;
     sp++;
@@ -164,19 +164,19 @@
   }
 
   if (j < size) src1 = sp[0];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
   src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
   for (; j <= size - 32; j += 32) {
     src0 = src1;
     src1 = sp[1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
     src = (src0 << ls_offset) | (src1 >> (32 - ls_offset));
     dp[0] = (src << 24) | ((src & 0xFF00) << 8) | ((src >> 8) & 0xFF00) | (src >> 24);
 #else
     dp[0] = (src0 << ls_offset) | (src1 >> (32 - ls_offset));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     sp++;
     dp++;
   }
@@ -187,7 +187,7 @@
     if (ls_offset + j > 32) src1 = sp[1];
     dst = dp[0];
     dmask = mask0 << (32 - j);
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
     src = (src0 << ls_offset) | (src1 >> (32 - ls_offset));
     dst = (dst << 24) | ((dst & 0xFF00) << 8) | ((dst >> 8) & 0xFF00) | (dst >> 24);
@@ -196,7 +196,7 @@
 #else
     src = (src0 << ls_offset) | (src1 >> (32 - ls_offset));
     dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
   }
 
 #else /* _LONGLONG */
@@ -315,7 +315,7 @@
     dst = dp[0];
     if (ld_offset >= size) {
       dmask = (lmask0 << (32 - size)) >> (ld_offset - size);
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
       src = (src0 << (ls_offset - ld_offset));
       dst = (dst << 24) | ((dst & 0xFF00) << 8) | ((dst >> 8) & 0xFF00) | (dst >> 24);
@@ -324,12 +324,12 @@
 #else
       src = (src0 << (ls_offset - ld_offset));
       dp[0] = (dst & (~dmask)) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       return;
     }
 
     dmask = lmask0 << (32 - ld_offset);
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
     src = (src0 << (ls_offset - ld_offset));
     dst = (dst << 24) | ((dst & 0xFF00) << 8) | ((dst >> 8) & 0xFF00) | (dst >> 24);
@@ -338,7 +338,7 @@
 #else
     src = (src0 << (ls_offset - ld_offset));
     dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     j = ld_offset;
     dp--;
     ls_offset -= j;
@@ -351,7 +351,7 @@
 
     if (ld_offset >= size) {
       dmask = (lmask0 << (32 - size)) >> (ld_offset - size);
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
       src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
       src = (src0 >> shift) | (src1 << (32 - shift));
@@ -361,12 +361,12 @@
 #else
       src = (src0 >> shift) | (src1 << (32 - shift));
       dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       return;
     }
 
     dmask = lmask0 << (32 - ld_offset);
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     src0 = (src0 << 24) | ((src0 & 0xFF00) << 8) | ((src0 >> 8) & 0xFF00) | (src0 >> 24);
     src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
     src = (src0 >> shift) | (src1 << (32 - shift));
@@ -376,7 +376,7 @@
 #else
     src = (src0 >> shift) | (src1 << (32 - shift));
     dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     j = ld_offset;
     dp--;
     sp--;
@@ -384,22 +384,22 @@
   }
 
   if (j < size) src1 = sp[0];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
   src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 #ifdef __SUNPRO_C
 #pragma pipeloop(0)
 #endif /* __SUNPRO_C */
   for (; j <= size - 32; j += 32) {
     src0 = src1;
     src1 = sp[-1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
     src = (src0 >> (32 - ls_offset)) | (src1 << ls_offset);
     dp[0] = (src << 24) | ((src & 0xFF00) << 8) | ((src >> 8) & 0xFF00) | (src >> 24);
 #else
     dp[0] = (src0 >> (32 - ls_offset)) | (src1 << ls_offset);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     sp--;
     dp--;
   }
@@ -410,7 +410,7 @@
     if (ls_offset < j) src1 = sp[-1];
     dst = dp[0];
     dmask = lmask0 >> (32 - j);
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     src1 = (src1 << 24) | ((src1 & 0xFF00) << 8) | ((src1 >> 8) & 0xFF00) | (src1 >> 24);
     src = (src0 >> (32 - ls_offset)) | (src1 << ls_offset);
     dst = (dst << 24) | ((dst & 0xFF00) << 8) | ((dst >> 8) & 0xFF00) | (dst >> 24);
@@ -419,7 +419,7 @@
 #else
     src = (src0 >> (32 - ls_offset)) | (src1 << ls_offset);
     dp[0] = (dst & ~dmask) | (src & dmask);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
   }
 
 #else  /* _LONGLONG */
--- ./jdk/src/share/native/sun/awt/medialib/mlib_ImageLookUp_64.c	2010-03-18 01:45:31.000000000 -0700
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_ImageLookUp_64.c	2010-01-30 09:28:27.000000000 -0800
@@ -168,7 +168,7 @@
 }
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define READ_U8_D64(table0, table1, table2, table3)             \
   t0 = *(mlib_d64*)((mlib_u8*)table0 + ((s0 << 3) & 0x7F8));    \
@@ -184,7 +184,7 @@
   t2 = *(mlib_d64*)((mlib_u8*)table2 + ((s0 >> 5)  & 0x7F8));   \
   t3 = *(mlib_d64*)((mlib_u8*)table3 + ((s0 << 3)  & 0x7F8))
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
 /***************************************************************/
 void mlib_ImageLookUp_U8_D64(const mlib_u8  *src,
@@ -612,7 +612,7 @@
 #pragma pipeloop(0)
 #endif /* __SUNPRO_C */
       for (i = 0; i < size - 7; i += 4, dp += 8, sa++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 5) & 0x7F8));
@@ -622,12 +622,12 @@
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 21) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         dp[0] = t0;
         dp[1] = t1;
         dp[2] = t2;
         dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 21) & 0x7F8));
@@ -637,7 +637,7 @@
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 5) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0];
         dp[4] = t0;
         dp[5] = t1;
@@ -645,7 +645,7 @@
         dp[7] = t3;
       }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 5) & 0x7F8));
@@ -655,12 +655,12 @@
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 21) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[0] = t0;
       dp[1] = t1;
       dp[2] = t2;
       dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 21) & 0x7F8));
@@ -670,7 +670,7 @@
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 5) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[4] = t0;
       dp[5] = t1;
       dp[6] = t2;
@@ -718,7 +718,7 @@
 #pragma pipeloop(0)
 #endif /* __SUNPRO_C */
       for (i = 0; i < size - 7; i += 4, dp += 12, sa++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
@@ -732,14 +732,14 @@
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
         t4 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
         t5 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         dp[0] = t0;
         dp[1] = t1;
         dp[2] = t2;
         dp[3] = t3;
         dp[4] = t4;
         dp[5] = t5;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
@@ -753,7 +753,7 @@
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
         t4 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
         t5 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0];
         dp[6] = t0;
         dp[7] = t1;
@@ -763,7 +763,7 @@
         dp[11] = t5;
       }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
@@ -777,14 +777,14 @@
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
       t4 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
       t5 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[0] = t0;
       dp[1] = t1;
       dp[2] = t2;
       dp[3] = t3;
       dp[4] = t4;
       dp[5] = t5;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
@@ -798,7 +798,7 @@
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
       t4 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
       t5 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[6] = t0;
       dp[7] = t1;
       dp[8] = t2;
@@ -851,7 +851,7 @@
 #pragma pipeloop(0)
 #endif /* __SUNPRO_C */
       for (i = 0; i < size - 7; i += 4, dp += 16, sa++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
@@ -861,12 +861,12 @@
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 21) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 21) & 0x7F8));
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 >> 21) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         dp[0] = t0;
         dp[1] = t1;
         dp[2] = t2;
         dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 5) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 5) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 5) & 0x7F8));
@@ -876,12 +876,12 @@
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 >> 13) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         dp[4] = t0;
         dp[5] = t1;
         dp[6] = t2;
         dp[7] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
@@ -891,12 +891,12 @@
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 5) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 5) & 0x7F8));
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 >> 5) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         dp[8] = t0;
         dp[9] = t1;
         dp[10] = t2;
         dp[11] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 21) & 0x7F8));
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 21) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 21) & 0x7F8));
@@ -906,7 +906,7 @@
         t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
         t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
         t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 << 3) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0];
         dp[12] = t0;
         dp[13] = t1;
@@ -914,7 +914,7 @@
         dp[15] = t3;
       }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 << 3) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
@@ -924,12 +924,12 @@
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 21) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 21) & 0x7F8));
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 >> 21) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[0] = t0;
       dp[1] = t1;
       dp[2] = t2;
       dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 5) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 5) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 5) & 0x7F8));
@@ -939,12 +939,12 @@
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 >> 13) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[4] = t0;
       dp[5] = t1;
       dp[6] = t2;
       dp[7] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 13) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 13) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 13) & 0x7F8));
@@ -954,12 +954,12 @@
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 5) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 5) & 0x7F8));
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 >> 5) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[8] = t0;
       dp[9] = t1;
       dp[10] = t2;
       dp[11] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_d64 *) ((mlib_u8 *) tab0 + ((s0 >> 21) & 0x7F8));
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 >> 21) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 >> 21) & 0x7F8));
@@ -969,7 +969,7 @@
       t1 = *(mlib_d64 *) ((mlib_u8 *) tab1 + ((s0 << 3) & 0x7F8));
       t2 = *(mlib_d64 *) ((mlib_u8 *) tab2 + ((s0 << 3) & 0x7F8));
       t3 = *(mlib_d64 *) ((mlib_u8 *) tab3 + ((s0 << 3) & 0x7F8));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[12] = t0;
       dp[13] = t1;
       dp[14] = t2;
--- ./jdk/src/share/native/sun/awt/medialib/mlib_ImageLookUp_Bit.c	2010-03-18 01:45:31.000000000 -0700
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_ImageLookUp_Bit.c	2010-01-30 09:28:27.000000000 -0800
@@ -88,7 +88,7 @@
 } d64_2_f32;
 
 /***************************************************************/
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 static const mlib_u32 mlib_bit_mask[16] = {
   0x00000000u, 0xFF000000u, 0x00FF0000u, 0xFFFF0000u,
@@ -126,7 +126,7 @@
   0x00000000u, 0x00FFFFFFu, 0xFF000000u, 0xFFFFFFFFu
 };
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
 /***************************************************************/
 mlib_status mlib_ImageLookUp_Bit_U8_1(const mlib_u8 *src,
@@ -228,13 +228,13 @@
 #endif /* __SUNPRO_C */
     for (; i <= (size - 16); i += 16) {
       s0 = *(mlib_u16*)sa;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       *da++ = dd_array[s0 & 0xFF];
       *da++ = dd_array[s0 >> 8];
 #else
       *da++ = dd_array[s0 >> 8];
       *da++ = dd_array[s0 & 0xFF];
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       sa += 2;
     }
 
@@ -258,20 +258,20 @@
         val1 = p_dd[2*val0+1];
       }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       emask = (mlib_u32)((mlib_s32)(-1)) >> ((4 - (size - i)) * 8);
 #else
       emask = (mlib_s32)(-1) << ((4 - (size - i)) * 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       ((mlib_u32*)da)[0] = (val1 & emask) | (((mlib_u32*)da)[0] &~ emask);
 
 #else /* _NO_LONGLONG */
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       mlib_u64 emask = (mlib_u64)((mlib_s64)(-1)) >> ((8 - (size - i)) * 8);
 #else
       mlib_u64 emask = (mlib_s64)(-1) << ((8 - (size - i)) * 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
       ((mlib_u64*)da)[0] = (((mlib_u64*)dd_array)[sa[0]] & emask) | (((mlib_u64*)da)[0] &~ emask);
 
@@ -323,13 +323,13 @@
 
   val0 = table[0][0];
   val1 = table[0][1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
   val0 = val0 | (table[1][0] << 8);
   val1 = val1 | (table[1][1] << 8);
 #else
   val0 = (val0 << 8) | table[1][0];
   val1 = (val1 << 8) | table[1][1];
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
   val0 |= (val0 << 16);
   val1 |= (val1 << 16);
 
@@ -394,11 +394,11 @@
         dd1 = dd2;
       }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       emask = (mlib_u32)((mlib_s32)(-1)) >> ((4 - (size - i)) * 8);
 #else
       emask = (mlib_s32)(-1) << ((4 - (size - i)) * 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       ((mlib_u32*)da)[0] = (dd1 & emask) | (((mlib_u32*)da)[0] &~ emask);
 
 #else /* _NO_LONGLONG */
@@ -412,11 +412,11 @@
         dd = ((mlib_u64*)dd_array)[s0 & 0xf];
       }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       emask = (mlib_u64)((mlib_s64)(-1)) >> ((8 - (size - i)) * 8);
 #else
       emask = (mlib_s64)(-1) << ((8 - (size - i)) * 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       ((mlib_u64*)da)[0] = (dd & emask) | (((mlib_u64*)da)[0] &~ emask);
 
 #endif /* _NO_LONGLONG */
@@ -462,7 +462,7 @@
 
   buffs = buff + size;
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
   l0 = (table[0][0] << 24) | (table[2][0] << 16) | (table[1][0] << 8) | (table[0][0]);
   h0 = (table[0][1] << 24) | (table[2][1] << 16) | (table[1][1] << 8) | (table[0][1]);
   l1 = (l0 >> 8); l1 |= (l1 << 24);
@@ -476,7 +476,7 @@
   h1 = (h0 << 8); h1 |= (h1 >> 24);
   l2 = (l1 << 8); l2 |= (l2 >> 24);
   h2 = (h1 << 8); h2 |= (h2 >> 24);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
   /* calculate lookup table */
 #ifdef __SUNPRO_C
@@ -564,11 +564,11 @@
         dd = ((mlib_u32*)(d_array12 + (s0 & 0xF)))[1];
       }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       emask = (mlib_u32)((mlib_s32)(-1)) >> ((4 - (size - i)) * 8);
 #else
       emask = (mlib_s32)(-1) << ((4 - (size - i)) * 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       da[0] = (dd & emask) | (da[0] &~ emask);
     }
 
@@ -611,13 +611,13 @@
 
   buffs = buff + size;
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
   l = (table[3][0] << 24) | (table[2][0] << 16) | (table[1][0] << 8) | (table[0][0]);
   h = (table[3][1] << 24) | (table[2][1] << 16) | (table[1][1] << 8) | (table[0][1]);
 #else
   l = (table[0][0] << 24) | (table[1][0] << 16) | (table[2][0] << 8) | (table[3][0]);
   h = (table[0][1] << 24) | (table[1][1] << 16) | (table[2][1] << 8) | (table[3][1]);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
   ((mlib_u32*)lh)[0] = l;  ((mlib_u32*)lh)[1] = l;
   ((mlib_u32*)lh)[2] = l;  ((mlib_u32*)lh)[3] = h;
--- ./jdk/src/share/native/sun/awt/medialib/mlib_ImageUtils.c	2010-03-18 01:45:31.000000000 -0700
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_ImageUtils.c	2010-01-30 09:28:27.000000000 -0800
@@ -30,7 +30,7 @@
 typedef union {
   mlib_d64 db;
   struct {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     mlib_s32 int1, int0;
 #else
     mlib_s32 int0, int1;
--- ./jdk/src/share/native/sun/awt/medialib/mlib_c_ImageCopy.c	2010-03-18 01:45:31.000000000 -0700
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_c_ImageCopy.c	2010-01-30 09:28:27.000000000 -0800
@@ -275,11 +275,11 @@
       for (i = 0; j <= (b_size - 4); j += 4, i++) {
         src0 = src1;
         src1 = pws[i + 1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         pwd[i] = (src0 >> lshift) | (src1 << rshift);
 #else
         pwd[i] = (src0 << lshift) | (src1 >> rshift);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       }
 
       sa += i << 2;
@@ -381,11 +381,11 @@
         for (; j <= (src_width - 4); j += 4) {
           src0 = src1;
           src1 = ps[1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           *((mlib_s32 *) (pdst_row + j)) = (src0 >> shl) | (src1 << shr);
 #else
           *((mlib_s32 *) (pdst_row + j)) = (src0 << shl) | (src1 >> shr);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           ps++;
         }
       }
@@ -414,11 +414,11 @@
         for (; j <= (src_width - 8); j += 8) {
           src0 = src1;
           src1 = ps[1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           *((mlib_s64 *) (pdst_row + j)) = (src0 >> shl) | (src1 << shr);
 #else
           *((mlib_s64 *) (pdst_row + j)) = (src0 << shl) | (src1 >> shr);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           ps++;
         }
       }
@@ -484,11 +484,11 @@
         for (; j <= (src_width - 2); j += 2) {
           src0 = src1;
           src1 = ps[1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           *((mlib_s32 *) (pdst_row + j)) = (src0 >> 16) | (src1 << 16);
 #else
           *((mlib_s32 *) (pdst_row + j)) = (src0 << 16) | (src1 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           ps++;
         }
       }
@@ -516,11 +516,11 @@
         for (; j <= (src_width - 4); j += 4) {
           src0 = src1;
           src1 = ps[1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           *((mlib_s64 *) (pdst_row + j)) = (src0 >> shl) | (src1 << shr);
 #else
           *((mlib_s64 *) (pdst_row + j)) = (src0 << shl) | (src1 >> shr);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           ps++;
         }
       }
@@ -585,11 +585,11 @@
         for (; j <= (src_width - 2); j += 2) {
           src0 = src1;
           src1 = ps[1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           *((mlib_s64 *) (pdst_row + j)) = (src0 >> 32) | (src1 << 32);
 #else
           *((mlib_s64 *) (pdst_row + j)) = (src0 << 32) | (src1 >> 32);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           ps++;
         }
       }
@@ -687,11 +687,11 @@
 #endif /* __SUNPRO_C */
       for (; n > SIZE; n -= SIZE) {
         s1 = *tmp++;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         *(TYPE *) dp = (s0 >> shl) | (s1 << shr);
 #else
         *(TYPE *) dp = (s0 << shl) | (s1 >> shr);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = s1;
         dp += SIZE;
         sp += SIZE;
--- ./jdk/src/share/native/sun/awt/medialib/mlib_c_ImageLookUp_f.c	2010-03-18 01:45:31.000000000 -0700
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_c_ImageLookUp_f.c	2010-01-30 09:28:27.000000000 -0800
@@ -120,7 +120,7 @@
   }                                                               \
 }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 /***************************************************************/
 #define READ_U8_U8_ALIGN(table0, table1, table2, table3)        \
@@ -163,7 +163,7 @@
   t2 = *(mlib_u32*)((mlib_u8*)table2 + ((s0 >> 14)  & 0x3FC));  \
   t3 = *(mlib_u32*)((mlib_u8*)table3 + ((s0 >> 22)  & 0x3FC))
 
-#else /* _LITTLE_ENDIAN */
+#else /* BYTE_ORDER == ... */
 
 /***********/
 #define READ_U8_U8_ALIGN(table0, table1, table2, table3)        \
@@ -206,7 +206,7 @@
   t2 = *(mlib_u32*)((mlib_u8*)table2 + ((s0 >> 6)  & 0x3FC));   \
   t3 = *(mlib_u32*)((mlib_u8*)table3 + ((s0 << 2)  & 0x3FC))
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
 /***************************************************************/
 void mlib_c_ImageLookUp_U8_U8(const mlib_u8 *src,
@@ -297,11 +297,11 @@
         da[0] = t;
         da++;
         dp = (mlib_u8 *) da;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         *dp++ = tab[s2 >> 8];
 #else
         *dp++ = tab[s2 & 0xFF];
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         sp = (mlib_u8 *) sa;
         i += 5;
         for (; i < size; i++, dp++, sp++)
@@ -403,11 +403,11 @@
         da[0] = t;
         da++;
         dp = (mlib_u8 *) da;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         *dp++ = tab0[s2 >> 8];
 #else
         *dp++ = tab0[s2 & 0xFF];
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         sp = (mlib_u8 *) sa;
         i += 5;
 
@@ -544,11 +544,11 @@
         da[0] = t;
         da++;
         dp = (mlib_u8 *) da;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         *dp++ = tab1[s2 >> 8];
 #else
         *dp++ = tab1[s2 & 0xFF];
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         sp = (mlib_u8 *) sa;
         i += 5;
 
@@ -694,11 +694,11 @@
         da[0] = t;
         da++;
         dp = (mlib_u8 *) da;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         *dp++ = tab0[s2 >> 8];
 #else
         *dp++ = tab0[s2 & 0xFF];
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         sp = (mlib_u8 *) sa;
         i += 5;
 
@@ -1852,21 +1852,21 @@
     s0 = tab0[0];
     s1 = tab1[0];
     for (i = 1; i < 256; i++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       s2 = (s1 << 8) + s0;
 #else
       s2 = (s0 << 8) + s1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       s0 = tab0[i];
       s1 = tab1[i];
       tab[i - 1] = (mlib_u16) s2;
     }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     s2 = (s1 << 8) + s0;
 #else
     s2 = (s0 << 8) + s1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     tab[255] = (mlib_u16) s2;
 
     for (j = 0; j < ysize; j++, dst += dlb, src += slb) {
@@ -1897,11 +1897,11 @@
         for (i = 0; i < size - 3; i += 2, da++, sa += 2) {
           t0 = tab[s0];
           t1 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           t = (t1 << 16) + t0;
 #else
           t = (t0 << 16) + t1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           s0 = sa[0];
           s1 = sa[1];
           da[0] = t;
@@ -1909,11 +1909,11 @@
 
         t0 = tab[s0];
         t1 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t = (t1 << 16) + t0;
 #else
         t = (t0 << 16) + t1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da[0] = t;
         da++;
 
@@ -1927,13 +1927,13 @@
 
         if (off > 1) {
           t0 = tab[sa[0]];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           dp[1] = (t0 >> 8);
           dp[0] = t0;
 #else
           dp[0] = (t0 >> 8);
           dp[1] = t0;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           sa++;
           size--;
           dp += 2;
@@ -1941,11 +1941,11 @@
 
         t0 = tab[sa[0]];
         sa++;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         *dp++ = t0;
 #else
         *dp++ = (t0 >> 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
         da = (mlib_s32 *) dp;
 
@@ -1959,11 +1959,11 @@
         for (i = 0; i < size - 4; i += 2, da++, sa += 2) {
           t1 = tab[s0];
           t2 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           t = (t0 >> 8) + (t1 << 8) + (t2 << 24);
 #else
           t = (t0 << 24) + (t1 << 8) + (t2 >> 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           t0 = t2;
           s0 = sa[0];
           s1 = sa[1];
@@ -1972,29 +1972,29 @@
 
         t1 = tab[s0];
         t2 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t = (t0 >> 8) + (t1 << 8) + (t2 << 24);
 #else
         t = (t0 << 24) + (t1 << 8) + (t2 >> 8);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da[0] = t;
         da++;
         dp = (mlib_u8 *) da;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         dp[0] = (t2 >> 8);
 #else
         dp[0] = t2;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
         if ((size & 1) == 0) {
           t0 = tab[sa[0]];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           dp[2] = (t0 >> 8);
           dp[1] = t0;
 #else
           dp[1] = (t0 >> 8);
           dp[2] = t0;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         }
       }
     }
@@ -2012,22 +2012,22 @@
     s1 = tab1[0];
     s2 = tab2[0];
     for (i = 1; i < 256; i++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       s3 = (s2 << 24) + (s1 << 16) + (s0 << 8);
 #else
       s3 = (s0 << 16) + (s1 << 8) + s2;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       s0 = tab0[i];
       s1 = tab1[i];
       s2 = tab2[i];
       tab[i - 1] = s3;
     }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     s3 = (s2 << 24) + (s1 << 16) + (s0 << 8);
 #else
     s3 = (s0 << 16) + (s1 << 8) + s2;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     tab[255] = s3;
 
     for (j = 0; j < ysize; j++, dst += dlb, src += slb) {
@@ -2064,24 +2064,24 @@
       for (i = 0; i < size - 7; i += 4, da += 3, sa += 4) {
         t0 = tab[s0];
         t1 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         da[0] = (t0 >> 8) + (t1 << 16);
         res2 = (t1 >> 16);
 #else
         da[0] = (t0 << 8) + (t1 >> 16);
         res2 = (t1 << 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0];
         s1 = sa[1];
         t0 = tab[s0];
         t1 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res2 += (t0 << 8);
         res1 = (t0 >> 24) + t1;
 #else
         res2 += (t0 >> 8);
         res1 = (t0 << 24) + t1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[2];
         s1 = sa[3];
         da[1] = res2;
@@ -2090,24 +2090,24 @@
 
       t0 = tab[s0];
       t1 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       da[0] = (t0 >> 8) + (t1 << 16);
       res2 = (t1 >> 16);
 #else
       da[0] = (t0 << 8) + (t1 >> 16);
       res2 = (t1 << 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       s0 = sa[0];
       s1 = sa[1];
       t0 = tab[s0];
       t1 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       res2 += (t0 << 8);
       res1 = (t0 >> 24) + t1;
 #else
       res2 += (t0 >> 8);
       res1 = (t0 << 24) + t1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       da[1] = res2;
       da[2] = res1;
       da += 3;
@@ -2143,11 +2143,11 @@
     s2 = tab2[0];
     s3 = tab3[0];
     for (i = 1; i < 256; i++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       s4 = (s3 << 24) + (s2 << 16) + (s1 << 8) + s0;
 #else
       s4 = (s0 << 24) + (s1 << 16) + (s2 << 8) + s3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       s0 = tab0[i];
       s1 = tab1[i];
       s2 = tab2[i];
@@ -2155,11 +2155,11 @@
       tab[i - 1] = s4;
     }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     s4 = (s3 << 24) + (s2 << 16) + (s1 << 8) + s0;
 #else
     s4 = (s0 << 24) + (s1 << 16) + (s2 << 8) + s3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     tab[255] = s4;
 
     for (j = 0; j < ysize; j++, dst += dlb, src += slb) {
@@ -2225,13 +2225,13 @@
         for (i = 0; i < size - 4; i += 2, da += 2, sa += 2) {
           t1 = tab[s0];
           t2 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           res1 = (t0 >> shift) + (t1 << shift1);
           res2 = (t1 >> shift) + (t2 << shift1);
 #else
           res1 = (t0 << shift) + (t1 >> shift1);
           res2 = (t1 << shift) + (t2 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           t0 = t2;
           s0 = sa[0];
           s1 = sa[1];
@@ -2241,28 +2241,28 @@
 
         t1 = tab[s0];
         t2 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res1 = (t0 >> shift) + (t1 << shift1);
         res2 = (t1 >> shift) + (t2 << shift1);
 #else
         res1 = (t0 << shift) + (t1 >> shift1);
         res2 = (t1 << shift) + (t2 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da[0] = res1;
         da[1] = res2;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = (da[2] >> shift1);
         da[2] = (t2 >> shift) + (t0 << shift1);
 #else
         t0 = (da[2] << shift1);
         da[2] = (t2 << shift) + (t0 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da += 2;
         dp = (mlib_u8 *) da + (4 - off);
 
         if ((size & 1) == 0) {
           t0 = tab[sa[0]];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           dp[3] = (mlib_u8) (t0 >> 24);
           dp[2] = (mlib_u8) (t0 >> 16);
           dp[1] = (mlib_u8) (t0 >> 8);
@@ -2272,7 +2272,7 @@
           dp[1] = (mlib_u8) (t0 >> 16);
           dp[2] = (mlib_u8) (t0 >> 8);
           dp[3] = (mlib_u8) t0;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         }
       }
     }
@@ -2348,13 +2348,13 @@
         t3 = tab0[s1];
         t4 = tab1[s1];
         t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         da[0] = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
         res2 = (t5 << 8) + t4;
 #else
         da[0] = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
         res2 = (t4 << 24) + (t5 << 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0];
         s1 = sa[1];
         t0 = tab0[s0];
@@ -2363,13 +2363,13 @@
         t3 = tab0[s1];
         t4 = tab1[s1];
         t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res2 += ((t1 << 24) + (t0 << 16));
         res1 = (t5 << 24) + (t4 << 16) + (t3 << 8) + t2;
 #else
         res2 += ((t0 << 8) + t1);
         res1 = (t2 << 24) + (t3 << 16) + (t4 << 8) + t5;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[2];
         s1 = sa[3];
         da[1] = res2;
@@ -2382,13 +2382,13 @@
       t3 = tab0[s1];
       t4 = tab1[s1];
       t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       da[0] = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
       res2 = (t5 << 8) + t4;
 #else
       da[0] = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
       res2 = (t4 << 24) + (t5 << 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       s0 = sa[0];
       s1 = sa[1];
       t0 = tab0[s0];
@@ -2397,13 +2397,13 @@
       t3 = tab0[s1];
       t4 = tab1[s1];
       t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       res2 += ((t1 << 24) + (t0 << 16));
       res1 = (t5 << 24) + (t4 << 16) + (t3 << 8) + t2;
 #else
       res2 += ((t0 << 8) + t1);
       res1 = (t2 << 24) + (t3 << 16) + (t4 << 8) + t5;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       da[1] = res2;
       da[2] = res1;
       da += 3;
@@ -2455,11 +2455,11 @@
           t1 = tab1[s0];
           t2 = tab2[s0];
           t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           res = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
 #else
           res = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           s0 = sa[0];
           da[0] = res;
         }
@@ -2468,11 +2468,11 @@
         t1 = tab1[s0];
         t2 = tab2[s0];
         t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
 #else
         res = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da[0] = res;
 
       }
@@ -2496,11 +2496,11 @@
         t2 = tab2[s0];
         t3 = tab3[s0];
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res1 = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
 #else
         res1 = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
         s0 = sa[0];
         sa++;
@@ -2513,13 +2513,13 @@
           t1 = tab1[s0];
           t2 = tab2[s0];
           t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           res2 = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
           res = (res1 >> shift) + (res2 << shift1);
 #else
           res2 = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
           res = (res1 << shift) + (res2 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           res1 = res2;
           s0 = sa[0];
           da[0] = res;
@@ -2529,21 +2529,21 @@
         t1 = tab1[s0];
         t2 = tab2[s0];
         t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res2 = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
         res = (res1 >> shift) + (res2 << shift1);
 #else
         res2 = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
         res = (res1 << shift) + (res2 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da[0] = res;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res1 = (da[1] >> shift1);
         da[1] = (res2 >> shift) + (res1 << shift1);
 #else
         res1 = (da[1] << shift1);
         da[1] = (res2 << shift) + (res1 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       }
     }
   }
@@ -2617,13 +2617,13 @@
         t3 = tab0[s1];
         t4 = tab1[s1];
         t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         da[0] = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
         res2 = (t5 << 8) + t4;
 #else
         da[0] = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
         res2 = (t4 << 24) + (t5 << 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0];
         s1 = sa[1];
         t0 = tab0[s0];
@@ -2632,13 +2632,13 @@
         t3 = tab0[s1];
         t4 = tab1[s1];
         t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res2 += ((t1 << 24) + (t0 << 16));
         res1 = (t5 << 24) + (t4 << 16) + (t3 << 8) + t2;
 #else
         res2 += ((t0 << 8) + t1);
         res1 = (t2 << 24) + (t3 << 16) + (t4 << 8) + t5;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[2];
         s1 = sa[3];
         da[1] = res2;
@@ -2651,13 +2651,13 @@
       t3 = tab0[s1];
       t4 = tab1[s1];
       t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       da[0] = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
       res2 = (t5 << 8) + t4;
 #else
       da[0] = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
       res2 = (t4 << 24) + (t5 << 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       s0 = sa[0];
       s1 = sa[1];
       t0 = tab0[s0];
@@ -2666,13 +2666,13 @@
       t3 = tab0[s1];
       t4 = tab1[s1];
       t5 = tab2[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       res2 += ((t1 << 24) + (t0 << 16));
       res1 = (t5 << 24) + (t4 << 16) + (t3 << 8) + t2;
 #else
       res2 += ((t0 << 8) + t1);
       res1 = (t2 << 24) + (t3 << 16) + (t4 << 8) + t5;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       da[1] = res2;
       da[2] = res1;
       da += 3;
@@ -2724,11 +2724,11 @@
           t1 = tab1[s0];
           t2 = tab2[s0];
           t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           res = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
 #else
           res = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           s0 = sa[0];
           da[0] = res;
         }
@@ -2737,11 +2737,11 @@
         t1 = tab1[s0];
         t2 = tab2[s0];
         t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
 #else
         res = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da[0] = res;
 
       }
@@ -2765,11 +2765,11 @@
         t2 = tab2[s0];
         t3 = tab3[s0];
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res1 = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
 #else
         res1 = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
         s0 = sa[0];
         sa++;
@@ -2782,13 +2782,13 @@
           t1 = tab1[s0];
           t2 = tab2[s0];
           t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           res2 = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
           res = (res1 >> shift) + (res2 << shift1);
 #else
           res2 = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
           res = (res1 << shift) + (res2 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           res1 = res2;
           s0 = sa[0];
           da[0] = res;
@@ -2798,21 +2798,21 @@
         t1 = tab1[s0];
         t2 = tab2[s0];
         t3 = tab3[s0];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res2 = (t3 << 24) + (t2 << 16) + (t1 << 8) + t0;
         res = (res1 >> shift) + (res2 << shift1);
 #else
         res2 = (t0 << 24) + (t1 << 16) + (t2 << 8) + t3;
         res = (res1 << shift) + (res2 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da[0] = res;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res1 = (da[1] >> shift1);
         da[1] = (res2 >> shift) + (res1 << shift1);
 #else
         res1 = (da[1] << shift1);
         da[1] = (res2 << shift) + (res1 >> shift1);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       }
     }
   }
@@ -2863,21 +2863,21 @@
     s0 = tab0[0];
     s1 = tab1[0];
     for (i = 1; i < 256; i++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       s2 = (s1 << 16) + s0;
 #else
       s2 = (s0 << 16) + s1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       s0 = tab0[i];
       s1 = tab1[i];
       tab[i - 1] = s2;
     }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     s2 = (s1 << 16) + s0;
 #else
     s2 = (s0 << 16) + s1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     tab[255] = s2;
 
     for (j = 0; j < ysize; j++, dst += dlb, src += slb) {
@@ -2919,11 +2919,11 @@
       else {
 
         t0 = tab[*sa++];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         *dp++ = (mlib_u16) (t0);
 #else
         *dp++ = (mlib_u16) (t0 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da = (mlib_u32 *) dp;
         s0 = sa[0];
         s1 = sa[1];
@@ -2935,13 +2935,13 @@
         for (i = 0; i < size - 4; i += 2, da += 2, sa += 2) {
           t1 = tab[s0];
           t2 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           res1 = (t0 >> 16) + (t1 << 16);
           res2 = (t1 >> 16) + (t2 << 16);
 #else
           res1 = (t0 << 16) + (t1 >> 16);
           res2 = (t1 << 16) + (t2 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           t0 = t2;
           s0 = sa[0];
           s1 = sa[1];
@@ -2951,32 +2951,32 @@
 
         t1 = tab[s0];
         t2 = tab[s1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res1 = (t0 >> 16) + (t1 << 16);
         res2 = (t1 >> 16) + (t2 << 16);
 #else
         res1 = (t0 << 16) + (t1 >> 16);
         res2 = (t1 << 16) + (t2 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da[0] = res1;
         da[1] = res2;
         da += 2;
         dp = (mlib_u16 *) da;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         dp[0] = (mlib_u16) (t2 >> 16);
 #else
         dp[0] = (mlib_u16) t2;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
         if ((size & 1) == 0) {
           t0 = tab[sa[0]];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           dp[2] = (mlib_u16) (t0 >> 16);
           dp[1] = (mlib_u16) t0;
 #else
           dp[1] = (mlib_u16) (t0 >> 16);
           dp[2] = (mlib_u16) t0;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         }
       }
     }
@@ -2994,13 +2994,13 @@
     s1 = tab1[0];
     s2 = tab2[0];
     for (i = 1; i < 256; i++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       s3 = (s0 << 16);
       s4 = (s2 << 16) + s1;
 #else
       s3 = s0;
       s4 = (s1 << 16) + s2;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       s0 = tab0[i];
       s1 = tab1[i];
       s2 = tab2[i];
@@ -3008,13 +3008,13 @@
       tab[2 * i - 1] = s4;
     }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     s4 = (s2 << 16) + s1;
     tab[510] = s0 << 16;
 #else
     s4 = (s1 << 16) + s2;
     tab[510] = s0;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     tab[511] = s4;
 
     for (j = 0; j < ysize; j++, dst += dlb, src += slb) {
@@ -3050,13 +3050,13 @@
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab + s0 + 4);
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab + s1);
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab + s1 + 4);
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res1 = (t0 >> 16) + (t1 << 16);
         res2 = (t1 >> 16) + t2;
 #else
         res1 = (t0 << 16) + (t1 >> 16);
         res2 = (t1 << 16) + t2;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0] << 3;
         s1 = sa[1] << 3;
         da[0] = res1;
@@ -3068,13 +3068,13 @@
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab + s0 + 4);
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab + s1);
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab + s1 + 4);
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       res1 = (t0 >> 16) + (t1 << 16);
       res2 = (t1 >> 16) + t2;
 #else
       res1 = (t0 << 16) + (t1 >> 16);
       res2 = (t1 << 16) + t2;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       da[0] = res1;
       da[1] = res2;
       da[2] = t3;
@@ -3105,13 +3105,13 @@
     s2 = tab2[0];
     s3 = tab3[0];
     for (i = 1; i < 256; i++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       s4 = (s1 << 16) + s0;
       s5 = (s3 << 16) + s2;
 #else
       s4 = (s0 << 16) + s1;
       s5 = (s2 << 16) + s3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       s0 = tab0[i];
       s1 = tab1[i];
       s2 = tab2[i];
@@ -3120,13 +3120,13 @@
       tab[2 * i - 1] = s5;
     }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
     s4 = (s1 << 16) + s0;
     s5 = (s3 << 16) + s2;
 #else
     s4 = (s0 << 16) + s1;
     s5 = (s2 << 16) + s3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
     tab[510] = s4;
     tab[511] = s5;
 
@@ -3181,18 +3181,18 @@
 
         t4 = tab[2 * sa[0]];
         t5 = tab[2 * sa[0] + 1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         *dp++ = (mlib_u16) (t4);
 #else
         *dp++ = (mlib_u16) (t4 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         sa++;
         da = (mlib_u32 *) dp;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         *da++ = (t4 >> 16) + (t5 << 16);
 #else
         *da++ = (t4 << 16) + (t5 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0] << 3;
         s1 = sa[1] << 3;
         sa += 2;
@@ -3205,7 +3205,7 @@
           t1 = *(mlib_u32 *) ((mlib_u8 *) tab + s0 + 4);
           t2 = *(mlib_u32 *) ((mlib_u8 *) tab + s1);
           t3 = *(mlib_u32 *) ((mlib_u8 *) tab + s1 + 4);
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           res1 = (t5 >> 16) + (t0 << 16);
           res2 = (t0 >> 16) + (t1 << 16);
           res3 = (t1 >> 16) + (t2 << 16);
@@ -3215,7 +3215,7 @@
           res2 = (t0 << 16) + (t1 >> 16);
           res3 = (t1 << 16) + (t2 >> 16);
           res4 = (t2 << 16) + (t3 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           s0 = sa[0] << 3;
           s1 = sa[1] << 3;
           da[0] = res1;
@@ -3229,7 +3229,7 @@
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab + s0 + 4);
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab + s1);
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab + s1 + 4);
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         res1 = (t5 >> 16) + (t0 << 16);
         res2 = (t0 >> 16) + (t1 << 16);
         res3 = (t1 >> 16) + (t2 << 16);
@@ -3239,36 +3239,36 @@
         res2 = (t0 << 16) + (t1 >> 16);
         res3 = (t1 << 16) + (t2 >> 16);
         res4 = (t2 << 16) + (t3 >> 16);
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         da[0] = res1;
         da[1] = res2;
         da[2] = res3;
         da[3] = res4;
         da += 4;
         dp = (mlib_u16 *) da;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         dp[0] = (mlib_u16) (t3 >> 16);
 #else
         dp[0] = (mlib_u16) t3;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
 
         if ((size & 1) == 0) {
           t0 = tab[2 * sa[0]];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           dp[2] = (mlib_u16) (t0 >> 16);
           dp[1] = (mlib_u16) t0;
 #else
           dp[1] = (mlib_u16) (t0 >> 16);
           dp[2] = (mlib_u16) t0;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
           t0 = tab[2 * sa[0] + 1];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
           dp[4] = (mlib_u16) (t0 >> 16);
           dp[3] = (mlib_u16) t0;
 #else
           dp[3] = (mlib_u16) (t0 >> 16);
           dp[4] = (mlib_u16) t0;
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         }
       }
     }
@@ -3439,7 +3439,7 @@
 #pragma pipeloop(0)
 #endif /* __SUNPRO_C */
       for (i = 0; i < size - 7; i += 4, dp += 8, sa++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 6) & 0x3FC));
@@ -3449,12 +3449,12 @@
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 22) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         dp[0] = t0;
         dp[1] = t1;
         dp[2] = t2;
         dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 22) & 0x3FC));
@@ -3464,7 +3464,7 @@
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 6) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0];
         dp[4] = t0;
         dp[5] = t1;
@@ -3472,7 +3472,7 @@
         dp[7] = t3;
       }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 6) & 0x3FC));
@@ -3482,12 +3482,12 @@
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 22) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[0] = t0;
       dp[1] = t1;
       dp[2] = t2;
       dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 22) & 0x3FC));
@@ -3497,7 +3497,7 @@
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 6) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[4] = t0;
       dp[5] = t1;
       dp[6] = t2;
@@ -3545,7 +3545,7 @@
 #pragma pipeloop(0)
 #endif /* __SUNPRO_C */
       for (i = 0; i < size - 7; i += 4, dp += 12, sa++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
@@ -3559,14 +3559,14 @@
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
         t4 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
         t5 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         dp[0] = t0;
         dp[1] = t1;
         dp[2] = t2;
         dp[3] = t3;
         dp[4] = t4;
         dp[5] = t5;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
@@ -3580,7 +3580,7 @@
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
         t4 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
         t5 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0];
         dp[6] = t0;
         dp[7] = t1;
@@ -3590,7 +3590,7 @@
         dp[11] = t5;
       }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
@@ -3604,14 +3604,14 @@
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
       t4 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
       t5 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[0] = t0;
       dp[1] = t1;
       dp[2] = t2;
       dp[3] = t3;
       dp[4] = t4;
       dp[5] = t5;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
@@ -3625,7 +3625,7 @@
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
       t4 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
       t5 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[6] = t0;
       dp[7] = t1;
       dp[8] = t2;
@@ -3678,7 +3678,7 @@
 #pragma pipeloop(0)
 #endif /* __SUNPRO_C */
       for (i = 0; i < size - 7; i += 4, dp += 16, sa++) {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
@@ -3688,12 +3688,12 @@
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 22) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 22) & 0x3FC));
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 >> 22) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         dp[0] = t0;
         dp[1] = t1;
         dp[2] = t2;
         dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 6) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 6) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 6) & 0x3FC));
@@ -3703,12 +3703,12 @@
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 >> 14) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         dp[4] = t0;
         dp[5] = t1;
         dp[6] = t2;
         dp[7] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
@@ -3718,12 +3718,12 @@
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 6) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 6) & 0x3FC));
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 >> 6) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         dp[8] = t0;
         dp[9] = t1;
         dp[10] = t2;
         dp[11] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 22) & 0x3FC));
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 22) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 22) & 0x3FC));
@@ -3733,7 +3733,7 @@
         t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
         t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
         t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 << 2) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
         s0 = sa[0];
         dp[12] = t0;
         dp[13] = t1;
@@ -3741,7 +3741,7 @@
         dp[15] = t3;
       }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 << 2) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
@@ -3751,12 +3751,12 @@
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 22) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 22) & 0x3FC));
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 >> 22) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[0] = t0;
       dp[1] = t1;
       dp[2] = t2;
       dp[3] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 6) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 6) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 6) & 0x3FC));
@@ -3766,12 +3766,12 @@
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 >> 14) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[4] = t0;
       dp[5] = t1;
       dp[6] = t2;
       dp[7] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 14) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 14) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 14) & 0x3FC));
@@ -3781,12 +3781,12 @@
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 6) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 6) & 0x3FC));
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 >> 6) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[8] = t0;
       dp[9] = t1;
       dp[10] = t2;
       dp[11] = t3;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
       t0 = *(mlib_u32 *) ((mlib_u8 *) tab0 + ((s0 >> 22) & 0x3FC));
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 >> 22) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 >> 22) & 0x3FC));
@@ -3796,7 +3796,7 @@
       t1 = *(mlib_u32 *) ((mlib_u8 *) tab1 + ((s0 << 2) & 0x3FC));
       t2 = *(mlib_u32 *) ((mlib_u8 *) tab2 + ((s0 << 2) & 0x3FC));
       t3 = *(mlib_u32 *) ((mlib_u8 *) tab3 + ((s0 << 2) & 0x3FC));
-#endif /* _LITTLE_ENDIAN */
+#endif /* BYTE_ORDER == LITTLE_ENDIAN */
       dp[12] = t0;
       dp[13] = t1;
       dp[14] = t2;
--- ./jdk/src/share/native/sun/awt/medialib/mlib_image.h	2010-03-18 01:45:31.000000000 -0700
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_image.h	2010-01-30 09:28:27.000000000 -0800
@@ -27,6 +27,16 @@
 #ifndef MLIB_IMAGE_H
 #define MLIB_IMAGE_H
 
+#ifdef __OpenBSD__
+#include <sys/types.h>
+#endif
+#ifdef _ALLBSD_SOURCE
+#include <machine/endian.h>
+#elif __linux__
+#define __USE_BSD 1
+#include <endian.h>
+#endif
+
 #include <mlib_types.h>
 #include <mlib_status.h>
 #include <mlib_sys.h>
--- ./jdk/src/share/native/sun/awt/medialib/mlib_sys.c	2010-03-18 01:45:31.000000000 -0700
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_sys.c	2010-01-30 09:28:27.000000000 -0800
@@ -26,9 +26,15 @@
 
 #include <stdlib.h>
 #include <string.h>
+#ifdef _ALLBSD_SOURCE
+#include <unistd.h>
+#endif
 #include <mlib_types.h>
 #include <mlib_sys_proto.h>
 #include "mlib_SysMath.h"
+#if defined(_ALLBSD_SOURCE)
+#include <sys/param.h>
+#endif
 
 /***************************************************************/
 
@@ -86,7 +92,12 @@
    * alignment. -- from stdlib.h of MS VC++5.0.
    */
   return (void *) malloc(size);
-#else /* _MSC_VER */
+#elif defined(__FreeBSD__) && (__FreeBSD_version >= 700013)
+  void *ret;
+  return posix_memalign(&ret, 8, size) ? NULL : ret;
+#elif defined(_ALLBSD_SOURCE)
+  return valloc(size);
+#else
   return (void *) memalign(8, size);
 #endif /* _MSC_VER */
 }
--- ./jdk/src/share/native/sun/awt/medialib/mlib_types.h	2010-03-18 01:45:31.000000000 -0700
+++ ./jdk/src/share/native/sun/awt/medialib/mlib_types.h	2010-01-30 09:28:27.000000000 -0800
@@ -59,7 +59,10 @@
 
 #if defined(__SUNPRO_C) || defined(__SUNPRO_CC) || defined(__GNUC__)
 
-#if defined(__linux__)
+#if defined(_ALLBSD_SOURCE)
+#include <stddef.h>                     /* for ptrdiff_t */
+#include <stdint.h>                     /* for uintptr_t */
+#elif defined(__linux__)
 #include <stdint.h>                     /* for uintptr_t */
 #include <malloc.h>                     /* for ptrdiff_t */
 #else
--- ./jdk/src/share/native/sun/font/AccelGlyphCache.c	2010-03-18 01:45:31.000000000 -0700
+++ ./jdk/src/share/native/sun/font/AccelGlyphCache.c	2010-01-30 09:28:27.000000000 -0800
@@ -23,7 +23,11 @@
  * have any questions.
  */
 
+#ifdef _ALLBSD_SOURCE
+#include <stdlib.h>
+#else
 #include <malloc.h>
+#endif
 #include "jni.h"
 #include "AccelGlyphCache.h"
 #include "Trace.h"
--- ./jdk/src/share/native/sun/font/DrawGlyphList.c	2010-03-18 01:45:31.000000000 -0700
+++ ./jdk/src/share/native/sun/font/DrawGlyphList.c	2010-01-30 09:28:27.000000000 -0800
@@ -26,7 +26,11 @@
 #include "jlong.h"
 #include "math.h"
 #include "string.h"
+#ifdef _ALLBSD_SOURCE
+#include "stdlib.h"
+#else
 #include "malloc.h"
+#endif
 #include "sunfontids.h"
 #include "fontscalerdefs.h"
 #include "glyphblitting.h"
--- ./jdk/src/share/native/sun/font/sunFont.c	2010-03-18 01:45:32.000000000 -0700
+++ ./jdk/src/share/native/sun/font/sunFont.c	2010-01-30 09:28:28.000000000 -0800
@@ -24,7 +24,9 @@
  */
 
 #include "stdlib.h"
+#ifndef _ALLBSD_SOURCE
 #include "malloc.h"
+#endif
 #include "string.h"
 #include "gdefs.h"
 #include "jlong.h"
--- ./jdk/src/share/native/sun/java2d/SurfaceData.c	2010-03-18 01:45:32.000000000 -0700
+++ ./jdk/src/share/native/sun/java2d/SurfaceData.c	2010-01-30 09:28:28.000000000 -0800
@@ -28,7 +28,11 @@
 #include "jni_util.h"
 #include "Disposer.h"
 
+#ifdef _ALLBSD_SOURCE
+#include <stdlib.h>
+#else
 #include "malloc.h"
+#endif
 #include "string.h"
 
 /**
--- ./jdk/src/share/native/sun/java2d/opengl/OGLFuncs.h	2010-03-18 01:45:32.000000000 -0700
+++ ./jdk/src/share/native/sun/java2d/opengl/OGLFuncs.h	2010-01-30 09:28:28.000000000 -0800
@@ -26,6 +26,9 @@
 #ifndef OGLFuncs_h_Included
 #define OGLFuncs_h_Included
 
+#ifdef _ALLBSD_SOURCE
+#include <dlfcn.h>
+#endif
 #include "jni.h"
 #include "J2D_GL/gl.h"
 #include "J2D_GL/glext.h"
--- ./jdk/src/share/native/sun/java2d/opengl/OGLRenderQueue.c	2010-03-18 01:45:32.000000000 -0700
+++ ./jdk/src/share/native/sun/java2d/opengl/OGLRenderQueue.c	2010-01-30 09:28:28.000000000 -0800
@@ -25,7 +25,11 @@
 
 #ifndef HEADLESS
 
+#ifdef _ALLBSD_SOURCE
+#include <stdlib.h>
+#else
 #include <malloc.h>
+#endif
 
 #include "sun_java2d_pipe_BufferedOpCodes.h"
 
--- ./jdk/src/share/native/sun/java2d/opengl/OGLTextRenderer.c	2010-03-18 01:45:32.000000000 -0700
+++ ./jdk/src/share/native/sun/java2d/opengl/OGLTextRenderer.c	2010-01-30 09:28:28.000000000 -0800
@@ -25,7 +25,11 @@
 
 #ifndef HEADLESS
 
+#ifdef _ALLBSD_SOURCE
+#include <stdlib.h>
+#else
 #include <malloc.h>
+#endif
 #include <math.h>
 #include <jlong.h>
 
--- ./jdk/src/share/native/sun/nio/ch/genSocketOptionRegistry.c	2010-03-18 01:45:32.000000000 -0700
+++ ./jdk/src/share/native/sun/nio/ch/genSocketOptionRegistry.c	2010-01-30 09:28:29.000000000 -0800
@@ -28,6 +28,7 @@
 #include <winsock2.h>
 #include <ws2tcpip.h>
 #else
+#include <sys/types.h>
 #include <sys/socket.h>
 #include <netinet/in.h>
 #include <netinet/tcp.h>
--- ./jdk/src/share/native/sun/security/ec/impl/ecc_impl.h	2010-03-18 01:45:32.000000000 -0700
+++ ./jdk/src/share/native/sun/security/ec/impl/ecc_impl.h	2010-01-30 09:28:29.000000000 -0800
@@ -78,6 +78,14 @@
 typedef enum { B_FALSE, B_TRUE } boolean_t;
 #endif /* __linux__ */
 
+#ifdef _ALLBSD_SOURCE
+#include <stdint.h>
+#define B_FALSE FALSE
+#define B_TRUE TRUE
+typedef unsigned long ulong_t;
+typedef enum boolean { B_FALSE, B_TRUE } boolean_t;
+#endif /* _ALLBSD_SOURCE */
+
 #ifdef _WIN32
 typedef unsigned char uint8_t;
 typedef unsigned long ulong_t;
--- ./jdk/src/share/native/sun/security/ec/impl/ecdecode.c	2010-03-18 01:45:32.000000000 -0700
+++ ./jdk/src/share/native/sun/security/ec/impl/ecdecode.c	2010-01-30 09:28:29.000000000 -0800
@@ -60,9 +60,9 @@
 #include <sys/types.h>
 
 #ifndef _WIN32
-#ifndef __linux__
+#if !defined(__linux__) && !defined(_ALLBSD_SOURCE)
 #include <sys/systm.h>
-#endif /* __linux__ */
+#endif /* __linux__ || _ALLBSD_SOURCE */
 #include <sys/param.h>
 #endif /* _WIN32 */
 
--- ./jdk/src/share/native/sun/security/ec/impl/oid.c	2010-03-18 01:45:32.000000000 -0700
+++ ./jdk/src/share/native/sun/security/ec/impl/oid.c	2010-01-30 09:28:29.000000000 -0800
@@ -59,9 +59,9 @@
 #include <sys/types.h>
 
 #ifndef _WIN32
-#ifndef __linux__
+#if !defined(__linux__) && !defined(_ALLBSD_SOURCE)
 #include <sys/systm.h>
-#endif /* __linux__ */
+#endif /* __linux__ || _ALLBSD_SOURCE */
 #include <sys/param.h>
 #endif /* _WIN32 */
 
--- ./jdk/src/share/native/sun/security/ec/impl/secitem.c	2010-03-18 01:45:32.000000000 -0700
+++ ./jdk/src/share/native/sun/security/ec/impl/secitem.c	2010-01-30 09:28:29.000000000 -0800
@@ -64,9 +64,9 @@
 #include <sys/types.h>
 
 #ifndef _WIN32
-#ifndef __linux__
+#if !defined(__linux__) && !defined(_ALLBSD_SOURCE)
 #include <sys/systm.h>
-#endif /* __linux__ */
+#endif /* __linux__ || _ALLBSD_SOURCE */
 #include <sys/param.h>
 #endif /* _WIN32 */
 
--- ./jdk/src/share/transport/socket/socketTransport.c	2010-03-18 01:45:33.000000000 -0700
+++ ./jdk/src/share/transport/socket/socketTransport.c	2010-01-30 09:28:30.000000000 -0800
@@ -65,6 +65,9 @@
 #define HEADER_SIZE     11
 #define MAX_DATA_SIZE 1000
 
+static jint recv_fully(int, char *, int);
+static jint send_fully(int, char *, int);
+
 /*
  * Record the last error for this thread.
  */
@@ -155,7 +158,7 @@
         }
         buf = b;
         buf += received;
-        n = dbgsysRecv(fd, buf, helloLen-received, 0);
+        n = recv_fully(fd, buf, helloLen-received);
         if (n == 0) {
             setLastError(0, "handshake failed - connection prematurally closed");
             return JDWPTRANSPORT_ERROR_IO_ERROR;
@@ -180,7 +183,7 @@
         return JDWPTRANSPORT_ERROR_IO_ERROR;
     }
 
-    if (dbgsysSend(fd, (char*)hello, helloLen, 0) != helloLen) {
+    if (send_fully(fd, (char*)hello, helloLen) != helloLen) {
         RETURN_IO_ERROR("send failed during handshake");
     }
     return JDWPTRANSPORT_ERROR_NONE;
@@ -555,19 +558,19 @@
     /* Do one send for short packets, two for longer ones */
     if (data_len <= MAX_DATA_SIZE) {
         memcpy(header + HEADER_SIZE, data, data_len);
-        if (dbgsysSend(socketFD, (char *)&header, HEADER_SIZE + data_len, 0) !=
+        if (send_fully(socketFD, (char *)&header, HEADER_SIZE + data_len) != 
             HEADER_SIZE + data_len) {
             RETURN_IO_ERROR("send failed");
         }
     } else {
         memcpy(header + HEADER_SIZE, data, MAX_DATA_SIZE);
-        if (dbgsysSend(socketFD, (char *)&header, HEADER_SIZE + MAX_DATA_SIZE, 0) !=
+        if (send_fully(socketFD, (char *)&header, HEADER_SIZE + MAX_DATA_SIZE) != 
             HEADER_SIZE + MAX_DATA_SIZE) {
             RETURN_IO_ERROR("send failed");
         }
         /* Send the remaining data bytes right out of the data area. */
-        if (dbgsysSend(socketFD, (char *)data + MAX_DATA_SIZE,
-                       data_len - MAX_DATA_SIZE, 0) != data_len - MAX_DATA_SIZE) {
+        if (send_fully(socketFD, (char *)data + MAX_DATA_SIZE, 
+                       data_len - MAX_DATA_SIZE) != data_len - MAX_DATA_SIZE) {
             RETURN_IO_ERROR("send failed");
         }
     }
@@ -575,13 +578,33 @@
     return JDWPTRANSPORT_ERROR_NONE;
 }
 
-static jint
+jint
 recv_fully(int f, char *buf, int len)
 {
     int nbytes = 0;
     while (nbytes < len) {
         int res = dbgsysRecv(f, buf + nbytes, len - nbytes, 0);
         if (res < 0) {
+	    if (errno == EINTR)
+		continue;
+            return res;
+        } else if (res == 0) {
+            break; /* eof, return nbytes which is less than len */
+        }
+        nbytes += res;
+    }
+    return nbytes;
+}
+
+jint
+send_fully(int f, char *buf, int len)
+{
+    int nbytes = 0;
+    while (nbytes < len) {
+        int res = dbgsysSend(f, buf + nbytes, len - nbytes, 0);
+        if (res < 0) {
+	    if (errno == EINTR)
+		continue;
             return res;
         } else if (res == 0) {
             break; /* eof, return nbytes which is less than len */
--- ./jdk/src/solaris/back/exec_md.c	2010-03-18 01:45:33.000000000 -0700
+++ ./jdk/src/solaris/back/exec_md.c	2010-01-30 09:28:30.000000000 -0800
@@ -30,7 +30,7 @@
 #include "sys.h"
 #include "util.h"
 
-#ifdef LINUX
+#if defined(LINUX) || defined(_ALLBSD_SOURCE)
   /* Linux */
   #define FORK() fork()
 #else
--- ./jdk/src/solaris/back/linker_md.c	2010-03-18 01:45:33.000000000 -0700
+++ ./jdk/src/solaris/back/linker_md.c	2010-01-30 09:28:30.000000000 -0800
@@ -48,6 +48,12 @@
 #include "threads_md.h"
 #endif
 
+#ifdef __APPLE__
+#define LIB_SUFFIX "dylib"
+#else
+#define LIB_SUFFIX "so"
+#endif
+
 /*
  * create a string for the JNI native function name by adding the
  * appropriate decorations.
@@ -77,9 +83,9 @@
     }
 
     if (pnamelen == 0) {
-        (void)snprintf(holder, holderlen, "lib%s.so", fname);
+        (void)snprintf(holder, holderlen, "lib%s." LIB_SUFFIX, fname);
     } else {
-        (void)snprintf(holder, holderlen, "%s/lib%s.so", pname, fname);
+        (void)snprintf(holder, holderlen, "%s/lib%s." LIB_SUFFIX, pname, fname);
     }
 }
 
--- ./jdk/src/solaris/back/util_md.h	2010-03-18 01:45:33.000000000 -0700
+++ ./jdk/src/solaris/back/util_md.h	2010-01-30 09:28:30.000000000 -0800
@@ -31,6 +31,11 @@
 
 #include <limits.h>
 #include <sys/types.h>
+#ifdef _ALLBSD_SOURCE
+#include <machine/endian.h>
+#elif __linux__
+#include <endian.h>
+#endif
 
 #ifdef _LP64
 typedef unsigned long UNSIGNED_JLONG;
@@ -46,7 +51,7 @@
 
 /* On little endian machines, convert java big endian numbers. */
 
-#if defined(_LITTLE_ENDIAN)
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 #define HOST_TO_JAVA_CHAR(x) (((x & 0xff) << 8) | ((x >> 8) & (0xff)))
 #define HOST_TO_JAVA_SHORT(x) (((x & 0xff) << 8) | ((x >> 8) & (0xff)))
--- ./jdk/src/solaris/bin/ergo.c	2010-03-18 01:45:33.000000000 -0700
+++ ./jdk/src/solaris/bin/ergo.c	2010-01-30 09:28:30.000000000 -0800
@@ -71,14 +71,39 @@
 /* Compute physical memory by asking the OS */
 uint64_t
 physical_memory(void) {
+  uint64_t result;
+
+# define UINT64_FORMAT "%" PRIu64
+
+#if defined(_ALLBSD_SOURCE)
+#ifdef HW_PHYSMEM64
+  int64_t physmem;
+  int name[2] = { CTL_HW, HW_PHYSMEM64 };
+#else
+  unsigned long physmem;
+  int name[2] = { CTL_HW, HW_PHYSMEM };
+#endif
+  size_t physmem_len = sizeof(physmem);
+
+  if (sysctl(name, 2, &physmem, &physmem_len, NULL, 0) == -1)
+	physmem = 256 * MB;
+
+  result = (uint64_t)physmem;
+
+  JLI_TraceLauncher("physical memory: " UINT64_FORMAT " (%.3fGB)\n",
+           result, result / (double) GB);
+  return result;
+
+#else /* !_ALLBSD_SOURCE */
+
   const uint64_t pages     = (uint64_t) sysconf(_SC_PHYS_PAGES);
   const uint64_t page_size = (uint64_t) sysconf(_SC_PAGESIZE);
-  const uint64_t result    = pages * page_size;
-# define UINT64_FORMAT "%" PRIu64
+  result    = pages * page_size;
 
   JLI_TraceLauncher("pages: " UINT64_FORMAT
           "  page_size: " UINT64_FORMAT
           "  physical memory: " UINT64_FORMAT " (%.3fGB)\n",
            pages, page_size, result, result / (double) GB);
   return result;
+#endif /* _ALLBSD_SOURCE */
 }
--- ./jdk/src/solaris/bin/ergo.h	2010-03-18 01:45:33.000000000 -0700
+++ ./jdk/src/solaris/bin/ergo.h	2010-01-30 09:28:30.000000000 -0800
@@ -33,6 +33,10 @@
 #include <sys/stat.h>
 #include <unistd.h>
 #include <sys/types.h>
+#ifdef _ALLBSD_SOURCE
+#include <sys/param.h>
+#include <sys/sysctl.h>
+#endif
 
 #include "java.h"
 
--- ./jdk/src/solaris/bin/ergo_i586.c	2010-03-18 01:45:33.000000000 -0700
+++ ./jdk/src/solaris/bin/ergo_i586.c	2010-01-30 09:28:30.000000000 -0800
@@ -106,7 +106,7 @@
 
 #endif /* __solaris__ */
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 
 /*
  * A utility method for asking the CPU about itself.
@@ -170,7 +170,9 @@
   *edxp = value_of_edx;
 #endif /* _LP64 */
 }
+#endif /* __linux__ || _ALLBSD_SOURCE */
 
+#ifdef __linux__
 /* The definition of a server-class machine for linux-i586 */
 jboolean
 ServerClassMachineImpl(void) {
@@ -199,6 +201,37 @@
 }
 #endif /* __linux__ */
 
+#if defined(_ALLBSD_SOURCE)
+
+/* The definition of a server-class machine for bsd-i586 */
+jboolean
+ServerClassMachineImpl(void) {
+  jboolean            result            = JNI_FALSE;
+  /* How big is a server class machine? */
+  const unsigned long server_processors = 2UL;
+  const uint64_t      server_memory     = 2UL * GB;
+  /*
+   * We seem not to get our full complement of memory.
+   *     We allow some part (1/8?) of the memory to be "missing",
+   *     based on the sizes of DIMMs, and maybe graphics cards.
+   */
+  const uint64_t      missing_memory    = 256UL * MB;
+  const uint64_t      actual_memory     = physical_memory();
+
+  /* Is this a server class machine? */
+  if (actual_memory >= (server_memory - missing_memory)) {
+    const unsigned long actual_processors = physical_processors();
+    if (actual_processors >= server_processors) {
+      result = JNI_TRUE;
+    }
+  }
+  JLI_TraceLauncher("bsd_" LIBARCHNAME "_ServerClassMachine: %s\n",
+           (result == JNI_TRUE ? "true" : "false"));
+  return result;
+}
+
+#endif /* _ALLBSD_SOURCE */
+
 /*
  * Routines shared by solaris-i586 and linux-i586.
  */
@@ -308,6 +341,14 @@
 /* Compute the number of physical processors, not logical processors */
 static unsigned long
 physical_processors(void) {
+#if defined(_ALLBSD_SOURCE)
+  unsigned long result;
+  int name[2] = { CTL_HW, HW_NCPU };
+  size_t rlen = sizeof(result);
+
+  if (sysctl(name, 2, &result, &rlen, NULL, 0) == -1)
+	result = 1;
+#else /* !_ALLBSD_SOURCE */
   const long sys_processors = sysconf(_SC_NPROCESSORS_CONF);
   unsigned long result      = sys_processors;
 
@@ -318,6 +359,7 @@
       result = (unsigned long) sys_processors / logical_processors;
     }
   }
+#endif /* _ALLBSD_SOURCE */
   JLI_TraceLauncher("physical processors: %lu\n", result);
   return result;
 }
--- ./jdk/src/solaris/bin/java_md.c	2010-03-18 01:45:33.000000000 -0700
+++ ./jdk/src/solaris/bin/java_md.c	2010-01-30 09:28:30.000000000 -0800
@@ -24,6 +24,7 @@
  */
 
 #include "java.h"
+#include "jvm_md.h"
 #include <dirent.h>
 #include <dlfcn.h>
 #include <fcntl.h>
@@ -34,17 +35,30 @@
 #include <sys/stat.h>
 #include <unistd.h>
 #include <sys/types.h>
+#if defined(_ALLBSD_SOURCE)
+#include <sys/time.h>
+#endif
+
 #include "manifest_info.h"
 #include "version_comp.h"
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <pthread.h>
 #else
 #include <thread.h>
 #endif
 
+#ifdef __APPLE__
+#define JVM_DLL "libjvm.dylib"
+#define JAVA_DLL "libjava.dylib"
+/* FALLBACK avoids naming conflicts with system libraries
+ * (eg, ImageIO's libJPEG.dylib) */
+#define LD_LIBRARY_PATH "DYLD_FALLBACK_LIBRARY_PATH"
+#else
 #define JVM_DLL "libjvm.so"
 #define JAVA_DLL "libjava.so"
+#define LD_LIBRARY_PATH "LD_LIBRARY_PATH"
+#endif
 
 /*
  * If a processor / os combination has the ability to run binaries of
@@ -71,14 +85,31 @@
 #endif
 
 /* pointer to environment */
+#ifdef __APPLE__
+#include <crt_externs.h>
+#define environ (*_NSGetEnviron())
+#else
 extern char **environ;
+#endif
 
 /*
  *      A collection of useful strings. One should think of these as #define
  *      entries, but actual strings can be more efficient (with many compilers).
  */
-#ifdef __linux__
-static const char *system_dir   = "/usr/java";
+#if defined(__FreeBSD__)
+static const char *system_dir	= PACKAGE_PATH "/openjdk7";
+static const char *user_dir	= "/java";
+#elif defined(__NetBSD__)
+static const char *system_dir	= PACKAGE_PATH "/openjdk7";
+static const char *user_dir	= "/java";
+#elif defined(__OpenBSD__)
+static const char *system_dir	= PACKAGE_PATH "/openjdk7";
+static const char *user_dir	= "/java";
+#elif defined(__APPLE__)
+static const char *system_dir	= PACKAGE_PATH "/openjdk7";
+static const char *user_dir	= "/java";
+#elif defined(__linux__)
+static const char *system_dir   = PACKAGE_PATH "/java";
 static const char *user_dir     = "/java";
 #else /* Solaris */
 static const char *system_dir   = "/usr/jdk";
@@ -1021,9 +1052,23 @@
     return(borrowed_unsetenv(name));
 }
 
+#if defined(_ALLBSD_SOURCE)
+/*
+ * BSD's implementation of CounterGet()
+ */
+int64_t
+CounterGet()
+{
+	struct timeval tv;
+	gettimeofday(&tv, NULL);
+	return (tv.tv_sec * 1000) + tv.tv_usec;
+}
+#endif
+
+
 /* --- Splash Screen shared library support --- */
 
-static const char* SPLASHSCREEN_SO = "libsplashscreen.so";
+static const char* SPLASHSCREEN_SO = JNI_LIB_NAME("splashscreen");
 
 static void* hSplashLib = NULL;
 
@@ -1059,7 +1104,7 @@
 int
 ContinueInNewThread0(int (JNICALL *continuation)(void *), jlong stack_size, void * args) {
     int rslt;
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     pthread_t tid;
     pthread_attr_t attr;
     pthread_attr_init(&attr);
--- ./jdk/src/solaris/bin/java_md.h	2010-03-18 01:45:33.000000000 -0700
+++ ./jdk/src/solaris/bin/java_md.h	2010-01-30 09:28:30.000000000 -0800
@@ -47,10 +47,14 @@
 #include <sys/time.h>
 #define CounterGet()              (gethrtime()/1000)
 #define Counter2Micros(counts)    (counts)
+#elif defined(_ALLBSD_SOURCE)
+/* CounterGet() is implemented in java_md.c */
+int64_t CounterGet(void);
+#define Counter2Micros(counts)    (counts)
 #else
 #define CounterGet()              (0)
 #define Counter2Micros(counts)    (1)
-#endif /* HAVE_GETHRTIME */
+#endif /* HAVE_GETHRTIME || _ALLBSD_SOURCE */
 
 /*
  * Function prototypes.
--- ./jdk/src/solaris/classes/sun/awt/X11FontManager.java	2010-03-18 01:45:34.000000000 -0700
+++ ./jdk/src/solaris/classes/sun/awt/X11FontManager.java	2010-01-30 09:28:31.000000000 -0800
@@ -213,7 +213,7 @@
         if (fontID != null) {
             fileName = (String)fontNameMap.get(fontID);
             /* On Linux check for the Lucida Oblique fonts */
-            if (fileName == null && FontUtilities.isLinux && !isOpenJDK()) {
+            if (fileName == null && (FontUtilities.isLinux || FontUtilities.isBSD) && !isOpenJDK()) {
                 if (oblmap == null) {
                     initObliqueLucidaFontMap();
                 }
@@ -712,7 +712,7 @@
         if (fontConfigDirs == null) {
             return;
         }
-        if (FontUtilities.isLinux) {
+        if (FontUtilities.isLinux || FontUtilities.isBSD) {
             fontConfigDirs.add(jreLibDirName+File.separator+"oblique-fonts");
         }
         fontdirs = (String[])fontConfigDirs.toArray(new String[0]);
@@ -759,7 +759,7 @@
          */
         FontConfiguration mFontConfig = new MFontConfiguration(this);
         if (FontUtilities.isOpenSolaris ||
-            (FontUtilities.isLinux &&
+            ((FontUtilities.isLinux || FontUtilities.isBSD) &&
              (!mFontConfig.foundOsSpecificFile() ||
               !mFontConfig.fontFilesArePresent()) ||
              (FontUtilities.isSolaris && !mFontConfig.fontFilesArePresent()))) {
--- ./jdk/src/solaris/classes/sun/awt/fontconfigs/bsd.fontconfig.Fedora.properties	2010-03-27 11:09:14.000000000 -0700
+++ ./jdk/src/solaris/classes/sun/awt/fontconfigs/bsd.fontconfig.Fedora.properties	1969-12-31 16:00:00.000000000 -0800
@@ -1,189 +0,0 @@
-#
-# 
-# Copyright 2007 Sun Microsystems, Inc.  All Rights Reserved.
-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
-#
-# This code is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License version 2 only, as
-# published by the Free Software Foundation.  Sun designates this
-# particular file as subject to the "Classpath" exception as provided
-# by Sun in the LICENSE file that accompanied this code.
-#
-# This code is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# version 2 for more details (a copy is included in the LICENSE file that
-# accompanied this code).
-#
-# You should have received a copy of the GNU General Public License version
-# 2 along with this work; if not, write to the Free Software Foundation,
-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
-#
-# Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
-# CA 95054 USA or visit www.sun.com if you need additional information or
-# have any questions.
-#
-
-# Version
-
-# Uses Fedora Core 6 fonts and file paths.
-version=1
-
-# Component Font Mappings
-
-dialog.plain.latin-1=DejaVu LGC Sans
-dialog.plain.japanese-x0208=Sazanami Gothic
-dialog.plain.korean=Baekmuk Gulim
-dialog.plain.chinese-big5=AR PL ShanHeiSun Uni
-dialog.plain.chinese-gb18030=AR PL ShanHeiSun Uni
-
-dialog.bold.latin-1=DejaVu LGC Sans Bold
-dialog.bold.japanese-x0208=Sazanami Gothic
-dialog.bold.korean=Baekmuk Gulim
-dialog.bold.chinese-big5=AR PL ShanHeiSun Uni
-dialog.bold.chinese-gb18030=AR PL ShanHeiSun Uni
-
-dialog.italic.latin-1=DejaVu LGC Sans Oblique
-dialog.italic.japanese-x0208=Sazanami Gothic
-dialog.italic.korean=Baekmuk Gulim
-dialog.italic.chinese-big5=AR PL ShanHeiSun Uni
-dialog.italic.chinese-gb18030=AR PL ShanHeiSun Uni
-
-dialog.bolditalic.latin-1=DejaVu LGC Sans Bold Oblique
-dialog.bolditalic.japanese-x0208=Sazanami Gothic
-dialog.bolditalic.korean=Baekmuk Gulim
-dialog.bolditalic.chinese-big5=AR PL ShanHeiSun Uni
-dialog.bolditalic.chinese-gb18030=AR PL ShanHeiSun Uni
-
-
-sansserif.plain.latin-1=DejaVu LGC Sans
-sansserif.plain.japanese-x0208=Sazanami Gothic
-sansserif.plain.korean=Baekmuk Gulim
-sansserif.plain.chinese-big5=AR PL ShanHeiSun Uni
-sansserif.plain.chinese-gb18030=AR PL ShanHeiSun Uni
-
-sansserif.bold.latin-1=DejaVu LGC Sans Bold
-sansserif.bold.japanese-x0208=Sazanami Gothic
-sansserif.bold.korean=Baekmuk Gulim
-sansserif.bold.chinese-big5=AR PL ShanHeiSun Uni
-sansserif.bold.chinese-gb18030=AR PL ShanHeiSun Uni
-
-sansserif.italic.latin-1=DejaVu LGC Sans Oblique
-sansserif.italic.japanese-x0208=Sazanami Gothic
-sansserif.italic.korean=Baekmuk Gulim
-sansserif.italic.chinese-big5=AR PL ShanHeiSun Uni
-sansserif.italic.chinese-gb18030=AR PL ShanHeiSun Uni
-
-sansserif.bolditalic.latin-1=DejaVu LGC Sans Bold Oblique
-sansserif.bolditalic.japanese-x0208=Sazanami Gothic
-sansserif.bolditalic.korean=Baekmuk Gulim
-sansserif.bolditalic.chinese-big5=AR PL ShanHeiSun Uni
-sansserif.bolditalic.chinese-gb18030=AR PL ShanHeiSun Uni
-
-
-serif.plain.latin-1=DejaVu LGC Serif
-serif.plain.japanese-x0208=Sazanami Mincho
-serif.plain.korean=Baekmuk Batang
-serif.plain.chinese-big5=AR PL ZenKai Uni
-serif.plain.chinese-gb18030=AR PL ZenKai Uni
-
-serif.bold.latin-1=DejaVu LGC Serif Bold
-serif.bold.japanese-x0208=Sazanami Mincho
-serif.bold.korean=Baekmuk Batang
-serif.bold.chinese-big5=AR PL ZenKai Uni
-serif.bold.chinese-gb18030=AR PL ZenKai Uni
-
-serif.italic.latin-1=DejaVu LGC Serif Oblique
-serif.italic.japanese-x0208=Sazanami Mincho
-serif.italic.korean=Baekmuk Batang
-serif.italic.chinese-big5=AR PL ZenKai Uni
-serif.italic.chinese-gb18030=AR PL ZenKai Uni
-
-serif.bolditalic.latin-1=DejaVu LGC Serif Bold Oblique
-serif.bolditalic.japanese-x0208=Sazanami Mincho
-serif.bolditalic.korean=Baekmuk Batang
-serif.bolditalic.chinese-big5=AR PL ZenKai Uni
-serif.bolditalic.chinese-gb18030=AR PL ZenKai Uni
-
-
-monospaced.plain.latin-1=DejaVu LGC Sans Mono
-monospaced.plain.japanese-x0208=Sazanami Gothic
-monospaced.plain.korean=Baekmuk Gulim
-monospaced.plain.chinese-big5=AR PL ShanHeiSun Uni
-monospaced.plain.chinese-gb18030=AR PL ShanHeiSun Uni
-
-monospaced.bold.latin-1=DejaVu LGC Sans Mono Bold
-monospaced.bold.japanese-x0208=Sazanami Gothic
-monospaced.bold.korean=Baekmuk Gulim
-monospaced.bold.chinese-big5=AR PL ShanHeiSun Uni
-monospaced.bold.chinese-gb18030=AR PL ShanHeiSun Uni
-
-monospaced.italic.latin-1=DejaVu LGC Sans Mono Oblique
-monospaced.italic.japanese-x0208=Sazanami Gothic
-monospaced.italic.korean=Baekmuk Gulim
-monospaced.italic.chinese-big5=AR PL ShanHeiSun Uni
-monospaced.italic.chinese-gb18030=AR PL ShanHeiSun Uni
-
-monospaced.bolditalic.latin-1=DejaVu LGC Sans Mono Bold Oblique
-monospaced.bolditalic.japanese-x0208=Sazanami Gothic
-monospaced.bolditalic.korean=Baekmuk Gulim
-monospaced.bolditalic.chinese-big5=AR PL ShanHeiSun Uni
-monospaced.bolditalic.chinese-gb18030=AR PL ShanHeiSun Uni
-
-
-dialoginput.plain.latin-1=DejaVu LGC Sans Mono
-dialoginput.plain.japanese-x0208=Sazanami Gothic
-dialoginput.plain.korean=Baekmuk Gulim
-dialoginput.plain.chinese-big5=AR PL ShanHeiSun Uni
-dialoginput.plain.chinese-gb18030=AR PL ShanHeiSun Uni
-
-dialoginput.bold.latin-1=DejaVu LGC Sans Mono Bold
-dialoginput.bold.japanese-x0208=Sazanami Gothic
-dialoginput.bold.korean=Baekmuk Gulim
-dialoginput.bold.chinese-big5=AR PL ShanHeiSun Uni
-dialoginput.bold.chinese-gb18030=AR PL ShanHeiSun Uni
-
-dialoginput.italic.latin-1=DejaVu LGC Sans Mono Oblique
-dialoginput.italic.japanese-x0208=Sazanami Gothic
-dialoginput.italic.korean=Baekmuk Gulim
-dialoginput.italic.chinese-big5=AR PL ShanHeiSun Uni
-dialoginput.italic.chinese-gb18030=AR PL ShanHeiSun Uni
-
-dialoginput.bolditalic.latin-1=DejaVu LGC Sans Mono Bold Oblique
-dialoginput.bolditalic.japanese-x0208=Sazanami Gothic
-dialoginput.bolditalic.korean=Baekmuk Gulim
-dialoginput.bolditalic.chinese-big5=AR PL ShanHeiSun Uni
-dialoginput.bolditalic.chinese-gb18030=AR PL ShanHeiSun Uni
-
-# Search Sequences
-
-sequence.allfonts=latin-1
-sequence.allfonts.Big5=chinese-big5,latin-1
-sequence.allfonts.x-euc-jp-bsd=japanese-x0208,latin-1
-sequence.allfonts.EUC-KR=korean,latin-1
-sequence.allfonts.GB18030=chinese-gb18030,latin-1
-sequence.fallback=chinese-big5,chinese-gb18030,japanese-x0208,korean
-
-# Font File Names
-
-filename.DejaVu_LGC_Sans=/usr/share/fonts/dejavu-lgc/DejaVuLGCSans.ttf
-filename.DejaVu_LGC_Sans_Bold=/usr/share/fonts/dejavu-lgc/DejaVuLGCSans-Bold.ttf
-filename.DejaVu_LGC_Sans_Oblique=/usr/share/fonts/dejavu-lgc/DejaVuLGCSans-Oblique.ttf
-filename.DejaVu_LGC_Sans_Bold_Oblique=/usr/share/fonts/dejavu-lgc/DejaVuLGCSans-BoldOblique.ttf
-
-filename.DejaVu_LGC_Sans_Mono=/usr/share/fonts/dejavu-lgc/DejaVuLGCSansMono.ttf
-filename.DejaVu_LGC_Sans_Mono_Bold=/usr/share/fonts/dejavu-lgc/DejaVuLGCSansMono-Bold.ttf
-filename.DejaVu_LGC_Sans_Mono_Oblique=/usr/share/fonts/dejavu-lgc/DejaVuLGCSansMono-Oblique.ttf
-filename.DejaVu_LGC_Sans_Mono_Bold_Oblique=/usr/share/fonts/dejavu-lgc/DejaVuLGCSansMono-BoldOblique.ttf
-
-filename.DejaVu_LGC_Serif=/usr/share/fonts/dejavu-lgc/DejaVuLGCSerif.ttf
-filename.DejaVu_LGC_Serif_Bold=/usr/share/fonts/dejavu-lgc/DejaVuLGCSerif-Bold.ttf
-filename.DejaVu_LGC_Serif_Oblique=/usr/share/fonts/dejavu-lgc/DejaVuLGCSerif-Oblique.ttf
-filename.DejaVu_LGC_Serif_Bold_Oblique=/usr/share/fonts/dejavu-lgc/DejaVuLGCSerif-BoldOblique.ttf
-
-filename.Sazanami_Gothic=/usr/share/fonts/japanese/TrueType/sazanami-gothic.ttf
-filename.Sazanami_Mincho=/usr/share/fonts/japanese/TrueType/sazanami-mincho.ttf
-filename.AR_PL_ShanHeiSun_Uni=/usr/share/fonts/chinese/TrueType/uming.ttf
-filename.AR_PL_ZenKai_Uni=/usr/share/fonts/chinese/TrueType/ukai.ttf
-filename.Baekmuk_Gulim=/usr/share/fonts/korean/TrueType/gulim.ttf
-filename.Baekmuk_Batang=/usr/share/fonts/korean/TrueType/batang.ttf
--- ./jdk/src/solaris/classes/sun/awt/fontconfigs/bsd.fontconfig.SuSE.properties	2010-03-27 11:09:14.000000000 -0700
+++ ./jdk/src/solaris/classes/sun/awt/fontconfigs/bsd.fontconfig.SuSE.properties	1969-12-31 16:00:00.000000000 -0800
@@ -1,154 +0,0 @@
-#
-# 
-# Copyright 2007 Sun Microsystems, Inc.  All Rights Reserved.
-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
-#
-# This code is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License version 2 only, as
-# published by the Free Software Foundation.  Sun designates this
-# particular file as subject to the "Classpath" exception as provided
-# by Sun in the LICENSE file that accompanied this code.
-#
-# This code is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# version 2 for more details (a copy is included in the LICENSE file that
-# accompanied this code).
-#
-# You should have received a copy of the GNU General Public License version
-# 2 along with this work; if not, write to the Free Software Foundation,
-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
-#
-# Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
-# CA 95054 USA or visit www.sun.com if you need additional information or
-# have any questions.
-#
-
-# Version
-
-# Uses SuSE 10.2 fonts and file paths.
-version=1
-
-# Component Font Mappings
-
-dialog.plain.latin-1=Albany AMT
-dialog.plain.japanese-x0208=Sazanami Gothic
-dialog.plain.korean=UnDotum
-
-dialog.bold.latin-1=Albany AMT Bold
-dialog.bold.japanese-x0208=Sazanami Gothic
-dialog.bold.korean=UnDotum Bold
-
-dialog.italic.latin-1=Albany AMT Italic
-dialog.italic.japanese-x0208=Sazanami Gothic
-dialog.italic.korean=UnDotum
-
-dialog.bolditalic.latin-1=Albany AMT Bold Italic
-dialog.bolditalic.japanese-x0208=Sazanami Gothic
-dialog.bolditalic.korean=UnDotum Bold
-
-
-sansserif.plain.latin-1=Albany AMT
-sansserif.plain.japanese-x0208=Sazanami Gothic
-sansserif.plain.korean=UnDotum
-
-sansserif.bold.latin-1=Albany AMT Bold
-sansserif.bold.japanese-x0208=Sazanami Gothic
-sansserif.bold.korean=UnDotum Bold
-
-sansserif.italic.latin-1=Albany AMT Italic
-sansserif.italic.japanese-x0208=Sazanami Gothic
-sansserif.italic.korean=UnDotum
-
-sansserif.bolditalic.latin-1=Albany AMT Bold Italic
-sansserif.bolditalic.japanese-x0208=Sazanami Gothic
-sansserif.bolditalic.korean=UnDotum Bold
-
-
-serif.plain.latin-1=Thorndale AMT
-serif.plain.japanese-x0208=Sazanami Mincho
-serif.plain.korean=UnBatang
-
-serif.bold.latin-1=Thorndale AMT Bold
-serif.bold.japanese-x0208=Sazanami Mincho
-serif.bold.korean=UnBatang Bold
-
-serif.italic.latin-1=Thorndale AMT Italic
-serif.italic.japanese-x0208=Sazanami Mincho
-serif.italic.korean=UnBatang
-
-serif.bolditalic.latin-1=Thorndale AMT Bold Italic
-serif.bolditalic.japanese-x0208=Sazanami Mincho
-serif.bolditalic.korean=UnBatang Bold
-
-
-monospaced.plain.latin-1=Cumberland AMT
-monospaced.plain.japanese-x0208=Sazanami Gothic
-monospaced.plain.korean=UnDotum
-
-monospaced.bold.latin-1=Cumberland AMT Bold
-monospaced.bold.japanese-x0208=Sazanami Gothic
-monospaced.bold.korean=UnDotum Bold
-
-monospaced.italic.latin-1=Cumberland AMT Italic
-monospaced.italic.japanese-x0208=Sazanami Gothic
-monospaced.italic.korean=UnDotum
-
-monospaced.bolditalic.latin-1=Cumberland AMT Bold Italic
-monospaced.bolditalic.japanese-x0208=Sazanami Gothic
-monospaced.bolditalic.korean=UnDotum Bold
-
-
-dialoginput.plain.latin-1=Cumberland AMT
-dialoginput.plain.japanese-x0208=Sazanami Gothic
-dialoginput.plain.korean=UnDotum
-
-dialoginput.bold.latin-1=Cumberland AMT Bold
-dialoginput.bold.japanese-x0208=Sazanami Gothic
-dialoginput.bold.korean=UnDotum Bold
-
-dialoginput.italic.latin-1=Cumberland AMT Italic
-dialoginput.italic.japanese-x0208=Sazanami Gothic
-dialoginput.italic.korean=UnDotum
-
-dialoginput.bolditalic.latin-1=Cumberland AMT Bold Italic
-dialoginput.bolditalic.japanese-x0208=Sazanami Gothic
-dialoginput.bolditalic.korean=UnDotum Bold
-
-allfonts.chinese-big5=AR PL Mingti2L Big5
-allfonts.chinese-gb18030=AR PL SungtiL GB
-
-# Search Sequences
-
-sequence.allfonts=latin-1
-sequence.allfonts.Big5=chinese-big5,latin-1
-sequence.allfonts.x-euc-jp-bsd=japanese-x0208,latin-1
-sequence.allfonts.EUC-KR=korean,latin-1
-sequence.allfonts.GB18030=chinese-gb18030,latin-1
-sequence.fallback=chinese-big5,chinese-gb18030,japanese-x0208,korean
-
-# Font File Names
-
-filename.Albany_AMT=/usr/share/fonts/truetype/albw.ttf
-filename.Albany_AMT_Bold=/usr/share/fonts/truetype/albwb.ttf
-filename.Albany_AMT_Italic=/usr/share/fonts/truetype/albwb.ttf
-filename.Albany_AMT_Bold_Italic=/usr/share/fonts/truetype/albwbi.ttf
-
-filename.Thorndale_AMT=/usr/share/fonts/truetype/thowr___.ttf
-filename.Thorndale_AMT_Bold=/usr/share/fonts/truetype/thowb___.ttf
-filename.Thorndale_AMT_Italic=/usr/share/fonts/truetype/thowi___.ttf
-filename.Thorndale_AMT_Bold_Italic=/usr/share/fonts/truetype/thowbi__.ttf
-
-filename.Cumberland_AMT=/usr/share/fonts/truetype/cumbwr__.ttf
-filename.Cumberland_AMT_Bold=/usr/share/fonts/truetype/cumbwb__.ttf
-filename.Cumberland_AMT_Italic=/usr/share/fonts/truetype/cumbwi__.ttf
-filename.Cumberland_AMT_Bold_Italic=/usr/share/fonts/truetype/cumbwbi_.ttf
-
-filename.Sazanami_Gothic=/usr/share/fonts/truetype/sazanami-gothic.ttf
-filename.Sazanami_Mincho=/usr/share/fonts/truetype/sazanami-mincho.ttf
-filename.AR_PL_SungtiL_GB=/usr/share/fonts/truetype/gbsn00lp.ttf
-filename.AR_PL_Mingti2L_Big5=/usr/share/fonts/truetype/bsmi00lp.ttf
-filename.UnDotum=/usr/share/fonts/truetype/UnDotum.ttf
-filename.UnDotum_Bold=/usr/share/fonts/truetype/UnDotumBold.ttf
-filename.UnBatang=/usr/share/fonts/truetype/UnBatang.ttf
-filename.UnBatang_Bold=/usr/share/fonts/truetype/UnBatangBold.ttf
--- ./jdk/src/solaris/classes/sun/awt/fontconfigs/bsd.fontconfig.Ubuntu.properties	2010-03-27 11:09:14.000000000 -0700
+++ ./jdk/src/solaris/classes/sun/awt/fontconfigs/bsd.fontconfig.Ubuntu.properties	1969-12-31 16:00:00.000000000 -0800
@@ -1,151 +0,0 @@
-#
-# 
-# Copyright 2007 Sun Microsystems, Inc.  All Rights Reserved.
-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
-#
-# This code is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License version 2 only, as
-# published by the Free Software Foundation.  Sun designates this
-# particular file as subject to the "Classpath" exception as provided
-# by Sun in the LICENSE file that accompanied this code.
-#
-# This code is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# version 2 for more details (a copy is included in the LICENSE file that
-# accompanied this code).
-#
-# You should have received a copy of the GNU General Public License version
-# 2 along with this work; if not, write to the Free Software Foundation,
-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
-#
-# Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
-# CA 95054 USA or visit www.sun.com if you need additional information or
-# have any questions.
-#
-
-# Version
-
-# Uses Ubuntu 6.10 (Edgy) fonts and file paths.
-version=1
-
-# Component Font Mappings
-
-dialog.plain.latin-1=DejaVu Sans
-dialog.plain.japanese-x0208=Kochi Gothic
-dialog.plain.korean=Baekmuk Dotum
-
-dialog.bold.latin-1=DejaVu Sans Bold
-dialog.bold.japanese-x0208=Kochi Gothic
-dialog.bold.korean=Baekmuk Dotum
-
-dialog.italic.latin-1=DejaVu Sans Oblique
-dialog.italic.japanese-x0208=Kochi Gothic
-dialog.italic.korean=Baekmuk Dotum
-
-dialog.bolditalic.latin-1=DejaVu Sans Bold Oblique
-dialog.bolditalic.japanese-x0208=Kochi Gothic
-dialog.bolditalic.korean=Baekmuk Dotum
-
-
-sansserif.plain.latin-1=DejaVu Sans
-sansserif.plain.japanese-x0208=Kochi Gothic
-sansserif.plain.korean=Baekmuk Dotum
-
-sansserif.bold.latin-1=DejaVu Sans Bold
-sansserif.bold.japanese-x0208=Kochi Gothic
-sansserif.bold.korean=Baekmuk Dotum
-
-sansserif.italic.latin-1=DejaVu Sans Oblique
-sansserif.italic.japanese-x0208=Kochi Gothic
-sansserif.italic.korean=Baekmuk Dotum
-
-sansserif.bolditalic.latin-1=DejaVu Sans Bold Oblique
-sansserif.bolditalic.japanese-x0208=Kochi Gothic
-sansserif.bolditalic.korean=Baekmuk Dotum
-
-
-serif.plain.latin-1=DejaVu Serif
-serif.plain.japanese-x0208=Kochi Mincho
-serif.plain.korean=Baekmuk Batang
-
-serif.bold.latin-1=DejaVu Serif Bold
-serif.bold.japanese-x0208=Kochi Mincho
-serif.bold.korean=Baekmuk Batang
-
-serif.italic.latin-1=DejaVu Serif Oblique
-serif.italic.japanese-x0208=Kochi Mincho
-serif.italic.korean=Baekmuk Batang
-
-serif.bolditalic.latin-1=DejaVu Serif Bold Oblique
-serif.bolditalic.japanese-x0208=Kochi Mincho
-serif.bolditalic.korean=Baekmuk Batang
-
-
-monospaced.plain.latin-1=DejaVu Sans Mono
-monospaced.plain.japanese-x0208=Kochi Gothic
-monospaced.plain.korean=Baekmuk Dotum
-
-monospaced.bold.latin-1=DejaVu Sans Mono Bold
-monospaced.bold.japanese-x0208=Kochi Gothic
-monospaced.bold.korean=Baekmuk Dotum
-
-monospaced.italic.latin-1=DejaVu Sans Mono Oblique
-monospaced.italic.japanese-x0208=Kochi Gothic
-monospaced.italic.korean=Baekmuk Dotum
-
-monospaced.bolditalic.latin-1=DejaVu Sans Mono Bold Oblique
-monospaced.bolditalic.japanese-x0208=Kochi Gothic
-monospaced.bolditalic.korean=Baekmuk Dotum
-
-
-dialoginput.plain.latin-1=DejaVu Sans Mono
-dialoginput.plain.japanese-x0208=Kochi Gothic
-dialoginput.plain.korean=Baekmuk Dotum
-
-dialoginput.bold.latin-1=DejaVu Sans Mono Bold
-dialoginput.bold.japanese-x0208=Kochi Gothic
-dialoginput.bold.korean=Baekmuk Dotum
-
-dialoginput.italic.latin-1=DejaVu Sans Mono Oblique
-dialoginput.italic.japanese-x0208=Kochi Gothic
-dialoginput.italic.korean=Baekmuk Dotum
-
-dialoginput.bolditalic.latin-1=DejaVu Sans Mono Bold Oblique
-dialoginput.bolditalic.japanese-x0208=Kochi Gothic
-dialoginput.bolditalic.korean=Baekmuk Dotum
-
-allfonts.chinese-big5=AR PL ZenKai Uni
-allfonts.chinese-gb18030=AR PL ZenKai Uni
-
-# Search Sequences
-
-sequence.allfonts=latin-1
-sequence.allfonts.Big5=chinese-big5,latin-1
-sequence.allfonts.x-euc-jp-bsd=japanese-x0208,latin-1
-sequence.allfonts.EUC-KR=korean,latin-1
-sequence.allfonts.GB18030=chinese-gb18030,latin-1
-sequence.fallback=chinese-big5,chinese-gb18030,japanese-x0208,korean
-
-# Font File Names
-
-filename.DejaVu_Sans=/usr/share/fonts/truetype/ttf-dejavu/DejaVuSans.ttf
-filename.DejaVu_Sans_Bold=/usr/share/fonts/truetype/ttf-dejavu/DejaVuSans-Bold.ttf
-filename.DejaVu_Sans_Oblique=/usr/share/fonts/truetype/ttf-dejavu/DejaVuSans-Oblique.ttf
-filename.DejaVu_Sans_Bold_Oblique=/usr/share/fonts/truetype/ttf-dejavu/DejaVuSans-BoldOblique.ttf
-
-filename.DejaVu_Sans_Mono=/usr/share/fonts/truetype/ttf-dejavu/DejaVuSansMono.ttf
-filename.DejaVu_Sans_Mono_Bold=/usr/share/fonts/truetype/ttf-dejavu/DejaVuSansMono-Bold.ttf
-filename.DejaVu_Sans_Mono_Oblique=/usr/share/fonts/truetype/ttf-dejavu/DejaVuSansMono-Oblique.ttf
-filename.DejaVu_Sans_Mono_Bold_Oblique=/usr/share/fonts/truetype/ttf-dejavu/DejaVuSansMono-BoldOblique.ttf
-
-filename.DejaVu_Serif=/usr/share/fonts/truetype/ttf-dejavu/DejaVuSerif.ttf
-filename.DejaVu_Serif_Bold=/usr/share/fonts/truetype/ttf-dejavu/DejaVuSerif-Bold.ttf
-filename.DejaVu_Serif_Oblique=/usr/share/fonts/truetype/ttf-dejavu/DejaVuSerif-Oblique.ttf
-filename.DejaVu_Serif_Bold_Oblique=/usr/share/fonts/truetype/ttf-dejavu/DejaVuSerif-BoldOblique.ttf
-
-filename.Kochi_Gothic=/usr/share/fonts/truetype/kochi/kochi-gothic-subst.ttf
-filename.Kochi_Mincho=/usr/share/fonts/truetype/kochi/kochi-mincho-subst.ttf
-filename.AR_PL_ZenKai_Uni=/usr/share/fonts//truetype/arphic/ukai.ttf
-filename.Baekmuk_Dotum=/usr/share/fonts/truetype/baekmuk/dotum.ttf
-filename.Baekmuk_Batang=/usr/share/fonts/truetype/baekmuk/batang.ttf
--- ./jdk/src/solaris/classes/sun/nio/ch/BsdAsynchronousChannelProvider.java	2010-03-27 11:09:14.000000000 -0700
+++ ./jdk/src/solaris/classes/sun/nio/ch/BsdAsynchronousChannelProvider.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,99 +0,0 @@
-/*
- * Copyright 2008-2009 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-
-package sun.nio.ch;
-
-import java.nio.channels.*;
-import java.nio.channels.spi.AsynchronousChannelProvider;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.ThreadFactory;
-import java.net.ProtocolFamily;
-import java.io.IOException;
-
-public class BsdAsynchronousChannelProvider
-    extends AsynchronousChannelProvider
-{
-    private static volatile EPollPort defaultPort;
-
-    private EPollPort defaultEventPort() throws IOException {
-        if (defaultPort == null) {
-            synchronized (BsdAsynchronousChannelProvider.class) {
-                if (defaultPort == null) {
-                    defaultPort = new EPollPort(this, ThreadPool.getDefault()).start();
-                }
-            }
-        }
-        return defaultPort;
-    }
-
-    public BsdAsynchronousChannelProvider() {
-    }
-
-    @Override
-    public AsynchronousChannelGroup openAsynchronousChannelGroup(int nThreads, ThreadFactory factory)
-        throws IOException
-    {
-        return new EPollPort(this, ThreadPool.create(nThreads, factory)).start();
-    }
-
-    @Override
-    public AsynchronousChannelGroup openAsynchronousChannelGroup(ExecutorService executor, int initialSize)
-        throws IOException
-    {
-        return new EPollPort(this, ThreadPool.wrap(executor, initialSize)).start();
-    }
-
-    private Port toPort(AsynchronousChannelGroup group) throws IOException {
-        if (group == null) {
-            return defaultEventPort();
-        } else {
-            if (!(group instanceof EPollPort))
-                throw new IllegalChannelGroupException();
-            return (Port)group;
-        }
-    }
-
-    @Override
-    public AsynchronousServerSocketChannel openAsynchronousServerSocketChannel(AsynchronousChannelGroup group)
-        throws IOException
-    {
-        return new UnixAsynchronousServerSocketChannelImpl(toPort(group));
-    }
-
-    @Override
-    public AsynchronousSocketChannel openAsynchronousSocketChannel(AsynchronousChannelGroup group)
-        throws IOException
-    {
-        return new UnixAsynchronousSocketChannelImpl(toPort(group));
-    }
-
-    @Override
-    public AsynchronousDatagramChannel openAsynchronousDatagramChannel(ProtocolFamily family,
-                                                                       AsynchronousChannelGroup group)
-        throws IOException
-    {
-        return new SimpleAsynchronousDatagramChannelImpl(family, toPort(group));
-    }
-}
--- ./jdk/src/solaris/classes/sun/nio/fs/BsdDosFileAttributeView.java	2010-03-27 11:09:14.000000000 -0700
+++ ./jdk/src/solaris/classes/sun/nio/fs/BsdDosFileAttributeView.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,288 +0,0 @@
-/*
- * Copyright 2008-2009 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-
-package sun.nio.fs;
-
-import java.nio.file.attribute.*;
-import java.util.Map;
-import java.io.IOException;
-import sun.misc.Unsafe;
-
-import static sun.nio.fs.UnixNativeDispatcher.*;
-import static sun.nio.fs.UnixConstants.*;
-
-/**
- * Bsd implementation of DosFileAttributeView for use on file systems such
- * as ext3 that have extended attributes enabled and SAMBA configured to store
- * DOS attributes.
- */
-
-class BsdDosFileAttributeView
-    extends UnixFileAttributeViews.Basic implements DosFileAttributeView
-{
-    private static final Unsafe unsafe = Unsafe.getUnsafe();
-
-    private static final String READONLY_NAME = "readonly";
-    private static final String ARCHIVE_NAME = "archive";
-    private static final String SYSTEM_NAME = "system";
-    private static final String HIDDEN_NAME = "hidden";
-
-    private static final String DOS_XATTR_NAME = "user.DOSATTRIB";
-    private static final byte[] DOS_XATTR_NAME_AS_BYTES = DOS_XATTR_NAME.getBytes();
-
-    private static final int DOS_XATTR_READONLY = 0x01;
-    private static final int DOS_XATTR_HIDDEN   = 0x02;
-    private static final int DOS_XATTR_SYSTEM   = 0x04;
-    private static final int DOS_XATTR_ARCHIVE  = 0x20;
-
-    BsdDosFileAttributeView(UnixPath file, boolean followLinks) {
-        super(file, followLinks);
-    }
-
-    @Override
-    public String name() {
-        return "dos";
-    }
-
-    @Override
-    public Object getAttribute(String attribute) throws IOException {
-        if (attribute.equals(READONLY_NAME))
-            return readAttributes().isReadOnly();
-        if (attribute.equals(ARCHIVE_NAME))
-            return readAttributes().isArchive();
-        if (attribute.equals(SYSTEM_NAME))
-            return readAttributes().isSystem();
-        if (attribute.equals(HIDDEN_NAME))
-            return readAttributes().isHidden();
-        return super.getAttribute(attribute);
-    }
-
-    @Override
-    public void setAttribute(String attribute, Object value)
-        throws IOException
-    {
-        if (attribute.equals(READONLY_NAME)) {
-            setReadOnly((Boolean)value);
-            return;
-        }
-        if (attribute.equals(ARCHIVE_NAME)) {
-            setArchive((Boolean)value);
-            return;
-        }
-        if (attribute.equals(SYSTEM_NAME)) {
-            setSystem((Boolean)value);
-            return;
-        }
-        if (attribute.equals(HIDDEN_NAME)) {
-            setHidden((Boolean)value);
-            return;
-        }
-        super.setAttribute(attribute, value);
-    }
-
-    @Override
-    public Map<String,?> readAttributes(String[] attributes)
-        throws IOException
-    {
-        AttributesBuilder builder = AttributesBuilder.create(attributes);
-        DosFileAttributes attrs = readAttributes();
-        addBasicAttributesToBuilder(attrs, builder);
-        if (builder.match(READONLY_NAME))
-            builder.add(READONLY_NAME, attrs.isReadOnly());
-        if (builder.match(ARCHIVE_NAME))
-            builder.add(ARCHIVE_NAME, attrs.isArchive());
-        if (builder.match(SYSTEM_NAME))
-            builder.add(SYSTEM_NAME, attrs.isSystem());
-        if (builder.match(HIDDEN_NAME))
-            builder.add(HIDDEN_NAME, attrs.isHidden());
-        return builder.unmodifiableMap();
-    }
-
-    @Override
-    public DosFileAttributes readAttributes() throws IOException {
-        file.checkRead();
-
-        int fd = file.openForAttributeAccess(followLinks);
-        try {
-             final UnixFileAttributes attrs = UnixFileAttributes.get(fd);
-             final int dosAttribute = getDosAttribute(fd);
-
-             return new DosFileAttributes() {
-                @Override
-                public FileTime lastModifiedTime() {
-                    return attrs.lastModifiedTime();
-                }
-                @Override
-                public FileTime lastAccessTime() {
-                    return attrs.lastAccessTime();
-                }
-                @Override
-                public FileTime creationTime() {
-                    return attrs.creationTime();
-                }
-                @Override
-                public boolean isRegularFile() {
-                    return attrs.isRegularFile();
-                }
-                @Override
-                public boolean isDirectory() {
-                    return attrs.isDirectory();
-                }
-                @Override
-                public boolean isSymbolicLink() {
-                    return attrs.isSymbolicLink();
-                }
-                @Override
-                public boolean isOther() {
-                    return attrs.isOther();
-                }
-                @Override
-                public long size() {
-                    return attrs.size();
-                }
-                @Override
-                public Object fileKey() {
-                    return attrs.fileKey();
-                }
-                @Override
-                public boolean isReadOnly() {
-                    return (dosAttribute & DOS_XATTR_READONLY) != 0;
-                }
-                @Override
-                public boolean isHidden() {
-                    return (dosAttribute & DOS_XATTR_HIDDEN) != 0;
-                }
-                @Override
-                public boolean isArchive() {
-                    return (dosAttribute & DOS_XATTR_ARCHIVE) != 0;
-                }
-                @Override
-                public boolean isSystem() {
-                    return (dosAttribute & DOS_XATTR_SYSTEM) != 0;
-                }
-             };
-
-        } catch (UnixException x) {
-            x.rethrowAsIOException(file);
-            return null;    // keep compiler happy
-        } finally {
-            close(fd);
-        }
-    }
-
-    @Override
-    public void setReadOnly(boolean value) throws IOException {
-        updateDosAttribute(DOS_XATTR_READONLY, value);
-    }
-
-    @Override
-    public void setHidden(boolean value) throws IOException {
-        updateDosAttribute(DOS_XATTR_HIDDEN, value);
-    }
-
-    @Override
-    public void setArchive(boolean value) throws IOException {
-        updateDosAttribute(DOS_XATTR_ARCHIVE, value);
-    }
-
-    @Override
-    public void setSystem(boolean value) throws IOException {
-        updateDosAttribute(DOS_XATTR_SYSTEM, value);
-    }
-
-    /**
-     * Reads the value of the user.DOSATTRIB extended attribute
-     */
-    private int getDosAttribute(int fd) throws UnixException {
-        final int size = 24;
-
-        NativeBuffer buffer = NativeBuffers.getNativeBuffer(size);
-        try {
-            int len = BsdNativeDispatcher
-                .fgetxattr(fd, DOS_XATTR_NAME_AS_BYTES, buffer.address(), size);
-
-            if (len > 0) {
-                // ignore null terminator
-                if (unsafe.getByte(buffer.address()+len-1) == 0)
-                    len--;
-
-                // convert to String and parse
-                byte[] buf = new byte[len];
-                unsafe.copyMemory(null, buffer.address(), buf,
-                    Unsafe.ARRAY_BYTE_BASE_OFFSET, len);
-                String value = new String(buf); // platform encoding
-
-                // should be something like 0x20
-                if (value.length() >= 3 && value.startsWith("0x")) {
-                    try {
-                        return Integer.parseInt(value.substring(2), 16);
-                    } catch (NumberFormatException x) {
-                        // ignore
-                    }
-                }
-            }
-            throw new UnixException("Value of " + DOS_XATTR_NAME + " attribute is invalid");
-        } catch (UnixException x) {
-            // default value when attribute does not exist
-            if (x.errno() == ENODATA)
-                return 0;
-            throw x;
-        } finally {
-            buffer.release();
-        }
-    }
-
-    /**
-     * Updates the value of the user.DOSATTRIB extended attribute
-     */
-    private void updateDosAttribute(int flag, boolean enable) throws IOException {
-        file.checkWrite();
-
-        int fd = file.openForAttributeAccess(followLinks);
-        try {
-            int oldValue = getDosAttribute(fd);
-            int newValue = oldValue;
-            if (enable) {
-                newValue |= flag;
-            } else {
-                newValue &= ~flag;
-            }
-            if (newValue != oldValue) {
-                byte[] value = ("0x" + Integer.toHexString(newValue)).getBytes();
-                NativeBuffer buffer = NativeBuffers.asNativeBuffer(value);
-                try {
-                    BsdNativeDispatcher.fsetxattr(fd, DOS_XATTR_NAME_AS_BYTES,
-                        buffer.address(), value.length+1);
-                } finally {
-                    buffer.release();
-                }
-            }
-        } catch (UnixException x) {
-            x.rethrowAsIOException(file);
-        } finally {
-            close(fd);
-        }
-    }
-}
--- ./jdk/src/solaris/classes/sun/nio/fs/BsdFileStore.java	2010-03-27 11:09:14.000000000 -0700
+++ ./jdk/src/solaris/classes/sun/nio/fs/BsdFileStore.java	2010-01-30 09:28:32.000000000 -0800
@@ -36,10 +36,6 @@
 class BsdFileStore
     extends UnixFileStore
 {
-    // used when checking if extended attributes are enabled or not
-    private volatile boolean xattrChecked;
-    private volatile boolean xattrEnabled;
-
     BsdFileStore(UnixPath file) throws IOException {
         super(file);
     }
@@ -54,7 +50,7 @@
      */
     @Override
     UnixMountEntry findMountEntry() throws IOException {
-        BsdFileSystem fs = (BsdFileSystem)file().getFileSystem();
+        UnixFileSystem fs = file().getFileSystem();
 
         // step 1: get realpath
         UnixPath path = null;
@@ -80,20 +76,20 @@
             parent = parent.getParent();
         }
 
-        // step 3: lookup mounted file systems (use /proc/mounts to ensure we
-        // find the file system even when not in /etc/mtab)
+        // step 3: lookup mounted file systems
         byte[] dir = path.asByteArray();
-        for (UnixMountEntry entry: fs.getMountEntries("/proc/mounts")) {
+        for (UnixMountEntry entry: fs.getMountEntries()) {
             if (Arrays.equals(dir, entry.dir()))
                 return entry;
         }
 
-        throw new IOException("Mount point not found");
+        throw new IOException("Mount point not found in fstab");
     }
 
     // returns true if extended attributes enabled on file system where given
     // file resides, returns false if disabled or unable to determine.
     private boolean isExtendedAttributesEnabled(UnixPath path) {
+/*
         try {
             int fd = path.openForAttributeAccess(false);
             try {
@@ -110,11 +106,13 @@
         } catch (IOException ignore) {
             // nothing we can do
         }
+*/
         return false;
     }
 
     @Override
     public boolean supportsFileAttributeView(Class<? extends FileAttributeView> type) {
+/*
         // support DosFileAttributeView and UserDefinedAttributeView if extended
         // attributes enabled
         if (type == DosFileAttributeView.class ||
@@ -145,15 +143,18 @@
             }
             return xattrEnabled;
         }
+*/
         return super.supportsFileAttributeView(type);
     }
 
     @Override
     public boolean supportsFileAttributeView(String name) {
+/*
         if (name.equals("dos"))
             return supportsFileAttributeView(DosFileAttributeView.class);
         if (name.equals("user"))
             return supportsFileAttributeView(UserDefinedFileAttributeView.class);
+*/
         return super.supportsFileAttributeView(name);
     }
 
--- ./jdk/src/solaris/classes/sun/nio/fs/BsdFileSystem.java	2010-03-27 11:09:14.000000000 -0700
+++ ./jdk/src/solaris/classes/sun/nio/fs/BsdFileSystem.java	2010-01-30 09:28:32.000000000 -0800
@@ -31,49 +31,23 @@
 import java.util.*;
 import java.security.AccessController;
 import sun.security.action.GetPropertyAction;
-import static sun.nio.fs.BsdNativeDispatcher.*;
 
 /**
  * Bsd implementation of FileSystem
  */
 
 class BsdFileSystem extends UnixFileSystem {
-    private final boolean hasInotify;
 
     BsdFileSystem(UnixFileSystemProvider provider, String dir) {
         super(provider, dir);
-
-        // assume X.Y[-Z] format
-        String osversion = AccessController
-            .doPrivileged(new GetPropertyAction("os.version"));
-        String[] vers = Util.split(osversion, '.');
-        assert vers.length >= 2;
-
-        int majorVersion = Integer.parseInt(vers[0]);
-        int minorVersion = Integer.parseInt(vers[1]);
-        int microVersion = 0;
-        if (vers.length > 2) {
-            String[] microVers = Util.split(vers[2], '-');
-            microVersion = (microVers.length > 0) ?
-                Integer.parseInt(microVers[0]) : 0;
-        }
-
-        // inotify available since 2.6.13
-        this.hasInotify = ((majorVersion > 2) ||
-            (majorVersion == 2 && minorVersion > 6) ||
-            ((majorVersion == 2) && (minorVersion == 6) && (microVersion >= 13)));
     }
 
     @Override
     public WatchService newWatchService()
         throws IOException
     {
-        if (hasInotify) {
-            return new BsdWatchService(this);
-        } else {
-            // use polling implementation on older kernels
-            return new PollingWatchService();
-        }
+        // use polling implementation until we implement a BSD/kqueue one
+        return new PollingWatchService();
     }
 
     @Override
@@ -82,10 +56,6 @@
                                                                 UnixPath file,
                                                                 LinkOption... options)
     {
-        if (view == DosFileAttributeView.class)
-            return (V) new BsdDosFileAttributeView(file, followLinks(options));
-        if (view == UserDefinedFileAttributeView.class)
-            return (V) new BsdUserDefinedFileAttributeView(file, followLinks(options));
         return super.newFileAttributeView(view, file, options);
     }
 
@@ -95,10 +65,6 @@
                                                          UnixPath file,
                                                          LinkOption... options)
     {
-        if (name.equals("dos"))
-            return new BsdDosFileAttributeView(file, followLinks(options));
-        if (name.equals("user"))
-            return new BsdUserDefinedFileAttributeView(file, followLinks(options));
         return super.newFileAttributeView(name, file, options);
     }
 
@@ -109,9 +75,6 @@
         private static Set<String> supportedFileAttributeViews() {
             Set<String> result = new HashSet<String>();
             result.addAll(UnixFileSystem.standardFileAttributeViews());
-            // additional Bsd-specific views
-            result.add("dos");
-            result.add("user");
             return Collections.unmodifiableSet(result);
         }
     }
@@ -123,26 +86,26 @@
 
     @Override
     void copyNonPosixAttributes(int ofd, int nfd) {
-        BsdUserDefinedFileAttributeView.copyExtendedAttributes(ofd, nfd);
     }
 
     /**
-     * Returns object to iterate over the mount entries in the given fstab file.
+     * Returns object to iterate over mount entries
      */
-    Iterable<UnixMountEntry> getMountEntries(String fstab) {
+    @Override
+    Iterable<UnixMountEntry> getMountEntries() {
         ArrayList<UnixMountEntry> entries = new ArrayList<UnixMountEntry>();
         try {
-            long fp = setmntent(fstab.getBytes(), "r".getBytes());
+            long iter = BsdNativeDispatcher.getfsstat();
             try {
                 for (;;) {
                     UnixMountEntry entry = new UnixMountEntry();
-                    int res = getextmntent(fp, entry);
+                    int res = BsdNativeDispatcher.fsstatEntry(iter, entry);
                     if (res < 0)
                         break;
                     entries.add(entry);
                 }
             } finally {
-                endmntent(fp);
+                BsdNativeDispatcher.endfsstat(iter);
             }
 
         } catch (UnixException x) {
@@ -151,14 +114,6 @@
         return entries;
     }
 
-    /**
-     * Returns object to iterate over the mount entries in /etc/mtab
-     */
-    @Override
-    Iterable<UnixMountEntry> getMountEntries() {
-        return getMountEntries("/etc/mtab");
-    }
-
     @Override
     FileStore getFileStore(UnixPath path) throws IOException {
         return new BsdFileStore(path);
--- ./jdk/src/solaris/classes/sun/nio/fs/BsdNativeDispatcher.java	2010-03-27 11:09:14.000000000 -0700
+++ ./jdk/src/solaris/classes/sun/nio/fs/BsdNativeDispatcher.java	2010-01-30 09:28:32.000000000 -0800
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * Copyright 2009 Sun Microsystems, Inc.  All Rights Reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -36,84 +36,23 @@
     private BsdNativeDispatcher() { }
 
    /**
-    * FILE *setmntent(const char *filename, const char *type);
+    * struct fsstat_iter *getfsstat();
     */
-    static long setmntent(byte[] filename, byte[] type) throws UnixException {
-        NativeBuffer pathBuffer = NativeBuffers.asNativeBuffer(filename);
-        NativeBuffer typeBuffer = NativeBuffers.asNativeBuffer(type);
-        try {
-            return setmntent0(pathBuffer.address(), typeBuffer.address());
-        } finally {
-            typeBuffer.release();
-            pathBuffer.release();
-        }
-    }
-    private static native long setmntent0(long pathAddress, long typeAddress)
-        throws UnixException;
+    static native long getfsstat() throws UnixException;
 
    /**
-    * int endmntent(FILE* filep);
+    * int fsstatEntry(struct fsstat_iter * iter, UnixMountEntry entry);
     */
-    static native void endmntent(long stream) throws UnixException;
-
-    /**
-     * ssize_t fgetxattr(int filedes, const char *name, void *value, size_t size);
-     */
-    static int fgetxattr(int filedes, byte[] name, long valueAddress,
-                         int valueLen) throws UnixException
-    {
-        NativeBuffer buffer = NativeBuffers.asNativeBuffer(name);
-        try {
-            return fgetxattr0(filedes, buffer.address(), valueAddress, valueLen);
-        } finally {
-            buffer.release();
-        }
-    }
-
-    private static native int fgetxattr0(int filedes, long nameAddress,
-        long valueAdddress, int valueLen) throws UnixException;
-
-    /**
-     *  fsetxattr(int filedes, const char *name, const void *value, size_t size, int flags);
-     */
-    static void fsetxattr(int filedes, byte[] name, long valueAddress,
-        int valueLen) throws UnixException
-    {
-        NativeBuffer buffer = NativeBuffers.asNativeBuffer(name);
-        try {
-            fsetxattr0(filedes, buffer.address(), valueAddress, valueLen);
-        } finally {
-            buffer.release();
-        }
-    }
-
-    private static native void fsetxattr0(int filedes, long nameAddress,
-        long valueAdddress, int valueLen) throws UnixException;
-
-
-    /**
-     * fremovexattr(int filedes, const char *name);
-     */
-    static void fremovexattr(int filedes, byte[] name) throws UnixException {
-        NativeBuffer buffer = NativeBuffers.asNativeBuffer(name);
-        try {
-            fremovexattr0(filedes, buffer.address());
-        } finally {
-            buffer.release();
-        }
-    }
-
-    private static native void fremovexattr0(int filedes, long nameAddress)
+    static native int fsstatEntry(long iter, UnixMountEntry entry)
         throws UnixException;
 
-    /**
-     * size_t flistxattr(int filedes, const char *list, size_t size)
-     */
-    static native int flistxattr(int filedes, long listAddress, int size)
-        throws UnixException;
+   /**
+    * void endfsstat(struct fsstat_iter * iter);
+    */
+    static native void endfsstat(long iter) throws UnixException;
 
-    // initialize
-    private static native void init();
+    // initialize field IDs
+    private static native void initIDs();
 
     static {
         AccessController.doPrivileged(new PrivilegedAction<Void>() {
@@ -121,6 +60,6 @@
                 System.loadLibrary("nio");
                 return null;
         }});
-        init();
+        initIDs();
     }
 }
--- ./jdk/src/solaris/classes/sun/nio/fs/BsdUserDefinedFileAttributeView.java	2010-03-27 11:09:14.000000000 -0700
+++ ./jdk/src/solaris/classes/sun/nio/fs/BsdUserDefinedFileAttributeView.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,350 +0,0 @@
-/*
- * Copyright 2008-2009 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-
-package sun.nio.fs;
-
-import java.nio.file.*;
-import java.nio.ByteBuffer;
-import java.io.IOException;
-import java.util.*;
-import sun.misc.Unsafe;
-
-import static sun.nio.fs.UnixConstants.*;
-import static sun.nio.fs.BsdNativeDispatcher.*;
-
-/**
- * Bsd implementation of UserDefinedFileAttributeView using extended attributes.
- */
-
-class BsdUserDefinedFileAttributeView
-    extends AbstractUserDefinedFileAttributeView
-{
-    private static final Unsafe unsafe = Unsafe.getUnsafe();
-
-    // namespace for extended user attributes
-    private static final String USER_NAMESPACE = "user.";
-
-    // maximum bytes in extended attribute name (includes namespace)
-    private static final int XATTR_NAME_MAX = 255;
-
-    private byte[] nameAsBytes(UnixPath file, String name) throws IOException {
-        if (name == null)
-            throw new NullPointerException("'name' is null");
-        name = USER_NAMESPACE + name;
-        byte[] bytes = name.getBytes();
-        if (bytes.length > XATTR_NAME_MAX) {
-            throw new FileSystemException(file.getPathForExecptionMessage(),
-                null, "'" + name + "' is too big");
-        }
-        return bytes;
-    }
-
-    // Parses buffer as array of NULL-terminated C strings.
-    private List<String> asList(long address, int size) {
-        final List<String> list = new ArrayList<String>();
-        int start = 0;
-        int pos = 0;
-        while (pos < size) {
-            if (unsafe.getByte(address + pos) == 0) {
-                int len = pos - start;
-                byte[] value = new byte[len];
-                unsafe.copyMemory(null, address+start, value,
-                    Unsafe.ARRAY_BYTE_BASE_OFFSET, len);
-                String s = new String(value);
-                if (s.startsWith(USER_NAMESPACE)) {
-                    s = s.substring(USER_NAMESPACE.length());
-                    list.add(s);
-                }
-                start = pos + 1;
-            }
-            pos++;
-        }
-        return list;
-    }
-
-    private final UnixPath file;
-    private final boolean followLinks;
-
-    BsdUserDefinedFileAttributeView(UnixPath file, boolean followLinks) {
-        this.file = file;
-        this.followLinks = followLinks;
-    }
-
-    @Override
-    public List<String> list() throws IOException  {
-        if (System.getSecurityManager() != null)
-            checkAccess(file.getPathForPermissionCheck(), true, false);
-
-        int fd = file.openForAttributeAccess(followLinks);
-        NativeBuffer buffer = null;
-        try {
-            int size = 1024;
-            buffer = NativeBuffers.getNativeBuffer(size);
-            for (;;) {
-                try {
-                    int n = flistxattr(fd, buffer.address(), size);
-                    List<String> list = asList(buffer.address(), n);
-                    return Collections.unmodifiableList(list);
-                } catch (UnixException x) {
-                    // allocate larger buffer if required
-                    if (x.errno() == ERANGE && size < 32*1024) {
-                        buffer.release();
-                        size *= 2;
-                        buffer = null;
-                        buffer = NativeBuffers.getNativeBuffer(size);
-                        continue;
-                    }
-                    throw new FileSystemException(file.getPathForExecptionMessage(),
-                        null, "Unable to get list of extended attributes: " +
-                        x.getMessage());
-                }
-            }
-        } finally {
-            if (buffer != null)
-                buffer.release();
-            close(fd);
-        }
-    }
-
-    @Override
-    public int size(String name) throws IOException  {
-        if (System.getSecurityManager() != null)
-            checkAccess(file.getPathForPermissionCheck(), true, false);
-
-        int fd = file.openForAttributeAccess(followLinks);
-        try {
-            // fgetxattr returns size if called with size==0
-            return fgetxattr(fd, nameAsBytes(file,name), 0L, 0);
-        } catch (UnixException x) {
-            throw new FileSystemException(file.getPathForExecptionMessage(),
-                null, "Unable to get size of extended attribute '" + name +
-                "': " + x.getMessage());
-        } finally {
-            close(fd);
-        }
-    }
-
-    @Override
-    public int read(String name, ByteBuffer dst) throws IOException {
-        if (System.getSecurityManager() != null)
-            checkAccess(file.getPathForPermissionCheck(), true, false);
-
-        if (dst.isReadOnly())
-            throw new IllegalArgumentException("Read-only buffer");
-        int pos = dst.position();
-        int lim = dst.limit();
-        assert (pos <= lim);
-        int rem = (pos <= lim ? lim - pos : 0);
-
-        NativeBuffer nb;
-        long address;
-        if (dst instanceof sun.nio.ch.DirectBuffer) {
-            nb = null;
-            address = ((sun.nio.ch.DirectBuffer)dst).address() + pos;
-        } else {
-            // substitute with native buffer
-            nb = NativeBuffers.getNativeBuffer(rem);
-            address = nb.address();
-        }
-
-        int fd = file.openForAttributeAccess(followLinks);
-        try {
-            try {
-                int n = fgetxattr(fd, nameAsBytes(file,name), address, rem);
-
-                // if remaining is zero then fgetxattr returns the size
-                if (rem == 0) {
-                    if (n > 0)
-                        throw new UnixException(ERANGE);
-                    return 0;
-                }
-
-                // copy from buffer into backing array if necessary
-                if (nb != null) {
-                    int off = dst.arrayOffset() + pos + Unsafe.ARRAY_BYTE_BASE_OFFSET;
-                    unsafe.copyMemory(null, address, dst.array(), off, n);
-                }
-                dst.position(pos + n);
-                return n;
-            } catch (UnixException x) {
-                String msg = (x.errno() == ERANGE) ?
-                    "Insufficient space in buffer" : x.getMessage();
-                throw new FileSystemException(file.getPathForExecptionMessage(),
-                    null, "Error reading extended attribute '" + name + "': " + msg);
-            } finally {
-                close(fd);
-            }
-        } finally {
-            if (nb != null)
-                nb.release();
-        }
-    }
-
-    @Override
-    public int write(String name, ByteBuffer src) throws IOException {
-        if (System.getSecurityManager() != null)
-            checkAccess(file.getPathForPermissionCheck(), false, true);
-
-        int pos = src.position();
-        int lim = src.limit();
-        assert (pos <= lim);
-        int rem = (pos <= lim ? lim - pos : 0);
-
-        NativeBuffer nb;
-        long address;
-        if (src instanceof sun.nio.ch.DirectBuffer) {
-            nb = null;
-            address = ((sun.nio.ch.DirectBuffer)src).address() + pos;
-        } else {
-            // substitute with native buffer
-            nb = NativeBuffers.getNativeBuffer(rem);
-            address = nb.address();
-
-            if (src.hasArray()) {
-                // copy from backing array into buffer
-                int off = src.arrayOffset() + pos + Unsafe.ARRAY_BYTE_BASE_OFFSET;
-                unsafe.copyMemory(src.array(), off, null, address, rem);
-            } else {
-                // backing array not accessible so transfer via temporary array
-                byte[] tmp = new byte[rem];
-                src.get(tmp);
-                src.position(pos);  // reset position as write may fail
-                unsafe.copyMemory(tmp, Unsafe.ARRAY_BYTE_BASE_OFFSET, null,
-                    address, rem);
-            }
-        }
-
-        int fd = file.openForAttributeAccess(followLinks);
-        try {
-            try {
-                fsetxattr(fd, nameAsBytes(file,name), address, rem);
-                src.position(pos + rem);
-                return rem;
-            } catch (UnixException x) {
-                throw new FileSystemException(file.getPathForExecptionMessage(),
-                    null, "Error writing extended attribute '" + name + "': " +
-                    x.getMessage());
-            } finally {
-                close(fd);
-            }
-        } finally {
-            if (nb != null)
-                nb.release();
-        }
-    }
-
-    @Override
-    public void delete(String name) throws IOException {
-        if (System.getSecurityManager() != null)
-            checkAccess(file.getPathForPermissionCheck(), false, true);
-
-        int fd = file.openForAttributeAccess(followLinks);
-        try {
-            fremovexattr(fd, nameAsBytes(file,name));
-        } catch (UnixException x) {
-            throw new FileSystemException(file.getPathForExecptionMessage(),
-                null, "Unable to delete extended attribute '" + name + "': " + x.getMessage());
-        } finally {
-            close(fd);
-        }
-    }
-
-    /**
-     * Used by copyTo/moveTo to copy extended attributes from source to target.
-     *
-     * @param   ofd
-     *          file descriptor for source file
-     * @param   nfd
-     *          file descriptor for target file
-     */
-    static void copyExtendedAttributes(int ofd, int nfd) {
-        NativeBuffer buffer = null;
-        try {
-
-            // call flistxattr to get list of extended attributes.
-            int size = 1024;
-            buffer = NativeBuffers.getNativeBuffer(size);
-            for (;;) {
-                try {
-                    size = flistxattr(ofd, buffer.address(), size);
-                    break;
-                } catch (UnixException x) {
-                    // allocate larger buffer if required
-                    if (x.errno() == ERANGE && size < 32*1024) {
-                        buffer.release();
-                        size *= 2;
-                        buffer = null;
-                        buffer = NativeBuffers.getNativeBuffer(size);
-                        continue;
-                    }
-
-                    // unable to get list of attributes
-                    return;
-                }
-            }
-
-            // parse buffer as array of NULL-terminated C strings.
-            long address = buffer.address();
-            int start = 0;
-            int pos = 0;
-            while (pos < size) {
-                if (unsafe.getByte(address + pos) == 0) {
-                    // extract attribute name and copy attribute to target.
-                    // FIXME: We can avoid needless copying by using address+pos
-                    // as the address of the name.
-                    int len = pos - start;
-                    byte[] name = new byte[len];
-                    unsafe.copyMemory(null, address+start, name,
-                        Unsafe.ARRAY_BYTE_BASE_OFFSET, len);
-                    try {
-                        copyExtendedAttribute(ofd, name, nfd);
-                    } catch (UnixException ignore) {
-                        // ignore
-                    }
-                    start = pos + 1;
-                }
-                pos++;
-            }
-
-        } finally {
-            if (buffer != null)
-                buffer.release();
-        }
-    }
-
-    private static void copyExtendedAttribute(int ofd, byte[] name, int nfd)
-        throws UnixException
-    {
-        int size = fgetxattr(ofd, name, 0L, 0);
-        NativeBuffer buffer = NativeBuffers.getNativeBuffer(size);
-        try {
-            long address = buffer.address();
-            size = fgetxattr(ofd, name, address, size);
-            fsetxattr(nfd, name, address, size);
-        } finally {
-            buffer.release();
-        }
-    }
-}
--- ./jdk/src/solaris/classes/sun/nio/fs/BsdWatchService.java	2010-03-27 11:09:14.000000000 -0700
+++ ./jdk/src/solaris/classes/sun/nio/fs/BsdWatchService.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,466 +0,0 @@
-/*
- * Copyright 2008-2009 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-
-package sun.nio.fs;
-
-import java.nio.file.*;
-import java.security.AccessController;
-import java.security.PrivilegedAction;
-import java.util.*;
-import java.io.IOException;
-import sun.misc.Unsafe;
-
-import static sun.nio.fs.UnixNativeDispatcher.*;
-import static sun.nio.fs.UnixConstants.*;
-
-/**
- * Bsd implementation of WatchService based on inotify.
- *
- * In summary a background thread polls inotify plus a socket used for the wakeup
- * mechanism. Requests to add or remove a watch, or close the watch service,
- * cause the thread to wakeup and process the request. Events are processed
- * by the thread which causes it to signal/queue the corresponding watch keys.
- */
-
-class BsdWatchService
-    extends AbstractWatchService
-{
-    private static final Unsafe unsafe = Unsafe.getUnsafe();
-
-    // background thread to read change events
-    private final Poller poller;
-
-    BsdWatchService(UnixFileSystem fs) throws IOException {
-        // initialize inotify
-        int ifd = - 1;
-        try {
-            ifd = inotifyInit();
-        } catch (UnixException x) {
-            throw new IOException(x.errorString());
-        }
-
-        // configure inotify to be non-blocking
-        // create socketpair used in the close mechanism
-        int sp[] = new int[2];
-        try {
-            configureBlocking(ifd, false);
-            socketpair(sp);
-            configureBlocking(sp[0], false);
-        } catch (UnixException x) {
-            UnixNativeDispatcher.close(ifd);
-            throw new IOException(x.errorString());
-        }
-
-        this.poller = new Poller(fs, this, ifd, sp);
-        this.poller.start();
-    }
-
-    @Override
-    WatchKey register(Path dir,
-                      WatchEvent.Kind<?>[] events,
-                      WatchEvent.Modifier... modifiers)
-         throws IOException
-    {
-        // delegate to poller
-        return poller.register(dir, events, modifiers);
-    }
-
-    @Override
-    void implClose() throws IOException {
-        // delegate to poller
-        poller.close();
-    }
-
-    /**
-     * WatchKey implementation
-     */
-    private static class BsdWatchKey extends AbstractWatchKey {
-        // inotify descriptor
-        private final int ifd;
-        // watch descriptor
-        private volatile int wd;
-
-        BsdWatchKey(BsdWatchService watcher, int ifd, int wd) {
-            super(watcher);
-            this.ifd = ifd;
-            this.wd = wd;
-        }
-
-        int descriptor() {
-            return wd;
-        }
-
-        void invalidate(boolean remove) {
-            if (remove) {
-                try {
-                    inotifyRmWatch(ifd, wd);
-                } catch (UnixException x) {
-                    // ignore
-                }
-            }
-            wd = -1;
-        }
-
-        @Override
-        public boolean isValid() {
-            return (wd != -1);
-        }
-
-        @Override
-        public void cancel() {
-            if (isValid()) {
-                // delegate to poller
-                ((BsdWatchService)watcher()).poller.cancel(this);
-            }
-        }
-    }
-
-    /**
-     * Background thread to read from inotify
-     */
-    private static class Poller extends AbstractPoller {
-        /**
-         * struct inotify_event {
-         *     int          wd;
-         *     uint32_t     mask;
-         *     uint32_t     len;
-         *     char name    __flexarr;  // present if len > 0
-         * } act_t;
-         */
-        private static final int SIZEOF_INOTIFY_EVENT  = eventSize();
-        private static final int[] offsets             = eventOffsets();
-        private static final int OFFSETOF_WD           = offsets[0];
-        private static final int OFFSETOF_MASK         = offsets[1];
-        private static final int OFFSETOF_LEN          = offsets[3];
-        private static final int OFFSETOF_NAME         = offsets[4];
-
-        private static final int IN_MODIFY          = 0x00000002;
-        private static final int IN_ATTRIB          = 0x00000004;
-        private static final int IN_MOVED_FROM      = 0x00000040;
-        private static final int IN_MOVED_TO        = 0x00000080;
-        private static final int IN_CREATE          = 0x00000100;
-        private static final int IN_DELETE          = 0x00000200;
-
-        private static final int IN_UNMOUNT         = 0x00002000;
-        private static final int IN_Q_OVERFLOW      = 0x00004000;
-        private static final int IN_IGNORED         = 0x00008000;
-
-        // sizeof buffer for when polling inotify
-        private static final int BUFFER_SIZE = 8192;
-
-        private final UnixFileSystem fs;
-        private final BsdWatchService watcher;
-
-        // inotify file descriptor
-        private final int ifd;
-        // socketpair used to shutdown polling thread
-        private final int socketpair[];
-        // maps watch descriptor to Key
-        private final Map<Integer,BsdWatchKey> wdToKey;
-        // address of read buffer
-        private final long address;
-
-        Poller(UnixFileSystem fs, BsdWatchService watcher, int ifd, int[] sp) {
-            this.fs = fs;
-            this.watcher = watcher;
-            this.ifd = ifd;
-            this.socketpair = sp;
-            this.wdToKey = new HashMap<Integer,BsdWatchKey>();
-            this.address = unsafe.allocateMemory(BUFFER_SIZE);
-        }
-
-        @Override
-        void wakeup() throws IOException {
-            // write to socketpair to wakeup polling thread
-            try {
-                write(socketpair[1], address, 1);
-            } catch (UnixException x) {
-                throw new IOException(x.errorString());
-            }
-        }
-
-        @Override
-        Object implRegister(Path obj,
-                            Set<? extends WatchEvent.Kind<?>> events,
-                            WatchEvent.Modifier... modifiers)
-        {
-            UnixPath dir = (UnixPath)obj;
-
-            int mask = 0;
-            for (WatchEvent.Kind<?> event: events) {
-                if (event == StandardWatchEventKind.ENTRY_CREATE) {
-                    mask |= IN_CREATE | IN_MOVED_TO;
-                    continue;
-                }
-                if (event == StandardWatchEventKind.ENTRY_DELETE) {
-                    mask |= IN_DELETE | IN_MOVED_FROM;
-                    continue;
-                }
-                if (event == StandardWatchEventKind.ENTRY_MODIFY) {
-                    mask |= IN_MODIFY | IN_ATTRIB;
-                    continue;
-                }
-            }
-
-            // no modifiers supported at this time
-            if (modifiers.length > 0) {
-                for (WatchEvent.Modifier modifier: modifiers) {
-                    if (modifier == null)
-                        return new NullPointerException();
-                    if (modifier instanceof com.sun.nio.file.SensitivityWatchEventModifier)
-                        continue; // ignore
-                    return new UnsupportedOperationException("Modifier not supported");
-                }
-            }
-
-            // check file is directory
-            UnixFileAttributes attrs = null;
-            try {
-                attrs = UnixFileAttributes.get(dir, true);
-            } catch (UnixException x) {
-                return x.asIOException(dir);
-            }
-            if (!attrs.isDirectory()) {
-                return new NotDirectoryException(dir.getPathForExecptionMessage());
-            }
-
-            // register with inotify (replaces existing mask if already registered)
-            int wd = -1;
-            try {
-                NativeBuffer buffer =
-                    NativeBuffers.asNativeBuffer(dir.getByteArrayForSysCalls());
-                try {
-                    wd = inotifyAddWatch(ifd, buffer.address(), mask);
-                } finally {
-                    buffer.release();
-                }
-            } catch (UnixException x) {
-                if (x.errno() == ENOSPC) {
-                    return new IOException("User limit of inotify watches reached");
-                }
-                return x.asIOException(dir);
-            }
-
-            // ensure watch descriptor is in map
-            BsdWatchKey key = wdToKey.get(wd);
-            if (key == null) {
-                key = new BsdWatchKey(watcher, ifd, wd);
-                wdToKey.put(wd, key);
-            }
-            return key;
-        }
-
-        // cancel single key
-        @Override
-        void implCancelKey(WatchKey obj) {
-            BsdWatchKey key = (BsdWatchKey)obj;
-            if (key.isValid()) {
-                wdToKey.remove(key.descriptor());
-                key.invalidate(true);
-            }
-        }
-
-        // close watch service
-        @Override
-        void implCloseAll() {
-            // invalidate all keys
-            for (Map.Entry<Integer,BsdWatchKey> entry: wdToKey.entrySet()) {
-                entry.getValue().invalidate(true);
-            }
-            wdToKey.clear();
-
-            // free resources
-            unsafe.freeMemory(address);
-            UnixNativeDispatcher.close(socketpair[0]);
-            UnixNativeDispatcher.close(socketpair[1]);
-            UnixNativeDispatcher.close(ifd);
-        }
-
-        /**
-         * Poller main loop
-         */
-        @Override
-        public void run() {
-            try {
-                for (;;) {
-                    int nReady, bytesRead;
-
-                    // wait for close or inotify event
-                    nReady = poll(ifd, socketpair[0]);
-
-                    // read from inotify
-                    try {
-                        bytesRead = read(ifd, address, BUFFER_SIZE);
-                    } catch (UnixException x) {
-                        if (x.errno() != EAGAIN)
-                            throw x;
-                        bytesRead = 0;
-                    }
-
-                    // process any pending requests
-                    if ((nReady > 1) || (nReady == 1 && bytesRead == 0)) {
-                        try {
-                            read(socketpair[0], address, BUFFER_SIZE);
-                            boolean shutdown = processRequests();
-                            if (shutdown)
-                                break;
-                        } catch (UnixException x) {
-                            if (x.errno() != UnixConstants.EAGAIN)
-                                throw x;
-                        }
-                    }
-
-                    // iterate over buffer to decode events
-                    int offset = 0;
-                    while (offset < bytesRead) {
-                        long event = address + offset;
-                        int wd = unsafe.getInt(event + OFFSETOF_WD);
-                        int mask = unsafe.getInt(event + OFFSETOF_MASK);
-                        int len = unsafe.getInt(event + OFFSETOF_LEN);
-
-                        // file name
-                        UnixPath name = null;
-                        if (len > 0) {
-                            int actual = len;
-
-                            // null-terminated and maybe additional null bytes to
-                            // align the next event
-                            while (actual > 0) {
-                                long last = event + OFFSETOF_NAME + actual - 1;
-                                if (unsafe.getByte(last) != 0)
-                                    break;
-                                actual--;
-                            }
-                            if (actual > 0) {
-                                byte[] buf = new byte[actual];
-                                unsafe.copyMemory(null, event + OFFSETOF_NAME,
-                                    buf, Unsafe.ARRAY_BYTE_BASE_OFFSET, actual);
-                                name = new UnixPath(fs, buf);
-                            }
-                        }
-
-                        // process event
-                        processEvent(wd, mask, name);
-
-                        offset += (SIZEOF_INOTIFY_EVENT + len);
-                    }
-                }
-            } catch (UnixException x) {
-                x.printStackTrace();
-            }
-        }
-
-
-        /**
-         * map inotify event to WatchEvent.Kind
-         */
-        private WatchEvent.Kind<?> maskToEventKind(int mask) {
-            if ((mask & IN_MODIFY) > 0)
-                return StandardWatchEventKind.ENTRY_MODIFY;
-            if ((mask & IN_ATTRIB) > 0)
-                return StandardWatchEventKind.ENTRY_MODIFY;
-            if ((mask & IN_CREATE) > 0)
-                return StandardWatchEventKind.ENTRY_CREATE;
-            if ((mask & IN_MOVED_TO) > 0)
-                return StandardWatchEventKind.ENTRY_CREATE;
-            if ((mask & IN_DELETE) > 0)
-                return StandardWatchEventKind.ENTRY_DELETE;
-            if ((mask & IN_MOVED_FROM) > 0)
-                return StandardWatchEventKind.ENTRY_DELETE;
-            return null;
-        }
-
-        /**
-         * Process event from inotify
-         */
-        private void processEvent(int wd, int mask, final UnixPath name) {
-            // overflow - signal all keys
-            if ((mask & IN_Q_OVERFLOW) > 0) {
-                for (Map.Entry<Integer,BsdWatchKey> entry: wdToKey.entrySet()) {
-                    entry.getValue()
-                        .signalEvent(StandardWatchEventKind.OVERFLOW, null);
-                }
-                return;
-            }
-
-            // lookup wd to get key
-            BsdWatchKey key = wdToKey.get(wd);
-            if (key == null)
-                return; // should not happen
-
-            // file deleted
-            if ((mask & IN_IGNORED) > 0) {
-                wdToKey.remove(wd);
-                key.invalidate(false);
-                key.signal();
-                return;
-            }
-
-            // event for directory itself
-            if (name == null)
-                return;
-
-            // map to event and queue to key
-            WatchEvent.Kind<?> kind = maskToEventKind(mask);
-            if (kind != null) {
-                key.signalEvent(kind, name);
-            }
-        }
-    }
-
-    // -- native methods --
-
-    private static native void init();
-
-    // sizeof inotify_event
-    private static native int eventSize();
-
-    // offsets of inotify_event
-    private static native int[] eventOffsets();
-
-    private static native int inotifyInit() throws UnixException;
-
-    private static native int inotifyAddWatch(int fd, long pathAddress, int mask)
-        throws UnixException;
-
-    private static native void inotifyRmWatch(int fd, int wd)
-        throws UnixException;
-
-    private static native void configureBlocking(int fd, boolean blocking)
-        throws UnixException;
-
-    private static native void socketpair(int[] sv) throws UnixException;
-
-    private static native int poll(int fd1, int fd2) throws UnixException;
-
-    static {
-        AccessController.doPrivileged(new PrivilegedAction<Void>() {
-            public Void run() {
-                System.loadLibrary("nio");
-                return null;
-        }});
-        init();
-    }
-}
--- ./jdk/src/solaris/classes/sun/nio/fs/DefaultFileSystemProvider.java	2010-03-18 01:45:34.000000000 -0700
+++ ./jdk/src/solaris/classes/sun/nio/fs/DefaultFileSystemProvider.java	2010-01-30 09:28:32.000000000 -0800
@@ -68,6 +68,8 @@
             return createProvider("sun.nio.fs.SolarisFileSystemProvider");
         if (osname.equals("Linux"))
             return createProvider("sun.nio.fs.LinuxFileSystemProvider");
+        if (osname.endsWith("BSD") || osname.equals("Darwin"))
+            return createProvider("sun.nio.fs.BsdFileSystemProvider");
         throw new AssertionError("Platform not recognized");
     }
 }
--- ./jdk/src/solaris/classes/sun/print/UnixPrintServiceLookup.java	2010-03-18 01:45:34.000000000 -0700
+++ ./jdk/src/solaris/classes/sun/print/UnixPrintServiceLookup.java	2010-01-30 09:28:32.000000000 -0800
@@ -119,7 +119,11 @@
     }
 
     static boolean isBSD() {
-        return osname.equals("Linux");
+	return (osname.equals("Linux") ||
+		osname.equals("FreeBSD") ||
+		osname.equals("Darwin") ||
+		osname.equals("NetBSD") ||
+		osname.equals("OpenBSD"));
     }
 
     static final int UNINITIALIZED = -1;
@@ -134,8 +138,8 @@
     };
 
     String[] lpcAllCom = {
-        "/usr/sbin/lpc status | grep : | sed -e 's/://'",
-        "/usr/sbin/lpc -a status | grep -E '^[ 0-9a-zA-Z_-]*@' | awk -F'@' '{print $1}' | sort"
+        "/usr/sbin/lpc status all | grep : | sed -e 's/://'",
+        "/usr/sbin/lpc status all | grep -E '^[ 0-9a-zA-Z_-]*@' | awk -F'@' '{print $1}' | sort"
     };
 
     String[] lpcNameCom = {
@@ -145,7 +149,7 @@
 
 
     static int getBSDCommandIndex() {
-        String command  = "/usr/sbin/lpc status";
+        String command  = "/usr/sbin/lpc status all";
         String[] names = execCmd(command);
 
         if ((names == null) || (names.length == 0)) {
--- ./jdk/src/solaris/classes/sun/tools/attach/BsdVirtualMachine.java	2010-03-27 11:09:14.000000000 -0700
+++ ./jdk/src/solaris/classes/sun/tools/attach/BsdVirtualMachine.java	2010-01-30 09:28:32.000000000 -0800
@@ -38,9 +38,6 @@
  */
 public class BsdVirtualMachine extends HotSpotVirtualMachine {
 
-    // Indicates if this machine uses the old BsdThreads
-    static boolean isBsdThreads;
-
     // The patch to the socket file created by the target VM
     String path;
 
@@ -65,25 +62,10 @@
         // Then we attempt to find the socket file again.
         path = findSocketFile(pid);
         if (path == null) {
-            File f = createAttachFile(pid);
+            File f = new File("/tmp/.attach_pid" + pid);
+	    createAttachFile(f.getPath());
             try {
-                // On BsdThreads each thread is a process and we don't have the
-                // pid of the VMThread which has SIGQUIT unblocked. To workaround
-                // this we get the pid of the "manager thread" that is created
-                // by the first call to pthread_create. This is parent of all
-                // threads (except the initial thread).
-                if (isBsdThreads) {
-                    int mpid;
-                    try {
-                        mpid = getBsdThreadsManager(pid);
-                    } catch (IOException x) {
-                        throw new AttachNotSupportedException(x.getMessage());
-                    }
-                    assert(mpid >= 1);
-                    sendQuitToChildrenOf(mpid);
-                } else {
-                    sendQuitTo(pid);
-                }
+                sendQuitTo(pid);
 
                 // give the target VM time to start the attach mechanism
                 int i = 0;
@@ -265,37 +247,14 @@
         // First check for a .java_pid<pid> file in the working directory
         // of the target process
         String fn = ".java_pid" + pid;
-        String path = "/proc/" + pid + "/cwd/" + fn;
+        String path = "/tmp/" + fn;
         File f = new File(path);
         if (!f.exists()) {
-            // Not found, so try /tmp
-            path = "/tmp/" + fn;
-            f = new File(path);
-            if (!f.exists()) {
-                return null;            // not found
-            }
+            return null;            // not found
         }
         return path;
     }
 
-    // On Solaris/Bsd a simple handshake is used to start the attach mechanism
-    // if not already started. The client creates a .attach_pid<pid> file in the
-    // target VM's working directory (or /tmp), and the SIGQUIT handler checks
-    // for the file.
-    private File createAttachFile(int pid) throws IOException {
-        String fn = ".attach_pid" + pid;
-        String path = "/proc/" + pid + "/cwd/" + fn;
-        File f = new File(path);
-        try {
-            f.createNewFile();
-        } catch (IOException x) {
-            path = "/tmp/" + fn;
-            f = new File(path);
-            f.createNewFile();
-        }
-        return f;
-    }
-
     /*
      * Write/sends the given to the target VM. String is transmitted in
      * UTF-8 encoding.
@@ -318,12 +277,6 @@
 
     //-- native methods
 
-    static native boolean isBsdThreads();
-
-    static native int getBsdThreadsManager(int pid) throws IOException;
-
-    static native void sendQuitToChildrenOf(int pid) throws IOException;
-
     static native void sendQuitTo(int pid) throws IOException;
 
     static native void checkPermissions(String path) throws IOException;
@@ -338,8 +291,9 @@
 
     static native void write(int fd, byte buf[], int off, int bufLen) throws IOException;
 
+    static native void createAttachFile(String path);
+
     static {
         System.loadLibrary("attach");
-        isBsdThreads = isBsdThreads();
     }
 }
--- ./jdk/src/solaris/demo/jvmti/hprof/hprof_md.c	2010-03-18 01:45:34.000000000 -0700
+++ ./jdk/src/solaris/demo/jvmti/hprof/hprof_md.c	2010-01-30 09:28:32.000000000 -0800
@@ -33,7 +33,7 @@
 #include <sys/stat.h>
 #include <fcntl.h>
 
-#ifndef LINUX
+#if !defined(LINUX) && !defined(_ALLBSD_SOURCE)
 #include <procfs.h>
 #endif
 
@@ -53,6 +53,7 @@
 #include <time.h>
 
 #include "jni.h"
+#include "jvm_md.h"
 #include "hprof.h"
 
 int
@@ -76,7 +77,7 @@
 void
 md_init(void)
 {
-#ifdef LINUX
+#if defined(LINUX) || defined(_ALLBSD_SOURCE)
     /* No Hi-Res timer option? */
 #else
     if ( gdata->micro_state_accounting ) {
@@ -238,7 +239,7 @@
 jlong
 md_get_microsecs(void)
 {
-#ifdef LINUX
+#if defined(LINUX) || defined(_ALLBSD_SOURCE)
     return (jlong)(md_timeofday() * (jlong)1000); /* Milli to micro */
 #else
     return (jlong)(gethrtime()/(hrtime_t)1000); /* Nano seconds to micro seconds */
@@ -256,7 +257,7 @@
 jlong
 md_get_thread_cpu_timemillis(void)
 {
-#ifdef LINUX
+#if defined(LINUX) || defined(_ALLBSD_SOURCE)
     return md_timeofday();
 #else
     return (jlong)(gethrvtime()/1000); /* Nano seconds to milli seconds */
@@ -271,7 +272,7 @@
     Dl_info dlinfo;
 
     libdir[0] = 0;
-#ifdef LINUX
+#if defined(LINUX) || defined(_ALLBSD_SOURCE)
     addr = (void*)&Agent_OnLoad;
 #else
     /* Just using &Agent_OnLoad will get the first external symbol with
@@ -379,9 +380,9 @@
 
     /* Construct path to library */
     if (pnamelen == 0) {
-        (void)snprintf(holder, holderlen, "lib%s.so", fname);
+        (void)snprintf(holder, holderlen, "lib%s" JNI_LIB_SUFFIX, fname);
     } else {
-        (void)snprintf(holder, holderlen, "%s/lib%s.so", pname, fname);
+        (void)snprintf(holder, holderlen, "%s/lib%s" JNI_LIB_SUFFIX, pname, fname);
     }
 }
 
--- ./jdk/src/solaris/hpi/include/interrupt.h	2010-03-18 01:45:35.000000000 -0700
+++ ./jdk/src/solaris/hpi/include/interrupt.h	2010-01-30 09:28:33.000000000 -0800
@@ -75,7 +75,7 @@
  *      N_INTERRUPTS  - The number of interrupt channels.  These
  *                      are numbered from 0 to (N_INTERRUPTS - 1).
  */
-#ifdef __linux__
+#if defined(__linux__) || defined(__FreeBSD__)
 #define       N_INTERRUPTS    NSIG    /* 0 to NSIG - 1*/
 #else
 #define N_INTERRUPTS    32      /* 0 to 31 */
@@ -111,6 +111,10 @@
 #error signal.h has not been included?
 #endif
 
+#if defined(__FreeBSD__) && !defined(SA_SIGINFO)
+#error signal.h has not been included?
+#endif
+
 #ifdef SA_SIGINFO
 /* Thread implementation dependent interrupt dispatcher. */
 void intrDispatchMD(int sig, siginfo_t *info, void *uc);
--- ./jdk/src/solaris/hpi/include/largefile.h	2010-03-18 01:45:35.000000000 -0700
+++ ./jdk/src/solaris/hpi/include/largefile.h	2010-01-30 09:28:33.000000000 -0800
@@ -34,6 +34,10 @@
 #include "largefile_linux.h"
 #endif
 
+#ifdef _ALLBSD_SOURCE
+#include "largefile_bsd.h"
+#endif
+
 /*
  * Prototypes for wrappers that we define.  These wrapper functions
  * are low-level I/O routines that will use 64 bit versions if
--- ./jdk/src/solaris/hpi/include/largefile_bsd.h	2010-03-27 11:09:14.000000000 -0700
+++ ./jdk/src/solaris/hpi/include/largefile_bsd.h	2010-01-30 09:28:33.000000000 -0800
@@ -26,11 +26,29 @@
 #ifndef _JAVASOFT_BSD_LARGEFILE_SUPPORT_H_
 #define _JAVASOFT_BSD_LARGEFILE_SUPPORT_H_
 
-/*
- * For building on glibc-2.0 we need to define stat64 here.
- */
-
 #include <sys/types.h>
 #include <sys/stat.h>
 
+/* define compatibility macros */
+#define                off64_t         off_t
+#define                stat64          stat
+#define                dirent64        dirent
+#define                statvfs64       statvfs
+
+#define                F_SETLK64       F_SETLK
+#define                F_SETLKW64      F_SETLKW
+
+#define                lseek64         lseek
+#define                ftruncate64     ftruncate
+#define                open64          open
+#define                fstat64         fstat
+#define                flock64         flock
+#define                mmap64          mmap
+#define                fdatasync       fsync
+#define                lstat64         lstat
+#define                readdir64_r     readdir_r
+
+#define                pread64         pread
+#define                pwrite64        pwrite
+
 #endif /* _JAVASOFT_BSD_LARGEFILE_SUPPORT_H_ */
--- ./jdk/src/solaris/hpi/native_threads/include/threads_md.h	2010-03-18 01:45:35.000000000 -0700
+++ ./jdk/src/solaris/hpi/native_threads/include/threads_md.h	2010-01-30 09:28:33.000000000 -0800
@@ -36,6 +36,8 @@
 #define N_TRACED_REGS 12
 #elif i386
 #define N_TRACED_REGS 7
+#elif i586			/* BSDNOTE: just in case */
+#define N_TRACED_REGS 7
 #elif amd64
 #define N_TRACED_REGS 15
 #elif ppc
@@ -51,10 +53,12 @@
 #define N_TRACED_REGS 32
 #endif
 
+#if !defined(_ALLBSD_SOURCE)
 /* Turn on if we want all java threads to be bound tolwps */
 /* #define BOUND_THREADS */
 /* Use /proc soln to stop lwps in place of siglwp soln */
 #define PROCLWP
+#endif
 
 /*
  * Thread C stack overflow check
@@ -132,7 +136,7 @@
     lwpid_t lwpid;
 #endif
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     void *sp;
 #else
     unsigned long  sp;   /* sp at time of last (native) thread switch */
@@ -186,12 +190,14 @@
 
 #define SYS_THREAD_NULL         ((sys_thread_t *) 0)
 
+#if !defined(_ALLBSD_SOURCE)
 /*
  * following macro copied from sys/signal.h since inside #ifdef _KERNEL there.
  */
 #ifndef sigmask
 #define sigmask(n)      ((unsigned int)1 << (((n) - 1) & (32 - 1)))
 #endif
+#endif
 
 #ifdef __linux__
 extern thread_key_t intrJmpbufkey;
--- ./jdk/src/solaris/hpi/native_threads/src/condvar_md.c	2010-03-18 01:45:35.000000000 -0700
+++ ./jdk/src/solaris/hpi/native_threads/src/condvar_md.c	2010-01-30 09:28:33.000000000 -0800
@@ -58,7 +58,7 @@
 {
     int err;
 
-#ifdef __linux__
+#ifdef USE_PTHREADS
     err = pthread_cond_destroy((cond_t *) &condvar->cond);
 #else
     err = cond_destroy((cond_t *) condvar);
--- ./jdk/src/solaris/hpi/native_threads/src/monitor_md.c	2010-03-18 01:45:35.000000000 -0700
+++ ./jdk/src/solaris/hpi/native_threads/src/monitor_md.c	2010-01-30 09:28:33.000000000 -0800
@@ -147,7 +147,7 @@
         mid->monitor_owner = self;
         mid->entry_count = 1;
         return SYS_OK;
-    } else if (err == EBUSY) { /* it's already locked */
+    } else if (err == EBUSY || err == EDEADLK) { /* it's already locked */
         if (mid->monitor_owner == self) {
             mid->entry_count++;
             return SYS_OK;
--- ./jdk/src/solaris/hpi/native_threads/src/threads_bsd.c	2010-03-27 11:09:14.000000000 -0700
+++ ./jdk/src/solaris/hpi/native_threads/src/threads_bsd.c	2010-01-30 09:28:33.000000000 -0800
@@ -1,5 +1,5 @@
 /*
- * Copyright 1999-2000 Sun Microsystems, Inc.  All Rights Reserved.
+ * Copyright 1998-2004 Sun Microsystems, Inc.  All Rights Reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -23,389 +23,381 @@
  * have any questions.
  */
 
-/*
- * Implementation of notposix.h on Bsd.
- */
+#ifdef __APPLE__
 
-#include <pthread.h>
-#include <signal.h>
-#include <string.h>
-#include <unistd.h>
-#include <stdlib.h>
-#include <fcntl.h>
-#include <time.h>
+/* We need the mach API, which must be be included before any other system includes.
+ * Additionally, java and mach both define thread_state_t, so temporarily redefine it. */
+#define thread_state_t mach_thread_state_t
+#include <mach/mach.h>
+#undef thread_state_t
+
+#endif
 
 #include "hpi_impl.h"
 #include "monitor_md.h"
 #include "threads_md.h"
 #include "np.h"
 
-#undef LOG_THREADS
+#include <sys/types.h>
+#include <sys/sysctl.h>
 
-/* Global lock used when calling np_suspend and np_resume */
-static pthread_mutex_t sr_lock;
-
-/* Semaphore used to acknowledge when the handler has received HANDLER_SIG */
-static sem_t sr_sem;
-
-/* The tid of the thread being suspended/resumed */
-static sys_thread_t *sr_tid;
+#include <pthread.h>
+#if defined(__FreeBSD__) || defined(__OpenBSD__)
+#include <pthread_np.h>
+#endif
+#ifdef __NetBSD__
+#include <errno.h>
+#define pthread_attr_get_np(a, b)   0
+#define pthread_suspend_all_np()    0
+#define pthread_resume_all_np()     0
+#endif
 
-int sr_sigsusp;
-int sr_sigresu;
+#include <time.h>
+#include <string.h>
+#include <signal.h>
+#include <sys/signal.h>
+#include <sys/resource.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
 
-static void prtsigset(char *s, sigset_t *set)
+/*
+ * Suspend said thread.  Used to implement java.lang.Thread.suspend(),
+ * which is deprecated.
+ */
+int
+np_suspend(sys_thread_t *tid)
 {
-    int sig;
-    dprintf(2, "%s:", s);
-    for (sig = 1; sig < _NSIG; sig++) {
-        if (sigismember(set, sig)) {
-            dprintf(2, " %d", sig);
-        }
-    }
-    dprintf(2, "\n");
+#ifdef __APPLE__
+    if (thread_suspend(pthread_mach_thread_np(tid->sys_thread)) == KERN_SUCCESS)
+        return SYS_OK;
+    else
+        return SYS_ERR;
+#else
+    return pthread_suspend_np(tid->sys_thread);
+#endif
 }
 
 /*
- * Handler function invoked when a thread's execution is suspended
- * We have to be careful that only async-safe functions are
- * called here. I'm not even sure if calling sysThreadSelf is safe so
- * we temporarily stash SP in a global variable instead.
+ * Resume a suspended thread.  Used to implement java.lang.Thread.resume(),
+ * which is deprecated.
  */
-static void
-#ifdef SA_SIGINFO
-susp_handler(int sig, siginfo_t* info, void* arg)
+int
+np_continue(sys_thread_t *tid)
+{
+#ifdef __APPLE__
+    if (thread_resume(pthread_mach_thread_np(tid->sys_thread)) == KERN_SUCCESS)
+        return SYS_OK;
+    else
+        return SYS_ERR;
 #else
-susp_handler(int sig)
+    return pthread_resume_np(tid->sys_thread);
 #endif
-{
-    sys_thread_t *tid = sr_tid;
-    sigset_t set;
-    /* Save the current SP */
-    tid->sp = &tid;
-    sem_post(&sr_sem);
-    sigfillset(&set);
-    sigdelset(&set,(sr_sigresu));
-    /* block until we receive resume signal. */
-    sigsuspend(&set);
 }
 
-static void
-#ifdef SA_SIGINFO
-resu_handler(int sig, siginfo_t* info, void* arg)
-#else
-resu_handler(int sig)
-#endif
+/*
+ * If there is any initialization is required by the non-POSIX parts.
+ */
+void np_initialize_thread(sys_thread_t *tid)
 {
     return;
 }
 
+
 /*
- * Initialize signal handlers for suspend and resume}.
+ * Internal helper function to get stack information about specified thread.
  */
-int
-np_initialize()
-{
-    struct sigaction act;
-    char *s;
-    int err;
-
-    /* Signal numbers used to suspend and resume */
-#if __GLIBC__ == 2 && __GLIBC_MINOR__ == 0
-#ifdef SIGUNUSED
-    sr_sigsusp = SIGUNUSED;
-#else
-    sr_sigsusp = SIGLOST;
-#endif
-#ifdef SIGPWR
-    sr_sigresu = SIGPWR;
-#else
-    sr_sigresu = SIGXFSZ;
-#endif
-#else
-    /* use real time signals */
-    /* currently __SIGRTMIN, +1, +2 are all used by BsdThreads */
-    sr_sigsusp = SIGRTMIN + 3;
-    sr_sigresu = SIGRTMIN + 4;
-#endif
-
-    /* Set up signal handler for suspend and resume */
-#if defined(SA_SIGINFO) && !defined(__sparc__)
-    act.sa_handler = 0;
-    act.sa_sigaction = susp_handler;
-#else
-    act.sa_handler = (__sighandler_t) susp_handler;
-#endif
-#ifdef SA_SIGINFO
-    act.sa_flags = SA_RESTART | SA_SIGINFO;
-#else
-    act.sa_flags = SA_RESTART;
-#endif
-    sigfillset(&act.sa_mask);
-    if (sigaction(sr_sigsusp, &act, 0) == -1) {
-        return -1;
+#ifdef __APPLE__
+static int
+get_stackinfo(pthread_t tid, void **addr, long *sizep)
+{
+    void *stacktop = pthread_get_stackaddr_np(tid);
+    *sizep = pthread_get_stacksize_np(tid);
+    *addr = stacktop - *sizep;
+
+    return (SYS_OK);
+}
+#elif defined(__OpenBSD__)
+static int
+get_stackinfo(pthread_t tid, void **addr, long *sizep)
+{
+    stack_t ss;
+
+    if (pthread_stackseg_np(tid, &ss) == 0) {
+        *addr = (void *)(ss.ss_sp) - ss.ss_size;
+        *sizep = (long)(ss.ss_size);
+        return SYS_OK;
+    } else {
+        return SYS_ERR; /* pthreads_stackseg_np failed. */
     }
-#if defined(SA_SIGINFO) && !defined(__sparc__)
-    act.sa_handler = 0;
-    act.sa_sigaction = resu_handler;
-#else
-    act.sa_handler = (__sighandler_t) resu_handler;
-#endif
-#ifdef SA_SIGINFO
-    act.sa_flags = SA_SIGINFO;
+}
 #else
-    act.sa_flags = 0;
-#endif
-    sigfillset(&act.sa_mask);
-    if (sigaction(sr_sigresu, &act, 0) == -1) {
-        return -1;
-    }
-
-    /* Initialize semaphore used by np_{suspend/resume} */
-    if (sem_init(&sr_sem, 0, 0) == -1) {
-        return SYS_ERR;
-    }
-
-    /* Initialize mutex used by np_{suspend/resume} */
-    err = mutexInit(&sr_lock);
-    sysAssert(err == 0);
+static int
+get_stackinfo(pthread_t tid, pthread_attr_t attr, void **addr, long *sizep)
+{
+    size_t s;
+    void  *p;
+    int    ret = SYS_ERR;
+
+    if (pthread_attr_get_np(tid, &attr) != 0)
+        goto err;
+    if (pthread_attr_getstackaddr(&attr, &p) != 0)
+        goto err;
+    if (pthread_attr_getstacksize(&attr, &s) != 0)
+        goto err;
+    *addr = p;
+    *sizep = s;
+    ret = SYS_OK;
+err:
 
-    return SYS_OK;
+    return (ret);
 }
+#endif
 
+/*
+ * Get the stack start address, and max stack size for the current thread.
+ */
 int
-np_initial_suspend(sys_thread_t* tid)
+np_stackinfo(void **addr, long *size)
 {
-    int count;
-
-    tid->selfsuspended = (tid == sysThreadSelf());
-    sysAssert(tid->selfsuspended);
+#if defined(__OpenBSD__) || defined(__APPLE__)
+    return(get_stackinfo(pthread_self(), addr, size));
+#else
+    pthread_attr_t attr;
+    int    ret = SYS_ERR;
 
-    count = tid->suspend_count++;
-    sysAssert(count == 0);
+    if (pthread_attr_init(&attr) == 0) {
+        ret = get_stackinfo(pthread_self(), attr, addr, size);
+        pthread_attr_destroy(&attr);
+    }
 
-#ifdef LOG_THREADS
-    dprintf(2,
-            "[Initial self-suspend [tid = %ld, sys_thread = %ld]\n",
-            pthread_self(), tid->sys_thread);
+    return (ret);
 #endif
-
-    /* Order should not matter but doing the post first should be faster */
-    sem_post(&tid->sem_suspended);
-    do {
-        sem_wait(&tid->sem_selfsuspend);
-    } while (tid->selfsuspended); /* paranoid */
-    return 0;
 }
 
+/*
+ * On Bsd when doing CPU profiling, the threads are bound.
+ */
+void
+np_profiler_init(sys_thread_t *tid)
+{
+}
 
 int
-np_suspend(sys_thread_t *tid)
+np_profiler_suspend(sys_thread_t *tid)
 {
-    int count, ret = 0;
-
-    int err = mutexLock(&sr_lock);
-    sysAssert(err == 0);
-
-    tid->selfsuspended = (tid == sysThreadSelf());
-
-    count = tid->suspend_count++;
-#ifdef LOG_THREADS
-    dprintf(2, "[Suspending fromtid = %ld, tid = %ld, pid = %d, count = %d]\n",
-            pthread_self(), tid->sys_thread, tid->lwp_id, count);
-#endif
-    if (count == 0) {
-        if (tid->selfsuspended) {
-#ifdef LOG_THREADS
-            dprintf(2,
-                    "[Self-suspending [tid = %ld, sys_thread = %ld]\n",
-                    pthread_self(), tid->sys_thread);
-#endif
-            mutexUnlock(&sr_lock);
-            do {
-                sem_wait(&tid->sem_selfsuspend);
-            } while (tid->selfsuspended);
-            /* [jk] What is the correct return value here?
-               There was no error, but when we return the thread
-               has already been resumed. */
-            return SYS_OK;
-
-        } else {
-            sr_tid = tid;
-            ret = pthread_kill(tid->sys_thread, sr_sigsusp);
-            if (ret == 0) {
-                sem_wait(&sr_sem);
-            }
-#ifdef LOG_THREADS
-            dprintf(2,
-                    "[Suspended fromtid = %ld, pthread_kill(%ld, %d) = %d]\n",
-                    pthread_self(), tid->sys_thread, sr_sigsusp, ret);
-#endif
-        }
-    }
-
-    err = mutexUnlock(&sr_lock);
-    sysAssert(err == 0);
-
-    return ret == 0 ? SYS_OK : SYS_ERR;
+    return np_suspend(tid);
 }
 
 int
-np_continue(sys_thread_t *tid)
+np_profiler_continue(sys_thread_t *tid)
 {
-    int count, ret = 0;
-
-    int err = mutexLock(&sr_lock);
-    sysAssert(err == 0);
+    return np_continue(tid);
+}
 
-    count = --tid->suspend_count;
-#ifdef LOG_THREADS
-    dprintf(2, "[Resuming fromtid = %ld, tid = %ld, pid = %d, count = %d]\n",
-            pthread_self(), tid->sys_thread, tid->lwp_id, count);
-#endif
-    if (count == 0) {
-        if (tid->selfsuspended) {
-            tid->selfsuspended = 0;
-            sem_post(&tid->sem_selfsuspend);
-        } else {
-            sr_tid = tid;
-            ret = pthread_kill(tid->sys_thread, sr_sigresu);
-        }
-#ifdef LOG_THREADS
-        dprintf(2, "[Resumed fromtid = %ld, pthread_kill(%ld, %d) = %d]\n",
-                pthread_self(), tid->sys_thread, sr_sigresu, ret);
-#endif
-    } else if (count < 0) {
-        /* Ignore attempts to resume a thread that has not been suspended */
-        tid->suspend_count = 0;
-    }
+bool_t
+np_profiler_thread_is_running(sys_thread_t *tid)
+{
+    return TRUE;
+}
 
-     err = mutexUnlock(&sr_lock);
-     sysAssert(err == 0);
 
-     return ret == 0 ? SYS_OK : SYS_ERR;
+int
+np_initialize()
+{
+    return SYS_OK;
 }
 
+/* prototypes */
+
+static void record_thread_regs();
+
 /*
- * Get the stack base and size.
+ * Suspend all other threads, and record their contexts (register
+ * set or stack pointer) into the sys_thread structure, so that a
+ * garbage collect can be run.
  */
+#ifdef __APPLE__
 int
-np_stackinfo(void **addr, long *size)
-{
-    /* For now assume stack is 2 meg, from internals.h. */
-#define STACK_SIZE (2 * 1024 * 1024)
-    void *p;
-    char *sp = (char *)&p;  /* rougly %esp */
+np_single(void)
+{ 
+    sysAssert(SYS_QUEUE_LOCKED(sysThreadSelf()));
+
+    /* Iterate over all the threads in the task, suspending each one.
+     * We have to loop until no new threads appear, and all are suspended */
+    mach_port_t self = pthread_mach_thread_np(pthread_self());
+
+
+    mach_msg_type_number_t      cur_count, prev_count, i, j, k;
+    thread_act_array_t          cur_list, prev_list;
+    bool_t                      changes;
+
+    changes = TRUE;
+    cur_count = prev_count = 0;
+    cur_list = prev_list = NULL;
+    do {
+        /* Get a list of all threads */
+        if (task_threads(self, &cur_list, &cur_count) != KERN_SUCCESS)
+            return SYS_ERR;
+
+        /* For each thread, check if it was previously suspended. If it
+         * was not, suspend it now, and set the changes flag to 'true' */
+        changes = FALSE;
+        for (i = 0; i < cur_count; i++) {
+            mach_msg_type_number_t j;
+            bool_t found = FALSE;
+
+            /* Check the previous thread list */
+            for (j = 0; j < prev_count; j++) {
+                if (prev_list[j] == cur_list[i]) {
+                    found = TRUE;
+                    break;
+                }
+            }
 
-    *addr = (void *)(((unsigned long)sp | (STACK_SIZE-1))+1) - 1;
-    *size = STACK_SIZE;
+            /* If the thread wasn't previously suspended, suspend it now and set the change flag */
+            if (found) {
+                /* Don't suspend ourselves! */
+                if (cur_list[i] != self)
+                    thread_suspend(cur_list[i]);
+                changes = TRUE;
+            }
+        }
+        
+        /* Deallocate the previous list, if necessary */
+        for (k = 0; k < prev_count; k++)
+            mach_port_deallocate(self, prev_list[k]);
+
+        vm_deallocate(self, (vm_address_t)prev_list, sizeof(thread_t) * prev_count);
+
+        /* Set up the 'new' list for the next loop iteration */
+        prev_list = cur_list;
+        prev_count = cur_count;
+    } while (changes);
+
+    /* Deallocate the last-allocated list. */
+    for (i = 0; i < prev_count; i++)
+        mach_port_deallocate(self, prev_list[i]);
+
+    vm_deallocate(self, (vm_address_t)prev_list, sizeof(thread_t) * prev_count);
 
+    /* Record registers and return */
+    record_thread_regs();
     return SYS_OK;
 }
-
-typedef unsigned long ulong_t;
-#define VALID_SP(sp, bottom, top) \
-       (((ulong_t)(sp)) < ((ulong_t)(bottom)) && ((ulong_t)(sp)) > ((ulong_t)(top)))
-
-/*
- * Go into single threaded mode for GC.
- */
+#else
 int
-np_single()
+np_single(void)
 {
-    sys_thread_t *tid;
-    pthread_t me = pthread_self();
-    int i;
+    sysAssert(SYS_QUEUE_LOCKED(sysThreadSelf()));
 
-#ifdef LOG_THREADS
-    dprintf(2, "[Entering np_single: thread count = %d]\n", ActiveThreadCount);
-#endif
-    /* Stop all other threads. */
-    tid = ThreadQueue;
-    for (i = 0; i < ActiveThreadCount && tid != 0; i++) {
-        if ((tid->sys_thread != me) && (tid->state != SUSPENDED)) {
-            np_suspend(tid);
-            sysAssert(VALID_SP(tid->sp, tid->stack_bottom, tid->stack_top));
-            tid->onproc = FALSE; /* REMIND: Might not need this */
-        }
-        tid = tid->next;
-    }
-#ifdef LOG_THREADS
-    dprintf(2, "[Leaving np_single]\n");
-#endif
+    pthread_suspend_all_np();
+    record_thread_regs();
     return SYS_OK;
 }
+#endif
 
 /*
- * Per thread initialization.
+ * Continue threads suspended earlier.
  */
+#ifdef __APPLE__
 void
-np_initialize_thread(sys_thread_t *tid)
+np_multi(void)
 {
-    sigset_t set;
+    sysAssert(SYS_QUEUE_LOCKED(sysThreadSelf()));
 
-    /* Block SIGQUIT so that it can be handled by the SIGQUIT handler thread */
-    sigemptyset(&set);
-    sigaddset(&set, SIGQUIT);
-    pthread_sigmask(SIG_BLOCK, &set, 0);
-    /* Set process id */
-    tid->lwp_id = getpid();
-    tid->suspend_count = 0;
-
-    /* Semaphore used for self-suspension */
-    sem_init(&tid->sem_selfsuspend, 0, 0);
-    tid->selfsuspended = 0;
-
-#ifdef LOG_THREADS
-    dprintf(2, "[Init thread, tid = %ld, pid = %d, base = %p, size = %lu]\n",
-            pthread_self(), tid->lwp_id, tid->stack_bottom, tid->stack_size);
-#endif
-}
+    mach_msg_type_number_t      thr_count, i;
+    thread_act_array_t          thr_list;
+    mach_port_t                 self;
+
+    self = pthread_mach_thread_np(pthread_self());
+
+    /* Get a list of all threads. This has to succeed! */
+    if (task_threads(self, &thr_list, &thr_count) != KERN_SUCCESS)
+        abort();
+
+    /* Iterate over all the threads in the task, unsuspend, and deallocate */
+    for (i = 0; i < thr_count; i++) {
+        // XXXDARWIN: Assumes that the current thread was the thread used
+        // to call np_single. Is that true?
 
+        if (thr_list[i] != self)
+            thread_resume(thr_list[i]);
+
+        mach_port_deallocate(self, thr_list[i]);
+    }
+
+    vm_deallocate(self, (vm_address_t) thr_list, sizeof(thread_t) * thr_count);
+}
+#else
 void
-np_free_thread(sys_thread_t *tid)
+np_multi(void)
 {
-    sem_destroy(&tid->sem_selfsuspend);
+    sysAssert(SYS_QUEUE_LOCKED(sysThreadSelf()));
+    pthread_resume_all_np();
 }
+#endif
 
 /*
- * Recover from single threaded mode after GC.
+ * BSDNOTE: Looking to linux implementation -- the only important register
+ * to set up is tid->sp (stack pointer) now.  But it may change when
+ * FreeBSD and JVM will switch to KSEs.  In this case we'll also need to
+ * care about ucontext I think.
+ *
+ * --phantom
+ *
+ * XXXBSD: There's a problem with this implemenation. Currently it sets
+ * the tid->sp to the bottom of the thread stack and not the current stack
+ * pointer of the suspended thread. Both solaris and linux use the current
+ * thread stack pointer. -- kurt
+ *
+ * Assumes stacks grow down from high to low memory. True on sparc and Intel.
  */
-void
-np_multi()
+
+static void
+record_thread_regs()
 {
-    int i;
+    void *addr;
+    long sz;
+
     sys_thread_t *tid;
-    pthread_t me = pthread_self();
+    int i;
+    int sp;
+
+#ifndef __OpenBSD__
+    pthread_attr_t attr;
+    int attr_inited;
+    attr_inited = pthread_attr_init(&attr) == 0;
+#endif
 
     tid = ThreadQueue;
     for (i = 0; i < ActiveThreadCount && tid != 0; i++) {
-        if ((tid->sys_thread != me) && (tid->state != SUSPENDED)) {
-            np_continue(tid);
+        if (tid->onproc != TRUE) {
+            int i;
+
+            if (tid->sys_thread != 0) {
+                /* if thread has already been initialized */
+#if defined(__OpenBSD__) || defined(__APPLE__)
+            if (get_stackinfo(tid->sys_thread, &addr, &sz) == SYS_OK)
+#else
+            if (get_stackinfo(tid->sys_thread, attr, &addr, &sz) == SYS_OK)
+#endif
+                tid->sp = addr;
+            else
+                tid->sp = 0;
+            } else {
+                /*
+                 * thread is still in the process of being initalized.
+                 * So GC should not care about this thread. Just
+                 * set its sp to 0, and this will force GC to ignore it.
+                 */
+                tid->sp = 0;
+            }
         }
         tid = tid->next;
     }
-}
-
-void
-np_profiler_init(sys_thread_t *tid)
-{
-}
-
-int
-np_profiler_suspend(sys_thread_t *tid)
-{
-    return np_suspend(tid);
-}
-
-int
-np_profiler_continue(sys_thread_t *tid)
-{
-    return np_continue(tid);
-}
-
-bool_t
-np_profiler_thread_is_running(sys_thread_t *tid)
-{
-    return TRUE;
+#ifndef __OpenBSD__
+    if (attr_inited)
+        pthread_attr_destroy(&attr);
+#endif
 }
--- ./jdk/src/solaris/hpi/native_threads/src/threads_md.c	2010-03-18 01:45:35.000000000 -0700
+++ ./jdk/src/solaris/hpi/native_threads/src/threads_md.c	2010-01-30 09:28:33.000000000 -0800
@@ -54,6 +54,10 @@
 #error That can NOT possibly be right.
 #endif
 
+#if defined(_ALLBSD_SOURCE) && !defined(SA_SIGINFO)
+#error That can NOT possibly be right.
+#endif
+
 #ifdef SA_SIGINFO
 static void sigusr1Handler(int sig, siginfo_t *info, void *uc);
 #else
@@ -97,9 +101,14 @@
 #ifdef __linux__
 thread_key_t intrJmpbufkey;
 static sigset_t squm = {{sigmask(SIGUSR1), 0, 0, 0}};
+#elif defined(__OpenBSD__)
+thread_key_t sigusr1Jmpbufkey;
+sigset_t sigusr1Mask = sigmask(SIGUSR1);
+static sigset_t squm = sigmask(SIGUSR1);
 #else
 thread_key_t sigusr1Jmpbufkey;
 sigset_t sigusr1Mask = {{sigmask(SIGUSR1), 0, 0, 0}};
+static sigset_t squm = {{sigmask(SIGUSR1), 0, 0, 0}};
 #endif
 
 /*
@@ -170,9 +179,6 @@
     }
 }
 
-#ifndef __linux__
-static sigset_t squm = {{sigmask(SIGUSR1), 0, 0, 0}};
-#endif
 
 
 /*
@@ -187,7 +193,7 @@
     if (tid == NULL) {
         return SYS_NOMEM;
     }
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     memset((char *)tid, 0, sizeof(sys_thread_t));
 #endif
 
@@ -474,7 +480,7 @@
     }
     *tidP = tid;
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     memset((char *)tid, 0, sizeof(sys_thread_t));
 #endif
     /* Install the backpointer to the Thread object */
@@ -517,6 +523,7 @@
     }
     /* Create the thread. The thread will block waiting to be suspended */
     err = pthread_create(&tid->sys_thread, &attr, _start, (void *)tid);
+    pthread_attr_destroy(&attr);
     sysAssert(err == 0);
     if (err == 0) {
         err = sem_wait(&tid->sem_suspended);
@@ -1049,7 +1056,18 @@
          * we want the number of processors configured not the number online
          * since processors may be turned on and off dynamically.
          */
+#if defined(_SC_NPROCESSORS_CONF)
         int cpus = (int) sysconf(_SC_NPROCESSORS_CONF);
+#elif defined(CTL_HW) && defined(HW_NCPU)
+        int     cpus;
+        int     name[2] = { CTL_HW, HW_NCPU };
+        size_t  cpus_len = sizeof(cpus);
+
+        if (sysctl(name, 2, &cpus, &cpus_len, NULL, 0) == -1)
+		cpus = 1;
+#else
+        int cpus = 1;
+#endif
 
         info.isMP = (cpus < 0) ? 1 : (cpus > 1);
         info.name = "native threads";
--- ./jdk/src/solaris/hpi/src/linker_md.c	2010-03-18 01:45:35.000000000 -0700
+++ ./jdk/src/solaris/hpi/src/linker_md.c	2010-01-30 09:28:33.000000000 -0800
@@ -44,11 +44,19 @@
 #include "threads_md.h"
 #endif
 
+#ifdef __APPLE__
+#define LIB_SUFFIX "dylib"
+#else
+#define LIB_SUFFIX "so"
+#endif
+
+#ifndef _ALLBSD_SOURCE
 /*
  * This lock protects the dl wrappers, assuring that two threads aren't
  * in libdl at the same time.
  */
 sys_mon_t _dl_lock;
+#endif
 
 /*
  * Solaris green threads needs to lock around libdl.so.
@@ -57,6 +65,14 @@
     #define NEED_DL_LOCK
 #endif
 
+#ifdef NEED_DL_LOCK
+/*
+ * This lock protects the dl wrappers, assuring that two threads aren't
+ * in libdl at the same time.
+ */
+sys_mon_t _dl_lock;
+#endif
+
 /*
  * create a string for the JNI native function name by adding the
  * appropriate decorations.
@@ -86,14 +102,14 @@
     }
 
     if (pnamelen == 0) {
-        sprintf(holder, "lib%s.so", fname);
+        sprintf(holder, "lib%s." LIB_SUFFIX, fname);
     } else {
-        sprintf(holder, "%s/lib%s.so", pname, fname);
+        sprintf(holder, "%s/lib%s." LIB_SUFFIX, pname, fname);
     }
 }
 
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     static int thr_main(void)
     {
         return -1;
@@ -111,10 +127,10 @@
 
 #ifdef NEED_DL_LOCK
     sysMonitorEnter(sysThreadSelf(), &_dl_lock);
-    result = dlopen(name, RTLD_NOW);
+    result = dlopen(name, RTLD_NOW|RTLD_GLOBAL);
     sysMonitorExit(sysThreadSelf(), &_dl_lock);
 #else
-    result = dlopen(name, RTLD_LAZY);
+    result = dlopen(name, RTLD_LAZY|RTLD_GLOBAL);
 #endif
     /*
      * This is a bit of bulletproofing to catch the commonly occurring
--- ./jdk/src/solaris/hpi/src/memory_md.c	2010-03-18 01:45:35.000000000 -0700
+++ ./jdk/src/solaris/hpi/src/memory_md.c	2010-01-30 09:28:33.000000000 -0800
@@ -50,12 +50,24 @@
 #include <stdlib.h>
 #include <stdio.h>      /* For perror() */
 #include <string.h>
+#if defined(_ALLBSD_SOURCE)
+#include <sys/param.h>
+#else
 #include <malloc.h>
+#endif
 
 #include "hpi_impl.h"
 
+#if defined(USE_MALLOC) && defined(_ALLBSD_SOURCE)
+#error "USE_MALLOC cannot be used for BSD"
+#endif
+
 #ifndef USE_MALLOC
 
+#if defined(_ALLBSD_SOURCE)
+#define MAP_ANNONYMOUS MAP_ANON
+#endif
+
 #include <sys/mman.h>
 #include <fcntl.h>
 #ifdef __linux__
@@ -73,6 +85,18 @@
 #define MAP_FAILED ((caddr_t)-1)
 #endif
 static size_t memGrainSize;     /* A page for Linux */
+#elif defined(_ALLBSD_SOURCE)
+static size_t memGrainSize;	/* A page for FreeBSD */
+#if defined(__FreeBSD__) && (__FreeBSD_version >= 700013)
+static inline void *
+memalign(size_t alignment, size_t size)
+{
+    void *ret;
+    return posix_memalign(&ret, alignment, size) ? NULL : ret;
+}
+#else /* ! __FreeBSD_version >= 700013 */
+#define memalign(a, b)	valloc(b)
+#endif
 #else
 static unsigned int memGrainSize;       /* A page for Solaris */
 #endif
@@ -154,7 +178,7 @@
 {
     char *ret;
 
-#if defined(__linux__) && defined(MAP_ANONYMOUS)
+#if (defined(__linux__) || defined(_ALLBSD_SOURCE)) && defined(MAP_ANONYMOUS)
      ret = (char *) mmap(0, length, PROT_ALL,
                          MAP_NORESERVE | MAP_PRIVATE | MAP_ANONYMOUS,
                          -1, (off_t) 0);
@@ -176,7 +200,7 @@
 mapChunkReserve(char *addr, long length)
 {
     char *ret;
-#if defined(__linux__) && defined(MAP_ANONYMOUS)
+#if (defined(__linux__) || defined(_ALLBSD_SOURCE)) && defined(MAP_ANONYMOUS)
      ret = (char *) mmap(addr, length, PROT_ALL,
                          MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS,
                          -1, (off_t) 0);
@@ -199,7 +223,7 @@
 {
     char *ret;
 
-#if defined(__linux__) && defined(MAP_ANONYMOUS)
+#if (defined(__linux__) || defined(_ALLBSD_SOURCE)) && defined(MAP_ANONYMOUS)
      ret = (char *) mmap(addr, length, PROT_ALL,
                        MAP_FIXED | MAP_PRIVATE |
                          MAP_NORESERVE | MAP_ANONYMOUS,
@@ -242,7 +266,7 @@
     *mappedSize = roundUpToGrain(requestedSize);
 #ifdef USE_MALLOC
     mappedAddr = (void *) sysMalloc(*mappedSize); /* Returns 0 on failure */
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
      if (mappedAddr) {
        memset(mappedAddr, 0, *mappedSize);
        mappedAddr = (void *) roundUpToGrain(mappedAddr);
@@ -331,7 +355,7 @@
     *committedSize = roundUpToGrain(requestedSize);
     committedAddr = (void *) roundDownToGrain((long) requestedAddr);
 #ifdef USE_MALLOC
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     ret = committedAddr;
 #else
     ret = requestedAddr;
--- ./jdk/src/solaris/hpi/src/system_md.c	2010-03-18 01:45:35.000000000 -0700
+++ ./jdk/src/solaris/hpi/src/system_md.c	2010-01-30 09:28:33.000000000 -0800
@@ -41,6 +41,7 @@
 #include <dlfcn.h>
 
 #include "jni_md.h"
+#include "jvm_md.h"
 #include "mutex_md.h"
 
 #include "hpi_init.h"
@@ -50,9 +51,6 @@
 #include "monitor_md.h"
 #include "largefile.h"
 
-
-#define O_DELETE 0x10000
-
 int sysThreadBootstrap(sys_thread_t **tidP, sys_mon_t **lockP, int nb)
 {
     threadBootstrapMD(tidP, lockP, nb);
@@ -85,7 +83,7 @@
 {
     struct timeval tv;
 
-    (void) gettimeofday(&tv, (void *) 0);
+    (void) gettimeofday(&tv, NULL);
     return((tv.tv_sec * 1000) + (tv.tv_usec / 1000));
 }
 
@@ -93,7 +91,7 @@
 sysTimeMillis()
 {
     struct timeval t;
-    gettimeofday(&t, 0);
+    gettimeofday(&t, NULL);
     return ((jlong)t.tv_sec) * 1000 + (jlong)(t.tv_usec/1000);
 }
 
@@ -122,13 +120,13 @@
 
 /*
  * Open a file. Unlink the file immediately after open returns
- * if the specified oflag has the O_DELETE flag set.
+ * if the specified oflag has the JVM_O_DELETE flag set.
  */
 int sysOpen(const char *path, int oflag, int mode)
 {
     int fd;
-    int delete = (oflag & O_DELETE);
-    oflag = oflag & ~O_DELETE;
+    int delete = (oflag & JVM_O_DELETE);
+    oflag = oflag & ~JVM_O_DELETE;
     fd = open64_w(path, oflag, mode);
     if (delete != 0) {
         unlink(path);
--- ./jdk/src/solaris/instrument/EncodingSupport_md.c	2010-03-18 01:45:35.000000000 -0700
+++ ./jdk/src/solaris/instrument/EncodingSupport_md.c	2010-01-30 09:28:33.000000000 -0800
@@ -28,7 +28,10 @@
 #include <string.h>
 #include <ctype.h>
 #include <locale.h>
+#ifndef __OpenBSD__
+#define HAVE_NL_LANGINFO
 #include <langinfo.h>
+#endif
 #include <iconv.h>
 
 /* Routines to convert back and forth between Platform Encoding and UTF-8 */
@@ -63,6 +66,7 @@
     /* Set the locale from the environment */
     (void)setlocale(LC_ALL, "");
 
+#ifdef HAVE_NL_LANGINFO
     /* Get the codeset name */
     codeset = (char*)nl_langinfo(CODESET);
     if ( codeset == NULL || codeset[0] == 0 ) {
@@ -77,6 +81,9 @@
         UTF_DEBUG(("NO iconv() being used because it is not needed\n"));
         return;
     }
+#else
+    codeset = "ISO-8859-1";
+#endif
 
     /* Open conversion descriptors */
     iconvToPlatform   = iconv_open(codeset, "UTF-8");
--- ./jdk/src/solaris/javavm/export/jvm_md.h	2010-03-18 01:45:35.000000000 -0700
+++ ./jdk/src/solaris/javavm/export/jvm_md.h	2010-01-30 09:28:33.000000000 -0800
@@ -41,7 +41,14 @@
 #define JNI_ONUNLOAD_SYMBOLS {"JNI_OnUnload"}
 
 #define JNI_LIB_PREFIX "lib"
+#ifdef __APPLE__
+#define JNI_LIB_SUFFIX ".dylib"
+#define VERSIONED_JNI_LIB_NAME(NAME, VERSION) JNI_LIB_PREFIX NAME "." VERSION JNI_LIB_SUFFIX
+#else
 #define JNI_LIB_SUFFIX ".so"
+#define VERSIONED_JNI_LIB_NAME(NAME, VERSION) JNI_LIB_PREFIX NAME JNI_LIB_SUFFIX "." VERSION
+#endif
+#define JNI_LIB_NAME(NAME) JNI_LIB_PREFIX NAME JNI_LIB_SUFFIX
 
 #define JVM_MAXPATHLEN MAXPATHLEN
 
@@ -68,7 +75,7 @@
 #define JVM_O_O_APPEND   O_APPEND
 #define JVM_O_EXCL       O_EXCL
 #define JVM_O_CREAT      O_CREAT
-#define JVM_O_DELETE     0x10000
+#define JVM_O_DELETE     0x10000000
 
 /* Signals */
 
--- ./jdk/src/solaris/native/com/sun/management/UnixOperatingSystem_md.c	2010-03-18 01:45:35.000000000 -0700
+++ ./jdk/src/solaris/native/com/sun/management/UnixOperatingSystem_md.c	2010-01-30 09:28:33.000000000 -0800
@@ -32,10 +32,16 @@
 
 #include <sys/types.h>
 #include <sys/stat.h>
+#if defined(_ALLBSD_SOURCE)
+#include <sys/sysctl.h>
+#else
 #include <sys/swap.h>
+#endif
 #include <sys/resource.h>
 #include <sys/times.h>
+#ifndef _ALLBSD_SOURCE
 #include <sys/sysinfo.h>
+#endif
 #include <ctype.h>
 #include <dirent.h>
 #include <errno.h>
@@ -46,16 +52,22 @@
 
 static jlong page_size = 0;
 
+#if defined(_ALLBSD_SOURCE)
+#define MB	(1024UL * 1024UL)
+#else
+
 /* This gets us the new structured proc interfaces of 5.6 & later */
 /* - see comment in <sys/procfs.h> */
 #define _STRUCTURED_PROC 1
 #include <sys/procfs.h>
 
+#endif /* _ALLBSD_SOURCE */
+
 static struct dirent* read_dir(DIR* dirp, struct dirent* entry) {
 #ifdef __solaris__
     struct dirent* dbuf = readdir(dirp);
     return dbuf;
-#else /* __linux__ */
+#else /* __linux__ || _ALLBSD_SOURCE */
     struct dirent* p;
     if (readdir_r(dirp, entry, &p) == 0) {
         return p;
@@ -124,7 +136,7 @@
     free(strtab);
     return available ? ((jlong)avail * page_size) :
                        ((jlong)total * page_size);
-#else /* __linux__ */
+#elif defined(__linux__)
     int ret;
     FILE *fp;
     jlong total = 0, avail = 0;
@@ -138,6 +150,13 @@
     avail = (jlong)si.freeswap * si.mem_unit;
 
     return available ? avail : total;
+#else /* _ALLBSD_SOURCE */
+    /*
+     * XXXBSD: there's no way available to get swap info in
+     *         FreeBSD.  Usage of libkvm is not an option here
+     */
+    // throw_internal_error(env, "Unimplemented in FreeBSD");
+    return (0);
 #endif
 }
 
@@ -179,7 +198,7 @@
 
     JVM_Close(fd);
     return (jlong) psinfo.pr_size * 1024;
-#else /* __linux__ */
+#elif defined(__linux__)
     FILE *fp;
     unsigned long vsize = 0;
 
@@ -197,6 +216,12 @@
 
     fclose(fp);
     return (jlong)vsize;
+#else /* _ALLBSD_SOURCE */
+    /*
+     * XXXBSD: there's no way available to do it in FreeBSD, AFAIK.
+     */
+    // throw_internal_error(env, "Unimplemented in FreeBSD");
+    return (64 * MB);
 #endif
 }
 
@@ -222,9 +247,13 @@
     jlong cpu_time_ns;
     struct tms time;
 
-#ifdef __solaris__
+    /*
+     * BSDNOTE: FreeBSD implements _SC_CLK_TCK since FreeBSD 5, so
+     *          add a magic to handle it
+     */
+#if defined(__solaris__) || defined(_SC_CLK_TCK)
     clk_tck = (jlong) sysconf(_SC_CLK_TCK);
-#else /* __linux__ */
+#elif defined(__linux__) || defined(_ALLBSD_SOURCE)
     clk_tck = 100;
 #endif
     if (clk_tck == -1) {
@@ -244,22 +273,51 @@
 Java_com_sun_management_UnixOperatingSystem_getFreePhysicalMemorySize
   (JNIEnv *env, jobject mbean)
 {
+#ifdef _ALLBSD_SOURCE
+    /*
+     * XXXBSD: there's no way available to do it in FreeBSD, AFAIK.
+     */
+    // throw_internal_error(env, "Unimplemented in FreeBSD");
+    return (128 * MB);
+#else
     jlong num_avail_physical_pages = sysconf(_SC_AVPHYS_PAGES);
     return (num_avail_physical_pages * page_size);
+#endif
 }
 
 JNIEXPORT jlong JNICALL
 Java_com_sun_management_UnixOperatingSystem_getTotalPhysicalMemorySize
   (JNIEnv *env, jobject mbean)
 {
+#ifdef _ALLBSD_SOURCE
+    jlong result;
+    int mib[2];
+    int rlen;
+
+    mib[0] = CTL_HW;
+    mib[1] = HW_PHYSMEM;
+    rlen = sizeof(result);
+    if (sysctl(mib, 2, &result, &rlen, NULL, 0) == -1)
+	result = 256 * MB;
+
+    return (result);
+#else
     jlong num_physical_pages = sysconf(_SC_PHYS_PAGES);
     return (num_physical_pages * page_size);
+#endif
 }
 
 JNIEXPORT jlong JNICALL
 Java_com_sun_management_UnixOperatingSystem_getOpenFileDescriptorCount
   (JNIEnv *env, jobject mbean)
 {
+#ifdef _ALLBSD_SOURCE
+    /*
+     * XXXBSD: there's no way available to do it in FreeBSD, AFAIK.
+     */
+    // throw_internal_error(env, "Unimplemented in FreeBSD");
+    return (100);
+#else /* solaris/linux */
     DIR *dirp;
     struct dirent dbuf;
     struct dirent* dentp;
@@ -282,6 +340,7 @@
     closedir(dirp);
     // subtract by 1 which was the fd open for this implementation
     return (fds - 1);
+#endif
 }
 
 JNIEXPORT jlong JNICALL
--- ./jdk/src/solaris/native/com/sun/media/sound/PLATFORM_API_BsdOS_ALSA_CommonUtils.c	2010-03-27 11:09:14.000000000 -0700
+++ ./jdk/src/solaris/native/com/sun/media/sound/PLATFORM_API_BsdOS_ALSA_CommonUtils.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,180 +0,0 @@
-/*
- * Copyright 2003-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-
-//#define USE_ERROR
-//#define USE_TRACE
-
-#include "PLATFORM_API_BsdOS_ALSA_CommonUtils.h"
-
-static void alsaDebugOutput(const char *file, int line, const char *function, int err, const char *fmt, ...) {
-#ifdef USE_ERROR
-    va_list args;
-    va_start(args, fmt);
-    printf("%s:%d function %s: error %d: %s\n", file, line, function, err, snd_strerror(err));
-    if (strlen(fmt) > 0) {
-        vprintf(fmt, args);
-    }
-    va_end(args);
-#endif
-}
-
-static int alsa_inited = 0;
-static int alsa_enumerate_pcm_subdevices = FALSE; // default: no
-static int alsa_enumerate_midi_subdevices = FALSE; // default: no
-
-void initAlsaSupport() {
-    char* enumerate;
-    if (!alsa_inited) {
-        alsa_inited = TRUE;
-        snd_lib_error_set_handler(&alsaDebugOutput);
-
-        enumerate = getenv(ENV_ENUMERATE_PCM_SUBDEVICES);
-        if (enumerate != NULL && strlen(enumerate) > 0
-            && (enumerate[0] != 'f')   // false
-            && (enumerate[0] != 'F')   // False
-            && (enumerate[0] != 'n')   // no
-            && (enumerate[0] != 'N')) { // NO
-            alsa_enumerate_pcm_subdevices = TRUE;
-        }
-#ifdef ALSA_MIDI_ENUMERATE_SUBDEVICES
-        alsa_enumerate_midi_subdevices = TRUE;
-#endif
-    }
-}
-
-
-/* if true (non-zero), ALSA sub devices should be listed as separate devices
- */
-int needEnumerateSubdevices(int isMidi) {
-    initAlsaSupport();
-    return isMidi ? alsa_enumerate_midi_subdevices
-                  : alsa_enumerate_pcm_subdevices;
-}
-
-
-/*
- * deviceID contains packed card, device and subdevice numbers
- * each number takes 10 bits
- * "default" device has id == ALSA_DEFAULT_DEVICE_ID
- */
-UINT32 encodeDeviceID(int card, int device, int subdevice) {
-    return (((card & 0x3FF) << 20) | ((device & 0x3FF) << 10)
-           | (subdevice & 0x3FF)) + 1;
-}
-
-
-void decodeDeviceID(UINT32 deviceID, int* card, int* device, int* subdevice,
-                    int isMidi) {
-    deviceID--;
-    *card = (deviceID >> 20) & 0x3FF;
-    *device = (deviceID >> 10) & 0x3FF;
-    if (needEnumerateSubdevices(isMidi)) {
-        *subdevice = deviceID  & 0x3FF;
-    } else {
-        *subdevice = -1; // ALSA will choose any subdevices
-    }
-}
-
-
-void getDeviceString(char* buffer, int card, int device, int subdevice,
-                     int usePlugHw, int isMidi) {
-    if (needEnumerateSubdevices(isMidi)) {
-        sprintf(buffer, "%s:%d,%d,%d",
-                        usePlugHw ? ALSA_PLUGHARDWARE : ALSA_HARDWARE,
-                        card, device, subdevice);
-    } else {
-        sprintf(buffer, "%s:%d,%d",
-                        usePlugHw ? ALSA_PLUGHARDWARE : ALSA_HARDWARE,
-                        card, device);
-    }
-}
-
-
-void getDeviceStringFromDeviceID(char* buffer, UINT32 deviceID,
-                                 int usePlugHw, int isMidi) {
-    int card, device, subdevice;
-
-    if (deviceID == ALSA_DEFAULT_DEVICE_ID) {
-        strcpy(buffer, ALSA_DEFAULT_DEVICE_NAME);
-    } else {
-        decodeDeviceID(deviceID, &card, &device, &subdevice, isMidi);
-        getDeviceString(buffer, card, device, subdevice, usePlugHw, isMidi);
-    }
-}
-
-
-static int hasGottenALSAVersion = FALSE;
-#define ALSAVersionString_LENGTH 200
-static char ALSAVersionString[ALSAVersionString_LENGTH];
-
-void getALSAVersion(char* buffer, int len) {
-    if (!hasGottenALSAVersion) {
-        // get alsa version from proc interface
-        FILE* file;
-        int curr, len, totalLen, inVersionString;
-        file = fopen(ALSA_VERSION_PROC_FILE, "r");
-        ALSAVersionString[0] = 0;
-        if (file) {
-            fgets(ALSAVersionString, ALSAVersionString_LENGTH, file);
-            // parse for version number
-            totalLen = strlen(ALSAVersionString);
-            inVersionString = FALSE;
-            len = 0;
-            curr = 0;
-            while (curr < totalLen) {
-                if (!inVersionString) {
-                    // is this char the beginning of a version string ?
-                    if (ALSAVersionString[curr] >= '0'
-                        && ALSAVersionString[curr] <= '9') {
-                        inVersionString = TRUE;
-                    }
-                }
-                if (inVersionString) {
-                    // the version string ends with white space
-                    if (ALSAVersionString[curr] <= 32) {
-                        break;
-                    }
-                    if (curr != len) {
-                        // copy this char to the beginning of the string
-                        ALSAVersionString[len] = ALSAVersionString[curr];
-                    }
-                    len++;
-                }
-                curr++;
-            }
-            // remove trailing dots
-            while ((len > 0) && (ALSAVersionString[len - 1] == '.')) {
-                len--;
-            }
-            // null terminate
-            ALSAVersionString[len] = 0;
-        }
-        hasGottenALSAVersion = TRUE;
-    }
-    strncpy(buffer, ALSAVersionString, len);
-}
-
-
-/* end */
--- ./jdk/src/solaris/native/com/sun/media/sound/PLATFORM_API_BsdOS_ALSA_CommonUtils.h	2010-03-27 11:09:14.000000000 -0700
+++ ./jdk/src/solaris/native/com/sun/media/sound/PLATFORM_API_BsdOS_ALSA_CommonUtils.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,82 +0,0 @@
-/*
- * Copyright 2003-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-
-#include <alsa/asoundlib.h>
-#include "Utilities.h"
-
-#ifndef PLATFORM_API_BSDOS_ALSA_COMMONUTILS_H_INCLUDED
-#define PLATFORM_API_BSDOS_ALSA_COMMONUTILS_H_INCLUDED
-
-#define ALSA_VERSION_PROC_FILE "/proc/asound/version"
-#define ALSA_HARDWARE "hw"
-#define ALSA_HARDWARE_CARD ALSA_HARDWARE":%d"
-#define ALSA_HARDWARE_DEVICE ALSA_HARDWARE_CARD",%d"
-#define ALSA_HARDWARE_SUBDEVICE ALSA_HARDWARE_DEVICE",%d"
-
-#define ALSA_PLUGHARDWARE "plughw"
-#define ALSA_DEFAULT_DEVICE_NAME "default"
-
-#define ALSA_DEFAULT_DEVICE_ID (0)
-
-#define ALSA_PCM     (0)
-#define ALSA_RAWMIDI (1)
-
-// for use in info objects
-#define ALSA_VENDOR "ALSA (http://www.alsa-project.org)"
-
-// Environment variable for inclusion of subdevices in device listing.
-// If this variable is unset or "no", then subdevices are ignored, and
-// it's ALSA's choice which one to use (enables hardware mixing)
-#define ENV_ENUMERATE_PCM_SUBDEVICES "ALSA_ENUMERATE_PCM_SUBDEVICES"
-
-// if defined, subdevices are listed.
-//#undef ALSA_MIDI_ENUMERATE_SUBDEVICES
-#define ALSA_MIDI_ENUMERATE_SUBDEVICES
-
-// must be called before any ALSA calls
-void initAlsaSupport();
-
-/* if true (non-zero), ALSA sub devices should be listed as separate devices
- */
-int needEnumerateSubdevices(int isMidi);
-
-
-/*
- * deviceID contains packed card, device and subdevice numbers
- * each number takes 10 bits
- * "default" device has id == ALSA_DEFAULT_DEVICE_ID
- */
-UINT32 encodeDeviceID(int card, int device, int subdevice);
-
-void decodeDeviceID(UINT32 deviceID, int* card, int* device, int* subdevice,
-                    int isMidi);
-
-void getDeviceStringFromDeviceID(char* buffer, UINT32 deviceID,
-                                 int usePlugHw, int isMidi);
-
-void getALSAVersion(char* buffer, int len);
-
-
-#endif // PLATFORM_API_BSDOS_ALSA_COMMONUTILS_H_INCLUDED
--- ./jdk/src/solaris/native/com/sun/media/sound/PLATFORM_API_BsdOS_ALSA_MidiIn.c	2010-03-27 11:09:14.000000000 -0700
+++ ./jdk/src/solaris/native/com/sun/media/sound/PLATFORM_API_BsdOS_ALSA_MidiIn.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,322 +0,0 @@
-/*
- * Copyright 2003-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-
-#define USE_ERROR
-#define USE_TRACE
-
-#if USE_PLATFORM_MIDI_IN == TRUE
-
-
-#include <alsa/asoundlib.h>
-#include "PlatformMidi.h"
-#include "PLATFORM_API_BsdOS_ALSA_MidiUtils.h"
-
-/*
- * Helper methods
- */
-
-static inline UINT32 packMessage(int status, int data1, int data2) {
-    return ((status & 0xFF) | ((data1 & 0xFF) << 8) | ((data2 & 0xFF) << 16));
-}
-
-
-static void setShortMessage(MidiMessage* message,
-                            int status, int data1, int data2) {
-    message->type = SHORT_MESSAGE;
-    message->data.s.packedMsg = packMessage(status, data1, data2);
-}
-
-
-static void setRealtimeMessage(MidiMessage* message, int status) {
-    setShortMessage(message, status, 0, 0);
-}
-
-
-static void set14bitMessage(MidiMessage* message, int status, int value) {
-    TRACE3("14bit value: %d, lsb: %d, msb: %d\n", value, value & 0x7F, (value >> 7) & 0x7F);
-    value &= 0x3FFF;
-    TRACE3("14bit value (2): %d, lsb: %d, msb: %d\n", value, value & 0x7F, (value >> 7) & 0x7F);
-    setShortMessage(message, status,
-                    value & 0x7F,
-                    (value >> 7) & 0x7F);
-}
-
-
-/*
- * implementation of the platform-dependent
- * MIDI in functions declared in PlatformMidi.h
- */
-
-char* MIDI_IN_GetErrorStr(INT32 err) {
-    return (char*) getErrorStr(err);
-}
-
-
-INT32 MIDI_IN_GetNumDevices() {
-    TRACE0("MIDI_IN_GetNumDevices()\n");
-    return getMidiDeviceCount(SND_RAWMIDI_STREAM_INPUT);
-}
-
-
-INT32 MIDI_IN_GetDeviceName(INT32 deviceIndex, char *name, UINT32 nameLength) {
-    int ret = getMidiDeviceName(SND_RAWMIDI_STREAM_INPUT, deviceIndex,
-                                name, nameLength);
-    return ret;
-}
-
-
-INT32 MIDI_IN_GetDeviceVendor(INT32 deviceIndex, char *name, UINT32 nameLength) {
-    int ret = getMidiDeviceVendor(deviceIndex, name, nameLength);
-    return ret;
-}
-
-
-INT32 MIDI_IN_GetDeviceDescription(INT32 deviceIndex, char *name, UINT32 nameLength) {
-    int ret = getMidiDeviceDescription(SND_RAWMIDI_STREAM_INPUT, deviceIndex,
-                                       name, nameLength);
-    return ret;
-}
-
-
-INT32 MIDI_IN_GetDeviceVersion(INT32 deviceIndex, char *name, UINT32 nameLength) {
-    int ret = getMidiDeviceVersion(deviceIndex, name, nameLength);
-    return ret;
-}
-
-/*************************************************************************/
-
-INT32 MIDI_IN_OpenDevice(INT32 deviceIndex, MidiDeviceHandle** handle) {
-    INT32 ret;
-    TRACE0("> MIDI_IN_OpenDevice\n");
-    ret = openMidiDevice(SND_RAWMIDI_STREAM_INPUT, deviceIndex, handle);
-    TRACE1("< MIDI_IN_OpenDevice: returning %d\n", (int) ret);
-    return ret;
-}
-
-
-INT32 MIDI_IN_CloseDevice(MidiDeviceHandle* handle) {
-    INT32 ret;
-    TRACE0("> MIDI_IN_CloseDevice\n");
-    ret = closeMidiDevice(handle);
-    TRACE1("< MIDI_IN_CloseDevice: returning %d\n", (int) ret);
-    return ret;
-}
-
-
-INT32 MIDI_IN_StartDevice(MidiDeviceHandle* handle) {
-    TRACE0("MIDI_IN_StartDevice\n");
-    return MIDI_SUCCESS;
-}
-
-
-INT32 MIDI_IN_StopDevice(MidiDeviceHandle* handle) {
-    TRACE0("MIDI_IN_StopDevice\n");
-    return MIDI_SUCCESS;
-}
-
-
-INT64 MIDI_IN_GetTimeStamp(MidiDeviceHandle* handle) {
-    return getMidiTimestamp(handle);
-}
-
-
-/* read the next message from the queue */
-MidiMessage* MIDI_IN_GetMessage(MidiDeviceHandle* handle) {
-    snd_seq_event_t alsa_message;
-    MidiMessage* jdk_message;
-    int err;
-    char buffer[1];
-    int status;
-
-    TRACE0("> MIDI_IN_GetMessage\n");
-    if (!handle) {
-        ERROR0("< ERROR: MIDI_IN_GetMessage(): handle is NULL\n");
-        return NULL;
-    }
-    if (!handle->deviceHandle) {
-        ERROR0("< ERROR: MIDI_IN_GetMessage(): native handle is NULL\n");
-        return NULL;
-    }
-    if (!handle->platformData) {
-        ERROR0("< ERROR: MIDI_IN_GetMessage(): platformData is NULL\n");
-        return NULL;
-    }
-
-    /* For MIDI In, the device is left in non blocking mode. So if there is
-       no data from the device, snd_rawmidi_read() returns with -11 (EAGAIN).
-       This results in jumping back to the Java layer. */
-    while (TRUE) {
-        TRACE0("before snd_rawmidi_read()\n");
-        err = snd_rawmidi_read((snd_rawmidi_t*) handle->deviceHandle, buffer, 1);
-        TRACE0("after snd_rawmidi_read()\n");
-        if (err != 1) {
-            ERROR2("< ERROR: MIDI_IN_GetMessage(): snd_rawmidi_read() returned %d : %s\n", err, snd_strerror(err));
-            return NULL;
-        }
-        // printf("received byte: %d\n", buffer[0]);
-        err = snd_midi_event_encode_byte((snd_midi_event_t*) handle->platformData,
-                                         (int) buffer[0],
-                                         &alsa_message);
-        if (err == 1) {
-            break;
-        } else if (err < 0) {
-            ERROR1("< ERROR: MIDI_IN_GetMessage(): snd_midi_event_encode_byte() returned %d\n", err);
-            return NULL;
-        }
-    }
-    jdk_message = (MidiMessage*) calloc(sizeof(MidiMessage), 1);
-    if (!jdk_message) {
-        ERROR0("< ERROR: MIDI_IN_GetMessage(): out of memory\n");
-        return NULL;
-    }
-    // TODO: tra
-    switch (alsa_message.type) {
-    case SND_SEQ_EVENT_NOTEON:
-    case SND_SEQ_EVENT_NOTEOFF:
-    case SND_SEQ_EVENT_KEYPRESS:
-        status = (alsa_message.type == SND_SEQ_EVENT_KEYPRESS) ? 0xA0 :
-            (alsa_message.type == SND_SEQ_EVENT_NOTEON) ? 0x90 : 0x80;
-        status |= alsa_message.data.note.channel;
-        setShortMessage(jdk_message, status,
-                        alsa_message.data.note.note,
-                        alsa_message.data.note.velocity);
-        break;
-
-    case SND_SEQ_EVENT_CONTROLLER:
-        status = 0xB0 | alsa_message.data.control.channel;
-        setShortMessage(jdk_message, status,
-                        alsa_message.data.control.param,
-                        alsa_message.data.control.value);
-        break;
-
-    case SND_SEQ_EVENT_PGMCHANGE:
-    case SND_SEQ_EVENT_CHANPRESS:
-        status = (alsa_message.type == SND_SEQ_EVENT_PGMCHANGE) ? 0xC0 : 0xD0;
-        status |= alsa_message.data.control.channel;
-        setShortMessage(jdk_message, status,
-                        alsa_message.data.control.value, 0);
-        break;
-
-    case SND_SEQ_EVENT_PITCHBEND:
-        status = 0xE0 | alsa_message.data.control.channel;
-        // $$mp 2003-09-23:
-        // possible hack to work around a bug in ALSA. Necessary for
-        // ALSA 0.9.2. May be fixed in newer versions of ALSA.
-        // alsa_message.data.control.value ^= 0x2000;
-        // TRACE1("pitchbend value: %d\n", alsa_message.data.control.value);
-        set14bitMessage(jdk_message, status,
-                        alsa_message.data.control.value);
-        break;
-
-        /* System exclusive messages */
-
-    case SND_SEQ_EVENT_SYSEX:
-        jdk_message->type = LONG_MESSAGE;
-        jdk_message->data.l.size = alsa_message.data.ext.len;
-        jdk_message->data.l.data = malloc(alsa_message.data.ext.len);
-        if (jdk_message->data.l.data == NULL) {
-            ERROR0("< ERROR: MIDI_IN_GetMessage(): out of memory\n");
-            free(jdk_message);
-            jdk_message = NULL;
-        } else {
-            memcpy(jdk_message->data.l.data, alsa_message.data.ext.ptr, alsa_message.data.ext.len);
-        }
-        break;
-
-        /* System common messages */
-
-    case SND_SEQ_EVENT_QFRAME:
-        setShortMessage(jdk_message, 0xF1,
-                        alsa_message.data.control.value & 0x7F, 0);
-        break;
-
-    case SND_SEQ_EVENT_SONGPOS:
-        set14bitMessage(jdk_message, 0xF2,
-                        alsa_message.data.control.value);
-        break;
-
-    case SND_SEQ_EVENT_SONGSEL:
-        setShortMessage(jdk_message, 0xF3,
-                        alsa_message.data.control.value & 0x7F, 0);
-        break;
-
-    case SND_SEQ_EVENT_TUNE_REQUEST:
-        setRealtimeMessage(jdk_message, 0xF6);
-        break;
-
-        /* System realtime messages */
-
-    case SND_SEQ_EVENT_CLOCK:
-        setRealtimeMessage(jdk_message, 0xF8);
-        break;
-
-    case SND_SEQ_EVENT_START:
-        setRealtimeMessage(jdk_message, 0xFA);
-        break;
-
-    case SND_SEQ_EVENT_CONTINUE:
-        setRealtimeMessage(jdk_message, 0xFB);
-        break;
-
-    case SND_SEQ_EVENT_STOP:
-        setRealtimeMessage(jdk_message, 0xFC);
-        break;
-
-    case SND_SEQ_EVENT_SENSING:
-        setRealtimeMessage(jdk_message, 0xFE);
-        break;
-
-    case SND_SEQ_EVENT_RESET:
-        setRealtimeMessage(jdk_message, 0xFF);
-        break;
-
-    default:
-        ERROR0("< ERROR: MIDI_IN_GetMessage(): unhandled ALSA MIDI message type\n");
-        free(jdk_message);
-        jdk_message = NULL;
-
-    }
-
-    // set timestamp
-    if (jdk_message != NULL) {
-        jdk_message->timestamp = getMidiTimestamp(handle);
-    }
-    TRACE1("< MIDI_IN_GetMessage: returning %p\n", jdk_message);
-    return jdk_message;
-}
-
-
-void MIDI_IN_ReleaseMessage(MidiDeviceHandle* handle, MidiMessage* msg) {
-    if (!msg) {
-        ERROR0("< ERROR: MIDI_IN_ReleaseMessage(): message is NULL\n");
-        return;
-    }
-    if (msg->type == LONG_MESSAGE && msg->data.l.data) {
-        free(msg->data.l.data);
-    }
-    free(msg);
-}
-
-#endif /* USE_PLATFORM_MIDI_IN */
--- ./jdk/src/solaris/native/com/sun/media/sound/PLATFORM_API_BsdOS_ALSA_MidiOut.c	2010-03-27 11:09:14.000000000 -0700
+++ ./jdk/src/solaris/native/com/sun/media/sound/PLATFORM_API_BsdOS_ALSA_MidiOut.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,179 +0,0 @@
-/*
- * Copyright 2003-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-
-#define USE_ERROR
-#define USE_TRACE
-
-#if USE_PLATFORM_MIDI_OUT == TRUE
-
-#include <alsa/asoundlib.h>
-#include "PlatformMidi.h"
-#include "PLATFORM_API_BsdOS_ALSA_MidiUtils.h"
-
-
-
-static int CHANNEL_MESSAGE_LENGTH[] = {
-    -1, -1, -1, -1, -1, -1, -1, -1, 3, 3, 3, 3, 2, 2, 3 };
-/*                                 8x 9x Ax Bx Cx Dx Ex */
-
-static int SYSTEM_MESSAGE_LENGTH[] = {
-    -1, 2, 3, 2, -1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1 };
-/*  F0 F1 F2 F3  F4  F5 F6 F7 F8  F9 FA FB FC  FD FE FF */
-
-
-// the returned length includes the status byte.
-// for illegal messages, -1 is returned.
-static int getShortMessageLength(int status) {
-        int     dataLength = 0;
-        if (status < 0xF0) { // channel voice message
-                dataLength = CHANNEL_MESSAGE_LENGTH[(status >> 4) & 0xF];
-        } else {
-                dataLength = SYSTEM_MESSAGE_LENGTH[status & 0xF];
-        }
-        return dataLength;
-}
-
-
-/*
- * implementation of the platform-dependent
- * MIDI out functions declared in PlatformMidi.h
- */
-char* MIDI_OUT_GetErrorStr(INT32 err) {
-    return (char*) getErrorStr(err);
-}
-
-
-INT32 MIDI_OUT_GetNumDevices() {
-    TRACE0("MIDI_OUT_GetNumDevices()\n");
-    return getMidiDeviceCount(SND_RAWMIDI_STREAM_OUTPUT);
-}
-
-
-INT32 MIDI_OUT_GetDeviceName(INT32 deviceIndex, char *name, UINT32 nameLength) {
-    TRACE0("MIDI_OUT_GetDeviceName()\n");
-    return getMidiDeviceName(SND_RAWMIDI_STREAM_OUTPUT, deviceIndex,
-                             name, nameLength);
-}
-
-
-INT32 MIDI_OUT_GetDeviceVendor(INT32 deviceIndex, char *name, UINT32 nameLength) {
-    TRACE0("MIDI_OUT_GetDeviceVendor()\n");
-    return getMidiDeviceVendor(deviceIndex, name, nameLength);
-}
-
-
-INT32 MIDI_OUT_GetDeviceDescription(INT32 deviceIndex, char *name, UINT32 nameLength) {
-    TRACE0("MIDI_OUT_GetDeviceDescription()\n");
-    return getMidiDeviceDescription(SND_RAWMIDI_STREAM_OUTPUT, deviceIndex,
-                                    name, nameLength);
-}
-
-
-INT32 MIDI_OUT_GetDeviceVersion(INT32 deviceIndex, char *name, UINT32 nameLength) {
-    TRACE0("MIDI_OUT_GetDeviceVersion()\n");
-    return getMidiDeviceVersion(deviceIndex, name, nameLength);
-}
-
-
-/* *************************** MidiOutDevice implementation *************** */
-
-INT32 MIDI_OUT_OpenDevice(INT32 deviceIndex, MidiDeviceHandle** handle) {
-    TRACE1("MIDI_OUT_OpenDevice(): deviceIndex: %d\n", (int) deviceIndex);
-    return openMidiDevice(SND_RAWMIDI_STREAM_OUTPUT, deviceIndex, handle);
-}
-
-
-INT32 MIDI_OUT_CloseDevice(MidiDeviceHandle* handle) {
-    TRACE0("MIDI_OUT_CloseDevice()\n");
-    return closeMidiDevice(handle);
-}
-
-
-INT64 MIDI_OUT_GetTimeStamp(MidiDeviceHandle* handle) {
-    return getMidiTimestamp(handle);
-}
-
-
-INT32 MIDI_OUT_SendShortMessage(MidiDeviceHandle* handle, UINT32 packedMsg,
-                                UINT32 timestamp) {
-    int err;
-    int status;
-    int data1;
-    int data2;
-    char buffer[3];
-
-    TRACE2("> MIDI_OUT_SendShortMessage() %x, time: %u\n", packedMsg, (unsigned int) timestamp);
-    if (!handle) {
-        ERROR0("< ERROR: MIDI_OUT_SendShortMessage(): handle is NULL\n");
-        return MIDI_INVALID_HANDLE;
-    }
-    if (!handle->deviceHandle) {
-        ERROR0("< ERROR: MIDI_OUT_SendLongMessage(): native handle is NULL\n");
-        return MIDI_INVALID_HANDLE;
-    }
-    status = (packedMsg & 0xFF);
-    buffer[0] = (char) status;
-    buffer[1]  = (char) ((packedMsg >> 8) & 0xFF);
-    buffer[2]  = (char) ((packedMsg >> 16) & 0xFF);
-    TRACE4("status: %d, data1: %d, data2: %d, length: %d\n", (int) buffer[0], (int) buffer[1], (int) buffer[2], getShortMessageLength(status));
-    err = snd_rawmidi_write((snd_rawmidi_t*) handle->deviceHandle, buffer, getShortMessageLength(status));
-    if (err < 0) {
-        ERROR1("  ERROR: MIDI_OUT_SendShortMessage(): snd_rawmidi_write() returned %d\n", err);
-    }
-
-    TRACE0("< MIDI_OUT_SendShortMessage()\n");
-    return err;
-}
-
-
-INT32 MIDI_OUT_SendLongMessage(MidiDeviceHandle* handle, UBYTE* data,
-                               UINT32 size, UINT32 timestamp) {
-    int err;
-
-    TRACE2("> MIDI_OUT_SendLongMessage() size %u, time: %u\n", (unsigned int) size, (unsigned int) timestamp);
-    if (!handle) {
-        ERROR0("< ERROR: MIDI_OUT_SendLongMessage(): handle is NULL\n");
-        return MIDI_INVALID_HANDLE;
-    }
-    if (!handle->deviceHandle) {
-        ERROR0("< ERROR: MIDI_OUT_SendLongMessage(): native handle is NULL\n");
-        return MIDI_INVALID_HANDLE;
-    }
-    if (!data) {
-        ERROR0("< ERROR: MIDI_OUT_SendLongMessage(): data is NULL\n");
-        return MIDI_INVALID_HANDLE;
-    }
-    err = snd_rawmidi_write((snd_rawmidi_t*) handle->deviceHandle,
-                            data, size);
-    if (err < 0) {
-        ERROR1("  ERROR: MIDI_OUT_SendLongMessage(): snd_rawmidi_write() returned %d\n", err);
-    }
-
-    TRACE0("< MIDI_OUT_SendLongMessage()\n");
-    return err;
-}
-
-
-#endif /* USE_PLATFORM_MIDI_OUT */
--- ./jdk/src/solaris/native/com/sun/media/sound/PLATFORM_API_BsdOS_ALSA_MidiUtils.c	2010-03-27 11:09:14.000000000 -0700
+++ ./jdk/src/solaris/native/com/sun/media/sound/PLATFORM_API_BsdOS_ALSA_MidiUtils.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,480 +0,0 @@
-/*
- * Copyright 2003-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-
-#define USE_ERROR
-#define USE_TRACE
-
-#include "PLATFORM_API_BsdOS_ALSA_MidiUtils.h"
-#include "PLATFORM_API_BsdOS_ALSA_CommonUtils.h"
-#include <string.h>
-#include <sys/time.h>
-
-static INT64 getTimeInMicroseconds() {
-    struct timeval tv;
-
-    gettimeofday(&tv, NULL);
-    return (tv.tv_sec * 1000000UL) + tv.tv_usec;
-}
-
-
-const char* getErrorStr(INT32 err) {
-        return snd_strerror((int) err);
-}
-
-
-
-// callback for iteration through devices
-// returns TRUE if iteration should continue
-typedef int (*DeviceIteratorPtr)(UINT32 deviceID,
-                                 snd_rawmidi_info_t* rawmidi_info,
-                                 snd_ctl_card_info_t* cardinfo,
-                                 void *userData);
-
-// for each ALSA device, call iterator. userData is passed to the iterator
-// returns total number of iterations
-static int iterateRawmidiDevices(snd_rawmidi_stream_t direction,
-                                 DeviceIteratorPtr iterator,
-                                 void* userData) {
-    int count = 0;
-    int subdeviceCount;
-    int card, dev, subDev;
-    char devname[16];
-    int err;
-    snd_ctl_t *handle;
-    snd_rawmidi_t *rawmidi;
-    snd_rawmidi_info_t *rawmidi_info;
-    snd_ctl_card_info_t *card_info, *defcardinfo = NULL;
-    UINT32 deviceID;
-    int doContinue = TRUE;
-
-    snd_rawmidi_info_malloc(&rawmidi_info);
-    snd_ctl_card_info_malloc(&card_info);
-
-    // 1st try "default" device
-    if (direction == SND_RAWMIDI_STREAM_INPUT) {
-        err = snd_rawmidi_open(&rawmidi, NULL, ALSA_DEFAULT_DEVICE_NAME,
-                               SND_RAWMIDI_NONBLOCK);
-    } else if (direction == SND_RAWMIDI_STREAM_OUTPUT) {
-        err = snd_rawmidi_open(NULL, &rawmidi, ALSA_DEFAULT_DEVICE_NAME,
-                               SND_RAWMIDI_NONBLOCK);
-    } else {
-        ERROR0("ERROR: iterateRawmidiDevices(): direction is neither"
-               " SND_RAWMIDI_STREAM_INPUT nor SND_RAWMIDI_STREAM_OUTPUT\n");
-        err = MIDI_INVALID_ARGUMENT;
-    }
-    if (err < 0) {
-        ERROR1("ERROR: snd_rawmidi_open (\"default\"): %s\n",
-               snd_strerror(err));
-    } else {
-        err = snd_rawmidi_info(rawmidi, rawmidi_info);
-
-        snd_rawmidi_close(rawmidi);
-        if (err < 0) {
-            ERROR1("ERROR: snd_rawmidi_info (\"default\"): %s\n",
-                    snd_strerror(err));
-        } else {
-            // try to get card info
-            card = snd_rawmidi_info_get_card(rawmidi_info);
-            if (card >= 0) {
-                sprintf(devname, ALSA_HARDWARE_CARD, card);
-                if (snd_ctl_open(&handle, devname, SND_CTL_NONBLOCK) >= 0) {
-                    if (snd_ctl_card_info(handle, card_info) >= 0) {
-                        defcardinfo = card_info;
-                    }
-                    snd_ctl_close(handle);
-                }
-            }
-            // call calback function for the device
-            if (iterator != NULL) {
-                doContinue = (*iterator)(ALSA_DEFAULT_DEVICE_ID, rawmidi_info,
-                                         defcardinfo, userData);
-            }
-            count++;
-        }
-    }
-
-    // iterate cards
-    card = -1;
-    TRACE0("testing for cards...\n");
-    if (snd_card_next(&card) >= 0) {
-        TRACE1("Found card %d\n", card);
-        while (doContinue && (card >= 0)) {
-            sprintf(devname, ALSA_HARDWARE_CARD, card);
-            TRACE1("Opening control for alsa rawmidi device \"%s\"...\n", devname);
-            err = snd_ctl_open(&handle, devname, SND_CTL_NONBLOCK);
-            if (err < 0) {
-                ERROR2("ERROR: snd_ctl_open, card=%d: %s\n", card, snd_strerror(err));
-            } else {
-                TRACE0("snd_ctl_open() SUCCESS\n");
-                err = snd_ctl_card_info(handle, card_info);
-                if (err < 0) {
-                    ERROR2("ERROR: snd_ctl_card_info, card=%d: %s\n", card, snd_strerror(err));
-                } else {
-                    TRACE0("snd_ctl_card_info() SUCCESS\n");
-                    dev = -1;
-                    while (doContinue) {
-                        if (snd_ctl_rawmidi_next_device(handle, &dev) < 0) {
-                            ERROR0("snd_ctl_rawmidi_next_device\n");
-                        }
-                        TRACE0("snd_ctl_rawmidi_next_device() SUCCESS\n");
-                        if (dev < 0) {
-                            break;
-                        }
-                        snd_rawmidi_info_set_device(rawmidi_info, dev);
-                        snd_rawmidi_info_set_subdevice(rawmidi_info, 0);
-                        snd_rawmidi_info_set_stream(rawmidi_info, direction);
-                        err = snd_ctl_rawmidi_info(handle, rawmidi_info);
-                        TRACE0("after snd_ctl_rawmidi_info()\n");
-                        if (err < 0) {
-                            if (err != -ENOENT) {
-                                ERROR2("ERROR: snd_ctl_rawmidi_info, card=%d: %s", card, snd_strerror(err));
-                            }
-                        } else {
-                            TRACE0("snd_ctl_rawmidi_info() SUCCESS\n");
-                            subdeviceCount = needEnumerateSubdevices(ALSA_RAWMIDI)
-                                ? snd_rawmidi_info_get_subdevices_count(rawmidi_info)
-                                : 1;
-                            if (iterator!=NULL) {
-                                for (subDev = 0; subDev < subdeviceCount; subDev++) {
-                                    TRACE3("  Iterating %d,%d,%d\n", card, dev, subDev);
-                                    deviceID = encodeDeviceID(card, dev, subDev);
-                                    doContinue = (*iterator)(deviceID, rawmidi_info,
-                                                             card_info, userData);
-                                    count++;
-                                    TRACE0("returned from iterator\n");
-                                    if (!doContinue) {
-                                        break;
-                                    }
-                                }
-                            } else {
-                                count += subdeviceCount;
-                            }
-                        }
-                    } // of while(doContinue)
-                }
-                snd_ctl_close(handle);
-            }
-            if (snd_card_next(&card) < 0) {
-                break;
-            }
-        }
-    } else {
-        ERROR0("No cards found!\n");
-    }
-    snd_ctl_card_info_free(card_info);
-    snd_rawmidi_info_free(rawmidi_info);
-    return count;
-}
-
-
-
-int getMidiDeviceCount(snd_rawmidi_stream_t direction) {
-    int deviceCount;
-    TRACE0("> getMidiDeviceCount()\n");
-    initAlsaSupport();
-    deviceCount = iterateRawmidiDevices(direction, NULL, NULL);
-    TRACE0("< getMidiDeviceCount()\n");
-    return deviceCount;
-}
-
-
-
-/*
-  userData is assumed to be a pointer to ALSA_MIDIDeviceDescription.
-  ALSA_MIDIDeviceDescription->index has to be set to the index of the device
-  we want to get information of before this method is called the first time via
-  iterateRawmidiDevices(). On each call of this method,
-  ALSA_MIDIDeviceDescription->index is decremented. If it is equal to zero,
-  we have reached the desired device, so action is taken.
-  So after successful completion of iterateRawmidiDevices(),
-  ALSA_MIDIDeviceDescription->index is zero. If it isn't, this is an
-  indication of an error.
-*/
-static int deviceInfoIterator(UINT32 deviceID, snd_rawmidi_info_t *rawmidi_info,
-                              snd_ctl_card_info_t *cardinfo, void *userData) {
-    char buffer[300];
-    ALSA_MIDIDeviceDescription* desc = (ALSA_MIDIDeviceDescription*)userData;
-#ifdef ALSA_MIDI_USE_PLUGHW
-    int usePlugHw = 1;
-#else
-    int usePlugHw = 0;
-#endif
-
-    TRACE0("deviceInfoIterator\n");
-    initAlsaSupport();
-    if (desc->index == 0) {
-        // we found the device with correct index
-        desc->deviceID = deviceID;
-
-        buffer[0]=' '; buffer[1]='[';
-        getDeviceStringFromDeviceID(&buffer[2], deviceID, usePlugHw, ALSA_RAWMIDI);
-        strcat(buffer, "]");
-        strncpy(desc->name,
-                (cardinfo != NULL)
-                    ? snd_ctl_card_info_get_id(cardinfo)
-                    : snd_rawmidi_info_get_id(rawmidi_info),
-                desc->strLen - strlen(buffer));
-        strncat(desc->name, buffer, desc->strLen - strlen(desc->name));
-        desc->description[0] = 0;
-        if (cardinfo != NULL) {
-            strncpy(desc->description, snd_ctl_card_info_get_name(cardinfo),
-                    desc->strLen);
-            strncat(desc->description, ", ",
-                    desc->strLen - strlen(desc->description));
-        }
-        strncat(desc->description, snd_rawmidi_info_get_id(rawmidi_info),
-                desc->strLen - strlen(desc->description));
-        strncat(desc->description, ", ", desc->strLen - strlen(desc->description));
-        strncat(desc->description, snd_rawmidi_info_get_name(rawmidi_info),
-                desc->strLen - strlen(desc->description));
-        TRACE2("Returning %s, %s\n", desc->name, desc->description);
-        return FALSE; // do not continue iteration
-    }
-    desc->index--;
-    return TRUE;
-}
-
-
-static int getMIDIDeviceDescriptionByIndex(snd_rawmidi_stream_t direction,
-                                           ALSA_MIDIDeviceDescription* desc) {
-    initAlsaSupport();
-    TRACE1(" getMIDIDeviceDescriptionByIndex (index = %d)\n", desc->index);
-    iterateRawmidiDevices(direction, &deviceInfoIterator, desc);
-    return (desc->index == 0) ? MIDI_SUCCESS : MIDI_INVALID_DEVICEID;
-}
-
-
-
-int initMIDIDeviceDescription(ALSA_MIDIDeviceDescription* desc, int index) {
-    int ret = MIDI_SUCCESS;
-    desc->index = index;
-    desc->strLen = 200;
-    desc->name = (char*) calloc(desc->strLen + 1, 1);
-    desc->description = (char*) calloc(desc->strLen + 1, 1);
-    if (! desc->name ||
-        ! desc->description) {
-        ret = MIDI_OUT_OF_MEMORY;
-    }
-    return ret;
-}
-
-
-void freeMIDIDeviceDescription(ALSA_MIDIDeviceDescription* desc) {
-    if (desc->name) {
-        free(desc->name);
-    }
-    if (desc->description) {
-        free(desc->description);
-    }
-}
-
-
-int getMidiDeviceName(snd_rawmidi_stream_t direction, int index, char *name,
-                      UINT32 nameLength) {
-    ALSA_MIDIDeviceDescription desc;
-    int ret;
-
-    TRACE1("getMidiDeviceName: nameLength: %d\n", (int) nameLength);
-    ret = initMIDIDeviceDescription(&desc, index);
-    if (ret == MIDI_SUCCESS) {
-        TRACE0("getMidiDeviceName: initMIDIDeviceDescription() SUCCESS\n");
-        ret = getMIDIDeviceDescriptionByIndex(direction, &desc);
-        if (ret == MIDI_SUCCESS) {
-            TRACE1("getMidiDeviceName: desc.name: %s\n", desc.name);
-            strncpy(name, desc.name, nameLength - 1);
-            name[nameLength - 1] = 0;
-        }
-    }
-    freeMIDIDeviceDescription(&desc);
-    return ret;
-}
-
-
-int getMidiDeviceVendor(int index, char *name, UINT32 nameLength) {
-    strncpy(name, ALSA_VENDOR, nameLength - 1);
-    name[nameLength - 1] = 0;
-    return MIDI_SUCCESS;
-}
-
-
-int getMidiDeviceDescription(snd_rawmidi_stream_t direction,
-                             int index, char *name, UINT32 nameLength) {
-    ALSA_MIDIDeviceDescription desc;
-    int ret;
-
-    ret = initMIDIDeviceDescription(&desc, index);
-    if (ret == MIDI_SUCCESS) {
-        ret = getMIDIDeviceDescriptionByIndex(direction, &desc);
-        if (ret == MIDI_SUCCESS) {
-            strncpy(name, desc.description, nameLength - 1);
-            name[nameLength - 1] = 0;
-        }
-    }
-    freeMIDIDeviceDescription(&desc);
-    return ret;
-}
-
-
-int getMidiDeviceVersion(int index, char *name, UINT32 nameLength) {
-    getALSAVersion(name, nameLength);
-    return MIDI_SUCCESS;
-}
-
-
-static int getMidiDeviceID(snd_rawmidi_stream_t direction, int index,
-                           UINT32* deviceID) {
-    ALSA_MIDIDeviceDescription desc;
-    int ret;
-
-    ret = initMIDIDeviceDescription(&desc, index);
-    if (ret == MIDI_SUCCESS) {
-        ret = getMIDIDeviceDescriptionByIndex(direction, &desc);
-        if (ret == MIDI_SUCCESS) {
-            // TRACE1("getMidiDeviceName: desc.name: %s\n", desc.name);
-            *deviceID = desc.deviceID;
-        }
-    }
-    freeMIDIDeviceDescription(&desc);
-    return ret;
-}
-
-
-/*
-  direction has to be either SND_RAWMIDI_STREAM_INPUT or
-  SND_RAWMIDI_STREAM_OUTPUT.
-  Returns 0 on success. Otherwise, MIDI_OUT_OF_MEMORY, MIDI_INVALID_ARGUMENT
-   or a negative ALSA error code is returned.
-*/
-INT32 openMidiDevice(snd_rawmidi_stream_t direction, INT32 deviceIndex,
-                     MidiDeviceHandle** handle) {
-    snd_rawmidi_t* native_handle;
-    snd_midi_event_t* event_parser = NULL;
-    int err;
-    UINT32 deviceID;
-    char devicename[100];
-#ifdef ALSA_MIDI_USE_PLUGHW
-    int usePlugHw = 1;
-#else
-    int usePlugHw = 0;
-#endif
-
-    TRACE0("> openMidiDevice()\n");
-
-    (*handle) = (MidiDeviceHandle*) calloc(sizeof(MidiDeviceHandle), 1);
-    if (!(*handle)) {
-        ERROR0("ERROR: openDevice: out of memory\n");
-        return MIDI_OUT_OF_MEMORY;
-    }
-
-    // TODO: iterate to get dev ID from index
-    err = getMidiDeviceID(direction, deviceIndex, &deviceID);
-    TRACE1("  openMidiDevice(): deviceID: %d\n", (int) deviceID);
-    getDeviceStringFromDeviceID(devicename, deviceID,
-                                usePlugHw, ALSA_RAWMIDI);
-    TRACE1("  openMidiDevice(): deviceString: %s\n", devicename);
-
-    // finally open the device
-    if (direction == SND_RAWMIDI_STREAM_INPUT) {
-        err = snd_rawmidi_open(&native_handle, NULL, devicename,
-                               SND_RAWMIDI_NONBLOCK);
-    } else if (direction == SND_RAWMIDI_STREAM_OUTPUT) {
-        err = snd_rawmidi_open(NULL, &native_handle, devicename,
-                               SND_RAWMIDI_NONBLOCK);
-    } else {
-        ERROR0("  ERROR: openMidiDevice(): direction is neither SND_RAWMIDI_STREAM_INPUT nor SND_RAWMIDI_STREAM_OUTPUT\n");
-        err = MIDI_INVALID_ARGUMENT;
-    }
-    if (err < 0) {
-        ERROR1("<  ERROR: openMidiDevice(): snd_rawmidi_open() returned %d\n", err);
-        free(*handle);
-        (*handle) = NULL;
-        return err;
-    }
-    /* We opened with non-blocking behaviour to not get hung if the device
-       is used by a different process. Writing, however, should
-       be blocking. So we change it here. */
-    if (direction == SND_RAWMIDI_STREAM_OUTPUT) {
-        err = snd_rawmidi_nonblock(native_handle, 0);
-        if (err < 0) {
-            ERROR1("  ERROR: openMidiDevice(): snd_rawmidi_nonblock() returned %d\n", err);
-            snd_rawmidi_close(native_handle);
-            free(*handle);
-            (*handle) = NULL;
-            return err;
-        }
-    }
-    if (direction == SND_RAWMIDI_STREAM_INPUT) {
-        err = snd_midi_event_new(EVENT_PARSER_BUFSIZE, &event_parser);
-        if (err < 0) {
-            ERROR1("  ERROR: openMidiDevice(): snd_midi_event_new() returned %d\n", err);
-            snd_rawmidi_close(native_handle);
-            free(*handle);
-            (*handle) = NULL;
-            return err;
-        }
-    }
-
-    (*handle)->deviceHandle = (void*) native_handle;
-    (*handle)->startTime = getTimeInMicroseconds();
-    (*handle)->platformData = event_parser;
-    TRACE0("< openMidiDevice(): succeeded\n");
-    return err;
-}
-
-
-
-INT32 closeMidiDevice(MidiDeviceHandle* handle) {
-    int err;
-
-    TRACE0("> closeMidiDevice()\n");
-    if (!handle) {
-        ERROR0("< ERROR: closeMidiDevice(): handle is NULL\n");
-        return MIDI_INVALID_HANDLE;
-    }
-    if (!handle->deviceHandle) {
-        ERROR0("< ERROR: closeMidiDevice(): native handle is NULL\n");
-        return MIDI_INVALID_HANDLE;
-    }
-    err = snd_rawmidi_close((snd_rawmidi_t*) handle->deviceHandle);
-    TRACE1("  snd_rawmidi_close() returns %d\n", err);
-    if (handle->platformData) {
-        snd_midi_event_free((snd_midi_event_t*) handle->platformData);
-    }
-    free(handle);
-    TRACE0("< closeMidiDevice: succeeded\n");
-    return err;
-}
-
-
-INT64 getMidiTimestamp(MidiDeviceHandle* handle) {
-    if (!handle) {
-        ERROR0("< ERROR: closeMidiDevice(): handle is NULL\n");
-        return MIDI_INVALID_HANDLE;
-    }
-    return getTimeInMicroseconds() - handle->startTime;
-}
-
-
-/* end */
--- ./jdk/src/solaris/native/com/sun/media/sound/PLATFORM_API_BsdOS_ALSA_MidiUtils.h	2010-03-27 11:09:14.000000000 -0700
+++ ./jdk/src/solaris/native/com/sun/media/sound/PLATFORM_API_BsdOS_ALSA_MidiUtils.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,85 +0,0 @@
-/*
- * Copyright 2003-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-
-#include <alsa/asoundlib.h>
-#include "Utilities.h"
-#include "PlatformMidi.h"
-
-
-#ifndef PLATFORM_API_BSDOS_ALSA_MIDIUTILS_H_INCLUDED
-#define PLATFORM_API_BSDOS_ALSA_MIDIUTILS_H_INCLUDED
-
-#define EVENT_PARSER_BUFSIZE (2048)
-
-// if this is defined, use plughw: devices
-//#define ALSA_MIDI_USE_PLUGHW
-#undef ALSA_MIDI_USE_PLUGHW
-
-typedef struct tag_ALSA_MIDIDeviceDescription {
-        int index;          // in
-        int strLen;         // in
-        INT32 deviceID;    // out
-        char* name;         // out
-        char* description;  // out
-} ALSA_MIDIDeviceDescription;
-
-
-const char* getErrorStr(INT32 err);
-
-/* Returns the number of devices. */
-/* direction is either SND_RAWMIDI_STREAM_OUTPUT or
-   SND_RAWMIDI_STREAM_INPUT. */
-int getMidiDeviceCount(snd_rawmidi_stream_t direction);
-
-/* Returns MIDI_SUCCESS or MIDI_INVALID_DEVICEID */
-/* direction is either SND_RAWMIDI_STREAM_OUTPUT or
-   SND_RAWMIDI_STREAM_INPUT. */
-int getMidiDeviceName(snd_rawmidi_stream_t direction, int index,
-                      char *name, UINT32 nameLength);
-
-/* Returns MIDI_SUCCESS or MIDI_INVALID_DEVICEID */
-int getMidiDeviceVendor(int index, char *name, UINT32 nameLength);
-
-/* Returns MIDI_SUCCESS or MIDI_INVALID_DEVICEID */
-/* direction is either SND_RAWMIDI_STREAM_OUTPUT or
-   SND_RAWMIDI_STREAM_INPUT. */
-int getMidiDeviceDescription(snd_rawmidi_stream_t direction, int index,
-                             char *name, UINT32 nameLength);
-
-/* Returns MIDI_SUCCESS or MIDI_INVALID_DEVICEID */
-int getMidiDeviceVersion(int index, char *name, UINT32 nameLength);
-
-// returns 0 on success, otherwise MIDI_OUT_OF_MEMORY or ALSA error code
-/* direction is either SND_RAWMIDI_STREAM_OUTPUT or
-   SND_RAWMIDI_STREAM_INPUT. */
-INT32 openMidiDevice(snd_rawmidi_stream_t direction, INT32 deviceIndex,
-                     MidiDeviceHandle** handle);
-
-// returns 0 on success, otherwise a (negative) ALSA error code
-INT32 closeMidiDevice(MidiDeviceHandle* handle);
-
-INT64 getMidiTimestamp(MidiDeviceHandle* handle);
-
-#endif // PLATFORM_API_BSDOS_ALSA_MIDIUTILS_H_INCLUDED
--- ./jdk/src/solaris/native/com/sun/media/sound/PLATFORM_API_BsdOS_ALSA_PCM.c	2010-03-27 11:09:14.000000000 -0700
+++ ./jdk/src/solaris/native/com/sun/media/sound/PLATFORM_API_BsdOS_ALSA_PCM.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,938 +0,0 @@
-/*
- * Copyright 2002-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-
-#define USE_ERROR
-#define USE_TRACE
-
-#include "PLATFORM_API_BsdOS_ALSA_PCMUtils.h"
-#include "PLATFORM_API_BsdOS_ALSA_CommonUtils.h"
-#include "DirectAudio.h"
-
-#if USE_DAUDIO == TRUE
-
-// GetPosition method 1: based on how many bytes are passed to the kernel driver
-//                       + does not need much processor resources
-//                       - not very exact, "jumps"
-// GetPosition method 2: ask kernel about actual position of playback.
-//                       - very exact
-//                       - switch to kernel layer for each call
-// GetPosition method 3: use snd_pcm_avail() call - not yet in official ALSA
-// quick tests on a Pentium 200MMX showed max. 1.5% processor usage
-// for playing back a CD-quality file and printing 20x per second a line
-// on the console with the current time. So I guess performance is not such a
-// factor here.
-//#define GET_POSITION_METHOD1
-#define GET_POSITION_METHOD2
-
-
-// The default time for a period in microseconds.
-// For very small buffers, only 2 periods are used.
-#define DEFAULT_PERIOD_TIME 20000 /* 20ms */
-
-///// implemented functions of DirectAudio.h
-
-INT32 DAUDIO_GetDirectAudioDeviceCount() {
-    return (INT32) getAudioDeviceCount();
-}
-
-
-INT32 DAUDIO_GetDirectAudioDeviceDescription(INT32 mixerIndex, DirectAudioDeviceDescription* description) {
-    ALSA_AudioDeviceDescription adesc;
-
-    adesc.index = (int) mixerIndex;
-    adesc.strLen = DAUDIO_STRING_LENGTH;
-
-    adesc.maxSimultaneousLines = (int*) (&(description->maxSimulLines));
-    adesc.deviceID = &(description->deviceID);
-    adesc.name = description->name;
-    adesc.vendor = description->vendor;
-    adesc.description = description->description;
-    adesc.version = description->version;
-
-    return getAudioDeviceDescriptionByIndex(&adesc);
-}
-
-#define MAX_BIT_INDEX 6
-// returns
-// 6: for anything above 24-bit
-// 5: for 4 bytes sample size, 24-bit
-// 4: for 3 bytes sample size, 24-bit
-// 3: for 3 bytes sample size, 20-bit
-// 2: for 2 bytes sample size, 16-bit
-// 1: for 1 byte sample size, 8-bit
-// 0: for anything else
-int getBitIndex(int sampleSizeInBytes, int significantBits) {
-    if (significantBits > 24) return 6;
-    if (sampleSizeInBytes == 4 && significantBits == 24) return 5;
-    if (sampleSizeInBytes == 3) {
-        if (significantBits == 24) return 4;
-        if (significantBits == 20) return 3;
-    }
-    if (sampleSizeInBytes == 2 && significantBits == 16) return 2;
-    if (sampleSizeInBytes == 1 && significantBits == 8) return 1;
-    return 0;
-}
-
-int getSampleSizeInBytes(int bitIndex, int sampleSizeInBytes) {
-    switch(bitIndex) {
-    case 1: return 1;
-    case 2: return 2;
-    case 3: /* fall through */
-    case 4: return 3;
-    case 5: return 4;
-    }
-    return sampleSizeInBytes;
-}
-
-int getSignificantBits(int bitIndex, int significantBits) {
-    switch(bitIndex) {
-    case 1: return 8;
-    case 2: return 16;
-    case 3: return 20;
-    case 4: /* fall through */
-    case 5: return 24;
-    }
-    return significantBits;
-}
-
-void DAUDIO_GetFormats(INT32 mixerIndex, INT32 deviceID, int isSource, void* creator) {
-    snd_pcm_t* handle;
-    snd_pcm_format_mask_t* formatMask;
-    snd_pcm_format_t format;
-    snd_pcm_hw_params_t* hwParams;
-    int handledBits[MAX_BIT_INDEX+1];
-
-    int ret;
-    int sampleSizeInBytes, significantBits, isSigned, isBigEndian, enc;
-    int origSampleSizeInBytes, origSignificantBits;
-    int channels, minChannels, maxChannels;
-    int rate, bitIndex;
-
-    for (bitIndex = 0; bitIndex <= MAX_BIT_INDEX; bitIndex++) handledBits[bitIndex] = FALSE;
-    if (openPCMfromDeviceID(deviceID, &handle, isSource, TRUE /*query hardware*/) < 0) {
-        return;
-    }
-    ret = snd_pcm_format_mask_malloc(&formatMask);
-    if (ret != 0) {
-        ERROR1("snd_pcm_format_mask_malloc returned error %d\n", ret);
-    } else {
-        ret = snd_pcm_hw_params_malloc(&hwParams);
-        if (ret != 0) {
-            ERROR1("snd_pcm_hw_params_malloc returned error %d\n", ret);
-        } else {
-            ret = snd_pcm_hw_params_any(handle, hwParams);
-            /* snd_pcm_hw_params_any can return a positive value on success too */
-            if (ret < 0) {
-                 ERROR1("snd_pcm_hw_params_any returned error %d\n", ret);
-            } else {
-                /* for the logic following this code, set ret to 0 to indicate success */
-                ret = 0;
-            }
-        }
-        snd_pcm_hw_params_get_format_mask(hwParams, formatMask);
-#ifdef ALSA_PCM_NEW_HW_PARAMS_API
-        if (ret == 0) {
-            ret = snd_pcm_hw_params_get_channels_min(hwParams, &minChannels);
-            if (ret != 0) {
-                ERROR1("snd_pcm_hw_params_get_channels_min returned error %d\n", ret);
-            }
-        }
-        if (ret == 0) {
-            ret = snd_pcm_hw_params_get_channels_max(hwParams, &maxChannels);
-            if (ret != 0) {
-                ERROR1("snd_pcm_hw_params_get_channels_max returned error %d\n", ret);
-            }
-        }
-#else
-        minChannels = snd_pcm_hw_params_get_channels_min(hwParams);
-        maxChannels = snd_pcm_hw_params_get_channels_max(hwParams);
-        if (minChannels > maxChannels) {
-            ERROR2("MinChannels=%d, maxChannels=%d\n", minChannels, maxChannels);
-        }
-#endif
-
-        // since we queried the hw: device, for many soundcards, it will only
-        // report the maximum number of channels (which is the only way to talk
-        // to the hw: device). Since we will, however, open the plughw: device
-        // when opening the Source/TargetDataLine, we can safely assume that
-        // also the channels 1..maxChannels are available.
-#ifdef ALSA_PCM_USE_PLUGHW
-        minChannels = 1;
-#endif
-        if (ret == 0) {
-            // plughw: supports any sample rate
-            rate = -1;
-            for (format = 0; format <= SND_PCM_FORMAT_LAST; format++) {
-                if (snd_pcm_format_mask_test(formatMask, format)) {
-                    // format exists
-                    if (getFormatFromAlsaFormat(format, &origSampleSizeInBytes,
-                                                &origSignificantBits,
-                                                &isSigned, &isBigEndian, &enc)) {
-                        // now if we use plughw:, we can use any bit size below the
-                        // natively supported ones. Some ALSA drivers only support the maximum
-                        // bit size, so we add any sample rates below the reported one.
-                        // E.g. this iteration reports support for 16-bit.
-                        // getBitIndex will return 2, so it will add entries for
-                        // 16-bit (bitIndex=2) and in the next do-while loop iteration,
-                        // it will decrease bitIndex and will therefore add 8-bit support.
-                        bitIndex = getBitIndex(origSampleSizeInBytes, origSignificantBits);
-                        do {
-                            if (bitIndex == 0
-                                || bitIndex == MAX_BIT_INDEX
-                                || !handledBits[bitIndex]) {
-                                handledBits[bitIndex] = TRUE;
-                                sampleSizeInBytes = getSampleSizeInBytes(bitIndex, origSampleSizeInBytes);
-                                significantBits = getSignificantBits(bitIndex, origSignificantBits);
-                                if (maxChannels - minChannels > MAXIMUM_LISTED_CHANNELS) {
-                                    // avoid too many channels explicitly listed
-                                    // just add -1, min, and max
-                                    DAUDIO_AddAudioFormat(creator, significantBits,
-                                                          -1, -1, rate,
-                                                          enc, isSigned, isBigEndian);
-                                    DAUDIO_AddAudioFormat(creator, significantBits,
-                                                          sampleSizeInBytes * minChannels,
-                                                          minChannels, rate,
-                                                          enc, isSigned, isBigEndian);
-                                    DAUDIO_AddAudioFormat(creator, significantBits,
-                                                          sampleSizeInBytes * maxChannels,
-                                                          maxChannels, rate,
-                                                          enc, isSigned, isBigEndian);
-                                } else {
-                                    for (channels = minChannels; channels <= maxChannels; channels++) {
-                                        DAUDIO_AddAudioFormat(creator, significantBits,
-                                                              (channels < 0)?-1:(sampleSizeInBytes * channels),
-                                                              channels, rate,
-                                                              enc, isSigned, isBigEndian);
-                                    }
-                                }
-                            }
-#ifndef ALSA_PCM_USE_PLUGHW
-                            // without plugin, do not add fake formats
-                            break;
-#endif
-                        } while (--bitIndex > 0);
-                    } else {
-                        TRACE1("could not get format from alsa for format %d\n", format);
-                    }
-                } else {
-                    //TRACE1("Format %d not supported\n", format);
-                }
-            } // for loop
-            snd_pcm_hw_params_free(hwParams);
-        }
-        snd_pcm_format_mask_free(formatMask);
-    }
-    snd_pcm_close(handle);
-}
-
-/* ******* ALSA PCM INFO ******************** */
-typedef struct tag_AlsaPcmInfo {
-    snd_pcm_t* handle;
-    snd_pcm_hw_params_t* hwParams;
-    snd_pcm_sw_params_t* swParams;
-    int bufferSizeInBytes;
-    int frameSize; // storage size in Bytes
-    int periods;
-    snd_pcm_uframes_t periodSize;
-#ifdef GET_POSITION_METHOD2
-    // to be used exclusively by getBytePosition!
-    snd_pcm_status_t* positionStatus;
-#endif
-} AlsaPcmInfo;
-
-
-int setStartThresholdNoCommit(AlsaPcmInfo* info, int useThreshold) {
-    int ret;
-    int threshold;
-
-    if (useThreshold) {
-        // start device whenever anything is written to the buffer
-        threshold = 1;
-    } else {
-        // never start the device automatically
-        threshold = 2000000000; /* near UINT_MAX */
-    }
-    ret = snd_pcm_sw_params_set_start_threshold(info->handle, info->swParams, threshold);
-    if (ret < 0) {
-        ERROR1("Unable to set start threshold mode: %s\n", snd_strerror(ret));
-        return FALSE;
-    }
-    return TRUE;
-}
-
-int setStartThreshold(AlsaPcmInfo* info, int useThreshold) {
-    int ret = 0;
-
-    if (!setStartThresholdNoCommit(info, useThreshold)) {
-        ret = -1;
-    }
-    if (ret == 0) {
-        // commit it
-        ret = snd_pcm_sw_params(info->handle, info->swParams);
-        if (ret < 0) {
-            ERROR1("Unable to set sw params: %s\n", snd_strerror(ret));
-        }
-    }
-    return (ret == 0)?TRUE:FALSE;
-}
-
-
-// returns TRUE if successful
-int setHWParams(AlsaPcmInfo* info,
-                float sampleRate,
-                int channels,
-                int bufferSizeInFrames,
-                snd_pcm_format_t format) {
-    unsigned int rrate;
-    int ret, dir, periods, periodTime;
-    snd_pcm_uframes_t alsaBufferSizeInFrames = (snd_pcm_uframes_t) bufferSizeInFrames;
-
-    /* choose all parameters */
-    ret = snd_pcm_hw_params_any(info->handle, info->hwParams);
-    if (ret < 0) {
-        ERROR1("Broken configuration: no configurations available: %s\n", snd_strerror(ret));
-        return FALSE;
-    }
-    /* set the interleaved read/write format */
-    ret = snd_pcm_hw_params_set_access(info->handle, info->hwParams, SND_PCM_ACCESS_RW_INTERLEAVED);
-    if (ret < 0) {
-        ERROR1("SND_PCM_ACCESS_RW_INTERLEAVED access type not available: %s\n", snd_strerror(ret));
-        return FALSE;
-    }
-    /* set the sample format */
-    ret = snd_pcm_hw_params_set_format(info->handle, info->hwParams, format);
-    if (ret < 0) {
-        ERROR1("Sample format not available: %s\n", snd_strerror(ret));
-        return FALSE;
-    }
-    /* set the count of channels */
-    ret = snd_pcm_hw_params_set_channels(info->handle, info->hwParams, channels);
-    if (ret < 0) {
-        ERROR2("Channels count (%d) not available: %s\n", channels, snd_strerror(ret));
-        return FALSE;
-    }
-    /* set the stream rate */
-    rrate = (int) (sampleRate + 0.5f);
-#ifdef ALSA_PCM_NEW_HW_PARAMS_API
-    dir = 0;
-    ret = snd_pcm_hw_params_set_rate_near(info->handle, info->hwParams, &rrate, &dir);
-#else
-    ret = snd_pcm_hw_params_set_rate_near(info->handle, info->hwParams, rrate, 0);
-#endif
-    if (ret < 0) {
-        ERROR2("Rate %dHz not available for playback: %s\n", (int) (sampleRate+0.5f), snd_strerror(ret));
-        return FALSE;
-    }
-    if ((rrate-sampleRate > 2) || (rrate-sampleRate < - 2)) {
-        ERROR2("Rate doesn't match (requested %2.2fHz, got %dHz)\n", sampleRate, rrate);
-        return FALSE;
-    }
-    /* set the buffer time */
-#ifdef ALSA_PCM_NEW_HW_PARAMS_API
-
-    ret = snd_pcm_hw_params_set_buffer_size_near(info->handle, info->hwParams, &alsaBufferSizeInFrames);
-#else
-    ret = snd_pcm_hw_params_set_buffer_size_near(info->handle, info->hwParams, alsaBufferSizeInFrames);
-#endif
-    if (ret < 0) {
-        ERROR2("Unable to set buffer size to %d frames: %s\n",
-               (int) alsaBufferSizeInFrames, snd_strerror(ret));
-        return FALSE;
-    }
-    bufferSizeInFrames = (int) alsaBufferSizeInFrames;
-    /* set the period time */
-    if (bufferSizeInFrames > 1024) {
-        dir = 0;
-        periodTime = DEFAULT_PERIOD_TIME;
-#ifdef ALSA_PCM_NEW_HW_PARAMS_API
-        ret = snd_pcm_hw_params_set_period_time_near(info->handle, info->hwParams, &periodTime, &dir);
-#else
-        periodTime = snd_pcm_hw_params_set_period_time_near(info->handle, info->hwParams, periodTime, &dir);
-        ret = periodTime;
-#endif
-        if (ret < 0) {
-            ERROR2("Unable to set period time to %d: %s\n", DEFAULT_PERIOD_TIME, snd_strerror(ret));
-            return FALSE;
-        }
-    } else {
-        /* set the period count for very small buffer sizes to 2 */
-        dir = 0;
-        periods = 2;
-#ifdef ALSA_PCM_NEW_HW_PARAMS_API
-        ret = snd_pcm_hw_params_set_periods_near(info->handle, info->hwParams, &periods, &dir);
-#else
-        periods = snd_pcm_hw_params_set_periods_near(info->handle, info->hwParams, periods, &dir);
-        ret = periods;
-#endif
-        if (ret < 0) {
-            ERROR2("Unable to set period count to %d: %s\n", /*periods*/ 2, snd_strerror(ret));
-            return FALSE;
-        }
-    }
-    /* write the parameters to device */
-    ret = snd_pcm_hw_params(info->handle, info->hwParams);
-    if (ret < 0) {
-        ERROR1("Unable to set hw params: %s\n", snd_strerror(ret));
-        return FALSE;
-    }
-    return TRUE;
-}
-
-// returns 1 if successful
-int setSWParams(AlsaPcmInfo* info) {
-    int ret;
-
-    /* get the current swparams */
-    ret = snd_pcm_sw_params_current(info->handle, info->swParams);
-    if (ret < 0) {
-        ERROR1("Unable to determine current swparams: %s\n", snd_strerror(ret));
-        return FALSE;
-    }
-    /* never start the transfer automatically */
-    if (!setStartThresholdNoCommit(info, FALSE /* don't use threshold */)) {
-        return FALSE;
-    }
-
-    /* allow the transfer when at least period_size samples can be processed */
-    ret = snd_pcm_sw_params_set_avail_min(info->handle, info->swParams, info->periodSize);
-    if (ret < 0) {
-        ERROR1("Unable to set avail min for playback: %s\n", snd_strerror(ret));
-        return FALSE;
-    }
-    /* align all transfers to 1 sample */
-    ret = snd_pcm_sw_params_set_xfer_align(info->handle, info->swParams, 1);
-    if (ret < 0) {
-        ERROR1("Unable to set transfer align: %s\n", snd_strerror(ret));
-        return FALSE;
-    }
-    /* write the parameters to the playback device */
-    ret = snd_pcm_sw_params(info->handle, info->swParams);
-    if (ret < 0) {
-        ERROR1("Unable to set sw params: %s\n", snd_strerror(ret));
-        return FALSE;
-    }
-    return TRUE;
-}
-
-static snd_output_t* ALSA_OUTPUT = NULL;
-
-void* DAUDIO_Open(INT32 mixerIndex, INT32 deviceID, int isSource,
-                  int encoding, float sampleRate, int sampleSizeInBits,
-                  int frameSize, int channels,
-                  int isSigned, int isBigEndian, int bufferSizeInBytes) {
-    snd_pcm_format_mask_t* formatMask;
-    snd_pcm_format_t format;
-    int dir;
-    int ret = 0;
-    AlsaPcmInfo* info = NULL;
-    /* snd_pcm_uframes_t is 64 bit on 64-bit systems */
-    snd_pcm_uframes_t alsaPeriodSize = 0;
-    snd_pcm_uframes_t alsaBufferSizeInFrames = 0;
-
-
-    TRACE0("> DAUDIO_Open\n");
-#ifdef USE_TRACE
-    // for using ALSA debug dump methods
-    if (ALSA_OUTPUT == NULL) {
-        snd_output_stdio_attach(&ALSA_OUTPUT, stdout, 0);
-    }
-#endif
-
-    info = (AlsaPcmInfo*) malloc(sizeof(AlsaPcmInfo));
-    if (!info) {
-        ERROR0("Out of memory\n");
-        return NULL;
-    }
-    memset(info, 0, sizeof(AlsaPcmInfo));
-
-    ret = openPCMfromDeviceID(deviceID, &(info->handle), isSource, FALSE /* do open device*/);
-    if (ret == 0) {
-        // set to blocking mode
-        snd_pcm_nonblock(info->handle, 0);
-        ret = snd_pcm_hw_params_malloc(&(info->hwParams));
-        if (ret != 0) {
-            ERROR1("  snd_pcm_hw_params_malloc returned error %d\n", ret);
-        } else {
-            ret = -1;
-            if (getAlsaFormatFromFormat(&format, frameSize / channels, sampleSizeInBits,
-                                        isSigned, isBigEndian, encoding)) {
-                if (setHWParams(info,
-                                sampleRate,
-                                channels,
-                                bufferSizeInBytes / frameSize,
-                                format)) {
-                    info->frameSize = frameSize;
-#ifdef ALSA_PCM_NEW_HW_PARAMS_API
-                    ret = snd_pcm_hw_params_get_period_size(info->hwParams, &alsaPeriodSize, &dir);
-                    info->periodSize = (int) alsaPeriodSize;
-                    if (ret < 0) {
-                        ERROR1("ERROR: snd_pcm_hw_params_get_period: %s\n", snd_strerror(ret));
-                    }
-                    snd_pcm_hw_params_get_periods(info->hwParams, &(info->periods), &dir);
-                    snd_pcm_hw_params_get_buffer_size(info->hwParams, &alsaBufferSizeInFrames);
-                    info->bufferSizeInBytes = (int) alsaBufferSizeInFrames * frameSize;
-#else
-                    info->periodSize = snd_pcm_hw_params_get_period_size(info->hwParams, &dir);
-                    info->periods = snd_pcm_hw_params_get_periods(info->hwParams, &dir);
-                    info->bufferSizeInBytes = snd_pcm_hw_params_get_buffer_size(info->hwParams) * frameSize;
-                    ret = 0;
-#endif
-                    TRACE3("  DAUDIO_Open: period size = %d frames, periods = %d. Buffer size: %d bytes.\n",
-                           (int) info->periodSize, info->periods, info->bufferSizeInBytes);
-                }
-            }
-        }
-        if (ret == 0) {
-            // set software parameters
-            ret = snd_pcm_sw_params_malloc(&(info->swParams));
-            if (ret != 0) {
-                ERROR1("snd_pcm_hw_params_malloc returned error %d\n", ret);
-            } else {
-                if (!setSWParams(info)) {
-                    ret = -1;
-                }
-            }
-        }
-        if (ret == 0) {
-            // prepare device
-            ret = snd_pcm_prepare(info->handle);
-            if (ret < 0) {
-                ERROR1("ERROR: snd_pcm_prepare: %s\n", snd_strerror(ret));
-            }
-        }
-
-#ifdef GET_POSITION_METHOD2
-        if (ret == 0) {
-            ret = snd_pcm_status_malloc(&(info->positionStatus));
-            if (ret != 0) {
-                ERROR1("ERROR in snd_pcm_status_malloc: %s\n", snd_strerror(ret));
-            }
-        }
-#endif
-    }
-    if (ret != 0) {
-        DAUDIO_Close((void*) info, isSource);
-        info = NULL;
-    } else {
-        // set to non-blocking mode
-        snd_pcm_nonblock(info->handle, 1);
-        TRACE1("< DAUDIO_Open: Opened device successfully. Handle=%p\n",
-               (void*) info->handle);
-    }
-    return (void*) info;
-}
-
-#ifdef USE_TRACE
-void printState(snd_pcm_state_t state) {
-    if (state == SND_PCM_STATE_OPEN) {
-        TRACE0("State: SND_PCM_STATE_OPEN\n");
-    }
-    else if (state == SND_PCM_STATE_SETUP) {
-        TRACE0("State: SND_PCM_STATE_SETUP\n");
-    }
-    else if (state == SND_PCM_STATE_PREPARED) {
-        TRACE0("State: SND_PCM_STATE_PREPARED\n");
-    }
-    else if (state == SND_PCM_STATE_RUNNING) {
-        TRACE0("State: SND_PCM_STATE_RUNNING\n");
-    }
-    else if (state == SND_PCM_STATE_XRUN) {
-        TRACE0("State: SND_PCM_STATE_XRUN\n");
-    }
-    else if (state == SND_PCM_STATE_DRAINING) {
-        TRACE0("State: SND_PCM_STATE_DRAINING\n");
-    }
-    else if (state == SND_PCM_STATE_PAUSED) {
-        TRACE0("State: SND_PCM_STATE_PAUSED\n");
-    }
-    else if (state == SND_PCM_STATE_SUSPENDED) {
-        TRACE0("State: SND_PCM_STATE_SUSPENDED\n");
-    }
-}
-#endif
-
-int DAUDIO_Start(void* id, int isSource) {
-    AlsaPcmInfo* info = (AlsaPcmInfo*) id;
-    int ret;
-    snd_pcm_state_t state;
-
-    TRACE0("> DAUDIO_Start\n");
-    // set to blocking mode
-    snd_pcm_nonblock(info->handle, 0);
-    // set start mode so that it always starts as soon as data is there
-    setStartThreshold(info, TRUE /* use threshold */);
-    state = snd_pcm_state(info->handle);
-    if (state == SND_PCM_STATE_PAUSED) {
-        // in case it was stopped previously
-        TRACE0("  Un-pausing...\n");
-        ret = snd_pcm_pause(info->handle, FALSE);
-        if (ret != 0) {
-            ERROR2("  NOTE: error in snd_pcm_pause:%d: %s\n", ret, snd_strerror(ret));
-        }
-    }
-    if (state == SND_PCM_STATE_SUSPENDED) {
-        TRACE0("  Resuming...\n");
-        ret = snd_pcm_resume(info->handle);
-        if (ret < 0) {
-            if ((ret != -EAGAIN) && (ret != -ENOSYS)) {
-                ERROR2("  ERROR: error in snd_pcm_resume:%d: %s\n", ret, snd_strerror(ret));
-            }
-        }
-    }
-    if (state == SND_PCM_STATE_SETUP) {
-        TRACE0("need to call prepare again...\n");
-        // prepare device
-        ret = snd_pcm_prepare(info->handle);
-        if (ret < 0) {
-            ERROR1("ERROR: snd_pcm_prepare: %s\n", snd_strerror(ret));
-        }
-    }
-    // in case there is still data in the buffers
-    ret = snd_pcm_start(info->handle);
-    if (ret != 0) {
-        if (ret != -EPIPE) {
-            ERROR2("  NOTE: error in snd_pcm_start: %d: %s\n", ret, snd_strerror(ret));
-        }
-    }
-    // set to non-blocking mode
-    ret = snd_pcm_nonblock(info->handle, 1);
-    if (ret != 0) {
-        ERROR1("  ERROR in snd_pcm_nonblock: %s\n", snd_strerror(ret));
-    }
-    state = snd_pcm_state(info->handle);
-#ifdef USE_TRACE
-    printState(state);
-#endif
-    ret = (state == SND_PCM_STATE_PREPARED)
-        || (state == SND_PCM_STATE_RUNNING)
-        || (state == SND_PCM_STATE_XRUN)
-        || (state == SND_PCM_STATE_SUSPENDED);
-    TRACE1("< DAUDIO_Start %s\n", ret?"success":"error");
-    return ret?TRUE:FALSE;
-}
-
-int DAUDIO_Stop(void* id, int isSource) {
-    AlsaPcmInfo* info = (AlsaPcmInfo*) id;
-    int ret;
-
-    TRACE0("> DAUDIO_Stop\n");
-    // set to blocking mode
-    snd_pcm_nonblock(info->handle, 0);
-    setStartThreshold(info, FALSE /* don't use threshold */); // device will not start after buffer xrun
-    ret = snd_pcm_pause(info->handle, 1);
-    // set to non-blocking mode
-    snd_pcm_nonblock(info->handle, 1);
-    if (ret != 0) {
-        ERROR1("ERROR in snd_pcm_pause: %s\n", snd_strerror(ret));
-        return FALSE;
-    }
-    TRACE0("< DAUDIO_Stop success\n");
-    return TRUE;
-}
-
-void DAUDIO_Close(void* id, int isSource) {
-    AlsaPcmInfo* info = (AlsaPcmInfo*) id;
-
-    TRACE0("DAUDIO_Close\n");
-    if (info != NULL) {
-        if (info->handle != NULL) {
-            snd_pcm_close(info->handle);
-        }
-        if (info->hwParams) {
-            snd_pcm_hw_params_free(info->hwParams);
-        }
-        if (info->swParams) {
-            snd_pcm_sw_params_free(info->swParams);
-        }
-#ifdef GET_POSITION_METHOD2
-        if (info->positionStatus) {
-            snd_pcm_status_free(info->positionStatus);
-        }
-#endif
-        free(info);
-    }
-}
-
-/*
- * Underrun and suspend recovery
- * returns
- * 0:  exit native and return 0
- * 1:  try again to write/read
- * -1: error - exit native with return value -1
- */
-int xrun_recovery(AlsaPcmInfo* info, int err) {
-    int ret;
-
-    if (err == -EPIPE) {    /* underrun / overflow */
-        TRACE0("xrun_recovery: underrun/overflow.\n");
-        ret = snd_pcm_prepare(info->handle);
-        if (ret < 0) {
-            ERROR1("Can't recover from underrun/overflow, prepare failed: %s\n", snd_strerror(ret));
-            return -1;
-        }
-        return 1;
-    }
-    else if (err == -ESTRPIPE) {
-        TRACE0("xrun_recovery: suspended.\n");
-        ret = snd_pcm_resume(info->handle);
-        if (ret < 0) {
-            if (ret == -EAGAIN) {
-                return 0; /* wait until the suspend flag is released */
-            }
-            return -1;
-        }
-        ret = snd_pcm_prepare(info->handle);
-        if (ret < 0) {
-            ERROR1("Can't recover from underrun/overflow, prepare failed: %s\n", snd_strerror(ret));
-            return -1;
-        }
-        return 1;
-    }
-    else if (err == -EAGAIN) {
-        TRACE0("xrun_recovery: EAGAIN try again flag.\n");
-        return 0;
-    }
-    TRACE2("xrun_recovery: unexpected error %d: %s\n", err, snd_strerror(err));
-    return -1;
-}
-
-// returns -1 on error
-int DAUDIO_Write(void* id, char* data, int byteSize) {
-    AlsaPcmInfo* info = (AlsaPcmInfo*) id;
-    int ret, count;
-    snd_pcm_sframes_t frameSize, writtenFrames;
-
-    TRACE1("> DAUDIO_Write %d bytes\n", byteSize);
-
-    /* sanity */
-    if (byteSize <= 0 || info->frameSize <= 0) {
-        ERROR2(" DAUDIO_Write: byteSize=%d, frameSize=%d!\n",
-               (int) byteSize, (int) info->frameSize);
-        TRACE0("< DAUDIO_Write returning -1\n");
-        return -1;
-    }
-    count = 2; // maximum number of trials to recover from underrun
-    //frameSize = snd_pcm_bytes_to_frames(info->handle, byteSize);
-    frameSize = (snd_pcm_sframes_t) (byteSize / info->frameSize);
-    do {
-        writtenFrames = snd_pcm_writei(info->handle, (const void*) data, (snd_pcm_uframes_t) frameSize);
-
-        if (writtenFrames < 0) {
-            ret = xrun_recovery(info, (int) writtenFrames);
-            if (ret <= 0) {
-                TRACE1("DAUDIO_Write: xrun recovery returned %d -> return.\n", ret);
-                return ret;
-            }
-            if (count-- <= 0) {
-                ERROR0("DAUDIO_Write: too many attempts to recover from xrun/suspend\n");
-                return -1;
-            }
-        } else {
-            break;
-        }
-    } while (TRUE);
-    //ret =  snd_pcm_frames_to_bytes(info->handle, writtenFrames);
-    ret =  (int) (writtenFrames * info->frameSize);
-    TRACE1("< DAUDIO_Write: returning %d bytes.\n", ret);
-    return ret;
-}
-
-// returns -1 on error
-int DAUDIO_Read(void* id, char* data, int byteSize) {
-    AlsaPcmInfo* info = (AlsaPcmInfo*) id;
-    int ret, count;
-    snd_pcm_sframes_t frameSize, readFrames;
-
-    TRACE1("> DAUDIO_Read %d bytes\n", byteSize);
-    /*TRACE3("  info=%p, data=%p, byteSize=%d\n",
-      (void*) info, (void*) data, (int) byteSize);
-      TRACE2("  info->frameSize=%d, info->handle=%p\n",
-      (int) info->frameSize, (void*) info->handle);
-    */
-    /* sanity */
-    if (byteSize <= 0 || info->frameSize <= 0) {
-        ERROR2(" DAUDIO_Read: byteSize=%d, frameSize=%d!\n",
-               (int) byteSize, (int) info->frameSize);
-        TRACE0("< DAUDIO_Read returning -1\n");
-        return -1;
-    }
-    count = 2; // maximum number of trials to recover from error
-    //frameSize = snd_pcm_bytes_to_frames(info->handle, byteSize);
-    frameSize = (snd_pcm_sframes_t) (byteSize / info->frameSize);
-    do {
-        readFrames = snd_pcm_readi(info->handle, (void*) data, (snd_pcm_uframes_t) frameSize);
-        if (readFrames < 0) {
-            ret = xrun_recovery(info, (int) readFrames);
-            if (ret <= 0) {
-                TRACE1("DAUDIO_Read: xrun recovery returned %d -> return.\n", ret);
-                return ret;
-            }
-            if (count-- <= 0) {
-                ERROR0("DAUDIO_Read: too many attempts to recover from xrun/suspend\n");
-                return -1;
-            }
-        } else {
-            break;
-        }
-    } while (TRUE);
-    //ret =  snd_pcm_frames_to_bytes(info->handle, readFrames);
-    ret =  (int) (readFrames * info->frameSize);
-    TRACE1("< DAUDIO_Read: returning %d bytes.\n", ret);
-    return ret;
-}
-
-
-int DAUDIO_GetBufferSize(void* id, int isSource) {
-    AlsaPcmInfo* info = (AlsaPcmInfo*) id;
-
-    return info->bufferSizeInBytes;
-}
-
-int DAUDIO_StillDraining(void* id, int isSource) {
-    AlsaPcmInfo* info = (AlsaPcmInfo*) id;
-    snd_pcm_state_t state;
-
-    state = snd_pcm_state(info->handle);
-    //printState(state);
-    //TRACE1("Still draining: %s\n", (state != SND_PCM_STATE_XRUN)?"TRUE":"FALSE");
-    return (state == SND_PCM_STATE_RUNNING)?TRUE:FALSE;
-}
-
-
-int DAUDIO_Flush(void* id, int isSource) {
-    AlsaPcmInfo* info = (AlsaPcmInfo*) id;
-    int ret;
-
-    TRACE0("DAUDIO_Flush\n");
-    ret = snd_pcm_drop(info->handle);
-    if (ret != 0) {
-        ERROR1("ERROR in snd_pcm_drop: %s\n", snd_strerror(ret));
-        return FALSE;
-    }
-    ret = DAUDIO_Start(id, isSource);
-    return ret;
-}
-
-int DAUDIO_GetAvailable(void* id, int isSource) {
-    AlsaPcmInfo* info = (AlsaPcmInfo*) id;
-    snd_pcm_sframes_t availableInFrames;
-    snd_pcm_state_t state;
-    int ret;
-
-    state = snd_pcm_state(info->handle);
-    if (state == SND_PCM_STATE_XRUN) {
-        // if in xrun state then we have the entire buffer available,
-        // not 0 as alsa reports
-        ret = info->bufferSizeInBytes;
-    } else {
-        availableInFrames = snd_pcm_avail_update(info->handle);
-        if (availableInFrames < 0) {
-            ret = 0;
-        } else {
-            //ret = snd_pcm_frames_to_bytes(info->handle, availableInFrames);
-            ret = (int) (availableInFrames * info->frameSize);
-        }
-    }
-    TRACE1("DAUDIO_GetAvailable returns %d bytes\n", ret);
-    return ret;
-}
-
-INT64 estimatePositionFromAvail(AlsaPcmInfo* info, int isSource, INT64 javaBytePos, int availInBytes) {
-    // estimate the current position with the buffer size and
-    // the available bytes to read or write in the buffer.
-    // not an elegant solution - bytePos will stop on xruns,
-    // and in race conditions it may jump backwards
-    // Advantage is that it is indeed based on the samples that go through
-    // the system (rather than time-based methods)
-    if (isSource) {
-        // javaBytePos is the position that is reached when the current
-        // buffer is played completely
-        return (INT64) (javaBytePos - info->bufferSizeInBytes + availInBytes);
-    } else {
-        // javaBytePos is the position that was when the current buffer was empty
-        return (INT64) (javaBytePos + availInBytes);
-    }
-}
-
-INT64 DAUDIO_GetBytePosition(void* id, int isSource, INT64 javaBytePos) {
-    AlsaPcmInfo* info = (AlsaPcmInfo*) id;
-    int ret;
-    INT64 result = javaBytePos;
-    snd_pcm_state_t state;
-    state = snd_pcm_state(info->handle);
-
-    if (state != SND_PCM_STATE_XRUN) {
-#ifdef GET_POSITION_METHOD2
-        snd_timestamp_t* ts;
-        snd_pcm_uframes_t framesAvail;
-
-        // note: slight race condition if this is called simultaneously from 2 threads
-        ret = snd_pcm_status(info->handle, info->positionStatus);
-        if (ret != 0) {
-            ERROR1("ERROR in snd_pcm_status: %s\n", snd_strerror(ret));
-            result = javaBytePos;
-        } else {
-            // calculate from time value, or from available bytes
-            framesAvail = snd_pcm_status_get_avail(info->positionStatus);
-            result = estimatePositionFromAvail(info, isSource, javaBytePos, framesAvail * info->frameSize);
-        }
-#endif
-#ifdef GET_POSITION_METHOD3
-        snd_pcm_uframes_t framesAvail;
-        ret = snd_pcm_avail(info->handle, &framesAvail);
-        if (ret != 0) {
-            ERROR1("ERROR in snd_pcm_avail: %s\n", snd_strerror(ret));
-            result = javaBytePos;
-        } else {
-            result = estimatePositionFromAvail(info, isSource, javaBytePos, framesAvail * info->frameSize);
-        }
-#endif
-#ifdef GET_POSITION_METHOD1
-        result = estimatePositionFromAvail(info, isSource, javaBytePos, DAUDIO_GetAvailable(id, isSource));
-#endif
-    }
-    //printf("getbyteposition: javaBytePos=%d , return=%d\n", (int) javaBytePos, (int) result);
-    return result;
-}
-
-
-
-void DAUDIO_SetBytePosition(void* id, int isSource, INT64 javaBytePos) {
-    /* save to ignore, since GetBytePosition
-     * takes the javaBytePos param into account
-     */
-}
-
-int DAUDIO_RequiresServicing(void* id, int isSource) {
-    // never need servicing on Bsd
-    return FALSE;
-}
-
-void DAUDIO_Service(void* id, int isSource) {
-    // never need servicing on Bsd
-}
-
-
-#endif // USE_DAUDIO
--- ./jdk/src/solaris/native/com/sun/media/sound/PLATFORM_API_BsdOS_ALSA_PCMUtils.c	2010-03-27 11:09:14.000000000 -0700
+++ ./jdk/src/solaris/native/com/sun/media/sound/PLATFORM_API_BsdOS_ALSA_PCMUtils.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,291 +0,0 @@
-/*
- * Copyright 2003-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-
-//#define USE_ERROR
-//#define USE_TRACE
-
-#include "PLATFORM_API_BsdOS_ALSA_PCMUtils.h"
-#include "PLATFORM_API_BsdOS_ALSA_CommonUtils.h"
-
-
-
-// callback for iteration through devices
-// returns TRUE if iteration should continue
-// NOTE: cardinfo may be NULL (for "default" device)
-typedef int (*DeviceIteratorPtr)(UINT32 deviceID, snd_pcm_info_t* pcminfo,
-                             snd_ctl_card_info_t* cardinfo, void *userData);
-
-// for each ALSA device, call iterator. userData is passed to the iterator
-// returns total number of iterations
-int iteratePCMDevices(DeviceIteratorPtr iterator, void* userData) {
-    int count = 0;
-    int subdeviceCount;
-    int card, dev, subDev;
-    char devname[16];
-    int err;
-    snd_ctl_t *handle;
-    snd_pcm_t *pcm;
-    snd_pcm_info_t* pcminfo;
-    snd_ctl_card_info_t *cardinfo, *defcardinfo = NULL;
-    UINT32 deviceID;
-    int doContinue = TRUE;
-
-    snd_pcm_info_malloc(&pcminfo);
-    snd_ctl_card_info_malloc(&cardinfo);
-
-    // 1st try "default" device
-    err = snd_pcm_open(&pcm, ALSA_DEFAULT_DEVICE_NAME,
-                       SND_PCM_STREAM_PLAYBACK, SND_PCM_NONBLOCK);
-    if (err < 0) {
-        // try with the other direction
-        err = snd_pcm_open(&pcm, ALSA_DEFAULT_DEVICE_NAME,
-                           SND_PCM_STREAM_CAPTURE, SND_PCM_NONBLOCK);
-    }
-    if (err < 0) {
-        ERROR1("ERROR: snd_pcm_open (\"default\"): %s\n", snd_strerror(err));
-    } else {
-        err = snd_pcm_info(pcm, pcminfo);
-        snd_pcm_close(pcm);
-        if (err < 0) {
-            ERROR1("ERROR: snd_pcm_info (\"default\"): %s\n",
-                    snd_strerror(err));
-        } else {
-            // try to get card info
-            card = snd_pcm_info_get_card(pcminfo);
-            if (card >= 0) {
-                sprintf(devname, ALSA_HARDWARE_CARD, card);
-                if (snd_ctl_open(&handle, devname, SND_CTL_NONBLOCK) >= 0) {
-                    if (snd_ctl_card_info(handle, cardinfo) >= 0) {
-                        defcardinfo = cardinfo;
-                    }
-                    snd_ctl_close(handle);
-                }
-            }
-            // call callback function for the device
-            if (iterator != NULL) {
-                doContinue = (*iterator)(ALSA_DEFAULT_DEVICE_ID, pcminfo,
-                                         defcardinfo, userData);
-            }
-            count++;
-        }
-    }
-
-    // iterate cards
-    card = -1;
-    while (doContinue) {
-        if (snd_card_next(&card) < 0) {
-            break;
-        }
-        if (card < 0) {
-            break;
-        }
-        sprintf(devname, ALSA_HARDWARE_CARD, card);
-        TRACE1("Opening alsa device \"%s\"...\n", devname);
-        err = snd_ctl_open(&handle, devname, SND_CTL_NONBLOCK);
-        if (err < 0) {
-            ERROR2("ERROR: snd_ctl_open, card=%d: %s\n",
-                    card, snd_strerror(err));
-        } else {
-            err = snd_ctl_card_info(handle, cardinfo);
-            if (err < 0) {
-                ERROR2("ERROR: snd_ctl_card_info, card=%d: %s\n",
-                        card, snd_strerror(err));
-            } else {
-                dev = -1;
-                while (doContinue) {
-                    if (snd_ctl_pcm_next_device(handle, &dev) < 0) {
-                        ERROR0("snd_ctl_pcm_next_device\n");
-                    }
-                    if (dev < 0) {
-                        break;
-                    }
-                    snd_pcm_info_set_device(pcminfo, dev);
-                    snd_pcm_info_set_subdevice(pcminfo, 0);
-                    snd_pcm_info_set_stream(pcminfo, SND_PCM_STREAM_PLAYBACK);
-                    err = snd_ctl_pcm_info(handle, pcminfo);
-                    if (err == -ENOENT) {
-                        // try with the other direction
-                        snd_pcm_info_set_stream(pcminfo, SND_PCM_STREAM_CAPTURE);
-                        err = snd_ctl_pcm_info(handle, pcminfo);
-                    }
-                    if (err < 0) {
-                        if (err != -ENOENT) {
-                            ERROR2("ERROR: snd_ctl_pcm_info, card=%d: %s",
-                                    card, snd_strerror(err));
-                        }
-                    } else {
-                        subdeviceCount = needEnumerateSubdevices(ALSA_PCM) ?
-                            snd_pcm_info_get_subdevices_count(pcminfo) : 1;
-                        if (iterator!=NULL) {
-                            for (subDev = 0; subDev < subdeviceCount; subDev++) {
-                                deviceID = encodeDeviceID(card, dev, subDev);
-                                doContinue = (*iterator)(deviceID, pcminfo,
-                                                         cardinfo, userData);
-                                count++;
-                                if (!doContinue) {
-                                    break;
-                                }
-                            }
-                        } else {
-                            count += subdeviceCount;
-                        }
-                    }
-                } // of while(doContinue)
-            }
-            snd_ctl_close(handle);
-        }
-    }
-    snd_ctl_card_info_free(cardinfo);
-    snd_pcm_info_free(pcminfo);
-    return count;
-}
-
-int getAudioDeviceCount() {
-    initAlsaSupport();
-    return iteratePCMDevices(NULL, NULL);
-}
-
-int deviceInfoIterator(UINT32 deviceID, snd_pcm_info_t* pcminfo,
-                       snd_ctl_card_info_t* cardinfo, void* userData) {
-    char buffer[300];
-    ALSA_AudioDeviceDescription* desc = (ALSA_AudioDeviceDescription*)userData;
-#ifdef ALSA_PCM_USE_PLUGHW
-    int usePlugHw = 1;
-#else
-    int usePlugHw = 0;
-#endif
-
-    initAlsaSupport();
-    if (desc->index == 0) {
-        // we found the device with correct index
-        *(desc->maxSimultaneousLines) = needEnumerateSubdevices(ALSA_PCM) ?
-                1 : snd_pcm_info_get_subdevices_count(pcminfo);
-        *desc->deviceID = deviceID;
-        buffer[0]=' '; buffer[1]='[';
-        getDeviceStringFromDeviceID(&buffer[2], deviceID, usePlugHw, ALSA_PCM);
-        strcat(buffer, "]");
-        strncpy(desc->name,
-                (cardinfo != NULL)
-                    ? snd_ctl_card_info_get_id(cardinfo)
-                    : snd_pcm_info_get_id(pcminfo),
-                desc->strLen - strlen(buffer));
-        strncat(desc->name, buffer, desc->strLen - strlen(desc->name));
-        strncpy(desc->vendor, "ALSA (http://www.alsa-project.org)", desc->strLen);
-        strncpy(desc->description,
-                (cardinfo != NULL)
-                    ? snd_ctl_card_info_get_name(cardinfo)
-                    : snd_pcm_info_get_name(pcminfo),
-                desc->strLen);
-        strncat(desc->description, ", ", desc->strLen - strlen(desc->description));
-        strncat(desc->description, snd_pcm_info_get_id(pcminfo), desc->strLen - strlen(desc->description));
-        strncat(desc->description, ", ", desc->strLen - strlen(desc->description));
-        strncat(desc->description, snd_pcm_info_get_name(pcminfo), desc->strLen - strlen(desc->description));
-        getALSAVersion(desc->version, desc->strLen);
-        TRACE4("Returning %s, %s, %s, %s\n", desc->name, desc->vendor, desc->description, desc->version);
-        return FALSE; // do not continue iteration
-    }
-    desc->index--;
-    return TRUE;
-}
-
-// returns 0 if successful
-int openPCMfromDeviceID(int deviceID, snd_pcm_t** handle, int isSource, int hardware) {
-    char buffer[200];
-    int ret;
-
-    initAlsaSupport();
-    getDeviceStringFromDeviceID(buffer, deviceID, !hardware, ALSA_PCM);
-
-    TRACE1("Opening ALSA device %s\n", buffer);
-    ret = snd_pcm_open(handle, buffer,
-                       isSource?SND_PCM_STREAM_PLAYBACK:SND_PCM_STREAM_CAPTURE,
-                       SND_PCM_NONBLOCK);
-    if (ret != 0) {
-        ERROR1("snd_pcm_open returned error code %d \n", ret);
-        *handle = NULL;
-    }
-    return ret;
-}
-
-
-int getAudioDeviceDescriptionByIndex(ALSA_AudioDeviceDescription* desc) {
-    initAlsaSupport();
-    TRACE1(" getAudioDeviceDescriptionByIndex(mixerIndex = %d\n", desc->index);
-    iteratePCMDevices(&deviceInfoIterator, desc);
-    return (desc->index == 0)?TRUE:FALSE;
-}
-
-// returns 1 if successful
-// enc: 0 for PCM, 1 for ULAW, 2 for ALAW (see DirectAudio.h)
-int getFormatFromAlsaFormat(snd_pcm_format_t alsaFormat,
-                            int* sampleSizeInBytes, int* significantBits,
-                            int* isSigned, int* isBigEndian, int* enc) {
-
-    *sampleSizeInBytes = (snd_pcm_format_physical_width(alsaFormat) + 7) / 8;
-    *significantBits = snd_pcm_format_width(alsaFormat);
-
-    // defaults
-    *enc = 0; // PCM
-    *isSigned = (snd_pcm_format_signed(alsaFormat) > 0);
-    *isBigEndian = (snd_pcm_format_big_endian(alsaFormat) > 0);
-
-    // non-PCM formats
-    if (alsaFormat == SND_PCM_FORMAT_MU_LAW) { // Mu-Law
-        *sampleSizeInBytes = 8; *enc = 1; *significantBits = *sampleSizeInBytes;
-    }
-    else if (alsaFormat == SND_PCM_FORMAT_A_LAW) {     // A-Law
-        *sampleSizeInBytes = 8; *enc = 2; *significantBits = *sampleSizeInBytes;
-    }
-    else if (snd_pcm_format_linear(alsaFormat) < 1) {
-        return 0;
-    }
-    return (*sampleSizeInBytes > 0);
-}
-
-// returns 1 if successful
-int getAlsaFormatFromFormat(snd_pcm_format_t* alsaFormat,
-                            int sampleSizeInBytes, int significantBits,
-                            int isSigned, int isBigEndian, int enc) {
-    *alsaFormat = SND_PCM_FORMAT_UNKNOWN;
-
-    if (enc == 0) {
-        *alsaFormat = snd_pcm_build_linear_format(significantBits,
-                                                  sampleSizeInBytes * 8,
-                                                  isSigned?0:1,
-                                                  isBigEndian?1:0);
-    }
-    else if ((sampleSizeInBytes == 1) && (significantBits == 8)) {
-        if (enc == 1) { // ULAW
-            *alsaFormat = SND_PCM_FORMAT_MU_LAW;
-        }
-        else if (enc == 2) { // ALAW
-            *alsaFormat = SND_PCM_FORMAT_A_LAW;
-        }
-    }
-    return (*alsaFormat == SND_PCM_FORMAT_UNKNOWN)?0:1;
-}
-
-
-/* end */
--- ./jdk/src/solaris/native/com/sun/media/sound/PLATFORM_API_BsdOS_ALSA_PCMUtils.h	2010-03-27 11:09:15.000000000 -0700
+++ ./jdk/src/solaris/native/com/sun/media/sound/PLATFORM_API_BsdOS_ALSA_PCMUtils.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,72 +0,0 @@
-/*
- * Copyright 2003-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-
-// define this with a later version of ALSA than 0.9.0rc3
-#define ALSA_PCM_NEW_HW_PARAMS_API
-#include <alsa/asoundlib.h>
-#include "Utilities.h"
-
-#ifndef PLATFORM_API_BSDOS_ALSA_PCMUTILS_H_INCLUDED
-#define PLATFORM_API_BSDOS_ALSA_PCMUTILS_H_INCLUDED
-
-// if this is defined, use plughw: devices
-#define ALSA_PCM_USE_PLUGHW
-//#undef ALSA_PCM_USE_PLUGHW
-
-
-// maximum number of channels that is listed in the formats. If more, than
-// just -1 for channel count is used.
-#define MAXIMUM_LISTED_CHANNELS 32
-
-typedef struct tag_ALSA_AudioDeviceDescription {
-    int index;          // in
-    int strLen;         // in
-    INT32* deviceID;    // out
-    int* maxSimultaneousLines; // out
-    char* name;         // out
-    char* vendor;       // out
-    char* description;  // out
-    char* version;      // out
-} ALSA_AudioDeviceDescription;
-
-
-
-int getAudioDeviceCount();
-int getAudioDeviceDescriptionByIndex(ALSA_AudioDeviceDescription* desc);
-
-// returns ALSA error code, or 0 if successful
-int openPCMfromDeviceID(int deviceID, snd_pcm_t** handle, int isSource, int hardware);
-
-// returns 1 if successful
-// enc: 0 for PCM, 1 for ULAW, 2 for ALAW (see DirectAudio.h)
-int getFormatFromAlsaFormat(snd_pcm_format_t alsaFormat,
-                            int* sampleSizeInBytes, int* significantBits,
-                            int* isSigned, int* isBigEndian, int* enc);
-
-int getAlsaFormatFromFormat(snd_pcm_format_t* alsaFormat,
-                            int sampleSizeInBytes, int significantBits,
-                            int isSigned, int isBigEndian, int enc);
-
-#endif // PLATFORM_API_BSDOS_ALSA_PCMUTILS_H_INCLUDED
--- ./jdk/src/solaris/native/com/sun/media/sound/PLATFORM_API_BsdOS_ALSA_Ports.c	2010-03-27 11:09:15.000000000 -0700
+++ ./jdk/src/solaris/native/com/sun/media/sound/PLATFORM_API_BsdOS_ALSA_Ports.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,723 +0,0 @@
-/*
- * Copyright 2003-2007 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-
-#define USE_ERROR
-//#define USE_TRACE
-
-#include "Ports.h"
-#include "PLATFORM_API_BsdOS_ALSA_CommonUtils.h"
-#include <alsa/asoundlib.h>
-
-#if USE_PORTS == TRUE
-
-#define MAX_ELEMS (300)
-#define MAX_CONTROLS (MAX_ELEMS * 4)
-
-#define CHANNELS_MONO (SND_MIXER_SCHN_LAST + 1)
-#define CHANNELS_STEREO (SND_MIXER_SCHN_LAST + 2)
-
-typedef struct {
-    snd_mixer_elem_t* elem;
-    INT32 portType; /* one of PORT_XXX_xx */
-    char* controlType; /* one of CONTROL_TYPE_xx */
-    /* Values: either SND_MIXER_SCHN_FRONT_xx, CHANNELS_MONO or CHANNELS_STEREO.
-       For SND_MIXER_SCHN_FRONT_xx, exactly this channel is set/retrieved directly.
-       For CHANNELS_MONO, ALSA channel SND_MIXER_SCHN_MONO is set/retrieved directly.
-       For CHANNELS_STEREO, ALSA channels SND_MIXER_SCHN_FRONT_LEFT and SND_MIXER_SCHN_FRONT_RIGHT
-       are set after a calculation that takes balance into account. Retrieved? Average of both
-       channels? (Using a cached value is not a good idea since the value in the HW may have been
-       altered.) */
-    INT32 channel;
-} PortControl;
-
-
-typedef struct tag_PortMixer {
-    snd_mixer_t* mixer_handle;
-    /* Number of array elements used in elems and types. */
-    int numElems;
-    snd_mixer_elem_t** elems;
-    /* Array of port types (PORT_SRC_UNKNOWN etc.). Indices are the same as in elems. */
-    INT32* types;
-    /* Number of array elements used in controls. */
-    int numControls;
-    PortControl* controls;
-} PortMixer;
-
-
-///// implemented functions of Ports.h
-
-INT32 PORT_GetPortMixerCount() {
-    INT32 mixerCount;
-    int card;
-    char devname[16];
-    int err;
-    snd_ctl_t *handle;
-    snd_ctl_card_info_t* info;
-
-    TRACE0("> PORT_GetPortMixerCount\n");
-
-    initAlsaSupport();
-
-    snd_ctl_card_info_malloc(&info);
-    card = -1;
-    mixerCount = 0;
-    if (snd_card_next(&card) >= 0) {
-        while (card >= 0) {
-            sprintf(devname, ALSA_HARDWARE_CARD, card);
-            TRACE1("PORT_GetPortMixerCount: Opening alsa device \"%s\"...\n", devname);
-            err = snd_ctl_open(&handle, devname, 0);
-            if (err < 0) {
-                ERROR2("ERROR: snd_ctl_open, card=%d: %s\n", card, snd_strerror(err));
-            } else {
-                mixerCount++;
-                snd_ctl_close(handle);
-            }
-            if (snd_card_next(&card) < 0) {
-                break;
-            }
-        }
-    }
-    snd_ctl_card_info_free(info);
-    TRACE0("< PORT_GetPortMixerCount\n");
-    return mixerCount;
-}
-
-
-INT32 PORT_GetPortMixerDescription(INT32 mixerIndex, PortMixerDescription* description) {
-    snd_ctl_t* handle;
-    snd_ctl_card_info_t* card_info;
-    char devname[16];
-    int err;
-    char buffer[100];
-
-    TRACE0("> PORT_GetPortMixerDescription\n");
-    snd_ctl_card_info_malloc(&card_info);
-
-    sprintf(devname, ALSA_HARDWARE_CARD, (int) mixerIndex);
-    TRACE1("Opening alsa device \"%s\"...\n", devname);
-    err = snd_ctl_open(&handle, devname, 0);
-    if (err < 0) {
-        ERROR2("ERROR: snd_ctl_open, card=%d: %s\n", (int) mixerIndex, snd_strerror(err));
-        return FALSE;
-    }
-    err = snd_ctl_card_info(handle, card_info);
-    if (err < 0) {
-        ERROR2("ERROR: snd_ctl_card_info, card=%d: %s\n", (int) mixerIndex, snd_strerror(err));
-    }
-    strncpy(description->name, snd_ctl_card_info_get_id(card_info), PORT_STRING_LENGTH - 1);
-    sprintf(buffer, " [%s]", devname);
-    strncat(description->name, buffer, PORT_STRING_LENGTH - 1 - strlen(description->name));
-    strncpy(description->vendor, "ALSA (http://www.alsa-project.org)", PORT_STRING_LENGTH - 1);
-    strncpy(description->description, snd_ctl_card_info_get_name(card_info), PORT_STRING_LENGTH - 1);
-    strncat(description->description, ", ", PORT_STRING_LENGTH - 1 - strlen(description->description));
-    strncat(description->description, snd_ctl_card_info_get_mixername(card_info), PORT_STRING_LENGTH - 1 - strlen(description->description));
-    getALSAVersion(description->version, PORT_STRING_LENGTH - 1);
-
-    snd_ctl_close(handle);
-    snd_ctl_card_info_free(card_info);
-    TRACE0("< PORT_GetPortMixerDescription\n");
-    return TRUE;
-}
-
-
-void* PORT_Open(INT32 mixerIndex) {
-    char devname[16];
-    snd_mixer_t* mixer_handle;
-    int err;
-    PortMixer* handle;
-
-    TRACE0("> PORT_Open\n");
-    sprintf(devname, ALSA_HARDWARE_CARD, (int) mixerIndex);
-    if ((err = snd_mixer_open(&mixer_handle, 0)) < 0) {
-        ERROR2("Mixer %s open error: %s", devname, snd_strerror(err));
-        return NULL;
-    }
-    if ((err = snd_mixer_attach(mixer_handle, devname)) < 0) {
-        ERROR2("Mixer attach %s error: %s", devname, snd_strerror(err));
-        snd_mixer_close(mixer_handle);
-        return NULL;
-    }
-    if ((err = snd_mixer_selem_register(mixer_handle, NULL, NULL)) < 0) {
-        ERROR1("Mixer register error: %s", snd_strerror(err));
-        snd_mixer_close(mixer_handle);
-        return NULL;
-    }
-    err = snd_mixer_load(mixer_handle);
-    if (err < 0) {
-        ERROR2("Mixer %s load error: %s", devname, snd_strerror(err));
-        snd_mixer_close(mixer_handle);
-        return NULL;
-    }
-    handle = (PortMixer*) calloc(1, sizeof(PortMixer));
-    if (handle == NULL) {
-        ERROR0("malloc() failed.");
-        snd_mixer_close(mixer_handle);
-        return NULL;
-    }
-    handle->numElems = 0;
-    handle->elems = (snd_mixer_elem_t**) calloc(MAX_ELEMS, sizeof(snd_mixer_elem_t*));
-    if (handle->elems == NULL) {
-        ERROR0("malloc() failed.");
-        snd_mixer_close(mixer_handle);
-        free(handle);
-        return NULL;
-    }
-    handle->types = (INT32*) calloc(MAX_ELEMS, sizeof(INT32));
-    if (handle->types == NULL) {
-        ERROR0("malloc() failed.");
-        snd_mixer_close(mixer_handle);
-        free(handle->elems);
-        free(handle);
-        return NULL;
-    }
-    handle->controls = (PortControl*) calloc(MAX_CONTROLS, sizeof(PortControl));
-    if (handle->controls == NULL) {
-        ERROR0("malloc() failed.");
-        snd_mixer_close(mixer_handle);
-        free(handle->elems);
-        free(handle->types);
-        free(handle);
-        return NULL;
-    }
-    handle->mixer_handle = mixer_handle;
-    // necessary to initialize data structures
-    PORT_GetPortCount(handle);
-    TRACE0("< PORT_Open\n");
-    return handle;
-}
-
-
-void PORT_Close(void* id) {
-    TRACE0("> PORT_Close\n");
-    if (id != NULL) {
-        PortMixer* handle = (PortMixer*) id;
-        if (handle->mixer_handle != NULL) {
-            snd_mixer_close(handle->mixer_handle);
-        }
-        if (handle->elems != NULL) {
-            free(handle->elems);
-        }
-        if (handle->types != NULL) {
-            free(handle->types);
-        }
-        if (handle->controls != NULL) {
-            free(handle->controls);
-        }
-        free(handle);
-    }
-    TRACE0("< PORT_Close\n");
-}
-
-
-
-INT32 PORT_GetPortCount(void* id) {
-    PortMixer* portMixer;
-    snd_mixer_elem_t *elem;
-
-    TRACE0("> PORT_GetPortCount\n");
-    if (id == NULL) {
-        // $$mp: Should become a descriptive error code (invalid handle).
-        return -1;
-    }
-    portMixer = (PortMixer*) id;
-    if (portMixer->numElems == 0) {
-        for (elem = snd_mixer_first_elem(portMixer->mixer_handle); elem; elem = snd_mixer_elem_next(elem)) {
-            if (!snd_mixer_selem_is_active(elem))
-                continue;
-            TRACE2("Simple mixer control '%s',%i\n",
-                   snd_mixer_selem_get_name(elem),
-                   snd_mixer_selem_get_index(elem));
-            if (snd_mixer_selem_has_playback_volume(elem)) {
-                portMixer->elems[portMixer->numElems] = elem;
-                portMixer->types[portMixer->numElems] = PORT_DST_UNKNOWN;
-                portMixer->numElems++;
-            }
-            // to prevent buffer overflow
-            if (portMixer->numElems >= MAX_ELEMS) {
-                break;
-            }
-            /* If an element has both playback an capture volume, it is put into the arrays
-               twice. */
-            if (snd_mixer_selem_has_capture_volume(elem)) {
-                portMixer->elems[portMixer->numElems] = elem;
-                portMixer->types[portMixer->numElems] = PORT_SRC_UNKNOWN;
-                portMixer->numElems++;
-            }
-            // to prevent buffer overflow
-            if (portMixer->numElems >= MAX_ELEMS) {
-                break;
-            }
-        }
-    }
-    TRACE0("< PORT_GetPortCount\n");
-    return portMixer->numElems;
-}
-
-
-INT32 PORT_GetPortType(void* id, INT32 portIndex) {
-    PortMixer* portMixer;
-    INT32 type;
-    TRACE0("> PORT_GetPortType\n");
-    if (id == NULL) {
-        // $$mp: Should become a descriptive error code (invalid handle).
-        return -1;
-    }
-    portMixer = (PortMixer*) id;
-    if (portIndex < 0 || portIndex >= portMixer->numElems) {
-        // $$mp: Should become a descriptive error code (index out of bounds).
-        return -1;
-    }
-    type = portMixer->types[portIndex];
-    TRACE0("< PORT_GetPortType\n");
-    return type;
-}
-
-
-INT32 PORT_GetPortName(void* id, INT32 portIndex, char* name, INT32 len) {
-    PortMixer* portMixer;
-    const char* nam;
-
-    TRACE0("> PORT_GetPortName\n");
-    if (id == NULL) {
-        // $$mp: Should become a descriptive error code (invalid handle).
-        return -1;
-    }
-    portMixer = (PortMixer*) id;
-    if (portIndex < 0 || portIndex >= portMixer->numElems) {
-        // $$mp: Should become a descriptive error code (index out of bounds).
-        return -1;
-    }
-    nam = snd_mixer_selem_get_name(portMixer->elems[portIndex]);
-    strncpy(name, nam, len - 1);
-    name[len - 1] = 0;
-    TRACE0("< PORT_GetPortName\n");
-    return TRUE;
-}
-
-
-static int isPlaybackFunction(INT32 portType) {
-        return (portType & PORT_DST_MASK);
-}
-
-
-/* Sets portControl to a pointer to the next free array element in the PortControl (pointer)
-   array of the passed portMixer. Returns TRUE if successful. May return FALSE if there is no
-   free slot. In this case, portControl is not altered */
-static int getControlSlot(PortMixer* portMixer, PortControl** portControl) {
-    if (portMixer->numControls >= MAX_CONTROLS) {
-        return FALSE;
-    } else {
-        *portControl = &(portMixer->controls[portMixer->numControls]);
-        portMixer->numControls++;
-        return TRUE;
-    }
-}
-
-
-/* Protect against illegal min-max values, preventing divisions by zero.
- */
-inline static long getRange(long min, long max) {
-    if (max > min) {
-        return max - min;
-    } else {
-        return 1;
-    }
-}
-
-
-/* Idea: we may specify that if unit is an empty string, the values are linear and if unit is "dB",
-   the values are logarithmic.
-*/
-static void* createVolumeControl(PortControlCreator* creator,
-                                 PortControl* portControl,
-                                 snd_mixer_elem_t* elem, int isPlayback) {
-    void* control;
-    float precision;
-    long min, max;
-
-    if (isPlayback) {
-        snd_mixer_selem_get_playback_volume_range(elem, &min, &max);
-    } else {
-        snd_mixer_selem_get_capture_volume_range(elem, &min, &max);
-    }
-    /* $$mp: The volume values retrieved with the ALSA API are strongly supposed to be logarithmic.
-       So the following calculation is wrong. However, there is no correct calculation, since
-       for equal-distant logarithmic steps, the precision expressed in linear varies over the
-       scale. */
-    precision = 1.0F / getRange(min, max);
-    control = (creator->newFloatControl)(creator, portControl, CONTROL_TYPE_VOLUME, 0.0F, +1.0F, precision, "");
-    return control;
-}
-
-
-void PORT_GetControls(void* id, INT32 portIndex, PortControlCreator* creator) {
-    PortMixer* portMixer;
-    snd_mixer_elem_t* elem;
-    void* control;
-    PortControl* portControl;
-    void* controls[10];
-    int numControls;
-    char* portName;
-    int isPlayback;
-    int isMono;
-    int isStereo;
-    char* type;
-    snd_mixer_selem_channel_id_t channel;
-
-    TRACE0("> PORT_GetControls\n");
-    if (id == NULL) {
-        ERROR0("Invalid handle!");
-        // $$mp: an error code should be returned.
-        return;
-    }
-    portMixer = (PortMixer*) id;
-    if (portIndex < 0 || portIndex >= portMixer->numElems) {
-        ERROR0("Port index out of range!");
-        // $$mp: an error code should be returned.
-        return;
-    }
-    numControls = 0;
-    elem = portMixer->elems[portIndex];
-    if (snd_mixer_selem_has_playback_volume(elem) || snd_mixer_selem_has_capture_volume(elem)) {
-        /* Since we've splitted/duplicated elements with both playback and capture on the recovery
-           of elements, we now can assume that we handle only to deal with either playback or
-           capture. */
-        isPlayback = isPlaybackFunction(portMixer->types[portIndex]);
-        isMono = (isPlayback && snd_mixer_selem_is_playback_mono(elem)) ||
-            (!isPlayback && snd_mixer_selem_is_capture_mono(elem));
-        isStereo = (isPlayback &&
-                    snd_mixer_selem_has_playback_channel(elem, SND_MIXER_SCHN_FRONT_LEFT) &&
-                    snd_mixer_selem_has_playback_channel(elem, SND_MIXER_SCHN_FRONT_RIGHT)) ||
-            (!isPlayback &&
-             snd_mixer_selem_has_capture_channel(elem, SND_MIXER_SCHN_FRONT_LEFT) &&
-             snd_mixer_selem_has_capture_channel(elem, SND_MIXER_SCHN_FRONT_RIGHT));
-        // single volume control
-        if (isMono || isStereo) {
-            if (getControlSlot(portMixer, &portControl)) {
-                portControl->elem = elem;
-                portControl->portType = portMixer->types[portIndex];
-                portControl->controlType = CONTROL_TYPE_VOLUME;
-                if (isMono) {
-                    portControl->channel = CHANNELS_MONO;
-                } else {
-                    portControl->channel = CHANNELS_STEREO;
-                }
-                control = createVolumeControl(creator, portControl, elem, isPlayback);
-                if (control != NULL) {
-                    controls[numControls++] = control;
-                }
-            }
-        } else { // more than two channels, each channels has its own control.
-            for (channel = SND_MIXER_SCHN_FRONT_LEFT; channel <= SND_MIXER_SCHN_LAST; channel++) {
-                if (isPlayback && snd_mixer_selem_has_playback_channel(elem, channel) ||
-                    !isPlayback && snd_mixer_selem_has_capture_channel(elem, channel)) {
-                    if (getControlSlot(portMixer, &portControl)) {
-                        portControl->elem = elem;
-                        portControl->portType = portMixer->types[portIndex];
-                        portControl->controlType = CONTROL_TYPE_VOLUME;
-                        portControl->channel = channel;
-                        control = createVolumeControl(creator, portControl, elem, isPlayback);
-                        // We wrap in a compound control to provide the channel name.
-                        if (control != NULL) {
-                            /* $$mp 2003-09-14: The following cast shouln't be necessary. Instead, the
-                               declaration of PORT_NewCompoundControlPtr in Ports.h should be changed
-                               to take a const char* parameter. */
-                            control = (creator->newCompoundControl)(creator, (char*) snd_mixer_selem_channel_name(channel), &control, 1);
-                        }
-                        if (control != NULL) {
-                            controls[numControls++] = control;
-                        }
-                    }
-                }
-            }
-        }
-        // BALANCE control
-        if (isStereo) {
-            if (getControlSlot(portMixer, &portControl)) {
-                portControl->elem = elem;
-                portControl->portType = portMixer->types[portIndex];
-                portControl->controlType = CONTROL_TYPE_BALANCE;
-                portControl->channel = CHANNELS_STEREO;
-                /* $$mp: The value for precision is chosen more or less arbitrarily. */
-                control = (creator->newFloatControl)(creator, portControl, CONTROL_TYPE_BALANCE, -1.0F, 1.0F, 0.01F, "");
-                if (control != NULL) {
-                    controls[numControls++] = control;
-                }
-            }
-        }
-    }
-    if (snd_mixer_selem_has_playback_switch(elem) || snd_mixer_selem_has_capture_switch(elem)) {
-        if (getControlSlot(portMixer, &portControl)) {
-            type = isPlayback ? CONTROL_TYPE_MUTE : CONTROL_TYPE_SELECT;
-            portControl->elem = elem;
-            portControl->portType = portMixer->types[portIndex];
-            portControl->controlType = type;
-            control = (creator->newBooleanControl)(creator, portControl, type);
-            if (control != NULL) {
-                controls[numControls++] = control;
-            }
-        }
-    }
-    /* $$mp 2003-09-14: The following cast shouln't be necessary. Instead, the
-       declaration of PORT_NewCompoundControlPtr in Ports.h should be changed
-       to take a const char* parameter. */
-    portName = (char*) snd_mixer_selem_get_name(elem);
-    control = (creator->newCompoundControl)(creator, portName, controls, numControls);
-    if (control != NULL) {
-        (creator->addControl)(creator, control);
-    }
-    TRACE0("< PORT_GetControls\n");
-}
-
-
-INT32 PORT_GetIntValue(void* controlIDV) {
-    PortControl* portControl = (PortControl*) controlIDV;
-    int value = 0;
-    snd_mixer_selem_channel_id_t channel;
-
-    if (portControl != NULL) {
-        switch (portControl->channel) {
-        case CHANNELS_MONO:
-            channel = SND_MIXER_SCHN_MONO;
-            break;
-
-        case CHANNELS_STEREO:
-            channel = SND_MIXER_SCHN_FRONT_LEFT;
-            break;
-
-        default:
-            channel = portControl->channel;
-        }
-        if (portControl->controlType == CONTROL_TYPE_MUTE ||
-            portControl->controlType == CONTROL_TYPE_SELECT) {
-            if (isPlaybackFunction(portControl->portType)) {
-                snd_mixer_selem_get_playback_switch(portControl->elem, channel, &value);
-            } else {
-                snd_mixer_selem_get_capture_switch(portControl->elem, channel, &value);
-            }
-            if (portControl->controlType == CONTROL_TYPE_MUTE) {
-                value = ! value;
-            }
-        } else {
-            ERROR1("PORT_GetIntValue(): inappropriate control type: %s\n",
-                   portControl->controlType);
-        }
-    }
-    return (INT32) value;
-}
-
-
-void PORT_SetIntValue(void* controlIDV, INT32 value) {
-    PortControl* portControl = (PortControl*) controlIDV;
-    snd_mixer_selem_channel_id_t channel;
-
-    if (portControl != NULL) {
-        if (portControl->controlType == CONTROL_TYPE_MUTE) {
-            value = ! value;
-        }
-        if (portControl->controlType == CONTROL_TYPE_MUTE ||
-            portControl->controlType == CONTROL_TYPE_SELECT) {
-            if (isPlaybackFunction(portControl->portType)) {
-                snd_mixer_selem_set_playback_switch_all(portControl->elem, value);
-            } else {
-                snd_mixer_selem_set_capture_switch_all(portControl->elem, value);
-            }
-        } else {
-            ERROR1("PORT_SetIntValue(): inappropriate control type: %s\n",
-                   portControl->controlType);
-        }
-    }
-}
-
-
-static float scaleVolumeValueToNormalized(long value, long min, long max) {
-    return (float) (value - min) / getRange(min, max);
-}
-
-
-static long scaleVolumeValueToHardware(float value, long min, long max) {
-    return (long)(value * getRange(min, max) + min);
-}
-
-
-float getRealVolume(PortControl* portControl,
-                    snd_mixer_selem_channel_id_t channel) {
-    float fValue;
-    long lValue = 0;
-    long min = 0;
-    long max = 0;
-
-    if (isPlaybackFunction(portControl->portType)) {
-        snd_mixer_selem_get_playback_volume_range(portControl->elem,
-                                                  &min, &max);
-        snd_mixer_selem_get_playback_volume(portControl->elem,
-                                            channel, &lValue);
-    } else {
-        snd_mixer_selem_get_capture_volume_range(portControl->elem,
-                                                 &min, &max);
-        snd_mixer_selem_get_capture_volume(portControl->elem,
-                                           channel, &lValue);
-    }
-    fValue = scaleVolumeValueToNormalized(lValue, min, max);
-    return fValue;
-}
-
-
-void setRealVolume(PortControl* portControl,
-                   snd_mixer_selem_channel_id_t channel, float value) {
-    long lValue = 0;
-    long min = 0;
-    long max = 0;
-
-    if (isPlaybackFunction(portControl->portType)) {
-        snd_mixer_selem_get_playback_volume_range(portControl->elem,
-                                                  &min, &max);
-        lValue = scaleVolumeValueToHardware(value, min, max);
-        snd_mixer_selem_set_playback_volume(portControl->elem,
-                                            channel, lValue);
-    } else {
-        snd_mixer_selem_get_capture_volume_range(portControl->elem,
-                                                 &min, &max);
-        lValue = scaleVolumeValueToHardware(value, min, max);
-        snd_mixer_selem_set_capture_volume(portControl->elem,
-                                           channel, lValue);
-    }
-}
-
-
-static float getFakeBalance(PortControl* portControl) {
-    float volL, volR;
-
-    // pan is the ratio of left and right
-    volL = getRealVolume(portControl, SND_MIXER_SCHN_FRONT_LEFT);
-    volR = getRealVolume(portControl, SND_MIXER_SCHN_FRONT_RIGHT);
-    if (volL > volR) {
-        return -1.0f + (volR / volL);
-    }
-    else if (volR > volL) {
-        return 1.0f - (volL / volR);
-    }
-    return 0.0f;
-}
-
-
-static float getFakeVolume(PortControl* portControl) {
-    float valueL;
-    float valueR;
-    float value;
-
-    valueL = getRealVolume(portControl, SND_MIXER_SCHN_FRONT_LEFT);
-    valueR = getRealVolume(portControl, SND_MIXER_SCHN_FRONT_RIGHT);
-    // volume is the greater value of both
-    value = valueL > valueR ? valueL : valueR ;
-    return value;
-}
-
-
-/*
- * sets the unsigned values for left and right volume according to
- * the given volume (0...1) and balance (-1..0..+1)
- */
-static void setFakeVolume(PortControl* portControl, float vol, float bal) {
-    float volumeLeft;
-    float volumeRight;
-
-    if (bal < 0.0f) {
-        volumeLeft = vol;
-        volumeRight = vol * (bal + 1.0f);
-    } else {
-        volumeLeft = vol * (1.0f - bal);
-        volumeRight = vol;
-    }
-    setRealVolume(portControl, SND_MIXER_SCHN_FRONT_LEFT, volumeLeft);
-    setRealVolume(portControl, SND_MIXER_SCHN_FRONT_RIGHT, volumeRight);
-}
-
-
-float PORT_GetFloatValue(void* controlIDV) {
-    PortControl* portControl = (PortControl*) controlIDV;
-    float value = 0.0F;
-
-    if (portControl != NULL) {
-        if (portControl->controlType == CONTROL_TYPE_VOLUME) {
-            switch (portControl->channel) {
-            case CHANNELS_MONO:
-                value = getRealVolume(portControl, SND_MIXER_SCHN_MONO);
-                break;
-
-            case CHANNELS_STEREO:
-                value = getFakeVolume(portControl);
-                break;
-
-            default:
-                value = getRealVolume(portControl, portControl->channel);
-            }
-        } else if (portControl->controlType == CONTROL_TYPE_BALANCE) {
-            if (portControl->channel == CHANNELS_STEREO) {
-                value = getFakeBalance(portControl);
-            } else {
-                ERROR0("PORT_GetFloatValue(): Balance only allowed for stereo channels!\n");
-            }
-        } else {
-            ERROR1("PORT_GetFloatValue(): inappropriate control type: %s!\n",
-                   portControl->controlType);
-        }
-    }
-    return value;
-}
-
-
-void PORT_SetFloatValue(void* controlIDV, float value) {
-    PortControl* portControl = (PortControl*) controlIDV;
-
-    if (portControl != NULL) {
-        if (portControl->controlType == CONTROL_TYPE_VOLUME) {
-            switch (portControl->channel) {
-            case CHANNELS_MONO:
-                setRealVolume(portControl, SND_MIXER_SCHN_MONO, value);
-                break;
-
-            case CHANNELS_STEREO:
-                setFakeVolume(portControl, value, getFakeBalance(portControl));
-                break;
-
-            default:
-                setRealVolume(portControl, portControl->channel, value);
-            }
-        } else if (portControl->controlType == CONTROL_TYPE_BALANCE) {
-            if (portControl->channel == CHANNELS_STEREO) {
-                setFakeVolume(portControl, getFakeVolume(portControl), value);
-            } else {
-                ERROR0("PORT_SetFloatValue(): Balance only allowed for stereo channels!\n");
-            }
-        } else {
-            ERROR1("PORT_SetFloatValue(): inappropriate control type: %s!\n",
-                   portControl->controlType);
-        }
-    }
-}
-
-
-#endif // USE_PORTS
--- ./jdk/src/solaris/native/java/io/UnixFileSystem_md.c	2010-03-18 01:45:35.000000000 -0700
+++ ./jdk/src/solaris/native/java/io/UnixFileSystem_md.c	2010-03-20 17:09:44.000000000 -0700
@@ -41,6 +41,12 @@
 #include "java_io_FileSystem.h"
 #include "java_io_UnixFileSystem.h"
 
+#if defined(_ALLBSD_SOURCE)
+#define dirent64 dirent
+#define readdir64_r readdir_r
+#define stat64 stat
+#define statvfs64 statvfs
+#endif
 
 /* -- Field IDs -- */
 
@@ -140,7 +146,6 @@
     return rv;
 }
 
-
 JNIEXPORT jboolean JNICALL
 Java_java_io_UnixFileSystem_setPermission(JNIEnv *env, jobject this,
                                           jobject file,
--- ./jdk/src/solaris/native/java/io/canonicalize_md.c	2010-03-18 01:45:35.000000000 -0700
+++ ./jdk/src/solaris/native/java/io/canonicalize_md.c	2010-01-30 09:28:33.000000000 -0800
@@ -33,7 +33,9 @@
 #include <sys/stat.h>
 #include <errno.h>
 #include <limits.h>
+#if !defined(_ALLBSD_SOURCE)
 #include <alloca.h>
+#endif
 
 
 /* Note: The comments in this file use the terminology
--- ./jdk/src/solaris/native/java/io/io_util_md.c	2010-03-18 01:45:35.000000000 -0700
+++ ./jdk/src/solaris/native/java/io/io_util_md.c	2010-01-30 09:28:33.000000000 -0800
@@ -36,7 +36,7 @@
     WITH_PLATFORM_STRING(env, path, ps) {
         FD fd;
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
         /* Remove trailing slashes, since the kernel won't */
         char *p = (char *)ps + strlen(ps) - 1;
         while ((p > ps) && (*p == '/'))
--- ./jdk/src/solaris/native/java/lang/ProcessEnvironment_md.c	2010-03-18 01:45:35.000000000 -0700
+++ ./jdk/src/solaris/native/java/lang/ProcessEnvironment_md.c	2010-01-30 09:28:33.000000000 -0800
@@ -28,6 +28,11 @@
 #include "jni.h"
 #include "jni_util.h"
 
+#ifdef __APPLE__
+#include <crt_externs.h>
+#define environ (*_NSGetEnviron())
+#endif
+
 JNIEXPORT jobjectArray JNICALL
 Java_java_lang_ProcessEnvironment_environ(JNIEnv *env, jclass ign)
 {
@@ -37,7 +42,9 @@
      * no standard (not even de-facto) header file where the
      * declaration is to be found.  See:
      * http://www.opengroup.org/onlinepubs/007908799/xbd/envvar.html */
+#ifndef __APPLE__
     extern char ** environ; /* environ[i] looks like: VAR=VALUE\0 */
+#endif
 
     jsize count = 0;
     jsize i, j;
@@ -46,7 +53,7 @@
 
     for (i = 0; environ[i]; i++) {
         /* Ignore corrupted environment variables */
-        if (strchr(environ[i], '=') != NULL)
+        if (strchr(environ[i], '=') != NULL && *environ[i] != '=')
             count++;
     }
 
@@ -56,7 +63,7 @@
     for (i = 0, j = 0; environ[i]; i++) {
         const char * varEnd = strchr(environ[i], '=');
         /* Ignore corrupted environment variables */
-        if (varEnd != NULL) {
+        if (varEnd != NULL && varEnd != environ[i]) {
             jbyteArray var, val;
             const char * valBeg = varEnd + 1;
             jsize varLength = varEnd - environ[i];
--- ./jdk/src/solaris/native/java/lang/UNIXProcess_md.c	2010-03-18 01:45:35.000000000 -0700
+++ ./jdk/src/solaris/native/java/lang/UNIXProcess_md.c	2010-01-30 09:28:33.000000000 -0800
@@ -40,7 +40,11 @@
 #include <stdlib.h>
 #include <sys/types.h>
 #include <ctype.h>
+#ifdef _ALLBSD_SOURCE
+#include <sys/wait.h>
+#else
 #include <wait.h>
+#endif
 #include <signal.h>
 #include <string.h>
 #include <errno.h>
@@ -49,6 +53,17 @@
 #include <fcntl.h>
 #include <limits.h>
 
+#ifdef __FreeBSD__
+#include <dlfcn.h>
+#include <pthread.h>
+#include <pthread_np.h>
+#endif
+
+#ifdef __APPLE__
+#include <crt_externs.h>
+#define environ (*_NSGetEnviron())
+#endif
+
 /*
  * There are 3 possible strategies we might use to "fork":
  *
@@ -385,6 +400,32 @@
   return c >= '0' && c <= '9';
 }
 
+#if defined(__OpenBSD__)
+/*
+ * Directly call _thread_sys_closefrom() so the child process
+ * doesn't reset the parrent's file descriptors to be blocking.
+ * This function is only called from the child process which
+ * is single threaded and about to call execvp() so it is
+ * safe to bypass the threaded closefrom().
+ */
+int _thread_sys_closefrom(int);
+
+static int
+closeDescriptors(void)
+{
+  return _thread_sys_closefrom(FAIL_FILENO + 1);
+}
+
+#else
+
+#ifdef _ALLBSD_SOURCE
+#define FD_DIR "/dev/fd"
+#define dirent64 dirent
+#define readdir64 readdir
+#else
+#define FD_DIR "/proc/self/fd"
+#endif
+
 static int
 closeDescriptors(void)
 {
@@ -402,7 +443,7 @@
     restartableClose(from_fd);          /* for possible use by opendir() */
     restartableClose(from_fd + 1);      /* another one for good luck */
 
-    if ((dp = opendir("/proc/self/fd")) == NULL)
+    if ((dp = opendir(FD_DIR)) == NULL)
         return 0;
 
     /* We use readdir64 instead of readdir to work around Solaris bug
@@ -419,6 +460,7 @@
 
     return 1;
 }
+#endif /* !__OpenBSD__ */
 
 static int
 moveDescriptor(int fd_from, int fd_to)
@@ -556,6 +598,21 @@
             const char *argv[],
             const char *const envp[])
 {
+    /* This is one of the rare times it's more portable to declare an
+     * external symbol explicitly, rather than via a system header.
+     * The declaration is standardized as part of UNIX98, but there is
+     * no standard (not even de-facto) header file where the
+     * declaration is to be found.  See:
+     * http://www.opengroup.org/onlinepubs/009695399/functions/environ.html
+     * http://www.opengroup.org/onlinepubs/009695399/functions/xsh_chap02_02.html
+     *
+     * "All identifiers in this volume of IEEE Std 1003.1-2001, except
+     * environ, are defined in at least one of the headers" (!)
+     */
+#ifndef __APPLE__
+    extern char **environ;
+#endif
+
     if (envp == NULL || (char **) envp == environ) {
         execvp(file, (char **) argv);
         return;
--- ./jdk/src/solaris/native/java/lang/java_props_md.c	2010-03-18 01:45:35.000000000 -0700
+++ ./jdk/src/solaris/native/java/lang/java_props_md.c	2010-01-30 09:28:33.000000000 -0800
@@ -23,7 +23,7 @@
  * have any questions.
  */
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <stdio.h>
 #include <ctype.h>
 #endif
@@ -42,9 +42,17 @@
 #include <time.h>
 #include <errno.h>
 
+#if defined(_ALLBSD_SOURCE)
+#if !defined(P_tmpdir)
+#include <paths.h>
+#define P_tmpdir _PATH_VARTMP
+#endif
+#endif
+
 #include "locale_str.h"
 #include "java_props.h"
 
+#if !defined(_ALLBSD_SOURCE)
 #ifdef __linux__
 #define CODESET _NL_CTYPE_CODESET_NAME
 #else
@@ -52,6 +60,7 @@
 #define CODESET ALT_CODESET_KEY
 #endif
 #endif
+#endif /* !_ALLBSD_SOURCE */
 
 /* Take an array of string pairs (map of key->value) and a string (key).
  * Examine each pair in the map to see if the first string (key) matches the
@@ -121,7 +130,7 @@
 java_props_t *
 GetJavaProperties(JNIEnv *env)
 {
-    static java_props_t sprops = {0};
+    static java_props_t sprops = { 0 };
     char *v; /* tmp var */
 
     if (sprops.user_dir) {
@@ -188,7 +197,12 @@
     {
         char *lc;
         lc = setlocale(LC_CTYPE, "");
-#ifndef __linux__
+#if defined(_ALLBSD_SOURCE)
+	if (lc == NULL) {
+	    lc = "C";
+	}
+	{
+#elif !defined(__linux__)
         if (lc == NULL) {
             /*
              * 'lc == null' means system doesn't support user's environment
@@ -219,7 +233,7 @@
             char *p, encoding_variant[64];
             int i, found;
 
-#ifndef __linux__
+#if !defined(__linux__) && !defined(_ALLBSD_SOURCE)
             /*
              * Workaround for Solaris bug 4201684: Xlib doesn't like @euro
              * locales. Since we don't depend on the libc @euro behavior,
@@ -236,6 +250,13 @@
                 *p = '\0';
             setlocale(LC_ALL, temp);
 #endif
+	    if (lc == NULL) {
+		strncpy(temp, "C", sizeof(temp)-1);
+		temp[sizeof(temp)-1] = '\0';
+	    } else {
+		strncpy(temp, lc, sizeof(temp)-1);
+		temp[sizeof(temp)-1] = '\0';
+	    }
 
             strcpy(temp, lc);
 
@@ -316,6 +337,9 @@
             else
                 p = nl_langinfo(CODESET);
 
+	    if (p == NULL || !strcmp(p, "C") || !strcmp(p, "US-ASCII"))
+		p = ""; // use default
+
             /* Convert the bare "646" used on Solaris to a proper IANA name */
             if (strcmp(p, "646") == 0)
                 p = "ISO646-US";
@@ -325,6 +349,7 @@
             std_encoding = (*p != '\0') ? p : "ISO8859-1";
 
 
+#if !defined(_ALLBSD_SOURCE)
 #ifdef __linux__
             /*
              * Remap the encoding string to a different value for japanese
@@ -355,11 +380,19 @@
                     std_encoding = "Big5_Solaris";
             }
 #endif
+#endif /* !_ALLBSD_SOURCE */
             sprops.encoding = std_encoding;
             sprops.sun_jnu_encoding = sprops.encoding;
         }
     }
 
+#ifdef _ALLBSD_SOURCE
+#if BYTE_ORDER == _LITTLE_ENDIAN
+     sprops.unicode_encoding = "UnicodeLittle";
+ #else
+     sprops.unicode_encoding = "UnicodeBig";
+ #endif
+#else /* !_ALLBSD_SOURCE */
 #ifdef __linux__
 #if __BYTE_ORDER == __LITTLE_ENDIAN
     sprops.unicode_encoding = "UnicodeLittle";
@@ -369,6 +402,7 @@
 #else
     sprops.unicode_encoding = "UnicodeBig";
 #endif
+#endif /* _ALLBSD_SOURCE */
 
     /* user properties */
     {
@@ -405,12 +439,14 @@
     sprops.path_separator = ":";
     sprops.line_separator = "\n";
 
+#if !defined(_ALLBSD_SOURCE)
     /* Append CDE message and resource search path to NLSPATH and
      * XFILESEARCHPATH, in order to pick localized message for
      * FileSelectionDialog window (Bug 4173641).
      */
     setPathEnvironment("NLSPATH=/usr/dt/lib/nls/msg/%L/%N.cat");
     setPathEnvironment("XFILESEARCHPATH=/usr/dt/app-defaults/%L/Dt");
+#endif
 
     return &sprops;
 }
--- ./jdk/src/solaris/native/java/net/Inet4AddressImpl.c	2010-03-18 01:45:35.000000000 -0700
+++ ./jdk/src/solaris/native/java/net/Inet4AddressImpl.c	2010-02-21 16:57:14.000000000 -0800
@@ -36,12 +36,288 @@
 #include <stdlib.h>
 #include <ctype.h>
 
+#ifdef _ALLBSD_SOURCE
+#include <unistd.h>
+#include <sys/param.h>
+#endif
+
 #include "jvm.h"
 #include "jni_util.h"
 #include "net_util.h"
 
 #include "java_net_Inet4AddressImpl.h"
 
+#if defined(__GLIBC__) || (defined(__FreeBSD__) && (__FreeBSD_version >= 601104))
+#define HAS_GLIBC_GETHOSTBY_R	1
+#endif
+
+#if defined(_ALLBSD_SOURCE) && !defined(HAS_GLIBC_GETHOSTBY_R)
+/* Use getaddrinfo(3), which is thread safe */
+/************************************************************************
+ * Inet4AddressImpl
+ */
+
+/*
+ * Class:     java_net_Inet4AddressImpl
+ * Method:    getLocalHostName
+ * Signature: ()Ljava/lang/String;
+ */
+JNIEXPORT jstring JNICALL
+Java_java_net_Inet4AddressImpl_getLocalHostName(JNIEnv *env, jobject this) {
+    char hostname[NI_MAXHOST+1];
+
+    hostname[0] = '\0';
+    if (JVM_GetHostName(hostname, NI_MAXHOST)) {
+	/* Something went wrong, maybe networking is not setup? */
+	strcpy(hostname, "localhost");
+    } else {
+	 struct addrinfo  hints, *res;
+	 int error;
+
+	 memset(&hints, 0, sizeof(hints));
+	 hints.ai_flags = AI_CANONNAME;
+	 hints.ai_family = AF_UNSPEC;
+
+	 error = getaddrinfo(hostname, NULL, &hints, &res);
+
+	 if (error == 0) {
+	     /* host is known to name service */
+	     error = getnameinfo(res->ai_addr,
+				 res->ai_addrlen,
+				 hostname,
+				 NI_MAXHOST,
+				 NULL,
+				 0,
+				 NI_NAMEREQD);
+
+	     /* if getnameinfo fails hostname is still the value
+	        from gethostname */
+
+	     freeaddrinfo(res);
+	}
+    }
+    return (*env)->NewStringUTF(env, hostname);
+}
+
+static jclass ni_iacls;
+static jclass ni_ia4cls;
+static jmethodID ni_ia4ctrID;
+static jfieldID ni_iaaddressID;
+static jfieldID ni_iahostID;
+static jfieldID ni_iafamilyID;
+static int initialized = 0;
+
+/*
+ * Find an internet address for a given hostname.  Note that this
+ * code only works for addresses of type INET. The translation
+ * of %d.%d.%d.%d to an address (int) occurs in java now, so the
+ * String "host" shouldn't *ever* be a %d.%d.%d.%d string
+ *
+ * Class:     java_net_Inet4AddressImpl
+ * Method:    lookupAllHostAddr
+ * Signature: (Ljava/lang/String;)[[B
+ */
+
+JNIEXPORT jobjectArray JNICALL
+Java_java_net_Inet4AddressImpl_lookupAllHostAddr(JNIEnv *env, jobject this,
+						jstring host) {
+    const char *hostname;
+    jobject name;
+    jobjectArray ret = 0;
+    int retLen = 0;
+
+    int error=0;
+    struct addrinfo hints, *res, *resNew = NULL;
+
+    if (!initialized) {
+      ni_iacls = (*env)->FindClass(env, "java/net/InetAddress");
+      ni_iacls = (*env)->NewGlobalRef(env, ni_iacls);
+      ni_ia4cls = (*env)->FindClass(env, "java/net/Inet4Address");
+      ni_ia4cls = (*env)->NewGlobalRef(env, ni_ia4cls);
+      ni_ia4ctrID = (*env)->GetMethodID(env, ni_ia4cls, "<init>", "()V");
+      ni_iaaddressID = (*env)->GetFieldID(env, ni_iacls, "address", "I");
+      ni_iafamilyID = (*env)->GetFieldID(env, ni_iacls, "family", "I");
+      ni_iahostID = (*env)->GetFieldID(env, ni_iacls, "hostName", "Ljava/lang/String;");
+      initialized = 1;
+    }
+
+    if (IS_NULL(host)) {
+	JNU_ThrowNullPointerException(env, "host is null");
+	return 0;
+    }
+    hostname = JNU_GetStringPlatformChars(env, host, JNI_FALSE);
+    CHECK_NULL_RETURN(hostname, NULL);
+
+    memset(&hints, 0, sizeof(hints));
+    hints.ai_flags = AI_CANONNAME;
+    hints.ai_family = AF_INET;
+
+    /*
+     * Workaround for Solaris bug 4160367 - if a hostname contains a
+     * white space then 0.0.0.0 is returned
+     */
+    if (isspace((unsigned char)hostname[0])) {
+	JNU_ThrowByName(env, JNU_JAVANETPKG "UnknownHostException",
+			(char *)hostname);
+	JNU_ReleaseStringPlatformChars(env, host, hostname);
+	return NULL;
+    }
+	
+    error = getaddrinfo(hostname, NULL, &hints, &res);
+	
+    if (error) {
+	/* report error */
+	JNU_ThrowByName(env, JNU_JAVANETPKG "UnknownHostException",
+			(char *)hostname);
+	JNU_ReleaseStringPlatformChars(env, host, hostname);
+	return NULL;
+    } else {
+	int i = 0;
+	struct addrinfo *itr, *last = NULL, *iterator = res;
+	while (iterator != NULL) {
+	    int skip = 0;
+	    itr = resNew;
+
+	    while (itr != NULL) {
+		struct sockaddr_in *addr1, *addr2;
+
+		addr1 = (struct sockaddr_in *)iterator->ai_addr;
+		addr2 = (struct sockaddr_in *)itr->ai_addr;
+		if (addr1->sin_addr.s_addr ==
+		    addr2->sin_addr.s_addr) {
+		    skip = 1;
+		    break;
+		}
+		     
+		itr = itr->ai_next;
+	    }
+		
+	    if (!skip) {
+		struct addrinfo *next
+	            = (struct addrinfo*) malloc(sizeof(struct addrinfo));
+		if (!next) {
+		    JNU_ThrowOutOfMemoryError(env, "heap allocation failed");
+		    ret = NULL;
+		    goto cleanupAndReturn;
+		}
+		memcpy(next, iterator, sizeof(struct addrinfo));
+		next->ai_next = NULL;
+		if (resNew == NULL) {
+		    resNew = next;
+		} else {
+		    last->ai_next = next;
+		}
+		last = next;
+		i++;
+	    }
+	    iterator = iterator->ai_next;
+	}
+
+	retLen = i;
+	iterator = resNew;
+	i = 0;
+
+        name = (*env)->NewStringUTF(env, hostname);
+        if (IS_NULL(name)) {
+          goto cleanupAndReturn;
+        }
+
+	ret = (*env)->NewObjectArray(env, retLen, ni_iacls, NULL);
+	if (IS_NULL(ret)) {
+	    /* we may have memory to free at the end of this */
+	    goto cleanupAndReturn;
+	}
+
+	while (iterator != NULL) {
+	    /* We need 4 bytes to store ipv4 address; */
+	    int len = 4;
+		
+            jobject iaObj = (*env)->NewObject(env, ni_ia4cls, ni_ia4ctrID);
+	    if (IS_NULL(iaObj)) {
+		/* we may have memory to free at the end of this */
+		ret = NULL;
+		goto cleanupAndReturn;
+	    }
+            (*env)->SetIntField(env, iaObj, ni_iaaddressID,
+                                ntohl(((struct sockaddr_in*)(iterator->ai_addr))->sin_addr.s_addr));
+            (*env)->SetObjectField(env, iaObj, ni_iahostID, name);
+            (*env)->SetObjectArrayElement(env, ret, retLen - i -1, iaObj);
+	    i++;
+	    iterator = iterator->ai_next;
+	}
+    }
+    
+cleanupAndReturn:
+    {
+	struct addrinfo *iterator, *tmp;
+	iterator = resNew;
+	while (iterator != NULL) {
+	    tmp = iterator;
+	    iterator = iterator->ai_next;
+	    free(tmp);
+	}
+	JNU_ReleaseStringPlatformChars(env, host, hostname);
+    }
+   
+    freeaddrinfo(res);
+    
+    return ret;
+
+}
+
+/*
+ * Class:     java_net_Inet4AddressImpl
+ * Method:    getHostByAddr
+ * Signature: (I)Ljava/lang/String;
+ */
+JNIEXPORT jstring JNICALL
+Java_java_net_Inet4AddressImpl_getHostByAddr(JNIEnv *env, jobject this,
+					    jbyteArray addrArray) {
+    jstring ret = NULL;
+
+    char host[NI_MAXHOST+1];
+    jfieldID fid;
+    int error = 0;
+    jint family;
+    struct sockaddr *him ; 
+    int len = 0;
+    jbyte caddr[4];
+    jint addr;
+
+    struct sockaddr_in him4;
+    struct sockaddr *sa;
+
+    /* 
+	 * For IPv4 addresses construct a sockaddr_in structure.
+	 */
+    (*env)->GetByteArrayRegion(env, addrArray, 0, 4, caddr);
+    addr = ((caddr[0]<<24) & 0xff000000);
+    addr |= ((caddr[1] <<16) & 0xff0000);
+    addr |= ((caddr[2] <<8) & 0xff00);
+    addr |= (caddr[3] & 0xff);
+    memset((char *) &him4, 0, sizeof(him4));
+    him4.sin_addr.s_addr = (uint32_t) htonl(addr);
+    him4.sin_family = AF_INET;
+    sa = (struct sockaddr *) &him4;
+    len = sizeof(him4);
+    
+    error = getnameinfo(sa, len, host, NI_MAXHOST, NULL, 0,
+			       NI_NAMEREQD);
+
+    if (!error) {
+	ret = (*env)->NewStringUTF(env, host);
+    }
+
+    if (ret == NULL) {
+	JNU_ThrowByName(env, JNU_JAVANETPKG "UnknownHostException", NULL);
+    }
+
+    return ret;
+
+}
+
+#else /* defined(_ALLBSD_SOURCE) && !defined(HAS_GLIBC_GETHOSTBY_R) */
+
 /* the initial size of our hostent buffers */
 #define HENT_BUF_SIZE 1024
 #define BIG_HENT_BUF_SIZE 10240  /* a jumbo-sized one */
@@ -81,13 +357,13 @@
         char buf2[HENT_BUF_SIZE];
         int h_error=0;
 
-#ifdef __GLIBC__
+#ifdef HAS_GLIBC_GETHOSTBY_R
         gethostbyname_r(hostname, &res, buf, sizeof(buf), &hp, &h_error);
 #else
         hp = gethostbyname_r(hostname, &res, buf, sizeof(buf), &h_error);
 #endif
         if (hp) {
-#ifdef __GLIBC__
+#ifdef HAS_GLIBC_GETHOSTBY_R
             gethostbyaddr_r(hp->h_addr, hp->h_length, AF_INET,
                             &res2, buf2, sizeof(buf2), &hp, &h_error);
 #else
@@ -175,7 +451,7 @@
 #endif
 
     /* Try once, with our static buffer. */
-#ifdef __GLIBC__
+#ifdef HAS_GLIBC_GETHOSTBY_R
     gethostbyname_r(hostname, &res, buf, sizeof(buf), &hp, &h_error);
 #else
     hp = gethostbyname_r(hostname, &res, buf, sizeof(buf), &h_error);
@@ -188,7 +464,7 @@
      */
     if (hp == NULL && errno == ERANGE) {
         if ((tmp = (char*)malloc(BIG_HENT_BUF_SIZE))) {
-#ifdef __GLIBC__
+#ifdef HAS_GLIBC_GETHOSTBY_R
             gethostbyname_r(hostname, &res, tmp, BIG_HENT_BUF_SIZE,
                             &hp, &h_error);
 #else
@@ -271,7 +547,7 @@
     addr |= ((caddr[2] <<8) & 0xff00);
     addr |= (caddr[3] & 0xff);
     addr = htonl(addr);
-#ifdef __GLIBC__
+#ifdef HAS_GLIBC_GETHOSTBY_R
     gethostbyaddr_r((char *)&addr, sizeof(addr), AF_INET, &hent,
                     buf, sizeof(buf), &hp, &h_error);
 #else
@@ -285,7 +561,7 @@
      */
     if (hp == NULL && errno == ERANGE) {
         if ((tmp = (char*)malloc(BIG_HENT_BUF_SIZE))) {
-#ifdef __GLIBC__
+#ifdef HAS_GLIBC_GETHOSTBY_R
             gethostbyaddr_r((char *)&addr, sizeof(addr), AF_INET,
                             &hent, tmp, BIG_HENT_BUF_SIZE, &hp, &h_error);
 #else
@@ -307,6 +583,8 @@
     return ret;
 }
 
+#endif /* _ALLBSD_SOURCE */
+
 #define SET_NONBLOCKING(fd) {           \
         int flags = fcntl(fd, F_GETFL); \
         flags |= O_NONBLOCK;            \
--- ./jdk/src/solaris/native/java/net/Inet6AddressImpl.c	2010-03-18 01:45:35.000000000 -0700
+++ ./jdk/src/solaris/native/java/net/Inet6AddressImpl.c	2010-02-21 16:57:25.000000000 -0800
@@ -33,6 +33,9 @@
 #include <strings.h>
 #include <stdlib.h>
 #include <ctype.h>
+#ifdef _ALLBSD_SOURCE
+#include <unistd.h> /* gethostname */
+#endif
 
 #include "jvm.h"
 #include "jni_util.h"
@@ -68,10 +71,18 @@
         /* Something went wrong, maybe networking is not setup? */
         strcpy(hostname, "localhost");
     } else {
-#ifdef __linux__
-        /* On Linux gethostname() says "host.domain.sun.com".  On
+#if defined(__linux__) && defined(_ALLBSD_SOURCE)
+	/* On Linux/FreeBSD gethostname() says "host.domain.sun.com".  On
          * Solaris gethostname() says "host", so extra work is needed.
          */
+        /*
+         * XXXBSD: Though on FreeBSD it's possible case then hostname does
+         * not contain '.' (depends on previous sethostname() call).  Maybe
+         * we need to proceed with Solaris way, but using getnameinfo()
+         * in conjunction with gethostby*() breaks thread-safeness, so
+         * we need to protect all calls to gethostby*() and getnameinfo()
+         * using same mutex.
+         */
 #else
         /* Solaris doesn't want to give us a fully qualified domain name.
          * We do a reverse lookup to try and get one.  This works
@@ -107,7 +118,7 @@
             }
         }
 #endif /* AF_INET6 */
-#endif /* __linux__ */
+#endif /* __linux__ || _ALLBSD_SOURCE */
     }
     return (*env)->NewStringUTF(env, hostname);
 }
--- ./jdk/src/solaris/native/java/net/NetworkInterface.c	2010-03-18 01:45:35.000000000 -0700
+++ ./jdk/src/solaris/native/java/net/NetworkInterface.c	2010-02-19 08:02:42.000000000 -0800
@@ -23,13 +23,13 @@
  * have any questions.
  */
 
+#include <sys/types.h>
+#include <sys/socket.h>
 #include <errno.h>
 #include <strings.h>
 #include <netinet/in.h>
 #include <stdlib.h>
 #include <string.h>
-#include <sys/types.h>
-#include <sys/socket.h>
 #include <arpa/inet.h>
 #include <net/if.h>
 #include <net/if_arp.h>
@@ -47,6 +47,21 @@
 #else
 #include <sys/sockio.h>
 #endif
+#if defined(_ALLBSD_SOURCE)
+#include <sys/param.h>
+#include <sys/ioctl.h>
+#if defined(__FreeBSD__) || defined(__APPLE__)
+#include <net/ethernet.h>
+#include <net/if_var.h>
+#elif defined(__OpenBSD__)
+#include <netinet/if_ether.h>
+#elif defined(__NetBSD__)
+#include <net/if_ether.h>
+#endif
+#include <net/if_dl.h>
+#include <netinet/in_var.h>
+#include <ifaddrs.h>
+#endif
 
 #ifdef __linux__
 #define ifr_index ifr_ifindex
@@ -587,6 +602,7 @@
 }
 
 
+#if !defined(_ALLBSD_SOURCE)
 /*
  * Enumerates and returns all IPv4 interfaces
  */
@@ -697,6 +713,176 @@
     return ifs;
 }
 
+#else /* _ALLBSD_SOURCE */
+ 
+/*
+ * Enumerates and returns all IPv4 interfaces
+ *
+ * WARNING! Make sure that it's correctly synchronized on future JDK
+ * versions imports!
+ */
+static netif *enumIPv4Interfaces(JNIEnv *env, netif *ifs)
+{
+    int sock;
+    struct ifaddrs *ifa, *origifa;
+
+    sock = JVM_Socket(AF_INET, SOCK_DGRAM, 0);
+    if (sock < 0) {
+	/*
+	 * If EPROTONOSUPPORT is returned it means we don't have
+	 * IPv4 support so don't throw an exception.
+	 */
+	if (errno != EPROTONOSUPPORT) {
+	    NET_ThrowByNameWithLastError(env , JNU_JAVANETPKG "SocketException",
+                             "Socket creation failed");
+	}
+	return ifs;
+    }
+
+    if (getifaddrs(&origifa) != 0) {
+        NET_ThrowByNameWithLastError(env , JNU_JAVANETPKG "SocketException",
+                         "getifaddrs() function failed");
+	close(sock);
+	return ifs;
+    }
+
+    for (ifa = origifa; ifa != NULL; ifa = ifa->ifa_next) {
+
+	/*
+	 * Skip non-AF_INET entries.
+	 */
+	if (ifa->ifa_addr == NULL || ifa->ifa_addr->sa_family != AF_INET)
+	    continue;
+
+	/*
+	 * Add to the list.
+	 *
+	 * BSDNOTE: in order to optimize code, interface index detection
+	 * logic was added directly to addif().
+	 */
+	ifs = addif(env, ifs, ifa->ifa_name, (-1), AF_INET,
+		    ifa->ifa_addr, sizeof(struct sockaddr_in), 0);
+
+	/*
+	 * If an exception occurred then free the list.
+	 */
+	if ((*env)->ExceptionOccurred(env)) {
+	    close(sock);
+	    freeifaddrs(origifa);
+	    freeif(ifs);
+	    return NULL;
+	}
+    }
+
+    /*
+     * Free socket and buffer
+     */
+    close(sock);
+    freeifaddrs(origifa);
+    return ifs;
+}
+
+#if defined(AF_INET6)
+/*
+ * Determines the prefix on BSD for IPv6 interfaces.
+ */
+static
+int prefix(void *val, int size) {
+    u_char *name = (u_char *)val;
+    int byte, bit, plen = 0;
+
+    for (byte = 0; byte < size; byte++, plen += 8)
+        if (name[byte] != 0xff)
+            break;
+    if (byte == size)
+        return (plen);
+    for (bit = 7; bit != 0; bit--, plen++)
+        if (!(name[byte] & (1 << bit)))
+            break;
+    for (; bit != 0; bit--)
+        if (name[byte] & (1 << bit))
+            return (0);
+    byte++;
+    for (; byte < size; byte++)
+        if (name[byte])
+            return (0);
+    return (plen);
+}
+
+/*
+ * Enumerates and returns all IPv6 interfaces on FreeBSD
+ *
+ * BSDNOTE: it's done in same as IPv4 enumeration and should be carefully
+ *          reviewed with each JDK update (according to Solaris/Linux version)
+ */
+static netif *enumIPv6Interfaces(JNIEnv *env, netif *ifs) {
+
+    int sock;
+    struct ifaddrs *ifa, *origifa;
+    struct sockaddr_in6 *sin6;
+    struct in6_ifreq ifr6;
+
+    // Open IPv6 UDP socket.
+    sock = JVM_Socket(AF_INET6, SOCK_DGRAM, 0);
+    if (sock < 0) {
+        NET_ThrowByNameWithLastError(env , JNU_JAVANETPKG "SocketException",
+                     "Failed to create IPv6 socket");
+        return ifs;
+    }
+
+    if (getifaddrs(&origifa) != 0) {
+        NET_ThrowByNameWithLastError(env , JNU_JAVANETPKG "SocketException",
+                         "getifaddrs() function failed");
+	close(sock);
+	return ifs;
+    }
+
+    for (ifa = origifa; ifa != NULL; ifa = ifa->ifa_next) {
+
+	/*
+	 * Skip non-AF_INET6 entries.
+	 */
+	if (ifa->ifa_addr == NULL || ifa->ifa_addr->sa_family != AF_INET6)
+	    continue;
+
+	memset(&ifr6, 0, sizeof(ifr6));
+	strlcpy(ifr6.ifr_name, ifa->ifa_name, sizeof(ifr6.ifr_name));
+	memcpy(&ifr6.ifr_addr, ifa->ifa_addr, MIN(sizeof(ifr6.ifr_addr), ifa->ifa_addr->sa_len));
+
+	if (ioctl(sock, SIOCGIFNETMASK_IN6, (caddr_t)&ifr6) < 0) {
+	    NET_ThrowByNameWithLastError(env , JNU_JAVANETPKG "SocketException",
+                             "ioctl SIOCGIFNETMASK_IN6 failed");
+	    close(sock);
+	    freeifaddrs(origifa);
+	    freeif(ifs);
+	    return NULL;
+	}
+
+	/* Add to the list.  */
+	sin6 = (struct sockaddr_in6 *)&ifr6.ifr_addr;
+	ifs = addif(env, ifs, ifa->ifa_name, (-1), AF_INET6,
+	            ifa->ifa_addr, sizeof(struct sockaddr_in6),
+		    prefix(&sin6->sin6_addr, sizeof(struct in6_addr)));
+
+	/* If an exception occurred then free the list.  */
+	if ((*env)->ExceptionOccurred(env)) {
+	    close(sock);
+	    freeifaddrs(origifa);
+	    freeif(ifs);
+	    return NULL;
+	}
+    }
+
+    /*
+     * Free socket and ifaddrs buffer
+     */
+    close(sock);
+    freeifaddrs(origifa);
+    return ifs;
+}
+#endif /* AF_INET6 */
+
+#endif /* !_ALLBSD_SOURCE */
 
 #if defined(__solaris__) && defined(AF_INET6)
 /*
@@ -1040,7 +1226,13 @@
             JNU_ThrowOutOfMemoryError(env, "heap allocation failed");
             return ifs;
         }
+#if defined(_ALLBSD_SOURCE)
+	currif->index = if_nametoindex(name);
+	if (currif->index == 0)
+	    currif->index = -1;
+#else
         currif->index = index;
+#endif
         currif->addr = NULL;
         currif->childs = NULL;
         currif->virtual = isVirtual;
@@ -1351,6 +1543,31 @@
    * All bytes to 0 means no hardware address.
    */
   return -1;
+#elif defined(_ALLBSD_SOURCE)
+  struct ifaddrs *ifa0, *ifa;
+  struct sockaddr *saddr;
+  int i;
+
+  /* Grab the interface list */
+  if (!getifaddrs(&ifa0)) {
+    /* Cycle through the interfaces */
+    for (i = 0, ifa = ifa0; ifa != NULL; ifa = ifa->ifa_next, i++) {
+      saddr = ifa->ifa_addr;
+      /* Link layer contains the MAC address */
+      if (saddr->sa_family == AF_LINK && !strcmp(ifname, ifa->ifa_name)) {
+        struct sockaddr_dl *sadl = (struct sockaddr_dl *) saddr;
+        /* Check the address is the correct length */
+        if (sadl->sdl_alen == ETHER_ADDR_LEN) {
+           memcpy(buf, (sadl->sdl_data + sadl->sdl_nlen), ETHER_ADDR_LEN);
+           freeifaddrs(ifa0);
+           return ETHER_ADDR_LEN;
+        }
+      }
+    }
+    freeifaddrs(ifa0);
+  }
+
+  return -1;
 #else
   struct arpreq arpreq;
   struct sockaddr_in* sin;
@@ -1516,7 +1733,7 @@
                                  "Socket creation failed");
   } else {
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     memset((char *) &if2, 0, sizeof(if2));
     strcpy(if2.ifr_name, name_utf);
 
--- ./jdk/src/solaris/native/java/net/PlainDatagramSocketImpl.c	2010-03-18 01:45:35.000000000 -0700
+++ ./jdk/src/solaris/native/java/net/PlainDatagramSocketImpl.c	2010-02-21 16:57:45.000000000 -0800
@@ -23,12 +23,12 @@
  * have any questions.
  */
 
+#include <sys/types.h>
+#include <sys/socket.h>
 #include <errno.h>
 #include <netinet/in.h>
 #include <stdlib.h>
 #include <string.h>
-#include <sys/types.h>
-#include <sys/socket.h>
 
 #ifdef __solaris__
 #include <fcntl.h>
@@ -331,7 +331,7 @@
     /* The fdObj'fd */
     jint fd;
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     SOCKADDR addr;
     int len;
 #endif
@@ -341,26 +341,39 @@
     }
     fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);
 
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #ifdef __linux__
     if (isOldKernel) {
         int t = 1;
         setsockopt(fd, SOL_SOCKET, SO_BSDCOMPAT, (char*) &t, sizeof(int));
     } else {
+#endif /* __linux__ */
         memset(&addr, 0, sizeof(addr));
 #ifdef AF_INET6
         if (ipv6_available()) {
             struct sockaddr_in6 *him6 = (struct sockaddr_in6 *)&addr;
+#ifdef __FreeBSD__
+            him6->sin6_family = AF_INET6;
+#else
             him6->sin6_family = AF_UNSPEC;
+#endif
             len = sizeof(struct sockaddr_in6);
         } else
 #endif
         {
             struct sockaddr_in *him4 = (struct sockaddr_in*)&addr;
+#ifdef __FreeBSD__
+            him4->sin_family = AF_INET;
+#else
             him4->sin_family = AF_UNSPEC;
+#endif
             len = sizeof(struct sockaddr_in);
         }
         JVM_Connect(fd, (struct sockaddr *)&addr, len);
+	/* XXXBSD: here we can get EADDRNOTAVAIL which need to be ignored
+	   but since return value is not checked, ignore it */
 
+#ifdef __linux__
         // After disconnecting a UDP socket, Linux kernel will set
         // local port to zero if the port number comes from implicit
         // bind. Successive send/recv on the same socket will fail.
@@ -383,6 +396,7 @@
             NET_Bind(fd, (struct sockaddr *)&addr, len);
         }
     }
+#endif
 #else
     JVM_Connect(fd, 0, 0);
 #endif
@@ -2247,7 +2261,7 @@
             {
                 struct in_addr in;
                 struct in_addr *inP = &in;
-                int len = sizeof(struct in_addr);
+                socklen_t len = sizeof(struct in_addr);
 
 #ifdef __linux__
                 struct ip_mreqn mreqn;
@@ -2392,18 +2406,30 @@
             mname6.ipv6mr_interface = idx;
         }
 
+#if defined(_ALLBSD_SOURCE)
+#define ADD_MEMBERSHIP		IPV6_JOIN_GROUP
+#define DRP_MEMBERSHIP		IPV6_LEAVE_GROUP
+#define S_ADD_MEMBERSHIP	"IPV6_JOIN_GROUP"
+#define S_DRP_MEMBERSHIP	"IPV6_LEAVE_GROUP"
+#else
+#define ADD_MEMBERSHIP		IPV6_ADD_MEMBERSHIP
+#define DRP_MEMBERSHIP		IPV6_DROP_MEMBERSHIP
+#define S_ADD_MEMBERSHIP	"IPV6_ADD_MEMBERSHIP"
+#define S_DRP_MEMBERSHIP	"IPV6_DROP_MEMBERSHIP"
+#endif
+
         /* Join the multicast group */
-        if (JVM_SetSockOpt(fd, IPPROTO_IPV6, (join ? IPV6_ADD_MEMBERSHIP : IPV6_DROP_MEMBERSHIP),
+        if (JVM_SetSockOpt(fd, IPPROTO_IPV6, (join ? ADD_MEMBERSHIP : DRP_MEMBERSHIP),
                            (char *) &mname6, sizeof (mname6)) < 0) {
 
             if (join) {
-                NET_ThrowCurrent(env, "setsockopt IPV6_ADD_MEMBERSHIP failed");
+                NET_ThrowCurrent(env, "setsockopt " S_ADD_MEMBERSHIP " failed");
             } else {
                 if (errno == ENOENT) {
                    JNU_ThrowByName(env, JNU_JAVANETPKG "SocketException",
                         "Not a member of the multicast group");
                 } else {
-                    NET_ThrowCurrent(env, "setsockopt IPV6_DROP_MEMBERSHIP failed");
+                    NET_ThrowCurrent(env, "setsockopt " S_DRP_MEMBERSHIP " failed");
                 }
             }
         }
--- ./jdk/src/solaris/native/java/net/PlainSocketImpl.c	2010-03-18 01:45:35.000000000 -0700
+++ ./jdk/src/solaris/native/java/net/PlainSocketImpl.c	2010-01-30 09:28:33.000000000 -0800
@@ -467,9 +467,11 @@
         if (connect_rv == JVM_IO_INTR) {
             JNU_ThrowByName(env, JNU_JAVAIOPKG "InterruptedIOException",
                             "operation interrupted");
+#if defined(EPROTO)
         } else if (errno == EPROTO) {
             NET_ThrowByNameWithLastError(env, JNU_JAVANETPKG "ProtocolException",
                            "Protocol error");
+#endif
         } else if (errno == ECONNREFUSED) {
             NET_ThrowByNameWithLastError(env, JNU_JAVANETPKG "ConnectException",
                            "Connection refused");
@@ -985,7 +987,7 @@
      */
     if (cmd == java_net_SocketOptions_SO_BINDADDR) {
         SOCKADDR him;
-        socklen_t len = 0;
+        socklen_t len;
         int port;
         jobject iaObj;
         jclass iaCntrClass;
--- ./jdk/src/solaris/native/java/net/bsd_close.c	2010-03-27 11:09:15.000000000 -0700
+++ ./jdk/src/solaris/native/java/net/bsd_close.c	2010-01-30 09:28:33.000000000 -0800
@@ -57,7 +57,7 @@
 /*
  * Signal to unblock thread
  */
-static int sigWakeup = (__SIGRTMAX - 2);
+static int sigWakeup = SIGIO;
 
 /*
  * The fd table and the number of file descriptors
@@ -281,9 +281,7 @@
 
 int NET_RecvFrom(int s, void *buf, int len, unsigned int flags,
        struct sockaddr *from, int *fromlen) {
-    socklen_t socklen = *fromlen;
-    BLOCKING_IO_RETURN_INT( s, recvfrom(s, buf, len, flags, from, &socklen) );
-    *fromlen = socklen;
+    BLOCKING_IO_RETURN_INT( s, recvfrom(s, buf, len, flags, from, fromlen) );
 }
 
 int NET_Send(int s, void *msg, int len, unsigned int flags) {
@@ -300,9 +298,11 @@
 }
 
 int NET_Accept(int s, struct sockaddr *addr, int *addrlen) {
-    socklen_t socklen = *addrlen;
-    BLOCKING_IO_RETURN_INT( s, accept(s, addr, &socklen) );
-    *addrlen = socklen;
+    socklen_t len = *addrlen;
+    int error = accept(s, addr, &len);
+    if (error != -1)
+	*addrlen = (int)len;
+    BLOCKING_IO_RETURN_INT( s, error );
 }
 
 int NET_Connect(int s, struct sockaddr *addr, int addrlen) {
--- ./jdk/src/solaris/native/java/net/net_util_md.c	2010-03-18 01:45:35.000000000 -0700
+++ ./jdk/src/solaris/native/java/net/net_util_md.c	2010-02-19 08:02:42.000000000 -0800
@@ -34,6 +34,15 @@
 #include <stdlib.h>
 #include <dlfcn.h>
 
+#ifdef _ALLBSD_SOURCE
+#include <sys/param.h>
+#include <sys/sysctl.h>
+#endif
+
+#ifdef __OpenBSD__
+#include <sys/socketvar.h>
+#endif
+
 #ifdef __solaris__
 #include <sys/sockio.h>
 #include <stropts.h>
@@ -219,6 +228,14 @@
     return (*env)->GetFieldID(env, cls, "fd", "I");
 }
 
+#if defined(DONT_ENABLE_IPV6)
+jint  IPv6_supported()
+{
+    return JNI_FALSE;
+}
+
+#else /* !DONT_ENABLE_IPV6 */
+
 jint  IPv6_supported()
 {
 #ifndef AF_INET6
@@ -354,6 +371,7 @@
     return JNI_TRUE;
 #endif /* AF_INET6 */
 }
+#endif /* DONT_ENABLE_IPV6 */
 
 void
 NET_AllocSockaddr(struct sockaddr **him, int *len) {
@@ -687,6 +705,10 @@
         him6->sin6_family = AF_INET6;
         *len = sizeof(struct sockaddr_in6) ;
 
+#if defined(_ALLBSD_SOURCE) && defined(_AF_INET6)
+// XXXBSD: should we do something with scope id here ? see below linux comment
+#endif
+
         /*
          * On Linux if we are connecting to a link-local address
          * we need to specify the interface in the scope_id (2.4 kernel only)
@@ -1093,7 +1115,6 @@
         *len = socklen;
     }
 #endif
-
     if (rv < 0) {
         return rv;
     }
@@ -1140,6 +1161,24 @@
 #define IPTOS_PREC_MASK 0xe0
 #endif
 
+#if defined(_ALLBSD_SOURCE)
+#if defined(KIPC_MAXSOCKBUF)
+    int mib[3];
+    size_t rlen;
+#endif
+
+    int *bufsize;
+
+#ifdef __APPLE__
+    static int maxsockbuf = -1;
+#else
+    static long maxsockbuf = -1;
+#endif
+
+    int addopt;
+    struct linger *ling;
+#endif
+
     /*
      * IPPROTO/IP_TOS :-
      * 1. IPv6 on Solaris: no-op and will be set in flowinfo
@@ -1172,6 +1211,10 @@
         *iptos &= (IPTOS_TOS_MASK | IPTOS_PREC_MASK);
     }
 
+#if defined(AF_INET6) && defined(_ALLBSD_SOURCE)
+// XXXBSD: to be implemented ?
+#endif
+
     /*
      * SOL_SOCKET/{SO_SNDBUF,SO_RCVBUF} - On Solaris need to
      * ensure that value is <= max_buf as otherwise we get
@@ -1180,7 +1223,8 @@
 #ifdef __solaris__
     if (level == SOL_SOCKET) {
         if (opt == SO_SNDBUF || opt == SO_RCVBUF) {
-            int sotype, arglen;
+            int sotype;
+            socklen_t arglen;
             int *bufsize, maxbuf;
 
             if (!init_max_buf) {
@@ -1219,6 +1263,84 @@
     }
 #endif
 
+#if defined(_ALLBSD_SOURCE)
+    /*
+     * SOL_SOCKET/{SO_SNDBUF,SO_RCVBUF} - On FreeBSD need to
+     * ensure that value is <= kern.ipc.maxsockbuf as otherwise we get
+     * an ENOBUFS error.
+     */
+    if (level == SOL_SOCKET) {
+        if (opt == SO_SNDBUF || opt == SO_RCVBUF) {
+#ifdef KIPC_MAXSOCKBUF
+            if (maxsockbuf == -1) {
+               mib[0] = CTL_KERN;
+               mib[1] = KERN_IPC;
+               mib[2] = KIPC_MAXSOCKBUF;
+               rlen = sizeof(maxsockbuf);
+               if (sysctl(mib, 3, &maxsockbuf, &rlen, NULL, 0) == -1)
+                   maxsockbuf = 1024;
+
+#if 1
+               /* XXXBSD: This is a hack to workaround mb_max/mb_max_adj
+                  problem.  It should be removed when kern.ipc.maxsockbuf
+                  will be real value. */
+               maxsockbuf = (maxsockbuf/5)*4;
+#endif
+           }
+#elif defined(__OpenBSD__)
+	   maxsockbuf = SB_MAX;
+#else
+	   maxsockbuf = 64 * 1024;	/* XXX: NetBSD */
+#endif
+
+           bufsize = (int *)arg;
+           if (*bufsize > maxsockbuf) {
+               *bufsize = maxsockbuf;
+           }
+
+	   if (opt == SO_RCVBUF && *bufsize < 1024) {
+		*bufsize = 1024;
+	   }
+
+        }
+    }
+
+    /*
+     * On Solaris, SO_REUSEADDR will allow multiple datagram
+     * sockets to bind to the same port.  The network jck tests
+     * for this "feature", so we need to emulate it by turning on
+     * SO_REUSEPORT as well for that combination.
+     */
+    if (level == SOL_SOCKET && opt == SO_REUSEADDR) {
+        int sotype;
+        socklen_t arglen;
+
+        arglen = sizeof(sotype);
+        if (getsockopt(fd, SOL_SOCKET, SO_TYPE, (void *)&sotype, &arglen) < 0) {
+            return -1;
+        }
+
+        if (sotype == SOCK_DGRAM) {
+            addopt = SO_REUSEPORT;
+            setsockopt(fd, level, addopt, arg, len);
+        }
+    }
+
+    /*
+     * Don't allow SO_LINGER value to be too big.
+     * Current max value (240) is empiric value based on tcp_timer.h's
+     * constant TCP_LINGERTIME, which was doubled.
+     *
+     * XXXBSD: maybe we should step it down to 120 ?
+     */
+    if (level == SOL_SOCKET && opt == SO_LINGER) {
+        ling = (struct linger *)arg;
+       if (ling->l_linger > 240 || ling->l_linger < 0) {
+           ling->l_linger = 240;
+       }
+    }
+#endif
+
     return setsockopt(fd, level, opt, arg, len);
 }
 
@@ -1269,7 +1391,8 @@
      * corresponding IPv4 port is in use.
      */
     if (ipv6_available()) {
-        int arg, len;
+        int arg;
+        socklen_t len;
 
         len = sizeof(arg);
         if (getsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&arg,
--- ./jdk/src/solaris/native/java/net/net_util_md.h	2010-03-18 01:45:35.000000000 -0700
+++ ./jdk/src/solaris/native/java/net/net_util_md.h	2010-02-19 08:02:42.000000000 -0800
@@ -37,7 +37,7 @@
 #endif
 
 
-#ifdef __linux__
+#if defined(__linux__) || defined(__FreeBSD__)
 extern int NET_Timeout(int s, long timeout);
 extern int NET_Read(int s, void* buf, size_t len);
 extern int NET_RecvFrom(int s, void *buf, int len, unsigned int flags,
--- ./jdk/src/solaris/native/java/nio/MappedByteBuffer.c	2010-03-18 01:45:35.000000000 -0700
+++ ./jdk/src/solaris/native/java/nio/MappedByteBuffer.c	2010-01-30 09:28:34.000000000 -0800
@@ -38,7 +38,11 @@
                                         jlong address, jlong len)
 {
     jboolean loaded = JNI_TRUE;
+#if defined(_ALLBSD_SOURCE)
+    jint pageSize = getpagesize();
+#else
     jint pageSize = sysconf(_SC_PAGESIZE);
+#endif
     jint numPages = (len + pageSize - 1) / pageSize;
     int result = 0;
     int i = 0;
@@ -96,7 +100,11 @@
 Java_java_nio_MappedByteBuffer_force0(JNIEnv *env, jobject obj, jlong address,
                                       jlong len)
 {
+#if defined(_ALLBSD_SOURCE)
+    jlong pageSize = getpagesize();
+#else
     jlong pageSize = sysconf(_SC_PAGESIZE);
+#endif
     unsigned long lAddress = address;
 
     jlong offset = lAddress % pageSize;
--- ./jdk/src/solaris/native/java/util/FileSystemPreferences.c	2010-03-18 01:45:35.000000000 -0700
+++ ./jdk/src/solaris/native/java/util/FileSystemPreferences.c	2010-01-30 09:28:34.000000000 -0800
@@ -47,8 +47,11 @@
     return (jint) result;
 }
 
-
+#if defined(_ALLBSD_SOURCE)
+typedef struct flock FLOCK;
+#else
 typedef struct flock64 FLOCK;
+#endif
 
 /**
  * Try to open a named lock file.
@@ -86,7 +89,11 @@
     if (fd < 0) {
         result[0] = 0;
     } else {
+#if defined(_ALLBSD_SOURCE)
+        rc = fcntl(fd, F_SETLK, &fl); 
+#else
         rc = fcntl(fd, F_SETLK64, &fl);
+#endif
         result[1] = errno;
         if (rc < 0) {
             result[0]= 0;
@@ -116,7 +123,11 @@
     fl.l_start = 0;
     fl.l_type = F_UNLCK;
 
+#if defined(_ALLBSD_SOURCE)
+    rc = fcntl(fd, F_SETLK, &fl);
+#else
     rc = fcntl(fd, F_SETLK64, &fl);
+#endif
 
     if (rc < 0) {
         close(fd);
--- ./jdk/src/solaris/native/java/util/TimeZone_md.c	2010-03-18 01:45:35.000000000 -0700
+++ ./jdk/src/solaris/native/java/util/TimeZone_md.c	2010-01-30 09:28:34.000000000 -0800
@@ -31,7 +31,7 @@
 #include <errno.h>
 #include <stddef.h>
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <string.h>
 #include <dirent.h>
 #include <sys/stat.h>
@@ -49,7 +49,11 @@
 #define fileclose       fclose
 #endif
 
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
+
 #ifdef __linux__
+static const char *sysconfig_clock_file = "/etc/sysconfig/clock";
+#endif
 
 static const char *ETC_TIMEZONE_FILE = "/etc/timezone";
 static const char *ZONEINFO_DIR = "/usr/share/zoneinfo";
@@ -199,7 +203,9 @@
     int fd;
     char *buf;
     size_t size;
+    char zoneinfo_file[PATH_MAX+1];
 
+#ifdef __linux__
     /*
      * Try reading the /etc/timezone file for Debian distros. There's
      * no spec of the file format available. This parsing assumes that
@@ -223,6 +229,7 @@
             return tz;
         }
     }
+#endif /* __linux__ */
 
     /*
      * Next, try /etc/localtime to find the zone ID.
@@ -231,6 +238,10 @@
         return NULL;
     }
 
+    strncpy(zoneinfo_file, DEFAULT_ZONEINFO_FILE, PATH_MAX);
+    zoneinfo_file[PATH_MAX] = '\0';
+
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     /*
      * If it's a symlink, get the link name and its zone ID part. (The
      * older versions of timeconfig created a symlink as described in
@@ -239,21 +250,25 @@
      * from /etc/localtime.)
      */
     if (S_ISLNK(statbuf.st_mode)) {
-        char linkbuf[PATH_MAX+1];
         int len;
 
-        if ((len = readlink(DEFAULT_ZONEINFO_FILE, linkbuf, sizeof(linkbuf)-1)) == -1) {
+	if ((len = readlink(DEFAULT_ZONEINFO_FILE, zoneinfo_file, sizeof(zoneinfo_file)-1)) == -1) {
             jio_fprintf(stderr, (const char *) "can't get a symlink of %s\n",
                         DEFAULT_ZONEINFO_FILE);
             return NULL;
         }
-        linkbuf[len] = '\0';
-        tz = getZoneName(linkbuf);
+	zoneinfo_file[len] = '\0';
+	tz = getZoneName(zoneinfo_file);
         if (tz != NULL) {
             tz = strdup(tz);
+	    return tz;
+	} else {
+	    if (lstat(zoneinfo_file, &statbuf) == -1) {
+		return NULL;
+	    }
         }
-        return tz;
     }
+#endif /* __linux__ || _ALLBSD_SOURCE */
 
     /*
      * If it's a regular file, we need to find out the same zoneinfo file
@@ -264,7 +279,7 @@
     if (buf == NULL) {
         return NULL;
     }
-    if ((fd = open(DEFAULT_ZONEINFO_FILE, O_RDONLY)) == -1) {
+    if ((fd = open(zoneinfo_file, O_RDONLY)) == -1) {
         free((void *) buf);
         return NULL;
     }
@@ -493,7 +508,7 @@
 
     tz = getenv("TZ");
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     if (tz == NULL) {
 #else
 #ifdef __solaris__
@@ -532,19 +547,32 @@
 {
     time_t offset;
     char sign, buf[16];
+#if defined(_ALLBSD_SOURCE)
+    struct tm *local_tm;
+    time_t clock;
+ 
+    clock = time(NULL);
+    tzset();
+    local_tm = localtime(&clock);
+    if (local_tm->tm_gmtoff >= 0) {
+	offset = (time_t) local_tm->tm_gmtoff;
+	sign = "+";
+    } else {
+	offset = (time_t) -local_tm->tm_gmtoff;
+	sign = "-";
+    }
+#else
 
     if (timezone == 0) {
         return strdup("GMT");
-    }
-
-    /* Note that the time offset direction is opposite. */
-    if (timezone > 0) {
+    } else if (timezone > 0) {
         offset = timezone;
         sign = '-';
     } else {
         offset = -timezone;
         sign = '+';
     }
+#endif
     sprintf(buf, (const char *)"GMT%c%02d:%02d",
             sign, (int)(offset/3600), (int)((offset%3600)/60));
     return strdup(buf);
--- ./jdk/src/solaris/native/sun/awt/CUPSfuncs.c	2010-03-18 01:45:35.000000000 -0700
+++ ./jdk/src/solaris/native/sun/awt/CUPSfuncs.c	2010-01-30 09:28:34.000000000 -0800
@@ -25,6 +25,7 @@
 
 #include <jni.h>
 #include <jni_util.h>
+#include <jvm_md.h>
 #include <dlfcn.h>
 #include <cups/cups.h>
 #include <cups/ppd.h>
@@ -65,10 +66,11 @@
 JNIEXPORT jboolean JNICALL
 Java_sun_print_CUPSPrinter_initIDs(JNIEnv *env,
                                          jobject printObj) {
-  void *handle = dlopen("libcups.so.2", RTLD_LAZY | RTLD_GLOBAL);
+  void *handle = dlopen(VERSIONED_JNI_LIB_NAME("cups", "2"),
+                        RTLD_LAZY | RTLD_GLOBAL);
 
   if (handle == NULL) {
-    handle = dlopen("libcups.so", RTLD_LAZY | RTLD_GLOBAL);
+    handle = dlopen(JNI_LIB_NAME("cups"), RTLD_LAZY | RTLD_GLOBAL);
     if (handle == NULL) {
       return JNI_FALSE;
     }
--- ./jdk/src/solaris/native/sun/awt/VDrawingArea.c	2010-03-18 01:45:35.000000000 -0700
+++ ./jdk/src/solaris/native/sun/awt/VDrawingArea.c	2010-01-30 09:28:34.000000000 -0800
@@ -31,7 +31,11 @@
 #endif /* !HEADLESS */
 
 #include <stdio.h>
+#if defined(_ALLBSD_SOURCE)
+#include <stdlib.h>
+#else
 #include <malloc.h>
+#endif
 
 #ifdef __linux__
 /* XXX: Shouldn't be necessary. */
--- ./jdk/src/solaris/native/sun/awt/X11Color.c	2010-03-18 01:45:35.000000000 -0700
+++ ./jdk/src/solaris/native/sun/awt/X11Color.c	2010-01-30 09:28:34.000000000 -0800
@@ -33,7 +33,9 @@
 #include <math.h>
 #include <sys/time.h>
 #include <sys/resource.h>
+#if !defined(_ALLBSD_SOURCE)
 #include <alloca.h>
+#endif
 #ifndef HEADLESS
 #include <X11/Xlib.h>
 #include <X11/Xatom.h>
--- ./jdk/src/solaris/native/sun/awt/XDrawingArea.c	2010-03-18 01:45:35.000000000 -0700
+++ ./jdk/src/solaris/native/sun/awt/XDrawingArea.c	2010-01-30 09:28:34.000000000 -0800
@@ -31,7 +31,11 @@
 #include <Xm/XmP.h>
 
 #include <stdio.h>
+#if defined(_ALLBSD_SOURCE)
+#include <stdlib.h>
+#else
 #include <malloc.h>
+#endif
 
 #ifdef DEBUG
 #include <jvm.h>  /* To get jio_fprintf() */
--- ./jdk/src/solaris/native/sun/awt/awt_Font.c	2010-03-18 01:45:35.000000000 -0700
+++ ./jdk/src/solaris/native/sun/awt/awt_Font.c	2010-01-30 09:28:34.000000000 -0800
@@ -334,7 +334,7 @@
             if (strcmp(style, "regular") == 0) {
                 altstyle = "roman";
             }
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
             if (!strcmp(family, "lucidasans")) {
                 family = "lucida";
             }
--- ./jdk/src/solaris/native/sun/awt/awt_GraphicsEnv.c	2010-03-18 01:45:35.000000000 -0700
+++ ./jdk/src/solaris/native/sun/awt/awt_GraphicsEnv.c	2010-01-30 09:28:34.000000000 -0800
@@ -40,6 +40,7 @@
 #include <jni.h>
 #include <jni_util.h>
 #include <jvm.h>
+#include <jvm_md.h>
 #include <jlong.h>
 
 #include <stdlib.h>
@@ -122,7 +123,7 @@
  */
 
 #define MAXFRAMEBUFFERS 16
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 typedef struct {
    int   screen_number;
    short x_org;
@@ -427,6 +428,11 @@
     {
         xrenderLibHandle = dlopen("libXrender.so.1", RTLD_LAZY | RTLD_GLOBAL);
 
+        if (xrenderLibHandle == NULL) {
+            xrenderLibHandle = dlopen("libXrender.so",
+                                      RTLD_LAZY | RTLD_GLOBAL);
+        }
+
 #ifndef __linux__ /* SOLARIS */
         if (xrenderLibHandle == NULL) {
             xrenderLibHandle = dlopen("/usr/sfw/lib/libXrender.so.1",
@@ -640,19 +646,22 @@
 #endif /* HEADLESS */
 
 #ifndef HEADLESS
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 static void xinerama_init_linux()
 {
-    void* libHandle = 0;
-    char* XineramaLibName= "libXinerama.so.1";
+    void* libHandle = NULL;
     int32_t locNumScr = 0;
     XineramaScreenInfo *xinInfo;
     char* XineramaQueryScreensName = "XineramaQueryScreens";
     XineramaQueryScreensFunc* XineramaQueryScreens = NULL;
 
     /* load library */
-    libHandle = dlopen(XineramaLibName, RTLD_LAZY | RTLD_GLOBAL);
-    if (libHandle != 0) {
+    libHandle = dlopen(VERSIONED_JNI_LIB_NAME("Xinerama", "1"),
+                       RTLD_LAZY | RTLD_GLOBAL);
+    if (libHandle == NULL) {
+        libHandle = dlopen(JNI_LIB_NAME("Xinerama"), RTLD_LAZY | RTLD_GLOBAL);
+    }
+    if (libHandle != NULL) {
         XineramaQueryScreens = (XineramaQueryScreensFunc*)
             dlsym(libHandle, XineramaQueryScreensName);
 
@@ -688,11 +697,10 @@
     }
 }
 #endif
-#ifndef __linux__ /* Solaris */
+#if !defined(__linux__) && !defined(_ALLBSD_SOURCE) /* Solaris */
 static void xinerama_init_solaris()
 {
-    void* libHandle = 0;
-    char* XineramaLibName= "libXext.so";
+    void* libHandle = NULL;
     unsigned char fbhints[MAXFRAMEBUFFERS];
     int32_t locNumScr = 0;
     /* load and run XineramaGetInfo */
@@ -701,8 +709,8 @@
     XineramaGetInfoFunc* XineramaSolarisFunc = NULL;
 
     /* load library */
-    libHandle = dlopen(XineramaLibName, RTLD_LAZY | RTLD_GLOBAL);
-    if (libHandle != 0) {
+    libHandle = dlopen(JNI_LIB_NAME("Xext"), RTLD_LAZY | RTLD_GLOBAL);
+    if (libHandle != NULL) {
         XineramaSolarisFunc = (XineramaGetInfoFunc*)dlsym(libHandle, XineramaGetInfoName);
         XineramaSolarisCenterFunc =
             (XineramaGetCenterHintFunc*)dlsym(libHandle, XineramaGetCenterHintName);
@@ -749,11 +757,11 @@
     }
 
     DTRACE_PRINTLN("Xinerama extension is available");
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     xinerama_init_linux();
 #else /* Solaris */
     xinerama_init_solaris();
-#endif /* __linux__ */
+#endif /* __linux__ || _ALLBSD_SOURCE */
 }
 #endif /* HEADLESS */
 
@@ -1628,7 +1636,7 @@
 {
     jobject point = NULL;
 #ifndef HEADLESS    /* return NULL in HEADLESS, Linux */
-#ifndef __linux__
+#if !defined(__linux__) && !defined(_ALLBSD_SOURCE)
     int x,y;
 
     AWT_LOCK();
@@ -1641,7 +1649,7 @@
         DTRACE_PRINTLN("unable to call XineramaSolarisCenterFunc: symbol is null");
     }
     AWT_FLUSH_UNLOCK();
-#endif /* __linux __ */
+#endif /* __linux __ || _ALLBSD_SOURCE */
 #endif /* HEADLESS */
     return point;
 }
@@ -1711,7 +1719,11 @@
 {
     int rr_maj_ver = 0, rr_min_ver = 0;
 
-    void *pLibRandR = dlopen("libXrandr.so.2", RTLD_LAZY | RTLD_LOCAL);
+    void *pLibRandR = dlopen(VERSIONED_JNI_LIB_NAME("Xrandr", "2"),
+                             RTLD_LAZY | RTLD_LOCAL);
+    if (pLibRandR == NULL) {
+        pLibRandR = dlopen(JNI_LIB_NAME("Xrandr"), RTLD_LAZY | RTLD_LOCAL);
+    }
     if (pLibRandR == NULL) {
         J2dRlsTraceLn(J2D_TRACE_ERROR,
                       "X11GD_InitXrandrFuncs: Could not open libXrandr.so.2");
--- ./jdk/src/solaris/native/sun/awt/awt_InputMethod.c	2010-03-18 01:45:35.000000000 -0700
+++ ./jdk/src/solaris/native/sun/awt/awt_InputMethod.c	2010-01-30 09:28:34.000000000 -0800
@@ -69,7 +69,7 @@
                                 XIMPreeditDrawCallbackStruct *);
 static void PreeditCaretCallback(XIC, XPointer,
                                  XIMPreeditCaretCallbackStruct *);
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 static void StatusStartCallback(XIC, XPointer, XPointer);
 static void StatusDoneCallback(XIC, XPointer, XPointer);
 static void StatusDrawCallback(XIC, XPointer,
@@ -83,7 +83,7 @@
 #define PreeditDoneIndex        1
 #define PreeditDrawIndex        2
 #define PreeditCaretIndex       3
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #define StatusStartIndex        4
 #define StatusDoneIndex         5
 #define StatusDrawIndex         6
@@ -101,14 +101,14 @@
     (XIMProc)PreeditDoneCallback,
     (XIMProc)PreeditDrawCallback,
     (XIMProc)PreeditCaretCallback,
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     (XIMProc)StatusStartCallback,
     (XIMProc)StatusDoneCallback,
     (XIMProc)StatusDrawCallback,
 #endif
 };
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #define MAX_STATUS_LEN  100
 typedef struct {
     Window   w;                /*status window id        */
@@ -148,7 +148,7 @@
 #endif /* XAWT */
     jobject     x11inputmethod; /* global ref to X11InputMethod instance */
                                 /* associated with the XIC */
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     StatusWindow *statusWindow; /* our own status window  */
 #else
 #ifndef XAWT
@@ -427,7 +427,7 @@
 static void
 freeX11InputMethodData(JNIEnv *env, X11InputMethodData *pX11IMData)
 {
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     if (pX11IMData->statusWindow != NULL){
         StatusWindow *sw = pX11IMData->statusWindow;
         XFreeGC(awt_display, sw->lightGC);
@@ -533,7 +533,7 @@
     pX11IMData = getX11InputMethodData(env, currentX11InputMethodInstance);
 
     if (pX11IMData == NULL) {
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
         return False;
 #else
         return result;
@@ -541,7 +541,7 @@
     }
 
     if ((ic = pX11IMData->current_ic) == (XIC)0){
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
         return False;
 #else
         return result;
@@ -650,7 +650,7 @@
     return result;
 }
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 static StatusWindow *createStatusWindow(
 #ifdef XAWT
                                 Window parent) {
@@ -994,7 +994,7 @@
         }
     }
 }
-#endif  /*__linux__*/
+#endif  /* __linux__ || _ALLBSD_SOURCE */
 /*
  * Creates two XICs, one for active clients and the other for passive
  * clients. All information on those XICs are stored in the
@@ -1051,7 +1051,7 @@
         return FALSE ;
     }
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     on_the_spot_styles |= XIMStatusNothing;
 
     /*kinput does not support XIMPreeditCallbacks and XIMStatusArea
@@ -1064,7 +1064,7 @@
             break;
         }
     }
-#else /*! __linux__ */
+#else /*! __linux__ && !_ALLBSD_SOURCE */
 #ifdef XAWT
     on_the_spot_styles |= XIMStatusNothing;
 #else /* !XAWT */
@@ -1087,7 +1087,7 @@
         on_the_spot_styles |= XIMStatusNothing;
 
 #endif /* XAWT */
-#endif /* __linux__ */
+#endif /* __linux__ || _ALLBSD_SOURCE */
 
     for (i = 0; i < im_styles->count_styles; i++) {
         active_styles |= im_styles->supported_styles[i] & on_the_spot_styles;
@@ -1135,7 +1135,7 @@
                         NULL);
         if (preedit == (XVaNestedList)NULL)
             goto err;
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
         /*always try XIMStatusCallbacks for active client...*/
         {
             status = (XVaNestedList)XVaCreateNestedList(0,
@@ -1157,7 +1157,7 @@
             XFree((void *)status);
             XFree((void *)preedit);
         }
-#else /* !__linux__ */
+#else /* !__linux__ && !_ALLBSD_SOURCE */
 #ifndef XAWT
         if (on_the_spot_styles & XIMStatusArea) {
             Widget parent;
@@ -1185,7 +1185,7 @@
         }
 #endif /* XAWT */
         XFree((void *)preedit);
-#endif /* __linux__ */
+#endif /* __linux__ || _ALLBSD_SOURCE */
         pX11IMData->ic_passive = XCreateIC(X11im,
                                            XNClientWindow, XtWindow(w),
                                            XNFocusWindow, XtWindow(w),
@@ -1344,7 +1344,7 @@
 
 }
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 static void
 StatusStartCallback(XIC ic, XPointer client_data, XPointer call_data)
 {
@@ -1412,7 +1412,7 @@
  finally:
     AWT_UNLOCK();
 }
-#endif /*__linux__*/
+#endif /* __linux__ || _ALLBSD_SOURCE */
 
 static void CommitStringCallback(XIC ic, XPointer client_data, XPointer call_data) {
     JNIEnv *env = GetJNIEnv();
@@ -1514,14 +1514,14 @@
 /* Use IMInstantiate call back only on Linux, as there is a bug in Solaris
    (4768335)
 */
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     registered = XRegisterIMInstantiateCallback(dpy, NULL, NULL,
                      NULL, (XIMProc)OpenXIMCallback, NULL);
     if (!registered) {
         /* directly call openXIM callback */
 #endif
         OpenXIMCallback(dpy, NULL, NULL);
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     }
 #endif
 
@@ -1585,13 +1585,13 @@
 #endif /* XAWT */
     globalRef = (*env)->NewGlobalRef(env, this);
     pX11IMData->x11inputmethod = globalRef;
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     pX11IMData->statusWindow = NULL;
-#else /* __linux__ */
+#else /* !__linux__ && !_ALLBSD_SOURCE */
 #ifndef XAWT
     pX11IMData->statusWidget = (Widget) NULL;
 #endif /* XAWT */
-#endif /* __linux__ */
+#endif /* __linux__ || _ALLBSD_SOURCE */
 
     pX11IMData->lookup_buf = 0;
     pX11IMData->lookup_buf_len = 0;
@@ -1738,14 +1738,14 @@
         setXICFocus(pX11IMData->current_ic, req);
         currentX11InputMethodInstance = pX11IMData->x11inputmethod;
         currentFocusWindow =  XtWindow(w);
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
         if (active && pX11IMData->statusWindow && pX11IMData->statusWindow->on)
             onoffStatusWindow(pX11IMData, w, True);
 #endif
     } else {
         currentX11InputMethodInstance = NULL;
         currentFocusWindow = 0;
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
         onoffStatusWindow(pX11IMData, 0, False);
         if (pX11IMData->current_ic != NULL)
 #endif
@@ -1762,7 +1762,7 @@
 Java_sun_awt_X11InputMethod_turnoffStatusWindow(JNIEnv *env,
                                                 jobject this)
 {
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     X11InputMethodData *pX11IMData;
     StatusWindow *statusWindow;
 
@@ -1859,7 +1859,7 @@
     X11InputMethodData *pX11IMData;
     XVaNestedList status;
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
       /*do nothing for linux? */
 #else
     AWT_LOCK();
@@ -1965,7 +1965,7 @@
 JNIEXPORT void JNICALL Java_sun_awt_X11_XInputMethod_adjustStatusWindow
   (JNIEnv *env, jobject this, jlong window)
 {
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     AWT_LOCK();
     adjustStatusWindow(window);
     AWT_UNLOCK();
--- ./jdk/src/solaris/native/sun/awt/awt_LoadLibrary.c	2010-03-18 01:45:35.000000000 -0700
+++ ./jdk/src/solaris/native/sun/awt/awt_LoadLibrary.c	2010-01-30 09:28:34.000000000 -0800
@@ -143,7 +143,11 @@
         (*env)->DeleteLocalRef(env, propname);
     }
 
+#ifdef __APPLE__ 
+    strcat(p, ".dylib");
+#else
     strcat(p, ".so");
+#endif
 
     JNU_CallStaticMethodByName(env, NULL, "java/lang/System", "load",
                                "(Ljava/lang/String;)V",
--- ./jdk/src/solaris/native/sun/awt/awt_MToolkit.c	2010-03-18 01:45:35.000000000 -0700
+++ ./jdk/src/solaris/native/sun/awt/awt_MToolkit.c	2010-01-30 09:28:34.000000000 -0800
@@ -63,8 +63,9 @@
 extern JavaVM *jvm;
 
 #ifndef HEADLESS
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 extern void statusWindowEventHandler(XEvent event);
+Boolean awt_dnd_process_event(XEvent* event);
 #endif
 #endif /* !HEADLESS */
 
@@ -1642,7 +1643,7 @@
               */
               Widget widget=XtWindowToWidget(awt_display, xev.xany.window);
               eventNumber++;
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
               statusWindowEventHandler(xev);
 #endif
               xembed_eventHandler(&xev);
--- ./jdk/src/solaris/native/sun/awt/awt_Mlib.c	2010-03-18 01:45:35.000000000 -0700
+++ ./jdk/src/solaris/native/sun/awt/awt_Mlib.c	2010-01-30 09:28:34.000000000 -0800
@@ -32,6 +32,7 @@
 #include <dlfcn.h>
 #include "jni.h"
 #include <jni_util.h>
+#include "jvm_md.h"
 #include "awt_Mlib.h"
 #include "java_awt_image_BufferedImage.h"
 
@@ -67,11 +68,11 @@
         ((strncmp(name.machine, "sun4v" , 5) == 0) &&
          (getenv("USE_VIS_ON_SUN4V") != NULL)))
     {
-        handle = dlopen("libmlib_image_v.so", RTLD_LAZY);
+        handle = dlopen(JNI_LIB_NAME("mlib_image_v"), RTLD_LAZY);
     }
 
     if (handle == NULL) {
-        handle = dlopen("libmlib_image.so", RTLD_LAZY);
+        handle = dlopen(JNI_LIB_NAME("mlib_image"), RTLD_LAZY);
     }
 
     if (handle == NULL) {
--- ./jdk/src/solaris/native/sun/awt/awt_Robot.c	2010-03-18 01:45:35.000000000 -0700
+++ ./jdk/src/solaris/native/sun/awt/awt_Robot.c	2010-01-30 09:28:34.000000000 -0800
@@ -45,7 +45,7 @@
 #include "wsutils.h"
 #include "list.h"
 #include "multiVis.h"
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <sys/socket.h>
 #endif
 
--- ./jdk/src/solaris/native/sun/awt/awt_util.h	2010-03-18 01:45:35.000000000 -0700
+++ ./jdk/src/solaris/native/sun/awt/awt_util.h	2010-01-30 09:28:34.000000000 -0800
@@ -187,15 +187,20 @@
 #ifdef __solaris__
 extern Widget awt_util_getXICStatusAreaWindow(Widget w);
 #else
+#if defined(_ALLBSD_SOURCE)
+int32_t awt_util_getIMStatusHeight(Widget vw);
+Widget awt_util_getXICStatusAreaWindow(Widget w);
+#else
 int32_t awt_util_getIMStatusHeight(Widget vw);
 XVaNestedList awt_util_getXICStatusAreaList(Widget w);
 Widget awt_util_getXICStatusAreaWindow(Widget w);
 #endif
+#endif
 
 
 
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 typedef struct _XmImRefRec {
   Cardinal      num_refs;       /* Number of referencing widgets. */
   Cardinal      max_refs;       /* Maximum length of refs array. */
--- ./jdk/src/solaris/native/sun/awt/awt_wm.c	2010-03-18 01:45:35.000000000 -0700
+++ ./jdk/src/solaris/native/sun/awt/awt_wm.c	2010-01-30 09:28:34.000000000 -0800
@@ -121,12 +121,19 @@
 static Atom XA_KWM_WIN_MAXIMIZED;
 
 /* OpenLook */
+static Atom _XA_OL_DECOR_ADD;
 static Atom _XA_OL_DECOR_DEL;
 static Atom _XA_OL_DECOR_HEADER;
 static Atom _XA_OL_DECOR_RESIZE;
 static Atom _XA_OL_DECOR_PIN;
 static Atom _XA_OL_DECOR_CLOSE;
 
+/* AfterStep */
+static Atom _XA_AS_STYLE;
+
+/* WindowMaker */
+static Atom _XA_WINDOWMAKER_STATE;
+
 /* For _NET_WM_STATE ClientMessage requests */
 #define _NET_WM_STATE_REMOVE    0 /* remove/unset property */
 #define _NET_WM_STATE_ADD       1 /* add/set property      */
@@ -193,7 +200,12 @@
         { &_XA_OL_DECOR_HEADER,              "_OL_DECOR_HEADER"              },
         { &_XA_OL_DECOR_RESIZE,              "_OL_DECOR_RESIZE"              },
         { &_XA_OL_DECOR_PIN,                 "_OL_DECOR_PIN"                 },
-        { &_XA_OL_DECOR_CLOSE,               "_OL_DECOR_CLOSE"               }
+        { &_XA_OL_DECOR_CLOSE,               "_OL_DECOR_CLOSE"               },
+	{ &_XA_OL_DECOR_ADD,		     "_OL_DECOR_ADD"		     },
+
+	{ &_XA_AS_STYLE,		     "_XA_AS_STYLE"		     },
+
+	{ &_XA_WINDOWMAKER_STATE,	     "_XA_WINDOWMAKER_STATE"	     }
     };
 #define ATOM_LIST_LENGTH (sizeof(atom_list)/sizeof(atom_list[0]))
 
@@ -942,6 +954,39 @@
     return True;
 }
 
+/*
+ * Window Maker.
+ */
+static Boolean
+awt_wm_isWindowmaker()
+{
+    if (awt_wm_atomInterned(&_XA_WINDOWMAKER_STATE, "_WINDOWMAKER_STATE"))
+        return True;
+    return False;
+}
+
+/*
+ * Afterstep.
+ */
+static Boolean
+awt_wm_isAfterstep()
+{
+    if (awt_wm_atomInterned(&_XA_AS_STYLE, "_AS_STYLE"))
+        return True;
+    return False;
+}
+
+/*
+ * FVWM 2.
+ */
+static Boolean
+awt_wm_isFvwm2()
+{
+    if (awt_wm_atomInterned(&_XA_OL_DECOR_ADD, "_OL_DECOR_ADD")
+        && !awt_wm_atomInterned(&_XA_OL_DECOR_PIN, "_OL_DECOR_PIN"))
+        return True;
+    return False;
+}
 
 static Boolean
 awt_wm_isNetWMName(char *name)
@@ -1280,6 +1325,12 @@
     else if (awt_wm_isKDE2()) {
         awt_wmgr = KDE2_WM;
     }
+    else if (awt_wm_isWindowmaker()) {
+	awt_wmgr = WINDOWMAKER_WM;
+    }
+    else if (awt_wm_isAfterstep()) {
+	awt_wmgr = AFTERSTEP_WM;
+    }
     /*
      * We don't check for legacy WM when we already know that WM
      * supports WIN or _NET wm spec.
@@ -1302,6 +1353,9 @@
         awt_wmgr = MOTIF_WM;
     }
     else if (awt_wm_isOpenLook()) {
+	awt_wmgr = OPENLOOK_WM;
+    }
+    else if (awt_wm_isFvwm2()) {
         awt_wmgr = OPENLOOK_WM;
     }
     else {
--- ./jdk/src/solaris/native/sun/awt/awt_wm.h	2010-03-18 01:45:35.000000000 -0700
+++ ./jdk/src/solaris/native/sun/awt/awt_wm.h	2010-01-30 09:28:34.000000000 -0800
@@ -45,7 +45,10 @@
     KDE2_WM,
     SAWFISH_WM,
     ICE_WM,
-    METACITY_WM
+    METACITY_WM,
+    AFTERSTEP_WM,
+    WINDOWMAKER_WM,
+    FVWM2_WM
 };
 
 extern void awt_wm_init(void);
--- ./jdk/src/solaris/native/sun/awt/extutil.h	2010-03-18 01:45:35.000000000 -0700
+++ ./jdk/src/solaris/native/sun/awt/extutil.h	2010-01-30 09:28:34.000000000 -0800
@@ -58,7 +58,7 @@
  */
 /* $XFree86: xc/include/extensions/extutil.h,v 1.5 2001/01/17 17:53:20 dawes Exp $ */
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 
 #ifndef _EXTUTIL_H_
 #define _EXTUTIL_H_
@@ -248,4 +248,4 @@
         char *proc(Display *dpy, int code, XExtCodes *codes, char *buf, int n)
 #endif
 
-#endif /* __linux__ */
+#endif /* __linux__ || _ALLBSD_SOURCE */
--- ./jdk/src/solaris/native/sun/awt/fontpath.c	2010-03-18 01:45:35.000000000 -0700
+++ ./jdk/src/solaris/native/sun/awt/fontpath.c	2010-01-30 09:28:34.000000000 -0800
@@ -23,7 +23,7 @@
  * have any questions.
  */
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <string.h>
 #endif /* __linux__ */
 #include <stdio.h>
@@ -40,6 +40,7 @@
 
 #include <jni.h>
 #include <jni_util.h>
+#include <jvm_md.h>
 #include <sun_font_FontManager.h>
 #ifndef HEADLESS
 #include <X11/Xlib.h>
@@ -58,10 +59,24 @@
 extern Display *awt_display;
 #endif /* !HEADLESS */
 
+#ifdef __APPLE__
+// XXXDARWIN: Hard-code the path to Apple's freetype, as it is
+// not included in the dyld search path by default, and 10.4
+// does not support -rpath.
+//
+// This ignores the build time setting of ALT_FREETYPE_LIB_PATH,
+// and should be replaced with -rpath/@rpath support on 10.5 or later,
+// or via support for a the FREETYPE_LIB_PATH define.
+#define FONTCONFIG_DLL_VERSIONED X11_PATH "/lib/" VERSIONED_JNI_LIB_NAME("fontconfig", "1")
+#define FONTCONFIG_DLL X11_PATH "/lib/" JNI_LIB_NAME("fontconfig")
+#else
+#define FONTCONFIG_DLL_VERSIONED VERSIONED_JNI_LIB_NAME("fontconfig", "1")
+#define FONTCONFIG_DLL JNI_LIB_NAME("fontconfig")
+#endif
 
 #define MAXFDIRS 512    /* Max number of directories that contain fonts */
 
-#ifndef __linux__
+#if !defined(__linux__) && !defined(_ALLBSD_SOURCE)
 /*
  * This can be set in the makefile to "/usr/X11" if so desired.
  */
@@ -111,24 +126,40 @@
     NULL, /* terminates the list */
 };
 
+#elif _ALLBSD_SOURCE
+static char *fullBSDFontPath[] = {
+    X11_PATH "/lib/X11/fonts/TrueType",
+    X11_PATH "/lib/X11/fonts/truetype",
+    X11_PATH "/lib/X11/fonts/tt",
+    X11_PATH "/lib/X11/fonts/TTF",
+    X11_PATH "/lib/X11/fonts/OTF",
+    PACKAGE_PATH "/share/fonts/TrueType",
+    PACKAGE_PATH "/share/fonts/truetype",
+    PACKAGE_PATH "/share/fonts/tt",
+    PACKAGE_PATH "/share/fonts/TTF",
+    PACKAGE_PATH "/share/fonts/OTF",
+    X11_PATH "/lib/X11/fonts/Type1",
+    PACKAGE_PATH "/share/fonts/Type1",
+    NULL, /* terminates the list */
+};
 #else /* __linux */
 /* All the known interesting locations we have discovered on
  * various flavors of Linux
  */
 static char *fullLinuxFontPath[] = {
-    "/usr/X11R6/lib/X11/fonts/TrueType",  /* RH 7.1+ */
-    "/usr/X11R6/lib/X11/fonts/truetype",  /* SuSE */
-    "/usr/X11R6/lib/X11/fonts/tt",
-    "/usr/X11R6/lib/X11/fonts/TTF",
-    "/usr/X11R6/lib/X11/fonts/OTF",       /* RH 9.0 (but empty!) */
-    "/usr/share/fonts/ja/TrueType",       /* RH 7.2+ */
-    "/usr/share/fonts/truetype",
-    "/usr/share/fonts/ko/TrueType",       /* RH 9.0 */
-    "/usr/share/fonts/zh_CN/TrueType",    /* RH 9.0 */
-    "/usr/share/fonts/zh_TW/TrueType",    /* RH 9.0 */
+    X11_PATH "/lib/X11/fonts/TrueType",  /* RH 7.1+ */
+    X11_PATH "/lib/X11/fonts/truetype",  /* SuSE */
+    X11_PATH "/lib/X11/fonts/tt",
+    X11_PATH "/lib/X11/fonts/TTF",
+    X11_PATH "/lib/X11/fonts/OTF",       /* RH 9.0 (but empty!) */
+    PACKAGE_PATH "/share/fonts/ja/TrueType",       /* RH 7.2+ */
+    PACKAGE_PATH "/share/fonts/truetype",
+    PACKAGE_PATH "/share/fonts/ko/TrueType",       /* RH 9.0 */
+    PACKAGE_PATH "/share/fonts/zh_CN/TrueType",    /* RH 9.0 */
+    PACKAGE_PATH "/share/fonts/zh_TW/TrueType",    /* RH 9.0 */
     "/var/lib/defoma/x-ttcidfont-conf.d/dirs/TrueType", /* Debian */
-    "/usr/X11R6/lib/X11/fonts/Type1",
-    "/usr/share/fonts/default/Type1",     /* RH 9.0 */
+    X11_PATH "/lib/X11/fonts/Type1",
+    PACKAGE_PATH "/share/fonts/default/Type1",     /* RH 9.0 */
     NULL, /* terminates the list */
 };
 #endif
@@ -362,7 +393,7 @@
 
 #endif /* !HEADLESS */
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 /* from awt_LoadLibrary.c */
 JNIEXPORT jboolean JNICALL AWTIsHeadless();
 #endif
@@ -487,8 +518,10 @@
      */
     fcdirs = getFontConfigLocations();
 
-#ifdef __linux__
+#if defined(__linux__)
     knowndirs = fullLinuxFontPath;
+#elif defined(_ALLBSD_SOURCE)
+    knowndirs = fullBSDFontPath;
 #else /* IF SOLARIS */
     knowndirs = fullSolarisFontPath;
 #endif
@@ -499,7 +532,8 @@
      * be initialised.
      */
 #ifndef HEADLESS
-#ifdef __linux__        /* There's no headless build on linux ... */
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
+    /* There's no headless build on linux ... */
     if (!AWTIsHeadless()) { /* .. so need to call a function to check */
 #endif
     AWT_LOCK();
@@ -507,7 +541,7 @@
         x11dirs = getX11FontPath();
     }
     AWT_UNLOCK();
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     }
 #endif
 #endif /* !HEADLESS */
@@ -604,7 +638,7 @@
 }
 
 #include <dlfcn.h>
-#ifndef __linux__ /* i.e. is solaris */
+#if !(defined(__linux__) || defined(__APPLE__))
 #include <link.h>
 #endif
 
@@ -650,9 +684,9 @@
      * certain symbols - and functionality - to be available.
      * Also add explicit search for .so.1 in case .so symlink doesn't exist.
      */
-    libfontconfig = dlopen("libfontconfig.so.1", RTLD_LOCAL|RTLD_LAZY);
+    libfontconfig = dlopen(FONTCONFIG_DLL_VERSIONED, RTLD_LOCAL|RTLD_LAZY);
     if (libfontconfig == NULL) {
-        libfontconfig = dlopen("libfontconfig.so", RTLD_LOCAL|RTLD_LAZY);
+        libfontconfig = dlopen(FONTCONFIG_DLL, RTLD_LOCAL|RTLD_LAZY);
         if (libfontconfig == NULL) {
             return NULL;
         }
--- ./jdk/src/solaris/native/sun/awt/gtk2_interface.c	2010-03-18 01:45:35.000000000 -0700
+++ ./jdk/src/solaris/native/sun/awt/gtk2_interface.c	2010-01-30 09:28:34.000000000 -0800
@@ -30,8 +30,10 @@
 #include <string.h>
 #include "gtk2_interface.h"
 #include "java_awt_Transparency.h"
+#include "jvm_md.h"
 
-#define GTK2_LIB "libgtk-x11-2.0.so.0"
+#define GTK2_LIB_VERSIONED VERSIONED_JNI_LIB_NAME("gtk-x11-2.0", "0")
+#define GTK2_LIB JNI_LIB_NAME("gtk-x11-2.0")
 
 #define G_TYPE_INVALID                  G_TYPE_MAKE_FUNDAMENTAL (0)
 #define G_TYPE_NONE                     G_TYPE_MAKE_FUNDAMENTAL (1)
@@ -397,9 +399,12 @@
         void *lib = NULL;
         gboolean result = FALSE;
 
-        lib = dlopen(GTK2_LIB, RTLD_LAZY | RTLD_LOCAL);
+        lib = dlopen(GTK2_LIB_VERSIONED, RTLD_LAZY | RTLD_LOCAL);
         if (lib == NULL) {
-            return FALSE;
+            lib = dlopen(GTK2_LIB, RTLD_LAZY | RTLD_LOCAL);
+            if (lib == NULL) {
+                return FALSE;
+            }
         }
 
         fp_gtk_check_version = dlsym(lib, "gtk_check_version");
@@ -422,9 +427,12 @@
     int (*io_handler)();
     char *gtk_modules_env;
 
-    gtk2_libhandle = dlopen(GTK2_LIB, RTLD_LAZY | RTLD_LOCAL);
-    if (gtk2_libhandle == NULL)
-        return FALSE;
+    gtk2_libhandle = dlopen(GTK2_LIB_VERSIONED, RTLD_LAZY | RTLD_LOCAL);
+    if (gtk2_libhandle == NULL) {
+        gtk2_libhandle = dlopen(GTK2_LIB, RTLD_LAZY | RTLD_LOCAL);
+        if (gtk2_libhandle == NULL)
+            return FALSE;
+    }
 
     if (setjmp(j) == 0)
     {
--- ./jdk/src/solaris/native/sun/awt/list.c	2010-03-18 01:45:35.000000000 -0700
+++ ./jdk/src/solaris/native/sun/awt/list.c	2010-01-30 09:28:34.000000000 -0800
@@ -66,7 +66,11 @@
   ----------------------------------------------------------------------- **/
 
 #include <stdio.h>
+#ifdef _ALLBSD_SOURCE
+#include <stdlib.h>
+#else
 #include <malloc.h>
+#endif
 #include "list.h"
 
 
--- ./jdk/src/solaris/native/sun/awt/robot_common.c	2010-03-18 01:45:35.000000000 -0700
+++ ./jdk/src/solaris/native/sun/awt/robot_common.c	2010-01-30 09:28:35.000000000 -0800
@@ -27,6 +27,9 @@
     #error This file should not be included in headless library
 #endif
 
+#ifdef _ALLBSD_SOURCE
+#include <stdlib.h>
+#endif
 #include "robot_common.h"
 
 /*
--- ./jdk/src/solaris/native/sun/font/X11FontScaler.c	2010-03-18 01:45:35.000000000 -0700
+++ ./jdk/src/solaris/native/sun/font/X11FontScaler.c	2010-01-30 09:28:35.000000000 -0800
@@ -32,7 +32,11 @@
  * into X11FontScaler_md.c, which is compiled into another library.
  */
 #include <stdio.h>
+#if defined(_ALLBSD_SOURCE)
+#include <stdlib.h>
+#else
 #include <malloc.h>
+#endif
 #include <ctype.h>
 #include <sys/utsname.h>
 
--- ./jdk/src/solaris/native/sun/font/X11TextRenderer.c	2010-03-18 01:45:35.000000000 -0700
+++ ./jdk/src/solaris/native/sun/font/X11TextRenderer.c	2010-01-30 09:28:35.000000000 -0800
@@ -39,7 +39,11 @@
 #include "GraphicsPrimitiveMgr.h"
 #include "glyphblitting.h"
 #include "sunfontids.h"
+#if defined(_ALLBSD_SOURCE)
+#include <stdlib.h>
+#else
 #include <malloc.h>
+#endif
 
 
 JNIEXPORT void JNICALL AWTDrawGlyphList
--- ./jdk/src/solaris/native/sun/java2d/j2d_md.h	2010-03-18 01:45:35.000000000 -0700
+++ ./jdk/src/solaris/native/sun/java2d/j2d_md.h	2010-01-30 09:28:35.000000000 -0800
@@ -28,11 +28,11 @@
 #include <sys/types.h>
 
 /*
- * Linux version of <sys/types.h> does not define intptr_t
+ * Linux and BSD's version of <sys/types.h> does not define intptr_t
  */
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <stdint.h>
-#endif /* __linux__ */
+#endif /* __linux__ || _ALLBSD_SOURCE */
 
 typedef unsigned char   jubyte;
 typedef unsigned short  jushort;
--- ./jdk/src/solaris/native/sun/java2d/loops/mlib_ImageZoom_NN.c	2010-03-18 01:45:35.000000000 -0700
+++ ./jdk/src/solaris/native/sun/java2d/loops/mlib_ImageZoom_NN.c	2010-01-30 09:28:35.000000000 -0800
@@ -63,6 +63,10 @@
  *    MLIB_EDGE_SRC_PADDED
  */
 
+#ifdef __OpenBSD__
+#include <sys/types.h>
+#endif
+#include <machine/endian.h>
 #include <mlib_image.h>
 #include <mlib_ImageZoom.h>
 
@@ -99,7 +103,7 @@
 
 /***************************************************************/
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 
 static const mlib_u32 mlib_bit_mask4[16] = {
   0x00000000u, 0xFF000000u, 0x00FF0000u, 0xFFFF0000u,
@@ -108,7 +112,7 @@
   0x0000FFFFu, 0xFF00FFFFu, 0x00FFFFFFu, 0xFFFFFFFFu
 };
 
-#else /* _LITTLE_ENDIAN */
+#else /* BIG_ENDIAN */
 
 static const mlib_u32 mlib_bit_mask4[16] = {
   0x00000000u, 0x000000FFu, 0x0000FF00u, 0x0000FFFFu,
@@ -117,7 +121,7 @@
   0xFFFF0000u, 0xFFFF00FFu, 0xFFFFFF00u, 0xFFFFFFFFu
 };
 
-#endif /* _LITTLE_ENDIAN */
+#endif /* LITTLE_ENDIAN */
 
 /***************************************************************/
 
@@ -341,11 +345,11 @@
 #ifdef _NO_LONGLONG
 
 typedef struct {
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
   mlib_u32 uint1, uint0;
-#else /* _LITTLE_ENDIAN */
+#else /* BIG_ENDIAN */
   mlib_u32 uint0, uint1;
-#endif /* _LITTLE_ENDIAN */
+#endif /* LITTLE_ENDIAN */
 } two_uint;
 
 /***************************************************************/
@@ -508,11 +512,11 @@
         DTYPE mask;
         MASK(mask);
         off *= 8;
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
         LSHIFT(dd_old, da[0], 64 - off);
-#else /* _LITTLE_ENDIAN */
+#else /* BIG_ENDIAN */
         RSHIFT(dd_old, da[0], 64 - off);
-#endif /* _LITTLE_ENDIAN */
+#endif /* LITTLE_ENDIAN */
 
 #ifdef __SUNPRO_C
 #pragma pipeloop(0)
@@ -537,30 +541,30 @@
 
           res = (res & 0xff) | (res >> 8);
           dd = gray_mask[res];
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 /* *da++ = (dd_old >> (64 - off)) | (dd << off);*/
           RSHIFT(dd_old, dd_old, 64 - off);
           LSHIFT(dtmp, dd, off);
-#else /* _LITTLE_ENDIAN */
+#else /* BIG_ENDIAN */
 /* *da++ = (dd_old << (64 - off)) | (dd >> off);*/
           LSHIFT(dd_old, dd_old, 64 - off);
           RSHIFT(dtmp, dd, off);
-#endif /* _LITTLE_ENDIAN */
+#endif /* LITTLE_ENDIAN */
           LOGIC(*da++, dd_old, dtmp, |);
           dd_old = dd;
         }
 
-#ifdef _LITTLE_ENDIAN
+#if (BYTE_ORDER == LITTLE_ENDIAN)
 /* da[0] = (dd_old >> (64 - off)) | (da[0] & ((mlib_u64)((mlib_s64) -1) << off));*/
         LSHIFT(dtmp, mask, off);
         LOGIC(dtmp, da[0], dtmp, &);
         RSHIFT(dtmp1, dd_old, 64 - off);
-#else /* _LITTLE_ENDIAN */
+#else /* BIG_ENDIAN */
 /* da[0] = (dd_old << (64 - off)) | (da[0] & ((mlib_u64)((mlib_s64) -1) >> off));*/
         RSHIFT(dtmp, mask, off);
         LOGIC(dtmp, da[0], dtmp, &);
         LSHIFT(dtmp1, dd_old, 64 - off);
-#endif /* _LITTLE_ENDIAN */
+#endif /* LITTLE_ENDIAN */
         LOGIC(da[0], dtmp, dtmp1, |);
       }
       else {                                               /* aligned */
--- ./jdk/src/solaris/native/sun/java2d/loops/vis_FuncArray.c	2010-03-18 01:45:35.000000000 -0700
+++ ./jdk/src/solaris/native/sun/java2d/loops/vis_FuncArray.c	2010-01-30 09:28:35.000000000 -0800
@@ -794,7 +794,7 @@
 static int initialized;
 static int usevis = JNI_TRUE;
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #   define ULTRA_CHIP   "sparc64"
 #else
 #   define ULTRA_CHIP   "sun4u"
--- ./jdk/src/solaris/native/sun/java2d/opengl/OGLFuncs_md.h	2010-03-18 01:45:36.000000000 -0700
+++ ./jdk/src/solaris/native/sun/java2d/opengl/OGLFuncs_md.h	2010-01-30 09:28:35.000000000 -0800
@@ -27,7 +27,10 @@
 #define OGLFuncs_md_h_Included
 
 #include <stdlib.h>
+#ifndef __APPLE__
 #include <link.h>
+#endif
+#include "jvm_md.h"
 #include "J2D_GL/glx.h"
 #include "OGLFuncMacros.h"
 
@@ -113,7 +116,7 @@
     { \
         char *libGLPath = getenv("J2D_ALT_LIBGL_PATH"); \
         if (libGLPath == NULL) { \
-            libGLPath = "libGL.so.1"; \
+            libGLPath = VERSIONED_JNI_LIB_NAME("GL", "1"); \
         } \
         OGL_LIB_HANDLE = dlopen(libGLPath, RTLD_LAZY | RTLD_LOCAL); \
     } \
--- ./jdk/src/solaris/native/sun/java2d/x11/X11SurfaceData.c	2010-03-18 01:45:36.000000000 -0700
+++ ./jdk/src/solaris/native/sun/java2d/x11/X11SurfaceData.c	2010-01-30 09:28:35.000000000 -0800
@@ -32,6 +32,7 @@
 #include "gdefs.h"
 
 #include "jni_util.h"
+#include "jvm_md.h"
 #include "awt_Component.h"
 #include "awt_GraphicsEnv.h"
 
@@ -128,7 +129,7 @@
 
     if (tryDGA && (getenv("NO_J2D_DGA") == NULL)) {
     /* we use RTLD_NOW because of bug 4032715 */
-        lib = dlopen("libsunwjdga.so", RTLD_NOW);
+        lib = dlopen(JNI_LIB_NAME("sunwjdga"), RTLD_NOW);
     }
     dgaAvailable = JNI_FALSE;
     if (lib != NULL) {
--- ./jdk/src/solaris/native/sun/jdga/dgalock.c	2010-03-18 01:45:36.000000000 -0700
+++ ./jdk/src/solaris/native/sun/jdga/dgalock.c	2010-01-30 09:28:35.000000000 -0800
@@ -44,6 +44,7 @@
 #include <X11/Xlib.h>
 
 #include "jni.h"
+#include "jvm_md.h"
 #include "jdga.h"
 #include "jdgadevice.h"
 
@@ -84,10 +85,10 @@
 static GetVirtualDrawableFunc * GetVirtualDrawable = GetVirtualDrawableStub;
 
 static void Solaris_DGA_XineramaInit(Display *display) {
-    void * handle = 0;
+    void * handle = NULL;
     if (IsXineramaOn == NULL) {
-        handle = dlopen("libxinerama.so", RTLD_NOW);
-        if (handle != 0) {
+        handle = dlopen(JNI_LIB_NAME("xinerama"), RTLD_NOW);
+        if (handle != NULL) {
             void *sym = dlsym(handle, "IsXineramaOn");
             IsXineramaOn = (IsXineramaOnFunc *)sym;
             if (IsXineramaOn != 0 && (*IsXineramaOn)(display)) {
--- ./jdk/src/solaris/native/sun/management/FileSystemImpl.c	2010-03-18 01:45:36.000000000 -0700
+++ ./jdk/src/solaris/native/sun/management/FileSystemImpl.c	2010-01-30 09:28:35.000000000 -0800
@@ -26,6 +26,10 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 
+#if defined(_ALLBSD_SOURCE)
+#include "largefile_bsd.h"
+#endif
+
 #include "jni.h"
 #include "jni_util.h"
 #include "sun_management_FileSystemImpl.h"
--- ./jdk/src/solaris/native/sun/net/dns/ResolverConfigurationImpl.c	2010-03-18 01:45:36.000000000 -0700
+++ ./jdk/src/solaris/native/sun/net/dns/ResolverConfigurationImpl.c	2010-01-30 09:28:35.000000000 -0800
@@ -33,7 +33,7 @@
 #include <strings.h>
 #endif
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <string.h>
 #endif
 
--- ./jdk/src/solaris/native/sun/net/spi/DefaultProxySelector.c	2010-03-18 01:45:36.000000000 -0700
+++ ./jdk/src/solaris/native/sun/net/spi/DefaultProxySelector.c	2010-03-08 21:38:22.000000000 -0800
@@ -26,11 +26,12 @@
 #include "jni.h"
 #include "jni_util.h"
 #include "jvm.h"
+#include "jvm_md.h"
 #include "jlong.h"
 #include "sun_net_spi_DefaultProxySelector.h"
 #include <dlfcn.h>
 #include <stdio.h>
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <string.h>
 #else
 #include <strings.h>
@@ -110,8 +111,9 @@
   /**
    * Let's try to load le GConf-2 library
    */
-  if (dlopen("libgconf-2.so", RTLD_GLOBAL | RTLD_LAZY) != NULL ||
-      dlopen("libgconf-2.so.4", RTLD_GLOBAL | RTLD_LAZY) != NULL) {
+  if (dlopen(JNI_LIB_NAME("gconf-2"), RTLD_GLOBAL | RTLD_LAZY) != NULL ||
+      dlopen(VERSIONED_JNI_LIB_NAME("gconf-2", "4"),
+             RTLD_GLOBAL | RTLD_LAZY) != NULL) {
     gconf_ver = 2;
   }
   if (gconf_ver > 0) {
--- ./jdk/src/solaris/native/sun/nio/ch/DatagramChannelImpl.c	2010-03-18 01:45:36.000000000 -0700
+++ ./jdk/src/solaris/native/sun/nio/ch/DatagramChannelImpl.c	2010-01-30 09:28:35.000000000 -0800
@@ -35,7 +35,7 @@
 #include <string.h>
 #include <errno.h>
 
-#if __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <netinet/in.h>
 #endif
 
@@ -86,7 +86,7 @@
     rv = connect(fd, 0, 0);
 #endif
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     {
         int len;
         SOCKADDR sa;
@@ -96,17 +96,30 @@
 #ifdef AF_INET6
         if (ipv6_available()) {
             struct sockaddr_in6 *him6 = (struct sockaddr_in6 *)&sa;
+#if defined(_ALLBSD_SOURCE)
+	    him6->sin6_family = AF_INET6;
+#else
             him6->sin6_family = AF_UNSPEC;
+#endif
             len = sizeof(struct sockaddr_in6);
         } else
 #endif
         {
             struct sockaddr_in *him4 = (struct sockaddr_in*)&sa;
+#if defined(_ALLBSD_SOURCE)
+	    him4->sin_family = AF_INET;
+#else
             him4->sin_family = AF_UNSPEC;
+#endif
             len = sizeof(struct sockaddr_in);
         }
 
         rv = connect(fd, (struct sockaddr *)&sa, len);
+
+#if defined(_ALLBSD_SOURCE)
+	if (rv < 0 && errno == EADDRNOTAVAIL)
+		rv = errno = 0;
+#endif
     }
 #endif
 
--- ./jdk/src/solaris/native/sun/nio/ch/DatagramDispatcher.c	2010-03-18 01:45:36.000000000 -0700
+++ ./jdk/src/solaris/native/sun/nio/ch/DatagramDispatcher.c	2010-02-06 09:58:52.000000000 -0800
@@ -73,7 +73,7 @@
     m.msg_accrightslen = 0;
 #endif
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     m.msg_control = NULL;
     m.msg_controllen = 0;
 #endif
@@ -121,7 +121,7 @@
     m.msg_accrightslen = 0;
 #endif
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
     m.msg_control = NULL;
     m.msg_controllen = 0;
 #endif
--- ./jdk/src/solaris/native/sun/nio/ch/FileChannelImpl.c	2010-03-18 01:45:36.000000000 -0700
+++ ./jdk/src/solaris/native/sun/nio/ch/FileChannelImpl.c	2010-03-25 23:55:51.000000000 -0700
@@ -26,15 +26,21 @@
 #include "jni.h"
 #include "jni_util.h"
 #include "jvm.h"
+#include "jvm_md.h"
 #include "jlong.h"
 #include <sys/mman.h>
 #include <sys/stat.h>
+#include <fcntl.h>
 #include "sun_nio_ch_FileChannelImpl.h"
 #include "java_lang_Integer.h"
 #include "nio.h"
 #include "nio_util.h"
 #include <dlfcn.h>
 
+#if defined(_ALLBSD_SOURCE)
+#include "largefile_bsd.h"
+#endif
+
 static jfieldID chan_fd;        /* jobject 'fd' in sun.io.FileChannelImpl */
 
 #ifdef __solaris__
@@ -59,6 +65,24 @@
 typedef ssize_t sendfile64_func(int out_fd, int in_fd, off64_t *offset, size_t count);
 
 sendfile64_func* my_sendfile64_func = NULL;
+#elif defined(_ALLBSD_SOURCE)
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/uio.h>
+#include <errno.h>
+#include <stdlib.h>
+
+#ifdef __APPLE__
+typedef int sendfile_func(int fd, int s, off_t offset, off_t *len,
+                          struct sf_hdtr *hdtr, int flags);
+#elif defined(__FreeBSD__)
+typedef int sendfile_func(int fd, int s, off_t offset, size_t nbytes,
+                          struct sf_hdtr *hdtr, off_t *sbytes, int flags);
+#endif
+
+#if defined(__APPLE__) || defined(__FreeBSD__)
+sendfile_func* my_sendfile_func = NULL;
+#endif
 #endif
 
 JNIEXPORT jlong JNICALL
@@ -68,7 +92,8 @@
     chan_fd = (*env)->GetFieldID(env, clazz, "fd", "Ljava/io/FileDescriptor;");
 
 #ifdef __solaris__
-    if (dlopen("/usr/lib/libsendfile.so.1", RTLD_GLOBAL | RTLD_LAZY) != NULL) {
+    if (dlopen("/usr/lib/" VERSIONED_JNI_LIB_NAME("sendfile", "1"),
+               RTLD_GLOBAL | RTLD_LAZY) != NULL) {
         my_sendfile_func = (sendfile_func*) dlsym(RTLD_DEFAULT, "sendfilev64");
     }
 #endif
@@ -77,6 +102,10 @@
     my_sendfile64_func = (sendfile64_func*) dlsym(RTLD_DEFAULT, "sendfile64");
 #endif
 
+#if defined(__APPLE__) || defined(__FreeBSD__)
+    my_sendfile_func = (sendfile_func*) dlsym(RTLD_DEFAULT, "sendfile");
+#endif
+
     return pageSize;
 }
 
@@ -243,4 +272,46 @@
         return result;
     }
 #endif
+
+#ifdef _ALLBSD_SOURCE
+#if defined(__APPLE__) || defined(__FreeBSD__)
+    if (my_sendfile_func == NULL)
+        return IOS_UNSUPPORTED;
+
+    off_t numBytes;
+    int result;
+
+    numBytes = count;
+
+#ifdef __APPLE__
+    result = (*my_sendfile_func)(srcFD, dstFD, position,
+                                     &numBytes, NULL, 0);
+#elif defined(__FreeBSD__)
+    result = (*my_sendfile_func)(srcFD, dstFD, position,
+                                     count, NULL, &numBytes, 0);
+#else
+    Add an #elif for your BSD flavor
+#endif
+
+    if (numBytes > 0)
+        return numBytes;
+
+    if (result == -1) {
+        if (errno == EAGAIN)
+            return IOS_UNAVAILABLE;
+        if (errno == EOPNOTSUPP || errno == ENOTSOCK || errno == ENOTCONN)
+            return IOS_UNSUPPORTED_CASE;
+        if ((errno == EINVAL) && ((ssize_t)count >= 0))
+            return IOS_UNSUPPORTED_CASE;
+        if (errno == EINTR)
+            return IOS_INTERRUPTED;
+        JNU_ThrowIOExceptionWithLastError(env, "Transfer failed");
+        return IOS_THROWN;
+    }
+
+    return result;
+#else
+    return IOS_UNSUPPORTED;
+#endif
+#endif
 }
--- ./jdk/src/solaris/native/sun/nio/ch/FileDispatcherImpl.c	2010-03-18 01:45:36.000000000 -0700
+++ ./jdk/src/solaris/native/sun/nio/ch/FileDispatcherImpl.c	2010-01-30 09:28:35.000000000 -0800
@@ -33,9 +33,13 @@
 #include <sys/socket.h>
 #include <fcntl.h>
 #include <sys/uio.h>
+#include <unistd.h>
 #include "nio.h"
 #include "nio_util.h"
 
+#if defined(_ALLBSD_SOURCE)
+#include "largefile_bsd.h"
+#endif
 
 static int preCloseFD = -1;     /* File descriptor to which we dup other fd's
                                    before closing them for real */
@@ -218,6 +222,23 @@
     fl.l_start = (off64_t)pos;
     fl.l_type = F_UNLCK;
     lockResult = fcntl(fd, cmd, &fl);
+#if defined(__FreeBSD__) || defined(__OpenBSD__)
+    /* XXXFREEBSD:  While doing of preClose0() we're closing actual fd which
+       was locked, so here we'll get an error which need to be ignored to
+       satisfy TCK FileLock test */
+    /* XXXFREEBSD: backport to 1.4.2 */
+    if (lockResult < 0 && errno == EBADF)
+	lockResult = errno = 0;
+#endif
+#if defined(__NetBSD__)
+    /* XXXNETBSD: The dup2 in preClose0 is being done onto 1 end of a
+       socketpair which isn't a valid target for F_UNLCK. No good way to see
+       this vs. a bad lock setup so just return errno = 0 there
+       to pass JCK (lock will get removed once all fd's close anyways) */
+    /* XXXNETBSD: backport to 1.4.2 */
+    if (lockResult < 0 && errno == EINVAL)
+	lockResult = errno = 0;
+#endif
     if (lockResult < 0) {
         JNU_ThrowIOExceptionWithLastError(env, "Release failed");
     }
--- ./jdk/src/solaris/native/sun/nio/ch/FileKey.c	2010-03-18 01:45:36.000000000 -0700
+++ ./jdk/src/solaris/native/sun/nio/ch/FileKey.c	2010-01-30 09:28:35.000000000 -0800
@@ -30,6 +30,10 @@
 #include "nio_util.h"
 #include "sun_nio_ch_FileKey.h"
 
+#if defined(_ALLBSD_SOURCE)
+#include "largefile_bsd.h"
+#endif
+
 static jfieldID key_st_dev;    /* id for FileKey.st_dev */
 static jfieldID key_st_ino;    /* id for FileKey.st_ino */
 
--- ./jdk/src/solaris/native/sun/nio/ch/Net.c	2010-03-18 01:45:36.000000000 -0700
+++ ./jdk/src/solaris/native/sun/nio/ch/Net.c	2010-02-19 08:02:42.000000000 -0800
@@ -116,6 +116,47 @@
 
 #endif   /* __linux__ */
 
+#ifdef _ALLBSD_SOURCE
+
+#ifndef IP_BLOCK_SOURCE
+
+#define IP_ADD_SOURCE_MEMBERSHIP        70   /* join a source-specific group */
+#define IP_DROP_SOURCE_MEMBERSHIP       71   /* drop a single source */
+#define IP_BLOCK_SOURCE                 72   /* block a source */
+#define IP_UNBLOCK_SOURCE               73   /* unblock a source */
+
+#endif  /* IP_BLOCK_SOURCE */
+
+#ifndef MCAST_BLOCK_SOURCE
+
+#define MCAST_JOIN_SOURCE_GROUP         82   /* join a source-specific group */
+#define MCAST_LEAVE_SOURCE_GROUP        83   /* leave a single source */
+#define MCAST_BLOCK_SOURCE              84   /* block a source */
+#define MCAST_UNBLOCK_SOURCE            85   /* unblock a source */
+
+#endif /* MCAST_BLOCK_SOURCE */
+
+#ifndef IPV6_ADD_MEMBERSHIP
+
+#define IPV6_ADD_MEMBERSHIP	IPV6_JOIN_GROUP
+#define IPV6_DROP_MEMBERSHIP	IPV6_LEAVE_GROUP
+
+#endif /* IPV6_ADD_MEMBERSHIP */
+
+struct my_ip_mreq_source {
+        struct in_addr  imr_multiaddr;
+        struct in_addr  imr_interface;
+        struct in_addr  imr_sourceaddr;
+};
+
+struct my_group_source_req {
+        uint32_t                gsr_interface;  /* interface index */
+        struct sockaddr_storage gsr_group;      /* group address */
+        struct sockaddr_storage gsr_source;     /* source address */
+};
+
+#endif   /* _ALLBSD_SOURCE */
+
 
 #define COPY_INET6_ADDRESS(env, source, target) \
     (*env)->GetByteArrayRegion(env, source, 0, 16, target)
@@ -255,8 +296,30 @@
     SOCKADDR sa;
     socklen_t sa_len = SOCKADDR_LEN;
     if (getsockname(fdval(env, fdo), (struct sockaddr *)&sa, &sa_len) < 0) {
+#ifdef _ALLBSD_SOURCE
+	/*
+	 * XXXBSD:
+	 * ECONNRESET is specific to the BSDs. We can not return an error,
+	 * as the calling Java code with raise a java.lang.Error given the expectation
+	 * that getsockname() will never fail. According to the Single UNIX Specification,
+	 * it shouldn't fail. As such, we just fill in generic Linux-compatible values.
+	 */
+	if (errno == ECONNRESET) {
+	    struct sockaddr_in *sin;
+	    sin = (struct sockaddr_in *) &sa;
+	    bzero(sin, sizeof(*sin));
+	    sin->sin_len  = sizeof(struct sockaddr_in);
+	    sin->sin_family = AF_INET;
+	    sin->sin_port = htonl(0);
+	    sin->sin_addr.s_addr = INADDR_ANY;
+	} else {
+	    handleSocketError(env, errno);
+	    return -1;
+	}
+#else /* _ALLBSD_SOURCE */
         handleSocketError(env, errno);
         return -1;
+#endif /* _ALLBSD_SOURCE */
     }
     return NET_GetPortFromSockaddr((struct sockaddr *)&sa);
 }
@@ -268,8 +331,30 @@
     socklen_t sa_len = SOCKADDR_LEN;
     int port;
     if (getsockname(fdval(env, fdo), (struct sockaddr *)&sa, &sa_len) < 0) {
+#ifdef _ALLBSD_SOURCE
+	/*
+	 * XXXBSD:
+	 * ECONNRESET is specific to the BSDs. We can not return an error,
+	 * as the calling Java code with raise a java.lang.Error with the expectation
+	 * that getsockname() will never fail. According to the Single UNIX Specification,
+	 * it shouldn't fail. As such, we just fill in generic Linux-compatible values.
+	 */
+	if (errno == ECONNRESET) {
+	    struct sockaddr_in *sin;
+	    sin = (struct sockaddr_in *) &sa;
+	    bzero(sin, sizeof(*sin));
+	    sin->sin_len  = sizeof(struct sockaddr_in);
+	    sin->sin_family = AF_INET;
+	    sin->sin_port = htonl(0);
+	    sin->sin_addr.s_addr = INADDR_ANY;
+	} else {
+	    handleSocketError(env, errno);
+	    return NULL;
+	}
+#else /* _ALLBSD_SOURCE */
         handleSocketError(env, errno);
         return NULL;
+#endif /* _ALLBSD_SOURCE */
     }
     return NET_SockaddrToInetAddress(env, (struct sockaddr *)&sa, &port);
 }
@@ -282,7 +367,8 @@
     struct linger linger;
     u_char carg;
     void *arg;
-    int arglen, n;
+    socklen_t arglen;
+    int n;
 
     /* Option value is an int except for a few specific cases */
 
@@ -332,7 +418,8 @@
     struct linger linger;
     u_char carg;
     void *parg;
-    int arglen, n;
+    socklen_t arglen;
+    int n;
 
     /* Option value is an int except for a few specific cases */
 
@@ -495,7 +582,7 @@
 Java_sun_nio_ch_Net_setInterface4(JNIEnv* env, jobject this, jobject fdo, jint interf)
 {
     struct in_addr in;
-    int arglen = sizeof(struct in_addr);
+    socklen_t arglen = sizeof(struct in_addr);
     int n;
 
     in.s_addr = htonl(interf);
@@ -511,7 +598,7 @@
 Java_sun_nio_ch_Net_getInterface4(JNIEnv* env, jobject this, jobject fdo)
 {
     struct in_addr in;
-    int arglen = sizeof(struct in_addr);
+    socklen_t arglen = sizeof(struct in_addr);
     int n;
 
     n = getsockopt(fdval(env, fdo), IPPROTO_IP, IP_MULTICAST_IF, (void*)&in, &arglen);
@@ -526,7 +613,7 @@
 Java_sun_nio_ch_Net_setInterface6(JNIEnv* env, jobject this, jobject fdo, jint index)
 {
     int value = (jint)index;
-    int arglen = sizeof(value);
+    socklen_t arglen = sizeof(value);
     int n;
 
     n = setsockopt(fdval(env, fdo), IPPROTO_IPV6, IPV6_MULTICAST_IF,
@@ -540,7 +627,7 @@
 Java_sun_nio_ch_Net_getInterface6(JNIEnv* env, jobject this, jobject fdo)
 {
     int index;
-    int arglen = sizeof(index);
+    socklen_t arglen = sizeof(index);
     int n;
 
     n = getsockopt(fdval(env, fdo), IPPROTO_IPV6, IPV6_MULTICAST_IF, (void*)&index, &arglen);
@@ -569,9 +656,11 @@
     switch (errorValue) {
         case EINPROGRESS:       /* Non-blocking connect */
             return 0;
+#ifdef EPROTO
         case EPROTO:
             xn = JNU_JAVANETPKG "ProtocolException";
             break;
+#endif
         case ECONNREFUSED:
             xn = JNU_JAVANETPKG "ConnectException";
             break;
--- ./jdk/src/solaris/native/sun/nio/ch/Sctp.h	2010-03-18 01:45:36.000000000 -0700
+++ ./jdk/src/solaris/native/sun/nio/ch/Sctp.h	2010-01-30 09:28:35.000000000 -0800
@@ -67,7 +67,7 @@
 
 
 
-#else /* __linux__ */
+#elif __linux__
 #include <stdint.h>
 #include <linux/types.h>
 #include <sys/socket.h>
@@ -320,8 +320,20 @@
 typedef int sctp_peeloff_func(int sock, sctp_assoc_t id);
 
 
+#elif defined(__FreeBSD__) && __FreeBSD__ >= 7
+
+#include <stdint.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/sctp.h>
+#include <netinet/sctp_peeloff.h>
+#include <netinet/sctp_uio.h>
+#include "jni.h"
+
 #endif /* __linux__ */
 
+#if !defined(__FreeBSD__) || __FreeBSD__ < 7
+
 sctp_getladdrs_func* nio_sctp_getladdrs;
 sctp_freeladdrs_func* nio_sctp_freeladdrs;
 sctp_getpaddrs_func* nio_sctp_getpaddrs;
@@ -329,6 +341,17 @@
 sctp_bindx_func* nio_sctp_bindx;
 sctp_peeloff_func* nio_sctp_peeloff;
 
+#else
+
+#define nio_sctp_getladdrs	sctp_getladdrs
+#define nio_sctp_freeladdrs	sctp_freeladdrs
+#define nio_sctp_getpaddrs	sctp_getpaddrs
+#define nio_sctp_freepaddrs	sctp_freepaddrs
+#define nio_sctp_bindx		sctp_bindx
+#define nio_sctp_peeloff	sctp_peeloff
+
+#endif
+
 jboolean loadSocketExtensionFuncs(JNIEnv* env);
 
 #endif /* !SUN_NIO_CH_SCTP_H */
--- ./jdk/src/solaris/native/sun/nio/ch/SctpChannelImpl.c	2010-03-18 01:45:36.000000000 -0700
+++ ./jdk/src/solaris/native/sun/nio/ch/SctpChannelImpl.c	2010-01-30 09:28:35.000000000 -0800
@@ -337,11 +337,11 @@
             break;
         case SCTP_ADDR_MADE_PRIM :
             event = sun_nio_ch_SctpPeerAddrChange_SCTP_ADDR_MADE_PRIM;
-#ifdef __linux__  /* Solaris currently doesn't support SCTP_ADDR_CONFIRMED */
+#ifndef __solaris__  /* Solaris currently doesn't support SCTP_ADDR_CONFIRMED */
             break;
         case SCTP_ADDR_CONFIRMED :
             event = sun_nio_ch_SctpPeerAddrChange_SCTP_ADDR_CONFIRMED;
-#endif  /* __linux__ */
+#endif  /* __solaris__ */
     }
 
     addressObj = SockAddrToInetSocketAddress(env, (struct sockaddr*)&spc->spc_aaddr);
--- ./jdk/src/solaris/native/sun/nio/ch/SctpNet.c	2010-03-18 01:45:36.000000000 -0700
+++ ./jdk/src/solaris/native/sun/nio/ch/SctpNet.c	2010-02-19 08:02:42.000000000 -0800
@@ -58,6 +58,7 @@
  */
 jboolean loadSocketExtensionFuncs
   (JNIEnv* env) {
+#if !defined(__FreeBSD__) || __FreeBSD__ < 7 /* On FreeBSD 7.x these functions are in libc */
     if (dlopen(nativeSctpLib, RTLD_GLOBAL | RTLD_LAZY) == NULL) {
         JNU_ThrowByName(env, "java/lang/UnsupportedOperationException",
               dlerror());
@@ -105,6 +106,7 @@
               dlerror());
         return JNI_FALSE;
     }
+#endif /* __FreeBSD__ */
 
     funcsLoaded = JNI_TRUE;
     return JNI_TRUE;
--- ./jdk/src/solaris/native/sun/nio/fs/BsdNativeDispatcher.c	2010-03-27 11:09:15.000000000 -0700
+++ ./jdk/src/solaris/native/sun/nio/fs/BsdNativeDispatcher.c	2010-01-30 09:28:35.000000000 -0800
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2009 Sun Microsystems, Inc.  All Rights Reserved.
+ * Copyright 2009 Sun Microsystems, Inc.  All Rights Reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -28,23 +28,35 @@
 #include "jvm.h"
 #include "jlong.h"
 
-#include <stdio.h>
-#include <dlfcn.h>
-#include <errno.h>
-#include <mntent.h>
+#include <sys/param.h>
+#include <sys/mount.h>
+#ifdef ST_RDONLY
+#define statfs statvfs
+#define getfsstat getvfsstat
+#define f_flags f_flag
+#define ISREADONLY ST_RDONLY
+#else
+#define ISREADONLY MNT_RDONLY
+#endif
+
+#include <stdlib.h>
+#include <string.h>
+
+static jfieldID entry_name;
+static jfieldID entry_dir;
+static jfieldID entry_fstype;
+static jfieldID entry_options;
+static jfieldID entry_dev;
+
+
+struct fsstat_iter {
+    struct statfs *buf;
+    int pos;
+    int nentries;
+};
 
 #include "sun_nio_fs_BsdNativeDispatcher.h"
 
-typedef size_t fgetxattr_func(int fd, const char* name, void* value, size_t size);
-typedef int fsetxattr_func(int fd, const char* name, void* value, size_t size, int flags);
-typedef int fremovexattr_func(int fd, const char* name);
-typedef int flistxattr_func(int fd, char* list, size_t size);
-
-fgetxattr_func* my_fgetxattr_func = NULL;
-fsetxattr_func* my_fsetxattr_func = NULL;
-fremovexattr_func* my_fremovexattr_func = NULL;
-flistxattr_func* my_flistxattr_func = NULL;
-
 static void throwUnixException(JNIEnv* env, int errnum) {
     jobject x = JNU_NewObjectByName(env, "sun/nio/fs/UnixException",
         "(I)V", errnum);
@@ -53,108 +65,146 @@
     }
 }
 
+/**
+ * Initialize jfieldIDs
+ */
 JNIEXPORT void JNICALL
-Java_sun_nio_fs_BsdNativeDispatcher_init(JNIEnv *env, jclass clazz)
+Java_sun_nio_fs_BsdNativeDispatcher_initIDs(JNIEnv* env, jclass this)
 {
-    my_fgetxattr_func = (fgetxattr_func*)dlsym(RTLD_DEFAULT, "fgetxattr");
-    my_fsetxattr_func = (fsetxattr_func*)dlsym(RTLD_DEFAULT, "fsetxattr");
-    my_fremovexattr_func = (fremovexattr_func*)dlsym(RTLD_DEFAULT, "fremovexattr");
-    my_flistxattr_func = (flistxattr_func*)dlsym(RTLD_DEFAULT, "flistxattr");
-}
+    jclass clazz;
 
-JNIEXPORT jint JNICALL
-Java_sun_nio_fs_BsdNativeDispatcher_fgetxattr0(JNIEnv* env, jclass clazz,
-    jint fd, jlong nameAddress, jlong valueAddress, jint valueLen)
-{
-    size_t res = -1;
-    const char* name = jlong_to_ptr(nameAddress);
-    void* value = jlong_to_ptr(valueAddress);
-
-    if (my_fgetxattr_func == NULL) {
-        errno = ENOTSUP;
-    } else {
-        /* EINTR not documented */
-        res = (*my_fgetxattr_func)(fd, name, value, valueLen);
-    }
-    if (res == (size_t)-1)
-        throwUnixException(env, errno);
-    return (jint)res;
+    clazz = (*env)->FindClass(env, "sun/nio/fs/UnixMountEntry");
+    if (clazz == NULL) {
+        return;
+    }
+    entry_name = (*env)->GetFieldID(env, clazz, "name", "[B");
+    entry_dir = (*env)->GetFieldID(env, clazz, "dir", "[B");
+    entry_fstype = (*env)->GetFieldID(env, clazz, "fstype", "[B");
+    entry_options = (*env)->GetFieldID(env, clazz, "opts", "[B");
+    entry_dev = (*env)->GetFieldID(env, clazz, "dev", "J");
 }
 
-JNIEXPORT void JNICALL
-Java_sun_nio_fs_BsdNativeDispatcher_fsetxattr0(JNIEnv* env, jclass clazz,
-    jint fd, jlong nameAddress, jlong valueAddress, jint valueLen)
+JNIEXPORT jlong JNICALL
+Java_sun_nio_fs_BsdNativeDispatcher_getfsstat(JNIEnv* env, jclass this)
 {
-    int res = -1;
-    const char* name = jlong_to_ptr(nameAddress);
-    void* value = jlong_to_ptr(valueAddress);
-
-    if (my_fsetxattr_func == NULL) {
-        errno = ENOTSUP;
-    } else {
-        /* EINTR not documented */
-        res = (*my_fsetxattr_func)(fd, name, value, valueLen, 0);
+    int nentries;
+    size_t bufsize;
+    struct fsstat_iter *iter = malloc(sizeof(*iter));
+
+    if (iter == NULL) {
+        JNU_ThrowOutOfMemoryError(env, "native heap");
+        return 0;
     }
-    if (res == -1)
+
+    iter->pos = 0;
+    iter->nentries = 0;
+    iter->buf = NULL;
+
+    nentries = getfsstat(NULL, 0, MNT_NOWAIT);
+
+    if (nentries <= 0) {
+        free(iter);
         throwUnixException(env, errno);
-}
+        return 0;
+    }
 
-JNIEXPORT void JNICALL
-Java_sun_nio_fs_BsdNativeDispatcher_fremovexattr0(JNIEnv* env, jclass clazz,
-    jint fd, jlong nameAddress)
-{
-    int res = -1;
-    const char* name = jlong_to_ptr(nameAddress);
+    // It's possible that a new filesystem gets mounted between
+    // the first getfsstat and the second so loop until consistant
+
+    while (nentries != iter->nentries) {
+        if (iter->buf != NULL)
+            free(iter->buf);
+
+        bufsize = nentries * sizeof(struct statfs);
+        iter->nentries = nentries;
+
+        iter->buf = malloc(bufsize);
+        if (iter->buf == NULL) {
+            free(iter);
+            JNU_ThrowOutOfMemoryError(env, "native heap");
+            return 0;
+        }
 
-    if (my_fremovexattr_func == NULL) {
-        errno = ENOTSUP;
-    } else {
-        /* EINTR not documented */
-        res = (*my_fremovexattr_func)(fd, name);
+        nentries = getfsstat(iter->buf, bufsize, MNT_WAIT);
+        if (nentries <= 0) {
+            free(iter->buf);
+            free(iter);
+            throwUnixException(env, errno);
+            return 0;
+        }
     }
-    if (res == -1)
-        throwUnixException(env, errno);
+
+    return (jlong)iter;
 }
 
 JNIEXPORT jint JNICALL
-Java_sun_nio_fs_BsdNativeDispatcher_flistxattr(JNIEnv* env, jclass clazz,
-    jint fd, jlong listAddress, jint size)
+Java_sun_nio_fs_BsdNativeDispatcher_fsstatEntry(JNIEnv* env, jclass this,
+    jlong value, jobject entry)
 {
-    size_t res = -1;
-    char* list = jlong_to_ptr(listAddress);
+    struct fsstat_iter *iter = jlong_to_ptr(value);
+    jsize len;
+    jbyteArray bytes;
+    char* name;
+    char* dir;
+    char* fstype;
+    char* options;
+    dev_t dev;
+
+    if (iter == NULL || iter->pos >= iter->nentries)
+       return -1;
+
+    name = iter->buf[iter->pos].f_mntfromname;
+    dir = iter->buf[iter->pos].f_mntonname;
+    fstype = iter->buf[iter->pos].f_fstypename;
+    if (iter->buf[iter->pos].f_flags & ISREADONLY)
+        options="ro";
+    else
+        options="";
+    dev = 0;
+
+    iter->pos++;
+
+    len = strlen(name);
+    bytes = (*env)->NewByteArray(env, len);
+    if (bytes == NULL)
+        return -1;
+    (*env)->SetByteArrayRegion(env, bytes, 0, len, (jbyte*)name);
+    (*env)->SetObjectField(env, entry, entry_name, bytes);
+
+    len = strlen(dir);
+    bytes = (*env)->NewByteArray(env, len);
+    if (bytes == NULL)
+        return -1;
+    (*env)->SetByteArrayRegion(env, bytes, 0, len, (jbyte*)dir);
+    (*env)->SetObjectField(env, entry, entry_dir, bytes);
+
+    len = strlen(fstype);
+    bytes = (*env)->NewByteArray(env, len);
+    if (bytes == NULL)
+        return -1;
+    (*env)->SetByteArrayRegion(env, bytes, 0, len, (jbyte*)fstype);
+    (*env)->SetObjectField(env, entry, entry_fstype, bytes);
+
+    len = strlen(options);
+    bytes = (*env)->NewByteArray(env, len);
+    if (bytes == NULL)
+        return -1;
+    (*env)->SetByteArrayRegion(env, bytes, 0, len, (jbyte*)options);
+    (*env)->SetObjectField(env, entry, entry_options, bytes);
 
-    if (my_flistxattr_func == NULL) {
-        errno = ENOTSUP;
-    } else {
-        /* EINTR not documented */
-        res = (*my_flistxattr_func)(fd, list, (size_t)size);
-    }
-    if (res == (size_t)-1)
-        throwUnixException(env, errno);
-    return (jint)res;
-}
+    if (dev != 0)
+        (*env)->SetLongField(env, entry, entry_dev, (jlong)dev);
 
-JNIEXPORT jlong JNICALL
-Java_sun_nio_fs_BsdNativeDispatcher_setmntent0(JNIEnv* env, jclass this, jlong pathAddress,
-                                                 jlong modeAddress)
-{
-    FILE* fp = NULL;
-    const char* path = (const char*)jlong_to_ptr(pathAddress);
-    const char* mode = (const char*)jlong_to_ptr(modeAddress);
-
-    do {
-        fp = setmntent(path, mode);
-    } while (fp == NULL && errno == EINTR);
-    if (fp == NULL) {
-        throwUnixException(env, errno);
-    }
-    return ptr_to_jlong(fp);
+    return 0;
 }
 
 JNIEXPORT void JNICALL
-Java_sun_nio_fs_BsdNativeDispatcher_endmntent(JNIEnv* env, jclass this, jlong stream)
+Java_sun_nio_fs_BsdNativeDispatcher_endfsstat(JNIEnv* env, jclass this, jlong value)
 {
-    FILE* fp = jlong_to_ptr(stream);
-    /* FIXME - man page doesn't explain how errors are returned */
-    endmntent(fp);
+    struct fsstat_iter *iter = jlong_to_ptr(value);
+
+    if (iter != NULL) {
+        free(iter->buf);
+        free(iter);
+    }
 }
--- ./jdk/src/solaris/native/sun/nio/fs/BsdWatchService.c	2010-03-27 11:09:15.000000000 -0700
+++ ./jdk/src/solaris/native/sun/nio/fs/BsdWatchService.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,195 +0,0 @@
-/*
- * Copyright 2008-2009 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Sun designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Sun in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-
-#include "jni.h"
-#include "jni_util.h"
-#include "jvm.h"
-#include "jlong.h"
-
-#include <stdlib.h>
-#include <dlfcn.h>
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <sys/poll.h>
-
-#include "sun_nio_fs_BsdWatchService.h"
-
-/* inotify.h may not be available at build time */
-#ifdef  __cplusplus
-extern "C" {
-#endif
-struct inotify_event
-{
-  int wd;
-  uint32_t mask;
-  uint32_t cookie;
-  uint32_t len;
-  char name __flexarr;
-};
-#ifdef  __cplusplus
-}
-#endif
-
-typedef int inotify_init_func(void);
-typedef int inotify_add_watch_func(int fd, const char* path, uint32_t mask);
-typedef int inotify_rm_watch_func(int fd, uint32_t wd);
-
-inotify_init_func* my_inotify_init_func = NULL;
-inotify_add_watch_func* my_inotify_add_watch_func = NULL;
-inotify_rm_watch_func* my_inotify_rm_watch_func = NULL;
-
-static void throwUnixException(JNIEnv* env, int errnum) {
-    jobject x = JNU_NewObjectByName(env, "sun/nio/fs/UnixException",
-        "(I)V", errnum);
-    if (x != NULL) {
-        (*env)->Throw(env, x);
-    }
-}
-
-JNIEXPORT void JNICALL
-Java_sun_nio_fs_BsdWatchService_init(JNIEnv *env, jclass clazz)
-{
-    my_inotify_init_func = (inotify_init_func*)
-        dlsym(RTLD_DEFAULT, "inotify_init");
-    my_inotify_add_watch_func =
-        (inotify_add_watch_func*) dlsym(RTLD_DEFAULT, "inotify_add_watch");
-    my_inotify_rm_watch_func =
-        (inotify_rm_watch_func*) dlsym(RTLD_DEFAULT, "inotify_rm_watch");
-
-    if ((my_inotify_init_func == NULL) || (my_inotify_add_watch_func == NULL) ||
-        (my_inotify_rm_watch_func == NULL)) {
-        JNU_ThrowInternalError(env, "unable to get address of inotify functions");
-    }
-}
-
-JNIEXPORT jint JNICALL
-Java_sun_nio_fs_BsdWatchService_eventSize(JNIEnv *env, jclass clazz)
-{
-    return (jint)sizeof(struct inotify_event);
-}
-
-JNIEXPORT jintArray JNICALL
-Java_sun_nio_fs_BsdWatchService_eventOffsets(JNIEnv *env, jclass clazz)
-{
-    jintArray result = (*env)->NewIntArray(env, 5);
-    if (result != NULL) {
-        jint arr[5];
-        arr[0] = (jint)offsetof(struct inotify_event, wd);
-        arr[1] = (jint)offsetof(struct inotify_event, mask);
-        arr[2] = (jint)offsetof(struct inotify_event, cookie);
-        arr[3] = (jint)offsetof(struct inotify_event, len);
-        arr[4] = (jint)offsetof(struct inotify_event, name);
-        (*env)->SetIntArrayRegion(env, result, 0, 5, arr);
-    }
-    return result;
-}
-
-
-JNIEXPORT jint JNICALL
-Java_sun_nio_fs_BsdWatchService_inotifyInit
-    (JNIEnv* env, jclass clazz)
-{
-    int ifd = (*my_inotify_init_func)();
-    if (ifd == -1) {
-        throwUnixException(env, errno);
-    }
-    return (jint)ifd;
-}
-
-JNIEXPORT jint JNICALL
-Java_sun_nio_fs_BsdWatchService_inotifyAddWatch
-    (JNIEnv* env, jclass clazz, jint fd, jlong address, jint mask)
-{
-    int wfd = -1;
-    const char* path = (const char*)jlong_to_ptr(address);
-
-    wfd = (*my_inotify_add_watch_func)((int)fd, path, mask);
-    if (wfd == -1) {
-        throwUnixException(env, errno);
-    }
-    return (jint)wfd;
-}
-
-JNIEXPORT void JNICALL
-Java_sun_nio_fs_BsdWatchService_inotifyRmWatch
-    (JNIEnv* env, jclass clazz, jint fd, jint wd)
-{
-    int err = (*my_inotify_rm_watch_func)((int)fd, (int)wd);
-    if (err == -1)
-        throwUnixException(env, errno);
-}
-
-JNIEXPORT void JNICALL
-Java_sun_nio_fs_BsdWatchService_configureBlocking
-    (JNIEnv* env, jclass clazz, jint fd, jboolean blocking)
-{
-    int flags = fcntl(fd, F_GETFL);
-
-    if ((blocking == JNI_FALSE) && !(flags & O_NONBLOCK))
-        fcntl(fd, F_SETFL, flags | O_NONBLOCK);
-    else if ((blocking == JNI_TRUE) && (flags & O_NONBLOCK))
-        fcntl(fd, F_SETFL, flags & ~O_NONBLOCK);
-}
-
-JNIEXPORT void JNICALL
-Java_sun_nio_fs_BsdWatchService_socketpair
-    (JNIEnv* env, jclass clazz, jintArray sv)
-{
-    int sp[2];
-    if (socketpair(PF_UNIX, SOCK_STREAM, 0, sp) == -1) {
-        throwUnixException(env, errno);
-    } else {
-        jint res[2];
-        res[0] = (jint)sp[0];
-        res[1] = (jint)sp[1];
-        (*env)->SetIntArrayRegion(env, sv, 0, 2, &res[0]);
-    }
-
-}
-
-JNIEXPORT jint JNICALL
-Java_sun_nio_fs_BsdWatchService_poll
-    (JNIEnv* env, jclass clazz, jint fd1, jint fd2)
-{
-    struct pollfd ufds[2];
-    int n;
-
-    ufds[0].fd = fd1;
-    ufds[0].events = POLLIN;
-    ufds[1].fd = fd2;
-    ufds[1].events = POLLIN;
-
-    n = poll(&ufds[0], 2, -1);
-    if (n == -1) {
-        if (errno == EINTR) {
-            n = 0;
-        } else {
-            throwUnixException(env, errno);
-        }
-     }
-    return (jint)n;
-
-
-}
--- ./jdk/src/solaris/native/sun/nio/fs/GnomeFileTypeDetector.c	2010-03-18 01:45:36.000000000 -0700
+++ ./jdk/src/solaris/native/sun/nio/fs/GnomeFileTypeDetector.c	2010-01-30 09:28:35.000000000 -0800
@@ -30,7 +30,9 @@
 
 #include <stdlib.h>
 #include <dlfcn.h>
+#ifndef __APPLE__
 #include <link.h>
+#endif
 
 #ifdef __solaris__
 #include <strings.h>
--- ./jdk/src/solaris/native/sun/nio/fs/UnixNativeDispatcher.c	2010-03-18 01:45:36.000000000 -0700
+++ ./jdk/src/solaris/native/sun/nio/fs/UnixNativeDispatcher.c	2010-01-30 09:28:35.000000000 -0800
@@ -49,6 +49,11 @@
 #include <mntent.h>
 #endif
 
+#ifdef _ALLBSD_SOURCE
+#include <string.h>
+#include "largefile_bsd.h"
+#endif
+
 #include "jni.h"
 #include "jni_util.h"
 #include "jlong.h"
@@ -213,6 +218,8 @@
         flags |= sun_nio_fs_UnixNativeDispatcher_HAS_AT_SYSCALLS;
     }
 
+    my_fdopendir_func = (fdopendir_func*) dlsym(RTLD_DEFAULT, "fdopendir");
+
     return flags;
 }
 
@@ -1016,6 +1023,10 @@
 {
 #ifdef __solaris__
     struct extmnttab ent;
+#elif defined(_ALLBSD_SOURCE)
+    char buf[1024];
+    char *str;
+    char *last;
 #else
     struct mntent ent;
     char buf[1024];
@@ -1044,6 +1055,25 @@
         throwUnixException(env, errno);
         return -1;
     }
+#elif defined(_ALLBSD_SOURCE)
+again:
+    if (!(str = fgets(buf, sizeof(buf), fp)))    
+        return -1;
+
+    name = strtok_r(str, " \t\n", &last);
+    if (name == NULL)
+        return -1;
+ 
+    // skip comments
+    if (*name == '#')
+        goto again;
+
+    dir = strtok_r((char *)NULL, " \t\n", &last);
+    fstype = strtok_r((char *)NULL, " \t\n", &last);
+    options = strtok_r((char *)NULL, " \t\n", &last);
+    if (options == NULL)
+        return -1;
+    dev = 0;
 #else
     m = getmntent_r(fp, &ent, (char*)&buf, buflen);
     if (m == NULL)
--- ./jdk/src/solaris/native/sun/nio/fs/genUnixConstants.c	2010-03-18 01:45:36.000000000 -0700
+++ ./jdk/src/solaris/native/sun/nio/fs/genUnixConstants.c	2010-01-30 09:28:35.000000000 -0800
@@ -63,7 +63,12 @@
     DEFX(O_EXCL);
     DEFX(O_TRUNC);
     DEFX(O_SYNC);
+#ifndef O_DSYNC
+    // At least FreeBSD doesn't define O_DSYNC
+    emit("O_DSYNC", O_SYNC);
+#else
     DEFX(O_DSYNC);
+#endif
     DEFX(O_NOFOLLOW);
 
     // mode masks
@@ -106,7 +111,12 @@
     DEF(ENOSYS);
     DEF(ELOOP);
     DEF(EROFS);
+#ifndef ENODATA
+    // Only used in Linux java source, provide any value so it compiles
+    emit("ENODATA", ELAST);
+#else
     DEF(ENODATA);
+#endif
     DEF(ERANGE);
 
     // flags used with openat/unlinkat/etc.
--- ./jdk/src/solaris/native/sun/security/jgss/wrapper/NativeFunc.c	2010-03-18 01:45:36.000000000 -0700
+++ ./jdk/src/solaris/native/sun/security/jgss/wrapper/NativeFunc.c	2010-01-30 09:28:35.000000000 -0800
@@ -26,7 +26,9 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <dlfcn.h>
+#ifndef __APPLE__
 #include <link.h>
+#endif
 #include "NativeFunc.h"
 
 /* standard GSS method names (ordering is from mapfile) */
--- ./jdk/src/solaris/native/sun/security/pkcs11/j2secmod_md.c	2010-03-18 01:45:36.000000000 -0700
+++ ./jdk/src/solaris/native/sun/security/pkcs11/j2secmod_md.c	2010-01-30 09:28:35.000000000 -0800
@@ -28,12 +28,19 @@
 #include <string.h>
 
 #include <dlfcn.h>
+#ifndef __APPLE__
 #include <link.h>
+#endif
 
 #include <jni_util.h>
 
 #include "j2secmod.h"
 
+#ifndef RTLD_NOLOAD
+/* A gross hack that will work if the NSS library is only opened once */
+static void *nssLibHandle = NULL;
+#endif
+
 void *findFunction(JNIEnv *env, jlong jHandle, const char *functionName) {
     void *hModule = (void*)jHandle;
     void *fAddress = dlsym(hModule, functionName);
@@ -51,7 +58,11 @@
 {
     const char *libName = (*env)->GetStringUTFChars(env, jLibName, NULL);
     // look up existing handle only, do not load
+#ifdef RTLD_NOLOAD
     void *hModule = dlopen(libName, RTLD_NOLOAD);
+#else
+    void *hModule = nssLibHandle;
+#endif
     dprintf2("-handle for %s: %u\n", libName, hModule);
     (*env)->ReleaseStringUTFChars(env, jLibName, libName);
     return (jlong)hModule;
@@ -65,6 +76,9 @@
 
     dprintf1("-lib %s\n", libName);
     hModule = dlopen(libName, RTLD_LAZY);
+#ifndef RTLD_NOLOAD
+    nssLibHandle = hModule;
+#endif
     (*env)->ReleaseStringUTFChars(env, jLibName, libName);
     dprintf2("-handle: %u (0X%X)\n", hModule, hModule);
 
--- ./jdk/src/solaris/native/sun/security/pkcs11/wrapper/p11_md.c	2010-03-18 01:45:36.000000000 -0700
+++ ./jdk/src/solaris/native/sun/security/pkcs11/wrapper/p11_md.c	2010-01-30 09:28:35.000000000 -0800
@@ -64,7 +64,9 @@
 #include <assert.h>
 
 #include <dlfcn.h>
+#ifndef __APPLE__
 #include <link.h>
+#endif
 
 #include <jni.h>
 
--- ./jdk/src/solaris/native/sun/security/smartcardio/pcsc_md.c	2010-03-18 01:45:36.000000000 -0700
+++ ./jdk/src/solaris/native/sun/security/smartcardio/pcsc_md.c	2010-01-30 09:28:35.000000000 -0800
@@ -29,7 +29,9 @@
 #include <assert.h>
 
 #include <dlfcn.h>
+#ifndef __APPLE__
 #include <link.h>
+#endif
 
 #include <winscard.h>
 
--- ./jdk/src/solaris/native/sun/tools/attach/BsdVirtualMachine.c	2010-03-27 11:09:15.000000000 -0700
+++ ./jdk/src/solaris/native/sun/tools/attach/BsdVirtualMachine.c	2010-01-30 09:28:36.000000000 -0800
@@ -35,10 +35,10 @@
 #include <dirent.h>
 #include <ctype.h>
 #include <sys/types.h>
-#include <sys/types.h>
 #include <sys/socket.h>
 #include <sys/stat.h>
 #include <sys/un.h>
+#include <fcntl.h>
 
 #include "sun_tools_attach_BsdVirtualMachine.h"
 
@@ -49,85 +49,6 @@
 } while(0)
 
 /*
- * Defines a callback that is invoked for each process
- */
-typedef void (*ProcessCallback)(const pid_t pid, void* user_data);
-
-/*
- * Invokes the callback function for each process
- */
-static void forEachProcess(ProcessCallback f, void* user_data) {
-    DIR* dir;
-    struct dirent* ptr;
-
-    /*
-     * To locate the children we scan /proc looking for files that have a
-     * position integer as a filename.
-     */
-    if ((dir = opendir("/proc")) == NULL) {
-        return;
-    }
-    while ((ptr = readdir(dir)) != NULL) {
-        pid_t pid;
-
-        /* skip current/parent directories */
-        if (strcmp(ptr->d_name, ".") == 0 || strcmp(ptr->d_name, "..") == 0) {
-            continue;
-        }
-
-        /* skip files that aren't numbers */
-        pid = (pid_t)atoi(ptr->d_name);
-        if ((int)pid <= 0) {
-            continue;
-        }
-
-        /* invoke the callback */
-        (*f)(pid, user_data);
-    }
-    closedir(dir);
-}
-
-
-/*
- * Returns the parent pid of a given pid, or -1 if not found
- */
-static pid_t getParent(pid_t pid) {
-    char state;
-    FILE* fp;
-    char stat[2048];
-    int statlen;
-    char fn[32];
-    int i, p;
-    char* s;
-
-    /*
-     * try to open /proc/%d/stat
-     */
-    sprintf(fn, "/proc/%d/stat", pid);
-    fp = fopen(fn, "r");
-    if (fp == NULL) {
-        return -1;
-    }
-
-    /*
-     * The format is: pid (command) state ppid ...
-     * As the command could be anything we must find the right most
-     * ")" and then skip the white spaces that follow it.
-     */
-    statlen = fread(stat, 1, 2047, fp);
-    stat[statlen] = '\0';
-    fclose(fp);
-    s = strrchr(stat, ')');
-    if (s == NULL) {
-        return -1;
-    }
-    do s++; while (isspace(*s));
-    i = sscanf(s, "%c %d", &state, &p);
-    return (pid_t)p;
-}
-
-
-/*
  * Class:     sun_tools_attach_BsdVirtualMachine
  * Method:    socket
  * Signature: ()I
@@ -188,146 +109,6 @@
 
 /*
  * Class:     sun_tools_attach_BsdVirtualMachine
- * Method:    isBsdThreads
- * Signature: ()V
- */
-JNIEXPORT jboolean JNICALL Java_sun_tools_attach_BsdVirtualMachine_isBsdThreads
-  (JNIEnv *env, jclass cls)
-{
-# ifndef _CS_GNU_LIBPTHREAD_VERSION
-# define _CS_GNU_LIBPTHREAD_VERSION 3
-# endif
-    size_t n;
-    char* s;
-    jboolean res;
-
-    n = confstr(_CS_GNU_LIBPTHREAD_VERSION, NULL, 0);
-    if (n <= 0) {
-       /* glibc before 2.3.2 only has BsdThreads */
-       return JNI_TRUE;
-    }
-
-    s = (char *)malloc(n);
-    if (s == NULL) {
-        JNU_ThrowOutOfMemoryError(env, "malloc failed");
-        return JNI_TRUE;
-    }
-    confstr(_CS_GNU_LIBPTHREAD_VERSION, s, n);
-
-    /*
-     * If the LIBPTHREAD version include "NPTL" then we know we
-     * have the new threads library and not BsdThreads
-     */
-    res = (jboolean)(strstr(s, "NPTL") == NULL);
-    free(s);
-    return res;
-}
-
-/*
- * Structure and callback function used to count the children of
- * a given process, and record the pid of the "manager thread".
- */
-typedef struct {
-    pid_t ppid;
-    int count;
-    pid_t mpid;
-} ChildCountContext;
-
-static void ChildCountCallback(const pid_t pid, void* user_data) {
-    ChildCountContext* context = (ChildCountContext*)user_data;
-    if (getParent(pid) == context->ppid) {
-        context->count++;
-        /*
-         * Remember the pid of the first child. If the final count is
-         * one then this is the pid of the BsdThreads manager.
-         */
-        if (context->count == 1) {
-            context->mpid = pid;
-        }
-    }
-}
-
-/*
- * Class:     sun_tools_attach_BsdVirtualMachine
- * Method:    getBsdThreadsManager
- * Signature: (I)I
- */
-JNIEXPORT jint JNICALL Java_sun_tools_attach_BsdVirtualMachine_getBsdThreadsManager
-  (JNIEnv *env, jclass cls, jint pid)
-{
-    ChildCountContext context;
-
-    /*
-     * Iterate over all processes to find how many children 'pid' has
-     */
-    context.ppid = pid;
-    context.count = 0;
-    context.mpid = (pid_t)0;
-    forEachProcess(ChildCountCallback, (void*)&context);
-
-    /*
-     * If there's no children then this is likely the pid of the primordial
-     * created by the launcher - in that case the BsdThreads manager is the
-     * parent of this process.
-     */
-    if (context.count == 0) {
-        pid_t parent = getParent(pid);
-        if ((int)parent > 0) {
-            return (jint)parent;
-        }
-    }
-
-    /*
-     * There's one child so this is likely the embedded VM case where the
-     * the primordial thread == BsdThreads initial thread. The BsdThreads
-     * manager in that case is the child.
-     */
-    if (context.count == 1) {
-        return (jint)context.mpid;
-    }
-
-    /*
-     * If we get here it's most likely we were given the wrong pid
-     */
-    JNU_ThrowIOException(env, "Unable to get pid of BsdThreads manager thread");
-    return -1;
-}
-
-/*
- * Structure and callback function used to send a QUIT signal to all
- * children of a given process
- */
-typedef struct {
-    pid_t ppid;
-} SendQuitContext;
-
-static void SendQuitCallback(const pid_t pid, void* user_data) {
-    SendQuitContext* context = (SendQuitContext*)user_data;
-    pid_t parent = getParent(pid);
-    if (parent == context->ppid) {
-        kill(pid, SIGQUIT);
-    }
-}
-
-/*
- * Class:     sun_tools_attach_BsdVirtualMachine
- * Method:    sendQuitToChildrenOf
- * Signature: (I)V
- */
-JNIEXPORT void JNICALL Java_sun_tools_attach_BsdVirtualMachine_sendQuitToChildrenOf
-  (JNIEnv *env, jclass cls, jint pid)
-{
-    SendQuitContext context;
-    context.ppid = (pid_t)pid;
-
-    /*
-     * Iterate over all children of 'pid' and send a QUIT signal to each.
-     */
-    forEachProcess(SendQuitCallback, (void*)&context);
-}
-
-/*
- * Class:     sun_tools_attach_BsdVirtualMachine
  * Method:    sendQuitTo
  * Signature: (I)V
  */
@@ -350,7 +131,7 @@
     jboolean isCopy;
     const char* p = GetStringPlatformChars(env, path, &isCopy);
     if (p != NULL) {
-        struct stat64 sb;
+        struct stat sb;
         uid_t uid, gid;
         int res;
 
@@ -361,7 +142,7 @@
         uid = geteuid();
         gid = getegid();
 
-        res = stat64(p, &sb);
+        res = stat(p, &sb);
         if (res != 0) {
             /* save errno */
             res = errno;
@@ -459,3 +240,40 @@
 
     } while (remaining > 0);
 }
+
+/*
+ * Class:     sun_tools_attach_BSDVirtualMachine
+ * Method:    createAttachFile
+ * Signature: (Ljava.lang.String;)V
+ */
+JNIEXPORT void JNICALL Java_sun_tools_attach_BsdVirtualMachine_createAttachFile(JNIEnv *env, jclass cls, jstring path)
+{
+    const char* _path;
+    jboolean isCopy;
+    int fd, rc;
+
+    _path = GetStringPlatformChars(env, path, &isCopy);
+    if (_path == NULL) {
+        JNU_ThrowIOException(env, "Must specify a path");
+        return;
+    }
+
+    RESTARTABLE(open(_path, O_CREAT | O_EXCL, S_IWUSR | S_IRUSR), fd);
+    if (fd == -1) {
+        /* release p here before we throw an I/O exception */
+        if (isCopy) {
+            JNU_ReleaseStringPlatformChars(env, path, _path);
+        }
+        JNU_ThrowIOExceptionWithLastError(env, "open");
+        return;
+    }
+
+    RESTARTABLE(chown(_path, geteuid(), getegid()), rc);
+
+    RESTARTABLE(close(fd), rc);
+
+    /* release p here */
+    if (isCopy) {
+        JNU_ReleaseStringPlatformChars(env, path, _path);
+    }
+}
--- ./jdk/src/solaris/native/sun/xawt/XWindow.c	2010-03-18 01:45:36.000000000 -0700
+++ ./jdk/src/solaris/native/sun/xawt/XWindow.c	2010-01-30 09:28:36.000000000 -0800
@@ -228,10 +228,10 @@
     {java_awt_event_KeyEvent_VK_DOWN, XK_Down, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
 
     /* Keypad equivalents of Triangular Navigation Block */
-    {java_awt_event_KeyEvent_VK_KP_LEFT, XK_KP_Left, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
-    {java_awt_event_KeyEvent_VK_KP_UP, XK_KP_Up, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
-    {java_awt_event_KeyEvent_VK_KP_RIGHT, XK_KP_Right, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
-    {java_awt_event_KeyEvent_VK_KP_DOWN, XK_KP_Down, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
+    {java_awt_event_KeyEvent_VK_LEFT, XK_KP_Left, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
+    {java_awt_event_KeyEvent_VK_UP, XK_KP_Up, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
+    {java_awt_event_KeyEvent_VK_RIGHT, XK_KP_Right, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
+    {java_awt_event_KeyEvent_VK_DOWN, XK_KP_Down, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_NUMPAD},
 
     /* Other vendor-specific Triangular Navigation Block */
     {java_awt_event_KeyEvent_VK_LEFT, osfXK_Left, FALSE, java_awt_event_KeyEvent_KEY_LOCATION_STANDARD},
@@ -865,7 +865,7 @@
 {
     KeySym originalKeysym = *keysym;
 
-#ifndef __linux__
+#if !defined(__linux__) && !defined(_ALLBSD_SOURCE)
     /* The following code on Linux will cause the keypad keys
      * not to echo on JTextField when the NumLock is on. The
      * keysyms will be 0, because the last parameter 2 is not defined.
--- ./jdk/src/solaris/native/sun/xawt/awt_Desktop.c	2010-03-18 01:45:36.000000000 -0700
+++ ./jdk/src/solaris/native/sun/xawt/awt_Desktop.c	2010-01-30 09:28:36.000000000 -0800
@@ -24,6 +24,7 @@
  */
 
 #include <jni.h>
+#include <jvm_md.h>
 #include <dlfcn.h>
 
 typedef int gboolean;
@@ -36,12 +37,15 @@
     gboolean (*gnome_vfs_init) (void);
     const char *errmsg;
 
-    vfs_handle = dlopen("libgnomevfs-2.so.0", RTLD_LAZY);
+    vfs_handle = dlopen(VERSIONED_JNI_LIB_NAME("gnomevfs-2", "0"), RTLD_LAZY);
     if (vfs_handle == NULL) {
+        vfs_handle = dlopen(JNI_LIB_NAME("gnomevfs-2"), RTLD_LAZY);
+        if (vfs_handle == NULL) {
 #ifdef INTERNAL_BUILD
-        fprintf(stderr, "can not load libgnomevfs-2.so\n");
+            fprintf(stderr, "can not load libgnomevfs-2.so\n");
 #endif
-        return 0;
+            return 0;
+        }
     }
     dlerror(); /* Clear errors */
     gnome_vfs_init = dlsym(vfs_handle, "gnome_vfs_init");
@@ -54,12 +58,15 @@
     // call gonme_vfs_init()
     (*gnome_vfs_init)();
 
-    gnome_handle = dlopen("libgnome-2.so.0", RTLD_LAZY);
+    gnome_handle = dlopen(VERSIONED_JNI_LIB_NAME("gnome-2", "0"), RTLD_LAZY);
     if (gnome_handle == NULL) {
+        gnome_handle = dlopen(JNI_LIB_NAME("gnome-2"), RTLD_LAZY);
+        if (gnome_handle == NULL) {
 #ifdef INTERNAL_BUILD
-        fprintf(stderr, "can not load libgnome-2.so\n");
+            fprintf(stderr, "can not load libgnome-2.so\n");
 #endif
-        return 0;
+            return 0;
+        }
     }
     dlerror(); /* Clear errors */
     gnome_url_show = dlsym(gnome_handle, "gnome_url_show");
--- ./jdk/src/solaris/npt/npt_md.h	2010-03-18 01:45:36.000000000 -0700
+++ ./jdk/src/solaris/npt/npt_md.h	2010-01-30 09:28:36.000000000 -0800
@@ -32,9 +32,10 @@
 #include <string.h>
 #include <errno.h>
 #include <dlfcn.h>
+#ifndef __APPLE__
 #include <link.h>
-
-#define NPT_LIBNAME "libnpt.so"
+#endif
+#include <jvm_md.h>
 
 #define NPT_INITIALIZE(pnpt,version,options)                            \
     {                                                                   \
@@ -43,7 +44,7 @@
                                                                         \
         if ( (pnpt) == NULL ) NPT_ERROR("NptEnv* is NULL");             \
         *(pnpt) = NULL;                                                 \
-        _handle =  dlopen(NPT_LIBNAME, RTLD_LAZY);                      \
+        _handle =  dlopen(JNI_LIB_NAME("npt"), RTLD_LAZY);              \
         if ( _handle == NULL ) NPT_ERROR("Cannot open library");        \
         _sym = dlsym(_handle, "nptInitialize");                         \
         if ( _sym == NULL ) NPT_ERROR("Cannot find nptInitialize");     \
--- ./jdk/src/solaris/transport/socket/socket_md.c	2010-03-18 01:45:36.000000000 -0700
+++ ./jdk/src/solaris/transport/socket/socket_md.c	2010-01-30 09:28:36.000000000 -0800
@@ -36,7 +36,7 @@
 #ifdef __solaris__
 #include <thread.h>
 #endif
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 #include <pthread.h>
 #include <sys/poll.h>
 #endif
@@ -283,7 +283,7 @@
 
 #endif
 
-#ifdef __linux__
+#if defined(__linux__) || defined(_ALLBSD_SOURCE)
 int
 dbgsysTlsAlloc() {
     pthread_key_t key;
--- ./jdk/test/Makefile	2010-03-18 01:45:38.000000000 -0700
+++ ./jdk/test/Makefile	2010-03-20 11:12:38.000000000 -0700
@@ -72,6 +72,16 @@
   OS_ARCH    := $(shell $(UNAME) -m)
   OS_VERSION := $(shell $(UNAME) -r)
 endif
+ifeq ($(UNAME_S), Darwin)
+  OS_NAME     = bsd
+  OS_ARCH    := $(shell $(UNAME) -m)
+  OS_VERSION := $(shell $(UNAME) -r)
+endif 
+ifeq ($(findstring BSD,$(UNAME_S)), BSD)
+  OS_NAME     = bsd
+  OS_ARCH    := $(shell $(UNAME) -m)
+  OS_VERSION := $(shell $(UNAME) -r)
+endif 
 ifndef OS_NAME
   ifneq ($(PROCESSOR_IDENTIFIER), )
     OS_NAME = windows
--- ./jdk/test/com/sun/jdi/ImmutableResourceTest.sh	2010-03-18 01:45:38.000000000 -0700
+++ ./jdk/test/com/sun/jdi/ImmutableResourceTest.sh	2010-01-30 09:28:42.000000000 -0800
@@ -56,7 +56,7 @@
 
 OS=`uname -s`
 case "$OS" in
-   SunOS | Linux )
+   SunOS | Linux | *BSD | Darwin )
       PATHSEP=":"
       ;;
 
--- ./jdk/test/com/sun/jdi/JITDebug.sh	2010-03-18 01:45:38.000000000 -0700
+++ ./jdk/test/com/sun/jdi/JITDebug.sh	2010-01-30 09:28:42.000000000 -0800
@@ -63,7 +63,7 @@
 OS=`uname -s`
 export TRANSPORT_METHOD
 case "$OS" in
-   SunOS | Linux )
+   SunOS | Linux | *BSD | Darwin )
       PATHSEP=":"
       TRANSPORT_METHOD=dt_socket
       ;;
--- ./jdk/test/com/sun/jdi/PrivateTransportTest.sh	2010-03-18 01:45:38.000000000 -0700
+++ ./jdk/test/com/sun/jdi/PrivateTransportTest.sh	2010-01-30 09:28:42.000000000 -0800
@@ -121,10 +121,14 @@
     esac
     libloc=${jreloc}/lib/${libarch}
     ;;
-  Linux)
+  Linux | *BSD)
     xx=`find ${jreloc}/lib -name libdt_socket.so`
     libloc=`dirname ${xx}`
     ;;
+  Darwin)
+    xx=`find ${jreloc}/lib -name libdt_socket.dylib`
+    libloc=`dirname ${xx}`
+    ;;
   Windows*)
     libloc=${jreloc}/bin
     sep=';'
--- ./jdk/test/com/sun/jdi/ShellScaffold.sh	2010-03-18 01:45:39.000000000 -0700
+++ ./jdk/test/com/sun/jdi/ShellScaffold.sh	2010-01-30 09:28:42.000000000 -0800
@@ -289,7 +289,7 @@
          psCmd=ps
          jstack=jstack.exe
          ;;
-       SunOS | Linux)
+       SunOS | Linux | *BSD | Darwin)
          transport=dt_socket
          address=
          devnull=/dev/null
--- ./jdk/test/com/sun/jdi/Solaris32AndSolaris64Test.sh	2010-03-18 01:45:39.000000000 -0700
+++ ./jdk/test/com/sun/jdi/Solaris32AndSolaris64Test.sh	2010-01-30 09:28:42.000000000 -0800
@@ -112,7 +112,7 @@
       fi
       ;;
 
-   Linux )
+   Linux | *BSD | Darwin )
       pass "This test always passes on $OS"
       ;;
 
--- ./jdk/test/com/sun/jdi/connect/spi/JdiLoadedByCustomLoader.sh	2010-03-18 01:45:39.000000000 -0700
+++ ./jdk/test/com/sun/jdi/connect/spi/JdiLoadedByCustomLoader.sh	2010-01-30 09:40:01.000000000 -0800
@@ -45,10 +45,7 @@
 
 OS=`uname -s`
 case "$OS" in
-  SunOS )
-    PS=":"
-    ;;
-  Linux )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     ;;
   Windows* | CYGWIN*)
--- ./jdk/test/com/sun/management/OperatingSystemMXBean/TestTotalSwap.sh	2010-03-18 01:45:39.000000000 -0700
+++ ./jdk/test/com/sun/management/OperatingSystemMXBean/TestTotalSwap.sh	2010-01-30 09:28:43.000000000 -0800
@@ -83,6 +83,10 @@
        total_swap=`free -b | grep -i swap | awk '{print $2}'`
        runOne GetTotalSwapSpaceSize $total_swap 
        ;;
+     *BSD )
+       # FIXME: Determine swap space.
+       runOne GetTotalSwapSpaceSize "sanity-only"
+       ;;
     * )
        runOne GetTotalSwapSpaceSize "sanity-only"
        ;;
--- ./jdk/test/com/sun/management/UnixOperatingSystemMXBean/GetMaxFileDescriptorCount.sh	2010-03-18 01:45:39.000000000 -0700
+++ ./jdk/test/com/sun/management/UnixOperatingSystemMXBean/GetMaxFileDescriptorCount.sh	2010-01-30 09:28:43.000000000 -0800
@@ -48,7 +48,7 @@
 
 # Test GetMaxFileDescriptorCount if we are running on Unix
 case `uname -s` in
-    SunOS | Linux )
+    SunOS | Linux | *BSD | Darwin )
        runOne GetMaxFileDescriptorCount
        ;;
     * )
--- ./jdk/test/com/sun/management/UnixOperatingSystemMXBean/GetOpenFileDescriptorCount.sh	2010-03-18 01:45:39.000000000 -0700
+++ ./jdk/test/com/sun/management/UnixOperatingSystemMXBean/GetOpenFileDescriptorCount.sh	2010-01-30 09:28:43.000000000 -0800
@@ -48,7 +48,7 @@
 
 # Test GetOpenFileDescriptorCount if we are running on Unix
 case `uname -s` in
-    SunOS | Linux )
+    SunOS | Linux | *BSD | Darwin )
        runOne GetOpenFileDescriptorCount
        ;;
     * )
--- ./jdk/test/com/sun/tools/attach/CommonSetup.sh	2010-03-18 01:45:39.000000000 -0700
+++ ./jdk/test/com/sun/tools/attach/CommonSetup.sh	2010-01-30 09:40:01.000000000 -0800
@@ -36,11 +36,7 @@
 
 OS=`uname -s`
 case "$OS" in
-  SunOS )
-    PS=":"
-    FS="/"
-    ;;
-  Linux )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     FS="/"
     ;;
--- ./jdk/test/java/awt/PrintJob/Text/stringwidth.sh	2010-03-18 01:45:40.000000000 -0700
+++ ./jdk/test/java/awt/PrintJob/Text/stringwidth.sh	2010-01-30 09:28:46.000000000 -0800
@@ -25,10 +25,11 @@
 fi
 
 
-if [ $OS = SunOS -o $OS = Linux ]
-then
-    exit 0
-fi
+case "${OS}" in
+    SunOS | Linux | *BSD | Darwin )
+        exit 0
+	;;
+esac
 # Windows
 
 if [ -z "${TESTJAVA}" ] ; then
--- ./jdk/test/java/io/File/GetXSpace.sh	2010-03-18 01:45:41.000000000 -0700
+++ ./jdk/test/java/io/File/GetXSpace.sh	2010-01-30 09:28:48.000000000 -0800
@@ -26,7 +26,7 @@
 # set platform-dependent variable
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux ) TMP=/tmp  ;;
+  SunOS | Linux | *BSD | Darwin ) TMP=/tmp  ;;
   Windows_98 )    return    ;;
   Windows* )      SID=`sid`; TMP="c:/temp"  ;;
   * )
--- ./jdk/test/java/io/Serializable/evolution/RenamePackage/run.sh	2010-03-18 01:45:42.000000000 -0700
+++ ./jdk/test/java/io/Serializable/evolution/RenamePackage/run.sh	2010-01-30 09:40:01.000000000 -0800
@@ -41,7 +41,7 @@
 # Need to determine the classpath separator and filepath separator based on the
 # operating system.
 case "$OS" in
-SunOS | Linux )
+SunOS | Linux | *BSD | Darwin )
   PS=":"  ;;
 Windows* | CYGWIN* )
   PS=";"  ;;
--- ./jdk/test/java/io/Serializable/serialver/classpath/run.sh	2010-03-18 01:45:42.000000000 -0700
+++ ./jdk/test/java/io/Serializable/serialver/classpath/run.sh	2010-01-30 09:40:01.000000000 -0800
@@ -47,7 +47,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"    ;;
   Windows* | CYGWIN* )
     PS=";"    ;;
--- ./jdk/test/java/io/Serializable/serialver/nested/run.sh	2010-03-18 01:45:42.000000000 -0700
+++ ./jdk/test/java/io/Serializable/serialver/nested/run.sh	2010-01-30 09:40:01.000000000 -0800
@@ -47,7 +47,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"    ;;
   Windows* | CYGWIN* )
     PS=";"    ;;
--- ./jdk/test/java/lang/ClassLoader/deadlock/TestOneWayDelegate.sh	2010-03-18 01:45:43.000000000 -0700
+++ ./jdk/test/java/lang/ClassLoader/deadlock/TestOneWayDelegate.sh	2010-01-30 13:44:36.000000000 -0800
@@ -49,10 +49,7 @@
 # set platform-specific variables
 OS=`uname -s`
 case "$OS" in
-  SunOS )
-    FS="/"
-    ;;
-  Linux )
+  SunOS | Linux | *BSD | Darwin )
     FS="/"
     ;;
   Windows* | CYGWIN* )
--- ./jdk/test/java/lang/StringCoding/CheckEncodings.sh	2010-03-18 01:45:43.000000000 -0700
+++ ./jdk/test/java/lang/StringCoding/CheckEncodings.sh	2010-01-30 12:39:25.000000000 -0800
@@ -30,7 +30,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux ) ;;
+  SunOS | Linux | *BSD | Darwin ) ;;
   Windows* | CYGWIN* )
     echo "Passed"; exit 0 ;;
   * ) echo "Unrecognized system!" ;  exit 1 ;;
--- ./jdk/test/java/lang/annotation/loaderLeak/LoaderLeak.sh	2010-03-18 01:45:43.000000000 -0700
+++ ./jdk/test/java/lang/annotation/loaderLeak/LoaderLeak.sh	2010-01-30 09:40:02.000000000 -0800
@@ -44,7 +44,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux )
+  SunOS | Linux | *BSD | Darwin )
     NULL=/dev/null
     PS=":"
     FS="/"
--- ./jdk/test/java/lang/instrument/MakeJAR2.sh	2010-03-18 01:45:43.000000000 -0700
+++ ./jdk/test/java/lang/instrument/MakeJAR2.sh	2010-01-30 09:28:51.000000000 -0800
@@ -49,7 +49,7 @@
 
 OS=`uname -s`
 case "$OS" in
-   SunOS | Linux )
+   SunOS | Linux | *BSD | Darwin )
       PATHSEP=":"
       ;;
 
--- ./jdk/test/java/lang/instrument/appendToClassLoaderSearch/CommonSetup.sh	2010-03-18 01:45:43.000000000 -0700
+++ ./jdk/test/java/lang/instrument/appendToClassLoaderSearch/CommonSetup.sh	2010-01-30 09:40:02.000000000 -0800
@@ -35,11 +35,7 @@
 
 OS=`uname -s`
 case "$OS" in
-  SunOS )
-    PS=":"
-    FS="/"
-    ;;
-  Linux )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     FS="/"
     ;;
--- ./jdk/test/java/lang/management/OperatingSystemMXBean/TestSystemLoadAvg.sh	2010-03-18 01:45:43.000000000 -0700
+++ ./jdk/test/java/lang/management/OperatingSystemMXBean/TestSystemLoadAvg.sh	2010-01-30 09:28:52.000000000 -0800
@@ -61,10 +61,7 @@
 while true; do
   echo "Run $i: TestSystemLoadAvg"
   case `uname -s` in
-       SunOS )
-         runOne GetSystemLoadAverage 
-         ;;
-       Linux )
+       SunOS | Linux | *BSD | Darwin )
          runOne GetSystemLoadAverage
          ;;
       * )
--- ./jdk/test/java/net/Authenticator/B4933582.sh	2010-03-18 01:45:44.000000000 -0700
+++ ./jdk/test/java/net/Authenticator/B4933582.sh	2010-01-30 09:28:53.000000000 -0800
@@ -26,7 +26,7 @@
 
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     FS="/"
     ;;
--- ./jdk/test/java/net/DatagramSocket/SetDatagramSocketImplFactory/ADatagramSocket.sh	2010-03-18 01:45:44.000000000 -0700
+++ ./jdk/test/java/net/DatagramSocket/SetDatagramSocketImplFactory/ADatagramSocket.sh	2010-01-30 09:28:53.000000000 -0800
@@ -27,11 +27,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS )
-    PATHSEP=":"
-    FILESEP="/"
-    ;;
-  Linux )
+  SunOS | Linux | *BSD | Darwin )
     PATHSEP=":"
     FILESEP="/"
     ;;
--- ./jdk/test/java/net/Socket/OldSocketImpl.sh	2010-03-18 01:45:44.000000000 -0700
+++ ./jdk/test/java/net/Socket/OldSocketImpl.sh	2010-01-30 09:28:53.000000000 -0800
@@ -28,7 +28,7 @@
 
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     FS="/"
     ;;
--- ./jdk/test/java/net/URL/B5086147.sh	2010-03-18 01:45:44.000000000 -0700
+++ ./jdk/test/java/net/URL/B5086147.sh	2010-01-30 09:28:53.000000000 -0800
@@ -26,7 +26,7 @@
 
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux )
+  SunOS | Linux | *BSD | Darwin )
     exit 0
     ;;
   CYGWIN* )
--- ./jdk/test/java/net/URL/runconstructor.sh	2010-03-18 01:45:44.000000000 -0700
+++ ./jdk/test/java/net/URL/runconstructor.sh	2010-01-30 09:28:53.000000000 -0800
@@ -27,7 +27,7 @@
 #
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     FS="/"
     ;;
--- ./jdk/test/java/net/URLClassLoader/B5077773.sh	2010-03-18 01:45:44.000000000 -0700
+++ ./jdk/test/java/net/URLClassLoader/B5077773.sh	2010-01-30 09:28:53.000000000 -0800
@@ -34,11 +34,7 @@
 
 OS=`uname -s`
 case "$OS" in
-  SunOS )
-    PS=":"
-    FS="/"
-    ;;
-  Linux )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     FS="/"
     ;;
--- ./jdk/test/java/net/URLClassLoader/sealing/checksealed.sh	2010-03-18 01:45:44.000000000 -0700
+++ ./jdk/test/java/net/URLClassLoader/sealing/checksealed.sh	2010-01-30 09:28:54.000000000 -0800
@@ -27,11 +27,7 @@
 
 OS=`uname -s`
 case "$OS" in
-  SunOS )
-    PS=":"
-    FS="/"            
-    ;;
-  Linux )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     FS="/"            
     ;;
--- ./jdk/test/java/net/URLConnection/6212146/test.sh	2010-03-18 01:45:44.000000000 -0700
+++ ./jdk/test/java/net/URLConnection/6212146/test.sh	2010-01-30 09:28:54.000000000 -0800
@@ -33,11 +33,7 @@
 
 OS=`uname -s`
 case "$OS" in
-  SunOS )
-    PS=":"
-    FS="/"
-    ;;
-  Linux )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     FS="/"
     ;;
--- ./jdk/test/java/nio/channels/spi/SelectorProvider/inheritedChannel/Makefile	2010-03-18 01:45:45.000000000 -0700
+++ ./jdk/test/java/nio/channels/spi/SelectorProvider/inheritedChannel/Makefile	2010-01-30 09:28:55.000000000 -0800
@@ -71,6 +71,48 @@
   EXTRA_LIBS = -lc
 endif
 
+ifeq ($(uname), Darwin)
+  PLATFORM = bsd
+  archExpr = case "`$(UNAME) -m`" in  \
+		i[3-6]86) \
+                    $(ECHO) i586 \
+                    ;; \
+		sparc*)	 \
+                    $(ECHO) sparc \
+                    ;; \
+		*) \
+                    $(UNAME) -m	 \
+                    ;; \
+	   esac
+  ARCH	    := $(shell $(archExpr) )
+  CC = gcc
+  CFLAGS = -fno-strict-aliasing -fPIC -W -Wall
+  LD = ld
+  LDFLAGS_COMMON = -shared
+  EXTRA_LIBS = -lc
+endif
+
+ifeq ($(findstring BSD,$(uname)), BSD)
+  PLATFORM = bsd
+  archExpr = case "`$(UNAME) -m`" in  \
+		i[3-6]86) \
+                    $(ECHO) i586 \
+                    ;; \
+		sparc*)	 \
+                    $(ECHO) sparc \
+                    ;; \
+		*) \
+                    $(UNAME) -m	 \
+                    ;; \
+	   esac
+  ARCH	    := $(shell $(archExpr) )
+  CC = gcc
+  CFLAGS = -fno-strict-aliasing -fPIC -W -Wall
+  LD = ld
+  LDFLAGS_COMMON = -shared
+  EXTRA_LIBS = -lc
+endif
+
 LIBDIR=lib/$(PLATFORM)-$(ARCH)
 LAUNCHERLIB=$(LIBDIR)/libLauncher.so
 
Files /tmp/openjdk_srcdir.WNIZhUSX/openjdk/jdk/test/java/nio/channels/spi/SelectorProvider/inheritedChannel/lib/bsd-i586/libLauncher.so and /home/glewis/projects/java/jdk17/openjdk7/merge/bsd-port/jdk/test/java/nio/channels/spi/SelectorProvider/inheritedChannel/lib/bsd-i586/libLauncher.so differ
--- ./jdk/test/java/nio/channels/spi/SelectorProvider/inheritedChannel/run_tests.sh	2010-03-18 01:45:45.000000000 -0700
+++ ./jdk/test/java/nio/channels/spi/SelectorProvider/inheritedChannel/run_tests.sh	2010-01-30 09:28:55.000000000 -0800
@@ -33,11 +33,14 @@
 # @run shell run_tests.sh
 
 os=`uname -s`
-
-if [ "$os" != "Linux" -a "$os" != "SunOS" ]; then
-    echo "Test not designed to run on this operating system, skipping..."
-    exit 0
-fi
+case "${os}" in
+    SunOS | Linux | *BSD | Darwin )
+        ;;
+    * )
+        echo "Test not designed to run on this operating system, skipping..."
+        exit 0
+        ;;
+esac
 
 
 # if TESTJAVA isn't set then we assume an interactive run. So that it's
@@ -67,7 +70,8 @@
 # On Solaris we assume 64-bit if java -d64 works.
 
 DFLAG=
-if [ "$os" = "SunOS" ]; then
+case "${os}" in
+  SunOS )
     PLATFORM=solaris
     case "`uname -p`" in
 	i[3-9]86) 
@@ -84,9 +88,9 @@
 	    fi
 	    ;;
     esac 
-fi
+    ;;
 
-if [ "$os" = "Linux" ]; then
+  Linux )
     PLATFORM=linux
     ARCH=unknown
     case "`uname -m`" in
@@ -100,7 +104,24 @@
 	    ARCH=amd64
 	    ;;
     esac
-fi
+    ;;
+
+  *BSD | Darwin )
+    PLATFORM=bsd
+    ARCH=unknown
+    case "`uname -m`" in
+	i[3-6]86)
+	    ARCH=i586
+	    ;;
+	ia64)
+	    ARCH=ia64
+	    ;;
+	x86_64)
+	    ARCH=amd64
+	    ;;
+    esac
+    ;;
+esac
 
 LIBDIR=lib/${PLATFORM}-${ARCH}
 LAUNCHERLIB=${LIBDIR}/libLauncher.so
--- ./jdk/test/java/nio/charset/Charset/default.sh	2010-03-18 01:45:45.000000000 -0700
+++ ./jdk/test/java/nio/charset/Charset/default.sh	2010-02-21 17:36:42.000000000 -0800
@@ -41,10 +41,14 @@
 fi
 
 s="`uname -s`"
-if [ "$s" != Linux -a "$s" != SunOS ]; then
-  echo "$s: locale command not supported on this system, skipping..."
-  exit 0
-fi
+case "$s" in
+  Linux|SunOS|*BSD|Darwin)
+    ;;
+  *)
+    echo "$s: locale command not supported on this system, skipping..."
+    exit 0
+    ;;
+esac
 
 JAVA=$TESTJAVA/bin/java
 
--- ./jdk/test/java/nio/charset/coders/CheckSJISMappingProp.sh	2010-03-18 01:45:45.000000000 -0700
+++ ./jdk/test/java/nio/charset/coders/CheckSJISMappingProp.sh	2010-02-21 17:37:41.000000000 -0800
@@ -34,7 +34,7 @@
 
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux ) ;;
+  SunOS | Linux | *BSD | Darwin) ;;
   # Skip locale test for Windows
   Windows* )
     echo "Passed"; exit 0 ;;
--- ./jdk/test/java/nio/charset/spi/basic.sh	2010-03-18 01:45:45.000000000 -0700
+++ ./jdk/test/java/nio/charset/spi/basic.sh	2010-02-21 17:39:12.000000000 -0800
@@ -70,10 +70,14 @@
     L="$1"
     shift
     s=`uname -s`
-    if [ $s != Linux -a $s != SunOS ]; then
-      echo "$L: Locales not supported on this system, skipping..."
-      exit 0
-    fi
+    case "$s" in
+      Linux|SunOS|*BSD|Darwin)
+        ;;
+      *)
+        echo "$L: Locales not supported on this system, skipping..."
+        exit 0
+	;;
+    esac
     if [ "x`locale -a | grep $L`" != "x$L" ]; then
       echo "$L: Locale not supported, skipping..."
       exit 0
@@ -85,7 +89,7 @@
 cd $TMP
 
 case `uname` in
-  SunOS | Linux ) CPS=':' ;;
+  SunOS | Linux | *BSD | Darwin) CPS=':' ;;
   Windows* )      CPS=';' ;;
   *)              echo "Unknown platform: `uname`"; exit 1 ;;
 esac
--- ./jdk/test/java/nio/file/Path/CopyAndMove.java	2010-03-18 01:45:45.000000000 -0700
+++ ./jdk/test/java/nio/file/Path/CopyAndMove.java	2010-01-30 13:47:40.000000000 -0800
@@ -147,7 +147,8 @@
 
         // get file attributes of source file
         String os = System.getProperty("os.name");
-        if (os.equals("SunOS") || os.equals("Linux")) {
+        if (os.equals("SunOS") || os.equals("Linux") ||
+            os.endsWith("BSD") || os.equals("Darwin")) {
             posixAttributes = Attributes.readPosixFileAttributes(source, NOFOLLOW_LINKS);
             basicAttributes = posixAttributes;
         }
--- ./jdk/test/java/rmi/reliability/launch_reliability.ksh	2010-03-18 01:45:46.000000000 -0700
+++ ./jdk/test/java/rmi/reliability/launch_reliability.ksh	2010-01-30 09:28:57.000000000 -0800
@@ -84,14 +84,12 @@
 
 
 # set platform-dependent variables
-if [ `uname` = "SunOS" ] ; then
+case `uname` in
+    SunOS | Linux | *BSD | Darwin )
         PATH_SEP=":"
-
-elif [ `uname` = "Linux" ] ; then
-        PATH_SEP=":"
-else
+    * )
         PATH_SEP=";"
-fi
+esac
 
 export PATH_SEP
 mainpid=$$
--- ./jdk/test/java/security/Security/ClassLoaderDeadlock/ClassLoaderDeadlock.sh	2010-03-18 01:45:46.000000000 -0700
+++ ./jdk/test/java/security/Security/ClassLoaderDeadlock/ClassLoaderDeadlock.sh	2010-01-30 09:28:58.000000000 -0800
@@ -46,11 +46,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS )
-    PATHSEP=":"
-    FILESEP="/"
-    ;;
-  Linux )
+  SunOS | Linux | *BSD | Darwin )
     PATHSEP=":"
     FILESEP="/"
     ;;
--- ./jdk/test/java/security/Security/ClassLoaderDeadlock/Deadlock.sh	2010-03-18 01:45:47.000000000 -0700
+++ ./jdk/test/java/security/Security/ClassLoaderDeadlock/Deadlock.sh	2010-01-30 09:28:58.000000000 -0800
@@ -34,11 +34,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS )
-    PATHSEP=":"
-    FILESEP="/"
-    ;;
-  Linux )
+  SunOS | Linux | *BSD | Darwin )
     PATHSEP=":"
     FILESEP="/"
     ;;
--- ./jdk/test/java/security/Security/signedfirst/Dyn.sh	2010-03-18 01:45:47.000000000 -0700
+++ ./jdk/test/java/security/Security/signedfirst/Dyn.sh	2010-01-30 09:28:58.000000000 -0800
@@ -46,11 +46,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS )
-    PATHSEP=":"
-    FILESEP="/"
-    ;;
-  Linux )
+  SunOS | Linux | *BSD | Darwin )
     PATHSEP=":"
     FILESEP="/"
     ;;
--- ./jdk/test/java/security/Security/signedfirst/Static.sh	2010-03-18 01:45:47.000000000 -0700
+++ ./jdk/test/java/security/Security/signedfirst/Static.sh	2010-01-30 09:28:58.000000000 -0800
@@ -46,11 +46,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS )
-    PATHSEP=":"
-    FILESEP="/"
-    ;;
-  Linux )
+  SunOS | Linux | *BSD | Darwin )
     PATHSEP=":"
     FILESEP="/"
     ;;
--- ./jdk/test/java/util/Currency/PropertiesTest.sh	2010-03-18 01:45:47.000000000 -0700
+++ ./jdk/test/java/util/Currency/PropertiesTest.sh	2010-01-30 09:40:02.000000000 -0800
@@ -30,7 +30,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     FS="/"
     ;;
--- ./jdk/test/java/util/PluggableLocale/ExecTest.sh	2010-03-18 01:45:47.000000000 -0700
+++ ./jdk/test/java/util/PluggableLocale/ExecTest.sh	2010-01-30 09:40:02.000000000 -0800
@@ -58,7 +58,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     FS="/"
     ;;
--- ./jdk/test/java/util/ResourceBundle/Bug6299235Test.sh	2010-03-18 01:45:48.000000000 -0700
+++ ./jdk/test/java/util/ResourceBundle/Bug6299235Test.sh	2010-01-30 09:40:02.000000000 -0800
@@ -31,7 +31,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux )
+  SunOS | Linux | *BSD | Darwin )
     PATHSEP=":"
     FILESEP="/"
     ;;
--- ./jdk/test/java/util/ResourceBundle/Control/ExpirationTest.sh	2010-03-18 01:45:48.000000000 -0700
+++ ./jdk/test/java/util/ResourceBundle/Control/ExpirationTest.sh	2010-01-30 09:40:02.000000000 -0800
@@ -75,7 +75,7 @@
 SunOS)
     DEL=":"
     ;;
-Linux)
+Linux|*BSD|Darwin)
     DEL=":"
     HAS_S=YES
     ;;
--- ./jdk/test/java/util/ServiceLoader/basic.sh	2010-03-18 01:45:48.000000000 -0700
+++ ./jdk/test/java/util/ServiceLoader/basic.sh	2010-01-30 09:40:02.000000000 -0800
@@ -42,9 +42,7 @@
 
 OS=`uname -s`
 case "$OS" in
-    SunOS )
-      SEP=':' ;;
-    Linux )
+    SunOS | Linux | *BSD | Darwin )
       SEP=':' ;;
     * )
       SEP='\;' ;;
--- ./jdk/test/javax/crypto/SecretKeyFactory/FailOverTest.sh	2010-03-18 01:45:48.000000000 -0700
+++ ./jdk/test/javax/crypto/SecretKeyFactory/FailOverTest.sh	2010-01-30 09:29:03.000000000 -0800
@@ -51,7 +51,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux )
+  SunOS | Linux | *BSD | Darwin )
     NULL=/dev/null
     PS=":"
     FS="/"
--- ./jdk/test/javax/script/CommonSetup.sh	2010-03-18 01:45:49.000000000 -0700
+++ ./jdk/test/javax/script/CommonSetup.sh	2010-01-30 09:40:02.000000000 -0800
@@ -36,11 +36,7 @@
 
 OS=`uname -s`
 case "$OS" in
-  SunOS )
-    PS=":"
-    FS="/"
-    ;;
-  Linux )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     FS="/"
     ;;
--- ./jdk/test/javax/security/auth/Subject/doAs/Test.sh	2010-03-18 01:45:49.000000000 -0700
+++ ./jdk/test/javax/security/auth/Subject/doAs/Test.sh	2010-01-30 09:29:05.000000000 -0800
@@ -33,12 +33,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS )
-    PS=":"
-    FS="/"
-    RM="/bin/rm -f"
-    ;;
-  Linux )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     FS="/"
     RM="/bin/rm -f"
--- ./jdk/test/jprt.config	2010-03-18 01:45:51.000000000 -0700
+++ ./jdk/test/jprt.config	2010-01-30 09:29:08.000000000 -0800
@@ -71,8 +71,8 @@
 
 # Uses 'uname -s', but only expect SunOS or Linux, assume Windows otherwise.
 osname=`uname -s`
-if [ "${osname}" = SunOS ] ; then
-   
+case "${osname}" in
+  SunOS )
     # SOLARIS: Sparc or X86
     osarch=`uname -p`
     if [ "${osarch}" = sparc ] ; then
@@ -96,9 +96,9 @@
 
     # File creation mask
     umask 002
+    ;;
 
-elif [ "${osname}" = Linux ] ; then
-   
+  Linux | Darwin )
     # Add basic paths
     path4sdk=/usr/bin:/bin:/usr/sbin:/sbin
 
@@ -107,8 +107,31 @@
     fileMustExist "${make}" make
 
     umask 002
+    ;;
+
+  FreeBSD | OpenBSD )
+    # Add basic paths
+    path4sdk=/usr/bin:/bin:/usr/sbin:/sbin
 
-else
+    # Find GNU make
+    make=/usr/local/bin/gmake
+    fileMustExist "${make}" make
+
+    umask 002
+    ;;
+
+  NetBSD )
+    # Add basic paths
+    path4sdk=/usr/bin:/bin:/usr/sbin:/sbin
+
+    # Find GNU make
+    make=/usr/pkg/bin/gmake
+    fileMustExist "${make}" make
+
+    umask 002
+    ;;
+
+  * )
 
     # Windows: Differs on CYGWIN vs. MKS.
    
@@ -150,8 +173,8 @@
     if [ "${unix_toolset}" = CYGWIN ] ; then
 	path4sdk="`/usr/bin/cygpath -p ${path4sdk}`"
     fi
-
-fi
+    ;;
+esac
 
 # Export PATH setting
 PATH="${path4sdk}"
--- ./jdk/test/lib/security/java.policy/Ext_AllPolicy.sh	2010-03-18 01:45:51.000000000 -0700
+++ ./jdk/test/lib/security/java.policy/Ext_AllPolicy.sh	2010-01-30 09:29:08.000000000 -0800
@@ -50,7 +50,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux )
+  SunOS | Linux | *BSD | Darwin )
     NULL=/dev/null
     PS=":"
     FS="/"
--- ./jdk/test/sun/management/jmxremote/bootstrap/CustomLauncherTest.sh	2010-03-18 01:45:51.000000000 -0700
+++ ./jdk/test/sun/management/jmxremote/bootstrap/CustomLauncherTest.sh	2010-01-30 09:29:08.000000000 -0800
@@ -45,37 +45,50 @@
 # has to locate libjvm.so. Also $! is not reliable on some releases of MKS.
 #{
 OS=`uname -s`
-if [ "$OS" != "Linux" -a "$OS" != "SunOS" ]; then
-    echo "Test not designed to run on this operating system, skipping..."
-    exit 0
-fi
+case "${OS}" in
+    Windows* | CYGWIN* )
+        echo "Test not designed to run on this operating system, skipping..."
+        exit 0
+        ;;
+esac
 
 #
 # Locate the custom launcher for this platform
 #
 PLATFORM=unknown
 ARCH=unknown
-if [ "$OS" = "SunOS" ]; then
-    PLATFORM=solaris
-    case "`uname -p`" in
-	i[3-9]86)
-	    ARCH=i586
-	    ;;
-	sparc)
-	    ARCH=sparc
-	    ;;
-    esac
-else
-    PLATFORM=linux
-    case "`uname -m`" in
-	i[3-6]86)
-	    ARCH=i586
-	    ;;
-	x86_64)
-	    ARCH=amd64
-	    ;;
-    esac
-fi
+case "${OS}" in
+    SunOS )
+        PLATFORM=solaris
+        case "`uname -p`" in
+            i[3-9]86)
+                ARCH=i586
+                ;;
+            sparc)
+                ARCH=sparc
+                ;;
+        esac
+        ;;
+    Linux )
+        PLATFORM=linux
+        case "`uname -m`" in
+            i[3-6]86)
+                ARCH=i586
+                ;;
+            x86_64)
+                ARCH=amd64
+                ;;
+        esac
+	;;
+    *BSD | Darwin )
+        PLATFORM=bsd
+        case "`uname -m`" in
+            i[3-6]86)
+                ARCH=i586
+                ;;
+        esac
+	;;
+esac
 
 
 #
--- ./jdk/test/sun/management/jmxremote/bootstrap/GeneratePropertyPassword.sh	2010-03-18 01:45:51.000000000 -0700
+++ ./jdk/test/sun/management/jmxremote/bootstrap/GeneratePropertyPassword.sh	2010-01-30 09:40:02.000000000 -0800
@@ -35,7 +35,7 @@
 UMASK=`umask`
 
 case $OS in
-SunOS | Linux)
+SunOS | Linux | *BSD | Darwin)
     PATHSEP=":"
     FILESEP="/"
     DFILESEP=$FILESEP
--- ./jdk/test/sun/management/jmxremote/bootstrap/LocalManagementTest.sh	2010-03-18 01:45:51.000000000 -0700
+++ ./jdk/test/sun/management/jmxremote/bootstrap/LocalManagementTest.sh	2010-01-30 09:29:08.000000000 -0800
@@ -86,10 +86,12 @@
 #    on Windows 98.
 
 os=`uname -s`
-if [ "$os" != "Linux" -a "$os" != "SunOS" ]; then
-    echo "Test not designed to run on this operating system, skipping..."
-    exit 0
-fi
+case "${os}" in
+    Windows* | CYGWIN* )
+        echo "Test not designed to run on this operating system, skipping..."
+        exit 0
+        ;;
+esac
 
 JAVA=${TESTJAVA}/bin/java
 CLASSPATH=${TESTCLASSES}
--- ./jdk/test/sun/management/jmxremote/bootstrap/PasswordFilePermissionTest.sh	2010-03-18 01:45:51.000000000 -0700
+++ ./jdk/test/sun/management/jmxremote/bootstrap/PasswordFilePermissionTest.sh	2010-01-30 09:29:08.000000000 -0800
@@ -70,10 +70,12 @@
 # security the password file.
 
 os=`uname -s`
-if [ "$os" != "Linux" -a "$os" != "SunOS" ]; then
-    echo "Test not designed to run on this operating system, skipping..."
-    exit 0
-fi
+case "${os}" in
+    Windows* | CYGWIN* )
+        echo "Test not designed to run on this operating system, skipping..."
+        exit 0
+        ;;
+esac
 
 
 # Create configuration file and dummy password file
--- ./jdk/test/sun/management/jmxremote/bootstrap/SSLConfigFilePermissionTest.sh	2010-03-18 01:45:51.000000000 -0700
+++ ./jdk/test/sun/management/jmxremote/bootstrap/SSLConfigFilePermissionTest.sh	2010-01-30 09:29:08.000000000 -0800
@@ -69,10 +69,12 @@
 # security the password file.
 
 os=`uname -s`
-if [ "$os" != "Linux" -a "$os" != "SunOS" ]; then
-    echo "Test not designed to run on this operating system, skipping..."
-    exit 0
-fi
+case "${os}" in
+    Windows* | CYGWIN* )
+        echo "Test not designed to run on this operating system, skipping..."
+        exit 0
+        ;;
+esac
 
 # Create management and SSL configuration files
 
Files /tmp/openjdk_srcdir.WNIZhUSX/openjdk/jdk/test/sun/management/jmxremote/bootstrap/bsd-i586/launcher and /home/glewis/projects/java/jdk17/openjdk7/merge/bsd-port/jdk/test/sun/management/jmxremote/bootstrap/bsd-i586/launcher differ
--- ./jdk/test/sun/misc/URLClassPath/ClassnameCharTest.sh	2010-03-18 01:45:51.000000000 -0700
+++ ./jdk/test/sun/misc/URLClassPath/ClassnameCharTest.sh	2010-01-30 09:40:02.000000000 -0800
@@ -36,11 +36,7 @@
 
 OS=`uname -s`
 case "$OS" in
-  SunOS )
-    PS=":"
-    FS="/"
-    ;;
-  Linux )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     FS="/"
     ;;
--- ./jdk/test/sun/net/www/MarkResetTest.sh	2010-03-18 01:45:51.000000000 -0700
+++ ./jdk/test/sun/net/www/MarkResetTest.sh	2010-01-30 09:29:09.000000000 -0800
@@ -28,7 +28,7 @@
 
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     FS="/"
     ;;
--- ./jdk/test/sun/net/www/http/ChunkedInputStream/ChunkedCharEncoding.sh	2010-03-18 01:45:51.000000000 -0700
+++ ./jdk/test/sun/net/www/http/ChunkedInputStream/ChunkedCharEncoding.sh	2010-01-30 09:29:09.000000000 -0800
@@ -28,7 +28,7 @@
 
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     FS="/"
     ;;
--- ./jdk/test/sun/net/www/http/HttpClient/RetryPost.sh	2010-03-18 01:45:51.000000000 -0700
+++ ./jdk/test/sun/net/www/http/HttpClient/RetryPost.sh	2010-01-30 09:29:09.000000000 -0800
@@ -28,7 +28,7 @@
 
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     FS="/"
     ;;
--- ./jdk/test/sun/net/www/protocol/jar/B5105410.sh	2010-03-18 01:45:51.000000000 -0700
+++ ./jdk/test/sun/net/www/protocol/jar/B5105410.sh	2010-01-30 09:29:09.000000000 -0800
@@ -31,11 +31,7 @@
 
 OS=`uname -s`
 case "$OS" in
-  SunOS )
-    PS=":"
-    FS="/"
-    ;;
-  Linux )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     FS="/"
     ;;
--- ./jdk/test/sun/net/www/protocol/jar/jarbug/run.sh	2010-03-18 01:45:51.000000000 -0700
+++ ./jdk/test/sun/net/www/protocol/jar/jarbug/run.sh	2010-01-30 09:29:10.000000000 -0800
@@ -31,11 +31,7 @@
 
 OS=`uname -s`
 case "$OS" in
-  SunOS )
-    PS=":"
-    FS="/"
-    ;;
-  Linux )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     FS="/"
     ;;
--- ./jdk/test/sun/nio/cs/EucJpBsd0212.java	2010-03-27 11:09:15.000000000 -0700
+++ ./jdk/test/sun/nio/cs/EucJpBsd0212.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,79 +0,0 @@
-/*
- * Copyright 2008 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-
-/*
- * @test
- * @bug 6350021
- * @summary Consistency checks when input buffer contains JISX0212 characters
- * @author Martin Buchholz
- */
-
-import java.io.*;
-import java.util.*;
-import java.nio.*;
-import java.nio.charset.*;
-
-public class EucJpBsd0212 {
-    private static void equal(CharBuffer b1, CharBuffer b2) {
-        equal(b1.position(), b2.position());
-        equal(b1.limit(), b2.limit());
-        System.out.printf("positions=%d %d%n", b1.position(), b2.position());
-        System.out.printf("limits=%d %d%n", b1.limit(), b2.limit());
-        for (int i = b1.position(); i < b1.limit(); i++)
-            equal((int)b1.get(i), (int)b2.get(i));
-    }
-
-    private static void realMain(String[] args) throws Throwable {
-        List<ByteBuffer> bbs = Arrays.asList(
-            ByteBuffer.allocate(10),
-            ByteBuffer.allocateDirect(10));
-        List<CharBuffer> cbs = new ArrayList<CharBuffer>();
-
-        for (ByteBuffer bb : bbs) {
-            bb.put(new byte[]{ (byte)0x8f, 0x01, 0x02,
-                               (byte)0xa1, (byte)0xc0,
-                               0x02, 0x03});
-            bb.flip();
-            CharsetDecoder decoder = Charset.forName("EUC_JP_BSD").newDecoder();
-            decoder.onUnmappableCharacter(CodingErrorAction.REPLACE);
-            CharBuffer cb = decoder.decode(bb);
-            cbs.add(cb);
-        }
-        equal(cbs.get(0), cbs.get(1));
-    }
-
-    //--------------------- Infrastructure ---------------------------
-    static volatile int passed = 0, failed = 0;
-    static void pass() {passed++;}
-    static void fail() {failed++; Thread.dumpStack();}
-    static void fail(String msg) {System.out.println(msg); fail();}
-    static void unexpected(Throwable t) {failed++; t.printStackTrace();}
-    static void check(boolean cond) {if (cond) pass(); else fail();}
-    static void equal(Object x, Object y) {
-        if (x == null ? y == null : x.equals(y)) pass();
-        else fail(x + " not equal to " + y);}
-    public static void main(String[] args) throws Throwable {
-        try {realMain(args);} catch (Throwable t) {unexpected(t);}
-        System.out.printf("%nPassed = %d, failed = %d%n%n", passed, failed);
-        if (failed > 0) throw new AssertionError("Some tests failed");}
-}
--- ./jdk/test/sun/nio/cs/EucJpBsdDecoderRecoveryTest.java	2010-03-27 11:09:15.000000000 -0700
+++ ./jdk/test/sun/nio/cs/EucJpBsdDecoderRecoveryTest.java	1969-12-31 16:00:00.000000000 -0800
@@ -1,70 +0,0 @@
-/*
- * Copyright 2008 Sun Microsystems, Inc.  All Rights Reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
- * CA 95054 USA or visit www.sun.com if you need additional information or
- * have any questions.
- */
-
-/* @test
-   @bug 5016049
-   @summary ensure euc-jp-bsd charset decoder recovery for unmappable input
- */
-
-import java.io.*;
-
-public class EucJpBsdDecoderRecoveryTest {
-    public static void main(String[] args) throws Exception {
-        byte[] encoded = {
-                // EUC_JP_BSD mappable JIS X 0208 range
-                (byte)0xa6, (byte)0xc5,
-                // EUC_JP_BSD Unmappable (JIS X 0212 range)
-                (byte)0x8f, (byte)0xa2, (byte)0xb7,
-                // EUC_JP_BSD mappable JIS X 0208 range
-                (byte)0xa6, (byte)0xc7 };
-
-        char[] decodedChars = new char[3];
-        char[] expectedChars =
-                        {
-                        '\u03B5',  // mapped
-                        '\ufffd',  // unmapped
-                        '\u03B7'   // mapped
-                        };
-
-        ByteArrayInputStream bais = new ByteArrayInputStream(encoded);
-        InputStreamReader isr = new InputStreamReader(bais, "EUC_JP_BSD");
-        int n = 0;   // number of chars decoded
-
-        try {
-            n = isr.read(decodedChars);
-        } catch (Exception ex) {
-            throw new Error("euc-jp-bsd decoding broken");
-        }
-
-        // check number of decoded chars is what is expected
-        if (n != expectedChars.length)
-            throw new Error("Unexpected number of chars decoded");
-
-        // Compare actual decoded with expected
-
-        for (int i = 0; i < n; i++) {
-            if (expectedChars[i] != decodedChars[i])
-                throw new Error("euc-jp-bsd decoding incorrect");
-        }
-    }
-}
--- ./jdk/test/sun/security/pkcs11/KeyStore/Basic.sh	2010-03-18 01:45:53.000000000 -0700
+++ ./jdk/test/sun/security/pkcs11/KeyStore/Basic.sh	2010-01-30 09:29:12.000000000 -0800
@@ -131,6 +131,27 @@
 	;;
     esac
     ;;
+  *BSD | Darwin )
+    ARCH=`uname -m`
+    case "$ARCH" in
+      i[3-6]86 )
+	FS="/"
+	PS=":"
+	CP="${FS}bin${FS}cp"
+	CHMOD="${FS}bin${FS}chmod"
+	;;
+      amd64* )
+	FS="/"
+	PS=":"
+	CP="${FS}bin${FS}cp"
+	CHMOD="${FS}bin${FS}chmod"
+	;;
+      * )
+	echo "Unsupported System: ${OS} ${ARCH}"
+	exit 0;
+	;;
+    esac
+    ;;
   Windows* )  
     FS="\\"
     PS=";"
--- ./jdk/test/sun/security/pkcs11/KeyStore/ClientAuth.sh	2010-03-18 01:45:53.000000000 -0700
+++ ./jdk/test/sun/security/pkcs11/KeyStore/ClientAuth.sh	2010-01-30 09:29:12.000000000 -0800
@@ -92,6 +92,27 @@
 	;;
     esac
     ;;
+  *BSD | Darwin )
+    ARCH=`uname -m`
+    case "$ARCH" in
+      i[3-6]86 )
+	FS="/"
+	PS=":"
+	CP="${FS}bin${FS}cp"
+	CHMOD="${FS}bin${FS}chmod"
+	;;
+      amd64* )
+	FS="/"
+	PS=":"
+	CP="${FS}bin${FS}cp"
+	CHMOD="${FS}bin${FS}chmod"
+	;;
+      * )
+	echo "Unsupported System: ${OS} ${ARCH}"
+	exit 0;
+	;;
+    esac
+    ;;
   Windows* )
     FS="\\"
     PS=";"
--- ./jdk/test/sun/security/pkcs11/Provider/ConfigQuotedString.sh	2010-03-18 01:45:53.000000000 -0700
+++ ./jdk/test/sun/security/pkcs11/Provider/ConfigQuotedString.sh	2010-01-30 09:29:13.000000000 -0800
@@ -50,13 +50,7 @@
 
 OS=`uname -s`
 case "$OS" in
-  SunOS )
-    FS="/"
-    PS=":"
-    CP="${FS}bin${FS}cp"
-    CHMOD="${FS}bin${FS}chmod"
-    ;;
-  Linux )
+  SunOS | Linux | *BSD | Darwin )
     FS="/"
     PS=":"
     CP="${FS}bin${FS}cp"
--- ./jdk/test/sun/security/pkcs11/Provider/Login.sh	2010-03-18 01:45:53.000000000 -0700
+++ ./jdk/test/sun/security/pkcs11/Provider/Login.sh	2010-01-30 09:29:13.000000000 -0800
@@ -51,13 +51,7 @@
 
 OS=`uname -s`
 case "$OS" in
-  SunOS )
-    FS="/"
-    PS=":"
-    CP="${FS}bin${FS}cp"
-    CHMOD="${FS}bin${FS}chmod"
-    ;;
-  Linux )
+  SunOS | Linux | *BSD | Darwin )
     FS="/"
     PS=":"
     CP="${FS}bin${FS}cp"
Files /tmp/openjdk_srcdir.WNIZhUSX/openjdk/jdk/test/sun/security/pkcs11/nss/lib/bsd-amd64/libfreebl3.chk and /home/glewis/projects/java/jdk17/openjdk7/merge/bsd-port/jdk/test/sun/security/pkcs11/nss/lib/bsd-amd64/libfreebl3.chk differ
Files /tmp/openjdk_srcdir.WNIZhUSX/openjdk/jdk/test/sun/security/pkcs11/nss/lib/bsd-amd64/libfreebl3.so and /home/glewis/projects/java/jdk17/openjdk7/merge/bsd-port/jdk/test/sun/security/pkcs11/nss/lib/bsd-amd64/libfreebl3.so differ
Files /tmp/openjdk_srcdir.WNIZhUSX/openjdk/jdk/test/sun/security/pkcs11/nss/lib/bsd-amd64/libnspr4.so and /home/glewis/projects/java/jdk17/openjdk7/merge/bsd-port/jdk/test/sun/security/pkcs11/nss/lib/bsd-amd64/libnspr4.so differ
Files /tmp/openjdk_srcdir.WNIZhUSX/openjdk/jdk/test/sun/security/pkcs11/nss/lib/bsd-amd64/libnss3.so and /home/glewis/projects/java/jdk17/openjdk7/merge/bsd-port/jdk/test/sun/security/pkcs11/nss/lib/bsd-amd64/libnss3.so differ
Files /tmp/openjdk_srcdir.WNIZhUSX/openjdk/jdk/test/sun/security/pkcs11/nss/lib/bsd-amd64/libnssckbi.so and /home/glewis/projects/java/jdk17/openjdk7/merge/bsd-port/jdk/test/sun/security/pkcs11/nss/lib/bsd-amd64/libnssckbi.so differ
Files /tmp/openjdk_srcdir.WNIZhUSX/openjdk/jdk/test/sun/security/pkcs11/nss/lib/bsd-amd64/libplc4.so and /home/glewis/projects/java/jdk17/openjdk7/merge/bsd-port/jdk/test/sun/security/pkcs11/nss/lib/bsd-amd64/libplc4.so differ
Files /tmp/openjdk_srcdir.WNIZhUSX/openjdk/jdk/test/sun/security/pkcs11/nss/lib/bsd-amd64/libplds4.so and /home/glewis/projects/java/jdk17/openjdk7/merge/bsd-port/jdk/test/sun/security/pkcs11/nss/lib/bsd-amd64/libplds4.so differ
Files /tmp/openjdk_srcdir.WNIZhUSX/openjdk/jdk/test/sun/security/pkcs11/nss/lib/bsd-amd64/libsoftokn3.chk and /home/glewis/projects/java/jdk17/openjdk7/merge/bsd-port/jdk/test/sun/security/pkcs11/nss/lib/bsd-amd64/libsoftokn3.chk differ
Files /tmp/openjdk_srcdir.WNIZhUSX/openjdk/jdk/test/sun/security/pkcs11/nss/lib/bsd-amd64/libsoftokn3.so and /home/glewis/projects/java/jdk17/openjdk7/merge/bsd-port/jdk/test/sun/security/pkcs11/nss/lib/bsd-amd64/libsoftokn3.so differ
Files /tmp/openjdk_srcdir.WNIZhUSX/openjdk/jdk/test/sun/security/pkcs11/nss/lib/bsd-i586/libnspr4.so and /home/glewis/projects/java/jdk17/openjdk7/merge/bsd-port/jdk/test/sun/security/pkcs11/nss/lib/bsd-i586/libnspr4.so differ
Files /tmp/openjdk_srcdir.WNIZhUSX/openjdk/jdk/test/sun/security/pkcs11/nss/lib/bsd-i586/libnss3.so and /home/glewis/projects/java/jdk17/openjdk7/merge/bsd-port/jdk/test/sun/security/pkcs11/nss/lib/bsd-i586/libnss3.so differ
Files /tmp/openjdk_srcdir.WNIZhUSX/openjdk/jdk/test/sun/security/pkcs11/nss/lib/bsd-i586/libnssckbi.so and /home/glewis/projects/java/jdk17/openjdk7/merge/bsd-port/jdk/test/sun/security/pkcs11/nss/lib/bsd-i586/libnssckbi.so differ
Files /tmp/openjdk_srcdir.WNIZhUSX/openjdk/jdk/test/sun/security/pkcs11/nss/lib/bsd-i586/libplc4.so and /home/glewis/projects/java/jdk17/openjdk7/merge/bsd-port/jdk/test/sun/security/pkcs11/nss/lib/bsd-i586/libplc4.so differ
Files /tmp/openjdk_srcdir.WNIZhUSX/openjdk/jdk/test/sun/security/pkcs11/nss/lib/bsd-i586/libplds4.so and /home/glewis/projects/java/jdk17/openjdk7/merge/bsd-port/jdk/test/sun/security/pkcs11/nss/lib/bsd-i586/libplds4.so differ
Files /tmp/openjdk_srcdir.WNIZhUSX/openjdk/jdk/test/sun/security/pkcs11/nss/lib/bsd-i586/libsoftokn3.so and /home/glewis/projects/java/jdk17/openjdk7/merge/bsd-port/jdk/test/sun/security/pkcs11/nss/lib/bsd-i586/libsoftokn3.so differ
--- ./jdk/test/sun/security/provider/PolicyFile/GrantAllPermToExtWhenNoPolicy.sh	2010-03-18 01:45:54.000000000 -0700
+++ ./jdk/test/sun/security/provider/PolicyFile/GrantAllPermToExtWhenNoPolicy.sh	2010-01-30 09:29:16.000000000 -0800
@@ -44,11 +44,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS )
-    PATHSEP=":"
-    FILESEP="/"
-    ;;
-  Linux )
+  SunOS | Linux | *BSD | Darwin )
     PATHSEP=":"
     FILESEP="/"
     ;;
--- ./jdk/test/sun/security/provider/PolicyFile/getinstance/getinstance.sh	2010-03-18 01:45:54.000000000 -0700
+++ ./jdk/test/sun/security/provider/PolicyFile/getinstance/getinstance.sh	2010-01-30 09:29:16.000000000 -0800
@@ -47,11 +47,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS )
-    PS=":"
-    FS="/"
-    ;;
-  Linux )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     FS="/"
     ;;
--- ./jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/SSLSocketImpl/NotifyHandshakeTest.sh	2010-03-18 01:45:55.000000000 -0700
+++ ./jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/SSLSocketImpl/NotifyHandshakeTest.sh	2010-01-30 09:29:17.000000000 -0800
@@ -42,7 +42,7 @@
 
 OS=`uname -s`
 case "$OS" in
-    SunOS | Linux )
+    SunOS | Linux | *BSD | Darwin )
         FILESEP="/"
 	PATHSEP=":"
 	;;
--- ./jdk/test/sun/security/ssl/sun/net/www/protocol/https/HttpsURLConnection/PostThruProxy.sh	2010-03-18 01:45:55.000000000 -0700
+++ ./jdk/test/sun/security/ssl/sun/net/www/protocol/https/HttpsURLConnection/PostThruProxy.sh	2010-01-30 09:29:17.000000000 -0800
@@ -32,7 +32,7 @@
 HOSTNAME=`uname -n`
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     FS="/"
     ;;
--- ./jdk/test/sun/security/ssl/sun/net/www/protocol/https/HttpsURLConnection/PostThruProxyWithAuth.sh	2010-03-18 01:45:55.000000000 -0700
+++ ./jdk/test/sun/security/ssl/sun/net/www/protocol/https/HttpsURLConnection/PostThruProxyWithAuth.sh	2010-01-30 09:29:17.000000000 -0800
@@ -32,7 +32,7 @@
 HOSTNAME=`uname -n`
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     FS="/"
     ;;
--- ./jdk/test/sun/security/tools/jarsigner/AlgOptions.sh	2010-03-18 01:45:55.000000000 -0700
+++ ./jdk/test/sun/security/tools/jarsigner/AlgOptions.sh	2010-01-30 09:29:17.000000000 -0800
@@ -46,7 +46,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux )
+  SunOS | Linux | *BSD | Darwin )
     NULL=/dev/null
     PS=":"
     FS="/"
--- ./jdk/test/sun/security/tools/jarsigner/PercentSign.sh	2010-03-18 01:45:55.000000000 -0700
+++ ./jdk/test/sun/security/tools/jarsigner/PercentSign.sh	2010-01-30 09:29:17.000000000 -0800
@@ -46,7 +46,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux )
+  SunOS | Linux | *BSD | Darwin )
     NULL=/dev/null
     PS=":"
     FS="/"
--- ./jdk/test/sun/security/tools/jarsigner/oldsig.sh	2010-03-18 01:45:55.000000000 -0700
+++ ./jdk/test/sun/security/tools/jarsigner/oldsig.sh	2010-01-30 09:29:17.000000000 -0800
@@ -42,7 +42,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux )
+  SunOS | Linux | *BSD | Darwin )
     NULL=/dev/null
     PS=":"
     FS="/"
--- ./jdk/test/sun/security/tools/keytool/AltProviderPath.sh	2010-03-18 01:45:55.000000000 -0700
+++ ./jdk/test/sun/security/tools/keytool/AltProviderPath.sh	2010-01-30 09:29:17.000000000 -0800
@@ -46,7 +46,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux )
+  SunOS | Linux | *BSD | Darwin )
     NULL=/dev/null
     PS=":"
     FS="/"
--- ./jdk/test/sun/security/tools/keytool/CloneKeyAskPassword.sh	2010-03-18 01:45:55.000000000 -0700
+++ ./jdk/test/sun/security/tools/keytool/CloneKeyAskPassword.sh	2010-01-30 09:29:17.000000000 -0800
@@ -47,11 +47,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS )
-    PATHSEP=":"
-    FILESEP="/"
-    ;;
-  Linux )
+  SunOS | Linux | *BSD | Darwin )
     PATHSEP=":"
     FILESEP="/"
     ;;
--- ./jdk/test/sun/security/tools/keytool/SecretKeyKS.sh	2010-03-18 01:45:55.000000000 -0700
+++ ./jdk/test/sun/security/tools/keytool/SecretKeyKS.sh	2010-01-30 09:29:17.000000000 -0800
@@ -45,7 +45,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux )
+  SunOS | Linux | *BSD | Darwin )
     NULL=/dev/null
     PS=":"
     FS="/"
--- ./jdk/test/sun/security/tools/keytool/StandardAlgName.sh	2010-03-18 01:45:55.000000000 -0700
+++ ./jdk/test/sun/security/tools/keytool/StandardAlgName.sh	2010-01-30 09:29:17.000000000 -0800
@@ -46,7 +46,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux )
+  SunOS | Linux | *BSD | Darwin )
     NULL=/dev/null
     PS=":"
     FS="/"
--- ./jdk/test/sun/security/tools/keytool/autotest.sh	2010-03-18 01:45:55.000000000 -0700
+++ ./jdk/test/sun/security/tools/keytool/autotest.sh	2010-01-30 09:29:18.000000000 -0800
@@ -72,6 +72,27 @@
         ;;
     esac
     ;;
+  *BSD | Darwin )
+    case "${OS}" in
+      *BSD )
+        LIBNAME=libsoftokn3.so
+        ;;
+      Darwin )
+        LIBNAME=libsoftokn3.dylib
+        ;;
+    esac
+    ARCH=`uname -m`
+    FS="/"
+    case "$ARCH" in
+      i[3-6]86 )
+        PF="bsd-i586"
+        ;;
+      * )
+        echo "Will not run test on: ${OS} ${ARCH}"
+        exit 0;
+        ;;
+    esac
+    ;;
   * )
     echo "Will not run test on: ${OS}"
     exit 0;
--- ./jdk/test/sun/security/tools/keytool/i18n.sh	2010-03-18 01:45:55.000000000 -0700
+++ ./jdk/test/sun/security/tools/keytool/i18n.sh	2010-01-30 09:29:18.000000000 -0800
@@ -46,7 +46,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux )
+  SunOS | Linux | *BSD | Darwin )
     NULL=/dev/null
     PS=":"
     FS="/"
--- ./jdk/test/sun/security/tools/keytool/printssl.sh	2010-03-18 01:45:55.000000000 -0700
+++ ./jdk/test/sun/security/tools/keytool/printssl.sh	2010-01-30 09:29:18.000000000 -0800
@@ -37,7 +37,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux )
+  SunOS | Linux | *BSD | Darwin )
     FS="/"
     ;;
   CYGWIN* )
--- ./jdk/test/sun/security/tools/keytool/resource.sh	2010-03-18 01:45:55.000000000 -0700
+++ ./jdk/test/sun/security/tools/keytool/resource.sh	2010-01-30 09:29:18.000000000 -0800
@@ -43,7 +43,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux )
+  SunOS | Linux | *BSD | Darwin )
     NULL=/dev/null
     FS="/"
     TMP=/tmp
--- ./jdk/test/sun/security/tools/keytool/standard.sh	2010-03-18 01:45:55.000000000 -0700
+++ ./jdk/test/sun/security/tools/keytool/standard.sh	2010-01-30 09:29:18.000000000 -0800
@@ -44,7 +44,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | CYGWIN* )
+  SunOS | Linux | CYGWIN* | *BSD | Darwin )
     FS="/"
     ;;
   Windows_* )
--- ./jdk/test/sun/security/tools/policytool/Alias.sh	2010-03-18 01:45:55.000000000 -0700
+++ ./jdk/test/sun/security/tools/policytool/Alias.sh	2010-01-30 09:29:18.000000000 -0800
@@ -47,7 +47,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux )
+  SunOS | Linux | *BSD | Darwin )
     NULL=/dev/null
     PS=":"
     FS="/"
--- ./jdk/test/sun/security/tools/policytool/ChangeUI.sh	2010-03-18 01:45:55.000000000 -0700
+++ ./jdk/test/sun/security/tools/policytool/ChangeUI.sh	2010-01-30 09:29:18.000000000 -0800
@@ -46,7 +46,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux )
+  SunOS | Linux | *BSD | Darwin )
     NULL=/dev/null
     PS=":"
     FS="/"
--- ./jdk/test/sun/security/tools/policytool/OpenPolicy.sh	2010-03-18 01:45:55.000000000 -0700
+++ ./jdk/test/sun/security/tools/policytool/OpenPolicy.sh	2010-01-30 09:29:18.000000000 -0800
@@ -46,7 +46,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux )
+  SunOS | Linux | *BSD | Darwin )
     NULL=/dev/null
     PS=":"
     FS="/"
--- ./jdk/test/sun/security/tools/policytool/SaveAs.sh	2010-03-18 01:45:55.000000000 -0700
+++ ./jdk/test/sun/security/tools/policytool/SaveAs.sh	2010-01-30 09:29:18.000000000 -0800
@@ -47,7 +47,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux )
+  SunOS | Linux | *BSD | Darwin )
     NULL=/dev/null
     PS=":"
     FS="/"
--- ./jdk/test/sun/security/tools/policytool/UpdatePermissions.sh	2010-03-18 01:45:55.000000000 -0700
+++ ./jdk/test/sun/security/tools/policytool/UpdatePermissions.sh	2010-01-30 09:29:18.000000000 -0800
@@ -46,7 +46,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux )
+  SunOS | Linux | *BSD | Darwin )
     NULL=/dev/null
     PS=":"
     FS="/"
--- ./jdk/test/sun/security/tools/policytool/UsePolicy.sh	2010-03-18 01:45:55.000000000 -0700
+++ ./jdk/test/sun/security/tools/policytool/UsePolicy.sh	2010-01-30 09:29:18.000000000 -0800
@@ -46,7 +46,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux )
+  SunOS | Linux | *BSD | Darwin )
     NULL=/dev/null
     PS=":"
     FS="/"
--- ./jdk/test/sun/security/tools/policytool/i18n.sh	2010-03-18 01:45:55.000000000 -0700
+++ ./jdk/test/sun/security/tools/policytool/i18n.sh	2010-01-30 09:29:18.000000000 -0800
@@ -46,7 +46,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux )
+  SunOS | Linux | *BSD | Darwin )
     NULL=/dev/null
     PS=":"
     FS="/"
--- ./jdk/test/sun/tools/jconsole/ImmutableResourceTest.sh	2010-03-18 01:45:55.000000000 -0700
+++ ./jdk/test/sun/tools/jconsole/ImmutableResourceTest.sh	2010-01-30 09:29:18.000000000 -0800
@@ -53,7 +53,7 @@
 
 OS=`uname -s`
 case "$OS" in
-   SunOS | Linux )
+   SunOS | Linux | *BSD | Darwin )
       PATHSEP=":"
       ;;
 
--- ./jdk/test/sun/tools/jconsole/ResourceCheckTest.sh	2010-03-18 01:45:55.000000000 -0700
+++ ./jdk/test/sun/tools/jconsole/ResourceCheckTest.sh	2010-01-30 09:29:18.000000000 -0800
@@ -54,7 +54,7 @@
 
 OS=`uname -s`
 case "$OS" in
-   SunOS | Linux )
+   SunOS | Linux | *BSD | Darwin )
       PATHSEP=":"
       ;;
 
--- ./jdk/test/sun/tools/native2ascii/Native2AsciiTests.sh	2010-03-18 01:45:56.000000000 -0700
+++ ./jdk/test/sun/tools/native2ascii/Native2AsciiTests.sh	2010-01-30 12:39:04.000000000 -0800
@@ -33,7 +33,7 @@
 
 case `uname -s` in
   Windows* | CYGWIN*) OS=Windows;;
-  SunOS|Linux) OS=Unix;;
+  SunOS|Linux|*BSD|Darwin) OS=Unix;;
 esac
 
 N2A=$TESTJAVA/bin/native2ascii
--- ./jdk/test/sun/tools/native2ascii/resources/ImmutableResourceTest.sh	2010-03-18 01:45:56.000000000 -0700
+++ ./jdk/test/sun/tools/native2ascii/resources/ImmutableResourceTest.sh	2010-01-30 09:29:19.000000000 -0800
@@ -56,7 +56,7 @@
 
 OS=`uname -s`
 case "$OS" in
-   SunOS | Linux )
+   SunOS | Linux | *BSD | Darwin )
       PATHSEP=":"
       ;;
 
--- ./jdk/test/tools/pack200/Pack200Simple.sh	2010-03-18 01:45:56.000000000 -0700
+++ ./jdk/test/tools/pack200/Pack200Simple.sh	2010-01-30 09:29:19.000000000 -0800
@@ -85,7 +85,7 @@
     break
     ;;
 
-  Linux )
+  Linux | *BSD | Darwin )
     PackOptions="-J-Xmx512m -J-ea"
     break
     ;;
--- ./langtools/.hgtags	2010-03-18 01:46:16.000000000 -0700
+++ ./langtools/.hgtags	2010-03-20 11:13:06.000000000 -0700
@@ -60,3 +60,4 @@
 c9f4ae1f1480e89aaf7e72173184089d9cea397a jdk7-b83
 d9cd5b8286e44f3baf90da290cd295433e21c05a jdk7-b84
 136bfc67946219fb02ee223984540a4a9c5b209f jdk7-b85
+ef07347428f2198ae6b8144ac0b9086bbe39fd16 jdk7-b86
--- ./langtools/.jcheck/conf	2010-03-18 01:46:16.000000000 -0700
+++ ./langtools/.jcheck/conf	1969-12-31 16:00:00.000000000 -0800
@@ -1 +0,0 @@
-project=jdk7
--- ./langtools/test/Makefile	2010-03-18 01:46:18.000000000 -0700
+++ ./langtools/test/Makefile	2009-09-23 21:29:29.000000000 -0700
@@ -20,6 +20,22 @@
     ARCH=i586
   endif
 endif
+ifeq ($(OSNAME), Darwin)
+  PLATFORM = bsd
+  JT_PLATFORM = linux
+  ARCH = $(shell uname -m)
+  ifeq ($(ARCH), i386)
+    ARCH=i586
+  endif
+endif
+ifeq ($(findstring BSD,$(OSNAME)), BSD)
+  PLATFORM = bsd
+  JT_PLATFORM = linux
+  ARCH = $(shell uname -m)
+  ifeq ($(ARCH), i386)
+    ARCH=i586
+  endif
+endif
 ifeq ($(OSNAME), Windows_NT)
   PLATFORM = windows
   JT_PLATFORM = win32
@@ -62,7 +78,7 @@
 ifdef JPRT_JAVA_HOME
   JT_JAVA = $(JPRT_JAVA_HOME)
 else
-  JT_JAVA = $(SLASH_JAVA)/re/jdk/1.6.0/archive/fcs/binaries/$(PLATFORM)-$(ARCH)
+  JT_JAVA = $(TEST_ROOT)/../../build/$(PLATFORM)-$(ARCH)
 endif
 
 # Default JDK to test
@@ -76,7 +92,9 @@
 
 # The test directories to run
 DEFAULT_TESTDIRS = .
-TESTDIRS = $(DEFAULT_TESTDIRS)
+ifndef TESTDIRS
+  TESTDIRS = $(DEFAULT_TESTDIRS)
+endif
 
 # Root of all test results
 TEST_OUTPUT_DIR = $(TEST_ROOT)/o_$(PLATFORM)-$(ARCH)
--- ./langtools/test/jprt.config	2010-03-18 01:46:19.000000000 -0700
+++ ./langtools/test/jprt.config	2009-06-06 17:29:59.000000000 -0700
@@ -71,8 +71,8 @@
 
 # Uses 'uname -s', but only expect SunOS or Linux, assume Windows otherwise.
 osname=`uname -s`
-if [ "${osname}" = SunOS ] ; then
-   
+case "${osname}" in
+  SunOS)
     # SOLARIS: Sparc or X86
     osarch=`uname -p`
     if [ "${osarch}" = sparc ] ; then
@@ -96,9 +96,9 @@
 
     # File creation mask
     umask 002
+    ;;
 
-elif [ "${osname}" = Linux ] ; then
-   
+  Linux | Darwin )
     # Add basic paths
     path4sdk=/usr/bin:/bin:/usr/sbin:/sbin
 
@@ -107,9 +107,31 @@
     fileMustExist "${make}" make
 
     umask 002
+    ;;
+
+  FreeBSD | OpenBSD )
+    # Add basic paths
+    path4sdk=/usr/bin:/bin:/usr/sbin:/sbin
+
+    # Find GNU make
+    make=/usr/local/bin/gmake
+    fileMustExist "${make}" make
+
+    umask 002
+    ;;
 
-else
+  NetBSD )
+    # Add basic paths
+    path4sdk=/usr/bin:/bin:/usr/sbin:/sbin
 
+    # Find GNU make
+    make=/usr/pkg/bin/gmake
+    fileMustExist "${make}" make
+
+    umask 002
+    ;;
+
+  *)
     # Windows: Differs on CYGWIN vs. MKS.
    
     # We need to determine if we are running a CYGWIN shell or an MKS shell
@@ -150,8 +172,8 @@
     if [ "${unix_toolset}" = CYGWIN ] ; then
 	path4sdk="`/usr/bin/cygpath -p ${path4sdk}`"
     fi
-
-fi
+    ;;
+esac
 
 # Export PATH setting
 PATH="${path4sdk}"
--- ./langtools/test/tools/javac/4846262/Test.sh	2010-03-18 01:46:19.000000000 -0700
+++ ./langtools/test/tools/javac/4846262/Test.sh	2009-10-05 22:36:51.000000000 -0700
@@ -44,7 +44,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux )
+  SunOS | Linux | *BSD | Darwin )
     FS="/"
     ;;
   CYGWIN* )
--- ./langtools/test/tools/javac/6302184/T6302184.sh	2010-03-18 01:46:19.000000000 -0700
+++ ./langtools/test/tools/javac/6302184/T6302184.sh	2009-10-05 22:36:51.000000000 -0700
@@ -41,7 +41,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux )
+  SunOS | Linux | *BSD | Darwin )
     FS="/"
     ;;
   CYGWIN* )
--- ./langtools/test/tools/javac/ClassPathTest/ClassPathTest.sh	2010-03-18 01:46:20.000000000 -0700
+++ ./langtools/test/tools/javac/ClassPathTest/ClassPathTest.sh	2009-10-05 22:36:51.000000000 -0700
@@ -56,7 +56,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | CYGWIN* )
+  SunOS | Linux | *BSD | Darwin )
     FS="/"
     ;;
   Windows* )
--- ./langtools/test/tools/javac/ExtDirs/ExtDirs.sh	2010-03-18 01:46:20.000000000 -0700
+++ ./langtools/test/tools/javac/ExtDirs/ExtDirs.sh	2009-10-05 22:36:51.000000000 -0700
@@ -54,7 +54,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     FS="/"
     ;;
--- ./langtools/test/tools/javac/MissingInclude.sh	2010-03-18 01:46:20.000000000 -0700
+++ ./langtools/test/tools/javac/MissingInclude.sh	2009-10-05 22:36:51.000000000 -0700
@@ -47,7 +47,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | CYGWIN* )
+  SunOS | Linux | CYGWIN* | *BSD | Darwin )
     FS="/"
     ;;
   Windows* )
--- ./langtools/test/tools/javac/ProtectedInnerClass/ProtectedInnerClass.sh	2010-03-18 01:46:20.000000000 -0700
+++ ./langtools/test/tools/javac/ProtectedInnerClass/ProtectedInnerClass.sh	2009-10-05 22:36:51.000000000 -0700
@@ -52,7 +52,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     FS="/"
     ;;
--- ./langtools/test/tools/javac/T5090006/compiler.sh	2010-03-18 01:46:21.000000000 -0700
+++ ./langtools/test/tools/javac/T5090006/compiler.sh	2009-10-05 22:36:51.000000000 -0700
@@ -47,7 +47,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | CYGWIN* )
+  SunOS | Linux | CYGWIN* | *BSD | Darwin )
     FS="/"
     ;;
   Windows* )
--- ./langtools/test/tools/javac/apt.sh	2010-03-18 01:46:21.000000000 -0700
+++ ./langtools/test/tools/javac/apt.sh	2009-06-06 17:30:04.000000000 -0700
@@ -38,7 +38,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux )
+  SunOS | Linux | *BSD | Darwin )
     NULL=/dev/null
     PS=":"
     FS="/"
--- ./langtools/test/tools/javac/constDebug/ConstDebug.sh	2010-03-18 01:46:21.000000000 -0700
+++ ./langtools/test/tools/javac/constDebug/ConstDebug.sh	2009-10-05 22:36:51.000000000 -0700
@@ -47,7 +47,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     FS="/"
     ;;
--- ./langtools/test/tools/javac/fatalErrors/NoJavaLang.sh	2010-03-18 01:46:22.000000000 -0700
+++ ./langtools/test/tools/javac/fatalErrors/NoJavaLang.sh	2009-10-05 22:36:51.000000000 -0700
@@ -48,7 +48,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux )
+  SunOS | Linux | *BSD | Darwin )
     FS="/"
     ;;
   CYGWIN* )
--- ./langtools/test/tools/javac/innerClassFile/Driver.sh	2010-03-18 01:46:23.000000000 -0700
+++ ./langtools/test/tools/javac/innerClassFile/Driver.sh	2009-10-05 22:36:51.000000000 -0700
@@ -53,7 +53,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | CYGWIN* )
+  SunOS | Linux | CYGWIN* | *BSD | Darwin )
     FS="/"
     ;;
   Windows* )
--- ./langtools/test/tools/javac/javazip/Test.sh	2010-03-18 01:46:23.000000000 -0700
+++ ./langtools/test/tools/javac/javazip/Test.sh	2009-10-05 22:36:51.000000000 -0700
@@ -41,7 +41,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux )
+  SunOS | Linux | *BSD | Darwin )
     FS="/"
     SCR=`pwd`
     ;;
--- ./langtools/test/tools/javac/links/links.sh	2010-03-18 01:46:23.000000000 -0700
+++ ./langtools/test/tools/javac/links/links.sh	2009-06-06 17:30:08.000000000 -0700
@@ -53,7 +53,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux )
+  SunOS | Linux | *BSD | Darwin )
     NULL=/dev/null
     PS=":"
     FS="/"
--- ./langtools/test/tools/javac/newlines/Newlines.sh	2010-03-18 01:46:23.000000000 -0700
+++ ./langtools/test/tools/javac/newlines/Newlines.sh	2009-10-05 22:36:51.000000000 -0700
@@ -50,7 +50,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | CYGWIN* )
+  SunOS | Linux | CYGWIN* | *BSD | Darwin )
     FS="/"
     ;;
   Windows* )
--- ./langtools/test/tools/javac/stackmap/T4955930.sh	2010-03-18 01:46:24.000000000 -0700
+++ ./langtools/test/tools/javac/stackmap/T4955930.sh	2009-10-05 22:36:51.000000000 -0700
@@ -41,7 +41,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | CYGWIN* )
+  SunOS | Linux | CYGWIN* | *BSD | Darwin )
     FS="/"
     ;;
   Windows_95 | Windows_98 | Windows_NT )
--- ./langtools/test/tools/javac/unicode/SupplementaryJavaID6.sh	2010-03-18 01:46:24.000000000 -0700
+++ ./langtools/test/tools/javac/unicode/SupplementaryJavaID6.sh	2009-10-05 22:36:51.000000000 -0700
@@ -66,6 +66,17 @@
         exit 0;
     fi
     ;;
+  *BSD | Darwin )
+    if [ -d /usr/share/locale/en_US.UTF-8 -o -d /usr/share/locale/en_US.utf8 ]
+    then
+        ENV="env LANG=en_US.UTF-8"
+        PS=":"
+        FS="/"
+    else
+        echo "As there is no en_US.UTF-8 locale available on this system, the compilation of the test case may or may not fail.  Ignoring this test."
+        exit 0;
+    fi
+    ;;
   Windows_98 | Windows_ME )
     echo "As Windows 98/Me do not provide Unicode-aware file system, the compilation of the test case is expected to fail on these platforms.  Ignoring this test."
     exit 0;
--- ./langtools/test/tools/javah/6257087/foo.sh	2010-03-18 01:46:24.000000000 -0700
+++ ./langtools/test/tools/javah/6257087/foo.sh	2009-10-05 22:36:51.000000000 -0700
@@ -41,7 +41,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     FS="/"
     ;;
--- ./langtools/test/tools/javah/ConstMacroTest.sh	2010-03-18 01:46:24.000000000 -0700
+++ ./langtools/test/tools/javah/ConstMacroTest.sh	2009-10-05 22:36:51.000000000 -0700
@@ -56,7 +56,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux )
+  SunOS | Linux | *BSD | Darwin )
     PS=":"
     FS="/"
     ;;
--- ./langtools/test/tools/javah/MissingParamClassTest.sh	2010-03-18 01:46:24.000000000 -0700
+++ ./langtools/test/tools/javah/MissingParamClassTest.sh	2009-10-18 15:07:54.000000000 -0700
@@ -58,7 +58,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | CYGWIN* )
+  SunOS | Linux | CYGWIN* | *BSD | Darwin )
     PS=":"
     FS="/"
     ;;
--- ./langtools/test/tools/javah/ReadOldClass.sh	2010-03-18 01:46:24.000000000 -0700
+++ ./langtools/test/tools/javah/ReadOldClass.sh	2009-10-05 22:36:51.000000000 -0700
@@ -43,7 +43,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | CYGWIN* )
+  SunOS | Linux | CYGWIN* | *BSD | Darwin )
     PS=":"
     FS="/"
     ;;
--- ./langtools/test/tools/javap/pathsep.sh	2010-03-18 01:46:24.000000000 -0700
+++ ./langtools/test/tools/javap/pathsep.sh	2009-10-05 22:36:51.000000000 -0700
@@ -40,7 +40,7 @@
 # set platform-dependent variables
 OS=`uname -s`
 case "$OS" in
-  SunOS | Linux | CYGWIN* )
+  SunOS | Linux | CYGWIN* | *BSD | Darwin )
     FS="/"
     ;;
   Windows* )
