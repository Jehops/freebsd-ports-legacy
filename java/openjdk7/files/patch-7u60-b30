--- ./.hgtags	Tue Mar 18 12:29:21 2014 -0700
+++ ./.hgtags	Wed May 07 19:25:50 2014 -0700
@@ -357,6 +357,7 @@
 3af81bfe320c12758234233da6fa27c3c0ffcdc4 jdk7u40-b42
 1d53bd8fd2a62bcf336727ebec377ef7498dd4a6 jdk7u40-b43
 dc1e099cd62d250b4a997ce694b47fe2f50d2905 jdk7u40-b60
+11147a12bd8c6b02f98016a8d1151e56f42a43b6 jdk7u60-b00
 6359fa34199c9619dfec0f41d2eb22a4083ce610 jdk7u40-b61
 a2605cf03226ce2fef7a899ce41521c654300975 jdk7u40-b62
 07e41ff8674c9438cb1124cf78eed8636ed5d4fa jdk7u45-b02
@@ -414,3 +415,26 @@
 f4ace62029de00d2497058c3c0e1d26e019cde30 jdk7u55-b11
 de268da51b54a4f36bcc1a9af60faea285e94330 jdk7u55-b12
 d972a2d9e4f3f864d26c33ccfdacd8269e0f29a8 jdk7u55-b13
+0820b4707cfa75f8211b88b0daa67bba8475f498 jdk7u55-b30
+997ab3897d6ede80b0decdda94b569e57dd7dd90 jdk7u55-b14
+1f52edec29fd44c8bacce11ba7440287b37d04d1 jdk7u55-b31
+11147a12bd8c6b02f98016a8d1151e56f42a43b6 jdk7u60-b00
+88113cabda386320a087b288d43e792f523cc0ba jdk7u60-b01
+6bdacebbc97f0a03be45be48a6d5b5cf2f7fe77d jdk7u60-b02
+87f2193da40d3a2eedca95108ae78403c7bdcd49 jdk7u60-b03
+d4397128f8b65eb96287128575dd1a3da6a7825b jdk7u60-b04
+ea798405286d97f643ef809abcb1e13024b4f951 jdk7u60-b05
+b0940b205cab942512b5bca1338ab96a45a67832 jdk7u60-b06
+cae7bacaa13bb8c42a42fa35b156a7660874e907 jdk7u60-b07
+1af0560611469ad2a068a03774ecd0d7790db7b7 jdk7u60-b08
+662dc3b6467488b8c175a4423ba7a4991ad87d94 jdk7u60-b09
+023f8eb40d371d5cb761f7e60ba7b396b3fdf886 jdk7u60-b10
+798468b91bcbb81684aea8620dbb31eaceb24c6c jdk7u60-b11
+e40360c10b2ce5b24b1eea63160b78e112aa5d3f jdk7u60-b12
+5e540a4d55916519f5604a422bfbb7a0967d0594 jdk7u60-b13
+1ca6a368aec38ee91a41dc03899d7dc1037de44d jdk7u60-b14
+a95b821a2627295b90fb4ae8f3b8bc2ff9c64acc jdk7u60-b15
+19a3f6f48c541a8cf144eedffa0e52e108052e82 jdk7u60-b16
+472f5930e6cc8f307b5508995ee2edcf9913a852 jdk7u60-b18
+472f5930e6cc8f307b5508995ee2edcf9913a852 jdk7u60-b17
+2a7a5e774023944f291ee27ca5b3ad89e0e62aaf jdk7u60-b19
--- ./make/scripts/webrev.ksh	Tue Mar 18 12:29:21 2014 -0700
+++ ./make/scripts/webrev.ksh	Wed May 07 19:25:50 2014 -0700
@@ -2695,11 +2695,11 @@
         rm -f $WDIR/$DIR/$F.html
 
 	its_a_jar=
-	if expr $F : '.*\.jar' >/dev/null; then
+	if expr $F : '.*\.jar' \| $F : '.*\.zip' >/dev/null; then
 	    its_a_jar=1
-	    # It's a JAR file, let's do it differntly
+	    # It's a JAR or ZIP file, let's do it differently
 	    if [[ -z $JAR ]]; then
-		print "No access to jar, so can't produce diffs for jar files"
+		print "No access to jar, so can't produce diffs for jar or zip files"
 	    else
 		if [ -f $ofile ]; then
 		    $JAR -tvf $ofile >"$ofile".lst
--- ./corba/.hgtags	Tue Mar 18 12:29:47 2014 -0700
+++ ./corba/.hgtags	Wed May 07 19:25:52 2014 -0700
@@ -417,3 +417,26 @@
 cbd5b4b07e0c8a5f61eff396b7622e7b04d2a164 jdk7u55-b11
 3cce2a49d18d93dfca2634db32368486ebbb1590 jdk7u55-b12
 8efa6e66c13a5329c312d1a521ffab75d9a330e3 jdk7u55-b13
+e041c52fe69128ec3439d26afef9b0fcba00684c jdk7u55-b30
+a0bfd0e80ae0ae6e3a29bf527b5911c83163b3f5 jdk7u55-b14
+55ff6957449cf6c79f5d5bb159df27f51ece1659 jdk7u55-b31
+c5b5886004e6446b8b27ccdc1fd073354c1dc614 jdk7u60-b00
+a531112cc6d0b0a1e7d4ffdaa3ba53addcd25cf4 jdk7u60-b01
+d81370c5b863acc19e8fb07315b1ec687ac1136a jdk7u60-b02
+d7e98ed925a3885380226f8375fe109a9a25397f jdk7u60-b03
+1a3aa4637b80fabbd069ae88c241efcb3520fc49 jdk7u60-b04
+753698a910167cc29c01490648a2adbcea1314cc jdk7u60-b05
+9852efe6d6b992b73fdbf59e36fb3547a9535051 jdk7u60-b06
+84a18429f247774fc7f1bc81de271da20b40845b jdk7u60-b07
+8469bc00ddca4de366b20b32d42548c882656cd8 jdk7u60-b08
+7abca119f9543489280d560dc11256d439004f0f jdk7u60-b09
+1861f1f599728c4f15a85a5980edef916552747b jdk7u60-b10
+a429ff635395688ded6c52cd21c0b4ce75e62168 jdk7u60-b11
+d581875525aaf618afe901da31d679195ee35f4b jdk7u60-b12
+2c8ba5f9487b0ac085874afd38f4c10a4127f62c jdk7u60-b13
+02bdeb33754315f589bd650dde656d2c9947976d jdk7u60-b14
+e5946b2cf82bdea3a4b85917e903168e65a543a7 jdk7u60-b15
+e424fb8452851b56db202488a4e9a283934c4887 jdk7u60-b16
+b96d90694be873372cc417b38b01afed6ac1b239 jdk7u60-b18
+b96d90694be873372cc417b38b01afed6ac1b239 jdk7u60-b17
+5d1b39fe68944cff6380db56fbe2fbaa28091bf6 jdk7u60-b19
--- ./corba/src/share/classes/com/sun/corba/se/impl/copyobject/JavaInputStream.sjava	Tue Mar 18 12:29:47 2014 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,528 +0,0 @@
-/*
- * Copyright (c) 2004, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package com.sun.corba.se.impl.encoding;
-
-import java.io.IOException;
-import java.io.Serializable;
-import java.math.BigDecimal;
-import java.nio.ByteBuffer;
-
-import org.omg.CORBA.TypeCode;
-import org.omg.CORBA.Principal;
-import org.omg.CORBA.Any;
-
-import com.sun.org.omg.SendingContext.CodeBase;
-
-import com.sun.corba.se.pept.protocol.MessageMediator;
-
-import com.sun.corba.se.spi.logging.CORBALogDomains;
-import com.sun.corba.se.spi.orb.ORB;
-import com.sun.corba.se.spi.ior.iiop.GIOPVersion;
-import com.sun.corba.se.spi.protocol.CorbaMessageMediator;
-
-import com.sun.corba.se.impl.logging.ORBUtilSystemException;
-import com.sun.corba.se.impl.encoding.CodeSetConversion;
-import com.sun.corba.se.impl.encoding.OSFCodeSetRegistry;
-
-/**
- * This is delegates to the real implementation.
- *
- * NOTE:
- *
- * Before using the stream for valuetype unmarshaling, one must call
- * performORBVersionSpecificInit().
- */
-public abstract class CDRInputStream
-    extends org.omg.CORBA_2_3.portable.InputStream
-    implements com.sun.corba.se.impl.encoding.MarshalInputStream,
-               org.omg.CORBA.DataInputStream, org.omg.CORBA.portable.ValueInputStream
-{
-    protected CorbaMessageMediator messageMediator;
-    private CDRInputStreamBase impl;
-
-    // We can move this out somewhere later.  For now, it serves its purpose
-    // to create a concrete CDR delegate based on the GIOP version.
-    private static class InputStreamFactory {
-        
-        public static CDRInputStreamBase newInputStream(ORB orb, GIOPVersion version)
-        {
-            switch(version.intValue()) {
-                case GIOPVersion.VERSION_1_0:
-                    return new CDRInputStream_1_0();
-                case GIOPVersion.VERSION_1_1:
-                    return new CDRInputStream_1_1();
-                case GIOPVersion.VERSION_1_2:
-                    return new CDRInputStream_1_2();
-                default:
-		    ORBUtilSystemException wrapper = ORBUtilSystemException.get( orb,
-			CORBALogDomains.RPC_ENCODING ) ;
-		    throw wrapper.unsupportedGiopVersion( version ) ;
-            }
-        }
-    }
-
-    // Required for the case when a ClientResponseImpl is
-    // created with a SystemException due to a dead server/closed
-    // connection with no warning.  Note that the stream will
-    // not be initialized in this case.
-    // 
-    // Probably also required by ServerRequestImpl.
-    // 
-    // REVISIT.
-    public CDRInputStream() {
-    }
-
-    public CDRInputStream(CDRInputStream is) {
-        impl = is.impl.dup();
-        impl.setParent(this);
-    }
-
-    public CDRInputStream(org.omg.CORBA.ORB orb,
-                          ByteBuffer byteBuffer,
-                          int size,
-                          boolean littleEndian,
-                          GIOPVersion version,
-                          BufferManagerRead bufMgr)
-    {
-        impl = InputStreamFactory.newInputStream( (ORB)orb, version);
-
-        impl.init(orb, byteBuffer, size, littleEndian, bufMgr);
-
-        impl.setParent(this);
-    }
-
-    // org.omg.CORBA.portable.InputStream
-    public final boolean read_boolean() {
-        return impl.read_boolean();
-    }
-
-    public final char read_char() {
-        return impl.read_char();
-    }
-
-    public final char read_wchar() {
-        return impl.read_wchar();
-    }
-
-    public final byte read_octet() {
-        return impl.read_octet();
-    }
-
-    public final short read_short() {
-        return impl.read_short();
-    }
-
-    public final short read_ushort() {
-        return impl.read_ushort();
-    }
-
-    public final int read_long() {
-        return impl.read_long();
-    }
-
-    public final int read_ulong() {
-        return impl.read_ulong();
-    }
-
-    public final long read_longlong() {
-        return impl.read_longlong();
-    }
-
-    public final long read_ulonglong() {
-        return impl.read_ulonglong();
-    }
-
-    public final float read_float() {
-        return impl.read_float();
-    }
-
-    public final double read_double() {
-        return impl.read_double();
-    }
-
-    public final String read_string() {
-        return impl.read_string();
-    }
-
-    public final String read_wstring() {
-        return impl.read_wstring();
-    }
-
-    public final void read_boolean_array(boolean[] value, int offset, int length) {
-        impl.read_boolean_array(value, offset, length);
-    }
-
-    public final void read_char_array(char[] value, int offset, int length) {
-        impl.read_char_array(value, offset, length);
-    }
-
-    public final void read_wchar_array(char[] value, int offset, int length) {
-        impl.read_wchar_array(value, offset, length);
-    }
-
-    public final void read_octet_array(byte[] value, int offset, int length) {
-        impl.read_octet_array(value, offset, length);
-    }
-
-    public final void read_short_array(short[] value, int offset, int length) {
-        impl.read_short_array(value, offset, length);
-    }
-
-    public final void read_ushort_array(short[] value, int offset, int length) {
-        impl.read_ushort_array(value, offset, length);
-    }
-
-    public final void read_long_array(int[] value, int offset, int length) {
-        impl.read_long_array(value, offset, length);
-    }
-
-    public final void read_ulong_array(int[] value, int offset, int length) {
-        impl.read_ulong_array(value, offset, length);
-    }
-
-    public final void read_longlong_array(long[] value, int offset, int length) {
-        impl.read_longlong_array(value, offset, length);
-    }
-
-    public final void read_ulonglong_array(long[] value, int offset, int length) {
-        impl.read_ulonglong_array(value, offset, length);
-    }
-
-    public final void read_float_array(float[] value, int offset, int length) {
-        impl.read_float_array(value, offset, length);
-    }
-
-    public final void read_double_array(double[] value, int offset, int length) {
-        impl.read_double_array(value, offset, length);
-    }
-
-    public final org.omg.CORBA.Object read_Object() {
-        return impl.read_Object();
-    }
-
-    public final TypeCode read_TypeCode() {
-        return impl.read_TypeCode();
-    }
-    public final Any read_any() {
-        return impl.read_any();
-    }
-
-    public final Principal read_Principal() {
-        return impl.read_Principal();
-    }
-
-    public final int read() throws java.io.IOException {
-        return impl.read();
-    }
-
-    public final java.math.BigDecimal read_fixed() {
-        return impl.read_fixed();
-    }
-
-    public final org.omg.CORBA.Context read_Context() {
-        return impl.read_Context();
-    }
-
-    public final org.omg.CORBA.Object read_Object(java.lang.Class clz) {
-        return impl.read_Object(clz);
-    }
-
-    public final org.omg.CORBA.ORB orb() {
-        return impl.orb();
-    }
-
-    // org.omg.CORBA_2_3.portable.InputStream
-    public final java.io.Serializable read_value() {
-        return impl.read_value();
-    }
-
-    public final java.io.Serializable read_value(java.lang.Class clz) {
-        return impl.read_value(clz);
-    }
-
-    public final java.io.Serializable read_value(org.omg.CORBA.portable.BoxedValueHelper factory) {
-        return impl.read_value(factory);
-    }
-
-    public final java.io.Serializable read_value(java.lang.String rep_id) {
-        return impl.read_value(rep_id);
-    }
-
-    public final java.io.Serializable read_value(java.io.Serializable value) {
-        return impl.read_value(value);
-    }
-
-    public final java.lang.Object read_abstract_interface() {
-        return impl.read_abstract_interface();
-    }
-
-    public final java.lang.Object read_abstract_interface(java.lang.Class clz) {
-        return impl.read_abstract_interface(clz);
-    }
-    // com.sun.corba.se.impl.encoding.MarshalInputStream
-
-    public final void consumeEndian() {
-        impl.consumeEndian();
-    }
-
-    public final int getPosition() {
-        return impl.getPosition();
-    }
-
-    // org.omg.CORBA.DataInputStream
-
-    public final java.lang.Object read_Abstract () {
-        return impl.read_Abstract();
-    }
-
-    public final java.io.Serializable read_Value () {
-        return impl.read_Value();
-    }
-
-    public final void read_any_array (org.omg.CORBA.AnySeqHolder seq, int offset, int length) {
-        impl.read_any_array(seq, offset, length);
-    }
-
-    public final void read_boolean_array (org.omg.CORBA.BooleanSeqHolder seq, int offset, int length) {
-        impl.read_boolean_array(seq, offset, length);
-    }
-
-    public final void read_char_array (org.omg.CORBA.CharSeqHolder seq, int offset, int length) {
-        impl.read_char_array(seq, offset, length);
-    }
-
-    public final void read_wchar_array (org.omg.CORBA.WCharSeqHolder seq, int offset, int length) {
-        impl.read_wchar_array(seq, offset, length);
-    }
-
-    public final void read_octet_array (org.omg.CORBA.OctetSeqHolder seq, int offset, int length) {
-        impl.read_octet_array(seq, offset, length);
-    }
-
-    public final void read_short_array (org.omg.CORBA.ShortSeqHolder seq, int offset, int length) {
-        impl.read_short_array(seq, offset, length);
-    }
-
-    public final void read_ushort_array (org.omg.CORBA.UShortSeqHolder seq, int offset, int length) {
-        impl.read_ushort_array(seq, offset, length);
-    }
-
-    public final void read_long_array (org.omg.CORBA.LongSeqHolder seq, int offset, int length) {
-        impl.read_long_array(seq, offset, length);
-    }
-
-    public final void read_ulong_array (org.omg.CORBA.ULongSeqHolder seq, int offset, int length) {
-        impl.read_ulong_array(seq, offset, length);
-    }
-
-    public final void read_ulonglong_array (org.omg.CORBA.ULongLongSeqHolder seq, int offset, int length) {
-        impl.read_ulonglong_array(seq, offset, length);
-    }
-
-    public final void read_longlong_array (org.omg.CORBA.LongLongSeqHolder seq, int offset, int length) {
-        impl.read_longlong_array(seq, offset, length);
-    }
-
-    public final void read_float_array (org.omg.CORBA.FloatSeqHolder seq, int offset, int length) {
-        impl.read_float_array(seq, offset, length);
-    }
-
-    public final void read_double_array (org.omg.CORBA.DoubleSeqHolder seq, int offset, int length) {
-        impl.read_double_array(seq, offset, length);
-    }
-
-    // org.omg.CORBA.portable.ValueBase
-    public final String[] _truncatable_ids() {
-        return impl._truncatable_ids();
-    }
-
-    // java.io.InputStream
-    public final int read(byte b[]) throws IOException {
-        return impl.read(b);
-    }
-
-    public final int read(byte b[], int off, int len) throws IOException {
-        return impl.read(b, off, len);
-    }
-
-    public final long skip(long n) throws IOException {
-        return impl.skip(n);
-    }
-
-    public final int available() throws IOException {
-        return impl.available();
-    }
-
-    public final void close() throws IOException {
-        impl.close();
-    }
-
-    public final void mark(int readlimit) {
-        impl.mark(readlimit);
-    }
-
-    public final void reset() {
-        impl.reset();
-    }
-
-    public final boolean markSupported() {
-        return impl.markSupported();
-    }
-
-    public abstract CDRInputStream dup();
-
-    // Needed by TCUtility
-    public final java.math.BigDecimal read_fixed(short digits, short scale) {
-        return impl.read_fixed(digits, scale);
-    }
-
-    public final boolean isLittleEndian() {
-        return impl.isLittleEndian();
-    }
-
-    protected final ByteBuffer getByteBuffer() {
-        return impl.getByteBuffer();
-    }
-
-    protected final void setByteBuffer(ByteBuffer byteBuffer) {
-        impl.setByteBuffer(byteBuffer);
-    }
-
-    protected final void setByteBufferWithInfo(ByteBufferWithInfo bbwi) {
-        impl.setByteBufferWithInfo(bbwi);
-    }
-
-    public final int getBufferLength() {
-        return impl.getBufferLength();
-    }
-
-    protected final void setBufferLength(int value) {
-        impl.setBufferLength(value);
-    }
-
-    protected final int getIndex() {
-        return impl.getIndex();
-    }
-
-    protected final void setIndex(int value) {
-        impl.setIndex(value);
-    }
-
-    public final void orb(org.omg.CORBA.ORB orb) {
-        impl.orb(orb);
-    }
-
-    public final GIOPVersion getGIOPVersion() {
-        return impl.getGIOPVersion();
-    }
-
-    public final BufferManagerRead getBufferManager() {
-        return impl.getBufferManager();
-    }
-
-    // This should be overridden by any stream (ex: IIOPInputStream)
-    // which wants to read values.  Thus, TypeCodeInputStream doesn't
-    // have to do this.
-    public CodeBase getCodeBase() {
-        return null;
-    }
-
-    // Use Latin-1 for GIOP 1.0 or when code set negotiation was not
-    // performed.
-    protected CodeSetConversion.BTCConverter createCharBTCConverter() {
-        return CodeSetConversion.impl().getBTCConverter(OSFCodeSetRegistry.ISO_8859_1,
-                                                        impl.isLittleEndian());
-    }
-
-    // Subclasses must decide what to do here.  It's inconvenient to
-    // make the class and this method abstract because of dup().
-    protected abstract CodeSetConversion.BTCConverter createWCharBTCConverter();
-
-    // Prints the current buffer in a human readable form
-    void printBuffer() {
-        impl.printBuffer();
-    }
-
-    /**
-     * Aligns the current position on the given octet boundary
-     * if there are enough bytes available to do so.  Otherwise,
-     * it just returns.  This is used for some (but not all)
-     * GIOP 1.2 message headers.
-     */
-    public void alignOnBoundary(int octetBoundary) {
-        impl.alignOnBoundary(octetBoundary);
-    }
-
-    // Needed by request and reply messages for GIOP versions >= 1.2 only.
-    public void setHeaderPadding(boolean headerPadding) {
-        impl.setHeaderPadding(headerPadding);
-    }
-    
-    /**
-     * This must be called after determining the proper ORB version,
-     * and setting it on the stream's ORB instance.  It can be called
-     * after reading the service contexts, since that is the only place
-     * we can get the ORB version info.
-     *
-     * Trying to unmarshal things requiring repository IDs before calling
-     * this will result in NullPtrExceptions.
-     */
-    public void performORBVersionSpecificInit() {
-        // In the case of SystemExceptions, a stream is created
-        // with its default constructor (and thus no impl is set).
-        if (impl != null)
-            impl.performORBVersionSpecificInit();
-    }
-
-    /**
-     * Resets any internal references to code set converters.
-     * This is useful for forcing the CDR stream to reacquire
-     * converters (probably from its subclasses) when state
-     * has changed.
-     */
-    public void resetCodeSetConverters() {
-        impl.resetCodeSetConverters();
-    }
-
-    public void setMessageMediator(MessageMediator messageMediator)
-    {
-        this.messageMediator = (CorbaMessageMediator) messageMediator;
-    }
-
-    public MessageMediator getMessageMediator()
-    {
-        return messageMediator;
-    }
-
-    // ValueInputStream -----------------------------
-
-    public void start_value() {
-        impl.start_value();
-    }
-
-    public void end_value() {
-        impl.end_value();
-    }
-}
--- ./corba/src/share/classes/com/sun/corba/se/impl/copyobject/JavaOutputStream.sjava	Tue Mar 18 12:29:47 2014 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,435 +0,0 @@
-/*
- * Copyright (c) 2004, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package com.sun.corba.se.impl.encoding;
-
-import java.io.IOException;
-import java.io.Serializable;
-import java.math.BigDecimal;
-import java.nio.ByteBuffer;
-
-import org.omg.CORBA.TypeCode;
-import org.omg.CORBA.Principal;
-import org.omg.CORBA.Any;
-
-import com.sun.corba.se.pept.protocol.MessageMediator;
-
-import com.sun.corba.se.spi.orb.ORB;
-import com.sun.corba.se.spi.logging.CORBALogDomains;
-import com.sun.corba.se.spi.ior.iiop.GIOPVersion;
-import com.sun.corba.se.spi.protocol.CorbaMessageMediator;
-
-import com.sun.corba.se.impl.encoding.CodeSetConversion;
-import com.sun.corba.se.impl.encoding.OSFCodeSetRegistry;
-import com.sun.corba.se.impl.orbutil.ORBConstants;
-import com.sun.corba.se.impl.logging.ORBUtilSystemException;
-
-/**
- * This is delegates to the real implementation.
- */
-public abstract class CDROutputStream
-    extends org.omg.CORBA_2_3.portable.OutputStream
-    implements com.sun.corba.se.impl.encoding.MarshalOutputStream,
-               org.omg.CORBA.DataOutputStream, org.omg.CORBA.portable.ValueOutputStream
-{
-/*
-    private CDROutputStreamBase impl;
-    protected ORB orb ;
-    protected ORBUtilSystemException wrapper ;
-    protected CorbaMessageMediator corbaMessageMediator;
-
-
-    // We can move this out somewhere later.  For now, it serves its purpose
-    // to create a concrete CDR delegate based on the GIOP version.
-    private static class OutputStreamFactory {
-        
-        public static CDROutputStreamBase newOutputStream(ORB orb, GIOPVersion version)
-        {
-            switch(version.intValue()) {
-                case GIOPVersion.VERSION_1_0:
-                    return new CDROutputStream_1_0();
-                case GIOPVersion.VERSION_1_1:
-                    return new CDROutputStream_1_1();
-                case GIOPVersion.VERSION_1_2:
-                    return new CDROutputStream_1_2();
-                default:
-		    ORBUtilSystemException wrapper = ORBUtilSystemException.get( orb,
-			CORBALogDomains.RPC_ENCODING ) ;
-                    // REVISIT - what is appropriate?  INTERNAL exceptions
-                    // are really hard to track later.
-		    throw wrapper.unsupportedGiopVersion( version ) ;
-            }
-        }
-    }
-
-    // REVISIT - These two constructors should be re-factored to better hide
-    // the fact that someone extending this class 'can' construct a CDROutputStream
-    // that does not use pooled ByteBuffers. Right now, only EncapsOutputStream
-    // does _not_ use pooled ByteBuffers, see EncapsOutputStream.
-
-    // NOTE: When a stream is constructed for non-channel-backed sockets
-    // it notifies the constructor not to use pooled (i.e, direct)
-    // ByteBuffers.
-
-    public CDROutputStream(ORB orb,
-                           GIOPVersion version,
-			   boolean littleEndian,
-			   BufferManagerWrite bufferManager,
-                           byte streamFormatVersion,
-                           boolean usePooledByteBuffers)
-    {
-        impl = OutputStreamFactory.newOutputStream(orb, version);
-        impl.init(orb, littleEndian, bufferManager, streamFormatVersion, usePooledByteBuffers);
-
-        impl.setParent(this);
-	this.orb = orb ;
-	this.wrapper = ORBUtilSystemException.get( orb,
-	    CORBALogDomains.RPC_ENCODING ) ;
-    }
-
-    public CDROutputStream(ORB orb,
-                           GIOPVersion version,
-			   boolean littleEndian,
-			   BufferManagerWrite bufferManager,
-                           byte streamFormatVersion)
-    {
-        this(orb, version, littleEndian, bufferManager, streamFormatVersion, true);
-    }
-*/
-
-    private ByteArrayOutputStream bos ;
-    private ObjectOutputStream oos ;
-
-    public JavaOutputStream() 
-    {
-	bos = new ByteArrayOutputStream() ;
-	oos = new ObjectOutputStream( bos ) ;
-    }
-
-    // Provided by IIOPOutputStream and EncapsOutputStream
-    public org.omg.CORBA.portable.InputStream create_input_stream()
-    {
-	ObjectInputStream ois = new ByteArrayInputStream( bos.toByteArray() ) ;
-	    
-	return new JavaInputStream( ois ) ;
-    }
-
-    public final void write_boolean(boolean value) {
-        impl.write_boolean(value);
-    }
-    public final void write_char(char value) {
-        impl.write_char(value);
-    }
-    public final void write_wchar(char value) {
-        impl.write_wchar(value);
-    }
-    public final void write_octet(byte value) {
-        impl.write_octet(value);
-    }
-    public final void write_short(short value) {
-        impl.write_short(value);
-    }
-    public final void write_ushort(short value) {
-        impl.write_ushort(value);
-    }
-    public final void write_long(int value) {
-        impl.write_long(value);
-    }
-    public final void write_ulong(int value) {
-        impl.write_ulong(value);
-    }
-    public final void write_longlong(long value) {
-        impl.write_longlong(value);
-    }
-    public final void write_ulonglong(long value) {
-        impl.write_ulonglong(value);
-    }
-    public final void write_float(float value) {
-        impl.write_float(value);
-    }
-    public final void write_double(double value) {
-        impl.write_double(value);
-    }
-    public final void write_string(String value) {
-        impl.write_string(value);
-    }
-    public final void write_wstring(String value) {
-        impl.write_wstring(value);
-    }
-
-    public final void write_boolean_array(boolean[] value, int offset, int length) {
-        impl.write_boolean_array(value, offset, length);
-    }
-    public final void write_char_array(char[] value, int offset, int length) {
-        impl.write_char_array(value, offset, length);
-    }
-    public final void write_wchar_array(char[] value, int offset, int length) {
-        impl.write_wchar_array(value, offset, length);
-    }
-    public final void write_octet_array(byte[] value, int offset, int length) {
-        impl.write_octet_array(value, offset, length);
-    }
-    public final void write_short_array(short[] value, int offset, int length) {
-        impl.write_short_array(value, offset, length);
-    }
-    public final void write_ushort_array(short[] value, int offset, int length){
-        impl.write_ushort_array(value, offset, length);
-    }
-    public final void write_long_array(int[] value, int offset, int length) {
-        impl.write_long_array(value, offset, length);
-    }
-    public final void write_ulong_array(int[] value, int offset, int length) {
-        impl.write_ulong_array(value, offset, length);
-    }
-    public final void write_longlong_array(long[] value, int offset, int length) {
-        impl.write_longlong_array(value, offset, length);
-    }
-    public final void write_ulonglong_array(long[] value, int offset,int length) {
-        impl.write_ulonglong_array(value, offset, length);
-    }
-    public final void write_float_array(float[] value, int offset, int length) {
-        impl.write_float_array(value, offset, length);
-    }
-    public final void write_double_array(double[] value, int offset, int length) {
-        impl.write_double_array(value, offset, length);
-    }
-    public final void write_Object(org.omg.CORBA.Object value) {
-        impl.write_Object(value);
-    }
-    public final void write_TypeCode(TypeCode value) {
-        impl.write_TypeCode(value);
-    }
-    public final void write_any(Any value) {
-        impl.write_any(value);
-    }
-
-    public final void write_Principal(Principal value) {
-        impl.write_Principal(value);
-    }
-
-    public final void write(int b) throws java.io.IOException {
-        impl.write(b);
-    }
-    
-    public final void write_fixed(java.math.BigDecimal value) {
-        impl.write_fixed(value);
-    }
-
-    public final void write_Context(org.omg.CORBA.Context ctx,
-			      org.omg.CORBA.ContextList contexts) {
-        impl.write_Context(ctx, contexts);
-    }
-
-    public final org.omg.CORBA.ORB orb() {
-        return impl.orb();
-    }
-
-    // org.omg.CORBA_2_3.portable.OutputStream
-    public final void write_value(java.io.Serializable value) {
-        impl.write_value(value);
-    }
-
-    public final void write_value(java.io.Serializable value, java.lang.Class clz) {
-        impl.write_value(value, clz);
-    }
-
-    public final void write_value(java.io.Serializable value, String repository_id) {
-        impl.write_value(value, repository_id);
-    }
-
-    public final void write_value(java.io.Serializable value, 
-                            org.omg.CORBA.portable.BoxedValueHelper factory) {
-        impl.write_value(value, factory);
-    }
-
-    public final void write_abstract_interface(java.lang.Object obj) {
-        impl.write_abstract_interface(obj);
-    }
-
-    // java.io.OutputStream
-    public final void write(byte b[]) throws IOException {
-        impl.write(b);
-    }
-
-    public final void write(byte b[], int off, int len) throws IOException {
-        impl.write(b, off, len);
-    }
-
-    public final void flush() throws IOException {
-        impl.flush();
-    }
-
-    public final void close() throws IOException {
-        impl.close();
-    }
-
-    // com.sun.corba.se.impl.encoding.MarshalOutputStream
-    public final void start_block() {
-        impl.start_block();
-    }
-
-    public final void end_block() {
-        impl.end_block();
-    }
-
-    public final void putEndian() {
-        impl.putEndian();
-    }
-
-    public void writeTo(java.io.OutputStream s)
-	throws IOException 
-    {
-        impl.writeTo(s);
-    }
-
-    public final byte[] toByteArray() {
-        return impl.toByteArray();
-    }
-
-    // org.omg.CORBA.DataOutputStream
-    public final void write_Abstract (java.lang.Object value) {
-        impl.write_Abstract(value);
-    }
-
-    public final void write_Value (java.io.Serializable value) {
-        impl.write_Value(value);
-    }
-
-    public final void write_any_array(org.omg.CORBA.Any[] seq, int offset, int length) {
-        impl.write_any_array(seq, offset, length);
-    }
-
-    public void setMessageMediator(MessageMediator messageMediator)
-    {
-        this.corbaMessageMediator = (CorbaMessageMediator) messageMediator;
-    }
-
-    public MessageMediator getMessageMediator()
-    {
-        return corbaMessageMediator;
-    }
-
-    // org.omg.CORBA.portable.ValueBase
-    public final String[] _truncatable_ids() {
-        return impl._truncatable_ids();
-    }
-
-    // Other
-    protected final int getSize() {
-        return impl.getSize();
-    }
-
-    protected final int getIndex() {
-        return impl.getIndex();
-    }
-
-    protected int getRealIndex(int index) {
-        // Used in indirections. Overridden by TypeCodeOutputStream.
-        return index;
-    }
-
-    protected final void setIndex(int value) {
-        impl.setIndex(value);
-    }
-
-    protected final ByteBuffer getByteBuffer() {
-        return impl.getByteBuffer();
-    }
-
-    protected final void setByteBuffer(ByteBuffer byteBuffer) {
-        impl.setByteBuffer(byteBuffer);
-    }
-
-    public final boolean isLittleEndian() {
-        return impl.isLittleEndian();
-    }
-
-    // XREVISIT - return to final if possible
-    // REVISIT - was protected - need access from msgtypes test.
-    public ByteBufferWithInfo getByteBufferWithInfo() {
-        return impl.getByteBufferWithInfo();
-    }
-
-    protected void setByteBufferWithInfo(ByteBufferWithInfo bbwi) {
-        impl.setByteBufferWithInfo(bbwi);
-    }
-
-    // REVISIT: was protected - but need to access from xgiop.
-    public final BufferManagerWrite getBufferManager() {
-        return impl.getBufferManager();
-    }
-
-    public final void write_fixed(java.math.BigDecimal bigDecimal, short digits, short scale) {
-        impl.write_fixed(bigDecimal, digits, scale);
-    }
-
-    public final void writeOctetSequenceTo(org.omg.CORBA.portable.OutputStream s) {
-        impl.writeOctetSequenceTo(s);
-    }
-
-    public final GIOPVersion getGIOPVersion() {
-        return impl.getGIOPVersion();
-    }
-
-    public final void writeIndirection(int tag, int posIndirectedTo) {
-        impl.writeIndirection(tag, posIndirectedTo);
-    }
-
-    // Use Latin-1 for GIOP 1.0 or when code set negotiation was not
-    // performed.
-    protected CodeSetConversion.CTBConverter createCharCTBConverter() {
-        return CodeSetConversion.impl().getCTBConverter(OSFCodeSetRegistry.ISO_8859_1);
-    }
-
-    // Subclasses must decide what to do here.  It's inconvenient to
-    // make the class and this method abstract because of dup().
-    protected abstract CodeSetConversion.CTBConverter createWCharCTBConverter();
-
-    protected final void freeInternalCaches() {
-        impl.freeInternalCaches();
-    }
-
-    void printBuffer() {
-        impl.printBuffer();
-    }
-
-    public void alignOnBoundary(int octetBoundary) {
-        impl.alignOnBoundary(octetBoundary);
-    }
-
-    // Needed by request and reply messages for GIOP versions >= 1.2 only.
-    public void setHeaderPadding(boolean headerPadding) {
-        impl.setHeaderPadding(headerPadding);
-    }
-
-    // ValueOutputStream -----------------------------
-
-    public void start_value(String rep_id) {
-        impl.start_value(rep_id);
-    }
-
-    public void end_value() {
-        impl.end_value();
-    }
-}
--- ./corba/src/share/classes/com/sun/corba/se/impl/interceptors/ThreadCurrentStack.sjava	Tue Mar 18 12:29:47 2014 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,164 +0,0 @@
-/*
- * Copyright (c) 2000, 2002, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package com.sun.corba.se.impl.interceptors;
-
-import com.sun.corba.se.impl.corba.AnyImpl;
-import org.omg.PortableInterceptor.Current;
-import org.omg.PortableInterceptor.InvalidSlot;
-
-import com.sun.corba.se.impl.util.MinorCodes;
-import com.sun.corba.se.impl.core.ORB;
-
-/**
- * ThreadCurrentStack is the container of PICurrent instances for each thread
- */
-public class ThreadCurrentStack
-{
-    // PICurrentPool is the container for reusable PICurrents
-    private class PICurrentPool {
-
-        // Contains a list of reusable PICurrents
-        private java.util.ArrayList pool;
-
-        // High water mark for the pool
-        // If the pool size reaches this limit then putPICurrent will
-        // not put PICurrent to the pool.
-        private static final int  HIGH_WATER_MARK = 5;
-
-        // currentIndex points to the last PICurrent in the list
-        private int currentIndex;
-
-        PICurrentPool( ) {
-            pool = new java.util.ArrayList( HIGH_WATER_MARK );
-            currentIndex = 0;
-        }
-
-        /**
-         * Puts PICurrent to the re-usable pool.
-         */
-        void putPICurrent( PICurrent current ) {
-            // If there are enough PICurrents in the pool, then don't add
-            // this current to the pool.
-            if( currentIndex >= HIGH_WATER_MARK ) {
-                return;
-            }
-            pool.add(currentIndex , current);
-            currentIndex++;
-        }
-
-        /**
-         * Gets PICurrent from the re-usable pool.
-         */
-        PICurrent getPICurrent( ) {
-            // If there are no entries in the pool then return null
-            if( currentIndex == 0 ) {
-                return null;
-            }
-            // Works like a stack, Gets the last one added first
-            currentIndex--;
-            return (PICurrent) pool.get(currentIndex);
-        }
-    }
-   
-    // Contains all the active PICurrents for each thread.
-    // The ArrayList is made to behave like a stack.
-    private java.util.ArrayList currentContainer;
-
-    // Keeps track of number of PICurrents in the stack.
-    private int currentIndex;
- 
-    // For Every Thread there will be a pool of re-usable ThreadCurrent's
-    // stored in PICurrentPool
-    private PICurrentPool currentPool;
-
-    // The orb associated with this ThreadCurrentStack
-    private ORB piOrb;
-
-    /**
-     * Constructs the stack and and PICurrentPool
-     */
-    ThreadCurrentStack( ORB piOrb, PICurrent current ) {
-       this.piOrb = piOrb;
-       currentIndex = 0;
-       currentContainer = new java.util.ArrayList( );
-       currentPool = new PICurrentPool( );
-       currentContainer.add( currentIndex, current );
-       currentIndex++;
-    }
-   
-
-    /**
-     * pushPICurrent goes through the following steps
-     * 1: Checks to see if there is any PICurrent in PICurrentPool
-     *    If present then use that instance to push into the ThreadCurrentStack
-     *
-     * 2:If there is no PICurrent in the pool, then creates a new one and pushes
-     *    that into the ThreadCurrentStack
-     */
-    void pushPICurrent( ) {
-        PICurrent current = currentPool.getPICurrent( );
-        if( current == null ) {
-            // get an existing PICurrent to get the slotSize
-            PICurrent currentTemp = peekPICurrent();
-            current = new PICurrent( piOrb, currentTemp.getSlotSize( ));
-        }
-        currentContainer.add( currentIndex, current );
-        currentIndex++;
-    }
-
-    /**
-     * popPICurrent does the following
-     * 1: pops the top PICurrent in the ThreadCurrentStack
-     *
-     * 2: resets the slots in the PICurrent which resets the slotvalues to
-     *    null if there are any previous sets. 
-     *
-     * 3: pushes the reset PICurrent into the PICurrentPool to reuse 
-     */
-    void  popPICurrent( ) {
-        // Do not pop the PICurrent, If there is only one.
-        // This should not happen, But an extra check for safety.
-        if( currentIndex <= 1 ) {
-            throw new org.omg.CORBA.INTERNAL( 
-                      "Cannot pop the only PICurrent in the stack",
-		      MinorCodes.CANT_POP_ONLY_CURRENT_2,
-		      CompletionStatus.COMPLETED_NO );
-        }
-        currentIndex--;
-        PICurrent current = (PICurrent)currentContainer.get( currentIndex );
-        current.resetSlots( );
-        currentPool.putPICurrent( current );
-    }
-
-    /**
-     * peekPICurrent gets the top PICurrent in the ThreadCurrentStack without
-     * popping.
-     */
-    PICurrent peekPICurrent( ) {
-       return (PICurrent) currentContainer.get( currentIndex - 1);
-    }
-
-}
--- ./corba/src/share/classes/com/sun/corba/se/impl/orbutil/DefineWrapper.sjava	Tue Mar 18 12:29:47 2014 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,120 +0,0 @@
-package com.sun.corba.se.impl.orbutil ;
-
-import java.lang.reflect.Method;
-import java.lang.reflect.Modifier;
-
-/** This class provides just a main method.  Its purpose is to allow -D arguments to
-* set up the system properties when starting programs with tools like OptimizeIt that
-* make this difficult or impossible.
-*
-* Invocation: {java launcher of some kind} DefineClass -Dxxx=yyy -Dxxx=yyy ... {class name} arg0, arg1, ...
-* Result: updates system properties with -D args, then uses reflection to invoke {class name}.main with the args
-*/
-
-class DefineWrapper {
-    public static void main( String[] args )
-    {
-	int numberDefines = args.length ;
-	String className = null ;
-
-	for (int ctr=0; ctr<args.length; ctr++ ) {
-	    String arg = args[ctr] ;
-
-	    if ((arg.charAt(0) == '-') && (arg.charAt(1) == 'D')) {
-		int eqIndex =  arg.indexOf( '=' ) ;
-		if (eqIndex < 0)
-		    throw new Exception( arg + " is not a valid property assignment" ) ;
-
-		final String key = arg.subString( 2, eqIndex ) ;
-		final String value = arg.subStrung( eqIndex + 1 ) ;
-
-		AccessController.doPrivileged( new PrivilegedAction() {
-			public Object run() {
-			    System.setProperty( key, value ) ;
-			    return null ;
-			}
-		    } ) ;
-	    } else {
-		numberDefines = ctr ;
-		className = arg ;
-		break ;
-	    }
-	}
-
-	if (numberDefines < args.length) {
-	    Class cls = getMainClass( className ) ;
-	    Method mainMethod = getMainMethod( cls ) ;
-
-	    String[] newArgs = new String[ args.length - numberDefines ] ;
-	    for (int ctr = numberDefines+1; ctr<args.length; ctr++ ) {
-		newArgs[ ctr-numberDefines-1 ] = args[ ctr ] ;
-	    }
-		
-	    // build args to the main and call it
-	    Object params [] = new Object [1];
-	    params[0] = newArgs;
-	    mainMethod.invoke(null, params);
-	} else {
-	    throw new Exception( "No class name given" ) ;
-	}
-    }
-
-    private static Class getMainClass( String name ) 
-    {
-	// determine the class loader to be used for loading the class
-	// since ServerMain is going to be in JDK and we need to have this
-	// class to load application classes, this is required here.
-	ClassLoader cl = Thread.currentThread().getContextClassLoader();
-
-	if (cl == null)
-	    cl = ClassLoader.getSystemClassLoader();
-
-	try {
-	    // determine the main class, try loading with current class loader
-	    cls = Class.forName( className ) ;
-	} catch (ClassNotFoundException ex) {
-	    // eat the exception and try to load using SystemClassLoader
-	    cls = Class.forName( className, true, cl);
-	}
-    }
-
-    private static Method getMainMethod( Class serverClass ) 
-    {
-	Class argTypes[] = new Class[] { String[].class } ;
-	Method method = null ;
-
-	try {
-	    method = serverClass.getDeclaredMethod( "main", argTypes ) ;
-	} catch (Exception exc) {
-	    throw new Exception( "Could not get main() method: " + exc ) ;
-	} 
-
-	if (!isPublicStaticVoid( method ))
-	    throw new Exception( "Main method is not public static void" ) ;
-	
-	return method ;
-    }
-
-    private static boolean isPublicStaticVoid( Method method ) 
-    {
-	// check modifiers: public static
-	int modifiers =  method.getModifiers ();
-	if (!Modifier.isPublic (modifiers) || !Modifier.isStatic (modifiers)) {
-	    logError( method.getName() + " is not public static" ) ;
-	    return false ;
-	}
-
-	// check return type and exceptions
-	if (method.getExceptionTypes ().length != 0) {
-	    logError( method.getName() + " declares exceptions" ) ;
-	    return false ;
-	}
-
-	if (!method.getReturnType().equals (Void.TYPE)) {
-	    logError( method.getName() + " does not have a void return type" ) ;
-	    return false ;
-	}
-
-	return true ;
-    }
-}
--- ./corba/src/share/classes/com/sun/corba/se/impl/orbutil/resources/sunorb_pt_BR.properties	Tue Mar 18 12:29:47 2014 -0700
+++ ./corba/src/share/classes/com/sun/corba/se/impl/orbutil/resources/sunorb_pt_BR.properties	Wed May 07 19:25:52 2014 -0700
@@ -23,7 +23,7 @@
 # questions.
 #
 
-orbd.usage=Uso: {0} <op\u00E7\u00F5es> \n\nem que <op\u00E7\u00F5es> inclui:\n  -port                  porta de ativa\u00E7\u00E3o na qual o ORBD deve ser iniciado, default 1049 (opcional)\n  -defaultdb             diret\u00F3rio dos arquivos ORBD, default "./orb.db" (opcional)\n  -serverid              id do servidor para ORBD, default 1 (opcional)\n  -ORBInitialPort        porta inicial (obrigat\u00F3rio)\n  -ORBInitialHost        nome de host inicial (obrigat\u00F3rio)\n
+orbd.usage=Uso: {0} <op\u00E7\u00F5es> \n\nem que <op\u00E7\u00F5es> inclui:\n  -port                  porta de ativa\u00E7\u00E3o na qual o ORBD deve ser iniciado, padr\u00E3o 1049 (opcional)\n  -defaultdb             diret\u00F3rio dos arquivos ORBD, padr\u00E3o "./orb.db" (opcional)\n  -serverid              id do servidor para ORBD, padr\u00E3o 1 (opcional)\n  -ORBInitialPort        porta inicial (obrigat\u00F3rio)\n  -ORBInitialHost        nome de host inicial (obrigat\u00F3rio)\n
 
 servertool.usage=Uso: {0} <op\u00E7\u00F5es> \n\nem que <op\u00E7\u00F5es> inclui:\n  -ORBInitialPort        porta inicial (obrigat\u00F3rio)\n  -ORBInitialHost        nome de host inicial (obrigat\u00F3rio)\n
 servertool.banner=\n\nBem-vindo \u00E0 Ferramenta de Servidor IDL Java \ninsira os comandos no prompt \n
--- ./corba/src/share/classes/com/sun/corba/se/impl/presentation/rmi/IDLNameTranslatorImpl_save.sjava	Tue Mar 18 12:29:47 2014 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,909 +0,0 @@
-/*
- * Copyright (c) 2004, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package com.sun.corba.se.impl.presentation.rmi ;
-
-import java.lang.reflect.Method;
-
-import java.math.BigInteger;
-
-import java.util.Map;
-import java.util.Set;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.HashMap;
-import java.util.StringTokenizer;
-
-import com.sun.corba.se.spi.presentation.rmi.IDLNameTranslator ;
-
-import com.sun.corba.se.impl.presentation.rmi.IDLType ;
-import com.sun.corba.se.impl.presentation.rmi.IDLTypeException ;
-import com.sun.corba.se.impl.presentation.rmi.IDLTypesUtil ;
-import com.sun.corba.se.impl.orbutil.ObjectUtility ;
-
-/**
- * Bidirectional translator between RMI-IIOP interface methods and
- * and IDL Names.
- */
-public class IDLNameTranslatorImpl implements IDLNameTranslator {
-
-    // From CORBA Spec, Table 6 Keywords.
-    // Note that since all IDL identifiers are case 
-    // insensitive, java identifier comparisons to these
-    // will be case insensitive also.
-    private static String[] IDL_KEYWORDS = {
-
-        "abstract", "any", "attribute", "boolean", "case", "char",
-        "const", "context", "custom", "default", "double", "enum",
-        "exception", "factory", "FALSE", "fixed", "float", "in", "inout",
-        "interface", "long", "module", "native", "Object", "octet",
-        "oneway", "out", "private", "public", "raises", "readonly", "sequence",
-        "short", "string", "struct", "supports", "switch", "TRUE", "truncatable",
-        "typedef", "unsigned", "union", "ValueBase", "valuetype", "void",
-	"wchar", "wstring"
-
-    };
-
-    private static char[] HEX_DIGITS = {
-        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
-        'A', 'B', 'C', 'D', 'E', 'F' 
-    };
-    
-    private static final String UNDERSCORE = "_";
-
-    // used to mangle java inner class names
-    private static final String INNER_CLASS_SEPARATOR =
-        UNDERSCORE + UNDERSCORE;
-
-    // used to form IDL array type names
-    private static final String[] BASE_IDL_ARRAY_MODULE_TYPE=
-	new String[] { "org", "omg", "boxedRMI" } ;
-
-    private static final String BASE_IDL_ARRAY_ELEMENT_TYPE = "seq";
-
-    // used to mangling java identifiers that have a leading underscore
-    private static final String LEADING_UNDERSCORE_CHAR = "J";
-    private static final String ID_CONTAINER_CLASH_CHAR = UNDERSCORE;
-
-    // separator used between types in a mangled overloaded method name
-    private static final String OVERLOADED_TYPE_SEPARATOR = 
-        UNDERSCORE + UNDERSCORE;
-
-    // string appended to attribute if it clashes with a method name
-    private static final String ATTRIBUTE_METHOD_CLASH_MANGLE_CHARS =
-        UNDERSCORE + UNDERSCORE;
-
-    private static Set idlKeywords_;
-
-    static {
-        
-        idlKeywords_ = new HashSet();
-        for(int i = 0; i < IDL_KEYWORDS.length; i++) {
-            String next = (String) IDL_KEYWORDS[i];
-            // Convert keyword to all caps to ease equality
-            // check.
-            String keywordAllCaps = next.toUpperCase();
-            idlKeywords_.add(keywordAllCaps);
-        }
-
-    }
-
-    //
-    // Instance state
-    //
-    
-    // Remote interface for name translation.  
-    private Class[] interf_;
-
-    // Maps used to hold name translations.  These do not need to be
-    // synchronized since the translation is never modified after
-    // initialization.
-    private Map methodToIDLNameMap_;
-    private Map IDLNameToMethodMap_;
-    private Method[] methods_;
-    
-    /**
-     * Return an IDLNameTranslator for the given interface.  
-     *
-     * @throws IllegalStateException if given class is not a valid 
-     *         RMI/IIOP Remote Interface
-     */
-    public static IDLNameTranslator get( Class interf )
-    {
-        
-        return new IDLNameTranslatorImpl(new Class[] { interf } );
-
-    }
-
-    /**
-     * Return an IDLNameTranslator for the given interfacex.  
-     *
-     * @throws IllegalStateException if given classes are not  valid 
-     *         RMI/IIOP Remote Interfaces
-     */
-    public static IDLNameTranslator get( Class[] interfaces )
-    {
-        
-        return new IDLNameTranslatorImpl(interfaces );
-
-    }
-
-    public static String getExceptionId( Class cls ) 
-    {
-	// Requirements for this method:
-	// 1. cls must be an exception but not a RemoteException.
-	// 2. If cls has an IDL keyword name, an underscore is prepended (1.3.2.2).
-	// 3. If cls jas a leading underscore, J is prepended (1.3.2.3).
-	// 4. If cls has an illegal IDL ident char, it is mapped to UXXXX where
-	//    XXXX is the unicode value in hex of the char (1.3.2.4).
-	// 5. double underscore for inner class (1.3.2.5).
-	// 6. The ID is "IDL:" + name with / separators + ":1.0".
-	IDLType itype = classToIDLType( cls ) ;
-	return itype.getExceptionName() ;
-    }
-
-    public Class[] getInterfaces()
-    {
-        return interf_;
-    }
-
-    public Method[] getMethods()
-    {
-	return methods_ ;
-    }
-
-    public Method getMethod( String idlName ) 
-    {
-        return (Method) IDLNameToMethodMap_.get(idlName);
-    }
-
-    public String getIDLName( Method method ) 
-    {
-        return (String) methodToIDLNameMap_.get(method);
-    }
-
-    /**
-     * Initialize an IDLNameTranslator for the given interface.  
-     *
-     * @throws IllegalStateException if given class is not a valid 
-     *         RMI/IIOP Remote Interface
-     */
-    private IDLNameTranslatorImpl(Class[] interfaces) 
-    {
-
-        try {
-            IDLTypesUtil idlTypesUtil = new IDLTypesUtil();
-	    for (int ctr=0; ctr<interfaces.length; ctr++)
-		idlTypesUtil.validateRemoteInterface(interfaces[ctr]);
-            interf_ = interfaces;
-            buildNameTranslation();
-        } catch( IDLTypeException ite) {
-            String msg = ite.getMessage();
-            IllegalStateException ise = new IllegalStateException(msg);
-            ise.initCause(ite);
-            throw ise;
-        }
-    }
-
-    private void buildNameTranslation() 
-    {
-	// holds method info, keyed by method
-	Map allMethodInfo = new HashMap() ;
-
-	for (int ctr=0; ctr<interf_.length; ctr++) {
-	    Class interf = interf_[ctr] ;
-
-	    IDLTypesUtil idlTypesUtil = new IDLTypesUtil();
-	    Method[] methods = interf.getMethods();
-
-	    // Take an initial pass through all the methods and create some
-	    // information that will be used to track the IDL name 
-	    // transformation.
-	    for(int i = 0; i < methods.length; i++) {
-		
-		Method nextMethod = methods[i];
-
-		IDLMethodInfo methodInfo = new IDLMethodInfo();
-
-		methodInfo.method = nextMethod;           
-
-		methodInfo.propertyType = 
-		    idlTypesUtil.propertyAccessorMethodType(
-			nextMethod, interf ) ;
-
-		if (methodInfo.propertyType != null) {
-		    String attributeName = idlTypesUtil.
-			getAttributeNameForProperty(nextMethod.getName());
-		    methodInfo.originalName = attributeName;
-		    methodInfo.mangledName  = attributeName;               
-		} else {
-		    methodInfo.originalName = nextMethod.getName();
-		    methodInfo.mangledName  = nextMethod.getName();
-		}
-		
-		allMethodInfo.put(nextMethod, methodInfo);
-	    }
-	}
-
-	// Check for having both is<NAME> and get<NAME> methods.
-
-	
-        //
-        // Perform case sensitivity test first.  This applies to all
-        // method names AND attributes.  Compare each method name and 
-        // attribute to all other method names and attributes.  If names 
-        // differ only in case, apply mangling as defined in section 1.3.2.7
-        // of Java2IDL spec.  Note that we compare using the original names.
-        //
-        for(Iterator outerIter=allMethodInfo.values().iterator();
-            outerIter.hasNext();) {
-            IDLMethodInfo outer = (IDLMethodInfo) outerIter.next();           
-            for(Iterator innerIter = allMethodInfo.values().iterator(); 
-                innerIter.hasNext();) {
-                IDLMethodInfo inner = (IDLMethodInfo) innerIter.next();
-
-                if( (outer != inner) &&
-                    (!outer.originalName.equals(inner.originalName)) &&
-                    outer.originalName.equalsIgnoreCase(inner.originalName) ) {
-                    outer.mangledName = 
-                        mangleCaseSensitiveCollision(outer.originalName);
-                    break;
-                }
-
-            }
-        }
-                   
-        for(Iterator iter = allMethodInfo.values().iterator(); 
-            iter.hasNext();) {
-            IDLMethodInfo next = (IDLMethodcurrentInfo) iter.next();           
-            next.mangledName = 
-                mangleIdentifier(next.mangledName, 
-		    next.propertyType != null);
-        }         
-
-        //
-        // Now check for overloaded method names and apply 1.3.2.6.
-        //
-        for(Iterator outerIter=allMethodInfo.values().iterator();
-            outerIter.hasNext();) {
-            IDLMethodInfo outer = (IDLMethodInfo) outerIter.next();
-            if (outer.propertyType != null) {
-                continue;
-            }
-            for(Iterator innerIter = allMethodInfo.values().iterator(); 
-                innerIter.hasNext();) {
-                IDLMethodInfo inner = (IDLMethodInfo) innerIter.next();
-
-                if( (outer != inner) &&
-                    (inner.propertyType == null) &&
-                    outer.originalName.equals(inner.originalName) ) {
-                    outer.mangledName = mangleOverloadedMethod
-                        (outer.mangledName, outer.method);
-                    break;
-                }
-            }
-        }
-       
-        //
-        // Now mangle any properties that clash with method names.
-        //
-        for(Iterator outerIter=allMethodInfo.values().iterator();
-            outerIter.hasNext();) {
-            IDLMethodInfo outer = (IDLMethodInfo) outerIter.next();
-            if(outer.propertyType == null) {
-                continue;
-            }
-            for(Iterator innerIter = allMethodInfo.values().iterator(); 
-                innerIter.hasNext();) {
-                IDLMethodInfo inner = (IDLMethodInfo) innerIter.next();
-                if( (outer != inner) &&
-                    (inner.propertyType == null) &&
-                    outer.mangledName.equals(inner.mangledName) ) {
-                    outer.mangledName = outer.mangledName + 
-                        ATTRIBUTE_METHOD_CLASH_MANGLE_CHARS;
-                    break;
-                }
-            }
-        }
-
-        //
-        // Ensure that no mapped method names clash with mapped name
-        // of container(1.3.2.9).  This is a case insensitive comparison.
-        //
-	for (int ctr=0; ctr<interf_.length; ctr++ ) {
-	    Class interf = interf_[ctr] ;
-	    String mappedContainerName = getMappedContainerName(interf);
-	    for(Iterator iter = allMethodInfo.values().iterator(); 
-		iter.hasNext();) {
-		IDLMethodInfo next = (IDLMethodInfo) iter.next();           
-		if( (next.propertyType == null) &&
-		    identifierClashesWithContainer(mappedContainerName, 
-						   next.mangledName)) {
-		    next.mangledName = mangleContainerClash(next.mangledName);
-		}
-	    }         
-	}
-
-        //
-        // Populate name translation maps.
-        //
-        methodToIDLNameMap_ = new HashMap();
-        IDLNameToMethodMap_ = new HashMap();
-	methods_ = (Method[])allMethodInfo.keySet().toArray( 
-	    new Method[0] ) ;
-
-        for(Iterator iter = allMethodInfo.values().iterator(); 
-            iter.hasNext();) {
-            IDLMethodInfo next = (IDLMethodInfo) iter.next();           
-            String idlName = next.mangledName;
-            if (next.propertyType != null) {                
-		idlName = javaPropertyPrefixToIDL( next.propertyType ) +
-		    next.mangledName ;
-            }
-            
-            methodToIDLNameMap_.put(next.method, idlName);
-
-            // Final check to see if there are any clashes after all the
-            // manglings have been applied.  If so, this is treated as an
-            // invalid interface.  Currently, we do a CASE-SENSITIVE 
-            // comparison since that matches the rmic behavior.  
-            // @@@ Shouldn't this be a case-insensitive check?
-	    // If there is a collision between is<TYPE> and get<TYPE>,
-	    // map only is<TYPE> to an attribute, and leave the
-	    // get<TYPE> method alone.
-            if( IDLNameToMethodMap_.containsKey(idlName) ) {
-                // @@@ I18N
-                Method clash = (Method) IDLNameToMethodMap_.get(idlName);
-		MethodInfo clashMethodInfo = 
-		    (MethodInfo)allMethodInfo.get( clash ) ;
-		if (clashMethodInfo.isBooleanProperty() &&
-		    next.isReadProperty()) {
-		    // fix idlName
-		} else if (clashMethodInfo.isReadProperty() &&
-		    next.isBooleanProperty()) {
-		    // Remove entry under idlName
-		    // put entry into table under correct name
-		} else {
-		    throw new IllegalStateException("Error : methods " + 
-			clash + " and " + next.method + 
-			" both result in IDL name '" + idlName + "'");
-		}
-            } 
-
-	    IDLNameToMethodMap_.put(idlName, next.method);
-        }
-
-        return;
-
-    }
-
-    
-    /**
-     * Perform all necessary stand-alone identifier mangling operations
-     * on a java identifier that is being transformed into an IDL name.
-     * That is, mangling operations that don't require looking at anything
-     * else but the identifier itself.  This covers sections 1.3.2.2, 1.3.2.3, 
-     * and 1.3.2.4 of the Java2IDL spec.  Method overloading and 
-     * case-sensitivity checks are handled elsewhere.
-     */
-
-    private static String mangleIdentifier(String identifier) {
-        return mangleIdentifier(identifier, false);
-    }
-
-    private static String mangleIdentifier(String identifier, boolean attribute) {
-
-        String mangledName = identifier;
-
-        //
-        // Apply leading underscore test (1.3.2.3) 
-        // This should be done before IDL Keyword clash test, since clashing 
-        // IDL keywords are mangled by adding a leading underscore.
-        //
-        if( hasLeadingUnderscore(mangledName) ) {
-            mangledName = mangleLeadingUnderscore(mangledName);            
-        }         
-        
-        //
-        // Apply IDL keyword clash test (1.3.2.2).
-        // This is not needed for attributes since when the full property 
-        // name is composed it cannot clash with an IDL keyword.
-        // (Also, rmic doesn't do it.)
-        //
-        
-        if( !attribute && isIDLKeyword(mangledName) ) {
-            mangledName = mangleIDLKeywordClash(mangledName);           
-        } 
-
-        //
-        // Replace illegal IDL identifier characters (1.3.2.4) 
-        // for all method names and attributes.
-        //
-        if( !isIDLIdentifier(mangledName) ) {
-            mangledName = mangleUnicodeChars(mangledName);
-        }       
-        
-        return mangledName;
-    }
-
-    /**
-     * Checks whether a java identifier clashes with an
-     * IDL keyword.  Note that this is a case-insensitive
-     * comparison.
-     *
-     * Used to implement section 1.3.2.2 of Java2IDL spec.
-     */ 
-    private static boolean isIDLKeyword(String identifier) {
-        
-        String identifierAllCaps = identifier.toUpperCase();
-
-        return idlKeywords_.contains(identifierAllCaps);
-    }
-
-    private static String mangleIDLKeywordClash(String identifier) {
-        return UNDERSCORE + identifier;
-    }
-
-    private static String mangleLeadingUnderscore(String identifier) {
-        return LEADING_UNDERSCORE_CHAR + identifier;
-    }
-
-    /**
-     * Checks whether a java identifier starts with an underscore.
-     * Used to implement section 1.3.2.3 of Java2IDL spec.
-     */
-    private static boolean hasLeadingUnderscore(String identifier) {
-        return identifier.startsWith(UNDERSCORE);
-    }
-
-    /**
-     * Implements Section 1.3.2.4 of Java2IDL Mapping.
-     * All non-IDL identifier characters must be replaced
-     * with their Unicode representation.
-     */
-    static String mangleUnicodeChars(String identifier) {
-        StringBuffer mangledIdentifier = new StringBuffer();
-
-        for(int i = 0; i < identifier.length(); i++) {
-            char nextChar = identifier.charAt(i);
-            if( isIDLIdentifierChar(nextChar) ) {
-                mangledIdentifier.append(nextChar);
-            } else {
-                String unicode = charToUnicodeRepresentation(nextChar);
-                mangledIdentifier.append(unicode);
-            }
-        }
-        
-        return mangledIdentifier.toString();
-    }
-
-    /**
-     * Implements mangling portion of Section 1.3.2.7 of Java2IDL spec.
-     * This method only deals with the actual mangling.  Decision about 
-     * whether case-sensitive collision mangling is required is made 
-     * elsewhere.
-     * 
-     * 
-     * "...a mangled name is generated consisting of the original name 
-     * followed by an underscore separated list of decimal indices 
-     * into the string, where the indices identify all the upper case 
-     * characters in the original string. Indices are zero based."
-     *
-     */ 
-    String mangleCaseSensitiveCollision(String identifier) {
-
-        StringBuffer mangledIdentifier = new StringBuffer(identifier);
-
-        // There is always at least one trailing underscore, whether or 
-        // not the identifier has uppercase letters.
-        mangledIdentifier.append(UNDERSCORE);
-
-        boolean needUnderscore = false;
-        for(int i = 0; i < identifier.length(); i++) {
-            char next = identifier.charAt(i);
-            if( Character.isUpperCase(next) ) {
-                // This bit of logic is needed to ensure that we have
-                // an underscore separated list of indices but no 
-                // trailing underscores.  Basically, after we have at least
-                // one uppercase letter, we always put an undercore before
-                // printing the next one.
-                if( needUnderscore ) {
-                    mangledIdentifier.append(UNDERSCORE);
-                }
-                mangledIdentifier.append(i);
-                needUnderscore = true;
-            }
-        }
-
-        return mangledIdentifier.toString();
-    }
-
-    private static String mangleContainerClash(String identifier) {
-        return identifier + ID_CONTAINER_CLASH_CHAR;
-    }
-
-    /**
-     * Implements Section 1.3.2.9 of Java2IDL Mapping. Container in this
-     * context means the name of the java Class(excluding package) in which 
-     * the identifier is defined.  Comparison is case-insensitive.
-     */
-    private static boolean identifierClashesWithContainer
-        (String mappedContainerName, String identifier) {
-
-        return identifier.equalsIgnoreCase(mappedContainerName);
-    }
-
-    /**
-     * Returns Unicode mangling as defined in Section 1.3.2.4 of
-     * Java2IDL spec.
-     *
-     * "For Java identifiers that contain illegal OMG IDL identifier 
-     * characters such as '$' or Unicode characters outside of ISO Latin 1,
-     * any such illegal characters are replaced by "U" followed by the
-     * 4 hexadecimal characters(in upper case) representing the Unicode
-     * value.  So, the Java name a$b is mapped to aU0024b and 
-     * x\u03bCy is mapped to xU03BCy."
-     */
-    public static String charToUnicodeRepresentation(char c) {
-        
-        int orig = (int) c;
-        StringBuffer hexString = new StringBuffer();
-        
-        int value = orig;
-
-        while( value > 0 ) {
-            int div = value / 16;
-            int mod = value % 16;
-            hexString.insert(0, HEX_DIGITS[mod]);
-            value = div;
-        }
-
-        int numZerosToAdd = 4 - hexString.length();
-        for(int i = 0; i < numZerosToAdd; i++) {
-            hexString.insert(0, "0");
-        }
-
-        hexString.insert(0, "U");
-        return hexString.toString();
-    }
-
-    private static boolean isIDLIdentifier(String identifier) {
-
-        boolean isIdentifier = true;
-
-        for(int i = 0; i < identifier.length(); i++) {
-            char nextChar = identifier.charAt(i);
-            // 1st char must be alphbetic.
-            isIdentifier  = (i == 0) ?
-                isIDLAlphabeticChar(nextChar) : 
-                isIDLIdentifierChar(nextChar);
-            if( !isIdentifier ) {
-                break;
-            }
-        }
-
-        return isIdentifier;
-        
-    }
-
-    private static boolean isIDLIdentifierChar(char c) {
-        return (isIDLAlphabeticChar(c) || 
-                isIDLDecimalDigit(c)   ||
-                isUnderscore(c));
-    }
-
-    /**
-     * True if character is one of 114 Alphabetic characters as
-     * specified in Table 2 of Chapter 3 in CORBA spec.
-     */ 
-    private static boolean isIDLAlphabeticChar(char c) {
-
-        // NOTE that we can't use the java.lang.Character
-        // isUpperCase, isLowerCase, etc. methods since they
-        // include many characters other than the Alphabetic list in
-        // the CORBA spec.  Instead, we test for inclusion in the
-        // Unicode value ranges for the corresponding legal characters.
-
-        boolean alphaChar = 
-            (
-             // A - Z
-             ((c >= 0x0041) && (c <= 0x005A)) 
-
-             ||
-             
-             // a - z
-             ((c >= 0x0061) && (c <= 0x007A)) 
-             
-             ||
-             
-             // other letter uppercase, other letter lowercase, which is
-             // the entire upper half of C1 Controls except X and /
-             ((c >= 0x00C0) && (c <= 0x00FF)
-              && (c != 0x00D7) && (c != 0x00F7)));
-        
-        return alphaChar;
-    }
-
-    /**
-     * True if character is one of 10 Decimal Digits 
-     * specified in Table 3 of Chapter 3 in CORBA spec.
-     */ 
-    private static boolean isIDLDecimalDigit(char c) {
-        return ( (c >= 0x0030) && (c <= 0x0039) );
-    }
-
-    private static boolean isUnderscore(char c) {
-        return ( c == 0x005F );
-    }
-    
-    /**
-     * Mangle an overloaded method name as defined in Section 1.3.2.6 of
-     * Java2IDL spec.  Current value of method name is passed in as argument.
-     * We can't start from original method name since the name might have
-     * been partially mangled as a result of the other rules.  
-     */
-    private static String mangleOverloadedMethod(String mangledName, Method m) {
-
-        IDLTypesUtil idlTypesUtil = new IDLTypesUtil();
-
-        // Start by appending the separator string
-        String newMangledName = mangledName + OVERLOADED_TYPE_SEPARATOR;
-        
-        Class[] parameterTypes = m.getParameterTypes();
-        
-        for(int i = 0; i < parameterTypes.length; i++) {
-            Class nextParamType = parameterTypes[i];
-            
-            if( i > 0 ) {
-                newMangledName = newMangledName + OVERLOADED_TYPE_SEPARATOR;
-            }            
-            IDLType idlType = classToIDLType(nextParamType);
-
-            String moduleName = idlType.getModuleName();
-            String memberName = idlType.getMemberName();
-
-            String typeName = (moduleName.length() > 0) ?
-                moduleName + UNDERSCORE + memberName : memberName;
-                                   
-            if( !idlTypesUtil.isPrimitive(nextParamType) && 
-                (idlTypesUtil.getSpecialCaseIDLTypeMapping(nextParamType) 
-                 == null) &&               
-                isIDLKeyword(typeName) ) {
-                typeName = mangleIDLKeywordClash(typeName);
-            }
-
-            typeName = mangleUnicodeChars(typeName);
-
-            newMangledName = newMangledName + typeName;
-        }        
-
-        return newMangledName;        
-    }
-
-
-    private static IDLType classToIDLType(Class c) {
-               
-        IDLType idlType = null;
-        IDLTypesUtil idlTypesUtil = new IDLTypesUtil();
-
-        if( idlTypesUtil.isPrimitive(c) ) {
-
-            idlType = idlTypesUtil.getPrimitiveIDLTypeMapping(c);
-
-        } else if( c.isArray() ) {
-            
-            // Calculate array depth, as well as base element type.
-            Class componentType = c.getComponentType();
-            int numArrayDimensions = 1;
-            while(componentType.isArray()) {
-                componentType = componentType.getComponentType();
-                numArrayDimensions++;
-            }
-            IDLType componentIdlType = classToIDLType(componentType);
-            
-            String[] modules = BASE_IDL_ARRAY_MODULE_TYPE;
-            if( componentIdlType.hasModule() ) {
-                modules = (String[])ObjectUtility.concatenateArrays( modules, 
-                    componentIdlType.getModules() ) ;
-            }
-
-            String memberName = BASE_IDL_ARRAY_ELEMENT_TYPE + 
-                numArrayDimensions + UNDERSCORE + 
-                componentIdlType.getMemberName();                
-            
-            idlType = new IDLType(c, modules, memberName);
-               
-        } else {
-            idlType = idlTypesUtil.getSpecialCaseIDLTypeMapping(c);
-
-            if (idlType == null) {
-                // Section 1.3.2.5 of Java2IDL spec defines mangling rules for
-                // inner classes.
-                String memberName = getUnmappedContainerName(c);
-
-                // replace inner class separator with double underscore
-                memberName = memberName.replaceAll("\\$", 
-                                                   INNER_CLASS_SEPARATOR);
-                                
-                if( hasLeadingUnderscore(memberName) ) {
-                    memberName = mangleLeadingUnderscore(memberName);
-                }                    
-
-                // Get raw package name.  If there is a package, it
-                // will still have the "." separators and none of the
-                // mangling rules will have been applied.
-                String packageName = getPackageName(c);                 
-                
-                if (packageName == null) {
-		    idlType = new IDLType( c, memberName ) ;
-		} else {
-		    // If this is a generated IDL Entity Type we need to
-		    // prepend org_omg_boxedIDL per sections 1.3.5 and 1.3.9
-		    if (idlTypesUtil.isEntity(c)) {
-			packageName = "org.omg.boxedIDL." + packageName ;
-		    }
-		    
-		    // Section 1.3.2.1 and 1.3.2.6 of Java2IDL spec defines 
-		    // rules for mapping java packages to IDL modules and for 
-		    // mangling module name portion of type name.  NOTE that
-		    // of the individual identifier mangling rules, 
-		    // only the leading underscore test is done here.  
-		    // The other two(IDL Keyword, Illegal Unicode chars) are
-		    // done in mangleOverloadedMethodName.  
-                    StringTokenizer tokenizer = 
-                        new StringTokenizer(packageName, ".");
-		    
-		    String[] modules = new String[ tokenizer.countTokens() ] ;
-		    int index = 0 ;
-                    while (tokenizer.hasMoreElements()) {
-                        String next = tokenizer.nextToken();
-                        String nextMangled = hasLeadingUnderscore(next) ?
-                            mangleLeadingUnderscore(next) : next;
-
-			modules[index++] = nextMangled ;
-                    }                                                          
-
-		    idlType = new IDLType(c, modules, memberName);
-                }
-            }
-        }
-
-        return idlType;
-    }
-
-    /**
-     * Return Class' package name or null if there is no package.
-     */
-    private static String getPackageName(Class c) {
-        Package thePackage = c.getPackage();
-        String packageName = null;
-
-        // Try to get package name by introspection.  Some classloaders might
-        // not provide this information, so check for null.
-        if( thePackage != null ) {
-            packageName = thePackage.getName();
-        } else {
-            // brute force method
-            String fullyQualifiedClassName = c.getName();
-            int lastDot = fullyQualifiedClassName.indexOf('.');
-            packageName = (lastDot == -1) ? null :
-                fullyQualifiedClassName.substring(0, lastDot);
-        }
-        return packageName;
-    }
-    
-    private static String getMappedContainerName(Class c) {
-        String unmappedName = getUnmappedContainerName(c);
-
-        return mangleIdentifier(unmappedName);
-    }
-
-    /**
-     * Return portion of class name excluding package name.
-     */
-    private static String getUnmappedContainerName(Class c) {
-
-        String memberName  = null;
-        String packageName = getPackageName(c);
-
-        String fullyQualifiedClassName = c.getName();
-               
-        if( packageName != null ) {
-            int packageLength = packageName.length();
-            memberName = fullyQualifiedClassName.substring(packageLength + 1);
-        } else {
-            memberName = fullyQualifiedClassName;
-
-        }
-
-        return memberName;
-    }
-
-    /**
-     * Internal helper class for tracking information related to each
-     * interface method while we're building the name translation table.
-     */
-    private static class IDLMethodInfo 
-    {
-        public Method method;
-        public String propertyType;
-        
-        // If this is a property, originalName holds the original 
-        // attribute name. Otherwise, it holds the original method name.
-        public String originalName;
-
-        // If this is a property, mangledName holds the mangled attribute 
-        // name. Otherwise, it holds the mangled method name. 
-        public String mangledName;        
-
-    }
-
-    public String toString() {
-
-        StringBuffer contents = new StringBuffer();
-        contents.append("IDLNameTranslator[" );
-	for( int ctr=0; ctr<interf_.length; ctr++) {
-	    if (ctr != 0)
-		contents.append( " " ) ;
-	    contents.append( interf_[ctr].getName() ) ;
-	}
-        contents.append("]\n");
-        for(Iterator iter = methodToIDLNameMap_.keySet().iterator();
-            iter.hasNext();) {
-
-            Method method  = (Method) iter.next();
-            String idlName = (String) methodToIDLNameMap_.get(method);
-
-            contents.append(idlName + ":" + method + "\n");
-
-        }
-
-        return contents.toString();
-    }
-
-    public static void main(String[] args) {
-        
-        Class remoteInterface = java.rmi.Remote.class;
-        
-        if( args.length > 0 ) {
-            String className = args[0];
-            try {
-                remoteInterface = Class.forName(className);
-            } catch(Exception e) {
-                e.printStackTrace();
-                System.exit(-1);
-            }            
-        }
-        
-        System.out.println("Building name translation for " + remoteInterface);
-        try {
-            IDLNameTranslator nameTranslator = 
-                IDLNameTranslatorImpl.get(remoteInterface);
-            System.out.println(nameTranslator);
-        } catch(IllegalStateException ise) {
-            ise.printStackTrace();
-        }
-    }
-}
--- ./corba/src/share/classes/com/sun/corba/se/impl/presentation/rmi/IDLTypesUtil_save.sjava	Tue Mar 18 12:29:47 2014 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,520 +0,0 @@
-
-package com.sun.corba.se.impl.presentation.rmi ;
-
-import java.lang.reflect.Method;
-import java.lang.reflect.Field;
-import java.util.Set;
-import java.util.HashSet;
-import java.util.Iterator;
-
-/**
- * Utility class for testing RMI/IDL Types as defined in
- * Section 1.2 of The Java Language to IDL Mapping.  Note that
- * these are static checks only.  Runtime checks, such as those
- * described in Section 1.2.3, #3, are not covered.
- */
-public class IDLTypesUtil {
-
-    public static final String JAVA_GET_PROPERTY_PREFIX = "get";
-    public static final String JAVA_SET_PROPERTY_PREFIX = "set";
-    public static final String JAVA_IS_PROPERTY_PREFIX  = "is";
-
-    public static final int VALID_TYPE   = 0;
-    public static final int INVALID_TYPE = 1;
-
-    /**
-     * Validate a class to ensure it conforms to the rules for a
-     * Java RMI/IIOP interface.
-     *
-     * @throws IDLTypeException if not a valid RMI/IIOP interface.
-     */
-    public void validateRemoteInterface(Class c) throws IDLTypeException
-    {
-        if( c == null ) {
-            throw new IllegalArgumentException();
-        } 
-
-        if( !c.isInterface() ) {
-            String msg = "Class " + c + " must be a java interface.";
-            throw new IDLTypeException(msg);
-        }
-
-        if( !java.rmi.Remote.class.isAssignableFrom(c) ) {
-            String msg = "Class " + c + " must extend java.rmi.Remote, " +
-                "either directly or indirectly.";
-            throw new IDLTypeException(msg);
-        }
-
-        // Get all methods, including super-interface methods.
-        Method[] methods = c.getMethods();
-        
-        for(int i = 0; i < methods.length; i++) {
-            Method next = methods[i];
-            validateExceptions(next);
-        }
-        
-	// Removed because of bug 4989053
-        // validateDirectInterfaces(c);
-        validateConstants(c);
-
-        return;
-    }
-
-    public boolean isRemoteInterface(Class c)     
-    {
-        boolean remoteInterface = true;
-        try {
-            validateRemoteInterface(c);
-        } catch(IDLTypeException ite) {
-            remoteInterface = false;
-        }
-
-        return remoteInterface;
-    }
-
-    /**
-     * Section 1.2.2 Primitive Types
-     */ 
-    public boolean isPrimitive(Class c) 
-    {
-        if( c == null ) {
-            throw new IllegalArgumentException();
-        } 
-
-        return c.isPrimitive();
-    }
-
-    /**
-     * Section 1.2.4
-     */
-    public boolean isValue(Class c) 
-    {
-        if( c == null ) {
-            throw new IllegalArgumentException();
-        } 
-
-        return 
-            (!c.isInterface() &&
-             java.io.Serializable.class.isAssignableFrom(c) &&
-             !java.rmi.Remote.class.isAssignableFrom(c));
-    }
-
-    /**
-     * Section 1.2.5
-     */
-    public boolean isArray(Class c) 
-    {
-        boolean arrayType = false;
-
-        if( c == null ) {
-            throw new IllegalArgumentException();
-        } 
-
-        if( c.isArray() ) {
-            Class componentType = c.getComponentType();
-            arrayType =
-                (isPrimitive(componentType) || isRemoteInterface(componentType) ||
-                 isEntity(componentType) || isException(componentType) || 
-		 isValue(componentType) || isObjectReference(componentType) );
-        }
-
-        return arrayType;
-    }
-
-    /**
-     * Section 1.2.6
-     */
-    public boolean isException(Class c) 
-    {
-        if( c == null ) {
-            throw new IllegalArgumentException();
-        } 
-
-        // Must be a checked exception, not including RemoteException or
-        // its subclasses.
-        return isCheckedException(c) && !isRemoteException(c) && isValue(c);
-    }
-
-    public boolean isRemoteException(Class c)
-    {
-        if( c == null ) {
-            throw new IllegalArgumentException();
-        } 
-
-	return java.rmi.RemoteException.class.isAssignableFrom(c) ;
-    }
-
-    public boolean isCheckedException(Class c) 
-    {
-        if( c == null ) {
-            throw new IllegalArgumentException();
-        } 
-
-        return Throwable.class.isAssignableFrom(c) &&
-            !RuntimeException.class.isAssignableFrom(c) &&
-            !Error.class.isAssignableFrom(c) ;
-    }
-
-    /**
-     * Section 1.2.7
-     */ 
-    public boolean isObjectReference(Class c) 
-    {
-        if( c == null ) {
-            throw new IllegalArgumentException();
-        } 
-
-        return (c.isInterface() && 
-                org.omg.CORBA.Object.class.isAssignableFrom(c));
-    }
-
-    /**
-     * Section 1.2.8
-     */ 
-    public boolean isEntity(Class c)
-    {
-        if( c == null ) {
-            throw new IllegalArgumentException();
-        } 
-
-        Class superClass = c.getSuperclass();
-        return (!c.isInterface() &&
-                (superClass != null) && 
-                (org.omg.CORBA.portable.IDLEntity.class.isAssignableFrom(c)));
-    }
-
-    public String javaPropertyPrefixToIDL( String javaPrefix )
-    {
-	return "_" + javaPrefix + "_" ;
-    }
-
-    /**
-     * Return the property type if given method is legal property accessor as defined in 
-     * Section 1.3.4.3 of Java2IDL spec.  Result is one of: JAVA_GET_PROPERTY_PREFIX,
-     * JAVA_SET_PROPERTY_PREFIX, JAVA_IS_PROPERTY_PREFIX.
-     */
-    public String propertyAccessorMethodType(Method m, Class c) {
-        
-        String methodName = m.getName();
-        Class returnType  = m.getReturnType();
-        Class[] parameters = m.getParameterTypes();
-        Class[] exceptionTypes = m.getExceptionTypes();
-        String propertyType = null;
-
-        if( methodName.startsWith(JAVA_GET_PROPERTY_PREFIX) ) {
-
-            if((parameters.length == 0) && (returnType != Void.TYPE) &&
-		!hasCorrespondingReadProperty(m, c, JAVA_IS_PROPERTY_PREFIX) {
-                propertyType = JAVA_GET_PROPERTY_PREFIX;
-            }
-           
-        } else if( methodName.startsWith(JAVA_SET_PROPERTY_PREFIX) ) {
-            
-            if((returnType == Void.TYPE) && (parameters.length == 1)) {
-                if (hasCorrespondingReadProperty(m, c, JAVA_GET_PROPERTY_PREFIX) ||
-                    hasCorrespondingReadProperty(m, c, JAVA_IS_PROPERTY_PREFIX)) {
-                    propertyType = JAVA_SET_PROPERTY_PREFIX;
-                }
-            }
-
-        } else if( methodName.startsWith(JAVA_IS_PROPERTY_PREFIX) ) {
-            if((parameters.length == 0) && (returnType == Boolean.TYPE)) {
-                propertyType = JAVA_IS_PROPERTY_PREFIX;             
-            }
-        }
-
-        // Some final checks that apply to all properties.  
-        if( propertyType != null ) {
-            if(!validPropertyExceptions(m) || 
-               (methodName.length() <= propertyType.length())) {
-                propertyType = null;
-            }                                       
-        }
-
-        return propertyType ;
-    }
-
-    private boolean hasCorrespondingReadProperty
-        (Method writeProperty, Class c, String readPropertyPrefix) {
-
-        String writePropertyMethodName = writeProperty.getName();
-        Class[] writePropertyParameters = writeProperty.getParameterTypes();
-        boolean foundReadProperty = false;
-
-        try {            
-            // Look for a valid corresponding Read property
-            String readPropertyMethodName = 
-                writePropertyMethodName.replaceFirst
-                    (JAVA_SET_PROPERTY_PREFIX, readPropertyPrefix);
-            Method readPropertyMethod = c.getMethod(readPropertyMethodName, 
-                                                    new Class[] {});
-            foundReadProperty = 
-                ((propertyAccessorMethodType(readPropertyMethod, c) != null) &&
-                 (readPropertyMethod.getReturnType() == 
-                   writePropertyParameters[0]));
-        } catch(Exception e) {
-            // ignore. this means we didn't find a corresponding get property.
-        }
-
-        return foundReadProperty;
-    }
-
-    public String getAttributeNameForProperty(String propertyName) {
-        String attributeName = null;
-        String prefix = null;
-
-        if( propertyName.startsWith(JAVA_GET_PROPERTY_PREFIX) ) {
-            prefix = JAVA_GET_PROPERTY_PREFIX;           
-        } else if( propertyName.startsWith(JAVA_SET_PROPERTY_PREFIX) ) {
-            prefix = JAVA_SET_PROPERTY_PREFIX;
-        } else if( propertyName.startsWith(JAVA_IS_PROPERTY_PREFIX) ) {
-            prefix = JAVA_IS_PROPERTY_PREFIX;
-        }
-
-        if( (prefix != null) && (prefix.length() < propertyName.length()) ) {
-            String remainder = propertyName.substring(prefix.length());
-            if( (remainder.length() >= 2) && 
-                Character.isUpperCase(remainder.charAt(0)) &&
-                Character.isUpperCase(remainder.charAt(1)) ) {
-                // don't set the first letter to lower-case if the 
-                // first two are upper-case
-                attributeName = remainder;
-            } else {
-                attributeName = Character.toLowerCase(remainder.charAt(0)) +
-                    remainder.substring(1);
-            }
-        }
-
-        return attributeName;
-    }
-
-    /**
-     * Return IDL Type name for primitive types as defined in 
-     * Section 1.3.3 of Java2IDL spec or null if not a primitive type.
-     */ 
-    public IDLType getPrimitiveIDLTypeMapping(Class c) {
-               
-        if( c == null ) {
-            throw new IllegalArgumentException();
-        } 
-
-        if( c.isPrimitive() ) {            
-            if( c == Void.TYPE ) {
-		return new IDLType( c, "void" ) ;
-            } else if( c == Boolean.TYPE ) {
-		return new IDLType( c, "boolean" ) ;
-            } else if( c == Character.TYPE ) {
-		return new IDLType( c, "wchar" ) ;
-            } else if( c == Byte.TYPE ) {
-		return new IDLType( c, "octet" ) ;
-            } else if( c == Short.TYPE ) {
-		return new IDLType( c, "short" ) ;
-            } else if( c == Integer.TYPE ) {
-		return new IDLType( c, "long" ) ;
-            } else if( c == Long.TYPE ) {
-		return new IDLType( c, "long_long" ) ;
-            } else if( c == Float.TYPE ) {
-		return new IDLType( c, "float" ) ;
-            } else if( c == Double.TYPE ) {
-		return new IDLType( c, "double" ) ;
-            }
-        }
-        
-        return null;
-    }
-
-    /**
-     * Return IDL Type name for special case type mappings as defined in
-     * Table 1-1 of Java2IDL spec or null if given class is not a special
-     * type.
-     */
-    public IDLType getSpecialCaseIDLTypeMapping(Class c) {
-
-        if( c == null ) {
-            throw new IllegalArgumentException();
-        } 
-
-        if( c == java.lang.Object.class ) {
-	    return new IDLType( c, new String[] { "java", "lang" },
-		"Object" ) ;
-        } else if( c == java.lang.String.class ) {
-	    return new IDLType( c, new String[] { "CORBA" },
-		"WStringValue" ) ;
-        } else if( c == java.lang.Class.class ) {
-	    return new IDLType( c, new String[] { "javax", "rmi", "CORBA" },
-		"ClassDesc" ) ;
-        } else if( c == java.io.Serializable.class ) {
-	    return new IDLType( c, new String[] { "java", "io" },
-		"Serializable" ) ;
-        } else if( c == java.io.Externalizable.class ) {
-	    return new IDLType( c, new String[] { "java", "io" },
-		"Externalizable" ) ;
-        } else if( c == java.rmi.Remote.class ) {
-	    return new IDLType( c, new String[] { "java", "rmi" },
-		"Remote" ) ;
-        } else if( c == org.omg.CORBA.Object.class ) {
-	    return new IDLType( c, "Object" ) ;
-        } else {
-            return null;
-        }
-    }
-
-    /**
-     * Implements 1.2.3 #2 and #4
-     */
-    private void validateExceptions(Method method) throws IDLTypeException {
-        
-        Class[] exceptions = method.getExceptionTypes();
-
-        boolean declaresRemoteExceptionOrSuperClass = false;
-
-        // Section 1.2.3, #2
-        for(int eIndex = 0; eIndex < exceptions.length; eIndex++) {
-            Class exception = exceptions[eIndex];
-            if( isRemoteExceptionOrSuperClass(exception) ) {
-                declaresRemoteExceptionOrSuperClass = true;
-                break;
-            }
-        }
-
-        if( !declaresRemoteExceptionOrSuperClass ) {
-            String msg = "Method '" + method + "' must throw at least one " +
-                "exception of type java.rmi.RemoteException or one of its " +
-                "super-classes";
-            throw new IDLTypeException(msg);
-        } 
-
-        // Section 1.2.3, #4
-	// See also bug 4972402
-	// For all exceptions E in exceptions, 
-	// (isCheckedException(E) => (isValue(E) || RemoteException.isAssignableFrom( E ) )
-        for(int eIndex = 0; eIndex < exceptions.length; eIndex++) {
-            Class exception = exceptions[eIndex];
-
-	    if (isCheckedException(exception) && !isValue(exception) && 
-		!isRemoteException(exception)) 
-	    {
-		String msg = "Exception '" + exception + "' on method '" +
-		    method + "' is not a allowed RMI/IIOP exception type";
-		throw new IDLTypeException(msg);
-            }
-        }
-
-        return;
-    }
-
-    /**
-     * Returns true if the method's throw clause conforms to the exception 
-     * restrictions for properties as defined in Section 1.3.4.3 of 
-     * Java2IDL spec.  This means that for all exceptions E declared on the
-     * method, E isChecked => RemoteException.isAssignableFrom( E ). 
-     */
-    private boolean validPropertyExceptions(Method method) 
-    {
-        Class[] exceptions = method.getExceptionTypes();
-         
-        for(int eIndex = 0; eIndex < exceptions.length; eIndex++) {
-            Class exception = exceptions[eIndex];
-
-	    if (isCheckedException(exception) && !isRemoteException(exception)) 
-		return false ;
-        }
-
-        return true;
-    }
-
-    /**
-     * Implements Section 1.2.3, #2.  
-     */
-    private boolean isRemoteExceptionOrSuperClass(Class c) {
-        return 
-            ((c == java.rmi.RemoteException.class) ||
-             (c == java.io.IOException.class) ||
-             (c == java.lang.Exception.class) ||
-             (c == java.lang.Throwable.class));
-    }
-
-    /**
-     * Implements Section 1.2.3, #5.
-     */ 
-    private void validateDirectInterfaces(Class c) throws IDLTypeException {
-
-        Class[] directInterfaces = c.getInterfaces();
-
-        if( directInterfaces.length < 2 ) {
-            return;
-        }
-
-        Set allMethodNames = new HashSet();
-        Set currentMethodNames = new HashSet();
-
-        for(int i = 0; i < directInterfaces.length; i++) {
-            Class next = directInterfaces[i];
-            Method[] methods = next.getMethods();
-
-            // Comparison is based on method names only.  First collect
-            // all methods from current interface, eliminating duplicate
-            // names.
-            currentMethodNames.clear();
-            for(int m = 0; m < methods.length; m++) {
-                currentMethodNames.add(methods[m].getName());
-            }
-
-            // Now check each method against list of all unique method
-            // names processed so far.
-            for(Iterator iter=currentMethodNames.iterator(); iter.hasNext();) {
-                String methodName = (String) iter.next();
-                if( allMethodNames.contains(methodName) ) {
-                    String msg = "Class " + c + " inherits method " + 
-                        methodName + " from multiple direct interfaces.";
-                    throw new IDLTypeException(msg);
-                } else {
-                    allMethodNames.add(methodName);
-                }
-            }
-        }
-
-        return;
-    }
-
-    /**
-     * Implements 1.2.3 #6
-     */
-    private void validateConstants(final Class c) 
-        throws IDLTypeException {
-
-        Field[] fields = null;
-
-        try {
-            fields = (Field[])
-                java.security.AccessController.doPrivileged
-                (new java.security.PrivilegedExceptionAction() {
-                        public java.lang.Object run() throws Exception {
-                            return c.getFields();
-                        }
-                    });
-        } catch(java.security.PrivilegedActionException pae) {
-            IDLTypeException ite = new IDLTypeException();
-            ite.initCause(pae);
-            throw ite;
-        }
-   
-        for(int i = 0; i < fields.length; i++) {
-            Field next = fields[i];
-            Class fieldType = next.getType();
-            if( (fieldType != java.lang.String.class) &&
-                !isPrimitive(fieldType) ) {
-                String msg = "Constant field '" + next.getName() + 
-                    "' in class '" + next.getDeclaringClass().getName() + 
-                    "' has invalid type' " + next.getType() + "'. Constants" +
-                    " in RMI/IIOP interfaces can only have primitive" + 
-                    " types and java.lang.String types.";
-                throw new IDLTypeException(msg);
-            }
-        }
-
-
-        return;
-    }
-
-}
--- ./corba/src/share/classes/com/sun/corba/se/impl/protocol/oldlocal/LocalClientRequestImpl.sjava	Tue Mar 18 12:29:47 2014 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,138 +0,0 @@
-/*
- * Copyright (c) 1999, 2003, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package com.sun.corba.se.impl.iiop;
-
-import com.sun.corba.se.impl.protocol.Request;
-import com.sun.corba.se.impl.core.ClientRequest;
-import com.sun.corba.se.impl.core.ServiceContext;
-import com.sun.corba.se.impl.core.ServiceContexts;
-import com.sun.corba.se.impl.core.ClientResponse;
-import com.sun.corba.se.impl.core.ServerRequest;
-import com.sun.corba.se.impl.core.ServerResponse;
-import com.sun.corba.se.impl.corba.IOR;
-import com.sun.corba.se.impl.corba.GIOPVersion;
-import com.sun.corba.se.impl.protocol.giopmsgheaders.MessageBase;
-import com.sun.corba.se.impl.protocol.giopmsgheaders.RequestMessage;
-import com.sun.corba.se.impl.orbutil.ORBConstants;
-import com.sun.corba.se.impl.core.ORBVersion;
-import com.sun.corba.se.impl.core.ORB;
-import com.sun.corba.se.impl.orbutil.ORBUtility;
-import com.sun.corba.se.impl.ior.ObjectKeyFactory ;
-import com.sun.corba.se.impl.ior.ObjectKey ;
-import com.sun.corba.se.impl.ior.ObjectKeyTemplate ;
-import com.sun.corba.se.impl.ior.IIOPProfile;
-
-public class LocalClientRequestImpl extends IIOPOutputStream 
-    implements ClientRequest 
-{
-    public LocalClientRequestImpl( GIOPVersion gv, 
-	ORB orb, IOR ior, short addrDisposition, 
-        String operationName, boolean oneway, ServiceContexts svc, 
-	int requestId, byte streamFormatVersion)
-    {
-	super(gv, 
-              orb, 
-              null, 
-              BufferManagerFactory.newBufferManagerWrite(BufferManagerFactory.GROW),
-              streamFormatVersion);
-
-	this.isOneway = oneway;
-	boolean responseExpected = !isOneway;
-
-        IIOPProfile iop = ior.getProfile();
-	ObjectKey okey = iop.getObjectKey();
-	ObjectKeyTemplate oktemp = okey.getTemplate() ;
-	ORBVersion version = oktemp.getORBVersion() ;
-	orb.setORBVersion( version ) ;
-
-        this.request = MessageBase.createRequest(orb, gv, requestId,
-	    responseExpected, ior, addrDisposition, operationName, svc, null);
-	setMessage(request);
-	request.write(this);
-
-	// mark beginning of msg body for possible later use
-	bodyBegin = getSize();
-    }
-
-    public int getRequestId() {
-	return request.getRequestId();
-    }
-    
-    public boolean isOneWay() {
-	return isOneway;
-    }
-
-    public ServiceContexts getServiceContexts() {
-	return request.getServiceContexts();
-    }
-
-    public String getOperationName() {
-	return request.getOperation();
-    }
-
-    public ObjectKey getObjectKey() {
-	return request.getObjectKey();
-    }
-
-    public ServerRequest getServerRequest()
-    {
-	// Set the size of the marshalled data in the message header.
-	getMessage().setSize( getByteBuffer(), getSize() ) ;
-
-	// Construct a new ServerRequest out of the buffer in this ClientRequest
-	LocalServerRequestImpl serverRequest = new LocalServerRequestImpl(
-	    (ORB)orb(), toByteArray(), request ) ;
-
-	// Skip over all of the GIOP header information.  This positions
-	// the offset in the buffer so that the skeleton can correctly read
-	// the marshalled arguments.
-	serverRequest.setIndex( bodyBegin ) ;
-
-	return serverRequest ;
-    }
-    
-    public ClientResponse invoke() 
-    {	
-	ORB myORB = (ORB)orb() ;
-
-	ServerResponse serverResponse = myORB.process( getServerRequest() ) ;
-
-	LocalServerResponseImpl lsr = (LocalServerResponseImpl)serverResponse ;
-
-	return lsr.getClientResponse() ;
-    }
-
-    /**
-     * Check to see if the request is local.
-     */
-    public boolean isLocal(){
-        return true;
-    }
-
-    private RequestMessage request;
-    private int bodyBegin;
-    private boolean isOneway;
-}
--- ./corba/src/share/classes/com/sun/corba/se/impl/protocol/oldlocal/LocalClientResponseImpl.sjava	Tue Mar 18 12:29:47 2014 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,162 +0,0 @@
-/*
- * Copyright (c) 1999, 2003, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package com.sun.corba.se.impl.iiop;
-
-import java.io.IOException;
-
-import org.omg.CORBA.SystemException;
-import org.omg.CORBA.CompletionStatus;
-
-import com.sun.corba.se.impl.core.Response;
-import com.sun.corba.se.impl.core.ClientResponse;
-import com.sun.corba.se.impl.corba.IOR;
-import com.sun.corba.se.impl.core.ORB;
-import com.sun.corba.se.impl.core.ServiceContext;
-import com.sun.corba.se.impl.core.ServiceContexts;
-import com.sun.corba.se.impl.protocol.giopmsgheaders.Message;
-import com.sun.corba.se.impl.protocol.giopmsgheaders.ReplyMessage;
-import com.sun.corba.se.impl.orbutil.MinorCodes;
-
-class LocalClientResponseImpl extends IIOPInputStream implements ClientResponse
-{
-    LocalClientResponseImpl(ORB orb, byte[] buf, ReplyMessage header)
-    {
-	super(orb, buf, header.getSize(), header.isLittleEndian(), header, null);
-
-        this.reply = header;
-
-        // NOTE (Ram J) (06/02/2000) if we set result.setIndex(bodyBegin)
-        // in LocalServerResponse.getClientResponse(), then we do not need
-        // to read the headers (done below) anymore.
-        // This will be an optimisation which is can be done to speed up the
-        // local invocation by avoiding reading the headers in the local cases.
-
-        // BUGFIX(Ram Jeyaraman) This has been moved from
-        // LocalServerResponse.getClientResponse()
-        // Skip over all of the GIOP header information.  This positions
-        // the offset in the buffer so that the skeleton can correctly read
-        // the marshalled arguments.
-        this.setIndex(Message.GIOPMessageHeaderLength);
-
-        // BUGFIX(Ram Jeyaraman) For local invocations, the reply mesg fields
-        // needs to be set, by reading the response buffer contents
-        // to correctly set the exception type and other info.
-        this.reply.read(this);
-    }
-
-    LocalClientResponseImpl(SystemException ex)
-    {
-	this.systemException = ex;
-    }
-
-    public boolean isSystemException() {
-	if ( reply != null )
-	    return reply.getReplyStatus() == ReplyMessage.SYSTEM_EXCEPTION;
-	else
-	    return (systemException != null);	
-    }
-
-    public boolean isUserException() {
-	if ( reply != null )
-	    return reply.getReplyStatus() == ReplyMessage.USER_EXCEPTION;
-	else
-	    return false;
-    }
-
-    public boolean isLocationForward() {
-        if ( reply != null ) {
-            return ( (reply.getReplyStatus() == ReplyMessage.LOCATION_FORWARD) ||
-                     (reply.getReplyStatus() == ReplyMessage.LOCATION_FORWARD_PERM) );
-            //return reply.getReplyStatus() == ReplyMessage.LOCATION_FORWARD;
-        } else {
-            return false;
-        }
-    }
-    
-    public boolean isDifferentAddrDispositionRequested() {
-        if (reply != null) {
-            return reply.getReplyStatus() == ReplyMessage.NEEDS_ADDRESSING_MODE;
-        }
-    
-        return false;
-    }
-        
-    public short getAddrDisposition() {
-        if (reply != null) {
-            return reply.getAddrDisposition();
-        }
-        
-        throw new org.omg.CORBA.INTERNAL(
-            "Null reply in getAddrDisposition",
-            MinorCodes.NULL_REPLY_IN_GET_ADDR_DISPOSITION,        
-            CompletionStatus.COMPLETED_MAYBE);
-    }
-        
-    public IOR getForwardedIOR() {
-	if ( reply != null )
-	    return reply.getIOR();
-	else
-	    return null;
-    }
-
-    public int getRequestId() {
-	if ( reply != null )
-	    return reply.getRequestId();
-	else
-	    throw new org.omg.CORBA.INTERNAL("Error in getRequestId");
-    }
-
-    public ServiceContexts getServiceContexts() {
-	if ( reply != null )
-	    return reply.getServiceContexts();
-	else
-	    return null;
-    }
-
-    public SystemException getSystemException() {
-	if ( reply != null )
-	    return reply.getSystemException();
-	else
-	    return systemException;
-    }
-
-    public java.lang.String peekUserExceptionId() {
-        mark(Integer.MAX_VALUE);
-        String result = read_string();
-        reset();
-        return result;
-    }
-
-    /**
-     * Check to see if the response is local.
-     */
-    public boolean isLocal(){
-        return true;
-    }
-
-    private ReplyMessage reply;
-    private SystemException systemException;
-}
--- ./corba/src/share/classes/com/sun/corba/se/impl/protocol/oldlocal/LocalServerRequestImpl.sjava	Tue Mar 18 12:29:47 2014 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,208 +0,0 @@
-/*
- * Copyright (c) 1999, 2003, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package com.sun.corba.se.impl.iiop;
-
-import org.omg.CORBA.SystemException;
-
-import com.sun.corba.se.impl.core.ServerRequest;
-import com.sun.corba.se.impl.core.ServiceContext;
-import com.sun.corba.se.impl.core.DuplicateServiceContext;
-import com.sun.corba.se.impl.core.UEInfoServiceContext;
-import com.sun.corba.se.impl.core.ServiceContexts;
-import com.sun.corba.se.impl.core.ServerResponse;
-import com.sun.corba.se.impl.corba.IOR;
-import com.sun.corba.se.impl.core.ORB;
-import com.sun.corba.se.impl.orbutil.ORBUtility;  //d11638
-import org.omg.CORBA.portable.UnknownException;
-import org.omg.CORBA.UNKNOWN;
-import org.omg.CORBA.CompletionStatus;
-import com.sun.corba.se.impl.ior.ObjectKey;
-import com.sun.corba.se.impl.protocol.giopmsgheaders.MessageBase;
-import com.sun.corba.se.impl.protocol.giopmsgheaders.ReplyMessage;
-import com.sun.corba.se.impl.protocol.giopmsgheaders.RequestMessage;
-
-class LocalServerRequestImpl extends IIOPInputStream implements ServerRequest {
-    org.omg.CORBA.portable.OutputStream replyStream;
-    org.omg.CORBA.portable.OutputStream exceptionReplyStream;
-
-    LocalServerRequestImpl(ORB orb, byte[] buf, RequestMessage header)
-    {
-        super(orb, buf, header.getSize(), header.isLittleEndian(), header, null );
-
-        this.request = header;
-    }
-
-    public int getRequestId() {
-    	return request.getRequestId();
-    }
-
-    public boolean isOneWay() {
-    	return !request.isResponseExpected();
-    }
-
-    public ServiceContexts getServiceContexts() {
-    	return request.getServiceContexts();
-    }
-
-    public String getOperationName() {
-    	return request.getOperation();
-    }
-
-    public ObjectKey getObjectKey() {
-    	return request.getObjectKey();
-    }
-
-    public ServerResponse createResponse(ServiceContexts svc)
-    {
-    	return new LocalServerResponseImpl(this, svc);
-    }
-
-    public org.omg.CORBA.portable.OutputStream createReply() {
-        if (replyStream == null) {
-            replyStream = (org.omg.CORBA.portable.OutputStream)
-                                createResponse(null);
-        }
-        return replyStream;
-    }
-
-    public org.omg.CORBA.portable.OutputStream createExceptionReply() {
-        if (exceptionReplyStream == null) {
-            exceptionReplyStream = (org.omg.CORBA.portable.OutputStream)
-                                        createUserExceptionResponse(null);
-        }
-        return exceptionReplyStream;
-    }
-
-    public ServerResponse createUserExceptionResponse(
-	ServiceContexts svc)
-    {
-    	return new LocalServerResponseImpl(this, svc, true);
-    }
-
-    public ServerResponse createUnknownExceptionResponse(
-	        UnknownException ex) {
-        ServiceContexts contexts = null;
-        SystemException sys = new UNKNOWN( 0,
-            CompletionStatus.COMPLETED_MAYBE);
-
-            try {
-                contexts = new ServiceContexts( (ORB)orb() );
-                UEInfoServiceContext uei = new UEInfoServiceContext(sys);
-                contexts.put(uei) ;
-            } catch (DuplicateServiceContext d) {
-            // can't happen
-            }
-
-        return createSystemExceptionResponse(sys,contexts);
-    }
-
-    public ServerResponse createSystemExceptionResponse(
-    	SystemException ex, ServiceContexts svc) {
-
-	// Only do this if interceptors have been initialized on this request
-	// and have not completed their lifecycle (otherwise the info stack
-	// may be empty or have a different request's entry on top).
-	if (executePIInResponseConstructor()) {
-	    // Inform Portable Interceptors of the SystemException.  This is
-	    // required to be done here because the ending interception point
-	    // is called in the ServerResponseImpl constructor called below
-	    // but we do not currently write the SystemException into the
-	    // response until after the ending point is called.
-	    ORB orb = (ORB)orb();
-	    orb.getPIHandler().setServerPIInfo( ex );
-	}
-
-	if (orb() != null && ((ORB)orb()).subcontractDebugFlag && ex != null)
-            ORBUtility.dprint(this, "Sending SystemException:", ex);
-
-        LocalServerResponseImpl response =
-            new LocalServerResponseImpl(this, svc, false);
-        ORBUtility.writeSystemException(ex, response);
-        return response;
-    }
-
-    public ServerResponse createLocationForward(
-	        IOR ior, ServiceContexts svc) {
-        ReplyMessage reply = MessageBase.createReply( (ORB)orb(),
-	    request.getGIOPVersion(), request.getRequestId(),
-	    ReplyMessage.LOCATION_FORWARD, svc, ior);
-        LocalServerResponseImpl response =
-            new LocalServerResponseImpl(this, reply, ior);
-
-        return response;
-    }
-
-    private RequestMessage request;
-
-    /**
-     * Check to see if the request is local.
-     */
-    public boolean isLocal(){
-        return true;
-    }
-
-    private boolean _executeReturnServantInResponseConstructor = false;
-
-    public boolean executeReturnServantInResponseConstructor()
-    {
-	return _executeReturnServantInResponseConstructor;
-    }
-
-    public void setExecuteReturnServantInResponseConstructor(boolean b)
-    {
-	_executeReturnServantInResponseConstructor = b;
-    }
-
-    
-    private boolean _executeRemoveThreadInfoInResponseConstructor = false;
-
-    public boolean executeRemoveThreadInfoInResponseConstructor()
-    {
-	return _executeRemoveThreadInfoInResponseConstructor;
-    }
-
-    public void setExecuteRemoveThreadInfoInResponseConstructor(boolean b)
-    {
-	_executeRemoveThreadInfoInResponseConstructor = b;
-    }
-
-    
-    private boolean _executePIInResponseConstructor = false;
-                                                            
-    public boolean executePIInResponseConstructor() {
-        return _executePIInResponseConstructor;
-    }
-
-    public void setExecutePIInResponseConstructor( boolean b ) {
-        _executePIInResponseConstructor = b;
-    }
-
-    // We know that we're talking to the same ValueHandler, so
-    // use the maximum version it supports.
-    public byte getStreamFormatVersionForReply() {
-        return ORBUtility.getMaxStreamFormatVersion();
-    }
-}
--- ./corba/src/share/classes/com/sun/corba/se/impl/protocol/oldlocal/LocalServerResponseImpl.sjava	Tue Mar 18 12:29:47 2014 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,192 +0,0 @@
-/*
- * Copyright (c) 1999, 2003, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package com.sun.corba.se.impl.iiop;
-
-import org.omg.CORBA.SystemException;
-
-import com.sun.corba.se.impl.core.ServerResponse;
-import com.sun.corba.se.impl.core.ORB;
-import com.sun.corba.se.impl.corba.IOR;
-import com.sun.corba.se.impl.core.ServiceContext;
-import com.sun.corba.se.impl.core.ServiceContexts;
-import com.sun.corba.se.impl.core.ClientResponse;
-import com.sun.corba.se.impl.protocol.giopmsgheaders.MessageBase;
-import com.sun.corba.se.impl.protocol.giopmsgheaders.ReplyMessage;
-
-class LocalServerResponseImpl
-    extends     IIOPOutputStream
-    implements  ServerResponse
-{
-    LocalServerResponseImpl(LocalServerRequestImpl request, ServiceContexts svc)
-    {
-        this(request,
-            MessageBase.createReply(
-                            (ORB)request.orb(),
-                            request.getGIOPVersion(),
-                            request.getRequestId(), ReplyMessage.NO_EXCEPTION,
-                            svc, null),
-            null);
-    }
-
-    LocalServerResponseImpl(LocalServerRequestImpl request, ServiceContexts svc,
-            boolean user)
-    {
-        this(request,
-            MessageBase.createReply(
-                            (ORB)request.orb(),
-                            request.getGIOPVersion(), request.getRequestId(),
-                            user ? ReplyMessage.USER_EXCEPTION :
-                                   ReplyMessage.SYSTEM_EXCEPTION,
-                            svc, null),
-            null);
-    }
-
-    LocalServerResponseImpl( LocalServerRequestImpl request, ReplyMessage reply,
-			     IOR ior)
-    {
-        super(request.getGIOPVersion(),
-              (ORB)request.orb(), 
-              null, 
-              BufferManagerFactory.newBufferManagerWrite(BufferManagerFactory.GROW),
-              request.getStreamFormatVersionForReply());
-
-        setMessage(reply);
-
-	ORB orb = (ORB)request.orb();
-
-	ServerResponseImpl.runServantPostInvoke(orb, request);
-
-	if( request.executePIInResponseConstructor() ) {
-	    // Invoke server request ending interception points (send_*):
-	    // Note: this may end up with a SystemException or an internal
-	    // Runtime ForwardRequest.
-	    orb.getPIHandler().invokeServerPIEndingPoint( reply );
-
-	    // Note this will be executed even if a ForwardRequest or
-	    // SystemException is thrown by a Portable Interceptors ending 
-	    // point since we end up in this constructor again anyway.
-	    orb.getPIHandler().cleanupServerPIRequest();
-
-	    // See (Local)ServerRequestImpl.createSystemExceptionResponse
-	    // for why this is necesary.
-	    request.setExecutePIInResponseConstructor(false);
-	}
-
-	// Once you get here then the final reply is available (i.e.,
-	// postinvoke and interceptors have completed.
-	if (request.executeRemoveThreadInfoInResponseConstructor()) {
-	    ServerResponseImpl.removeThreadInfo(orb, request);
-	}
-        
-	reply.write(this);
-	if (reply.getIOR() != null)
-	    reply.getIOR().write(this);
-
-        this.reply = reply;
-        this.ior = reply.getIOR();
-    }
-
-    public boolean isSystemException() {
-        if (reply != null)
-            return reply.getReplyStatus() == ReplyMessage.SYSTEM_EXCEPTION;
-        return false;
-    }
-
-    public boolean isUserException() {
-        if (reply != null)
-            return reply.getReplyStatus() == ReplyMessage.USER_EXCEPTION;
-        return false;
-    }
-
-    public boolean isLocationForward() {
-        if (ior != null)
-            return true;
-        return false;
-    }
-
-    public IOR getForwardedIOR() {
-    	return ior;
-    }
-
-    public int getRequestId() {
-        if (reply != null)
-            return reply.getRequestId();
-        return -1;
-    }
-
-    public ServiceContexts getServiceContexts() {
-        if (reply != null)
-            return reply.getServiceContexts();
-        return null;
-    }
-
-    public SystemException getSystemException() {
-        if (reply != null)
-            return reply.getSystemException();
-        return null;
-    }
-
-    public ReplyMessage getReply()
-    {
-    	return reply ;
-    }
-
-    public ClientResponse getClientResponse()
-    {
-        // set the size of the marshalled data in the message header
-        getMessage().setSize(getByteBuffer(), getSize());
-
-        // Construct a new ClientResponse out of the buffer in this ClientRequest
-        LocalClientResponseImpl result =
-            new LocalClientResponseImpl( (ORB)orb(), toByteArray(), reply);
-
-        // NOTE (Ram J) (06/02/2000) if we set result.setIndex(bodyBegin) here
-        // then the LocalClientResponse does not need to read the headers anymore.
-        // This will be an optimisation which is can be done to speed up the
-        // local invocation by avoiding reading the headers in the local cases.
-
-        // BUGFIX(Ram Jeyaraman) result.setOffset is now done in
-        // LocalClientResponseImpl constructor.
-        /*
-          // Skip over all of the GIOP header information.  This positions
-          // the offset in the buffer so that the skeleton can correctly read
-          // the marshalled arguments.
-          result.setOffset( bodyBegin ) ;
-        */
-
-        return result ;
-    }
-
-    /**
-     * Check to see if the response is local.
-     */
-    public boolean isLocal(){
-        return true;
-    }
-
-    private ReplyMessage reply;
-    private IOR ior; // forwarded IOR
-}
--- ./corba/src/share/classes/com/sun/corba/se/impl/transport/BufferConnectionImpl.sjava	Tue Mar 18 12:29:47 2014 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,710 +0,0 @@
-/*
- * Copyright (c) 2004, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-package com.sun.corba.se.impl.transport;
-
-import java.io.IOException;
-import java.net.InetSocketAddress;
-import java.net.Socket;
-import java.nio.ByteBuffer;
-import java.nio.channels.SelectableChannel;
-import java.nio.channels.SelectionKey;
-import java.nio.channels.SocketChannel;
-import java.security.AccessController;
-import java.security.PrivilegedAction;
-import java.util.Collections;
-import java.util.Hashtable;
-import java.util.HashMap;
-import java.util.Map;
-
-import org.omg.CORBA.COMM_FAILURE;
-import org.omg.CORBA.CompletionStatus;
-import org.omg.CORBA.DATA_CONVERSION;
-import org.omg.CORBA.INTERNAL;
-import org.omg.CORBA.MARSHAL;
-import org.omg.CORBA.OBJECT_NOT_EXIST;
-import org.omg.CORBA.SystemException;
-
-import com.sun.org.omg.SendingContext.CodeBase;
-
-import com.sun.corba.se.pept.broker.Broker;
-import com.sun.corba.se.pept.encoding.InputObject;
-import com.sun.corba.se.pept.encoding.OutputObject;
-import com.sun.corba.se.pept.protocol.MessageMediator;
-import com.sun.corba.se.pept.transport.Acceptor;
-import com.sun.corba.se.pept.transport.Connection;
-import com.sun.corba.se.pept.transport.ConnectionCache;
-import com.sun.corba.se.pept.transport.ContactInfo;
-import com.sun.corba.se.pept.transport.EventHandler;
-import com.sun.corba.se.pept.transport.InboundConnectionCache;
-import com.sun.corba.se.pept.transport.OutboundConnectionCache;
-import com.sun.corba.se.pept.transport.ResponseWaitingRoom;
-import com.sun.corba.se.pept.transport.Selector;
-
-import com.sun.corba.se.spi.ior.IOR;
-import com.sun.corba.se.spi.ior.iiop.GIOPVersion;
-import com.sun.corba.se.spi.logging.CORBALogDomains;
-import com.sun.corba.se.spi.orb.ORB ;
-import com.sun.corba.se.spi.orbutil.threadpool.Work;
-import com.sun.corba.se.spi.protocol.CorbaMessageMediator;
-import com.sun.corba.se.spi.transport.CorbaContactInfo;
-import com.sun.corba.se.spi.transport.CorbaConnection;
-import com.sun.corba.se.spi.transport.CorbaResponseWaitingRoom;
-
-import com.sun.corba.se.impl.encoding.CachedCodeBase;
-import com.sun.corba.se.impl.encoding.CDRInputStream_1_0;
-import com.sun.corba.se.impl.encoding.CDROutputObject;
-import com.sun.corba.se.impl.encoding.CDROutputStream_1_0;
-import com.sun.corba.se.impl.encoding.CodeSetComponentInfo;
-import com.sun.corba.se.impl.encoding.OSFCodeSetRegistry;
-import com.sun.corba.se.impl.logging.ORBUtilSystemException;
-import com.sun.corba.se.impl.orbutil.ORBConstants;
-import com.sun.corba.se.impl.orbutil.ORBUtility;
-import com.sun.corba.se.impl.protocol.giopmsgheaders.Message;
-import com.sun.corba.se.impl.protocol.giopmsgheaders.MessageBase;
-import com.sun.corba.se.impl.transport.CorbaResponseWaitingRoomImpl;
-
-/**
- * @author Ken Cavanaugh
- */
-public class BufferConnectionImpl
-    extends
-	EventHandlerBase
-    implements
-        CorbaConnection,
-	Work
-{
-    //
-    // New transport.
-    //
-
-    protected long enqueueTime;
-
-    public SocketChannel getSocketChannel()
-    {
-	return null;
-    }
-
-    // REVISIT:
-    // protected for test: genericRPCMSGFramework.IIOPConnection constructor.
-
-    //
-    // From iiop.Connection.java
-    //
-
-    protected long timeStamp = 0;
-    protected boolean isServer = false;
-
-    // Start at some value other than zero since this is a magic
-    // value in some protocols.
-    protected int requestId = 5;
-    protected CorbaResponseWaitingRoom responseWaitingRoom;
-    protected int state;
-    protected java.lang.Object stateEvent = new java.lang.Object();
-    protected java.lang.Object writeEvent = new java.lang.Object();
-    protected boolean writeLocked;
-    protected int serverRequestCount = 0;
-    
-    // Server request map: used on the server side of Connection
-    // Maps request ID to IIOPInputStream.
-    Map serverRequestMap = new HashMap() ;
-
-    // This is a flag associated per connection telling us if the
-    // initial set of sending contexts were sent to the receiver
-    // already...
-    protected boolean postInitialContexts = false;
- 
-    // Remote reference to CodeBase server (supplies
-    // FullValueDescription, among other things)
-    protected IOR codeBaseServerIOR;
-
-    // CodeBase cache for this connection.  This will cache remote operations,
-    // handle connecting, and ensure we don't do any remote operations until
-    // necessary.
-    protected CachedCodeBase cachedCodeBase = new CachedCodeBase(this);
-
-    protected ORBUtilSystemException wrapper ;
-
-    List buffers ;
-
-    public BufferConnectionImpl(ORB orb, byte[][] data )
-    {
-	this.orb = orb;
-	wrapper = ORBUtilSystemException.get( orb,
-	    CORBALogDomains.RPC_TRANSPORT ) ;
-	buffers = new ArrayList() ;
-    }
-
-    ////////////////////////////////////////////////////
-    //
-    // framework.transport.Connection
-    //
-
-    public boolean shouldRegisterReadEvent()
-    {
-	return false;
-    }
-
-    public boolean shouldRegisterServerReadEvent()
-    {
-	return false;
-    }
-
-    public boolean read()
-    {
-	return true ;
-    }
-
-    protected CorbaMessageMediator readBits()
-    {
-	return null ;
-    }
-
-    protected boolean dispatch(CorbaMessageMediator messageMediator)
-    {
-    }
-
-    public boolean shouldUseDirectByteBuffers()
-    {
-	return false ;
-    }
-
-    // Only called from readGIOPMessage with (12, 0, 12) as arguments
-    // size is size of buffer to create
-    // offset is offset from start of message in buffer
-    // length is length to read
-    public ByteBuffer read(int size, int offset, int length)
-	throws IOException
-    {
-	byte[] buf = new byte[size];
-	readFully( buf, offset, length);
-	ByteBuffer byteBuffer = ByteBuffer.wrap(buf);
-	byteBuffer.limit(size);
-	return byteBuffer;
-    }
-
-    // Only called as read( buf, 12, msgsize-12 ) in readGIOPMessage
-    // We can ignore the byteBuffer parameter
-    // offset is the starting position to place data in the result
-    // length is the length of the data to read
-    public ByteBuffer read(ByteBuffer byteBuffer, int offset, int length)
-	throws IOException
-    {
-	int size = offset + length;
-	byte[] buf = new byte[size];
-	readFully(buf, offset, length);
-	return ByteBuffer.wrap(buf);
-    }
-
-    // Read size bytes from buffer list and place the data
-    // starting at offset in buf.
-    public void readFully(byte[] buf, int offset, int size) 
-	throws IOException
-    {
-	int remaining = size ;
-	int position = offset ;
-	while (remaining > 0) {
-	    ByteBuffer buff = (ByteBuffer)buffers.get(0) ; 
-	    int dataSize = buff.remaining() ;
-	    int xferSize = dataSize ;
-	    if (dataSize >= remaining) :
-		xferSize = remaining ;
-		buffers.remove(0) ;
-	    }
-	    
-	    buff.get( buf, offset, xferSize ) ;
-
-	    offset += xferSize ;
-	    remaining -= xferSize ;
-	}
-    }    
-
-    public void write(ByteBuffer byteBuffer)
-	throws IOException
-    {
-	buffers.add( byteBuffer ) ;
-    }
-
-    /**
-     * Note:it is possible for this to be called more than once
-     */
-    public synchronized void close() 
-    {
-    }
-
-    public Acceptor getAcceptor()
-    {
-	return null;
-    }
-
-    public ContactInfo getContactInfo()
-    {
-	return null;
-    }
-
-    public EventHandler getEventHandler()
-    {
-	return this;
-    }
-
-    public OutputObject createOutputObject(MessageMediator messageMediator)
-    {
-	// REVISIT - remove this method from Connection and all it subclasses.
-	throw new RuntimeException("*****SocketOrChannelConnectionImpl.createOutputObject - should not be called.");
-    }
-
-    // This is used by the GIOPOutputObject in order to
-    // throw the correct error when handling code sets.
-    // Can we determine if we are on the server side by
-    // other means?  XREVISIT
-    public boolean isServer()
-    {
-        return isServer;
-    }
-
-    public boolean isBusy()
-    {
-	return false ;
-    }
-
-    public long getTimeStamp()
-    {
-	return timeStamp;
-    }
-
-    public void setTimeStamp(long time)
-    {
-	timeStamp = time;
-    }
-
-    public void setState(String stateString)
-    {
-	synchronized (stateEvent) {
-	    if (stateString.equals("ESTABLISHED")) {
-		state =  ESTABLISHED;
-		stateEvent.notifyAll();
-	    } else {
-		// REVISIT: ASSERT
-	    }
-	}
-    }
-
-    public void writeLock()
-    {
-    }
-
-    public void writeUnlock()
-    {
-    }
-
-    public void sendWithoutLock(OutputObject outputObject)
-    {
-    }
-
-    public void registerWaiter(MessageMediator messageMediator)
-    {
-    }
-
-    public void unregisterWaiter(MessageMediator messageMediator)
-    {
-    }
-
-    public InputObject waitForResponse(MessageMediator messageMediator)
-    {
-	return null ;
-    }
-
-    public void setConnectionCache(ConnectionCache connectionCache)
-    {
-    }
-
-    public ConnectionCache getConnectionCache()
-    {
-	return null;	
-    }
-
-    ////////////////////////////////////////////////////
-    //
-    // EventHandler methods
-    //
-
-    public SelectableChannel getChannel()
-    {
-	return null;
-    }
-
-    public int getInterestOps()
-    {
-	return null;
-    }
-
-    //    public Acceptor getAcceptor() - already defined above.
-
-    public Connection getConnection()
-    {
-	return this;
-    }
-
-    ////////////////////////////////////////////////////
-    //
-    // Work methods.
-    //
-
-    public String getName()
-    {
-	return this.toString();
-    }
-
-    public void doWork()
-    {
-    }
-
-    public void setEnqueueTime(long timeInMillis)
-    {
-	enqueueTime = timeInMillis;
-    }
-
-    public long getEnqueueTime()
-    {
-	return enqueueTime;
-    }
-
-    ////////////////////////////////////////////////////
-    //
-    // spi.transport.CorbaConnection.
-    //
-
-    public ResponseWaitingRoom getResponseWaitingRoom()
-    {
-	return null ;
-    }
-
-    // REVISIT - inteface defines isServer but already defined in 
-    // higher interface.
-
-
-    public void serverRequestMapPut(int requestId, 
-				    CorbaMessageMediator messageMediator)
-    {
-	serverRequestMap.put(new Integer(requestId), messageMediator);
-    }
-
-    public CorbaMessageMediator serverRequestMapGet(int requestId)
-    {
-	return (CorbaMessageMediator)
-	    serverRequestMap.get(new Integer(requestId));
-    }
-
-    public void serverRequestMapRemove(int requestId)
-    {
-	serverRequestMap.remove(new Integer(requestId));
-    }
-
-
-    // REVISIT: this is also defined in:
-    // com.sun.corba.se.spi.legacy.connection.Connection
-    public java.net.Socket getSocket()
-    {
-	return null;
-    }
-
-    /** It is possible for a Close Connection to have been
-     ** sent here, but we will not check for this. A "lazy"
-     ** Exception will be thrown in the Worker thread after the
-     ** incoming request has been processed even though the connection
-     ** is closed before the request is processed. This is o.k because
-     ** it is a boundary condition. To prevent it we would have to add
-     ** more locks which would reduce performance in the normal case.
-     **/
-    public synchronized void serverRequestProcessingBegins()
-    {
-        serverRequestCount++;
-    }
-
-    public synchronized void serverRequestProcessingEnds()
-    {
-        serverRequestCount--;
-    }
-
-    //
-    //
-    //
-
-    public synchronized int getNextRequestId() 
-    {
-	return requestId++;
-    }
-
-    // Negotiated code sets for char and wchar data
-    protected CodeSetComponentInfo.CodeSetContext codeSetContext = null;
-
-    public ORB getBroker() 
-    {
-        return orb;
-    }
-
-    public CodeSetComponentInfo.CodeSetContext getCodeSetContext() 
-    {
-        // Needs to be synchronized for the following case when the client
-        // doesn't send the code set context twice, and we have two threads
-        // in ServerRequestDispatcher processCodeSetContext.
-        //
-        // Thread A checks to see if there is a context, there is none, so
-        //     it calls setCodeSetContext, getting the synch lock.
-        // Thread B checks to see if there is a context.  If we didn't synch,
-        //     it might decide to outlaw wchar/wstring.
-        if (codeSetContext == null) {
-            synchronized(this) {
-                return codeSetContext;
-            }
-        }
-
-        return codeSetContext;
-    }
-
-    public synchronized void setCodeSetContext(CodeSetComponentInfo.CodeSetContext csc) {
-        // Double check whether or not we need to do this
-        if (codeSetContext == null) {
-            
-            if (OSFCodeSetRegistry.lookupEntry(csc.getCharCodeSet()) == null ||
-                OSFCodeSetRegistry.lookupEntry(csc.getWCharCodeSet()) == null) {
-                // If the client says it's negotiated a code set that
-                // isn't a fallback and we never said we support, then
-                // it has a bug.
-		throw wrapper.badCodesetsFromClient() ;
-            }
-
-            codeSetContext = csc;
-        }
-    }
-
-    //
-    // from iiop.IIOPConnection.java
-    //
-
-    // Map request ID to an InputObject.
-    // This is so the client thread can start unmarshaling
-    // the reply and remove it from the out_calls map while the
-    // ReaderThread can still obtain the input stream to give
-    // new fragments.  Only the ReaderThread touches the clientReplyMap,
-    // so it doesn't incur synchronization overhead.
-
-    public MessageMediator clientRequestMapGet(int requestId)
-    {
-	return null ;
-    }
-
-    protected MessageMediator clientReply_1_1;
-
-    public void clientReply_1_1_Put(MessageMediator x)
-    {
-	clientReply_1_1 = x;
-    }
-
-    public MessageMediator clientReply_1_1_Get()
-    {
-	return 	clientReply_1_1;
-    }
-
-    public void clientReply_1_1_Remove()
-    {
-	clientReply_1_1 = null;
-    }
-
-    protected MessageMediator serverRequest_1_1;
-
-    public void serverRequest_1_1_Put(MessageMediator x)
-    {
-	serverRequest_1_1 = x;
-    }
-
-    public MessageMediator serverRequest_1_1_Get()
-    {
-	return 	serverRequest_1_1;
-    }
-
-    public void serverRequest_1_1_Remove()
-    {
-	serverRequest_1_1 = null;
-    }
-
-    protected String getStateString( int state ) 
-    {
-        synchronized ( stateEvent ){
-            switch (state) {
-            case OPENING : return "OPENING" ;
-            case ESTABLISHED : return "ESTABLISHED" ;
-            case CLOSE_SENT : return "CLOSE_SENT" ;
-            case CLOSE_RECVD : return "CLOSE_RECVD" ;
-            case ABORT : return "ABORT" ;
-            default : return "???" ;
-            }
-        }
-    }
-    
-    public synchronized boolean isPostInitialContexts() {
-        return postInitialContexts;
-    }
-
-    // Can never be unset...
-    public synchronized void setPostInitialContexts(){
-        postInitialContexts = true;
-    }
-    
-    /**
-     * Wake up the outstanding requests on the connection, and hand them
-     * COMM_FAILURE exception with a given minor code.
-     *
-     * Also, delete connection from connection table and
-     * stop the reader thread.
-
-     * Note that this should only ever be called by the Reader thread for
-     * this connection.
-     * 
-     * @param minor_code The minor code for the COMM_FAILURE major code.
-     * @param die Kill the reader thread (this thread) before exiting.
-     */
-    public void purgeCalls(SystemException systemException,
-			   boolean die, boolean lockHeld)
-    {
-    }
-
-    /*************************************************************************
-    * The following methods are for dealing with Connection cleaning for
-    * better scalability of servers in high network load conditions.
-    **************************************************************************/
-
-    public void sendCloseConnection(GIOPVersion giopVersion)
-	throws IOException 
-    {
-        Message msg = MessageBase.createCloseConnection(giopVersion);
-	sendHelper(giopVersion, msg);
-    }
-
-    public void sendMessageError(GIOPVersion giopVersion)
-	throws IOException 
-    {
-        Message msg = MessageBase.createMessageError(giopVersion);
-	sendHelper(giopVersion, msg);
-    }
-
-    /**
-     * Send a CancelRequest message. This does not lock the connection, so the
-     * caller needs to ensure this method is called appropriately.
-     * @exception IOException - could be due to abortive connection closure.
-     */
-    public void sendCancelRequest(GIOPVersion giopVersion, int requestId)
-	throws IOException 
-    {
-
-        Message msg = MessageBase.createCancelRequest(giopVersion, requestId);
-	sendHelper(giopVersion, msg);
-    }
-
-    protected void sendHelper(GIOPVersion giopVersion, Message msg)
-	throws IOException
-    {
-	// REVISIT: See comments in CDROutputObject constructor.
-        CDROutputObject outputObject = 
-	    new CDROutputObject((ORB)orb, null, giopVersion, this, msg,
-				ORBConstants.STREAM_FORMAT_VERSION_1);
-        msg.write(outputObject);
-
-	outputObject.writeTo(this);
-    }
-
-    public void sendCancelRequestWithLock(GIOPVersion giopVersion,
-					  int requestId)
-	throws IOException 
-    {
-	writeLock();
-	try {
-	    sendCancelRequest(giopVersion, requestId);
-	} finally {
-	    writeUnlock();
-	}
-    }
-
-    // Begin Code Base methods ---------------------------------------
-    //
-    // Set this connection's code base IOR.  The IOR comes from the
-    // SendingContext.  This is an optional service context, but all
-    // JavaSoft ORBs send it.
-    //
-    // The set and get methods don't need to be synchronized since the
-    // first possible get would occur during reading a valuetype, and
-    // that would be after the set.
-
-    // Sets this connection's code base IOR.  This is done after
-    // getting the IOR out of the SendingContext service context.
-    // Our ORBs always send this, but it's optional in CORBA.
-
-    public final void setCodeBaseIOR(IOR ior) {
-        codeBaseServerIOR = ior;
-    }
-
-    public final IOR getCodeBaseIOR() {
-        return codeBaseServerIOR;
-    }
-
-    // Get a CodeBase stub to use in unmarshaling.  The CachedCodeBase
-    // won't connect to the remote codebase unless it's necessary.
-    public final CodeBase getCodeBase() {
-        return cachedCodeBase;
-    }
-
-    // End Code Base methods -----------------------------------------
-
-    // Can be overridden in subclass for different options.
-    protected void setSocketOptions(Socket socket)
-    {
-    }
-
-    public String toString()
-    {
-        synchronized ( stateEvent ){
-            return 
-		"BufferConnectionImpl[" + " "
-		+ getStateString( state ) + " "
-		+ shouldUseSelectThreadToWait() + " "
-		+ shouldUseWorkerThreadForEvent()
-		+ "]" ;
-        }
-    }
-    
-    // Must be public - used in encoding.
-    public void dprint(String msg) 
-    {
-	ORBUtility.dprint("SocketOrChannelConnectionImpl", msg);
-    }
-
-    protected void dprint(String msg, Throwable t)
-    {
-	dprint(msg);
-	t.printStackTrace(System.out);
-    }
-}
-
-// End of file.
--- ./corba/src/share/classes/com/sun/corba/se/impl/transport/DefaultSocketFactoryImpl.java	Tue Mar 18 12:29:47 2014 -0700
+++ ./corba/src/share/classes/com/sun/corba/se/impl/transport/DefaultSocketFactoryImpl.java	Wed May 07 19:25:52 2014 -0700
@@ -32,6 +32,7 @@
 import java.net.ServerSocket;
 import java.nio.channels.SocketChannel;
 import java.nio.channels.ServerSocketChannel;
+import java.security.PrivilegedAction;
 
 import com.sun.corba.se.pept.transport.Acceptor;
 
@@ -44,6 +45,22 @@
     implements ORBSocketFactory
 {
     private ORB orb;
+    private static final boolean keepAlive;
+
+    static {
+        keepAlive = java.security.AccessController.doPrivileged(
+            new PrivilegedAction<Boolean>() {
+                @Override
+                public Boolean run () {
+                    String value =
+                        System.getProperty("com.sun.CORBA.transport.enableTcpKeepAlive");
+                    if (value != null)
+                        return new Boolean(!"false".equalsIgnoreCase(value));
+
+                    return Boolean.FALSE;
+                }
+            });
+    }
 
     public void setORB(ORB orb)
     {
@@ -85,6 +102,9 @@
         // Disable Nagle's algorithm (i.e., always send immediately).
         socket.setTcpNoDelay(true);
 
+        if (keepAlive)
+            socket.setKeepAlive(true);
+
         return socket;
     }
 
@@ -95,6 +115,8 @@
     {
         // Disable Nagle's algorithm (i.e., always send immediately).
         socket.setTcpNoDelay(true);
+        if (keepAlive)
+            socket.setKeepAlive(true);
     }
 }
 
--- ./hotspot/.hgtags	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/.hgtags	Wed May 07 19:26:16 2014 -0700
@@ -626,3 +626,35 @@
 49cada8e39b9215b9fd8b9183743f92625587cfc jdk7u55-b11
 aadc864abd1ced3049bf59ce32786a07997ba190 jdk7u55-b12
 b021fd817a0177b31d1e3d65127a27458e85801e jdk7u55-b13
+d27b468d5f3be3329ff1ff342f3347e6b2e0303b jdk7u55-b30
+dff9147a781672f20bb0577a94233264ea4a95d1 jdk7u55-b14
+8175599864880938d68d0a515fa561043d7d5fd0 jdk7u55-b31
+ae4adc1492d1c90a70bd2d139a939fc0c8329be9 jdk7u60-b00
+af1fc2868a2b919727bfbb0858449bd991bbee4a jdk7u40-b60
+cc83359f5e5eb46dd9176b0a272390b1a0a51fdc hs24.60-b01
+b7d44793cd267b22352c688b0185466741bb7a89 hs24.60-b02
+90cfd4ad3c9263886d876792d72cb24ac0e03a85 hs24.60-b03
+8fd0e931efa57d1579fb1bc8a68ba3924244b99e jdk7u60-b01
+99e96aaac8afc14ce6f9f3d92ef7004cf505b35d hs24.60-b04
+0025a2a965c8f21376278245c2493d8861386fba jdk7u60-b02
+fa59add77d1a8f601a695f137248462fdc68cc2f hs24.60-b05
+a59134ccb1b704b2cd05e157970d425af43e5437 hs24.60-b06
+2c971ed884cec0a9293ccff3def696da81823225 jdk7u60-b03
+1afbeb8cb558429156d432f35e7582716053a9cb hs24.60-b07
+05fe7a87d14908eb3f21a0d29fc72cee2f996b7f jdk7u60-b04
+f52b5452d424545e3b101d808e6d7da763d6f0f3 hs24.60-b08
+462db155547e9bdd7ba26bead42808deb0b10d44 jdk7u60-b05
+0cc4550bd9c57ba3be343bfbfcaf46b9060d5e7d jdk7u60-b06
+2d053c4fd767155b2ac5e3e0a60b08a1bcc73cab jdk7u60-b07
+a198787e7b9bc7b831ad210b67732cdb2be9e46e jdk7u60-b08
+22cae361773d14b467328e8f90cf893550d1d610 jdk7u60-b09
+6f74afd8577eb4b6a0e6f7b25cfef7d6f7d92e5f jdk7u60-b10
+a2ac67a2c1cc867a8d6b525ab1df17204186e636 jdk7u60-b11
+cae50351dcece6e5bf215eabf958c5d669ffff1f jdk7u60-b12
+5853131ba4b448c5d89a3f0aa501fdf07f3b473c jdk7u60-b13
+b226be2040f971855626f5b88cb41a7d5299fea0 jdk7u60-b14
+2871f345b7e5585e20dc7aa91035967fe774cfba jdk7u60-b15
+ec76bacbb5b90efc7988dee5345c656126b97561 jdk7u60-b16
+617a6338e0c4f7699eed5061d7e8f576c3ace029 jdk7u60-b18
+617a6338e0c4f7699eed5061d7e8f576c3ace029 jdk7u60-b17
+361493c7cdb5f75b28efc63389d6cebaaaa43a2c jdk7u60-b19
--- ./hotspot/agent/src/os/linux/ps_core.c	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/agent/src/os/linux/ps_core.c	Wed May 07 19:26:16 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -700,29 +700,61 @@
 
 // read segments of a shared object
 static bool read_lib_segments(struct ps_prochandle* ph, int lib_fd, ELF_EHDR* lib_ehdr, uintptr_t lib_base) {
-   int i = 0;
-   ELF_PHDR* phbuf;
-   ELF_PHDR* lib_php = NULL;
+  int i = 0;
+  ELF_PHDR* phbuf;
+  ELF_PHDR* lib_php = NULL;
 
-   if ((phbuf = read_program_header_table(lib_fd, lib_ehdr)) == NULL)
-      return false;
+  int page_size = sysconf(_SC_PAGE_SIZE);
 
-   // we want to process only PT_LOAD segments that are not writable.
-   // i.e., text segments. The read/write/exec (data) segments would
-   // have been already added from core file segments.
-   for (lib_php = phbuf, i = 0; i < lib_ehdr->e_phnum; i++) {
-      if ((lib_php->p_type == PT_LOAD) && !(lib_php->p_flags & PF_W) && (lib_php->p_filesz != 0)) {
-         if (add_map_info(ph, lib_fd, lib_php->p_offset, lib_php->p_vaddr + lib_base, lib_php->p_filesz) == NULL)
-            goto err;
+  if ((phbuf = read_program_header_table(lib_fd, lib_ehdr)) == NULL) {
+    return false;
+  }
+
+  // we want to process only PT_LOAD segments that are not writable.
+  // i.e., text segments. The read/write/exec (data) segments would
+  // have been already added from core file segments.
+  for (lib_php = phbuf, i = 0; i < lib_ehdr->e_phnum; i++) {
+    if ((lib_php->p_type == PT_LOAD) && !(lib_php->p_flags & PF_W) && (lib_php->p_filesz != 0)) {
+
+      uintptr_t target_vaddr = lib_php->p_vaddr + lib_base;
+      map_info *existing_map = core_lookup(ph, target_vaddr);
+
+      if (existing_map == NULL){
+        if (add_map_info(ph, lib_fd, lib_php->p_offset,
+                          target_vaddr, lib_php->p_memsz) == NULL) {
+          goto err;
+        }
+      } else {
+        // Coredump stores value of p_memsz elf field
+        // rounded up to page boundary.
+
+        if ((existing_map->memsz != page_size) &&
+            (existing_map->fd != lib_fd) &&
+            (ROUNDUP(existing_map->memsz, page_size) != ROUNDUP(lib_php->p_memsz, page_size))) {
+
+          print_debug("address conflict @ 0x%lx (existing map size = %ld, size = %ld, flags = %d)\n",
+                        target_vaddr, existing_map->memsz, lib_php->p_memsz, lib_php->p_flags);
+          goto err;
+        }
+
+        /* replace PT_LOAD segment with library segment */
+        print_debug("overwrote with new address mapping (memsz %ld -> %ld)\n",
+                     existing_map->memsz, ROUNDUP(lib_php->p_memsz, page_size));
+
+        existing_map->fd = lib_fd;
+        existing_map->offset = lib_php->p_offset;
+        existing_map->memsz = ROUNDUP(lib_php->p_memsz, page_size);
       }
-      lib_php++;
-   }
+    }
 
-   free(phbuf);
-   return true;
+    lib_php++;
+  }
+
+  free(phbuf);
+  return true;
 err:
-   free(phbuf);
-   return false;
+  free(phbuf);
+  return false;
 }
 
 // process segments from interpreter (ld.so or ld-linux.so)
--- ./hotspot/agent/src/share/classes/sun/jvm/hotspot/interpreter/Bytecodes.java	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/agent/src/share/classes/sun/jvm/hotspot/interpreter/Bytecodes.java	Wed May 07 19:26:16 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -272,9 +272,10 @@
   public static final int _fast_aldc            = 229;
   public static final int _fast_aldc_w          = 230;
   public static final int _return_register_finalizer = 231;
-  public static final int _shouldnotreachhere   = 232; // For debugging
+  public static final int _invokehandle         = 232;
+  public static final int _shouldnotreachhere   = 233; // For debugging
 
-  public static final int number_of_codes       = 233;
+  public static final int number_of_codes       = 234;
 
   // Flag bits derived from format strings, can_trap, can_rewrite, etc.:
   // semantic flags:
@@ -798,6 +799,9 @@
 
     def(_return_register_finalizer, "return_register_finalizer", "b"    , null    , BasicType.getTVoid()   , 0, true, _return );
 
+    def(_invokehandle        , "invokehandle"        , "bJJ"  , null    , BasicType.getTIllegal(), -1, true, _invokevirtual   );
+
+
     def(_fast_aldc           , "fast_aldc"           , "bj"   , null    , BasicType.getTObject(),   1, true,  _ldc   );
     def(_fast_aldc_w         , "fast_aldc_w"         , "bJJ"  , null    , BasicType.getTObject(),   1, true,  _ldc_w );
 
--- ./hotspot/agent/src/share/classes/sun/jvm/hotspot/jdi/JVMTIThreadState.java	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/agent/src/share/classes/sun/jvm/hotspot/jdi/JVMTIThreadState.java	Wed May 07 19:26:16 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2013 Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -29,11 +29,10 @@
     public static final int JVMTI_THREAD_STATE_ALIVE = 0x0001;
     public static final int JVMTI_THREAD_STATE_TERMINATED = 0x0002;
     public static final int JVMTI_THREAD_STATE_RUNNABLE = 0x0004;
-    public static final int JVMTI_THREAD_STATE_WAITING = 0x0008;
+    public static final int JVMTI_THREAD_STATE_WAITING = 0x0080;
     public static final int JVMTI_THREAD_STATE_WAITING_INDEFINITELY = 0x0010;
     public static final int JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT = 0x0020;
     public static final int JVMTI_THREAD_STATE_SLEEPING = 0x0040;
-    public static final int JVMTI_THREAD_STATE_WAITING_FOR_NOTIFICATION = 0x0080;
     public static final int JVMTI_THREAD_STATE_IN_OBJECT_WAIT = 0x0100;
     public static final int JVMTI_THREAD_STATE_PARKED = 0x0200;
     public static final int JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER = 0x0400;
--- ./hotspot/agent/src/share/classes/sun/jvm/hotspot/runtime/OSThread.java	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/agent/src/share/classes/sun/jvm/hotspot/runtime/OSThread.java	Wed May 07 19:26:16 2014 -0700
@@ -32,7 +32,7 @@
 // to the sys_thread_t structure of the classic JVM implementation.
 public class OSThread extends VMObject {
     private static JIntField interruptedField;
-    private static JIntField threadIdField;
+    private static Field threadIdField;
     static {
         VM.registerVMInitializedObserver(new Observer() {
             public void update(Observable o, Object data) {
@@ -44,7 +44,7 @@
     private static synchronized void initialize(TypeDataBase db) {
         Type type = db.lookupType("OSThread");
         interruptedField = type.getJIntField("_interrupted");
-        threadIdField = type.getJIntField("_thread_id");
+        threadIdField = type.getField("_thread_id");
     }
 
     public OSThread(Address addr) {
@@ -56,7 +56,7 @@
     }
 
     public int threadId() {
-        return (int)threadIdField.getValue(addr);
+        return threadIdField.getJInt(addr);
     }
 
 }
--- ./hotspot/make/bsd/makefiles/buildtree.make	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/make/bsd/makefiles/buildtree.make	Wed May 07 19:26:16 2014 -0700
@@ -1,5 +1,6 @@
 #
 # Copyright (c) 2005, 2011, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2013 Red Hat, Inc.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -59,7 +60,7 @@
 # needs to be set here since this Makefile doesn't include defs.make
 OS_VENDOR:=$(shell uname -s)
 
--include $(SPEC)
+include $(GAMMADIR)/make/defs.make
 include $(GAMMADIR)/make/scm.make
 include $(GAMMADIR)/make/altsrc.make
 
@@ -215,6 +216,7 @@
 	echo "HOTSPOT_BUILD_USER = $(HOTSPOT_BUILD_USER)"; \
 	echo "HOTSPOT_VM_DISTRO = $(HOTSPOT_VM_DISTRO)"; \
 	echo "OPENJDK = $(OPENJDK)"; \
+	echo "ZERO_BUILD = $(ZERO_BUILD)"; \
 	echo; \
 	echo "# Used for platform dispatching"; \
 	echo "TARGET_DEFINES  = -DTARGET_OS_FAMILY_\$$(Platform_os_family)"; \
--- ./hotspot/make/bsd/makefiles/gcc.make	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/make/bsd/makefiles/gcc.make	Wed May 07 19:26:16 2014 -0700
@@ -1,5 +1,6 @@
 #
 # Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2013 Red Hat, Inc.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -105,10 +106,10 @@
 VM_PICFLAG/AOUT   =
 VM_PICFLAG        = $(VM_PICFLAG/$(LINK_INTO))
 
-ifeq ($(JVM_VARIANT_ZERO), true)
+ifeq ($(TYPE),ZERO)
   CFLAGS += $(LIBFFI_CFLAGS)
 endif
-ifeq ($(JVM_VARIANT_ZEROSHARK), true)
+ifeq ($(TYPE),SHARK)
   CFLAGS += $(LIBFFI_CFLAGS)
   CFLAGS += $(LLVM_CFLAGS)
 endif
--- ./hotspot/make/bsd/makefiles/vm.make	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/make/bsd/makefiles/vm.make	Wed May 07 19:26:16 2014 -0700
@@ -1,5 +1,6 @@
 #
 # Copyright (c) 1999, 2012, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2013 Red Hat, Inc.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -42,7 +43,9 @@
 -include $(DEP_DIR)/*.d
 
 # read machine-specific adjustments (%%% should do this via buildtree.make?)
-ifeq ($(findstring true, $(JVM_VARIANT_ZERO) $(JVM_VARIANT_ZEROSHARK)), true)
+ifeq ($(TYPE),ZERO)
+  include $(MAKEFILES_DIR)/zeroshark.make
+else ifeq ($(TYPE),SHARK)
   include $(MAKEFILES_DIR)/zeroshark.make
 else
   include $(MAKEFILES_DIR)/$(BUILDARCH).make
@@ -271,10 +274,10 @@
 
   LIBS_VM                  += $(LIBS)
 endif
-ifeq ($(JVM_VARIANT_ZERO), true)
+ifeq ($(TYPE),ZERO)
   LIBS_VM += $(LIBFFI_LIBS)
 endif
-ifeq ($(JVM_VARIANT_ZEROSHARK), true)
+ifeq ($(TYPE),SHARK)
   LIBS_VM   += $(LIBFFI_LIBS) $(LLVM_LIBS)
   LFLAGS_VM += $(LLVM_LDFLAGS)
 endif
--- ./hotspot/make/hotspot_version	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/make/hotspot_version	Wed May 07 19:26:16 2014 -0700
@@ -34,8 +34,8 @@
 HOTSPOT_VM_COPYRIGHT=Copyright 2014
 
 HS_MAJOR_VER=24
-HS_MINOR_VER=55
-HS_BUILD_NUMBER=03
+HS_MINOR_VER=60
+HS_BUILD_NUMBER=09
 
 JDK_MAJOR_VER=1
 JDK_MINOR_VER=7
--- ./hotspot/make/linux/makefiles/buildtree.make	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/make/linux/makefiles/buildtree.make	Wed May 07 19:26:16 2014 -0700
@@ -1,5 +1,6 @@
 #
 # Copyright (c) 2005, 2012, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2013 Red Hat, Inc.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -56,7 +57,7 @@
 # The makefiles are split this way so that "make foo" will run faster by not
 # having to read the dependency files for the vm.
 
--include $(SPEC)
+include $(GAMMADIR)/make/defs.make
 include $(GAMMADIR)/make/scm.make
 include $(GAMMADIR)/make/altsrc.make
 
@@ -208,6 +209,7 @@
 	echo "HOTSPOT_BUILD_USER = $(HOTSPOT_BUILD_USER)"; \
 	echo "HOTSPOT_VM_DISTRO = $(HOTSPOT_VM_DISTRO)"; \
 	echo "OPENJDK = $(OPENJDK)"; \
+	echo "ZERO_BUILD = $(ZERO_BUILD)"; \
 	echo; \
 	echo "# Used for platform dispatching"; \
 	echo "TARGET_DEFINES  = -DTARGET_OS_FAMILY_\$$(Platform_os_family)"; \
--- ./hotspot/make/linux/makefiles/gcc.make	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/make/linux/makefiles/gcc.make	Wed May 07 19:26:16 2014 -0700
@@ -1,5 +1,6 @@
 #
 # Copyright (c) 1999, 2012, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2013 Red Hat, Inc.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -72,10 +73,10 @@
 VM_PICFLAG/AOUT   =
 VM_PICFLAG        = $(VM_PICFLAG/$(LINK_INTO))
 
-ifeq ($(JVM_VARIANT_ZERO), true)
+ifeq ($(TYPE),ZERO)
 CFLAGS += $(LIBFFI_CFLAGS)
 endif
-ifeq ($(JVM_VARIANT_ZEROSHARK), true)
+ifeq ($(TYPE),SHARK)
 CFLAGS += $(LIBFFI_CFLAGS)
 CFLAGS += $(LLVM_CFLAGS)
 endif
--- ./hotspot/make/linux/makefiles/vm.make	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/make/linux/makefiles/vm.make	Wed May 07 19:26:16 2014 -0700
@@ -1,5 +1,6 @@
 #
 # Copyright (c) 1999, 2012, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2013 Red Hat, Inc.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -42,7 +43,9 @@
 -include $(DEP_DIR)/*.d
 
 # read machine-specific adjustments (%%% should do this via buildtree.make?)
-ifeq ($(findstring true, $(JVM_VARIANT_ZERO) $(JVM_VARIANT_ZEROSHARK)), true)
+ifeq ($(TYPE),ZERO)
+  include $(MAKEFILES_DIR)/zeroshark.make
+else ifeq ($(TYPE),SHARK)
   include $(MAKEFILES_DIR)/zeroshark.make
 else
   include $(MAKEFILES_DIR)/$(BUILDARCH).make
@@ -244,7 +247,7 @@
 vm.def: $(Res_Files) $(Obj_Files)
 	sh $(GAMMADIR)/make/linux/makefiles/build_vm_def.sh *.o > $@
 
-ifeq ($(JVM_VARIANT_ZEROSHARK), true)
+ifeq ($(TYPE),SHARK)
   STATIC_CXX = false
 else
   ifeq ($(ZERO_LIBARCH), ppc64)
@@ -276,10 +279,10 @@
 
   LIBS_VM                  += $(LIBS)
 endif
-ifeq ($(JVM_VARIANT_ZERO), true)
+ifeq ($(TYPE),ZERO)
   LIBS_VM += $(LIBFFI_LIBS)
 endif
-ifeq ($(JVM_VARIANT_ZEROSHARK), true)
+ifeq ($(TYPE),SHARK)
   LIBS_VM   += $(LIBFFI_LIBS) $(LLVM_LIBS)
   LFLAGS_VM += $(LLVM_LDFLAGS)
 endif
--- ./hotspot/src/cpu/sparc/vm/assembler_sparc.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/cpu/sparc/vm/assembler_sparc.cpp	Wed May 07 19:26:16 2014 -0700
@@ -4512,7 +4512,7 @@
 #define __ masm.
   address start = __ pc();
 
-  Label not_already_dirty, restart, refill;
+  Label not_already_dirty, restart, refill, young_card;
 
 #ifdef _LP64
   __ srlx(O0, CardTableModRefBS::card_shift, O0);
@@ -4523,9 +4523,15 @@
   __ set(addrlit, O1); // O1 := <card table base>
   __ ldub(O0, O1, O2); // O2 := [O0 + O1]
 
+  __ cmp_and_br_short(O2, G1SATBCardTableModRefBS::g1_young_card_val(), Assembler::equal, Assembler::pt, young_card);
+
+  __ membar(Assembler::Membar_mask_bits(Assembler::StoreLoad));
+  __ ldub(O0, O1, O2); // O2 := [O0 + O1]
+
   assert(CardTableModRefBS::dirty_card_val() == 0, "otherwise check this code");
   __ cmp_and_br_short(O2, G0, Assembler::notEqual, Assembler::pt, not_already_dirty);
 
+  __ bind(young_card);
   // We didn't take the branch, so we're already dirty: return.
   // Use return-from-leaf
   __ retl();
--- ./hotspot/src/cpu/sparc/vm/c1_Runtime1_sparc.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/cpu/sparc/vm/c1_Runtime1_sparc.cpp	Wed May 07 19:26:16 2014 -0700
@@ -36,6 +36,9 @@
 #include "runtime/signature.hpp"
 #include "runtime/vframeArray.hpp"
 #include "vmreg_sparc.inline.hpp"
+#ifndef SERIALGC
+#include "gc_implementation/g1/g1SATBCardTableModRefBS.hpp"
+#endif
 
 // Implementation of StubAssembler
 
@@ -898,7 +901,7 @@
         Register tmp2 = G3_scratch;
         jbyte* byte_map_base = ((CardTableModRefBS*)bs)->byte_map_base;
 
-        Label not_already_dirty, restart, refill;
+        Label not_already_dirty, restart, refill, young_card;
 
 #ifdef _LP64
         __ srlx(addr, CardTableModRefBS::card_shift, addr);
@@ -910,9 +913,15 @@
         __ set(rs, cardtable);         // cardtable := <card table base>
         __ ldub(addr, cardtable, tmp); // tmp := [addr + cardtable]
 
+        __ cmp_and_br_short(tmp, G1SATBCardTableModRefBS::g1_young_card_val(), Assembler::equal, Assembler::pt, young_card);
+
+        __ membar(Assembler::Membar_mask_bits(Assembler::StoreLoad));
+        __ ldub(addr, cardtable, tmp); // tmp := [addr + cardtable]
+
         assert(CardTableModRefBS::dirty_card_val() == 0, "otherwise check this code");
         __ cmp_and_br_short(tmp, G0, Assembler::notEqual, Assembler::pt, not_already_dirty);
 
+        __ bind(young_card);
         // We didn't take the branch, so we're already dirty: return.
         // Use return-from-leaf
         __ retl();
--- ./hotspot/src/cpu/sparc/vm/sparc.ad	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/cpu/sparc/vm/sparc.ad	Wed May 07 19:26:16 2014 -0700
@@ -3399,8 +3399,8 @@
   interface(CONST_INTER);
 %}
 
-// Unsigned (positive) Integer Immediate: 13-bit
-operand immU13() %{
+// Unsigned Integer Immediate: 12-bit (non-negative that fits in simm13)
+operand immU12() %{
   predicate((0 <= n->get_int()) && Assembler::is_simm13(n->get_int()));
   match(ConI);
   op_cost(0);
@@ -3436,6 +3436,17 @@
   interface(CONST_INTER);
 %}
 
+// Int Immediate non-negative
+operand immU31()
+%{
+  predicate(n->get_int() >= 0);
+  match(ConI);
+
+  op_cost(0);
+  format %{ %}
+  interface(CONST_INTER);
+%}
+
 // Integer Immediate: 0-bit
 operand immI0() %{
   predicate(n->get_int() == 0);
@@ -5732,7 +5743,6 @@
   effect(TEMP dst, TEMP tmp);
   ins_cost(MEMORY_REF_COST + 2*DEFAULT_COST);
 
-  size((3+1)*4);  // set may use two instructions.
   format %{ "LDUH   $mem,$dst\t! ushort/char & 16-bit mask -> long\n\t"
             "SET    $mask,$tmp\n\t"
             "AND    $dst,$tmp,$dst" %}
@@ -5854,13 +5864,13 @@
   ins_pipe(iload_mem);
 %}
 
-// Load Integer with a 13-bit mask into a Long Register
-instruct loadI2L_immI13(iRegL dst, memory mem, immI13 mask) %{
+// Load Integer with a 12-bit mask into a Long Register
+instruct loadI2L_immU12(iRegL dst, memory mem, immU12 mask) %{
   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
   ins_cost(MEMORY_REF_COST + DEFAULT_COST);
 
   size(2*4);
-  format %{ "LDUW   $mem,$dst\t! int & 13-bit mask -> long\n\t"
+  format %{ "LDUW   $mem,$dst\t! int & 12-bit mask -> long\n\t"
             "AND    $dst,$mask,$dst" %}
   ins_encode %{
     Register Rdst = $dst$$Register;
@@ -5870,14 +5880,13 @@
   ins_pipe(iload_mem);
 %}
 
-// Load Integer with a 32-bit mask into a Long Register
-instruct loadI2L_immI(iRegL dst, memory mem, immI mask, iRegL tmp) %{
+// Load Integer with a 31-bit mask into a Long Register
+instruct loadI2L_immU31(iRegL dst, memory mem, immU31 mask, iRegL tmp) %{
   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
   effect(TEMP dst, TEMP tmp);
   ins_cost(MEMORY_REF_COST + 2*DEFAULT_COST);
 
-  size((3+1)*4);  // set may use two instructions.
-  format %{ "LDUW   $mem,$dst\t! int & 32-bit mask -> long\n\t"
+  format %{ "LDUW   $mem,$dst\t! int & 31-bit mask -> long\n\t"
             "SET    $mask,$tmp\n\t"
             "AND    $dst,$tmp,$dst" %}
   ins_encode %{
@@ -8919,7 +8928,7 @@
   ins_pipe(ialu_cconly_reg_reg);
 %}
 
-instruct compU_iReg_imm13(flagsRegU icc, iRegI op1, immU13 op2 ) %{
+instruct compU_iReg_imm13(flagsRegU icc, iRegI op1, immU12 op2 ) %{
   match(Set icc (CmpU op1 op2));
 
   size(4);
--- ./hotspot/src/cpu/sparc/vm/templateInterpreter_sparc.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/cpu/sparc/vm/templateInterpreter_sparc.cpp	Wed May 07 19:26:16 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -1873,6 +1873,25 @@
   if (ProfileInterpreter) {
     __ set_method_data_pointer_for_bcp();
   }
+
+  if (EnableInvokeDynamic) {
+    Label L_done;
+
+    __ ldub(Address(Lbcp, 0), G1_scratch);  // Load current bytecode
+    __ cmp_and_br_short(G1_scratch, Bytecodes::_invokestatic, Assembler::notEqual, Assembler::pn, L_done);
+
+    // The member name argument must be restored if _invokestatic is re-executed after a PopFrame call.
+    // Detect such a case in the InterpreterRuntime function and return the member name argument, or NULL.
+
+    __ call_VM(G1_scratch, CAST_FROM_FN_PTR(address, InterpreterRuntime::member_name_arg_or_null), I0, Lmethod, Lbcp);
+
+    __ br_null(G1_scratch, false, Assembler::pn, L_done);
+    __ delayed()->nop();
+
+    __ st_ptr(G1_scratch, Lesp, wordSize);
+    __ bind(L_done);
+  }
+
   // Resume bytecode interpretation at the current bcp
   __ dispatch_next(vtos);
   // end of JVMTI PopFrame support
--- ./hotspot/src/cpu/x86/vm/assembler_x86.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/cpu/x86/vm/assembler_x86.cpp	Wed May 07 19:26:16 2014 -0700
@@ -8754,13 +8754,18 @@
   const Register card_addr = tmp;
   lea(card_addr, as_Address(ArrayAddress(cardtable, index)));
 #endif
-  cmpb(Address(card_addr, 0), 0);
+  cmpb(Address(card_addr, 0), (int)G1SATBCardTableModRefBS::g1_young_card_val());
   jcc(Assembler::equal, done);
 
+  membar(Assembler::Membar_mask_bits(Assembler::StoreLoad));
+  cmpb(Address(card_addr, 0), (int)CardTableModRefBS::dirty_card_val());
+  jcc(Assembler::equal, done);
+
+
   // storing a region crossing, non-NULL oop, card is clean.
   // dirty card and log.
 
-  movb(Address(card_addr, 0), 0);
+  movb(Address(card_addr, 0), (int)CardTableModRefBS::dirty_card_val());
 
   cmpl(queue_index, 0);
   jcc(Assembler::equal, runtime);
--- ./hotspot/src/cpu/x86/vm/c1_LIRAssembler_x86.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/cpu/x86/vm/c1_LIRAssembler_x86.cpp	Wed May 07 19:26:16 2014 -0700
@@ -1686,14 +1686,6 @@
   }
 
   assert_different_registers(obj, k_RInfo, klass_RInfo);
-  if (!k->is_loaded()) {
-    jobject2reg_with_patching(k_RInfo, op->info_for_patch());
-  } else {
-#ifdef _LP64
-    __ movoop(k_RInfo, k->constant_encoding());
-#endif // _LP64
-  }
-  assert(obj != k_RInfo, "must be different");
 
   __ cmpptr(obj, (int32_t)NULL_WORD);
   if (op->should_profile()) {
@@ -1710,6 +1702,14 @@
   } else {
     __ jcc(Assembler::equal, *obj_is_null);
   }
+
+  if (!k->is_loaded()) {
+    jobject2reg_with_patching(k_RInfo, op->info_for_patch());
+  } else {
+#ifdef _LP64
+    __ movoop(k_RInfo, k->constant_encoding());
+#endif // _LP64
+  }
   __ verify_oop(obj);
 
   if (op->fast_check()) {
--- ./hotspot/src/cpu/x86/vm/c1_LIRGenerator_x86.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/cpu/x86/vm/c1_LIRGenerator_x86.cpp	Wed May 07 19:26:16 2014 -0700
@@ -1395,19 +1395,18 @@
     addr = new LIR_Address(src.result(), offset, type);
   }
 
-  if (data != dst) {
-    __ move(data, dst);
-    data = dst;
-  }
+  // Because we want a 2-arg form of xchg and xadd
+  __ move(data, dst);
+
   if (x->is_add()) {
-    __ xadd(LIR_OprFact::address(addr), data, dst, LIR_OprFact::illegalOpr);
+    __ xadd(LIR_OprFact::address(addr), dst, dst, LIR_OprFact::illegalOpr);
   } else {
     if (is_obj) {
       // Do the pre-write barrier, if any.
       pre_barrier(LIR_OprFact::address(addr), LIR_OprFact::illegalOpr /* pre_val */,
                   true /* do_load */, false /* patch */, NULL);
     }
-    __ xchg(LIR_OprFact::address(addr), data, dst, LIR_OprFact::illegalOpr);
+    __ xchg(LIR_OprFact::address(addr), dst, dst, LIR_OprFact::illegalOpr);
     if (is_obj) {
       // Seems to be a precise address
       post_barrier(LIR_OprFact::address(addr), data);
--- ./hotspot/src/cpu/x86/vm/c1_Runtime1_x86.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/cpu/x86/vm/c1_Runtime1_x86.cpp	Wed May 07 19:26:16 2014 -0700
@@ -37,6 +37,9 @@
 #include "runtime/signature.hpp"
 #include "runtime/vframeArray.hpp"
 #include "vmreg_x86.inline.hpp"
+#ifndef SERIALGC
+#include "gc_implementation/g1/g1SATBCardTableModRefBS.hpp"
+#endif
 
 
 // Implementation of StubAssembler
@@ -1743,13 +1746,17 @@
         __ leal(card_addr, __ as_Address(ArrayAddress(cardtable, index)));
 #endif
 
-        __ cmpb(Address(card_addr, 0), 0);
+        __ cmpb(Address(card_addr, 0), (int)G1SATBCardTableModRefBS::g1_young_card_val());
+        __ jcc(Assembler::equal, done);
+
+        __ membar(Assembler::Membar_mask_bits(Assembler::StoreLoad));
+        __ cmpb(Address(card_addr, 0), (int)CardTableModRefBS::dirty_card_val());
         __ jcc(Assembler::equal, done);
 
         // storing region crossing non-NULL, card is clean.
         // dirty card and log.
 
-        __ movb(Address(card_addr, 0), 0);
+        __ movb(Address(card_addr, 0), (int)CardTableModRefBS::dirty_card_val());
 
         __ cmpl(queue_index, 0);
         __ jcc(Assembler::equal, runtime);
--- ./hotspot/src/cpu/x86/vm/frame_x86.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/cpu/x86/vm/frame_x86.cpp	Wed May 07 19:26:16 2014 -0700
@@ -94,12 +94,6 @@
     // other generic buffer blobs are more problematic so we just assume they are
     // ok. adapter blobs never have a frame complete and are never ok.
 
-    // check for a valid frame_size, otherwise we are unlikely to get a valid sender_pc
-
-    if (!Interpreter::contains(_pc) && _cb->frame_size() <= 0) {
-      return false;
-    }
-
     if (!_cb->is_frame_complete_at(_pc)) {
       if (_cb->is_nmethod() || _cb->is_adapter_blob() || _cb->is_runtime_stub()) {
         return false;
@@ -139,6 +133,11 @@
       // must be some sort of compiled/runtime frame
       // fp does not have to be safe (although it could be check for c1?)
 
+      // check for a valid frame_size, otherwise we are unlikely to get a valid sender_pc
+      if (_cb->frame_size() <= 0) {
+        return false;
+      }
+
       sender_sp = _unextended_sp + _cb->frame_size();
       // On Intel the return_address is always the word on the stack
       sender_pc = (address) *(sender_sp-1);
--- ./hotspot/src/cpu/x86/vm/globals_x86.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/cpu/x86/vm/globals_x86.hpp	Wed May 07 19:26:16 2014 -0700
@@ -62,7 +62,7 @@
 // due to lack of optimization caused by C++ compiler bugs
 define_pd_global(intx, StackShadowPages, NOT_WIN64(20) WIN64_ONLY(6) DEBUG_ONLY(+2));
 #else
-define_pd_global(intx, StackShadowPages, 4 DEBUG_ONLY(+5));
+define_pd_global(intx, StackShadowPages, 6 DEBUG_ONLY(+5));
 #endif // AMD64
 
 define_pd_global(intx, PreInflateSpin,           10);
--- ./hotspot/src/cpu/x86/vm/templateInterpreter_x86_32.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/cpu/x86/vm/templateInterpreter_x86_32.cpp	Wed May 07 19:26:16 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -1789,6 +1789,27 @@
   __ get_thread(thread);
   __ movl(Address(thread, JavaThread::popframe_condition_offset()), JavaThread::popframe_inactive);
 
+  if (EnableInvokeDynamic) {
+    Label L_done;
+    const Register local0 = rdi;
+
+    __ cmpb(Address(rsi, 0), Bytecodes::_invokestatic);
+    __ jcc(Assembler::notEqual, L_done);
+
+    // The member name argument must be restored if _invokestatic is re-executed after a PopFrame call.
+    // Detect such a case in the InterpreterRuntime function and return the member name argument, or NULL.
+
+    __ get_method(rdx);
+    __ movptr(rax, Address(local0, 0));
+    __ call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::member_name_arg_or_null), rax, rdx, rsi);
+
+    __ testptr(rax, rax);
+    __ jcc(Assembler::zero, L_done);
+
+    __ movptr(Address(rbx, 0), rax);
+    __ bind(L_done);
+  }
+
   __ dispatch_next(vtos);
   // end of PopFrame support
 
--- ./hotspot/src/cpu/x86/vm/templateInterpreter_x86_64.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/cpu/x86/vm/templateInterpreter_x86_64.cpp	Wed May 07 19:26:16 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -1815,6 +1815,27 @@
   __ movl(Address(r15_thread, JavaThread::popframe_condition_offset()),
           JavaThread::popframe_inactive);
 
+  if (EnableInvokeDynamic) {
+    Label L_done;
+    const Register local0 = r14;
+
+    __ cmpb(Address(r13, 0), Bytecodes::_invokestatic);
+    __ jcc(Assembler::notEqual, L_done);
+
+    // The member name argument must be restored if _invokestatic is re-executed after a PopFrame call.
+    // Detect such a case in the InterpreterRuntime function and return the member name argument, or NULL.
+
+    __ get_method(rdx);
+    __ movptr(rax, Address(local0, 0));
+    __ call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::member_name_arg_or_null), rax, rdx, r13);
+
+    __ testptr(rax, rax);
+    __ jcc(Assembler::zero, L_done);
+
+    __ movptr(Address(rbx, 0), rax);
+    __ bind(L_done);
+  }
+
   __ dispatch_next(vtos);
   // end of PopFrame support
 
--- ./hotspot/src/cpu/x86/vm/x86_32.ad	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/cpu/x86/vm/x86_32.ad	Wed May 07 19:26:16 2014 -0700
@@ -3919,6 +3919,17 @@
   interface(CONST_INTER);
 %}
 
+// Int Immediate non-negative
+operand immU31()
+%{
+  predicate(n->get_int() >= 0);
+  match(ConI);
+
+  op_cost(0);
+  format %{ %}
+  interface(CONST_INTER);
+%}
+
 // Constant for long shifts
 operand immI_32() %{
   predicate( n->get_int() == 32 );
@@ -6135,12 +6146,12 @@
   ins_pipe(ialu_reg_mem);
 %}
 
-// Load Integer with 32-bit mask into Long Register
-instruct loadI2L_immI(eRegL dst, memory mem, immI mask, eFlagsReg cr) %{
+// Load Integer with 31-bit mask into Long Register
+instruct loadI2L_immU31(eRegL dst, memory mem, immU31 mask, eFlagsReg cr) %{
   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
   effect(KILL cr);
 
-  format %{ "MOV    $dst.lo,$mem\t# int & 32-bit mask -> long\n\t"
+  format %{ "MOV    $dst.lo,$mem\t# int & 31-bit mask -> long\n\t"
             "XOR    $dst.hi,$dst.hi\n\t"
             "AND    $dst.lo,$mask" %}
   ins_encode %{
--- ./hotspot/src/cpu/x86/vm/x86_64.ad	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/cpu/x86/vm/x86_64.ad	Wed May 07 19:26:16 2014 -0700
@@ -3142,6 +3142,17 @@
   interface(CONST_INTER);
 %}
 
+// Int Immediate non-negative
+operand immU31()
+%{
+  predicate(n->get_int() >= 0);
+  match(ConI);
+
+  op_cost(0);
+  format %{ %}
+  interface(CONST_INTER);
+%}
+
 // Constant for long shifts
 operand immI_32()
 %{
@@ -5083,12 +5094,12 @@
   ins_pipe(ialu_reg_mem);
 %}
 
-// Load Integer with a 32-bit mask into Long Register
-instruct loadI2L_immI(rRegL dst, memory mem, immI mask, rFlagsReg cr) %{
+// Load Integer with a 31-bit mask into Long Register
+instruct loadI2L_immU31(rRegL dst, memory mem, immU31 mask, rFlagsReg cr) %{
   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
   effect(KILL cr);
 
-  format %{ "movl    $dst, $mem\t# int & 32-bit mask -> long\n\t"
+  format %{ "movl    $dst, $mem\t# int & 31-bit mask -> long\n\t"
             "andl    $dst, $mask" %}
   ins_encode %{
     Register Rdst = $dst$$Register;
--- ./hotspot/src/cpu/zero/vm/entryFrame_zero.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/cpu/zero/vm/entryFrame_zero.hpp	Wed May 07 19:26:16 2014 -0700
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright 2008, 2010 Red Hat, Inc.
+ * Copyright (c) 2013 Red Hat, Inc.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -58,8 +58,8 @@
                            JavaCallWrapper* call_wrapper,
                            TRAPS);
  public:
-  JavaCallWrapper *call_wrapper() const {
-    return (JavaCallWrapper *) value_of_word(call_wrapper_off);
+  JavaCallWrapper **call_wrapper() const {
+    return (JavaCallWrapper **) addr_of_word(call_wrapper_off);
   }
 
  public:
--- ./hotspot/src/cpu/zero/vm/frame_zero.inline.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/cpu/zero/vm/frame_zero.inline.hpp	Wed May 07 19:26:16 2014 -0700
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2007, 2013, Red Hat, Inc.
+ * Copyright (c) 2013 Red Hat, Inc.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -132,7 +132,7 @@
   return fp();
 }
 
-inline JavaCallWrapper* frame::entry_frame_call_wrapper() const {
+inline JavaCallWrapper** frame::entry_frame_call_wrapper_addr() const {
   return zero_entryframe()->call_wrapper();
 }
 
--- ./hotspot/src/os/bsd/vm/attachListener_bsd.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/os/bsd/vm/attachListener_bsd.cpp	Wed May 07 19:26:16 2014 -0700
@@ -460,14 +460,14 @@
 
 void AttachListener::vm_start() {
   char fn[UNIX_PATH_MAX];
-  struct stat64 st;
+  struct stat st;
   int ret;
 
   int n = snprintf(fn, UNIX_PATH_MAX, "%s/.java_pid%d",
            os::get_temp_directory(), os::current_process_id());
   assert(n < (int)UNIX_PATH_MAX, "java_pid file name buffer overflow");
 
-  RESTARTABLE(::stat64(fn, &st), ret);
+  RESTARTABLE(::stat(fn, &st), ret);
   if (ret == 0) {
     ret = ::unlink(fn);
     if (ret == -1) {
--- ./hotspot/src/os/bsd/vm/os_bsd.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/os/bsd/vm/os_bsd.cpp	Wed May 07 19:26:16 2014 -0700
@@ -1582,10 +1582,10 @@
   return (1000 * 1000);
 }
 
-// XXX: For now, code this as if BSD does not support vtime.
-bool os::supports_vtime() { return false; }
+bool os::supports_vtime() { return true; }
 bool os::enable_vtime()   { return false; }
 bool os::vtime_enabled()  { return false; }
+
 double os::elapsedVTime() {
   // better than nothing, but not much
   return elapsedTime();
@@ -3434,7 +3434,9 @@
 #endif
 #endif
 
-char* os::reserve_memory_special(size_t bytes, char* req_addr, bool exec) {
+char* os::reserve_memory_special(size_t bytes, size_t alignment, char* req_addr, bool exec) {
+  fatal("This code is not used or maintained.");
+
   // "exec" is passed in but not used.  Creating the shared image for
   // the code cache doesn't have an SHM_X executable permission to check.
   assert(UseLargePages && UseSHM, "only for SHM large pages");
@@ -6105,3 +6107,9 @@
   return n;
 }
 
+#ifndef PRODUCT
+void TestReserveMemorySpecial_test() {
+  // No tests available for this platform
+}
+#endif
+
--- ./hotspot/src/os/linux/vm/globals_linux.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/os/linux/vm/globals_linux.hpp	Wed May 07 19:26:16 2014 -0700
@@ -40,6 +40,9 @@
   product(bool, UseHugeTLBFS, false,                                    \
           "Use MAP_HUGETLB for large pages")                            \
                                                                         \
+  product(bool, UseTransparentHugePages, false,                         \
+          "Use MADV_HUGEPAGE for large pages")                          \
+                                                                        \
   product(bool, LoadExecStackDllInVMThread, true,                       \
           "Load DLLs with executable-stack attribute in the VM Thread") \
                                                                         \
@@ -50,7 +53,7 @@
 // Defines Linux-specific default values. The flags are available on all
 // platforms, but they may have different default values on other platforms.
 //
-define_pd_global(bool, UseLargePages, true);
+define_pd_global(bool, UseLargePages, false);
 define_pd_global(bool, UseLargePagesIndividualAllocation, false);
 define_pd_global(bool, UseOSErrorReporting, false);
 define_pd_global(bool, UseThreadPriorities, true) ;
--- ./hotspot/src/os/linux/vm/jsig.c	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/os/linux/vm/jsig.c	Wed May 07 19:26:16 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -107,7 +107,7 @@
 
   signal_lock();
 
-  sigused = (MASK(sig) & jvmsigs) != 0;
+  sigused = (sig < MAXSIGNUM) && ((MASK(sig) & jvmsigs) != 0);
   if (jvm_signal_installed && sigused) {
     /* jvm has installed its signal handler for this signal. */
     /* Save the handler. Don't really install it. */
@@ -116,7 +116,7 @@
 
     signal_unlock();
     return oldhandler;
-  } else if (jvm_signal_installing) {
+  } else if (sig < MAXSIGNUM && jvm_signal_installing) {
     /* jvm is installing its signal handlers. Install the new
      * handlers and save the old ones. jvm uses sigaction().
      * Leave the piece here just in case. */
@@ -165,7 +165,7 @@
 
   signal_lock();
 
-  sigused = (MASK(sig) & jvmsigs) != 0;
+  sigused = (sig < MAXSIGNUM) && ((MASK(sig) & jvmsigs) != 0);
   if (jvm_signal_installed && sigused) {
     /* jvm has installed its signal handler for this signal. */
     /* Save the handler. Don't really install it. */
@@ -178,7 +178,7 @@
 
     signal_unlock();
     return 0;
-  } else if (jvm_signal_installing) {
+  } else if (sig < MAXSIGNUM && jvm_signal_installing) {
     /* jvm is installing its signal handlers. Install the new
      * handlers and save the old ones. */
     res = call_os_sigaction(sig, act, &oldAct);
--- ./hotspot/src/os/linux/vm/os_linux.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/os/linux/vm/os_linux.cpp	Wed May 07 19:26:16 2014 -0700
@@ -120,8 +120,16 @@
 # include <inttypes.h>
 # include <sys/ioctl.h>
 
+// if RUSAGE_THREAD for getrusage() has not been defined, do it here. The code calling
+// getrusage() is prepared to handle the associated failure.
+#ifndef RUSAGE_THREAD
+#define RUSAGE_THREAD   (1)               /* only the calling thread */
+#endif
+
 #define MAX_PATH    (2 * K)
 
+#define MAX_SECS 100000000
+
 // for timer info max values which include all bits
 #define ALL_64_BITS CONST64(0xFFFFFFFFFFFFFFFF)
 
@@ -144,6 +152,7 @@
 bool os::Linux::_supports_fast_thread_cpu_time = false;
 const char * os::Linux::_glibc_version = NULL;
 const char * os::Linux::_libpthread_version = NULL;
+pthread_condattr_t os::Linux::_condattr[1];
 
 static jlong initial_time_count=0;
 
@@ -1377,15 +1386,19 @@
   return (1000 * 1000);
 }
 
-// For now, we say that linux does not support vtime.  I have no idea
-// whether it can actually be made to (DLD, 9/13/05).
-
-bool os::supports_vtime() { return false; }
+bool os::supports_vtime() { return true; }
 bool os::enable_vtime()   { return false; }
 bool os::vtime_enabled()  { return false; }
+
 double os::elapsedVTime() {
-  // better than nothing, but not much
-  return elapsedTime();
+  struct rusage usage;
+  int retval = getrusage(RUSAGE_THREAD, &usage);
+  if (retval == 0) {
+    return (double) (usage.ru_utime.tv_sec + usage.ru_stime.tv_sec) + (double) (usage.ru_utime.tv_usec + usage.ru_stime.tv_usec) / (1000 * 1000);
+  } else {
+    // better than nothing, but not much
+    return elapsedTime();
+  }
 }
 
 jlong os::javaTimeMillis() {
@@ -1427,12 +1440,15 @@
           clock_gettime_func(CLOCK_MONOTONIC, &tp)  == 0) {
         // yes, monotonic clock is supported
         _clock_gettime = clock_gettime_func;
+        return;
       } else {
         // close librt if there is no monotonic clock
         dlclose(handle);
       }
     }
   }
+  warning("No monotonic clock was available - timed services may " \
+          "be adversely affected if the time-of-day clock changes");
 }
 
 #ifndef SYS_clock_getres
@@ -2468,7 +2484,6 @@
     sem_t _semaphore;
 };
 
-
 Semaphore::Semaphore() {
   sem_init(&_semaphore, 0, 0);
 }
@@ -2490,8 +2505,22 @@
 }
 
 bool Semaphore::timedwait(unsigned int sec, int nsec) {
+
   struct timespec ts;
-  unpackTime(&ts, false, (sec * NANOSECS_PER_SEC) + nsec);
+  // Semaphore's are always associated with CLOCK_REALTIME
+  os::Linux::clock_gettime(CLOCK_REALTIME, &ts);
+  // see unpackTime for discussion on overflow checking
+  if (sec >= MAX_SECS) {
+    ts.tv_sec += MAX_SECS;
+    ts.tv_nsec = 0;
+  } else {
+    ts.tv_sec += sec;
+    ts.tv_nsec += nsec;
+    if (ts.tv_nsec >= NANOSECS_PER_SEC) {
+      ts.tv_nsec -= NANOSECS_PER_SEC;
+      ++ts.tv_sec; // note: this must be <= max_secs
+    }
+  }
 
   while (1) {
     int result = sem_timedwait(&_semaphore, &ts);
@@ -2696,14 +2725,6 @@
           alignment_hint, exec, strerror(err), err);
 }
 
-static void warn_fail_commit_memory(char* addr, size_t size,
-                                    size_t alignment_hint, bool exec,
-                                    int err, const char* msg) {
-  warning("INFO: os::commit_memory(" PTR_FORMAT ", " SIZE_FORMAT
-          ", " SIZE_FORMAT ", %d) failed; error='%s' (errno=%d); %s", addr, size,
-          alignment_hint, exec, strerror(err), err, msg);
-}
-
 // NOTE: Linux kernel does not really reserve the pages for us.
 //       All it does is to check if there are enough free pages
 //       left at the time of mmap(). This could be a potential
@@ -2754,41 +2775,9 @@
 #define MADV_HUGEPAGE 14
 #endif
 
-volatile jint os::Linux::num_largepage_commit_fails = 0;
-
 int os::Linux::commit_memory_impl(char* addr, size_t size,
                                   size_t alignment_hint, bool exec) {
-  int err;
-  if (UseHugeTLBFS && alignment_hint > (size_t)vm_page_size()) {
-    int prot = exec ? PROT_READ|PROT_WRITE|PROT_EXEC : PROT_READ|PROT_WRITE;
-    uintptr_t res =
-      (uintptr_t) ::mmap(addr, size, prot,
-                         MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS|MAP_HUGETLB,
-                         -1, 0);
-    if (res != (uintptr_t) MAP_FAILED) {
-      if (UseNUMAInterleaving) {
-        numa_make_global(addr, size);
-      }
-      return 0;
-    }
-
-    err = errno;  // save errno from mmap() call above
-
-    if (!recoverable_mmap_error(err)) {
-      // However, it is not clear that this loss of our reserved mapping
-      // happens with large pages on Linux or that we cannot recover
-      // from the loss. For now, we just issue a warning and we don't
-      // call vm_exit_out_of_memory(). This issue is being tracked by
-      // JBS-8007074.
-      Atomic::inc(&os::Linux::num_largepage_commit_fails);
-      warn_fail_commit_memory(addr, size, alignment_hint, exec, err,
-        "Cannot allocate large pages, falling back to regular pages");
-//    vm_exit_out_of_memory(size, "committing reserved memory.");
-    }
-    // Fall through and try to use small pages
-  }
-
-  err = os::Linux::commit_memory_impl(addr, size, exec);
+  int err = os::Linux::commit_memory_impl(addr, size, exec);
   if (err == 0) {
     realign_memory(addr, size, alignment_hint);
   }
@@ -2813,7 +2802,7 @@
 }
 
 void os::pd_realign_memory(char *addr, size_t bytes, size_t alignment_hint) {
-  if (UseHugeTLBFS && alignment_hint > (size_t)vm_page_size()) {
+  if (UseTransparentHugePages && alignment_hint > (size_t)vm_page_size()) {
     // We don't check the return value: madvise(MADV_HUGEPAGE) may not
     // be supported or the memory may already be backed by huge pages.
     ::madvise(addr, bytes, MADV_HUGEPAGE);
@@ -2826,7 +2815,7 @@
   // uncommitted at all. We don't do anything in this case to avoid creating a segment with
   // small pages on top of the SHM segment. This method always works for small pages, so we
   // allow that in any case.
-  if (alignment_hint <= (size_t)os::vm_page_size() || !UseSHM) {
+  if (alignment_hint <= (size_t)os::vm_page_size() || can_commit_large_page_memory()) {
     commit_memory(addr, bytes, alignment_hint, !ExecMem);
   }
 }
@@ -3195,11 +3184,31 @@
   return linux_mprotect(addr, size, PROT_READ|PROT_WRITE);
 }
 
+bool os::Linux::transparent_huge_pages_sanity_check(bool warn, size_t page_size) {
+  bool result = false;
+  void *p = mmap(NULL, page_size * 2, PROT_READ|PROT_WRITE,
+                 MAP_ANONYMOUS|MAP_PRIVATE,
+                 -1, 0);
+  if (p != MAP_FAILED) {
+    void *aligned_p = align_ptr_up(p, page_size);
+
+    result = madvise(aligned_p, page_size, MADV_HUGEPAGE) == 0;
+
+    munmap(p, page_size * 2);
+  }
+
+  if (warn && !result) {
+    warning("TransparentHugePages is not supported by the operating system.");
+  }
+
+  return result;
+}
+
 bool os::Linux::hugetlbfs_sanity_check(bool warn, size_t page_size) {
   bool result = false;
-  void *p = mmap (NULL, page_size, PROT_READ|PROT_WRITE,
-                  MAP_ANONYMOUS|MAP_PRIVATE|MAP_HUGETLB,
-                  -1, 0);
+  void *p = mmap(NULL, page_size, PROT_READ|PROT_WRITE,
+                 MAP_ANONYMOUS|MAP_PRIVATE|MAP_HUGETLB,
+                 -1, 0);
 
   if (p != MAP_FAILED) {
     // We don't know if this really is a huge page or not.
@@ -3220,12 +3229,10 @@
       }
       fclose(fp);
     }
-    munmap (p, page_size);
-    if (result)
-      return true;
-  }
-
-  if (warn) {
+    munmap(p, page_size);
+  }
+
+  if (warn && !result) {
     warning("HugeTLBFS is not supported by the operating system.");
   }
 
@@ -3273,82 +3280,126 @@
 
 static size_t _large_page_size = 0;
 
-void os::large_page_init() {
-  if (!UseLargePages) {
-    UseHugeTLBFS = false;
-    UseSHM = false;
-    return;
-  }
-
-  if (FLAG_IS_DEFAULT(UseHugeTLBFS) && FLAG_IS_DEFAULT(UseSHM)) {
-    // If UseLargePages is specified on the command line try both methods,
-    // if it's default, then try only HugeTLBFS.
-    if (FLAG_IS_DEFAULT(UseLargePages)) {
-      UseHugeTLBFS = true;
-    } else {
-      UseHugeTLBFS = UseSHM = true;
-    }
-  }
-
-  if (LargePageSizeInBytes) {
-    _large_page_size = LargePageSizeInBytes;
-  } else {
-    // large_page_size on Linux is used to round up heap size. x86 uses either
-    // 2M or 4M page, depending on whether PAE (Physical Address Extensions)
-    // mode is enabled. AMD64/EM64T uses 2M page in 64bit mode. IA64 can use
-    // page as large as 256M.
-    //
-    // Here we try to figure out page size by parsing /proc/meminfo and looking
-    // for a line with the following format:
-    //    Hugepagesize:     2048 kB
-    //
-    // If we can't determine the value (e.g. /proc is not mounted, or the text
-    // format has been changed), we'll use the largest page size supported by
-    // the processor.
+size_t os::Linux::find_large_page_size() {
+  size_t large_page_size = 0;
+
+  // large_page_size on Linux is used to round up heap size. x86 uses either
+  // 2M or 4M page, depending on whether PAE (Physical Address Extensions)
+  // mode is enabled. AMD64/EM64T uses 2M page in 64bit mode. IA64 can use
+  // page as large as 256M.
+  //
+  // Here we try to figure out page size by parsing /proc/meminfo and looking
+  // for a line with the following format:
+  //    Hugepagesize:     2048 kB
+  //
+  // If we can't determine the value (e.g. /proc is not mounted, or the text
+  // format has been changed), we'll use the largest page size supported by
+  // the processor.
 
 #ifndef ZERO
-    _large_page_size = IA32_ONLY(4 * M) AMD64_ONLY(2 * M) IA64_ONLY(256 * M) SPARC_ONLY(4 * M)
-                       ARM_ONLY(2 * M) PPC_ONLY(4 * M);
+  large_page_size = IA32_ONLY(4 * M) AMD64_ONLY(2 * M) IA64_ONLY(256 * M) SPARC_ONLY(4 * M)
+                     ARM_ONLY(2 * M) PPC_ONLY(4 * M);
 #endif // ZERO
 
-    FILE *fp = fopen("/proc/meminfo", "r");
-    if (fp) {
-      while (!feof(fp)) {
-        int x = 0;
-        char buf[16];
-        if (fscanf(fp, "Hugepagesize: %d", &x) == 1) {
-          if (x && fgets(buf, sizeof(buf), fp) && strcmp(buf, " kB\n") == 0) {
-            _large_page_size = x * K;
-            break;
-          }
-        } else {
-          // skip to next line
-          for (;;) {
-            int ch = fgetc(fp);
-            if (ch == EOF || ch == (int)'\n') break;
-          }
+  FILE *fp = fopen("/proc/meminfo", "r");
+  if (fp) {
+    while (!feof(fp)) {
+      int x = 0;
+      char buf[16];
+      if (fscanf(fp, "Hugepagesize: %d", &x) == 1) {
+        if (x && fgets(buf, sizeof(buf), fp) && strcmp(buf, " kB\n") == 0) {
+          large_page_size = x * K;
+          break;
+        }
+      } else {
+        // skip to next line
+        for (;;) {
+          int ch = fgetc(fp);
+          if (ch == EOF || ch == (int)'\n') break;
         }
       }
-      fclose(fp);
     }
-  }
-
-  // print a warning if any large page related flag is specified on command line
-  bool warn_on_failure = !FLAG_IS_DEFAULT(UseHugeTLBFS);
-
+    fclose(fp);
+  }
+
+  if (!FLAG_IS_DEFAULT(LargePageSizeInBytes) && LargePageSizeInBytes != large_page_size) {
+    warning("Setting LargePageSizeInBytes has no effect on this OS. Large page size is "
+        SIZE_FORMAT "%s.", byte_size_in_proper_unit(large_page_size),
+        proper_unit_for_byte_size(large_page_size));
+  }
+
+  return large_page_size;
+}
+
+size_t os::Linux::setup_large_page_size() {
+  _large_page_size = Linux::find_large_page_size();
   const size_t default_page_size = (size_t)Linux::page_size();
   if (_large_page_size > default_page_size) {
     _page_sizes[0] = _large_page_size;
     _page_sizes[1] = default_page_size;
     _page_sizes[2] = 0;
   }
-  UseHugeTLBFS = UseHugeTLBFS &&
-                 Linux::hugetlbfs_sanity_check(warn_on_failure, _large_page_size);
-
-  if (UseHugeTLBFS)
+
+  return _large_page_size;
+}
+
+bool os::Linux::setup_large_page_type(size_t page_size) {
+  if (FLAG_IS_DEFAULT(UseHugeTLBFS) &&
+      FLAG_IS_DEFAULT(UseSHM) &&
+      FLAG_IS_DEFAULT(UseTransparentHugePages)) {
+
+    // The type of large pages has not been specified by the user.
+
+    // Try UseHugeTLBFS and then UseSHM.
+    UseHugeTLBFS = UseSHM = true;
+
+    // Don't try UseTransparentHugePages since there are known
+    // performance issues with it turned on. This might change in the future.
+    UseTransparentHugePages = false;
+  }
+
+  if (UseTransparentHugePages) {
+    bool warn_on_failure = !FLAG_IS_DEFAULT(UseTransparentHugePages);
+    if (transparent_huge_pages_sanity_check(warn_on_failure, page_size)) {
+      UseHugeTLBFS = false;
+      UseSHM = false;
+      return true;
+    }
+    UseTransparentHugePages = false;
+  }
+
+  if (UseHugeTLBFS) {
+    bool warn_on_failure = !FLAG_IS_DEFAULT(UseHugeTLBFS);
+    if (hugetlbfs_sanity_check(warn_on_failure, page_size)) {
+      UseSHM = false;
+      return true;
+    }
+    UseHugeTLBFS = false;
+  }
+
+  return UseSHM;
+}
+
+void os::large_page_init() {
+  if (!UseLargePages &&
+      !UseTransparentHugePages &&
+      !UseHugeTLBFS &&
+      !UseSHM) {
+    // Not using large pages.
+    return;
+  }
+
+  if (!FLAG_IS_DEFAULT(UseLargePages) && !UseLargePages) {
+    // The user explicitly turned off large pages.
+    // Ignore the rest of the large pages flags.
+    UseTransparentHugePages = false;
+    UseHugeTLBFS = false;
     UseSHM = false;
-
-  UseLargePages = UseHugeTLBFS || UseSHM;
+    return;
+  }
+
+  size_t large_page_size = Linux::setup_large_page_size();
+  UseLargePages          = Linux::setup_large_page_type(large_page_size);
 
   set_coredump_filter();
 }
@@ -3357,16 +3408,22 @@
 #define SHM_HUGETLB 04000
 #endif
 
-char* os::reserve_memory_special(size_t bytes, char* req_addr, bool exec) {
+char* os::Linux::reserve_memory_special_shm(size_t bytes, size_t alignment, char* req_addr, bool exec) {
   // "exec" is passed in but not used.  Creating the shared image for
   // the code cache doesn't have an SHM_X executable permission to check.
   assert(UseLargePages && UseSHM, "only for SHM large pages");
+  assert(is_ptr_aligned(req_addr, os::large_page_size()), "Unaligned address");
+
+  if (!is_size_aligned(bytes, os::large_page_size()) || alignment > os::large_page_size()) {
+    return NULL; // Fallback to small pages.
+  }
 
   key_t key = IPC_PRIVATE;
   char *addr;
 
   bool warn_on_failure = UseLargePages &&
                         (!FLAG_IS_DEFAULT(UseLargePages) ||
+                         !FLAG_IS_DEFAULT(UseSHM) ||
                          !FLAG_IS_DEFAULT(LargePageSizeInBytes)
                         );
   char msg[128];
@@ -3414,42 +3471,220 @@
      return NULL;
   }
 
-  if ((addr != NULL) && UseNUMAInterleaving) {
-    numa_make_global(addr, bytes);
-  }
-
-  // The memory is committed
-  MemTracker::record_virtual_memory_reserve_and_commit((address)addr, bytes, mtNone, CALLER_PC);
-
   return addr;
 }
 
+static void warn_on_large_pages_failure(char* req_addr, size_t bytes, int error) {
+  assert(error == ENOMEM, "Only expect to fail if no memory is available");
+
+  bool warn_on_failure = UseLargePages &&
+      (!FLAG_IS_DEFAULT(UseLargePages) ||
+       !FLAG_IS_DEFAULT(UseHugeTLBFS) ||
+       !FLAG_IS_DEFAULT(LargePageSizeInBytes));
+
+  if (warn_on_failure) {
+    char msg[128];
+    jio_snprintf(msg, sizeof(msg), "Failed to reserve large pages memory req_addr: "
+        PTR_FORMAT " bytes: " SIZE_FORMAT " (errno = %d).", req_addr, bytes, error);
+    warning(msg);
+  }
+}
+
+char* os::Linux::reserve_memory_special_huge_tlbfs_only(size_t bytes, char* req_addr, bool exec) {
+  assert(UseLargePages && UseHugeTLBFS, "only for Huge TLBFS large pages");
+  assert(is_size_aligned(bytes, os::large_page_size()), "Unaligned size");
+  assert(is_ptr_aligned(req_addr, os::large_page_size()), "Unaligned address");
+
+  int prot = exec ? PROT_READ|PROT_WRITE|PROT_EXEC : PROT_READ|PROT_WRITE;
+  char* addr = (char*)::mmap(req_addr, bytes, prot,
+                             MAP_PRIVATE|MAP_ANONYMOUS|MAP_HUGETLB,
+                             -1, 0);
+
+  if (addr == MAP_FAILED) {
+    warn_on_large_pages_failure(req_addr, bytes, errno);
+    return NULL;
+  }
+
+  assert(is_ptr_aligned(addr, os::large_page_size()), "Must be");
+
+  return addr;
+}
+
+char* os::Linux::reserve_memory_special_huge_tlbfs_mixed(size_t bytes, size_t alignment, char* req_addr, bool exec) {
+  size_t large_page_size = os::large_page_size();
+
+  assert(bytes >= large_page_size, "Shouldn't allocate large pages for small sizes");
+
+  // Allocate small pages.
+
+  char* start;
+  if (req_addr != NULL) {
+    assert(is_ptr_aligned(req_addr, alignment), "Must be");
+    assert(is_size_aligned(bytes, alignment), "Must be");
+    start = os::reserve_memory(bytes, req_addr);
+    assert(start == NULL || start == req_addr, "Must be");
+  } else {
+    start = os::reserve_memory_aligned(bytes, alignment);
+  }
+
+  if (start == NULL) {
+    return NULL;
+  }
+
+  assert(is_ptr_aligned(start, alignment), "Must be");
+
+  // os::reserve_memory_special will record this memory area.
+  // Need to release it here to prevent overlapping reservations.
+  MemTracker::record_virtual_memory_release((address)start, bytes);
+
+  char* end = start + bytes;
+
+  // Find the regions of the allocated chunk that can be promoted to large pages.
+  char* lp_start = (char*)align_ptr_up(start, large_page_size);
+  char* lp_end   = (char*)align_ptr_down(end, large_page_size);
+
+  size_t lp_bytes = lp_end - lp_start;
+
+  assert(is_size_aligned(lp_bytes, large_page_size), "Must be");
+
+  if (lp_bytes == 0) {
+    // The mapped region doesn't even span the start and the end of a large page.
+    // Fall back to allocate a non-special area.
+    ::munmap(start, end - start);
+    return NULL;
+  }
+
+  int prot = exec ? PROT_READ|PROT_WRITE|PROT_EXEC : PROT_READ|PROT_WRITE;
+
+
+  void* result;
+
+  if (start != lp_start) {
+    result = ::mmap(start, lp_start - start, prot,
+                    MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED,
+                    -1, 0);
+    if (result == MAP_FAILED) {
+      ::munmap(lp_start, end - lp_start);
+      return NULL;
+    }
+  }
+
+  result = ::mmap(lp_start, lp_bytes, prot,
+                  MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED|MAP_HUGETLB,
+                  -1, 0);
+  if (result == MAP_FAILED) {
+    warn_on_large_pages_failure(req_addr, bytes, errno);
+    // If the mmap above fails, the large pages region will be unmapped and we
+    // have regions before and after with small pages. Release these regions.
+    //
+    // |  mapped  |  unmapped  |  mapped  |
+    // ^          ^            ^          ^
+    // start      lp_start     lp_end     end
+    //
+    ::munmap(start, lp_start - start);
+    ::munmap(lp_end, end - lp_end);
+    return NULL;
+  }
+
+  if (lp_end != end) {
+      result = ::mmap(lp_end, end - lp_end, prot,
+                      MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED,
+                      -1, 0);
+    if (result == MAP_FAILED) {
+      ::munmap(start, lp_end - start);
+      return NULL;
+    }
+  }
+
+  return start;
+}
+
+char* os::Linux::reserve_memory_special_huge_tlbfs(size_t bytes, size_t alignment, char* req_addr, bool exec) {
+  assert(UseLargePages && UseHugeTLBFS, "only for Huge TLBFS large pages");
+  assert(is_ptr_aligned(req_addr, alignment), "Must be");
+  assert(is_power_of_2(alignment), "Must be");
+  assert(is_power_of_2(os::large_page_size()), "Must be");
+  assert(bytes >= os::large_page_size(), "Shouldn't allocate large pages for small sizes");
+
+  if (is_size_aligned(bytes, os::large_page_size()) && alignment <= os::large_page_size()) {
+    return reserve_memory_special_huge_tlbfs_only(bytes, req_addr, exec);
+  } else {
+    return reserve_memory_special_huge_tlbfs_mixed(bytes, alignment, req_addr, exec);
+  }
+}
+
+char* os::reserve_memory_special(size_t bytes, size_t alignment, char* req_addr, bool exec) {
+  assert(UseLargePages, "only for large pages");
+
+  char* addr;
+  if (UseSHM) {
+    addr = os::Linux::reserve_memory_special_shm(bytes, alignment, req_addr, exec);
+  } else {
+    assert(UseHugeTLBFS, "must be");
+    addr = os::Linux::reserve_memory_special_huge_tlbfs(bytes, alignment, req_addr, exec);
+  }
+
+  if (addr != NULL) {
+    if (UseNUMAInterleaving) {
+      numa_make_global(addr, bytes);
+    }
+
+    // The memory is committed
+    MemTracker::record_virtual_memory_reserve_and_commit((address)addr, bytes, mtNone, CALLER_PC);
+  }
+
+  return addr;
+}
+
+bool os::Linux::release_memory_special_shm(char* base, size_t bytes) {
+  // detaching the SHM segment will also delete it, see reserve_memory_special_shm()
+  return shmdt(base) == 0;
+}
+
+bool os::Linux::release_memory_special_huge_tlbfs(char* base, size_t bytes) {
+  return pd_release_memory(base, bytes);
+}
+
 bool os::release_memory_special(char* base, size_t bytes) {
+  assert(UseLargePages, "only for large pages");
+
   MemTracker::Tracker tkr = MemTracker::get_virtual_memory_release_tracker();
-  // detaching the SHM segment will also delete it, see reserve_memory_special()
-  int rslt = shmdt(base);
-  if (rslt == 0) {
+
+  bool res;
+  if (UseSHM) {
+    res = os::Linux::release_memory_special_shm(base, bytes);
+  } else {
+    assert(UseHugeTLBFS, "must be");
+    res = os::Linux::release_memory_special_huge_tlbfs(base, bytes);
+  }
+
+  if (res) {
     tkr.record((address)base, bytes);
-    return true;
   } else {
     tkr.discard();
-   return false;
-  }
-}
+  }
+
+  return res;
+}
+
 
 size_t os::large_page_size() {
   return _large_page_size;
 }
 
-// HugeTLBFS allows application to commit large page memory on demand;
-// with SysV SHM the entire memory region must be allocated as shared
+// With SysV SHM the entire memory region must be allocated as shared
 // memory.
+// HugeTLBFS allows application to commit large page memory on demand.
+// However, when committing memory with HugeTLBFS fails, the region
+// that was supposed to be committed will lose the old reservation
+// and allow other threads to steal that memory region. Because of this
+// behavior we can't commit HugeTLBFS memory.
 bool os::can_commit_large_page_memory() {
-  return UseHugeTLBFS;
+  return UseTransparentHugePages;
 }
 
 bool os::can_execute_large_page_memory() {
-  return UseHugeTLBFS;
+  return UseTransparentHugePages || UseHugeTLBFS;
 }
 
 // Reserve memory at an arbitrary address, only if that area is
@@ -4505,6 +4740,26 @@
 
   Linux::clock_init();
   initial_time_count = os::elapsed_counter();
+
+  // pthread_condattr initialization for monotonic clock
+  int status;
+  pthread_condattr_t* _condattr = os::Linux::condAttr();
+  if ((status = pthread_condattr_init(_condattr)) != 0) {
+    fatal(err_msg("pthread_condattr_init: %s", strerror(status)));
+  }
+  // Only set the clock if CLOCK_MONOTONIC is available
+  if (Linux::supports_monotonic_clock()) {
+    if ((status = pthread_condattr_setclock(_condattr, CLOCK_MONOTONIC)) != 0) {
+      if (status == EINVAL) {
+        warning("Unable to use monotonic clock with relative timed-waits" \
+                " - changes to the time-of-day clock may have adverse affects");
+      } else {
+        fatal(err_msg("pthread_condattr_setclock: %s", strerror(status)));
+      }
+    }
+  }
+  // else it defaults to CLOCK_REALTIME
+
   pthread_mutex_init(&dl_mutex, NULL);
 
   // If the pagesize of the VM is greater than 8K determine the appropriate
@@ -4587,6 +4842,10 @@
 
   Linux::capture_initial_stack(JavaThread::stack_size_at_create());
 
+#if defined(IA32)
+  workaround_expand_exec_shield_cs_limit();
+#endif
+
   Linux::libpthread_init();
   if (PrintMiscellaneous && (Verbose || WizardMode)) {
      tty->print_cr("[HotSpot is running with %s, %s(%s)]\n",
@@ -4603,21 +4862,23 @@
         UseNUMA = false;
       }
     }
-    // With SHM large pages we cannot uncommit a page, so there's not way
+    // With SHM and HugeTLBFS large pages we cannot uncommit a page, so there's no way
     // we can make the adaptive lgrp chunk resizing work. If the user specified
-    // both UseNUMA and UseLargePages (or UseSHM) on the command line - warn and
+    // both UseNUMA and UseLargePages (or UseSHM/UseHugeTLBFS) on the command line - warn and
     // disable adaptive resizing.
-    if (UseNUMA && UseLargePages && UseSHM) {
-      if (!FLAG_IS_DEFAULT(UseNUMA)) {
-        if (FLAG_IS_DEFAULT(UseLargePages) && FLAG_IS_DEFAULT(UseSHM)) {
+    if (UseNUMA && UseLargePages && !can_commit_large_page_memory()) {
+      if (FLAG_IS_DEFAULT(UseNUMA)) {
+        UseNUMA = false;
+      } else {
+        if (FLAG_IS_DEFAULT(UseLargePages) &&
+            FLAG_IS_DEFAULT(UseSHM) &&
+            FLAG_IS_DEFAULT(UseHugeTLBFS)) {
           UseLargePages = false;
         } else {
-          warning("UseNUMA is not fully compatible with SHM large pages, disabling adaptive resizing");
+          warning("UseNUMA is not fully compatible with SHM/HugeTLBFS large pages, disabling adaptive resizing");
           UseAdaptiveSizePolicy = false;
           UseAdaptiveNUMAChunkSizing = false;
         }
-      } else {
-        UseNUMA = false;
       }
     }
     if (!UseNUMA && ForceNUMA) {
@@ -5351,21 +5612,36 @@
 
 static struct timespec* compute_abstime(timespec* abstime, jlong millis) {
   if (millis < 0)  millis = 0;
-  struct timeval now;
-  int status = gettimeofday(&now, NULL);
-  assert(status == 0, "gettimeofday");
+
   jlong seconds = millis / 1000;
   millis %= 1000;
   if (seconds > 50000000) { // see man cond_timedwait(3T)
     seconds = 50000000;
   }
-  abstime->tv_sec = now.tv_sec  + seconds;
-  long       usec = now.tv_usec + millis * 1000;
-  if (usec >= 1000000) {
-    abstime->tv_sec += 1;
-    usec -= 1000000;
-  }
-  abstime->tv_nsec = usec * 1000;
+
+  if (os::Linux::supports_monotonic_clock()) {
+    struct timespec now;
+    int status = os::Linux::clock_gettime(CLOCK_MONOTONIC, &now);
+    assert_status(status == 0, status, "clock_gettime");
+    abstime->tv_sec = now.tv_sec  + seconds;
+    long nanos = now.tv_nsec + millis * NANOSECS_PER_MILLISEC;
+    if (nanos >= NANOSECS_PER_SEC) {
+      abstime->tv_sec += 1;
+      nanos -= NANOSECS_PER_SEC;
+    }
+    abstime->tv_nsec = nanos;
+  } else {
+    struct timeval now;
+    int status = gettimeofday(&now, NULL);
+    assert(status == 0, "gettimeofday");
+    abstime->tv_sec = now.tv_sec  + seconds;
+    long usec = now.tv_usec + millis * 1000;
+    if (usec >= 1000000) {
+      abstime->tv_sec += 1;
+      usec -= 1000000;
+    }
+    abstime->tv_nsec = usec * 1000;
+  }
   return abstime;
 }
 
@@ -5457,7 +5733,7 @@
     status = os::Linux::safe_cond_timedwait(_cond, _mutex, &abst);
     if (status != 0 && WorkAroundNPTLTimedWaitHang) {
       pthread_cond_destroy (_cond);
-      pthread_cond_init (_cond, NULL) ;
+      pthread_cond_init (_cond, os::Linux::condAttr()) ;
     }
     assert_status(status == 0 || status == EINTR ||
                   status == ETIME || status == ETIMEDOUT,
@@ -5536,7 +5812,6 @@
  * is no need to track notifications.
  */
 
-#define MAX_SECS 100000000
 /*
  * This code is common to linux and solaris and will be moved to a
  * common place in dolphin.
@@ -5558,32 +5833,50 @@
 
 static void unpackTime(timespec* absTime, bool isAbsolute, jlong time) {
   assert (time > 0, "convertTime");
-
-  struct timeval now;
-  int status = gettimeofday(&now, NULL);
-  assert(status == 0, "gettimeofday");
-
-  time_t max_secs = now.tv_sec + MAX_SECS;
-
-  if (isAbsolute) {
-    jlong secs = time / 1000;
-    if (secs > max_secs) {
-      absTime->tv_sec = max_secs;
+  time_t max_secs = 0;
+
+  if (!os::Linux::supports_monotonic_clock() || isAbsolute) {
+    struct timeval now;
+    int status = gettimeofday(&now, NULL);
+    assert(status == 0, "gettimeofday");
+
+    max_secs = now.tv_sec + MAX_SECS;
+
+    if (isAbsolute) {
+      jlong secs = time / 1000;
+      if (secs > max_secs) {
+        absTime->tv_sec = max_secs;
+      } else {
+        absTime->tv_sec = secs;
+      }
+      absTime->tv_nsec = (time % 1000) * NANOSECS_PER_MILLISEC;
+    } else {
+      jlong secs = time / NANOSECS_PER_SEC;
+      if (secs >= MAX_SECS) {
+        absTime->tv_sec = max_secs;
+        absTime->tv_nsec = 0;
+      } else {
+        absTime->tv_sec = now.tv_sec + secs;
+        absTime->tv_nsec = (time % NANOSECS_PER_SEC) + now.tv_usec*1000;
+        if (absTime->tv_nsec >= NANOSECS_PER_SEC) {
+          absTime->tv_nsec -= NANOSECS_PER_SEC;
+          ++absTime->tv_sec; // note: this must be <= max_secs
+        }
+      }
     }
-    else {
-      absTime->tv_sec = secs;
-    }
-    absTime->tv_nsec = (time % 1000) * NANOSECS_PER_MILLISEC;
-  }
-  else {
+  } else {
+    // must be relative using monotonic clock
+    struct timespec now;
+    int status = os::Linux::clock_gettime(CLOCK_MONOTONIC, &now);
+    assert_status(status == 0, status, "clock_gettime");
+    max_secs = now.tv_sec + MAX_SECS;
     jlong secs = time / NANOSECS_PER_SEC;
     if (secs >= MAX_SECS) {
       absTime->tv_sec = max_secs;
       absTime->tv_nsec = 0;
-    }
-    else {
+    } else {
       absTime->tv_sec = now.tv_sec + secs;
-      absTime->tv_nsec = (time % NANOSECS_PER_SEC) + now.tv_usec*1000;
+      absTime->tv_nsec = (time % NANOSECS_PER_SEC) + now.tv_nsec;
       if (absTime->tv_nsec >= NANOSECS_PER_SEC) {
         absTime->tv_nsec -= NANOSECS_PER_SEC;
         ++absTime->tv_sec; // note: this must be <= max_secs
@@ -5662,16 +5955,20 @@
   OSThreadWaitState osts(thread->osthread(), false /* not Object.wait() */);
   jt->set_suspend_equivalent();
   // cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()
-
+  assert(_cur_index == -1, "invariant");
   if (time == 0) {
-    status = pthread_cond_wait (_cond, _mutex) ;
+    _cur_index = REL_INDEX; // arbitrary choice when not timed
+    status = pthread_cond_wait (&_cond[_cur_index], _mutex) ;
   } else {
-    status = os::Linux::safe_cond_timedwait (_cond, _mutex, &absTime) ;
+    _cur_index = isAbsolute ? ABS_INDEX : REL_INDEX;
+    status = os::Linux::safe_cond_timedwait (&_cond[_cur_index], _mutex, &absTime) ;
     if (status != 0 && WorkAroundNPTLTimedWaitHang) {
-      pthread_cond_destroy (_cond) ;
-      pthread_cond_init    (_cond, NULL);
+      pthread_cond_destroy (&_cond[_cur_index]) ;
+      pthread_cond_init    (&_cond[_cur_index], isAbsolute ? NULL : os::Linux::condAttr());
     }
   }
+  _cur_index = -1;
+
   assert_status(status == 0 || status == EINTR ||
                 status == ETIME || status == ETIMEDOUT,
                 status, "cond_timedwait");
@@ -5700,17 +5997,24 @@
   s = _counter;
   _counter = 1;
   if (s < 1) {
-     if (WorkAroundNPTLTimedWaitHang) {
-        status = pthread_cond_signal (_cond) ;
-        assert (status == 0, "invariant") ;
+    // thread might be parked
+    if (_cur_index != -1) {
+      // thread is definitely parked
+      if (WorkAroundNPTLTimedWaitHang) {
+        status = pthread_cond_signal (&_cond[_cur_index]);
+        assert (status == 0, "invariant");
         status = pthread_mutex_unlock(_mutex);
-        assert (status == 0, "invariant") ;
-     } else {
+        assert (status == 0, "invariant");
+      } else {
         status = pthread_mutex_unlock(_mutex);
-        assert (status == 0, "invariant") ;
-        status = pthread_cond_signal (_cond) ;
-        assert (status == 0, "invariant") ;
-     }
+        assert (status == 0, "invariant");
+        status = pthread_cond_signal (&_cond[_cur_index]);
+        assert (status == 0, "invariant");
+      }
+    } else {
+      pthread_mutex_unlock(_mutex);
+      assert (status == 0, "invariant") ;
+    }
   } else {
     pthread_mutex_unlock(_mutex);
     assert (status == 0, "invariant") ;
@@ -5926,3 +6230,149 @@
 }
 
 #endif // JAVASE_EMBEDDED
+
+
+/////////////// Unit tests ///////////////
+
+#ifndef PRODUCT
+
+#define test_log(...) \
+  do {\
+    if (VerboseInternalVMTests) { \
+      tty->print_cr(__VA_ARGS__); \
+      tty->flush(); \
+    }\
+  } while (false)
+
+class TestReserveMemorySpecial : AllStatic {
+ public:
+  static void small_page_write(void* addr, size_t size) {
+    size_t page_size = os::vm_page_size();
+
+    char* end = (char*)addr + size;
+    for (char* p = (char*)addr; p < end; p += page_size) {
+      *p = 1;
+    }
+  }
+
+  static void test_reserve_memory_special_huge_tlbfs_only(size_t size) {
+    if (!UseHugeTLBFS) {
+      return;
+    }
+
+    test_log("test_reserve_memory_special_huge_tlbfs_only(" SIZE_FORMAT ")", size);
+
+    char* addr = os::Linux::reserve_memory_special_huge_tlbfs_only(size, NULL, false);
+
+    if (addr != NULL) {
+      small_page_write(addr, size);
+
+      os::Linux::release_memory_special_huge_tlbfs(addr, size);
+    }
+  }
+
+  static void test_reserve_memory_special_huge_tlbfs_only() {
+    if (!UseHugeTLBFS) {
+      return;
+    }
+
+    size_t lp = os::large_page_size();
+
+    for (size_t size = lp; size <= lp * 10; size += lp) {
+      test_reserve_memory_special_huge_tlbfs_only(size);
+    }
+  }
+
+  static void test_reserve_memory_special_huge_tlbfs_mixed(size_t size, size_t alignment) {
+    if (!UseHugeTLBFS) {
+        return;
+    }
+
+    test_log("test_reserve_memory_special_huge_tlbfs_mixed(" SIZE_FORMAT ", " SIZE_FORMAT ")",
+        size, alignment);
+
+    assert(size >= os::large_page_size(), "Incorrect input to test");
+
+    char* addr = os::Linux::reserve_memory_special_huge_tlbfs_mixed(size, alignment, NULL, false);
+
+    if (addr != NULL) {
+      small_page_write(addr, size);
+
+      os::Linux::release_memory_special_huge_tlbfs(addr, size);
+    }
+  }
+
+  static void test_reserve_memory_special_huge_tlbfs_mixed_all_alignments(size_t size) {
+    size_t lp = os::large_page_size();
+    size_t ag = os::vm_allocation_granularity();
+
+    for (size_t alignment = ag; is_size_aligned(size, alignment); alignment *= 2) {
+      test_reserve_memory_special_huge_tlbfs_mixed(size, alignment);
+    }
+  }
+
+  static void test_reserve_memory_special_huge_tlbfs_mixed() {
+    size_t lp = os::large_page_size();
+    size_t ag = os::vm_allocation_granularity();
+
+    test_reserve_memory_special_huge_tlbfs_mixed_all_alignments(lp);
+    test_reserve_memory_special_huge_tlbfs_mixed_all_alignments(lp + ag);
+    test_reserve_memory_special_huge_tlbfs_mixed_all_alignments(lp + lp / 2);
+    test_reserve_memory_special_huge_tlbfs_mixed_all_alignments(lp * 2);
+    test_reserve_memory_special_huge_tlbfs_mixed_all_alignments(lp * 2 + ag);
+    test_reserve_memory_special_huge_tlbfs_mixed_all_alignments(lp * 2 - ag);
+    test_reserve_memory_special_huge_tlbfs_mixed_all_alignments(lp * 2 + lp / 2);
+    test_reserve_memory_special_huge_tlbfs_mixed_all_alignments(lp * 10);
+    test_reserve_memory_special_huge_tlbfs_mixed_all_alignments(lp * 10 + lp / 2);
+  }
+
+  static void test_reserve_memory_special_huge_tlbfs() {
+    if (!UseHugeTLBFS) {
+      return;
+    }
+
+    test_reserve_memory_special_huge_tlbfs_only();
+    test_reserve_memory_special_huge_tlbfs_mixed();
+  }
+
+  static void test_reserve_memory_special_shm(size_t size, size_t alignment) {
+    if (!UseSHM) {
+      return;
+    }
+
+    test_log("test_reserve_memory_special_shm(" SIZE_FORMAT ", " SIZE_FORMAT ")", size, alignment);
+
+    char* addr = os::Linux::reserve_memory_special_shm(size, alignment, NULL, false);
+
+    if (addr != NULL) {
+      assert(is_ptr_aligned(addr, alignment), "Check");
+      assert(is_ptr_aligned(addr, os::large_page_size()), "Check");
+
+      small_page_write(addr, size);
+
+      os::Linux::release_memory_special_shm(addr, size);
+    }
+  }
+
+  static void test_reserve_memory_special_shm() {
+    size_t lp = os::large_page_size();
+    size_t ag = os::vm_allocation_granularity();
+
+    for (size_t size = ag; size < lp * 3; size += ag) {
+      for (size_t alignment = ag; is_size_aligned(size, alignment); alignment *= 2) {
+        test_reserve_memory_special_shm(size, alignment);
+      }
+    }
+  }
+
+  static void test() {
+    test_reserve_memory_special_huge_tlbfs();
+    test_reserve_memory_special_shm();
+  }
+};
+
+void TestReserveMemorySpecial_test() {
+  TestReserveMemorySpecial::test();
+}
+
+#endif
--- ./hotspot/src/os/linux/vm/os_linux.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/os/linux/vm/os_linux.hpp	Wed May 07 19:26:16 2014 -0700
@@ -32,6 +32,7 @@
 
 class Linux {
   friend class os;
+  friend class TestReserveMemorySpecial;
 
   // For signal-chaining
 #define MAXSIGNUM 32
@@ -92,15 +93,27 @@
   static void rebuild_cpu_to_node_map();
   static GrowableArray<int>* cpu_to_node()    { return _cpu_to_node; }
 
+  static size_t find_large_page_size();
+  static size_t setup_large_page_size();
+
+  static bool setup_large_page_type(size_t page_size);
+  static bool transparent_huge_pages_sanity_check(bool warn, size_t pages_size);
   static bool hugetlbfs_sanity_check(bool warn, size_t page_size);
 
+  static char* reserve_memory_special_shm(size_t bytes, size_t alignment, char* req_addr, bool exec);
+  static char* reserve_memory_special_huge_tlbfs(size_t bytes, size_t alignment, char* req_addr, bool exec);
+  static char* reserve_memory_special_huge_tlbfs_only(size_t bytes, char* req_addr, bool exec);
+  static char* reserve_memory_special_huge_tlbfs_mixed(size_t bytes, size_t alignment, char* req_addr, bool exec);
+
+  static bool release_memory_special_shm(char* base, size_t bytes);
+  static bool release_memory_special_huge_tlbfs(char* base, size_t bytes);
+
   static void print_full_memory_info(outputStream* st);
   static void print_distro_info(outputStream* st);
   static void print_libversion_info(outputStream* st);
 
  public:
   static bool _stack_is_executable;
-  static volatile jint num_largepage_commit_fails;
   static void *dlopen_helper(const char *name, char *ebuf, int ebuflen);
   static void *dll_load_in_vmthread(const char *name, char *ebuf, int ebuflen);
 
@@ -208,6 +221,13 @@
 
   static jlong fast_thread_cpu_time(clockid_t clockid);
 
+  // pthread_cond clock suppport
+  private:
+  static pthread_condattr_t _condattr[1];
+
+  public:
+  static pthread_condattr_t* condAttr() { return _condattr; }
+
   // Stack repair handling
 
   // none present
@@ -274,7 +294,7 @@
   public:
     PlatformEvent() {
       int status;
-      status = pthread_cond_init (_cond, NULL);
+      status = pthread_cond_init (_cond, os::Linux::condAttr());
       assert_status(status == 0, status, "cond_init");
       status = pthread_mutex_init (_mutex, NULL);
       assert_status(status == 0, status, "mutex_init");
@@ -289,14 +309,19 @@
     void park () ;
     void unpark () ;
     int  TryPark () ;
-    int  park (jlong millis) ;
+    int  park (jlong millis) ; // relative timed-wait only
     void SetAssociation (Thread * a) { _Assoc = a ; }
 } ;
 
 class PlatformParker : public CHeapObj<mtInternal> {
   protected:
+    enum {
+      REL_INDEX = 0,
+      ABS_INDEX = 1
+    };
+    int _cur_index; // which cond is in use: -1, 0, 1
     pthread_mutex_t _mutex [1] ;
-    pthread_cond_t  _cond  [1] ;
+    pthread_cond_t _cond [2] ; // one for relative times and one for abs.
 
   public:       // TODO-FIXME: make dtor private
     ~PlatformParker() { guarantee (0, "invariant") ; }
@@ -304,10 +329,13 @@
   public:
     PlatformParker() {
       int status;
-      status = pthread_cond_init (_cond, NULL);
-      assert_status(status == 0, status, "cond_init");
+      status = pthread_cond_init (&_cond[REL_INDEX], os::Linux::condAttr());
+      assert_status(status == 0, status, "cond_init rel");
+      status = pthread_cond_init (&_cond[ABS_INDEX], NULL);
+      assert_status(status == 0, status, "cond_init abs");
       status = pthread_mutex_init (_mutex, NULL);
       assert_status(status == 0, status, "mutex_init");
+      _cur_index = -1; // mark as unused
     }
 };
 
--- ./hotspot/src/os/posix/vm/os_posix.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/os/posix/vm/os_posix.cpp	Wed May 07 19:26:16 2014 -0700
@@ -1,5 +1,5 @@
 /*
-* Copyright (c) 1999, 2011, Oracle and/or its affiliates. All rights reserved.
+* Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
@@ -30,6 +30,8 @@
 #include <unistd.h>
 #include <sys/resource.h>
 #include <sys/utsname.h>
+#include <pthread.h>
+#include <signal.h>
 
 
 // Check core dump limit and report possible place where core can be found
@@ -203,11 +205,17 @@
  * The callback is supposed to provide the method that should be protected.
  */
 bool os::WatcherThreadCrashProtection::call(os::CrashProtectionCallback& cb) {
+  sigset_t saved_sig_mask;
+
   assert(Thread::current()->is_Watcher_thread(), "Only for WatcherThread");
   assert(!WatcherThread::watcher_thread()->has_crash_protection(),
       "crash_protection already set?");
 
-  if (sigsetjmp(_jmpbuf, 1) == 0) {
+  // we cannot rely on sigsetjmp/siglongjmp to save/restore the signal mask
+  // since on at least some systems (OS X) siglongjmp will restore the mask
+  // for the process, not the thread
+  pthread_sigmask(0, NULL, &saved_sig_mask);
+  if (sigsetjmp(_jmpbuf, 0) == 0) {
     // make sure we can see in the signal handler that we have crash protection
     // installed
     WatcherThread::watcher_thread()->set_crash_protection(this);
@@ -217,6 +225,7 @@
     return true;
   }
   // this happens when we siglongjmp() back
+  pthread_sigmask(SIG_SETMASK, &saved_sig_mask, NULL);
   WatcherThread::watcher_thread()->set_crash_protection(NULL);
   return false;
 }
--- ./hotspot/src/os/solaris/vm/os_solaris.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/os/solaris/vm/os_solaris.cpp	Wed May 07 19:26:16 2014 -0700
@@ -3530,11 +3530,15 @@
   return true;
 }
 
-char* os::reserve_memory_special(size_t size, char* addr, bool exec) {
+char* os::reserve_memory_special(size_t size, size_t alignment, char* addr, bool exec) {
   // "exec" is passed in but not used.  Creating the shared image for
   // the code cache doesn't have an SHM_X executable permission to check.
   assert(UseLargePages && UseISM, "only for ISM large pages");
 
+  if (!is_size_aligned(size, os::large_page_size()) || alignment > os::large_page_size()) {
+    return NULL; // Fallback to small pages.
+  }
+
   char* retAddr = NULL;
   int shmid;
   key_t ismKey;
@@ -6862,3 +6866,9 @@
 
   return strlen(buffer);
 }
+
+#ifndef PRODUCT
+void TestReserveMemorySpecial_test() {
+  // No tests available for this platform
+}
+#endif
--- ./hotspot/src/os/windows/vm/os_windows.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/os/windows/vm/os_windows.cpp	Wed May 07 19:26:16 2014 -0700
@@ -800,15 +800,21 @@
   return result;
 }
 
-// For now, we say that Windows does not support vtime.  I have no idea
-// whether it can actually be made to (DLD, 9/13/05).
-
-bool os::supports_vtime() { return false; }
+bool os::supports_vtime() { return true; }
 bool os::enable_vtime() { return false; }
 bool os::vtime_enabled() { return false; }
+
 double os::elapsedVTime() {
-  // better than nothing, but not much
-  return elapsedTime();
+  FILETIME created;
+  FILETIME exited;
+  FILETIME kernel;
+  FILETIME user;
+  if (GetThreadTimes(GetCurrentThread(), &created, &exited, &kernel, &user) != 0) {
+    // the resolution of windows_to_java_time() should be sufficient (ms)
+    return (double) (windows_to_java_time(kernel) + windows_to_java_time(user)) / MILLIUNITS;
+  } else {
+    return elapsedTime();
+  }
 }
 
 jlong os::javaTimeMillis() {
@@ -3088,7 +3094,12 @@
   return true;
 }
 
-char* os::reserve_memory_special(size_t bytes, char* addr, bool exec) {
+char* os::reserve_memory_special(size_t bytes, size_t alignment, char* addr, bool exec) {
+  assert(UseLargePages, "only for large pages");
+
+  if (!is_size_aligned(bytes, os::large_page_size()) || alignment > os::large_page_size()) {
+    return NULL; // Fallback to small pages.
+  }
 
   const DWORD prot = exec ? PAGE_EXECUTE_READWRITE : PAGE_READWRITE;
   const DWORD flags = MEM_RESERVE | MEM_COMMIT | MEM_LARGE_PAGES;
@@ -5593,3 +5604,9 @@
 }
 
 #endif
+
+#ifndef PRODUCT
+void TestReserveMemorySpecial_test() {
+  // No tests available for this platform
+}
+#endif
--- ./hotspot/src/os_cpu/linux_x86/vm/os_linux_x86.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/os_cpu/linux_x86/vm/os_linux_x86.cpp	Wed May 07 19:26:16 2014 -0700
@@ -873,3 +873,46 @@
 #endif
 }
 #endif
+
+
+/*
+ * IA32 only: execute code at a high address in case buggy NX emulation is present. I.e. avoid CS limit
+ * updates (JDK-8023956).
+ */
+void os::workaround_expand_exec_shield_cs_limit() {
+#if defined(IA32)
+  size_t page_size = os::vm_page_size();
+  /*
+   * Take the highest VA the OS will give us and exec
+   *
+   * Although using -(pagesz) as mmap hint works on newer kernel as you would
+   * think, older variants affected by this work-around don't (search forward only).
+   *
+   * On the affected distributions, we understand the memory layout to be:
+   *
+   *   TASK_LIMIT= 3G, main stack base close to TASK_LIMT.
+   *
+   * A few pages south main stack will do it.
+   *
+   * If we are embedded in an app other than launcher (initial != main stack),
+   * we don't have much control or understanding of the address space, just let it slide.
+   */
+  char* hint = (char*) (Linux::initial_thread_stack_bottom() -
+                        ((StackYellowPages + StackRedPages + 1) * page_size));
+  char* codebuf = os::reserve_memory(page_size, hint);
+  if ( (codebuf == NULL) || (!os::commit_memory(codebuf, page_size, true)) ) {
+    return; // No matter, we tried, best effort.
+  }
+  if (PrintMiscellaneous && (Verbose || WizardMode)) {
+     tty->print_cr("[CS limit NX emulation work-around, exec code at: %p]", codebuf);
+  }
+
+  // Some code to exec: the 'ret' instruction
+  codebuf[0] = 0xC3;
+
+  // Call the code in the codebuf
+  __asm__ volatile("call *%0" : : "r"(codebuf));
+
+  // keep the page mapped so CS limit isn't reduced.
+#endif
+}
--- ./hotspot/src/os_cpu/linux_x86/vm/os_linux_x86.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/os_cpu/linux_x86/vm/os_linux_x86.hpp	Wed May 07 19:26:16 2014 -0700
@@ -36,4 +36,17 @@
   // Note: Currently only used in 64 bit Windows implementations
   static bool register_code_area(char *low, char *high) { return true; }
 
+  /*
+   * Work-around for broken NX emulation using CS limit, Red Hat patch "Exec-Shield"
+   * (IA32 only).
+   *
+   * Map and execute at a high VA to prevent CS lazy updates race with SMP MM
+   * invalidation.Further code generation by the JVM will no longer cause CS limit
+   * updates.
+   *
+   * Affects IA32: RHEL 5 & 6, Ubuntu 10.04 (LTS), 10.10, 11.04, 11.10, 12.04.
+   * @see JDK-8023956
+   */
+  static void workaround_expand_exec_shield_cs_limit();
+
 #endif // OS_CPU_LINUX_X86_VM_OS_LINUX_X86_HPP
--- ./hotspot/src/share/vm/c1/c1_GraphBuilder.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/c1/c1_GraphBuilder.cpp	Wed May 07 19:26:16 2014 -0700
@@ -4178,7 +4178,9 @@
     }
   }
 
-  if (!PrintInlining)  return;
+  if (!PrintInlining && !compilation()->method()->has_option("PrintInlining")) {
+    return;
+  }
   CompileTask::print_inlining(callee, scope()->level(), bci(), msg);
   if (success && CIPrintMethodCodes) {
     callee->print_codes();
--- ./hotspot/src/share/vm/c1/c1_LIR.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/c1/c1_LIR.hpp	Wed May 07 19:26:16 2014 -0700
@@ -2221,7 +2221,7 @@
   typedef enum { inputMode, firstMode = inputMode, tempMode, outputMode, numModes, invalidMode = -1 } OprMode;
 
   enum {
-    maxNumberOfOperands = 16,
+    maxNumberOfOperands = 20,
     maxNumberOfInfos = 4
   };
 
--- ./hotspot/src/share/vm/c1/c1_LinearScan.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/c1/c1_LinearScan.cpp	Wed May 07 19:26:16 2014 -0700
@@ -1138,8 +1138,10 @@
         }
       }
     }
-
-  } else if (opr_type != T_LONG) {
+    // We want to sometimes use logical operations on pointers, in particular in GC barriers.
+    // Since 64bit logical operations do not current support operands on stack, we have to make sure
+    // T_OBJECT doesn't get spilled along with T_LONG.
+  } else if (opr_type != T_LONG LP64_ONLY(&& opr_type != T_OBJECT)) {
     // integer instruction (note: long operands must always be in register)
     switch (op->code()) {
       case lir_cmp:
--- ./hotspot/src/share/vm/c1/c1_Runtime1.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/c1/c1_Runtime1.cpp	Wed May 07 19:26:16 2014 -0700
@@ -911,16 +911,6 @@
     // Return to the now deoptimized frame.
   }
 
-  // If we are patching in a non-perm oop, make sure the nmethod
-  // is on the right list.
-  if (ScavengeRootsInCode && load_klass.not_null() && load_klass->is_scavengable()) {
-    MutexLockerEx ml_code (CodeCache_lock, Mutex::_no_safepoint_check_flag);
-    nmethod* nm = CodeCache::find_nmethod(caller_frame.pc());
-    guarantee(nm != NULL, "only nmethods can contain non-perm oops");
-    if (!nm->on_scavenge_root_list())
-      CodeCache::add_scavenge_root_nmethod(nm);
-  }
-
   // Now copy code back
 
   {
@@ -1096,6 +1086,22 @@
       }
     }
   }
+
+
+  // If we are patching in a non-perm oop, make sure the nmethod
+  // is on the right list.
+  if (ScavengeRootsInCode && load_klass.not_null() && load_klass->is_scavengable()) {
+    MutexLockerEx ml_code (CodeCache_lock, Mutex::_no_safepoint_check_flag);
+    nmethod* nm = CodeCache::find_nmethod(caller_frame.pc());
+    guarantee(nm != NULL, "only nmethods can contain non-perm oops");
+    if (!nm->on_scavenge_root_list()) {
+      CodeCache::add_scavenge_root_nmethod(nm);
+    }
+
+    // Since we've patched some oops in the nmethod,
+    // (re)register it with the heap.
+    Universe::heap()->register_nmethod(nm);
+  }
 JRT_END
 
 //
--- ./hotspot/src/share/vm/classfile/classFileParser.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/classfile/classFileParser.cpp	Wed May 07 19:26:16 2014 -0700
@@ -4056,8 +4056,8 @@
   for (int index = 0; index < num_methods; index++) {
     methodOop m = (methodOop)methods->obj_at(index);
 
-    // skip static and <init> methods
-    if ((!m->is_static()) &&
+    // skip private, static, and <init> methods
+    if ((!m->is_private() && !m->is_static()) &&
         (m->name() != vmSymbols::object_initializer_name())) {
 
       Symbol* name = m->name();
--- ./hotspot/src/share/vm/classfile/javaClasses.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/classfile/javaClasses.cpp	Wed May 07 19:26:16 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -2388,6 +2388,26 @@
   *offset = value;
 }
 
+// Support for java_lang_invoke_DirectMethodHandle
+
+int java_lang_invoke_DirectMethodHandle::_member_offset;
+
+oop java_lang_invoke_DirectMethodHandle::member(oop dmh) {
+  oop member_name = NULL;
+  bool is_dmh = dmh->is_oop() && java_lang_invoke_DirectMethodHandle::is_instance(dmh);
+  assert(is_dmh, "a DirectMethodHandle oop is expected");
+  if (is_dmh) {
+    member_name = dmh->obj_field(member_offset_in_bytes());
+  }
+  return member_name;
+}
+
+void java_lang_invoke_DirectMethodHandle::compute_offsets() {
+  klassOop klass_oop = SystemDictionary::DirectMethodHandle_klass();
+  if (klass_oop != NULL && EnableInvokeDynamic) {
+    compute_offset(_member_offset, klass_oop, vmSymbols::member_name(), vmSymbols::java_lang_invoke_MemberName_signature());
+  }
+}
 
 // Support for java_lang_invoke_MethodHandle
 
@@ -2497,6 +2517,13 @@
   return mname->obj_field(_vmtarget_offset);
 }
 
+// Can be executed on VM thread only
+void java_lang_invoke_MemberName::adjust_vmtarget(oop mname, oop ref) {
+  assert((is_instance(mname) && (flags(mname) & (MN_IS_METHOD | MN_IS_CONSTRUCTOR)) > 0), "wrong type");
+  assert(Thread::current()->is_VM_thread(), "not VM thread");
+  mname->address_field_put(_vmtarget_offset, (address)ref);
+}
+
 void java_lang_invoke_MemberName::set_vmtarget(oop mname, oop ref) {
   assert(is_instance(mname), "wrong type");
 #ifdef ASSERT
@@ -3000,6 +3027,7 @@
   java_lang_ThreadGroup::compute_offsets();
   if (EnableInvokeDynamic) {
     java_lang_invoke_MethodHandle::compute_offsets();
+    java_lang_invoke_DirectMethodHandle::compute_offsets();
     java_lang_invoke_MemberName::compute_offsets();
     java_lang_invoke_LambdaForm::compute_offsets();
     java_lang_invoke_MethodType::compute_offsets();
--- ./hotspot/src/share/vm/classfile/javaClasses.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/classfile/javaClasses.hpp	Wed May 07 19:26:16 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -915,6 +915,32 @@
   static int form_offset_in_bytes()             { return _form_offset; }
 };
 
+// Interface to java.lang.invoke.DirectMethodHandle objects
+
+class java_lang_invoke_DirectMethodHandle: AllStatic {
+  friend class JavaClasses;
+
+ private:
+  static int _member_offset;               // the MemberName of this DMH
+
+  static void compute_offsets();
+
+ public:
+  // Accessors
+  static oop  member(oop mh);
+
+  // Testers
+  static bool is_subclass(klassOop klass) {
+    return Klass::cast(klass)->is_subclass_of(SystemDictionary::DirectMethodHandle_klass());
+  }
+  static bool is_instance(oop obj) {
+    return obj != NULL && is_subclass(obj->klass());
+  }
+
+  // Accessors for code generation:
+  static int member_offset_in_bytes() { return _member_offset; }
+};
+
 // Interface to java.lang.invoke.LambdaForm objects
 // (These are a private interface for managing adapter code generation.)
 
@@ -988,6 +1014,7 @@
 
   static oop            vmtarget(oop mname);
   static void       set_vmtarget(oop mname, oop target);
+  static void       adjust_vmtarget(oop mname, oop target);
 
   static intptr_t       vmindex(oop mname);
   static void       set_vmindex(oop mname, intptr_t index);
--- ./hotspot/src/share/vm/classfile/symbolTable.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/classfile/symbolTable.cpp	Wed May 07 19:26:16 2014 -0700
@@ -39,6 +39,9 @@
 
 // --------------------------------------------------------------------------
 
+// the number of buckets a thread claims
+const int ClaimChunkSize = 32;
+
 SymbolTable* SymbolTable::_the_table = NULL;
 // Static arena for symbols that are not deallocated
 Arena* SymbolTable::_arena = NULL;
@@ -81,16 +84,12 @@
   }
 }
 
-int SymbolTable::symbols_removed = 0;
-int SymbolTable::symbols_counted = 0;
+int SymbolTable::_symbols_removed = 0;
+int SymbolTable::_symbols_counted = 0;
+volatile int SymbolTable::_parallel_claimed_idx = 0;
 
-// Remove unreferenced symbols from the symbol table
-// This is done late during GC.
-void SymbolTable::unlink() {
-  int removed = 0;
-  int total = 0;
-  size_t memory_total = 0;
-  for (int i = 0; i < the_table()->table_size(); ++i) {
+void SymbolTable::buckets_unlink(int start_idx, int end_idx, int* processed, int* removed, size_t* memory_total) {
+  for (int i = start_idx; i < end_idx; ++i) {
     HashtableEntry<Symbol*, mtSymbol>** p = the_table()->bucket_addr(i);
     HashtableEntry<Symbol*, mtSymbol>* entry = the_table()->bucket(i);
     while (entry != NULL) {
@@ -102,14 +101,14 @@
         break;
       }
       Symbol* s = entry->literal();
-      memory_total += s->object_size();
-      total++;
+      (*memory_total) += s->object_size();
+      (*processed)++;
       assert(s != NULL, "just checking");
       // If reference count is zero, remove.
       if (s->refcount() == 0) {
         assert(!entry->is_shared(), "shared entries should be kept live");
         delete s;
-        removed++;
+        (*removed)++;
         *p = entry->next();
         the_table()->free_entry(entry);
       } else {
@@ -119,12 +118,45 @@
       entry = (HashtableEntry<Symbol*, mtSymbol>*)HashtableEntry<Symbol*, mtSymbol>::make_ptr(*p);
     }
   }
-  symbols_removed += removed;
-  symbols_counted += total;
+}
+
+// Remove unreferenced symbols from the symbol table
+// This is done late during GC.
+void SymbolTable::unlink(int* processed, int* removed) {
+  size_t memory_total = 0;
+  buckets_unlink(0, the_table()->table_size(), processed, removed, &memory_total);
+  _symbols_removed += *removed;
+  _symbols_counted += *processed;
   // Exclude printing for normal PrintGCDetails because people parse
   // this output.
   if (PrintGCDetails && Verbose && WizardMode) {
-    gclog_or_tty->print(" [Symbols=%d size=" SIZE_FORMAT "K] ", total,
+    gclog_or_tty->print(" [Symbols=%d size=" SIZE_FORMAT "K] ", *processed,
+                        (memory_total*HeapWordSize)/1024);
+  }
+}
+
+void SymbolTable::possibly_parallel_unlink(int* processed, int* removed) {
+  const int limit = the_table()->table_size();
+
+  size_t memory_total = 0;
+
+  for (;;) {
+    // Grab next set of buckets to scan
+    int start_idx = Atomic::add(ClaimChunkSize, &_parallel_claimed_idx) - ClaimChunkSize;
+    if (start_idx >= limit) {
+      // End of table
+      break;
+    }
+
+    int end_idx = MIN2(limit, start_idx + ClaimChunkSize);
+    buckets_unlink(start_idx, end_idx, processed, removed, &memory_total);
+  }
+  Atomic::add(*processed, &_symbols_counted);
+  Atomic::add(*removed, &_symbols_removed);
+  // Exclude printing for normal PrintGCDetails because people parse
+  // this output.
+  if (PrintGCDetails && Verbose && WizardMode) {
+    gclog_or_tty->print(" [Symbols: scanned=%d removed=%d size=" SIZE_FORMAT "K] ", *processed, *removed,
                         (memory_total*HeapWordSize)/1024);
   }
 }
@@ -503,21 +535,21 @@
     }
   }
   tty->print_cr("Symbol Table:");
-  tty->print_cr("Total number of symbols  %5d", count);
-  tty->print_cr("Total size in memory     %5dK",
+  tty->print_cr("Total number of symbols  "INT32_FORMAT, count);
+  tty->print_cr("Total size in memory     "INT32_FORMAT"K",
           (memory_total*HeapWordSize)/1024);
-  tty->print_cr("Total counted            %5d", symbols_counted);
-  tty->print_cr("Total removed            %5d", symbols_removed);
-  if (symbols_counted > 0) {
+  tty->print_cr("Total counted            "INT32_FORMAT, _symbols_counted);
+  tty->print_cr("Total removed            "INT32_FORMAT, _symbols_removed);
+  if (_symbols_counted > 0) {
     tty->print_cr("Percent removed          %3.2f",
-          ((float)symbols_removed/(float)symbols_counted)* 100);
+          ((float)_symbols_removed/(float)_symbols_counted)* 100);
   }
-  tty->print_cr("Reference counts         %5d", Symbol::_total_count);
-  tty->print_cr("Symbol arena size        %5d used %5d",
+  tty->print_cr("Reference counts         "INT32_FORMAT, Symbol::_total_count);
+  tty->print_cr("Symbol arena size        "SIZE_FORMAT" used "SIZE_FORMAT,
                  arena()->size_in_bytes(), arena()->used());
   tty->print_cr("Histogram of symbol length:");
-  tty->print_cr("%8s %5d", "Total  ", total);
-  tty->print_cr("%8s %5d", "Maximum", max_symbols);
+  tty->print_cr("%8s "INT32_FORMAT, "Total  ", total);
+  tty->print_cr("%8s "INT32_FORMAT, "Maximum", max_symbols);
   tty->print_cr("%8s %3.2f", "Average",
           ((float) total / (float) the_table()->table_size()));
   tty->print_cr("%s", "Histogram:");
@@ -746,11 +778,41 @@
   return result;
 }
 
-void StringTable::unlink(BoolObjectClosure* is_alive) {
+void StringTable::unlink(BoolObjectClosure* is_alive, int* processed, int* removed) {
+    buckets_unlink(is_alive, 0, the_table()->table_size(), processed, removed);
+}
+
+void StringTable::possibly_parallel_unlink(BoolObjectClosure* is_alive, int* processed, int* removed) {
   // Readers of the table are unlocked, so we should only be removing
   // entries at a safepoint.
   assert(SafepointSynchronize::is_at_safepoint(), "must be at safepoint");
-  for (int i = 0; i < the_table()->table_size(); ++i) {
+  const int limit = the_table()->table_size();
+
+  for (;;) {
+    // Grab next set of buckets to scan
+    int start_idx = Atomic::add(ClaimChunkSize, &_parallel_claimed_idx) - ClaimChunkSize;
+    if (start_idx >= limit) {
+      // End of table
+      break;
+    }
+
+    int end_idx = MIN2(limit, start_idx + ClaimChunkSize);
+    buckets_unlink(is_alive, start_idx, end_idx, processed, removed);
+  }
+}
+
+void StringTable::buckets_unlink(BoolObjectClosure* is_alive, int start_idx, int end_idx, int* processed, int* removed) {
+  const int limit = the_table()->table_size();
+
+  assert(0 <= start_idx && start_idx <= limit,
+         err_msg("start_idx (" INT32_FORMAT ") is out of bounds", start_idx));
+  assert(0 <= end_idx && end_idx <= limit,
+         err_msg("end_idx (" INT32_FORMAT ") is out of bounds", end_idx));
+  assert(start_idx <= end_idx,
+         err_msg("Index ordering: start_idx=" INT32_FORMAT", end_idx=" INT32_FORMAT,
+                 start_idx, end_idx));
+
+  for (int i = start_idx; i < end_idx; ++i) {
     HashtableEntry<oop, mtSymbol>** p = the_table()->bucket_addr(i);
     HashtableEntry<oop, mtSymbol>* entry = the_table()->bucket(i);
     while (entry != NULL) {
@@ -767,24 +829,26 @@
       } else {
         *p = entry->next();
         the_table()->free_entry(entry);
+        (*removed)++;
       }
+      (*processed)++;
       entry = (HashtableEntry<oop, mtSymbol>*)HashtableEntry<oop, mtSymbol>::make_ptr(*p);
     }
   }
 }
 
-void StringTable::buckets_do(OopClosure* f, int start_idx, int end_idx) {
+void StringTable::buckets_oops_do(OopClosure* f, int start_idx, int end_idx) {
   const int limit = the_table()->table_size();
 
   assert(0 <= start_idx && start_idx <= limit,
-         err_msg("start_idx (" INT32_FORMAT ") oob?", start_idx));
+         err_msg("start_idx (" INT32_FORMAT ") is out of bounds", start_idx));
   assert(0 <= end_idx && end_idx <= limit,
-         err_msg("end_idx (" INT32_FORMAT ") oob?", end_idx));
+         err_msg("end_idx (" INT32_FORMAT ") is out of bounds", end_idx));
   assert(start_idx <= end_idx,
-         err_msg("Ordering: start_idx=" INT32_FORMAT", end_idx=" INT32_FORMAT,
+         err_msg("Index ordering: start_idx=" INT32_FORMAT", end_idx=" INT32_FORMAT,
                  start_idx, end_idx));
 
-  for (int i = start_idx; i < end_idx; i += 1) {
+  for (int i = start_idx; i < end_idx; i++) {
     HashtableEntry<oop, mtSymbol>** p = the_table()->bucket_addr(i);
     HashtableEntry<oop, mtSymbol>* entry = the_table()->bucket(i);
     while (entry != NULL) {
@@ -804,11 +868,10 @@
 }
 
 void StringTable::oops_do(OopClosure* f) {
-  buckets_do(f, 0, the_table()->table_size());
+  buckets_oops_do(f, 0, the_table()->table_size());
 }
 
 void StringTable::possibly_parallel_oops_do(OopClosure* f) {
-  const int ClaimChunkSize = 32;
   const int limit = the_table()->table_size();
 
   for (;;) {
@@ -820,7 +883,7 @@
     }
 
     int end_idx = MIN2(limit, start_idx + ClaimChunkSize);
-    buckets_do(f, start_idx, end_idx);
+    buckets_oops_do(f, start_idx, end_idx);
   }
 }
 
--- ./hotspot/src/share/vm/classfile/symbolTable.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/classfile/symbolTable.hpp	Wed May 07 19:26:16 2014 -0700
@@ -86,8 +86,8 @@
   static bool _needs_rehashing;
 
   // For statistics
-  static int symbols_removed;
-  static int symbols_counted;
+  static int _symbols_removed;
+  static int _symbols_counted;
 
   Symbol* allocate_symbol(const u1* name, int len, bool c_heap, TRAPS); // Assumes no characters larger than 0x7F
 
@@ -126,6 +126,11 @@
   static Arena* arena() { return _arena; }  // called for statistics
 
   static void initialize_symbols(int arena_alloc_size = 0);
+
+  static volatile int _parallel_claimed_idx;
+
+  // Release any dead symbols
+  static void buckets_unlink(int start_idx, int end_idx, int* processed, int* removed, size_t* memory_total);
 public:
   enum {
     symbol_alloc_batch_size = 8,
@@ -175,7 +180,19 @@
                   unsigned int* hashValues, TRAPS);
 
   // Release any dead symbols
-  static void unlink();
+  static void unlink() {
+    int processed = 0;
+    int removed = 0;
+    unlink(&processed, &removed);
+  }
+  static void unlink(int* processed, int* removed);
+  // Release any dead symbols, possibly parallel version
+  static void possibly_parallel_unlink() {
+    int processed = 0;
+    int removed = 0;
+    possibly_parallel_unlink(&processed, &removed);
+  }
+  static void possibly_parallel_unlink(int* processed, int* removed);
 
   // iterate over symbols
   static void symbols_do(SymbolClosure *cl);
@@ -233,6 +250,9 @@
   // Rehash the symbol table if it gets out of balance
   static void rehash_table();
   static bool needs_rehashing()         { return _needs_rehashing; }
+  // Parallel chunked scanning
+  static void clear_parallel_claimed_index() { _parallel_claimed_idx = 0; }
+  static int parallel_claimed_index() { return _parallel_claimed_idx; }
 };
 
 class StringTable : public Hashtable<oop, mtSymbol> {
@@ -256,7 +276,9 @@
 
   // Apply the give oop closure to the entries to the buckets
   // in the range [start_idx, end_idx).
-  static void buckets_do(OopClosure* f, int start_idx, int end_idx);
+  static void buckets_oops_do(OopClosure* f, int start_idx, int end_idx);
+  // Unlink the entries to the buckets in the range [start_idx, end_idx).
+  static void buckets_unlink(BoolObjectClosure* is_alive, int start_idx, int end_idx, int* processed, int* removed);
 
   StringTable() : Hashtable<oop, mtSymbol>((int)StringTableSize,
                               sizeof (HashtableEntry<oop, mtSymbol>)) {}
@@ -283,7 +305,13 @@
 
   // GC support
   //   Delete pointers to otherwise-unreachable objects.
-  static void unlink(BoolObjectClosure* cl);
+  static void unlink(BoolObjectClosure* cl) {
+    int processed = 0;
+    int removed = 0;
+    unlink(cl, &processed, &removed);
+  }
+
+  static void unlink(BoolObjectClosure* cl, int* processed, int* removed);
 
   // Serially invoke "f->do_oop" on the locations of all oops in the table.
   static void oops_do(OopClosure* f);
@@ -291,6 +319,8 @@
   // Possibly parallel version of the above
   static void possibly_parallel_oops_do(OopClosure* f);
 
+  static void possibly_parallel_unlink(BoolObjectClosure* cl, int* processed, int* removed);
+
   // Hashing algorithm, used as the hash value used by the
   //     StringTable for bucket selection and comparison (stored in the
   //     HashtableEntry structures).  This is used in the String.intern() method.
@@ -328,5 +358,6 @@
 
   // Parallel chunked scanning
   static void clear_parallel_claimed_index() { _parallel_claimed_idx = 0; }
+  static int parallel_claimed_index() { return _parallel_claimed_idx; }
 };
 #endif // SHARE_VM_CLASSFILE_SYMBOLTABLE_HPP
--- ./hotspot/src/share/vm/classfile/systemDictionary.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/classfile/systemDictionary.cpp	Wed May 07 19:26:16 2014 -0700
@@ -585,7 +585,7 @@
   assert(name != NULL && !FieldType::is_array(name) &&
          !FieldType::is_obj(name), "invalid class name");
 
-  TracingTime class_load_start_time = Tracing::time();
+  const Ticks class_load_start_time = Ticks::now();
 
   // UseNewReflection
   // Fix for 4474172; see evaluation for more details
@@ -946,7 +946,7 @@
                                         TRAPS) {
   TempNewSymbol parsed_name = NULL;
 
-  TracingTime class_load_start_time = Tracing::time();
+  const Ticks class_load_start_time = Ticks::now();
 
   // Parse the stream. Note that we do this even though this klass might
   // already be present in the SystemDictionary, otherwise we would not
@@ -1572,9 +1572,10 @@
 // Used for assertions and verification only
 klassOop SystemDictionary::find_class(Symbol* class_name, Handle class_loader) {
   #ifndef ASSERT
-  guarantee(VerifyBeforeGC   ||
-            VerifyDuringGC   ||
-            VerifyBeforeExit ||
+  guarantee(VerifyBeforeGC      ||
+            VerifyDuringGC      ||
+            VerifyBeforeExit    ||
+            VerifyDuringStartup ||
             VerifyAfterGC, "too expensive");
   #endif
   assert_locked_or_safepoint(SystemDictionary_lock);
@@ -2314,6 +2315,11 @@
   objArrayHandle appendix_box = oopFactory::new_objArray(SystemDictionary::Object_klass(), 1, CHECK_(empty));
   assert(appendix_box->obj_at(0) == NULL, "");
 
+  // This should not happen.  JDK code should take care of that.
+  if (accessing_klass.is_null() || method_type.is_null()) {
+    THROW_MSG_(vmSymbols::java_lang_InternalError(), "bad invokehandle", empty);
+  }
+
   // call java.lang.invoke.MethodHandleNatives::linkMethod(... String, MethodType) -> MemberName
   JavaCallArguments args;
   args.push_oop(accessing_klass()->java_mirror());
@@ -2439,6 +2445,9 @@
   Handle type;
   if (signature->utf8_length() > 0 && signature->byte_at(0) == '(') {
     type = find_method_handle_type(signature, caller, CHECK_(empty));
+  } else if (caller.is_null()) {
+    // This should not happen.  JDK code should take care of that.
+    THROW_MSG_(vmSymbols::java_lang_InternalError(), "bad MH constant", empty);
   } else {
     ResourceMark rm(THREAD);
     SignatureStream ss(signature, false);
@@ -2502,6 +2511,11 @@
   Handle method_name = java_lang_String::create_from_symbol(name, CHECK_(empty));
   Handle method_type = find_method_handle_type(type, caller, CHECK_(empty));
 
+  // This should not happen.  JDK code should take care of that.
+  if (caller.is_null() || method_type.is_null()) {
+    THROW_MSG_(vmSymbols::java_lang_InternalError(), "bad invokedynamic", empty);
+  }
+
   objArrayHandle appendix_box = oopFactory::new_objArray(SystemDictionary::Object_klass(), 1, CHECK_(empty));
   assert(appendix_box->obj_at(0) == NULL, "");
 
@@ -2607,13 +2621,12 @@
 }
 
 // utility function for posting class load event
-void SystemDictionary::post_class_load_event(TracingTime start_time,
+void SystemDictionary::post_class_load_event(const Ticks& start_time,
                                              instanceKlassHandle k,
                                              Handle initiating_loader) {
 #if INCLUDE_TRACE
   EventClassLoad event(UNTIMED);
   if (event.should_commit()) {
-    event.set_endtime(Tracing::time());
     event.set_starttime(start_time);
     event.set_loadedClass(k());
     oop defining_class_loader = k->class_loader();
@@ -2632,7 +2645,7 @@
   assert(SafepointSynchronize::is_at_safepoint(), "must be at safepoint!");
   if (Tracing::enabled()) {
     _should_write_unload_events = Tracing::is_event_enabled(TraceClassUnloadEvent);
-    _class_unload_time = Tracing::time();
+    _class_unload_time = Ticks::now();
     _is_alive = is_alive;
     classes_do(&class_unload_event);
 
@@ -2648,7 +2661,7 @@
 
 #if INCLUDE_TRACE
 
-TracingTime SystemDictionary::_class_unload_time;
+Ticks SystemDictionary::_class_unload_time;
 BoolObjectClosure* SystemDictionary::_is_alive = NULL;
 int SystemDictionary::_no_of_classes_unloading = 0;
 bool SystemDictionary::_should_write_unload_events = false;
--- ./hotspot/src/share/vm/classfile/systemDictionary.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/classfile/systemDictionary.hpp	Wed May 07 19:26:16 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -33,7 +33,7 @@
 #include "runtime/reflectionUtils.hpp"
 #include "utilities/hashtable.hpp"
 #include "utilities/hashtable.inline.hpp"
-#include "trace/traceTime.hpp"
+#include "utilities/ticks.hpp"
 
 // The system dictionary stores all loaded classes and maps:
 //
@@ -151,6 +151,7 @@
   do_klass(MemberName_klass,                            java_lang_invoke_MemberName,               Pre_JSR292          ) \
   do_klass(MethodHandleNatives_klass,                   java_lang_invoke_MethodHandleNatives,      Pre_JSR292          ) \
   do_klass(LambdaForm_klass,                            java_lang_invoke_LambdaForm,               Opt                 ) \
+  do_klass(DirectMethodHandle_klass,                    java_lang_invoke_DirectMethodHandle,       Opt                 ) \
   do_klass(MethodType_klass,                            java_lang_invoke_MethodType,               Pre_JSR292          ) \
   do_klass(BootstrapMethodError_klass,                  java_lang_BootstrapMethodError,            Pre_JSR292          ) \
   do_klass(CallSite_klass,                              java_lang_invoke_CallSite,                 Pre_JSR292          ) \
@@ -616,7 +617,7 @@
   static void add_to_hierarchy(instanceKlassHandle k, TRAPS);
 
   // event based tracing
-  static void post_class_load_event(TracingTime start_time, instanceKlassHandle k,
+  static void post_class_load_event(const Ticks& start_time, instanceKlassHandle k,
                                     Handle initiating_loader);
   static void post_class_unload_events(BoolObjectClosure* is_alive);
 
@@ -678,7 +679,7 @@
   static bool _has_checkPackageAccess;
 
 #if INCLUDE_TRACE
-  static TracingTime _class_unload_time;
+  static Ticks _class_unload_time;
   static BoolObjectClosure* _is_alive;
   static int _no_of_classes_unloading;
   static bool _should_write_unload_events;
--- ./hotspot/src/share/vm/classfile/vmSymbols.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/classfile/vmSymbols.hpp	Wed May 07 19:26:16 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -243,6 +243,7 @@
   /* Support for JSR 292 & invokedynamic (JDK 1.7 and above) */                                   \
   template(java_lang_invoke_CallSite,                 "java/lang/invoke/CallSite")                \
   template(java_lang_invoke_ConstantCallSite,         "java/lang/invoke/ConstantCallSite")        \
+  template(java_lang_invoke_DirectMethodHandle,       "java/lang/invoke/DirectMethodHandle")      \
   template(java_lang_invoke_MutableCallSite,          "java/lang/invoke/MutableCallSite")         \
   template(java_lang_invoke_VolatileCallSite,         "java/lang/invoke/VolatileCallSite")        \
   template(java_lang_invoke_MethodHandle,             "java/lang/invoke/MethodHandle")            \
@@ -338,6 +339,7 @@
   template(thread_id_name,                            "tid")                                      \
   template(newInstance0_name,                         "newInstance0")                             \
   template(limit_name,                                "limit")                                    \
+  template(member_name,                               "member")                                   \
   template(forName_name,                              "forName")                                  \
   template(forName0_name,                             "forName0")                                 \
   template(isJavaIdentifierStart_name,                "isJavaIdentifierStart")                    \
--- ./hotspot/src/share/vm/code/nmethod.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/code/nmethod.cpp	Wed May 07 19:26:16 2014 -0700
@@ -676,6 +676,7 @@
     code_buffer->copy_oops_to(this);
     if (ScavengeRootsInCode && detect_scavenge_root_oops()) {
       CodeCache::add_scavenge_root_nmethod(this);
+      Universe::heap()->register_nmethod(this);
     }
     debug_only(verify_scavenge_root_oops());
     CodeCache::commit(this);
@@ -869,6 +870,7 @@
     dependencies->copy_to(this);
     if (ScavengeRootsInCode && detect_scavenge_root_oops()) {
       CodeCache::add_scavenge_root_nmethod(this);
+      Universe::heap()->register_nmethod(this);
     }
     debug_only(verify_scavenge_root_oops());
 
@@ -1282,6 +1284,13 @@
   methodHandle the_method(method());
   No_Safepoint_Verifier nsv;
 
+  // during patching, depending on the nmethod state we must notify the GC that
+  // code has been unloaded, unregistering it. We cannot do this right while
+  // holding the Patching_lock because we need to use the CodeCache_lock. This
+  // would be prone to deadlocks.
+  // This flag is used to remember whether we need to later lock and unregister.
+  bool nmethod_needs_unregister = false;
+
   {
     // invalidate osr nmethod before acquiring the patching lock since
     // they both acquire leaf locks and we don't want a deadlock.
@@ -1314,6 +1323,13 @@
       inc_decompile_count();
     }
 
+    // If the state is becoming a zombie, signal to unregister the nmethod with
+    // the heap.
+    // This nmethod may have already been unloaded during a full GC.
+    if ((state == zombie) && !is_unloaded()) {
+      nmethod_needs_unregister = true;
+    }
+
     // Change state
     _state = state;
 
@@ -1349,6 +1365,9 @@
       // safepoint can sneak in, otherwise the oops used by the
       // dependency logic could have become stale.
       MutexLockerEx mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
+      if (nmethod_needs_unregister) {
+        Universe::heap()->unregister_nmethod(this);
+      }
       flush_dependencies(NULL);
     }
 
@@ -1696,20 +1715,10 @@
 #endif // !PRODUCT
 }
 
-// This method is called twice during GC -- once while
-// tracing the "active" nmethods on thread stacks during
-// the (strong) marking phase, and then again when walking
-// the code cache contents during the weak roots processing
-// phase. The two uses are distinguished by means of the
-// 'do_strong_roots_only' flag, which is true in the first
-// case. We want to walk the weak roots in the nmethod
-// only in the second case. The weak roots in the nmethod
-// are the oops in the ExceptionCache and the InlineCache
-// oops.
-void nmethod::oops_do(OopClosure* f, bool do_strong_roots_only) {
-  // make sure the oops ready to receive visitors
-  assert(!is_zombie() && !is_unloaded(),
-         "should not call follow on zombie or unloaded nmethod");
+void nmethod::oops_do(OopClosure* f, bool do_strong_roots_only, bool allow_zombie) {
+   // make sure the oops ready to receive visitors
+  assert(allow_zombie || !is_zombie(), "should not call follow on zombie nmethod");
+  assert(!is_unloaded(), "should not call follow on unloaded nmethod");
 
   // If the method is not entrant or zombie then a JMP is plastered over the
   // first few bytes.  If an oop in the old code was there, that oop
--- ./hotspot/src/share/vm/code/nmethod.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/code/nmethod.hpp	Wed May 07 19:26:16 2014 -0700
@@ -548,8 +548,8 @@
 
   void preserve_callee_argument_oops(frame fr, const RegisterMap *reg_map,
                                      OopClosure* f);
-  void oops_do(OopClosure* f) { oops_do(f, false); }
-  void oops_do(OopClosure* f, bool do_strong_roots_only);
+  void oops_do(OopClosure* f) { oops_do(f, false, false); }
+  void oops_do(OopClosure* f, bool do_strong_roots_only, bool allow_zombie);
   bool detect_scavenge_root_oops();
   void verify_scavenge_root_oops() PRODUCT_RETURN;
 
--- ./hotspot/src/share/vm/gc_implementation/concurrentMarkSweep/cmsOopClosures.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/gc_implementation/concurrentMarkSweep/cmsOopClosures.hpp	Wed May 07 19:26:16 2014 -0700
@@ -58,8 +58,22 @@
   MarkRefsIntoClosure(MemRegion span, CMSBitMap* bitMap);
   virtual void do_oop(oop* p);
   virtual void do_oop(narrowOop* p);
-  inline void do_oop_nv(oop* p)       { MarkRefsIntoClosure::do_oop_work(p); }
-  inline void do_oop_nv(narrowOop* p) { MarkRefsIntoClosure::do_oop_work(p); }
+
+  Prefetch::style prefetch_style() {
+    return Prefetch::do_read;
+  }
+};
+
+class Par_MarkRefsIntoClosure: public OopsInGenClosure {
+ private:
+  const MemRegion _span;
+  CMSBitMap*      _bitMap;
+ protected:
+  DO_OOP_WORK_DEFN
+ public:
+  Par_MarkRefsIntoClosure(MemRegion span, CMSBitMap* bitMap);
+  virtual void do_oop(oop* p);
+  virtual void do_oop(narrowOop* p);
   bool do_header() { return true; }
   Prefetch::style prefetch_style() {
     return Prefetch::do_read;
--- ./hotspot/src/share/vm/gc_implementation/concurrentMarkSweep/concurrentMarkSweepGeneration.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/gc_implementation/concurrentMarkSweep/concurrentMarkSweepGeneration.cpp	Wed May 07 19:26:16 2014 -0700
@@ -575,6 +575,7 @@
   _restart_addr(NULL),
   _overflow_list(NULL),
   _stats(cmsGen),
+  _eden_chunk_lock(new Mutex(Mutex::leaf + 1, "CMS_eden_chunk_lock", true)),
   _eden_chunk_array(NULL),     // may be set in ctor body
   _eden_chunk_capacity(0),     // -- ditto --
   _eden_chunk_index(0),        // -- ditto --
@@ -754,7 +755,7 @@
   assert(_eden_chunk_array != NULL || _eden_chunk_capacity == 0, "Error");
 
   // Support for parallelizing survivor space rescan
-  if (CMSParallelRemarkEnabled && CMSParallelSurvivorRemarkEnabled) {
+  if ((CMSParallelRemarkEnabled && CMSParallelSurvivorRemarkEnabled) || CMSParallelInitialMarkEnabled) {
     const size_t max_plab_samples =
       ((DefNewGeneration*)_young_gen)->max_survivor_size()/MinTLABSize;
 
@@ -1997,7 +1998,7 @@
   GenCollectedHeap* gch = GenCollectedHeap::heap();
 
   STWGCTimer* gc_timer = GenMarkSweep::gc_timer();
-  gc_timer->register_gc_start(os::elapsed_counter());
+  gc_timer->register_gc_start();
 
   SerialOldTracer* gc_tracer = GenMarkSweep::gc_tracer();
   gc_tracer->report_gc_start(gch->gc_cause(), gc_timer->gc_start());
@@ -2094,7 +2095,7 @@
     size_policy()->msc_collection_end(gch->gc_cause());
   }
 
-  gc_timer->register_gc_end(os::elapsed_counter());
+  gc_timer->register_gc_end();
 
   gc_tracer->report_gc_end(gc_timer->gc_end(), gc_timer->time_partitions());
 
@@ -2136,6 +2137,39 @@
 }
 
 
+void CMSCollector::print_eden_and_survivor_chunk_arrays() {
+  DefNewGeneration* dng = _young_gen->as_DefNewGeneration();
+  EdenSpace* eden_space = dng->eden();
+  ContiguousSpace* from_space = dng->from();
+  ContiguousSpace* to_space   = dng->to();
+  // Eden
+  if (_eden_chunk_array != NULL) {
+    gclog_or_tty->print_cr("eden " PTR_FORMAT "-" PTR_FORMAT "-" PTR_FORMAT "(" SIZE_FORMAT ")",
+                           eden_space->bottom(), eden_space->top(),
+                           eden_space->end(), eden_space->capacity());
+    gclog_or_tty->print_cr("_eden_chunk_index=" SIZE_FORMAT ", "
+                           "_eden_chunk_capacity=" SIZE_FORMAT,
+                           _eden_chunk_index, _eden_chunk_capacity);
+    for (size_t i = 0; i < _eden_chunk_index; i++) {
+      gclog_or_tty->print_cr("_eden_chunk_array[" SIZE_FORMAT "]=" PTR_FORMAT,
+                             i, _eden_chunk_array[i]);
+    }
+  }
+  // Survivor
+  if (_survivor_chunk_array != NULL) {
+    gclog_or_tty->print_cr("survivor " PTR_FORMAT "-" PTR_FORMAT "-" PTR_FORMAT "(" SIZE_FORMAT ")",
+                           from_space->bottom(), from_space->top(),
+                           from_space->end(), from_space->capacity());
+    gclog_or_tty->print_cr("_survivor_chunk_index=" SIZE_FORMAT ", "
+                           "_survivor_chunk_capacity=" SIZE_FORMAT,
+                           _survivor_chunk_index, _survivor_chunk_capacity);
+    for (size_t i = 0; i < _survivor_chunk_index; i++) {
+      gclog_or_tty->print_cr("_survivor_chunk_array[" SIZE_FORMAT "]=" PTR_FORMAT,
+                             i, _survivor_chunk_array[i]);
+    }
+  }
+}
+
 void CMSCollector::getFreelistLocks() const {
   // Get locks for all free lists in all generations that this
   // collector is responsible for
@@ -2443,7 +2477,7 @@
 
 void CMSCollector::register_gc_start(GCCause::Cause cause) {
   _cms_start_registered = true;
-  _gc_timer_cm->register_gc_start(os::elapsed_counter());
+  _gc_timer_cm->register_gc_start();
   _gc_tracer_cm->report_gc_start(cause, _gc_timer_cm->gc_start());
 }
 
@@ -2451,7 +2485,7 @@
   if (_cms_start_registered) {
     report_heap_summary(GCWhen::AfterGC);
 
-    _gc_timer_cm->register_gc_end(os::elapsed_counter());
+    _gc_timer_cm->register_gc_end();
     _gc_tracer_cm->report_gc_end(_gc_timer_cm->gc_end(), _gc_timer_cm->time_partitions());
     _cms_start_registered = false;
   }
@@ -2510,8 +2544,7 @@
         // initial marking in checkpointRootsInitialWork has been completed
         if (VerifyDuringGC &&
             GenCollectedHeap::heap()->total_collections() >= VerifyGCStartAt) {
-          gclog_or_tty->print("Verify before initial mark: ");
-          Universe::verify();
+          Universe::verify("Verify before initial mark: ");
         }
         {
           bool res = markFromRoots(false);
@@ -2522,8 +2555,7 @@
       case FinalMarking:
         if (VerifyDuringGC &&
             GenCollectedHeap::heap()->total_collections() >= VerifyGCStartAt) {
-          gclog_or_tty->print("Verify before re-mark: ");
-          Universe::verify();
+          Universe::verify("Verify before re-mark: ");
         }
         checkpointRootsFinal(false, clear_all_soft_refs,
                              init_mark_was_synchronous);
@@ -2534,8 +2566,7 @@
         // final marking in checkpointRootsFinal has been completed
         if (VerifyDuringGC &&
             GenCollectedHeap::heap()->total_collections() >= VerifyGCStartAt) {
-          gclog_or_tty->print("Verify before sweep: ");
-          Universe::verify();
+          Universe::verify("Verify before sweep: ");
         }
         sweep(false);
         assert(_collectorState == Resizing, "Incorrect state");
@@ -2550,8 +2581,7 @@
         // The heap has been resized.
         if (VerifyDuringGC &&
             GenCollectedHeap::heap()->total_collections() >= VerifyGCStartAt) {
-          gclog_or_tty->print("Verify before reset: ");
-          Universe::verify();
+          Universe::verify("Verify before reset: ");
         }
         save_heap_summary();
         reset(false);
@@ -2890,8 +2920,8 @@
   bool failed() { return _failed; }
 };
 
-bool CMSCollector::verify_after_remark() {
-  gclog_or_tty->print(" [Verifying CMS Marking... ");
+bool CMSCollector::verify_after_remark(bool silent) {
+  if (!silent) gclog_or_tty->print(" [Verifying CMS Marking... ");
   MutexLockerEx ml(verification_mark_bm()->lock(), Mutex::_no_safepoint_check_flag);
   static bool init = false;
 
@@ -2952,7 +2982,7 @@
     warning("Unrecognized value %d for CMSRemarkVerifyVariant",
             CMSRemarkVerifyVariant);
   }
-  gclog_or_tty->print(" done] ");
+  if (!silent) gclog_or_tty->print(" done] ");
   return true;
 }
 
@@ -3530,6 +3560,31 @@
 
 // CMS work
 
+// The common parts of CMSParInitialMarkTask and CMSParRemarkTask.
+class CMSParMarkTask : public AbstractGangTask {
+ protected:
+  CMSCollector*     _collector;
+  int               _n_workers;
+  CMSParMarkTask(const char* name, CMSCollector* collector, int n_workers) :
+      AbstractGangTask(name),
+      _collector(collector),
+      _n_workers(n_workers) {}
+  // Work method in support of parallel rescan ... of young gen spaces
+  void do_young_space_rescan(uint worker_id, OopsInGenClosure* cl,
+                             ContiguousSpace* space,
+                             HeapWord** chunk_array, size_t chunk_top);
+  void work_on_young_gen_roots(uint worker_id, OopsInGenClosure* cl);
+};
+
+// Parallel initial mark task
+class CMSParInitialMarkTask: public CMSParMarkTask {
+ public:
+  CMSParInitialMarkTask(CMSCollector* collector, int n_workers) :
+      CMSParMarkTask("Scan roots and young gen for initial mark in parallel",
+                     collector, n_workers) {}
+  void work(uint worker_id);
+};
+
 // Checkpoint the roots into this generation from outside
 // this generation. [Note this initial checkpoint need only
 // be approximate -- we'll do a catch up phase subsequently.]
@@ -3619,20 +3674,42 @@
   // weak reference processing has not started yet.
   ref_processor()->set_enqueuing_is_done(false);
 
+  if (CMSPrintEdenSurvivorChunks) {
+    print_eden_and_survivor_chunk_arrays();
+  }
+
   {
     // This is not needed. DEBUG_ONLY(RememberKlassesChecker imx(true);)
     COMPILER2_PRESENT(DerivedPointerTableDeactivate dpt_deact;)
-    gch->rem_set()->prepare_for_younger_refs_iterate(false); // Not parallel.
-    gch->gen_process_strong_roots(_cmsGen->level(),
-                                  true,   // younger gens are roots
-                                  true,   // activate StrongRootsScope
-                                  true,   // collecting perm gen
-                                  SharedHeap::ScanningOption(roots_scanning_options()),
-                                  &notOlder,
-                                  true,   // walk all of code cache if (so & SO_CodeCache)
-                                  NULL);
-  }
-
+    if (CMSParallelInitialMarkEnabled && CollectedHeap::use_parallel_gc_threads()) {
+      // The parallel version.
+      FlexibleWorkGang* workers = gch->workers();
+      assert(workers != NULL, "Need parallel worker threads.");
+      int n_workers = workers->active_workers();
+      CMSParInitialMarkTask tsk(this, n_workers);
+      gch->set_par_threads(n_workers);
+      initialize_sequential_subtasks_for_young_gen_rescan(n_workers);
+      if (n_workers > 1) {
+        GenCollectedHeap::StrongRootsScope srs(gch);
+        workers->run_task(&tsk);
+      } else {
+        GenCollectedHeap::StrongRootsScope srs(gch);
+        tsk.work(0);
+      }
+      gch->set_par_threads(0);
+    } else {
+      // The serial version.
+      gch->rem_set()->prepare_for_younger_refs_iterate(false); // Not parallel.
+      gch->gen_process_strong_roots(_cmsGen->level(),
+                                    true,   // younger gens are roots
+                                    true,   // activate StrongRootsScope
+                                    true,   // collecting perm gen
+                                    SharedHeap::ScanningOption(roots_scanning_options()),
+                                    &notOlder,
+                                    true,   // walk all of code cache if (so & SO_CodeCache)
+                                    NULL);
+    }
+  }
   // Clear mod-union table; it will be dirtied in the prologue of
   // CMS generation per each younger generation collection.
 
@@ -4414,7 +4491,9 @@
   verify_overflow_empty();
   _abort_preclean = false;
   if (CMSPrecleaningEnabled) {
-    _eden_chunk_index = 0;
+    if (!CMSEdenChunksRecordAlways) {
+      _eden_chunk_index = 0;
+    }
     size_t used = get_eden_used();
     size_t capacity = get_eden_capacity();
     // Don't start sampling unless we will get sufficiently
@@ -4523,7 +4602,9 @@
   if (!_start_sampling) {
     return;
   }
-  if (_eden_chunk_array) {
+  // When CMSEdenChunksRecordAlways is true, the eden chunk array
+  // is populated by the young generation.
+  if (_eden_chunk_array != NULL && !CMSEdenChunksRecordAlways) {
     if (_eden_chunk_index < _eden_chunk_capacity) {
       _eden_chunk_array[_eden_chunk_index] = *_top_addr;   // take sample
       assert(_eden_chunk_array[_eden_chunk_index] <= *_end_addr,
@@ -5000,6 +5081,10 @@
     // Update the saved marks which may affect the root scans.
     gch->save_marks();
 
+    if (CMSPrintEdenSurvivorChunks) {
+      print_eden_and_survivor_chunk_arrays();
+    }
+
     {
       COMPILER2_PRESENT(DerivedPointerTableDeactivate dpt_deact;)
 
@@ -5107,10 +5192,51 @@
   }
 }
 
+void CMSParInitialMarkTask::work(uint worker_id) {
+  elapsedTimer _timer;
+  ResourceMark rm;
+  HandleMark   hm;
+
+  // ---------- scan from roots --------------
+  _timer.start();
+  GenCollectedHeap* gch = GenCollectedHeap::heap();
+  Par_MarkRefsIntoClosure par_mri_cl(_collector->_span, &(_collector->_markBitMap));
+
+  // ---------- young gen roots --------------
+  {
+    work_on_young_gen_roots(worker_id, &par_mri_cl);
+    _timer.stop();
+    if (PrintCMSStatistics != 0) {
+      gclog_or_tty->print_cr(
+        "Finished young gen initial mark scan work in %dth thread: %3.3f sec",
+        worker_id, _timer.seconds());
+    }
+  }
+
+  // ---------- remaining roots --------------
+  _timer.reset();
+  _timer.start();
+  gch->gen_process_strong_roots(_collector->_cmsGen->level(),
+                                false,     // yg was scanned above
+                                false,     // this is parallel code
+                                true,      // collecting perm gen
+                                SharedHeap::ScanningOption(_collector->CMSCollector::roots_scanning_options()),
+                                &par_mri_cl,
+                                true,   // walk all of code cache if (so & SO_CodeCache)
+                                NULL);
+  assert(_collector->should_unload_classes()
+         || (_collector->CMSCollector::roots_scanning_options() & SharedHeap::SO_CodeCache),
+         "if we didn't scan the code cache, we have to be ready to drop nmethods with expired weak oops");
+  _timer.stop();
+  if (PrintCMSStatistics != 0) {
+    gclog_or_tty->print_cr(
+      "Finished remaining root initial mark scan work in %dth thread: %3.3f sec",
+      worker_id, _timer.seconds());
+  }
+}
+
 // Parallel remark task
-class CMSParRemarkTask: public AbstractGangTask {
-  CMSCollector* _collector;
-  int           _n_workers;
+class CMSParRemarkTask: public CMSParMarkTask {
   CompactibleFreeListSpace* _cms_space;
   CompactibleFreeListSpace* _perm_space;
 
@@ -5126,10 +5252,9 @@
                    CompactibleFreeListSpace* perm_space,
                    int n_workers, FlexibleWorkGang* workers,
                    OopTaskQueueSet* task_queues):
-    AbstractGangTask("Rescan roots and grey objects in parallel"),
-    _collector(collector),
+    CMSParMarkTask("Rescan roots and grey objects in parallel",
+                   collector, n_workers),
     _cms_space(cms_space), _perm_space(perm_space),
-    _n_workers(n_workers),
     _task_queues(task_queues),
     _term(n_workers, task_queues) { }
 
@@ -5143,11 +5268,6 @@
   void work(uint worker_id);
 
  private:
-  // Work method in support of parallel rescan ... of young gen spaces
-  void do_young_space_rescan(int i, Par_MarkRefsIntoAndScanClosure* cl,
-                             ContiguousSpace* space,
-                             HeapWord** chunk_array, size_t chunk_top);
-
   // ... of  dirty cards in old space
   void do_dirty_card_rescan_tasks(CompactibleFreeListSpace* sp, int i,
                                   Par_MarkRefsIntoAndScanClosure* cl);
@@ -5156,6 +5276,25 @@
   void do_work_steal(int i, Par_MarkRefsIntoAndScanClosure* cl, int* seed);
 };
 
+void CMSParMarkTask::work_on_young_gen_roots(uint worker_id, OopsInGenClosure* cl) {
+  DefNewGeneration* dng = _collector->_young_gen->as_DefNewGeneration();
+  EdenSpace* eden_space = dng->eden();
+  ContiguousSpace* from_space = dng->from();
+  ContiguousSpace* to_space   = dng->to();
+
+  HeapWord** eca = _collector->_eden_chunk_array;
+  size_t     ect = _collector->_eden_chunk_index;
+  HeapWord** sca = _collector->_survivor_chunk_array;
+  size_t     sct = _collector->_survivor_chunk_index;
+
+  assert(ect <= _collector->_eden_chunk_capacity, "out of bounds");
+  assert(sct <= _collector->_survivor_chunk_capacity, "out of bounds");
+
+  do_young_space_rescan(worker_id, cl, to_space, NULL, 0);
+  do_young_space_rescan(worker_id, cl, from_space, sca, sct);
+  do_young_space_rescan(worker_id, cl, eden_space, eca, ect);
+}
+
 // work_queue(i) is passed to the closure
 // Par_MarkRefsIntoAndScanClosure.  The "i" parameter
 // also is passed to do_dirty_card_rescan_tasks() and to
@@ -5180,23 +5319,7 @@
   // work first.
   // ---------- young gen roots --------------
   {
-    DefNewGeneration* dng = _collector->_young_gen->as_DefNewGeneration();
-    EdenSpace* eden_space = dng->eden();
-    ContiguousSpace* from_space = dng->from();
-    ContiguousSpace* to_space   = dng->to();
-
-    HeapWord** eca = _collector->_eden_chunk_array;
-    size_t     ect = _collector->_eden_chunk_index;
-    HeapWord** sca = _collector->_survivor_chunk_array;
-    size_t     sct = _collector->_survivor_chunk_index;
-
-    assert(ect <= _collector->_eden_chunk_capacity, "out of bounds");
-    assert(sct <= _collector->_survivor_chunk_capacity, "out of bounds");
-
-    do_young_space_rescan(worker_id, &par_mrias_cl, to_space, NULL, 0);
-    do_young_space_rescan(worker_id, &par_mrias_cl, from_space, sca, sct);
-    do_young_space_rescan(worker_id, &par_mrias_cl, eden_space, eca, ect);
-
+    work_on_young_gen_roots(worker_id, &par_mrias_cl);
     _timer.stop();
     if (PrintCMSStatistics != 0) {
       gclog_or_tty->print_cr(
@@ -5257,8 +5380,8 @@
 
 // Note that parameter "i" is not used.
 void
-CMSParRemarkTask::do_young_space_rescan(int i,
-  Par_MarkRefsIntoAndScanClosure* cl, ContiguousSpace* space,
+CMSParMarkTask::do_young_space_rescan(uint worker_id,
+  OopsInGenClosure* cl, ContiguousSpace* space,
   HeapWord** chunk_array, size_t chunk_top) {
   // Until all tasks completed:
   // . claim an unclaimed task
@@ -5454,6 +5577,32 @@
          "Else our work is not yet done");
 }
 
+// Record object boundaries in _eden_chunk_array by sampling the eden
+// top in the slow-path eden object allocation code path and record
+// the boundaries, if CMSEdenChunksRecordAlways is true. If
+// CMSEdenChunksRecordAlways is false, we use the other asynchronous
+// sampling in sample_eden() that activates during the part of the
+// preclean phase.
+void CMSCollector::sample_eden_chunk() {
+  if (CMSEdenChunksRecordAlways && _eden_chunk_array != NULL) {
+    if (_eden_chunk_lock->try_lock()) {
+      // Record a sample. This is the critical section. The contents
+      // of the _eden_chunk_array have to be non-decreasing in the
+      // address order.
+      _eden_chunk_array[_eden_chunk_index] = *_top_addr;
+      assert(_eden_chunk_array[_eden_chunk_index] <= *_end_addr,
+             "Unexpected state of Eden");
+      if (_eden_chunk_index == 0 ||
+          ((_eden_chunk_array[_eden_chunk_index] > _eden_chunk_array[_eden_chunk_index-1]) &&
+           (pointer_delta(_eden_chunk_array[_eden_chunk_index],
+                          _eden_chunk_array[_eden_chunk_index-1]) >= CMSSamplingGrain))) {
+        _eden_chunk_index++;  // commit sample
+      }
+      _eden_chunk_lock->unlock();
+    }
+  }
+}
+
 // Return a thread-local PLAB recording array, as appropriate.
 void* CMSCollector::get_data_recorder(int thr_num) {
   if (_survivor_plab_array != NULL &&
@@ -5477,12 +5626,13 @@
 
 // Merge the per-thread plab arrays into the global survivor chunk
 // array which will provide the partitioning of the survivor space
-// for CMS rescan.
+// for CMS initial scan and rescan.
 void CMSCollector::merge_survivor_plab_arrays(ContiguousSpace* surv,
                                               int no_of_gc_threads) {
   assert(_survivor_plab_array  != NULL, "Error");
   assert(_survivor_chunk_array != NULL, "Error");
-  assert(_collectorState == FinalMarking, "Error");
+  assert(_collectorState == FinalMarking ||
+         (CMSParallelInitialMarkEnabled && _collectorState == InitialMarking), "Error");
   for (int j = 0; j < no_of_gc_threads; j++) {
     _cursor[j] = 0;
   }
@@ -5545,7 +5695,7 @@
 }
 
 // Set up the space's par_seq_tasks structure for work claiming
-// for parallel rescan of young gen.
+// for parallel initial scan and rescan of young gen.
 // See ParRescanTask where this is currently used.
 void
 CMSCollector::
@@ -6695,6 +6845,28 @@
 void MarkRefsIntoClosure::do_oop(oop* p)       { MarkRefsIntoClosure::do_oop_work(p); }
 void MarkRefsIntoClosure::do_oop(narrowOop* p) { MarkRefsIntoClosure::do_oop_work(p); }
 
+Par_MarkRefsIntoClosure::Par_MarkRefsIntoClosure(
+  MemRegion span, CMSBitMap* bitMap):
+    _span(span),
+    _bitMap(bitMap)
+{
+    assert(_ref_processor == NULL, "deliberately left NULL");
+    assert(_bitMap->covers(_span), "_bitMap/_span mismatch");
+}
+
+void Par_MarkRefsIntoClosure::do_oop(oop obj) {
+  // if p points into _span, then mark corresponding bit in _markBitMap
+  assert(obj->is_oop(), "expected an oop");
+  HeapWord* addr = (HeapWord*)obj;
+  if (_span.contains(addr)) {
+    // this should be made more efficient
+    _bitMap->par_mark(addr);
+  }
+}
+
+void Par_MarkRefsIntoClosure::do_oop(oop* p)       { Par_MarkRefsIntoClosure::do_oop_work(p); }
+void Par_MarkRefsIntoClosure::do_oop(narrowOop* p) { Par_MarkRefsIntoClosure::do_oop_work(p); }
+
 // A variant of the above, used for CMS marking verification.
 MarkRefsIntoVerifyClosure::MarkRefsIntoVerifyClosure(
   MemRegion span, CMSBitMap* verification_bm, CMSBitMap* cms_bm):
@@ -9360,7 +9532,6 @@
     return;
   }
 }
-
 // Transfer some number of overflown objects to usual marking
 // stack. Return true if some objects were transferred.
 bool MarkRefsIntoAndScanClosure::take_from_overflow_list() {
@@ -9432,4 +9603,3 @@
       ShouldNotReachHere();
   }
 }
-
--- ./hotspot/src/share/vm/gc_implementation/concurrentMarkSweep/concurrentMarkSweepGeneration.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/gc_implementation/concurrentMarkSweep/concurrentMarkSweepGeneration.hpp	Wed May 07 19:26:16 2014 -0700
@@ -516,6 +516,8 @@
   friend class ConcurrentMarkSweepThread;
   friend class ConcurrentMarkSweepGeneration;
   friend class CompactibleFreeListSpace;
+  friend class CMSParMarkTask;
+  friend class CMSParInitialMarkTask;
   friend class CMSParRemarkTask;
   friend class CMSConcMarkingTask;
   friend class CMSRefProcTaskProxy;
@@ -752,6 +754,7 @@
   Generation* _young_gen;  // the younger gen
   HeapWord** _top_addr;    // ... Top of Eden
   HeapWord** _end_addr;    // ... End of Eden
+  Mutex*     _eden_chunk_lock;
   HeapWord** _eden_chunk_array; // ... Eden partitioning array
   size_t     _eden_chunk_index; // ... top (exclusive) of array
   size_t     _eden_chunk_capacity;  // ... max entries in array
@@ -953,6 +956,7 @@
 
   // Support for parallel remark of survivor space
   void* get_data_recorder(int thr_num);
+  void sample_eden_chunk();
 
   CMSBitMap* markBitMap()  { return &_markBitMap; }
   void directAllocated(HeapWord* start, size_t size);
@@ -1013,7 +1017,7 @@
 
   // debugging
   void verify();
-  bool verify_after_remark();
+  bool verify_after_remark(bool silent = VerifySilently);
   void verify_ok_to_terminate() const PRODUCT_RETURN;
   void verify_work_stacks_empty() const PRODUCT_RETURN;
   void verify_overflow_empty() const PRODUCT_RETURN;
@@ -1031,6 +1035,8 @@
 
   // Initialization errors
   bool completed_initialization() { return _completed_initialization; }
+
+  void print_eden_and_survivor_chunk_arrays();
 };
 
 class CMSExpansionCause : public AllStatic  {
@@ -1317,6 +1323,10 @@
     //Delegate to collector
     return collector()->get_data_recorder(thr_num);
   }
+  void sample_eden_chunk() {
+    //Delegate to collector
+    return collector()->sample_eden_chunk();
+  }
 
   // Printing
   const char* name() const;
--- ./hotspot/src/share/vm/gc_implementation/concurrentMarkSweep/vmCMSOperations.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/gc_implementation/concurrentMarkSweep/vmCMSOperations.cpp	Wed May 07 19:26:16 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -145,7 +145,7 @@
                                 );
 #endif /* USDT2 */
 
-  _collector->_gc_timer_cm->register_gc_pause_start("Initial Mark", os::elapsed_counter());
+  _collector->_gc_timer_cm->register_gc_pause_start("Initial Mark");
 
   GenCollectedHeap* gch = GenCollectedHeap::heap();
   GCCauseSetter gccs(gch, GCCause::_cms_initial_mark);
@@ -157,7 +157,7 @@
 
   VM_CMS_Operation::verify_after_gc();
 
-  _collector->_gc_timer_cm->register_gc_pause_end(os::elapsed_counter());
+  _collector->_gc_timer_cm->register_gc_pause_end();
 
 #ifndef USDT2
   HS_DTRACE_PROBE(hs_private, cms__initmark__end);
@@ -182,7 +182,7 @@
                                 );
 #endif /* USDT2 */
 
-  _collector->_gc_timer_cm->register_gc_pause_start("Final Mark", os::elapsed_counter());
+  _collector->_gc_timer_cm->register_gc_pause_start("Final Mark");
 
   GenCollectedHeap* gch = GenCollectedHeap::heap();
   GCCauseSetter gccs(gch, GCCause::_cms_final_remark);
@@ -195,7 +195,7 @@
   VM_CMS_Operation::verify_after_gc();
 
   _collector->save_heap_summary();
-  _collector->_gc_timer_cm->register_gc_pause_end(os::elapsed_counter());
+  _collector->_gc_timer_cm->register_gc_pause_end();
 
 #ifndef USDT2
   HS_DTRACE_PROBE(hs_private, cms__remark__end);
--- ./hotspot/src/share/vm/gc_implementation/g1/concurrentG1Refine.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/gc_implementation/g1/concurrentG1Refine.cpp	Wed May 07 19:26:16 2014 -0700
@@ -114,6 +114,14 @@
   }
 }
 
+void ConcurrentG1Refine::worker_threads_do(ThreadClosure * tc) {
+  if (_threads != NULL) {
+    for (int i = 0; i < worker_thread_num(); i++) {
+      tc->do_thread(_threads[i]);
+    }
+  }
+}
+
 int ConcurrentG1Refine::thread_num() {
   int n_threads = (G1ConcRefinementThreads > 0) ? G1ConcRefinementThreads
                                                 : ParallelGCThreads;
@@ -126,3 +134,7 @@
     st->cr();
   }
 }
+
+ConcurrentG1RefineThread * ConcurrentG1Refine::sampling_thread() const {
+  return _threads[worker_thread_num()];
+}
--- ./hotspot/src/share/vm/gc_implementation/g1/concurrentG1Refine.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/gc_implementation/g1/concurrentG1Refine.hpp	Wed May 07 19:26:16 2014 -0700
@@ -35,6 +35,7 @@
 class G1CollectedHeap;
 class G1HotCardCache;
 class G1RemSet;
+class DirtyCardQueue;
 
 class ConcurrentG1Refine: public CHeapObj<mtGC> {
   ConcurrentG1RefineThread** _threads;
@@ -78,9 +79,15 @@
 
   void reinitialize_threads();
 
-  // Iterate over the conc refine threads
+  // Iterate over all concurrent refinement threads
   void threads_do(ThreadClosure *tc);
 
+  // Iterate over all worker refinement threads
+  void worker_threads_do(ThreadClosure * tc);
+
+  // The RS sampling thread
+  ConcurrentG1RefineThread * sampling_thread() const;
+
   static int thread_num();
 
   void print_worker_threads_on(outputStream* st) const;
--- ./hotspot/src/share/vm/gc_implementation/g1/concurrentMark.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/gc_implementation/g1/concurrentMark.cpp	Wed May 07 19:26:16 2014 -0700
@@ -1154,10 +1154,9 @@
 
   if (VerifyDuringGC) {
     HandleMark hm;  // handle scope
-    gclog_or_tty->print(" VerifyDuringGC:(before)");
     Universe::heap()->prepare_for_verify();
-    Universe::verify(/* silent */ false,
-                     /* option */ VerifyOption_G1UsePrevMarking);
+    Universe::verify(VerifyOption_G1UsePrevMarking,
+                     " VerifyDuringGC:(before)");
   }
 
   G1CollectorPolicy* g1p = g1h->g1_policy();
@@ -1181,10 +1180,9 @@
     // Verify the heap w.r.t. the previous marking bitmap.
     if (VerifyDuringGC) {
       HandleMark hm;  // handle scope
-      gclog_or_tty->print(" VerifyDuringGC:(overflow)");
       Universe::heap()->prepare_for_verify();
-      Universe::verify(/* silent */ false,
-                       /* option */ VerifyOption_G1UsePrevMarking);
+      Universe::verify(VerifyOption_G1UsePrevMarking,
+                       " VerifyDuringGC:(overflow)");
     }
 
     // Clear the marking state because we will be restarting
@@ -1204,10 +1202,9 @@
 
     if (VerifyDuringGC) {
       HandleMark hm;  // handle scope
-      gclog_or_tty->print(" VerifyDuringGC:(after)");
       Universe::heap()->prepare_for_verify();
-      Universe::verify(/* silent */ false,
-                       /* option */ VerifyOption_G1UseNextMarking);
+      Universe::verify(VerifyOption_G1UseNextMarking,
+                       " VerifyDuringGC:(after)");
     }
     assert(!restart_for_overflow(), "sanity");
     // Completely reset the marking state since marking completed
@@ -1498,7 +1495,6 @@
   }
 };
 
-
 class G1ParVerifyFinalCountTask: public AbstractGangTask {
 protected:
   G1CollectedHeap* _g1h;
@@ -1856,10 +1852,9 @@
 
   if (VerifyDuringGC) {
     HandleMark hm;  // handle scope
-    gclog_or_tty->print(" VerifyDuringGC:(before)");
     Universe::heap()->prepare_for_verify();
-    Universe::verify(/* silent */ false,
-                     /* option */ VerifyOption_G1UsePrevMarking);
+    Universe::verify(VerifyOption_G1UsePrevMarking,
+                     " VerifyDuringGC:(before)");
   }
 
   G1CollectorPolicy* g1p = G1CollectedHeap::heap()->g1_policy();
@@ -2011,10 +2006,9 @@
 
   if (VerifyDuringGC) {
     HandleMark hm;  // handle scope
-    gclog_or_tty->print(" VerifyDuringGC:(after)");
     Universe::heap()->prepare_for_verify();
-    Universe::verify(/* silent */ false,
-                     /* option */ VerifyOption_G1UsePrevMarking);
+    Universe::verify(VerifyOption_G1UsePrevMarking,
+                     " VerifyDuringGC:(after)");
   }
 
   g1h->verify_region_sets_optional();
@@ -2412,10 +2406,9 @@
     assert(!rp->discovery_enabled(), "Post condition");
   }
 
-  // Now clean up stale oops in StringTable
-  StringTable::unlink(&g1_is_alive);
-  // Clean up unreferenced symbols in symbol table.
-  SymbolTable::unlink();
+  g1h->unlink_string_and_symbol_table(&g1_is_alive,
+                                      /* process_strings */ false, // currently strings are always roots
+                                      /* process_symbols */ true);
 }
 
 void ConcurrentMark::swapMarkBitMaps() {
@@ -4396,7 +4389,8 @@
     _total_used_bytes(0), _total_capacity_bytes(0),
     _total_prev_live_bytes(0), _total_next_live_bytes(0),
     _hum_used_bytes(0), _hum_capacity_bytes(0),
-    _hum_prev_live_bytes(0), _hum_next_live_bytes(0) {
+    _hum_prev_live_bytes(0), _hum_next_live_bytes(0),
+    _total_remset_bytes(0), _total_strong_code_roots_bytes(0) {
   G1CollectedHeap* g1h = G1CollectedHeap::heap();
   MemRegion g1_committed = g1h->g1_committed();
   MemRegion g1_reserved = g1h->g1_reserved();
@@ -4414,23 +4408,29 @@
                  HeapRegion::GrainBytes);
   _out->print_cr(G1PPRL_LINE_PREFIX);
   _out->print_cr(G1PPRL_LINE_PREFIX
-                 G1PPRL_TYPE_H_FORMAT
-                 G1PPRL_ADDR_BASE_H_FORMAT
-                 G1PPRL_BYTE_H_FORMAT
-                 G1PPRL_BYTE_H_FORMAT
-                 G1PPRL_BYTE_H_FORMAT
-                 G1PPRL_DOUBLE_H_FORMAT,
-                 "type", "address-range",
-                 "used", "prev-live", "next-live", "gc-eff");
+                G1PPRL_TYPE_H_FORMAT
+                G1PPRL_ADDR_BASE_H_FORMAT
+                G1PPRL_BYTE_H_FORMAT
+                G1PPRL_BYTE_H_FORMAT
+                G1PPRL_BYTE_H_FORMAT
+                G1PPRL_DOUBLE_H_FORMAT
+                G1PPRL_BYTE_H_FORMAT
+                G1PPRL_BYTE_H_FORMAT,
+                "type", "address-range",
+                "used", "prev-live", "next-live", "gc-eff",
+                "remset", "code-roots");
   _out->print_cr(G1PPRL_LINE_PREFIX
-                 G1PPRL_TYPE_H_FORMAT
-                 G1PPRL_ADDR_BASE_H_FORMAT
-                 G1PPRL_BYTE_H_FORMAT
-                 G1PPRL_BYTE_H_FORMAT
-                 G1PPRL_BYTE_H_FORMAT
-                 G1PPRL_DOUBLE_H_FORMAT,
-                 "", "",
-                 "(bytes)", "(bytes)", "(bytes)", "(bytes/ms)");
+                G1PPRL_TYPE_H_FORMAT
+                G1PPRL_ADDR_BASE_H_FORMAT
+                G1PPRL_BYTE_H_FORMAT
+                G1PPRL_BYTE_H_FORMAT
+                G1PPRL_BYTE_H_FORMAT
+                G1PPRL_DOUBLE_H_FORMAT
+                G1PPRL_BYTE_H_FORMAT
+                G1PPRL_BYTE_H_FORMAT,
+                "", "",
+                "(bytes)", "(bytes)", "(bytes)", "(bytes/ms)",
+                "(bytes)", "(bytes)");
 }
 
 // It takes as a parameter a reference to one of the _hum_* fields, it
@@ -4472,6 +4472,9 @@
   size_t prev_live_bytes = r->live_bytes();
   size_t next_live_bytes = r->next_live_bytes();
   double gc_eff          = r->gc_efficiency();
+  size_t remset_bytes    = r->rem_set()->mem_size();
+  size_t strong_code_roots_bytes = r->rem_set()->strong_code_roots_mem_size();
+
   if (r->used() == 0) {
     type = "FREE";
   } else if (r->is_survivor()) {
@@ -4505,6 +4508,8 @@
   _total_capacity_bytes  += capacity_bytes;
   _total_prev_live_bytes += prev_live_bytes;
   _total_next_live_bytes += next_live_bytes;
+  _total_remset_bytes    += remset_bytes;
+  _total_strong_code_roots_bytes += strong_code_roots_bytes;
 
   // Print a line for this particular region.
   _out->print_cr(G1PPRL_LINE_PREFIX
@@ -4513,14 +4518,19 @@
                  G1PPRL_BYTE_FORMAT
                  G1PPRL_BYTE_FORMAT
                  G1PPRL_BYTE_FORMAT
-                 G1PPRL_DOUBLE_FORMAT,
+                 G1PPRL_DOUBLE_FORMAT
+                 G1PPRL_BYTE_FORMAT
+                 G1PPRL_BYTE_FORMAT,
                  type, bottom, end,
-                 used_bytes, prev_live_bytes, next_live_bytes, gc_eff);
+                 used_bytes, prev_live_bytes, next_live_bytes, gc_eff,
+                 remset_bytes, strong_code_roots_bytes);
 
   return false;
 }
 
 G1PrintRegionLivenessInfoClosure::~G1PrintRegionLivenessInfoClosure() {
+  // add static memory usages to remembered set sizes
+  _total_remset_bytes += HeapRegionRemSet::fl_mem_size() + HeapRegionRemSet::static_mem_size();
   // Print the footer of the output.
   _out->print_cr(G1PPRL_LINE_PREFIX);
   _out->print_cr(G1PPRL_LINE_PREFIX
@@ -4528,13 +4538,17 @@
                  G1PPRL_SUM_MB_FORMAT("capacity")
                  G1PPRL_SUM_MB_PERC_FORMAT("used")
                  G1PPRL_SUM_MB_PERC_FORMAT("prev-live")
-                 G1PPRL_SUM_MB_PERC_FORMAT("next-live"),
+                 G1PPRL_SUM_MB_PERC_FORMAT("next-live")
+                 G1PPRL_SUM_MB_FORMAT("remset")
+                 G1PPRL_SUM_MB_FORMAT("code-roots"),
                  bytes_to_mb(_total_capacity_bytes),
                  bytes_to_mb(_total_used_bytes),
                  perc(_total_used_bytes, _total_capacity_bytes),
                  bytes_to_mb(_total_prev_live_bytes),
                  perc(_total_prev_live_bytes, _total_capacity_bytes),
                  bytes_to_mb(_total_next_live_bytes),
-                 perc(_total_next_live_bytes, _total_capacity_bytes));
+                 perc(_total_next_live_bytes, _total_capacity_bytes),
+                 bytes_to_mb(_total_remset_bytes),
+                 bytes_to_mb(_total_strong_code_roots_bytes));
   _out->cr();
 }
--- ./hotspot/src/share/vm/gc_implementation/g1/concurrentMark.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/gc_implementation/g1/concurrentMark.hpp	Wed May 07 19:26:16 2014 -0700
@@ -1224,6 +1224,12 @@
   size_t _hum_prev_live_bytes;
   size_t _hum_next_live_bytes;
 
+  // Accumulator for the remembered set size
+  size_t _total_remset_bytes;
+
+  // Accumulator for strong code roots memory size
+  size_t _total_strong_code_roots_bytes;
+
   static double perc(size_t val, size_t total) {
     if (total == 0) {
       return 0.0;
--- ./hotspot/src/share/vm/gc_implementation/g1/concurrentMark.inline.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/gc_implementation/g1/concurrentMark.inline.hpp	Wed May 07 19:26:16 2014 -0700
@@ -81,7 +81,7 @@
                                          size_t* marked_bytes_array,
                                          BitMap* task_card_bm) {
   G1CollectedHeap* g1h = _g1h;
-  CardTableModRefBS* ct_bs = (CardTableModRefBS*) (g1h->barrier_set());
+  CardTableModRefBS* ct_bs = g1h->g1_barrier_set();
 
   HeapWord* start = mr.start();
   HeapWord* end = mr.end();
--- ./hotspot/src/share/vm/gc_implementation/g1/g1CardCounts.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/gc_implementation/g1/g1CardCounts.cpp	Wed May 07 19:26:16 2014 -0700
@@ -65,9 +65,7 @@
     // threshold limit is no more than this.
     guarantee(G1ConcRSHotCardLimit <= max_jubyte, "sanity");
 
-    ModRefBarrierSet* bs = _g1h->mr_bs();
-    guarantee(bs->is_a(BarrierSet::CardTableModRef), "Precondition");
-    _ct_bs = (CardTableModRefBS*)bs;
+    _ct_bs = _g1h->g1_barrier_set();
     _ct_bot = _ct_bs->byte_for_const(_g1h->reserved_region().start());
 
     // Allocate/Reserve the counts table
--- ./hotspot/src/share/vm/gc_implementation/g1/g1CollectedHeap.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/gc_implementation/g1/g1CollectedHeap.cpp	Wed May 07 19:26:16 2014 -0700
@@ -23,6 +23,7 @@
  */
 
 #include "precompiled.hpp"
+#include "code/codeCache.hpp"
 #include "code/icBuffer.hpp"
 #include "gc_implementation/g1/bufferingOopClosure.hpp"
 #include "gc_implementation/g1/concurrentG1Refine.hpp"
@@ -56,6 +57,7 @@
 #include "oops/oop.pcgc.inline.hpp"
 #include "runtime/aprofiler.hpp"
 #include "runtime/vmThread.hpp"
+#include "utilities/ticks.hpp"
 
 size_t G1CollectedHeap::_humongous_object_threshold_in_words = 0;
 
@@ -125,10 +127,8 @@
   int _histo[256];
 public:
   ClearLoggedCardTableEntryClosure() :
-    _calls(0)
+    _calls(0), _g1h(G1CollectedHeap::heap()), _ctbs(_g1h->g1_barrier_set())
   {
-    _g1h = G1CollectedHeap::heap();
-    _ctbs = (CardTableModRefBS*)_g1h->barrier_set();
     for (int i = 0; i < 256; i++) _histo[i] = 0;
   }
   bool do_card_ptr(jbyte* card_ptr, int worker_i) {
@@ -158,11 +158,8 @@
   CardTableModRefBS* _ctbs;
 public:
   RedirtyLoggedCardTableEntryClosure() :
-    _calls(0)
-  {
-    _g1h = G1CollectedHeap::heap();
-    _ctbs = (CardTableModRefBS*)_g1h->barrier_set();
-  }
+    _calls(0), _g1h(G1CollectedHeap::heap()), _ctbs(_g1h->g1_barrier_set()) {}
+
   bool do_card_ptr(jbyte* card_ptr, int worker_i) {
     if (_g1h->is_in_reserved(_ctbs->addr_for(card_ptr))) {
       _calls++;
@@ -477,7 +474,7 @@
 
 void G1CollectedHeap::check_ct_logs_at_safepoint() {
   DirtyCardQueueSet& dcqs = JavaThread::dirty_card_queue_set();
-  CardTableModRefBS* ct_bs = (CardTableModRefBS*)barrier_set();
+  CardTableModRefBS* ct_bs = g1_barrier_set();
 
   // Count the dirty cards at the start.
   CountNonCleanMemRegionClosure count1(this);
@@ -1158,26 +1155,33 @@
   ModRefBarrierSet* _mr_bs;
 public:
   PostMCRemSetClearClosure(G1CollectedHeap* g1h, ModRefBarrierSet* mr_bs) :
-    _g1h(g1h), _mr_bs(mr_bs) { }
+    _g1h(g1h), _mr_bs(mr_bs) {}
+
   bool doHeapRegion(HeapRegion* r) {
+    HeapRegionRemSet* hrrs = r->rem_set();
+
     if (r->continuesHumongous()) {
+      // We'll assert that the strong code root list and RSet is empty
+      assert(hrrs->strong_code_roots_list_length() == 0, "sanity");
+      assert(hrrs->occupied() == 0, "RSet should be empty");
       return false;
     }
+
     _g1h->reset_gc_time_stamps(r);
-    HeapRegionRemSet* hrrs = r->rem_set();
-    if (hrrs != NULL) hrrs->clear();
+    hrrs->clear();
     // You might think here that we could clear just the cards
     // corresponding to the used region.  But no: if we leave a dirty card
     // in a region we might allocate into, then it would prevent that card
     // from being enqueued, and cause it to be missed.
     // Re: the performance cost: we shouldn't be doing full GC anyway!
     _mr_bs->clear(MemRegion(r->bottom(), r->end()));
+
     return false;
   }
 };
 
 void G1CollectedHeap::clear_rsets_post_compaction() {
-  PostMCRemSetClearClosure rs_clear(this, mr_bs());
+  PostMCRemSetClearClosure rs_clear(this, g1_barrier_set());
   heap_region_iterate(&rs_clear);
 }
 
@@ -1251,31 +1255,6 @@
   heap_region_iterate(&cl);
 }
 
-double G1CollectedHeap::verify(bool guard, const char* msg) {
-  double verify_time_ms = 0.0;
-
-  if (guard && total_collections() >= VerifyGCStartAt) {
-    double verify_start = os::elapsedTime();
-    HandleMark hm;  // Discard invalid handles created during verification
-    gclog_or_tty->print(msg);
-    prepare_for_verify();
-    Universe::verify(false /* silent */, VerifyOption_G1UsePrevMarking);
-    verify_time_ms = (os::elapsedTime() - verify_start) * 1000;
-  }
-
-  return verify_time_ms;
-}
-
-void G1CollectedHeap::verify_before_gc() {
-  double verify_time_ms = verify(VerifyBeforeGC, " VerifyBeforeGC:");
-  g1_policy()->phase_times()->record_verify_before_time_ms(verify_time_ms);
-}
-
-void G1CollectedHeap::verify_after_gc() {
-  double verify_time_ms = verify(VerifyAfterGC, " VerifyAfterGC:");
-  g1_policy()->phase_times()->record_verify_after_time_ms(verify_time_ms);
-}
-
 bool G1CollectedHeap::do_collection(bool explicit_gc,
                                     bool clear_all_soft_refs,
                                     size_t word_size) {
@@ -1286,7 +1265,7 @@
   }
 
   STWGCTimer* gc_timer = G1MarkSweep::gc_timer();
-  gc_timer->register_gc_start(os::elapsed_counter());
+  gc_timer->register_gc_start();
 
   SerialOldTracer* gc_tracer = G1MarkSweep::gc_tracer();
   gc_tracer->report_gc_start(gc_cause(), gc_timer->gc_start());
@@ -1408,8 +1387,6 @@
 
       MemoryService::track_memory_usage();
 
-      verify_after_gc();
-
       assert(!ref_processor_stw()->discovery_enabled(), "Postcondition");
       ref_processor_stw()->verify_no_references_recorded();
 
@@ -1482,6 +1459,9 @@
         heap_region_iterate(&rebuild_rs);
       }
 
+      // Rebuild the strong code root lists for each region
+      rebuild_strong_code_roots();
+
       if (true) { // FIXME
         // Ask the permanent generation to adjust size for full collections
         perm()->compute_new_size();
@@ -1509,6 +1489,8 @@
       _hrs.verify_optional();
       verify_region_sets_optional();
 
+      verify_after_gc();
+
       // Start a new incremental collection set for the next pause
       assert(g1_policy()->collection_set() == NULL, "must be");
       g1_policy()->start_incremental_cset_building();
@@ -1546,8 +1528,7 @@
     post_full_gc_dump(gc_timer);
   }
 
-  gc_timer->register_gc_end(os::elapsed_counter());
-
+  gc_timer->register_gc_end();
   gc_tracer->report_gc_end(gc_timer->gc_end(), gc_timer->time_partitions());
 
   return true;
@@ -1568,8 +1549,6 @@
 void
 G1CollectedHeap::
 resize_if_necessary_after_full_collection(size_t word_size) {
-  assert(MinHeapFreeRatio <= MaxHeapFreeRatio, "sanity check");
-
   // Include the current allocation, if any, and bytes that will be
   // pre-allocated to support collections, as "used".
   const size_t used_after_gc = used();
@@ -2002,10 +1981,12 @@
 
   size_t init_byte_size = collector_policy()->initial_heap_byte_size();
   size_t max_byte_size = collector_policy()->max_heap_byte_size();
+  size_t heap_alignment = collector_policy()->max_alignment();
 
   // Ensure that the sizes are properly aligned.
   Universe::check_alignment(init_byte_size, HeapRegion::GrainBytes, "g1 heap");
   Universe::check_alignment(max_byte_size, HeapRegion::GrainBytes, "g1 heap");
+  Universe::check_alignment(max_byte_size, heap_alignment, "g1 heap");
 
   _cg1r = new ConcurrentG1Refine(this);
 
@@ -2029,14 +2010,14 @@
   size_t total_reserved = 0;
 
   total_reserved = add_and_check_overflow(total_reserved, max_byte_size);
-  size_t pg_max_size = (size_t) align_size_up(pgs->max_size(), HeapRegion::GrainBytes);
+  size_t pg_max_size = (size_t) align_size_up(pgs->max_size(), heap_alignment);
   total_reserved = add_and_check_overflow(total_reserved, pg_max_size);
 
   Universe::check_alignment(total_reserved, HeapRegion::GrainBytes, "g1 heap and perm");
 
-  char* addr = Universe::preferred_heap_base(total_reserved, Universe::UnscaledNarrowOop);
-
-  ReservedHeapSpace heap_rs(total_reserved, HeapRegion::GrainBytes,
+  char* addr = Universe::preferred_heap_base(total_reserved, heap_alignment, Universe::UnscaledNarrowOop);
+
+  ReservedHeapSpace heap_rs(total_reserved, heap_alignment,
                             UseLargePages, addr);
 
   if (UseCompressedOops) {
@@ -2044,17 +2025,17 @@
       // Failed to reserve at specified address - the requested memory
       // region is taken already, for example, by 'java' launcher.
       // Try again to reserver heap higher.
-      addr = Universe::preferred_heap_base(total_reserved, Universe::ZeroBasedNarrowOop);
-
-      ReservedHeapSpace heap_rs0(total_reserved, HeapRegion::GrainBytes,
+      addr = Universe::preferred_heap_base(total_reserved, heap_alignment, Universe::ZeroBasedNarrowOop);
+
+      ReservedHeapSpace heap_rs0(total_reserved, heap_alignment,
                                  UseLargePages, addr);
 
       if (addr != NULL && !heap_rs0.is_reserved()) {
         // Failed to reserve at specified address again - give up.
-        addr = Universe::preferred_heap_base(total_reserved, Universe::HeapBasedNarrowOop);
+        addr = Universe::preferred_heap_base(total_reserved, heap_alignment, Universe::HeapBasedNarrowOop);
         assert(addr == NULL, "");
 
-        ReservedHeapSpace heap_rs1(total_reserved, HeapRegion::GrainBytes,
+        ReservedHeapSpace heap_rs1(total_reserved, heap_alignment,
                                    UseLargePages, addr);
         heap_rs = heap_rs1;
       } else {
@@ -2080,20 +2061,13 @@
   // Create the gen rem set (and barrier set) for the entire reserved region.
   _rem_set = collector_policy()->create_rem_set(_reserved, 2);
   set_barrier_set(rem_set()->bs());
-  if (barrier_set()->is_a(BarrierSet::ModRef)) {
-    _mr_bs = (ModRefBarrierSet*)_barrier_set;
-  } else {
-    vm_exit_during_initialization("G1 requires a mod ref bs.");
+  if (!barrier_set()->is_a(BarrierSet::G1SATBCTLogging)) {
+    vm_exit_during_initialization("G1 requires a G1SATBLoggingCardTableModRefBS");
     return JNI_ENOMEM;
   }
 
   // Also create a G1 rem set.
-  if (mr_bs()->is_a(BarrierSet::CardTableModRef)) {
-    _g1_rem_set = new G1RemSet(this, (CardTableModRefBS*)mr_bs());
-  } else {
-    vm_exit_during_initialization("G1 requires a cardtable mod ref bs.");
-    return JNI_ENOMEM;
-  }
+  _g1_rem_set = new G1RemSet(this, g1_barrier_set());
 
   // Carve out the G1 part of the heap.
 
@@ -2517,7 +2491,7 @@
   FullGCCount_lock->notify_all();
 }
 
-void G1CollectedHeap::register_concurrent_cycle_start(jlong start_time) {
+void G1CollectedHeap::register_concurrent_cycle_start(const Ticks& start_time) {
   _concurrent_cycle_started = true;
   _gc_timer_cm->register_gc_start(start_time);
 
@@ -2527,7 +2501,7 @@
 
 void G1CollectedHeap::register_concurrent_cycle_end() {
   if (_concurrent_cycle_started) {
-    _gc_timer_cm->register_gc_end(os::elapsed_counter());
+    _gc_timer_cm->register_gc_end();
 
     if (_cm->has_aborted()) {
       _gc_tracer_cm->report_concurrent_mode_failure();
@@ -3161,6 +3135,119 @@
   return NULL; // keep some compilers happy
 }
 
+// TODO: VerifyRootsClosure extends OopsInGenClosure so that we can
+//       pass it as the perm_blk to SharedHeap::process_strong_roots.
+//       When process_strong_roots stop calling perm_blk->younger_refs_iterate
+//       we can change this closure to extend the simpler OopClosure.
+class VerifyRootsClosure: public OopsInGenClosure {
+private:
+  G1CollectedHeap* _g1h;
+  VerifyOption     _vo;
+  bool             _failures;
+public:
+  // _vo == UsePrevMarking -> use "prev" marking information,
+  // _vo == UseNextMarking -> use "next" marking information,
+  // _vo == UseMarkWord    -> use mark word from object header.
+  VerifyRootsClosure(VerifyOption vo) :
+    _g1h(G1CollectedHeap::heap()),
+    _vo(vo),
+    _failures(false) { }
+
+  bool failures() { return _failures; }
+
+  template <class T> void do_oop_nv(T* p) {
+    T heap_oop = oopDesc::load_heap_oop(p);
+    if (!oopDesc::is_null(heap_oop)) {
+      oop obj = oopDesc::decode_heap_oop_not_null(heap_oop);
+      if (_g1h->is_obj_dead_cond(obj, _vo)) {
+        gclog_or_tty->print_cr("Root location "PTR_FORMAT" "
+                              "points to dead obj "PTR_FORMAT, p, (void*) obj);
+        if (_vo == VerifyOption_G1UseMarkWord) {
+          gclog_or_tty->print_cr("  Mark word: "PTR_FORMAT, (void*)(obj->mark()));
+        }
+        obj->print_on(gclog_or_tty);
+        _failures = true;
+      }
+    }
+  }
+
+  void do_oop(oop* p)       { do_oop_nv(p); }
+  void do_oop(narrowOop* p) { do_oop_nv(p); }
+};
+
+class G1VerifyCodeRootOopClosure: public OopsInGenClosure {
+  G1CollectedHeap* _g1h;
+  OopClosure* _root_cl;
+  nmethod* _nm;
+  VerifyOption _vo;
+  bool _failures;
+
+  template <class T> void do_oop_work(T* p) {
+    // First verify that this root is live
+    _root_cl->do_oop(p);
+
+    if (!G1VerifyHeapRegionCodeRoots) {
+      // We're not verifying the code roots attached to heap region.
+      return;
+    }
+
+    // Don't check the code roots during marking verification in a full GC
+    if (_vo == VerifyOption_G1UseMarkWord) {
+      return;
+    }
+
+    // Now verify that the current nmethod (which contains p) is
+    // in the code root list of the heap region containing the
+    // object referenced by p.
+
+    T heap_oop = oopDesc::load_heap_oop(p);
+    if (!oopDesc::is_null(heap_oop)) {
+      oop obj = oopDesc::decode_heap_oop_not_null(heap_oop);
+
+      if (_g1h->is_in_g1_reserved(obj)) {
+        // Now fetch the region containing the object
+        HeapRegion* hr = _g1h->heap_region_containing(obj);
+        HeapRegionRemSet* hrrs = hr->rem_set();
+        // Verify that the strong code root list for this region
+        // contains the nmethod
+        if (!hrrs->strong_code_roots_list_contains(_nm)) {
+          gclog_or_tty->print_cr("Code root location "PTR_FORMAT" "
+                                "from nmethod "PTR_FORMAT" not in strong "
+                                "code roots for region ["PTR_FORMAT","PTR_FORMAT")",
+                                p, _nm, hr->bottom(), hr->end());
+          _failures = true;
+        }
+      }
+    }
+  }
+
+public:
+  G1VerifyCodeRootOopClosure(G1CollectedHeap* g1h, OopClosure* root_cl, VerifyOption vo):
+    _g1h(g1h), _root_cl(root_cl), _vo(vo), _nm(NULL), _failures(false) {}
+
+  void do_oop(oop* p) { do_oop_work(p); }
+  void do_oop(narrowOop* p) { do_oop_work(p); }
+
+  void set_nmethod(nmethod* nm) { _nm = nm; }
+  bool failures() { return _failures; }
+};
+
+class G1VerifyCodeRootBlobClosure: public CodeBlobClosure {
+  G1VerifyCodeRootOopClosure* _oop_cl;
+
+public:
+  G1VerifyCodeRootBlobClosure(G1VerifyCodeRootOopClosure* oop_cl):
+    _oop_cl(oop_cl) {}
+
+  void do_code_blob(CodeBlob* cb) {
+    nmethod* nm = cb->as_nmethod_or_null();
+    if (nm != NULL) {
+      _oop_cl->set_nmethod(nm);
+      nm->oops_do(_oop_cl);
+    }
+  }
+};
+
 class VerifyLivenessOopClosure: public OopClosure {
   G1CollectedHeap* _g1h;
   VerifyOption _vo;
@@ -3294,42 +3381,6 @@
   }
 };
 
-class VerifyRootsClosure: public OopsInGenClosure {
-private:
-  G1CollectedHeap* _g1h;
-  VerifyOption     _vo;
-  bool             _failures;
-public:
-  // _vo == UsePrevMarking -> use "prev" marking information,
-  // _vo == UseNextMarking -> use "next" marking information,
-  // _vo == UseMarkWord    -> use mark word from object header.
-  VerifyRootsClosure(VerifyOption vo) :
-    _g1h(G1CollectedHeap::heap()),
-    _vo(vo),
-    _failures(false) { }
-
-  bool failures() { return _failures; }
-
-  template <class T> void do_oop_nv(T* p) {
-    T heap_oop = oopDesc::load_heap_oop(p);
-    if (!oopDesc::is_null(heap_oop)) {
-      oop obj = oopDesc::decode_heap_oop_not_null(heap_oop);
-      if (_g1h->is_obj_dead_cond(obj, _vo)) {
-        gclog_or_tty->print_cr("Root location "PTR_FORMAT" "
-                              "points to dead obj "PTR_FORMAT, p, (void*) obj);
-        if (_vo == VerifyOption_G1UseMarkWord) {
-          gclog_or_tty->print_cr("  Mark word: "PTR_FORMAT, (void*)(obj->mark()));
-        }
-        obj->print_on(gclog_or_tty);
-        _failures = true;
-      }
-    }
-  }
-
-  void do_oop(oop* p)       { do_oop_nv(p); }
-  void do_oop(narrowOop* p) { do_oop_nv(p); }
-};
-
 // This is the task used for parallel heap verification.
 
 class G1ParVerifyTask: public AbstractGangTask {
@@ -3364,21 +3415,16 @@
   }
 };
 
-void G1CollectedHeap::verify(bool silent) {
-  verify(silent, VerifyOption_G1UsePrevMarking);
-}
-
-void G1CollectedHeap::verify(bool silent,
-                             VerifyOption vo) {
+void G1CollectedHeap::verify(bool silent, VerifyOption vo) {
   if (SafepointSynchronize::is_at_safepoint()) {
+    assert(Thread::current()->is_VM_thread(),
+           "Expected to be executed serially by the VM thread at this point");
+
     if (!silent) { gclog_or_tty->print("Roots (excluding permgen) "); }
     VerifyRootsClosure rootsCl(vo);
 
-    assert(Thread::current()->is_VM_thread(),
-           "Expected to be executed serially by the VM thread at this point");
-
-    CodeBlobToOopClosure blobsCl(&rootsCl, /*do_marking=*/ false);
-
+    G1VerifyCodeRootOopClosure codeRootsCl(this, &rootsCl, vo);
+    G1VerifyCodeRootBlobClosure blobsCl(&codeRootsCl);
     // We apply the relevant closures to all the oops in the
     // system dictionary, the string table and the code cache.
     const int so = SO_AllClasses | SO_Strings | SO_CodeCache;
@@ -3473,6 +3519,34 @@
   }
 }
 
+void G1CollectedHeap::verify(bool silent) {
+  verify(silent, VerifyOption_G1UsePrevMarking);
+}
+
+double G1CollectedHeap::verify(bool guard, const char* msg) {
+  double verify_time_ms = 0.0;
+
+  if (guard && total_collections() >= VerifyGCStartAt) {
+    double verify_start = os::elapsedTime();
+    HandleMark hm;  // Discard invalid handles created during verification
+    prepare_for_verify();
+    Universe::verify(VerifyOption_G1UsePrevMarking, msg);
+    verify_time_ms = (os::elapsedTime() - verify_start) * 1000;
+  }
+
+  return verify_time_ms;
+}
+
+void G1CollectedHeap::verify_before_gc() {
+  double verify_time_ms = verify(VerifyBeforeGC, " VerifyBeforeGC:");
+  g1_policy()->phase_times()->record_verify_before_time_ms(verify_time_ms);
+}
+
+void G1CollectedHeap::verify_after_gc() {
+  double verify_time_ms = verify(VerifyAfterGC, " VerifyAfterGC:");
+  g1_policy()->phase_times()->record_verify_after_time_ms(verify_time_ms);
+}
+
 class PrintRegionClosure: public HeapRegionClosure {
   outputStream* _st;
 public:
@@ -3616,9 +3690,22 @@
   AllocationProfiler::iterate_since_last_gc();
   // Fill TLAB's and such
   ensure_parsability(true);
+
+  if (G1SummarizeRSetStats && (G1SummarizeRSetStatsPeriod > 0) &&
+      (total_collections() % G1SummarizeRSetStatsPeriod == 0)) {
+    g1_rem_set()->print_periodic_summary_info("Before GC RS summary");
+  }
 }
 
 void G1CollectedHeap::gc_epilogue(bool full /* Ignored */) {
+
+  if (G1SummarizeRSetStats &&
+      (G1SummarizeRSetStatsPeriod > 0) &&
+      // we are at the end of the GC. Total collections has already been increased.
+      ((total_collections() - 1) % G1SummarizeRSetStatsPeriod == 0)) {
+    g1_rem_set()->print_periodic_summary_info("After GC RS summary");
+  }
+
   // FIXME: what is this about?
   // I'm ignoring the "fill_newgen()" call if "alloc_event_enabled"
   // is set.
@@ -3815,7 +3902,7 @@
     return false;
   }
 
-  _gc_timer_stw->register_gc_start(os::elapsed_counter());
+  _gc_timer_stw->register_gc_start();
 
   _gc_tracer_stw->report_gc_start(gc_cause(), _gc_timer_stw->gc_start());
 
@@ -3880,8 +3967,9 @@
       append_secondary_free_list_if_not_empty_with_lock();
     }
 
-    assert(check_young_list_well_formed(),
-      "young list should be well formed");
+    assert(check_young_list_well_formed(), "young list should be well formed");
+    assert(check_heap_region_claim_values(HeapRegion::InitialClaimValue),
+           "sanity check");
 
     // Don't dynamically change the number of GC threads this early.  A value of
     // 0 is used to indicate serial work.  When parallel work is done,
@@ -4193,15 +4281,10 @@
 
     _gc_tracer_stw->report_evacuation_info(&evacuation_info);
     _gc_tracer_stw->report_tenuring_threshold(_g1_policy->tenuring_threshold());
-    _gc_timer_stw->register_gc_end(os::elapsed_counter());
+    _gc_timer_stw->register_gc_end();
     _gc_tracer_stw->report_gc_end(_gc_timer_stw->gc_end(), _gc_timer_stw->time_partitions());
   }
 
-  if (G1SummarizeRSetStats &&
-      (G1SummarizeRSetStatsPeriod > 0) &&
-      (total_collections() % G1SummarizeRSetStatsPeriod == 0)) {
-    g1_rem_set()->print_summary_info();
-  }
   // It should now be safe to tell the concurrent mark thread to start
   // without its logging output interfering with the logging output
   // that came from the pause.
@@ -4482,7 +4565,7 @@
   : _g1h(g1h),
     _refs(g1h->task_queue(queue_num)),
     _dcq(&g1h->dirty_card_queue_set()),
-    _ct_bs((CardTableModRefBS*)_g1h->barrier_set()),
+    _ct_bs(g1h->g1_barrier_set()),
     _g1_rem(g1h->g1_rem_set()),
     _hash_seed(17), _queue_num(queue_num),
     _term_attempts(0),
@@ -4975,7 +5058,8 @@
                                     scan_root_cl,
                                     &push_heap_rs_cl,
                                     scan_perm_cl,
-                                    worker_id);
+                                    worker_id,
+                                    /* manages_code_roots */ true);
       pss.end_strong_roots();
 
       {
@@ -5009,67 +5093,6 @@
 
 // *** Common G1 Evacuation Stuff
 
-// Closures that support the filtering of CodeBlobs scanned during
-// external root scanning.
-
-// Closure applied to reference fields in code blobs (specifically nmethods)
-// to determine whether an nmethod contains references that point into
-// the collection set. Used as a predicate when walking code roots so
-// that only nmethods that point into the collection set are added to the
-// 'marked' list.
-
-class G1FilteredCodeBlobToOopClosure : public CodeBlobToOopClosure {
-
-  class G1PointsIntoCSOopClosure : public OopClosure {
-    G1CollectedHeap* _g1;
-    bool _points_into_cs;
-  public:
-    G1PointsIntoCSOopClosure(G1CollectedHeap* g1) :
-      _g1(g1), _points_into_cs(false) { }
-
-    bool points_into_cs() const { return _points_into_cs; }
-
-    template <class T>
-    void do_oop_nv(T* p) {
-      if (!_points_into_cs) {
-        T heap_oop = oopDesc::load_heap_oop(p);
-        if (!oopDesc::is_null(heap_oop) &&
-            _g1->in_cset_fast_test(oopDesc::decode_heap_oop_not_null(heap_oop))) {
-          _points_into_cs = true;
-        }
-      }
-    }
-
-    virtual void do_oop(oop* p)        { do_oop_nv(p); }
-    virtual void do_oop(narrowOop* p)  { do_oop_nv(p); }
-  };
-
-  G1CollectedHeap* _g1;
-
-public:
-  G1FilteredCodeBlobToOopClosure(G1CollectedHeap* g1, OopClosure* cl) :
-    CodeBlobToOopClosure(cl, true), _g1(g1) { }
-
-  virtual void do_code_blob(CodeBlob* cb) {
-    nmethod* nm = cb->as_nmethod_or_null();
-    if (nm != NULL && !(nm->test_oops_do_mark())) {
-      G1PointsIntoCSOopClosure predicate_cl(_g1);
-      nm->oops_do(&predicate_cl);
-
-      if (predicate_cl.points_into_cs()) {
-        // At least one of the reference fields or the oop relocations
-        // in the nmethod points into the collection set. We have to
-        // 'mark' this nmethod.
-        // Note: Revisit the following if CodeBlobToOopClosure::do_code_blob()
-        // or MarkingCodeBlobClosure::do_code_blob() change.
-        if (!nm->test_set_oops_do_mark()) {
-          do_newly_marked_nmethod(nm);
-        }
-      }
-    }
-  }
-};
-
 // This method is run in a GC worker.
 
 void
@@ -5079,7 +5102,8 @@
                         OopClosure* scan_non_heap_roots,
                         OopsInHeapRegionClosure* scan_rs,
                         OopsInGenClosure* scan_perm,
-                        int worker_i) {
+                        int worker_i,
+                        bool manages_code_roots) {
 
   // First scan the strong roots, including the perm gen.
   double ext_roots_start = os::elapsedTime();
@@ -5089,15 +5113,17 @@
   BufferingOopsInGenClosure buf_scan_perm(scan_perm);
   buf_scan_perm.set_generation(perm_gen());
 
-  // Walk the code cache w/o buffering, because StarTask cannot handle
-  // unaligned oop locations.
-  G1FilteredCodeBlobToOopClosure eager_scan_code_roots(this, scan_non_heap_roots);
+  assert(so & SO_CodeCache || scan_rs != NULL, "must scan code roots somehow");
+  // Walk the code cache/strong code roots w/o buffering, because StarTask
+  // cannot handle unaligned oop locations.
+  CodeBlobToOopClosure eager_scan_code_roots(scan_non_heap_roots, true /* do_marking */);
 
   process_strong_roots(false, // no scoping; this is parallel code
                        collecting_perm_gen, so,
                        &buf_scan_non_heap_roots,
                        &eager_scan_code_roots,
-                       &buf_scan_perm);
+                       &buf_scan_perm,
+                       manages_code_roots);
 
   // Now the CM ref_processor roots.
   if (!_process_strong_tasks->is_task_claimed(G1H_PS_refProcessor_oops_do)) {
@@ -5136,9 +5162,22 @@
   }
   g1_policy()->phase_times()->record_satb_filtering_time(worker_i, satb_filtering_ms);
 
+  // If this is an initial mark pause, and we're not scanning
+  // the entire code cache, we need to mark the oops in the
+  // strong code root lists for the regions that are not in
+  // the collection set.
+  // Note all threads participate in this set of root tasks.
+  double mark_strong_code_roots_ms = 0.0;
+  if (g1_policy()->during_initial_mark_pause() && !(so & SO_CodeCache)) {
+    double mark_strong_roots_start = os::elapsedTime();
+    mark_strong_code_roots(worker_i);
+    mark_strong_code_roots_ms = (os::elapsedTime() - mark_strong_roots_start) * 1000.0;
+  }
+  g1_policy()->phase_times()->record_strong_code_root_mark_time(worker_i, mark_strong_code_roots_ms);
+
   // Now scan the complement of the collection set.
   if (scan_rs != NULL) {
-    g1_rem_set()->oops_into_collection_set_do(scan_rs, worker_i);
+    g1_rem_set()->oops_into_collection_set_do(scan_rs, &eager_scan_code_roots, worker_i);
   }
 
   _process_strong_tasks->all_tasks_completed();
@@ -5151,6 +5190,102 @@
   SharedHeap::process_weak_roots(root_closure, &roots_in_blobs, non_root_closure);
 }
 
+class G1StringSymbolTableUnlinkTask : public AbstractGangTask {
+private:
+  BoolObjectClosure* _is_alive;
+  int _initial_string_table_size;
+  int _initial_symbol_table_size;
+
+  bool  _process_strings;
+  int _strings_processed;
+  int _strings_removed;
+
+  bool  _process_symbols;
+  int _symbols_processed;
+  int _symbols_removed;
+
+  bool _do_in_parallel;
+public:
+  G1StringSymbolTableUnlinkTask(BoolObjectClosure* is_alive, bool process_strings, bool process_symbols) :
+    AbstractGangTask("Par String/Symbol table unlink"), _is_alive(is_alive),
+    _do_in_parallel(G1CollectedHeap::use_parallel_gc_threads()),
+    _process_strings(process_strings), _strings_processed(0), _strings_removed(0),
+    _process_symbols(process_symbols), _symbols_processed(0), _symbols_removed(0) {
+
+    _initial_string_table_size = StringTable::the_table()->table_size();
+    _initial_symbol_table_size = SymbolTable::the_table()->table_size();
+    if (process_strings) {
+      StringTable::clear_parallel_claimed_index();
+    }
+    if (process_symbols) {
+      SymbolTable::clear_parallel_claimed_index();
+    }
+  }
+
+  ~G1StringSymbolTableUnlinkTask() {
+    guarantee(!_process_strings || !_do_in_parallel || StringTable::parallel_claimed_index() >= _initial_string_table_size,
+              err_msg("claim value "INT32_FORMAT" after unlink less than initial string table size "INT32_FORMAT,
+                      StringTable::parallel_claimed_index(), _initial_string_table_size));
+    guarantee(!_process_symbols || !_do_in_parallel || SymbolTable::parallel_claimed_index() >= _initial_symbol_table_size,
+              err_msg("claim value "INT32_FORMAT" after unlink less than initial symbol table size "INT32_FORMAT,
+                      SymbolTable::parallel_claimed_index(), _initial_symbol_table_size));
+  }
+
+  void work(uint worker_id) {
+    if (_do_in_parallel) {
+      int strings_processed = 0;
+      int strings_removed = 0;
+      int symbols_processed = 0;
+      int symbols_removed = 0;
+      if (_process_strings) {
+        StringTable::possibly_parallel_unlink(_is_alive, &strings_processed, &strings_removed);
+        Atomic::add(strings_processed, &_strings_processed);
+        Atomic::add(strings_removed, &_strings_removed);
+      }
+      if (_process_symbols) {
+        SymbolTable::possibly_parallel_unlink(&symbols_processed, &symbols_removed);
+        Atomic::add(symbols_processed, &_symbols_processed);
+        Atomic::add(symbols_removed, &_symbols_removed);
+      }
+    } else {
+      if (_process_strings) {
+        StringTable::unlink(_is_alive, &_strings_processed, &_strings_removed);
+      }
+      if (_process_symbols) {
+        SymbolTable::unlink(&_symbols_processed, &_symbols_removed);
+      }
+    }
+  }
+
+  size_t strings_processed() const { return (size_t)_strings_processed; }
+  size_t strings_removed()   const { return (size_t)_strings_removed; }
+
+  size_t symbols_processed() const { return (size_t)_symbols_processed; }
+  size_t symbols_removed()   const { return (size_t)_symbols_removed; }
+};
+
+void G1CollectedHeap::unlink_string_and_symbol_table(BoolObjectClosure* is_alive,
+                                                     bool process_strings, bool process_symbols) {
+  uint n_workers = (G1CollectedHeap::use_parallel_gc_threads() ?
+                   _g1h->workers()->active_workers() : 1);
+
+  G1StringSymbolTableUnlinkTask g1_unlink_task(is_alive, process_strings, process_symbols);
+  if (G1CollectedHeap::use_parallel_gc_threads()) {
+    set_par_threads(n_workers);
+    workers()->run_task(&g1_unlink_task);
+    set_par_threads(0);
+  } else {
+    g1_unlink_task.work(0);
+  }
+  if (G1TraceStringSymbolTableScrubbing) {
+    gclog_or_tty->print_cr("Cleaned string and symbol table, "
+                           "strings: "SIZE_FORMAT" processed, "SIZE_FORMAT" removed, "
+                           "symbols: "SIZE_FORMAT" processed, "SIZE_FORMAT" removed",
+                           g1_unlink_task.strings_processed(), g1_unlink_task.strings_removed(),
+                           g1_unlink_task.symbols_processed(), g1_unlink_task.symbols_removed());
+  }
+}
+
 // Weak Reference Processing support
 
 // An always "is_alive" closure that is used to preserve referents.
@@ -5761,9 +5896,6 @@
   process_discovered_references(n_workers);
 
   // Weak root processing.
-  // Note: when JSR 292 is enabled and code blobs can contain
-  // non-perm oops then we will need to process the code blobs
-  // here too.
   {
     G1STWIsAliveClosure is_alive(this);
     G1KeepAliveClosure keep_alive(this);
@@ -5779,6 +5911,17 @@
   hot_card_cache->reset_hot_cache();
   hot_card_cache->set_use_cache(true);
 
+  // Migrate the strong code roots attached to each region in
+  // the collection set. Ideally we would like to do this
+  // after we have finished the scanning/evacuation of the
+  // strong code roots for a particular heap region.
+  migrate_strong_code_roots();
+
+  if (g1_policy()->during_initial_mark_pause()) {
+    // Reset the claim values set during marking the strong code roots
+    reset_heap_region_claim_values();
+  }
+
   finalize_for_evac_failure();
 
   if (evacuation_failed()) {
@@ -5912,11 +6055,11 @@
 }
 
 class G1ParCleanupCTTask : public AbstractGangTask {
-  CardTableModRefBS* _ct_bs;
+  G1SATBCardTableModRefBS* _ct_bs;
   G1CollectedHeap* _g1h;
   HeapRegion* volatile _su_head;
 public:
-  G1ParCleanupCTTask(CardTableModRefBS* ct_bs,
+  G1ParCleanupCTTask(G1SATBCardTableModRefBS* ct_bs,
                      G1CollectedHeap* g1h) :
     AbstractGangTask("G1 Par Cleanup CT Task"),
     _ct_bs(ct_bs), _g1h(g1h) { }
@@ -5939,9 +6082,9 @@
 #ifndef PRODUCT
 class G1VerifyCardTableCleanup: public HeapRegionClosure {
   G1CollectedHeap* _g1h;
-  CardTableModRefBS* _ct_bs;
+  G1SATBCardTableModRefBS* _ct_bs;
 public:
-  G1VerifyCardTableCleanup(G1CollectedHeap* g1h, CardTableModRefBS* ct_bs)
+  G1VerifyCardTableCleanup(G1CollectedHeap* g1h, G1SATBCardTableModRefBS* ct_bs)
     : _g1h(g1h), _ct_bs(ct_bs) { }
   virtual bool doHeapRegion(HeapRegion* r) {
     if (r->is_survivor()) {
@@ -5955,7 +6098,7 @@
 
 void G1CollectedHeap::verify_not_dirty_region(HeapRegion* hr) {
   // All of the region should be clean.
-  CardTableModRefBS* ct_bs = (CardTableModRefBS*)barrier_set();
+  G1SATBCardTableModRefBS* ct_bs = g1_barrier_set();
   MemRegion mr(hr->bottom(), hr->end());
   ct_bs->verify_not_dirty_region(mr);
 }
@@ -5968,13 +6111,17 @@
   // not dirty that area (one less thing to have to do while holding
   // a lock). So we can only verify that [bottom(),pre_dummy_top()]
   // is dirty.
-  CardTableModRefBS* ct_bs = (CardTableModRefBS*) barrier_set();
+  G1SATBCardTableModRefBS* ct_bs = g1_barrier_set();
   MemRegion mr(hr->bottom(), hr->pre_dummy_top());
-  ct_bs->verify_dirty_region(mr);
+  if (hr->is_young()) {
+    ct_bs->verify_g1_young_region(mr);
+  } else {
+    ct_bs->verify_dirty_region(mr);
+  }
 }
 
 void G1CollectedHeap::verify_dirty_young_list(HeapRegion* head) {
-  CardTableModRefBS* ct_bs = (CardTableModRefBS*) barrier_set();
+  G1SATBCardTableModRefBS* ct_bs = g1_barrier_set();
   for (HeapRegion* hr = head; hr != NULL; hr = hr->get_next_young_region()) {
     verify_dirty_region(hr);
   }
@@ -5986,7 +6133,7 @@
 #endif
 
 void G1CollectedHeap::cleanUpCardTable() {
-  CardTableModRefBS* ct_bs = (CardTableModRefBS*) (barrier_set());
+  G1SATBCardTableModRefBS* ct_bs = g1_barrier_set();
   double start = os::elapsedTime();
 
   {
@@ -6575,3 +6722,234 @@
   _humongous_set.verify_end();
   _free_list.verify_end();
 }
+
+// Optimized nmethod scanning
+
+class RegisterNMethodOopClosure: public OopClosure {
+  G1CollectedHeap* _g1h;
+  nmethod* _nm;
+
+  template <class T> void do_oop_work(T* p) {
+    T heap_oop = oopDesc::load_heap_oop(p);
+    if (!oopDesc::is_null(heap_oop)) {
+      oop obj = oopDesc::decode_heap_oop_not_null(heap_oop);
+      HeapRegion* hr = _g1h->heap_region_containing(obj);
+      if (hr == NULL) {
+        // reference into perm gen - ignore.
+        assert(_g1h->is_in_permanent(obj), "must be a reference into perm gen");
+        return;
+      }
+      assert(!hr->continuesHumongous(),
+             err_msg("trying to add code root "PTR_FORMAT" in continuation of humongous region "HR_FORMAT
+                     " starting at "HR_FORMAT,
+                     _nm, HR_FORMAT_PARAMS(hr), HR_FORMAT_PARAMS(hr->humongous_start_region())));
+
+      // HeapRegion::add_strong_code_root() avoids adding duplicate
+      // entries but having duplicates is  OK since we "mark" nmethods
+      // as visited when we scan the strong code root lists during the GC.
+      hr->add_strong_code_root(_nm);
+      assert(hr->rem_set()->strong_code_roots_list_contains(_nm),
+             err_msg("failed to add code root "PTR_FORMAT" to remembered set of region "HR_FORMAT,
+                     _nm, HR_FORMAT_PARAMS(hr)));
+    }
+  }
+
+public:
+  RegisterNMethodOopClosure(G1CollectedHeap* g1h, nmethod* nm) :
+    _g1h(g1h), _nm(nm) {}
+
+  void do_oop(oop* p)       { do_oop_work(p); }
+  void do_oop(narrowOop* p) { do_oop_work(p); }
+};
+
+class UnregisterNMethodOopClosure: public OopClosure {
+  G1CollectedHeap* _g1h;
+  nmethod* _nm;
+
+  template <class T> void do_oop_work(T* p) {
+    T heap_oop = oopDesc::load_heap_oop(p);
+    if (!oopDesc::is_null(heap_oop)) {
+      oop obj = oopDesc::decode_heap_oop_not_null(heap_oop);
+      HeapRegion* hr = _g1h->heap_region_containing(obj);
+      if (hr == NULL) {
+        // reference into perm gen - ignore.
+        assert(_g1h->is_in_permanent(obj), "must be a reference into perm gen");
+        return;
+      }
+      assert(!hr->continuesHumongous(),
+             err_msg("trying to remove code root "PTR_FORMAT" in continuation of humongous region "HR_FORMAT
+                     " starting at "HR_FORMAT,
+                     _nm, HR_FORMAT_PARAMS(hr), HR_FORMAT_PARAMS(hr->humongous_start_region())));
+
+      hr->remove_strong_code_root(_nm);
+      assert(!hr->rem_set()->strong_code_roots_list_contains(_nm),
+             err_msg("failed to remove code root "PTR_FORMAT" of region "HR_FORMAT,
+                     _nm, HR_FORMAT_PARAMS(hr)));    }
+  }
+
+public:
+  UnregisterNMethodOopClosure(G1CollectedHeap* g1h, nmethod* nm) :
+    _g1h(g1h), _nm(nm) {}
+
+  void do_oop(oop* p)       { do_oop_work(p); }
+  void do_oop(narrowOop* p) { do_oop_work(p); }
+};
+
+void G1CollectedHeap::register_nmethod(nmethod* nm) {
+  CollectedHeap::register_nmethod(nm);
+
+  guarantee(nm != NULL, "sanity");
+  RegisterNMethodOopClosure reg_cl(this, nm);
+  nm->oops_do(&reg_cl);
+}
+
+void G1CollectedHeap::unregister_nmethod(nmethod* nm) {
+  CollectedHeap::unregister_nmethod(nm);
+
+  guarantee(nm != NULL, "sanity");
+  UnregisterNMethodOopClosure reg_cl(this, nm);
+  nm->oops_do(&reg_cl, false, true);
+}
+
+class MigrateCodeRootsHeapRegionClosure: public HeapRegionClosure {
+public:
+  bool doHeapRegion(HeapRegion *hr) {
+    assert(!hr->isHumongous(),
+           err_msg("humongous region "HR_FORMAT" should not have been added to collection set",
+                   HR_FORMAT_PARAMS(hr)));
+    hr->migrate_strong_code_roots();
+    return false;
+  }
+};
+
+void G1CollectedHeap::migrate_strong_code_roots() {
+  MigrateCodeRootsHeapRegionClosure cl;
+  double migrate_start = os::elapsedTime();
+  collection_set_iterate(&cl);
+  double migration_time_ms = (os::elapsedTime() - migrate_start) * 1000.0;
+  g1_policy()->phase_times()->record_strong_code_root_migration_time(migration_time_ms);
+}
+
+// Mark all the code roots that point into regions *not* in the
+// collection set.
+//
+// Note we do not want to use a "marking" CodeBlobToOopClosure while
+// walking the the code roots lists of regions not in the collection
+// set. Suppose we have an nmethod (M) that points to objects in two
+// separate regions - one in the collection set (R1) and one not (R2).
+// Using a "marking" CodeBlobToOopClosure here would result in "marking"
+// nmethod M when walking the code roots for R1. When we come to scan
+// the code roots for R2, we would see that M is already marked and it
+// would be skipped and the objects in R2 that are referenced from M
+// would not be evacuated.
+
+class MarkStrongCodeRootCodeBlobClosure: public CodeBlobClosure {
+
+  class MarkStrongCodeRootOopClosure: public OopClosure {
+    ConcurrentMark* _cm;
+    HeapRegion* _hr;
+    uint _worker_id;
+
+    template <class T> void do_oop_work(T* p) {
+      T heap_oop = oopDesc::load_heap_oop(p);
+      if (!oopDesc::is_null(heap_oop)) {
+        oop obj = oopDesc::decode_heap_oop_not_null(heap_oop);
+        // Only mark objects in the region (which is assumed
+        // to be not in the collection set).
+        if (_hr->is_in(obj)) {
+          _cm->grayRoot(obj, (size_t) obj->size(), _worker_id);
+        }
+      }
+    }
+
+  public:
+    MarkStrongCodeRootOopClosure(ConcurrentMark* cm, HeapRegion* hr, uint worker_id) :
+      _cm(cm), _hr(hr), _worker_id(worker_id) {
+      assert(!_hr->in_collection_set(), "sanity");
+    }
+
+    void do_oop(narrowOop* p) { do_oop_work(p); }
+    void do_oop(oop* p)       { do_oop_work(p); }
+  };
+
+  MarkStrongCodeRootOopClosure _oop_cl;
+
+public:
+  MarkStrongCodeRootCodeBlobClosure(ConcurrentMark* cm, HeapRegion* hr, uint worker_id):
+    _oop_cl(cm, hr, worker_id) {}
+
+  void do_code_blob(CodeBlob* cb) {
+    nmethod* nm = (cb == NULL) ? NULL : cb->as_nmethod_or_null();
+    if (nm != NULL) {
+      nm->oops_do(&_oop_cl);
+    }
+  }
+};
+
+class MarkStrongCodeRootsHRClosure: public HeapRegionClosure {
+  G1CollectedHeap* _g1h;
+  uint _worker_id;
+
+public:
+  MarkStrongCodeRootsHRClosure(G1CollectedHeap* g1h, uint worker_id) :
+    _g1h(g1h), _worker_id(worker_id) {}
+
+  bool doHeapRegion(HeapRegion *hr) {
+    HeapRegionRemSet* hrrs = hr->rem_set();
+    if (hr->continuesHumongous()) {
+      // Code roots should never be attached to a continuation of a humongous region
+      assert(hrrs->strong_code_roots_list_length() == 0,
+             err_msg("code roots should never be attached to continuations of humongous region "HR_FORMAT
+                     " starting at "HR_FORMAT", but has "INT32_FORMAT,
+                     HR_FORMAT_PARAMS(hr), HR_FORMAT_PARAMS(hr->humongous_start_region()),
+                     hrrs->strong_code_roots_list_length()));
+      return false;
+    }
+
+    if (hr->in_collection_set()) {
+      // Don't mark code roots into regions in the collection set here.
+      // They will be marked when we scan them.
+      return false;
+    }
+
+    MarkStrongCodeRootCodeBlobClosure cb_cl(_g1h->concurrent_mark(), hr, _worker_id);
+    hr->strong_code_roots_do(&cb_cl);
+    return false;
+  }
+};
+
+void G1CollectedHeap::mark_strong_code_roots(uint worker_id) {
+  MarkStrongCodeRootsHRClosure cl(this, worker_id);
+  if (G1CollectedHeap::use_parallel_gc_threads()) {
+    heap_region_par_iterate_chunked(&cl,
+                                    worker_id,
+                                    workers()->active_workers(),
+                                    HeapRegion::ParMarkRootClaimValue);
+  } else {
+    heap_region_iterate(&cl);
+  }
+}
+
+class RebuildStrongCodeRootClosure: public CodeBlobClosure {
+  G1CollectedHeap* _g1h;
+
+public:
+  RebuildStrongCodeRootClosure(G1CollectedHeap* g1h) :
+    _g1h(g1h) {}
+
+  void do_code_blob(CodeBlob* cb) {
+    nmethod* nm = (cb != NULL) ? cb->as_nmethod_or_null() : NULL;
+    if (nm == NULL) {
+      return;
+    }
+
+    if (ScavengeRootsInCode && nm->detect_scavenge_root_oops()) {
+      _g1h->register_nmethod(nm);
+    }
+  }
+};
+
+void G1CollectedHeap::rebuild_strong_code_roots() {
+  RebuildStrongCodeRootClosure blob_cl(this);
+  CodeCache::blobs_do(&blob_cl);
+}
--- ./hotspot/src/share/vm/gc_implementation/g1/g1CollectedHeap.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/gc_implementation/g1/g1CollectedHeap.hpp	Wed May 07 19:26:16 2014 -0700
@@ -31,6 +31,7 @@
 #include "gc_implementation/g1/g1HRPrinter.hpp"
 #include "gc_implementation/g1/g1MonitoringSupport.hpp"
 #include "gc_implementation/g1/g1RemSet.hpp"
+#include "gc_implementation/g1/g1SATBCardTableModRefBS.hpp"
 #include "gc_implementation/g1/g1YCTypes.hpp"
 #include "gc_implementation/g1/heapRegionSeq.hpp"
 #include "gc_implementation/g1/heapRegionSets.hpp"
@@ -46,6 +47,7 @@
 // may combine concurrent marking with parallel, incremental compaction of
 // heap subsets that will yield large amounts of garbage.
 
+// Forward declarations
 class HeapRegion;
 class HRRSCleanupTask;
 class PermanentGenerationSpec;
@@ -69,6 +71,8 @@
 class G1NewTracer;
 class G1OldTracer;
 class EvacuationFailedInfo;
+class nmethod;
+class Ticks;
 
 typedef OverflowTaskQueue<StarTask, mtGC>         RefToScanQueue;
 typedef GenericTaskQueueSet<RefToScanQueue, mtGC> RefToScanQueueSet;
@@ -163,19 +167,6 @@
     : G1AllocRegion("Mutator Alloc Region", false /* bot_updates */) { }
 };
 
-// The G1 STW is alive closure.
-// An instance is embedded into the G1CH and used as the
-// (optional) _is_alive_non_header closure in the STW
-// reference processor. It is also extensively used during
-// reference processing during STW evacuation pauses.
-class G1STWIsAliveClosure: public BoolObjectClosure {
-  G1CollectedHeap* _g1;
-public:
-  G1STWIsAliveClosure(G1CollectedHeap* g1) : _g1(g1) {}
-  void do_object(oop p) { assert(false, "Do not call."); }
-  bool do_object_b(oop p);
-};
-
 class SurvivorGCAllocRegion : public G1AllocRegion {
 protected:
   virtual HeapRegion* allocate_new_region(size_t word_size, bool force);
@@ -194,6 +185,19 @@
   : G1AllocRegion("Old GC Alloc Region", true /* bot_updates */) { }
 };
 
+// The G1 STW is alive closure.
+// An instance is embedded into the G1CH and used as the
+// (optional) _is_alive_non_header closure in the STW
+// reference processor. It is also extensively used during
+// reference processing during STW evacuation pauses.
+class G1STWIsAliveClosure: public BoolObjectClosure {
+  G1CollectedHeap* _g1;
+public:
+  G1STWIsAliveClosure(G1CollectedHeap* g1) : _g1(g1) {}
+  void do_object(oop p) { assert(false, "Do not call."); }
+  bool do_object_b(oop p);
+};
+
 class RefineCardTableEntryClosure;
 
 class G1CollectedHeap : public SharedHeap {
@@ -747,7 +751,7 @@
     return _old_marking_cycles_completed;
   }
 
-  void register_concurrent_cycle_start(jlong start_time);
+  void register_concurrent_cycle_start(const Ticks& start_time);
   void register_concurrent_cycle_end();
   void trace_heap_after_concurrent_cycle();
 
@@ -792,8 +796,6 @@
 
   // The g1 remembered set of the heap.
   G1RemSet* _g1_rem_set;
-  // And it's mod ref barrier set, used to track updates for the above.
-  ModRefBarrierSet* _mr_bs;
 
   // A set of cards that cover the objects for which the Rsets should be updated
   // concurrently after the collection.
@@ -835,7 +837,8 @@
                                OopClosure* scan_non_heap_roots,
                                OopsInHeapRegionClosure* scan_rs,
                                OopsInGenClosure* scan_perm,
-                               int worker_i);
+                               int worker_i,
+                               bool manages_code_roots = false);
 
   // Apply "blk" to all the weak roots of the system.  These include
   // JNI weak roots, the code cache, system dictionary, symbol table,
@@ -1127,7 +1130,6 @@
 
   // The rem set and barrier set.
   G1RemSet* g1_rem_set() const { return _g1_rem_set; }
-  ModRefBarrierSet* mr_bs() const { return _mr_bs; }
 
   // The rem set iterator.
   HeapRegionRemSetIterator* rem_set_iterator(int i) {
@@ -1361,6 +1363,10 @@
 
   virtual bool is_in_closed_subset(const void* p) const;
 
+  G1SATBCardTableModRefBS* g1_barrier_set() {
+    return (G1SATBCardTableModRefBS*) barrier_set();
+  }
+
   // This resets the card table to all zeros.  It is used after
   // a collection pause which used the card table to claim cards.
   void cleanUpCardTable();
@@ -1592,41 +1598,6 @@
 
   virtual jlong millis_since_last_gc();
 
-  // Perform any cleanup actions necessary before allowing a verification.
-  virtual void prepare_for_verify();
-
-  // Perform verification.
-
-  // vo == UsePrevMarking  -> use "prev" marking information,
-  // vo == UseNextMarking -> use "next" marking information
-  // vo == UseMarkWord    -> use the mark word in the object header
-  //
-  // NOTE: Only the "prev" marking information is guaranteed to be
-  // consistent most of the time, so most calls to this should use
-  // vo == UsePrevMarking.
-  // Currently, there is only one case where this is called with
-  // vo == UseNextMarking, which is to verify the "next" marking
-  // information at the end of remark.
-  // Currently there is only one place where this is called with
-  // vo == UseMarkWord, which is to verify the marking during a
-  // full GC.
-  void verify(bool silent, VerifyOption vo);
-
-  // Override; it uses the "prev" marking information
-  virtual void verify(bool silent);
-
-  virtual void print_on(outputStream* st) const;
-  virtual void print_extended_on(outputStream* st) const;
-
-  virtual void print_gc_threads_on(outputStream* st) const;
-  virtual void gc_threads_do(ThreadClosure* tc) const;
-
-  // Override
-  void print_tracing_info() const;
-
-  // The following two methods are helpful for debugging RSet issues.
-  void print_cset_rsets() PRODUCT_RETURN;
-  void print_all_rsets() PRODUCT_RETURN;
 
   // Convenience function to be used in situations where the heap type can be
   // asserted to be this type.
@@ -1684,7 +1655,6 @@
   // then call the region version of the same function.
 
   // Added if it is in permanent gen it isn't dead.
-  // Added if it is NULL it isn't dead.
 
   bool is_obj_dead(const oop obj) const {
     const HeapRegion* hr = heap_region_containing(obj);
@@ -1708,13 +1678,90 @@
     else return is_obj_ill(obj, hr);
   }
 
+  bool allocated_since_marking(oop obj, HeapRegion* hr, VerifyOption vo);
+  HeapWord* top_at_mark_start(HeapRegion* hr, VerifyOption vo);
+  bool is_marked(oop obj, VerifyOption vo);
+  const char* top_at_mark_start_str(VerifyOption vo);
+
+  ConcurrentMark* concurrent_mark() const { return _cm; }
+
+  // Refinement
+
+  ConcurrentG1Refine* concurrent_g1_refine() const { return _cg1r; }
+
+  // The dirty cards region list is used to record a subset of regions
+  // whose cards need clearing. The list if populated during the
+  // remembered set scanning and drained during the card table
+  // cleanup. Although the methods are reentrant, population/draining
+  // phases must not overlap. For synchronization purposes the last
+  // element on the list points to itself.
+  HeapRegion* _dirty_cards_region_list;
+  void push_dirty_cards_region(HeapRegion* hr);
+  HeapRegion* pop_dirty_cards_region();
+
+  // Optimized nmethod scanning support routines
+
+  // Register the given nmethod with the G1 heap
+  virtual void register_nmethod(nmethod* nm);
+
+  // Unregister the given nmethod from the G1 heap
+  virtual void unregister_nmethod(nmethod* nm);
+
+  // Migrate the nmethods in the code root lists of the regions
+  // in the collection set to regions in to-space. In the event
+  // of an evacuation failure, nmethods that reference objects
+  // that were not successfullly evacuated are not migrated.
+  void migrate_strong_code_roots();
+
+  // During an initial mark pause, mark all the code roots that
+  // point into regions *not* in the collection set.
+  void mark_strong_code_roots(uint worker_id);
+
+  // Rebuild the stong code root lists for each region
+  // after a full GC
+  void rebuild_strong_code_roots();
+
+  // Delete entries for dead interned string and clean up unreferenced symbols
+  // in symbol table, possibly in parallel.
+  void unlink_string_and_symbol_table(BoolObjectClosure* is_alive, bool unlink_strings = true, bool unlink_symbols = true);
+
+  // Verification
+
+  // The following is just to alert the verification code
+  // that a full collection has occurred and that the
+  // remembered sets are no longer up to date.
+  bool _full_collection;
+  void set_full_collection() { _full_collection = true;}
+  void clear_full_collection() {_full_collection = false;}
+  bool full_collection() {return _full_collection;}
+
+  // Perform any cleanup actions necessary before allowing a verification.
+  virtual void prepare_for_verify();
+
+  // Perform verification.
+
+  // vo == UsePrevMarking  -> use "prev" marking information,
+  // vo == UseNextMarking -> use "next" marking information
+  // vo == UseMarkWord    -> use the mark word in the object header
+  //
+  // NOTE: Only the "prev" marking information is guaranteed to be
+  // consistent most of the time, so most calls to this should use
+  // vo == UsePrevMarking.
+  // Currently, there is only one case where this is called with
+  // vo == UseNextMarking, which is to verify the "next" marking
+  // information at the end of remark.
+  // Currently there is only one place where this is called with
+  // vo == UseMarkWord, which is to verify the marking during a
+  // full GC.
+  void verify(bool silent, VerifyOption vo);
+
+  // Override; it uses the "prev" marking information
+  virtual void verify(bool silent);
+
   // The methods below are here for convenience and dispatch the
   // appropriate method depending on value of the given VerifyOption
-  // parameter. The options for that parameter are:
-  //
-  // vo == UsePrevMarking -> use "prev" marking information,
-  // vo == UseNextMarking -> use "next" marking information,
-  // vo == UseMarkWord    -> use mark word from object header
+  // parameter. The values for that parameter, and their meanings,
+  // are the same as those above.
 
   bool is_obj_dead_cond(const oop obj,
                         const HeapRegion* hr,
@@ -1739,31 +1786,20 @@
     return false; // keep some compilers happy
   }
 
-  bool allocated_since_marking(oop obj, HeapRegion* hr, VerifyOption vo);
-  HeapWord* top_at_mark_start(HeapRegion* hr, VerifyOption vo);
-  bool is_marked(oop obj, VerifyOption vo);
-  const char* top_at_mark_start_str(VerifyOption vo);
+  // Printing
 
-  // The following is just to alert the verification code
-  // that a full collection has occurred and that the
-  // remembered sets are no longer up to date.
-  bool _full_collection;
-  void set_full_collection() { _full_collection = true;}
-  void clear_full_collection() {_full_collection = false;}
-  bool full_collection() {return _full_collection;}
+  virtual void print_on(outputStream* st) const;
+  virtual void print_extended_on(outputStream* st) const;
 
-  ConcurrentMark* concurrent_mark() const { return _cm; }
-  ConcurrentG1Refine* concurrent_g1_refine() const { return _cg1r; }
+  virtual void print_gc_threads_on(outputStream* st) const;
+  virtual void gc_threads_do(ThreadClosure* tc) const;
 
-  // The dirty cards region list is used to record a subset of regions
-  // whose cards need clearing. The list if populated during the
-  // remembered set scanning and drained during the card table
-  // cleanup. Although the methods are reentrant, population/draining
-  // phases must not overlap. For synchronization purposes the last
-  // element on the list points to itself.
-  HeapRegion* _dirty_cards_region_list;
-  void push_dirty_cards_region(HeapRegion* hr);
-  HeapRegion* pop_dirty_cards_region();
+  // Override
+  void print_tracing_info() const;
+
+  // The following two methods are helpful for debugging RSet issues.
+  void print_cset_rsets() PRODUCT_RETURN;
+  void print_all_rsets() PRODUCT_RETURN;
 
 public:
   void stop_conc_gc_threads();
@@ -1800,7 +1836,7 @@
   G1CollectedHeap* _g1h;
   RefToScanQueue*  _refs;
   DirtyCardQueue   _dcq;
-  CardTableModRefBS* _ct_bs;
+  G1SATBCardTableModRefBS* _ct_bs;
   G1RemSet* _g1_rem;
 
   G1ParGCAllocBuffer  _surviving_alloc_buffer;
@@ -1839,7 +1875,7 @@
   void   add_to_undo_waste(size_t waste)         { _undo_waste += waste; }
 
   DirtyCardQueue& dirty_card_queue()             { return _dcq;  }
-  CardTableModRefBS* ctbs()                      { return _ct_bs; }
+  G1SATBCardTableModRefBS* ctbs()                { return _ct_bs; }
 
   template <class T> void immediate_rs_update(HeapRegion* from, T* p, int tid) {
     if (!from->is_survivor()) {
--- ./hotspot/src/share/vm/gc_implementation/g1/g1CollectedHeap.inline.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/gc_implementation/g1/g1CollectedHeap.inline.hpp	Wed May 07 19:26:16 2014 -0700
@@ -29,6 +29,7 @@
 #include "gc_implementation/g1/g1CollectedHeap.hpp"
 #include "gc_implementation/g1/g1AllocRegion.inline.hpp"
 #include "gc_implementation/g1/g1CollectorPolicy.hpp"
+#include "gc_implementation/g1/g1SATBCardTableModRefBS.hpp"
 #include "gc_implementation/g1/heapRegionSeq.inline.hpp"
 #include "utilities/taskqueue.hpp"
 
@@ -131,7 +132,7 @@
   assert(containing_hr->is_in(end - 1), "it should also contain end - 1");
 
   MemRegion mr(start, end);
-  ((CardTableModRefBS*)_g1h->barrier_set())->dirty(mr);
+  g1_barrier_set()->g1_mark_as_young(mr);
 }
 
 inline RefToScanQueue* G1CollectedHeap::task_queue(int i) const {
--- ./hotspot/src/share/vm/gc_implementation/g1/g1CollectorPolicy.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/gc_implementation/g1/g1CollectorPolicy.cpp	Wed May 07 19:26:16 2014 -0700
@@ -310,7 +310,8 @@
 void G1CollectorPolicy::initialize_flags() {
   set_min_alignment(HeapRegion::GrainBytes);
   size_t card_table_alignment = GenRemSet::max_alignment_constraint(rem_set_name());
-  set_max_alignment(MAX2(card_table_alignment, min_alignment()));
+  size_t page_size = UseLargePages ? os::large_page_size() : os::vm_page_size();
+  set_max_alignment(MAX3(card_table_alignment, min_alignment(), page_size));
   if (SurvivorRatio < 1) {
     vm_exit_during_initialization("Invalid survivor ratio specified");
   }
--- ./hotspot/src/share/vm/gc_implementation/g1/g1EvacFailure.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/gc_implementation/g1/g1EvacFailure.hpp	Wed May 07 19:26:16 2014 -0700
@@ -41,11 +41,11 @@
 private:
   G1CollectedHeap* _g1;
   DirtyCardQueue *_dcq;
-  CardTableModRefBS* _ct_bs;
+  G1SATBCardTableModRefBS* _ct_bs;
 
 public:
   UpdateRSetDeferred(G1CollectedHeap* g1, DirtyCardQueue* dcq) :
-    _g1(g1), _ct_bs((CardTableModRefBS*)_g1->barrier_set()), _dcq(dcq) {}
+    _g1(g1), _ct_bs(_g1->g1_barrier_set()), _dcq(dcq) {}
 
   virtual void do_oop(narrowOop* p) { do_oop_work(p); }
   virtual void do_oop(      oop* p) { do_oop_work(p); }
--- ./hotspot/src/share/vm/gc_implementation/g1/g1GCPhaseTimes.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/gc_implementation/g1/g1GCPhaseTimes.cpp	Wed May 07 19:26:16 2014 -0700
@@ -161,6 +161,8 @@
   _last_update_rs_times_ms(_max_gc_threads, "%.1lf"),
   _last_update_rs_processed_buffers(_max_gc_threads, "%d"),
   _last_scan_rs_times_ms(_max_gc_threads, "%.1lf"),
+  _last_strong_code_root_scan_times_ms(_max_gc_threads, "%.1lf"),
+  _last_strong_code_root_mark_times_ms(_max_gc_threads, "%.1lf"),
   _last_obj_copy_times_ms(_max_gc_threads, "%.1lf"),
   _last_termination_times_ms(_max_gc_threads, "%.1lf"),
   _last_termination_attempts(_max_gc_threads, SIZE_FORMAT),
@@ -182,6 +184,8 @@
   _last_update_rs_times_ms.reset();
   _last_update_rs_processed_buffers.reset();
   _last_scan_rs_times_ms.reset();
+  _last_strong_code_root_scan_times_ms.reset();
+  _last_strong_code_root_mark_times_ms.reset();
   _last_obj_copy_times_ms.reset();
   _last_termination_times_ms.reset();
   _last_termination_attempts.reset();
@@ -197,6 +201,8 @@
   _last_update_rs_times_ms.verify();
   _last_update_rs_processed_buffers.verify();
   _last_scan_rs_times_ms.verify();
+  _last_strong_code_root_scan_times_ms.verify();
+  _last_strong_code_root_mark_times_ms.verify();
   _last_obj_copy_times_ms.verify();
   _last_termination_times_ms.verify();
   _last_termination_attempts.verify();
@@ -210,6 +216,8 @@
                                _last_satb_filtering_times_ms.get(i) +
                                _last_update_rs_times_ms.get(i) +
                                _last_scan_rs_times_ms.get(i) +
+                               _last_strong_code_root_scan_times_ms.get(i) +
+                               _last_strong_code_root_mark_times_ms.get(i) +
                                _last_obj_copy_times_ms.get(i) +
                                _last_termination_times_ms.get(i);
 
@@ -239,6 +247,9 @@
     // Now subtract the time taken to fix up roots in generated code
     misc_time_ms += _cur_collection_code_root_fixup_time_ms;
 
+    // Strong code root migration time
+    misc_time_ms += _cur_strong_code_root_migration_time_ms;
+
     // Subtract the time taken to clean the card table from the
     // current value of "other time"
     misc_time_ms += _cur_clear_ct_time_ms;
@@ -257,9 +268,13 @@
     if (_last_satb_filtering_times_ms.sum() > 0.0) {
       _last_satb_filtering_times_ms.print(2, "SATB Filtering (ms)");
     }
+    if (_last_strong_code_root_mark_times_ms.sum() > 0.0) {
+     _last_strong_code_root_mark_times_ms.print(2, "Code Root Marking (ms)");
+    }
     _last_update_rs_times_ms.print(2, "Update RS (ms)");
       _last_update_rs_processed_buffers.print(3, "Processed Buffers");
     _last_scan_rs_times_ms.print(2, "Scan RS (ms)");
+    _last_strong_code_root_scan_times_ms.print(2, "Code Root Scanning (ms)");
     _last_obj_copy_times_ms.print(2, "Object Copy (ms)");
     _last_termination_times_ms.print(2, "Termination (ms)");
     if (G1Log::finest()) {
@@ -273,12 +288,17 @@
     if (_last_satb_filtering_times_ms.sum() > 0.0) {
       _last_satb_filtering_times_ms.print(1, "SATB Filtering (ms)");
     }
+    if (_last_strong_code_root_mark_times_ms.sum() > 0.0) {
+      _last_strong_code_root_mark_times_ms.print(1, "Code Root Marking (ms)");
+    }
     _last_update_rs_times_ms.print(1, "Update RS (ms)");
       _last_update_rs_processed_buffers.print(2, "Processed Buffers");
     _last_scan_rs_times_ms.print(1, "Scan RS (ms)");
+    _last_strong_code_root_scan_times_ms.print(1, "Code Root Scanning (ms)");
     _last_obj_copy_times_ms.print(1, "Object Copy (ms)");
   }
   print_stats(1, "Code Root Fixup", _cur_collection_code_root_fixup_time_ms);
+  print_stats(1, "Code Root Migration", _cur_strong_code_root_migration_time_ms);
   print_stats(1, "Clear CT", _cur_clear_ct_time_ms);
   double misc_time_ms = pause_time_sec * MILLIUNITS - accounted_time_ms();
   print_stats(1, "Other", misc_time_ms);
--- ./hotspot/src/share/vm/gc_implementation/g1/g1GCPhaseTimes.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/gc_implementation/g1/g1GCPhaseTimes.hpp	Wed May 07 19:26:16 2014 -0700
@@ -119,6 +119,8 @@
   WorkerDataArray<double> _last_update_rs_times_ms;
   WorkerDataArray<int>    _last_update_rs_processed_buffers;
   WorkerDataArray<double> _last_scan_rs_times_ms;
+  WorkerDataArray<double> _last_strong_code_root_scan_times_ms;
+  WorkerDataArray<double> _last_strong_code_root_mark_times_ms;
   WorkerDataArray<double> _last_obj_copy_times_ms;
   WorkerDataArray<double> _last_termination_times_ms;
   WorkerDataArray<size_t> _last_termination_attempts;
@@ -128,6 +130,7 @@
 
   double _cur_collection_par_time_ms;
   double _cur_collection_code_root_fixup_time_ms;
+  double _cur_strong_code_root_migration_time_ms;
 
   double _cur_clear_ct_time_ms;
   double _cur_ref_proc_time_ms;
@@ -179,6 +182,14 @@
     _last_scan_rs_times_ms.set(worker_i, ms);
   }
 
+  void record_strong_code_root_scan_time(uint worker_i, double ms) {
+    _last_strong_code_root_scan_times_ms.set(worker_i, ms);
+  }
+
+  void record_strong_code_root_mark_time(uint worker_i, double ms) {
+    _last_strong_code_root_mark_times_ms.set(worker_i, ms);
+  }
+
   void record_obj_copy_time(uint worker_i, double ms) {
     _last_obj_copy_times_ms.set(worker_i, ms);
   }
@@ -208,6 +219,10 @@
     _cur_collection_code_root_fixup_time_ms = ms;
   }
 
+  void record_strong_code_root_migration_time(double ms) {
+    _cur_strong_code_root_migration_time_ms = ms;
+  }
+
   void record_ref_proc_time(double ms) {
     _cur_ref_proc_time_ms = ms;
   }
@@ -294,6 +309,14 @@
     return _last_scan_rs_times_ms.average();
   }
 
+  double average_last_strong_code_root_scan_time(){
+    return _last_strong_code_root_scan_times_ms.average();
+  }
+
+  double average_last_strong_code_root_mark_time(){
+    return _last_strong_code_root_mark_times_ms.average();
+  }
+
   double average_last_obj_copy_time() {
     return _last_obj_copy_times_ms.average();
   }
--- ./hotspot/src/share/vm/gc_implementation/g1/g1MarkSweep.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/gc_implementation/g1/g1MarkSweep.cpp	Wed May 07 19:26:16 2014 -0700
@@ -177,10 +177,8 @@
   GenMarkSweep::follow_mdo_weak_refs();
   assert(GenMarkSweep::_marking_stack.is_empty(), "just drained");
 
-  // Visit interned string tables and delete unmarked oops
-  StringTable::unlink(&GenMarkSweep::is_alive);
-  // Clean up unreferenced symbols in symbol table.
-  SymbolTable::unlink();
+  // Delete entries for dead interned string and clean up unreferenced symbols in symbol table.
+  G1CollectedHeap::heap()->unlink_string_and_symbol_table(&GenMarkSweep::is_alive);
 
   assert(GenMarkSweep::_marking_stack.is_empty(),
          "stack should be empty by now");
@@ -188,7 +186,6 @@
   if (VerifyDuringGC) {
     HandleMark hm;  // handle scope
     COMPILER2_PRESENT(DerivedPointerTableDeactivate dpt_deact);
-    gclog_or_tty->print(" VerifyDuringGC:(full)[Verifying ");
     Universe::heap()->prepare_for_verify();
     // Note: we can verify only the heap here. When an object is
     // marked, the previous value of the mark word (including
@@ -200,11 +197,13 @@
     // fail. At the end of the GC, the orginal mark word values
     // (including hash values) are restored to the appropriate
     // objects.
-    Universe::heap()->verify(/* silent      */ false,
-                             /* option      */ VerifyOption_G1UseMarkWord);
-
-    G1CollectedHeap* g1h = G1CollectedHeap::heap();
-    gclog_or_tty->print_cr("]");
+    if (!VerifySilently) {
+      gclog_or_tty->print(" VerifyDuringGC:(full)[Verifying ");
+    }
+    Universe::heap()->verify(VerifySilently, VerifyOption_G1UseMarkWord);
+    if (!VerifySilently) {
+      gclog_or_tty->print_cr("]");
+    }
   }
 
   gc_tracer()->report_object_count_after_gc(&GenMarkSweep::is_alive);
@@ -235,7 +234,7 @@
 public:
   G1PrepareCompactClosure(CompactibleSpace* cs)
   : _g1h(G1CollectedHeap::heap()),
-    _mrbs(G1CollectedHeap::heap()->mr_bs()),
+    _mrbs(_g1h->g1_barrier_set()),
     _cp(NULL, cs, cs->initialize_threshold()),
     _humongous_proxy_set("G1MarkSweep Humongous Proxy Set") { }
 
--- ./hotspot/src/share/vm/gc_implementation/g1/g1RemSet.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/gc_implementation/g1/g1RemSet.cpp	Wed May 07 19:26:16 2014 -0700
@@ -34,6 +34,7 @@
 #include "gc_implementation/g1/g1OopClosures.inline.hpp"
 #include "gc_implementation/g1/g1RemSet.inline.hpp"
 #include "gc_implementation/g1/heapRegionSeq.inline.hpp"
+#include "gc_implementation/g1/heapRegionRemSet.hpp"
 #include "memory/iterator.hpp"
 #include "oops/oop.inline.hpp"
 #include "utilities/intHisto.hpp"
@@ -73,7 +74,8 @@
     _ct_bs(ct_bs), _g1p(_g1->g1_policy()),
     _cg1r(g1->concurrent_g1_refine()),
     _cset_rs_update_cl(NULL),
-    _cards_scanned(NULL), _total_cards_scanned(0)
+    _cards_scanned(NULL), _total_cards_scanned(0),
+    _prev_period_summary()
 {
   _seq_task = new SubTasksDone(NumSeqTasks);
   guarantee(n_workers() > 0, "There should be some workers");
@@ -81,6 +83,9 @@
   for (uint i = 0; i < n_workers(); i++) {
     _cset_rs_update_cl[i] = NULL;
   }
+  if (G1SummarizeRSetStats) {
+    _prev_period_summary.initialize(this);
+  }
 }
 
 G1RemSet::~G1RemSet() {
@@ -101,15 +106,25 @@
 class ScanRSClosure : public HeapRegionClosure {
   size_t _cards_done, _cards;
   G1CollectedHeap* _g1h;
+
   OopsInHeapRegionClosure* _oc;
+  CodeBlobToOopClosure* _code_root_cl;
+
   G1BlockOffsetSharedArray* _bot_shared;
-  CardTableModRefBS *_ct_bs;
-  int _worker_i;
-  int _block_size;
-  bool _try_claimed;
+  G1SATBCardTableModRefBS *_ct_bs;
+
+  double _strong_code_root_scan_time_sec;
+  int    _worker_i;
+  int    _block_size;
+  bool   _try_claimed;
+
 public:
-  ScanRSClosure(OopsInHeapRegionClosure* oc, int worker_i) :
+  ScanRSClosure(OopsInHeapRegionClosure* oc,
+                CodeBlobToOopClosure* code_root_cl,
+                int worker_i) :
     _oc(oc),
+    _code_root_cl(code_root_cl),
+    _strong_code_root_scan_time_sec(0.0),
     _cards(0),
     _cards_done(0),
     _worker_i(worker_i),
@@ -117,7 +132,7 @@
   {
     _g1h = G1CollectedHeap::heap();
     _bot_shared = _g1h->bot_shared();
-    _ct_bs = (CardTableModRefBS*) (_g1h->barrier_set());
+    _ct_bs = _g1h->g1_barrier_set();
     _block_size = MAX2<int>(G1RSetScanBlockSize, 1);
   }
 
@@ -157,6 +172,12 @@
                            card_start, card_start + G1BlockOffsetSharedArray::N_words);
   }
 
+  void scan_strong_code_roots(HeapRegion* r) {
+    double scan_start = os::elapsedTime();
+    r->strong_code_roots_do(_code_root_cl);
+    _strong_code_root_scan_time_sec += (os::elapsedTime() - scan_start);
+  }
+
   bool doHeapRegion(HeapRegion* r) {
     assert(r->in_collection_set(), "should only be called on elements of CS.");
     HeapRegionRemSet* hrrs = r->rem_set();
@@ -170,6 +191,7 @@
     //   _try_claimed || r->claim_iter()
     // is true: either we're supposed to work on claimed-but-not-complete
     // regions, or we successfully claimed the region.
+
     HeapRegionRemSetIterator* iter = _g1h->rem_set_iterator(_worker_i);
     hrrs->init_iterator(iter);
     size_t card_index;
@@ -203,30 +225,43 @@
       }
     }
     if (!_try_claimed) {
+      // Scan the strong code root list attached to the current region
+      scan_strong_code_roots(r);
+
       hrrs->set_iter_complete();
     }
     return false;
   }
+
+  double strong_code_root_scan_time_sec() {
+    return _strong_code_root_scan_time_sec;
+  }
+
   size_t cards_done() { return _cards_done;}
   size_t cards_looked_up() { return _cards;}
 };
 
-void G1RemSet::scanRS(OopsInHeapRegionClosure* oc, int worker_i) {
+void G1RemSet::scanRS(OopsInHeapRegionClosure* oc,
+                      CodeBlobToOopClosure* code_root_cl,
+                      int worker_i) {
   double rs_time_start = os::elapsedTime();
   HeapRegion *startRegion = _g1->start_cset_region_for_worker(worker_i);
 
-  ScanRSClosure scanRScl(oc, worker_i);
+  ScanRSClosure scanRScl(oc, code_root_cl, worker_i);
 
   _g1->collection_set_iterate_from(startRegion, &scanRScl);
   scanRScl.set_try_claimed();
   _g1->collection_set_iterate_from(startRegion, &scanRScl);
 
-  double scan_rs_time_sec = os::elapsedTime() - rs_time_start;
+  double scan_rs_time_sec = (os::elapsedTime() - rs_time_start)
+                            - scanRScl.strong_code_root_scan_time_sec();
 
-  assert( _cards_scanned != NULL, "invariant" );
+  assert(_cards_scanned != NULL, "invariant");
   _cards_scanned[worker_i] = scanRScl.cards_done();
 
   _g1p->phase_times()->record_scan_rs_time(worker_i, scan_rs_time_sec * 1000.0);
+  _g1p->phase_times()->record_strong_code_root_scan_time(worker_i,
+                                                         scanRScl.strong_code_root_scan_time_sec() * 1000.0);
 }
 
 // Closure used for updating RSets and recording references that
@@ -286,7 +321,8 @@
 }
 
 void G1RemSet::oops_into_collection_set_do(OopsInHeapRegionClosure* oc,
-                                             int worker_i) {
+                                           CodeBlobToOopClosure* code_root_cl,
+                                           int worker_i) {
 #if CARD_REPEAT_HISTO
   ct_freq_update_histo_and_reset();
 #endif
@@ -326,7 +362,7 @@
     _g1p->phase_times()->record_update_rs_time(worker_i, 0.0);
   }
   if (G1UseParallelRSetScanning || (worker_i == 0)) {
-    scanRS(oc, worker_i);
+    scanRS(oc, code_root_cl, worker_i);
   } else {
     _g1p->phase_times()->record_scan_rs_time(worker_i, 0.0);
   }
@@ -472,12 +508,7 @@
   ScrubRSClosure(BitMap* region_bm, BitMap* card_bm) :
     _g1h(G1CollectedHeap::heap()),
     _region_bm(region_bm), _card_bm(card_bm),
-    _ctbs(NULL)
-  {
-    ModRefBarrierSet* bs = _g1h->mr_bs();
-    guarantee(bs->is_a(BarrierSet::CardTableModRef), "Precondition");
-    _ctbs = (CardTableModRefBS*)bs;
-  }
+    _ctbs(_g1h->g1_barrier_set()) {}
 
   bool doHeapRegion(HeapRegion* r) {
     if (!r->continuesHumongous()) {
@@ -700,47 +731,29 @@
   return has_refs_into_cset;
 }
 
-class HRRSStatsIter: public HeapRegionClosure {
-  size_t _occupied;
-  size_t _total_mem_sz;
-  size_t _max_mem_sz;
-  HeapRegion* _max_mem_sz_region;
-public:
-  HRRSStatsIter() :
-    _occupied(0),
-    _total_mem_sz(0),
-    _max_mem_sz(0),
-    _max_mem_sz_region(NULL)
-  {}
+void G1RemSet::print_periodic_summary_info(const char* header) {
+  G1RemSetSummary current;
+  current.initialize(this);
 
-  bool doHeapRegion(HeapRegion* r) {
-    if (r->continuesHumongous()) return false;
-    size_t mem_sz = r->rem_set()->mem_size();
-    if (mem_sz > _max_mem_sz) {
-      _max_mem_sz = mem_sz;
-      _max_mem_sz_region = r;
-    }
-    _total_mem_sz += mem_sz;
-    size_t occ = r->rem_set()->occupied();
-    _occupied += occ;
-    return false;
-  }
-  size_t total_mem_sz() { return _total_mem_sz; }
-  size_t max_mem_sz() { return _max_mem_sz; }
-  size_t occupied() { return _occupied; }
-  HeapRegion* max_mem_sz_region() { return _max_mem_sz_region; }
-};
+  _prev_period_summary.subtract_from(&current);
+  print_summary_info(&_prev_period_summary, header);
 
-class PrintRSThreadVTimeClosure : public ThreadClosure {
-public:
-  virtual void do_thread(Thread *t) {
-    ConcurrentG1RefineThread* crt = (ConcurrentG1RefineThread*) t;
-    gclog_or_tty->print("    %5.2f", crt->vtime_accum());
-  }
-};
+  _prev_period_summary.set(&current);
+}
 
 void G1RemSet::print_summary_info() {
-  G1CollectedHeap* g1 = G1CollectedHeap::heap();
+  G1RemSetSummary current;
+  current.initialize(this);
+
+  print_summary_info(&current, " Cumulative RS summary");
+}
+
+void G1RemSet::print_summary_info(G1RemSetSummary * summary, const char * header) {
+  assert(summary != NULL, "just checking");
+
+  if (header != NULL) {
+    gclog_or_tty->print_cr("%s", header);
+  }
 
 #if CARD_REPEAT_HISTO
   gclog_or_tty->print_cr("\nG1 card_repeat count histogram: ");
@@ -748,52 +761,13 @@
   card_repeat_count.print_on(gclog_or_tty);
 #endif
 
-  gclog_or_tty->print_cr("\n Concurrent RS processed %d cards",
-                         _conc_refine_cards);
-  DirtyCardQueueSet& dcqs = JavaThread::dirty_card_queue_set();
-  jint tot_processed_buffers =
-    dcqs.processed_buffers_mut() + dcqs.processed_buffers_rs_thread();
-  gclog_or_tty->print_cr("  Of %d completed buffers:", tot_processed_buffers);
-  gclog_or_tty->print_cr("     %8d (%5.1f%%) by conc RS threads.",
-                dcqs.processed_buffers_rs_thread(),
-                100.0*(float)dcqs.processed_buffers_rs_thread()/
-                (float)tot_processed_buffers);
-  gclog_or_tty->print_cr("     %8d (%5.1f%%) by mutator threads.",
-                dcqs.processed_buffers_mut(),
-                100.0*(float)dcqs.processed_buffers_mut()/
-                (float)tot_processed_buffers);
-  gclog_or_tty->print_cr("  Conc RS threads times(s)");
-  PrintRSThreadVTimeClosure p;
-  gclog_or_tty->print("     ");
-  g1->concurrent_g1_refine()->threads_do(&p);
-  gclog_or_tty->print_cr("");
-
-  HRRSStatsIter blk;
-  g1->heap_region_iterate(&blk);
-  gclog_or_tty->print_cr("  Total heap region rem set sizes = "SIZE_FORMAT"K."
-                         "  Max = "SIZE_FORMAT"K.",
-                         blk.total_mem_sz()/K, blk.max_mem_sz()/K);
-  gclog_or_tty->print_cr("  Static structures = "SIZE_FORMAT"K,"
-                         " free_lists = "SIZE_FORMAT"K.",
-                         HeapRegionRemSet::static_mem_size() / K,
-                         HeapRegionRemSet::fl_mem_size() / K);
-  gclog_or_tty->print_cr("    "SIZE_FORMAT" occupied cards represented.",
-                         blk.occupied());
-  HeapRegion* max_mem_sz_region = blk.max_mem_sz_region();
-  HeapRegionRemSet* rem_set = max_mem_sz_region->rem_set();
-  gclog_or_tty->print_cr("    Max size region = "HR_FORMAT", "
-                         "size = "SIZE_FORMAT "K, occupied = "SIZE_FORMAT"K.",
-                         HR_FORMAT_PARAMS(max_mem_sz_region),
-                         (rem_set->mem_size() + K - 1)/K,
-                         (rem_set->occupied() + K - 1)/K);
-  gclog_or_tty->print_cr("    Did %d coarsenings.",
-                         HeapRegionRemSet::n_coarsenings());
+  summary->print_on(gclog_or_tty);
 }
 
 void G1RemSet::prepare_for_verify() {
   if (G1HRRSFlushLogBuffersOnVerify &&
       (VerifyBeforeGC || VerifyAfterGC)
-      &&  !_g1->full_collection()) {
+      &&  (!_g1->full_collection() || G1VerifyRSetsDuringFullGC)) {
     cleanupHRRS();
     _g1->set_refine_cte_cl_concurrency(false);
     if (SafepointSynchronize::is_at_safepoint()) {
--- ./hotspot/src/share/vm/gc_implementation/g1/g1RemSet.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/gc_implementation/g1/g1RemSet.hpp	Wed May 07 19:26:16 2014 -0700
@@ -25,6 +25,8 @@
 #ifndef SHARE_VM_GC_IMPLEMENTATION_G1_G1REMSET_HPP
 #define SHARE_VM_GC_IMPLEMENTATION_G1_G1REMSET_HPP
 
+#include "gc_implementation/g1/g1RemSetSummary.hpp"
+
 // A G1RemSet provides ways of iterating over pointers into a selected
 // collection set.
 
@@ -37,9 +39,11 @@
 // so that they can be used to update the individual region remsets.
 
 class G1RemSet: public CHeapObj<mtGC> {
+private:
+  G1RemSetSummary _prev_period_summary;
 protected:
   G1CollectedHeap* _g1;
-  unsigned _conc_refine_cards;
+  size_t _conc_refine_cards;
   uint n_workers();
 
 protected:
@@ -66,6 +70,8 @@
   // references into the collection set.
   OopsInHeapRegionClosure** _cset_rs_update_cl;
 
+  // Print the given summary info
+  virtual void print_summary_info(G1RemSetSummary * summary, const char * header = NULL);
 public:
   // This is called to reset dual hash tables after the gc pause
   // is finished and the initial hash table is no longer being
@@ -75,14 +81,23 @@
   G1RemSet(G1CollectedHeap* g1, CardTableModRefBS* ct_bs);
   ~G1RemSet();
 
-  // Invoke "blk->do_oop" on all pointers into the CS in objects in regions
-  // outside the CS (having invoked "blk->set_region" to set the "from"
-  // region correctly beforehand.) The "worker_i" param is for the
-  // parallel case where the number of the worker thread calling this
-  // function can be helpful in partitioning the work to be done. It
-  // should be the same as the "i" passed to the calling thread's
-  // work(i) function. In the sequential case this param will be ingored.
-  void oops_into_collection_set_do(OopsInHeapRegionClosure* blk, int worker_i);
+  // Invoke "blk->do_oop" on all pointers into the collection set
+  // from objects in regions outside the collection set (having
+  // invoked "blk->set_region" to set the "from" region correctly
+  // beforehand.)
+  //
+  // Invoke code_root_cl->do_code_blob on the unmarked nmethods
+  // on the strong code roots list for each region in the
+  // collection set.
+  //
+  // The "worker_i" param is for the parallel case where the id
+  // of the worker thread calling this function can be helpful in
+  // partitioning the work to be done. It should be the same as
+  // the "i" passed to the calling thread's work(i) function.
+  // In the sequential case this param will be ignored.
+  void oops_into_collection_set_do(OopsInHeapRegionClosure* blk,
+                                   CodeBlobToOopClosure* code_root_cl,
+                                   int worker_i);
 
   // Prepare for and cleanup after an oops_into_collection_set_do
   // call.  Must call each of these once before and after (in sequential
@@ -92,7 +107,10 @@
   void prepare_for_oops_into_collection_set_do();
   void cleanup_after_oops_into_collection_set_do();
 
-  void scanRS(OopsInHeapRegionClosure* oc, int worker_i);
+  void scanRS(OopsInHeapRegionClosure* oc,
+              CodeBlobToOopClosure* code_root_cl,
+              int worker_i);
+
   void updateRS(DirtyCardQueue* into_cset_dcq, int worker_i);
 
   CardTableModRefBS* ct_bs() { return _ct_bs; }
@@ -123,11 +141,18 @@
                            int worker_i,
                            bool check_for_refs_into_cset);
 
-  // Print any relevant summary info.
+  // Print accumulated summary info from the start of the VM.
   virtual void print_summary_info();
 
+  // Print accumulated summary info from the last time called.
+  virtual void print_periodic_summary_info(const char* header);
+
   // Prepare remembered set for verification.
   virtual void prepare_for_verify();
+
+  size_t conc_refine_cards() const {
+    return _conc_refine_cards;
+  }
 };
 
 class CountNonCleanMemRegionClosure: public MemRegionClosure {
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/src/share/vm/gc_implementation/g1/g1RemSetSummary.cpp	Wed May 07 19:26:16 2014 -0700
@@ -0,0 +1,354 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#include "precompiled.hpp"
+#include "gc_implementation/g1/concurrentG1Refine.hpp"
+#include "gc_implementation/g1/concurrentG1RefineThread.hpp"
+#include "gc_implementation/g1/heapRegion.hpp"
+#include "gc_implementation/g1/g1CollectedHeap.inline.hpp"
+#include "gc_implementation/g1/g1RemSet.inline.hpp"
+#include "gc_implementation/g1/g1RemSetSummary.hpp"
+#include "gc_implementation/g1/heapRegionRemSet.hpp"
+#include "runtime/thread.hpp"
+
+class GetRSThreadVTimeClosure : public ThreadClosure {
+private:
+  G1RemSetSummary* _summary;
+  uint _counter;
+
+public:
+  GetRSThreadVTimeClosure(G1RemSetSummary * summary) : ThreadClosure(), _summary(summary), _counter(0) {
+    assert(_summary != NULL, "just checking");
+  }
+
+  virtual void do_thread(Thread* t) {
+    ConcurrentG1RefineThread* crt = (ConcurrentG1RefineThread*) t;
+    _summary->set_rs_thread_vtime(_counter, crt->vtime_accum());
+    _counter++;
+  }
+};
+
+void G1RemSetSummary::update() {
+  _num_refined_cards = remset()->conc_refine_cards();
+  DirtyCardQueueSet& dcqs = JavaThread::dirty_card_queue_set();
+  _num_processed_buf_mutator = dcqs.processed_buffers_mut();
+  _num_processed_buf_rs_threads = dcqs.processed_buffers_rs_thread();
+
+  _num_coarsenings = HeapRegionRemSet::n_coarsenings();
+
+  ConcurrentG1Refine * cg1r = G1CollectedHeap::heap()->concurrent_g1_refine();
+  if (_rs_threads_vtimes != NULL) {
+    GetRSThreadVTimeClosure p(this);
+    cg1r->worker_threads_do(&p);
+  }
+  set_sampling_thread_vtime(cg1r->sampling_thread()->vtime_accum());
+}
+
+void G1RemSetSummary::set_rs_thread_vtime(uint thread, double value) {
+  assert(_rs_threads_vtimes != NULL, "just checking");
+  assert(thread < _num_vtimes, "just checking");
+  _rs_threads_vtimes[thread] = value;
+}
+
+double G1RemSetSummary::rs_thread_vtime(uint thread) const {
+  assert(_rs_threads_vtimes != NULL, "just checking");
+  assert(thread < _num_vtimes, "just checking");
+  return _rs_threads_vtimes[thread];
+}
+
+void G1RemSetSummary::initialize(G1RemSet* remset) {
+  assert(_rs_threads_vtimes == NULL, "just checking");
+  assert(remset != NULL, "just checking");
+
+  _remset = remset;
+  _num_vtimes = ConcurrentG1Refine::thread_num();
+  _rs_threads_vtimes = NEW_C_HEAP_ARRAY(double, _num_vtimes, mtGC);
+  memset(_rs_threads_vtimes, 0, sizeof(double) * _num_vtimes);
+
+  update();
+}
+
+void G1RemSetSummary::set(G1RemSetSummary* other) {
+  assert(other != NULL, "just checking");
+  assert(remset() == other->remset(), "just checking");
+  assert(_num_vtimes == other->_num_vtimes, "just checking");
+
+  _num_refined_cards = other->num_concurrent_refined_cards();
+
+  _num_processed_buf_mutator = other->num_processed_buf_mutator();
+  _num_processed_buf_rs_threads = other->num_processed_buf_rs_threads();
+
+  _num_coarsenings = other->_num_coarsenings;
+
+  memcpy(_rs_threads_vtimes, other->_rs_threads_vtimes, sizeof(double) * _num_vtimes);
+
+  set_sampling_thread_vtime(other->sampling_thread_vtime());
+}
+
+void G1RemSetSummary::subtract_from(G1RemSetSummary* other) {
+  assert(other != NULL, "just checking");
+  assert(remset() == other->remset(), "just checking");
+  assert(_num_vtimes == other->_num_vtimes, "just checking");
+
+  _num_refined_cards = other->num_concurrent_refined_cards() - _num_refined_cards;
+
+  _num_processed_buf_mutator = other->num_processed_buf_mutator() - _num_processed_buf_mutator;
+  _num_processed_buf_rs_threads = other->num_processed_buf_rs_threads() - _num_processed_buf_rs_threads;
+
+  _num_coarsenings = other->num_coarsenings() - _num_coarsenings;
+
+  for (uint i = 0; i < _num_vtimes; i++) {
+    set_rs_thread_vtime(i, other->rs_thread_vtime(i) - rs_thread_vtime(i));
+  }
+
+  _sampling_thread_vtime = other->sampling_thread_vtime() - _sampling_thread_vtime;
+}
+
+static double percent_of(size_t numerator, size_t denominator) {
+  if (denominator != 0) {
+    return (double)numerator / denominator * 100.0f;
+  } else {
+    return 0.0f;
+  }
+}
+
+static size_t round_to_K(size_t value) {
+  return value / K;
+}
+
+class RegionTypeCounter VALUE_OBJ_CLASS_SPEC {
+private:
+  const char* _name;
+
+  size_t _rs_mem_size;
+  size_t _cards_occupied;
+  size_t _amount;
+
+  size_t _code_root_mem_size;
+  size_t _code_root_elems;
+
+  double rs_mem_size_percent_of(size_t total) {
+    return percent_of(_rs_mem_size, total);
+  }
+
+  double cards_occupied_percent_of(size_t total) {
+    return percent_of(_cards_occupied, total);
+  }
+
+  double code_root_mem_size_percent_of(size_t total) {
+    return percent_of(_code_root_mem_size, total);
+  }
+
+  double code_root_elems_percent_of(size_t total) {
+    return percent_of(_code_root_elems, total);
+  }
+
+  size_t amount() const { return _amount; }
+
+public:
+
+  RegionTypeCounter(const char* name) : _name(name), _rs_mem_size(0), _cards_occupied(0),
+    _amount(0), _code_root_mem_size(0), _code_root_elems(0) { }
+
+  void add(size_t rs_mem_size, size_t cards_occupied, size_t code_root_mem_size,
+    size_t code_root_elems) {
+    _rs_mem_size += rs_mem_size;
+    _cards_occupied += cards_occupied;
+    _code_root_mem_size += code_root_mem_size;
+    _code_root_elems += code_root_elems;
+    _amount++;
+  }
+
+  size_t rs_mem_size() const { return _rs_mem_size; }
+  size_t cards_occupied() const { return _cards_occupied; }
+
+  size_t code_root_mem_size() const { return _code_root_mem_size; }
+  size_t code_root_elems() const { return _code_root_elems; }
+
+  void print_rs_mem_info_on(outputStream * out, size_t total) {
+    out->print_cr("    "SIZE_FORMAT_W(8)"K (%5.1f%%) by "SIZE_FORMAT" %s regions",
+        round_to_K(rs_mem_size()), rs_mem_size_percent_of(total), amount(), _name);
+  }
+
+  void print_cards_occupied_info_on(outputStream * out, size_t total) {
+    out->print_cr("     "SIZE_FORMAT_W(8)" (%5.1f%%) entries by "SIZE_FORMAT" %s regions",
+        cards_occupied(), cards_occupied_percent_of(total), amount(), _name);
+  }
+
+  void print_code_root_mem_info_on(outputStream * out, size_t total) {
+    out->print_cr("    "SIZE_FORMAT_W(8)"K (%5.1f%%) by "SIZE_FORMAT" %s regions",
+        round_to_K(code_root_mem_size()), code_root_mem_size_percent_of(total), amount(), _name);
+  }
+
+  void print_code_root_elems_info_on(outputStream * out, size_t total) {
+    out->print_cr("     "SIZE_FORMAT_W(8)" (%5.1f%%) elements by "SIZE_FORMAT" %s regions",
+        code_root_elems(), code_root_elems_percent_of(total), amount(), _name);
+  }
+};
+
+
+class HRRSStatsIter: public HeapRegionClosure {
+private:
+  RegionTypeCounter _young;
+  RegionTypeCounter _humonguous;
+  RegionTypeCounter _free;
+  RegionTypeCounter _old;
+  RegionTypeCounter _all;
+
+  size_t _max_rs_mem_sz;
+  HeapRegion* _max_rs_mem_sz_region;
+
+  size_t total_rs_mem_sz() const            { return _all.rs_mem_size(); }
+  size_t total_cards_occupied() const       { return _all.cards_occupied(); }
+
+  size_t max_rs_mem_sz() const              { return _max_rs_mem_sz; }
+  HeapRegion* max_rs_mem_sz_region() const  { return _max_rs_mem_sz_region; }
+
+  size_t _max_code_root_mem_sz;
+  HeapRegion* _max_code_root_mem_sz_region;
+
+  size_t total_code_root_mem_sz() const     { return _all.code_root_mem_size(); }
+  size_t total_code_root_elems() const      { return _all.code_root_elems(); }
+
+  size_t max_code_root_mem_sz() const       { return _max_code_root_mem_sz; }
+  HeapRegion* max_code_root_mem_sz_region() const { return _max_code_root_mem_sz_region; }
+
+public:
+  HRRSStatsIter() : _all("All"), _young("Young"), _humonguous("Humonguous"),
+    _free("Free"), _old("Old"), _max_code_root_mem_sz_region(NULL), _max_rs_mem_sz_region(NULL),
+    _max_rs_mem_sz(0), _max_code_root_mem_sz(0)
+  {}
+
+  bool doHeapRegion(HeapRegion* r) {
+    HeapRegionRemSet* hrrs = r->rem_set();
+
+    // HeapRegionRemSet::mem_size() includes the
+    // size of the strong code roots
+    size_t rs_mem_sz = hrrs->mem_size();
+    if (rs_mem_sz > _max_rs_mem_sz) {
+      _max_rs_mem_sz = rs_mem_sz;
+      _max_rs_mem_sz_region = r;
+    }
+    size_t occupied_cards = hrrs->occupied();
+    size_t code_root_mem_sz = hrrs->strong_code_roots_mem_size();
+    if (code_root_mem_sz > max_code_root_mem_sz()) {
+      _max_code_root_mem_sz_region = r;
+    }
+    size_t code_root_elems = hrrs->strong_code_roots_list_length();
+
+    RegionTypeCounter* current = NULL;
+    if (r->is_young()) {
+      current = &_young;
+    } else if (r->isHumongous()) {
+      current = &_humonguous;
+    } else if (r->is_empty()) {
+      current = &_free;
+    } else {
+      current = &_old;
+    }
+    current->add(rs_mem_sz, occupied_cards, code_root_mem_sz, code_root_elems);
+    _all.add(rs_mem_sz, occupied_cards, code_root_mem_sz, code_root_elems);
+
+    return false;
+  }
+
+  void print_summary_on(outputStream* out) {
+    RegionTypeCounter* counters[] = { &_young, &_humonguous, &_free, &_old, NULL };
+
+    out->print_cr("\n Current rem set statistics");
+    out->print_cr("  Total per region rem sets sizes = "SIZE_FORMAT"K."
+                  " Max = "SIZE_FORMAT"K.",
+                  round_to_K(total_rs_mem_sz()), round_to_K(max_rs_mem_sz()));
+    for (RegionTypeCounter** current = &counters[0]; *current != NULL; current++) {
+      (*current)->print_rs_mem_info_on(out, total_rs_mem_sz());
+    }
+
+    out->print_cr("   Static structures = "SIZE_FORMAT"K,"
+                  " free_lists = "SIZE_FORMAT"K.",
+                  round_to_K(HeapRegionRemSet::static_mem_size()),
+                  round_to_K(HeapRegionRemSet::fl_mem_size()));
+
+    out->print_cr("    "SIZE_FORMAT" occupied cards represented.",
+                  total_cards_occupied());
+    for (RegionTypeCounter** current = &counters[0]; *current != NULL; current++) {
+      (*current)->print_cards_occupied_info_on(out, total_cards_occupied());
+    }
+
+    // Largest sized rem set region statistics
+    HeapRegionRemSet* rem_set = max_rs_mem_sz_region()->rem_set();
+    out->print_cr("    Region with largest rem set = "HR_FORMAT", "
+                  "size = "SIZE_FORMAT "K, occupied = "SIZE_FORMAT"K.",
+                  HR_FORMAT_PARAMS(max_rs_mem_sz_region()),
+                  round_to_K(rem_set->mem_size()),
+                  round_to_K(rem_set->occupied()));
+
+    // Strong code root statistics
+    HeapRegionRemSet* max_code_root_rem_set = max_code_root_mem_sz_region()->rem_set();
+    out->print_cr("  Total heap region code root sets sizes = "SIZE_FORMAT"K."
+                  "  Max = "SIZE_FORMAT"K.",
+                  round_to_K(total_code_root_mem_sz()),
+                  round_to_K(max_code_root_rem_set->strong_code_roots_mem_size()));
+    for (RegionTypeCounter** current = &counters[0]; *current != NULL; current++) {
+      (*current)->print_code_root_mem_info_on(out, total_code_root_mem_sz());
+    }
+
+    out->print_cr("    "SIZE_FORMAT" code roots represented.",
+                  total_code_root_elems());
+    for (RegionTypeCounter** current = &counters[0]; *current != NULL; current++) {
+      (*current)->print_code_root_elems_info_on(out, total_code_root_elems());
+    }
+
+    out->print_cr("    Region with largest amount of code roots = "HR_FORMAT", "
+                  "size = "SIZE_FORMAT "K, num_elems = "SIZE_FORMAT".",
+                  HR_FORMAT_PARAMS(max_code_root_mem_sz_region()),
+                  round_to_K(max_code_root_rem_set->strong_code_roots_mem_size()),
+                  round_to_K(max_code_root_rem_set->strong_code_roots_list_length()));
+  }
+};
+
+void G1RemSetSummary::print_on(outputStream* out) {
+  out->print_cr("\n Recent concurrent refinement statistics");
+  out->print_cr("  Processed "SIZE_FORMAT" cards",
+                num_concurrent_refined_cards());
+  out->print_cr("  Of "SIZE_FORMAT" completed buffers:", num_processed_buf_total());
+  out->print_cr("     "SIZE_FORMAT_W(8)" (%5.1f%%) by concurrent RS threads.",
+                num_processed_buf_total(),
+                percent_of(num_processed_buf_rs_threads(), num_processed_buf_total()));
+  out->print_cr("     "SIZE_FORMAT_W(8)" (%5.1f%%) by mutator threads.",
+                num_processed_buf_mutator(),
+                percent_of(num_processed_buf_mutator(), num_processed_buf_total()));
+  out->print_cr("  Did "SIZE_FORMAT" coarsenings.", num_coarsenings());
+  out->print_cr("  Concurrent RS threads times (s)");
+  out->print("     ");
+  for (uint i = 0; i < _num_vtimes; i++) {
+    out->print("    %5.2f", rs_thread_vtime(i));
+  }
+  out->cr();
+  out->print_cr("  Concurrent sampling threads times (s)");
+  out->print_cr("         %5.2f", sampling_thread_vtime());
+
+  HRRSStatsIter blk;
+  G1CollectedHeap::heap()->heap_region_iterate(&blk);
+  blk.print_summary_on(out);
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/src/share/vm/gc_implementation/g1/g1RemSetSummary.hpp	Wed May 07 19:26:16 2014 -0700
@@ -0,0 +1,118 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef SHARE_VM_GC_IMPLEMENTATION_G1_G1REMSETSUMMARY_HPP
+#define SHARE_VM_GC_IMPLEMENTATION_G1_G1REMSETSUMMARY_HPP
+
+#include "utilities/ostream.hpp"
+
+class G1RemSet;
+
+// A G1RemSetSummary manages statistical information about the G1RemSet
+
+class G1RemSetSummary VALUE_OBJ_CLASS_SPEC {
+private:
+  friend class GetRSThreadVTimeClosure;
+
+  G1RemSet* _remset;
+
+  G1RemSet* remset() const {
+    return _remset;
+  }
+
+  size_t _num_refined_cards;
+  size_t _num_processed_buf_mutator;
+  size_t _num_processed_buf_rs_threads;
+
+  size_t _num_coarsenings;
+
+  double* _rs_threads_vtimes;
+  size_t _num_vtimes;
+
+  double _sampling_thread_vtime;
+
+  void set_rs_thread_vtime(uint thread, double value);
+  void set_sampling_thread_vtime(double value) {
+    _sampling_thread_vtime = value;
+  }
+
+  void free_and_null() {
+    if (_rs_threads_vtimes) {
+      FREE_C_HEAP_ARRAY(double, _rs_threads_vtimes, mtGC);
+      _rs_threads_vtimes = NULL;
+      _num_vtimes = 0;
+    }
+  }
+
+  // update this summary with current data from various places
+  void update();
+
+public:
+  G1RemSetSummary() : _remset(NULL), _num_refined_cards(0),
+    _num_processed_buf_mutator(0), _num_processed_buf_rs_threads(0), _num_coarsenings(0),
+    _rs_threads_vtimes(NULL), _num_vtimes(0), _sampling_thread_vtime(0.0f) {
+  }
+
+  ~G1RemSetSummary() {
+    free_and_null();
+  }
+
+  // set the counters in this summary to the values of the others
+  void set(G1RemSetSummary* other);
+  // subtract all counters from the other summary, and set them in the current
+  void subtract_from(G1RemSetSummary* other);
+
+  // initialize and get the first sampling
+  void initialize(G1RemSet* remset);
+
+  void print_on(outputStream* out);
+
+  double rs_thread_vtime(uint thread) const;
+
+  double sampling_thread_vtime() const {
+    return _sampling_thread_vtime;
+  }
+
+  size_t num_concurrent_refined_cards() const {
+    return _num_refined_cards;
+  }
+
+  size_t num_processed_buf_mutator() const {
+    return _num_processed_buf_mutator;
+  }
+
+  size_t num_processed_buf_rs_threads() const {
+    return _num_processed_buf_rs_threads;
+  }
+
+  size_t num_processed_buf_total() const {
+    return num_processed_buf_mutator() + num_processed_buf_rs_threads();
+  }
+
+  size_t num_coarsenings() const {
+    return _num_coarsenings;
+  }
+};
+
+#endif // SHARE_VM_GC_IMPLEMENTATION_G1_G1REMSETSUMMARY_HPP
--- ./hotspot/src/share/vm/gc_implementation/g1/g1SATBCardTableModRefBS.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/gc_implementation/g1/g1SATBCardTableModRefBS.cpp	Wed May 07 19:26:16 2014 -0700
@@ -76,6 +76,46 @@
   }
 }
 
+bool G1SATBCardTableModRefBS::mark_card_deferred(size_t card_index) {
+  jbyte val = _byte_map[card_index];
+  // It's already processed
+  if ((val & (clean_card_mask_val() | deferred_card_val())) == deferred_card_val()) {
+    return false;
+  }
+
+  if  (val == g1_young_gen) {
+    // the card is for a young gen region. We don't need to keep track of all pointers into young
+    return false;
+  }
+
+  // Cached bit can be installed either on a clean card or on a claimed card.
+  jbyte new_val = val;
+  if (val == clean_card_val()) {
+    new_val = (jbyte)deferred_card_val();
+  } else {
+    if (val & claimed_card_val()) {
+      new_val = val | (jbyte)deferred_card_val();
+    }
+  }
+  if (new_val != val) {
+    Atomic::cmpxchg(new_val, &_byte_map[card_index], val);
+  }
+  return true;
+}
+
+void G1SATBCardTableModRefBS::g1_mark_as_young(const MemRegion& mr) {
+  jbyte *const first = byte_for(mr.start());
+  jbyte *const last = byte_after(mr.last());
+
+  memset(first, g1_young_gen, last - first);
+}
+
+#ifndef PRODUCT
+void G1SATBCardTableModRefBS::verify_g1_young_region(MemRegion mr) {
+  verify_region(mr, g1_young_gen,  true);
+}
+#endif
+
 G1SATBCardTableLoggingModRefBS::
 G1SATBCardTableLoggingModRefBS(MemRegion whole_heap,
                                int max_covered_regions) :
@@ -88,7 +128,11 @@
 void
 G1SATBCardTableLoggingModRefBS::write_ref_field_work(void* field,
                                                      oop new_val) {
-  jbyte* byte = byte_for(field);
+  volatile jbyte* byte = byte_for(field);
+  if (*byte == g1_young_gen) {
+    return;
+  }
+  OrderAccess::storeload();
   if (*byte != dirty_card) {
     *byte = dirty_card;
     Thread* thr = Thread::current();
@@ -120,7 +164,7 @@
 
 void
 G1SATBCardTableLoggingModRefBS::invalidate(MemRegion mr, bool whole_heap) {
-  jbyte* byte = byte_for(mr.start());
+  volatile jbyte* byte = byte_for(mr.start());
   jbyte* last_byte = byte_for(mr.last());
   Thread* thr = Thread::current();
   if (whole_heap) {
@@ -129,25 +173,35 @@
       byte++;
     }
   } else {
-    // Enqueue if necessary.
-    if (thr->is_Java_thread()) {
-      JavaThread* jt = (JavaThread*)thr;
-      while (byte <= last_byte) {
-        if (*byte != dirty_card) {
-          *byte = dirty_card;
-          jt->dirty_card_queue().enqueue(byte);
+    // skip all consecutive young cards
+    for (; byte <= last_byte && *byte == g1_young_gen; byte++);
+
+    if (byte <= last_byte) {
+      OrderAccess::storeload();
+      // Enqueue if necessary.
+      if (thr->is_Java_thread()) {
+        JavaThread* jt = (JavaThread*)thr;
+        for (; byte <= last_byte; byte++) {
+          if (*byte == g1_young_gen) {
+            continue;
+          }
+          if (*byte != dirty_card) {
+            *byte = dirty_card;
+            jt->dirty_card_queue().enqueue(byte);
+          }
         }
-        byte++;
-      }
-    } else {
-      MutexLockerEx x(Shared_DirtyCardQ_lock,
-                      Mutex::_no_safepoint_check_flag);
-      while (byte <= last_byte) {
-        if (*byte != dirty_card) {
-          *byte = dirty_card;
-          _dcqs.shared_dirty_card_queue()->enqueue(byte);
+      } else {
+        MutexLockerEx x(Shared_DirtyCardQ_lock,
+                        Mutex::_no_safepoint_check_flag);
+        for (; byte <= last_byte; byte++) {
+          if (*byte == g1_young_gen) {
+            continue;
+          }
+          if (*byte != dirty_card) {
+            *byte = dirty_card;
+            _dcqs.shared_dirty_card_queue()->enqueue(byte);
+          }
         }
-        byte++;
       }
     }
   }
--- ./hotspot/src/share/vm/gc_implementation/g1/g1SATBCardTableModRefBS.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/gc_implementation/g1/g1SATBCardTableModRefBS.hpp	Wed May 07 19:26:16 2014 -0700
@@ -37,7 +37,14 @@
 // snapshot-at-the-beginning marking.
 
 class G1SATBCardTableModRefBS: public CardTableModRefBSForCTRS {
+protected:
+  enum G1CardValues {
+    g1_young_gen = CT_MR_BS_last_reserved << 1
+  };
+
 public:
+  static int g1_young_card_val()   { return g1_young_gen; }
+
   // Add "pre_val" to a set of objects that may have been disconnected from the
   // pre-marking object graph.
   static void enqueue(oop pre_val);
@@ -88,6 +95,45 @@
       write_ref_array_pre_work(dst, count);
     }
   }
+
+/*
+   Claimed and deferred bits are used together in G1 during the evacuation
+   pause. These bits can have the following state transitions:
+   1. The claimed bit can be put over any other card state. Except that
+      the "dirty -> dirty and claimed" transition is checked for in
+      G1 code and is not used.
+   2. Deferred bit can be set only if the previous state of the card
+      was either clean or claimed. mark_card_deferred() is wait-free.
+      We do not care if the operation is be successful because if
+      it does not it will only result in duplicate entry in the update
+      buffer because of the "cache-miss". So it's not worth spinning.
+ */
+
+  bool is_card_claimed(size_t card_index) {
+    jbyte val = _byte_map[card_index];
+    return (val & (clean_card_mask_val() | claimed_card_val())) == claimed_card_val();
+  }
+
+  void set_card_claimed(size_t card_index) {
+      jbyte val = _byte_map[card_index];
+      if (val == clean_card_val()) {
+        val = (jbyte)claimed_card_val();
+      } else {
+        val |= (jbyte)claimed_card_val();
+      }
+      _byte_map[card_index] = val;
+  }
+
+  void verify_g1_young_region(MemRegion mr) PRODUCT_RETURN;
+  void g1_mark_as_young(const MemRegion& mr);
+
+  bool mark_card_deferred(size_t card_index);
+
+  bool is_card_deferred(size_t card_index) {
+    jbyte val = _byte_map[card_index];
+    return (val & (clean_card_mask_val() | deferred_card_val())) == deferred_card_val();
+  }
+
 };
 
 // Adds card-table logging to the post-barrier.
--- ./hotspot/src/share/vm/gc_implementation/g1/g1_globals.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/gc_implementation/g1/g1_globals.hpp	Wed May 07 19:26:16 2014 -0700
@@ -71,6 +71,9 @@
   diagnostic(bool, G1TraceConcRefinement, false,                            \
           "Trace G1 concurrent refinement")                                 \
                                                                             \
+  experimental(bool, G1TraceStringSymbolTableScrubbing, false,              \
+          "Trace information string and symbol table scrubbing.")           \
+                                                                            \
   product(double, G1ConcMarkStepDurationMillis, 10.0,                       \
           "Target duration of individual concurrent marking steps "         \
           "in milliseconds.")                                               \
@@ -332,7 +335,14 @@
                                                                             \
   develop(bool, G1EvacuationFailureALotDuringMixedGC, true,                 \
           "Force use of evacuation failure handling during mixed "          \
-          "evacuation pauses")
+          "evacuation pauses")                                              \
+                                                                            \
+  diagnostic(bool, G1VerifyRSetsDuringFullGC, false,                        \
+             "If true, perform verification of each heap region's "         \
+             "remembered set when verifying the heap during a full GC.")    \
+                                                                            \
+  diagnostic(bool, G1VerifyHeapRegionCodeRoots, false,                      \
+             "Verify the code root lists attached to each heap region.")
 
 G1_FLAGS(DECLARE_DEVELOPER_FLAG, DECLARE_PD_DEVELOPER_FLAG, DECLARE_PRODUCT_FLAG, DECLARE_PD_PRODUCT_FLAG, DECLARE_DIAGNOSTIC_FLAG, DECLARE_EXPERIMENTAL_FLAG, DECLARE_NOTPRODUCT_FLAG, DECLARE_MANAGEABLE_FLAG, DECLARE_PRODUCT_RW_FLAG)
 
--- ./hotspot/src/share/vm/gc_implementation/g1/heapRegion.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/gc_implementation/g1/heapRegion.cpp	Wed May 07 19:26:16 2014 -0700
@@ -23,6 +23,7 @@
  */
 
 #include "precompiled.hpp"
+#include "code/nmethod.hpp"
 #include "gc_implementation/g1/g1BlockOffsetTable.inline.hpp"
 #include "gc_implementation/g1/g1CollectedHeap.inline.hpp"
 #include "gc_implementation/g1/g1OopClosures.inline.hpp"
@@ -50,144 +51,6 @@
                                                    OopClosure* oc) :
   _r_bottom(r->bottom()), _r_end(r->end()), _oc(oc) { }
 
-class VerifyLiveClosure: public OopClosure {
-private:
-  G1CollectedHeap* _g1h;
-  CardTableModRefBS* _bs;
-  oop _containing_obj;
-  bool _failures;
-  int _n_failures;
-  VerifyOption _vo;
-public:
-  // _vo == UsePrevMarking -> use "prev" marking information,
-  // _vo == UseNextMarking -> use "next" marking information,
-  // _vo == UseMarkWord    -> use mark word from object header.
-  VerifyLiveClosure(G1CollectedHeap* g1h, VerifyOption vo) :
-    _g1h(g1h), _bs(NULL), _containing_obj(NULL),
-    _failures(false), _n_failures(0), _vo(vo)
-  {
-    BarrierSet* bs = _g1h->barrier_set();
-    if (bs->is_a(BarrierSet::CardTableModRef))
-      _bs = (CardTableModRefBS*)bs;
-  }
-
-  void set_containing_obj(oop obj) {
-    _containing_obj = obj;
-  }
-
-  bool failures() { return _failures; }
-  int n_failures() { return _n_failures; }
-
-  virtual void do_oop(narrowOop* p) { do_oop_work(p); }
-  virtual void do_oop(      oop* p) { do_oop_work(p); }
-
-  void print_object(outputStream* out, oop obj) {
-#ifdef PRODUCT
-    klassOop k = obj->klass();
-    const char* class_name = instanceKlass::cast(k)->external_name();
-    out->print_cr("class name %s", class_name);
-#else // PRODUCT
-    obj->print_on(out);
-#endif // PRODUCT
-  }
-
-  template <class T>
-  void do_oop_work(T* p) {
-    assert(_containing_obj != NULL, "Precondition");
-    assert(!_g1h->is_obj_dead_cond(_containing_obj, _vo),
-           "Precondition");
-    T heap_oop = oopDesc::load_heap_oop(p);
-    if (!oopDesc::is_null(heap_oop)) {
-      oop obj = oopDesc::decode_heap_oop_not_null(heap_oop);
-      bool failed = false;
-      if (!_g1h->is_in_closed_subset(obj) || _g1h->is_obj_dead_cond(obj, _vo)) {
-        MutexLockerEx x(ParGCRareEvent_lock,
-                        Mutex::_no_safepoint_check_flag);
-
-        if (!_failures) {
-          gclog_or_tty->print_cr("");
-          gclog_or_tty->print_cr("----------");
-        }
-        if (!_g1h->is_in_closed_subset(obj)) {
-          HeapRegion* from = _g1h->heap_region_containing((HeapWord*)p);
-          gclog_or_tty->print_cr("Field "PTR_FORMAT
-                                 " of live obj "PTR_FORMAT" in region "
-                                 "["PTR_FORMAT", "PTR_FORMAT")",
-                                 p, (void*) _containing_obj,
-                                 from->bottom(), from->end());
-          print_object(gclog_or_tty, _containing_obj);
-          gclog_or_tty->print_cr("points to obj "PTR_FORMAT" not in the heap",
-                                 (void*) obj);
-        } else {
-          HeapRegion* from = _g1h->heap_region_containing((HeapWord*)p);
-          HeapRegion* to   = _g1h->heap_region_containing((HeapWord*)obj);
-          gclog_or_tty->print_cr("Field "PTR_FORMAT
-                                 " of live obj "PTR_FORMAT" in region "
-                                 "["PTR_FORMAT", "PTR_FORMAT")",
-                                 p, (void*) _containing_obj,
-                                 from->bottom(), from->end());
-          print_object(gclog_or_tty, _containing_obj);
-          gclog_or_tty->print_cr("points to dead obj "PTR_FORMAT" in region "
-                                 "["PTR_FORMAT", "PTR_FORMAT")",
-                                 (void*) obj, to->bottom(), to->end());
-          print_object(gclog_or_tty, obj);
-        }
-        gclog_or_tty->print_cr("----------");
-        gclog_or_tty->flush();
-        _failures = true;
-        failed = true;
-        _n_failures++;
-      }
-
-      if (!_g1h->full_collection()) {
-        HeapRegion* from = _g1h->heap_region_containing((HeapWord*)p);
-        HeapRegion* to   = _g1h->heap_region_containing(obj);
-        if (from != NULL && to != NULL &&
-            from != to &&
-            !to->isHumongous()) {
-          jbyte cv_obj = *_bs->byte_for_const(_containing_obj);
-          jbyte cv_field = *_bs->byte_for_const(p);
-          const jbyte dirty = CardTableModRefBS::dirty_card_val();
-
-          bool is_bad = !(from->is_young()
-                          || to->rem_set()->contains_reference(p)
-                          || !G1HRRSFlushLogBuffersOnVerify && // buffers were not flushed
-                              (_containing_obj->is_objArray() ?
-                                  cv_field == dirty
-                               : cv_obj == dirty || cv_field == dirty));
-          if (is_bad) {
-            MutexLockerEx x(ParGCRareEvent_lock,
-                            Mutex::_no_safepoint_check_flag);
-
-            if (!_failures) {
-              gclog_or_tty->print_cr("");
-              gclog_or_tty->print_cr("----------");
-            }
-            gclog_or_tty->print_cr("Missing rem set entry:");
-            gclog_or_tty->print_cr("Field "PTR_FORMAT" "
-                                   "of obj "PTR_FORMAT", "
-                                   "in region "HR_FORMAT,
-                                   p, (void*) _containing_obj,
-                                   HR_FORMAT_PARAMS(from));
-            _containing_obj->print_on(gclog_or_tty);
-            gclog_or_tty->print_cr("points to obj "PTR_FORMAT" "
-                                   "in region "HR_FORMAT,
-                                   (void*) obj,
-                                   HR_FORMAT_PARAMS(to));
-            obj->print_on(gclog_or_tty);
-            gclog_or_tty->print_cr("Obj head CTE = %d, field CTE = %d.",
-                          cv_obj, cv_field);
-            gclog_or_tty->print_cr("----------");
-            gclog_or_tty->flush();
-            _failures = true;
-            if (!failed) _n_failures++;
-          }
-        }
-      }
-    }
-  }
-};
-
 template<class ClosureType>
 HeapWord* walk_mem_region_loop(ClosureType* cl, G1CollectedHeap* g1h,
                                HeapRegion* hr,
@@ -314,6 +177,11 @@
     region_size = MAX_REGION_SIZE;
   }
 
+  if (region_size != G1HeapRegionSize) {
+    // Update the flag to make sure that PrintFlagsFinal logs the correct value
+    FLAG_SET_ERGO(uintx, G1HeapRegionSize, region_size);
+  }
+
   // And recalculate the log.
   region_size_log = log2_long((jlong) region_size);
 
@@ -363,7 +231,7 @@
   if (!par) {
     // If this is parallel, this will be done later.
     HeapRegionRemSet* hrrs = rem_set();
-    if (hrrs != NULL) hrrs->clear();
+    hrrs->clear();
     _claimed = InitialClaimValue;
   }
   zero_marked_bytes();
@@ -504,6 +372,7 @@
     _rem_set(NULL), _recorded_rs_length(0), _predicted_elapsed_time_ms(0),
     _predicted_bytes_to_copy(0)
 {
+  _rem_set = new HeapRegionRemSet(sharedOffsetArray, this);
   _orig_end = mr.end();
   // Note that initialize() will set the start of the unmarked area of the
   // region.
@@ -511,8 +380,6 @@
   set_top(bottom());
   set_saved_mark();
 
-  _rem_set =  new HeapRegionRemSet(sharedOffsetArray, this);
-
   assert(HeapRegionRemSet::num_par_rem_sets() > 0, "Invariant.");
 }
 
@@ -732,6 +599,161 @@
   return NULL;
 }
 
+// Code roots support
+
+void HeapRegion::add_strong_code_root(nmethod* nm) {
+  HeapRegionRemSet* hrrs = rem_set();
+  hrrs->add_strong_code_root(nm);
+}
+
+void HeapRegion::remove_strong_code_root(nmethod* nm) {
+  HeapRegionRemSet* hrrs = rem_set();
+  hrrs->remove_strong_code_root(nm);
+}
+
+void HeapRegion::migrate_strong_code_roots() {
+  assert(in_collection_set(), "only collection set regions");
+  assert(!isHumongous(),
+          err_msg("humongous region "HR_FORMAT" should not have been added to collection set",
+                  HR_FORMAT_PARAMS(this)));
+
+  HeapRegionRemSet* hrrs = rem_set();
+  hrrs->migrate_strong_code_roots();
+}
+
+void HeapRegion::strong_code_roots_do(CodeBlobClosure* blk) const {
+  HeapRegionRemSet* hrrs = rem_set();
+  hrrs->strong_code_roots_do(blk);
+}
+
+class VerifyStrongCodeRootOopClosure: public OopClosure {
+  const HeapRegion* _hr;
+  nmethod* _nm;
+  bool _failures;
+  bool _has_oops_in_region;
+
+  template <class T> void do_oop_work(T* p) {
+    T heap_oop = oopDesc::load_heap_oop(p);
+    if (!oopDesc::is_null(heap_oop)) {
+      oop obj = oopDesc::decode_heap_oop_not_null(heap_oop);
+
+      // Note: not all the oops embedded in the nmethod are in the
+      // current region. We only look at those which are.
+      if (_hr->is_in(obj)) {
+        // Object is in the region. Check that its less than top
+        if (_hr->top() <= (HeapWord*)obj) {
+          // Object is above top
+          gclog_or_tty->print_cr("Object "PTR_FORMAT" in region "
+                                 "["PTR_FORMAT", "PTR_FORMAT") is above "
+                                 "top "PTR_FORMAT,
+                                 obj, _hr->bottom(), _hr->end(), _hr->top());
+          _failures = true;
+          return;
+        }
+        // Nmethod has at least one oop in the current region
+        _has_oops_in_region = true;
+      }
+    }
+  }
+
+public:
+  VerifyStrongCodeRootOopClosure(const HeapRegion* hr, nmethod* nm):
+    _hr(hr), _failures(false), _has_oops_in_region(false) {}
+
+  void do_oop(narrowOop* p) { do_oop_work(p); }
+  void do_oop(oop* p)       { do_oop_work(p); }
+
+  bool failures()           { return _failures; }
+  bool has_oops_in_region() { return _has_oops_in_region; }
+};
+
+class VerifyStrongCodeRootCodeBlobClosure: public CodeBlobClosure {
+  const HeapRegion* _hr;
+  bool _failures;
+public:
+  VerifyStrongCodeRootCodeBlobClosure(const HeapRegion* hr) :
+    _hr(hr), _failures(false) {}
+
+  void do_code_blob(CodeBlob* cb) {
+    nmethod* nm = (cb == NULL) ? NULL : cb->as_nmethod_or_null();
+    if (nm != NULL) {
+      // Verify that the nemthod is live
+      if (!nm->is_alive()) {
+        gclog_or_tty->print_cr("region ["PTR_FORMAT","PTR_FORMAT"] has dead nmethod "
+                               PTR_FORMAT" in its strong code roots",
+                               _hr->bottom(), _hr->end(), nm);
+        _failures = true;
+      } else {
+        VerifyStrongCodeRootOopClosure oop_cl(_hr, nm);
+        nm->oops_do(&oop_cl);
+        if (!oop_cl.has_oops_in_region()) {
+          gclog_or_tty->print_cr("region ["PTR_FORMAT","PTR_FORMAT"] has nmethod "
+                                 PTR_FORMAT" in its strong code roots "
+                                 "with no pointers into region",
+                                 _hr->bottom(), _hr->end(), nm);
+          _failures = true;
+        } else if (oop_cl.failures()) {
+          gclog_or_tty->print_cr("region ["PTR_FORMAT","PTR_FORMAT"] has other "
+                                 "failures for nmethod "PTR_FORMAT,
+                                 _hr->bottom(), _hr->end(), nm);
+          _failures = true;
+        }
+      }
+    }
+  }
+
+  bool failures()       { return _failures; }
+};
+
+void HeapRegion::verify_strong_code_roots(VerifyOption vo, bool* failures) const {
+  if (!G1VerifyHeapRegionCodeRoots) {
+    // We're not verifying code roots.
+    return;
+  }
+  if (vo == VerifyOption_G1UseMarkWord) {
+    // Marking verification during a full GC is performed after class
+    // unloading, code cache unloading, etc so the strong code roots
+    // attached to each heap region are in an inconsistent state. They won't
+    // be consistent until the strong code roots are rebuilt after the
+    // actual GC. Skip verifying the strong code roots in this particular
+    // time.
+    assert(VerifyDuringGC, "only way to get here");
+    return;
+  }
+
+  HeapRegionRemSet* hrrs = rem_set();
+  int strong_code_roots_length = hrrs->strong_code_roots_list_length();
+
+  // if this region is empty then there should be no entries
+  // on its strong code root list
+  if (is_empty()) {
+    if (strong_code_roots_length > 0) {
+      gclog_or_tty->print_cr("region ["PTR_FORMAT","PTR_FORMAT"] is empty "
+                             "but has "INT32_FORMAT" code root entries",
+                             bottom(), end(), strong_code_roots_length);
+      *failures = true;
+    }
+    return;
+  }
+
+  if (continuesHumongous()) {
+    if (strong_code_roots_length > 0) {
+      gclog_or_tty->print_cr("region "HR_FORMAT" is a continuation of a humongous "
+                             "region but has "INT32_FORMAT" code root entries",
+                             HR_FORMAT_PARAMS(this), strong_code_roots_length);
+      *failures = true;
+    }
+    return;
+  }
+
+  VerifyStrongCodeRootCodeBlobClosure cb_cl(this);
+  strong_code_roots_do(&cb_cl);
+
+  if (cb_cl.failures()) {
+    *failures = true;
+  }
+}
+
 void HeapRegion::print() const { print_on(gclog_or_tty); }
 void HeapRegion::print_on(outputStream* st) const {
   if (isHumongous()) {
@@ -760,10 +782,143 @@
   G1OffsetTableContigSpace::print_on(st);
 }
 
-void HeapRegion::verify() const {
-  bool dummy = false;
-  verify(VerifyOption_G1UsePrevMarking, /* failures */ &dummy);
-}
+class VerifyLiveClosure: public OopClosure {
+private:
+  G1CollectedHeap* _g1h;
+  CardTableModRefBS* _bs;
+  oop _containing_obj;
+  bool _failures;
+  int _n_failures;
+  VerifyOption _vo;
+public:
+  // _vo == UsePrevMarking -> use "prev" marking information,
+  // _vo == UseNextMarking -> use "next" marking information,
+  // _vo == UseMarkWord    -> use mark word from object header.
+  VerifyLiveClosure(G1CollectedHeap* g1h, VerifyOption vo) :
+    _g1h(g1h), _bs(NULL), _containing_obj(NULL),
+    _failures(false), _n_failures(0), _vo(vo)
+  {
+    BarrierSet* bs = _g1h->barrier_set();
+    if (bs->is_a(BarrierSet::CardTableModRef))
+      _bs = (CardTableModRefBS*)bs;
+  }
+
+  void set_containing_obj(oop obj) {
+    _containing_obj = obj;
+  }
+
+  bool failures() { return _failures; }
+  int n_failures() { return _n_failures; }
+
+  virtual void do_oop(narrowOop* p) { do_oop_work(p); }
+  virtual void do_oop(      oop* p) { do_oop_work(p); }
+
+  void print_object(outputStream* out, oop obj) {
+#ifdef PRODUCT
+    klassOop k = obj->klass();
+    const char* class_name = instanceKlass::cast(k)->external_name();
+    out->print_cr("class name %s", class_name);
+#else // PRODUCT
+    obj->print_on(out);
+#endif // PRODUCT
+  }
+
+  template <class T>
+  void do_oop_work(T* p) {
+    assert(_containing_obj != NULL, "Precondition");
+    assert(!_g1h->is_obj_dead_cond(_containing_obj, _vo),
+           "Precondition");
+    T heap_oop = oopDesc::load_heap_oop(p);
+    if (!oopDesc::is_null(heap_oop)) {
+      oop obj = oopDesc::decode_heap_oop_not_null(heap_oop);
+      bool failed = false;
+      if (!_g1h->is_in_closed_subset(obj) || _g1h->is_obj_dead_cond(obj, _vo)) {
+        MutexLockerEx x(ParGCRareEvent_lock,
+                        Mutex::_no_safepoint_check_flag);
+
+        if (!_failures) {
+          gclog_or_tty->print_cr("");
+          gclog_or_tty->print_cr("----------");
+        }
+        if (!_g1h->is_in_closed_subset(obj)) {
+          HeapRegion* from = _g1h->heap_region_containing((HeapWord*)p);
+          gclog_or_tty->print_cr("Field "PTR_FORMAT
+                                 " of live obj "PTR_FORMAT" in region "
+                                 "["PTR_FORMAT", "PTR_FORMAT")",
+                                 p, (void*) _containing_obj,
+                                 from->bottom(), from->end());
+          print_object(gclog_or_tty, _containing_obj);
+          gclog_or_tty->print_cr("points to obj "PTR_FORMAT" not in the heap",
+                                 (void*) obj);
+        } else {
+          HeapRegion* from = _g1h->heap_region_containing((HeapWord*)p);
+          HeapRegion* to   = _g1h->heap_region_containing((HeapWord*)obj);
+          gclog_or_tty->print_cr("Field "PTR_FORMAT
+                                 " of live obj "PTR_FORMAT" in region "
+                                 "["PTR_FORMAT", "PTR_FORMAT")",
+                                 p, (void*) _containing_obj,
+                                 from->bottom(), from->end());
+          print_object(gclog_or_tty, _containing_obj);
+          gclog_or_tty->print_cr("points to dead obj "PTR_FORMAT" in region "
+                                 "["PTR_FORMAT", "PTR_FORMAT")",
+                                 (void*) obj, to->bottom(), to->end());
+          print_object(gclog_or_tty, obj);
+        }
+        gclog_or_tty->print_cr("----------");
+        gclog_or_tty->flush();
+        _failures = true;
+        failed = true;
+        _n_failures++;
+      }
+
+      if (!_g1h->full_collection() || G1VerifyRSetsDuringFullGC) {
+        HeapRegion* from = _g1h->heap_region_containing((HeapWord*)p);
+        HeapRegion* to   = _g1h->heap_region_containing(obj);
+        if (from != NULL && to != NULL &&
+            from != to &&
+            !to->isHumongous()) {
+          jbyte cv_obj = *_bs->byte_for_const(_containing_obj);
+          jbyte cv_field = *_bs->byte_for_const(p);
+          const jbyte dirty = CardTableModRefBS::dirty_card_val();
+
+          bool is_bad = !(from->is_young()
+                          || to->rem_set()->contains_reference(p)
+                          || !G1HRRSFlushLogBuffersOnVerify && // buffers were not flushed
+                              (_containing_obj->is_objArray() ?
+                                  cv_field == dirty
+                               : cv_obj == dirty || cv_field == dirty));
+          if (is_bad) {
+            MutexLockerEx x(ParGCRareEvent_lock,
+                            Mutex::_no_safepoint_check_flag);
+
+            if (!_failures) {
+              gclog_or_tty->print_cr("");
+              gclog_or_tty->print_cr("----------");
+            }
+            gclog_or_tty->print_cr("Missing rem set entry:");
+            gclog_or_tty->print_cr("Field "PTR_FORMAT" "
+                                   "of obj "PTR_FORMAT", "
+                                   "in region "HR_FORMAT,
+                                   p, (void*) _containing_obj,
+                                   HR_FORMAT_PARAMS(from));
+            _containing_obj->print_on(gclog_or_tty);
+            gclog_or_tty->print_cr("points to obj "PTR_FORMAT" "
+                                   "in region "HR_FORMAT,
+                                   (void*) obj,
+                                   HR_FORMAT_PARAMS(to));
+            obj->print_on(gclog_or_tty);
+            gclog_or_tty->print_cr("Obj head CTE = %d, field CTE = %d.",
+                          cv_obj, cv_field);
+            gclog_or_tty->print_cr("----------");
+            gclog_or_tty->flush();
+            _failures = true;
+            if (!failed) _n_failures++;
+          }
+        }
+      }
+    }
+  }
+};
 
 // This really ought to be commoned up into OffsetTableContigSpace somehow.
 // We would need a mechanism to make that code skip dead objects.
@@ -903,6 +1058,13 @@
     *failures = true;
     return;
   }
+
+  verify_strong_code_roots(vo, failures);
+}
+
+void HeapRegion::verify() const {
+  bool dummy = false;
+  verify(VerifyOption_G1UsePrevMarking, /* failures */ &dummy);
 }
 
 // G1OffsetTableContigSpace code; copied from space.cpp.  Hope this can go
--- ./hotspot/src/share/vm/gc_implementation/g1/heapRegion.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/gc_implementation/g1/heapRegion.hpp	Wed May 07 19:26:16 2014 -0700
@@ -51,6 +51,7 @@
 class HeapRegionRemSetIterator;
 class HeapRegion;
 class HeapRegionSetBase;
+class nmethod;
 
 #define HR_FORMAT "%u:(%s)["PTR_FORMAT","PTR_FORMAT","PTR_FORMAT"]"
 #define HR_FORMAT_PARAMS(_hr_) \
@@ -374,7 +375,8 @@
     RebuildRSClaimValue        = 5,
     ParEvacFailureClaimValue   = 6,
     AggregateCountClaimValue   = 7,
-    VerifyCountClaimValue      = 8
+    VerifyCountClaimValue      = 8,
+    ParMarkRootClaimValue      = 9
   };
 
   inline HeapWord* par_allocate_no_bot_updates(size_t word_size) {
@@ -801,6 +803,25 @@
 
   virtual void reset_after_compaction();
 
+  // Routines for managing a list of code roots (attached to the
+  // this region's RSet) that point into this heap region.
+  void add_strong_code_root(nmethod* nm);
+  void remove_strong_code_root(nmethod* nm);
+
+  // During a collection, migrate the successfully evacuated
+  // strong code roots that referenced into this region to the
+  // new regions that they now point into. Unsuccessfully
+  // evacuated code roots are not migrated.
+  void migrate_strong_code_roots();
+
+  // Applies blk->do_code_blob() to each of the entries in
+  // the strong code roots list for this region
+  void strong_code_roots_do(CodeBlobClosure* blk) const;
+
+  // Verify that the entries on the strong code root list for this
+  // region are live and include at least one pointer into this region.
+  void verify_strong_code_roots(VerifyOption vo, bool* failures) const;
+
   void print() const;
   void print_on(outputStream* st) const;
 
--- ./hotspot/src/share/vm/gc_implementation/g1/heapRegionRemSet.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/gc_implementation/g1/heapRegionRemSet.cpp	Wed May 07 19:26:16 2014 -0700
@@ -33,6 +33,7 @@
 #include "oops/oop.inline.hpp"
 #include "utilities/bitMap.inline.hpp"
 #include "utilities/globalDefinitions.hpp"
+#include "utilities/growableArray.hpp"
 
 class PerRegionTable: public CHeapObj<mtGC> {
   friend class OtherRegionsTable;
@@ -706,10 +707,11 @@
   // Cast away const in this case.
   MutexLockerEx x((Mutex*)&_m, Mutex::_no_safepoint_check_flag);
   size_t sum = 0;
-  PerRegionTable * cur = _first_all_fine_prts;
-  while (cur != NULL) {
-    sum += cur->mem_size();
-    cur = cur->next();
+  // all PRTs are of the same size so it is sufficient to query only one of them.
+  if (_first_all_fine_prts != NULL) {
+    assert(_last_all_fine_prts != NULL &&
+      _first_all_fine_prts->mem_size() == _last_all_fine_prts->mem_size(), "check that mem_size() is constant");
+    sum += _first_all_fine_prts->mem_size() * _n_fine_entries;
   }
   sum += (sizeof(PerRegionTable*) * _max_fine_entries);
   sum += (_coarse_map.size_in_words() * HeapWordSize);
@@ -845,7 +847,7 @@
 
 HeapRegionRemSet::HeapRegionRemSet(G1BlockOffsetSharedArray* bosa,
                                    HeapRegion* hr)
-  : _bosa(bosa), _other_regions(hr) {
+  : _bosa(bosa), _strong_code_roots_list(NULL), _other_regions(hr) {
   reset_for_par_iteration();
 }
 
@@ -909,6 +911,12 @@
 }
 
 void HeapRegionRemSet::clear() {
+  if (_strong_code_roots_list != NULL) {
+    delete _strong_code_roots_list;
+  }
+  _strong_code_roots_list = new (ResourceObj::C_HEAP, mtGC)
+                                GrowableArray<nmethod*>(10, 0, NULL, true);
+
   _other_regions.clear();
   assert(occupied() == 0, "Should be clear.");
   reset_for_par_iteration();
@@ -926,6 +934,126 @@
   _other_regions.scrub(ctbs, region_bm, card_bm);
 }
 
+
+// Code roots support
+
+void HeapRegionRemSet::add_strong_code_root(nmethod* nm) {
+  assert(nm != NULL, "sanity");
+  // Search for the code blob from the RHS to avoid
+  // duplicate entries as much as possible
+  if (_strong_code_roots_list->find_from_end(nm) < 0) {
+    // Code blob isn't already in the list
+    _strong_code_roots_list->push(nm);
+  }
+}
+
+void HeapRegionRemSet::remove_strong_code_root(nmethod* nm) {
+  assert(nm != NULL, "sanity");
+  int idx = _strong_code_roots_list->find(nm);
+  if (idx >= 0) {
+    _strong_code_roots_list->remove_at(idx);
+  }
+  // Check that there were no duplicates
+  guarantee(_strong_code_roots_list->find(nm) < 0, "duplicate entry found");
+}
+
+class NMethodMigrationOopClosure : public OopClosure {
+  G1CollectedHeap* _g1h;
+  HeapRegion* _from;
+  nmethod* _nm;
+
+  uint _num_self_forwarded;
+
+  template <class T> void do_oop_work(T* p) {
+    T heap_oop = oopDesc::load_heap_oop(p);
+    if (!oopDesc::is_null(heap_oop)) {
+      oop obj = oopDesc::decode_heap_oop_not_null(heap_oop);
+      if (obj->is_perm()) {
+        // reference into perm gen - ignore.
+        return;
+      } else if (_from->is_in(obj)) {
+        // Reference still points into the source region.
+        // Since roots are immediately evacuated this means that
+        // we must have self forwarded the object
+        assert(obj->is_forwarded(),
+               err_msg("code roots should be immediately evacuated. "
+                       "Ref: "PTR_FORMAT", "
+                       "Obj: "PTR_FORMAT", "
+                       "Region: "HR_FORMAT,
+                       p, (void*) obj, HR_FORMAT_PARAMS(_from)));
+        assert(obj->forwardee() == obj,
+               err_msg("not self forwarded? obj = "PTR_FORMAT, (void*)obj));
+
+        // The object has been self forwarded.
+        // Note, if we're during an initial mark pause, there is
+        // no need to explicitly mark object. It will be marked
+        // during the regular evacuation failure handling code.
+        _num_self_forwarded++;
+      } else {
+        // The reference points into a promotion or to-space region
+        HeapRegion* to = _g1h->heap_region_containing(obj);
+        to->rem_set()->add_strong_code_root(_nm);
+      }
+    }
+  }
+
+public:
+  NMethodMigrationOopClosure(G1CollectedHeap* g1h, HeapRegion* from, nmethod* nm):
+    _g1h(g1h), _from(from), _nm(nm), _num_self_forwarded(0) {}
+
+  void do_oop(narrowOop* p) { do_oop_work(p); }
+  void do_oop(oop* p)       { do_oop_work(p); }
+
+  uint retain() { return _num_self_forwarded > 0; }
+};
+
+void HeapRegionRemSet::migrate_strong_code_roots() {
+  assert(hr()->in_collection_set(), "only collection set regions");
+  assert(!hr()->isHumongous(),
+         err_msg("humongous region "HR_FORMAT" should not have been added to the collection set",
+                 HR_FORMAT_PARAMS(hr())));
+
+  ResourceMark rm;
+
+  // List of code blobs to retain for this region
+  GrowableArray<nmethod*> to_be_retained(10);
+  G1CollectedHeap* g1h = G1CollectedHeap::heap();
+
+  while (_strong_code_roots_list->is_nonempty()) {
+    nmethod *nm = _strong_code_roots_list->pop();
+    if (nm != NULL) {
+      NMethodMigrationOopClosure oop_cl(g1h, hr(), nm);
+      nm->oops_do(&oop_cl);
+      if (oop_cl.retain()) {
+        to_be_retained.push(nm);
+      }
+    }
+  }
+
+  // Now push any code roots we need to retain
+  assert(to_be_retained.is_empty() || hr()->evacuation_failed(),
+         "Retained nmethod list must be empty or "
+         "evacuation of this region failed");
+
+  while (to_be_retained.is_nonempty()) {
+    nmethod* nm = to_be_retained.pop();
+    assert(nm != NULL, "sanity");
+    add_strong_code_root(nm);
+  }
+}
+
+void HeapRegionRemSet::strong_code_roots_do(CodeBlobClosure* blk) const {
+  for (int i = 0; i < _strong_code_roots_list->length(); i += 1) {
+    nmethod* nm = _strong_code_roots_list->at(i);
+    blk->do_code_blob(nm);
+  }
+}
+
+size_t HeapRegionRemSet::strong_code_roots_mem_size() {
+  return sizeof(GrowableArray<nmethod*>) +
+         _strong_code_roots_list->max_length() * sizeof(nmethod*);
+}
+
 //-------------------- Iteration --------------------
 
 HeapRegionRemSetIterator::
--- ./hotspot/src/share/vm/gc_implementation/g1/heapRegionRemSet.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/gc_implementation/g1/heapRegionRemSet.hpp	Wed May 07 19:26:16 2014 -0700
@@ -37,6 +37,7 @@
 class HeapRegionRemSetIterator;
 class PerRegionTable;
 class SparsePRT;
+class nmethod;
 
 // Essentially a wrapper around SparsePRTCleanupTask. See
 // sparsePRT.hpp for more details.
@@ -191,6 +192,10 @@
   G1BlockOffsetSharedArray* _bosa;
   G1BlockOffsetSharedArray* bosa() const { return _bosa; }
 
+  // A list of code blobs (nmethods) whose code contains pointers into
+  // the region that owns this RSet.
+  GrowableArray<nmethod*>* _strong_code_roots_list;
+
   OtherRegionsTable _other_regions;
 
   enum ParIterState { Unclaimed, Claimed, Complete };
@@ -285,11 +290,13 @@
   void init_iterator(HeapRegionRemSetIterator* iter) const;
 
   // The actual # of bytes this hr_remset takes up.
+  // Note also includes the strong code root set.
   size_t mem_size() {
     return _other_regions.mem_size()
       // This correction is necessary because the above includes the second
       // part.
-      + sizeof(this) - sizeof(OtherRegionsTable);
+      + (sizeof(this) - sizeof(OtherRegionsTable))
+      + strong_code_roots_mem_size();
   }
 
   // Returns the memory occupancy of all static data structures associated
@@ -307,6 +314,37 @@
   bool contains_reference(OopOrNarrowOopStar from) const {
     return _other_regions.contains_reference(from);
   }
+
+  // Routines for managing the list of code roots that point into
+  // the heap region that owns this RSet.
+  void add_strong_code_root(nmethod* nm);
+  void remove_strong_code_root(nmethod* nm);
+
+  // During a collection, migrate the successfully evacuated strong
+  // code roots that referenced into the region that owns this RSet
+  // to the RSets of the new regions that they now point into.
+  // Unsuccessfully evacuated code roots are not migrated.
+  void migrate_strong_code_roots();
+
+  // Applies blk->do_code_blob() to each of the entries in
+  // the strong code roots list
+  void strong_code_roots_do(CodeBlobClosure* blk) const;
+
+  // Returns the number of elements in the strong code roots list
+  int strong_code_roots_list_length() {
+    return _strong_code_roots_list->length();
+  }
+
+  // Returns true if the strong code roots contains the given
+  // nmethod.
+  bool strong_code_roots_list_contains(nmethod* nm) {
+    return _strong_code_roots_list->contains(nm);
+  }
+
+  // Returns the amount of memory, in bytes, currently
+  // consumed by the strong code roots.
+  size_t strong_code_roots_mem_size();
+
   void print() const;
 
   // Called during a stop-world phase to perform any deferred cleanups.
--- ./hotspot/src/share/vm/gc_implementation/g1/ptrQueue.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/gc_implementation/g1/ptrQueue.hpp	Wed May 07 19:26:16 2014 -0700
@@ -79,6 +79,10 @@
 
   void reset() { if (_buf != NULL) _index = _sz; }
 
+  void enqueue(volatile void* ptr) {
+    enqueue((void*)(ptr));
+  }
+
   // Enqueues the given "obj".
   void enqueue(void* ptr) {
     if (!_active) return;
--- ./hotspot/src/share/vm/gc_implementation/parNew/parNewGeneration.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/gc_implementation/parNew/parNewGeneration.cpp	Wed May 07 19:26:16 2014 -0700
@@ -923,7 +923,7 @@
 
   GenCollectedHeap* gch = GenCollectedHeap::heap();
 
-  _gc_timer->register_gc_start(os::elapsed_counter());
+  _gc_timer->register_gc_start();
 
   assert(gch->kind() == CollectedHeap::GenCollectedHeap,
     "not a CMS generational heap");
@@ -1100,7 +1100,7 @@
   gch->trace_heap_after_gc(&gc_tracer);
   gc_tracer.report_tenuring_threshold(tenuring_threshold());
 
-  _gc_timer->register_gc_end(os::elapsed_counter());
+  _gc_timer->register_gc_end();
 
   gc_tracer.report_gc_end(_gc_timer->gc_end(), _gc_timer->time_partitions());
 }
--- ./hotspot/src/share/vm/gc_implementation/parallelScavenge/parallelScavengeHeap.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/gc_implementation/parallelScavenge/parallelScavengeHeap.cpp	Wed May 07 19:26:16 2014 -0700
@@ -90,14 +90,16 @@
                   og_min_size, og_max_size,
                   yg_min_size, yg_max_size);
 
-  // The ReservedSpace ctor used below requires that the page size for the perm
-  // gen is <= the page size for the rest of the heap (young + old gens).
   const size_t og_page_sz = os::page_size_for_region(yg_min_size + og_min_size,
                                                      yg_max_size + og_max_size,
                                                      8);
-  const size_t pg_page_sz = MIN2(os::page_size_for_region(pg_min_size,
-                                                          pg_max_size, 16),
-                                 og_page_sz);
+
+  // Use the same page size for both perm gen and old gen,
+  // to allow large pages to be allocated when the heap is reserved
+  // for the implementations that can't 'commit' large pages.
+  // NEEDS_CLEANUP. ReservedHeapSpace/ReservedSpace that takes both
+  // a prefix and a suffix alignment can now be removed.
+  const size_t pg_page_sz = og_page_sz;
 
   const size_t pg_align = set_alignment(_perm_gen_alignment,  pg_page_sz);
   const size_t og_align = set_alignment(_old_gen_alignment,   og_page_sz);
@@ -138,12 +140,9 @@
   total_reserved = add_and_check_overflow(total_reserved, og_max_size);
   total_reserved = add_and_check_overflow(total_reserved, yg_max_size);
 
-  char* addr = Universe::preferred_heap_base(total_reserved, Universe::UnscaledNarrowOop);
+  assert(is_size_aligned(total_reserved, og_align), "Must be");
 
-  // The main part of the heap (old gen + young gen) can often use a larger page
-  // size than is needed or wanted for the perm gen.  Use the "compound
-  // alignment" ReservedSpace ctor to avoid having to use the same page size for
-  // all gens.
+  char* addr = Universe::preferred_heap_base(total_reserved, og_align, Universe::UnscaledNarrowOop);
 
   ReservedHeapSpace heap_rs(pg_max_size, pg_align, og_max_size + yg_max_size,
                             og_align, addr);
@@ -153,12 +152,12 @@
       // Failed to reserve at specified address - the requested memory
       // region is taken already, for example, by 'java' launcher.
       // Try again to reserver heap higher.
-      addr = Universe::preferred_heap_base(total_reserved, Universe::ZeroBasedNarrowOop);
+      addr = Universe::preferred_heap_base(total_reserved, og_align, Universe::ZeroBasedNarrowOop);
       ReservedHeapSpace heap_rs0(pg_max_size, pg_align, og_max_size + yg_max_size,
                                  og_align, addr);
       if (addr != NULL && !heap_rs0.is_reserved()) {
         // Failed to reserve at specified address again - give up.
-        addr = Universe::preferred_heap_base(total_reserved, Universe::HeapBasedNarrowOop);
+        addr = Universe::preferred_heap_base(total_reserved, og_align, Universe::HeapBasedNarrowOop);
         assert(addr == NULL, "");
         ReservedHeapSpace heap_rs1(pg_max_size, pg_align, og_max_size + yg_max_size,
                                    og_align, addr);
--- ./hotspot/src/share/vm/gc_implementation/parallelScavenge/psAdaptiveSizePolicy.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/gc_implementation/parallelScavenge/psAdaptiveSizePolicy.cpp	Wed May 07 19:26:16 2014 -0700
@@ -24,6 +24,7 @@
 
 #include "precompiled.hpp"
 #include "gc_implementation/parallelScavenge/generationSizer.hpp"
+#include "gc_implementation/parallelScavenge/parallelScavengeHeap.hpp"
 #include "gc_implementation/parallelScavenge/psAdaptiveSizePolicy.hpp"
 #include "gc_implementation/parallelScavenge/psGCAdaptivePolicyCounters.hpp"
 #include "gc_implementation/parallelScavenge/psScavenge.hpp"
@@ -78,6 +79,38 @@
   _old_gen_policy_is_ready = false;
 }
 
+size_t PSAdaptiveSizePolicy::calculate_free_based_on_live(size_t live, uintx ratio_as_percentage) {
+  // We want to calculate how much free memory there can be based on the
+  // amount of live data currently in the old gen. Using the formula:
+  // ratio * (free + live) = free
+  // Some equation solving later we get:
+  // free = (live * ratio) / (1 - ratio)
+
+  const double ratio = ratio_as_percentage / 100.0;
+  const double ratio_inverse = 1.0 - ratio;
+  const double tmp = live * ratio;
+  size_t free = (size_t)(tmp / ratio_inverse);
+
+  return free;
+}
+
+size_t PSAdaptiveSizePolicy::calculated_old_free_size_in_bytes() const {
+  size_t free_size = (size_t)(_promo_size + avg_promoted()->padded_average());
+  size_t live = ParallelScavengeHeap::heap()->old_gen()->used_in_bytes();
+
+  if (MinHeapFreeRatio != 0) {
+    size_t min_free = calculate_free_based_on_live(live, MinHeapFreeRatio);
+    free_size = MAX2(free_size, min_free);
+  }
+
+  if (MaxHeapFreeRatio != 100) {
+    size_t max_free = calculate_free_based_on_live(live, MaxHeapFreeRatio);
+    free_size = MIN2(max_free, free_size);
+  }
+
+  return free_size;
+}
+
 void PSAdaptiveSizePolicy::major_collection_begin() {
   // Update the interval time
   _major_timer.stop();
@@ -1107,3 +1140,18 @@
                           st,
                           PSScavenge::tenuring_threshold());
 }
+
+#ifndef PRODUCT
+
+void TestOldFreeSpaceCalculation_test() {
+  assert(PSAdaptiveSizePolicy::calculate_free_based_on_live(100, 20) == 25, "Calculation of free memory failed");
+  assert(PSAdaptiveSizePolicy::calculate_free_based_on_live(100, 50) == 100, "Calculation of free memory failed");
+  assert(PSAdaptiveSizePolicy::calculate_free_based_on_live(100, 60) == 150, "Calculation of free memory failed");
+  assert(PSAdaptiveSizePolicy::calculate_free_based_on_live(100, 75) == 300, "Calculation of free memory failed");
+  assert(PSAdaptiveSizePolicy::calculate_free_based_on_live(400, 20) == 100, "Calculation of free memory failed");
+  assert(PSAdaptiveSizePolicy::calculate_free_based_on_live(400, 50) == 400, "Calculation of free memory failed");
+  assert(PSAdaptiveSizePolicy::calculate_free_based_on_live(400, 60) == 600, "Calculation of free memory failed");
+  assert(PSAdaptiveSizePolicy::calculate_free_based_on_live(400, 75) == 1200, "Calculation of free memory failed");
+}
+
+#endif /* !PRODUCT */
--- ./hotspot/src/share/vm/gc_implementation/parallelScavenge/psAdaptiveSizePolicy.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/gc_implementation/parallelScavenge/psAdaptiveSizePolicy.hpp	Wed May 07 19:26:16 2014 -0700
@@ -238,7 +238,6 @@
   void major_collection_begin();
   void major_collection_end(size_t amount_live, GCCause::Cause gc_cause);
 
-  //
   void tenured_allocation(size_t size) {
     _avg_pretenured->sample(size);
   }
@@ -246,9 +245,9 @@
   // Accessors
   // NEEDS_CLEANUP   should use sizes.hpp
 
-  size_t calculated_old_free_size_in_bytes() const {
-    return (size_t)(_promo_size + avg_promoted()->padded_average());
-  }
+  static size_t calculate_free_based_on_live(size_t live, uintx ratio_as_percentage);
+
+  size_t calculated_old_free_size_in_bytes() const;
 
   size_t average_old_live_in_bytes() const {
     return (size_t) avg_old_live()->average();
--- ./hotspot/src/share/vm/gc_implementation/parallelScavenge/psMarkSweep.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/gc_implementation/parallelScavenge/psMarkSweep.cpp	Wed May 07 19:26:16 2014 -0700
@@ -116,7 +116,7 @@
   assert(heap->kind() == CollectedHeap::ParallelScavengeHeap, "Sanity");
   GCCause::Cause gc_cause = heap->gc_cause();
 
-  _gc_timer->register_gc_start(os::elapsed_counter());
+  _gc_timer->register_gc_start();
   _gc_tracer->report_gc_start(gc_cause, _gc_timer->gc_start());
 
   PSAdaptiveSizePolicy* size_policy = heap->size_policy();
@@ -149,8 +149,7 @@
 
   if (VerifyBeforeGC && heap->total_collections() >= VerifyGCStartAt) {
     HandleMark hm;  // Discard invalid handles created during verification
-    gclog_or_tty->print(" VerifyBeforeGC:");
-    Universe::verify();
+    Universe::verify(" VerifyBeforeGC:");
   }
 
   // Verify object start arrays
@@ -359,8 +358,7 @@
 
   if (VerifyAfterGC && heap->total_collections() >= VerifyGCStartAt) {
     HandleMark hm;  // Discard invalid handles created during verification
-    gclog_or_tty->print(" VerifyAfterGC:");
-    Universe::verify();
+    Universe::verify(" VerifyAfterGC:");
   }
 
   // Re-verify object start arrays
@@ -386,7 +384,7 @@
   ParallelTaskTerminator::print_termination_counts();
 #endif
 
-  _gc_timer->register_gc_end(os::elapsed_counter());
+  _gc_timer->register_gc_end();
 
   _gc_tracer->report_gc_end(_gc_timer->gc_end(), _gc_timer->time_partitions());
 
--- ./hotspot/src/share/vm/gc_implementation/parallelScavenge/psParallelCompact.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/gc_implementation/parallelScavenge/psParallelCompact.cpp	Wed May 07 19:26:16 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2005, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2005, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -1034,8 +1034,7 @@
 
   if (VerifyBeforeGC && heap->total_collections() >= VerifyGCStartAt) {
     HandleMark hm;  // Discard invalid handles created during verification
-    gclog_or_tty->print(" VerifyBeforeGC:");
-    Universe::verify();
+    Universe::verify(" VerifyBeforeGC:");
   }
 
   // Verify object start arrays
@@ -2041,7 +2040,7 @@
 
   ParallelScavengeHeap* heap = gc_heap();
 
-  _gc_timer.register_gc_start(os::elapsed_counter());
+  _gc_timer.register_gc_start();
   _gc_tracer.report_gc_start(heap->gc_cause(), _gc_timer.gc_start());
 
   TimeStamp marking_start;
@@ -2248,8 +2247,7 @@
 
   if (VerifyAfterGC && heap->total_collections() >= VerifyGCStartAt) {
     HandleMark hm;  // Discard invalid handles created during verification
-    gclog_or_tty->print(" VerifyAfterGC:");
-    Universe::verify();
+    Universe::verify(" VerifyAfterGC:");
   }
 
   // Re-verify object start arrays
@@ -2285,7 +2283,7 @@
   ParallelTaskTerminator::print_termination_counts();
 #endif
 
-  _gc_timer.register_gc_end(os::elapsed_counter());
+  _gc_timer.register_gc_end();
 
   _gc_tracer.report_dense_prefix(dense_prefix(old_space_id));
   _gc_tracer.report_gc_end(_gc_timer.gc_end(), _gc_timer.time_partitions());
--- ./hotspot/src/share/vm/gc_implementation/parallelScavenge/psScavenge.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/gc_implementation/parallelScavenge/psScavenge.cpp	Wed May 07 19:26:16 2014 -0700
@@ -266,7 +266,7 @@
   assert(_preserved_mark_stack.is_empty(), "should be empty");
   assert(_preserved_oop_stack.is_empty(), "should be empty");
 
-  _gc_timer.register_gc_start(os::elapsed_counter());
+  _gc_timer.register_gc_start();
 
   TimeStamp scavenge_entry;
   TimeStamp scavenge_midpoint;
@@ -325,8 +325,7 @@
 
   if (VerifyBeforeGC && heap->total_collections() >= VerifyGCStartAt) {
     HandleMark hm;  // Discard invalid handles created during verification
-    gclog_or_tty->print(" VerifyBeforeGC:");
-    Universe::verify();
+    Universe::verify(" VerifyBeforeGC:");
   }
 
   {
@@ -536,8 +535,19 @@
           counters->update_survivor_overflowed(_survivor_overflow);
         }
 
+        size_t max_young_size = young_gen->max_size();
+
+        // Deciding a free ratio in the young generation is tricky, so if
+        // MinHeapFreeRatio or MaxHeapFreeRatio are in use (implicating
+        // that the old generation size may have been limited because of them) we
+        // should then limit our young generation size using NewRatio to have it
+        // follow the old generation size.
+        if (MinHeapFreeRatio != 0 || MaxHeapFreeRatio != 100) {
+          max_young_size = MIN2(old_gen->capacity_in_bytes() / NewRatio, young_gen->max_size());
+        }
+
         size_t survivor_limit =
-          size_policy->max_survivor_size(young_gen->max_size());
+          size_policy->max_survivor_size(max_young_size);
         _tenuring_threshold =
           size_policy->compute_survivor_space_size_and_threshold(
                                                            _survivor_overflow,
@@ -560,8 +570,7 @@
         // Do call at minor collections?
         // Don't check if the size_policy is ready at this
         // level.  Let the size_policy check that internally.
-        if (UseAdaptiveSizePolicy &&
-            UseAdaptiveGenerationSizePolicyAtMinorCollection &&
+        if (UseAdaptiveGenerationSizePolicyAtMinorCollection &&
             ((gc_cause != GCCause::_java_lang_system_gc) ||
               UseAdaptiveSizePolicyWithSystemGC)) {
 
@@ -570,7 +579,7 @@
             young_gen->from_space()->capacity_in_bytes() +
             young_gen->to_space()->capacity_in_bytes(),
             "Sizes of space in young gen are out-of-bounds");
-          size_t max_eden_size = young_gen->max_size() -
+          size_t max_eden_size = max_young_size -
             young_gen->from_space()->capacity_in_bytes() -
             young_gen->to_space()->capacity_in_bytes();
           size_policy->compute_generation_free_space(young_gen->used_in_bytes(),
@@ -661,8 +670,7 @@
 
   if (VerifyAfterGC && heap->total_collections() >= VerifyGCStartAt) {
     HandleMark hm;  // Discard invalid handles created during verification
-    gclog_or_tty->print(" VerifyAfterGC:");
-    Universe::verify();
+    Universe::verify(" VerifyAfterGC:");
   }
 
   heap->print_heap_after_gc();
@@ -689,7 +697,7 @@
 #endif
 
 
-  _gc_timer.register_gc_end(os::elapsed_counter());
+  _gc_timer.register_gc_end();
 
   _gc_tracer.report_gc_end(_gc_timer.gc_end(), _gc_timer.time_partitions());
 
--- ./hotspot/src/share/vm/gc_implementation/shared/gcTimer.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/gc_implementation/shared/gcTimer.cpp	Wed May 07 19:26:16 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,52 +25,55 @@
 #include "precompiled.hpp"
 #include "gc_implementation/shared/gcTimer.hpp"
 #include "utilities/growableArray.hpp"
+#include "utilities/ticks.inline.hpp"
 
-void GCTimer::register_gc_start(jlong time) {
+// the "time" parameter for most functions
+// has a default value set by Ticks::now()
+
+void GCTimer::register_gc_start(const Ticks& time) {
   _time_partitions.clear();
   _gc_start = time;
 }
 
-void GCTimer::register_gc_end(jlong time) {
+void GCTimer::register_gc_end(const Ticks& time) {
   assert(!_time_partitions.has_active_phases(),
       "We should have ended all started phases, before ending the GC");
 
   _gc_end = time;
 }
 
-void GCTimer::register_gc_pause_start(const char* name, jlong time) {
+void GCTimer::register_gc_pause_start(const char* name, const Ticks& time) {
   _time_partitions.report_gc_phase_start(name, time);
 }
 
-void GCTimer::register_gc_pause_end(jlong time) {
+void GCTimer::register_gc_pause_end(const Ticks& time) {
   _time_partitions.report_gc_phase_end(time);
 }
 
-void GCTimer::register_gc_phase_start(const char* name, jlong time) {
+void GCTimer::register_gc_phase_start(const char* name, const Ticks& time) {
   _time_partitions.report_gc_phase_start(name, time);
 }
 
-void GCTimer::register_gc_phase_end(jlong time) {
+void GCTimer::register_gc_phase_end(const Ticks& time) {
   _time_partitions.report_gc_phase_end(time);
 }
 
-
-void STWGCTimer::register_gc_start(jlong time) {
+void STWGCTimer::register_gc_start(const Ticks& time) {
   GCTimer::register_gc_start(time);
   register_gc_pause_start("GC Pause", time);
 }
 
-void STWGCTimer::register_gc_end(jlong time) {
+void STWGCTimer::register_gc_end(const Ticks& time) {
   register_gc_pause_end(time);
   GCTimer::register_gc_end(time);
 }
 
-void ConcurrentGCTimer::register_gc_pause_start(const char* name, jlong time) {
-  GCTimer::register_gc_pause_start(name, time);
+void ConcurrentGCTimer::register_gc_pause_start(const char* name) {
+  GCTimer::register_gc_pause_start(name);
 }
 
-void ConcurrentGCTimer::register_gc_pause_end(jlong time) {
-  GCTimer::register_gc_pause_end(time);
+void ConcurrentGCTimer::register_gc_pause_end() {
+  GCTimer::register_gc_pause_end();
 }
 
 void PhasesStack::clear() {
@@ -111,11 +114,11 @@
 void TimePartitions::clear() {
   _phases->clear();
   _active_phases.clear();
-  _sum_of_pauses = 0;
-  _longest_pause = 0;
+  _sum_of_pauses = Tickspan();
+  _longest_pause = Tickspan();
 }
 
-void TimePartitions::report_gc_phase_start(const char* name, jlong time) {
+void TimePartitions::report_gc_phase_start(const char* name, const Ticks& time) {
   assert(_phases->length() <= 1000, "Too many recored phases?");
 
   int level = _active_phases.count();
@@ -133,13 +136,13 @@
 void TimePartitions::update_statistics(GCPhase* phase) {
   // FIXME: This should only be done for pause phases
   if (phase->level() == 0) {
-    jlong pause = phase->end() - phase->start();
+    const Tickspan pause = phase->end() - phase->start();
     _sum_of_pauses += pause;
     _longest_pause = MAX2(pause, _longest_pause);
   }
 }
 
-void TimePartitions::report_gc_phase_end(jlong time) {
+void TimePartitions::report_gc_phase_end(const Ticks& time) {
   int phase_index = _active_phases.pop();
   GCPhase* phase = _phases->adr_at(phase_index);
   phase->set_end(time);
@@ -157,14 +160,6 @@
   return _phases->adr_at(index);
 }
 
-jlong TimePartitions::sum_of_pauses() {
-  return _sum_of_pauses;
-}
-
-jlong TimePartitions::longest_pause() {
-  return _longest_pause;
-}
-
 bool TimePartitions::has_active_phases() {
   return _active_phases.count() > 0;
 }
@@ -194,7 +189,7 @@
     max_nested_pause_phases();
   }
 
-  static void validate_pause_phase(GCPhase* phase, int level, const char* name, jlong start, jlong end) {
+  static void validate_pause_phase(GCPhase* phase, int level, const char* name, const Ticks& start, const Ticks& end) {
     assert(phase->level() == level, "Incorrect level");
     assert(strcmp(phase->name(), name) == 0, "Incorrect name");
     assert(phase->start() == start, "Incorrect start");
@@ -209,8 +204,8 @@
     TimePartitionPhasesIterator iter(&time_partitions);
 
     validate_pause_phase(iter.next(), 0, "PausePhase", 2, 8);
-    assert(time_partitions.sum_of_pauses() == 8-2, "Incorrect");
-    assert(time_partitions.longest_pause() == 8-2, "Incorrect");
+    assert(time_partitions.sum_of_pauses() == Ticks(8) - Ticks(2), "Incorrect");
+    assert(time_partitions.longest_pause() == Ticks(8) - Ticks(2), "Incorrect");
 
     assert(!iter.has_next(), "Too many elements");
   }
@@ -227,8 +222,8 @@
     validate_pause_phase(iter.next(), 0, "PausePhase1", 2, 3);
     validate_pause_phase(iter.next(), 0, "PausePhase2", 4, 6);
 
-    assert(time_partitions.sum_of_pauses() == 3, "Incorrect");
-    assert(time_partitions.longest_pause() == 2, "Incorrect");
+    assert(time_partitions.sum_of_pauses() == Ticks(3) - Ticks(0), "Incorrect");
+    assert(time_partitions.longest_pause() == Ticks(2) - Ticks(0), "Incorrect");
 
     assert(!iter.has_next(), "Too many elements");
   }
@@ -245,8 +240,8 @@
     validate_pause_phase(iter.next(), 0, "PausePhase", 2, 5);
     validate_pause_phase(iter.next(), 1, "SubPhase", 3, 4);
 
-    assert(time_partitions.sum_of_pauses() == 3, "Incorrect");
-    assert(time_partitions.longest_pause() == 3, "Incorrect");
+    assert(time_partitions.sum_of_pauses() == Ticks(3) - Ticks(0), "Incorrect");
+    assert(time_partitions.longest_pause() == Ticks(3) - Ticks(0), "Incorrect");
 
     assert(!iter.has_next(), "Too many elements");
   }
@@ -269,8 +264,8 @@
     validate_pause_phase(iter.next(), 2, "SubPhase2", 4, 7);
     validate_pause_phase(iter.next(), 3, "SubPhase3", 5, 6);
 
-    assert(time_partitions.sum_of_pauses() == 7, "Incorrect");
-    assert(time_partitions.longest_pause() == 7, "Incorrect");
+    assert(time_partitions.sum_of_pauses() == Ticks(7) - Ticks(0), "Incorrect");
+    assert(time_partitions.longest_pause() == Ticks(7) - Ticks(0), "Incorrect");
 
     assert(!iter.has_next(), "Too many elements");
   }
@@ -298,8 +293,8 @@
     validate_pause_phase(iter.next(), 1, "SubPhase3", 7, 8);
     validate_pause_phase(iter.next(), 1, "SubPhase4", 9, 10);
 
-    assert(time_partitions.sum_of_pauses() == 9, "Incorrect");
-    assert(time_partitions.longest_pause() == 9, "Incorrect");
+    assert(time_partitions.sum_of_pauses() == Ticks(9) - Ticks(0), "Incorrect");
+    assert(time_partitions.longest_pause() == Ticks(9) - Ticks(0), "Incorrect");
 
     assert(!iter.has_next(), "Too many elements");
   }
@@ -336,8 +331,8 @@
     validate_pause_phase(iter.next(), 2, "SubPhase22", 12, 13);
     validate_pause_phase(iter.next(), 1, "SubPhase3", 15, 16);
 
-    assert(time_partitions.sum_of_pauses() == 15, "Incorrect");
-    assert(time_partitions.longest_pause() == 15, "Incorrect");
+    assert(time_partitions.sum_of_pauses() == Ticks(15) - Ticks(0), "Incorrect");
+    assert(time_partitions.longest_pause() == Ticks(15) - Ticks(0), "Incorrect");
 
     assert(!iter.has_next(), "Too many elements");
   }
--- ./hotspot/src/share/vm/gc_implementation/shared/gcTimer.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/gc_implementation/shared/gcTimer.hpp	Wed May 07 19:26:16 2014 -0700
@@ -28,6 +28,7 @@
 #include "memory/allocation.hpp"
 #include "prims/jni_md.h"
 #include "utilities/macros.hpp"
+#include "utilities/ticks.hpp"
 
 class ConcurrentPhase;
 class GCPhase;
@@ -45,21 +46,21 @@
 class GCPhase {
   const char* _name;
   int _level;
-  jlong _start;
-  jlong _end;
+  Ticks _start;
+  Ticks _end;
 
  public:
   void set_name(const char* name) { _name = name; }
-  const char* name() { return _name; }
+  const char* name() const { return _name; }
 
-  int level() { return _level; }
+  int level() const { return _level; }
   void set_level(int level) { _level = level; }
 
-  jlong start() { return _start; }
-  void set_start(jlong time) { _start = time; }
+  const Ticks start() const { return _start; }
+  void set_start(const Ticks& time) { _start = time; }
 
-  jlong end() { return _end; }
-  void set_end(jlong time) { _end = time; }
+  const Ticks end() const { return _end; }
+  void set_end(const Ticks& time) { _end = time; }
 
   virtual void accept(PhaseVisitor* visitor) = 0;
 };
@@ -102,22 +103,22 @@
   GrowableArray<PausePhase>* _phases;
   PhasesStack _active_phases;
 
-  jlong _sum_of_pauses;
-  jlong _longest_pause;
+  Tickspan _sum_of_pauses;
+  Tickspan _longest_pause;
 
  public:
   TimePartitions();
   ~TimePartitions();
   void clear();
 
-  void report_gc_phase_start(const char* name, jlong time);
-  void report_gc_phase_end(jlong time);
+  void report_gc_phase_start(const char* name, const Ticks& time);
+  void report_gc_phase_end(const Ticks& time);
 
   int num_phases() const;
   GCPhase* phase_at(int index) const;
 
-  jlong sum_of_pauses();
-  jlong longest_pause();
+  const Tickspan sum_of_pauses() const { return _sum_of_pauses; }
+  const Tickspan longest_pause() const { return _longest_pause; }
 
   bool has_active_phases();
  private:
@@ -133,40 +134,37 @@
 class GCTimer : public ResourceObj {
   NOT_PRODUCT(friend class GCTimerTest;)
  protected:
-  jlong _gc_start;
-  jlong _gc_end;
+  Ticks _gc_start;
+  Ticks _gc_end;
   TimePartitions _time_partitions;
 
  public:
-  virtual void register_gc_start(jlong time);
-  virtual void register_gc_end(jlong time);
+  virtual void register_gc_start(const Ticks& time = Ticks::now());
+  virtual void register_gc_end(const Ticks& time = Ticks::now());
 
-  void register_gc_phase_start(const char* name, jlong time);
-  void register_gc_phase_end(jlong time);
+  void register_gc_phase_start(const char* name, const Ticks& time);
+  void register_gc_phase_end(const Ticks& time);
 
-  jlong gc_start() { return _gc_start; }
-  jlong gc_end() { return _gc_end; }
+  const Ticks gc_start() const { return _gc_start; }
+  const Ticks gc_end() const { return _gc_end; }
 
   TimePartitions* time_partitions() { return &_time_partitions; }
 
-  long longest_pause();
-  long sum_of_pauses();
-
  protected:
-  void register_gc_pause_start(const char* name, jlong time);
-  void register_gc_pause_end(jlong time);
+  void register_gc_pause_start(const char* name, const Ticks& time = Ticks::now());
+  void register_gc_pause_end(const Ticks& time = Ticks::now());
 };
 
 class STWGCTimer : public GCTimer {
  public:
-  virtual void register_gc_start(jlong time);
-  virtual void register_gc_end(jlong time);
+  virtual void register_gc_start(const Ticks& time = Ticks::now());
+  virtual void register_gc_end(const Ticks& time = Ticks::now());
 };
 
 class ConcurrentGCTimer : public GCTimer {
  public:
-  void register_gc_pause_start(const char* name, jlong time);
-  void register_gc_pause_end(jlong time);
+  void register_gc_pause_start(const char* name);
+  void register_gc_pause_end();
 };
 
 class TimePartitionPhasesIterator {
--- ./hotspot/src/share/vm/gc_implementation/shared/gcTrace.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/gc_implementation/shared/gcTrace.cpp	Wed May 07 19:26:16 2014 -0700
@@ -33,6 +33,7 @@
 #include "memory/referenceProcessorStats.hpp"
 #include "runtime/os.hpp"
 #include "utilities/globalDefinitions.hpp"
+#include "utilities/ticks.inline.hpp"
 
 #ifndef SERIALGC
 #include "gc_implementation/g1/evacuationInfo.hpp"
@@ -46,7 +47,7 @@
   return GCTracer_next_gc_id++;
 }
 
-void GCTracer::report_gc_start_impl(GCCause::Cause cause, jlong timestamp) {
+void GCTracer::report_gc_start_impl(GCCause::Cause cause, const Ticks& timestamp) {
   assert_unset_gc_id();
 
   GCId gc_id = create_new_gc_id();
@@ -55,7 +56,7 @@
   _shared_gc_info.set_start_timestamp(timestamp);
 }
 
-void GCTracer::report_gc_start(GCCause::Cause cause, jlong timestamp) {
+void GCTracer::report_gc_start(GCCause::Cause cause, const Ticks& timestamp) {
   assert_unset_gc_id();
 
   report_gc_start_impl(cause, timestamp);
@@ -65,7 +66,7 @@
   return _shared_gc_info.id() != SharedGCInfo::UNSET_GCID;
 }
 
-void GCTracer::report_gc_end_impl(jlong timestamp, TimePartitions* time_partitions) {
+void GCTracer::report_gc_end_impl(const Ticks& timestamp, TimePartitions* time_partitions) {
   assert_set_gc_id();
 
   _shared_gc_info.set_sum_of_pauses(time_partitions->sum_of_pauses());
@@ -76,7 +77,7 @@
   send_garbage_collection_event();
 }
 
-void GCTracer::report_gc_end(jlong timestamp, TimePartitions* time_partitions) {
+void GCTracer::report_gc_end(const Ticks& timestamp, TimePartitions* time_partitions) {
   assert_set_gc_id();
 
   report_gc_end_impl(timestamp, time_partitions);
@@ -97,10 +98,10 @@
   const GCId _gc_id;
   const double _size_threshold_percentage;
   const size_t _total_size_in_words;
-  const jlong _timestamp;
+  const Ticks _timestamp;
 
  public:
-  ObjectCountEventSenderClosure(GCId gc_id, size_t total_size_in_words, jlong timestamp) :
+  ObjectCountEventSenderClosure(GCId gc_id, size_t total_size_in_words, const Ticks& timestamp) :
     _gc_id(gc_id),
     _size_threshold_percentage(ObjectCountCutOffPercent / 100),
     _total_size_in_words(total_size_in_words),
@@ -154,8 +155,7 @@
       ObjectCountFilter object_filter(is_alive_cl);
       HeapInspection::populate_table(&cit, false, &object_filter);
 
-      jlong timestamp = os::elapsed_counter();
-      ObjectCountEventSenderClosure event_sender(_shared_gc_info.id(), cit.size_of_instances_in_words(), timestamp);
+      ObjectCountEventSenderClosure event_sender(_shared_gc_info.id(), cit.size_of_instances_in_words(), Ticks::now());
       cit.iterate(&event_sender);
     }
   }
@@ -168,7 +168,7 @@
   send_perm_gen_summary_event(when, perm_gen_summary);
 }
 
-void YoungGCTracer::report_gc_end_impl(jlong timestamp, TimePartitions* time_partitions) {
+void YoungGCTracer::report_gc_end_impl(const Ticks& timestamp, TimePartitions* time_partitions) {
   assert_set_gc_id();
   assert(_tenuring_threshold != UNSET_TENURING_THRESHOLD, "Tenuring threshold has not been reported");
 
@@ -188,14 +188,14 @@
   _tenuring_threshold = tenuring_threshold;
 }
 
-void OldGCTracer::report_gc_end_impl(jlong timestamp, TimePartitions* time_partitions) {
+void OldGCTracer::report_gc_end_impl(const Ticks& timestamp, TimePartitions* time_partitions) {
   assert_set_gc_id();
 
   GCTracer::report_gc_end_impl(timestamp, time_partitions);
   send_old_gc_event();
 }
 
-void ParallelOldTracer::report_gc_end_impl(jlong timestamp, TimePartitions* time_partitions) {
+void ParallelOldTracer::report_gc_end_impl(const Ticks& timestamp, TimePartitions* time_partitions) {
   assert_set_gc_id();
 
   OldGCTracer::report_gc_end_impl(timestamp, time_partitions);
@@ -221,7 +221,7 @@
   _g1_young_gc_info.set_type(type);
 }
 
-void G1NewTracer::report_gc_end_impl(jlong timestamp, TimePartitions* time_partitions) {
+void G1NewTracer::report_gc_end_impl(const Ticks& timestamp, TimePartitions* time_partitions) {
   assert_set_gc_id();
 
   YoungGCTracer::report_gc_end_impl(timestamp, time_partitions);
--- ./hotspot/src/share/vm/gc_implementation/shared/gcTrace.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/gc_implementation/shared/gcTrace.hpp	Wed May 07 19:26:16 2014 -0700
@@ -34,6 +34,7 @@
 #ifndef SERIALGC
 #include "gc_implementation/g1/g1YCTypes.hpp"
 #endif
+#include "utilities/ticks.hpp"
 
 typedef uint GCId;
 
@@ -46,8 +47,6 @@
 class BoolObjectClosure;
 
 class SharedGCInfo VALUE_OBJ_CLASS_SPEC {
-  static const jlong UNSET_TIMESTAMP = -1;
-
  public:
   static const GCId UNSET_GCID = (GCId)-1;
 
@@ -55,23 +54,30 @@
   GCId _id;
   GCName _name;
   GCCause::Cause _cause;
-  jlong _start_timestamp;
-  jlong _end_timestamp;
-  jlong _sum_of_pauses;
-  jlong _longest_pause;
+  Ticks     _start_timestamp;
+  Ticks     _end_timestamp;
+  Tickspan  _sum_of_pauses;
+  Tickspan  _longest_pause;
 
  public:
-  SharedGCInfo(GCName name) : _id(UNSET_GCID), _name(name), _cause(GCCause::_last_gc_cause),
-      _start_timestamp(UNSET_TIMESTAMP), _end_timestamp(UNSET_TIMESTAMP), _sum_of_pauses(0), _longest_pause(0) {}
+  SharedGCInfo(GCName name) :
+    _id(UNSET_GCID),
+    _name(name),
+    _cause(GCCause::_last_gc_cause),
+    _start_timestamp(),
+    _end_timestamp(),
+    _sum_of_pauses(),
+    _longest_pause() {
+  }
 
   void set_id(GCId id) { _id = id; }
   GCId id() const { return _id; }
 
-  void set_start_timestamp(jlong timestamp) { _start_timestamp = timestamp; }
-  jlong start_timestamp() const { return _start_timestamp; }
+  void set_start_timestamp(const Ticks& timestamp) { _start_timestamp = timestamp; }
+  const Ticks start_timestamp() const { return _start_timestamp; }
 
-  void set_end_timestamp(jlong timestamp) { _end_timestamp = timestamp; }
-  jlong end_timestamp() const { return _end_timestamp; }
+  void set_end_timestamp(const Ticks& timestamp) { _end_timestamp = timestamp; }
+  const Ticks end_timestamp() const { return _end_timestamp; }
 
   void set_name(GCName name) { _name = name; }
   GCName name() const { return _name; }
@@ -79,11 +85,11 @@
   void set_cause(GCCause::Cause cause) { _cause = cause; }
   GCCause::Cause cause() const { return _cause; }
 
-  void set_sum_of_pauses(jlong duration) { _sum_of_pauses = duration; }
-  jlong sum_of_pauses() const { return _sum_of_pauses; }
+  void set_sum_of_pauses(const Tickspan& duration) { _sum_of_pauses = duration; }
+  const Tickspan sum_of_pauses() const { return _sum_of_pauses; }
 
-  void set_longest_pause(jlong duration) { _longest_pause = duration; }
-  jlong longest_pause() const { return _longest_pause; }
+  void set_longest_pause(const Tickspan& duration) { _longest_pause = duration; }
+  const Tickspan longest_pause() const { return _longest_pause; }
 };
 
 class ParallelOldGCInfo VALUE_OBJ_CLASS_SPEC {
@@ -115,8 +121,8 @@
   SharedGCInfo _shared_gc_info;
 
  public:
-  void report_gc_start(GCCause::Cause cause, jlong timestamp);
-  void report_gc_end(jlong timestamp, TimePartitions* time_partitions);
+  void report_gc_start(GCCause::Cause cause, const Ticks& timestamp);
+  void report_gc_end(const Ticks& timestamp, TimePartitions* time_partitions);
   void report_gc_heap_summary(GCWhen::Type when, const GCHeapSummary& heap_summary, const PermGenSummary& perm_gen_summary) const;
   void report_gc_reference_stats(const ReferenceProcessorStats& rp) const;
   void report_object_count_after_gc(BoolObjectClosure* object_filter);
@@ -125,8 +131,8 @@
 
  protected:
   GCTracer(GCName name) : _shared_gc_info(name) {}
-  virtual void report_gc_start_impl(GCCause::Cause cause, jlong timestamp);
-  virtual void report_gc_end_impl(jlong timestamp, TimePartitions* time_partitions);
+  virtual void report_gc_start_impl(GCCause::Cause cause, const Ticks& timestamp);
+  virtual void report_gc_end_impl(const Ticks& timestamp, TimePartitions* time_partitions);
 
  private:
   void send_garbage_collection_event() const;
@@ -143,7 +149,7 @@
 
  protected:
   YoungGCTracer(GCName name) : GCTracer(name), _tenuring_threshold(UNSET_TENURING_THRESHOLD) {}
-  virtual void report_gc_end_impl(jlong timestamp, TimePartitions* time_partitions);
+  virtual void report_gc_end_impl(const Ticks& timestamp, TimePartitions* time_partitions);
 
  public:
   void report_promotion_failed(const PromotionFailedInfo& pf_info);
@@ -157,7 +163,7 @@
 class OldGCTracer : public GCTracer {
  protected:
   OldGCTracer(GCName name) : GCTracer(name) {}
-  virtual void report_gc_end_impl(jlong timestamp, TimePartitions* time_partitions);
+  virtual void report_gc_end_impl(const Ticks& timestamp, TimePartitions* time_partitions);
 
  public:
   void report_concurrent_mode_failure();
@@ -175,7 +181,7 @@
   void report_dense_prefix(void* dense_prefix);
 
  protected:
-  void report_gc_end_impl(jlong timestamp, TimePartitions* time_partitions);
+  void report_gc_end_impl(const Ticks& timestamp, TimePartitions* time_partitions);
 
  private:
   void send_parallel_old_event() const;
@@ -209,7 +215,7 @@
   G1NewTracer() : YoungGCTracer(G1New) {}
 
   void report_yc_type(G1YCType type);
-  void report_gc_end_impl(jlong timestamp, TimePartitions* time_partitions);
+  void report_gc_end_impl(const Ticks& timestamp, TimePartitions* time_partitions);
   void report_evacuation_info(EvacuationInfo* info);
   void report_evacuation_failed(EvacuationFailedInfo& ef_info);
 
--- ./hotspot/src/share/vm/gc_implementation/shared/gcTraceSend.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/gc_implementation/shared/gcTraceSend.cpp	Wed May 07 19:26:16 2014 -0700
@@ -28,8 +28,10 @@
 #include "gc_implementation/shared/gcTrace.hpp"
 #include "gc_implementation/shared/gcWhen.hpp"
 #include "gc_implementation/shared/copyFailedInfo.hpp"
+#include "runtime/os.hpp"
 #include "trace/traceBackend.hpp"
 #include "trace/tracing.hpp"
+
 #ifndef SERIALGC
 #include "gc_implementation/g1/evacuationInfo.hpp"
 #include "gc_implementation/g1/g1YCTypes.hpp"
--- ./hotspot/src/share/vm/gc_implementation/shared/gcTraceTime.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/gc_implementation/shared/gcTraceTime.cpp	Wed May 07 19:26:16 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -43,11 +43,13 @@
 # include "thread_bsd.inline.hpp"
 #endif
 
+#include "utilities/ticks.inline.hpp"
+
 
 GCTraceTime::GCTraceTime(const char* title, bool doit, bool print_cr, GCTimer* timer) :
-    _title(title), _doit(doit), _print_cr(print_cr), _timer(timer) {
+    _title(title), _doit(doit), _print_cr(print_cr), _timer(timer), _start_counter() {
   if (_doit || _timer != NULL) {
-    _start_counter = os::elapsed_counter();
+    _start_counter.stamp();
   }
 
   if (_timer != NULL) {
@@ -66,10 +68,10 @@
 }
 
 GCTraceTime::~GCTraceTime() {
-  jlong stop_counter = 0;
+  Ticks stop_counter;
 
   if (_doit || _timer != NULL) {
-    stop_counter = os::elapsed_counter();
+    stop_counter.stamp();
   }
 
   if (_timer != NULL) {
@@ -77,11 +79,12 @@
   }
 
   if (_doit) {
-    double seconds = TimeHelper::counter_to_seconds(stop_counter - _start_counter);
+    const Tickspan duration = stop_counter - _start_counter;
+    double duration_in_seconds = TicksToTimeHelper::seconds(duration);
     if (_print_cr) {
-      gclog_or_tty->print_cr(", %3.7f secs]", seconds);
+      gclog_or_tty->print_cr(", %3.7f secs]", duration_in_seconds);
     } else {
-      gclog_or_tty->print(", %3.7f secs]", seconds);
+      gclog_or_tty->print(", %3.7f secs]", duration_in_seconds);
     }
     gclog_or_tty->flush();
   }
--- ./hotspot/src/share/vm/gc_implementation/shared/gcTraceTime.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/gc_implementation/shared/gcTraceTime.hpp	Wed May 07 19:26:16 2014 -0700
@@ -26,6 +26,7 @@
 #define SHARE_VM_GC_IMPLEMENTATION_SHARED_GCTRACETIME_HPP
 
 #include "prims/jni_md.h"
+#include "utilities/ticks.hpp"
 
 class GCTimer;
 
@@ -34,7 +35,7 @@
   bool _doit;
   bool _print_cr;
   GCTimer* _timer;
-  jlong _start_counter;
+  Ticks _start_counter;
 
  public:
   GCTraceTime(const char* title, bool doit, bool print_cr, GCTimer* timer);
--- ./hotspot/src/share/vm/gc_implementation/shared/objectCountEventSender.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/gc_implementation/shared/objectCountEventSender.cpp	Wed May 07 19:26:16 2014 -0700
@@ -28,8 +28,10 @@
 #include "memory/heapInspection.hpp"
 #include "trace/tracing.hpp"
 #include "utilities/globalDefinitions.hpp"
+#include "utilities/ticks.hpp"
 
-void ObjectCountEventSender::send(const KlassInfoEntry* entry, GCId gc_id, jlong timestamp) {
+void ObjectCountEventSender::send(const KlassInfoEntry* entry, GCId gc_id, const Ticks& timestamp) {
+#if INCLUDE_TRACE
   assert(Tracing::is_event_enabled(EventObjectCountAfterGC::eventId),
          "Only call this method if the event is enabled");
 
@@ -40,6 +42,8 @@
   event.set_totalSize(entry->words() * BytesPerWord);
   event.set_endtime(timestamp);
   event.commit();
+
+#endif
 }
 
 bool ObjectCountEventSender::should_send_event() {
--- ./hotspot/src/share/vm/gc_implementation/shared/objectCountEventSender.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/gc_implementation/shared/objectCountEventSender.hpp	Wed May 07 19:26:16 2014 -0700
@@ -29,10 +29,11 @@
 #include "memory/allocation.hpp"
 
 class KlassInfoEntry;
+class Ticks;
 
 class ObjectCountEventSender : public AllStatic {
  public:
-  static void send(const KlassInfoEntry* entry, GCId gc_id, jlong timestamp);
+  static void send(const KlassInfoEntry* entry, GCId gc_id, const Ticks& timestamp);
   static bool should_send_event();
 };
 
--- ./hotspot/src/share/vm/gc_interface/collectedHeap.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/gc_interface/collectedHeap.cpp	Wed May 07 19:26:16 2014 -0700
@@ -121,6 +121,14 @@
   }
 }
 
+void CollectedHeap::register_nmethod(nmethod* nm) {
+  assert_locked_or_safepoint(CodeCache_lock);
+}
+
+void CollectedHeap::unregister_nmethod(nmethod* nm) {
+  assert_locked_or_safepoint(CodeCache_lock);
+}
+
 void CollectedHeap::trace_heap(GCWhen::Type when, GCTracer* gc_tracer) {
   const GCHeapSummary& heap_summary = create_heap_summary();
   const PermGenSummary& perm_summary = create_perm_gen_summary();
--- ./hotspot/src/share/vm/gc_interface/collectedHeap.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/gc_interface/collectedHeap.hpp	Wed May 07 19:26:16 2014 -0700
@@ -49,6 +49,7 @@
 class Thread;
 class ThreadClosure;
 class VirtualSpaceSummary;
+class nmethod;
 
 class GCMessage : public FormatBuffer<1024> {
  public:
@@ -667,6 +668,11 @@
   void print_heap_before_gc();
   void print_heap_after_gc();
 
+  // Registering and unregistering an nmethod (compiled code) with the heap.
+  // Override with specific mechanism for each specialized heap type.
+  virtual void register_nmethod(nmethod* nm);
+  virtual void unregister_nmethod(nmethod* nm);
+
   void trace_heap_before_gc(GCTracer* gc_tracer);
   void trace_heap_after_gc(GCTracer* gc_tracer);
 
--- ./hotspot/src/share/vm/interpreter/interpreterRuntime.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/interpreter/interpreterRuntime.cpp	Wed May 07 19:26:16 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -1222,3 +1222,24 @@
                        size_of_arguments * Interpreter::stackElementSize);
 IRT_END
 #endif
+
+// This is a support of the JVMTI PopFrame interface.
+// Make sure it is an invokestatic of a polymorphic intrinsic that has a member_name argument
+// and return it as a vm_result so that it can be reloaded in the list of invokestatic parameters.
+// The dmh argument is a reference to a DirectMethoHandle that has a member name field.
+IRT_ENTRY(void, InterpreterRuntime::member_name_arg_or_null(JavaThread* thread, address dmh,
+                                                            methodOopDesc* method, address bcp))
+  Bytecodes::Code code = Bytecodes::code_at(method, bcp);
+  if (code != Bytecodes::_invokestatic) {
+    return;
+  }
+  constantPoolOopDesc* cpool = method->constants();
+  int cp_index = Bytes::get_native_u2(bcp + 1) + constantPoolOopDesc::CPCACHE_INDEX_TAG;
+  Symbol* cname = cpool->klass_name_at(cpool->klass_ref_index_at(cp_index));
+  Symbol* mname = cpool->name_ref_at(cp_index);
+
+  if (MethodHandles::has_member_arg(cname, mname)) {
+    oop member_name = java_lang_invoke_DirectMethodHandle::member((oop)dmh);
+    thread->set_vm_result(member_name);
+  }
+IRT_END
--- ./hotspot/src/share/vm/interpreter/interpreterRuntime.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/interpreter/interpreterRuntime.hpp	Wed May 07 19:26:16 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -106,6 +106,7 @@
   static void    create_exception(JavaThread* thread, char* name, char* message);
   static void    create_klass_exception(JavaThread* thread, char* name, oopDesc* obj);
   static address exception_handler_for_exception(JavaThread* thread, oopDesc* exception);
+  static void    member_name_arg_or_null(JavaThread* thread, address dmh, methodOopDesc* m, address bcp);
   static void    throw_pending_exception(JavaThread* thread);
 
   // Statics & fields
--- ./hotspot/src/share/vm/memory/cardTableModRefBS.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/memory/cardTableModRefBS.cpp	Wed May 07 19:26:16 2014 -0700
@@ -400,60 +400,6 @@
   inline_write_ref_field(field, newVal);
 }
 
-/*
-   Claimed and deferred bits are used together in G1 during the evacuation
-   pause. These bits can have the following state transitions:
-   1. The claimed bit can be put over any other card state. Except that
-      the "dirty -> dirty and claimed" transition is checked for in
-      G1 code and is not used.
-   2. Deferred bit can be set only if the previous state of the card
-      was either clean or claimed. mark_card_deferred() is wait-free.
-      We do not care if the operation is be successful because if
-      it does not it will only result in duplicate entry in the update
-      buffer because of the "cache-miss". So it's not worth spinning.
- */
-
-
-bool CardTableModRefBS::claim_card(size_t card_index) {
-  jbyte val = _byte_map[card_index];
-  assert(val != dirty_card_val(), "Shouldn't claim a dirty card");
-  while (val == clean_card_val() ||
-         (val & (clean_card_mask_val() | claimed_card_val())) != claimed_card_val()) {
-    jbyte new_val = val;
-    if (val == clean_card_val()) {
-      new_val = (jbyte)claimed_card_val();
-    } else {
-      new_val = val | (jbyte)claimed_card_val();
-    }
-    jbyte res = Atomic::cmpxchg(new_val, &_byte_map[card_index], val);
-    if (res == val) {
-      return true;
-    }
-    val = res;
-  }
-  return false;
-}
-
-bool CardTableModRefBS::mark_card_deferred(size_t card_index) {
-  jbyte val = _byte_map[card_index];
-  // It's already processed
-  if ((val & (clean_card_mask_val() | deferred_card_val())) == deferred_card_val()) {
-    return false;
-  }
-  // Cached bit can be installed either on a clean card or on a claimed card.
-  jbyte new_val = val;
-  if (val == clean_card_val()) {
-    new_val = (jbyte)deferred_card_val();
-  } else {
-    if (val & claimed_card_val()) {
-      new_val = val | (jbyte)deferred_card_val();
-    }
-  }
-  if (new_val != val) {
-    Atomic::cmpxchg(new_val, &_byte_map[card_index], val);
-  }
-  return true;
-}
 
 void CardTableModRefBS::non_clean_card_iterate_possibly_parallel(Space* sp,
                                                                  MemRegion mr,
--- ./hotspot/src/share/vm/memory/cardTableModRefBS.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/memory/cardTableModRefBS.hpp	Wed May 07 19:26:16 2014 -0700
@@ -344,34 +344,10 @@
     _byte_map[card_index] = dirty_card_val();
   }
 
-  bool is_card_claimed(size_t card_index) {
-    jbyte val = _byte_map[card_index];
-    return (val & (clean_card_mask_val() | claimed_card_val())) == claimed_card_val();
-  }
-
-  void set_card_claimed(size_t card_index) {
-      jbyte val = _byte_map[card_index];
-      if (val == clean_card_val()) {
-        val = (jbyte)claimed_card_val();
-      } else {
-        val |= (jbyte)claimed_card_val();
-      }
-      _byte_map[card_index] = val;
-  }
-
-  bool claim_card(size_t card_index);
-
   bool is_card_clean(size_t card_index) {
     return _byte_map[card_index] == clean_card_val();
   }
 
-  bool is_card_deferred(size_t card_index) {
-    jbyte val = _byte_map[card_index];
-    return (val & (clean_card_mask_val() | deferred_card_val())) == deferred_card_val();
-  }
-
-  bool mark_card_deferred(size_t card_index);
-
   // Card marking array base (adjusted for heap low boundary)
   // This would be the 0th element of _byte_map, if the heap started at 0x0.
   // But since the heap starts at some higher address, this points to somewhere
--- ./hotspot/src/share/vm/memory/collectorPolicy.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/memory/collectorPolicy.cpp	Wed May 07 19:26:16 2014 -0700
@@ -230,6 +230,8 @@
       alignment = lcm(os::large_page_size(), alignment);
   }
 
+  assert(alignment >= min_alignment(), "Must be");
+
   return alignment;
 }
 
--- ./hotspot/src/share/vm/memory/defNewGeneration.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/memory/defNewGeneration.cpp	Wed May 07 19:26:16 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -538,7 +538,7 @@
 
   GenCollectedHeap* gch = GenCollectedHeap::heap();
 
-  _gc_timer->register_gc_start(os::elapsed_counter());
+  _gc_timer->register_gc_start();
   DefNewTracer gc_tracer;
   gc_tracer.report_gc_start(gch->gc_cause(), _gc_timer->gc_start());
 
@@ -682,7 +682,7 @@
   gch->trace_heap_after_gc(&gc_tracer);
   gc_tracer.report_tenuring_threshold(tenuring_threshold());
 
-  _gc_timer->register_gc_end(os::elapsed_counter());
+  _gc_timer->register_gc_end();
 
   gc_tracer.report_gc_end(_gc_timer->gc_end(), _gc_timer->time_partitions());
 }
@@ -1004,6 +1004,9 @@
   // have to use it here, as well.
   HeapWord* result = eden()->par_allocate(word_size);
   if (result != NULL) {
+    if (CMSEdenChunksRecordAlways && _next_gen != NULL) {
+      _next_gen->sample_eden_chunk();
+    }
     return result;
   }
   do {
@@ -1034,13 +1037,19 @@
   // circular dependency at compile time.
   if (result == NULL) {
     result = allocate_from_space(word_size);
+  } else if (CMSEdenChunksRecordAlways && _next_gen != NULL) {
+    _next_gen->sample_eden_chunk();
   }
   return result;
 }
 
 HeapWord* DefNewGeneration::par_allocate(size_t word_size,
                                          bool is_tlab) {
-  return eden()->par_allocate(word_size);
+  HeapWord* res = eden()->par_allocate(word_size);
+  if (CMSEdenChunksRecordAlways && _next_gen != NULL) {
+    _next_gen->sample_eden_chunk();
+  }
+  return res;
 }
 
 void DefNewGeneration::gc_prologue(bool full) {
--- ./hotspot/src/share/vm/memory/genCollectedHeap.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/memory/genCollectedHeap.cpp	Wed May 07 19:26:16 2014 -0700
@@ -99,17 +99,19 @@
   guarantee(HeapWordSize == wordSize, "HeapWordSize must equal wordSize");
 
   // The heap must be at least as aligned as generations.
-  size_t alignment = Generation::GenGrain;
+  size_t gen_alignment = Generation::GenGrain;
 
   _gen_specs = gen_policy()->generations();
   PermanentGenerationSpec *perm_gen_spec =
                                 collector_policy()->permanent_generation();
 
+  size_t heap_alignment = collector_policy()->max_alignment();
+
   // Make sure the sizes are all aligned.
   for (i = 0; i < _n_gens; i++) {
-    _gen_specs[i]->align(alignment);
+    _gen_specs[i]->align(gen_alignment);
   }
-  perm_gen_spec->align(alignment);
+  perm_gen_spec->align(heap_alignment);
 
   // If we are dumping the heap, then allocate a wasted block of address
   // space in order to push the heap to a lower address.  This extra
@@ -130,9 +132,9 @@
   char* heap_address;
   size_t total_reserved = 0;
   int n_covered_regions = 0;
-  ReservedSpace heap_rs(0);
+  ReservedSpace heap_rs;
 
-  heap_address = allocate(alignment, perm_gen_spec, &total_reserved,
+  heap_address = allocate(heap_alignment, perm_gen_spec, &total_reserved,
                           &n_covered_regions, &heap_rs);
 
   if (UseSharedSpaces) {
@@ -142,7 +144,7 @@
       }
       FileMapInfo* mapinfo = FileMapInfo::current_info();
       mapinfo->fail_continue("Unable to reserve shared region.");
-      allocate(alignment, perm_gen_spec, &total_reserved, &n_covered_regions,
+      allocate(heap_alignment, perm_gen_spec, &total_reserved, &n_covered_regions,
                &heap_rs);
     }
   }
@@ -207,19 +209,21 @@
   const size_t pageSize = UseLargePages ?
       os::large_page_size() : os::vm_page_size();
 
+  assert(alignment % pageSize == 0, "Must be");
+
   for (int i = 0; i < _n_gens; i++) {
     total_reserved = add_and_check_overflow(total_reserved, _gen_specs[i]->max_size());
     n_covered_regions += _gen_specs[i]->n_covered_regions();
   }
 
-  assert(total_reserved % pageSize == 0,
-         err_msg("Gen size; total_reserved=" SIZE_FORMAT ", pageSize="
-                 SIZE_FORMAT, total_reserved, pageSize));
+  assert(total_reserved % alignment == 0,
+         err_msg("Gen size; total_reserved=" SIZE_FORMAT ", alignment="
+                 SIZE_FORMAT, total_reserved, alignment));
   total_reserved = add_and_check_overflow(total_reserved, perm_gen_spec->max_size());
-  assert(total_reserved % pageSize == 0,
-         err_msg("Perm size; total_reserved=" SIZE_FORMAT ", pageSize="
+  assert(total_reserved % alignment == 0,
+         err_msg("Perm size; total_reserved=" SIZE_FORMAT ", alignment="
                  SIZE_FORMAT ", perm gen max=" SIZE_FORMAT, total_reserved,
-                 pageSize, perm_gen_spec->max_size()));
+                 alignment, perm_gen_spec->max_size()));
 
   n_covered_regions += perm_gen_spec->n_covered_regions();
 
@@ -229,7 +233,9 @@
   total_reserved = add_and_check_overflow(total_reserved, misc);
 
   if (UseLargePages) {
+    assert(misc == 0, "CDS does not support Large Pages");
     assert(total_reserved != 0, "total_reserved cannot be 0");
+    assert(is_size_aligned(total_reserved, os::large_page_size()), "Must be");
     total_reserved = round_up_and_check_overflow(total_reserved, os::large_page_size());
   }
 
@@ -250,7 +256,7 @@
   } else {
     heap_address = NULL;  // any address will do.
     if (UseCompressedOops) {
-      heap_address = Universe::preferred_heap_base(total_reserved, Universe::UnscaledNarrowOop);
+      heap_address = Universe::preferred_heap_base(total_reserved, alignment, Universe::UnscaledNarrowOop);
       *_total_reserved = total_reserved;
       *_n_covered_regions = n_covered_regions;
       *heap_rs = ReservedHeapSpace(total_reserved, alignment,
@@ -260,13 +266,13 @@
         // Failed to reserve at specified address - the requested memory
         // region is taken already, for example, by 'java' launcher.
         // Try again to reserver heap higher.
-        heap_address = Universe::preferred_heap_base(total_reserved, Universe::ZeroBasedNarrowOop);
+        heap_address = Universe::preferred_heap_base(total_reserved, alignment, Universe::ZeroBasedNarrowOop);
         *heap_rs = ReservedHeapSpace(total_reserved, alignment,
                                      UseLargePages, heap_address);
 
         if (heap_address != NULL && !heap_rs->is_reserved()) {
           // Failed to reserve at specified address again - give up.
-          heap_address = Universe::preferred_heap_base(total_reserved, Universe::HeapBasedNarrowOop);
+          heap_address = Universe::preferred_heap_base(total_reserved, alignment, Universe::HeapBasedNarrowOop);
           assert(heap_address == NULL, "");
           *heap_rs = ReservedHeapSpace(total_reserved, alignment,
                                        UseLargePages, heap_address);
@@ -538,8 +544,7 @@
             prepare_for_verify();
             prepared_for_verification = true;
           }
-          gclog_or_tty->print(" VerifyBeforeGC:");
-          Universe::verify();
+          Universe::verify(" VerifyBeforeGC:");
         }
         COMPILER2_PRESENT(DerivedPointerTable::clear());
 
@@ -610,8 +615,7 @@
         if (VerifyAfterGC && i >= VerifyGCLevel &&
             total_collections() >= VerifyGCStartAt) {
           HandleMark hm;  // Discard invalid handles created during verification
-          gclog_or_tty->print(" VerifyAfterGC:");
-          Universe::verify();
+          Universe::verify(" VerifyAfterGC:");
         }
 
         if (PrintGCDetails) {
@@ -932,12 +936,13 @@
 // Returns "TRUE" iff "p" points into the committed areas of the heap.
 bool GenCollectedHeap::is_in(const void* p) const {
   #ifndef ASSERT
-  guarantee(VerifyBeforeGC   ||
-            VerifyDuringGC   ||
-            VerifyBeforeExit ||
-            PrintAssembly    ||
-            tty->count() != 0 ||   // already printing
-            VerifyAfterGC    ||
+  guarantee(VerifyBeforeGC      ||
+            VerifyDuringGC      ||
+            VerifyBeforeExit    ||
+            VerifyDuringStartup ||
+            PrintAssembly       ||
+            tty->count() != 0   ||   // already printing
+            VerifyAfterGC       ||
     VMError::fatal_error_in_progress(), "too expensive");
 
   #endif
--- ./hotspot/src/share/vm/memory/generation.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/memory/generation.cpp	Wed May 07 19:26:16 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -476,16 +476,16 @@
     x(ref_processor(), gch->reserved_region());
 
   STWGCTimer* gc_timer = GenMarkSweep::gc_timer();
-  gc_timer->register_gc_start(os::elapsed_counter());
+  gc_timer->register_gc_start();
 
   SerialOldTracer* gc_tracer = GenMarkSweep::gc_tracer();
   gc_tracer->report_gc_start(gch->gc_cause(), gc_timer->gc_start());
 
   GenMarkSweep::invoke_at_safepoint(_level, ref_processor(), clear_all_soft_refs);
 
-  gc_timer->register_gc_end(os::elapsed_counter());
+  gc_timer->register_gc_end();
 
-  gc_tracer->report_gc_end(os::elapsed_counter(), gc_timer->time_partitions());
+  gc_tracer->report_gc_end(gc_timer->gc_end(), gc_timer->time_partitions());
 
   SpecializationStats::print();
 }
--- ./hotspot/src/share/vm/memory/generation.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/memory/generation.hpp	Wed May 07 19:26:16 2014 -0700
@@ -457,6 +457,7 @@
   // expected to be GC worker thread-local, with the worker index
   // indicated by "thr_num".
   virtual void* get_data_recorder(int thr_num) { return NULL; }
+  virtual void sample_eden_chunk() {}
 
   // Some generations may require some cleanup actions before allowing
   // a verification.
--- ./hotspot/src/share/vm/memory/iterator.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/memory/iterator.cpp	Wed May 07 19:26:16 2014 -0700
@@ -70,7 +70,7 @@
 }
 
 void CodeBlobToOopClosure::do_newly_marked_nmethod(nmethod* nm) {
-  nm->oops_do(_cl, /*do_strong_roots_only=*/ true);
+  nm->oops_do(_cl, /*do_strong_roots_only=*/ true, /*allow_zombie=*/ false);
 }
 
 void CodeBlobToOopClosure::do_code_blob(CodeBlob* cb) {
--- ./hotspot/src/share/vm/memory/sharedHeap.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/memory/sharedHeap.cpp	Wed May 07 19:26:16 2014 -0700
@@ -64,7 +64,8 @@
   }
   _sh = this;  // ch is static, should be set only once.
   if ((UseParNewGC ||
-      (UseConcMarkSweepGC && CMSParallelRemarkEnabled) ||
+      (UseConcMarkSweepGC && (CMSParallelInitialMarkEnabled ||
+                              CMSParallelRemarkEnabled)) ||
        UseG1GC) &&
       ParallelGCThreads > 0) {
     _workers = new FlexibleWorkGang("Parallel GC Threads", ParallelGCThreads,
@@ -148,7 +149,8 @@
                                       ScanningOption so,
                                       OopClosure* roots,
                                       CodeBlobClosure* code_roots,
-                                      OopsInGenClosure* perm_blk) {
+                                      OopsInGenClosure* perm_blk,
+                                      bool manages_code_roots) {
   StrongRootsScope srs(this, activate_scope);
   // General strong roots.
   assert(_strong_roots_parity != 0, "must have called prologue code");
@@ -216,7 +218,7 @@
         CodeCache::blobs_do(code_roots);
       }
     } else if (so & (SO_SystemClasses|SO_AllClasses)) {
-      if (!collecting_perm_gen) {
+      if (!manages_code_roots && !collecting_perm_gen) {
         // If we are collecting from class statics, but we are not going to
         // visit all of the CodeCache, collect from the non-perm roots if any.
         // This makes the code cache function temporarily as a source of strong
--- ./hotspot/src/share/vm/memory/sharedHeap.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/memory/sharedHeap.hpp	Wed May 07 19:26:16 2014 -0700
@@ -267,7 +267,8 @@
                             ScanningOption so,
                             OopClosure* roots,
                             CodeBlobClosure* code_roots,
-                            OopsInGenClosure* perm_blk);
+                            OopsInGenClosure* perm_blk,
+                            bool manages_code_roots = false);
 
   // Apply "blk" to all the weak roots of the system.  These include
   // JNI weak roots, the code cache, system dictionary, symbol table,
--- ./hotspot/src/share/vm/memory/universe.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/memory/universe.cpp	Wed May 07 19:26:16 2014 -0700
@@ -826,17 +826,23 @@
 // 32Gb
 // OopEncodingHeapMax == NarrowOopHeapMax << LogMinObjAlignmentInBytes;
 
-char* Universe::preferred_heap_base(size_t heap_size, NARROW_OOP_MODE mode) {
+char* Universe::preferred_heap_base(size_t heap_size, size_t alignment, NARROW_OOP_MODE mode) {
+  assert(is_size_aligned((size_t)OopEncodingHeapMax, alignment), "Must be");
+  assert(is_size_aligned((size_t)NarrowOopHeapMax, alignment), "Must be");
+  assert(is_size_aligned(heap_size, alignment), "Must be");
+
+  uintx heap_base_min_address_aligned = align_size_up(HeapBaseMinAddress, alignment);
+
   size_t base = 0;
 #ifdef _LP64
   if (UseCompressedOops) {
     assert(mode == UnscaledNarrowOop  ||
            mode == ZeroBasedNarrowOop ||
            mode == HeapBasedNarrowOop, "mode is invalid");
-    const size_t total_size = heap_size + HeapBaseMinAddress;
+    const size_t total_size = heap_size + heap_base_min_address_aligned;
     // Return specified base for the first request.
     if (!FLAG_IS_DEFAULT(HeapBaseMinAddress) && (mode == UnscaledNarrowOop)) {
-      base = HeapBaseMinAddress;
+      base = heap_base_min_address_aligned;
     } else if (total_size <= OopEncodingHeapMax && (mode != HeapBasedNarrowOop)) {
       if (total_size <= NarrowOopHeapMax && (mode == UnscaledNarrowOop) &&
           (Universe::narrow_oop_shift() == 0)) {
@@ -882,6 +888,8 @@
     }
   }
 #endif
+
+  assert(is_ptr_aligned((char*)base, alignment), "Must be");
   return (char*)base; // also return NULL (don't care) for 32-bit VM
 }
 
@@ -1366,7 +1374,7 @@
   st->print_cr("}");
 }
 
-void Universe::verify(bool silent, VerifyOption option) {
+void Universe::verify(VerifyOption option, const char* prefix, bool silent) {
   if (SharedSkipVerify) {
     return;
   }
@@ -1387,11 +1395,12 @@
   HandleMark hm;  // Handles created during verification can be zapped
   _verify_count++;
 
+  if (!silent) gclog_or_tty->print(prefix);
   if (!silent) gclog_or_tty->print("[Verifying ");
   if (!silent) gclog_or_tty->print("threads ");
   Threads::verify();
+  if (!silent) gclog_or_tty->print("heap ");
   heap()->verify(silent, option);
-
   if (!silent) gclog_or_tty->print("syms ");
   SymbolTable::verify();
   if (!silent) gclog_or_tty->print("strs ");
--- ./hotspot/src/share/vm/memory/universe.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/memory/universe.hpp	Wed May 07 19:26:16 2014 -0700
@@ -380,7 +380,7 @@
 
   static NARROW_OOP_MODE narrow_oop_mode();
 
-  static char* preferred_heap_base(size_t heap_size, NARROW_OOP_MODE mode);
+  static char* preferred_heap_base(size_t heap_size, size_t alignment, NARROW_OOP_MODE mode);
 
   // Historic gc information
   static size_t get_heap_capacity_at_last_gc()         { return _heap_capacity_at_last_gc; }
@@ -419,12 +419,12 @@
 
   // Debugging
   static bool verify_in_progress() { return _verify_in_progress; }
-  static void verify(bool silent, VerifyOption option);
-  static void verify(bool silent) {
-    verify(silent, VerifyOption_Default /* option */);
+  static void verify(VerifyOption option, const char* prefix, bool silent = VerifySilently);
+  static void verify(const char* prefix, bool silent = VerifySilently) {
+    verify(VerifyOption_Default, prefix, silent);
   }
-  static void verify() {
-    verify(false /* silent */);
+  static void verify(bool silent = VerifySilently) {
+    verify("", silent);
   }
 
   static int  verify_count()       { return _verify_count; }
--- ./hotspot/src/share/vm/oops/constantPoolOop.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/oops/constantPoolOop.cpp	Wed May 07 19:26:16 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -1026,24 +1026,13 @@
 
   case JVM_CONSTANT_InvokeDynamic:
   {
-    int k1 = invoke_dynamic_bootstrap_method_ref_index_at(index1);
-    int k2 = cp2->invoke_dynamic_bootstrap_method_ref_index_at(index2);
-    bool match = compare_entry_to(k1, cp2, k2, CHECK_false);
-    if (!match)  return false;
-    k1 = invoke_dynamic_name_and_type_ref_index_at(index1);
-    k2 = cp2->invoke_dynamic_name_and_type_ref_index_at(index2);
-    match = compare_entry_to(k1, cp2, k2, CHECK_false);
-    if (!match)  return false;
-    int argc = invoke_dynamic_argument_count_at(index1);
-    if (argc == cp2->invoke_dynamic_argument_count_at(index2)) {
-      for (int j = 0; j < argc; j++) {
-        k1 = invoke_dynamic_argument_index_at(index1, j);
-        k2 = cp2->invoke_dynamic_argument_index_at(index2, j);
-        match = compare_entry_to(k1, cp2, k2, CHECK_false);
-        if (!match)  return false;
-      }
-      return true;           // got through loop; all elements equal
-    }
+    int k1 = invoke_dynamic_name_and_type_ref_index_at(index1);
+    int k2 = cp2->invoke_dynamic_name_and_type_ref_index_at(index2);
+    int i1 = invoke_dynamic_bootstrap_specifier_index(index1);
+    int i2 = cp2->invoke_dynamic_bootstrap_specifier_index(index2);
+    bool match = compare_entry_to(k1, cp2, k2, CHECK_false) &&
+                 compare_operand_to(i1, cp2, i2, CHECK_false);
+    return match;
   } break;
 
   case JVM_CONSTANT_UnresolvedString:
@@ -1078,12 +1067,135 @@
 } // end compare_entry_to()
 
 
+// Resize the operands array with delta_len and delta_size.
+// Used in RedefineClasses for CP merge.
+void constantPoolOopDesc::resize_operands(int delta_len, int delta_size, TRAPS) {
+  int old_len  = operand_array_length(operands());
+  int new_len  = old_len + delta_len;
+  int min_len  = (delta_len > 0) ? old_len : new_len;
+
+  int old_size = operands()->length();
+  int new_size = old_size + delta_size;
+  int min_size = (delta_size > 0) ? old_size : new_size;
+
+  typeArrayHandle new_ops = oopFactory::new_permanent_intArray(new_size, CHECK);
+
+  // Set index in the resized array for existing elements only
+  for (int idx = 0; idx < min_len; idx++) {
+    int offset = operand_offset_at(idx);                         // offset in original array
+    operand_offset_at_put(new_ops(), idx, offset + 2*delta_len); // offset in resized array
+  }
+  // Copy the bootstrap specifiers only
+  Copy::conjoint_memory_atomic(operands()->short_at_addr(2*old_len),
+                               new_ops->short_at_addr(2*new_len),
+                               (min_size - 2*min_len) * sizeof(u2));
+  // Explicit deallocation of old operands array is not needed for 7u
+  set_operands(new_ops());
+} // end resize_operands()
+
+
+// Extend the operands array with the length and size of the ext_cp operands.
+// Used in RedefineClasses for CP merge.
+void constantPoolOopDesc::extend_operands(constantPoolHandle ext_cp, TRAPS) {
+  int delta_len = operand_array_length(ext_cp->operands());
+  if (delta_len == 0) {
+    return; // nothing to do
+  }
+  int delta_size = ext_cp->operands()->length();
+
+  assert(delta_len  > 0 && delta_size > 0, "extended operands array must be bigger");
+
+  if (operand_array_length(operands()) == 0) {
+    typeArrayHandle new_ops = oopFactory::new_permanent_intArray(delta_size, CHECK);
+    // The first element index defines the offset of second part
+    operand_offset_at_put(new_ops(), 0, 2*delta_len); // offset in new array
+    set_operands(new_ops());
+  } else {
+    resize_operands(delta_len, delta_size, CHECK);
+  }
+
+} // end extend_operands()
+
+
+// Shrink the operands array to a smaller array with new_len length.
+// Used in RedefineClasses for CP merge.
+void constantPoolOopDesc::shrink_operands(int new_len, TRAPS) {
+  int old_len = operand_array_length(operands());
+  if (new_len == old_len) {
+    return; // nothing to do
+  }
+  assert(new_len < old_len, "shrunken operands array must be smaller");
+
+  int free_base  = operand_next_offset_at(new_len - 1);
+  int delta_len  = new_len - old_len;
+  int delta_size = 2*delta_len + free_base - operands()->length();
+
+  resize_operands(delta_len, delta_size, CHECK);
+
+} // end shrink_operands()
+
+
+void constantPoolOopDesc::copy_operands(constantPoolHandle from_cp,
+                                        constantPoolHandle to_cp,
+                                        TRAPS) {
+
+  int from_oplen = operand_array_length(from_cp->operands());
+  int old_oplen  = operand_array_length(to_cp->operands());
+  if (from_oplen != 0) {
+    // append my operands to the target's operands array
+    if (old_oplen == 0) {
+      to_cp->set_operands(from_cp->operands());  // reuse; do not merge
+    } else {
+      int old_len  = to_cp->operands()->length();
+      int from_len = from_cp->operands()->length();
+      int old_off  = old_oplen * sizeof(u2);
+      int from_off = from_oplen * sizeof(u2);
+      typeArrayHandle new_operands = oopFactory::new_permanent_intArray(old_len + from_len, CHECK);
+      int fillp = 0, len = 0;
+      // first part of dest
+      Copy::conjoint_memory_atomic(to_cp->operands()->short_at_addr(0),
+                                   new_operands->short_at_addr(fillp),
+                                   (len = old_off) * sizeof(u2));
+      fillp += len;
+      // first part of src
+      Copy::conjoint_memory_atomic(from_cp->operands()->short_at_addr(0),
+                                   new_operands->short_at_addr(fillp),
+                                   (len = from_off) * sizeof(u2));
+      fillp += len;
+      // second part of dest
+      Copy::conjoint_memory_atomic(to_cp->operands()->short_at_addr(old_off),
+                                   new_operands->short_at_addr(fillp),
+                                   (len = old_len - old_off) * sizeof(u2));
+      fillp += len;
+      // second part of src
+      Copy::conjoint_memory_atomic(from_cp->operands()->short_at_addr(from_off),
+                                   new_operands->short_at_addr(fillp),
+                                   (len = from_len - from_off) * sizeof(u2));
+      fillp += len;
+      assert(fillp == new_operands->length(), "");
+
+      // Adjust indexes in the first part of the copied operands array.
+      for (int j = 0; j < from_oplen; j++) {
+        int offset = operand_offset_at(new_operands(), old_oplen + j);
+        assert(offset == operand_offset_at(from_cp->operands(), j), "correct copy");
+        offset += old_len;  // every new tuple is preceded by old_len extra u2's
+        operand_offset_at_put(new_operands(), old_oplen + j, offset);
+      }
+
+      // replace target operands array with combined array
+      to_cp->set_operands(new_operands());
+    }
+  }
+} // end copy_operands()
+
+
 // Copy this constant pool's entries at start_i to end_i (inclusive)
 // to the constant pool to_cp's entries starting at to_i. A total of
 // (end_i - start_i) + 1 entries are copied.
 void constantPoolOopDesc::copy_cp_to_impl(constantPoolHandle from_cp, int start_i, int end_i,
        constantPoolHandle to_cp, int to_i, TRAPS) {
 
+
   int dest_i = to_i;  // leave original alone for debug purposes
 
   for (int src_i = start_i; src_i <= end_i; /* see loop bottom */ ) {
@@ -1104,56 +1216,9 @@
       break;
     }
   }
+  copy_operands(from_cp, to_cp, CHECK);
 
-  int from_oplen = operand_array_length(from_cp->operands());
-  int old_oplen  = operand_array_length(to_cp->operands());
-  if (from_oplen != 0) {
-    // append my operands to the target's operands array
-    if (old_oplen == 0) {
-      to_cp->set_operands(from_cp->operands());  // reuse; do not merge
-    } else {
-      int old_len  = to_cp->operands()->length();
-      int from_len = from_cp->operands()->length();
-      int old_off  = old_oplen * sizeof(u2);
-      int from_off = from_oplen * sizeof(u2);
-      typeArrayHandle new_operands = oopFactory::new_permanent_shortArray(old_len + from_len, CHECK);
-      int fillp = 0, len = 0;
-      // first part of dest
-      Copy::conjoint_memory_atomic(to_cp->operands()->short_at_addr(0),
-                                   new_operands->short_at_addr(fillp),
-                                   (len = old_off) * sizeof(u2));
-      fillp += len;
-      // first part of src
-      Copy::conjoint_memory_atomic(to_cp->operands()->short_at_addr(0),
-                                   new_operands->short_at_addr(fillp),
-                                   (len = from_off) * sizeof(u2));
-      fillp += len;
-      // second part of dest
-      Copy::conjoint_memory_atomic(to_cp->operands()->short_at_addr(old_off),
-                                   new_operands->short_at_addr(fillp),
-                                   (len = old_len - old_off) * sizeof(u2));
-      fillp += len;
-      // second part of src
-      Copy::conjoint_memory_atomic(to_cp->operands()->short_at_addr(from_off),
-                                   new_operands->short_at_addr(fillp),
-                                   (len = from_len - from_off) * sizeof(u2));
-      fillp += len;
-      assert(fillp == new_operands->length(), "");
-
-      // Adjust indexes in the first part of the copied operands array.
-      for (int j = 0; j < from_oplen; j++) {
-        int offset = operand_offset_at(new_operands(), old_oplen + j);
-        assert(offset == operand_offset_at(from_cp->operands(), j), "correct copy");
-        offset += old_len;  // every new tuple is preceded by old_len extra u2's
-        operand_offset_at_put(new_operands(), old_oplen + j, offset);
-      }
-
-      // replace target operands array with combined array
-      to_cp->set_operands(new_operands());
-    }
-  }
-
-} // end copy_cp_to()
+} // end copy_cp_to_impl()
 
 
 // Copy this constant pool's entry at from_i to the constant pool
@@ -1337,6 +1402,46 @@
 } // end find_matching_entry()
 
 
+// Compare this constant pool's bootstrap specifier at idx1 to the constant pool
+// cp2's bootstrap specifier at idx2.
+bool constantPoolOopDesc::compare_operand_to(int idx1, constantPoolHandle cp2, int idx2, TRAPS) {
+  int k1 = operand_bootstrap_method_ref_index_at(idx1);
+  int k2 = cp2->operand_bootstrap_method_ref_index_at(idx2);
+  bool match = compare_entry_to(k1, cp2, k2, CHECK_false);
+
+  if (!match) {
+    return false;
+  }
+  int argc = operand_argument_count_at(idx1);
+  if (argc == cp2->operand_argument_count_at(idx2)) {
+    for (int j = 0; j < argc; j++) {
+      k1 = operand_argument_index_at(idx1, j);
+      k2 = cp2->operand_argument_index_at(idx2, j);
+      match = compare_entry_to(k1, cp2, k2, CHECK_false);
+      if (!match) {
+        return false;
+      }
+    }
+    return true;           // got through loop; all elements equal
+  }
+  return false;
+} // end compare_operand_to()
+
+// Search constant pool search_cp for a bootstrap specifier that matches
+// this constant pool's bootstrap specifier at pattern_i index.
+// Return the index of a matching bootstrap specifier or (-1) if there is no match.
+int constantPoolOopDesc::find_matching_operand(int pattern_i,
+                    constantPoolHandle search_cp, int search_len, TRAPS) {
+  for (int i = 0; i < search_len; i++) {
+    bool found = compare_operand_to(pattern_i, search_cp, i, CHECK_(-1));
+    if (found) {
+      return i;
+    }
+  }
+  return -1;  // bootstrap specifier not found; return unused index (-1)
+} // end find_matching_operand()
+
+
 #ifndef PRODUCT
 
 const char* constantPoolOopDesc::printable_name_at(int which) {
--- ./hotspot/src/share/vm/oops/constantPoolOop.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/oops/constantPoolOop.hpp	Wed May 07 19:26:16 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -565,6 +565,47 @@
          _indy_argc_offset = 1,  // u2 argc
          _indy_argv_offset = 2   // u2 argv[argc]
   };
+
+  // These functions are used in RedefineClasses for CP merge
+
+  int operand_offset_at(int bootstrap_specifier_index) {
+    assert(0 <= bootstrap_specifier_index &&
+           bootstrap_specifier_index < operand_array_length(operands()),
+           "Corrupted CP operands");
+    return operand_offset_at(operands(), bootstrap_specifier_index);
+  }
+  int operand_bootstrap_method_ref_index_at(int bootstrap_specifier_index) {
+    int offset = operand_offset_at(bootstrap_specifier_index);
+    return operands()->short_at(offset + _indy_bsm_offset);
+  }
+  int operand_argument_count_at(int bootstrap_specifier_index) {
+    int offset = operand_offset_at(bootstrap_specifier_index);
+    int argc = operands()->short_at(offset + _indy_argc_offset);
+    return argc;
+  }
+  int operand_argument_index_at(int bootstrap_specifier_index, int j) {
+    int offset = operand_offset_at(bootstrap_specifier_index);
+    return operands()->short_at(offset + _indy_argv_offset + j);
+  }
+  int operand_next_offset_at(int bootstrap_specifier_index) {
+    int offset = operand_offset_at(bootstrap_specifier_index) + _indy_argv_offset
+                   + operand_argument_count_at(bootstrap_specifier_index);
+    return offset;
+  }
+  // Compare a bootsrap specifier in the operands arrays
+  bool compare_operand_to(int bootstrap_specifier_index1, constantPoolHandle cp2,
+                          int bootstrap_specifier_index2, TRAPS);
+  // Find a bootsrap specifier in the operands array
+  int find_matching_operand(int bootstrap_specifier_index, constantPoolHandle search_cp,
+                            int operands_cur_len, TRAPS);
+  // Resize the operands array with delta_len and delta_size
+  void resize_operands(int delta_len, int delta_size, TRAPS);
+  // Extend the operands array with the length and size of the ext_cp operands
+  void extend_operands(constantPoolHandle ext_cp, TRAPS);
+  // Shrink the operands array to a smaller array with new_len length
+  void shrink_operands(int new_len, TRAPS);
+
+
   int invoke_dynamic_bootstrap_method_ref_index_at(int which) {
     assert(tag_at(which).is_invoke_dynamic(), "Corrupted constant pool");
     int op_base = invoke_dynamic_operand_base(which);
@@ -755,6 +796,7 @@
     copy_cp_to_impl(h_this, start_i, end_i, to_cp, to_i, THREAD);
   }
   static void copy_cp_to_impl(constantPoolHandle from_cp, int start_i, int end_i, constantPoolHandle to_cp, int to_i, TRAPS);
+  static void copy_operands(constantPoolHandle from_cp, constantPoolHandle to_cp, TRAPS);
   static void copy_entry_to(constantPoolHandle from_cp, int from_i, constantPoolHandle to_cp, int to_i, TRAPS);
   int  find_matching_entry(int pattern_i, constantPoolHandle search_cp, TRAPS);
   int  orig_length() const                { return _orig_length; }
--- ./hotspot/src/share/vm/oops/instanceKlass.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/oops/instanceKlass.cpp	Wed May 07 19:26:16 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -1901,6 +1901,17 @@
     FreeHeap(jmeths);
   }
 
+  // Deallocate MemberNameTable
+  {
+    Mutex* lock_or_null = SafepointSynchronize::is_at_safepoint() ? NULL : MemberNameTable_lock;
+    MutexLockerEx ml(lock_or_null, Mutex::_no_safepoint_check_flag);
+    MemberNameTable* mnt = member_names();
+    if (mnt != NULL) {
+      delete mnt;
+      set_member_names(NULL);
+    }
+  }
+
   int* indices = methods_cached_itable_indices_acquire();
   if (indices != (int*)NULL) {
     release_set_methods_cached_itable_indices(NULL);
@@ -2333,6 +2344,30 @@
   return NULL;
 }
 
+void instanceKlass::add_member_name(int index, Handle mem_name) {
+  jweak mem_name_wref = JNIHandles::make_weak_global(mem_name);
+  MutexLocker ml(MemberNameTable_lock);
+  assert(0 <= index && index < idnum_allocated_count(), "index is out of bounds");
+  DEBUG_ONLY(No_Safepoint_Verifier nsv);
+
+  if (_member_names == NULL) {
+    _member_names = new (ResourceObj::C_HEAP, mtClass) MemberNameTable(idnum_allocated_count());
+  }
+  _member_names->add_member_name(index, mem_name_wref);
+}
+
+oop instanceKlass::get_member_name(int index) {
+  MutexLocker ml(MemberNameTable_lock);
+  assert(0 <= index && index < idnum_allocated_count(), "index is out of bounds");
+  DEBUG_ONLY(No_Safepoint_Verifier nsv);
+
+  if (_member_names == NULL) {
+    return NULL;
+  }
+  oop mem_name =_member_names->get_member_name(index);
+  return mem_name;
+}
+
 // -----------------------------------------------------------------------------------------------------
 #ifndef PRODUCT
 
--- ./hotspot/src/share/vm/oops/instanceKlass.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/oops/instanceKlass.hpp	Wed May 07 19:26:16 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -94,6 +94,7 @@
 class nmethodBucket;
 class PreviousVersionNode;
 class JvmtiCachedClassFieldMap;
+class MemberNameTable;
 
 // This is used in iterators below.
 class FieldClosure: public StackObj {
@@ -265,6 +266,7 @@
   int             _vtable_len;           // length of Java vtable (in words)
   int             _itable_len;           // length of Java itable (in words)
   OopMapCache*    volatile _oop_map_cache;   // OopMapCache for all methods in the klass (allocated lazily)
+  MemberNameTable* _member_names;        // Member names
   JNIid*          _jni_ids;              // First JNI identifier for static fields in this class
   jmethodID*      _methods_jmethod_ids;  // jmethodIDs corresponding to method_idnum, or NULL if none
   int*            _methods_cached_itable_indices;  // itable_index cache for JNI invoke corresponding to methods idnum, or NULL
@@ -972,6 +974,12 @@
   // jvm support
   jint compute_modifier_flags(TRAPS) const;
 
+  // JSR-292 support
+  MemberNameTable* member_names() { return _member_names; }
+  void set_member_names(MemberNameTable* member_names) { _member_names = member_names; }
+  void add_member_name(int index, Handle member_name);
+  oop  get_member_name(int index);
+
 public:
   // JVMTI support
   jint jvmti_class_status() const;
--- ./hotspot/src/share/vm/opto/bytecodeInfo.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/opto/bytecodeInfo.cpp	Wed May 07 19:26:16 2014 -0700
@@ -103,7 +103,7 @@
   // Allows targeted inlining
   if(callee_method->should_inline()) {
     *wci_result = *(WarmCallInfo::always_hot());
-    if (PrintInlining && Verbose) {
+    if (C->print_inlining() && Verbose) {
       CompileTask::print_inline_indent(inline_level());
       tty->print_cr("Inlined method is hot: ");
     }
@@ -117,7 +117,7 @@
   if(callee_method->interpreter_throwout_count() > InlineThrowCount &&
      size < InlineThrowMaxSize ) {
     wci_result->set_profit(wci_result->profit() * 100);
-    if (PrintInlining && Verbose) {
+    if (C->print_inlining() && Verbose) {
       CompileTask::print_inline_indent(inline_level());
       tty->print_cr("Inlined method with many throws (throws=%d):", callee_method->interpreter_throwout_count());
     }
@@ -468,7 +468,7 @@
       C->log()->inline_fail(inline_msg);
     }
   }
-  if (PrintInlining) {
+  if (C->print_inlining()) {
     C->print_inlining(callee_method, inline_level(), caller_bci, inline_msg);
     if (callee_method == NULL) tty->print(" callee not monotonic or profiled");
     if (Verbose && callee_method) {
@@ -517,7 +517,7 @@
 
 #ifndef PRODUCT
   if (UseOldInlining && InlineWarmCalls
-      && (PrintOpto || PrintOptoInlining || PrintInlining)) {
+      && (PrintOpto || C->print_inlining())) {
     bool cold = wci.is_cold();
     bool hot  = !cold && wci.is_hot();
     bool old_cold = !success;
@@ -594,7 +594,7 @@
              callee_method->is_compiled_lambda_form()) {
       max_inline_level_adjust += 1;  // don't count method handle calls from java.lang.invoke implem
     }
-    if (max_inline_level_adjust != 0 && PrintInlining && (Verbose || WizardMode)) {
+    if (max_inline_level_adjust != 0 && C->print_inlining() && (Verbose || WizardMode)) {
       CompileTask::print_inline_indent(inline_level());
       tty->print_cr(" \\-> discounting inline depth");
     }
--- ./hotspot/src/share/vm/opto/c2_globals.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/opto/c2_globals.hpp	Wed May 07 19:26:16 2014 -0700
@@ -173,6 +173,9 @@
   product_pd(intx,  LoopUnrollLimit,                                        \
           "Unroll loop bodies with node count less than this")              \
                                                                             \
+  product(intx,  LoopMaxUnroll, 16,                                         \
+          "Maximum number of unrolls for main loop")                        \
+                                                                            \
   product(intx,  LoopUnrollMin, 4,                                          \
           "Minimum number of unroll loop bodies before checking progress"   \
           "of rounds of unroll,optimize,..")                                \
--- ./hotspot/src/share/vm/opto/callGenerator.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/opto/callGenerator.hpp	Wed May 07 19:26:16 2014 -0700
@@ -158,8 +158,9 @@
   virtual void print_inlining_late(const char* msg) { ShouldNotReachHere(); }
 
   static void print_inlining(Compile* C, ciMethod* callee, int inline_level, int bci, const char* msg) {
-    if (PrintInlining)
+    if (C->print_inlining()) {
       C->print_inlining(callee, inline_level, bci, msg);
+    }
   }
 };
 
--- ./hotspot/src/share/vm/opto/coalesce.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/opto/coalesce.cpp	Wed May 07 19:26:16 2014 -0700
@@ -135,20 +135,26 @@
 // After cloning some rematerialized instruction, clone any MachProj's that
 // follow it.  Example: Intel zero is XOR, kills flags.  Sparc FP constants
 // use G3 as an address temp.
-int PhaseChaitin::clone_projs( Block *b, uint idx, Node *con, Node *copy, uint &maxlrg ) {
-  Block *bcon = _cfg._bbs[con->_idx];
-  uint cindex = bcon->find_node(con);
-  Node *con_next = bcon->_nodes[cindex+1];
-  if( con_next->in(0) != con || !con_next->is_MachProj() )
-    return false;               // No MachProj's follow
-
-  // Copy kills after the cloned constant
-  Node *kills = con_next->clone();
-  kills->set_req( 0, copy );
-  b->_nodes.insert( idx, kills );
-  _cfg._bbs.map( kills->_idx, b );
-  new_lrg( kills, maxlrg++ );
-  return true;
+int PhaseChaitin::clone_projs(Block* b, uint idx, Node* orig, Node* copy, uint& max_lrg_id) {
+  assert(b->find_node(copy) == (idx - 1), "incorrect insert index for copy kill projections");
+  DEBUG_ONLY( Block* borig = _cfg._bbs[orig->_idx]; )
+  int found_projs = 0;
+  uint cnt = orig->outcnt();
+  for (uint i = 0; i < cnt; i++) {
+    Node* proj = orig->raw_out(i);
+    if (proj->is_MachProj()) {
+      assert(proj->outcnt() == 0, "only kill projections are expected here");
+      assert(_cfg._bbs[proj->_idx] == borig, "incorrect block for kill projections");
+      found_projs++;
+      // Copy kill projections after the cloned node
+      Node* kills = proj->clone();
+      kills->set_req(0, copy);
+      b->_nodes.insert(idx++, kills);
+      _cfg._bbs.map(kills->_idx, b);
+      new_lrg(kills, max_lrg_id++);
+    }
+  }
+  return found_projs;
 }
 
 //------------------------------compact----------------------------------------
@@ -464,8 +470,7 @@
               copy = m->clone();
               // Insert the copy in the basic block, just before us
               b->_nodes.insert( l++, copy );
-              if( _phc.clone_projs( b, l, m, copy, _phc._maxlrg ) )
-                l++;
+              l += _phc.clone_projs(b, l, m, copy, _phc._maxlrg);
             } else {
               const RegMask *rm = C->matcher()->idealreg2spillmask[m->ideal_reg()];
               copy = new (C) MachSpillCopyNode( m, *rm, *rm );
--- ./hotspot/src/share/vm/opto/compile.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/opto/compile.cpp	Wed May 07 19:26:16 2014 -0700
@@ -642,7 +642,7 @@
                   _inlining_progress(false),
                   _inlining_incrementally(false),
                   _print_inlining_list(NULL),
-                  _print_inlining(0) {
+                  _print_inlining_idx(0) {
   C = this;
 
   CompileWrapper cw(this);
@@ -667,6 +667,8 @@
   set_print_assembly(print_opto_assembly);
   set_parsed_irreducible_loop(false);
 #endif
+  set_print_inlining(PrintInlining || method()->has_option("PrintInlining") NOT_PRODUCT( || PrintOptoInlining));
+  set_print_intrinsics(PrintIntrinsics || method()->has_option("PrintIntrinsics"));
 
   if (ProfileTraps) {
     // Make sure the method being compiled gets its own MDO,
@@ -698,7 +700,7 @@
   PhaseGVN gvn(node_arena(), estimated_size);
   set_initial_gvn(&gvn);
 
-  if (PrintInlining  || PrintIntrinsics NOT_PRODUCT( || PrintOptoInlining)) {
+  if (print_inlining() || print_intrinsics()) {
     _print_inlining_list = new (comp_arena())GrowableArray<PrintInliningBuffer>(comp_arena(), 1, 1, PrintInliningBuffer());
   }
   { // Scope for timing the parser
@@ -832,6 +834,7 @@
   }
 #endif
 
+  NOT_PRODUCT( verify_barriers(); )
   // Now that we know the size of all the monitors we can add a fixed slot
   // for the original deopt pc.
 
@@ -924,7 +927,7 @@
     _inlining_progress(false),
     _inlining_incrementally(false),
     _print_inlining_list(NULL),
-    _print_inlining(0) {
+    _print_inlining_idx(0) {
   C = this;
 
 #ifndef PRODUCT
@@ -3237,6 +3240,72 @@
     }
   }
 }
+
+// Verify GC barriers consistency
+// Currently supported:
+// - G1 pre-barriers (see GraphKit::g1_write_barrier_pre())
+void Compile::verify_barriers() {
+  if (UseG1GC) {
+    // Verify G1 pre-barriers
+    const int marking_offset = in_bytes(JavaThread::satb_mark_queue_offset() + PtrQueue::byte_offset_of_active());
+
+    ResourceArea *area = Thread::current()->resource_area();
+    Unique_Node_List visited(area);
+    Node_List worklist(area);
+    // We're going to walk control flow backwards starting from the Root
+    worklist.push(_root);
+    while (worklist.size() > 0) {
+      Node* x = worklist.pop();
+      if (x == NULL || x == top()) continue;
+      if (visited.member(x)) {
+        continue;
+      } else {
+        visited.push(x);
+      }
+
+      if (x->is_Region()) {
+        for (uint i = 1; i < x->req(); i++) {
+          worklist.push(x->in(i));
+        }
+      } else {
+        worklist.push(x->in(0));
+        // We are looking for the pattern:
+        //                            /->ThreadLocal
+        // If->Bool->CmpI->LoadB->AddP->ConL(marking_offset)
+        //              \->ConI(0)
+        // We want to verify that the If and the LoadB have the same control
+        // See GraphKit::g1_write_barrier_pre()
+        if (x->is_If()) {
+          IfNode *iff = x->as_If();
+          if (iff->in(1)->is_Bool() && iff->in(1)->in(1)->is_Cmp()) {
+            CmpNode *cmp = iff->in(1)->in(1)->as_Cmp();
+            if (cmp->Opcode() == Op_CmpI && cmp->in(2)->is_Con() && cmp->in(2)->bottom_type()->is_int()->get_con() == 0
+                && cmp->in(1)->is_Load()) {
+              LoadNode* load = cmp->in(1)->as_Load();
+              if (load->Opcode() == Op_LoadB && load->in(2)->is_AddP() && load->in(2)->in(2)->Opcode() == Op_ThreadLocal
+                  && load->in(2)->in(3)->is_Con()
+                  && load->in(2)->in(3)->bottom_type()->is_intptr_t()->get_con() == marking_offset) {
+
+                Node* if_ctrl = iff->in(0);
+                Node* load_ctrl = load->in(0);
+
+                if (if_ctrl != load_ctrl) {
+                  // Skip possible CProj->NeverBranch in infinite loops
+                  if ((if_ctrl->is_Proj() && if_ctrl->Opcode() == Op_CProj)
+                      && (if_ctrl->in(0)->is_MultiBranch() && if_ctrl->in(0)->Opcode() == Op_NeverBranch)) {
+                    if_ctrl = if_ctrl->in(0)->in(0);
+                  }
+                }
+                assert(load_ctrl != NULL && if_ctrl == load_ctrl, "controls must match");
+              }
+            }
+          }
+        }
+      }
+    }
+  }
+}
+
 #endif
 
 // The Compile object keeps track of failure reasons separately from the ciEnv.
@@ -3510,7 +3579,7 @@
 }
 
 void Compile::dump_inlining() {
-  if (PrintInlining || PrintIntrinsics NOT_PRODUCT( || PrintOptoInlining)) {
+  if (print_inlining() || print_intrinsics()) {
     // Print inlining message for candidates that we couldn't inline
     // for lack of space or non constant receiver
     for (int i = 0; i < _late_inlines.length(); i++) {
@@ -3534,7 +3603,7 @@
       }
     }
     for (int i = 0; i < _print_inlining_list->length(); i++) {
-      tty->print(_print_inlining_list->at(i).ss()->as_string());
+      tty->print(_print_inlining_list->adr_at(i)->ss()->as_string());
     }
   }
 }
--- ./hotspot/src/share/vm/opto/compile.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/opto/compile.hpp	Wed May 07 19:26:16 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -42,6 +42,7 @@
 #include "runtime/deoptimization.hpp"
 #include "runtime/vmThread.hpp"
 #include "trace/tracing.hpp"
+#include "utilities/ticks.hpp"
 
 class Block;
 class Bundle;
@@ -284,6 +285,8 @@
   bool                  _do_method_data_update; // True if we generate code to update methodDataOops
   int                   _AliasLevel;            // Locally-adjusted version of AliasLevel flag.
   bool                  _print_assembly;        // True if we should dump assembly code for this compilation
+  bool                  _print_inlining;        // True if we should print inlining for this compilation
+  bool                  _print_intrinsics;      // True if we should print intrinsics for this compilation
 #ifndef PRODUCT
   bool                  _trace_opto_output;
   bool                  _parsed_irreducible_loop; // True if ciTypeFlow detected irreducible loops during parsing
@@ -384,7 +387,7 @@
   };
 
   GrowableArray<PrintInliningBuffer>* _print_inlining_list;
-  int _print_inlining;
+  int _print_inlining_idx;
 
   // Only keep nodes in the expensive node list that need to be optimized
   void cleanup_expensive_nodes(PhaseIterGVN &igvn);
@@ -396,24 +399,24 @@
  public:
 
   outputStream* print_inlining_stream() const {
-    return _print_inlining_list->at(_print_inlining).ss();
+    return _print_inlining_list->adr_at(_print_inlining_idx)->ss();
   }
 
   void print_inlining_skip(CallGenerator* cg) {
-    if (PrintInlining) {
-      _print_inlining_list->at(_print_inlining).set_cg(cg);
-      _print_inlining++;
-      _print_inlining_list->insert_before(_print_inlining, PrintInliningBuffer());
+    if (_print_inlining) {
+      _print_inlining_list->adr_at(_print_inlining_idx)->set_cg(cg);
+      _print_inlining_idx++;
+      _print_inlining_list->insert_before(_print_inlining_idx, PrintInliningBuffer());
     }
   }
 
   void print_inlining_insert(CallGenerator* cg) {
-    if (PrintInlining) {
+    if (_print_inlining) {
       for (int i = 0; i < _print_inlining_list->length(); i++) {
-        if (_print_inlining_list->at(i).cg() == cg) {
+        if (_print_inlining_list->adr_at(i)->cg() == cg) {
           _print_inlining_list->insert_before(i+1, PrintInliningBuffer());
-          _print_inlining = i+1;
-          _print_inlining_list->at(i).set_cg(NULL);
+          _print_inlining_idx = i+1;
+          _print_inlining_list->adr_at(i)->set_cg(NULL);
           return;
         }
       }
@@ -536,6 +539,10 @@
   int               AliasLevel() const          { return _AliasLevel; }
   bool              print_assembly() const       { return _print_assembly; }
   void          set_print_assembly(bool z)       { _print_assembly = z; }
+  bool              print_inlining() const       { return _print_inlining; }
+  void          set_print_inlining(bool z)       { _print_inlining = z; }
+  bool              print_intrinsics() const     { return _print_intrinsics; }
+  void          set_print_intrinsics(bool z)     { _print_intrinsics = z; }
   // check the CompilerOracle for special behaviours for this compile
   bool          method_has_option(const char * option) {
     return method() != NULL && method()->has_option(option);
@@ -550,20 +557,19 @@
   bool              has_method_handle_invokes() const { return _has_method_handle_invokes;     }
   void          set_has_method_handle_invokes(bool z) {        _has_method_handle_invokes = z; }
 
-  jlong _latest_stage_start_counter;
+  Ticks _latest_stage_start_counter;
 
   void begin_method() {
 #ifndef PRODUCT
     if (_printer) _printer->begin_method(this);
 #endif
-    C->_latest_stage_start_counter = os::elapsed_counter();
+    C->_latest_stage_start_counter.stamp();
   }
 
   void print_method(CompilerPhaseType cpt, int level = 1) {
-    EventCompilerPhase event(UNTIMED);
+    EventCompilerPhase event;
     if (event.should_commit()) {
       event.set_starttime(C->_latest_stage_start_counter);
-      event.set_endtime(os::elapsed_counter());
       event.set_phase((u1) cpt);
       event.set_compileID(C->_compile_id);
       event.set_phaseLevel(level);
@@ -574,14 +580,13 @@
 #ifndef PRODUCT
     if (_printer) _printer->print_method(this, CompilerPhaseTypeHelper::to_string(cpt), level);
 #endif
-    C->_latest_stage_start_counter = os::elapsed_counter();
+    C->_latest_stage_start_counter.stamp();
   }
 
   void end_method(int level = 1) {
-    EventCompilerPhase event(UNTIMED);
+    EventCompilerPhase event;
     if (event.should_commit()) {
       event.set_starttime(C->_latest_stage_start_counter);
-      event.set_endtime(os::elapsed_counter());
       event.set_phase((u1) PHASE_END);
       event.set_compileID(C->_compile_id);
       event.set_phaseLevel(level);
@@ -1091,6 +1096,9 @@
   // Print bytecodes, including the scope inlining tree
   void print_codes();
 
+  // Verify GC barrier patterns
+  void verify_barriers() PRODUCT_RETURN;
+
   // End-of-run dumps.
   static void print_statistics() PRODUCT_RETURN;
 
--- ./hotspot/src/share/vm/opto/doCall.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/opto/doCall.cpp	Wed May 07 19:26:16 2014 -0700
@@ -42,9 +42,9 @@
 #include "runtime/sharedRuntime.hpp"
 
 void trace_type_profile(Compile* C, ciMethod *method, int depth, int bci, ciMethod *prof_method, ciKlass *prof_klass, int site_count, int receiver_count) {
-  if (TraceTypeProfile || PrintInlining NOT_PRODUCT(|| PrintOptoInlining)) {
+  if (TraceTypeProfile || C->print_inlining()) {
     outputStream* out = tty;
-    if (!PrintInlining) {
+    if (!C->print_inlining()) {
       if (NOT_PRODUCT(!PrintOpto &&) !PrintCompilation) {
         method->print_short_name();
         tty->cr();
--- ./hotspot/src/share/vm/opto/graphKit.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/opto/graphKit.cpp	Wed May 07 19:26:16 2014 -0700
@@ -3596,7 +3596,7 @@
   Node* marking = __ load(__ ctrl(), marking_adr, TypeInt::INT, active_type, Compile::AliasIdxRaw);
 
   // if (!marking)
-  __ if_then(marking, BoolTest::ne, zero); {
+  __ if_then(marking, BoolTest::ne, zero, unlikely); {
     BasicType index_bt = TypeX_X->basic_type();
     assert(sizeof(size_t) == type2aelembytes(index_bt), "Loading G1 PtrQueue::_index with wrong size.");
     Node* index   = __ load(__ ctrl(), index_adr, TypeX_X, index_bt, Compile::AliasIdxRaw);
@@ -3604,7 +3604,7 @@
     if (do_load) {
       // load original value
       // alias_idx correct??
-      pre_val = __ load(no_ctrl, adr, val_type, bt, alias_idx);
+      pre_val = __ load(__ ctrl(), adr, val_type, bt, alias_idx);
     }
 
     // if (pre_val != NULL)
@@ -3701,7 +3701,8 @@
   Node* no_base = __ top();
   float likely  = PROB_LIKELY(0.999);
   float unlikely  = PROB_UNLIKELY(0.999);
-  Node* zero = __ ConI(0);
+  Node* young_card = __ ConI((jint)G1SATBCardTableModRefBS::g1_young_card_val());
+  Node* dirty_card = __ ConI((jint)CardTableModRefBS::dirty_card_val());
   Node* zeroX = __ ConX(0);
 
   // Get the alias_index for raw card-mark memory
@@ -3757,8 +3758,16 @@
         // load the original value of the card
         Node* card_val = __ load(__ ctrl(), card_adr, TypeInt::INT, T_BYTE, Compile::AliasIdxRaw);
 
-        __ if_then(card_val, BoolTest::ne, zero); {
-          g1_mark_card(ideal, card_adr, oop_store, alias_idx, index, index_adr, buffer, tf);
+        __ if_then(card_val, BoolTest::ne, young_card); {
+          sync_kit(ideal);
+          // Use Op_MemBarVolatile to achieve the effect of a StoreLoad barrier.
+          insert_mem_bar(Op_MemBarVolatile, oop_store);
+          __ sync_kit(this);
+
+          Node* card_val_reload = __ load(__ ctrl(), card_adr, TypeInt::INT, T_BYTE, Compile::AliasIdxRaw);
+          __ if_then(card_val_reload, BoolTest::ne, dirty_card); {
+            g1_mark_card(ideal, card_adr, oop_store, alias_idx, index, index_adr, buffer, tf);
+          } __ end_if();
         } __ end_if();
       } __ end_if();
     } __ end_if();
--- ./hotspot/src/share/vm/opto/library_call.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/opto/library_call.cpp	Wed May 07 19:26:16 2014 -0700
@@ -525,7 +525,7 @@
   Compile* C = kit.C;
   int nodes = C->unique();
 #ifndef PRODUCT
-  if ((PrintIntrinsics || PrintInlining NOT_PRODUCT( || PrintOptoInlining) ) && Verbose) {
+  if ((C->print_intrinsics() || C->print_inlining()) && Verbose) {
     char buf[1000];
     const char* str = vmIntrinsics::short_name_as_C_string(intrinsic_id(), buf, sizeof(buf));
     tty->print_cr("Intrinsic %s", str);
@@ -536,7 +536,7 @@
 
   // Try to inline the intrinsic.
   if (kit.try_to_inline()) {
-    if (PrintIntrinsics || PrintInlining NOT_PRODUCT( || PrintOptoInlining) ) {
+    if (C->print_intrinsics() || C->print_inlining()) {
       C->print_inlining(callee, jvms->depth() - 1, bci, is_virtual() ? "(intrinsic, virtual)" : "(intrinsic)");
     }
     C->gather_intrinsic_statistics(intrinsic_id(), is_virtual(), Compile::_intrinsic_worked);
@@ -552,7 +552,7 @@
   }
 
   // The intrinsic bailed out
-  if (PrintIntrinsics || PrintInlining NOT_PRODUCT( || PrintOptoInlining) ) {
+  if (C->print_intrinsics() || C->print_inlining()) {
     if (jvms->has_method()) {
       // Not a root compile.
       const char* msg = is_virtual() ? "failed to inline (intrinsic, virtual)" : "failed to inline (intrinsic)";
@@ -574,7 +574,7 @@
   int nodes = C->unique();
 #ifndef PRODUCT
   assert(is_predicted(), "sanity");
-  if ((PrintIntrinsics || PrintInlining NOT_PRODUCT( || PrintOptoInlining) ) && Verbose) {
+  if ((C->print_intrinsics() || C->print_inlining()) && Verbose) {
     char buf[1000];
     const char* str = vmIntrinsics::short_name_as_C_string(intrinsic_id(), buf, sizeof(buf));
     tty->print_cr("Predicate for intrinsic %s", str);
@@ -585,7 +585,7 @@
 
   Node* slow_ctl = kit.try_to_predicate();
   if (!kit.failing()) {
-    if (PrintIntrinsics || PrintInlining NOT_PRODUCT( || PrintOptoInlining) ) {
+    if (C->print_intrinsics() || C->print_inlining()) {
       C->print_inlining(callee, jvms->depth() - 1, bci, is_virtual() ? "(intrinsic, virtual)" : "(intrinsic)");
     }
     C->gather_intrinsic_statistics(intrinsic_id(), is_virtual(), Compile::_intrinsic_worked);
@@ -599,7 +599,7 @@
   }
 
   // The intrinsic bailed out
-  if (PrintIntrinsics || PrintInlining NOT_PRODUCT( || PrintOptoInlining) ) {
+  if (C->print_intrinsics() || C->print_inlining()) {
     if (jvms->has_method()) {
       // Not a root compile.
       const char* msg = "failed to generate predicate for intrinsic";
@@ -2262,7 +2262,7 @@
     const TypeOopPtr* tjp = TypeOopPtr::make_from_klass(sharpened_klass);
 
 #ifndef PRODUCT
-    if (PrintIntrinsics || PrintInlining || PrintOptoInlining) {
+    if (C->print_intrinsics() || C->print_inlining()) {
       tty->print("  from base type: ");  adr_type->dump();
       tty->print("  sharpened value: ");  tjp->dump();
     }
@@ -3158,7 +3158,7 @@
   if (mirror_con == NULL)  return false;  // cannot happen?
 
 #ifndef PRODUCT
-  if (PrintIntrinsics || PrintInlining || PrintOptoInlining) {
+  if (C->print_intrinsics() || C->print_inlining()) {
     ciType* k = mirror_con->java_mirror_type();
     if (k) {
       tty->print("Inlining %s on constant Class ", vmIntrinsics::name_at(intrinsic_id()));
@@ -3846,7 +3846,7 @@
 // Method.invoke() and auxiliary frames.
 bool LibraryCallKit::inline_native_Reflection_getCallerClass() {
 #ifndef PRODUCT
-  if ((PrintIntrinsics || PrintInlining || PrintOptoInlining) && Verbose) {
+  if ((C->print_intrinsics() || C->print_inlining()) && Verbose) {
     tty->print_cr("Attempting to inline sun.reflect.Reflection.getCallerClass");
   }
 #endif
@@ -3858,7 +3858,7 @@
   const TypeInt* caller_depth_type = _gvn.type(caller_depth_node)->isa_int();
   if (caller_depth_type == NULL || !caller_depth_type->is_con()) {
 #ifndef PRODUCT
-    if ((PrintIntrinsics || PrintInlining || PrintOptoInlining) && Verbose) {
+    if ((C->print_intrinsics() || C->print_inlining()) && Verbose) {
       tty->print_cr("  Bailing out because caller depth was not a constant");
     }
 #endif
@@ -3873,7 +3873,7 @@
   int caller_depth = caller_depth_type->get_con() - 1;
   if (caller_depth < 0) {
 #ifndef PRODUCT
-    if ((PrintIntrinsics || PrintInlining || PrintOptoInlining) && Verbose) {
+    if ((C->print_intrinsics() || C->print_inlining()) && Verbose) {
       tty->print_cr("  Bailing out because caller depth was %d", caller_depth);
     }
 #endif
@@ -3882,7 +3882,7 @@
 
   if (!jvms()->has_method()) {
 #ifndef PRODUCT
-    if ((PrintIntrinsics || PrintInlining || PrintOptoInlining) && Verbose) {
+    if ((C->print_intrinsics() || C->print_inlining()) && Verbose) {
       tty->print_cr("  Bailing out because intrinsic was inlined at top level");
     }
 #endif
@@ -3919,7 +3919,7 @@
 
   if (inlining_depth == 0) {
 #ifndef PRODUCT
-    if ((PrintIntrinsics || PrintInlining || PrintOptoInlining) && Verbose) {
+    if ((C->print_intrinsics() || C->print_inlining()) && Verbose) {
       tty->print_cr("  Bailing out because caller depth (%d) exceeded inlining depth (%d)", caller_depth_type->get_con(), _depth);
       tty->print_cr("  JVM state at this point:");
       for (int i = _depth; i >= 1; i--) {
@@ -3939,7 +3939,7 @@
   set_result(makecon(TypeInstPtr::make(caller_mirror)));
 
 #ifndef PRODUCT
-  if ((PrintIntrinsics || PrintInlining || PrintOptoInlining) && Verbose) {
+  if ((C->print_intrinsics() || C->print_inlining()) && Verbose) {
     tty->print_cr("  Succeeded: caller = %s.%s, caller depth = %d, depth = %d", caller_klass->name()->as_utf8(), caller_jvms->method()->name()->as_utf8(), caller_depth_type->get_con(), _depth);
     tty->print_cr("  JVM state at this point:");
     for (int i = _depth; i >= 1; i--) {
--- ./hotspot/src/share/vm/opto/loopTransform.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/opto/loopTransform.cpp	Wed May 07 19:26:16 2014 -0700
@@ -623,8 +623,6 @@
 }
 
 
-#define MAX_UNROLL 16 // maximum number of unrolls for main loop
-
 //------------------------------policy_unroll----------------------------------
 // Return TRUE or FALSE if the loop should be unrolled or not.  Unroll if
 // the loop is a CountedLoop and the body is small enough.
@@ -641,7 +639,7 @@
   if (cl->trip_count() <= (uint)(cl->is_normal_loop() ? 2 : 1)) return false;
 
   int future_unroll_ct = cl->unrolled_count() * 2;
-  if (future_unroll_ct > MAX_UNROLL) return false;
+  if (future_unroll_ct > LoopMaxUnroll) return false;
 
   // Check for initial stride being a small enough constant
   if (abs(cl->stride_con()) > (1<<2)*future_unroll_ct) return false;
@@ -1956,7 +1954,7 @@
       // Find loads off the surviving projection; remove their control edge
       for (DUIterator_Fast imax, i = dp->fast_outs(imax); i < imax; i++) {
         Node* cd = dp->fast_out(i); // Control-dependent node
-        if( cd->is_Load() ) {   // Loads can now float around in the loop
+        if (cd->is_Load() && cd->depends_only_on_test()) {   // Loads can now float around in the loop
           // Allow the load to float around in the loop, or before it
           // but NOT before the pre-loop.
           _igvn.replace_input_of(cd, 0, ctrl); // ctrl, not NULL
--- ./hotspot/src/share/vm/opto/memnode.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/opto/memnode.cpp	Wed May 07 19:26:16 2014 -0700
@@ -1957,6 +1957,11 @@
       if (t != NULL) {
         // constant oop => constant klass
         if (offset == java_lang_Class::array_klass_offset_in_bytes()) {
+          if (t->is_void()) {
+            // We cannot create a void array.  Since void is a primitive type return null
+            // klass.  Users of this result need to do a null check on the returned klass.
+            return TypePtr::NULL_PTR;
+          }
           return TypeKlassPtr::make(ciArrayKlass::make(t));
         }
         if (!t->is_klass()) {
--- ./hotspot/src/share/vm/opto/memnode.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/opto/memnode.hpp	Wed May 07 19:26:16 2014 -0700
@@ -204,6 +204,17 @@
 protected:
   const Type* load_array_final_field(const TypeKlassPtr *tkls,
                                      ciKlass* klass) const;
+  // depends_only_on_test is almost always true, and needs to be almost always
+  // true to enable key hoisting & commoning optimizations.  However, for the
+  // special case of RawPtr loads from TLS top & end, and other loads performed by
+  // GC barriers, the control edge carries the dependence preventing hoisting past
+  // a Safepoint instead of the memory edge.  (An unfortunate consequence of having
+  // Safepoints not set Raw Memory; itself an unfortunate consequence of having Nodes
+  // which produce results (new raw memory state) inside of loops preventing all
+  // manner of other optimizations).  Basically, it's ugly but so is the alternative.
+  // See comment in macro.cpp, around line 125 expand_allocate_common().
+  virtual bool depends_only_on_test() const { return adr_type() != TypeRawPtr::BOTTOM; }
+
 };
 
 //------------------------------LoadBNode--------------------------------------
@@ -370,16 +381,6 @@
   virtual uint ideal_reg() const { return Op_RegP; }
   virtual int store_Opcode() const { return Op_StoreP; }
   virtual BasicType memory_type() const { return T_ADDRESS; }
-  // depends_only_on_test is almost always true, and needs to be almost always
-  // true to enable key hoisting & commoning optimizations.  However, for the
-  // special case of RawPtr loads from TLS top & end, the control edge carries
-  // the dependence preventing hoisting past a Safepoint instead of the memory
-  // edge.  (An unfortunate consequence of having Safepoints not set Raw
-  // Memory; itself an unfortunate consequence of having Nodes which produce
-  // results (new raw memory state) inside of loops preventing all manner of
-  // other optimizations).  Basically, it's ugly but so is the alternative.
-  // See comment in macro.cpp, around line 125 expand_allocate_common().
-  virtual bool depends_only_on_test() const { return adr_type() != TypeRawPtr::BOTTOM; }
 };
 
 
@@ -393,16 +394,6 @@
   virtual uint ideal_reg() const { return Op_RegN; }
   virtual int store_Opcode() const { return Op_StoreN; }
   virtual BasicType memory_type() const { return T_NARROWOOP; }
-  // depends_only_on_test is almost always true, and needs to be almost always
-  // true to enable key hoisting & commoning optimizations.  However, for the
-  // special case of RawPtr loads from TLS top & end, the control edge carries
-  // the dependence preventing hoisting past a Safepoint instead of the memory
-  // edge.  (An unfortunate consequence of having Safepoints not set Raw
-  // Memory; itself an unfortunate consequence of having Nodes which produce
-  // results (new raw memory state) inside of loops preventing all manner of
-  // other optimizations).  Basically, it's ugly but so is the alternative.
-  // See comment in macro.cpp, around line 125 expand_allocate_common().
-  virtual bool depends_only_on_test() const { return adr_type() != TypeRawPtr::BOTTOM; }
 };
 
 //------------------------------LoadKlassNode----------------------------------
--- ./hotspot/src/share/vm/opto/reg_split.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/opto/reg_split.cpp	Wed May 07 19:26:16 2014 -0700
@@ -391,10 +391,15 @@
 #endif
   // See if the cloned def kills any flags, and copy those kills as well
   uint i = insidx+1;
-  if( clone_projs( b, i, def, spill, maxlrg ) ) {
+  int found_projs = clone_projs(b, i, def, spill, maxlrg);
+  if (found_projs > 0) {
     // Adjust the point where we go hi-pressure
-    if( i <= b->_ihrp_index ) b->_ihrp_index++;
-    if( i <= b->_fhrp_index ) b->_fhrp_index++;
+    if (i <= b->_ihrp_index) {
+      b->_ihrp_index += found_projs;
+    }
+    if (i <= b->_fhrp_index) {
+      b->_fhrp_index += found_projs;
+    }
   }
 
   return spill;
--- ./hotspot/src/share/vm/prims/jni.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/prims/jni.cpp	Wed May 07 19:26:16 2014 -0700
@@ -5042,14 +5042,22 @@
   tty->print_cr("Running test: " #unit_test_function_call); \
   unit_test_function_call
 
+// Forward declaration
+void TestReservedSpace_test();
+void TestReserveMemorySpecial_test();
+void TestOldFreeSpaceCalculation_test();
+
 void execute_internal_vm_tests() {
   if (ExecuteInternalVMTests) {
     tty->print_cr("Running internal VM tests");
+    run_unit_test(TestReservedSpace_test());
+    run_unit_test(TestReserveMemorySpecial_test());
     run_unit_test(GCTimerAllTest::all());
     run_unit_test(arrayOopDesc::test_max_array_length());
     run_unit_test(CollectedHeap::test_is_in());
     run_unit_test(QuickSort::test_quick_sort());
     run_unit_test(AltHashing::test_alt_hash());
+    run_unit_test(TestOldFreeSpaceCalculation_test());
     tty->print_cr("All internal VM tests passed");
   }
 }
--- ./hotspot/src/share/vm/prims/jvmtiClassFileReconstituter.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/prims/jvmtiClassFileReconstituter.cpp	Wed May 07 19:26:16 2014 -0700
@@ -204,7 +204,7 @@
 
   write_attribute_name_index("Code");
   write_u4(size);
-  write_u2(method->max_stack());
+  write_u2(method->verifier_max_stack());
   write_u2(method->max_locals());
   write_u4(code_size);
   copy_bytecodes(method, (unsigned char*)writeable_address(code_size));
--- ./hotspot/src/share/vm/prims/jvmtiRedefineClasses.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/prims/jvmtiRedefineClasses.cpp	Wed May 07 19:26:16 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -35,6 +35,7 @@
 #include "prims/jvmtiImpl.hpp"
 #include "prims/jvmtiRedefineClasses.hpp"
 #include "prims/methodComparator.hpp"
+#include "prims/methodHandles.hpp"
 #include "runtime/deoptimization.hpp"
 #include "runtime/relocator.hpp"
 #include "utilities/bitMap.inline.hpp"
@@ -262,76 +263,23 @@
     case JVM_CONSTANT_NameAndType:
     {
       int name_ref_i = scratch_cp->name_ref_index_at(scratch_i);
-      int new_name_ref_i = 0;
-      bool match = (name_ref_i < *merge_cp_length_p) &&
-        scratch_cp->compare_entry_to(name_ref_i, *merge_cp_p, name_ref_i,
-          THREAD);
-      if (!match) {
-        // forward reference in *merge_cp_p or not a direct match
-
-        int found_i = scratch_cp->find_matching_entry(name_ref_i, *merge_cp_p,
-          THREAD);
-        if (found_i != 0) {
-          guarantee(found_i != name_ref_i,
-            "compare_entry_to() and find_matching_entry() do not agree");
-
-          // Found a matching entry somewhere else in *merge_cp_p so
-          // just need a mapping entry.
-          new_name_ref_i = found_i;
-          map_index(scratch_cp, name_ref_i, found_i);
-        } else {
-          // no match found so we have to append this entry to *merge_cp_p
-          append_entry(scratch_cp, name_ref_i, merge_cp_p, merge_cp_length_p,
-            THREAD);
-          // The above call to append_entry() can only append one entry
-          // so the post call query of *merge_cp_length_p is only for
-          // the sake of consistency.
-          new_name_ref_i = *merge_cp_length_p - 1;
-        }
-      }
+      int new_name_ref_i = find_or_append_indirect_entry(scratch_cp, name_ref_i, merge_cp_p,
+                                                         merge_cp_length_p, THREAD);
 
       int signature_ref_i = scratch_cp->signature_ref_index_at(scratch_i);
-      int new_signature_ref_i = 0;
-      match = (signature_ref_i < *merge_cp_length_p) &&
-        scratch_cp->compare_entry_to(signature_ref_i, *merge_cp_p,
-          signature_ref_i, THREAD);
-      if (!match) {
-        // forward reference in *merge_cp_p or not a direct match
-
-        int found_i = scratch_cp->find_matching_entry(signature_ref_i,
-          *merge_cp_p, THREAD);
-        if (found_i != 0) {
-          guarantee(found_i != signature_ref_i,
-            "compare_entry_to() and find_matching_entry() do not agree");
-
-          // Found a matching entry somewhere else in *merge_cp_p so
-          // just need a mapping entry.
-          new_signature_ref_i = found_i;
-          map_index(scratch_cp, signature_ref_i, found_i);
-        } else {
-          // no match found so we have to append this entry to *merge_cp_p
-          append_entry(scratch_cp, signature_ref_i, merge_cp_p,
-            merge_cp_length_p, THREAD);
-          // The above call to append_entry() can only append one entry
-          // so the post call query of *merge_cp_length_p is only for
-          // the sake of consistency.
-          new_signature_ref_i = *merge_cp_length_p - 1;
-        }
-      }
+      int new_signature_ref_i = find_or_append_indirect_entry(scratch_cp, signature_ref_i,
+                                                              merge_cp_p, merge_cp_length_p,
+                                                              THREAD);
 
       // If the referenced entries already exist in *merge_cp_p, then
       // both new_name_ref_i and new_signature_ref_i will both be 0.
       // In that case, all we are appending is the current entry.
-      if (new_name_ref_i == 0) {
-        new_name_ref_i = name_ref_i;
-      } else {
+      if (new_name_ref_i != name_ref_i) {
         RC_TRACE(0x00080000,
           ("NameAndType entry@%d name_ref_index change: %d to %d",
           *merge_cp_length_p, name_ref_i, new_name_ref_i));
       }
-      if (new_signature_ref_i == 0) {
-        new_signature_ref_i = signature_ref_i;
-      } else {
+      if (new_signature_ref_i != signature_ref_i) {
         RC_TRACE(0x00080000,
           ("NameAndType entry@%d signature_ref_index change: %d to %d",
           *merge_cp_length_p, signature_ref_i, new_signature_ref_i));
@@ -353,76 +301,11 @@
     case JVM_CONSTANT_Methodref:
     {
       int klass_ref_i = scratch_cp->uncached_klass_ref_index_at(scratch_i);
-      int new_klass_ref_i = 0;
-      bool match = (klass_ref_i < *merge_cp_length_p) &&
-        scratch_cp->compare_entry_to(klass_ref_i, *merge_cp_p, klass_ref_i,
-          THREAD);
-      if (!match) {
-        // forward reference in *merge_cp_p or not a direct match
-
-        int found_i = scratch_cp->find_matching_entry(klass_ref_i, *merge_cp_p,
-          THREAD);
-        if (found_i != 0) {
-          guarantee(found_i != klass_ref_i,
-            "compare_entry_to() and find_matching_entry() do not agree");
-
-          // Found a matching entry somewhere else in *merge_cp_p so
-          // just need a mapping entry.
-          new_klass_ref_i = found_i;
-          map_index(scratch_cp, klass_ref_i, found_i);
-        } else {
-          // no match found so we have to append this entry to *merge_cp_p
-          append_entry(scratch_cp, klass_ref_i, merge_cp_p, merge_cp_length_p,
-            THREAD);
-          // The above call to append_entry() can only append one entry
-          // so the post call query of *merge_cp_length_p is only for
-          // the sake of consistency. Without the optimization where we
-          // use JVM_CONSTANT_UnresolvedClass, then up to two entries
-          // could be appended.
-          new_klass_ref_i = *merge_cp_length_p - 1;
-        }
-      }
-
-      int name_and_type_ref_i =
-        scratch_cp->uncached_name_and_type_ref_index_at(scratch_i);
-      int new_name_and_type_ref_i = 0;
-      match = (name_and_type_ref_i < *merge_cp_length_p) &&
-        scratch_cp->compare_entry_to(name_and_type_ref_i, *merge_cp_p,
-          name_and_type_ref_i, THREAD);
-      if (!match) {
-        // forward reference in *merge_cp_p or not a direct match
-
-        int found_i = scratch_cp->find_matching_entry(name_and_type_ref_i,
-          *merge_cp_p, THREAD);
-        if (found_i != 0) {
-          guarantee(found_i != name_and_type_ref_i,
-            "compare_entry_to() and find_matching_entry() do not agree");
-
-          // Found a matching entry somewhere else in *merge_cp_p so
-          // just need a mapping entry.
-          new_name_and_type_ref_i = found_i;
-          map_index(scratch_cp, name_and_type_ref_i, found_i);
-        } else {
-          // no match found so we have to append this entry to *merge_cp_p
-          append_entry(scratch_cp, name_and_type_ref_i, merge_cp_p,
-            merge_cp_length_p, THREAD);
-          // The above call to append_entry() can append more than
-          // one entry so the post call query of *merge_cp_length_p
-          // is required in order to get the right index for the
-          // JVM_CONSTANT_NameAndType entry.
-          new_name_and_type_ref_i = *merge_cp_length_p - 1;
-        }
-      }
-
-      // If the referenced entries already exist in *merge_cp_p, then
-      // both new_klass_ref_i and new_name_and_type_ref_i will both be
-      // 0. In that case, all we are appending is the current entry.
-      if (new_klass_ref_i == 0) {
-        new_klass_ref_i = klass_ref_i;
-      }
-      if (new_name_and_type_ref_i == 0) {
-        new_name_and_type_ref_i = name_and_type_ref_i;
-      }
+      int new_klass_ref_i = find_or_append_indirect_entry(scratch_cp, klass_ref_i,
+                                                          merge_cp_p, merge_cp_length_p, THREAD);
+      int name_and_type_ref_i = scratch_cp->uncached_name_and_type_ref_index_at(scratch_i);
+      int new_name_and_type_ref_i = find_or_append_indirect_entry(scratch_cp, name_and_type_ref_i,
+                                                          merge_cp_p, merge_cp_length_p, THREAD);
 
       const char *entry_name;
       switch (scratch_cp->tag_at(scratch_i).value()) {
@@ -465,7 +348,79 @@
       (*merge_cp_length_p)++;
     } break;
 
-    // At this stage, Class or UnresolvedClass could be here, but not
+    // this is an indirect CP entry so it needs special handling
+    case JVM_CONSTANT_MethodType:
+    {
+      int ref_i = scratch_cp->method_type_index_at(scratch_i);
+      int new_ref_i = find_or_append_indirect_entry(scratch_cp, ref_i, merge_cp_p,
+                                                    merge_cp_length_p, THREAD);
+      if (new_ref_i != ref_i) {
+        RC_TRACE(0x00080000,
+                 ("MethodType entry@%d ref_index change: %d to %d",
+                  *merge_cp_length_p, ref_i, new_ref_i));
+      }
+      (*merge_cp_p)->method_type_index_at_put(*merge_cp_length_p, new_ref_i);
+      if (scratch_i != *merge_cp_length_p) {
+        // The new entry in *merge_cp_p is at a different index than
+        // the new entry in scratch_cp so we need to map the index values.
+        map_index(scratch_cp, scratch_i, *merge_cp_length_p);
+      }
+      (*merge_cp_length_p)++;
+    } break;
+
+    // this is an indirect CP entry so it needs special handling
+    case JVM_CONSTANT_MethodHandle:
+    {
+      int ref_kind = scratch_cp->method_handle_ref_kind_at(scratch_i);
+      int ref_i = scratch_cp->method_handle_index_at(scratch_i);
+      int new_ref_i = find_or_append_indirect_entry(scratch_cp, ref_i, merge_cp_p,
+                                                    merge_cp_length_p, THREAD);
+      if (new_ref_i != ref_i) {
+        RC_TRACE(0x00080000,
+                 ("MethodHandle entry@%d ref_index change: %d to %d",
+                  *merge_cp_length_p, ref_i, new_ref_i));
+      }
+      (*merge_cp_p)->method_handle_index_at_put(*merge_cp_length_p, ref_kind, new_ref_i);
+      if (scratch_i != *merge_cp_length_p) {
+        // The new entry in *merge_cp_p is at a different index than
+        // the new entry in scratch_cp so we need to map the index values.
+        map_index(scratch_cp, scratch_i, *merge_cp_length_p);
+      }
+      (*merge_cp_length_p)++;
+    } break;
+
+    // this is an indirect CP entry so it needs special handling
+    case JVM_CONSTANT_InvokeDynamic:
+    {
+      // Index of the bootstrap specifier in the operands array
+      int old_bs_i = scratch_cp->invoke_dynamic_bootstrap_specifier_index(scratch_i);
+      int new_bs_i = find_or_append_operand(scratch_cp, old_bs_i, merge_cp_p,
+                                                    merge_cp_length_p, THREAD);
+      // The bootstrap method NameAndType_info index
+      int old_ref_i = scratch_cp->invoke_dynamic_name_and_type_ref_index_at(scratch_i);
+      int new_ref_i = find_or_append_indirect_entry(scratch_cp, old_ref_i, merge_cp_p,
+                                                    merge_cp_length_p, THREAD);
+      if (new_bs_i != old_bs_i) {
+        RC_TRACE(0x00080000,
+                 ("InvokeDynamic entry@%d bootstrap_method_attr_index change: %d to %d",
+                  *merge_cp_length_p, old_bs_i, new_bs_i));
+      }
+      if (new_ref_i != old_ref_i) {
+        RC_TRACE(0x00080000,
+                 ("InvokeDynamic entry@%d name_and_type_index change: %d to %d",
+                  *merge_cp_length_p, old_ref_i, new_ref_i));
+      }
+
+      (*merge_cp_p)->invoke_dynamic_at_put(*merge_cp_length_p, new_bs_i, new_ref_i);
+      if (scratch_i != *merge_cp_length_p) {
+        // The new entry in *merge_cp_p is at a different index than
+        // the new entry in scratch_cp so we need to map the index values.
+        map_index(scratch_cp, scratch_i, *merge_cp_length_p);
+      }
+      (*merge_cp_length_p)++;
+    } break;
+
+   // At this stage, Class or UnresolvedClass could be here, but not
     // ClassIndex
     case JVM_CONSTANT_ClassIndex: // fall through
 
@@ -492,6 +447,134 @@
 } // end append_entry()
 
 
+int VM_RedefineClasses::find_or_append_indirect_entry(constantPoolHandle scratch_cp,
+      int ref_i, constantPoolHandle *merge_cp_p, int *merge_cp_length_p, TRAPS) {
+
+  int new_ref_i = ref_i;
+  bool match = (ref_i < *merge_cp_length_p) &&
+               scratch_cp->compare_entry_to(ref_i, *merge_cp_p, ref_i, THREAD);
+
+  if (!match) {
+    // forward reference in *merge_cp_p or not a direct match
+    int found_i = scratch_cp->find_matching_entry(ref_i, *merge_cp_p, THREAD);
+    if (found_i != 0) {
+      guarantee(found_i != ref_i, "compare_entry_to() and find_matching_entry() do not agree");
+      // Found a matching entry somewhere else in *merge_cp_p so just need a mapping entry.
+      new_ref_i = found_i;
+      map_index(scratch_cp, ref_i, found_i);
+    } else {
+      // no match found so we have to append this entry to *merge_cp_p
+      append_entry(scratch_cp, ref_i, merge_cp_p, merge_cp_length_p, THREAD);
+      // The above call to append_entry() can only append one entry
+      // so the post call query of *merge_cp_length_p is only for
+      // the sake of consistency.
+      new_ref_i = *merge_cp_length_p - 1;
+    }
+  }
+
+  return new_ref_i;
+} // end find_or_append_indirect_entry()
+
+
+// Append a bootstrap specifier into the merge_cp operands that is semantically equal
+// to the scratch_cp operands bootstrap specifier passed by the old_bs_i index.
+// Recursively append new merge_cp entries referenced by the new bootstrap specifier.
+void VM_RedefineClasses::append_operand(constantPoolHandle scratch_cp, int old_bs_i,
+       constantPoolHandle *merge_cp_p, int *merge_cp_length_p, TRAPS) {
+
+  int old_ref_i = scratch_cp->operand_bootstrap_method_ref_index_at(old_bs_i);
+  int new_ref_i = find_or_append_indirect_entry(scratch_cp, old_ref_i, merge_cp_p,
+                                                merge_cp_length_p, THREAD);
+  if (new_ref_i != old_ref_i) {
+    RC_TRACE(0x00080000,
+             ("operands entry@%d bootstrap method ref_index change: %d to %d",
+              _operands_cur_length, old_ref_i, new_ref_i));
+  }
+
+  typeArrayOop merge_ops = (*merge_cp_p)->operands();
+  int new_bs_i = _operands_cur_length;
+  // We have _operands_cur_length == 0 when the merge_cp operands is empty yet.
+  // However, the operand_offset_at(0) was set in the extend_operands() call.
+  int new_base = (new_bs_i == 0) ? (*merge_cp_p)->operand_offset_at(0)
+                                 : (*merge_cp_p)->operand_next_offset_at(new_bs_i - 1);
+  int argc     = scratch_cp->operand_argument_count_at(old_bs_i);
+
+  constantPoolOopDesc::operand_offset_at_put(merge_ops, _operands_cur_length, new_base);
+  merge_ops->short_at_put(new_base++, new_ref_i);
+  merge_ops->short_at_put(new_base++, argc);
+
+  for (int i = 0; i < argc; i++) {
+    int old_arg_ref_i = scratch_cp->operand_argument_index_at(old_bs_i, i);
+    int new_arg_ref_i = find_or_append_indirect_entry(scratch_cp, old_arg_ref_i, merge_cp_p,
+                                                      merge_cp_length_p, THREAD);
+    merge_ops->short_at_put(new_base++, new_arg_ref_i);
+    if (new_arg_ref_i != old_arg_ref_i) {
+      RC_TRACE(0x00080000,
+               ("operands entry@%d bootstrap method argument ref_index change: %d to %d",
+                _operands_cur_length, old_arg_ref_i, new_arg_ref_i));
+    }
+  }
+  if (old_bs_i != _operands_cur_length) {
+    // The bootstrap specifier in *merge_cp_p is at a different index than
+    // that in scratch_cp so we need to map the index values.
+    map_operand_index(old_bs_i, new_bs_i);
+  }
+  _operands_cur_length++;
+} // end append_operand()
+
+
+int VM_RedefineClasses::find_or_append_operand(constantPoolHandle scratch_cp,
+      int old_bs_i, constantPoolHandle *merge_cp_p, int *merge_cp_length_p, TRAPS) {
+
+  int new_bs_i = old_bs_i; // bootstrap specifier index
+  bool match = (old_bs_i < _operands_cur_length) &&
+               scratch_cp->compare_operand_to(old_bs_i, *merge_cp_p, old_bs_i, THREAD);
+
+  if (!match) {
+    // forward reference in *merge_cp_p or not a direct match
+    int found_i = scratch_cp->find_matching_operand(old_bs_i, *merge_cp_p,
+                                                    _operands_cur_length, THREAD);
+    if (found_i != -1) {
+      guarantee(found_i != old_bs_i, "compare_operand_to() and find_matching_operand() disagree");
+      // found a matching operand somewhere else in *merge_cp_p so just need a mapping
+      new_bs_i = found_i;
+      map_operand_index(old_bs_i, found_i);
+    } else {
+      // no match found so we have to append this bootstrap specifier to *merge_cp_p
+      append_operand(scratch_cp, old_bs_i, merge_cp_p, merge_cp_length_p, THREAD);
+      new_bs_i = _operands_cur_length - 1;
+    }
+  }
+  return new_bs_i;
+} // end find_or_append_operand()
+
+
+void VM_RedefineClasses::finalize_operands_merge(constantPoolHandle merge_cp, TRAPS) {
+  if (merge_cp->operands() == NULL) {
+    return;
+  }
+  // Shrink the merge_cp operands
+  merge_cp->shrink_operands(_operands_cur_length, CHECK);
+
+  if (RC_TRACE_ENABLED(0x00040000)) {
+    // don't want to loop unless we are tracing
+    int count = 0;
+    for (int i = 1; i < _operands_index_map_p->length(); i++) {
+      int value = _operands_index_map_p->at(i);
+      if (value != -1) {
+        RC_TRACE_WITH_THREAD(0x00040000, THREAD,
+          ("operands_index_map[%d]: old=%d new=%d", count, i, value));
+        count++;
+      }
+    }
+  }
+  // Clean-up
+  _operands_index_map_p = NULL;
+  _operands_cur_length = 0;
+  _operands_index_map_count = 0;
+} // end finalize_operands_merge()
+
+
 void VM_RedefineClasses::swap_all_method_annotations(int i, int j, instanceKlassHandle scratch_class) {
   typeArrayOop save;
 
@@ -777,6 +860,27 @@
 } // end find_new_index()
 
 
+// Find new bootstrap specifier index value for old bootstrap specifier index
+// value by seaching the index map. Returns zero (-1) if there is no mapped
+// value for the old bootstrap specifier index.
+int VM_RedefineClasses::find_new_operand_index(int old_index) {
+  if (_operands_index_map_count == 0) {
+    // map is empty so nothing can be found
+    return -1;
+  }
+
+  if (old_index == -1 || old_index >= _operands_index_map_p->length()) {
+    // The old_index is out of range so it is not mapped.
+    // This should not happen in regular constant pool merging use.
+    return -1;
+  }
+
+  int value = _operands_index_map_p->at(old_index);
+
+  return value;
+} // end find_new_operand_index()
+
+
 // Returns true if the current mismatch is due to a resolved/unresolved
 // class pair. Otherwise, returns false.
 bool VM_RedefineClasses::is_unresolved_class_mismatch(constantPoolHandle cp1,
@@ -1042,6 +1146,25 @@
 } // end map_index()
 
 
+// Map old_index to new_index as needed.
+void VM_RedefineClasses::map_operand_index(int old_index, int new_index) {
+  if (find_new_operand_index(old_index) != -1) {
+    // old_index is already mapped
+    return;
+  }
+
+  if (old_index == new_index) {
+    // no mapping is needed
+    return;
+  }
+
+  _operands_index_map_p->at_put(old_index, new_index);
+  _operands_index_map_count++;
+
+  RC_TRACE(0x00040000, ("mapped bootstrap specifier at index %d to %d", old_index, new_index));
+} // end map_index()
+
+
 // Merge old_cp and scratch_cp and return the results of the merge via
 // merge_cp_p. The number of entries in *merge_cp_p is returned via
 // merge_cp_length_p. The entries in old_cp occupy the same locations
@@ -1113,6 +1236,9 @@
       }
     } // end for each old_cp entry
 
+    constantPoolOopDesc::copy_operands(old_cp, *merge_cp_p, CHECK_0);
+    (*merge_cp_p)->extend_operands(scratch_cp, CHECK_0);
+
     // We don't need to sanity check that *merge_cp_length_p is within
     // *merge_cp_p bounds since we have the minimum on-entry check above.
     (*merge_cp_length_p) = old_i;
@@ -1235,6 +1361,7 @@
       ("after pass 1b: merge_cp_len=%d, scratch_i=%d, index_map_len=%d",
       *merge_cp_length_p, scratch_i, _index_map_count));
   }
+  finalize_operands_merge(*merge_cp_p, THREAD);
 
   return true;
 } // end merge_constant_pools()
@@ -1282,8 +1409,17 @@
   _index_map_count = 0;
   _index_map_p = new intArray(scratch_cp->length(), -1);
 
+  _operands_cur_length = constantPoolOopDesc::operand_array_length(old_cp->operands());
+  _operands_index_map_count = 0;
+  _operands_index_map_p = new intArray(
+    constantPoolOopDesc::operand_array_length(scratch_cp->operands()), -1);
+
+  // reference to the cp holder is needed for copy_operands()
+  merge_cp->set_pool_holder(scratch_class());
   bool result = merge_constant_pools(old_cp, scratch_cp, &merge_cp,
                   &merge_cp_length, THREAD);
+  merge_cp->set_pool_holder(NULL);
+
   if (!result) {
     // The merge can fail due to memory allocation failure or due
     // to robustness checks.
@@ -1326,7 +1462,7 @@
       // Replace the new constant pool with a shrunken copy of the
       // merged constant pool; the previous new constant pool will
       // get GCed.
-      set_new_constant_pool(scratch_class, merge_cp, merge_cp_length, true,
+      set_new_constant_pool(scratch_class, merge_cp, merge_cp_length,
         THREAD);
       // drop local ref to the merged constant pool
       merge_cp()->set_is_conc_safe(true);
@@ -1357,7 +1493,7 @@
     // merged constant pool so now the rewritten bytecodes have
     // valid references; the previous new constant pool will get
     // GCed.
-    set_new_constant_pool(scratch_class, merge_cp, merge_cp_length, true,
+    set_new_constant_pool(scratch_class, merge_cp, merge_cp_length,
       THREAD);
     merge_cp()->set_is_conc_safe(true);
   }
@@ -1540,6 +1676,7 @@
       case Bytecodes::_getfield       : // fall through
       case Bytecodes::_getstatic      : // fall through
       case Bytecodes::_instanceof     : // fall through
+      case Bytecodes::_invokedynamic  : // fall through
       case Bytecodes::_invokeinterface: // fall through
       case Bytecodes::_invokespecial  : // fall through
       case Bytecodes::_invokestatic   : // fall through
@@ -2343,30 +2480,30 @@
 // smaller constant pool is associated with scratch_class.
 void VM_RedefineClasses::set_new_constant_pool(
        instanceKlassHandle scratch_class, constantPoolHandle scratch_cp,
-       int scratch_cp_length, bool shrink, TRAPS) {
-  assert(!shrink || scratch_cp->length() >= scratch_cp_length, "sanity check");
-
-  if (shrink) {
-    // scratch_cp is a merged constant pool and has enough space for a
-    // worst case merge situation. We want to associate the minimum
-    // sized constant pool with the klass to save space.
-    constantPoolHandle smaller_cp(THREAD,
-      oopFactory::new_constantPool(scratch_cp_length,
-                                   oopDesc::IsUnsafeConc,
-                                   THREAD));
-    // preserve orig_length() value in the smaller copy
-    int orig_length = scratch_cp->orig_length();
-    assert(orig_length != 0, "sanity check");
-    smaller_cp->set_orig_length(orig_length);
-    scratch_cp->copy_cp_to(1, scratch_cp_length - 1, smaller_cp, 1, THREAD);
-    scratch_cp = smaller_cp;
-    smaller_cp()->set_is_conc_safe(true);
-  }
+       int scratch_cp_length, TRAPS) {
+  assert(scratch_cp->length() >= scratch_cp_length, "sanity check");
+
+  // scratch_cp is a merged constant pool and has enough space for a
+  // worst case merge situation. We want to associate the minimum
+  // sized constant pool with the klass to save space.
+  constantPoolHandle smaller_cp(THREAD,
+    oopFactory::new_constantPool(scratch_cp_length,
+                                 oopDesc::IsUnsafeConc,
+                                 THREAD));
+  // preserve orig_length() value in the smaller copy
+  int orig_length = scratch_cp->orig_length();
+  assert(orig_length != 0, "sanity check");
+  smaller_cp->set_orig_length(orig_length);
+
+  // attach klass to new constant pool
+  // reference to the cp holder is needed for copy_operands()
+  smaller_cp->set_pool_holder(scratch_class());
+
+  scratch_cp->copy_cp_to(1, scratch_cp_length - 1, smaller_cp, 1, THREAD);
+  scratch_cp = smaller_cp;
+  smaller_cp()->set_is_conc_safe(true);
 
   // attach new constant pool to klass
-  scratch_cp->set_pool_holder(scratch_class());
-
-  // attach klass to new constant pool
   scratch_class->set_constants(scratch_cp());
 
   int i;  // for portability
@@ -3310,6 +3447,16 @@
   // that reference methods of the evolved class.
   SystemDictionary::classes_do(adjust_cpool_cache_and_vtable, THREAD);
 
+  // JSR-292 support
+  MemberNameTable* mnt = the_class->member_names();
+  if (mnt != NULL) {
+    bool trace_name_printed = false;
+    mnt->adjust_method_entries(_matching_old_methods,
+                               _matching_new_methods,
+                               _matching_methods_length,
+                               &trace_name_printed);
+  }
+
   if (the_class->oop_map_cache() != NULL) {
     // Flush references to any obsolete methods from the oop map cache
     // so that obsolete methods are not pinned.
--- ./hotspot/src/share/vm/prims/jvmtiRedefineClasses.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/prims/jvmtiRedefineClasses.hpp	Wed May 07 19:26:16 2014 -0700
@@ -370,6 +370,13 @@
   // _index_map_p contains any entries.
   int                         _index_map_count;
   intArray *                  _index_map_p;
+
+  // _operands_index_map_count is just an optimization for knowing if
+  // _operands_index_map_p contains any entries.
+  int                         _operands_cur_length;
+  int                         _operands_index_map_count;
+  intArray *                  _operands_index_map_p;
+
   // ptr to _class_count scratch_classes
   instanceKlassHandle *       _scratch_classes;
   jvmtiError                  _res;
@@ -431,16 +438,24 @@
   // and in all direct and indirect subclasses.
   void increment_class_counter(instanceKlass *ik, TRAPS);
 
-  // Support for constant pool merging (these routines are in alpha
-  // order):
+  // Support for constant pool merging (these routines are in alpha order):
   void append_entry(constantPoolHandle scratch_cp, int scratch_i,
     constantPoolHandle *merge_cp_p, int *merge_cp_length_p, TRAPS);
+  void append_operand(constantPoolHandle scratch_cp, int scratch_bootstrap_spec_index,
+    constantPoolHandle *merge_cp_p, int *merge_cp_length_p, TRAPS);
+  void finalize_operands_merge(constantPoolHandle merge_cp, TRAPS);
+  int find_or_append_indirect_entry(constantPoolHandle scratch_cp, int scratch_i,
+    constantPoolHandle *merge_cp_p, int *merge_cp_length_p, TRAPS);
+  int find_or_append_operand(constantPoolHandle scratch_cp, int scratch_bootstrap_spec_index,
+    constantPoolHandle *merge_cp_p, int *merge_cp_length_p, TRAPS);
   int find_new_index(int old_index);
+  int find_new_operand_index(int old_bootstrap_spec_index);
   bool is_unresolved_class_mismatch(constantPoolHandle cp1, int index1,
     constantPoolHandle cp2, int index2);
   bool is_unresolved_string_mismatch(constantPoolHandle cp1, int index1,
     constantPoolHandle cp2, int index2);
   void map_index(constantPoolHandle scratch_cp, int old_index, int new_index);
+  void map_operand_index(int old_bootstrap_spec_index, int new_bootstrap_spec_index);
   bool merge_constant_pools(constantPoolHandle old_cp,
     constantPoolHandle scratch_cp, constantPoolHandle *merge_cp_p,
     int *merge_cp_length_p, TRAPS);
@@ -474,7 +489,7 @@
          address& stackmap_addr_ref, address stackmap_end, u2 frame_i,
          u1 frame_size, TRAPS);
   void set_new_constant_pool(instanceKlassHandle scratch_class,
-    constantPoolHandle scratch_cp, int scratch_cp_length, bool shrink, TRAPS);
+    constantPoolHandle scratch_cp, int scratch_cp_length, TRAPS);
 
   void flush_dependent_code(instanceKlassHandle k_h, TRAPS);
 
--- ./hotspot/src/share/vm/prims/methodHandles.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/prims/methodHandles.cpp	Wed May 07 19:26:16 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -29,6 +29,7 @@
 #include "interpreter/oopMapCache.hpp"
 #include "memory/allocation.inline.hpp"
 #include "memory/oopFactory.hpp"
+#include "prims/jvmtiRedefineClassesTrace.hpp"
 #include "prims/methodHandles.hpp"
 #include "runtime/compilationPolicy.hpp"
 #include "runtime/javaCalls.hpp"
@@ -123,7 +124,9 @@
   return Handle(THREAD, k->allocate_instance(THREAD));
 }
 
-oop MethodHandles::init_MemberName(oop mname_oop, oop target_oop) {
+oop MethodHandles::init_MemberName(Handle mname, Handle target) {
+  Thread* thread = Thread::current();
+  oop target_oop = target();
   klassOop target_klass = target_oop->klass();
   if (target_klass == SystemDictionary::reflect_Field_klass()) {
     oop clazz = java_lang_reflect_Field::clazz(target_oop); // fd.field_holder()
@@ -131,24 +134,24 @@
     int mods  = java_lang_reflect_Field::modifiers(target_oop);
     oop type  = java_lang_reflect_Field::type(target_oop);
     oop name  = java_lang_reflect_Field::name(target_oop);
-    klassOop k = java_lang_Class::as_klassOop(clazz);
-    intptr_t offset = instanceKlass::cast(k)->field_offset(slot);
-    return init_field_MemberName(mname_oop, k, accessFlags_from(mods), type, name, offset);
+    KlassHandle k(thread, java_lang_Class::as_klassOop(clazz));
+    intptr_t offset = instanceKlass::cast(k())->field_offset(slot);
+    return init_field_MemberName(mname, k, accessFlags_from(mods), type, name, offset);
   } else if (target_klass == SystemDictionary::reflect_Method_klass()) {
     oop clazz  = java_lang_reflect_Method::clazz(target_oop);
     int slot   = java_lang_reflect_Method::slot(target_oop);
-    klassOop k = java_lang_Class::as_klassOop(clazz);
-    if (k != NULL && Klass::cast(k)->oop_is_instance()) {
-      methodOop m = instanceKlass::cast(k)->method_with_idnum(slot);
-      return init_method_MemberName(mname_oop, m, true, k);
+    KlassHandle k(thread, java_lang_Class::as_klassOop(clazz));
+    if (!k.is_null() && k->oop_is_instance()) {
+      methodOop m = instanceKlass::cast(k())->method_with_idnum(slot);
+      return init_method_MemberName(mname, m, true, k);
     }
   } else if (target_klass == SystemDictionary::reflect_Constructor_klass()) {
     oop clazz  = java_lang_reflect_Constructor::clazz(target_oop);
     int slot   = java_lang_reflect_Constructor::slot(target_oop);
-    klassOop k = java_lang_Class::as_klassOop(clazz);
-    if (k != NULL && Klass::cast(k)->oop_is_instance()) {
-      methodOop m = instanceKlass::cast(k)->method_with_idnum(slot);
-      return init_method_MemberName(mname_oop, m, false, k);
+    KlassHandle k(thread, java_lang_Class::as_klassOop(clazz));
+    if (!k.is_null() && k->oop_is_instance()) {
+      methodOop m = instanceKlass::cast(k())->method_with_idnum(slot);
+      return init_method_MemberName(mname, m, false, k);
     }
   } else if (target_klass == SystemDictionary::MemberName_klass()) {
     // Note: This only works if the MemberName has already been resolved.
@@ -156,17 +159,18 @@
     int flags        = java_lang_invoke_MemberName::flags(target_oop);
     oop vmtarget     = java_lang_invoke_MemberName::vmtarget(target_oop);
     intptr_t vmindex = java_lang_invoke_MemberName::vmindex(target_oop);
-    klassOop k       = java_lang_Class::as_klassOop(clazz);
+    KlassHandle k(thread, java_lang_Class::as_klassOop(clazz));
     int ref_kind     = (flags >> REFERENCE_KIND_SHIFT) & REFERENCE_KIND_MASK;
     if (vmtarget == NULL)  return NULL;  // not resolved
     if ((flags & IS_FIELD) != 0) {
       assert(vmtarget->is_klass(), "field vmtarget is klassOop");
       int basic_mods = (ref_kind_is_static(ref_kind) ? JVM_ACC_STATIC : 0);
       // FIXME:  how does k (receiver_limit) contribute?
-      return init_field_MemberName(mname_oop, klassOop(vmtarget), accessFlags_from(basic_mods), NULL, NULL, vmindex);
+      KlassHandle k_vmtarget(thread, klassOop(vmtarget));
+      return init_field_MemberName(mname, k_vmtarget, accessFlags_from(basic_mods), NULL, NULL, vmindex);
     } else if ((flags & (IS_METHOD | IS_CONSTRUCTOR)) != 0) {
       assert(vmtarget->is_method(), "method or constructor vmtarget is methodOop");
-      return init_method_MemberName(mname_oop, methodOop(vmtarget), ref_kind_does_dispatch(ref_kind), k);
+      return init_method_MemberName(mname, methodOop(vmtarget), ref_kind_does_dispatch(ref_kind), k);
     } else {
       return NULL;
     }
@@ -174,8 +178,9 @@
   return NULL;
 }
 
-oop MethodHandles::init_method_MemberName(oop mname_oop, methodOop m, bool do_dispatch,
-                                          klassOop resolved_klass) {
+oop MethodHandles::init_method_MemberName(Handle mname, methodOop m, bool do_dispatch,
+                                          KlassHandle resolved_klass_h) {
+  klassOop resolved_klass = resolved_klass_h();
   AccessFlags mods = m->access_flags();
   int flags = (jushort)( mods.as_short() & JVM_RECOGNIZED_METHOD_MODIFIERS );
   int vmindex = methodOopDesc::nonvirtual_vtable_index; // implies never any dispatch
@@ -235,6 +240,7 @@
     }
   }
 
+  oop mname_oop = mname();
   java_lang_invoke_MemberName::set_flags(mname_oop,    flags);
   java_lang_invoke_MemberName::set_vmtarget(mname_oop, m);
   java_lang_invoke_MemberName::set_vmindex(mname_oop,  vmindex);   // vtable/itable index
@@ -246,11 +252,12 @@
   // If relevant, the vtable or itable value is stored as vmindex.
   // This is done eagerly, since it is readily available without
   // constructing any new objects.
-  // TO DO: maybe intern mname_oop
-  return mname_oop;
+  instanceKlass::cast(m->method_holder())->add_member_name(m->method_idnum(), mname);
+
+  return mname();
 }
 
-Handle MethodHandles::init_method_MemberName(oop mname_oop, CallInfo& info, TRAPS) {
+Handle MethodHandles::init_method_MemberName(Handle mname, CallInfo& info, TRAPS) {
   Handle empty;
   if (info.resolved_appendix().not_null()) {
     // The resolved MemberName must not be accompanied by an appendix argument,
@@ -270,23 +277,24 @@
   } else {
     vmindex = info.vtable_index();
   }
-  oop res = init_method_MemberName(mname_oop, m(), (vmindex >= 0), defc());
+  oop res = init_method_MemberName(mname, m(), (vmindex >= 0), defc());
   assert(res == NULL || (java_lang_invoke_MemberName::vmindex(res) == vmindex), "");
   return Handle(THREAD, res);
 }
 
-oop MethodHandles::init_field_MemberName(oop mname_oop, klassOop field_holder,
+oop MethodHandles::init_field_MemberName(Handle mname, KlassHandle field_holder,
                                          AccessFlags mods, oop type, oop name,
                                          intptr_t offset, bool is_setter) {
   int flags = (jushort)( mods.as_short() & JVM_RECOGNIZED_FIELD_MODIFIERS );
   flags |= IS_FIELD | ((mods.is_static() ? JVM_REF_getStatic : JVM_REF_getField) << REFERENCE_KIND_SHIFT);
   if (is_setter)  flags += ((JVM_REF_putField - JVM_REF_getField) << REFERENCE_KIND_SHIFT);
-  oop vmtarget = field_holder;
+  oop vmtarget = field_holder();
   int vmindex  = offset;  // determines the field uniquely when combined with static bit
+  oop mname_oop = mname();
   java_lang_invoke_MemberName::set_flags(mname_oop,    flags);
   java_lang_invoke_MemberName::set_vmtarget(mname_oop, vmtarget);
   java_lang_invoke_MemberName::set_vmindex(mname_oop,  vmindex);
-  java_lang_invoke_MemberName::set_clazz(mname_oop,    Klass::cast(field_holder)->java_mirror());
+  java_lang_invoke_MemberName::set_clazz(mname_oop,    field_holder()->java_mirror());
   if (name != NULL)
     java_lang_invoke_MemberName::set_name(mname_oop,   name);
   if (type != NULL)
@@ -298,11 +306,10 @@
   // because they unambiguously identify the field.
   // Although the fieldDescriptor::_index would also identify the field,
   // we do not use it, because it is harder to decode.
-  // TO DO: maybe intern mname_oop
-  return mname_oop;
+  return mname();
 }
 
-Handle MethodHandles::init_field_MemberName(oop mname_oop, FieldAccessInfo& info, TRAPS) {
+Handle MethodHandles::init_field_MemberName(Handle mname, FieldAccessInfo& info, TRAPS) {
   return Handle();
 #if 0
   KlassHandle field_holder = info.klass();
@@ -728,7 +735,7 @@
           return empty;
         }
       }
-      return init_method_MemberName(mname(), result, THREAD);
+      return init_method_MemberName(mname, result, THREAD);
     }
   case IS_CONSTRUCTOR:
     {
@@ -746,7 +753,7 @@
         }
       }
       assert(result.is_statically_bound(), "");
-      return init_method_MemberName(mname(), result, THREAD);
+      return init_method_MemberName(mname, result, THREAD);
     }
   case IS_FIELD:
     {
@@ -759,7 +766,7 @@
       oop name = field_name_or_null(fd.name());
       bool is_setter = (ref_kind_is_valid(ref_kind) && ref_kind_is_setter(ref_kind));
       mname = Handle(THREAD,
-                     init_field_MemberName(mname(), sel_klass->as_klassOop(),
+                     init_field_MemberName(mname, sel_klass,
                                            fd.access_flags(), type, name, fd.offset(), is_setter));
       return mname;
     }
@@ -851,16 +858,16 @@
   THROW_MSG(vmSymbols::java_lang_InternalError(), "unrecognized MemberName format");
 }
 
-int MethodHandles::find_MemberNames(klassOop k,
+int MethodHandles::find_MemberNames(KlassHandle k,
                                     Symbol* name, Symbol* sig,
-                                    int mflags, klassOop caller,
-                                    int skip, objArrayOop results) {
-  DEBUG_ONLY(No_Safepoint_Verifier nsv);
-  // this code contains no safepoints!
+                                    int mflags, KlassHandle caller,
+                                    int skip, objArrayHandle results) {
 
   // %%% take caller into account!
 
-  if (k == NULL || !Klass::cast(k)->oop_is_instance())  return -1;
+  Thread* thread = Thread::current();
+
+  if (k.is_null() || !k->oop_is_instance())  return -1;
 
   int rfill = 0, rlimit = results->length(), rskip = skip;
   // overflow measurement:
@@ -888,7 +895,7 @@
   }
 
   if ((match_flags & IS_FIELD) != 0) {
-    for (FieldStream st(k, local_only, !search_intfc); !st.eos(); st.next()) {
+    for (FieldStream st(k(), local_only, !search_intfc); !st.eos(); st.next()) {
       if (name != NULL && st.name() != name)
           continue;
       if (sig != NULL && st.signature() != sig)
@@ -897,15 +904,15 @@
       if (rskip > 0) {
         --rskip;
       } else if (rfill < rlimit) {
-        oop result = results->obj_at(rfill++);
-        if (!java_lang_invoke_MemberName::is_instance(result))
+        Handle result(thread, results->obj_at(rfill++));
+        if (!java_lang_invoke_MemberName::is_instance(result()))
           return -99;  // caller bug!
         oop type = field_signature_type_or_null(st.signature());
         oop name = field_name_or_null(st.name());
-        oop saved = MethodHandles::init_field_MemberName(result, st.klass()->as_klassOop(),
+        oop saved = MethodHandles::init_field_MemberName(result, st.klass(),
                                                          st.access_flags(), type, name,
                                                          st.offset());
-        if (saved != result)
+        if (saved != result())
           results->obj_at_put(rfill-1, saved);  // show saved instance to user
       } else if (++overflow >= overflow_limit) {
         match_flags = 0; break; // got tired of looking at overflow
@@ -938,7 +945,7 @@
     } else {
       // caller will accept either sort; no need to adjust name
     }
-    for (MethodStream st(k, local_only, !search_intfc); !st.eos(); st.next()) {
+    for (MethodStream st(k(), local_only, !search_intfc); !st.eos(); st.next()) {
       methodOop m = st.method();
       Symbol* m_name = m->name();
       if (m_name == clinit_name)
@@ -951,11 +958,11 @@
       if (rskip > 0) {
         --rskip;
       } else if (rfill < rlimit) {
-        oop result = results->obj_at(rfill++);
-        if (!java_lang_invoke_MemberName::is_instance(result))
+        Handle result(thread, results->obj_at(rfill++));
+        if (!java_lang_invoke_MemberName::is_instance(result()))
           return -99;  // caller bug!
-        oop saved = MethodHandles::init_method_MemberName(result, m, true, NULL);
-        if (saved != result)
+        oop saved = MethodHandles::init_method_MemberName(result, m, true, KlassHandle());
+        if (saved != result())
           results->obj_at_put(rfill-1, saved);  // show saved instance to user
       } else if (++overflow >= overflow_limit) {
         match_flags = 0; break; // got tired of looking at overflow
@@ -967,6 +974,85 @@
   return rfill + overflow;
 }
 
+//------------------------------------------------------------------------------
+// MemberNameTable
+//
+
+MemberNameTable::MemberNameTable(int methods_cnt)
+                  : GrowableArray<jweak>(methods_cnt, true) {
+  assert_locked_or_safepoint(MemberNameTable_lock);
+}
+
+MemberNameTable::~MemberNameTable() {
+  assert_locked_or_safepoint(MemberNameTable_lock);
+  int len = this->length();
+
+  for (int idx = 0; idx < len; idx++) {
+    jweak ref = this->at(idx);
+    JNIHandles::destroy_weak_global(ref);
+  }
+}
+
+void MemberNameTable::add_member_name(int index, jweak mem_name_wref) {
+  assert_locked_or_safepoint(MemberNameTable_lock);
+  this->at_put_grow(index, mem_name_wref);
+}
+
+// Return a member name oop or NULL.
+oop MemberNameTable::get_member_name(int index) {
+  assert_locked_or_safepoint(MemberNameTable_lock);
+  jweak ref = this->at(index);
+  oop mem_name = JNIHandles::resolve(ref);
+  return mem_name;
+}
+
+oop MemberNameTable::find_member_name_by_method(methodOop old_method) {
+  assert_locked_or_safepoint(MemberNameTable_lock);
+  oop found = NULL;
+  int len = this->length();
+
+  for (int idx = 0; idx < len; idx++) {
+    oop mem_name = JNIHandles::resolve(this->at(idx));
+    if (mem_name == NULL) {
+      continue;
+    }
+    methodOop method = (methodOop)java_lang_invoke_MemberName::vmtarget(mem_name);
+    if (method == old_method) {
+      found = mem_name;
+      break;
+    }
+  }
+  return found;
+}
+
+// It is called at safepoint only
+void MemberNameTable::adjust_method_entries(methodOop* old_methods, methodOop* new_methods,
+                                            int methods_length, bool *trace_name_printed) {
+  assert(SafepointSynchronize::is_at_safepoint(), "only called at safepoint");
+  // search the MemberNameTable for uses of either obsolete or EMCP methods
+  for (int j = 0; j < methods_length; j++) {
+    methodOop old_method = old_methods[j];
+    methodOop new_method = new_methods[j];
+    oop mem_name = find_member_name_by_method(old_method);
+    if (mem_name != NULL) {
+      java_lang_invoke_MemberName::adjust_vmtarget(mem_name, new_method);
+
+      if (RC_TRACE_IN_RANGE(0x00100000, 0x00400000)) {
+        if (!(*trace_name_printed)) {
+          // RC_TRACE_MESG macro has an embedded ResourceMark
+          RC_TRACE_MESG(("adjust: name=%s",
+                         Klass::cast(old_method->method_holder())->external_name()));
+          *trace_name_printed = true;
+        }
+        // RC_TRACE macro has an embedded ResourceMark
+        RC_TRACE(0x00400000, ("MemberName method update: %s(%s)",
+                              new_method->name()->as_C_string(),
+                              new_method->signature()->as_C_string()));
+      }
+    }
+  }
+}
+
 //
 // Here are the native methods in java.lang.invoke.MethodHandleNatives
 // They are the private interface between this JVM and the HotSpot-specific
@@ -1058,8 +1144,8 @@
   if (mname_jh == NULL) { THROW_MSG(vmSymbols::java_lang_InternalError(), "mname is null"); }
   if (target_jh == NULL) { THROW_MSG(vmSymbols::java_lang_InternalError(), "target is null"); }
   Handle mname(THREAD, JNIHandles::resolve_non_null(mname_jh));
-  oop target_oop = JNIHandles::resolve_non_null(target_jh);
-  MethodHandles::init_MemberName(mname(), target_oop);
+  Handle target(THREAD, JNIHandles::resolve_non_null(target_jh));
+  MethodHandles::init_MemberName(mname, target);
 }
 JVM_END
 
@@ -1174,11 +1260,12 @@
   } else if (vmtarget->is_klass()) {
     x = Klass::cast((klassOop) vmtarget())->java_mirror();
   } else {
-    Handle mname2 = MethodHandles::new_MemberName(CHECK_NULL);
-    if (vmtarget->is_method())
-      x = MethodHandles::init_method_MemberName(mname2(), methodOop(vmtarget()), false, NULL);
-    else
+    if (vmtarget->is_method()) {
+      x = mname();
+    } else {
+      Handle mname2 = MethodHandles::new_MemberName(CHECK_NULL);
       x = MethodHandles::init_MemberName(mname2(), vmtarget());
+    }
   }
   result->obj_at_put(1, x);
   return JNIHandles::make_local(env, result());
@@ -1221,8 +1308,8 @@
     // %%% TO DO
   }
 
-  int res = MethodHandles::find_MemberNames(k(), name, sig, mflags,
-                                            caller(), skip, results());
+  int res = MethodHandles::find_MemberNames(k, name, sig, mflags,
+                                            caller, skip, results);
   // TO DO: expand at least some of the MemberNames, to avoid massive callbacks
   return res;
 }
--- ./hotspot/src/share/vm/prims/methodHandles.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/prims/methodHandles.hpp	Wed May 07 19:26:16 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -39,7 +39,6 @@
   // in java.lang.invoke and sun.invoke.
   // See also  javaClasses for layouts java_lang_invoke_Method{Handle,Type,Type::Form}.
  public:
- public:
   static bool enabled()                         { return _enabled; }
   static void set_enabled(bool z);
 
@@ -54,18 +53,18 @@
   static Handle resolve_MemberName(Handle mname, KlassHandle caller, TRAPS); // compute vmtarget/vmindex from name/type
   static void expand_MemberName(Handle mname, int suppress, TRAPS);  // expand defc/name/type if missing
   static Handle new_MemberName(TRAPS);  // must be followed by init_MemberName
-  static oop init_MemberName(oop mname_oop, oop target_oop); // compute vmtarget/vmindex from target
-  static oop init_method_MemberName(oop mname_oop, methodOop m, bool do_dispatch,
-                                    klassOop resolved_klass);
-  static oop init_field_MemberName(oop mname_oop, klassOop field_holder,
+  static oop init_MemberName(Handle mname_h, Handle target_h); // compute vmtarget/vmindex from target
+  static oop init_method_MemberName(Handle mname_h, methodOop m, bool do_dispatch,
+                                    KlassHandle resolved_klass_h);
+  static oop init_field_MemberName(Handle mname_h, KlassHandle field_holder_h,
                                    AccessFlags mods, oop type, oop name,
                                    intptr_t offset, bool is_setter = false);
-  static Handle init_method_MemberName(oop mname_oop, CallInfo& info, TRAPS);
-  static Handle init_field_MemberName(oop mname_oop, FieldAccessInfo& info, TRAPS);
+  static Handle init_method_MemberName(Handle mname_h, CallInfo& info, TRAPS);
+  static Handle init_field_MemberName(Handle mname_h, FieldAccessInfo& info, TRAPS);
   static int method_ref_kind(methodOop m, bool do_dispatch_if_possible = true);
-  static int find_MemberNames(klassOop k, Symbol* name, Symbol* sig,
-                              int mflags, klassOop caller,
-                              int skip, objArrayOop results);
+  static int find_MemberNames(KlassHandle k, Symbol* name, Symbol* sig,
+                              int mflags, KlassHandle caller,
+                              int skip, objArrayHandle results);
   // bit values for suppress argument to expand_MemberName:
   enum { _suppress_defc = 1, _suppress_name = 2, _suppress_type = 4 };
 
@@ -230,4 +229,26 @@
   void generate();
 };
 
+//------------------------------------------------------------------------------
+// MemberNameTable
+//
+
+class MemberNameTable : public GrowableArray<jweak> {
+ public:
+  MemberNameTable(int methods_cnt);
+  ~MemberNameTable();
+
+  void add_member_name(int index, jweak mem_name_ref);
+  oop  get_member_name(int index);
+
+ public:
+  // RedefineClasses() API support:
+  // If a MemberName refers to old_method then update it
+  // to refer to new_method.
+  void adjust_method_entries(methodOop* old_methods, methodOop* new_methods,
+                             int methods_length, bool *trace_name_printed);
+ private:
+  oop find_member_name_by_method(methodOop old_method);
+};
+
 #endif // SHARE_VM_PRIMS_METHODHANDLES_HPP
--- ./hotspot/src/share/vm/prims/whitebox.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/prims/whitebox.cpp	Wed May 07 19:26:16 2014 -0700
@@ -27,6 +27,8 @@
 #include "memory/universe.hpp"
 #include "oops/oop.inline.hpp"
 
+#include "code/codeCache.hpp"
+
 #include "classfile/symbolTable.hpp"
 
 #include "prims/whitebox.hpp"
@@ -131,6 +133,13 @@
   return MemTracker::wbtest_wait_for_data_merge();
 WB_END
 
+WB_ENTRY(void, WB_DeoptimizeAll(JNIEnv* env, jobject o))
+  MutexLockerEx mu(Compile_lock);
+  CodeCache::mark_all_nmethods_for_deoptimization();
+  VM_Deoptimize op;
+  VMThread::execute(&op);
+WB_END
+
 //Some convenience methods to deal with objects from java
 int WhiteBox::offset_for_field(const char* field_name, oop object,
     Symbol* signature_symbol) {
@@ -204,6 +213,7 @@
   {CC"NMTUncommitMemory",   CC"(JJ)V",                (void*)&WB_NMTUncommitMemory  },
   {CC"NMTReleaseMemory",    CC"(JJ)V",                (void*)&WB_NMTReleaseMemory   },
   {CC"NMTWaitForDataMerge", CC"()Z",                  (void*)&WB_NMTWaitForDataMerge},
+  {CC"deoptimizeAll",       CC"()V",                  (void*)&WB_DeoptimizeAll     },
 };
 
 #undef CC
--- ./hotspot/src/share/vm/runtime/arguments.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/runtime/arguments.cpp	Wed May 07 19:26:16 2014 -0700
@@ -1447,6 +1447,17 @@
   }
   FLAG_SET_DEFAULT(UseParallelGC, true);
 
+  if (UseAdaptiveSizePolicy) {
+    // We don't want to limit adaptive heap sizing's freedom to adjust the heap
+    // unless the user actually sets these flags.
+    if (FLAG_IS_DEFAULT(MinHeapFreeRatio)) {
+      FLAG_SET_DEFAULT(MinHeapFreeRatio, 0);
+    }
+    if (FLAG_IS_DEFAULT(MaxHeapFreeRatio)) {
+      FLAG_SET_DEFAULT(MaxHeapFreeRatio, 100);
+    }
+  }
+
   // If no heap maximum was requested explicitly, use some reasonable fraction
   // of the physical memory, up to a maximum of 1GB.
   if (UseParallelGC) {
@@ -1719,7 +1730,7 @@
 }
 
 bool Arguments::verify_percentage(uintx value, const char* name) {
-  if (value <= 100) {
+  if (is_percentage(value)) {
     return true;
   }
   jio_fprintf(defaultStream::error_stream(),
@@ -1768,6 +1779,34 @@
   }
 }
 
+bool Arguments::verify_MinHeapFreeRatio(FormatBuffer<80>& err_msg, uintx min_heap_free_ratio) {
+  if (!is_percentage(min_heap_free_ratio)) {
+    err_msg.print("MinHeapFreeRatio must have a value between 0 and 100");
+    return false;
+  }
+  if (min_heap_free_ratio > MaxHeapFreeRatio) {
+    err_msg.print("MinHeapFreeRatio (" UINTX_FORMAT ") must be less than or "
+                  "equal to MaxHeapFreeRatio (" UINTX_FORMAT ")", min_heap_free_ratio,
+                  MaxHeapFreeRatio);
+    return false;
+  }
+  return true;
+}
+
+bool Arguments::verify_MaxHeapFreeRatio(FormatBuffer<80>& err_msg, uintx max_heap_free_ratio) {
+  if (!is_percentage(max_heap_free_ratio)) {
+    err_msg.print("MaxHeapFreeRatio must have a value between 0 and 100");
+    return false;
+  }
+  if (max_heap_free_ratio < MinHeapFreeRatio) {
+    err_msg.print("MaxHeapFreeRatio (" UINTX_FORMAT ") must be greater than or "
+                  "equal to MinHeapFreeRatio (" UINTX_FORMAT ")", max_heap_free_ratio,
+                  MinHeapFreeRatio);
+    return false;
+  }
+  return true;
+}
+
 // Check consistency of GC selection
 bool Arguments::check_gc_consistency() {
   check_gclog_consistency();
@@ -1852,15 +1891,19 @@
                               "AdaptiveSizePolicyWeight");
   status = status && verify_percentage(AdaptivePermSizeWeight, "AdaptivePermSizeWeight");
   status = status && verify_percentage(ThresholdTolerance, "ThresholdTolerance");
-  status = status && verify_percentage(MinHeapFreeRatio, "MinHeapFreeRatio");
-  status = status && verify_percentage(MaxHeapFreeRatio, "MaxHeapFreeRatio");
-
-  if (MinHeapFreeRatio > MaxHeapFreeRatio) {
-    jio_fprintf(defaultStream::error_stream(),
-                "MinHeapFreeRatio (" UINTX_FORMAT ") must be less than or "
-                "equal to MaxHeapFreeRatio (" UINTX_FORMAT ")\n",
-                MinHeapFreeRatio, MaxHeapFreeRatio);
-    status = false;
+
+  {
+    // Using "else if" below to avoid printing two error messages if min > max.
+    // This will also prevent us from reporting both min>100 and max>100 at the
+    // same time, but that is less annoying than printing two identical errors IMHO.
+    FormatBuffer<80> err_msg("");
+    if (!verify_MinHeapFreeRatio(err_msg, MinHeapFreeRatio)) {
+      jio_fprintf(defaultStream::error_stream(), "%s\n", err_msg.buffer());
+      status = false;
+    } else if (!verify_MaxHeapFreeRatio(err_msg, MaxHeapFreeRatio)) {
+      jio_fprintf(defaultStream::error_stream(), "%s\n", err_msg.buffer());
+      status = false;
+    }
   }
   // Keeping the heap 100% free is hard ;-) so limit it to 99%.
   MinHeapFreeRatio = MIN2(MinHeapFreeRatio, (uintx) 99);
@@ -1943,11 +1986,12 @@
   // than just disable the lock verification. This will be fixed under
   // bug 4788986.
   if (UseConcMarkSweepGC && FLSVerifyAllHeapReferences) {
-    if (VerifyGCStartAt == 0) {
+    if (VerifyDuringStartup) {
       warning("Heap verification at start-up disabled "
               "(due to current incompatibility with FLSVerifyAllHeapReferences)");
-      VerifyGCStartAt = 1;      // Disable verification at start-up
+      VerifyDuringStartup = false; // Disable verification at start-up
     }
+
     if (VerifyBeforeExit) {
       warning("Heap verification at shutdown disabled "
               "(due to current incompatibility with FLSVerifyAllHeapReferences)");
@@ -2549,7 +2593,9 @@
          FLAG_SET_CMDLINE(uintx, MaxNewSize, NewSize);
       }
 
+#ifndef _ALLBSD_SOURCE  // UseLargePages is not yet supported on BSD.
       FLAG_SET_DEFAULT(UseLargePages, true);
+#endif
 
       // Increase some data structure sizes for efficiency
       FLAG_SET_CMDLINE(uintx, BaseFootPrintEstimate, MaxHeapSize);
@@ -3111,6 +3157,10 @@
   UNSUPPORTED_OPTION(UseG1GC, "G1 GC");
 #endif
 
+#ifdef _ALLBSD_SOURCE  // UseLargePages is not yet supported on BSD.
+  UNSUPPORTED_OPTION(UseLargePages, "-XX:+UseLargePages");
+#endif
+
 #ifndef PRODUCT
   if (TraceBytecodesAt != 0) {
     TraceBytecodes = true;
--- ./hotspot/src/share/vm/runtime/arguments.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/runtime/arguments.hpp	Wed May 07 19:26:16 2014 -0700
@@ -27,6 +27,7 @@
 
 #include "runtime/java.hpp"
 #include "runtime/perfData.hpp"
+#include "utilities/debug.hpp"
 #include "utilities/top.hpp"
 
 // Arguments parses the command line and recognizes options
@@ -350,6 +351,9 @@
   static bool is_bad_option(const JavaVMOption* option, jboolean ignore) {
     return is_bad_option(option, ignore, NULL);
   }
+  static bool is_percentage(uintx val) {
+    return val <= 100;
+  }
   static bool verify_interval(uintx val, uintx min,
                               uintx max, const char* name);
   static bool verify_min_value(intx val, intx min, const char* name);
@@ -411,6 +415,12 @@
  public:
   // Parses the arguments
   static jint parse(const JavaVMInitArgs* args);
+  // Verifies that the given value will fit as a MinHeapFreeRatio. If not, an error
+  // message is returned in the provided buffer.
+  static bool verify_MinHeapFreeRatio(FormatBuffer<80>& err_msg, uintx min_heap_free_ratio);
+  // Verifies that the given value will fit as a MaxHeapFreeRatio. If not, an error
+  // message is returned in the provided buffer.
+  static bool verify_MaxHeapFreeRatio(FormatBuffer<80>& err_msg, uintx max_heap_free_ratio);
   // Check for consistency in the selection of the garbage collector.
   static bool check_gc_consistency();
   // Check consistecy or otherwise of VM argument settings
--- ./hotspot/src/share/vm/runtime/frame.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/runtime/frame.cpp	Wed May 07 19:26:16 2014 -0700
@@ -23,6 +23,7 @@
  */
 
 #include "precompiled.hpp"
+#include "compiler/abstractCompiler.hpp"
 #include "gc_interface/collectedHeap.inline.hpp"
 #include "interpreter/interpreter.hpp"
 #include "interpreter/oopMapCache.hpp"
@@ -559,7 +560,7 @@
 
   st->print("%s frame (sp=" INTPTR_FORMAT " unextended sp=" INTPTR_FORMAT, print_name(), sp(), unextended_sp());
   if (sp() != NULL)
-    st->print(", fp=" INTPTR_FORMAT ", pc=" INTPTR_FORMAT, fp(), pc());
+    st->print(", fp=" INTPTR_FORMAT ", real_fp=" INTPTR_FORMAT ", pc=" INTPTR_FORMAT, fp(), real_fp(), pc());
 
   if (StubRoutines::contains(pc())) {
     st->print_cr(")");
@@ -720,10 +721,14 @@
     } else if (_cb->is_buffer_blob()) {
       st->print("v  ~BufferBlob::%s", ((BufferBlob *)_cb)->name());
     } else if (_cb->is_nmethod()) {
-      methodOop m = ((nmethod *)_cb)->method();
+      nmethod* nm = (nmethod*)_cb;
+      methodOop m = nm->method();
       if (m != NULL) {
         m->name_and_sig_as_C_string(buf, buflen);
-        st->print("J  %s", buf);
+        st->print("J %d%s %s %s (%d bytes) @ " PTR_FORMAT " [" PTR_FORMAT "+0x%x]",
+                  nm->compile_id(), (nm->is_osr_method() ? "%" : ""),
+                  ((nm->compiler() != NULL) ? nm->compiler()->name() : ""),
+                  buf, m->code_size(), _pc, _cb->code_begin(), _pc - _cb->code_begin());
       } else {
         st->print("J  " PTR_FORMAT, pc());
       }
--- ./hotspot/src/share/vm/runtime/globals.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/runtime/globals.hpp	Wed May 07 19:26:16 2014 -0700
@@ -1697,6 +1697,9 @@
   product(bool, CMSAbortSemantics, false,                                   \
           "Whether abort-on-overflow semantics is implemented")             \
                                                                             \
+  product(bool, CMSParallelInitialMarkEnabled, false,                       \
+          "Use the parallel initial mark.")                                 \
+                                                                            \
   product(bool, CMSParallelRemarkEnabled, true,                             \
           "Whether parallel remark enabled (only if ParNewGC)")             \
                                                                             \
@@ -1708,6 +1711,14 @@
           "Whether to always record survivor space PLAB bdries"             \
           " (effective only if CMSParallelSurvivorRemarkEnabled)")          \
                                                                             \
+  product(bool, CMSEdenChunksRecordAlways, false,                           \
+          "Whether to always record eden chunks used for "                  \
+          "the parallel initial mark or remark of eden" )                   \
+                                                                            \
+  product(bool, CMSPrintEdenSurvivorChunks, false,                          \
+          "Print the eden and the survivor chunks used for the parallel "   \
+          "initial mark or remark of the eden/survivor spaces")             \
+                                                                            \
   product(bool, CMSConcurrentMTEnabled, true,                               \
           "Whether multi-threaded concurrent work enabled (if ParNewGC)")   \
                                                                             \
@@ -1917,6 +1928,9 @@
   notproduct(bool, ExecuteInternalVMTests, false,                           \
           "Enable execution of internal VM tests.")                         \
                                                                             \
+  notproduct(bool, VerboseInternalVMTests, false,                           \
+          "Turn on logging for internal VM tests.")                         \
+                                                                            \
   product_pd(bool, UseTLAB, "Use thread-local object allocation")           \
                                                                             \
   product_pd(bool, ResizeTLAB,                                              \
@@ -2126,6 +2140,13 @@
   product(intx, PrefetchFieldsAhead, -1,                                    \
           "How many fields ahead to prefetch in oop scan (<= 0 means off)") \
                                                                             \
+  diagnostic(bool, VerifySilently, false,                                   \
+          "Don't print print the verification progress")                    \
+                                                                            \
+  diagnostic(bool, VerifyDuringStartup, false,                              \
+          "Verify memory system before executing any Java code "            \
+          "during VM initialization")                                       \
+                                                                            \
   diagnostic(bool, VerifyBeforeExit, trueInDebug,                           \
           "Verify system before exiting")                                   \
                                                                             \
@@ -3010,10 +3031,10 @@
   product_pd(uintx, MaxPermSize,                                            \
           "Maximum size of permanent generation (in bytes)")                \
                                                                             \
-  product(uintx, MinHeapFreeRatio,    40,                                   \
+  manageable(uintx, MinHeapFreeRatio,    40,                                \
           "Min percentage of heap free after GC to avoid expansion")        \
                                                                             \
-  product(uintx, MaxHeapFreeRatio,    70,                                   \
+  manageable(uintx, MaxHeapFreeRatio,    70,                                \
           "Max percentage of heap free after GC to avoid shrinking")        \
                                                                             \
   product(intx, SoftRefLRUPolicyMSPerMB, 1000,                              \
--- ./hotspot/src/share/vm/runtime/mutexLocker.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/runtime/mutexLocker.cpp	Wed May 07 19:26:16 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -57,6 +57,7 @@
 Mutex*   JNIGlobalHandle_lock         = NULL;
 Mutex*   JNIHandleBlockFreeList_lock  = NULL;
 Mutex*   JNICachedItableIndex_lock    = NULL;
+Mutex*   MemberNameTable_lock         = NULL;
 Mutex*   JmethodIdCreation_lock       = NULL;
 Mutex*   JfieldIdCreation_lock        = NULL;
 Monitor* JNICritical_lock             = NULL;
@@ -263,6 +264,7 @@
   def(Heap_lock                    , Monitor, nonleaf+1,   false);
   def(JfieldIdCreation_lock        , Mutex  , nonleaf+1,   true ); // jfieldID, Used in VM_Operation
   def(JNICachedItableIndex_lock    , Mutex  , nonleaf+1,   false); // Used to cache an itable index during JNI invoke
+  def(MemberNameTable_lock         , Mutex  , nonleaf+1,   false); // Used to protect MemberNameTable
 
   def(CompiledIC_lock              , Mutex  , nonleaf+2,   false); // locks VtableStubs_lock, InlineCacheBuffer_lock
   def(CompileTaskAlloc_lock        , Mutex  , nonleaf+2,   true );
--- ./hotspot/src/share/vm/runtime/mutexLocker.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/runtime/mutexLocker.hpp	Wed May 07 19:26:16 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -51,6 +51,7 @@
 extern Mutex*   JNIGlobalHandle_lock;            // a lock on creating JNI global handles
 extern Mutex*   JNIHandleBlockFreeList_lock;     // a lock on the JNI handle block free list
 extern Mutex*   JNICachedItableIndex_lock;       // a lock on caching an itable index during JNI invoke
+extern Mutex*   MemberNameTable_lock;            // a lock on the MemberNameTable updates
 extern Mutex*   JmethodIdCreation_lock;          // a lock on creating JNI method identifiers
 extern Mutex*   JfieldIdCreation_lock;           // a lock on creating JNI static field identifiers
 extern Monitor* JNICritical_lock;                // a lock used while entering and exiting JNI critical regions, allows GC to sometimes get in
--- ./hotspot/src/share/vm/runtime/os.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/runtime/os.hpp	Wed May 07 19:26:16 2014 -0700
@@ -330,8 +330,8 @@
 
   static char*  non_memory_address_word();
   // reserve, commit and pin the entire memory region
-  static char*  reserve_memory_special(size_t size, char* addr = NULL,
-                bool executable = false);
+  static char*  reserve_memory_special(size_t size, size_t alignment,
+                                       char* addr, bool executable);
   static bool   release_memory_special(char* addr, size_t bytes);
   static void   large_page_init();
   static size_t large_page_size();
--- ./hotspot/src/share/vm/runtime/sweeper.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/runtime/sweeper.cpp	Wed May 07 19:26:16 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -36,6 +36,7 @@
 #include "runtime/vm_operations.hpp"
 #include "trace/tracing.hpp"
 #include "utilities/events.hpp"
+#include "utilities/ticks.inline.hpp"
 #include "utilities/xmlstream.hpp"
 
 #ifdef ASSERT
@@ -148,12 +149,12 @@
 
 int       NMethodSweeper::_number_of_flushes = 0; // Total of full traversals caused by full cache
 int       NMethodSweeper::_total_nof_methods_reclaimed = 0;
-jlong     NMethodSweeper::_total_time_sweeping = 0;
-jlong     NMethodSweeper::_total_time_this_sweep = 0;
-jlong     NMethodSweeper::_peak_sweep_time = 0;
-jlong     NMethodSweeper::_peak_sweep_fraction_time = 0;
-jlong     NMethodSweeper::_total_disconnect_time = 0;
-jlong     NMethodSweeper::_peak_disconnect_time = 0;
+Tickspan  NMethodSweeper::_total_time_sweeping;
+Tickspan  NMethodSweeper::_total_time_this_sweep;
+Tickspan  NMethodSweeper::_peak_sweep_time;
+Tickspan  NMethodSweeper::_peak_sweep_fraction_time;
+Tickspan  NMethodSweeper::_total_disconnect_time;
+Tickspan  NMethodSweeper::_peak_disconnect_time;
 
 class MarkActivationClosure: public CodeBlobClosure {
 public:
@@ -192,7 +193,7 @@
     _invocations = NmethodSweepFraction;
     _current     = CodeCache::first_nmethod();
     _traversals  += 1;
-    _total_time_this_sweep = 0;
+    _total_time_this_sweep = Tickspan();
 
     if (PrintMethodFlushing) {
       tty->print_cr("### Sweep: stack traversal %d", _traversals);
@@ -256,8 +257,7 @@
 }
 
 void NMethodSweeper::sweep_code_cache() {
-
-  jlong sweep_start_counter = os::elapsed_counter();
+  Ticks sweep_start_counter = Ticks::now();
 
   _flushed_count   = 0;
   _zombified_count = 0;
@@ -322,8 +322,8 @@
     }
   }
 
-  jlong sweep_end_counter = os::elapsed_counter();
-  jlong sweep_time = sweep_end_counter - sweep_start_counter;
+  const Ticks sweep_end_counter = Ticks::now();
+  const Tickspan sweep_time = sweep_end_counter - sweep_start_counter;
   _total_time_sweeping  += sweep_time;
   _total_time_this_sweep += sweep_time;
   _peak_sweep_fraction_time = MAX2(sweep_time, _peak_sweep_fraction_time);
@@ -344,7 +344,7 @@
 
 #ifdef ASSERT
   if(PrintMethodFlushing) {
-    tty->print_cr("### sweeper:      sweep time(%d): " INT64_FORMAT, _invocations, (jlong)sweep_time);
+    tty->print_cr("### sweeper:      sweep time(%d): " INT64_FORMAT, _invocations, (jlong)sweep_time.value());
   }
 #endif
 
@@ -529,7 +529,7 @@
     }
   }
 
-  jlong disconnect_start_counter = os::elapsed_counter();
+  Ticks disconnect_start_counter = Ticks::now();
 
   // Traverse the code cache trying to dump the oldest nmethods
   uint curr_max_comp_id = CompileBroker::get_compilation_id();
@@ -577,8 +577,8 @@
     CompileBroker::set_should_compile_new_jobs(CompileBroker::stop_compilation);
   }
 
-  jlong disconnect_end_counter = os::elapsed_counter();
-  jlong disconnect_time = disconnect_end_counter - disconnect_start_counter;
+  const Ticks disconnect_end_counter = Ticks::now();
+  const Tickspan disconnect_time = disconnect_end_counter - disconnect_start_counter;
   _total_disconnect_time += disconnect_time;
   _peak_disconnect_time = MAX2(disconnect_time, _peak_disconnect_time);
 
@@ -597,7 +597,7 @@
 #ifdef ASSERT
 
   if(PrintMethodFlushing && Verbose) {
-    tty->print_cr("### sweeper: unload time: " INT64_FORMAT, (jlong)disconnect_time);
+    tty->print_cr("### sweeper: unload time: " INT64_FORMAT, (jlong)disconnect_time.value());
   }
 #endif
 }
--- ./hotspot/src/share/vm/runtime/sweeper.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/runtime/sweeper.hpp	Wed May 07 19:26:16 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,6 +25,7 @@
 #ifndef SHARE_VM_RUNTIME_SWEEPER_HPP
 #define SHARE_VM_RUNTIME_SWEEPER_HPP
 
+#include "utilities/ticks.hpp"
 // An NmethodSweeper is an incremental cleaner for:
 //    - cleanup inline caches
 //    - reclamation of unreferences zombie nmethods
@@ -56,12 +57,12 @@
   // Stat counters
   static int       _number_of_flushes;            // Total of full traversals caused by full cache
   static int       _total_nof_methods_reclaimed;  // Accumulated nof methods flushed
-  static jlong     _total_time_sweeping;          // Accumulated time sweeping
-  static jlong     _total_time_this_sweep;        // Total time this sweep
-  static jlong     _peak_sweep_time;              // Peak time for a full sweep
-  static jlong     _peak_sweep_fraction_time;     // Peak time sweeping one fraction
-  static jlong     _total_disconnect_time;        // Total time cleaning code mem
-  static jlong     _peak_disconnect_time;         // Peak time cleaning code mem
+  static Tickspan     _total_time_sweeping;          // Accumulated time sweeping
+  static Tickspan     _total_time_this_sweep;        // Total time this sweep
+  static Tickspan     _peak_sweep_time;              // Peak time for a full sweep
+  static Tickspan     _peak_sweep_fraction_time;     // Peak time sweeping one fraction
+  static Tickspan     _total_disconnect_time;        // Total time cleaning code mem
+  static Tickspan     _peak_disconnect_time;         // Peak time cleaning code mem
 
   static void process_nmethod(nmethod *nm);
 
@@ -71,13 +72,14 @@
   static long traversal_count()              { return _traversals; }
   static int  number_of_flushes()            { return _number_of_flushes; }
   static int  total_nof_methods_reclaimed()  { return _total_nof_methods_reclaimed; }
-  static jlong total_time_sweeping()         { return _total_time_sweeping; }
-  static jlong peak_sweep_time()             { return _peak_sweep_time; }
-  static jlong peak_sweep_fraction_time()    { return _peak_sweep_fraction_time; }
-  static jlong total_disconnect_time()       { return _total_disconnect_time; }
-  static jlong peak_disconnect_time()        { return _peak_disconnect_time; }
+  static const Tickspan total_time_sweeping()         { return _total_time_sweeping; }
+  static const Tickspan peak_sweep_time()             { return _peak_sweep_time; }
+  static const Tickspan peak_sweep_fraction_time()    { return _peak_sweep_fraction_time; }
+  static const Tickspan total_disconnect_time()       { return _total_disconnect_time; }
+  static const Tickspan peak_disconnect_time()        { return _peak_disconnect_time; }
 
 #ifdef ASSERT
+  static bool is_sweeping(nmethod* which) { return _current == which; }
   // Keep track of sweeper activity in the ring buffer
   static void record_sweep(nmethod* nm, int line);
   static void report_events(int id, address entry);
--- ./hotspot/src/share/vm/runtime/thread.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/runtime/thread.cpp	Wed May 07 19:26:16 2014 -0700
@@ -3416,9 +3416,10 @@
   }
 
   assert (Universe::is_fully_initialized(), "not initialized");
-  if (VerifyBeforeGC && VerifyGCStartAt == 0) {
-    Universe::heap()->prepare_for_verify();
-    Universe::verify();   // make sure we're starting with a clean slate
+  if (VerifyDuringStartup) {
+    // Make sure we're starting with a clean slate.
+    VM_Verify verify_op;
+    VMThread::execute(&verify_op);
   }
 
   EXCEPTION_MARK;
@@ -3504,11 +3505,12 @@
       java_lang_Thread::set_thread_status(thread_object,
                                           java_lang_Thread::RUNNABLE);
 
-      // The VM preresolve methods to these classes. Make sure that get initialized
+      // The VM creates & returns objects of this class. Make sure it's initialized.
+      initialize_class(vmSymbols::java_lang_Class(), CHECK_0);
+
+      // The VM preresolves methods to these classes. Make sure that they get initialized
       initialize_class(vmSymbols::java_lang_reflect_Method(), CHECK_0);
       initialize_class(vmSymbols::java_lang_ref_Finalizer(),  CHECK_0);
-      // The VM creates & returns objects of this class. Make sure it's initialized.
-      initialize_class(vmSymbols::java_lang_Class(), CHECK_0);
       call_initializeSystemClass(CHECK_0);
 
       // get the Java runtime name after java.lang.System is initialized
--- ./hotspot/src/share/vm/runtime/virtualspace.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/runtime/virtualspace.cpp	Wed May 07 19:26:16 2014 -0700
@@ -42,8 +42,19 @@
 
 
 // ReservedSpace
+
+// Dummy constructor
+ReservedSpace::ReservedSpace() : _base(NULL), _size(0), _noaccess_prefix(0),
+    _alignment(0), _special(false), _executable(false) {
+}
+
 ReservedSpace::ReservedSpace(size_t size) {
-  initialize(size, 0, false, NULL, 0, false);
+  size_t page_size = os::page_size_for_region(size, size, 1);
+  bool large_pages = page_size != (size_t)os::vm_page_size();
+  // Don't force the alignment to be large page aligned,
+  // since that will waste memory.
+  size_t alignment = os::vm_allocation_granularity();
+  initialize(size, alignment, large_pages, NULL, 0, false);
 }
 
 ReservedSpace::ReservedSpace(size_t size, size_t alignment,
@@ -323,16 +334,18 @@
 
   if (special) {
 
-    base = os::reserve_memory_special(size, requested_address, executable);
+    base = os::reserve_memory_special(size, alignment, requested_address, executable);
 
     if (base != NULL) {
       if (failed_to_reserve_as_requested(base, requested_address, size, true)) {
         // OS ignored requested address. Try different address.
         return;
       }
-      // Check alignment constraints
+      // Check alignment constraints.
       assert((uintptr_t) base % alignment == 0,
-             "Large pages returned a non-aligned address");
+             err_msg("Large pages returned a non-aligned address, base: "
+                 PTR_FORMAT " alignment: " PTR_FORMAT,
+                 base, (void*)(uintptr_t)alignment));
       _special = true;
     } else {
       // failed; try to reserve regular memory below
@@ -928,4 +941,188 @@
   tty->print_cr(" - [low_b, high_b]: [" INTPTR_FORMAT ", " INTPTR_FORMAT "]",  low_boundary(), high_boundary());
 }
 
+
+/////////////// Unit tests ///////////////
+
+#ifndef PRODUCT
+
+#define test_log(...) \
+  do {\
+    if (VerboseInternalVMTests) { \
+      tty->print_cr(__VA_ARGS__); \
+      tty->flush(); \
+    }\
+  } while (false)
+
+class TestReservedSpace : AllStatic {
+ public:
+  static void small_page_write(void* addr, size_t size) {
+    size_t page_size = os::vm_page_size();
+
+    char* end = (char*)addr + size;
+    for (char* p = (char*)addr; p < end; p += page_size) {
+      *p = 1;
+    }
+  }
+
+  static void release_memory_for_test(ReservedSpace rs) {
+    if (rs.special()) {
+      guarantee(os::release_memory_special(rs.base(), rs.size()), "Shouldn't fail");
+    } else {
+      guarantee(os::release_memory(rs.base(), rs.size()), "Shouldn't fail");
+    }
+  }
+
+  static void test_reserved_space1(size_t size, size_t alignment) {
+    test_log("test_reserved_space1(%p)", (void*) (uintptr_t) size);
+
+    assert(is_size_aligned(size, alignment), "Incorrect input parameters");
+
+    ReservedSpace rs(size,          // size
+                     alignment,     // alignment
+                     UseLargePages, // large
+                     NULL,          // requested_address
+                     0);            // noacces_prefix
+
+    test_log(" rs.special() == %d", rs.special());
+
+    assert(rs.base() != NULL, "Must be");
+    assert(rs.size() == size, "Must be");
+
+    assert(is_ptr_aligned(rs.base(), alignment), "aligned sizes should always give aligned addresses");
+    assert(is_size_aligned(rs.size(), alignment), "aligned sizes should always give aligned addresses");
+
+    if (rs.special()) {
+      small_page_write(rs.base(), size);
+    }
+
+    release_memory_for_test(rs);
+  }
+
+  static void test_reserved_space2(size_t size) {
+    test_log("test_reserved_space2(%p)", (void*)(uintptr_t)size);
+
+    assert(is_size_aligned(size, os::vm_allocation_granularity()), "Must be at least AG aligned");
+
+    ReservedSpace rs(size);
+
+    test_log(" rs.special() == %d", rs.special());
+
+    assert(rs.base() != NULL, "Must be");
+    assert(rs.size() == size, "Must be");
+
+    if (rs.special()) {
+      small_page_write(rs.base(), size);
+    }
+
+    release_memory_for_test(rs);
+  }
+
+  static void test_reserved_space3(size_t size, size_t alignment, bool maybe_large) {
+    test_log("test_reserved_space3(%p, %p, %d)",
+        (void*)(uintptr_t)size, (void*)(uintptr_t)alignment, maybe_large);
+
+    assert(is_size_aligned(size, os::vm_allocation_granularity()), "Must be at least AG aligned");
+    assert(is_size_aligned(size, alignment), "Must be at least aligned against alignment");
+
+    bool large = maybe_large && UseLargePages && size >= os::large_page_size();
+
+    ReservedSpace rs(size, alignment, large, false);
+
+    test_log(" rs.special() == %d", rs.special());
+
+    assert(rs.base() != NULL, "Must be");
+    assert(rs.size() == size, "Must be");
+
+    if (rs.special()) {
+      small_page_write(rs.base(), size);
+    }
+
+    release_memory_for_test(rs);
+  }
+
+
+  static void test_reserved_space1() {
+    size_t size = 2 * 1024 * 1024;
+    size_t ag   = os::vm_allocation_granularity();
+
+    test_reserved_space1(size,      ag);
+    test_reserved_space1(size * 2,  ag);
+    test_reserved_space1(size * 10, ag);
+  }
+
+  static void test_reserved_space2() {
+    size_t size = 2 * 1024 * 1024;
+    size_t ag = os::vm_allocation_granularity();
+
+    test_reserved_space2(size * 1);
+    test_reserved_space2(size * 2);
+    test_reserved_space2(size * 10);
+    test_reserved_space2(ag);
+    test_reserved_space2(size - ag);
+    test_reserved_space2(size);
+    test_reserved_space2(size + ag);
+    test_reserved_space2(size * 2);
+    test_reserved_space2(size * 2 - ag);
+    test_reserved_space2(size * 2 + ag);
+    test_reserved_space2(size * 3);
+    test_reserved_space2(size * 3 - ag);
+    test_reserved_space2(size * 3 + ag);
+    test_reserved_space2(size * 10);
+    test_reserved_space2(size * 10 + size / 2);
+  }
+
+  static void test_reserved_space3() {
+    size_t ag = os::vm_allocation_granularity();
+
+    test_reserved_space3(ag,      ag    , false);
+    test_reserved_space3(ag * 2,  ag    , false);
+    test_reserved_space3(ag * 3,  ag    , false);
+    test_reserved_space3(ag * 2,  ag * 2, false);
+    test_reserved_space3(ag * 4,  ag * 2, false);
+    test_reserved_space3(ag * 8,  ag * 2, false);
+    test_reserved_space3(ag * 4,  ag * 4, false);
+    test_reserved_space3(ag * 8,  ag * 4, false);
+    test_reserved_space3(ag * 16, ag * 4, false);
+
+    if (UseLargePages) {
+      size_t lp = os::large_page_size();
+
+      // Without large pages
+      test_reserved_space3(lp,     ag * 4, false);
+      test_reserved_space3(lp * 2, ag * 4, false);
+      test_reserved_space3(lp * 4, ag * 4, false);
+      test_reserved_space3(lp,     lp    , false);
+      test_reserved_space3(lp * 2, lp    , false);
+      test_reserved_space3(lp * 3, lp    , false);
+      test_reserved_space3(lp * 2, lp * 2, false);
+      test_reserved_space3(lp * 4, lp * 2, false);
+      test_reserved_space3(lp * 8, lp * 2, false);
+
+      // With large pages
+      test_reserved_space3(lp, ag * 4    , true);
+      test_reserved_space3(lp * 2, ag * 4, true);
+      test_reserved_space3(lp * 4, ag * 4, true);
+      test_reserved_space3(lp, lp        , true);
+      test_reserved_space3(lp * 2, lp    , true);
+      test_reserved_space3(lp * 3, lp    , true);
+      test_reserved_space3(lp * 2, lp * 2, true);
+      test_reserved_space3(lp * 4, lp * 2, true);
+      test_reserved_space3(lp * 8, lp * 2, true);
+    }
+  }
+
+  static void test_reserved_space() {
+    test_reserved_space1();
+    test_reserved_space2();
+    test_reserved_space3();
+  }
+};
+
+void TestReservedSpace_test() {
+  TestReservedSpace::test_reserved_space();
+}
+
+#endif // PRODUCT
+
 #endif
--- ./hotspot/src/share/vm/runtime/virtualspace.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/runtime/virtualspace.hpp	Wed May 07 19:26:16 2014 -0700
@@ -90,6 +90,7 @@
 
  public:
   // Constructor
+  ReservedSpace();
   ReservedSpace(size_t size);
   ReservedSpace(size_t size, size_t alignment, bool large,
                 char* requested_address = NULL,
--- ./hotspot/src/share/vm/runtime/vmThread.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/runtime/vmThread.cpp	Wed May 07 19:26:16 2014 -0700
@@ -305,7 +305,7 @@
     os::check_heap();
     // Silent verification so as not to pollute normal output,
     // unless we really asked for it.
-    Universe::verify(!(PrintGCDetails || Verbose));
+    Universe::verify(!(PrintGCDetails || Verbose) || VerifySilently);
   }
 
   CompileBroker::set_should_block();
--- ./hotspot/src/share/vm/runtime/vm_operations.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/runtime/vm_operations.cpp	Wed May 07 19:26:16 2014 -0700
@@ -189,7 +189,8 @@
 }
 
 void VM_Verify::doit() {
-  Universe::verify();
+  Universe::heap()->prepare_for_verify();
+  Universe::verify(_silent);
 }
 
 bool VM_PrintThreads::doit_prologue() {
--- ./hotspot/src/share/vm/runtime/vm_operations.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/runtime/vm_operations.hpp	Wed May 07 19:26:16 2014 -0700
@@ -303,9 +303,9 @@
 
 class VM_Verify: public VM_Operation {
  private:
-  KlassHandle _dependee;
+  bool _silent;
  public:
-  VM_Verify() {}
+  VM_Verify(bool silent = VerifySilently) : _silent(silent) {}
   VMOp_Type type() const { return VMOp_Verify; }
   void doit();
 };
--- ./hotspot/src/share/vm/services/attachListener.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/services/attachListener.cpp	Wed May 07 19:26:16 2014 -0700
@@ -282,6 +282,20 @@
       return JNI_ERR;
     }
   }
+
+  if (strncmp(name, "MaxHeapFreeRatio", 17) == 0) {
+    FormatBuffer<80> err_msg("");
+    if (!Arguments::verify_MaxHeapFreeRatio(err_msg, value)) {
+      out->print_cr(err_msg.buffer());
+      return JNI_ERR;
+    }
+  } else if (strncmp(name, "MinHeapFreeRatio", 17) == 0) {
+    FormatBuffer<80> err_msg("");
+    if (!Arguments::verify_MinHeapFreeRatio(err_msg, value)) {
+      out->print_cr(err_msg.buffer());
+      return JNI_ERR;
+    }
+  }
   bool res = CommandLineFlags::uintxAtPut((char*)name, &value, ATTACH_ON_DEMAND);
   if (! res) {
     out->print_cr("setting flag %s failed", name);
@@ -470,7 +484,17 @@
                        vmSymbols::threadgroup_string_void_signature(),
                        thread_group,
                        string,
-                       CHECK);
+                       THREAD);
+
+  if (HAS_PENDING_EXCEPTION) {
+    tty->print_cr("Exception in VM (AttachListener::init) : ");
+    java_lang_Throwable::print(PENDING_EXCEPTION, tty);
+    tty->cr();
+
+    CLEAR_PENDING_EXCEPTION;
+
+    return;
+  }
 
   KlassHandle group(THREAD, SystemDictionary::ThreadGroup_klass());
   JavaCalls::call_special(&result,
@@ -479,7 +503,17 @@
                         vmSymbols::add_method_name(),
                         vmSymbols::thread_void_signature(),
                         thread_oop,             // ARG 1
-                        CHECK);
+                        THREAD);
+
+  if (HAS_PENDING_EXCEPTION) {
+    tty->print_cr("Exception in VM (AttachListener::init) : ");
+    java_lang_Throwable::print(PENDING_EXCEPTION, tty);
+    tty->cr();
+
+    CLEAR_PENDING_EXCEPTION;
+
+    return;
+  }
 
   { MutexLocker mu(Threads_lock);
     JavaThread* listener_thread = new JavaThread(&attach_listener_thread_entry);
--- ./hotspot/src/share/vm/services/management.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/services/management.cpp	Wed May 07 19:26:16 2014 -0700
@@ -851,8 +851,6 @@
       total_used += u.used();
       total_committed += u.committed();
 
-      // if any one of the memory pool has undefined init_size or max_size,
-      // set it to -1
       if (u.init_size() == (size_t)-1) {
         has_undefined_init_size = true;
       }
@@ -869,6 +867,15 @@
     }
   }
 
+  // if any one of the memory pool has undefined init_size or max_size,
+  // set it to -1
+  if (has_undefined_init_size) {
+    total_init = (size_t)-1;
+  }
+  if (has_undefined_max_size) {
+    total_max = (size_t)-1;
+  }
+
   // In our current implementation, we make sure that all non-heap
   // pools have defined init and max sizes. Heap pools do not matter,
   // as we never use total_init and total_max for them.
@@ -1793,6 +1800,18 @@
     succeed = CommandLineFlags::intxAtPut(name, &ivalue, MANAGEMENT);
   } else if (flag->is_uintx()) {
     uintx uvalue = (uintx)new_value.j;
+
+    if (strncmp(name, "MaxHeapFreeRatio", 17) == 0) {
+      FormatBuffer<80> err_msg("");
+      if (!Arguments::verify_MaxHeapFreeRatio(err_msg, uvalue)) {
+        THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), err_msg.buffer());
+      }
+    } else if (strncmp(name, "MinHeapFreeRatio", 17) == 0) {
+      FormatBuffer<80> err_msg("");
+      if (!Arguments::verify_MinHeapFreeRatio(err_msg, uvalue)) {
+        THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), err_msg.buffer());
+      }
+    }
     succeed = CommandLineFlags::uintxAtPut(name, &uvalue, MANAGEMENT);
   } else if (flag->is_uint64_t()) {
     uint64_t uvalue = (uint64_t)new_value.j;
--- ./hotspot/src/share/vm/services/memTracker.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/services/memTracker.hpp	Wed May 07 19:26:16 2014 -0700
@@ -302,6 +302,13 @@
     }
   }
 
+  static inline void record_virtual_memory_release(address addr, size_t size,
+      Thread* thread = NULL) {
+    if (is_on()) {
+      Tracker tkr(Tracker::Release, thread);
+      tkr.record(addr, size);
+    }
+  }
 
   // record memory type on virtual memory base address
   static inline void record_virtual_memory_type(address base, MEMFLAGS flags,
--- ./hotspot/src/share/vm/trace/noTraceBackend.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/trace/noTraceBackend.hpp	Wed May 07 19:26:16 2014 -0700
@@ -25,9 +25,7 @@
 #define SHARE_VM_TRACE_NOTRACEBACKEND_HPP
 
 #include "prims/jni.h"
-
-typedef jlong TracingTime;
-typedef jlong RelativeTracingTime;
+#include "trace/traceTime.hpp"
 
 class NoTraceBackend {
 public:
@@ -44,5 +42,3 @@
 typedef NoTraceBackend Tracing;
 
 #endif
-
-
--- ./hotspot/src/share/vm/trace/trace.xml	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/trace/trace.xml	Wed May 07 19:26:16 2014 -0700
@@ -169,8 +169,8 @@
       <value type="UINT" field="gcId"  label="GC ID" relation="GC_ID" />
       <value type="GCNAME" field="name" label="Name" description="The name of the Garbage Collector" />
       <value type="GCCAUSE" field="cause" label="Cause" description="The reason for triggering this Garbage Collection" />
-      <value type="RELATIVE_TICKS" field="sumOfPauses" label="Sum of Pauses" description="Sum of all the times in which Java execution was paused during the garbage collection" />
-      <value type="RELATIVE_TICKS" field="longestPause" label="Longest Pause" description="Longest individual pause during the garbage collection" />
+      <value type="TICKSPAN" field="sumOfPauses" label="Sum of Pauses" description="Sum of all the times in which Java execution was paused during the garbage collection" />
+      <value type="TICKSPAN" field="longestPause" label="Longest Pause" description="Longest individual pause during the garbage collection" />
     </event>
 
     <event id="GCParallelOld" path="vm/gc/collector/parold_garbage_collection" label="Parallel Old Garbage Collection"
--- ./hotspot/src/share/vm/trace/traceBackend.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/trace/traceBackend.hpp	Wed May 07 19:26:16 2014 -0700
@@ -26,10 +26,11 @@
 
 #if INCLUDE_TRACE
 
+#include "runtime/globals.hpp"
+#include "runtime/os.hpp"
 #include "trace/traceTime.hpp"
 #include "tracefiles/traceEventIds.hpp"
-#include "runtime/globals.hpp"
-#include "runtime/os.hpp"
+
 
 class TraceBackend {
 public:
@@ -44,10 +45,6 @@
     return os::elapsed_counter();
   }
 
-  static TracingTime time_adjustment(jlong time) {
-    return time;
-  }
-
   static void on_unloading_classes(BoolObjectClosure* is_alive, int no_of_classes_unloading) {
   }
 };
--- ./hotspot/src/share/vm/trace/traceEvent.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/trace/traceEvent.hpp	Wed May 07 19:26:16 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -36,13 +36,10 @@
 #include "trace/tracing.hpp"
 #include "tracefiles/traceEventIds.hpp"
 #include "tracefiles/traceTypes.hpp"
+#include "utilities/ticks.hpp"
 
 template<typename T>
 class TraceEvent : public StackObj {
- protected:
-  jlong _startTime;
-  jlong _endTime;
-
  private:
   bool _started;
 #ifdef ASSERT
@@ -52,6 +49,18 @@
   bool _ignore_check;
 #endif
 
+ protected:
+  jlong _startTime;
+  jlong _endTime;
+
+  void set_starttime(const TracingTime& time) {
+    _startTime = time;
+  }
+
+  void set_endtime(const TracingTime& time) {
+    _endTime = time;
+  }
+
  public:
   TraceEvent(EventStartTime timing=TIMED) :
     _startTime(0),
@@ -90,7 +99,7 @@
         return;
     }
     if (_endTime == 0) {
-      static_cast<T *>(this)->set_endtime(Tracing::time());
+      static_cast<T*>(this)->set_endtime(Tracing::time());
     }
     if (static_cast<T*>(this)->should_write()) {
       static_cast<T*>(this)->writeEvent();
@@ -98,12 +107,12 @@
     set_commited();
   }
 
-  void set_starttime(jlong time) {
-    _startTime = time;
+  void set_starttime(const Ticks& time) {
+    _startTime = time.value();
   }
 
-  void set_endtime(jlong time) {
-    _endTime = time;
+  void set_endtime(const Ticks& time) {
+    _endTime = time.value();
   }
 
   TraceEventId id() const {
--- ./hotspot/src/share/vm/trace/traceEventClasses.xsl	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/trace/traceEventClasses.xsl	Wed May 07 19:26:16 2014 -0700
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
- Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 
  This code is free software; you can redistribute it and/or modify it
@@ -23,8 +23,8 @@
 -->
 
 <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
+<xsl:import href="xsl_util.xsl"/>
 <xsl:output method="text" indent="no" omit-xml-declaration="yes"/>
-<xsl:import href="xsl_util.xsl"/>
 
 <xsl:template match="/">
   <xsl:call-template name="file-header"/>
@@ -40,6 +40,7 @@
 #include "runtime/handles.inline.hpp"
 #include "tracefiles/traceTypes.hpp"
 #include "trace/traceEvent.hpp"
+#include "utilities/ticks.hpp"
 
 #if INCLUDE_TRACE
 
@@ -54,8 +55,8 @@
 class TraceEvent {
 public:
   TraceEvent() {}
-  void set_starttime(jlong time) const {}
-  void set_endtime(jlong time) const {}
+  void set_starttime(const Ticks&amp; time) {}
+  void set_endtime(const Ticks&amp; time) {}
   bool should_commit() const { return false; }
   void commit() const {}
 };
@@ -174,20 +175,21 @@
 
 <xsl:template match="value[@type='TICKS']" mode="write-setters">
 #if INCLUDE_TRACE
-  <xsl:value-of select="concat('void set_', @field, '(jlong time) { _', @field, ' = time; }')"/>
+<xsl:value-of select="concat('  void set_', @field, '(const Ticks&amp; time) { _', @field, ' = time; }')"/>
 #else
-  <xsl:value-of select="concat('void set_', @field, '(jlong ignore) {}')"/>
+<xsl:value-of select="concat('  void set_', @field, '(const Ticks&amp; ignore) {}')"/>
 #endif
 </xsl:template>
 
-<xsl:template match="value[@type='RELATIVE_TICKS']" mode="write-setters">
+<xsl:template match="value[@type='TICKSPAN']" mode="write-setters">
 #if INCLUDE_TRACE
-  <xsl:value-of select="concat('void set_', @field, '(jlong time) { _', @field, ' = time; }')"/>
+  <xsl:value-of select="concat('  void set_', @field, '(const Tickspan&amp; time) { _', @field, ' = time; }')"/>
 #else
-  <xsl:value-of select="concat('void set_', @field, '(jlong ignore) {}')"/>
+  <xsl:value-of select="concat('  void set_', @field, '(const Tickspan&amp; ignore) {}')"/>
 #endif
 </xsl:template>
 
+
 <xsl:template match="value" mode="write-fields">
   <xsl:variable name="type" select="@type"/>
   <xsl:variable name="wt" select="//primary_type[@symbol=$type]/@type"/>
@@ -227,7 +229,17 @@
 <xsl:template match="value" mode="write-data">
   <xsl:variable name="type" select="@type"/>
   <xsl:variable name="wt" select="//primary_type[@symbol=$type]/@writetype"/>
-  <xsl:value-of select="concat('    ts.print_val(&quot;', @label, '&quot;, _', @field, ');')"/>
+  <xsl:choose>
+    <xsl:when test="@type='TICKSPAN'">
+      <xsl:value-of select="concat('    ts.print_val(&quot;', @label, '&quot;, _', @field, '.value());')"/>
+    </xsl:when>
+    <xsl:when test="@type='TICKS'">
+      <xsl:value-of select="concat('    ts.print_val(&quot;', @label, '&quot;, _', @field, '.value());')"/>
+    </xsl:when>
+    <xsl:otherwise>
+      <xsl:value-of select="concat('    ts.print_val(&quot;', @label, '&quot;, _', @field, ');')"/>
+    </xsl:otherwise>
+  </xsl:choose>
   <xsl:if test="position() != last()">
     <xsl:text>
     ts.print(", ");
--- ./hotspot/src/share/vm/trace/traceEventIds.xsl	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/trace/traceEventIds.xsl	Wed May 07 19:26:16 2014 -0700
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
- Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 
  This code is free software; you can redistribute it and/or modify it
@@ -23,8 +23,8 @@
 -->
 
 <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
+<xsl:import href="xsl_util.xsl"/>
 <xsl:output method="text" indent="no" omit-xml-declaration="yes"/>
-<xsl:import href="xsl_util.xsl"/>
 
 <xsl:template match="/">
   <xsl:call-template name="file-header"/>
--- ./hotspot/src/share/vm/trace/traceMacros.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/trace/traceMacros.hpp	Wed May 07 19:26:16 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./hotspot/src/share/vm/trace/traceTime.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/trace/traceTime.hpp	Wed May 07 19:26:16 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -28,6 +28,5 @@
 #include "prims/jni.h"
 
 typedef jlong TracingTime;
-typedef jlong RelativeTracingTime;
 
-#endif
+#endif // SHARE_VM_TRACE_TRACETIME_HPP
--- ./hotspot/src/share/vm/trace/traceTypes.xsl	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/trace/traceTypes.xsl	Wed May 07 19:26:16 2014 -0700
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
- Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 
  This code is free software; you can redistribute it and/or modify it
@@ -23,8 +23,8 @@
 -->
 
 <xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
+<xsl:import href="xsl_util.xsl"/>
 <xsl:output method="text" indent="no" omit-xml-declaration="yes"/>
-<xsl:import href="xsl_util.xsl"/>
 
 <xsl:template match="/">
   <xsl:call-template name="file-header"/>
@@ -32,11 +32,13 @@
 #ifndef TRACEFILES_JFRTYPES_HPP
 #define TRACEFILES_JFRTYPES_HPP
 
+
+#include "oops/klassOop.hpp"
+#include "oops/methodOop.hpp"
+#include "oops/symbol.hpp"
 #include "trace/traceDataTypes.hpp"
 #include "utilities/globalDefinitions.hpp"
-#include "oops/symbol.hpp"
-#include "oops/klassOop.hpp"
-#include "oops/methodOop.hpp"
+#include "utilities/ticks.hpp"
 
 enum JVMContentType {
   _not_a_content_type = (JVM_CONTENT_TYPES_START - 1),
--- ./hotspot/src/share/vm/trace/tracetypes.xml	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/trace/tracetypes.xml	Wed May 07 19:26:16 2014 -0700
@@ -249,13 +249,13 @@
     <primary_type symbol="NANOS" datatype="LONG" contenttype="NANOS"
                   type="s8" sizeop="sizeof(s8)"/>
 
-    <!-- 64-bit signed integer, SEMANTIC value ABSOLUTE TICKS -->
+    <!-- 64-bit signed integer, SEMANTIC value TICKS -->
     <primary_type symbol="TICKS" datatype="LONG" contenttype="TICKS"
-                  type="s8" sizeop="sizeof(s8)"/>
+                  type="Ticks" sizeop="sizeof(s8)"/>
 
-    <!-- 64-bit signed integer, SEMANTIC value RELATIVE TICKS -->
-    <primary_type symbol="RELATIVE_TICKS" datatype="LONG" contenttype="TICKS"
-                  type="s8" sizeop="sizeof(s8)"/>
+    <!-- 64-bit signed integer, SEMANTIC value TICKS duration -->
+    <primary_type symbol="TICKSPAN" datatype="LONG" contenttype="TICKS"
+                  type="Tickspan" sizeop="sizeof(s8)"/>
 
     <!-- 64-bit unsigned integer, SEMANTIC value ADDRESS (mem loc) -->
     <primary_type symbol="ADDRESS" datatype="U8" contenttype="ADDRESS"
--- ./hotspot/src/share/vm/trace/tracing.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/trace/tracing.hpp	Wed May 07 19:26:16 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./hotspot/src/share/vm/utilities/globalDefinitions.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/utilities/globalDefinitions.hpp	Wed May 07 19:26:16 2014 -0700
@@ -373,6 +373,14 @@
 
 #define align_size_up_(size, alignment) (((size) + ((alignment) - 1)) & ~((alignment) - 1))
 
+inline bool is_size_aligned(size_t size, size_t alignment) {
+  return align_size_up_(size, alignment) == size;
+}
+
+inline bool is_ptr_aligned(void* ptr, size_t alignment) {
+  return align_size_up_((intptr_t)ptr, (intptr_t)alignment) == (intptr_t)ptr;
+}
+
 inline intptr_t align_size_up(intptr_t size, intptr_t alignment) {
   return align_size_up_(size, alignment);
 }
@@ -383,6 +391,14 @@
   return align_size_down_(size, alignment);
 }
 
+inline void* align_ptr_up(void* ptr, size_t alignment) {
+  return (void*)align_size_up((intptr_t)ptr, (intptr_t)alignment);
+}
+
+inline void* align_ptr_down(void* ptr, size_t alignment) {
+  return (void*)align_size_down((intptr_t)ptr, (intptr_t)alignment);
+}
+
 // Align objects by rounding up their size, in HeapWord units.
 
 #define align_object_size_(size) align_size_up_(size, MinObjAlignment)
--- ./hotspot/src/share/vm/utilities/growableArray.hpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/utilities/growableArray.hpp	Wed May 07 19:26:16 2014 -0700
@@ -194,6 +194,7 @@
 
   void  clear()                 { _len = 0; }
   int   length() const          { return _len; }
+  int   max_length() const      { return _max; }
   void  trunc_to(int l)         { assert(l <= _len,"cannot increase length"); _len = l; }
   bool  is_empty() const        { return _len == 0; }
   bool  is_nonempty() const     { return _len != 0; }
@@ -281,6 +282,13 @@
     return -1;
   }
 
+  int  find_from_end(const E& elem) const {
+    for (int i = _len-1; i >= 0; i--) {
+      if (_data[i] == elem) return i;
+    }
+    return -1;
+  }
+
   int  find(void* token, bool f(void*, E)) const {
     for (int i = 0; i < _len; i++) {
       if (f(token, _data[i])) return i;
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/src/share/vm/utilities/ticks.cpp	Wed May 07 19:26:16 2014 -0700
@@ -0,0 +1,68 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#include "precompiled.hpp"
+#include "runtime/os.hpp"
+#include "utilities/ticks.inline.hpp"
+
+#ifdef ASSERT
+ const jlong Ticks::invalid_time_stamp = -2; // 0xFFFF FFFF`FFFF FFFE
+#endif
+
+void Ticks::stamp() {
+  _stamp_ticks = os::elapsed_counter();
+}
+
+const Ticks Ticks::now() {
+  Ticks t;
+  t.stamp();
+  return t;
+}
+
+Tickspan::Tickspan(const Ticks& end, const Ticks& start) {
+  assert(end.value() != Ticks::invalid_time_stamp, "end is unstamped!");
+  assert(start.value() != Ticks::invalid_time_stamp, "start is unstamped!");
+
+  assert(end >= start, "negative time!");
+
+  _span_ticks = end.value() - start.value();
+}
+
+template <typename ReturnType>
+static ReturnType time_conversion(const Tickspan& span, TicksToTimeHelper::Unit unit) {
+  assert(TicksToTimeHelper::SECONDS == unit ||
+         TicksToTimeHelper::MILLISECONDS == unit, "invalid unit!");
+
+  ReturnType frequency_per_unit = (ReturnType)os::elapsed_frequency() / (ReturnType)unit;
+
+  return (ReturnType) ((ReturnType)span.value() / frequency_per_unit);
+}
+
+double TicksToTimeHelper::seconds(const Tickspan& span) {
+  return time_conversion<double>(span, SECONDS);
+}
+
+jlong TicksToTimeHelper::milliseconds(const Tickspan& span) {
+  return time_conversion<jlong>(span, MILLISECONDS);
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/src/share/vm/utilities/ticks.hpp	Wed May 07 19:26:16 2014 -0700
@@ -0,0 +1,111 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef SHARE_VM_UTILITIES_TICKS_HPP
+#define SHARE_VM_UTILITIES_TICKS_HPP
+
+#include "memory/allocation.hpp"
+#include "utilities/globalDefinitions.hpp"
+
+class Ticks;
+
+class Tickspan VALUE_OBJ_CLASS_SPEC {
+  friend class Ticks;
+  friend Tickspan operator-(const Ticks& end, const Ticks& start);
+
+ private:
+  jlong _span_ticks;
+
+  Tickspan(const Ticks& end, const Ticks& start);
+
+ public:
+  Tickspan() : _span_ticks(0) {}
+
+  Tickspan& operator+=(const Tickspan& rhs) {
+    _span_ticks += rhs._span_ticks;
+    return *this;
+  }
+
+  jlong value() const {
+    return _span_ticks;
+  }
+
+};
+
+class Ticks VALUE_OBJ_CLASS_SPEC {
+ private:
+  jlong _stamp_ticks;
+
+ public:
+  Ticks() : _stamp_ticks(0) {
+    assert((_stamp_ticks = invalid_time_stamp) == invalid_time_stamp,
+      "initial unstamped time value assignment");
+  }
+
+  Ticks& operator+=(const Tickspan& span) {
+    _stamp_ticks += span.value();
+    return *this;
+  }
+
+  Ticks& operator-=(const Tickspan& span) {
+    _stamp_ticks -= span.value();
+    return *this;
+  }
+
+  void stamp();
+
+  jlong value() const {
+    return _stamp_ticks;
+  }
+
+  static const Ticks now();
+
+#ifdef ASSERT
+  static const jlong invalid_time_stamp;
+#endif
+
+#ifndef PRODUCT
+  // only for internal use by GC VM tests
+  friend class TimePartitionPhasesIteratorTest;
+  friend class GCTimerTest;
+
+ private:
+  // implicit type conversion
+  Ticks(int ticks) : _stamp_ticks(ticks) {}
+
+#endif // !PRODUCT
+
+};
+
+class TicksToTimeHelper : public AllStatic {
+ public:
+  enum Unit {
+    SECONDS = 1,
+    MILLISECONDS = 1000
+  };
+  static double seconds(const Tickspan& span);
+  static jlong milliseconds(const Tickspan& span);
+};
+
+#endif // SHARE_VM_UTILITIES_TICKS_HPP
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/src/share/vm/utilities/ticks.inline.hpp	Wed May 07 19:26:16 2014 -0700
@@ -0,0 +1,97 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+#ifndef SHARE_VM_UTILITIES_TICKS_INLINE_HPP
+#define SHARE_VM_UTILITIES_TICKS_INLINE_HPP
+
+#include "utilities/ticks.hpp"
+
+inline Tickspan operator+(Tickspan lhs, const Tickspan& rhs) {
+  lhs += rhs;
+  return lhs;
+}
+
+inline bool operator==(const Tickspan& lhs, const Tickspan& rhs) {
+  return lhs.value() == rhs.value();
+}
+
+inline bool operator!=(const Tickspan& lhs, const Tickspan& rhs) {
+  return !operator==(lhs,rhs);
+}
+
+inline bool operator<(const Tickspan& lhs, const Tickspan& rhs) {
+  return lhs.value() < rhs.value();
+}
+
+inline bool operator>(const Tickspan& lhs, const Tickspan& rhs) {
+  return operator<(rhs,lhs);
+}
+
+inline bool operator<=(const Tickspan& lhs, const Tickspan& rhs) {
+  return !operator>(lhs,rhs);
+}
+
+inline bool operator>=(const Tickspan& lhs, const Tickspan& rhs) {
+  return !operator<(lhs,rhs);
+}
+
+inline Ticks operator+(Ticks lhs, const Tickspan& span) {
+  lhs += span;
+  return lhs;
+}
+
+inline Ticks operator-(Ticks lhs, const Tickspan& span) {
+  lhs -= span;
+  return lhs;
+}
+
+inline Tickspan operator-(const Ticks& end, const Ticks& start) {
+  return Tickspan(end, start);
+}
+
+inline bool operator==(const Ticks& lhs, const Ticks& rhs) {
+  return lhs.value() == rhs.value();
+}
+
+inline bool operator!=(const Ticks& lhs, const Ticks& rhs) {
+  return !operator==(lhs,rhs);
+}
+
+inline bool operator<(const Ticks& lhs, const Ticks& rhs) {
+  return lhs.value() < rhs.value();
+}
+
+inline bool operator>(const Ticks& lhs, const Ticks& rhs) {
+  return operator<(rhs,lhs);
+}
+
+inline bool operator<=(const Ticks& lhs, const Ticks& rhs) {
+  return !operator>(lhs,rhs);
+}
+
+inline bool operator>=(const Ticks& lhs, const Ticks& rhs) {
+  return !operator<(lhs,rhs);
+}
+
+#endif // SHARE_VM_UTILITIES_TICKS_INLINE_HPP
--- ./hotspot/src/share/vm/utilities/vmError.cpp	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/src/share/vm/utilities/vmError.cpp	Wed May 07 19:26:16 2014 -0700
@@ -583,6 +583,13 @@
           while (count++ < StackPrintLimit) {
              fr.print_on_error(st, buf, sizeof(buf));
              st->cr();
+             // Compiled code may use EBP register on x86 so it looks like
+             // non-walkable C frame. Use frame.sender() for java frames.
+             if (_thread && _thread->is_Java_thread() && fr.is_java_frame()) {
+               RegisterMap map((JavaThread*)_thread, false); // No update
+               fr = fr.sender(&map);
+               continue;
+             }
              if (os::is_first_C_frame(&fr)) break;
              fr = os::get_sender_for_C_frame(&fr);
           }
@@ -698,18 +705,6 @@
        st->cr();
      }
 
-#ifdef LINUX
-  STEP(193, "(printing large pages allocation errors)")
-
-     if (_verbose) {
-       jint largepage_failures = os::Linux::num_largepage_commit_fails;
-       if (largepage_failures > 0) {
-         st->print_cr("Large page allocation failures have occurred " INT32_FORMAT " times", largepage_failures);
-         st->cr();
-       }
-     }
-#endif
-
   STEP(195, "(printing code cache information)" )
 
      if (_verbose && Universe::is_fully_initialized()) {
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/test/compiler/8004051/Test8004051.java	Wed May 07 19:26:16 2014 -0700
@@ -0,0 +1,56 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+/**
+ * @test
+ * @bug 8004051
+ * @bug 8005722
+ * @summary assert(_oprs_len[mode] < maxNumberOfOperands) failed: array overflow
+ *
+ * @run main/othervm -Xcomp -client Test8004051
+ */
+
+public class Test8004051 {
+    public static void main(String[] argv) {
+        Object o = new Object();
+        fillPrimRect(1.1f, 1.2f, 1.3f, 1.4f,
+                     o, o,
+                     1.5f, 1.6f, 1.7f, 1.8f,
+                     2.0f, 2.1f, 2.2f, 2.3f,
+                     2.4f, 2.5f, 2.6f, 2.7f,
+                     100, 101);
+        System.out.println("Test passed, test did not assert");
+    }
+
+    static boolean fillPrimRect(float x, float y, float w, float h,
+                                Object rectTex, Object wrapTex,
+                                float bx, float by, float bw, float bh,
+                                float f1, float f2, float f3, float f4,
+                                float f5, float f6, float f7, float f8,
+                                int i1, int i2 ) {
+        System.out.println(x + " " + y + " " + w + " " + h + " " +
+                           bx + " " + by + " " + bw + " " + bh);
+        return true;
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/test/compiler/codegen/LoadWithMask.java	Wed May 07 19:26:16 2014 -0700
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 8032207
+ * @summary Invalid node sizing for loadUS2L_immI16 and loadI2L_immI
+ * @run main/othervm -server -Xbatch -XX:-TieredCompilation -XX:CompileCommand=compileonly,LoadWithMask.foo LoadWithMask
+ *
+ */
+public class LoadWithMask {
+  static int x[] = new int[1];
+  static long foo() {
+    return x[0] & 0xfff0ffff;
+  }
+
+  public static void main(String[] args) {
+    x[0] = -1;
+    long l = 0;
+    for (int i = 0; i < 100000; ++i) {
+      l = foo();
+    }
+  }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/test/compiler/codegen/LoadWithMask2.java	Wed May 07 19:26:16 2014 -0700
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 8031743
+ * @summary loadI2L_immI broken for negative memory values
+ * @run main/othervm -server -Xbatch -XX:-TieredCompilation -XX:CompileCommand=compileonly,*.foo* LoadWithMask2
+ *
+ */
+public class LoadWithMask2 {
+  static int x;
+  static long foo1() {
+    return x & 0xfffffffe;
+  }
+  static long foo2() {
+    return x & 0xff000000;
+  }
+  static long foo3() {
+    return x & 0x8abcdef1;
+  }
+
+  public static void main(String[] args) {
+    x = -1;
+    long l = 0;
+    for (int i = 0; i < 100000; ++i) {
+      l = foo1() & foo2() & foo3();
+    }
+    if (l > 0) {
+      System.out.println("FAILED");
+      System.exit(97);
+    }
+    System.out.println("PASSED");
+  }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/test/compiler/gcbarriers/G1CrashTest.java	Wed May 07 19:26:16 2014 -0700
@@ -0,0 +1,84 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+/**
+ * @test
+ * @bug 8023472
+ * @summary C2 optimization breaks with G1
+ *
+ * @run main/othervm -Xbatch -XX:+IgnoreUnrecognizedVMOptions -XX:-TieredCompilation -Dcount=100000 G1CrashTest
+ *
+ * @author pbiswal@palantir.com
+ */
+
+public class G1CrashTest {
+    static Object[] set = new Object[11];
+
+    public static void main(String[] args) throws InterruptedException {
+        for (int j = 0; j < Integer.getInteger("count"); j++) {
+            Object key = new Object();
+            insertKey(key);
+            if (j > set.length / 2) {
+                Object[] oldKeys = set;
+                set = new Object[2 * set.length - 1];
+                for (Object o : oldKeys) {
+                    if (o != null)
+                        insertKey(o);
+                }
+            }
+        }
+    }
+
+    static void insertKey(Object key) {
+        int hash = key.hashCode() & 0x7fffffff;
+        int index = hash % set.length;
+        Object cur = set[index];
+        if (cur == null)
+            set[index] = key;
+        else
+            insertKeyRehash(key, index, hash, cur);
+    }
+
+    static void insertKeyRehash(Object key, int index, int hash, Object cur) {
+        int loopIndex = index;
+        int firstRemoved = -1;
+        do {
+            if (cur == "dead")
+                firstRemoved = 1;
+            index--;
+            if (index < 0)
+                index += set.length;
+            cur = set[index];
+            if (cur == null) {
+                if (firstRemoved != -1)
+                    set[firstRemoved] = "dead";
+                else
+                    set[index] = key;
+                return;
+            }
+        } while (index != loopIndex);
+        if (firstRemoved != -1)
+            set[firstRemoved] = null;
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/test/compiler/print/PrintInlining.java	Wed May 07 19:26:16 2014 -0700
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 8022585
+ * @summary VM crashes when ran with -XX:+PrintInlining
+ * @run main/othervm -Xcomp -XX:+PrintInlining PrintInlining
+ *
+ */
+
+public class PrintInlining {
+  public static void main(String[] args) {
+    System.out.println("Passed");
+  }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/test/compiler/reflection/ArrayNewInstanceOfVoid.java	Wed May 07 19:26:16 2014 -0700
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 8029366
+ * @summary ShouldNotReachHere error when creating an array with component type of void
+ */
+
+public class ArrayNewInstanceOfVoid {
+    public static void main(String[] args) {
+        for (int i = 0; i < 100_000; i++) {
+            test();
+        }
+    }
+
+    private static void test() {
+        try {
+            java.lang.reflect.Array.newInstance(void.class, 2);
+        } catch (IllegalArgumentException e) {
+            // expected
+        }
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/test/compiler/regalloc/C1ObjectSpillInLogicOp.java	Wed May 07 19:26:16 2014 -0700
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 8027751
+ * @summary C1 crashes generating G1 post-barrier in Unsafe.getAndSetObject() intrinsic because of the new value spill
+ * @run main/othervm -XX:+UseG1GC C1ObjectSpillInLogicOp
+ *
+ * G1 barriers use logical operators (xor) on T_OBJECT mixed with T_LONG or T_INT.
+ * The current implementation of logical operations on x86 in C1 doesn't allow for long operands to be on stack.
+ * There is a special code in the register allocator that forces long arguments in registers on x86. However T_OBJECT
+ * can be spilled just fine, and in that case the xor emission will fail.
+ */
+
+import java.util.concurrent.atomic.*;
+public class C1ObjectSpillInLogicOp {
+  static public void main(String[] args) {
+    AtomicReferenceArray<Integer> x = new AtomicReferenceArray(128);
+    Integer y = new Integer(0);
+    for (int i = 0; i < 50000; i++) {
+      x.getAndSet(i % x.length(), y);
+    }
+  }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/test/gc/8000311/Test8000311.java	Wed May 07 19:26:16 2014 -0700
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/**
+ * @test Test8000311
+ * @key gc
+ * @bug 8000311
+ * @summary G1: ParallelGCThreads==0 broken
+ * @run main/othervm -XX:+UseG1GC -XX:ParallelGCThreads=0 -XX:+ResizePLAB -XX:+ExplicitGCInvokesConcurrent Test8000311
+ * @author filipp.zhinkin@oracle.com
+ */
+
+import java.util.*;
+
+public class Test8000311 {
+  public static void main(String args[]) {
+    for(int i = 0; i<100; i++) {
+      byte[] garbage = new byte[1000];
+      System.gc();
+    }
+  }
+}
--- ./hotspot/test/gc/TestVerifyBeforeGCDuringStartup.java	Tue Mar 18 12:31:20 2014 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,45 +0,0 @@
-/*
- * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/* @test TestVerifyBeforeGCDuringStartup.java
- * @key gc
- * @bug 8010463
- * @summary Simple test run with -XX:+VerifyBeforeGC -XX:-UseTLAB to verify 8010463
- * @library /testlibrary
- */
-
-import com.oracle.java.testlibrary.OutputAnalyzer;
-import com.oracle.java.testlibrary.ProcessTools;
-
-public class TestVerifyBeforeGCDuringStartup {
-  public static void main(String args[]) throws Exception {
-    ProcessBuilder pb =
-      ProcessTools.createJavaProcessBuilder(System.getProperty("test.vm.opts"),
-                                            "-XX:-UseTLAB",
-                                            "-XX:+UnlockDiagnosticVMOptions",
-                                            "-XX:+VerifyBeforeGC", "-version");
-    OutputAnalyzer output = new OutputAnalyzer(pb.start());
-    output.shouldContain("[Verifying");
-    output.shouldHaveExitValue(0);
-  }
-}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/test/gc/TestVerifyDuringStartup.java	Wed May 07 19:26:16 2014 -0700
@@ -0,0 +1,45 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/* @test TestVerifyDuringStartup.java
+ * @key gc
+ * @bug 8010463
+ * @summary Simple test run with -XX:+VerifyDuringStartup -XX:-UseTLAB to verify 8010463
+ * @library /testlibrary
+ */
+
+import com.oracle.java.testlibrary.OutputAnalyzer;
+import com.oracle.java.testlibrary.ProcessTools;
+
+public class TestVerifyDuringStartup {
+  public static void main(String args[]) throws Exception {
+    ProcessBuilder pb =
+      ProcessTools.createJavaProcessBuilder(System.getProperty("test.vm.opts"),
+                                            "-XX:-UseTLAB",
+                                            "-XX:+UnlockDiagnosticVMOptions",
+                                            "-XX:+VerifyDuringStartup", "-version");
+    OutputAnalyzer output = new OutputAnalyzer(pb.start());
+    output.shouldContain("[Verifying");
+    output.shouldHaveExitValue(0);
+  }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/test/gc/TestVerifySilently.java	Wed May 07 19:26:16 2014 -0700
@@ -0,0 +1,84 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/* @test TestVerifySilently.java
+ * @key gc
+ * @bug 8032771
+ * @summary Test silent verification.
+ * @library /testlibrary
+ */
+
+import com.oracle.java.testlibrary.OutputAnalyzer;
+import com.oracle.java.testlibrary.ProcessTools;
+import java.util.ArrayList;
+import java.util.Collections;
+
+class RunSystemGC {
+  public static void main(String args[]) throws Exception {
+    System.gc();
+  }
+}
+
+
+public class TestVerifySilently {
+  private static String[] getTestJavaOpts() {
+    String testVmOptsStr = System.getProperty("test.java.opts");
+    if (!testVmOptsStr.isEmpty()) {
+      return testVmOptsStr.split(" ");
+    } else {
+      return new String[] {};
+    }
+  }
+
+  private static OutputAnalyzer runTest(boolean verifySilently) throws Exception {
+    ArrayList<String> vmOpts = new ArrayList();
+
+    Collections.addAll(vmOpts, getTestJavaOpts());
+    Collections.addAll(vmOpts, new String[] {"-XX:+UnlockDiagnosticVMOptions",
+                                             "-XX:+VerifyDuringStartup",
+                                             "-XX:+VerifyBeforeGC",
+                                             "-XX:+VerifyAfterGC",
+                                             "-XX:" + (verifySilently ? "+":"-") + "VerifySilently",
+                                             RunSystemGC.class.getName()});
+    ProcessBuilder pb =
+      ProcessTools.createJavaProcessBuilder(vmOpts.toArray(new String[vmOpts.size()]));
+    OutputAnalyzer output = new OutputAnalyzer(pb.start());
+
+    System.out.println("Output:\n" + output.getOutput());
+    return output;
+  }
+
+
+  public static void main(String args[]) throws Exception {
+
+    OutputAnalyzer output;
+
+    output = runTest(false);
+    output.shouldContain("[Verifying");
+    output.shouldHaveExitValue(0);
+
+    output = runTest(true);
+    output.shouldNotContain("[Verifying");
+    output.shouldHaveExitValue(0);
+  }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/test/gc/arguments/TestDynMaxHeapFreeRatio.java	Wed May 07 19:26:16 2014 -0700
@@ -0,0 +1,64 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/**
+ * @test TestDynMaxHeapFreeRatio
+ * @bug 8028391
+ * @summary Verify that MaxHeapFreeRatio flag is manageable
+ * @library /testlibrary
+ * @run main TestDynMaxHeapFreeRatio
+ * @run main/othervm -XX:MinHeapFreeRatio=0 -XX:MaxHeapFreeRatio=100 TestDynMaxHeapFreeRatio
+ * @run main/othervm -XX:MinHeapFreeRatio=10 -XX:MaxHeapFreeRatio=50 -XX:-UseAdaptiveSizePolicy TestDynMaxHeapFreeRatio
+ * @run main/othervm -XX:MinHeapFreeRatio=10 -XX:MaxHeapFreeRatio=50 TestDynMaxHeapFreeRatio
+ * @run main/othervm -XX:MinHeapFreeRatio=51 -XX:MaxHeapFreeRatio=52 TestDynMaxHeapFreeRatio
+ * @run main/othervm -XX:MinHeapFreeRatio=75 -XX:MaxHeapFreeRatio=100 TestDynMaxHeapFreeRatio
+ */
+import com.oracle.java.testlibrary.TestDynamicVMOption;
+import com.oracle.java.testlibrary.DynamicVMOptionChecker;
+
+public class TestDynMaxHeapFreeRatio extends TestDynamicVMOption {
+
+    public static final String MinFreeRatioFlagName = "MinHeapFreeRatio";
+    public static final String MaxFreeRatioFlagName = "MaxHeapFreeRatio";
+
+    public TestDynMaxHeapFreeRatio() {
+        super(MaxFreeRatioFlagName);
+    }
+
+    public void test() {
+
+        int minHeapFreeValue = DynamicVMOptionChecker.getIntValue(MinFreeRatioFlagName);
+        System.out.println(MinFreeRatioFlagName + " = " + minHeapFreeValue);
+
+        testPercentageValues();
+
+        checkInvalidValue(Integer.toString(minHeapFreeValue - 1));
+        checkValidValue(Integer.toString(minHeapFreeValue));
+        checkValidValue("100");
+    }
+
+    public static void main(String args[]) throws Exception {
+        new TestDynMaxHeapFreeRatio().test();
+    }
+
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/test/gc/arguments/TestDynMinHeapFreeRatio.java	Wed May 07 19:26:16 2014 -0700
@@ -0,0 +1,62 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/**
+ * @test TestDynMinHeapFreeRatio
+ * @bug 8028391
+ * @summary Verify that MinHeapFreeRatio flag is manageable
+ * @library /testlibrary
+ * @run main TestDynMinHeapFreeRatio
+ * @run main/othervm -XX:MinHeapFreeRatio=0 -XX:MaxHeapFreeRatio=100 TestDynMinHeapFreeRatio
+ * @run main/othervm -XX:MinHeapFreeRatio=10 -XX:MaxHeapFreeRatio=50 -XX:-UseAdaptiveSizePolicy TestDynMinHeapFreeRatio
+ * @run main/othervm -XX:MinHeapFreeRatio=10 -XX:MaxHeapFreeRatio=50 TestDynMinHeapFreeRatio
+ * @run main/othervm -XX:MinHeapFreeRatio=51 -XX:MaxHeapFreeRatio=52 TestDynMinHeapFreeRatio
+ * @run main/othervm -XX:MinHeapFreeRatio=75 -XX:MaxHeapFreeRatio=100 TestDynMinHeapFreeRatio
+ */
+import com.oracle.java.testlibrary.TestDynamicVMOption;
+import com.oracle.java.testlibrary.DynamicVMOptionChecker;
+
+public class TestDynMinHeapFreeRatio extends TestDynamicVMOption {
+
+    public static final String MinFreeRatioFlagName = "MinHeapFreeRatio";
+    public static final String MaxFreeRatioFlagName = "MaxHeapFreeRatio";
+
+    public TestDynMinHeapFreeRatio() {
+        super(MinFreeRatioFlagName);
+    }
+
+    public void test() {
+        int maxHeapFreeValue = DynamicVMOptionChecker.getIntValue(MaxFreeRatioFlagName);
+        System.out.println(MaxFreeRatioFlagName + " = " + maxHeapFreeValue);
+
+        testPercentageValues();
+
+        checkInvalidValue(Integer.toString(maxHeapFreeValue + 1));
+        checkValidValue(Integer.toString(maxHeapFreeValue));
+        checkValidValue("0");
+    }
+
+    public static void main(String args[]) throws Exception {
+        new TestDynMinHeapFreeRatio().test();
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/test/gc/g1/TestHumongousCodeCacheRoots.java	Wed May 07 19:26:16 2014 -0700
@@ -0,0 +1,143 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @key regression
+ * @key gc
+ * @bug 8027756
+ * @library /testlibrary /testlibrary/whitebox
+ * @build TestHumongousCodeCacheRoots
+ * @run main ClassFileInstaller sun.hotspot.WhiteBox
+ * @summary Humongous objects may have references from the code cache
+ * @run main TestHumongousCodeCacheRoots
+*/
+
+import com.oracle.java.testlibrary.*;
+import sun.hotspot.WhiteBox;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+
+class TestHumongousCodeCacheRootsHelper {
+
+    static final int n = 1000000;
+    static final int[] AA = new int[n];
+    static final int[] BB = new int[n];
+
+    public static void main(String args[]) throws Exception {
+        // do some work so that the compiler compiles this method, inlining the
+        // reference to the integer array (which is a humonguous object) into
+        // the code cache.
+        for(int i = 0; i < n; i++) {
+            AA[i] = 0;
+            BB[i] = 0;
+        }
+        // trigger a GC that checks that the verification code allows humongous
+        // objects with code cache roots; objects should be all live here.
+        System.gc();
+
+        // deoptimize everyhing: this should make all compiled code zombies.
+        WhiteBox wb = WhiteBox.getWhiteBox();
+        wb.deoptimizeAll();
+
+        // trigger a GC that checks that the verification code allows humongous
+        // objects with code cache roots; objects should be all live here.
+        System.gc();
+
+        // wait a little for the code cache sweeper to try to clean up zombie nmethods
+        // and unregister the code roots.
+        try { Thread.sleep(5000); } catch (InterruptedException ex) { }
+
+        // do some work on the arrays to make sure that they need to be live after the GCs
+        for(int i = 0; i < n; i++) {
+            AA[i] = 1;
+            BB[i] = 10;
+        }
+
+        System.out.println();
+    }
+}
+
+public class TestHumongousCodeCacheRoots {
+
+  /**
+   * Executes a class in a new VM process with the given parameters.
+   * @param vmargs Arguments to the VM to run
+   * @param classname Name of the class to run
+   * @param arguments Arguments to the class
+   * @param useTestDotJavaDotOpts Use test.java.opts as part of the VM argument string
+   * @return The OutputAnalyzer with the results for the invocation.
+   */
+  public static OutputAnalyzer runWhiteBoxTest(String[] vmargs, String classname, String[] arguments, boolean useTestDotJavaDotOpts) throws Exception {
+    ArrayList<String> finalargs = new ArrayList<String>();
+
+    String[] whiteboxOpts = new String[] {
+      "-Xbootclasspath/a:.",
+      "-XX:+UnlockDiagnosticVMOptions", "-XX:+WhiteBoxAPI",
+      "-cp", System.getProperty("java.class.path"),
+    };
+
+    if (useTestDotJavaDotOpts) {
+      // System.getProperty("test.java.opts") is '' if no options is set,
+      // we need to skip such a result
+      String[] externalVMOpts = new String[0];
+      if (System.getProperty("test.java.opts") != null && System.getProperty("test.java.opts").length() != 0) {
+        externalVMOpts = System.getProperty("test.java.opts").split(" ");
+      }
+      finalargs.addAll(Arrays.asList(externalVMOpts));
+    }
+
+    finalargs.addAll(Arrays.asList(vmargs));
+    finalargs.addAll(Arrays.asList(whiteboxOpts));
+    finalargs.add(classname);
+    finalargs.addAll(Arrays.asList(arguments));
+
+    ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(finalargs.toArray(new String[0]));
+    OutputAnalyzer output = new OutputAnalyzer(pb.start());
+    output.shouldHaveExitValue(0);
+
+    return output;
+  }
+
+  public static void runTest(String compiler, String[] other) throws Exception {
+    ArrayList<String> joined = new ArrayList<String>();
+    joined.add(compiler);
+    joined.addAll(Arrays.asList(other));
+    runWhiteBoxTest(joined.toArray(new String[0]), TestHumongousCodeCacheRootsHelper.class.getName(),
+      new String[] {}, false);
+  }
+
+  public static void main(String[] args) throws Exception {
+    final String[] baseArguments = new String[] {
+      "-XX:+UseG1GC", "-XX:G1HeapRegionSize=1M", "-Xmx100M", // make sure we get a humongous region
+      "-XX:+UnlockDiagnosticVMOptions",
+      "-XX:InitiatingHeapOccupancyPercent=1", // strong code root marking
+      "-XX:+G1VerifyHeapRegionCodeRoots", "-XX:+VerifyAfterGC", // make sure that verification is run
+      "-XX:NmethodSweepFraction=1", "-XX:NmethodSweepCheckInterval=1",  // make the code cache sweep more predictable
+    };
+    runTest("-client", baseArguments);
+    runTest("-server", baseArguments);
+  }
+}
+
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/test/gc/g1/TestPrintRegionRememberedSetInfo.java	Wed May 07 19:26:16 2014 -0700
@@ -0,0 +1,92 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/**
+ * @test TestPrintRegionRememberedSetInfo
+ * @key gc
+ * @bug 8014240
+ * @summary Test output of G1PrintRegionRememberedSetInfo
+ * @library /testlibrary
+ * @run main TestPrintRegionRememberedSetInfo
+ * @author thomas.schatzl@oracle.com
+ */
+
+import com.oracle.java.testlibrary.*;
+import java.lang.Thread;
+import java.util.ArrayList;
+import java.util.Arrays;
+
+class RunAndWaitForMarking {
+    public static void main(String[] args) {
+        System.gc();
+        try {
+            Thread.sleep(200);
+        } catch (InterruptedException e) {
+        }
+    }
+}
+
+public class TestPrintRegionRememberedSetInfo {
+
+    public static String runTest(String arg) throws Exception {
+        ArrayList<String> finalargs = new ArrayList<String>();
+        String[] defaultArgs = new String[] {
+            "-XX:+UseG1GC",
+            "-Xmx10m",
+            "-XX:+ExplicitGCInvokesConcurrent",
+            "-XX:+UnlockDiagnosticVMOptions",
+            "-XX:+G1PrintRegionLivenessInfo",
+            "-XX:G1HeapRegionSize=1M",
+            "-XX:InitiatingHeapOccupancyPercent=0",
+        };
+
+        finalargs.addAll(Arrays.asList(defaultArgs));
+        finalargs.add(arg);
+
+        finalargs.add(RunAndWaitForMarking.class.getName());
+
+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(
+            finalargs.toArray(new String[0]));
+        OutputAnalyzer output = new OutputAnalyzer(pb.start());
+        output.shouldHaveExitValue(0);
+
+        String result = output.getStdout();
+        return result;
+    }
+
+    public static void main(String[] args) throws Exception {
+        String result;
+
+        result = runTest("-XX:+G1PrintRegionLivenessInfo");
+        // check that we got region statistics output
+        if (result.indexOf("PHASE") == -1) {
+            throw new RuntimeException("Unexpected output from -XX:+PrintRegionLivenessInfo found.");
+        }
+
+        result = runTest("-XX:-G1PrintRegionLivenessInfo");
+        if (result.indexOf("remset") != -1) {
+            throw new RuntimeException("Should find remembered set information in output.");
+        }
+    }
+}
+
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/test/gc/g1/TestSummarizeRSetStats.java	Wed May 07 19:26:16 2014 -0700
@@ -0,0 +1,85 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test TestSummarizeRSetStats.java
+ * @bug 8013895
+ * @library /testlibrary
+ * @build TestSummarizeRSetStatsTools TestSummarizeRSetStats
+ * @summary Verify output of -XX:+G1SummarizeRSetStats
+ * @run main TestSummarizeRSetStats
+ *
+ * Test the output of G1SummarizeRSetStats in conjunction with G1SummarizeRSetStatsPeriod.
+ */
+
+public class TestSummarizeRSetStats {
+
+    public static void main(String[] args) throws Exception {
+        String result;
+
+        if (!TestSummarizeRSetStatsTools.testingG1GC()) {
+            return;
+        }
+
+        // no remembered set summary output
+        result = TestSummarizeRSetStatsTools.runTest(null, 0);
+        TestSummarizeRSetStatsTools.expectRSetSummaries(result, 0, 0);
+
+        // no remembered set summary output
+        result = TestSummarizeRSetStatsTools.runTest(null, 2);
+        TestSummarizeRSetStatsTools.expectRSetSummaries(result, 0, 0);
+
+        // no remembered set summary output
+        result = TestSummarizeRSetStatsTools.runTest(new String[] { "-XX:G1SummarizeRSetStatsPeriod=1" }, 3);
+        TestSummarizeRSetStatsTools.expectRSetSummaries(result, 0, 0);
+
+        // single remembered set summary output at the end
+        result = TestSummarizeRSetStatsTools.runTest(new String[] { "-XX:+G1SummarizeRSetStats" }, 0);
+        TestSummarizeRSetStatsTools.expectRSetSummaries(result, 1, 0);
+
+        // single remembered set summary output at the end
+        result = TestSummarizeRSetStatsTools.runTest(new String[] { "-XX:+G1SummarizeRSetStats" }, 2);
+        TestSummarizeRSetStatsTools.expectRSetSummaries(result, 1, 0);
+
+        // single remembered set summary output
+        result = TestSummarizeRSetStatsTools.runTest(new String[] { "-XX:+G1SummarizeRSetStats", "-XX:G1SummarizeRSetStatsPeriod=1" }, 0);
+        TestSummarizeRSetStatsTools.expectRSetSummaries(result, 1, 0);
+
+        // two times remembered set summary output
+        result = TestSummarizeRSetStatsTools.runTest(new String[] { "-XX:+G1SummarizeRSetStats", "-XX:G1SummarizeRSetStatsPeriod=1" }, 1);
+        TestSummarizeRSetStatsTools.expectRSetSummaries(result, 1, 2);
+
+        // four times remembered set summary output
+        result = TestSummarizeRSetStatsTools.runTest(new String[] { "-XX:+G1SummarizeRSetStats", "-XX:G1SummarizeRSetStatsPeriod=1" }, 3);
+        TestSummarizeRSetStatsTools.expectRSetSummaries(result, 1, 6);
+
+        // three times remembered set summary output
+        result = TestSummarizeRSetStatsTools.runTest(new String[] { "-XX:+G1SummarizeRSetStats", "-XX:G1SummarizeRSetStatsPeriod=2" }, 3);
+        TestSummarizeRSetStatsTools.expectRSetSummaries(result, 1, 4);
+
+        // single remembered set summary output
+        result = TestSummarizeRSetStatsTools.runTest(new String[] { "-XX:+G1SummarizeRSetStats", "-XX:G1SummarizeRSetStatsPeriod=100" }, 3);
+        TestSummarizeRSetStatsTools.expectRSetSummaries(result, 1, 2);
+    }
+}
+
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/test/gc/g1/TestSummarizeRSetStatsPerRegion.java	Wed May 07 19:26:16 2014 -0700
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test TestSummarizeRSetStatsPerRegion.java
+ * @bug 8014078
+ * @library /testlibrary
+ * @build TestSummarizeRSetStatsTools TestSummarizeRSetStatsPerRegion
+ * @summary Verify output of -XX:+G1SummarizeRSetStats in regards to per-region type output
+ * @run main TestSummarizeRSetStatsPerRegion
+ */
+
+import com.oracle.java.testlibrary.*;
+import java.lang.Thread;
+import java.util.ArrayList;
+import java.util.Arrays;
+
+public class TestSummarizeRSetStatsPerRegion {
+
+    public static void main(String[] args) throws Exception {
+        String result;
+
+        if (!TestSummarizeRSetStatsTools.testingG1GC()) {
+            return;
+        }
+
+        // single remembered set summary output at the end
+        result = TestSummarizeRSetStatsTools.runTest(new String[] { "-XX:+G1SummarizeRSetStats" }, 0);
+        TestSummarizeRSetStatsTools.expectPerRegionRSetSummaries(result, 1, 0);
+
+        // two times remembered set summary output
+        result = TestSummarizeRSetStatsTools.runTest(new String[] { "-XX:+G1SummarizeRSetStats", "-XX:G1SummarizeRSetStatsPeriod=1" }, 1);
+        TestSummarizeRSetStatsTools.expectPerRegionRSetSummaries(result, 1, 2);
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/test/gc/g1/TestSummarizeRSetStatsThreads.java	Wed May 07 19:26:16 2014 -0700
@@ -0,0 +1,83 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test TestSummarizeRSetStatsThreads
+ * @bug 8025441
+ * @summary Ensure that various values of worker threads/concurrent
+ * refinement threads do not crash the VM.
+ * @key gc
+ * @library /testlibrary
+ */
+
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import com.oracle.java.testlibrary.ProcessTools;
+import com.oracle.java.testlibrary.OutputAnalyzer;
+
+public class TestSummarizeRSetStatsThreads {
+
+  private static void runTest(int refinementThreads, int workerThreads) throws Exception {
+    ProcessBuilder pb = ProcessTools.createJavaProcessBuilder("-XX:+UseG1GC",
+                                                              "-XX:+UnlockDiagnosticVMOptions",
+                                                              "-XX:+G1SummarizeRSetStats",
+                                                              "-XX:G1ConcRefinementThreads=" + refinementThreads,
+                                                              "-XX:ParallelGCThreads=" + workerThreads,
+                                                              "-version");
+
+    OutputAnalyzer output = new OutputAnalyzer(pb.start());
+
+    // check output to contain the string "Concurrent RS threads times (s)" followed by
+    // the correct number of values in the next line.
+
+    // a zero in refinement thread numbers indicates that the value in ParallelGCThreads should be used.
+    // Additionally use at least one thread.
+    int expectedNumRefinementThreads = refinementThreads == 0 ? workerThreads : refinementThreads;
+    expectedNumRefinementThreads = Math.max(1, expectedNumRefinementThreads);
+    // create the pattern made up of n copies of a floating point number pattern
+    String numberPattern = String.format("%0" + expectedNumRefinementThreads + "d", 0)
+      .replace("0", "\\s+\\d+\\.\\d+");
+    String pattern = "Concurrent RS threads times \\(s\\)$" + numberPattern + "$";
+    Matcher m = Pattern.compile(pattern, Pattern.MULTILINE).matcher(output.getStdout());
+
+    if (!m.find()) {
+      throw new Exception("Could not find correct output for concurrent RS threads times in stdout," +
+        " should match the pattern \"" + pattern + "\", but stdout is \n" + output.getStdout());
+    }
+    output.shouldHaveExitValue(0);
+  }
+
+  public static void main(String[] args) throws Exception {
+    if (!TestSummarizeRSetStatsTools.testingG1GC()) {
+      return;
+    }
+    // different valid combinations of number of refinement and gc worker threads
+    runTest(0, 0);
+    runTest(0, 5);
+    runTest(5, 0);
+    runTest(10, 10);
+    runTest(1, 2);
+    runTest(4, 3);
+  }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/test/gc/g1/TestSummarizeRSetStatsTools.java	Wed May 07 19:26:16 2014 -0700
@@ -0,0 +1,154 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * Common helpers for TestSummarizeRSetStats* tests
+ */
+
+import sun.management.ManagementFactoryHelper;
+import com.sun.management.HotSpotDiagnosticMXBean;
+import com.sun.management.VMOption;
+
+import com.oracle.java.testlibrary.*;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import java.lang.Thread;
+import java.util.ArrayList;
+import java.util.Arrays;
+
+class VerifySummaryOutput {
+    // 4M size, both are directly allocated into the old gen
+    static Object[] largeObject1 = new Object[1024 * 1024];
+    static Object[] largeObject2 = new Object[1024 * 1024];
+
+    static int[] temp;
+
+    public static void main(String[] args) {
+        // create some cross-references between these objects
+        for (int i = 0; i < largeObject1.length; i++) {
+            largeObject1[i] = largeObject2;
+        }
+
+        for (int i = 0; i < largeObject2.length; i++) {
+            largeObject2[i] = largeObject1;
+        }
+
+        int numGCs = Integer.parseInt(args[0]);
+
+        if (numGCs > 0) {
+            // try to force a minor collection: the young gen is 4M, the
+            // amount of data allocated below is roughly that (4*1024*1024 +
+            // some header data)
+            for (int i = 0; i < 1024 ; i++) {
+                temp = new int[1024];
+            }
+        }
+
+        for (int i = 0; i < numGCs - 1; i++) {
+            System.gc();
+        }
+    }
+}
+
+public class TestSummarizeRSetStatsTools {
+
+    // the VM is currently run using G1GC, i.e. trying to test G1 functionality.
+    public static boolean testingG1GC() {
+        HotSpotDiagnosticMXBean diagnostic = ManagementFactoryHelper.getDiagnosticMXBean();
+
+        VMOption option = diagnostic.getVMOption("UseG1GC");
+        if (option.getValue().equals("false")) {
+          System.out.println("Skipping this test. It is only a G1 test.");
+          return false;
+        }
+        return true;
+    }
+
+    public static String runTest(String[] additionalArgs, int numGCs) throws Exception {
+        ArrayList<String> finalargs = new ArrayList<String>();
+        String[] defaultArgs = new String[] {
+            "-XX:+UseG1GC",
+            "-XX:+UseCompressedOops",
+            "-Xmn4m",
+            "-Xmx20m",
+            "-XX:InitiatingHeapOccupancyPercent=100", // we don't want the additional GCs due to initial marking
+            "-XX:+PrintGC",
+            "-XX:+UnlockDiagnosticVMOptions",
+            "-XX:G1HeapRegionSize=1M",
+        };
+
+        finalargs.addAll(Arrays.asList(defaultArgs));
+
+        if (additionalArgs != null) {
+            finalargs.addAll(Arrays.asList(additionalArgs));
+        }
+
+        finalargs.add(VerifySummaryOutput.class.getName());
+        finalargs.add(String.valueOf(numGCs));
+
+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(
+            finalargs.toArray(new String[0]));
+        OutputAnalyzer output = new OutputAnalyzer(pb.start());
+
+        output.shouldHaveExitValue(0);
+
+        String result = output.getStdout();
+        return result;
+    }
+
+    private static void checkCounts(int expected, int actual, String which) throws Exception {
+        if (expected != actual) {
+            throw new Exception("RSet summaries mention " + which + " regions an incorrect number of times. Expected " + expected + ", got " + actual);
+        }
+    }
+
+    public static void expectPerRegionRSetSummaries(String result, int expectedCumulative, int expectedPeriodic) throws Exception {
+        expectRSetSummaries(result, expectedCumulative, expectedPeriodic);
+        int actualYoung = result.split("Young regions").length - 1;
+        int actualHumonguous = result.split("Humonguous regions").length - 1;
+        int actualFree = result.split("Free regions").length - 1;
+        int actualOther = result.split("Old regions").length - 1;
+
+        // the strings we check for above are printed four times per summary
+        int expectedPerRegionTypeInfo = (expectedCumulative + expectedPeriodic) * 4;
+
+        checkCounts(expectedPerRegionTypeInfo, actualYoung, "Young");
+        checkCounts(expectedPerRegionTypeInfo, actualHumonguous, "Humonguous");
+        checkCounts(expectedPerRegionTypeInfo, actualFree, "Free");
+        checkCounts(expectedPerRegionTypeInfo, actualOther, "Old");
+    }
+
+    public static void expectRSetSummaries(String result, int expectedCumulative, int expectedPeriodic) throws Exception {
+        int actualTotal = result.split("concurrent refinement").length - 1;
+        int actualCumulative = result.split("Cumulative RS summary").length - 1;
+
+        if (expectedCumulative != actualCumulative) {
+            throw new Exception("Incorrect amount of RSet summaries at the end. Expected " + expectedCumulative + ", got " + actualCumulative);
+        }
+
+        if (expectedPeriodic != (actualTotal - actualCumulative)) {
+            throw new Exception("Incorrect amount of per-period RSet summaries at the end. Expected " + expectedPeriodic + ", got " + (actualTotal - actualCumulative));
+        }
+    }
+}
+
--- ./hotspot/test/runtime/6929067/Test6929067.sh	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/test/runtime/6929067/Test6929067.sh	Wed May 07 19:26:16 2014 -0700
@@ -3,6 +3,7 @@
 ##
 ## @test Test6929067.sh
 ## @bug 6929067
+## @bug 8021296
 ## @summary Stack guard pages should be removed when thread is detached
 ## @compile T.java
 ## @run shell Test6929067.sh
@@ -21,6 +22,11 @@
 OS=`uname -s`
 case "$OS" in
   Linux)
+    gcc_cmd=`which gcc`
+    if [ "x$gcc_cmd" == "x" ]; then
+        echo "WARNING: gcc not found. Cannot execute test." 2>&1
+        exit 0;
+    fi
     NULL=/dev/null
     PS=":"
     FS="/"
@@ -119,10 +125,10 @@
 # Check to ensure you have a /usr/lib/libpthread.so if you don't please look
 # for /usr/lib/`uname -m`-linux-gnu version ensure to add that path to below compilation.
 
-gcc -DLINUX ${COMP_FLAG} -o invoke \
-  -I${COMPILEJAVA}/include -I${COMPILEJAVA}/include/linux \
-  -L${COMPILEJAVA}/jre/lib/${ARCH}/${VMTYPE} \
-  -ljvm -lpthread invoke.c
+$gcc_cmd -DLINUX ${COMP_FLAG} -o invoke \
+    -I${COMPILEJAVA}/include -I${COMPILEJAVA}/include/linux \
+    -L${COMPILEJAVA}/jre/lib/${ARCH}/${VMTYPE} \
+    -ljvm -lpthread invoke.c
 
 ./invoke
 exit $?
--- ./hotspot/test/runtime/7107135/Test7107135.sh	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/test/runtime/7107135/Test7107135.sh	Wed May 07 19:26:16 2014 -0700
@@ -27,6 +27,7 @@
 ##
 ## @test Test7107135.sh
 ## @bug 7107135
+## @bug 8021296
 ## @summary Stack guard pages lost after loading library with executable stack.
 ## @run shell Test7107135.sh
 ##
@@ -45,6 +46,11 @@
 case "$OS" in
   Linux)
     echo "Testing on Linux"
+    gcc_cmd=`which gcc`
+    if [ "x$gcc_cmd" == "x" ]; then
+        echo "WARNING: gcc not found. Cannot execute test." 2>&1
+        exit 0;
+    fi
     ;;
   *)
     NULL=NUL
@@ -62,7 +68,10 @@
 cp ${TESTSRC}${FS}*.java ${THIS_DIR}
 ${TESTJAVA}${FS}bin${FS}javac *.java
 
-gcc -fPIC -shared -c -o test.o -I${TESTJAVA}${FS}include -I${TESTJAVA}${FS}include${FS}linux ${TESTSRC}${FS}test.c
+$gcc_cmd -fPIC -shared -c -o test.o \
+    -I${TESTJAVA}${FS}include -I${TESTJAVA}${FS}include${FS}linux \
+    ${TESTSRC}${FS}test.c
+
 ld -shared -z   execstack -o libtest-rwx.so test.o
 ld -shared -z noexecstack -o libtest-rw.so  test.o
 
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/test/runtime/jsig/Test8017498.sh	Wed May 07 19:26:16 2014 -0700
@@ -0,0 +1,94 @@
+#!/bin/sh
+
+#
+#  Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+#  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+#  This code is free software; you can redistribute it and/or modify it
+#  under the terms of the GNU General Public License version 2 only, as
+#  published by the Free Software Foundation.
+#
+#  This code is distributed in the hope that it will be useful, but WITHOUT
+#  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+#  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+#  version 2 for more details (a copy is included in the LICENSE file that
+#  accompanied this code).
+#
+#  You should have received a copy of the GNU General Public License version
+#  2 along with this work; if not, write to the Free Software Foundation,
+#  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+#  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+#  or visit www.oracle.com if you need additional information or have any
+#  questions.
+#
+
+##
+## @test Test8017498.sh
+## @bug 8017498
+## @bug 8020791
+## @bug 8021296
+## @summary sigaction(sig) results in process hang/timed-out if sig is much greater than SIGRTMAX
+## @run shell/timeout=30 Test8017498.sh
+##
+
+if [ "${TESTSRC}" = "" ]
+then
+  TESTSRC=${PWD}
+  echo "TESTSRC not set.  Using "${TESTSRC}" as default"
+fi
+echo "TESTSRC=${TESTSRC}"
+## Adding common setup Variables for running shell tests.
+. ${TESTSRC}/../../test_env.sh
+
+# set platform-dependent variables
+OS=`uname -s`
+case "$OS" in
+  Linux)
+    echo "Testing on Linux"
+    gcc_cmd=`which gcc`
+    if [ "x$gcc_cmd" == "x" ]; then
+        echo "WARNING: gcc not found. Cannot execute test." 2>&1
+        exit 0;
+    fi
+    if [ "$VM_BITS" = "64" ]
+    then
+        MY_LD_PRELOAD=${TESTJAVA}${FS}jre${FS}lib${FS}amd64${FS}libjsig.so
+    else
+        MY_LD_PRELOAD=${TESTJAVA}${FS}jre${FS}lib${FS}i386${FS}libjsig.so
+    fi
+    echo MY_LD_PRELOAD = ${MY_LD_PRELOAD}
+    ;;
+  *)
+    echo "Test passed; only valid for Linux"
+    exit 0;
+    ;;
+esac
+
+THIS_DIR=.
+
+cp ${TESTSRC}${FS}*.java ${THIS_DIR}
+${TESTJAVA}${FS}bin${FS}javac *.java
+
+$gcc_cmd -DLINUX -fPIC -shared \
+    -o ${TESTSRC}${FS}libTestJNI.so \
+    -I${TESTJAVA}${FS}include \
+    -I${TESTJAVA}${FS}include${FS}linux \
+    ${TESTSRC}${FS}TestJNI.c
+
+# run the java test in the background
+cmd="LD_PRELOAD=$MY_LD_PRELOAD \
+    ${TESTJAVA}${FS}bin${FS}java \
+    -Djava.library.path=${TESTSRC}${FS} -server TestJNI 100"
+echo "$cmd > test.out 2>&1"
+eval $cmd > test.out 2>&1
+
+grep "old handler" test.out > ${NULL}
+if [ $? = 0 ]
+then
+    echo "Test Passed"
+    exit 0
+fi
+
+echo "Test Failed"
+exit 1
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/test/runtime/jsig/TestJNI.c	Wed May 07 19:26:16 2014 -0700
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#include <stdio.h>
+#include <jni.h>
+#include <signal.h>
+#include <sys/ucontext.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+void sig_handler(int sig, siginfo_t *info, ucontext_t *context) {
+
+    printf( " HANDLER (1) " );
+}
+
+JNIEXPORT void JNICALL Java_TestJNI_doSomething(JNIEnv *env, jclass klass, jint val) {
+    struct sigaction act;
+    struct sigaction oact;
+
+    act.sa_flags = SA_ONSTACK|SA_RESTART|SA_SIGINFO;
+    sigfillset(&act.sa_mask);
+    act.sa_handler = SIG_DFL;
+    act.sa_sigaction = (void (*)())sig_handler;
+    sigaction(0x20+val, &act, &oact);
+
+    printf( " doSomething(%d) " , val);
+    printf( " old handler = %p " , oact.sa_handler);
+}
+
+#ifdef __cplusplus
+}
+#endif
+
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/test/runtime/jsig/TestJNI.java	Wed May 07 19:26:16 2014 -0700
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+public class TestJNI {
+    static {
+        System.loadLibrary("TestJNI");
+    }
+    public static native void doSomething(int val);
+    public static void main(String[] args) {
+        int intArg = 43;
+        if (args.length > 0) {
+            try {
+                intArg = Integer.parseInt(args[0]);
+            } catch (NumberFormatException e) {
+                System.err.println("arg " + args[0] + " must be an integer");
+                System.exit(1);
+            }
+        }
+        TestJNI.doSomething(intArg);
+    }
+}
+
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/test/runtime/memory/LargePages/TestLargePagesFlags.java	Wed May 07 19:26:16 2014 -0700
@@ -0,0 +1,389 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/* @test TestLargePagesFlags
+ * @summary Tests how large pages are choosen depending on the given large pages flag combinations.
+ * @library /testlibrary
+ * @run main TestLargePagesFlags
+ */
+
+import com.oracle.java.testlibrary.OutputAnalyzer;
+import com.oracle.java.testlibrary.Platform;
+import com.oracle.java.testlibrary.ProcessTools;
+import java.util.ArrayList;
+
+public class TestLargePagesFlags {
+
+  public static void main(String [] args) throws Exception {
+    if (!Platform.isLinux()) {
+      System.out.println("Skipping. TestLargePagesFlags has only been implemented for Linux.");
+      return;
+    }
+
+    testUseTransparentHugePages();
+    testUseHugeTLBFS();
+    testUseSHM();
+    testCombinations();
+  }
+
+  public static void testUseTransparentHugePages() throws Exception {
+    if (!canUse(UseTransparentHugePages(true))) {
+      System.out.println("Skipping testUseTransparentHugePages");
+      return;
+    }
+
+    // -XX:-UseLargePages overrides all other flags.
+    new FlagTester()
+      .use(UseLargePages(false),
+           UseTransparentHugePages(true))
+      .expect(
+           UseLargePages(false),
+           UseTransparentHugePages(false),
+           UseHugeTLBFS(false),
+           UseSHM(false));
+
+    // Explicitly turn on UseTransparentHugePages.
+    new FlagTester()
+      .use(UseTransparentHugePages(true))
+      .expect(
+           UseLargePages(true),
+           UseTransparentHugePages(true),
+           UseHugeTLBFS(false),
+           UseSHM(false));
+
+    new FlagTester()
+      .use(UseLargePages(true),
+           UseTransparentHugePages(true))
+      .expect(
+           UseLargePages(true),
+           UseTransparentHugePages(true),
+           UseHugeTLBFS(false),
+           UseSHM(false));
+
+    // Setting a specific large pages flag will turn
+    // off heuristics to choose large pages type.
+    new FlagTester()
+      .use(UseLargePages(true),
+           UseTransparentHugePages(false))
+      .expect(
+           UseLargePages(false),
+           UseTransparentHugePages(false),
+           UseHugeTLBFS(false),
+           UseSHM(false));
+
+    // Don't turn on UseTransparentHugePages
+    // unless the user explicitly asks for them.
+    new FlagTester()
+      .use(UseLargePages(true))
+      .expect(
+           UseTransparentHugePages(false));
+  }
+
+  public static void testUseHugeTLBFS() throws Exception {
+    if (!canUse(UseHugeTLBFS(true))) {
+      System.out.println("Skipping testUseHugeTLBFS");
+      return;
+    }
+
+    // -XX:-UseLargePages overrides all other flags.
+    new FlagTester()
+      .use(UseLargePages(false),
+           UseHugeTLBFS(true))
+      .expect(
+           UseLargePages(false),
+           UseTransparentHugePages(false),
+           UseHugeTLBFS(false),
+           UseSHM(false));
+
+    // Explicitly turn on UseHugeTLBFS.
+    new FlagTester()
+      .use(UseHugeTLBFS(true))
+      .expect(
+           UseLargePages(true),
+           UseTransparentHugePages(false),
+           UseHugeTLBFS(true),
+           UseSHM(false));
+
+    new FlagTester()
+      .use(UseLargePages(true),
+           UseHugeTLBFS(true))
+      .expect(
+           UseLargePages(true),
+           UseTransparentHugePages(false),
+           UseHugeTLBFS(true),
+           UseSHM(false));
+
+    // Setting a specific large pages flag will turn
+    // off heuristics to choose large pages type.
+    new FlagTester()
+      .use(UseLargePages(true),
+           UseHugeTLBFS(false))
+      .expect(
+           UseLargePages(false),
+           UseTransparentHugePages(false),
+           UseHugeTLBFS(false),
+           UseSHM(false));
+
+    // Using UseLargePages will default to UseHugeTLBFS large pages.
+    new FlagTester()
+      .use(UseLargePages(true))
+      .expect(
+           UseLargePages(true),
+           UseTransparentHugePages(false),
+           UseHugeTLBFS(true),
+           UseSHM(false));
+  }
+
+  public static void testUseSHM() throws Exception {
+    if (!canUse(UseSHM(true))) {
+      System.out.println("Skipping testUseSHM");
+      return;
+    }
+
+    // -XX:-UseLargePages overrides all other flags.
+    new FlagTester()
+      .use(UseLargePages(false),
+           UseSHM(true))
+      .expect(
+           UseLargePages(false),
+           UseTransparentHugePages(false),
+           UseHugeTLBFS(false),
+           UseSHM(false));
+
+    // Explicitly turn on UseSHM.
+    new FlagTester()
+      .use(UseSHM(true))
+      .expect(
+           UseLargePages(true),
+           UseTransparentHugePages(false),
+           UseHugeTLBFS(false),
+           UseSHM(true)) ;
+
+    new FlagTester()
+      .use(UseLargePages(true),
+           UseSHM(true))
+      .expect(
+           UseLargePages(true),
+           UseTransparentHugePages(false),
+           UseHugeTLBFS(false),
+           UseSHM(true)) ;
+
+    // Setting a specific large pages flag will turn
+    // off heuristics to choose large pages type.
+    new FlagTester()
+      .use(UseLargePages(true),
+           UseSHM(false))
+      .expect(
+           UseLargePages(false),
+           UseTransparentHugePages(false),
+           UseHugeTLBFS(false),
+           UseSHM(false));
+
+    // Setting UseLargePages can allow the system to choose
+    // UseHugeTLBFS instead of UseSHM, but never UseTransparentHugePages.
+    new FlagTester()
+      .use(UseLargePages(true))
+      .expect(
+           UseLargePages(true),
+           UseTransparentHugePages(false));
+  }
+
+  public static void testCombinations() throws Exception {
+    if (!canUse(UseSHM(true)) || !canUse(UseHugeTLBFS(true))) {
+      System.out.println("Skipping testUseHugeTLBFSAndUseSHMCombination");
+      return;
+    }
+
+    // UseHugeTLBFS takes precedence over SHM.
+
+    new FlagTester()
+      .use(UseLargePages(true),
+           UseHugeTLBFS(true),
+           UseSHM(true))
+      .expect(
+           UseLargePages(true),
+           UseTransparentHugePages(false),
+           UseHugeTLBFS(true),
+           UseSHM(false));
+
+    new FlagTester()
+      .use(UseLargePages(true),
+           UseHugeTLBFS(false),
+           UseSHM(true))
+      .expect(
+           UseLargePages(true),
+           UseTransparentHugePages(false),
+           UseHugeTLBFS(false),
+           UseSHM(true));
+
+    new FlagTester()
+      .use(UseLargePages(true),
+           UseHugeTLBFS(true),
+           UseSHM(false))
+      .expect(
+           UseLargePages(true),
+           UseTransparentHugePages(false),
+           UseHugeTLBFS(true),
+           UseSHM(false));
+
+    new FlagTester()
+      .use(UseLargePages(true),
+           UseHugeTLBFS(false),
+           UseSHM(false))
+      .expect(
+           UseLargePages(false),
+           UseTransparentHugePages(false),
+           UseHugeTLBFS(false),
+           UseSHM(false));
+
+
+    if (!canUse(UseTransparentHugePages(true))) {
+      return;
+    }
+
+    // UseTransparentHugePages takes precedence.
+
+    new FlagTester()
+      .use(UseLargePages(true),
+           UseTransparentHugePages(true),
+           UseHugeTLBFS(true),
+           UseSHM(true))
+      .expect(
+           UseLargePages(true),
+           UseTransparentHugePages(true),
+           UseHugeTLBFS(false),
+           UseSHM(false));
+
+    new FlagTester()
+      .use(UseTransparentHugePages(true),
+           UseHugeTLBFS(true),
+           UseSHM(true))
+      .expect(
+           UseLargePages(true),
+           UseTransparentHugePages(true),
+           UseHugeTLBFS(false),
+           UseSHM(false));
+  }
+
+  private static class FlagTester {
+    private Flag [] useFlags;
+
+    public FlagTester use(Flag... useFlags) {
+      this.useFlags = useFlags;
+      return this;
+    }
+
+    public void expect(Flag... expectedFlags) throws Exception {
+      if (useFlags == null) {
+        throw new IllegalStateException("Must run use() before expect()");
+      }
+
+      OutputAnalyzer output = executeNewJVM(useFlags);
+
+      for (Flag flag : expectedFlags) {
+        System.out.println("Looking for: " + flag.flagString());
+        String strValue = output.firstMatch(".* " + flag.name() +  " .* :?= (\\S+).*", 1);
+
+        if (strValue == null) {
+          throw new RuntimeException("Flag " + flag.name() + " couldn't be found");
+        }
+
+        if (!flag.value().equals(strValue)) {
+          throw new RuntimeException("Wrong value for: " + flag.name()
+                                     + " expected: " + flag.value()
+                                     + " got: " + strValue);
+        }
+      }
+
+      output.shouldHaveExitValue(0);
+    }
+  }
+
+  private static OutputAnalyzer executeNewJVM(Flag... flags) throws Exception {
+    ArrayList<String> args = new ArrayList<>();
+    for (Flag flag : flags) {
+      args.add(flag.flagString());
+    }
+    args.add("-XX:+PrintFlagsFinal");
+    args.add("-version");
+
+    ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(args.toArray(new String[args.size()]));
+    OutputAnalyzer output = new OutputAnalyzer(pb.start());
+
+    return output;
+  }
+
+  private static boolean canUse(Flag flag) {
+    try {
+      new FlagTester().use(flag).expect(flag);
+    } catch (Exception e) {
+      return false;
+    }
+
+    return true;
+  }
+
+  private static Flag UseLargePages(boolean value) {
+    return new BooleanFlag("UseLargePages", value);
+  }
+
+  private static Flag UseTransparentHugePages(boolean value) {
+    return new BooleanFlag("UseTransparentHugePages", value);
+  }
+
+  private static Flag UseHugeTLBFS(boolean value) {
+    return new BooleanFlag("UseHugeTLBFS", value);
+  }
+
+  private static Flag UseSHM(boolean value) {
+    return new BooleanFlag("UseSHM", value);
+  }
+
+  private static class BooleanFlag implements Flag {
+    private String name;
+    private boolean value;
+
+    BooleanFlag(String name, boolean value) {
+      this.name = name;
+      this.value = value;
+    }
+
+    public String flagString() {
+      return "-XX:" + (value ? "+" : "-") + name;
+    }
+
+    public String name() {
+      return name;
+    }
+
+    public String value() {
+      return Boolean.toString(value);
+    }
+  }
+
+  private static interface Flag {
+    public String flagString();
+    public String name();
+    public String value();
+  }
+}
--- ./hotspot/test/testlibrary/OutputAnalyzerTest.java	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/test/testlibrary/OutputAnalyzerTest.java	Wed May 07 19:26:16 2014 -0700
@@ -172,5 +172,22 @@
     } catch (RuntimeException e) {
         // expected
     }
+
+    {
+      String aaaa = "aaaa";
+      String result = output.firstMatch(aaaa);
+      if (!aaaa.equals(result)) {
+        throw new Exception("firstMatch(String) faild to match. Expected: " + aaaa + " got: " + result);
+      }
+    }
+
+    {
+      String aa = "aa";
+      String aa_grouped_aa = aa + "(" + aa + ")";
+      String result = output.firstMatch(aa_grouped_aa, 1);
+      if (!aa.equals(result)) {
+        throw new Exception("firstMatch(String, int) failed to match. Expected: " + aa + " got: " + result);
+      }
+    }
   }
 }
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/test/testlibrary/com/oracle/java/testlibrary/DynamicVMOptionChecker.java	Wed May 07 19:26:16 2014 -0700
@@ -0,0 +1,111 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package com.oracle.java.testlibrary;
+
+import com.sun.management.HotSpotDiagnosticMXBean;
+import com.sun.management.VMOption;
+import java.lang.management.ManagementFactory;
+
+/**
+ * Simple class to check writeability, invalid and valid values for VMOption
+ */
+public class DynamicVMOptionChecker {
+
+    /**
+     * Reads VM option from PlatformMXBean and parse it to integer value
+     *
+     * @param name of option
+     * @return parsed value
+     */
+    public static int getIntValue(String name) {
+
+        VMOption option = ManagementFactory.
+                getPlatformMXBean(HotSpotDiagnosticMXBean.class).
+                getVMOption(name);
+
+        return Integer.parseInt(option.getValue());
+    }
+
+    /**
+     * Checks that VM option is dynamically writable
+     *
+     * @param name
+     * @throws RuntimeException if option if not writable
+     * @return always true
+     */
+    public static boolean checkIsWritable(String name) {
+        VMOption option = ManagementFactory.
+                getPlatformMXBean(HotSpotDiagnosticMXBean.class).
+                getVMOption(name);
+
+        if (!option.isWriteable()) {
+            throw new RuntimeException(name + " is not writable");
+        }
+
+        return true;
+    }
+
+    /**
+     * Checks that value cannot be set
+     *
+     * @param name of flag
+     * @param value string representation of value to set
+     * @throws RuntimeException on error - when expected exception hasn't been thrown
+     */
+    public static void checkInvalidValue(String name, String value) {
+        // should throw
+        try {
+            ManagementFactory.
+                    getPlatformMXBean(HotSpotDiagnosticMXBean.class).
+                    setVMOption(name, value);
+
+        } catch (IllegalArgumentException e) {
+            return;
+        }
+
+        throw new RuntimeException("Expected IllegalArgumentException was not thrown, " + name + "= " + value);
+    }
+
+    /**
+     * Checks that value can be set
+     *
+     * @param name of flag to set
+     * @param value string representation of value to set
+     * @throws RuntimeException on error - when value in VM is not equal to origin
+     */
+    public static void checkValidValue(String name, String value) {
+        ManagementFactory.
+                getPlatformMXBean(HotSpotDiagnosticMXBean.class).
+                setVMOption(name, value);
+
+        VMOption option = ManagementFactory.
+                getPlatformMXBean(HotSpotDiagnosticMXBean.class).
+                getVMOption(name);
+
+        if (!option.getValue().equals(value)) {
+            throw new RuntimeException("Actual value of " + name + " \"" + option.getValue()
+                    + "\" not equal origin \"" + value + "\"");
+        }
+    }
+
+}
--- ./hotspot/test/testlibrary/com/oracle/java/testlibrary/OutputAnalyzer.java	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/test/testlibrary/com/oracle/java/testlibrary/OutputAnalyzer.java	Wed May 07 19:26:16 2014 -0700
@@ -241,7 +241,38 @@
   }
 
   /**
-   * Verifiy the exit value of the process
+   * Get the captured group of the first string matching the pattern.
+   * stderr is searched before stdout.
+   *
+   * @param pattern The multi-line pattern to match
+   * @param group The group to capture
+   * @return The matched string or null if no match was found
+   */
+  public String firstMatch(String pattern, int group) {
+    Matcher stderrMatcher = Pattern.compile(pattern, Pattern.MULTILINE).matcher(stderr);
+    Matcher stdoutMatcher = Pattern.compile(pattern, Pattern.MULTILINE).matcher(stdout);
+    if (stderrMatcher.find()) {
+      return stderrMatcher.group(group);
+    }
+    if (stdoutMatcher.find()) {
+      return stdoutMatcher.group(group);
+    }
+    return null;
+  }
+
+  /**
+   * Get the first string matching the pattern.
+   * stderr is searched before stdout.
+   *
+   * @param pattern The multi-line pattern to match
+   * @return The matched string or null if no match was found
+   */
+  public String firstMatch(String pattern) {
+    return firstMatch(pattern, 0);
+  }
+
+  /**
+   * Verify the exit value of the process
    *
    * @param expectedExitValue Expected exit value from process
    * @throws RuntimeException If the exit value from the process did not match the expected value
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./hotspot/test/testlibrary/com/oracle/java/testlibrary/TestDynamicVMOption.java	Wed May 07 19:26:16 2014 -0700
@@ -0,0 +1,95 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package com.oracle.java.testlibrary;
+
+/**
+ * Simple class to check writeability, invalid and valid values for concrete VMOption
+ */
+public class TestDynamicVMOption {
+
+    private final String name;
+    private final int value;
+
+    /**
+     * Constructor
+     *
+     * @param name of VM option to test
+     */
+    public TestDynamicVMOption(String name) {
+        this.name = name;
+        this.value = DynamicVMOptionChecker.getIntValue(name);
+        System.out.println(this.name + " = " + this.value);
+    }
+
+    /**
+     * Checks that this value can accept valid percentage values and cannot accept invalid percentage values
+     *
+     * @throws RuntimeException
+     */
+    public void testPercentageValues() {
+        checkInvalidValue(Integer.toString(Integer.MIN_VALUE));
+        checkInvalidValue(Integer.toString(Integer.MAX_VALUE));
+        checkInvalidValue("-10");
+        checkInvalidValue("190");
+    }
+
+    /**
+     * Reads VM option from PlatformMXBean and parse it to integer value
+     *
+     * @return value
+     */
+    public int getIntValue() {
+        return DynamicVMOptionChecker.getIntValue(this.name);
+    }
+
+    /**
+     * Checks that this VM option is dynamically writable
+     *
+     * @throws RuntimeException if option if not writable
+     * @return true
+     */
+    public boolean checkIsWritable() throws RuntimeException {
+        return DynamicVMOptionChecker.checkIsWritable(this.name);
+    }
+
+    /**
+     * Checks that value for this VM option cannot be set
+     *
+     * @param value to check
+     * @throws RuntimeException on error - when expected exception hasn't been thrown
+     */
+    public void checkInvalidValue(String value) {
+        DynamicVMOptionChecker.checkInvalidValue(this.name, value);
+    }
+
+    /**
+     * Checks that value for this VM option can be set
+     *
+     * @param value to check
+     * @throws RuntimeException on error - when value in VM is not equal to origin
+     */
+    public void checkValidValue(String value) {
+        DynamicVMOptionChecker.checkValidValue(this.name, value);
+    }
+
+}
--- ./hotspot/test/testlibrary/whitebox/sun/hotspot/WhiteBox.java	Tue Mar 18 12:31:20 2014 -0700
+++ ./hotspot/test/testlibrary/whitebox/sun/hotspot/WhiteBox.java	Wed May 07 19:26:16 2014 -0700
@@ -78,4 +78,7 @@
   public native void NMTUncommitMemory(long addr, long size);
   public native void NMTReleaseMemory(long addr, long size);
   public native boolean NMTWaitForDataMerge();
+
+  // Compiler
+  public native void    deoptimizeAll();
 }
--- ./jaxp/.hgtags	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/.hgtags	Wed May 07 19:26:26 2014 -0700
@@ -359,6 +359,7 @@
 66363323f14d85d4ab28e883a3323b9d72dea5fd jdk7u40-b42
 c0bd71414ea513f54f23965936a837fca093ac91 jdk7u40-b43
 91bc4534851265291bb3b16452a0968d6909979f jdk7u40-b60
+d9b92749a0f4c8e6c6f4fe11210c2a02d70bae74 jdk7u60-b00
 c500d4ec41ff2117eabfa33e640b6df2f21deb3d jdk7u40-b61
 9e3f8ab9d17be6b1a4a097fcc5bc5412013d3e86 jdk7u40-b62
 1a7e2024963d3a8d6cde209de0967ac43418b82a jdk7u45-b01
@@ -417,3 +418,26 @@
 f3f02e67d867ae25cd4f3b9bc39a4fd17f593126 jdk7u55-b11
 708a1872f5bb8ba58ecc9fcbf4e12e6fa4783998 jdk7u55-b12
 14719f73596f5c90e3f46c0f4312f32e5b105edd jdk7u55-b13
+01f26830f88cf4f10897416fe1f4f372efcdecf5 jdk7u55-b30
+26187a65c765b3177f1b7ff0638259bf66f9ec47 jdk7u55-b14
+5be97f6c25d9eb3ef0a05fc860964cb3d27134b0 jdk7u55-b31
+d9b92749a0f4c8e6c6f4fe11210c2a02d70bae74 jdk7u60-b00
+ad39e88c503948fc4fc01e97c75b6e3c24599d23 jdk7u60-b01
+050986fd54e3ec4515032ee938bc59e86772b6c0 jdk7u60-b02
+359b79d99538d17eeb90927a1e4883fcec31661f jdk7u60-b03
+7215972c2c30d0fa469a459a3e4fcee6bc93991d jdk7u60-b04
+673ea3822e59de18ae5771de7a280c6ae435ef86 jdk7u60-b05
+fd1cb0040a1d05086ca3bf32f10e1efd43f05116 jdk7u60-b06
+cd7c8fa7a057e62e094cdde78dd632de54cedb8c jdk7u60-b07
+b19c0f18b5a508be894aead53617688342690b01 jdk7u60-b08
+4bfece8a5148947d268611cc1b4485e92960064e jdk7u60-b09
+28a6c0b3b22580101bf750383c2e48d34dea2124 jdk7u60-b10
+e57490e0b99917ea8e1da1bb4d0c57fd5b7705f9 jdk7u60-b11
+a9574b35f0af409fa1665aadd9b2997a0f9878dc jdk7u60-b12
+92cf0b5c1c3e9b61d36671d8fb5070716e0f016b jdk7u60-b13
+2814f43a6c73414dcb2b799e1a52d5b44688590d jdk7u60-b14
+10eed57b66336660f71f7524f2283478bdf373dc jdk7u60-b15
+fefd2d5c524b0be78876d9b98d926abda2828e79 jdk7u60-b16
+ba6b0b5dfe5a0f50fac95c488c8a5400ea07d4f8 jdk7u60-b18
+ba6b0b5dfe5a0f50fac95c488c8a5400ea07d4f8 jdk7u60-b17
+581752d32aebea959fec84e8ae692e1f63d2c4a8 jdk7u60-b19
--- ./jaxp/src/com/sun/org/apache/xalan/internal/XalanConstants.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xalan/internal/XalanConstants.java	Wed May 07 19:26:26 2014 -0700
@@ -188,6 +188,19 @@
             ORACLE_JAXP_PROPERTY_PREFIX + "xmlSecurityPropertyManager";
 
     /**
+     * Feature enableExtensionFunctions
+     */
+    public static final String ORACLE_ENABLE_EXTENSION_FUNCTION =
+            ORACLE_JAXP_PROPERTY_PREFIX + "enableExtensionFunctions";
+    public static final String SP_ORACLE_ENABLE_EXTENSION_FUNCTION = "javax.xml.enableExtensionFunctions";
+
+    /**
+     * Values for a feature
+     */
+    public static final String FEATURE_TRUE = "true";
+    public static final String FEATURE_FALSE = "false";
+
+    /**
      * Check if we're in jdk8 or above
      */
     public static final boolean IS_JDK8_OR_ABOVE = isJavaVersionAtLeast(8);
--- ./jaxp/src/com/sun/org/apache/xalan/internal/res/XSLTErrorResources.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xalan/internal/res/XSLTErrorResources.java	Wed May 07 19:26:26 2014 -0700
@@ -471,7 +471,13 @@
 
   // Error messages...
 
-  private static final Object[][] _contents = new Object[][] {
+  /** Get the lookup table for error messages.
+    *
+    * @return The message lookup table.
+    */
+  public Object[][] getContents()
+  {
+      return new Object[][] {
 
   /** Error message ID that has a null message, but takes in a single object.    */
   {"ER0000" , "{0}" },
@@ -1412,13 +1418,6 @@
 
   };
 
-  /** Get the lookup table for error messages.
-   *
-   * @return The int to message lookup table.
-   */
-  public Object[][] getContents()
-  {
-      return _contents;
   }
   // ================= INFRASTRUCTURE ======================
 
--- ./jaxp/src/com/sun/org/apache/xalan/internal/res/XSLTErrorResources_de.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xalan/internal/res/XSLTErrorResources_de.java	Wed May 07 19:26:26 2014 -0700
@@ -471,7 +471,13 @@
 
   // Error messages...
 
-  private static final Object[][] _contents = new Object[][] {
+  /** Get the lookup table for error messages.
+    *
+    * @return The message lookup table.
+    */
+  public Object[][] getContents()
+  {
+      return new Object[][] {
 
   /** Error message ID that has a null message, but takes in a single object.    */
   {"ER0000" , "{0}" },
@@ -1412,13 +1418,6 @@
 
   };
 
-  /** Get the lookup table for error messages.
-   *
-   * @return The int to message lookup table.
-   */
-  public Object[][] getContents()
-  {
-      return _contents;
   }
   // ================= INFRASTRUCTURE ======================
 
--- ./jaxp/src/com/sun/org/apache/xalan/internal/res/XSLTErrorResources_es.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xalan/internal/res/XSLTErrorResources_es.java	Wed May 07 19:26:26 2014 -0700
@@ -471,7 +471,13 @@
 
   // Error messages...
 
-  private static final Object[][] _contents = new Object[][] {
+  /** Get the lookup table for error messages.
+    *
+    * @return The message lookup table.
+    */
+  public Object[][] getContents()
+  {
+      return new Object[][] {
 
   /** Error message ID that has a null message, but takes in a single object.    */
   {"ER0000" , "{0}" },
@@ -1412,13 +1418,6 @@
 
   };
 
-  /** Get the lookup table for error messages.
-   *
-   * @return The int to message lookup table.
-   */
-  public Object[][] getContents()
-  {
-      return _contents;
   }
   // ================= INFRASTRUCTURE ======================
 
--- ./jaxp/src/com/sun/org/apache/xalan/internal/res/XSLTErrorResources_fr.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xalan/internal/res/XSLTErrorResources_fr.java	Wed May 07 19:26:26 2014 -0700
@@ -471,7 +471,13 @@
 
   // Error messages...
 
-  private static final Object[][] _contents = new Object[][] {
+  /** Get the lookup table for error messages.
+    *
+    * @return The message lookup table.
+    */
+  public Object[][] getContents()
+  {
+      return new Object[][] {
 
   /** Error message ID that has a null message, but takes in a single object.    */
   {"ER0000" , "{0}" },
@@ -1412,13 +1418,6 @@
 
   };
 
-  /** Get the lookup table for error messages.
-   *
-   * @return The int to message lookup table.
-   */
-  public Object[][] getContents()
-  {
-      return _contents;
   }
   // ================= INFRASTRUCTURE ======================
 
--- ./jaxp/src/com/sun/org/apache/xalan/internal/res/XSLTErrorResources_it.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xalan/internal/res/XSLTErrorResources_it.java	Wed May 07 19:26:26 2014 -0700
@@ -471,7 +471,13 @@
 
   // Error messages...
 
-  private static final Object[][] _contents = new Object[][] {
+  /** Get the lookup table for error messages.
+    *
+    * @return The message lookup table.
+    */
+  public Object[][] getContents()
+  {
+      return new Object[][] {
 
   /** Error message ID that has a null message, but takes in a single object.    */
   {"ER0000" , "{0}" },
@@ -1412,13 +1418,6 @@
 
   };
 
-  /** Get the lookup table for error messages.
-   *
-   * @return The int to message lookup table.
-   */
-  public Object[][] getContents()
-  {
-      return _contents;
   }
   // ================= INFRASTRUCTURE ======================
 
--- ./jaxp/src/com/sun/org/apache/xalan/internal/res/XSLTErrorResources_ja.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xalan/internal/res/XSLTErrorResources_ja.java	Wed May 07 19:26:26 2014 -0700
@@ -471,7 +471,13 @@
 
   // Error messages...
 
-  private static final Object[][] _contents = new Object[][] {
+  /** Get the lookup table for error messages.
+    *
+    * @return The message lookup table.
+    */
+  public Object[][] getContents()
+  {
+      return new Object[][] {
 
   /** Error message ID that has a null message, but takes in a single object.    */
   {"ER0000" , "{0}" },
@@ -1412,13 +1418,6 @@
 
   };
 
-  /** Get the lookup table for error messages.
-   *
-   * @return The int to message lookup table.
-   */
-  public Object[][] getContents()
-  {
-      return _contents;
   }
   // ================= INFRASTRUCTURE ======================
 
--- ./jaxp/src/com/sun/org/apache/xalan/internal/res/XSLTErrorResources_ko.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xalan/internal/res/XSLTErrorResources_ko.java	Wed May 07 19:26:26 2014 -0700
@@ -471,7 +471,13 @@
 
   // Error messages...
 
-  private static final Object[][] _contents = new Object[][] {
+  /** Get the lookup table for error messages.
+    *
+    * @return The message lookup table.
+    */
+  public Object[][] getContents()
+  {
+      return new Object[][] {
 
   /** Error message ID that has a null message, but takes in a single object.    */
   {"ER0000" , "{0}" },
@@ -1412,13 +1418,6 @@
 
   };
 
-  /** Get the lookup table for error messages.
-   *
-   * @return The int to message lookup table.
-   */
-  public Object[][] getContents()
-  {
-      return _contents;
   }
   // ================= INFRASTRUCTURE ======================
 
--- ./jaxp/src/com/sun/org/apache/xalan/internal/res/XSLTErrorResources_pt_BR.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xalan/internal/res/XSLTErrorResources_pt_BR.java	Wed May 07 19:26:26 2014 -0700
@@ -472,7 +472,13 @@
 
   // Error messages...
 
-  private static final Object[][] _contents = new Object[][] {
+  /** Get the lookup table for error messages.
+    *
+    * @return The message lookup table.
+    */
+  public Object[][] getContents()
+  {
+      return new Object[][] {
 
   /** Error message ID that has a null message, but takes in a single object.    */
   {"ER0000" , "{0}" },
@@ -1413,13 +1419,6 @@
 
   };
 
-  /** Get the lookup table for error messages.
-   *
-   * @return The int to message lookup table.
-   */
-  public Object[][] getContents()
-  {
-      return _contents;
   }
   // ================= INFRASTRUCTURE ======================
 
--- ./jaxp/src/com/sun/org/apache/xalan/internal/res/XSLTErrorResources_sv.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xalan/internal/res/XSLTErrorResources_sv.java	Wed May 07 19:26:26 2014 -0700
@@ -471,7 +471,13 @@
 
   // Error messages...
 
-  private static final Object[][] _contents = new Object[][] {
+  /** Get the lookup table for error messages.
+    *
+    * @return The message lookup table.
+    */
+  public Object[][] getContents()
+  {
+      return new Object[][] {
 
   /** Error message ID that has a null message, but takes in a single object.    */
   {"ER0000" , "{0}" },
@@ -1412,13 +1418,6 @@
 
   };
 
-  /** Get the lookup table for error messages.
-   *
-   * @return The int to message lookup table.
-   */
-  public Object[][] getContents()
-  {
-      return _contents;
   }
   // ================= INFRASTRUCTURE ======================
 
--- ./jaxp/src/com/sun/org/apache/xalan/internal/res/XSLTErrorResources_zh_CN.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xalan/internal/res/XSLTErrorResources_zh_CN.java	Wed May 07 19:26:26 2014 -0700
@@ -471,7 +471,13 @@
 
   // Error messages...
 
-  private static final Object[][] _contents = new Object[][] {
+  /** Get the lookup table for error messages.
+    *
+    * @return The message lookup table.
+    */
+  public Object[][] getContents()
+  {
+      return new Object[][] {
 
   /** Error message ID that has a null message, but takes in a single object.    */
   {"ER0000" , "{0}" },
@@ -1412,13 +1418,6 @@
 
   };
 
-  /** Get the lookup table for error messages.
-   *
-   * @return The int to message lookup table.
-   */
-  public Object[][] getContents()
-  {
-      return _contents;
   }
   // ================= INFRASTRUCTURE ======================
 
--- ./jaxp/src/com/sun/org/apache/xalan/internal/res/XSLTErrorResources_zh_TW.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xalan/internal/res/XSLTErrorResources_zh_TW.java	Wed May 07 19:26:26 2014 -0700
@@ -471,7 +471,13 @@
 
   // Error messages...
 
-  private static final Object[][] _contents = new Object[][] {
+  /** Get the lookup table for error messages.
+    *
+    * @return The message lookup table.
+    */
+  public Object[][] getContents()
+  {
+      return new Object[][] {
 
   /** Error message ID that has a null message, but takes in a single object.    */
   {"ER0000" , "{0}" },
@@ -1412,13 +1418,6 @@
 
   };
 
-  /** Get the lookup table for error messages.
-   *
-   * @return The int to message lookup table.
-   */
-  public Object[][] getContents()
-  {
-      return _contents;
   }
   // ================= INFRASTRUCTURE ======================
 
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jaxp/src/com/sun/org/apache/xalan/internal/utils/FeatureManager.java	Wed May 07 19:26:26 2014 -0700
@@ -0,0 +1,124 @@
+/*
+ * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.sun.org.apache.xalan.internal.utils;
+
+
+import com.sun.org.apache.xalan.internal.XalanConstants;
+
+/**
+ * This class manages security related properties
+ *
+ */
+public final class FeatureManager extends FeaturePropertyBase {
+
+    /**
+     * States of the settings of a property, in the order: default value, value
+     * set by FEATURE_SECURE_PROCESSING, jaxp.properties file, jaxp system
+     * properties, and jaxp api properties
+     */
+    public static enum State {
+        //this order reflects the overriding order
+        DEFAULT, FSP, JAXPDOTPROPERTIES, SYSTEMPROPERTY, APIPROPERTY
+    }
+
+    /**
+     * Xalan Features
+     */
+    public static enum Feature {
+        ORACLE_ENABLE_EXTENSION_FUNCTION(XalanConstants.ORACLE_ENABLE_EXTENSION_FUNCTION,
+                "true");
+
+        final String name;
+        final String defaultValue;
+
+        Feature(String name, String value) {
+            this.name = name;
+            this.defaultValue = value;
+        }
+
+        public boolean equalsName(String propertyName) {
+            return (propertyName == null) ? false : name.equals(propertyName);
+        }
+
+        String defaultValue() {
+            return defaultValue;
+        }
+    }
+
+    /**
+     * Default constructor. Establishes default values
+     */
+    public FeatureManager() {
+        values = new String[Feature.values().length];
+        for (Feature feature : Feature.values()) {
+            values[feature.ordinal()] = feature.defaultValue();
+        }
+        //read system properties or jaxp.properties
+        readSystemProperties();
+    }
+
+
+    /**
+     * Check if the feature is enabled
+     * @param feature name of the feature
+     * @return true if enabled, false otherwise
+     */
+    public boolean isFeatureEnabled(Feature feature) {
+        return Boolean.parseBoolean(values[feature.ordinal()]);
+    }
+
+    /**
+     * Check if the feature is enabled
+     * @param propertyName name of the feature
+     * @return true if enabled, false otherwise
+     */
+    public boolean isFeatureEnabled(String propertyName) {
+        return Boolean.parseBoolean(values[getIndex(propertyName)]);
+    }
+
+    /**
+     * Get the index by property name
+     * @param propertyName property name
+     * @return the index of the property if found; return -1 if not
+     */
+    public int getIndex(String propertyName){
+        for (Feature feature : Feature.values()) {
+            if (feature.equalsName(propertyName)) {
+                return feature.ordinal();
+            }
+        }
+        return -1;
+    }
+
+    /**
+     * Read from system properties, or those in jaxp.properties
+     */
+    private void readSystemProperties() {
+        getSystemProperty(Feature.ORACLE_ENABLE_EXTENSION_FUNCTION,
+                XalanConstants.SP_ORACLE_ENABLE_EXTENSION_FUNCTION);
+    }
+
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jaxp/src/com/sun/org/apache/xalan/internal/utils/FeaturePropertyBase.java	Wed May 07 19:26:26 2014 -0700
@@ -0,0 +1,215 @@
+/*
+ * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.sun.org.apache.xalan.internal.utils;
+
+import com.sun.org.apache.xalan.internal.XalanConstants;
+
+/**
+ * This is the base class for features and properties
+ *
+ */
+public abstract class FeaturePropertyBase {
+
+    /**
+     * States of the settings of a property, in the order: default value, value
+     * set by FEATURE_SECURE_PROCESSING, jaxp.properties file, jaxp system
+     * properties, and jaxp api properties
+     */
+    public static enum State {
+        //this order reflects the overriding order
+        DEFAULT, FSP, JAXPDOTPROPERTIES, SYSTEMPROPERTY, APIPROPERTY
+    }
+
+
+    /**
+     * Values of the properties as defined in enum Properties
+     */
+    String[] values = null;
+    /**
+     * States of the settings for each property in Properties above
+     */
+    State[] states = {State.DEFAULT, State.DEFAULT};
+
+
+    /**
+     * Set the value for a specific property.
+     *
+     * @param property the property
+     * @param state the state of the property
+     * @param value the value of the property
+     */
+    public void setValue(Enum property, State state, String value) {
+        //only update if it shall override
+        if (state.compareTo(states[property.ordinal()]) >= 0) {
+            values[property.ordinal()] = value;
+            states[property.ordinal()] = state;
+        }
+    }
+
+    /**
+     * Set the value of a property by its index
+     * @param index the index of the property
+     * @param state the state of the property
+     * @param value the value of the property
+     */
+    public void setValue(int index, State state, String value) {
+        //only update if it shall override
+        if (state.compareTo(states[index]) >= 0) {
+            values[index] = value;
+            states[index] = state;
+        }
+    }
+
+     /**
+     * Set value by property name and state
+     * @param propertyName property name
+     * @param state the state of the property
+     * @param value the value of the property
+     * @return true if the property is managed by the security property manager;
+     *         false if otherwise.
+     */
+    public boolean setValue(String propertyName, State state, Object value) {
+        int index = getIndex(propertyName);
+        if (index > -1) {
+            setValue(index, state, (String)value);
+            return true;
+        }
+        return false;
+    }
+
+     /**
+     * Set value by property name and state
+     * @param propertyName property name
+     * @param state the state of the property
+     * @param value the value of the property
+     * @return true if the property is managed by the security property manager;
+     *         false if otherwise.
+     */
+    public boolean setValue(String propertyName, State state, boolean value) {
+        int index = getIndex(propertyName);
+        if (index > -1) {
+            if (value) {
+                setValue(index, state, XalanConstants.FEATURE_TRUE);
+            } else {
+                setValue(index, state, XalanConstants.FEATURE_FALSE);
+            }
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * Return the value of the specified property
+     *
+     * @param property the property
+     * @return the value of the property
+     */
+    public String getValue(Enum property) {
+        return values[property.ordinal()];
+    }
+
+    /**
+     * Return the value of the specified property
+     *
+     * @param property the property
+     * @return the value of the property
+     */
+    public String getValue(String property) {
+        int index = getIndex(property);
+        if (index > -1) {
+            return getValueByIndex(index);
+        }
+        return null;
+    }
+
+    /**
+     * Return the value of the specified property.
+     *
+     * @param propertyName the property name
+     * @return the value of the property as a string. If a property is managed
+     * by this manager, its value shall not be null.
+     */
+    public String getValueAsString(String propertyName) {
+        int index = getIndex(propertyName);
+        if (index > -1) {
+            return getValueByIndex(index);
+        }
+
+        return null;
+    }
+
+    /**
+     * Return the value of a property by its ordinal
+     * @param index the index of a property
+     * @return value of a property
+     */
+    public String getValueByIndex(int index) {
+        return values[index];
+    }
+
+    /**
+     * Get the index by property name
+     * @param propertyName property name
+     * @return the index of the property if found; return -1 if not
+     */
+    public abstract int getIndex(String propertyName);
+
+    public <E extends Enum<E>> int getIndex(Class<E> property, String propertyName) {
+        for (Enum<E> enumItem : property.getEnumConstants()) {
+            if (enumItem.toString().equals(propertyName)) {
+                //internally, ordinal is used as index
+                return enumItem.ordinal();
+            }
+        }
+        return -1;
+    };
+
+
+    /**
+     * Read from system properties, or those in jaxp.properties
+     *
+     * @param property the property
+     * @param systemProperty the name of the system property
+     */
+    void getSystemProperty(Enum property, String systemProperty) {
+        try {
+            String value = SecuritySupport.getSystemProperty(systemProperty);
+            if (value != null) {
+                values[property.ordinal()] = value;
+                states[property.ordinal()] = State.SYSTEMPROPERTY;
+                return;
+            }
+
+            value = SecuritySupport.readJAXPProperty(systemProperty);
+            if (value != null) {
+                values[property.ordinal()] = value;
+                states[property.ordinal()] = State.JAXPDOTPROPERTIES;
+            }
+        } catch (NumberFormatException e) {
+            //invalid setting ignored
+        }
+    }
+}
--- ./jaxp/src/com/sun/org/apache/xalan/internal/utils/XMLSecurityManager.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xalan/internal/utils/XMLSecurityManager.java	Wed May 07 19:26:26 2014 -0700
@@ -1,42 +1,28 @@
 /*
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
- * Copyright (c) 2013 Oracle and/or its affiliates. All rights reserved.
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
  *
- * The contents of this file are subject to the terms of either the GNU
- * General Public License Version 2 only ("GPL") or the Common Development
- * and Distribution License("CDDL") (collectively, the "License").  You
- * may not use this file except in compliance with the License.  You can
- * obtain a copy of the License at
- * https://glassfish.dev.java.net/public/CDDL+GPL_1_1.html
- * or packager/legal/LICENSE.txt.  See the License for the specific
- * language governing permissions and limitations under the License.
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
  *
- * When distributing the software, include this License Header Notice in each
- * file and include the License file at packager/legal/LICENSE.txt.
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  *
- * GPL Classpath Exception:
- * Oracle designates this particular file as subject to the "Classpath"
- * exception as provided by Oracle in the GPL Version 2 section of the License
- * file that accompanied this code.
- *
- * Modifications:
- * If applicable, add the following below the License Header, with the fields
- * enclosed by brackets [] replaced by your own identifying information:
- * "Portions Copyright [year] [name of copyright owner]"
- *
- * Contributor(s):
- * If you wish your version of this file to be governed by only the CDDL or
- * only the GPL Version 2, indicate your decision by adding "[Contributor]
- * elects to include this software in this distribution under the [CDDL or GPL
- * Version 2] license."  If you don't indicate a single choice of license, a
- * recipient has the option to distribute your version of this file under
- * either the CDDL, the GPL Version 2 or to extend the choice of license to
- * its licensees as provided above.  However, if you add GPL Version 2 code
- * and therefore, elected the GPL Version 2 license, then the option applies
- * only if the new code is made subject to such option by the copyright
- * holder.
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
  */
+
 package com.sun.org.apache.xalan.internal.utils;
 
 import com.sun.org.apache.xalan.internal.XalanConstants;
--- ./jaxp/src/com/sun/org/apache/xalan/internal/utils/XMLSecurityPropertyManager.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xalan/internal/utils/XMLSecurityPropertyManager.java	Wed May 07 19:26:26 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2013 Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -33,20 +33,10 @@
  * This class manages security related properties
  *
  */
-public final class XMLSecurityPropertyManager {
+public final class XMLSecurityPropertyManager extends FeaturePropertyBase {
 
     /**
-     * States of the settings of a property, in the order: default value, value
-     * set by FEATURE_SECURE_PROCESSING, jaxp.properties file, jaxp system
-     * properties, and jaxp api properties
-     */
-    public static enum State {
-        //this order reflects the overriding order
-        DEFAULT, FSP, JAXPDOTPROPERTIES, SYSTEMPROPERTY, APIPROPERTY
-    }
-
-    /**
-     * Limits managed by the security manager
+     * Properties managed by the security property manager
      */
     public static enum Property {
         ACCESS_EXTERNAL_DTD(XMLConstants.ACCESS_EXTERNAL_DTD,
@@ -73,15 +63,6 @@
 
 
     /**
-     * Values of the properties as defined in enum Properties
-     */
-    private final String[] values;
-    /**
-     * States of the settings for each property in Properties above
-     */
-    private State[] states = {State.DEFAULT, State.DEFAULT};
-
-    /**
      * Default constructor. Establishes default values
      */
     public XMLSecurityPropertyManager() {
@@ -94,86 +75,6 @@
     }
 
     /**
-     * Set limit by property name and state
-     * @param propertyName property name
-     * @param state the state of the property
-     * @param value the value of the property
-     * @return true if the property is managed by the security property manager;
-     *         false if otherwise.
-     */
-    public boolean setValue(String propertyName, State state, Object value) {
-        int index = getIndex(propertyName);
-        if (index > -1) {
-            setValue(index, state, (String)value);
-            return true;
-        }
-        return false;
-    }
-
-    /**
-     * Set the value for a specific property.
-     *
-     * @param property the property
-     * @param state the state of the property
-     * @param value the value of the property
-     */
-    public void setValue(Property property, State state, String value) {
-        //only update if it shall override
-        if (state.compareTo(states[property.ordinal()]) >= 0) {
-            values[property.ordinal()] = value;
-            states[property.ordinal()] = state;
-        }
-    }
-
-    /**
-     * Set the value of a property by its index
-     * @param index the index of the property
-     * @param state the state of the property
-     * @param value the value of the property
-     */
-    public void setValue(int index, State state, String value) {
-        //only update if it shall override
-        if (state.compareTo(states[index]) >= 0) {
-            values[index] = value;
-            states[index] = state;
-        }
-    }
-
-    /**
-     * Return the value of the specified property
-     *
-     * @param propertyName the property name
-     * @return the value of the property as a string
-     */
-    public String getValue(String propertyName) {
-        int index = getIndex(propertyName);
-        if (index > -1) {
-            return getValueByIndex(index);
-        }
-
-        return null;
-    }
-
-    /**
-     * Return the value of the specified property
-     *
-     * @param property the property
-     * @return the value of the property
-     */
-    public String getValue(Property property) {
-        return values[property.ordinal()];
-    }
-
-    /**
-     * Return the value of a property by its ordinal
-     * @param index the index of a property
-     * @return value of a property
-     */
-    public String getValueByIndex(int index) {
-        return values[index];
-    }
-
-    /**
      * Get the index by property name
      * @param propertyName property name
      * @return the index of the property if found; return -1 if not
@@ -198,28 +99,4 @@
                 XalanConstants.SP_ACCESS_EXTERNAL_STYLESHEET);
     }
 
-    /**
-     * Read from system properties, or those in jaxp.properties
-     *
-     * @param property the property
-     * @param systemProperty the name of the system property
-     */
-    private void getSystemProperty(Property property, String systemProperty) {
-        try {
-            String value = SecuritySupport.getSystemProperty(systemProperty);
-            if (value != null) {
-                values[property.ordinal()] = value;
-                states[property.ordinal()] = State.SYSTEMPROPERTY;
-                return;
-            }
-
-            value = SecuritySupport.readJAXPProperty(systemProperty);
-            if (value != null) {
-                values[property.ordinal()] = value;
-                states[property.ordinal()] = State.JAXPDOTPROPERTIES;
-            }
-        } catch (NumberFormatException e) {
-            //invalid setting ignored
-        }
-    }
 }
--- ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/cmdline/Compile.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/cmdline/Compile.java	Wed May 07 19:26:26 2014 -0700
@@ -23,6 +23,7 @@
 
 package com.sun.org.apache.xalan.internal.xsltc.cmdline;
 
+import com.sun.org.apache.xalan.internal.utils.FeatureManager;
 import java.io.File;
 import java.net.URL;
 import java.util.Vector;
@@ -77,7 +78,7 @@
             final GetOpt getopt = new GetOpt(args, "o:d:j:p:uxhsinv");
             if (args.length < 1) printUsage();
 
-            final XSLTC xsltc = new XSLTC(true);
+            final XSLTC xsltc = new XSLTC(true, new FeatureManager());
             xsltc.init();
 
             int c;
--- ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/FunctionCall.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/FunctionCall.java	Wed May 07 19:26:26 2014 -0700
@@ -42,6 +42,7 @@
 import com.sun.org.apache.bcel.internal.generic.LocalVariableGen;
 import com.sun.org.apache.bcel.internal.generic.NEW;
 import com.sun.org.apache.bcel.internal.generic.PUSH;
+import com.sun.org.apache.xalan.internal.utils.FeatureManager;
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.BooleanType;
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.ClassGenerator;
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.ErrorMsg;
@@ -717,6 +718,8 @@
         final ConstantPoolGen cpg = classGen.getConstantPool();
         final InstructionList il = methodGen.getInstructionList();
         final boolean isSecureProcessing = classGen.getParser().getXSLTC().isSecureProcessing();
+        final boolean isExtensionFunctionEnabled = classGen.getParser().getXSLTC()
+                .getFeature(FeatureManager.Feature.ORACLE_ENABLE_EXTENSION_FUNCTION);
         int index;
 
         // Translate calls to methods in the BasisLibrary
@@ -760,7 +763,7 @@
             il.append(new INVOKESTATIC(index));
         }
         else if (_isExtConstructor) {
-            if (isSecureProcessing)
+            if (isSecureProcessing && !isExtensionFunctionEnabled)
                 translateUnallowedExtension(cpg, il);
 
             final String clazz =
@@ -822,7 +825,7 @@
         }
         // Invoke function calls that are handled in separate classes
         else {
-            if (isSecureProcessing)
+            if (isSecureProcessing && !isExtensionFunctionEnabled)
                 translateUnallowedExtension(cpg, il);
 
             final String clazz = _chosenMethod.getDeclaringClass().getName();
--- ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/XSLTC.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/XSLTC.java	Wed May 07 19:26:26 2014 -0700
@@ -43,6 +43,8 @@
 
 import com.sun.org.apache.bcel.internal.classfile.JavaClass;
 import com.sun.org.apache.xalan.internal.XalanConstants;
+import com.sun.org.apache.xalan.internal.utils.FeatureManager;
+import com.sun.org.apache.xalan.internal.utils.FeatureManager.Feature;
 import com.sun.org.apache.xalan.internal.utils.SecuritySupport;
 import com.sun.org.apache.xalan.internal.utils.XMLSecurityManager;
 import com.sun.org.apache.xalan.internal.xsltc.compiler.util.ErrorMsg;
@@ -148,11 +150,14 @@
 
     private XMLSecurityManager _xmlSecurityManager;
 
+    private final FeatureManager _featureManager;
+
     /**
      * XSLTC compiler constructor
      */
-    public XSLTC(boolean useServicesMechanism) {
+    public XSLTC(boolean useServicesMechanism, FeatureManager featureManager) {
         _parser = new Parser(this, useServicesMechanism);
+        _featureManager = featureManager;
     }
 
     /**
@@ -182,6 +187,15 @@
         _useServicesMechanism = flag;
     }
 
+     /**
+     * Return the value of the specified feature
+     * @param name name of the feature
+     * @return true if the feature is enabled, false otherwise
+     */
+    public boolean getFeature(Feature name) {
+        return _featureManager.isFeatureEnabled(name);
+    }
+
     /**
      * Return allowed protocols for accessing external stylesheet.
      */
--- ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/util/ErrorMessages.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/util/ErrorMessages.java	Wed May 07 19:26:26 2014 -0700
@@ -90,7 +90,13 @@
  */
 
     // These message should be read from a locale-specific resource bundle
-    private static final Object[][] _contents =  new Object[][] {
+    /** Get the lookup table for error messages.
+     *
+     * @return The message lookup table.
+     */
+    public Object[][] getContents()
+    {
+      return new Object[][] {
         {ErrorMsg.MULTIPLE_STYLESHEET_ERR,
         "More than one stylesheet defined in the same file."},
 
@@ -1012,12 +1018,5 @@
 
     };
 
-    /** Get the lookup table for error messages.
-     *
-     * @return The message lookup table.
-     */
-    public Object[][] getContents()
-    {
-        return _contents;
     }
 }
--- ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/util/ErrorMessages_ca.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/util/ErrorMessages_ca.java	Wed May 07 19:26:26 2014 -0700
@@ -90,7 +90,13 @@
  */
 
     // These message should be read from a locale-specific resource bundle
-    private static final Object[][] _contents = new Object[][] {
+    /** Get the lookup table for error messages.
+     *
+     * @return The message lookup table.
+     */
+    public Object[][] getContents()
+    {
+      return new Object[][] {
         {ErrorMsg.MULTIPLE_STYLESHEET_ERR,
         "S'ha definit m\u00e9s d'un full d'estils en el mateix fitxer."},
 
@@ -853,12 +859,5 @@
         "FEATURE_SECURE_PROCESSING: Cannot set the feature to false when security manager is present."}
     };
 
-    /** Get the lookup table for error messages.
-     *
-     * @return The message lookup table.
-     */
-    public Object[][] getContents()
-    {
-      return _contents;
     }
 }
--- ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/util/ErrorMessages_cs.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/util/ErrorMessages_cs.java	Wed May 07 19:26:26 2014 -0700
@@ -90,7 +90,13 @@
  */
 
     // These message should be read from a locale-specific resource bundle
-    private static final Object[][] _contents = new Object[][] {
+    /** Get the lookup table for error messages.
+     *
+     * @return The message lookup table.
+     */
+    public Object[][] getContents()
+    {
+      return new Object[][] {
         {ErrorMsg.MULTIPLE_STYLESHEET_ERR,
         "V\u00edce ne\u017e jedna p\u0159edloha stylu je definov\u00e1na ve stejn\u00e9m souboru."},
 
@@ -853,12 +859,5 @@
         "FEATURE_SECURE_PROCESSING: Cannot set the feature to false when security manager is present."}
     };
 
-    /** Get the lookup table for error messages.
-     *
-     * @return The message lookup table.
-     */
-    public Object[][] getContents()
-    {
-      return _contents;
     }
 }
--- ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/util/ErrorMessages_de.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/util/ErrorMessages_de.java	Wed May 07 19:26:26 2014 -0700
@@ -90,7 +90,13 @@
  */
 
     // These message should be read from a locale-specific resource bundle
-    private static final Object[][] _contents =  new Object[][] {
+    /** Get the lookup table for error messages.
+     *
+     * @return The message lookup table.
+     */
+    public Object[][] getContents()
+    {
+      return new Object[][] {
         {ErrorMsg.MULTIPLE_STYLESHEET_ERR,
         "Mehrere Stylesheets in derselben Datei definiert."},
 
@@ -913,12 +919,5 @@
         "FEATURE_SECURE_PROCESSING: Feature kann nicht auf \"false\" gesetzt werden, wenn Security Manager vorhanden ist."}
     };
 
-    /** Get the lookup table for error messages.
-     *
-     * @return The message lookup table.
-     */
-    public Object[][] getContents()
-    {
-        return _contents;
     }
 }
--- ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/util/ErrorMessages_es.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/util/ErrorMessages_es.java	Wed May 07 19:26:26 2014 -0700
@@ -90,7 +90,13 @@
  */
 
     // These message should be read from a locale-specific resource bundle
-    private static final Object[][] _contents =  new Object[][] {
+    /** Get the lookup table for error messages.
+     *
+     * @return The message lookup table.
+     */
+    public Object[][] getContents()
+    {
+      return new Object[][] {
         {ErrorMsg.MULTIPLE_STYLESHEET_ERR,
         "Se ha definido m\u00E1s de una hoja de estilo en el mismo archivo."},
 
@@ -913,12 +919,5 @@
         "FEATURE_SECURE_PROCESSING: no se puede definir la funci\u00F3n en false cuando est\u00E1 presente el gestor de seguridad."}
     };
 
-    /** Get the lookup table for error messages.
-     *
-     * @return The message lookup table.
-     */
-    public Object[][] getContents()
-    {
-        return _contents;
     }
 }
--- ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/util/ErrorMessages_fr.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/util/ErrorMessages_fr.java	Wed May 07 19:26:26 2014 -0700
@@ -90,7 +90,13 @@
  */
 
     // These message should be read from a locale-specific resource bundle
-    private static final Object[][] _contents =  new Object[][] {
+    /** Get the lookup table for error messages.
+     *
+     * @return The message lookup table.
+     */
+    public Object[][] getContents()
+    {
+      return new Object[][] {
         {ErrorMsg.MULTIPLE_STYLESHEET_ERR,
         "Plusieurs feuilles de style d\u00E9finies dans le m\u00EAme fichier."},
 
@@ -913,12 +919,5 @@
         "FEATURE_SECURE_PROCESSING : impossible de d\u00E9finir la fonctionnalit\u00E9 sur False en pr\u00E9sence du gestionnaire de s\u00E9curit\u00E9."}
     };
 
-    /** Get the lookup table for error messages.
-     *
-     * @return The message lookup table.
-     */
-    public Object[][] getContents()
-    {
-        return _contents;
     }
 }
--- ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/util/ErrorMessages_it.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/util/ErrorMessages_it.java	Wed May 07 19:26:26 2014 -0700
@@ -90,7 +90,13 @@
  */
 
     // These message should be read from a locale-specific resource bundle
-    private static final Object[][] _contents =  new Object[][] {
+    /** Get the lookup table for error messages.
+     *
+     * @return The message lookup table.
+     */
+    public Object[][] getContents()
+    {
+      return new Object[][] {
         {ErrorMsg.MULTIPLE_STYLESHEET_ERR,
         "Sono stati definiti pi\u00F9 fogli di stile nello stesso file."},
 
@@ -913,12 +919,5 @@
         "FEATURE_SECURE_PROCESSING: impossibile impostare la funzione su false se \u00E8 presente Security Manager."}
     };
 
-    /** Get the lookup table for error messages.
-     *
-     * @return The message lookup table.
-     */
-    public Object[][] getContents()
-    {
-        return _contents;
     }
 }
--- ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/util/ErrorMessages_ja.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/util/ErrorMessages_ja.java	Wed May 07 19:26:26 2014 -0700
@@ -90,7 +90,13 @@
  */
 
     // These message should be read from a locale-specific resource bundle
-    private static final Object[][] _contents =  new Object[][] {
+    /** Get the lookup table for error messages.
+     *
+     * @return The message lookup table.
+     */
+    public Object[][] getContents()
+    {
+      return new Object[][] {
         {ErrorMsg.MULTIPLE_STYLESHEET_ERR,
         "\u540C\u3058\u30D5\u30A1\u30A4\u30EB\u306B\u8907\u6570\u306E\u30B9\u30BF\u30A4\u30EB\u30B7\u30FC\u30C8\u304C\u5B9A\u7FA9\u3055\u308C\u3066\u3044\u307E\u3059\u3002"},
 
@@ -913,12 +919,5 @@
         "FEATURE_SECURE_PROCESSING: \u30BB\u30AD\u30E5\u30EA\u30C6\u30A3\u30FB\u30DE\u30CD\u30FC\u30B8\u30E3\u304C\u5B58\u5728\u3059\u308B\u3068\u304D\u3001\u6A5F\u80FD\u3092false\u306B\u8A2D\u5B9A\u3067\u304D\u307E\u305B\u3093\u3002"}
     };
 
-    /** Get the lookup table for error messages.
-     *
-     * @return The message lookup table.
-     */
-    public Object[][] getContents()
-    {
-        return _contents;
     }
 }
--- ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/util/ErrorMessages_ko.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/util/ErrorMessages_ko.java	Wed May 07 19:26:26 2014 -0700
@@ -90,7 +90,13 @@
  */
 
     // These message should be read from a locale-specific resource bundle
-    private static final Object[][] _contents =  new Object[][] {
+    /** Get the lookup table for error messages.
+     *
+     * @return The message lookup table.
+     */
+    public Object[][] getContents()
+    {
+      return new Object[][] {
         {ErrorMsg.MULTIPLE_STYLESHEET_ERR,
         "\uB3D9\uC77C\uD55C \uD30C\uC77C\uC5D0 \uC2A4\uD0C0\uC77C\uC2DC\uD2B8\uAC00 \uB450 \uAC1C \uC774\uC0C1 \uC815\uC758\uB418\uC5C8\uC2B5\uB2C8\uB2E4."},
 
@@ -913,12 +919,5 @@
         "FEATURE_SECURE_PROCESSING: \uBCF4\uC548 \uAD00\uB9AC\uC790\uAC00 \uC788\uC744 \uACBD\uC6B0 \uAE30\uB2A5\uC744 false\uB85C \uC124\uC815\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4."}
     };
 
-    /** Get the lookup table for error messages.
-     *
-     * @return The message lookup table.
-     */
-    public Object[][] getContents()
-    {
-        return _contents;
     }
 }
--- ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/util/ErrorMessages_pt_BR.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/util/ErrorMessages_pt_BR.java	Wed May 07 19:26:26 2014 -0700
@@ -90,7 +90,13 @@
  */
 
     // These message should be read from a locale-specific resource bundle
-    private static final Object[][] _contents =  new Object[][] {
+    /** Get the lookup table for error messages.
+     *
+     * @return The message lookup table.
+     */
+    public Object[][] getContents()
+    {
+      return new Object[][] {
         {ErrorMsg.MULTIPLE_STYLESHEET_ERR,
         "Mais de uma folha de estilos definida no mesmo arquivo."},
 
@@ -913,12 +919,5 @@
         "FEATURE_SECURE_PROCESSING: N\u00E3o \u00E9 poss\u00EDvel definir o recurso como falso quando o gerenciador de seguran\u00E7a est\u00E1 presente."}
     };
 
-    /** Get the lookup table for error messages.
-     *
-     * @return The message lookup table.
-     */
-    public Object[][] getContents()
-    {
-        return _contents;
     }
 }
--- ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/util/ErrorMessages_sk.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/util/ErrorMessages_sk.java	Wed May 07 19:26:26 2014 -0700
@@ -90,7 +90,13 @@
  */
 
     // These message should be read from a locale-specific resource bundle
-    private static final Object[][] _contents =  new Object[][] {
+    /** Get the lookup table for error messages.
+     *
+     * @return The message lookup table.
+     */
+    public Object[][] getContents()
+    {
+      return new Object[][] {
         {ErrorMsg.MULTIPLE_STYLESHEET_ERR,
         "Viac ne\u017e jeden \u0161t\u00fdl dokumentu bol definovan\u00fd v rovnakom s\u00fabore."},
 
@@ -853,12 +859,5 @@
         "FEATURE_SECURE_PROCESSING: Cannot set the feature to false when security manager is present."}
     };
 
-    /** Get the lookup table for error messages.
-     *
-     * @return The message lookup table.
-     */
-    public Object[][] getContents()
-    {
-      return _contents;
     }
 }
--- ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/util/ErrorMessages_sv.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/util/ErrorMessages_sv.java	Wed May 07 19:26:26 2014 -0700
@@ -90,7 +90,13 @@
  */
 
     // These message should be read from a locale-specific resource bundle
-    private static final Object[][] _contents =  new Object[][] {
+    /** Get the lookup table for error messages.
+     *
+     * @return The message lookup table.
+     */
+    public Object[][] getContents()
+    {
+      return new Object[][] {
         {ErrorMsg.MULTIPLE_STYLESHEET_ERR,
         "Fler \u00E4n en formatmall har definierats i samma fil."},
 
@@ -913,12 +919,5 @@
         "FEATURE_SECURE_PROCESSING: Funktionen kan inte anges till false om s\u00E4kerhetshanteraren anv\u00E4nds."}
     };
 
-    /** Get the lookup table for error messages.
-     *
-     * @return The message lookup table.
-     */
-    public Object[][] getContents()
-    {
-        return _contents;
     }
 }
--- ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/util/ErrorMessages_zh_CN.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/util/ErrorMessages_zh_CN.java	Wed May 07 19:26:26 2014 -0700
@@ -90,7 +90,13 @@
  */
 
     // These message should be read from a locale-specific resource bundle
-    private static final Object[][] _contents =  new Object[][] {
+    /** Get the lookup table for error messages.
+     *
+     * @return The message lookup table.
+     */
+    public Object[][] getContents()
+    {
+      return new Object[][] {
         {ErrorMsg.MULTIPLE_STYLESHEET_ERR,
         "\u540C\u4E00\u6587\u4EF6\u4E2D\u5B9A\u4E49\u4E86\u591A\u4E2A\u6837\u5F0F\u8868\u3002"},
 
@@ -913,12 +919,5 @@
         "FEATURE_SECURE_PROCESSING: \u5B58\u5728 Security Manager \u65F6, \u65E0\u6CD5\u5C06\u6B64\u529F\u80FD\u8BBE\u7F6E\u4E3A\u201C\u5047\u201D\u3002"}
     };
 
-    /** Get the lookup table for error messages.
-     *
-     * @return The message lookup table.
-     */
-    public Object[][] getContents()
-    {
-        return _contents;
     }
 }
--- ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/util/ErrorMessages_zh_TW.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/compiler/util/ErrorMessages_zh_TW.java	Wed May 07 19:26:26 2014 -0700
@@ -90,7 +90,13 @@
  */
 
     // These message should be read from a locale-specific resource bundle
-    private static final Object[][] _contents =  new Object[][] {
+    /** Get the lookup table for error messages.
+     *
+     * @return The message lookup table.
+     */
+    public Object[][] getContents()
+    {
+      return new Object[][] {
         {ErrorMsg.MULTIPLE_STYLESHEET_ERR,
         "\u76F8\u540C\u6A94\u6848\u4E2D\u5B9A\u7FA9\u4E86\u8D85\u904E\u4E00\u500B\u6A23\u5F0F\u8868\u3002"},
 
@@ -913,12 +919,5 @@
         "FEATURE_SECURE_PROCESSING: \u5B89\u5168\u7BA1\u7406\u7A0B\u5F0F\u5B58\u5728\u6642\uFF0C\u7121\u6CD5\u5C07\u529F\u80FD\u8A2D\u70BA\u507D\u3002"}
     };
 
-    /** Get the lookup table for error messages.
-     *
-     * @return The message lookup table.
-     */
-    public Object[][] getContents()
-    {
-        return _contents;
     }
 }
--- ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/runtime/BasisLibrary.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/runtime/BasisLibrary.java	Wed May 07 19:26:26 2014 -0700
@@ -955,6 +955,9 @@
             if (Double.isNaN(d) || Double.isInfinite(d))
                 return(Double.toString(d));
 
+            //Convert -0.0 to +0.0 other values remains the same
+            d = d + 0.0;
+
             // Use the XPath formatter to ignore locales
             StringBuffer result = threadLocalStringBuffer.get();
             result.setLength(0);
--- ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/runtime/ErrorMessages.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/runtime/ErrorMessages.java	Wed May 07 19:26:26 2014 -0700
@@ -81,7 +81,13 @@
  */
 
     // These message should be read from a locale-specific resource bundle
-    private static final Object[][] _contents =  new Object[][] {
+    /** Get the lookup table for error messages.
+     *
+     * @return The message lookup table.
+     */
+    public Object[][] getContents()
+    {
+        return new Object[][] {
 
         /*
          * Note to translators:  the substitution text in the following message
@@ -276,13 +282,6 @@
         {BasisLibrary.UNALLOWED_EXTENSION_ELEMENT_ERR,
         "Use of the extension element ''{0}'' is not allowed when the secure processing feature is set to true."},
     };
-    /** Get the lookup table for error messages.
-     *
-     * @return The message lookup table.
-     */
-    public Object[][] getContents()
-    {
-        return _contents;
     }
 
 }
--- ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/runtime/ErrorMessages_ca.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/runtime/ErrorMessages_ca.java	Wed May 07 19:26:26 2014 -0700
@@ -79,7 +79,13 @@
  */
 
     // These message should be read from a locale-specific resource bundle
-    private static final Object[][] _contents =  new Object[][] {
+    /** Get the lookup table for error messages.
+     *
+     * @return The message lookup table.
+     */
+    public Object[][] getContents()
+    {
+        return new Object[][] {
 
         /*
          * Note to translators:  the substitution text in the following message
@@ -223,13 +229,6 @@
         "No s''ha pogut resoldre la refer\u00e8ncia d''URI ''{0}''."}
     };
 
-    /** Get the lookup table for error messages.
-     *
-     * @return The message lookup table.
-     */
-    public Object[][] getContents()
-    {
-      return _contents;
     }
 
 }
--- ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/runtime/ErrorMessages_cs.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/runtime/ErrorMessages_cs.java	Wed May 07 19:26:26 2014 -0700
@@ -79,7 +79,13 @@
  */
 
     // These message should be read from a locale-specific resource bundle
-    private static final Object[][] _contents =  new Object[][] {
+    /** Get the lookup table for error messages.
+     *
+     * @return The message lookup table.
+     */
+    public Object[][] getContents()
+    {
+        return new Object[][] {
 
         /*
          * Note to translators:  the substitution text in the following message
@@ -223,13 +229,6 @@
         "Nelze p\u0159elo\u017eit odkazy URI ''{0}''."}
     };
 
-    /** Get the lookup table for error messages.
-     *
-     * @return The message lookup table.
-     */
-    public Object[][] getContents()
-    {
-      return _contents;
     }
 
 }
--- ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/runtime/ErrorMessages_de.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/runtime/ErrorMessages_de.java	Wed May 07 19:26:26 2014 -0700
@@ -81,7 +81,13 @@
  */
 
     // These message should be read from a locale-specific resource bundle
-    private static final Object[][] _contents =  new Object[][] {
+    /** Get the lookup table for error messages.
+     *
+     * @return The message lookup table.
+     */
+    public Object[][] getContents()
+    {
+        return new Object[][] {
 
         /*
          * Note to translators:  the substitution text in the following message
@@ -276,13 +282,6 @@
         {BasisLibrary.UNALLOWED_EXTENSION_ELEMENT_ERR,
         "Verwendung des Erweiterungselements \"{0}\" ist nicht zul\u00E4ssig, wenn das Feature f\u00FCr die sichere Verarbeitung auf \"true\" gesetzt ist."},
     };
-    /** Get the lookup table for error messages.
-     *
-     * @return The message lookup table.
-     */
-    public Object[][] getContents()
-    {
-        return _contents;
     }
 
 }
--- ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/runtime/ErrorMessages_es.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/runtime/ErrorMessages_es.java	Wed May 07 19:26:26 2014 -0700
@@ -81,7 +81,13 @@
  */
 
     // These message should be read from a locale-specific resource bundle
-    private static final Object[][] _contents =  new Object[][] {
+    /** Get the lookup table for error messages.
+     *
+     * @return The message lookup table.
+     */
+    public Object[][] getContents()
+    {
+        return new Object[][] {
 
         /*
          * Note to translators:  the substitution text in the following message
@@ -276,13 +282,6 @@
         {BasisLibrary.UNALLOWED_EXTENSION_ELEMENT_ERR,
         "El uso del elemento de extensi\u00F3n ''{0}'' no est\u00E1 permitido cuando la funci\u00F3n de procesamiento seguro se ha definido en true."},
     };
-    /** Get the lookup table for error messages.
-     *
-     * @return The message lookup table.
-     */
-    public Object[][] getContents()
-    {
-        return _contents;
     }
 
 }
--- ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/runtime/ErrorMessages_fr.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/runtime/ErrorMessages_fr.java	Wed May 07 19:26:26 2014 -0700
@@ -81,7 +81,13 @@
  */
 
     // These message should be read from a locale-specific resource bundle
-    private static final Object[][] _contents =  new Object[][] {
+    /** Get the lookup table for error messages.
+     *
+     * @return The message lookup table.
+     */
+    public Object[][] getContents()
+    {
+        return new Object[][] {
 
         /*
          * Note to translators:  the substitution text in the following message
@@ -276,13 +282,6 @@
         {BasisLibrary.UNALLOWED_EXTENSION_ELEMENT_ERR,
         "L''utilisation de l''\u00E9l\u00E9ment d''extension ''{0}'' n''est pas autoris\u00E9e lorsque la fonctionnalit\u00E9 de traitement s\u00E9curis\u00E9 est d\u00E9finie sur True."},
     };
-    /** Get the lookup table for error messages.
-     *
-     * @return The message lookup table.
-     */
-    public Object[][] getContents()
-    {
-        return _contents;
     }
 
 }
--- ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/runtime/ErrorMessages_it.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/runtime/ErrorMessages_it.java	Wed May 07 19:26:26 2014 -0700
@@ -81,7 +81,13 @@
  */
 
     // These message should be read from a locale-specific resource bundle
-    private static final Object[][] _contents =  new Object[][] {
+    /** Get the lookup table for error messages.
+     *
+     * @return The message lookup table.
+     */
+    public Object[][] getContents()
+    {
+        return new Object[][] {
 
         /*
          * Note to translators:  the substitution text in the following message
@@ -276,13 +282,6 @@
         {BasisLibrary.UNALLOWED_EXTENSION_ELEMENT_ERR,
         "Non \u00E8 consentito utilizzare l''elemento di estensione ''{0}'' se la funzione di elaborazione sicura \u00E8 impostata su true."},
     };
-    /** Get the lookup table for error messages.
-     *
-     * @return The message lookup table.
-     */
-    public Object[][] getContents()
-    {
-        return _contents;
     }
 
 }
--- ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/runtime/ErrorMessages_ja.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/runtime/ErrorMessages_ja.java	Wed May 07 19:26:26 2014 -0700
@@ -81,7 +81,13 @@
  */
 
     // These message should be read from a locale-specific resource bundle
-    private static final Object[][] _contents =  new Object[][] {
+    /** Get the lookup table for error messages.
+     *
+     * @return The message lookup table.
+     */
+    public Object[][] getContents()
+    {
+        return new Object[][] {
 
         /*
          * Note to translators:  the substitution text in the following message
@@ -276,13 +282,6 @@
         {BasisLibrary.UNALLOWED_EXTENSION_ELEMENT_ERR,
         "\u30BB\u30AD\u30E5\u30A2\u51E6\u7406\u6A5F\u80FD\u304Ctrue\u306B\u8A2D\u5B9A\u3055\u308C\u3066\u3044\u308B\u3068\u304D\u3001\u62E1\u5F35\u8981\u7D20''{0}''\u306E\u4F7F\u7528\u306F\u8A31\u53EF\u3055\u308C\u307E\u305B\u3093\u3002"},
     };
-    /** Get the lookup table for error messages.
-     *
-     * @return The message lookup table.
-     */
-    public Object[][] getContents()
-    {
-        return _contents;
     }
 
 }
--- ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/runtime/ErrorMessages_ko.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/runtime/ErrorMessages_ko.java	Wed May 07 19:26:26 2014 -0700
@@ -81,7 +81,13 @@
  */
 
     // These message should be read from a locale-specific resource bundle
-    private static final Object[][] _contents =  new Object[][] {
+    /** Get the lookup table for error messages.
+     *
+     * @return The message lookup table.
+     */
+    public Object[][] getContents()
+    {
+        return new Object[][] {
 
         /*
          * Note to translators:  the substitution text in the following message
@@ -276,13 +282,6 @@
         {BasisLibrary.UNALLOWED_EXTENSION_ELEMENT_ERR,
         "\uBCF4\uC548 \uCC98\uB9AC \uAE30\uB2A5\uC774 true\uB85C \uC124\uC815\uB41C \uACBD\uC6B0 \uD655\uC7A5 \uC694\uC18C ''{0}''\uC744(\uB97C) \uC0AC\uC6A9\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4."},
     };
-    /** Get the lookup table for error messages.
-     *
-     * @return The message lookup table.
-     */
-    public Object[][] getContents()
-    {
-        return _contents;
     }
 
 }
--- ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/runtime/ErrorMessages_pt_BR.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/runtime/ErrorMessages_pt_BR.java	Wed May 07 19:26:26 2014 -0700
@@ -81,7 +81,13 @@
  */
 
     // These message should be read from a locale-specific resource bundle
-    private static final Object[][] _contents =  new Object[][] {
+    /** Get the lookup table for error messages.
+     *
+     * @return The message lookup table.
+     */
+    public Object[][] getContents()
+    {
+        return new Object[][] {
 
         /*
          * Note to translators:  the substitution text in the following message
@@ -276,13 +282,6 @@
         {BasisLibrary.UNALLOWED_EXTENSION_ELEMENT_ERR,
         "O uso do elemento da extens\u00E3o ''{0}'' n\u00E3o ser\u00E1 permitido quando o recurso de processamento seguro for definido como verdadeiro."},
     };
-    /** Get the lookup table for error messages.
-     *
-     * @return The message lookup table.
-     */
-    public Object[][] getContents()
-    {
-        return _contents;
     }
 
 }
--- ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/runtime/ErrorMessages_sk.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/runtime/ErrorMessages_sk.java	Wed May 07 19:26:26 2014 -0700
@@ -79,7 +79,13 @@
  */
 
     // These message should be read from a locale-specific resource bundle
-    private static final Object[][] _contents =  new Object[][] {
+    /** Get the lookup table for error messages.
+     *
+     * @return The message lookup table.
+     */
+    public Object[][] getContents()
+    {
+        return new Object[][] {
 
         /*
          * Note to translators:  the substitution text in the following message
@@ -223,13 +229,6 @@
         "Nebolo mo\u017en\u00e9 rozl\u00ed\u0161i\u0165 referenciu URI ''{0}''."}
     };
 
-    /** Get the lookup table for error messages.
-     *
-     * @return The message lookup table.
-     */
-    public Object[][] getContents()
-    {
-      return _contents;
     }
 
 }
--- ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/runtime/ErrorMessages_sv.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/runtime/ErrorMessages_sv.java	Wed May 07 19:26:26 2014 -0700
@@ -81,7 +81,13 @@
  */
 
     // These message should be read from a locale-specific resource bundle
-    private static final Object[][] _contents =  new Object[][] {
+    /** Get the lookup table for error messages.
+     *
+     * @return The message lookup table.
+     */
+    public Object[][] getContents()
+    {
+        return new Object[][] {
 
         /*
          * Note to translators:  the substitution text in the following message
@@ -276,13 +282,6 @@
         {BasisLibrary.UNALLOWED_EXTENSION_ELEMENT_ERR,
         "Anv\u00E4ndning av till\u00E4ggselementet ''{0}'' \u00E4r inte till\u00E5tet n\u00E4r s\u00E4ker bearbetning till\u00E4mpas."},
     };
-    /** Get the lookup table for error messages.
-     *
-     * @return The message lookup table.
-     */
-    public Object[][] getContents()
-    {
-        return _contents;
     }
 
 }
--- ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/runtime/ErrorMessages_zh_CN.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/runtime/ErrorMessages_zh_CN.java	Wed May 07 19:26:26 2014 -0700
@@ -81,7 +81,13 @@
  */
 
     // These message should be read from a locale-specific resource bundle
-    private static final Object[][] _contents =  new Object[][] {
+    /** Get the lookup table for error messages.
+     *
+     * @return The message lookup table.
+     */
+    public Object[][] getContents()
+    {
+        return new Object[][] {
 
         /*
          * Note to translators:  the substitution text in the following message
@@ -276,13 +282,6 @@
         {BasisLibrary.UNALLOWED_EXTENSION_ELEMENT_ERR,
         "\u5F53\u5B89\u5168\u5904\u7406\u529F\u80FD\u8BBE\u7F6E\u4E3A\u201C\u771F\u201D\u65F6, \u4E0D\u5141\u8BB8\u4F7F\u7528\u6269\u5C55\u5143\u7D20 ''{0}''\u3002"},
     };
-    /** Get the lookup table for error messages.
-     *
-     * @return The message lookup table.
-     */
-    public Object[][] getContents()
-    {
-        return _contents;
     }
 
 }
--- ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/runtime/ErrorMessages_zh_TW.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/runtime/ErrorMessages_zh_TW.java	Wed May 07 19:26:26 2014 -0700
@@ -81,7 +81,13 @@
  */
 
     // These message should be read from a locale-specific resource bundle
-    private static final Object[][] _contents =  new Object[][] {
+    /** Get the lookup table for error messages.
+     *
+     * @return The message lookup table.
+     */
+    public Object[][] getContents()
+    {
+        return new Object[][] {
 
         /*
          * Note to translators:  the substitution text in the following message
@@ -276,13 +282,6 @@
         {BasisLibrary.UNALLOWED_EXTENSION_ELEMENT_ERR,
         "\u7576\u5B89\u5168\u8655\u7406\u529F\u80FD\u8A2D\u70BA\u771F\u6642\uFF0C\u4E0D\u5141\u8A31\u4F7F\u7528\u64F4\u5145\u5957\u4EF6\u5143\u7D20 ''{0}''\u3002"},
     };
-    /** Get the lookup table for error messages.
-     *
-     * @return The message lookup table.
-     */
-    public Object[][] getContents()
-    {
-        return _contents;
     }
 
 }
--- ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/trax/TemplatesHandlerImpl.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/trax/TemplatesHandlerImpl.java	Wed May 07 19:26:26 2014 -0700
@@ -95,7 +95,7 @@
         _tfactory = tfactory;
 
         // Instantiate XSLTC and get reference to parser object
-        XSLTC xsltc = new XSLTC(tfactory.useServicesMechnism());
+        XSLTC xsltc = new XSLTC(tfactory.useServicesMechnism(), tfactory.getFeatureManager());
         if (tfactory.getFeature(XMLConstants.FEATURE_SECURE_PROCESSING))
             xsltc.setSecureProcessing(true);
 
--- ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/trax/TransformerFactoryImpl.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xalan/internal/xsltc/trax/TransformerFactoryImpl.java	Wed May 07 19:26:26 2014 -0700
@@ -23,6 +23,23 @@
 
 package com.sun.org.apache.xalan.internal.xsltc.trax;
 
+import com.sun.org.apache.xalan.internal.XalanConstants;
+import com.sun.org.apache.xalan.internal.utils.FactoryImpl;
+import com.sun.org.apache.xalan.internal.utils.FeatureManager;
+import com.sun.org.apache.xalan.internal.utils.FeaturePropertyBase;
+import com.sun.org.apache.xalan.internal.utils.ObjectFactory;
+import com.sun.org.apache.xalan.internal.utils.SecuritySupport;
+import com.sun.org.apache.xalan.internal.utils.XMLSecurityManager;
+import com.sun.org.apache.xalan.internal.utils.XMLSecurityPropertyManager;
+import com.sun.org.apache.xalan.internal.utils.XMLSecurityPropertyManager.Property;
+import com.sun.org.apache.xalan.internal.utils.FeaturePropertyBase.State;
+import com.sun.org.apache.xalan.internal.xsltc.compiler.Constants;
+import com.sun.org.apache.xalan.internal.xsltc.compiler.SourceLoader;
+import com.sun.org.apache.xalan.internal.xsltc.compiler.XSLTC;
+import com.sun.org.apache.xalan.internal.xsltc.compiler.util.ErrorMsg;
+import com.sun.org.apache.xalan.internal.xsltc.dom.XSLTCDTMManager;
+import com.sun.org.apache.xml.internal.utils.StopParseException;
+import com.sun.org.apache.xml.internal.utils.StylesheetPIHandler;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
@@ -37,11 +54,9 @@
 import java.util.Vector;
 import java.util.zip.ZipEntry;
 import java.util.zip.ZipFile;
-
 import javax.xml.XMLConstants;
+import javax.xml.parsers.SAXParser;
 import javax.xml.parsers.SAXParserFactory;
-import javax.xml.parsers.SAXParser;
-import javax.xml.parsers.ParserConfigurationException;
 
 import javax.xml.transform.ErrorListener;
 import javax.xml.transform.Source;
@@ -58,27 +73,9 @@
 import javax.xml.transform.sax.SAXTransformerFactory;
 import javax.xml.transform.sax.TemplatesHandler;
 import javax.xml.transform.sax.TransformerHandler;
+import javax.xml.transform.stax.*;
 import javax.xml.transform.stream.StreamResult;
 import javax.xml.transform.stream.StreamSource;
-import javax.xml.transform.stax.*;
-
-import com.sun.org.apache.xml.internal.utils.StylesheetPIHandler;
-import com.sun.org.apache.xml.internal.utils.StopParseException;
-
-import com.sun.org.apache.xalan.internal.XalanConstants;
-import com.sun.org.apache.xalan.internal.xsltc.compiler.Constants;
-import com.sun.org.apache.xalan.internal.xsltc.compiler.SourceLoader;
-import com.sun.org.apache.xalan.internal.xsltc.compiler.XSLTC;
-import com.sun.org.apache.xalan.internal.xsltc.compiler.util.ErrorMsg;
-import com.sun.org.apache.xalan.internal.xsltc.dom.XSLTCDTMManager;
-import com.sun.org.apache.xalan.internal.utils.ObjectFactory;
-import com.sun.org.apache.xalan.internal.utils.FactoryImpl;
-import com.sun.org.apache.xalan.internal.utils.SecuritySupport;
-import com.sun.org.apache.xalan.internal.utils.XMLSecurityPropertyManager;
-import com.sun.org.apache.xalan.internal.utils.XMLSecurityPropertyManager.Property;
-import com.sun.org.apache.xalan.internal.utils.XMLSecurityPropertyManager.State;
-import com.sun.org.apache.xalan.internal.utils.XMLSecurityManager;
-
 import org.xml.sax.InputSource;
 import org.xml.sax.XMLFilter;
 import org.xml.sax.XMLReader;
@@ -240,6 +237,8 @@
     private XMLSecurityPropertyManager _xmlSecurityPropertyMgr;
     private XMLSecurityManager _xmlSecurityManager;
 
+    private final FeatureManager _featureManager;
+
     /**
      * javax.xml.transform.sax.TransformerFactory implementation.
      */
@@ -254,10 +253,13 @@
     private TransformerFactoryImpl(boolean useServicesMechanism) {
         this.m_DTMManagerClass = XSLTCDTMManager.getDTMManagerClass(useServicesMechanism);
         this._useServicesMechanism = useServicesMechanism;
+        _featureManager = new FeatureManager();
 
         if (System.getSecurityManager() != null) {
             _isSecureMode = true;
             _isNotSecureProcessing = false;
+            _featureManager.setValue(FeatureManager.Feature.ORACLE_ENABLE_EXTENSION_FUNCTION,
+                    FeaturePropertyBase.State.FSP, XalanConstants.FEATURE_FALSE);
         }
 
         _xmlSecurityPropertyMgr = new XMLSecurityPropertyManager();
@@ -513,6 +515,10 @@
                         Property.ACCESS_EXTERNAL_STYLESHEET);
             }
 
+            if (value && _featureManager != null) {
+                _featureManager.setValue(FeatureManager.Feature.ORACLE_ENABLE_EXTENSION_FUNCTION,
+                        FeaturePropertyBase.State.FSP, XalanConstants.FEATURE_FALSE);
+            }
             return;
         }
         else if (name.equals(XalanConstants.ORACLE_FEATURE_SERVICE_MECHANISM)) {
@@ -521,6 +527,11 @@
                 _useServicesMechanism = value;
         }
         else {
+            if (_featureManager != null &&
+                    _featureManager.setValue(name, State.APIPROPERTY, value)) {
+                return;
+            }
+
             // unknown feature
             ErrorMsg err = new ErrorMsg(ErrorMsg.JAXP_UNSUPPORTED_FEATURE, name);
             throw new TransformerConfigurationException(err.toString());
@@ -569,6 +580,13 @@
                 return !_isNotSecureProcessing;
         }
 
+        /** Check to see if the property is managed by the security manager **/
+        String propertyValue = (_featureManager != null) ?
+                _featureManager.getValueAsString(name) : null;
+        if (propertyValue != null) {
+            return Boolean.parseBoolean(propertyValue);
+        }
+
         // Feature not supported
         return false;
     }
@@ -579,6 +597,13 @@
         return _useServicesMechanism;
     }
 
+     /**
+     * @return the feature manager
+     */
+    public FeatureManager getFeatureManager() {
+        return _featureManager;
+    }
+
     /**
      * javax.xml.transform.sax.TransformerFactory implementation.
      * Get the object that is used by default during the transformation to
@@ -859,7 +884,7 @@
         }
 
         // Create and initialize a stylesheet compiler
-        final XSLTC xsltc = new XSLTC(_useServicesMechanism);
+        final XSLTC xsltc = new XSLTC(_useServicesMechanism, _featureManager);
         if (_debug) xsltc.setDebug(true);
         if (_enableInlining)
                 xsltc.setTemplateInlining(true);
--- ./jaxp/src/com/sun/org/apache/xerces/internal/impl/xpath/XPath.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xerces/internal/impl/xpath/XPath.java	Wed May 07 19:26:26 2014 -0700
@@ -1422,7 +1422,7 @@
                             }
                             ch = data.charAt(currentOffset);
                         } while (ch == ' ' || ch == 0x0A || ch == 0x09 || ch == 0x0D);
-                        if (currentOffset == endOffset || ch == '|') {
+                        if (currentOffset == endOffset || ch == '|' || ch == '/') {
                             addToken(tokens, XPath.Tokens.EXPRTOKEN_PERIOD);
                             starIsMultiplyOperator = true;
                             break;
--- ./jaxp/src/com/sun/org/apache/xerces/internal/jaxp/DefaultValidationErrorHandler.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xerces/internal/jaxp/DefaultValidationErrorHandler.java	Wed May 07 19:26:26 2014 -0700
@@ -20,6 +20,8 @@
 
 package com.sun.org.apache.xerces.internal.jaxp;
 
+import com.sun.org.apache.xerces.internal.util.SAXMessageFormatter;
+import java.util.Locale;
 import org.xml.sax.SAXException;
 import org.xml.sax.SAXParseException;
 import org.xml.sax.helpers.DefaultHandler;
@@ -30,6 +32,11 @@
 class DefaultValidationErrorHandler extends DefaultHandler {
     static private int ERROR_COUNT_LIMIT = 10;
     private int errorCount = 0;
+    private Locale locale = Locale.getDefault();
+
+    public DefaultValidationErrorHandler(Locale locale) {
+        this.locale = locale;
+    }
 
     // XXX Fix message i18n
     public void error(SAXParseException e) throws SAXException {
@@ -38,11 +45,8 @@
             return;
         } else if (errorCount == 0) {
             // Print a warning before the first error
-            System.err.println("Warning: validation was turned on but an org.xml.sax.ErrorHandler was not");
-            System.err.println("set, which is probably not what is desired.  Parser will use a default");
-            System.err.println("ErrorHandler to print the first " +
-                               ERROR_COUNT_LIMIT +               " errors.  Please call");
-            System.err.println("the 'setErrorHandler' method to fix this.");
+            System.err.println(SAXMessageFormatter.formatMessage(locale,
+                        "errorHandlerNotSet", new Object [] {errorCount}));
         }
 
         String systemId = e.getSystemId();
--- ./jaxp/src/com/sun/org/apache/xerces/internal/jaxp/DocumentBuilderImpl.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xerces/internal/jaxp/DocumentBuilderImpl.java	Wed May 07 19:26:26 2014 -0700
@@ -140,7 +140,7 @@
         // validation errors with a warning telling the user to set an
         // ErrorHandler
         if (dbf.isValidating()) {
-            fInitErrorHandler = new DefaultValidationErrorHandler();
+            fInitErrorHandler = new DefaultValidationErrorHandler(domParser.getXMLParserConfiguration().getLocale());
             setErrorHandler(fInitErrorHandler);
         }
         else {
--- ./jaxp/src/com/sun/org/apache/xerces/internal/jaxp/SAXParserImpl.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xerces/internal/jaxp/SAXParserImpl.java	Wed May 07 19:26:26 2014 -0700
@@ -20,15 +20,6 @@
 
 package com.sun.org.apache.xerces.internal.jaxp;
 
-import java.io.IOException;
-import java.util.HashMap;
-import java.util.Hashtable;
-import java.util.Iterator;
-import java.util.Map;
-
-import javax.xml.XMLConstants;
-import javax.xml.validation.Schema;
-
 import com.sun.org.apache.xerces.internal.impl.Constants;
 import com.sun.org.apache.xerces.internal.impl.validation.ValidationManager;
 import com.sun.org.apache.xerces.internal.impl.xs.XMLSchemaValidator;
@@ -46,6 +37,14 @@
 import com.sun.org.apache.xerces.internal.xs.AttributePSVI;
 import com.sun.org.apache.xerces.internal.xs.ElementPSVI;
 import com.sun.org.apache.xerces.internal.xs.PSVIProvider;
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Hashtable;
+import java.util.Iterator;
+import java.util.Locale;
+import java.util.Map;
+import javax.xml.XMLConstants;
+import javax.xml.validation.Schema;
 import org.xml.sax.EntityResolver;
 import org.xml.sax.ErrorHandler;
 import org.xml.sax.HandlerBase;
@@ -186,7 +185,7 @@
         // validation errors with a warning telling the user to set an
         // ErrorHandler.
         if (spf.isValidating()) {
-            fInitErrorHandler = new DefaultValidationErrorHandler();
+            fInitErrorHandler = new DefaultValidationErrorHandler(xmlReader.getLocale());
             xmlReader.setErrorHandler(fInitErrorHandler);
         }
         else {
@@ -685,6 +684,10 @@
             return super.getProperty(name);
         }
 
+        Locale getLocale() {
+            return fConfiguration.getLocale();
+        }
+
         private void setSchemaValidatorFeature(String name, boolean value)
             throws SAXNotRecognizedException, SAXNotSupportedException {
             try {
--- ./jaxp/src/com/sun/org/apache/xerces/internal/util/URI.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xerces/internal/util/URI.java	Wed May 07 19:26:26 2014 -0700
@@ -689,9 +689,13 @@
         if (!initializeAuthority(uriSpec.substring(startPos, index))) {
           index = startPos - 2;
         }
-      }
-      else {
+      } else if (index < uriSpecLen) {
+        //Same as java.net.URI:
+        // DEVIATION: Allow empty authority prior to non-empty
+        // path, query component or fragment identifier
         m_host = "";
+      } else {
+        throw new MalformedURIException("Expected authority.");
       }
     }
 
--- ./jaxp/src/com/sun/org/apache/xerces/internal/utils/SecuritySupport.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xerces/internal/utils/SecuritySupport.java	Wed May 07 19:26:26 2014 -0700
@@ -211,7 +211,7 @@
         if (i > 0) {
             return uri.substring(i+1, uri.length());
         }
-        return "";
+        return uri;
     }
 
     /**
--- ./jaxp/src/com/sun/org/apache/xml/internal/dtm/ref/DTMAxisIterNodeList.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xml/internal/dtm/ref/DTMAxisIterNodeList.java	Wed May 07 19:26:26 2014 -0700
@@ -105,15 +105,15 @@
      */
     public Node item(int index) {
         if (m_iter != null) {
-            int node;
+            int node = 0;
             int count = m_cachedNodes.size();
 
             if (count > index) {
                 node = m_cachedNodes.elementAt(index);
                 return m_dtm.getNode(node);
             } else if (m_last == -1) {
-                while (((node = m_iter.next()) != DTMAxisIterator.END)
-                           && count <= index) {
+                while (count <= index
+                        && ((node = m_iter.next()) != DTMAxisIterator.END)) {
                     m_cachedNodes.addElement(node);
                     count++;
                 }
--- ./jaxp/src/com/sun/org/apache/xpath/internal/XPathContext.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xpath/internal/XPathContext.java	Wed May 07 19:26:26 2014 -0700
@@ -103,8 +103,7 @@
    * the DTMManager, it really is a proxy for this object, which
    * is the real DTMManager.
    */
-  protected DTMManager m_dtmManager = DTMManager.newInstance(
-                   com.sun.org.apache.xpath.internal.objects.XMLStringFactoryImpl.getFactory());
+  protected DTMManager m_dtmManager = null;
 
   /**
    * Return the DTMManager object.  Though XPathContext context extends
--- ./jaxp/src/com/sun/org/apache/xpath/internal/jaxp/JAXPExtensionsProvider.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xpath/internal/jaxp/JAXPExtensionsProvider.java	Wed May 07 19:26:26 2014 -0700
@@ -33,6 +33,7 @@
 import com.sun.org.apache.xpath.internal.objects.XNodeSet;
 import com.sun.org.apache.xpath.internal.res.XPATHErrorResources;
 import com.sun.org.apache.xalan.internal.res.XSLMessages;
+import com.sun.org.apache.xalan.internal.utils.FeatureManager;
 
 import com.sun.org.apache.xpath.internal.functions.FuncExtFunction;
 import java.util.Vector;
@@ -54,9 +55,12 @@
     }
 
     public JAXPExtensionsProvider(XPathFunctionResolver resolver,
-        boolean featureSecureProcessing ) {
+        boolean featureSecureProcessing, FeatureManager featureManager ) {
         this.resolver = resolver;
-        this.extensionInvocationDisabled = featureSecureProcessing;
+        if (featureSecureProcessing &&
+                !featureManager.isFeatureEnabled(FeatureManager.Feature.ORACLE_ENABLE_EXTENSION_FUNCTION)) {
+            this.extensionInvocationDisabled = true;
+        }
     }
 
     /**
--- ./jaxp/src/com/sun/org/apache/xpath/internal/jaxp/XPathExpressionImpl.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xpath/internal/jaxp/XPathExpressionImpl.java	Wed May 07 19:26:26 2014 -0700
@@ -30,6 +30,7 @@
 import com.sun.org.apache.xpath.internal.res.XPATHErrorResources;
 import com.sun.org.apache.xalan.internal.res.XSLMessages;
 import com.sun.org.apache.xalan.internal.utils.FactoryImpl;
+import com.sun.org.apache.xalan.internal.utils.FeatureManager;
 
 import javax.xml.namespace.NamespaceContext;
 import javax.xml.namespace.QName;
@@ -67,33 +68,36 @@
     private boolean featureSecureProcessing = false;
 
     private boolean useServicesMechanism = true;
+
+    private final FeatureManager featureManager;
+
     /** Protected constructor to prevent direct instantiation; use compile()
      * from the context.
      */
-    protected XPathExpressionImpl() { };
+    protected XPathExpressionImpl() {
+        this(null, null, null, null,
+             false, true, new FeatureManager());
+    };
 
     protected XPathExpressionImpl(com.sun.org.apache.xpath.internal.XPath xpath,
             JAXPPrefixResolver prefixResolver,
             XPathFunctionResolver functionResolver,
             XPathVariableResolver variableResolver ) {
-        this.xpath = xpath;
-        this.prefixResolver = prefixResolver;
-        this.functionResolver = functionResolver;
-        this.variableResolver = variableResolver;
-        this.featureSecureProcessing = false;
+        this(xpath, prefixResolver, functionResolver, variableResolver,
+             false, true, new FeatureManager());
     };
 
     protected XPathExpressionImpl(com.sun.org.apache.xpath.internal.XPath xpath,
-            JAXPPrefixResolver prefixResolver,
-            XPathFunctionResolver functionResolver,
-            XPathVariableResolver variableResolver,
-            boolean featureSecureProcessing, boolean useServicesMechanism ) {
+            JAXPPrefixResolver prefixResolver,XPathFunctionResolver functionResolver,
+            XPathVariableResolver variableResolver, boolean featureSecureProcessing,
+            boolean useServicesMechanism, FeatureManager featureManager ) {
         this.xpath = xpath;
         this.prefixResolver = prefixResolver;
         this.functionResolver = functionResolver;
         this.variableResolver = variableResolver;
         this.featureSecureProcessing = featureSecureProcessing;
         this.useServicesMechanism = useServicesMechanism;
+        this.featureManager = featureManager;
     };
 
     public void setXPath (com.sun.org.apache.xpath.internal.XPath xpath ) {
@@ -111,7 +115,7 @@
         com.sun.org.apache.xpath.internal.XPathContext xpathSupport = null;
         if ( functionResolver != null ) {
             JAXPExtensionsProvider jep = new JAXPExtensionsProvider(
-                    functionResolver, featureSecureProcessing );
+                    functionResolver, featureSecureProcessing, featureManager );
             xpathSupport = new com.sun.org.apache.xpath.internal.XPathContext( jep );
         } else {
             xpathSupport = new com.sun.org.apache.xpath.internal.XPathContext();
--- ./jaxp/src/com/sun/org/apache/xpath/internal/jaxp/XPathFactoryImpl.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xpath/internal/jaxp/XPathFactoryImpl.java	Wed May 07 19:26:26 2014 -0700
@@ -24,6 +24,8 @@
 import com.sun.org.apache.xalan.internal.XalanConstants;
 import com.sun.org.apache.xpath.internal.res.XPATHErrorResources;
 import com.sun.org.apache.xalan.internal.res.XSLMessages;
+import com.sun.org.apache.xalan.internal.utils.FeatureManager;
+import com.sun.org.apache.xalan.internal.utils.FeaturePropertyBase;
 
 import javax.xml.XMLConstants;
 import javax.xml.xpath.XPathFactory;
@@ -68,6 +70,8 @@
 
         private boolean _useServicesMechanism = true;
 
+        private final FeatureManager _featureManager;
+
         public XPathFactoryImpl() {
             this(true);
         }
@@ -77,9 +81,12 @@
         }
 
         public XPathFactoryImpl(boolean useServicesMechanism) {
+            _featureManager = new FeatureManager();
             if (System.getSecurityManager() != null) {
                 _isSecureMode = true;
                 _isNotSecureProcessing = false;
+                _featureManager.setValue(FeatureManager.Feature.ORACLE_ENABLE_EXTENSION_FUNCTION,
+                        FeaturePropertyBase.State.FSP, XalanConstants.FEATURE_FALSE);
             }
             this._useServicesMechanism = useServicesMechanism;
         }
@@ -131,7 +138,8 @@
         public javax.xml.xpath.XPath newXPath() {
             return new com.sun.org.apache.xpath.internal.jaxp.XPathImpl(
                     xPathVariableResolver, xPathFunctionResolver,
-                    !_isNotSecureProcessing, _useServicesMechanism );
+                    !_isNotSecureProcessing, _useServicesMechanism,
+                    _featureManager );
         }
 
         /**
@@ -181,6 +189,10 @@
                 }
 
                 _isNotSecureProcessing = !value;
+                if (value && _featureManager != null) {
+                    _featureManager.setValue(FeatureManager.Feature.ORACLE_ENABLE_EXTENSION_FUNCTION,
+                            FeaturePropertyBase.State.FSP, XalanConstants.FEATURE_FALSE);
+                }
 
                 // all done processing feature
                 return;
@@ -192,6 +204,11 @@
                 return;
             }
 
+            if (_featureManager != null &&
+                    _featureManager.setValue(name, FeaturePropertyBase.State.APIPROPERTY, value)) {
+                return;
+            }
+
             // unknown feature
             String fmsg = XSLMessages.createXPATHMessage(
                     XPATHErrorResources.ER_FEATURE_UNKNOWN,
@@ -240,6 +257,14 @@
             if (name.equals(XalanConstants.ORACLE_FEATURE_SERVICE_MECHANISM)) {
                 return _useServicesMechanism;
             }
+
+            /** Check to see if the property is managed by the security manager **/
+            String propertyValue = (_featureManager != null) ?
+                    _featureManager.getValueAsString(name) : null;
+            if (propertyValue != null) {
+                return _featureManager.isFeatureEnabled(name);
+            }
+
             // unknown feature
             String fmsg = XSLMessages.createXPATHMessage(
                     XPATHErrorResources.ER_GETTING_UNKNOWN_FEATURE,
--- ./jaxp/src/com/sun/org/apache/xpath/internal/jaxp/XPathImpl.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/com/sun/org/apache/xpath/internal/jaxp/XPathImpl.java	Wed May 07 19:26:26 2014 -0700
@@ -35,6 +35,7 @@
 import com.sun.org.apache.xpath.internal.res.XPATHErrorResources;
 import com.sun.org.apache.xalan.internal.res.XSLMessages;
 import com.sun.org.apache.xalan.internal.utils.FactoryImpl;
+import com.sun.org.apache.xalan.internal.utils.FeatureManager;
 
 import org.w3c.dom.Node;
 import org.w3c.dom.Document;
@@ -70,18 +71,20 @@
     // extensions function need to throw XPathFunctionException
     private boolean featureSecureProcessing = false;
     private boolean useServiceMechanism = true;
+    private final FeatureManager featureManager;
 
     XPathImpl( XPathVariableResolver vr, XPathFunctionResolver fr ) {
-        this.origVariableResolver = this.variableResolver = vr;
-        this.origFunctionResolver = this.functionResolver = fr;
+        this(vr, fr, false, true, new FeatureManager());
     }
 
     XPathImpl( XPathVariableResolver vr, XPathFunctionResolver fr,
-            boolean featureSecureProcessing, boolean useServiceMechanism ) {
+            boolean featureSecureProcessing, boolean useServiceMechanism,
+            FeatureManager featureManager) {
         this.origVariableResolver = this.variableResolver = vr;
         this.origFunctionResolver = this.functionResolver = fr;
         this.featureSecureProcessing = featureSecureProcessing;
         this.useServiceMechanism = useServiceMechanism;
+        this.featureManager = featureManager;
     }
 
     /**
@@ -190,7 +193,7 @@
         com.sun.org.apache.xpath.internal.XPathContext xpathSupport = null;
         if ( functionResolver != null ) {
             JAXPExtensionsProvider jep = new JAXPExtensionsProvider(
-                    functionResolver, featureSecureProcessing );
+                    functionResolver, featureSecureProcessing, featureManager );
             xpathSupport = new com.sun.org.apache.xpath.internal.XPathContext( jep );
         } else {
             xpathSupport = new com.sun.org.apache.xpath.internal.XPathContext();
@@ -391,7 +394,7 @@
             // Can have errorListener
             XPathExpressionImpl ximpl = new XPathExpressionImpl (xpath,
                     prefixResolver, functionResolver, variableResolver,
-                    featureSecureProcessing, useServiceMechanism );
+                    featureSecureProcessing, useServiceMechanism, featureManager );
             return ximpl;
         } catch ( javax.xml.transform.TransformerException te ) {
             throw new XPathExpressionException ( te ) ;
--- ./jaxp/src/javax/xml/xpath/XPathException.java	Tue Mar 18 12:34:22 2014 -0700
+++ ./jaxp/src/javax/xml/xpath/XPathException.java	Wed May 07 19:26:26 2014 -0700
@@ -26,6 +26,11 @@
 package javax.xml.xpath;
 
 import java.io.PrintWriter;
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.io.ObjectOutputStream;
+import java.io.ObjectStreamField;
+import java.io.InvalidClassException;
 
 /**
  * <code>XPathException</code> represents a generic XPath exception.</p>
@@ -36,7 +41,9 @@
  */
 public class XPathException extends Exception {
 
-    private final Throwable cause;
+    private static final ObjectStreamField[] serialPersistentFields = {
+        new ObjectStreamField( "cause", Throwable.class )
+    };
 
     /**
      * <p>Stream Unique Identifier.</p>
@@ -62,7 +69,6 @@
         if ( message == null ) {
             throw new NullPointerException ( "message can't be null");
         }
-        this.cause = null;
     }
 
     /**
@@ -77,8 +83,7 @@
      * @throws NullPointerException if <code>cause</code> is <code>null</code>.
      */
     public XPathException(Throwable cause) {
-        super();
-        this.cause = cause;
+        super(cause);
         if ( cause == null ) {
             throw new NullPointerException ( "cause can't be null");
         }
@@ -90,7 +95,47 @@
      * @return Cause of this XPathException.
      */
     public Throwable getCause() {
-        return cause;
+        return super.getCause();
+    }
+
+    /**
+     * Writes "cause" field to the stream.
+     * The cause is got from the parent class.
+     *
+     * @param out stream used for serialization.
+     * @throws IOException thrown by <code>ObjectOutputStream</code>
+     *
+     */
+    private void writeObject(ObjectOutputStream out)
+            throws IOException
+    {
+        ObjectOutputStream.PutField fields = out.putFields();
+        fields.put("cause", (Throwable) super.getCause());
+        out.writeFields();
+    }
+
+    /**
+     * Reads the "cause" field from the stream.
+     * And initializes the "cause" if it wasn't
+     * done before.
+     *
+     * @param in stream used for deserialization
+     * @throws IOException thrown by <code>ObjectInputStream</code>
+     * @throws ClassNotFoundException  thrown by <code>ObjectInputStream</code>
+     */
+    private void readObject(ObjectInputStream in)
+            throws IOException, ClassNotFoundException
+    {
+        ObjectInputStream.GetField fields = in.readFields();
+        Throwable scause = (Throwable) fields.get("cause", null);
+
+        if (super.getCause() == null && scause != null) {
+            try {
+                super.initCause(scause);
+            } catch(IllegalStateException e) {
+                throw new InvalidClassException("Inconsistent state: two causes");
+            }
+        }
     }
 
     /**
--- ./jaxws/.hgtags	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/.hgtags	Wed May 07 19:26:28 2014 -0700
@@ -417,3 +417,26 @@
 0db5b891d1ba10211da0a8158551b35f00da7684 jdk7u55-b11
 3834eb921dfd8d29d917a0c57bb9fdd9aa58c209 jdk7u55-b12
 3b0da73591b1ea23c48aa7babc34ed776fc183f0 jdk7u55-b13
+5d726bf8fedc1f10d250e980653315919b7602f2 jdk7u55-b30
+81d0f297557c4a876727cabeb2bfcdf066a1fc9d jdk7u55-b14
+2d103c97c9bd0b3357e6d5e2b5b9ffb64c271288 jdk7u55-b31
+cb5f95263f620967f5097c5ff8e0b27cfb9e8c44 jdk7u60-b00
+f675dfce1e61a6ed01732ae7cfbae941791cba74 jdk7u60-b01
+8a3b9e8492a5ac4e2e0c166dbfc5d058be244377 jdk7u60-b02
+d4ba4e1ed3ecdef1ef7c3b7aaf62ff69fc105cb2 jdk7u60-b03
+bef313c7ff7a7a829f8f6a305bf0c3738ad99795 jdk7u60-b04
+30afd3e2e7044b2aa87ce00ab4301990e6d94d27 jdk7u60-b05
+dc6017fb9cde43bce92d403abc2821b741cf977c jdk7u60-b06
+0380cb9d4dc27ed8e2c4fc3502e3d94b0ae0c02d jdk7u60-b07
+d3896e59b04dc4022c3e0d04e8750b281249bbd2 jdk7u60-b08
+c85645aa77cedabeeb6e01373cdd81afd56c602e jdk7u60-b09
+79501d4561e4cfa96fd77e2e92eb6a1b6ad61005 jdk7u60-b10
+5d848774565b5e188d7ba915ce1cb09d8f3fdb87 jdk7u60-b11
+9d34f726e35b321072ce5bd0aad2e513b9fc972f jdk7u60-b12
+d941a701cf5ca11b2777fd1d0238e05e3c963e89 jdk7u60-b13
+43b5a7cf08e7ee018b1fa42a89510b4c381dc4c5 jdk7u60-b14
+d00389bf5439e5c42599604d2ebc909d26df8dcf jdk7u60-b15
+2fc16d3a321212abc0cc93462b22c4be7f693ab9 jdk7u60-b16
+b312ec543dc09db784e161eb89607d4afd4cab1e jdk7u60-b18
+b312ec543dc09db784e161eb89607d4afd4cab1e jdk7u60-b17
+1d21eb9011a060c7761c9a8a53e69d58bbea4893 jdk7u60-b19
--- ./jaxws/src/share/jaxws_classes/com/sun/org/glassfish/external/statistics/impl/BoundedRangeStatisticImpl.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/org/glassfish/external/statistics/impl/BoundedRangeStatisticImpl.java	Wed May 07 19:26:28 2014 -0700
@@ -26,6 +26,7 @@
 
 
 package com.sun.org.glassfish.external.statistics.impl;
+
 import com.sun.org.glassfish.external.statistics.BoundedRangeStatistic;
 import java.util.Map;
 import java.lang.reflect.*;
--- ./jaxws/src/share/jaxws_classes/com/sun/tools/internal/ws/processor/modeler/annotation/WebServiceVisitor.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/tools/internal/ws/processor/modeler/annotation/WebServiceVisitor.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -204,24 +204,24 @@
         }
         portName = ClassNameInfo.getName(
                 d.getSimpleName().replace(
-                SIGC_INNERCLASS,
-                SIGC_UNDERSCORE));;
-                packageName = d.getPackage().getQualifiedName();
-                portName = webService != null && webService.name() != null && webService.name().length() >0 ?
-                    webService.name() : portName;
-                serviceName = ClassNameInfo.getName(d.getQualifiedName())+SERVICE;
-                serviceName = webService != null && webService.serviceName() != null &&
-                        webService.serviceName().length() > 0 ?
-                            webService.serviceName() : serviceName;
-                wsdlNamespace = seiContext.getNamespaceURI();
-                typeNamespace = wsdlNamespace;
+                        SIGC_INNERCLASS,
+                        SIGC_UNDERSCORE));;
+        packageName = d.getPackage().getQualifiedName();
+        portName = webService != null && webService.name() != null && webService.name().length() >0 ?
+                webService.name() : portName;
+        serviceName = ClassNameInfo.getName(d.getQualifiedName())+SERVICE;
+        serviceName = webService != null && webService.serviceName() != null &&
+                webService.serviceName().length() > 0 ?
+                webService.serviceName() : serviceName;
+        wsdlNamespace = seiContext.getNamespaceURI();
+        typeNamespace = wsdlNamespace;
 
-                SOAPBinding soapBinding = d.getAnnotation(SOAPBinding.class);
-                if (soapBinding != null) {
-                    pushedSOAPBinding = pushSOAPBinding(soapBinding, d, d);
-                } else if (d.equals(typeDecl)) {
-                    pushedSOAPBinding = pushSOAPBinding(new MySOAPBinding(), d, d);
-                }
+        SOAPBinding soapBinding = d.getAnnotation(SOAPBinding.class);
+        if (soapBinding != null) {
+            pushedSOAPBinding = pushSOAPBinding(soapBinding, d, d);
+        } else if (d.equals(typeDecl)) {
+            pushedSOAPBinding = pushSOAPBinding(new MySOAPBinding(), d, d);
+        }
     }
 
     public static boolean sameStyle(SOAPBinding.Style style, SOAPStyle soapStyle) {
@@ -235,7 +235,7 @@
     }
 
     protected boolean pushSOAPBinding(SOAPBinding soapBinding, Declaration bindingDecl,
-            TypeDeclaration classDecl) {
+                                      TypeDeclaration classDecl) {
         boolean changed = false;
         if (!sameStyle(soapBinding.style(), soapStyle)) {
             changed = true;
@@ -293,7 +293,7 @@
 
 //    abstract protected boolean shouldProcessWebService(WebService webService, InterfaceDeclaration intf);
 
-//    abstract protected boolean shouldProcessWebService(WebService webService, ClassDeclaration decl);
+    //    abstract protected boolean shouldProcessWebService(WebService webService, ClassDeclaration decl);
     protected boolean shouldProcessWebService(WebService webService, InterfaceDeclaration intf) {
         hasWebMethods = false;
         if (webService == null)
@@ -315,9 +315,9 @@
             return false;
         hasWebMethods = hasWebMethods(classDecl);
         SOAPBinding soapBinding = classDecl.getAnnotation(SOAPBinding.class);
-                if(soapBinding != null && soapBinding.style() == SOAPBinding.Style.RPC && soapBinding.parameterStyle() == SOAPBinding.ParameterStyle.BARE) {
-                  builder.onError(classDecl.getPosition(), WebserviceapMessages.localizableWEBSERVICEAP_INVALID_SOAPBINDING_PARAMETERSTYLE(soapBinding, classDecl));
-                    return false;
+        if(soapBinding != null && soapBinding.style() == SOAPBinding.Style.RPC && soapBinding.parameterStyle() == SOAPBinding.ParameterStyle.BARE) {
+            builder.onError(classDecl.getPosition(), WebserviceapMessages.localizableWEBSERVICEAP_INVALID_SOAPBINDING_PARAMETERSTYLE(soapBinding, classDecl));
+            return false;
         }
         return isLegalImplementation(webService, classDecl);
     }
@@ -345,8 +345,8 @@
                 if (webMethod.exclude()) {
                     if (webMethod.operationName().length() > 0)
                         builder.onError(method.getPosition(), WebserviceapMessages.localizableWEBSERVICEAP_INVALID_WEBMETHOD_ELEMENT_WITH_EXCLUDE("operationName", d.getQualifiedName(), method.toString()));
-                                if (webMethod.action().length() > 0)
-                                    builder.onError(method.getPosition(), WebserviceapMessages.localizableWEBSERVICEAP_INVALID_WEBMETHOD_ELEMENT_WITH_EXCLUDE("action", d.getQualifiedName(), method.toString()));
+                    if (webMethod.action().length() > 0)
+                        builder.onError(method.getPosition(), WebserviceapMessages.localizableWEBSERVICEAP_INVALID_WEBMETHOD_ELEMENT_WITH_EXCLUDE("action", d.getQualifiedName(), method.toString()));
                 } else {
                     return true;
                 }
@@ -382,7 +382,7 @@
     }
 
     private InterfaceDeclaration getEndpointInterfaceDecl(String endpointInterfaceName,
-            ClassDeclaration d) {
+                                                          ClassDeclaration d) {
         InterfaceDeclaration intTypeDecl = null;
         for (InterfaceType interfaceType : d.getSuperinterfaces()) {
             if (endpointInterfaceName.equals(interfaceType.toString())) {
@@ -488,7 +488,7 @@
         Collection<Modifier> modifiers = classDecl.getModifiers();
         if (!modifiers.contains(Modifier.PUBLIC)){
             builder.onError(classDecl.getPosition(), WebserviceapMessages.localizableWEBSERVICEAP_WEBSERVICE_CLASS_NOT_PUBLIC(classDecl.getQualifiedName()));
-                    return false;
+            return false;
         }
         if (modifiers.contains(Modifier.FINAL) && !isStateful) {
             builder.onError(classDecl.getPosition(), WebserviceapMessages.localizableWEBSERVICEAP_WEBSERVICE_CLASS_IS_FINAL(classDecl.getQualifiedName()));
@@ -538,7 +538,7 @@
     }
 
     protected boolean classImplementsSEI(ClassDeclaration classDecl,
-            InterfaceDeclaration intfDecl) {
+                                         InterfaceDeclaration intfDecl) {
         for (InterfaceType interfaceType : classDecl.getSuperinterfaces()) {
             if (interfaceType.getDeclaration().equals(intfDecl))
                 return true;
@@ -637,8 +637,8 @@
         */
         if (!isLegalType(method.getReturnType())) {
             builder.onError(method.getPosition(), WebserviceapMessages.localizableWEBSERVICEAP_METHOD_RETURN_TYPE_CANNOT_IMPLEMENT_REMOTE(typeDecl.getQualifiedName(),
-                method.getSimpleName(),
-                method.getReturnType()));
+                    method.getSimpleName(),
+                    method.getReturnType()));
         }
         boolean isOneway = method.getAnnotation(Oneway.class) != null;
         if (isOneway && !isValidOnewayMethod(method, typeDecl))
@@ -684,14 +684,14 @@
     }
 
     protected boolean isLegalParameter(ParameterDeclaration param,
-            MethodDeclaration method,
-            TypeDeclaration typeDecl,
-            int paramIndex) {
+                                       MethodDeclaration method,
+                                       TypeDeclaration typeDecl,
+                                       int paramIndex) {
         if (!isLegalType(param.getType())) {
             builder.onError(param.getPosition(), WebserviceapMessages.localizableWEBSERVICEAP_METHOD_PARAMETER_TYPES_CANNOT_IMPLEMENT_REMOTE(typeDecl.getQualifiedName(),
-                method.getSimpleName(),
-                param.getSimpleName(),
-                param.getType().toString()));
+                    method.getSimpleName(),
+                    param.getSimpleName(),
+                    param.getType().toString()));
             return false;
         }
         TypeMirror holderType;
--- ./jaxws/src/share/jaxws_classes/com/sun/tools/internal/ws/wscompile/WsimportTool.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/tools/internal/ws/wscompile/WsimportTool.java	Wed May 07 19:26:28 2014 -0700
@@ -334,7 +334,7 @@
             if(options.verbose) {
                 listener.message(WscompileMessages.WSIMPORT_ARCHIVE_ARTIFACT(f, options.clientjar));
             }
-            String entry = f.getCanonicalPath().substring(base.length()+1);
+            String entry = f.getCanonicalPath().substring(base.length()+1).replace(File.separatorChar, '/');
             BufferedInputStream bis = new BufferedInputStream(
                             new FileInputStream(f));
             JarEntry jarEntry = new JarEntry(entry);
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/bind/v2/model/impl/ModelBuilder.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/bind/v2/model/impl/ModelBuilder.java	Wed May 07 19:26:28 2014 -0700
@@ -160,8 +160,8 @@
                 res = Messages.INCOMPATIBLE_API_VERSION;
 
             throw new LinkageError( res.format(
-                Which.which(XmlSchema.class),
-                Which.which(ModelBuilder.class)
+                    Which.which(XmlSchema.class),
+                    Which.which(ModelBuilder.class)
             ));
         }
     }
@@ -176,8 +176,8 @@
         } catch (NoSuchMethodError e) {
             // we seem to be getting 1.0 runtime
             throw new LinkageError( Messages.RUNNING_WITH_1_0_RUNTIME.format(
-                Which.which(WhiteSpaceProcessor.class),
-                Which.which(ModelBuilder.class)
+                    Which.which(WhiteSpaceProcessor.class),
+                    Which.which(ModelBuilder.class)
             ));
         }
     }
@@ -293,7 +293,7 @@
 
         if(nav.isArray(t)) { // no need for checking byte[], because above typeInfoset.getTypeInfo() would return non-null
             ArrayInfoImpl<T,C,F,M> ai =
-                createArrayInfo(upstream, t);
+                    createArrayInfo(upstream, t);
             addTypeName(ai);
             typeInfoSet.add(ai);
             return ai;
@@ -329,7 +329,7 @@
     }
 
     protected ElementInfoImpl<T,C,F,M> createElementInfo(
-        RegistryInfoImpl<T,C,F,M> registryInfo, M m) throws IllegalAnnotationException {
+            RegistryInfoImpl<T,C,F,M> registryInfo, M m) throws IllegalAnnotationException {
         return new ElementInfoImpl<T,C,F,M>(this,registryInfo,m);
     }
 
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/org/jvnet/mimepull/MemoryData.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/org/jvnet/mimepull/MemoryData.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/org/jvnet/mimepull/TempFiles.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/org/jvnet/mimepull/TempFiles.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/client/WSServiceDelegate.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/client/WSServiceDelegate.java	Wed May 07 19:26:28 2014 -0700
@@ -22,6 +22,7 @@
  * or visit www.oracle.com if you need additional information or have any
  * questions.
  */
+
 package com.sun.xml.internal.ws.client;
 
 import com.sun.istack.internal.NotNull;
@@ -140,8 +141,8 @@
     /**
      * Information about SEI, keyed by their interface type.
      */
-   // private final Map<Class,SEIPortInfo> seiContext = new HashMap<Class,SEIPortInfo>();
-   private final Map<QName,SEIPortInfo> seiContext = new HashMap<QName,SEIPortInfo>();
+    // private final Map<Class,SEIPortInfo> seiContext = new HashMap<Class,SEIPortInfo>();
+    private final Map<QName,SEIPortInfo> seiContext = new HashMap<QName,SEIPortInfo>();
 
     // This executor is used for all the async invocations for all proxies
     // created from this service. But once the proxy is created, then changing
@@ -166,8 +167,8 @@
 
     public WSServiceDelegate(URL wsdlDocumentLocation, QName serviceName, Class<? extends Service> serviceClass) {
         this(
-            wsdlDocumentLocation==null ? null : new StreamSource(wsdlDocumentLocation.toExternalForm()),
-            serviceName,serviceClass);
+                wsdlDocumentLocation==null ? null : new StreamSource(wsdlDocumentLocation.toExternalForm()),
+                serviceName,serviceClass);
     }
 
     /**
@@ -204,10 +205,10 @@
         if(wsdl == null){
             if(serviceClass != Service.class){
                 WebServiceClient wsClient = AccessController.doPrivileged(new PrivilegedAction<WebServiceClient>() {
-                        public WebServiceClient run() {
-                            return serviceClass.getAnnotation(WebServiceClient.class);
-                        }
-                    });
+                    public WebServiceClient run() {
+                        return serviceClass.getAnnotation(WebServiceClient.class);
+                    }
+                });
                 String wsdlLocation = wsClient.wsdlLocation();
                 wsdlLocation = JAXWSUtils.absolutize(JAXWSUtils.getFileOrURLName(wsdlLocation));
                 wsdl = new StreamSource(wsdlLocation);
@@ -221,8 +222,8 @@
                 service = model.getService(this.serviceName);
                 if (service == null)
                     throw new WebServiceException(
-                        ClientMessages.INVALID_SERVICE_NAME(this.serviceName,
-                            buildNameList(model.getServices().keySet())));
+                            ClientMessages.INVALID_SERVICE_NAME(this.serviceName,
+                                    buildNameList(model.getServices().keySet())));
                 // fill in statically known ports
                 for (WSDLPortImpl port : service.getPorts())
                     ports.put(port.getName(), new PortInfo(this, port));
@@ -255,7 +256,7 @@
     private WSDLModelImpl parseWSDL(URL wsdlDocumentLocation, Source wsdlSource) {
         try {
             return RuntimeWSDLParser.parse(wsdlDocumentLocation, wsdlSource, createDefaultCatalogResolver(),
-                true, getContainer(), ServiceFinder.find(WSDLParserExtension.class).toArray());
+                    true, getContainer(), ServiceFinder.find(WSDLParserExtension.class).toArray());
         } catch (IOException e) {
             throw new WebServiceException(e);
         } catch (XMLStreamException e) {
@@ -345,7 +346,7 @@
         //get the first port corresponding to the SEI
         WSDLPortImpl port = wsdlService.getMatchingPort(portTypeName);
         if (port == null)
-                throw new WebServiceException(ClientMessages.UNDEFINED_PORT_TYPE(portTypeName));
+            throw new WebServiceException(ClientMessages.UNDEFINED_PORT_TYPE(portTypeName));
         QName portName = port.getName();
         return getPort(portName, portInterface,features);
     }
@@ -431,8 +432,8 @@
         binding.setMode(mode);
         Dispatch<Object> dispatch = Stubs.createJAXBDispatch(
                 port, binding, jaxbContext, mode,wsepr);
-         serviceInterceptor.postCreateDispatch((WSBindingProvider)dispatch);
-         return dispatch;
+        serviceInterceptor.postCreateDispatch((WSBindingProvider)dispatch);
+        return dispatch;
     }
 
     @Override
@@ -583,7 +584,7 @@
 
         if (wsdlService.get(portName)==null) {
             throw new WebServiceException(
-                ClientMessages.INVALID_PORT_NAME(portName,buildWsdlPortNames()));
+                    ClientMessages.INVALID_PORT_NAME(portName,buildWsdlPortNames()));
         }
 
         BindingImpl binding = eif.createBinding(webServiceFeatures,portInterface);
@@ -681,7 +682,7 @@
         return wsdlService;
     }
 
-     class DaemonThreadFactory implements ThreadFactory {
+    class DaemonThreadFactory implements ThreadFactory {
         public Thread newThread(Runnable r) {
             Thread daemonThread = new Thread(r);
             daemonThread.setDaemon(Boolean.TRUE);
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/AssertionSet.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/AssertionSet.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/AssertionValidationProcessor.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/AssertionValidationProcessor.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/ComplexAssertion.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/ComplexAssertion.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/EffectiveAlternativeSelector.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/EffectiveAlternativeSelector.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/EffectivePolicyModifier.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/EffectivePolicyModifier.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/NestedPolicy.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/NestedPolicy.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/Policy.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/Policy.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/PolicyAssertion.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/PolicyAssertion.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/PolicyConstants.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/PolicyConstants.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/PolicyException.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/PolicyException.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/PolicyIntersector.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/PolicyIntersector.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/PolicyMap.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/PolicyMap.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/PolicyMapExtender.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/PolicyMapExtender.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/PolicyMapKey.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/PolicyMapKey.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/PolicyMapKeyHandler.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/PolicyMapKeyHandler.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/PolicyMapMutator.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/PolicyMapMutator.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/PolicyMerger.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/PolicyMerger.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/PolicyScope.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/PolicyScope.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/PolicySubject.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/PolicySubject.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/SimpleAssertion.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/SimpleAssertion.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/package-info.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/package-info.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/privateutil/PolicyLogger.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/privateutil/PolicyLogger.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/privateutil/RuntimePolicyUtilsException.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/privateutil/RuntimePolicyUtilsException.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/privateutil/ServiceConfigurationError.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/privateutil/ServiceConfigurationError.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/privateutil/ServiceFinder.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/privateutil/ServiceFinder.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/privateutil/package-info.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/privateutil/package-info.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/sourcemodel/AssertionData.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/sourcemodel/AssertionData.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/sourcemodel/CompactModelGenerator.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/sourcemodel/CompactModelGenerator.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/sourcemodel/DefaultPolicyAssertionCreator.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/sourcemodel/DefaultPolicyAssertionCreator.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/sourcemodel/ModelNode.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/sourcemodel/ModelNode.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/sourcemodel/NormalizedModelGenerator.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/sourcemodel/NormalizedModelGenerator.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/sourcemodel/PolicyModelGenerator.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/sourcemodel/PolicyModelGenerator.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/sourcemodel/PolicyModelMarshaller.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/sourcemodel/PolicyModelMarshaller.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/sourcemodel/PolicyModelTranslator.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/sourcemodel/PolicyModelTranslator.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/sourcemodel/PolicyModelUnmarshaller.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/sourcemodel/PolicyModelUnmarshaller.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/sourcemodel/PolicyReferenceData.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/sourcemodel/PolicyReferenceData.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/sourcemodel/PolicySourceModel.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/sourcemodel/PolicySourceModel.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/sourcemodel/PolicySourceModelContext.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/sourcemodel/PolicySourceModelContext.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/sourcemodel/XmlPolicyModelMarshaller.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/sourcemodel/XmlPolicyModelMarshaller.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/sourcemodel/XmlPolicyModelUnmarshaller.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/sourcemodel/XmlPolicyModelUnmarshaller.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/sourcemodel/attach/package-info.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/sourcemodel/attach/package-info.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/sourcemodel/package-info.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/sourcemodel/package-info.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/sourcemodel/wspolicy/NamespaceVersion.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/sourcemodel/wspolicy/NamespaceVersion.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/sourcemodel/wspolicy/XmlToken.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/sourcemodel/wspolicy/XmlToken.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/spi/AbstractQNameValidator.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/spi/AbstractQNameValidator.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/spi/AssertionCreationException.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/spi/AssertionCreationException.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/spi/PolicyAssertionCreator.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/spi/PolicyAssertionCreator.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/spi/PolicyAssertionValidator.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/spi/PolicyAssertionValidator.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/spi/PrefixMapper.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/spi/PrefixMapper.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/spi/package-info.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/spi/package-info.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/subject/PolicyMapKeyConverter.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/subject/PolicyMapKeyConverter.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/subject/WsdlBindingSubject.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/subject/WsdlBindingSubject.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/subject/package-info.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/com/sun/xml/internal/ws/policy/subject/package-info.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/javax/xml/soap/AttachmentPart.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/javax/xml/soap/AttachmentPart.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/javax/xml/soap/Detail.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/javax/xml/soap/Detail.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/javax/xml/soap/DetailEntry.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/javax/xml/soap/DetailEntry.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/javax/xml/soap/FactoryFinder.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/javax/xml/soap/FactoryFinder.java	Wed May 07 19:26:28 2014 -0700
@@ -40,11 +40,12 @@
      */
     private static Object newInstance(String className,
                                       ClassLoader classLoader)
-        throws SOAPException
+            throws SOAPException
     {
         try {
             Class spiClass = safeLoadClass(className, classLoader);
             return spiClass.newInstance();
+
         } catch (ClassNotFoundException x) {
             throw new SOAPException("Provider " + className + " not found", x);
         } catch (Exception x) {
@@ -66,7 +67,7 @@
      * @exception SOAPException if there is a SOAP error
      */
     static Object find(String factoryId)
-        throws SOAPException
+            throws SOAPException
     {
         return find(factoryId, null, false);
     }
@@ -92,7 +93,7 @@
      * @exception SOAPException if there is a SOAP error
      */
     static Object find(String factoryId, String fallbackClassName)
-        throws SOAPException
+            throws SOAPException
     {
         return find(factoryId, fallbackClassName, true);
     }
@@ -122,7 +123,7 @@
      * @exception SOAPException if there is a SOAP error
      */
     static Object find(String factoryId, String defaultClassName,
-            boolean tryFallback) throws SOAPException {
+                       boolean tryFallback) throws SOAPException {
         ClassLoader classLoader;
         try {
             classLoader = Thread.currentThread().getContextClassLoader();
@@ -133,7 +134,7 @@
         // Use the system property first
         try {
             String systemProp =
-                System.getProperty( factoryId );
+                    System.getProperty( factoryId );
             if( systemProp!=null) {
                 return newInstance(systemProp, classLoader);
             }
@@ -144,7 +145,7 @@
         try {
             String javah=System.getProperty( "java.home" );
             String configFile = javah + File.separator +
-                "lib" + File.separator + "jaxm.properties";
+                    "lib" + File.separator + "jaxm.properties";
             File f=new File( configFile );
             if( f.exists()) {
                 Properties props=new Properties();
@@ -167,13 +168,13 @@
 
             if( is!=null ) {
                 BufferedReader rd =
-                    new BufferedReader(new InputStreamReader(is, "UTF-8"));
+                        new BufferedReader(new InputStreamReader(is, "UTF-8"));
 
                 String factoryClassName = rd.readLine();
                 rd.close();
 
                 if (factoryClassName != null &&
-                    ! "".equals(factoryClassName)) {
+                        ! "".equals(factoryClassName)) {
                     return newInstance(factoryClassName, classLoader);
                 }
             }
@@ -188,7 +189,7 @@
         // (built in) factory if specified.
         if (defaultClassName == null) {
             throw new SOAPException(
-                "Provider for " + factoryId + " cannot be found", null);
+                    "Provider for " + factoryId + " cannot be found", null);
         }
         return newInstance(defaultClassName, classLoader);
     }
@@ -200,7 +201,7 @@
      * Class.forName() on it so it will be loaded by the bootstrap class loader.
      */
     private static Class safeLoadClass(String className,
-            ClassLoader classLoader)
+                                       ClassLoader classLoader)
             throws ClassNotFoundException {
         try {
             // make sure that the current thread has an access to the package of the given name.
@@ -218,7 +219,7 @@
                 return classLoader.loadClass(className);
         } catch (SecurityException se) {
             // (only) default implementation can be loaded
-            // using bootstrap class loader ...
+            // using bootstrap class loader:
             if (isDefaultImplementation(className))
                 return Class.forName(className);
 
--- ./jaxws/src/share/jaxws_classes/javax/xml/soap/MessageFactory.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/javax/xml/soap/MessageFactory.java	Wed May 07 19:26:28 2014 -0700
@@ -96,8 +96,9 @@
      * @see SAAJMetaFactory
      */
 
-    public static MessageFactory newInstance()
-        throws SOAPException {
+    public static MessageFactory newInstance() throws SOAPException {
+
+
         try {
             MessageFactory factory = (MessageFactory) FactoryFinder.find(
                     MESSAGE_FACTORY_PROPERTY,
@@ -107,8 +108,8 @@
             if (factory != null) {
                 return factory;
             }
+            return newInstance(SOAPConstants.SOAP_1_1_PROTOCOL);
 
-            return newInstance(SOAPConstants.SOAP_1_1_PROTOCOL);
         } catch (Exception ex) {
             throw new SOAPException(
                     "Unable to create message factory for SOAP: "
--- ./jaxws/src/share/jaxws_classes/javax/xml/soap/MimeHeader.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/javax/xml/soap/MimeHeader.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/javax/xml/soap/MimeHeaders.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/javax/xml/soap/MimeHeaders.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/javax/xml/soap/Name.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/javax/xml/soap/Name.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/javax/xml/soap/Node.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/javax/xml/soap/Node.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/javax/xml/soap/SAAJResult.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/javax/xml/soap/SAAJResult.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/javax/xml/soap/SOAPBody.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/javax/xml/soap/SOAPBody.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/javax/xml/soap/SOAPBodyElement.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/javax/xml/soap/SOAPBodyElement.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/javax/xml/soap/SOAPConnection.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/javax/xml/soap/SOAPConnection.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/javax/xml/soap/SOAPConstants.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/javax/xml/soap/SOAPConstants.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/javax/xml/soap/SOAPElement.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/javax/xml/soap/SOAPElement.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/javax/xml/soap/SOAPElementFactory.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/javax/xml/soap/SOAPElementFactory.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/javax/xml/soap/SOAPEnvelope.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/javax/xml/soap/SOAPEnvelope.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/javax/xml/soap/SOAPException.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/javax/xml/soap/SOAPException.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/javax/xml/soap/SOAPFactory.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/javax/xml/soap/SOAPFactory.java	Wed May 07 19:26:28 2014 -0700
@@ -261,7 +261,8 @@
         throws SOAPException
     {
         try {
-            SOAPFactory factory = (SOAPFactory) FactoryFinder.find(SOAP_FACTORY_PROPERTY, DEFAULT_SOAP_FACTORY, false);
+            SOAPFactory factory = (SOAPFactory) FactoryFinder.find(
+                    SOAP_FACTORY_PROPERTY, DEFAULT_SOAP_FACTORY, false);
             if (factory != null)
                 return factory;
             return newInstance(SOAPConstants.SOAP_1_1_PROTOCOL);
--- ./jaxws/src/share/jaxws_classes/javax/xml/soap/SOAPFault.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/javax/xml/soap/SOAPFault.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/javax/xml/soap/SOAPFaultElement.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/javax/xml/soap/SOAPFaultElement.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/javax/xml/soap/SOAPHeader.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/javax/xml/soap/SOAPHeader.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/javax/xml/soap/SOAPHeaderElement.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/javax/xml/soap/SOAPHeaderElement.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/javax/xml/soap/SOAPMessage.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/javax/xml/soap/SOAPMessage.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/javax/xml/soap/SOAPPart.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/javax/xml/soap/SOAPPart.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jaxws/src/share/jaxws_classes/javax/xml/soap/Text.java	Tue Mar 18 12:34:51 2014 -0700
+++ ./jaxws/src/share/jaxws_classes/javax/xml/soap/Text.java	Wed May 07 19:26:28 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jdk/.hgtags	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/.hgtags	Wed May 07 19:26:47 2014 -0700
@@ -401,3 +401,26 @@
 2d80b7cd7aae76f0909a210414317dcf846ad651 jdk7u55-b11
 07be5d5508733ed37c11fcd21a13ae3c8288313b jdk7u55-b12
 92fd166252c2701092a510002f4cf9285a20473d jdk7u55-b13
+4a5651c84b1e6cf26dc9b19f00747e5004efba68 jdk7u55-b30
+ffd99c5975217a14609851602c5f5dc005234aba jdk7u55-b14
+88f1bf248cc520e0bf7ef17bc862f87aab958373 jdk7u55-b31
+db5a29c812ee25c34ce9cd97de6e0dae284a4e34 jdk7u60-b00
+def34c4a798678c424786a8f0d0508e90185958d jdk7u60-b01
+ff67c89658525e8903fb870861ed3645befd6bc5 jdk7u60-b02
+b1bcc999a8f1b4b4452b59c6636153bb0154cf5a jdk7u60-b03
+efc8886310cbccb941f826acfad2ad51a2891be5 jdk7u60-b04
+4fb749a3110727d5334c69793578a3254a053bf5 jdk7u60-b05
+46ca1ce7550f1463d60c3eacaf7b8cdc44b0c66e jdk7u60-b06
+d5a2f60006e3c4243abeee0f623e5c3f79372fd8 jdk7u60-b07
+0dd27693876d66d176457749d0f2161b219eba2d jdk7u60-b08
+7b571638b0f51bcbe04c088dfff569b4cba6bbdf jdk7u60-b09
+fb4981489b09594d2449527e2d511834cf8ad370 jdk7u60-b10
+c2bb87dae8a08eab6f4f336ce5a59865aa0214d6 jdk7u60-b11
+1a90de8005e3de2475fd9355dcdb6f5e60bf89cc jdk7u60-b12
+b06d4ed71ae0bc6e13f5a8437cb6388f17c66e84 jdk7u60-b13
+b7fbd9b4febf8961091fdf451d3da477602a8f1d jdk7u60-b14
+04882f9a073e8de153ec7ad32486569fd9a087ec jdk7u60-b15
+41547583c3a035c3924ffedfa8704e58d69e5c50 jdk7u60-b16
+e484202d9a4104840d758a21b2bba1250e766343 jdk7u60-b18
+e484202d9a4104840d758a21b2bba1250e766343 jdk7u60-b17
+7190843ddaf4f3ad158c3071be0f4ca42a5802dc jdk7u60-b19
--- ./jdk/make/bridge/AccessBridgeJava/Makefile	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/make/bridge/AccessBridgeJava/Makefile	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -51,7 +51,7 @@
 #
 # Java files to compile.
 #
-FILES_java = com/sun/java/accessibility/AccessBridge.java
+FILES_java = com/sun/java/accessibility/AccessBridgeLoader.java com/sun/java/accessibility/AccessBridge.java
 
 #
 # Location for the newly built classfiles.
@@ -68,7 +68,7 @@
 build: prebuild
 
 prebuild:
-	$(CP) $(CLOSED_PLATFORM_SRC)/classes/com/sun/java/accessibility/$(ABPLATFORM)/AccessBridge.java \
+	$(CP) $(CLOSED_PLATFORM_SRC)/classes/com/sun/java/accessibility/$(ABPLATFORM)/AccessBridgeLoader.java \
 		$(CLOSED_PLATFORM_SRC)/classes/com/sun/java/accessibility
 
 all : build $(JARFILE) 
--- ./jdk/make/com/oracle/Makefile	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/make/com/oracle/Makefile	Wed May 07 19:26:47 2014 -0700
@@ -30,22 +30,8 @@
 #SUBDIRS_MAKEFLAGS += JAVAC_LINT_OPTIONS=-Xlint:all,-deprecation,-path
 include $(BUILDDIR)/common/Defs.gmk
 
-JFR_SRCDIRS_EXIST := $(shell \
-  if [ -d $(CLOSED_SHARE_SRC)/native/oracle/jfr ] ; then \
-    echo true; \
-  else \
-    echo false; \
-  fi)
-
-JFR =
-ifndef OPENJDK
-  ifndef JAVASE_EMBEDDED
-    ifeq ($(JFR_SRCDIRS_EXIST), true)
-      ifneq (${ARCH},arm)
-        JFR = jfr
-      endif
-    endif
-  endif
+ifeq ($(BUILD_JFR), true)
+  JFR = jfr
 endif
 
 # build com/oracle/security/ucrypto on Solaris platform for non-OpenJDK builds
--- ./jdk/make/common/Defs-macosx.gmk	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/make/common/Defs-macosx.gmk	Wed May 07 19:26:47 2014 -0700
@@ -397,11 +397,14 @@
   INCLUDE_SA = true
 endif
 
-ifdef CROSS_COMPILE_ARCH
-  # X11 headers are not under /usr/include
-  OTHER_CFLAGS += -I$(OPENWIN_HOME)/include
-  OTHER_CXXFLAGS += -I$(OPENWIN_HOME)/include
-  OTHER_CPPFLAGS += -I$(OPENWIN_HOME)/include
-endif
+# X11 headers are not under /usr/include
+OTHER_CFLAGS += -I$(OPENWIN_HOME)/include
+OTHER_CXXFLAGS += -I$(OPENWIN_HOME)/include
+OTHER_CPPFLAGS += -I$(OPENWIN_HOME)/include
+
+# Use unlimited select
+OTHER_CFLAGS += -D_DARWIN_UNLIMITED_SELECT
+OTHER_CXXFLAGS += -D_DARWIN_UNLIMITED_SELECT
+OTHER_CPPFLAGS += -D_DARWIN_UNLIMITED_SELECT
 
 LIB_LOCATION ?= $(LIBDIR)
--- ./jdk/make/common/Release-macosx.gmk	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/make/common/Release-macosx.gmk	Wed May 07 19:26:47 2014 -0700
@@ -58,6 +58,9 @@
 jdk-bundle-setup:
 	$(RM) -r $(JDK_BUNDLE_DIR)
 
+jdk-server-bundle-setup:
+	$(RM) -r $(JDK_SERVER_BUNDLE_DIR)
+
 jre-bundle-files:
 	$(MKDIR) -p $(JRE_BUNDLE_DIR)/MacOS
 	ln -s ../Home/lib/jli/libjli.dylib $(JRE_BUNDLE_DIR)/MacOS/
@@ -79,6 +82,6 @@
 	$(SED) -e "s/@@ID@@/$(BUNDLE_ID_JDK)/g" -e "s/@@NAME@@/$(BUNDE_NAME_JDK)/g" -e "s/@@INFO@@/$(BUNDLE_INFO_JDK)/g" -e "s/@@PLATFORM_VERSION@@/$(BUNDLE_PLATFORM_VERSION)/g" -e "s/@@VERSION@@/$(BUNDLE_VERSION)/g" -e "s/@@VENDOR@@/$(BUNDLE_VENDOR)/g" < $(MACOSX_SRC)/bundle/JDK-Info.plist > $(JDK_SERVER_BUNDLE_DIR)/Info.plist
 	/usr/bin/SetFile -a B $(JDK_SERVER_BUNDLE_DIR)/../
 
-EXTRA_IMAGE_TARGETS += jre-bundle-setup jdk-bundle-setup jre-bundle-files jdk-bundle-files jdk-server-bundle-files
+EXTRA_IMAGE_TARGETS += jre-bundle-setup jdk-bundle-setup jdk-server-bundle-setup jre-bundle-files jdk-bundle-files jdk-server-bundle-files
 
 .PHONY: $(EXTRA_JRE_TARGETS) $(EXTRA_IMAGE_TARGETS)
--- ./jdk/make/common/Release.gmk	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/make/common/Release.gmk	Wed May 07 19:26:47 2014 -0700
@@ -402,25 +402,9 @@
 	sun/tools/jinfo         \
 	sun/tools/jmap
 
-JFR_SRCDIRS_EXIST := $(shell \
-  if [ -d $(CLOSED_SHARE_SRC)/classes/com/oracle/jrockit/jfr ] ; then \
-   echo true; \
-  else \
-   echo false; \
-  fi)
-
-BUILD_JFR=
-ifndef OPENJDK
-ifndef JAVASE_EMBEDDED
-ifeq ($(JFR_SRCDIRS_EXIST), true)
-BUILD_JFR=true
-endif
-endif
-endif
-
 # classes that go into jfr.jar
 JFR_CLASSES_DIRS=
-ifdef BUILD_JFR
+ifeq ($(BUILD_JFR), true)
 JFR_CLASSES_DIRS= \
 	com/oracle/jrockit/jfr \
 	oracle/jrockit/jfr \
@@ -629,7 +613,7 @@
 	$(ECHO) "sun/tools/jstack/" >> $@
 	$(ECHO) "sun/tools/jinfo/" >> $@
 	$(ECHO) "sun/tools/jmap/" >> $@
-ifdef BUILD_JFR
+ifeq ($(BUILD_JFR), true)
 	$(ECHO) "com/oracle/jrockit/jfr/" >> $@
 	$(ECHO) "com/oracle/jrockit/jfr/client/" >> $@
 	$(ECHO) "com/oracle/jrockit/jfr/management/" >> $@
@@ -668,7 +652,7 @@
 
 # Create jfr.jar
 JFR_JAR=
-ifdef BUILD_JFR
+ifeq ($(BUILD_JFR), true)
 JFR_JAR=$(ABS_TEMPDIR)/jfr-orig.jar
 $(JFR_JAR): $(OTHER_JAR_MANIFEST_FILE)
 	$(prep-target)
--- ./jdk/make/java/java/FILES_c.gmk	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/make/java/java/FILES_c.gmk	Wed May 07 19:26:47 2014 -0700
@@ -37,7 +37,6 @@
 	FileInputStream.c \
 	FileInputStream_md.c \
 	FileOutputStream_md.c \
-	Finalizer.c \
 	Float.c \
 	Object.c \
 	ObjectOutputStream.c \
--- ./jdk/make/java/java/Makefile	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/make/java/java/Makefile	Wed May 07 19:26:47 2014 -0700
@@ -102,6 +102,7 @@
 		java/util/prefs/MacOSXPreferencesFactory.java
 
 CFLAGS_$(VARIANT)/java_props_md.o = -Os -x objective-c
+CFLAGS_$(VARIANT)/java_props_macosx.o = -Os -x objective-c
 endif
 
 #
@@ -222,6 +223,7 @@
 ifeq ($(PLATFORM), macosx)
 OTHER_LDLIBS += \
         -framework CoreFoundation \
+        -framework Foundation \
         -framework Security \
         -framework SystemConfiguration
 endif
--- ./jdk/make/java/java/mapfile-vers	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/make/java/java/mapfile-vers	Wed May 07 19:26:47 2014 -0700
@@ -121,6 +121,7 @@
 		Java_java_io_UnixFileSystem_setReadOnly;
 		Java_java_io_UnixFileSystem_setPermission;
 		Java_java_lang_Class_forName0;
+                Java_java_lang_Class_getCheckMemberAccessMethod;
 		Java_java_lang_Class_getPrimitiveClass;
 		Java_java_lang_Class_isAssignableFrom;
 		Java_java_lang_Class_isInstance;
@@ -140,7 +141,6 @@
 		Java_java_lang_Double_doubleToRawLongBits;
 		Java_java_lang_reflect_Proxy_defineClass0;
 		Java_java_lang_Shutdown_runAllFinalizers;
-		Java_java_lang_ref_Finalizer_invokeFinalizeMethod;
 		Java_java_lang_Float_intBitsToFloat;
 		Java_java_lang_Float_floatToRawIntBits;
 		Java_java_lang_StrictMath_IEEEremainder;
--- ./jdk/make/java/java/reorder-i586	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/make/java/java/reorder-i586	Wed May 07 19:26:47 2014 -0700
@@ -77,7 +77,6 @@
 text: .text%JNU_GetEnv;
 text: .text%Java_java_io_UnixFileSystem_checkAccess;
 text: .text%Java_sun_reflect_NativeMethodAccessorImpl_invoke0;
-text: .text%Java_java_lang_ref_Finalizer_invokeFinalizeMethod;
 text: .text%Java_java_io_FileInputStream_available;
 text: .text%Java_java_lang_reflect_Array_newArray;
 text: .text%Java_java_lang_Throwable_getStackTraceDepth;
--- ./jdk/make/java/java/reorder-sparc	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/make/java/java/reorder-sparc	Wed May 07 19:26:47 2014 -0700
@@ -87,7 +87,6 @@
 text: .text%throwFileNotFoundException;
 text: .text%JNU_NotifyAll;
 # Test LoadFrame
-text: .text%Java_java_lang_ref_Finalizer_invokeFinalizeMethod;
 text: .text%JNU_CallMethodByName;
 text: .text%JNU_CallMethodByNameV;
 text: .text%Java_java_io_UnixFileSystem_createDirectory;
--- ./jdk/make/java/java/reorder-sparcv9	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/make/java/java/reorder-sparcv9	Wed May 07 19:26:47 2014 -0700
@@ -77,7 +77,6 @@
 text: .text%Java_java_security_AccessController_doPrivileged__Ljava_security_PrivilegedAction_2Ljava_security_AccessControlContext_2;
 text: .text%JNU_GetEnv;
 text: .text%Java_java_io_UnixFileSystem_checkAccess;
-text: .text%Java_java_lang_ref_Finalizer_invokeFinalizeMethod;
 text: .text%Java_java_lang_reflect_Array_newArray;
 text: .text%Java_java_lang_Throwable_getStackTraceDepth;
 text: .text%Java_java_lang_Throwable_getStackTraceElement;
--- ./jdk/make/sun/awt/Makefile	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/make/sun/awt/Makefile	Wed May 07 19:26:47 2014 -0700
@@ -191,6 +191,10 @@
 	sun/awt/windows/awtLocalization.properties
 endif
 
+ifeq ($(PLATFORM), macosx)
+  NEW_RESOURCE_BUNDLES_COMPILED_PROPERTIES += \
+        sun/awt/resources/awtosx.properties
+endif
 #
 # Rules
 #
--- ./jdk/make/sun/javazic/tzdata/VERSION	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/make/sun/javazic/tzdata/VERSION	Wed May 07 19:26:47 2014 -0700
@@ -21,4 +21,4 @@
 # or visit www.oracle.com if you need additional information or have any
 # questions.
 #
-tzdata2013i
+tzdata2014b
--- ./jdk/make/sun/javazic/tzdata/africa	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/make/sun/javazic/tzdata/africa	Wed May 07 19:26:47 2014 -0700
@@ -891,7 +891,10 @@
 # Another source (specifying the time for start and end in the decree):
 # http://www.lemag.ma/Heure-d-ete-au-Maroc-jusqu-au-27-octobre_a75620.html
 
-# From Paul Eggert (2013-10-03):
+# From Sebastien Willemijns (2014-03-18):
+# http://www.afriquinfos.com/articles/2014/3/18/maroc-heure-dete-avancez-tous-horloges-247891.asp
+
+# From Paul Eggert (2014-03-19):
 # To estimate what the Moroccan government will do in future years,
 # transition dates for 2014 through 2038 were determined by running
 # the following program under GNU Emacs 24.3:
--- ./jdk/make/sun/javazic/tzdata/antarctica	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/make/sun/javazic/tzdata/antarctica	Wed May 07 19:26:47 2014 -0700
@@ -253,24 +253,41 @@
 # year-round base
 # Scott Base, Ross Island, since 1957-01.
 # See Pacific/Auckland.
-#
-# These rules for New Zealand are stolen from the 'australasia' file.
-# Rule	NAME	FROM	TO	TYPE	IN	ON	AT	SAVE	LETTER/S
-Rule	NZAQ	1974	only	-	Nov	 3	2:00s	1:00	D
-Rule	NZAQ	1975	1988	-	Oct	lastSun	2:00s	1:00	D
-Rule	NZAQ	1989	only	-	Oct	 8	2:00s	1:00	D
-Rule	NZAQ	1990	2006	-	Oct	Sun>=1	2:00s	1:00	D
-Rule	NZAQ	1975	only	-	Feb	23	2:00s	0	S
-Rule	NZAQ	1976	1989	-	Mar	Sun>=1	2:00s	0	S
-Rule	NZAQ	1990	2007	-	Mar	Sun>=15	2:00s	0	S
-Rule	NZAQ	2007	max	-	Sep	lastSun	2:00s	1:00	D
-Rule	NZAQ	2008	max	-	Apr	Sun>=1	2:00s	0	S
 
 # Norway - territories
 # Bouvet (never inhabited)
 #
 # claims
 # Peter I Island (never inhabited)
+#
+# year-round base
+# Troll, Queen Maud Land, -720041+0023206, since 2005-02-12
+#
+# From Paul-Inge Flakstad (2014-03-10):
+# I recently had a long dialog about this with the developer of timegenie.com.
+# In the absence of specific dates, he decided to choose some likely ones:
+#   GMT +1 - From March 1 to the last Sunday in March
+#   GMT +2 - From the last Sunday in March until the last Sunday in October
+#   GMT +1 - From the last Sunday in October until November 7
+#   GMT +0 - From November 7 until March 1
+# The dates for switching to and from UTC+0 will probably not be absolutely
+# correct, but they should be quite close to the actual dates.
+#
+# From Paul Eggert (2014-03-21):
+# The CET-switching Troll rules require zic from tzcode 2014b or later, so as
+# suggested by Bengt-Inge Larsson comment them out for now, and approximate
+# with only UTC and CEST.  Uncomment them when 2014b is more prevalent.
+#
+# Rule	NAME	FROM	TO	TYPE	IN	ON	AT	SAVE	LETTER/S
+#Rule	Troll	2005	max	-	Mar	 1	1:00u	1:00	CET
+Rule	Troll	2005	max	-	Mar	lastSun	1:00u	2:00	CEST
+#Rule	Troll	2005	max	-	Oct	lastSun	1:00u	1:00	CET
+#Rule	Troll	2004	max	-	Nov	 7	1:00u	0:00	UTC
+# Remove the following line when uncommenting the above '#Rule' lines.
+Rule	Troll	2004	max	-	Oct	lastSun	1:00u	0:00	UTC
+# Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
+Zone Antarctica/Troll	0	-	zzz	2005 Feb 12
+     			0:00	Troll	%s
 
 # Poland - year-round base
 # Arctowski, King George Island, -620945-0582745, since 1977
--- ./jdk/make/sun/javazic/tzdata/asia	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/make/sun/javazic/tzdata/asia	Wed May 07 19:26:47 2014 -0700
@@ -1113,8 +1113,13 @@
 Rule	Zion	1986	only	-	Sep	 7	0:00	0	S
 Rule	Zion	1987	only	-	Apr	15	0:00	1:00	D
 Rule	Zion	1987	only	-	Sep	13	0:00	0	S
-Rule	Zion	1988	only	-	Apr	 9	0:00	1:00	D
-Rule	Zion	1988	only	-	Sep	 3	0:00	0	S
+
+# From Avigdor Finkelstein (2014-03-05):
+# I check the Parliament (Knesset) records and there it's stated that the
+# [1988] transition should take place on Saturday night, when the Sabbath
+# ends and changes to Sunday.
+Rule	Zion	1988	only	-	Apr	10	0:00	1:00	D
+Rule	Zion	1988	only	-	Sep	 4	0:00	0	S
 
 # From Ephraim Silverberg
 # (1997-03-04, 1998-03-16, 1998-12-28, 2000-01-17, 2000-07-25, 2004-12-22,
--- ./jdk/make/sun/javazic/tzdata/australasia	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/make/sun/javazic/tzdata/australasia	Wed May 07 19:26:47 2014 -0700
@@ -377,16 +377,18 @@
 # http://www.fiji.gov.fj/index.php?option=com_content&view=article&id=6702&catid=71&Itemid=155
 
 # From the Fijian Government Media Center (2013-08-30) via David Wheeler:
-# Fiji will start daylight savings on Sunday 27th October, 2013 and end at 3am
-# on Sunday 19th January, 2014....  move clocks forward by one hour from 2am
+# Fiji will start daylight savings on Sunday 27th October, 2013 ...
+# move clocks forward by one hour from 2am
 # http://www.fiji.gov.fj/Media-Center/Press-Releases/DAYLIGHT-SAVING-STARTS-ON-SUNDAY,-27th-OCTOBER-201.aspx
-#
-# From Paul Eggert (2013-09-09):
+
+# From Steffen Thorsen (2013-01-10):
+# Fiji will end DST on 2014-01-19 02:00:
+# http://www.fiji.gov.fj/Media-Center/Press-Releases/DAYLIGHT-SAVINGS-TO-END-THIS-MONTH-%281%29.aspx
+
+# From Paul Eggert (2014-01-10):
 # For now, guess that Fiji springs forward the Sunday before the fourth
-# Monday in October.  This matches both recent practice and
-# timeanddate.com's current spring-forward prediction.
-# For the January 2014 transition we guessed right while timeanddate.com
-# guessed wrong, so leave the fall-back prediction alone.
+# Monday in October, and springs back the penultimate Sunday in January.
+# This is ad hoc, but matches recent practice.
 
 # Rule	NAME	FROM	TO	TYPE	IN	ON	AT	SAVE	LETTER/S
 Rule	Fiji	1998	1999	-	Nov	Sun>=1	2:00	1:00	S
@@ -395,7 +397,8 @@
 Rule	Fiji	2010	only	-	Mar	lastSun	3:00	0	-
 Rule	Fiji	2010	max	-	Oct	Sun>=21	2:00	1:00	S
 Rule	Fiji	2011	only	-	Mar	Sun>=1	3:00	0	-
-Rule	Fiji	2012	max	-	Jan	Sun>=18	3:00	0	-
+Rule	Fiji	2012	2013	-	Jan	Sun>=18	3:00	0	-
+Rule	Fiji	2014	max	-	Jan	Sun>=18	2:00	0	-
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
 Zone	Pacific/Fiji	11:55:44 -	LMT	1915 Oct 26	# Suva
 			12:00	Fiji	FJ%sT	# Fiji Time
@@ -783,14 +786,29 @@
 
 # Johnston
 #
-# From Paul Eggert (2013-09-03):
+# From Paul Eggert (2014-03-11):
+# Sometimes Johnston kept Hawaii time, and sometimes it was an hour behind.
+# Details are uncertain.  We have no data for Johnston after 1970, so
+# treat it like Hawaii for now.
+#
 # In his memoirs of June 6th to October 4, 1945
 # <http://www.315bw.org/Herb_Bach.htm> (2005), Herbert C. Bach writes,
 # "We started our letdown to Kwajalein Atoll and landed there at 5:00 AM
 # Johnston time, 1:30 AM Kwajalein time."  This was in June 1945, and
 # confirms that Johnston kept the same time as Honolulu in summer 1945.
-# We have no better information, so for now, assume this has been true
-# indefinitely into the past.
+#
+# From Lyle McElhaney (2014-03-11):
+# [W]hen JI was being used for that [atomic bomb] testing, the time being used
+# was not Hawaiian time but rather the same time being used on the ships,
+# which had a GMT offset of -11 hours.  This apparently applied to at least the
+# time from Operation Newsreel (Hardtack I/Teak shot, 1958-08-01) to the last
+# Operation Fishbowl shot (Tightrope, 1962-11-04).... [See] Herman Hoerlin,
+# "The United States High-Altitude Test Experience: A Review Emphasizing the
+# Impact on the Environment", Los Alamos LA-6405, Oct 1976
+# <http://www.fas.org/sgp/othergov/doe/lanl/docs1/00322994.pdf>.
+# See the table on page 4 where he lists GMT and local times for the tests; a
+# footnote for the JI tests reads that local time is "JI time = Hawaii Time
+# Minus One Hour".
 #
 # See 'northamerica' for Pacific/Johnston.
 
--- ./jdk/make/sun/javazic/tzdata/europe	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/make/sun/javazic/tzdata/europe	Wed May 07 19:26:47 2014 -0700
@@ -2768,14 +2768,18 @@
 # According to the articles linked below, Turkey will change into summer
 # time zone (GMT+3) on March 28, 2011 at 3:00 a.m. instead of March 27.
 # This change is due to a nationwide exam on 27th.
-#
-# <a href="http://www.worldbulletin.net/?aType=haber&ArticleID=70872">
 # http://www.worldbulletin.net/?aType=haber&ArticleID=70872
-# </a>
 # Turkish:
-# <a href="http://www.hurriyet.com.tr/ekonomi/17230464.asp?gid=373">
 # http://www.hurriyet.com.tr/ekonomi/17230464.asp?gid=373
-# </a>
+
+# From Faruk Pasin (2014-02-14):
+# The DST for Turkey has been changed for this year because of the
+# Turkish Local election....
+# http://www.sabah.com.tr/Ekonomi/2014/02/12/yaz-saatinde-onemli-degisiklik
+# ... so Turkey will move clocks forward one hour on March 31 at 3:00 a.m.
+# From Paul Eggert (2014-02-17):
+# Here is an English-language source:
+# http://www.worldbulletin.net/turkey/129016/turkey-switches-to-daylight-saving-time-march-31
 
 # Rule	NAME	FROM	TO	TYPE	IN	ON	AT	SAVE	LETTER/S
 Rule	Turkey	1916	only	-	May	 1	0:00	1:00	S
@@ -2844,6 +2848,8 @@
 			2:00	Turkey	EE%sT	2007
 			2:00	EU	EE%sT	2011 Mar 27 1:00u
 			2:00	-	EET	2011 Mar 28 1:00u
+			2:00	EU	EE%sT	2014 Mar 30 1:00u
+			2:00	-	EET	2014 Mar 31 1:00u
 			2:00	EU	EE%sT
 Link	Europe/Istanbul	Asia/Istanbul	# Istanbul is in both continents.
 
@@ -2865,19 +2871,13 @@
 # approval from 266 deputies.
 #
 # Ukraine abolishes transter back to the winter time (in Russian)
-# <a href="http://news.mail.ru/politics/6861560/">
 # http://news.mail.ru/politics/6861560/
-# </a>
 #
 # The Ukrainians will no longer change the clock (in Russian)
-# <a href="http://www.segodnya.ua/news/14290482.html">
 # http://www.segodnya.ua/news/14290482.html
-# </a>
 #
 # Deputies cancelled the winter time (in Russian)
-# <a href="http://www.pravda.com.ua/rus/news/2011/09/20/6600616/">
 # http://www.pravda.com.ua/rus/news/2011/09/20/6600616/
-# </a>
 #
 # From Philip Pizzey (2011-10-18):
 # Today my Ukrainian colleagues have informed me that the
@@ -2888,18 +2888,39 @@
 # As far as I understand, the recent change to the Ukrainian time zone
 # (Europe/Kiev) to introduce permanent daylight saving time (similar
 # to Russia) was reverted today:
-#
-# <a href="http://portal.rada.gov.ua/rada/control/en/publish/article/info_left?art_id=287324&cat_id=105995">
 # http://portal.rada.gov.ua/rada/control/en/publish/article/info_left?art_id=287324&cat_id=105995
-# </a>
 #
 # Also reported by Alexander Bokovoy (2011-10-18) who also noted:
 # The law documents themselves are at
+# http://w1.c1.rada.gov.ua/pls/zweb_n/webproc4_1?id=&pf3511=41484
+
+# From Vladimir in Moscow via Alois Treindl re Kiev time 1991/2 (2014-02-28):
+# First in Ukraine they changed Time zone from UTC+3 to UTC+2 with DST:
+#       03 25 1990 02:00 -03.00 1       Time Zone 3 with DST
+#       07 01 1990 02:00 -02.00 1       Time Zone 2 with DST
+# * Ukrainian Government's Resolution of 18.06.1990, No. 134.
+# http://search.ligazakon.ua/l_doc2.nsf/link1/T001500.html
 #
-# <a href="http://w1.c1.rada.gov.ua/pls/zweb_n/webproc4_1?id=&pf3511=41484">
-# http://w1.c1.rada.gov.ua/pls/zweb_n/webproc4_1?id=&pf3511=41484
-# </a>
-
+# They did not end DST in September, 1990 (according to the law,
+# "summer time" was still in action):
+#       09 30 1990 03:00 -02.00 1       Time Zone 2 with DST
+# * Ukrainian Government's Resolution of 21.09.1990, No. 272.
+# http://search.ligazakon.ua/l_doc2.nsf/link1/KP900272.html
+#
+# Again no change in March, 1991 ("summer time" in action):
+#       03 31 1991 02:00 -02.00 1       Time Zone 2 with DST
+#
+# DST ended in September 1991 ("summer time" ended):
+#       09 29 1991 03:00 -02.00 0       Time Zone 2, no DST
+# * Ukrainian Government's Resolution of 25.09.1991, No. 225.
+# http://www.uazakon.com/documents/date_21/pg_iwgdoc.htm
+# This is an answer.
+#
+# Since 1992 they had normal DST procedure:
+#       03 29 1992 02:00 -02.00 1       DST started
+#       09 27 1992 03:00 -02.00 0       DST ended
+# * Ukrainian Government's Resolution of 20.03.1992, No. 139.
+# http://www.uazakon.com/documents/date_8u/pg_grcasa.htm
 
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
 # Most of Ukraine since 1970 has been like Kiev.
@@ -2910,9 +2931,8 @@
 			2:00	-	EET	1930 Jun 21
 			3:00	-	MSK	1941 Sep 20
 			1:00	C-Eur	CE%sT	1943 Nov  6
-			3:00	Russia	MSK/MSD	1990
-			3:00	-	MSK	1990 Jul  1 2:00
-			2:00	-	EET	1992
+			3:00	Russia	MSK/MSD	1990 Jul  1 2:00
+			2:00	1:00	EEST	1991 Sep 29 3:00
 			2:00	E-Eur	EE%sT	1995
 			2:00	EU	EE%sT
 # Ruthenia used CET 1990/1991.
@@ -2966,7 +2986,11 @@
 # Assume it happened in March by not changing the clocks.
 			3:00	Russia	MSK/MSD	1997
 			3:00	-	MSK	1997 Mar lastSun 1:00u
-			2:00	EU	EE%sT
+# From Alexander Krivenyshev (2014-03-17):
+# time change at 2:00 (2am) on March 30, 2014
+# http://vz.ru/news/2014/3/17/677464.html
+			2:00	EU	EE%sT	2014 Mar 30 2:00
+			4:00	-	MSK
 
 # Vatican City
 # See Europe/Rome.
--- ./jdk/make/sun/javazic/tzdata/leapseconds	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/make/sun/javazic/tzdata/leapseconds	Wed May 07 19:26:47 2014 -0700
@@ -20,7 +20,7 @@
 # Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 # or visit www.oracle.com if you need additional information or have any
 # questions.
-
+#
 # Allowance for leapseconds added to each timezone file.
 
 # This file is in the public domain.
--- ./jdk/make/sun/javazic/tzdata/northamerica	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/make/sun/javazic/tzdata/northamerica	Wed May 07 19:26:47 2014 -0700
@@ -414,9 +414,10 @@
 # US Pacific time, represented by Los Angeles
 #
 # California, northern Idaho (Benewah, Bonner, Boundary, Clearwater,
-# Idaho, Kootenai, Latah, Lewis, Nez Perce, and Shoshone counties,
-# and the northern three-quarters of Idaho county),
-# most of Nevada, most of Oregon, and Washington
+# Kootenai, Latah, Lewis, Nez Perce, and Shoshone counties, Idaho county
+# north of the Salmon River, and the towns of Burgdorf and Warren),
+# Nevada (except West Wendover), Oregon (except the northern 3/4 of
+# Malheur county), and Washington
 #
 # Rule	NAME	FROM	TO	TYPE	IN	ON	AT	SAVE	LETTER
 Rule	CA	1948	only	-	Mar	14	2:00	1:00	D
--- ./jdk/make/sun/javazic/tzdata/southamerica	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/make/sun/javazic/tzdata/southamerica	Wed May 07 19:26:47 2014 -0700
@@ -1298,6 +1298,13 @@
 # start date is 2013-09-08 00:00....
 # http://www.gob.cl/informa/2013/02/15/gobierno-anuncia-fechas-de-cambio-de-hora-para-el-ano-2013.htm
 
+# From Jose Miguel Garrido (2014-02-19):
+# Today appeared in the Diario Oficial a decree amending the time change
+# dates to 2014.
+# DST End: last Saturday of April 2014 (Sun 27 Apr 2014 03:00 UTC)
+# DST Start: first Saturday of September 2014 (Sun 07 Sep 2014 04:00 UTC)
+# http://www.diariooficial.interior.gob.cl//media/2014/02/19/do-20140219.pdf
+
 # NOTE: ChileAQ rules for Antarctic bases are stored separately in the
 # 'antarctica' file.
 
@@ -1631,6 +1638,9 @@
 # From Carlos Raul Perasso (2013-03-15):
 # The change in Paraguay is now final.  Decree number 10780
 # http://www.presidencia.gov.py/uploads/pdf/presidencia-3b86ff4b691c79d4f5927ca964922ec74772ce857c02ca054a52a37b49afc7fb.pdf
+# From Carlos Raul Perasso (2014-02-28):
+# Decree 1264 can be found at:
+# http://www.presidencia.gov.py/archivos/documentos/DECRETO1264_ey9r8zai.pdf
 Rule	Para	2013	max	-	Mar	Sun>=22	0:00	0	-
 
 # Zone	NAME		GMTOFF	RULES	FORMAT	[UNTIL]
@@ -1689,18 +1699,19 @@
 Zone America/Port_of_Spain -4:06:04 -	LMT	1912 Mar 2
 			-4:00	-	AST
 
+# These all agree with Trinidad and Tobago since 1970.
 Link America/Port_of_Spain America/Anguilla
 Link America/Port_of_Spain America/Dominica
 Link America/Port_of_Spain America/Grenada
 Link America/Port_of_Spain America/Guadeloupe
-Link America/Port_of_Spain America/Marigot
+Link America/Port_of_Spain America/Marigot	# St Martin (French part)
 Link America/Port_of_Spain America/Montserrat
 Link America/Port_of_Spain America/St_Barthelemy
-Link America/Port_of_Spain America/St_Kitts
+Link America/Port_of_Spain America/St_Kitts	# St Kitts & Nevis
 Link America/Port_of_Spain America/St_Lucia
-Link America/Port_of_Spain America/St_Thomas
+Link America/Port_of_Spain America/St_Thomas	# Virgin Islands (US)
 Link America/Port_of_Spain America/St_Vincent
-Link America/Port_of_Spain America/Tortola
+Link America/Port_of_Spain America/Tortola	# Virgin Islands (UK)
 
 # Uruguay
 # From Paul Eggert (1993-11-18):
--- ./jdk/make/sun/javazic/tzdata/zone.tab	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/make/sun/javazic/tzdata/zone.tab	Wed May 07 19:26:47 2014 -0700
@@ -74,6 +74,7 @@
 AQ	-7824+10654	Antarctica/Vostok	Vostok Station, Lake Vostok
 AQ	-6640+14001	Antarctica/DumontDUrville	Dumont-d'Urville Station, Terre Adelie
 AQ	-690022+0393524	Antarctica/Syowa	Syowa Station, E Ongul I
+AQ	-720041+0023206	Antarctica/Troll	Troll Station, Queen Maud Land
 AR	-3436-05827	America/Argentina/Buenos_Aires	Buenos Aires (BA, CF)
 AR	-3124-06411	America/Argentina/Cordoba	most locations (CB, CC, CN, ER, FM, MN, SE, SF)
 AR	-2447-06525	America/Argentina/Salta	(SA, LP, NQ, RN)
@@ -366,6 +367,7 @@
 RU	+5545+03735	Europe/Moscow	Moscow+00 - west Russia
 RU	+4844+04425	Europe/Volgograd	Moscow+00 - Caspian Sea
 RU	+5312+05009	Europe/Samara	Moscow+00 - Samara, Udmurtia
+RU	+4457+03406	Europe/Simferopol	Moscow+00 - Crimea
 RU	+5651+06036	Asia/Yekaterinburg	Moscow+02 - Urals
 RU	+5500+07324	Asia/Omsk	Moscow+03 - west Siberia
 RU	+5502+08255	Asia/Novosibirsk	Moscow+03 - Novosibirsk
@@ -421,7 +423,6 @@
 UA	+5026+03031	Europe/Kiev	most locations
 UA	+4837+02218	Europe/Uzhgorod	Ruthenia
 UA	+4750+03510	Europe/Zaporozhye	Zaporozh'ye, E Lugansk / Zaporizhia, E Luhansk
-UA	+4457+03406	Europe/Simferopol	central Crimea
 UG	+0019+03225	Africa/Kampala
 UM	+1645-16931	Pacific/Johnston	Johnston Atoll
 UM	+2813-17722	Pacific/Midway	Midway Islands
--- ./jdk/make/sun/nio/cs/Makefile	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/make/sun/nio/cs/Makefile	Wed May 07 19:26:47 2014 -0700
@@ -85,9 +85,6 @@
 #
 # Extra rules to build character converters.
 
-SERVICE_DESCRIPTION = java.nio.charset.spi.CharsetProvider
-SERVICE_DESCRIPTION_PATH = META-INF/services/$(SERVICE_DESCRIPTION)
-
 GENCSDATASRC = $(BUILDDIR)/tools/CharsetMapping
 GENCSSRCDIR = $(BUILDDIR)/tools/src/build/tools/charsetmapping
 GENCSEXT = $(GENSRCDIR)/sun/nio/cs/ext
@@ -116,10 +113,6 @@
 		$(GENCSSRCDIR)/HKSCS.java
 	$(BOOT_JAVA_CMD) -jar $(CHARSETMAPPING_JARFILE) $(GENCSDATASRC) $(GENCSEXT) dbcs
 
-$(CLASSDESTDIR)/$(SERVICE_DESCRIPTION_PATH): \
-  $(SHARE_SRC)/classes/sun/nio/cs/ext/$(SERVICE_DESCRIPTION_PATH)
-	$(install-file)
-
 # no compression unless requested
 ifndef COMPRESS_JARS
   CREATE_JAR_OPTS_NOMANIFEST = cf0
@@ -127,10 +120,9 @@
   CREATE_JAR_OPTS_NOMANIFEST = cf
 endif
 
-$(CHARSETS_JAR): $(FILES_class) $(CLASSDESTDIR)/$(SERVICE_DESCRIPTION_PATH) $(FILES_DAT)
+$(CHARSETS_JAR): $(FILES_class) $(FILES_DAT)
 	$(BOOT_JAR_CMD) $(CREATE_JAR_OPTS_NOMANIFEST) $(CHARSETS_JAR) \
 	      -C $(CLASSDESTDIR) sun \
-	      -C $(CLASSDESTDIR) $(SERVICE_DESCRIPTION_PATH)  \
 	      $(BOOT_JAR_JFLAGS)
 	@$(java-vm-cleanup)
 
--- ./jdk/src/macosx/classes/com/apple/eawt/_AppMenuBarHandler.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/macosx/classes/com/apple/eawt/_AppMenuBarHandler.java	Wed May 07 19:26:47 2014 -0700
@@ -31,6 +31,7 @@
 import javax.swing.*;
 import javax.swing.plaf.MenuBarUI;
 
+import com.apple.laf.ScreenMenuBar;
 import sun.lwawt.macosx.CMenuBar;
 
 import com.apple.laf.AquaMenuBarUI;
@@ -72,12 +73,15 @@
         // scan the current frames, and see if any are foreground
         final Frame[] frames = Frame.getFrames();
         for (final Frame frame : frames) {
-            if (frame.isVisible() && !isFrameMinimized(frame)) return;
+            if (frame.isVisible() && !isFrameMinimized(frame)) {
+                return;
+            }
         }
 
         // if we have no foreground frames, then we have to "kick" the menubar
         final JFrame pingFrame = new JFrame();
         pingFrame.getRootPane().putClientProperty("Window.alpha", new Float(0.0f));
+        pingFrame.setUndecorated(true);
         pingFrame.setVisible(true);
         pingFrame.toFront();
         pingFrame.setVisible(false);
@@ -101,7 +105,6 @@
             // Aqua was not installed
             throw new IllegalStateException("Application.setDefaultMenuBar() only works with the Aqua Look and Feel");
         }
-/* TODO: disabled until ScreenMenuBar is working
 
         final AquaMenuBarUI aquaUI = (AquaMenuBarUI)ui;
         final ScreenMenuBar screenMenuBar = aquaUI.getScreenMenuBar();
@@ -118,8 +121,7 @@
         }
 
         // grab the pointer to the CMenuBar, and retain it in native
-        nativeSetDefaultMenuBar(((CMenuBar)peer).getNativeMenuBarPeer());
-*/
+        nativeSetDefaultMenuBar(((CMenuBar)peer).getModel());
     }
 
     void setAboutMenuItemVisible(final boolean present) {
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/src/macosx/classes/sun/awt/resources/awtosx.properties	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,71 @@
+#
+# OS X specific AWT properties
+#
+
+# Modifier names
+AWT.shift=\u21e7
+AWT.control=\u2303
+AWT.alt=\u2325
+AWT.meta=\u2318
+AWT.altGraph=\u2325
+
+# Key names
+AWT.enter=\u23ce
+AWT.backSpace=\u232b
+AWT.tab=\u21e5
+AWT.cancel=\u238b
+AWT.clear=\u2327
+AWT.capsLock=\u21ea
+AWT.escape=\u238b
+AWT.space=\u2423
+AWT.pgup=\u21de
+AWT.pgdn=\u21df
+AWT.end=\u2198
+AWT.home=\u2196
+AWT.left=\u2190
+AWT.up=\u2191
+AWT.right=\u2192
+AWT.down=\u2193
+AWT.comma=,
+AWT.period=.
+AWT.slash=/
+AWT.semicolon=;
+AWT.equals=\u003d
+AWT.openBracket=[
+AWT.backSlash=\\
+AWT.closeBracket=]
+AWT.multiply=\u2328 *
+AWT.add=\u2328 +
+AWT.separator=\u2328 ,
+AWT.separater=\u2328 ,
+AWT.subtract=\u2328 -
+AWT.decimal=\u2328 .
+AWT.divide=\u2328 /
+AWT.delete=\u2326
+AWT.printScreen=\u2399
+AWT.backQuote=`
+AWT.quote='
+AWT.ampersand=&
+AWT.asterisk=*
+AWT.quoteDbl="
+AWT.Less=<
+AWT.greater=>
+AWT.braceLeft=[
+AWT.braceRight=]
+AWT.at=@
+AWT.colon=:
+AWT.circumflex=^
+AWT.dollar=$
+AWT.euro=\u20ac
+AWT.exclamationMark=!
+AWT.invertedExclamationMark=\u00a1
+AWT.leftParenthesis=(
+AWT.numberSign=#
+AWT.plus=+
+AWT.minus=-
+AWT.rightParenthesis=)
+AWT.underscore=_
+
+# Numeric Keypad
+AWT.numpad=\u2328
+
--- ./jdk/src/macosx/classes/sun/lwawt/macosx/CDropTargetContextPeer.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/macosx/classes/sun/lwawt/macosx/CDropTargetContextPeer.java	Wed May 07 19:26:47 2014 -0700
@@ -26,6 +26,7 @@
 package sun.lwawt.macosx;
 
 import java.awt.*;
+import java.awt.dnd.DropTarget;
 
 import sun.awt.dnd.SunDropTargetContextPeer;
 import sun.awt.dnd.SunDropTargetEvent;
@@ -38,7 +39,7 @@
     private long    fNativeDropTransfer = 0;
     private long    fNativeDataAvailable = 0;
     private Object  fNativeData    = null;
-    private boolean insideTarget = true;
+    private DropTarget insideTarget = null;
 
     Object awtLockAccess = new Object();
 
@@ -88,26 +89,19 @@
         return fNativeData;
     }
 
-    // We need to take care of dragExit message because for some reason it is not being
-    // generated for lightweight components
+    // We need to take care of dragEnter and dragExit messages because
+    // native system generates them only for heavyweights
     @Override
     protected void processMotionMessage(SunDropTargetEvent event, boolean operationChanged) {
-        Component eventSource = (Component)event.getComponent();
-        Point screenPoint = event.getPoint();
-        SwingUtilities.convertPointToScreen(screenPoint, eventSource);
-        Rectangle screenBounds = new Rectangle(eventSource.getLocationOnScreen().x,
-                eventSource.getLocationOnScreen().y,
-                eventSource.getWidth(), eventSource.getHeight());
-        if(insideTarget) {
-            if(!screenBounds.contains(screenPoint)) {
+        boolean eventInsideTarget = isEventInsideTarget(event);
+        if (event.getComponent().getDropTarget() == insideTarget) {
+            if (!eventInsideTarget) {
                 processExitMessage(event);
-                insideTarget = false;
                 return;
             }
         } else {
-            if(screenBounds.contains(screenPoint)) {
+            if (eventInsideTarget) {
                 processEnterMessage(event);
-                insideTarget = true;
             } else {
                 return;
             }
@@ -115,17 +109,52 @@
         super.processMotionMessage(event, operationChanged);
     }
 
+    /**
+     * Could be called when DnD enters a heavyweight or synthesized in processMotionMessage
+     */
+    @Override
+    protected void processEnterMessage(SunDropTargetEvent event) {
+        Component c = event.getComponent();
+        DropTarget dt = event.getComponent().getDropTarget();
+        if (isEventInsideTarget(event)
+                && dt != insideTarget
+                && c.isShowing()
+                && dt != null
+                && dt.isActive()) {
+            insideTarget = dt;
+            super.processEnterMessage(event);
+        }
+    }
+
+    /**
+     * Could be called when DnD exits a heavyweight or synthesized in processMotionMessage
+     */
+    @Override
+    protected void processExitMessage(SunDropTargetEvent event) {
+        if (event.getComponent().getDropTarget() == insideTarget) {
+            insideTarget = null;
+            super.processExitMessage(event);
+        }
+    }
+
     @Override
     protected void processDropMessage(SunDropTargetEvent event) {
-        Component eventSource = (Component)event.getComponent();
+        if (isEventInsideTarget(event)) {
+            super.processDropMessage(event);
+            insideTarget = null;
+        }
+    }
+
+    private boolean isEventInsideTarget(SunDropTargetEvent event) {
+        Component eventSource = event.getComponent();
         Point screenPoint = event.getPoint();
         SwingUtilities.convertPointToScreen(screenPoint, eventSource);
-        Rectangle screenBounds = new Rectangle(eventSource.getLocationOnScreen().x,
-                eventSource.getLocationOnScreen().y,
-                eventSource.getWidth(), eventSource.getHeight());
-        if(screenBounds.contains(screenPoint)) {
-            super.processDropMessage(event);
-        }
+        Point locationOnScreen = eventSource.getLocationOnScreen();
+        Rectangle screenBounds = new Rectangle(locationOnScreen.x,
+                                               locationOnScreen.y,
+                                               eventSource.getWidth(),
+                                               eventSource.getHeight());
+        return screenBounds.contains(screenPoint);
     }
 
     @Override
--- ./jdk/src/macosx/classes/sun/lwawt/macosx/CMenuComponent.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/macosx/classes/sun/lwawt/macosx/CMenuComponent.java	Wed May 07 19:26:47 2014 -0700
@@ -43,7 +43,7 @@
         return target;
     }
 
-    long getModel() {
+    public long getModel() {
         return modelPtr;
     }
 
--- ./jdk/src/macosx/classes/sun/lwawt/macosx/LWCToolkit.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/macosx/classes/sun/lwawt/macosx/LWCToolkit.java	Wed May 07 19:26:47 2014 -0700
@@ -44,6 +44,8 @@
 import sun.lwawt.LWWindowPeer.PeerType;
 import sun.security.action.GetBooleanAction;
 
+import sun.util.CoreResourceBundleControl;
+
 
 class NamedCursor extends Cursor {
     NamedCursor(String name) {
@@ -68,13 +70,26 @@
 
     static {
         System.err.flush();
-        java.security.AccessController.doPrivileged(new java.security.PrivilegedAction<Object>() {
-            public Object run() {
+        ResourceBundle platformResources = java.security.AccessController.doPrivileged(
+                new java.security.PrivilegedAction<ResourceBundle>() {
+            public ResourceBundle run() {
+                ResourceBundle platformResources = null;
+                try {
+                    platformResources =
+                            ResourceBundle.getBundle("sun.awt.resources.awtosx",
+                                    CoreResourceBundleControl.getRBControlInstance());
+                } catch (MissingResourceException e) {
+                    // No resource file; defaults will be used.
+                }
+
                 System.loadLibrary("awt");
                 System.loadLibrary("fontmanager");
-                return null;
+                return platformResources;
             }
         });
+
+        AWTAccessor.getToolkitAccessor().setPlatformResources(platformResources);
+
         if (!GraphicsEnvironment.isHeadless()) {
             initIDs();
         }
--- ./jdk/src/macosx/lib/flavormap.properties	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/macosx/lib/flavormap.properties	Wed May 07 19:26:47 2014 -0700
@@ -76,5 +76,6 @@
 text/uri-list=application/x-java-file-list;class=java.util.List
 PNG=image/x-java-image;class=java.awt.Image
 JFIF=image/x-java-image;class=java.awt.Image
+TIFF=image/x-java-image;class=java.awt.Image
 RICH_TEXT=text/rtf
 HTML=text/html;charset=utf-8;eoln="\r\n";terminators=1
--- ./jdk/src/macosx/native/java/util/SCDynamicStoreConfig.m	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/macosx/native/java/util/SCDynamicStoreConfig.m	Wed May 07 19:26:47 2014 -0700
@@ -103,7 +103,6 @@
         CFTypeRef realmInfo = SCDynamicStoreCopyValue(store, (CFStringRef) [NSString stringWithFormat:@"Kerberos:%@", realm]);
 
         if (CFGetTypeID(realmInfo) != CFDictionaryGetTypeID()) {
-            NSLog(@"Unexpected CFType for realm Info: %lu", CFGetTypeID(realmInfo));
             return nil;
         }
 
@@ -140,7 +139,6 @@
 
     SCDynamicStoreRef store = SCDynamicStoreCreate(NULL, CFSTR("java"), _SCDynamicStoreCallBack, NULL);
     if (store == NULL) {
-        NSLog(@"Unable to load SCDynamicStore to install NotificationCallback");
         return;
     }
 
@@ -171,19 +169,11 @@
 
     SCDynamicStoreRef store = SCDynamicStoreCreate(NULL, CFSTR("java-kerberos"), NULL, NULL);
     if (store == NULL) {
-        NSLog(@"Unable to load SCDynamicStore");
-        return NULL;
-    }
-
-    // Create the store if it is NULL and set it.
-    if (store == NULL) {
-        NSLog(@"Invalid value for SCDynamicStore");
         return NULL;
     }
 
     CFTypeRef realms = SCDynamicStoreCopyValue(store, (CFStringRef) KERBEROS_DEFAULT_REALMS);
     if (realms == NULL || CFGetTypeID(realms) != CFArrayGetTypeID()) {
-        NSLog(@"Unable to load realm info from SCDynamicStore");
         if (realms) CFRelease(realms);
         CFRelease(store);
         return NULL;
@@ -192,7 +182,6 @@
     CFTypeRef realmMappings = SCDynamicStoreCopyValue(store, (CFStringRef) KERBEROS_DEFAULT_REALM_MAPPINGS);
 
     if (realmMappings == NULL || CFGetTypeID(realmMappings) != CFArrayGetTypeID()) {
-        NSLog(@"Unable to load realm mapping info from SCDynamicStore");
         if (realmMappings) CFRelease(realmMappings);
         CFRelease(realms);
         CFRelease(store);
--- ./jdk/src/macosx/native/sun/awt/AWTEvent.m	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/macosx/native/sun/awt/AWTEvent.m	Wed May 07 19:26:47 2014 -0700
@@ -382,7 +382,7 @@
 {
     TISInputSourceRef currentKeyboard = TISCopyCurrentKeyboardInputSource();
     CFDataRef uchr = (CFDataRef)TISGetInputSourceProperty(currentKeyboard, kTISPropertyUnicodeKeyLayoutData);
-    if (uchr == nil) { return; }
+    if (uchr == nil) { return 0; }
     const UCKeyboardLayout *keyboardLayout = (const UCKeyboardLayout*)CFDataGetBytePtr(uchr);
     // Carbon modifiers should be used instead of NSEvent modifiers
     UInt32 modifierKeyState = (GetCurrentEventKeyModifiers() >> 8) & 0xFF;
--- ./jdk/src/macosx/native/sun/awt/AWTWindow.m	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/macosx/native/sun/awt/AWTWindow.m	Wed May 07 19:26:47 2014 -0700
@@ -30,6 +30,7 @@
 #import "sun_lwawt_macosx_CPlatformWindow.h"
 #import "com_apple_eawt_event_GestureHandler.h"
 #import "com_apple_eawt_FullScreenHandler.h"
+#import "ApplicationDelegate.h"
 
 #import "AWTWindow.h"
 #import "AWTView.h"
@@ -585,17 +586,26 @@
 AWT_ASSERT_APPKIT_THREAD;
     [AWTToolkit eventCountPlusPlus];
     AWTWindow *opposite = [AWTWindow lastKeyWindow];
-    
+
     // Finds appropriate menubar in our hierarchy,
     AWTWindow *awtWindow = self;
     while (awtWindow.ownerWindow != nil) {
         awtWindow = awtWindow.ownerWindow;
     }
+
     CMenuBar *menuBar = nil;
+    BOOL isDisabled = NO;
     if ([awtWindow.nsWindow isVisible]){
         menuBar = awtWindow.javaMenuBar;
+        isDisabled = !awtWindow.isEnabled;
     }
-    [CMenuBar activate:menuBar modallyDisabled:!awtWindow.isEnabled];
+
+    if (menuBar == nil) {
+        menuBar = [[ApplicationDelegate sharedDelegate] defaultMenuBar];
+        isDisabled = NO;
+    }
+
+    [CMenuBar activate:menuBar modallyDisabled:isDisabled];
 
     [AWTWindow setLastKeyWindow:nil];
 
@@ -608,6 +618,14 @@
     [AWTToolkit eventCountPlusPlus];
     [self.javaMenuBar deactivate];
 
+    // In theory, this might cause flickering if the window gaining focus
+    // has its own menu. However, I couldn't reproduce it on practice, so
+    // perhaps this is a non issue.
+    CMenuBar* defaultMenu = [[ApplicationDelegate sharedDelegate] defaultMenuBar];
+    if (defaultMenu != nil) {
+        [CMenuBar activate:defaultMenu modallyDisabled:NO];
+    }
+
     // the new key window
     NSWindow *keyWindow = [NSApp keyWindow];
     AWTWindow *opposite = nil;
@@ -875,11 +893,19 @@
 
         AWTWindow *window = (AWTWindow*)[nsWindow delegate];
 
-        if ([nsWindow isKeyWindow]) [window.javaMenuBar deactivate];
+        if ([nsWindow isKeyWindow]) {
+            [window.javaMenuBar deactivate];
+        }
+
         window.javaMenuBar = menuBar;
 
+        CMenuBar* actualMenuBar = menuBar;
+        if (actualMenuBar == nil) {
+            actualMenuBar = [[ApplicationDelegate sharedDelegate] defaultMenuBar];
+        }
+
         if ([nsWindow isKeyWindow]) {
-            [CMenuBar activate:window.javaMenuBar modallyDisabled:NO];
+            [CMenuBar activate:actualMenuBar modallyDisabled:NO];
         }
     }];
 
--- ./jdk/src/macosx/native/sun/awt/CDropTarget.m	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/macosx/native/sun/awt/CDropTarget.m	Wed May 07 19:26:47 2014 -0700
@@ -477,6 +477,8 @@
         sDraggingExited = FALSE;
         sDraggingLocation = [sender draggingLocation];
         NSPoint javaLocation = [fView convertPoint:sDraggingLocation fromView:nil];
+        javaLocation.y = fView.window.frame.size.height - javaLocation.y;
+
         DLog5(@"+ dragEnter: loc native %f, %f, java %f, %f\n", sDraggingLocation.x, sDraggingLocation.y, javaLocation.x, javaLocation.y);
 
                 ////////// BEGIN Calculate the current drag actions //////////
@@ -570,8 +572,7 @@
     // Should we notify Java things have changed?
     if (sDraggingError == FALSE && notifyJava) {
         NSPoint javaLocation = [fView convertPoint:sDraggingLocation fromView:nil];
-                // For some reason even after the convertPoint drag events come with the y coordinate reverted
-                javaLocation.y = fView.window.frame.size.height - javaLocation.y;
+        javaLocation.y = fView.window.frame.size.height - javaLocation.y;
         //DLog5(@"  : dragMoved: loc native %f, %f, java %f, %f\n", sDraggingLocation.x, sDraggingLocation.y, javaLocation.x, javaLocation.y);
 
         jlongArray formats = sDraggingFormats;
--- ./jdk/src/macosx/native/sun/awt/CMenuItem.m	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/macosx/native/sun/awt/CMenuItem.m	Wed May 07 19:26:47 2014 -0700
@@ -70,9 +70,15 @@
     JNIEnv *env = [ThreadUtilities getJNIEnv];
 JNF_COCOA_ENTER(env);
 
-    // If we are called as a result of user pressing a shorcut, do nothing,
-    // because AWTView has already sent corresponding key event to the Java
-    // layer from performKeyEquivalent
+    // If we are called as a result of user pressing a shortcut, do nothing,
+    // because AVTView has already sent corresponding key event to the Java
+    // layer from performKeyEquivalent.
+    // There is an exception from the rule above, though: if a window with
+    // a menu gets minimized by user and there are no other windows to take
+    // focus, the window's menu won't be removed from the global menu bar.
+    // However, the Java layer won't handle invocation by a shortcut coming
+    // from this "frameless" menu, because there are no active windows. This
+    // means we have to handle it here.
     NSEvent *currEvent = [[NSApplication sharedApplication] currentEvent];
     if ([currEvent type] == NSKeyDown) {
         NSString *menuKey = [sender keyEquivalent];
@@ -91,7 +97,8 @@
             eventKey = [NSString stringWithCharacters: &newChar length: 1];
         }
 
-        if ([menuKey isEqualToString:eventKey]) {
+        NSWindow *keyWindow = [NSApp keyWindow];
+        if ([menuKey isEqualToString:eventKey] && keyWindow != nil) {
             return;
         }
     }
@@ -289,7 +296,7 @@
 
         case java_awt_event_KeyEvent_VK_HELP            : macKey = NSHelpFunctionKey; break;
         case java_awt_event_KeyEvent_VK_TAB             : macKey = NSTabCharacter; break;
-        case java_awt_event_KeyEvent_VK_ENTER           : macKey = NSCarriageReturnCharacter; break;
+        case java_awt_event_KeyEvent_VK_ENTER           : macKey = NSNewlineCharacter; break;
         case java_awt_event_KeyEvent_VK_BACK_SPACE      : macKey = NSBackspaceCharacter; break;
         case java_awt_event_KeyEvent_VK_DELETE          : macKey = NSDeleteCharacter; break;
         case java_awt_event_KeyEvent_VK_CLEAR           : macKey = NSClearDisplayFunctionKey; break;
--- ./jdk/src/share/back/SDE.c	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/back/SDE.c	Wed May 07 19:26:47 2014 -0700
@@ -28,6 +28,12 @@
 #include "util.h"
 #include "SDE.h"
 
+#ifdef __APPLE__
+/* use setjmp/longjmp versions that do not save/restore the signal mask */
+#define setjmp _setjmp
+#define longjmp _longjmp
+#endif
+
 /**
  * This SourceDebugExtension code does not
  * allow concurrent translation - due to caching method.
--- ./jdk/src/share/back/export/sys.h	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/back/export/sys.h	Wed May 07 19:26:47 2014 -0700
@@ -37,7 +37,7 @@
 
 /* Implemented in linker_md.c */
 
-void    dbgsysBuildLibName(char *, int, char *, char *);
+void    dbgsysBuildLibName(char *, int, const char *, const char *);
 void *  dbgsysLoadLibrary(const char *, char *err_buf, int err_buflen);
 void    dbgsysUnloadLibrary(void *);
 void *  dbgsysFindLibraryEntry(void *, const char *);
--- ./jdk/src/share/back/transport.c	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/back/transport.c	Wed May 07 19:26:47 2014 -0700
@@ -97,12 +97,12 @@
 
 /* Load transport library (directory=="" means do system search) */
 static void *
-loadTransportLibrary(char *libdir, char *name)
+loadTransportLibrary(const char *libdir, const char *name)
 {
     void *handle;
     char libname[MAXPATHLEN+2];
     char buf[MAXPATHLEN*2+100];
-    char *plibdir;
+    const char *plibdir;
 
     /* Convert libdir from UTF-8 to platform encoding */
     plibdir = NULL;
@@ -117,6 +117,9 @@
 
     /* Construct library name (simple name or full path) */
     dbgsysBuildLibName(libname, sizeof(libname), plibdir, name);
+    if (strlen(libname) == 0) {
+        return NULL;
+    }
 
     /* dlopen (unix) / LoadLibrary (windows) the transport library */
     handle = dbgsysLoadLibrary(libname, buf, sizeof(buf));
@@ -128,12 +131,12 @@
  * JDK 1.2 javai.c v1.61
  */
 static jdwpError
-loadTransport(char *name, jdwpTransportEnv **transportPtr)
+loadTransport(const char *name, jdwpTransportEnv **transportPtr)
 {
     JNIEnv                 *env;
     jdwpTransport_OnLoad_t  onLoad;
     void                   *handle;
-    char                   *libdir;
+    const char             *libdir;
 
     /* Make sure library name is not empty */
     if (name == NULL) {
--- ./jdk/src/share/classes/com/sun/accessibility/internal/resources/accessibility_de.properties	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/com/sun/accessibility/internal/resources/accessibility_de.properties	Wed May 07 19:26:47 2014 -0700
@@ -17,7 +17,7 @@
 awtcomponent=AWT-Komponente
 checkbox=Kontrollk\u00E4stchen
 colorchooser=Farbauswahl
-columnheader=Spalten-Header
+columnheader=Spaltenheader
 combobox=Kombinationsfeld
 canvas=Leinwand
 desktopicon=Desktopsymbol
@@ -46,7 +46,7 @@
 pushbutton=Schaltfl\u00E4che
 radiobutton=Optionsfeld
 rootpane=Root-Bereich
-rowheader=Zeilen-Header
+rowheader=Zeilenheader
 scrollbar=Bildlaufleiste
 scrollpane=Bildlaufbereich
 separator=Trennzeichen
--- ./jdk/src/share/classes/com/sun/beans/decoder/ArrayElementHandler.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/com/sun/beans/decoder/ArrayElementHandler.java	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2013 Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -110,6 +110,20 @@
     }
 
     /**
+     * Tests whether the value of this element can be used
+     * as an argument of the element that contained in this one.
+     *
+     * @return {@code true} if the value of this element can be used
+     *         as an argument of the element that contained in this one,
+     *         {@code false} otherwise
+     */
+    @Override
+    protected boolean isArgument() {
+        return true; // hack for compatibility
+    }
+
+
+    /**
      * Creates an instance of the array.
      *
      * @param type  the base class
--- ./jdk/src/share/classes/com/sun/beans/finder/ConstructorFinder.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/com/sun/beans/finder/ConstructorFinder.java	Wed May 07 19:26:47 2014 -0700
@@ -24,11 +24,12 @@
  */
 package com.sun.beans.finder;
 
-import com.sun.beans.WeakCache;
+import com.sun.beans.util.Cache;
 
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Modifier;
 
+import static com.sun.beans.util.Cache.Kind.SOFT;
 import static sun.reflect.misc.ReflectUtil.isPackageAccessible;
 
 /**
@@ -41,7 +42,18 @@
  * @author Sergey A. Malenkov
  */
 public final class ConstructorFinder extends AbstractFinder<Constructor<?>> {
-    private static final WeakCache<Signature, Constructor<?>> CACHE = new WeakCache<Signature, Constructor<?>>();
+    private static final Cache<Signature, Constructor<?>> CACHE = new Cache<Signature, Constructor<?>>(SOFT, SOFT) {
+        @Override
+        public Constructor create(Signature signature) {
+            try {
+                ConstructorFinder finder = new ConstructorFinder(signature.getArgs());
+                return finder.find(signature.getType().getConstructors());
+            }
+            catch (Exception exception) {
+                throw new SignatureException(exception);
+            }
+        }
+    };
 
     /**
      * Finds public constructor
@@ -69,13 +81,12 @@
         PrimitiveWrapperMap.replacePrimitivesWithWrappers(args);
         Signature signature = new Signature(type, args);
 
-        Constructor<?> constructor = CACHE.get(signature);
-        if (constructor != null) {
-            return constructor;
+        try {
+            return CACHE.get(signature);
         }
-        constructor = new ConstructorFinder(args).find(type.getConstructors());
-        CACHE.put(signature, constructor);
-        return constructor;
+        catch (SignatureException exception) {
+            throw exception.toNoSuchMethodException("Constructor is not found");
+        }
     }
 
     /**
--- ./jdk/src/share/classes/com/sun/beans/finder/MethodFinder.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/com/sun/beans/finder/MethodFinder.java	Wed May 07 19:26:47 2014 -0700
@@ -25,7 +25,7 @@
 package com.sun.beans.finder;
 
 import com.sun.beans.TypeResolver;
-import com.sun.beans.WeakCache;
+import com.sun.beans.util.Cache;
 
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
@@ -33,6 +33,7 @@
 import java.lang.reflect.Type;
 import java.util.Arrays;
 
+import static com.sun.beans.util.Cache.Kind.SOFT;
 import static sun.reflect.misc.ReflectUtil.isPackageAccessible;
 
 /**
@@ -45,7 +46,18 @@
  * @author Sergey A. Malenkov
  */
 public final class MethodFinder extends AbstractFinder<Method> {
-    private static final WeakCache<Signature, Method> CACHE = new WeakCache<Signature, Method>();
+    private static final Cache<Signature, Method> CACHE = new Cache<Signature, Method>(SOFT, SOFT) {
+        @Override
+        public Method create(Signature signature) {
+            try {
+                MethodFinder finder = new MethodFinder(signature.getName(), signature.getArgs());
+                return findAccessibleMethod(finder.find(signature.getType().getMethods()));
+            }
+            catch (Exception exception) {
+                throw new SignatureException(exception);
+            }
+        }
+    };
 
     /**
      * Finds public method (static or non-static)
@@ -65,16 +77,13 @@
         PrimitiveWrapperMap.replacePrimitivesWithWrappers(args);
         Signature signature = new Signature(type, name, args);
 
-        Method method = CACHE.get(signature);
-        boolean cached = method != null;
-        if (cached && isPackageAccessible(method.getDeclaringClass())) {
-            return method;
+        try {
+            Method method = CACHE.get(signature);
+            return (method == null) || isPackageAccessible(method.getDeclaringClass()) ? method : CACHE.create(signature);
         }
-        method = findAccessibleMethod(new MethodFinder(name, args).find(type.getMethods()));
-        if (!cached) {
-            CACHE.put(signature, method);
+        catch (SignatureException exception) {
+            throw exception.toNoSuchMethodException("Method '" + name + "' is not found");
         }
-        return method;
     }
 
     /**
--- ./jdk/src/share/classes/com/sun/beans/finder/Signature.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/com/sun/beans/finder/Signature.java	Wed May 07 19:26:47 2014 -0700
@@ -62,6 +62,18 @@
         this.args = args;
     }
 
+    Class<?> getType() {
+        return this.type;
+    }
+
+    String getName() {
+        return this.name;
+    }
+
+    Class<?>[] getArgs() {
+        return this.args;
+    }
+
     /**
      * Indicates whether some other object is "equal to" this one.
      *
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/src/share/classes/com/sun/beans/finder/SignatureException.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package com.sun.beans.finder;
+
+final class SignatureException extends RuntimeException {
+    SignatureException(Throwable cause) {
+        super(cause);
+    }
+
+    NoSuchMethodException toNoSuchMethodException(String message) {
+        Throwable throwable = getCause();
+        if (throwable instanceof NoSuchMethodException) {
+            return (NoSuchMethodException) throwable;
+        }
+        NoSuchMethodException exception = new NoSuchMethodException(message);
+        exception.initCause(throwable);
+        return exception;
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/src/share/classes/com/sun/beans/util/Cache.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,613 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package com.sun.beans.util;
+
+import java.lang.ref.ReferenceQueue;
+import java.lang.ref.SoftReference;
+import java.lang.ref.WeakReference;
+import java.util.Objects;
+
+/**
+ * Hash table based implementation of the cache,
+ * which allows to use weak or soft references for keys and values.
+ * An entry in a {@code Cache} will automatically be removed
+ * when its key or value is no longer in ordinary use.
+ *
+ * @author Sergey Malenkov
+ * @since 1.8
+ */
+public abstract class Cache<K,V> {
+    private static final int MAXIMUM_CAPACITY = 1 << 30; // maximum capacity MUST be a power of two <= 1<<30
+
+    private final boolean identity; // defines whether the identity comparison is used
+    private final Kind keyKind; // a reference kind for the cache keys
+    private final Kind valueKind; // a reference kind for the cache values
+
+    private final ReferenceQueue<Object> queue = new ReferenceQueue<>(); // queue for references to remove
+
+    private volatile CacheEntry<K,V>[] table = newTable(1 << 3); // table's length MUST be a power of two
+    private int threshold = 6; // the next size value at which to resize
+    private int size; // the number of key-value mappings contained in this map
+
+    /**
+     * Creates a corresponding value for the specified key.
+     *
+     * @param key a key that can be used to create a value
+     * @return a corresponding value for the specified key
+     */
+    public abstract V create(K key);
+
+    /**
+     * Constructs an empty {@code Cache}.
+     * The default initial capacity is 8.
+     * The default load factor is 0.75.
+     *
+     * @param keyKind   a reference kind for keys
+     * @param valueKind a reference kind for values
+     *
+     * @throws NullPointerException if {@code keyKind} or {@code valueKind} are {@code null}
+     */
+    public Cache(Kind keyKind, Kind valueKind) {
+        this(keyKind, valueKind, false);
+    }
+
+    /**
+     * Constructs an empty {@code Cache}
+     * with the specified comparison method.
+     * The default initial capacity is 8.
+     * The default load factor is 0.75.
+     *
+     * @param keyKind   a reference kind for keys
+     * @param valueKind a reference kind for values
+     * @param identity  defines whether reference-equality
+     *                  is used in place of object-equality
+     *
+     * @throws NullPointerException if {@code keyKind} or {@code valueKind} are {@code null}
+     */
+    public Cache(Kind keyKind, Kind valueKind, boolean identity) {
+        Objects.requireNonNull(keyKind, "keyKind");
+        Objects.requireNonNull(valueKind, "valueKind");
+        this.keyKind = keyKind;
+        this.valueKind = valueKind;
+        this.identity = identity;
+    }
+
+    /**
+     * Returns the value to which the specified key is mapped,
+     * or {@code null} if there is no mapping for the key.
+     *
+     * @param key the key whose cached value is to be returned
+     * @return a value to which the specified key is mapped,
+     *         or {@code null} if there is no mapping for {@code key}
+     *
+     * @throws NullPointerException if {@code key} is {@code null}
+     *                              or corresponding value is {@code null}
+     */
+    public final V get(K key) {
+        Objects.requireNonNull(key, "key");
+        removeStaleEntries();
+        int hash = hash(key);
+        // unsynchronized search improves performance
+        // the null value does not mean that there are no needed entry
+        CacheEntry<K,V>[] table = this.table; // unsynchronized access
+        V current = getEntryValue(key, hash, table[index(hash, table)]);
+        if (current != null) {
+            return current;
+        }
+        synchronized (this.queue) {
+            // synchronized search improves stability
+            // we must create and add new value if there are no needed entry
+            int index = index(hash, this.table);
+            current = getEntryValue(key, hash, this.table[index]);
+            if (current != null) {
+                return current;
+            }
+            V value = create(key);
+            Objects.requireNonNull(value, "value");
+            this.table[index] = new CacheEntry<>(hash, key, value, this.table[index]);
+            if (++this.size >= this.threshold) {
+                if (this.table.length == MAXIMUM_CAPACITY) {
+                    this.threshold = Integer.MAX_VALUE;
+                } else {
+                    removeStaleEntries();
+                    table = newTable(this.table.length << 1);
+                    transfer(this.table, table);
+                    // If ignoring null elements and processing ref queue caused massive
+                    // shrinkage, then restore old table.  This should be rare, but avoids
+                    // unbounded expansion of garbage-filled tables.
+                    if (this.size >= this.threshold / 2) {
+                        this.table = table;
+                        this.threshold <<= 1;
+                    } else {
+                        transfer(table, this.table);
+                    }
+                    removeStaleEntries();
+                }
+            }
+            return value;
+        }
+    }
+
+    /**
+     * Removes the cached value that corresponds to the specified key.
+     *
+     * @param key the key whose mapping is to be removed from this cache
+     */
+    public final void remove(K key) {
+        if (key != null) {
+            synchronized (this.queue) {
+                removeStaleEntries();
+                int hash = hash(key);
+                int index = index(hash, this.table);
+                CacheEntry<K,V> prev = this.table[index];
+                CacheEntry<K,V> entry = prev;
+                while (entry != null) {
+                    CacheEntry<K,V> next = entry.next;
+                    if (entry.matches(hash, key)) {
+                        if (entry == prev) {
+                            this.table[index] = next;
+                        } else {
+                            prev.next = next;
+                        }
+                        entry.unlink();
+                        break;
+                    }
+                    prev = entry;
+                    entry = next;
+                }
+            }
+        }
+    }
+
+    /**
+     * Removes all of the mappings from this cache.
+     * It will be empty after this call returns.
+     */
+    public final void clear() {
+        synchronized (this.queue) {
+            int index = this.table.length;
+            while (0 < index--) {
+                CacheEntry<K,V> entry = this.table[index];
+                while (entry != null) {
+                    CacheEntry<K,V> next = entry.next;
+                    entry.unlink();
+                    entry = next;
+                }
+                this.table[index] = null;
+            }
+            while (null != this.queue.poll()) {
+                // Clear out the reference queue.
+            }
+        }
+    }
+
+    /**
+     * Retrieves object hash code and applies a supplemental hash function
+     * to the result hash, which defends against poor quality hash functions.
+     * This is critical because {@code Cache} uses power-of-two length hash tables,
+     * that otherwise encounter collisions for hashCodes that do not differ
+     * in lower bits.
+     *
+     * @param key the object which hash code is to be calculated
+     * @return a hash code value for the specified object
+     */
+    private int hash(Object key) {
+        if (this.identity) {
+            int hash = System.identityHashCode(key);
+            return (hash << 1) - (hash << 8);
+        }
+        int hash = key.hashCode();
+        // This function ensures that hashCodes that differ only by
+        // constant multiples at each bit position have a bounded
+        // number of collisions (approximately 8 at default load factor).
+        hash ^= (hash >>> 20) ^ (hash >>> 12);
+        return hash ^ (hash >>> 7) ^ (hash >>> 4);
+    }
+
+    /**
+     * Returns index of the specified hash code in the given table.
+     * Note that the table size must be a power of two.
+     *
+     * @param hash  the hash code
+     * @param table the table
+     * @return an index of the specified hash code in the given table
+     */
+    private static int index(int hash, Object[] table) {
+        return hash & (table.length - 1);
+    }
+
+    /**
+     * Creates a new array for the cache entries.
+     *
+     * @param size requested capacity MUST be a power of two
+     * @return a new array for the cache entries
+     */
+    @SuppressWarnings("unchecked")
+    private CacheEntry<K,V>[] newTable(int size) {
+        return (CacheEntry<K,V>[]) new CacheEntry[size];
+    }
+
+    private V getEntryValue(K key, int hash, CacheEntry<K,V> entry) {
+        while (entry != null) {
+            if (entry.matches(hash, key)) {
+                return entry.value.getReferent();
+            }
+            entry = entry.next;
+        }
+        return null;
+    }
+
+    private void removeStaleEntries() {
+        Object reference = this.queue.poll();
+        if (reference != null) {
+            synchronized (this.queue) {
+                do {
+                    if (reference instanceof Ref) {
+                        Ref ref = (Ref) reference;
+                        @SuppressWarnings("unchecked")
+                        CacheEntry<K,V> owner = (CacheEntry<K,V>) ref.getOwner();
+                        if (owner != null) {
+                            int index = index(owner.hash, this.table);
+                            CacheEntry<K,V> prev = this.table[index];
+                            CacheEntry<K,V> entry = prev;
+                            while (entry != null) {
+                                CacheEntry<K,V> next = entry.next;
+                                if (entry == owner) {
+                                    if (entry == prev) {
+                                        this.table[index] = next;
+                                    } else {
+                                        prev.next = next;
+                                    }
+                                    entry.unlink();
+                                    break;
+                                }
+                                prev = entry;
+                                entry = next;
+                            }
+                        }
+                    }
+                    reference = this.queue.poll();
+                }
+                while (reference != null);
+            }
+        }
+    }
+
+    private void transfer(CacheEntry<K,V>[] oldTable, CacheEntry<K,V>[] newTable) {
+        int oldIndex = oldTable.length;
+        while (0 < oldIndex--) {
+            CacheEntry<K,V> entry = oldTable[oldIndex];
+            oldTable[oldIndex] = null;
+            while (entry != null) {
+                CacheEntry<K,V> next = entry.next;
+                if (entry.key.isStale() || entry.value.isStale()) {
+                    entry.unlink();
+                } else {
+                    int newIndex = index(entry.hash, newTable);
+                    entry.next = newTable[newIndex];
+                    newTable[newIndex] = entry;
+                }
+                entry = next;
+            }
+        }
+    }
+
+    /**
+     * Represents a cache entry (key-value pair).
+     */
+    private final class CacheEntry<K,V> {
+        private final int hash;
+        private final Ref<K> key;
+        private final Ref<V> value;
+        private volatile CacheEntry<K,V> next;
+
+        /**
+         * Constructs an entry for the cache.
+         *
+         * @param hash  the hash code calculated for the entry key
+         * @param key   the entry key
+         * @param value the initial value of the entry
+         * @param next  the next entry in a chain
+         */
+        private CacheEntry(int hash, K key, V value, CacheEntry<K,V> next) {
+            this.hash = hash;
+            this.key = Cache.this.keyKind.create(this, key, Cache.this.queue);
+            this.value = Cache.this.valueKind.create(this, value, Cache.this.queue);
+            this.next = next;
+        }
+
+        /**
+         * Determines whether the entry has the given key with the given hash code.
+         *
+         * @param hash   an expected hash code
+         * @param object an object to be compared with the entry key
+         * @return {@code true} if the entry has the given key with the given hash code;
+         *         {@code false} otherwise
+         */
+        private boolean matches(int hash, Object object) {
+            if (this.hash != hash) {
+                return false;
+            }
+            Object key = this.key.getReferent();
+            return (key == object) || !Cache.this.identity && (key != null) && key.equals(object);
+        }
+
+        /**
+         * Marks the entry as actually removed from the cache.
+         */
+        private void unlink() {
+            this.next = null;
+            this.key.removeOwner();
+            this.value.removeOwner();
+            Cache.this.size--;
+        }
+    }
+
+    /**
+     * Basic interface for references.
+     * It defines the operations common for the all kind of references.
+     *
+     * @param <T> the type of object to refer
+     */
+    private static interface Ref<T> {
+        /**
+         * Returns the object that possesses information about the reference.
+         *
+         * @return the owner of the reference or {@code null} if the owner is unknown
+         */
+        Object getOwner();
+
+        /**
+         * Returns the object to refer.
+         *
+         * @return the referred object or {@code null} if it was collected
+         */
+        T getReferent();
+
+        /**
+         * Determines whether the referred object was taken by the garbage collector or not.
+         *
+         * @return {@code true} if the referred object was collected
+         */
+        boolean isStale();
+
+        /**
+         * Marks this reference as removed from the cache.
+         */
+        void removeOwner();
+    }
+
+    /**
+     * Represents a reference kind.
+     */
+    public static enum Kind {
+        STRONG {
+            <T> Ref<T> create(Object owner, T value, ReferenceQueue<? super T> queue) {
+                return new Strong<>(owner, value);
+            }
+        },
+        SOFT {
+            <T> Ref<T> create(Object owner, T referent, ReferenceQueue<? super T> queue) {
+                return (referent == null)
+                        ? new Strong<>(owner, referent)
+                        : new Soft<>(owner, referent, queue);
+            }
+        },
+        WEAK {
+            <T> Ref<T> create(Object owner, T referent, ReferenceQueue<? super T> queue) {
+                return (referent == null)
+                        ? new Strong<>(owner, referent)
+                        : new Weak<>(owner, referent, queue);
+            }
+        };
+
+        /**
+         * Creates a reference to the specified object.
+         *
+         * @param <T>      the type of object to refer
+         * @param owner    the owner of the reference, if needed
+         * @param referent the object to refer
+         * @param queue    the queue to register the reference with,
+         *                 or {@code null} if registration is not required
+         * @return the reference to the specified object
+         */
+        abstract <T> Ref<T> create(Object owner, T referent, ReferenceQueue<? super T> queue);
+
+        /**
+         * This is an implementation of the {@link Cache.Ref} interface
+         * that uses the strong references that prevent their referents
+         * from being made finalizable, finalized, and then reclaimed.
+         *
+         * @param <T> the type of object to refer
+         */
+        private static final class Strong<T> implements Ref<T> {
+            private Object owner;
+            private final T referent;
+
+            /**
+             * Creates a strong reference to the specified object.
+             *
+             * @param owner    the owner of the reference, if needed
+             * @param referent the non-null object to refer
+             */
+            private Strong(Object owner, T referent) {
+                this.owner = owner;
+                this.referent = referent;
+            }
+
+            /**
+             * Returns the object that possesses information about the reference.
+             *
+             * @return the owner of the reference or {@code null} if the owner is unknown
+             */
+            public Object getOwner() {
+                return this.owner;
+            }
+
+            /**
+             * Returns the object to refer.
+             *
+             * @return the referred object
+             */
+            public T getReferent() {
+                return this.referent;
+            }
+
+            /**
+             * Determines whether the referred object was taken by the garbage collector or not.
+             *
+             * @return {@code true} if the referred object was collected
+             */
+            public boolean isStale() {
+                return false;
+            }
+
+            /**
+             * Marks this reference as removed from the cache.
+             */
+            public void removeOwner() {
+                this.owner = null;
+            }
+        }
+
+        /**
+         * This is an implementation of the {@link Cache.Ref} interface
+         * that uses the soft references that are cleared at the discretion
+         * of the garbage collector in response to a memory request.
+         *
+         * @param <T> the type of object to refer
+         * @see java.lang.ref.SoftReference
+         */
+        private static final class Soft<T> extends SoftReference<T> implements Ref<T> {
+            private Object owner;
+
+            /**
+             * Creates a soft reference to the specified object.
+             *
+             * @param owner    the owner of the reference, if needed
+             * @param referent the non-null object to refer
+             * @param queue    the queue to register the reference with,
+             *                 or {@code null} if registration is not required
+             */
+            private Soft(Object owner, T referent, ReferenceQueue<? super T> queue) {
+                super(referent, queue);
+                this.owner = owner;
+            }
+
+            /**
+             * Returns the object that possesses information about the reference.
+             *
+             * @return the owner of the reference or {@code null} if the owner is unknown
+             */
+            public Object getOwner() {
+                return this.owner;
+            }
+
+            /**
+             * Returns the object to refer.
+             *
+             * @return the referred object or {@code null} if it was collected
+             */
+            public T getReferent() {
+                return get();
+            }
+
+            /**
+             * Determines whether the referred object was taken by the garbage collector or not.
+             *
+             * @return {@code true} if the referred object was collected
+             */
+            public boolean isStale() {
+                return null == get();
+            }
+
+            /**
+             * Marks this reference as removed from the cache.
+             */
+            public void removeOwner() {
+                this.owner = null;
+            }
+        }
+
+        /**
+         * This is an implementation of the {@link Cache.Ref} interface
+         * that uses the weak references that do not prevent their referents
+         * from being made finalizable, finalized, and then reclaimed.
+         *
+         * @param <T> the type of object to refer
+         * @see java.lang.ref.WeakReference
+         */
+        private static final class Weak<T> extends WeakReference<T> implements Ref<T> {
+            private Object owner;
+
+            /**
+             * Creates a weak reference to the specified object.
+             *
+             * @param owner    the owner of the reference, if needed
+             * @param referent the non-null object to refer
+             * @param queue    the queue to register the reference with,
+             *                 or {@code null} if registration is not required
+             */
+            private Weak(Object owner, T referent, ReferenceQueue<? super T> queue) {
+                super(referent, queue);
+                this.owner = owner;
+            }
+
+            /**
+             * Returns the object that possesses information about the reference.
+             *
+             * @return the owner of the reference or {@code null} if the owner is unknown
+             */
+            public Object getOwner() {
+                return this.owner;
+            }
+
+            /**
+             * Returns the object to refer.
+             *
+             * @return the referred object or {@code null} if it was collected
+             */
+            public T getReferent() {
+                return get();
+            }
+
+            /**
+             * Determines whether the referred object was taken by the garbage collector or not.
+             *
+             * @return {@code true} if the referred object was collected
+             */
+            public boolean isStale() {
+                return null == get();
+            }
+
+            /**
+             * Marks this reference as removed from the cache.
+             */
+            public void removeOwner() {
+                this.owner = null;
+            }
+        }
+    }
+}
--- ./jdk/src/share/classes/com/sun/imageio/plugins/jpeg/JPEGMetadata.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/com/sun/imageio/plugins/jpeg/JPEGMetadata.java	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001, 2004, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -278,10 +278,11 @@
                         (JFIFMarkerSegment) findMarkerSegment
                         (JFIFMarkerSegment.class, true);
                     if (jfif == null) {
-                        throw new IIOException
-                            ("ICC APP2 encountered without prior JFIF!");
+                        newGuy = new MarkerSegment(buffer);
+                        newGuy.loadData(buffer);
+                    } else {
+                        jfif.addICC(buffer);
                     }
-                    jfif.addICC(buffer);
                     // newGuy remains null
                 } else {
                     newGuy = new MarkerSegment(buffer);
--- ./jdk/src/share/classes/com/sun/java/swing/plaf/windows/resources/windows_fr.properties	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/com/sun/java/swing/plaf/windows/resources/windows_fr.properties	Wed May 07 19:26:47 2014 -0700
@@ -25,8 +25,8 @@
 FileChooser.filesOfTypeLabel.textAndMnemonic=&Type de fichier :
 FileChooser.upFolderToolTip.textAndMnemonic=Remonte d'un niveau.
 FileChooser.upFolderAccessibleName=Monter
-FileChooser.homeFolderToolTip.textAndMnemonic=R\u00E9pertoire d'origine
-FileChooser.homeFolderAccessibleName=R\u00E9pertoire d'origine
+FileChooser.homeFolderToolTip.textAndMnemonic=R\u00E9pertoire de base
+FileChooser.homeFolderAccessibleName=R\u00E9pertoire de base
 FileChooser.newFolderToolTip.textAndMnemonic=Cr\u00E9e un dossier.
 FileChooser.newFolderAccessibleName=Nouveau dossier
 FileChooser.newFolderActionLabel.textAndMnemonic=Nouveau dossier
--- ./jdk/src/share/classes/com/sun/java/util/jar/pack/Code.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/com/sun/java/util/jar/pack/Code.java	Wed May 07 19:26:47 2014 -0700
@@ -146,7 +146,6 @@
         int verbose = getPackage().verbose;
         if (verbose > 2)
             System.out.println("Reference scan "+this);
-        Class cls = thisClass();
         refs.addAll(Arrays.asList(handler_class));
         if (fixups != null) {
             fixups.visitRefs(refs);
--- ./jdk/src/share/classes/com/sun/java/util/jar/pack/ConstantPool.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/com/sun/java/util/jar/pack/ConstantPool.java	Wed May 07 19:26:47 2014 -0700
@@ -670,53 +670,55 @@
         return new String(sig);
     }
 
-    static private int skipClassNameChars(String sig, int i) {
-        int len = sig.length();
-        for (; i < len; i++) {
-            char ch = sig.charAt(i);
-            if (ch <= ' ')  break;
-            if (ch >= ';' && ch <= '@')  break;
-        }
-        return i;
+    static private int skipTo(char semi, String sig, int i) {
+        i = sig.indexOf(semi, i);
+        return (i >= 0) ? i : sig.length();
     }
 
     static String[] structureSignature(String sig) {
-        sig = sig.intern();
-
-        int formLen = 0;
-        int nparts = 1;
-        for (int i = 0; i < sig.length(); i++) {
-            char ch = sig.charAt(i);
-            formLen++;
-            if (ch == 'L') {
-                nparts++;
-                int i2 = skipClassNameChars(sig, i+1);
-                i = i2-1;  // keep the semicolon in the form
-                int i3 = sig.indexOf('<', i+1);
-                if (i3 > 0 && i3 < i2)
-                    i = i3-1;
-            }
-        }
-        char[] form = new char[formLen];
-        if (nparts == 1) {
+        int firstl = sig.indexOf('L');
+        if (firstl < 0) {
             String[] parts = { sig };
             return parts;
         }
-        String[] parts = new String[nparts];
-        int j = 0;
-        int k = 1;
-        for (int i = 0; i < sig.length(); i++) {
-            char ch = sig.charAt(i);
-            form[j++] = ch;
-            if (ch == 'L') {
-                int i2 = skipClassNameChars(sig, i+1);
-                parts[k++] = sig.substring(i+1, i2);
-                i = i2;
-                --i;  // keep the semicolon in the form
+        // Segment the string like sig.split("L\\([^;<]*\\)").
+        // N.B.: Previous version of this code did a more complex match,
+        // to next ch < ' ' or ch in [';'..'@'].  The only important
+        // characters are ';' and '<', since they are part of the
+        // signature syntax.
+        // Examples:
+        //   "(Ljava/lang/Object;IJLLoo;)V" => {"(L;IJL;)V", "java/lang/Object", "Loo"}
+        //   "Ljava/util/List<Ljava/lang/String;>;" => {"L<L;>;", "java/util/List", "java/lang/String"}
+        char[] form = null;
+        String[] parts = null;
+        for (int pass = 0; pass <= 1; pass++) {
+            // pass 0 is a sizing pass, pass 1 packs the arrays
+            int formPtr = 0;
+            int partPtr = 1;
+            int nextsemi = 0, nextangl = 0;  // next ';' or '<', or zero, or sigLen
+            int lastj = 0;
+            for (int i = firstl + 1, j; i > 0; i = sig.indexOf('L', j) + 1) {
+                // sig[i-1] is 'L', while sig[j] will be the first ';' or '<' after it
+                // each part is in sig[i .. j-1]
+                if (nextsemi < i)  nextsemi = skipTo(';', sig, i);
+                if (nextangl < i)  nextangl = skipTo('<', sig, i);
+                j = (nextsemi < nextangl ? nextsemi : nextangl);
+                if (pass != 0) {
+                    sig.getChars(lastj, i, form, formPtr);
+                    parts[partPtr] = sig.substring(i, j);
+                }
+                formPtr += (i - lastj);
+                partPtr += 1;
+                lastj = j;
             }
+            if (pass != 0) {
+                sig.getChars(lastj, sig.length(), form, formPtr);
+                break;
+            }
+            formPtr += (sig.length() - lastj);
+            form = new char[formPtr];
+            parts = new String[partPtr];
         }
-        assert(j == formLen);
-        assert(k == parts.length);
         parts[0] = new String(form);
         //assert(flattenSignature(parts).equals(sig));
         return parts;
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/src/share/classes/com/sun/java/util/jar/pack/DriverResource_ja.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,131 @@
+/*
+ * Copyright (c) 2005, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.sun.java.util.jar.pack;
+
+import java.util.ListResourceBundle;
+
+public class DriverResource_ja extends ListResourceBundle {
+        public static final String VERSION ="VERSION";
+        public static final String BAD_ARGUMENT ="BAD_ARGUMENT";
+        public static final String BAD_OPTION ="BAD_OPTION";
+        public static final String BAD_REPACK_OUTPUT="BAD_REPACK_OUTPUT";
+        public static final String DETECTED_ZIP_COMMENT="DETECTED_ZIP_COMMENT";
+        public static final String SKIP_FOR_REPACKED ="SKIP_FOR_REPACKED";
+        public static final String WRITE_PACK_FILE ="WRITE_PACK_FILE";
+        public static final String WIRTE_PACKGZ_FILE="WIRTE_PACKGZ_FILE";
+        public static final String SKIP_FOR_MOVE_FAILED="SKIP_FOR_MOVE_FAILED";
+        public static final String PACK_HELP="PACK_HELP";
+        public static final String UNPACK_HELP ="UNPACK_HELP";
+        public static final String MORE_INFO = "MORE_INFO";
+        public static final String DUPLICATE_OPTION = "DUPLICATE_OPTION";
+        public static final String BAD_SPEC = "BAD_SPEC";
+
+        //The following string is duplicate in PACK and UNPACK comment,which was draw out to ruduce translation work.
+        private static final String PARAMETER_V = "  -v, --verbose                   increase program verbosity";
+        private static final String PARAMETER_Q = "  -q, --quiet                     set verbosity to lowest level";
+        private static final String PARAMETER_LF = "  -l{F}, --log-file={F}           output to the given log file, or '-' for System.out";
+        private static final String PARAMETER_H = "  -?, -h, --help                  print this message";
+        private static final String PARAMETER_VER = "  -V, --version                   print program version";
+        private static final String PARAMETER_J = "  -J{X}                           pass option X to underlying Java VM";
+
+
+        //The following are outputs of command 'pack200' and 'unpack200'.
+        //Don't translate command arguments ,words with a prefix of '-' or '--'.
+        //
+        private static final Object[][] resource= {
+                {VERSION,"{0}\u30D0\u30FC\u30B8\u30E7\u30F3{1}"},//parameter 0:class name;parameter 1: version value
+                {BAD_ARGUMENT,"\u7121\u52B9\u306A\u5F15\u6570: {0}"},
+                {BAD_OPTION,"\u7121\u52B9\u306A\u30AA\u30D7\u30B7\u30E7\u30F3: {0}={1}"},//parameter 0:option name;parameter 1:option value
+                {BAD_REPACK_OUTPUT,"\u7121\u52B9\u306A--repack\u51FA\u529B: {0}"},//parameter 0:filename
+                {DETECTED_ZIP_COMMENT,"\u691C\u51FA\u3055\u308C\u305FZIP\u30B3\u30E1\u30F3\u30C8: {0}"},//parameter 0:comment
+                {SKIP_FOR_REPACKED,"\u3059\u3067\u306B\u518D\u5727\u7E2E\u3055\u308C\u3066\u3044\u308B\u305F\u3081\u30B9\u30AD\u30C3\u30D7\u3057\u3066\u3044\u307E\u3059: {0}"},//parameter 0:filename
+                {WRITE_PACK_FILE,"*.pack\u30D5\u30A1\u30A4\u30EB\u3092\u66F8\u304D\u8FBC\u3080\u306B\u306F\u3001--no-gzip\u3092\u6307\u5B9A\u3057\u307E\u3059: {0}"},//parameter 0:filename
+                {WIRTE_PACKGZ_FILE,"*.pack.gz\u30D5\u30A1\u30A4\u30EB\u3092\u66F8\u304D\u8FBC\u3080\u306B\u306F\u3001--gzip\u3092\u6307\u5B9A\u3057\u307E\u3059: {0}"},//parameter 0:filename
+                {SKIP_FOR_MOVE_FAILED,"\u79FB\u52D5\u304C\u5931\u6557\u3057\u305F\u305F\u3081\u89E3\u51CD\u3092\u30B9\u30AD\u30C3\u30D7\u3057\u3066\u3044\u307E\u3059: {0}"},//parameter 0:filename
+                {PACK_HELP,new String[]{
+                                "\u4F7F\u7528\u65B9\u6CD5:  pack200 [-opt... | --option=value]... x.pack[.gz] y.jar",
+                                "",
+                                "\u5727\u7E2E\u30AA\u30D7\u30B7\u30E7\u30F3",
+                                "  -g\u3001--no-gzip                   \u30D7\u30EC\u30FC\u30F3\u306A*.pack\u30D5\u30A1\u30A4\u30EB\u3092\u5727\u7E2E\u305B\u305A\u306B\u51FA\u529B\u3057\u307E\u3059",
+                                "  --gzip                          (\u30C7\u30D5\u30A9\u30EB\u30C8)\u5727\u7E2E\u51FA\u529B\u3092gzip\u3067\u5F8C\u51E6\u7406\u3057\u307E\u3059",
+                                "  -G\u3001--strip-debug               \u5727\u7E2E\u4E2D\u306B\u30C7\u30D0\u30C3\u30B0\u5C5E\u6027\u3092\u524A\u9664\u3057\u307E\u3059",
+                                "  -O\u3001--no-keep-file-order        \u30D5\u30A1\u30A4\u30EB\u306E\u9806\u5E8F\u4ED8\u3051\u60C5\u5831\u3092\u8EE2\u9001\u3057\u307E\u305B\u3093",
+                                "  --keep-file-order               (\u30C7\u30D5\u30A9\u30EB\u30C8)\u5165\u529B\u30D5\u30A1\u30A4\u30EB\u306E\u9806\u5E8F\u4ED8\u3051\u3092\u4FDD\u6301\u3057\u307E\u3059",
+                                "  -S{N}\u3001--segment-limit={N}       \u30BB\u30B0\u30E1\u30F3\u30C8\u5236\u9650\u3092\u51FA\u529B\u3057\u307E\u3059(\u30C7\u30D5\u30A9\u30EB\u30C8N=1Mb)",
+                                "  -E{N}\u3001--effort={N}             \u5727\u7E2E\u306E\u8A66\u884C(\u30C7\u30D5\u30A9\u30EB\u30C8N=5)",
+                                "  -H{h}\u3001--deflate-hint={h}       \u30C7\u30D5\u30EC\u30FC\u30C8\u30FB\u30D2\u30F3\u30C8\u3092\u8EE2\u9001\u3057\u307E\u3059: true\u3001false\u307E\u305F\u306Fkeep(\u30C7\u30D5\u30A9\u30EB\u30C8)",
+                                "  -m{V}\u3001--modification-time={V}  \u5909\u66F4\u6642\u9593\u3092\u8EE2\u9001\u3057\u307E\u3059: latest\u307E\u305F\u306Fkeep(\u30C7\u30D5\u30A9\u30EB\u30C8)",
+                                "  -P{F}\u3001--pass-file={F}          \u6307\u5B9A\u3055\u308C\u305F\u5727\u7E2E\u3055\u308C\u3066\u3044\u306A\u3044\u5165\u529B\u8981\u7D20\u3092\u8EE2\u9001\u3057\u307E\u3059",
+                                "  -U{a}\u3001--unknown-attribute={a}  \u4E0D\u660E\u306E\u5C5E\u6027\u30A2\u30AF\u30B7\u30E7\u30F3: error\u3001strip\u307E\u305F\u306Fpass(\u30C7\u30D5\u30A9\u30EB\u30C8)",
+                                "  -C{N}={L}\u3001--class-attribute={N}={L}  (\u30E6\u30FC\u30B6\u30FC\u5B9A\u7FA9\u5C5E\u6027)",
+                                "  -F{N}={L}\u3001--field-attribute={N}={L}  (\u30E6\u30FC\u30B6\u30FC\u5B9A\u7FA9\u5C5E\u6027)",
+                                "  -M{N}={L}\u3001--method-attribute={N}={L} (\u30E6\u30FC\u30B6\u30FC\u5B9A\u7FA9\u5C5E\u6027)",
+                                "  -D{N}={L}\u3001--code-attribute={N}={L}   (\u30E6\u30FC\u30B6\u30FC\u5B9A\u7FA9\u5C5E\u6027)",
+                                "  -f{F}\u3001--config-file={F}        Pack200.Packer\u30D7\u30ED\u30D1\u30C6\u30A3\u306B\u30D5\u30A1\u30A4\u30EBF\u3092\u8AAD\u307F\u8FBC\u307F\u307E\u3059",
+                                PARAMETER_V ,
+                                PARAMETER_Q ,
+                                PARAMETER_LF ,
+                                PARAMETER_H ,
+                                PARAMETER_VER ,
+                                PARAMETER_J,
+                                "",
+                                "\u6CE8\u610F:",
+                                "  -P\u3001-C\u3001-F\u3001-M\u304A\u3088\u3073-D\u30AA\u30D7\u30B7\u30E7\u30F3\u306F\u7D2F\u7A4D\u3055\u308C\u307E\u3059\u3002",
+                                "  \u5C5E\u6027\u5B9A\u7FA9\u306E\u4F8B:  -C SourceFile=RUH .",
+                                "  Config.\u30D5\u30A1\u30A4\u30EB\u30FB\u30D7\u30ED\u30D1\u30C6\u30A3\u306F\u3001Pack200 API\u306B\u3088\u3063\u3066\u5B9A\u7FA9\u3055\u308C\u307E\u3059\u3002",
+                                "  -S\u3001-E\u3001-H\u3001-m\u3001-U\u306E\u5024\u306E\u610F\u5473\u306F\u3001Pack200 API\u3092\u53C2\u7167\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
+                                "  \u30EC\u30A4\u30A2\u30A6\u30C8\u5B9A\u7FA9(RUH\u306A\u3069)\u306FJSR 200\u306B\u3088\u3063\u3066\u5B9A\u7FA9\u3055\u308C\u307E\u3059\u3002",
+                                "",
+                                "\u518D\u5727\u7E2E\u30E2\u30FC\u30C9\u3067\u306F\u3001JAR\u30D5\u30A1\u30A4\u30EB\u304C\u5727\u7E2E/\u89E3\u51CD\u30B5\u30A4\u30AF\u30EB\u3067\u66F4\u65B0\u3055\u308C\u307E\u3059:",
+                                "    pack200 [-r|--repack] [-opt | --option=value]... [repackedy.jar] y.jar\n"
+                                }
+                },
+                {UNPACK_HELP,new String[]{
+                                "\u4F7F\u7528\u65B9\u6CD5:  unpack200 [-opt... | --option=value]... x.pack[.gz] y.jar\n",
+                                "",
+                                "\u89E3\u51CD\u30AA\u30D7\u30B7\u30E7\u30F3",
+                                "  -H{h}\u3001--deflate-hint={h}     \u8EE2\u9001\u3055\u308C\u305F\u30C7\u30D5\u30EC\u30FC\u30C8\u30FB\u30D2\u30F3\u30C8\u3092\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3057\u307E\u3059: true\u3001false\u307E\u305F\u306Fkeep(\u30C7\u30D5\u30A9\u30EB\u30C8)",
+                                "  -r\u3001--remove-pack-file        \u89E3\u51CD\u5F8C\u306B\u5165\u529B\u30D5\u30A1\u30A4\u30EB\u3092\u524A\u9664\u3057\u307E\u3059",
+                                PARAMETER_V ,
+                                PARAMETER_Q ,
+                                PARAMETER_LF ,
+                                PARAMETER_H ,
+                                PARAMETER_VER ,
+                                PARAMETER_J,
+                            }
+                },
+
+                {MORE_INFO,"(\u8A73\u7D30\u306F\u3001{0} --help\u3092\u5B9F\u884C\u3057\u3066\u304F\u3060\u3055\u3044\u3002)"},//parameter 0:command name
+                {DUPLICATE_OPTION,"\u91CD\u8907\u30AA\u30D7\u30B7\u30E7\u30F3: {0}"},//parameter 0:option
+                {BAD_SPEC,"{0}\u306E\u7121\u52B9\u306A\u4ED5\u69D8: {1}"},//parameter 0:option;parameter 1:specifier
+        };
+
+        protected Object[][] getContents() {
+                return resource;
+        }
+
+
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/src/share/classes/com/sun/java/util/jar/pack/DriverResource_zh_CN.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,131 @@
+/*
+ * Copyright (c) 2005, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.sun.java.util.jar.pack;
+
+import java.util.ListResourceBundle;
+
+public class DriverResource_zh_CN extends ListResourceBundle {
+        public static final String VERSION ="VERSION";
+        public static final String BAD_ARGUMENT ="BAD_ARGUMENT";
+        public static final String BAD_OPTION ="BAD_OPTION";
+        public static final String BAD_REPACK_OUTPUT="BAD_REPACK_OUTPUT";
+        public static final String DETECTED_ZIP_COMMENT="DETECTED_ZIP_COMMENT";
+        public static final String SKIP_FOR_REPACKED ="SKIP_FOR_REPACKED";
+        public static final String WRITE_PACK_FILE ="WRITE_PACK_FILE";
+        public static final String WIRTE_PACKGZ_FILE="WIRTE_PACKGZ_FILE";
+        public static final String SKIP_FOR_MOVE_FAILED="SKIP_FOR_MOVE_FAILED";
+        public static final String PACK_HELP="PACK_HELP";
+        public static final String UNPACK_HELP ="UNPACK_HELP";
+        public static final String MORE_INFO = "MORE_INFO";
+        public static final String DUPLICATE_OPTION = "DUPLICATE_OPTION";
+        public static final String BAD_SPEC = "BAD_SPEC";
+
+        //The following string is duplicate in PACK and UNPACK comment,which was draw out to ruduce translation work.
+        private static final String PARAMETER_V = "  -v, --verbose                   increase program verbosity";
+        private static final String PARAMETER_Q = "  -q, --quiet                     set verbosity to lowest level";
+        private static final String PARAMETER_LF = "  -l{F}, --log-file={F}           output to the given log file, or '-' for System.out";
+        private static final String PARAMETER_H = "  -?, -h, --help                  print this message";
+        private static final String PARAMETER_VER = "  -V, --version                   print program version";
+        private static final String PARAMETER_J = "  -J{X}                           pass option X to underlying Java VM";
+
+
+        //The following are outputs of command 'pack200' and 'unpack200'.
+        //Don't translate command arguments ,words with a prefix of '-' or '--'.
+        //
+        private static final Object[][] resource= {
+                {VERSION,"{0}\u7248\u672C {1}"},//parameter 0:class name;parameter 1: version value
+                {BAD_ARGUMENT,"\u9519\u8BEF\u53C2\u6570: {0}"},
+                {BAD_OPTION,"\u9519\u8BEF\u9009\u9879: {0}={1}"},//parameter 0:option name;parameter 1:option value
+                {BAD_REPACK_OUTPUT,"--repack \u8F93\u51FA\u9519\u8BEF: {0}"},//parameter 0:filename
+                {DETECTED_ZIP_COMMENT,"\u68C0\u6D4B\u5230 ZIP \u6CE8\u91CA: {0}"},//parameter 0:comment
+                {SKIP_FOR_REPACKED,"\u7531\u4E8E\u5DF2\u91CD\u65B0\u6253\u5305\u800C\u8DF3\u8FC7: {0}"},//parameter 0:filename
+                {WRITE_PACK_FILE,"\u8981\u5199\u5165 *.pack \u6587\u4EF6, \u8BF7\u6307\u5B9A --no-gzip: {0}"},//parameter 0:filename
+                {WIRTE_PACKGZ_FILE,"\u8981\u5199\u5165 *.pack.gz \u6587\u4EF6, \u8BF7\u6307\u5B9A --gzip: {0}"},//parameter 0:filename
+                {SKIP_FOR_MOVE_FAILED,"\u7531\u4E8E\u79FB\u52A8\u5931\u8D25\u800C\u8DF3\u8FC7\u91CD\u65B0\u6253\u5305: {0}"},//parameter 0:filename
+                {PACK_HELP,new String[]{
+                                "\u7528\u6CD5:  pack200 [-opt... | --option=value]... x.pack[.gz] y.jar",
+                                "",
+                                "\u6253\u5305\u9009\u9879",
+                                "  -g, --no-gzip                   \u8F93\u51FA\u65E0\u683C\u5F0F\u7684 *.pack \u6587\u4EF6, \u4E0D\u538B\u7F29",
+                                "  --gzip                          (\u9ED8\u8BA4\u503C) \u4F7F\u7528 gzip \u5BF9\u6253\u5305\u8FDB\u884C\u540E\u5904\u7406",
+                                "  -G, --strip-debug               \u6253\u5305\u65F6\u5220\u9664\u8C03\u8BD5\u5C5E\u6027",
+                                "  -O, --no-keep-file-order        \u4E0D\u4F20\u8F93\u6587\u4EF6\u6392\u5E8F\u4FE1\u606F",
+                                "  --keep-file-order               (\u9ED8\u8BA4\u503C) \u4FDD\u7559\u8F93\u5165\u6587\u4EF6\u6392\u5E8F",
+                                "  -S{N}, --segment-limit={N}      \u8F93\u51FA\u6BB5\u9650\u5236 (\u9ED8\u8BA4\u503C N=1Mb)",
+                                "  -E{N}, --effort={N}             \u6253\u5305\u6548\u679C (\u9ED8\u8BA4\u503C N=5)",
+                                "  -H{h}, --deflate-hint={h}       \u4F20\u8F93\u538B\u7F29\u63D0\u793A: true, false \u6216 keep (\u9ED8\u8BA4\u503C)",
+                                "  -m{V}, --modification-time={V}  \u4F20\u8F93 modtimes: latest \u6216 keep (\u9ED8\u8BA4\u503C)",
+                                "  -P{F}, --pass-file={F}          \u4F20\u8F93\u672A\u89E3\u538B\u7F29\u7684\u7ED9\u5B9A\u8F93\u5165\u5143\u7D20",
+                                "  -U{a}, --unknown-attribute={a}  \u672A\u77E5\u5C5E\u6027\u64CD\u4F5C: error, strip \u6216 pass (\u9ED8\u8BA4\u503C)",
+                                "  -C{N}={L}, --class-attribute={N}={L}  (\u7528\u6237\u5B9A\u4E49\u7684\u5C5E\u6027)",
+                                "  -F{N}={L}, --field-attribute={N}={L}  (\u7528\u6237\u5B9A\u4E49\u7684\u5C5E\u6027)",
+                                "  -M{N}={L}, --method-attribute={N}={L} (\u7528\u6237\u5B9A\u4E49\u7684\u5C5E\u6027)",
+                                "  -D{N}={L}, --code-attribute={N}={L}   (\u7528\u6237\u5B9A\u4E49\u7684\u5C5E\u6027)",
+                                "  -f{F}, --config-file={F}        \u8BFB\u53D6\u6587\u4EF6 F \u7684 Pack200.Packer \u5C5E\u6027",
+                                PARAMETER_V ,
+                                PARAMETER_Q ,
+                                PARAMETER_LF ,
+                                PARAMETER_H ,
+                                PARAMETER_VER ,
+                                PARAMETER_J,
+                                "",
+                                "\u6CE8:",
+                                "  -P, -C, -F, -M \u548C -D \u9009\u9879\u7D2F\u8BA1\u3002",
+                                "  \u793A\u4F8B\u5C5E\u6027\u5B9A\u4E49:  -C SourceFile=RUH\u3002",
+                                "  Config. \u6587\u4EF6\u5C5E\u6027\u7531 Pack200 API \u5B9A\u4E49\u3002",
+                                "  \u6709\u5173 -S, -E, -H-, -m, -U \u503C\u7684\u542B\u4E49, \u8BF7\u53C2\u9605 Pack200 API\u3002",
+                                "  \u5E03\u5C40\u5B9A\u4E49 (\u4F8B\u5982 RUH) \u7531 JSR 200 \u5B9A\u4E49\u3002",
+                                "",
+                                "\u91CD\u65B0\u6253\u5305\u6A21\u5F0F\u901A\u8FC7\u6253\u5305/\u89E3\u5305\u5468\u671F\u66F4\u65B0 JAR \u6587\u4EF6:",
+                                "    pack200 [-r|--repack] [-opt | --option=value]... [repackedy.jar] y.jar\n"
+                                }
+                },
+                {UNPACK_HELP,new String[]{
+                                "\u7528\u6CD5:  unpack200 [-opt... | --option=value]... x.pack[.gz] y.jar\n",
+                                "",
+                                "\u89E3\u5305\u9009\u9879",
+                                "  -H{h}, --deflate-hint={h}     \u8986\u76D6\u5DF2\u4F20\u8F93\u7684\u538B\u7F29\u63D0\u793A: true, false \u6216 keep (\u9ED8\u8BA4\u503C)",
+                                "  -r, --remove-pack-file        \u89E3\u5305\u4E4B\u540E\u5220\u9664\u8F93\u5165\u6587\u4EF6",
+                                PARAMETER_V ,
+                                PARAMETER_Q ,
+                                PARAMETER_LF ,
+                                PARAMETER_H ,
+                                PARAMETER_VER ,
+                                PARAMETER_J,
+                            }
+                },
+
+                {MORE_INFO,"(\u6709\u5173\u8BE6\u7EC6\u4FE1\u606F, \u8BF7\u8FD0\u884C {0} --help\u3002)"},//parameter 0:command name
+                {DUPLICATE_OPTION,"\u91CD\u590D\u7684\u9009\u9879: {0}"},//parameter 0:option
+                {BAD_SPEC,"{0}\u7684\u89C4\u8303\u9519\u8BEF: {1}"},//parameter 0:option;parameter 1:specifier
+        };
+
+        protected Object[][] getContents() {
+                return resource;
+        }
+
+
+}
--- ./jdk/src/share/classes/com/sun/rowset/RowSetResourceBundle_de.properties	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/com/sun/rowset/RowSetResourceBundle_de.properties	Wed May 07 19:26:47 2014 -0700
@@ -140,7 +140,7 @@
 #WebRowSetXmlReader exception
 wrsxmlreader.invalidcp = Ende von RowSet wurde erreicht. Ung\u00FCltige Cursorposition
 wrsxmlreader.readxml = readXML: {0}
-wrsxmlreader.parseerr = ** Parsing-Fehler: {0}, Zeile: {1} , URI: {2}
+wrsxmlreader.parseerr = ** Parsingfehler: {0}, Zeile: {1} , URI: {2}
 
 #WebRowSetXmlWriter exceptions
 wrsxmlwriter.ioex = IOException: {0}
--- ./jdk/src/share/classes/com/sun/rowset/RowSetResourceBundle_ja.properties	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/com/sun/rowset/RowSetResourceBundle_ja.properties	Wed May 07 19:26:47 2014 -0700
@@ -51,8 +51,8 @@
 cachedrowsetimpl.last = last: TYPE_FORWARD_ONLY
 cachedrowsetimpl.absolute = absolute: \u7121\u52B9\u306A\u30AB\u30FC\u30BD\u30EB\u4F4D\u7F6E
 cachedrowsetimpl.relative = relative: \u7121\u52B9\u306A\u30AB\u30FC\u30BD\u30EB\u4F4D\u7F6E
-cachedrowsetimpl.asciistream = ascii\u30B9\u30C8\u30EA\u30FC\u30E0\u306E\u8AAD\u8FBC\u307F\u306B\u5931\u6557\u3057\u307E\u3057\u305F
-cachedrowsetimpl.binstream = \u30D0\u30A4\u30CA\u30EA\u30FB\u30B9\u30C8\u30EA\u30FC\u30E0\u306E\u8AAD\u8FBC\u307F\u306B\u5931\u6557\u3057\u307E\u3057\u305F
+cachedrowsetimpl.asciistream = ascii\u30B9\u30C8\u30EA\u30FC\u30E0\u306E\u8AAD\u8FBC\u307F\u304C\u5931\u6557\u3057\u307E\u3057\u305F
+cachedrowsetimpl.binstream = \u30D0\u30A4\u30CA\u30EA\u30FB\u30B9\u30C8\u30EA\u30FC\u30E0\u306E\u8AAD\u8FBC\u307F\u304C\u5931\u6557\u3057\u307E\u3057\u305F
 cachedrowsetimpl.failedins = \u884C\u306E\u633F\u5165\u306B\u5931\u6557
 cachedrowsetimpl.updateins = \u633F\u5165\u884C\u306B\u304A\u3044\u3066updateRow\u304C\u547C\u3073\u51FA\u3055\u308C\u307E\u3057\u305F
 cachedrowsetimpl.movetoins = moveToInsertRow: CONCUR_READ_ONLY
@@ -101,7 +101,7 @@
 
 #JdbcRowSetImpl exceptions
 jdbcrowsetimpl.invalstate = \u7121\u52B9\u306A\u72B6\u614B
-jdbcrowsetimpl.connect = JdbcRowSet(connect): JNDI\u304C\u63A5\u7D9A\u3067\u304D\u307E\u305B\u3093
+jdbcrowsetimpl.connect = JdbcRowSet (connect): JNDI\u304C\u63A5\u7D9A\u3067\u304D\u307E\u305B\u3093
 jdbcrowsetimpl.paramtype = \u30D1\u30E9\u30E1\u30FC\u30BF\u30FB\u30BF\u30A4\u30D7\u3092\u63A8\u5B9A\u3067\u304D\u307E\u305B\u3093
 jdbcrowsetimpl.matchcols = \u4E00\u81F4\u5217\u304C\u5217\u306E\u30BB\u30C3\u30C8\u3068\u540C\u3058\u3067\u306F\u3042\u308A\u307E\u305B\u3093
 jdbcrowsetimpl.setmatchcols = \u4E00\u81F4\u5217\u3092\u53D6\u5F97\u3059\u308B\u524D\u306B\u8A2D\u5B9A\u3057\u3066\u304F\u3060\u3055\u3044
--- ./jdk/src/share/classes/com/sun/rowset/RowSetResourceBundle_sv.properties	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/com/sun/rowset/RowSetResourceBundle_sv.properties	Wed May 07 19:26:47 2014 -0700
@@ -29,11 +29,11 @@
 cachedrowsetimpl.nullhash = Kan inte instansiera CachedRowSetImpl. Null-hashtabell skickades till konstruktor
 cachedrowsetimpl.invalidop = En ogiltig \u00E5tg\u00E4rd utf\u00F6rdes p\u00E5 infogad rad
 cachedrowsetimpl.accfailed = acceptChanges utf\u00F6rdes inte
-cachedrowsetimpl.invalidcp = Mark\u00F6rpositionen \u00E4r ogiltig
+cachedrowsetimpl.invalidcp = Ogiltigt mark\u00F6rl\u00E4ge
 cachedrowsetimpl.illegalop = En otill\u00E5ten \u00E5tg\u00E4rd utf\u00F6rdes p\u00E5 en icke infogad rad
 cachedrowsetimpl.clonefail = Kloningen utf\u00F6rdes inte: {0}
-cachedrowsetimpl.invalidcol = Kolumnindexet \u00E4r ogiltigt
-cachedrowsetimpl.invalcolnm = Kolumnnamnet \u00E4r ogiltigt
+cachedrowsetimpl.invalidcol = Ogiltigt kolumnindex
+cachedrowsetimpl.invalcolnm = Ogiltigt kolumnnamn
 cachedrowsetimpl.boolfail = getBoolen utf\u00F6rdes inte f\u00F6r v\u00E4rdet ({0}) i kolumnen {1}
 cachedrowsetimpl.bytefail = getByte utf\u00F6rdes inte f\u00F6r v\u00E4rdet ({0}) i kolumnen {1}
 cachedrowsetimpl.shortfail = getShort utf\u00F6rdes inte f\u00F6r v\u00E4rdet ({0}) i kolumnen {1}
@@ -60,7 +60,7 @@
 cachedrowsetimpl.movetoins2 = moveToInsertRow: ogiltigt antal kolumner
 cachedrowsetimpl.tablename = Tabellnamnet kan inte vara null
 cachedrowsetimpl.keycols = Ogiltiga nyckelkolumner
-cachedrowsetimpl.invalidcol = Kolumnindexet \u00E4r ogiltigt
+cachedrowsetimpl.invalidcol = Ogiltigt kolumnindex
 cachedrowsetimpl.opnotsupp = Databasen har inte st\u00F6d f\u00F6r denna \u00E5tg\u00E4rd
 cachedrowsetimpl.matchcols = Matchningskolumnerna \u00E4r inte samma som de som st\u00E4llts in
 cachedrowsetimpl.setmatchcols = St\u00E4ll in matchningskolumnerna innan du h\u00E4mtar dem
@@ -81,7 +81,7 @@
 
 # WebRowSetImpl exceptions
 webrowsetimpl.nullhash = Kan inte instansiera WebRowSetImpl. Null-hashtabell skickades till konstruktor.
-webrowsetimpl.invalidwr = Ogiltig f\u00F6rfattare
+webrowsetimpl.invalidwr = Ogiltig skrivfunktion
 webrowsetimpl.invalidrd = Ogiltig l\u00E4sare
 
 #FilteredRowSetImpl exceptions
--- ./jdk/src/share/classes/com/sun/security/auth/module/Krb5LoginModule.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/com/sun/security/auth/module/Krb5LoginModule.java	Wed May 07 19:26:47 2014 -0700
@@ -875,8 +875,7 @@
                 char[] tmpPassword = ((PasswordCallback)
                                       callbacks[0]).getPassword();
                 if (tmpPassword == null) {
-                    // treat a NULL password as an empty password
-                    tmpPassword = new char[0];
+                    throw new LoginException("No password provided");
                 }
                 password = new char[tmpPassword.length];
                 System.arraycopy(tmpPassword, 0,
--- ./jdk/src/share/classes/com/sun/security/sasl/util/AbstractSaslImpl.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/com/sun/security/sasl/util/AbstractSaslImpl.java	Wed May 07 19:26:47 2014 -0700
@@ -252,11 +252,12 @@
 
 
     /**
-     * Outputs a byte array and converts
+     * Outputs a byte array. Can be null.
      */
     protected static final void traceOutput(String srcClass, String srcMethod,
         String traceTag, byte[] output) {
-        traceOutput(srcClass, srcMethod, traceTag, output, 0, output.length);
+        traceOutput(srcClass, srcMethod, traceTag, output, 0,
+                output == null ? 0 : output.length);
     }
 
     protected static final void traceOutput(String srcClass, String srcMethod,
@@ -272,13 +273,20 @@
                 lev = Level.FINEST;
             }
 
-            ByteArrayOutputStream out = new ByteArrayOutputStream(len);
-            new HexDumpEncoder().encodeBuffer(
-                new ByteArrayInputStream(output, offset, len), out);
+            String content;
+
+            if (output != null) {
+                ByteArrayOutputStream out = new ByteArrayOutputStream(len);
+                new HexDumpEncoder().encodeBuffer(
+                    new ByteArrayInputStream(output, offset, len), out);
+                content = out.toString();
+            } else {
+                content = "NULL";
+            }
 
             // Message id supplied by caller as part of traceTag
             logger.logp(lev, srcClass, srcMethod, "{0} ( {1} ): {2}",
-                new Object[] {traceTag, new Integer(origlen), out.toString()});
+                new Object[] {traceTag, new Integer(origlen), content});
         } catch (Exception e) {
             logger.logp(Level.WARNING, srcClass, srcMethod,
                 "SASLIMPL09:Error generating trace output: {0}", e);
--- ./jdk/src/share/classes/com/sun/swing/internal/plaf/metal/resources/metal_fr.properties	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/com/sun/swing/internal/plaf/metal/resources/metal_fr.properties	Wed May 07 19:26:47 2014 -0700
@@ -25,8 +25,8 @@
 FileChooser.filesOfTypeLabel.textAndMnemonic=&Type de fichier :
 FileChooser.upFolderToolTip.textAndMnemonic=Remonte d'un niveau.
 FileChooser.upFolderAccessibleName=Monter
-FileChooser.homeFolderToolTip.textAndMnemonic=R\u00E9pertoire d'origine
-FileChooser.homeFolderAccessibleName=R\u00E9pertoire d'origine
+FileChooser.homeFolderToolTip.textAndMnemonic=R\u00E9pertoire de base
+FileChooser.homeFolderAccessibleName=R\u00E9pertoire de base
 FileChooser.newFolderToolTip.textAndMnemonic=Cr\u00E9e un dossier.
 FileChooser.newFolderAccessibleName=Nouveau dossier
 FileChooser.newFolderActionLabel.textAndMnemonic=Nouveau dossier
--- ./jdk/src/share/classes/com/sun/swing/internal/plaf/synth/resources/synth_fr.properties	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/com/sun/swing/internal/plaf/synth/resources/synth_fr.properties	Wed May 07 19:26:47 2014 -0700
@@ -25,8 +25,8 @@
 FileChooser.filesOfTypeLabel.textAndMnemonic=&Type de fichier :
 FileChooser.upFolderToolTip.textAndMnemonic=Remonte d'un niveau.
 FileChooser.upFolderAccessibleName=Monter
-FileChooser.homeFolderToolTip.textAndMnemonic=R\u00E9pertoire d'origine
-FileChooser.homeFolderAccessibleName=R\u00E9pertoire d'origine
+FileChooser.homeFolderToolTip.textAndMnemonic=R\u00E9pertoire de base
+FileChooser.homeFolderAccessibleName=R\u00E9pertoire de base
 FileChooser.newFolderToolTip.textAndMnemonic=Cr\u00E9e un dossier.
 FileChooser.newFolderAccessibleName=Nouveau dossier
 FileChooser.newFolderActionLabel.textAndMnemonic=Nouveau dossier
--- ./jdk/src/share/classes/com/sun/tools/jdi/resources/jdi_ja.properties	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/com/sun/tools/jdi/resources/jdi_ja.properties	Wed May 07 19:26:47 2014 -0700
@@ -47,6 +47,6 @@
 memory_listening.name = VM\u3078\u306E\u63A5\u7D9A\u3092\u30EA\u30B9\u30CB\u30F3\u30B0\u3059\u308B\u305F\u3081\u306E\u5171\u6709\u30E1\u30E2\u30EA\u30FC\u9818\u57DF\u540D
 memory_listening.name.label = \u540D\u524D
 memory_listening.description = \u305D\u306E\u4ED6\u306EVM\u306B\u3088\u308A\u958B\u59CB\u3055\u308C\u308B\u5171\u6709\u30E1\u30E2\u30EA\u30FC\u63A5\u7D9A\u3092\u53D7\u3051\u5165\u308C\u307E\u3059
-process_attaching.description = \u30C7\u30D0\u30C3\u30B0\u3059\u308B\u30D7\u30ED\u30BB\u30B9\u306B\u30D7\u30ED\u30BB\u30B9ID(pid)\u3092\u4F7F\u7528\u3057\u3066\u63A5\u7D9A\u3057\u307E\u3059
+process_attaching.description = \u30C7\u30D0\u30C3\u30B0\u3059\u308B\u30D7\u30ED\u30BB\u30B9\u306B\u30D7\u30ED\u30BB\u30B9ID (pid)\u3092\u4F7F\u7528\u3057\u3066\u63A5\u7D9A\u3057\u307E\u3059
 process_attaching.pid = pid
-process_attaching.pid.label = \u30C7\u30D0\u30C3\u30B0\u3059\u308B\u30D7\u30ED\u30BB\u30B9ID(pid)
+process_attaching.pid.label = \u30C7\u30D0\u30C3\u30B0\u3059\u308B\u30D7\u30ED\u30BB\u30B9ID (pid)
--- ./jdk/src/share/classes/java/awt/AWTException.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/java/awt/AWTException.java	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1995, 1997, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1995, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -26,7 +26,7 @@
 
 
 /**
- * Signals that an Absract Window Toolkit exception has occurred.
+ * Signals that an Abstract Window Toolkit exception has occurred.
  *
  * @author      Arthur van Hoff
  */
--- ./jdk/src/share/classes/java/awt/Component.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/java/awt/Component.java	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1995, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1995, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -972,6 +972,10 @@
             public AccessControlContext getAccessControlContext(Component comp) {
                 return comp.getAccessControlContext();
             }
+
+            public void revalidateSynchronously(Component comp) {
+                comp.revalidateSynchronously();
+            }
         });
     }
 
@@ -2963,6 +2967,13 @@
      * @since 1.7
      */
     public void revalidate() {
+        revalidateSynchronously();
+    }
+
+    /**
+     * Revalidates the component synchronously.
+     */
+    final void revalidateSynchronously() {
         synchronized (getTreeLock()) {
             invalidate();
 
--- ./jdk/src/share/classes/java/awt/Toolkit.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/java/awt/Toolkit.java	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1995, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1995, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -56,6 +56,7 @@
 import sun.awt.NullComponentPeer;
 import sun.awt.PeerEvent;
 import sun.awt.SunToolkit;
+import sun.awt.AWTAccessor;
 import sun.security.util.SecurityConstants;
 
 import sun.util.CoreResourceBundleControl;
@@ -1607,6 +1608,12 @@
      * here, so that only one copy is maintained.
      */
     private static ResourceBundle resources;
+    private static ResourceBundle platformResources;
+
+    // called by platform toolkit
+    private static void setPlatformResources(ResourceBundle bundle) {
+        platformResources = bundle;
+    }
 
     /**
      * Initialize JNI field and method ids
@@ -1650,6 +1657,13 @@
     }
 
     static {
+        AWTAccessor.setToolkitAccessor(
+                new AWTAccessor.ToolkitAccessor() {
+                    @Override
+                    public void setPlatformResources(ResourceBundle bundle) {
+                        Toolkit.setPlatformResources(bundle);
+                    }
+                });
         java.security.AccessController.doPrivileged(
                                  new java.security.PrivilegedAction() {
             public Object run() {
@@ -1677,6 +1691,14 @@
      * This method returns defaultValue if the property is not found.
      */
     public static String getProperty(String key, String defaultValue) {
+        // first try platform specific bundle
+        if (platformResources != null) {
+            try {
+                return platformResources.getString(key);
+            } catch (MissingResourceException e) {}
+        }
+
+        // then shared one
         if (resources != null) {
             try {
                 return resources.getString(key);
@@ -2544,7 +2566,7 @@
             Runnable updater = new Runnable() {
                 public void run() {
                     PropertyChangeSupport pcs = (PropertyChangeSupport)
-                            AppContext.getAppContext().get(PROP_CHANGE_SUPPORT_KEY);
+                        AppContext.getAppContext().get(PROP_CHANGE_SUPPORT_KEY);
                     if (null != pcs) {
                         pcs.firePropertyChange(evt);
                     }
--- ./jdk/src/share/classes/java/lang/AbstractStringBuilder.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/java/lang/AbstractStringBuilder.java	Wed May 07 19:26:47 2014 -0700
@@ -1273,7 +1273,7 @@
      * specified substring, starting at the specified index.  The integer
      * returned is the smallest value <tt>k</tt> for which:
      * <blockquote><pre>
-     *     k >= Math.min(fromIndex, str.length()) &&
+     *     k >= Math.min(fromIndex, this.length()) &&
      *                   this.toString().startsWith(str, k)
      * </pre></blockquote>
      * If no such value of <i>k</i> exists, then -1 is returned.
@@ -1317,7 +1317,7 @@
      * specified substring. The integer returned is the largest value <i>k</i>
      * such that:
      * <blockquote><pre>
-     *     k <= Math.min(fromIndex, str.length()) &&
+     *     k <= Math.min(fromIndex, this.length()) &&
      *                   this.toString().startsWith(str, k)
      * </pre></blockquote>
      * If no such value of <i>k</i> exists, then -1 is returned.
--- ./jdk/src/share/classes/java/lang/Class.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/java/lang/Class.java	Wed May 07 19:26:47 2014 -0700
@@ -2207,14 +2207,53 @@
      */
     static native Class getPrimitiveClass(String name);
 
-    private static boolean isCheckMemberAccessOverridden(SecurityManager smgr) {
-        if (smgr.getClass() == SecurityManager.class) return false;
+    private static class SecurityManagerHelper {
+        final SecurityManager sm;
+        final boolean overrideCheckMemberAccess;
+        SecurityManagerHelper(SecurityManager sm) {
+            this.sm = sm;
 
-        Class<?>[] paramTypes = new Class<?>[] {Class.class, int.class};
-        return smgr.getClass().getMethod0("checkMemberAccess", paramTypes).
-                getDeclaringClass() != SecurityManager.class;
+            boolean overridden = false;
+            if (sm.getClass() != SecurityManager.class) {
+                try {
+                    overridden = getCheckMemberAccessMethod(sm.getClass()).
+                                     getDeclaringClass() != SecurityManager.class;
+                } catch (NoSuchMethodError e) {
+                    // fall back to invoke sm.checkMemberAccess for the member access check
+                }
+            }
+            this.overrideCheckMemberAccess = overridden;
+        }
+
     }
 
+    private static volatile SecurityManagerHelper smHelper;
+    private static boolean isCheckMemberAccessOverridden(SecurityManager sm) {
+        if (sm.getClass() == SecurityManager.class)  return false;
+
+        SecurityManagerHelper helper = smHelper;
+        if (helper == null || helper.sm != sm) {
+            helper = new SecurityManagerHelper(sm);
+            smHelper = helper;
+        }
+        return helper.overrideCheckMemberAccess;
+    }
+
+    /**
+     * Finds the checkMemberAccess method of the given SecurityManager class.
+     *
+     * This method calls JNI_GetMethodID to look up the checkMemberAccess method
+     * instead of Class.getMethod0 that may cause loading of classes referenced
+     * by the SecurityManager subclass and cause ClassCircularityError.
+     *
+     * JNI_GetMethodID may throw NoSuchMethodError if the given class
+     * has a static checkMemberAccess method.
+     *
+     * @throws NoSuchMethodError if the method cannot be found.
+     */
+    private static native Method getCheckMemberAccessMethod(Class<? extends SecurityManager> c)
+        throws NoSuchMethodError;
+
 
     /*
      * Check if client is allowed to access members.  If access is denied,
--- ./jdk/src/share/classes/java/lang/ConditionalSpecialCasing.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/java/lang/ConditionalSpecialCasing.java	Wed May 07 19:26:47 2014 -0700
@@ -74,7 +74,6 @@
         new Entry(0x00CC, new char[]{0x0069, 0x0307, 0x0300}, new char[]{0x00CC}, "lt", 0), // # LATIN CAPITAL LETTER I WITH GRAVE
         new Entry(0x00CD, new char[]{0x0069, 0x0307, 0x0301}, new char[]{0x00CD}, "lt", 0), // # LATIN CAPITAL LETTER I WITH ACUTE
         new Entry(0x0128, new char[]{0x0069, 0x0307, 0x0303}, new char[]{0x0128}, "lt", 0), // # LATIN CAPITAL LETTER I WITH TILDE
-        new Entry(0x0130, new char[]{0x0069, 0x0307}, new char[]{0x0130}, "lt", 0), // # LATIN CAPITAL LETTER I WITH DOT ABOVE
 
         //# ================================================================================
         //# Turkish and Azeri
@@ -85,10 +84,7 @@
         new Entry(0x0049, new char[]{0x0131}, new char[]{0x0049}, "tr", NOT_BEFORE_DOT), // # LATIN CAPITAL LETTER I
         new Entry(0x0049, new char[]{0x0131}, new char[]{0x0049}, "az", NOT_BEFORE_DOT), // # LATIN CAPITAL LETTER I
         new Entry(0x0069, new char[]{0x0069}, new char[]{0x0130}, "tr", 0), // # LATIN SMALL LETTER I
-        new Entry(0x0069, new char[]{0x0069}, new char[]{0x0130}, "az", 0), // # LATIN SMALL LETTER I
-        //# ================================================================================
-        //# Other
-        new Entry(0x0130, new char[]{0x0069, 0x0307}, new char[]{0x0130}, "en", 0), // # LATIN CAPITALLETTER I WITH DOT ABOVE
+        new Entry(0x0069, new char[]{0x0069}, new char[]{0x0130}, "az", 0)  // # LATIN SMALL LETTER I
     };
 
     // A hash table that contains the above entries
--- ./jdk/src/share/classes/java/lang/String.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/java/lang/String.java	Wed May 07 19:26:47 2014 -0700
@@ -2461,21 +2461,14 @@
             }
             if (localeDependent || srcChar == '\u03A3') { // GREEK CAPITAL LETTER SIGMA
                 lowerChar = ConditionalSpecialCasing.toLowerCaseEx(this, i, locale);
-            } else if (srcChar == '\u0130') { // LATIN CAPITAL LETTER I DOT
-                lowerChar = Character.ERROR;
             } else {
                 lowerChar = Character.toLowerCase(srcChar);
             }
             if ((lowerChar == Character.ERROR)
                     || (lowerChar >= Character.MIN_SUPPLEMENTARY_CODE_POINT)) {
                 if (lowerChar == Character.ERROR) {
-                    if (!localeDependent && srcChar == '\u0130') {
-                        lowerCharArray =
-                                ConditionalSpecialCasing.toLowerCaseCharArray(this, i, Locale.ENGLISH);
-                    } else {
-                        lowerCharArray =
-                                ConditionalSpecialCasing.toLowerCaseCharArray(this, i, locale);
-                    }
+                    lowerCharArray =
+                            ConditionalSpecialCasing.toLowerCaseCharArray(this, i, locale);
                 } else if (srcCount == 2) {
                     resultOffset += Character.toChars(lowerChar, result, i + resultOffset) - srcCount;
                     continue;
--- ./jdk/src/share/classes/java/lang/System.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/java/lang/System.java	Wed May 07 19:26:47 2014 -0700
@@ -1206,6 +1206,9 @@
             public Thread newThreadWithAcc(Runnable target, AccessControlContext acc) {
                 return new Thread(target, acc);
             }
+            public void invokeFinalize(Object o) throws Throwable {
+                o.finalize();
+            }
         });
     }
 }
--- ./jdk/src/share/classes/java/lang/invoke/DirectMethodHandle.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/java/lang/invoke/DirectMethodHandle.java	Wed May 07 19:26:47 2014 -0700
@@ -53,7 +53,8 @@
         if (!member.isResolved())
             throw new InternalError();
 
-        if (member.getDeclaringClass().isInterface() && !member.isAbstract()) {
+        if (member.getDeclaringClass().isInterface() &&
+                member.isMethod() && !member.isAbstract()) {
            // Check for corner case: invokeinterface of Object method
             MemberName m = new MemberName(Object.class, member.getName(), member.getMethodType(), member.getReferenceKind());
             m = MemberName.getFactory().resolveOrNull(m.getReferenceKind(), m, null);
--- ./jdk/src/share/classes/java/lang/invoke/MethodHandleImpl.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/java/lang/invoke/MethodHandleImpl.java	Wed May 07 19:26:47 2014 -0700
@@ -742,7 +742,8 @@
             GuardWithCatch gguard = new GuardWithCatch(gtarget, exType, gcatcher);
             if (gtarget == null || gcatcher == null)  throw new InternalError();
             MethodHandle ginvoker = GuardWithCatch.VARARGS_INVOKE.bindReceiver(gguard);
-            return makeCollectArguments(ginvoker, ValueConversions.varargsArray(nargs), 0, false);
+            MethodHandle gcollect = makeCollectArguments(ginvoker, ValueConversions.varargsArray(nargs), 0, false);
+            return makePairwiseConvert(gcollect, type, 2);
         }
     }
 
--- ./jdk/src/share/classes/java/lang/ref/Finalizer.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/java/lang/ref/Finalizer.java	Wed May 07 19:26:47 2014 -0700
@@ -27,17 +27,14 @@
 
 import java.security.PrivilegedAction;
 import java.security.AccessController;
-
+import sun.misc.JavaLangAccess;
+import sun.misc.SharedSecrets;
+import sun.misc.VM;
 
 final class Finalizer extends FinalReference { /* Package-private; must be in
                                                   same package as the Reference
                                                   class */
 
-    /* A native method that invokes an arbitrary object's finalize method is
-       required since the finalize method is protected
-     */
-    static native void invokeFinalizeMethod(Object o) throws Throwable;
-
     private static ReferenceQueue queue = new ReferenceQueue();
     private static Finalizer unfinalized = null;
     private static final Object lock = new Object();
@@ -90,7 +87,7 @@
         new Finalizer(finalizee);
     }
 
-    private void runFinalizer() {
+    private void runFinalizer(JavaLangAccess jla) {
         synchronized (this) {
             if (hasBeenFinalized()) return;
             remove();
@@ -98,7 +95,8 @@
         try {
             Object finalizee = this.get();
             if (finalizee != null && !(finalizee instanceof java.lang.Enum)) {
-                invokeFinalizeMethod(finalizee);
+                jla.invokeFinalize(finalizee);
+
                 /* Clear stack slot containing this variable, to decrease
                    the chances of false retention with a conservative GC */
                 finalizee = null;
@@ -141,16 +139,21 @@
 
     /* Called by Runtime.runFinalization() */
     static void runFinalization() {
+        if (!VM.isBooted()) {
+            return;
+        }
+
         forkSecondaryFinalizer(new Runnable() {
             private volatile boolean running;
             public void run() {
                 if (running)
                     return;
+                final JavaLangAccess jla = SharedSecrets.getJavaLangAccess();
                 running = true;
                 for (;;) {
                     Finalizer f = (Finalizer)queue.poll();
                     if (f == null) break;
-                    f.runFinalizer();
+                    f.runFinalizer(jla);
                 }
             }
         });
@@ -158,11 +161,16 @@
 
     /* Invoked by java.lang.Shutdown */
     static void runAllFinalizers() {
+        if (!VM.isBooted()) {
+            return;
+        }
+
         forkSecondaryFinalizer(new Runnable() {
             private volatile boolean running;
             public void run() {
                 if (running)
                     return;
+                final JavaLangAccess jla = SharedSecrets.getJavaLangAccess();
                 running = true;
                 for (;;) {
                     Finalizer f;
@@ -171,7 +179,7 @@
                         if (f == null) break;
                         unfinalized = f.next;
                     }
-                    f.runFinalizer();
+                    f.runFinalizer(jla);
                 }}});
     }
 
@@ -183,13 +191,25 @@
         public void run() {
             if (running)
                 return;
+
+            // Finalizer thread starts before System.initializeSystemClass
+            // is called.  Wait until JavaLangAccess is available
+            while (!VM.isBooted()) {
+                // delay until VM completes initialization
+                try {
+                    VM.awaitBooted();
+                } catch (InterruptedException x) {
+                    // ignore and continue
+                }
+            }
+            final JavaLangAccess jla = SharedSecrets.getJavaLangAccess();
             running = true;
             for (;;) {
                 try {
                     Finalizer f = (Finalizer)queue.remove();
-                    f.runFinalizer();
+                    f.runFinalizer(jla);
                 } catch (InterruptedException x) {
-                    continue;
+                    // ignore and continue
                 }
             }
         }
--- ./jdk/src/share/classes/java/lang/reflect/Proxy.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/java/lang/reflect/Proxy.java	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,19 +25,15 @@
 
 package java.lang.reflect;
 
-import java.lang.ref.Reference;
 import java.lang.ref.WeakReference;
+import java.lang.reflect.WeakCache.BiFunction;
 import java.security.AccessController;
 import java.security.Permission;
 import java.security.PrivilegedAction;
 import java.util.Arrays;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.HashSet;
+import java.util.IdentityHashMap;
 import java.util.Map;
-import java.util.Set;
-import java.util.List;
-import java.util.WeakHashMap;
+import java.util.concurrent.atomic.AtomicLong;
 import sun.misc.ProxyGenerator;
 import sun.reflect.CallerSensitive;
 import sun.reflect.Reflection;
@@ -230,27 +226,15 @@
 
     private static final long serialVersionUID = -2222568056686623797L;
 
-    /** prefix for all proxy class names */
-    private final static String proxyClassNamePrefix = "$Proxy";
-
     /** parameter types of a proxy class constructor */
-    private final static Class[] constructorParams =
+    private static final Class<?>[] constructorParams =
         { InvocationHandler.class };
 
-    /** maps a class loader to the proxy class cache for that loader */
-    private static Map<ClassLoader, Map<List<String>, Object>> loaderToCache
-        = new WeakHashMap<>();
-
-    /** marks that a particular proxy class is currently being generated */
-    private static Object pendingGenerationMarker = new Object();
-
-    /** next number to use for generation of unique proxy class names */
-    private static long nextUniqueNumber = 0;
-    private static Object nextUniqueNumberLock = new Object();
-
-    /** set of all generated proxy classes, for isProxyClass implementation */
-    private static Map<Class<?>, Void> proxyClasses =
-        Collections.synchronizedMap(new WeakHashMap<Class<?>, Void>());
+    /**
+     * a cache of proxy classes
+     */
+    private static final WeakCache<ClassLoader, Class<?>[], Class<?>>
+        proxyClassCache = new WeakCache<>(new KeyFactory(), new ProxyClassFactory());
 
     /**
      * the invocation handler for this proxy instance.
@@ -464,131 +448,190 @@
             throw new IllegalArgumentException("interface limit exceeded");
         }
 
-        Class<?> proxyClass = null;
+        // If the proxy class defined by the given loader implementing
+        // the given interfaces exists, this will simply return the cached copy;
+        // otherwise, it will create the proxy class via the ProxyClassFactory
+        return proxyClassCache.get(loader, interfaces);
+    }
 
-        /* collect interface names to use as key for proxy class cache */
-        String[] interfaceNames = new String[interfaces.length];
+    /*
+     * a key used for proxy class with 0 implemented interfaces
+     */
+    private static final Object key0 = new Object();
 
-        // for detecting duplicates
-        Set<Class<?>> interfaceSet = new HashSet<>();
+    /*
+     * Key1 and Key2 are optimized for the common use of dynamic proxies
+     * that implement 1 or 2 interfaces.
+     */
 
-        for (int i = 0; i < interfaces.length; i++) {
-            /*
-             * Verify that the class loader resolves the name of this
-             * interface to the same Class object.
-             */
-            String interfaceName = interfaces[i].getName();
-            Class<?> interfaceClass = null;
-            try {
-                interfaceClass = Class.forName(interfaceName, false, loader);
-            } catch (ClassNotFoundException e) {
+    /*
+     * a key used for proxy class with 1 implemented interface
+     */
+    private static final class Key1 extends WeakReference<Class<?>> {
+        private final int hash;
+
+        Key1(Class<?> intf) {
+            super(intf);
+            this.hash = intf.hashCode();
+        }
+
+        @Override
+        public int hashCode() {
+            return hash;
+        }
+
+        @Override
+        public boolean equals(Object obj) {
+            Class<?> intf;
+            return this == obj ||
+                   obj != null &&
+                   obj.getClass() == Key1.class &&
+                   (intf = get()) != null &&
+                   intf == ((Key1) obj).get();
+        }
+    }
+
+    /*
+     * a key used for proxy class with 2 implemented interfaces
+     */
+    private static final class Key2 extends WeakReference<Class<?>> {
+        private final int hash;
+        private final WeakReference<Class<?>> ref2;
+
+        Key2(Class<?> intf1, Class<?> intf2) {
+            super(intf1);
+            hash = 31 * intf1.hashCode() + intf2.hashCode();
+            ref2 = new WeakReference<Class<?>>(intf2);
+        }
+
+        @Override
+        public int hashCode() {
+            return hash;
+        }
+
+        @Override
+        public boolean equals(Object obj) {
+            Class<?> intf1, intf2;
+            return this == obj ||
+                   obj != null &&
+                   obj.getClass() == Key2.class &&
+                   (intf1 = get()) != null &&
+                   intf1 == ((Key2) obj).get() &&
+                   (intf2 = ref2.get()) != null &&
+                   intf2 == ((Key2) obj).ref2.get();
+        }
+    }
+
+    /*
+     * a key used for proxy class with any number of implemented interfaces
+     * (used here for 3 or more only)
+     */
+    private static final class KeyX {
+        private final int hash;
+        private final WeakReference<Class<?>>[] refs;
+
+        KeyX(Class<?>[] interfaces) {
+            hash = Arrays.hashCode(interfaces);
+            refs = new WeakReference[interfaces.length];
+            for (int i = 0; i < interfaces.length; i++) {
+                refs[i] = new WeakReference(interfaces[i]);
             }
-            if (interfaceClass != interfaces[i]) {
-                throw new IllegalArgumentException(
-                    interfaces[i] + " is not visible from class loader");
+        }
+
+        @Override
+        public int hashCode() {
+            return hash;
+        }
+
+        @Override
+        public boolean equals(Object obj) {
+            return this == obj ||
+                   obj != null &&
+                   obj.getClass() == KeyX.class &&
+                   equals(refs, ((KeyX) obj).refs);
+        }
+
+        private static boolean equals(WeakReference<Class<?>>[] refs1,
+                                      WeakReference<Class<?>>[] refs2) {
+            if (refs1.length != refs2.length) {
+                return false;
+            }
+            for (int i = 0; i < refs1.length; i++) {
+                Class<?> intf = refs1[i].get();
+                if (intf == null || intf != refs2[i].get()) {
+                    return false;
+                }
+            }
+            return true;
+        }
+    }
+
+    /**
+     * A function that maps an array of interfaces to an optimal key where
+     * Class objects representing interfaces are weakly referenced.
+     */
+    private static final class KeyFactory
+        implements BiFunction<ClassLoader, Class<?>[], Object>
+    {
+        @Override
+        public Object apply(ClassLoader classLoader, Class<?>[] interfaces) {
+            switch (interfaces.length) {
+                case 1: return new Key1(interfaces[0]); // the most frequent
+                case 2: return new Key2(interfaces[0], interfaces[1]);
+                case 0: return key0;
+                default: return new KeyX(interfaces);
+            }
+        }
+    }
+
+    /**
+     * A factory function that generates, defines and returns the proxy class given
+     * the ClassLoader and array of interfaces.
+     */
+    private static final class ProxyClassFactory
+        implements BiFunction<ClassLoader, Class<?>[], Class<?>>
+    {
+        // prefix for all proxy class names
+        private static final String proxyClassNamePrefix = "$Proxy";
+
+        // next number to use for generation of unique proxy class names
+        private static final AtomicLong nextUniqueNumber = new AtomicLong();
+
+        @Override
+        public Class<?> apply(ClassLoader loader, Class<?>[] interfaces) {
+
+            Map<Class<?>, Boolean> interfaceSet = new IdentityHashMap<>(interfaces.length);
+            for (Class<?> intf : interfaces) {
+                /*
+                 * Verify that the class loader resolves the name of this
+                 * interface to the same Class object.
+                 */
+                Class<?> interfaceClass = null;
+                try {
+                    interfaceClass = Class.forName(intf.getName(), false, loader);
+                } catch (ClassNotFoundException e) {
+                }
+                if (interfaceClass != intf) {
+                    throw new IllegalArgumentException(
+                        intf + " is not visible from class loader");
+                }
+                /*
+                 * Verify that the Class object actually represents an
+                 * interface.
+                 */
+                if (!interfaceClass.isInterface()) {
+                    throw new IllegalArgumentException(
+                        interfaceClass.getName() + " is not an interface");
+                }
+                /*
+                 * Verify that this interface is not a duplicate.
+                 */
+                if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) {
+                    throw new IllegalArgumentException(
+                        "repeated interface: " + interfaceClass.getName());
+                }
             }
 
-            /*
-             * Verify that the Class object actually represents an
-             * interface.
-             */
-            if (!interfaceClass.isInterface()) {
-                throw new IllegalArgumentException(
-                    interfaceClass.getName() + " is not an interface");
-            }
-
-            /*
-             * Verify that this interface is not a duplicate.
-             */
-            if (interfaceSet.contains(interfaceClass)) {
-                throw new IllegalArgumentException(
-                    "repeated interface: " + interfaceClass.getName());
-            }
-            interfaceSet.add(interfaceClass);
-
-            interfaceNames[i] = interfaceName;
-        }
-
-        /*
-         * Using string representations of the proxy interfaces as
-         * keys in the proxy class cache (instead of their Class
-         * objects) is sufficient because we require the proxy
-         * interfaces to be resolvable by name through the supplied
-         * class loader, and it has the advantage that using a string
-         * representation of a class makes for an implicit weak
-         * reference to the class.
-         */
-        List<String> key = Arrays.asList(interfaceNames);
-
-        /*
-         * Find or create the proxy class cache for the class loader.
-         */
-        Map<List<String>, Object> cache;
-        synchronized (loaderToCache) {
-            cache = loaderToCache.get(loader);
-            if (cache == null) {
-                cache = new HashMap<>();
-                loaderToCache.put(loader, cache);
-            }
-            /*
-             * This mapping will remain valid for the duration of this
-             * method, without further synchronization, because the mapping
-             * will only be removed if the class loader becomes unreachable.
-             */
-        }
-
-        /*
-         * Look up the list of interfaces in the proxy class cache using
-         * the key.  This lookup will result in one of three possible
-         * kinds of values:
-         *     null, if there is currently no proxy class for the list of
-         *         interfaces in the class loader,
-         *     the pendingGenerationMarker object, if a proxy class for the
-         *         list of interfaces is currently being generated,
-         *     or a weak reference to a Class object, if a proxy class for
-         *         the list of interfaces has already been generated.
-         */
-        synchronized (cache) {
-            /*
-             * Note that we need not worry about reaping the cache for
-             * entries with cleared weak references because if a proxy class
-             * has been garbage collected, its class loader will have been
-             * garbage collected as well, so the entire cache will be reaped
-             * from the loaderToCache map.
-             */
-            do {
-                Object value = cache.get(key);
-                if (value instanceof Reference) {
-                    proxyClass = (Class<?>) ((Reference) value).get();
-                }
-                if (proxyClass != null) {
-                    // proxy class already generated: return it
-                    return proxyClass;
-                } else if (value == pendingGenerationMarker) {
-                    // proxy class being generated: wait for it
-                    try {
-                        cache.wait();
-                    } catch (InterruptedException e) {
-                        /*
-                         * The class generation that we are waiting for should
-                         * take a small, bounded time, so we can safely ignore
-                         * thread interrupts here.
-                         */
-                    }
-                    continue;
-                } else {
-                    /*
-                     * No proxy class for this list of interfaces has been
-                     * generated or is being generated, so we will go and
-                     * generate it now.  Mark it as pending generation.
-                     */
-                    cache.put(key, pendingGenerationMarker);
-                    break;
-                }
-            } while (true);
-        }
-
-        try {
             String proxyPkg = null;     // package to define proxy class in
 
             /*
@@ -596,10 +639,10 @@
              * proxy class will be defined in the same package.  Verify that
              * all non-public proxy interfaces are in the same package.
              */
-            for (int i = 0; i < interfaces.length; i++) {
-                int flags = interfaces[i].getModifiers();
+            for (Class<?> intf : interfaces) {
+                int flags = intf.getModifiers();
                 if (!Modifier.isPublic(flags)) {
-                    String name = interfaces[i].getName();
+                    String name = intf.getName();
                     int n = name.lastIndexOf('.');
                     String pkg = ((n == -1) ? "" : name.substring(0, n + 1));
                     if (proxyPkg == null) {
@@ -616,60 +659,31 @@
                 proxyPkg = ReflectUtil.PROXY_PACKAGE + ".";
             }
 
-            {
+            /*
+             * Choose a name for the proxy class to generate.
+             */
+            long num = nextUniqueNumber.getAndIncrement();
+            String proxyName = proxyPkg + proxyClassNamePrefix + num;
+
+            /*
+             * Generate the specified proxy class.
+             */
+            byte[] proxyClassFile = ProxyGenerator.generateProxyClass(
+                proxyName, interfaces);
+            try {
+                return defineClass0(loader, proxyName,
+                                    proxyClassFile, 0, proxyClassFile.length);
+            } catch (ClassFormatError e) {
                 /*
-                 * Choose a name for the proxy class to generate.
+                 * A ClassFormatError here means that (barring bugs in the
+                 * proxy class generation code) there was some other
+                 * invalid aspect of the arguments supplied to the proxy
+                 * class creation (such as virtual machine limitations
+                 * exceeded).
                  */
-                long num;
-                synchronized (nextUniqueNumberLock) {
-                    num = nextUniqueNumber++;
-                }
-                String proxyName = proxyPkg + proxyClassNamePrefix + num;
-                /*
-                 * Verify that the class loader hasn't already
-                 * defined a class with the chosen name.
-                 */
-
-                /*
-                 * Generate the specified proxy class.
-                 */
-                byte[] proxyClassFile = ProxyGenerator.generateProxyClass(
-                    proxyName, interfaces);
-                try {
-                    proxyClass = defineClass0(loader, proxyName,
-                        proxyClassFile, 0, proxyClassFile.length);
-                } catch (ClassFormatError e) {
-                    /*
-                     * A ClassFormatError here means that (barring bugs in the
-                     * proxy class generation code) there was some other
-                     * invalid aspect of the arguments supplied to the proxy
-                     * class creation (such as virtual machine limitations
-                     * exceeded).
-                     */
-                    throw new IllegalArgumentException(e.toString());
-                }
-            }
-            // add to set of all generated proxy classes, for isProxyClass
-            proxyClasses.put(proxyClass, null);
-
-        } finally {
-            /*
-             * We must clean up the "pending generation" state of the proxy
-             * class cache entry somehow.  If a proxy class was successfully
-             * generated, store it in the cache (with a weak reference);
-             * otherwise, remove the reserved entry.  In all cases, notify
-             * all waiters on reserved entries in this cache.
-             */
-            synchronized (cache) {
-                if (proxyClass != null) {
-                    cache.put(key, new WeakReference<Class<?>>(proxyClass));
-                } else {
-                    cache.remove(key);
-                }
-                cache.notifyAll();
+                throw new IllegalArgumentException(e.toString());
             }
         }
-        return proxyClass;
     }
 
     /**
@@ -773,11 +787,7 @@
      * @throws  NullPointerException if {@code cl} is {@code null}
      */
     public static boolean isProxyClass(Class<?> cl) {
-        if (cl == null) {
-            throw new NullPointerException();
-        }
-
-        return proxyClasses.containsKey(cl);
+        return Proxy.class.isAssignableFrom(cl) && proxyClassCache.containsValue(cl);
     }
 
     /**
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/src/share/classes/java/lang/reflect/WeakCache.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,393 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package java.lang.reflect;
+
+import java.lang.ref.ReferenceQueue;
+import java.lang.ref.WeakReference;
+import java.util.Objects;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+
+/**
+ * Cache mapping pairs of {@code (key, sub-key) -> value}. Keys and values are
+ * weakly but sub-keys are strongly referenced.  Keys are passed directly to
+ * {@link #get} method which also takes a {@code parameter}. Sub-keys are
+ * calculated from keys and parameters using the {@code subKeyFactory} function
+ * passed to the constructor. Values are calculated from keys and parameters
+ * using the {@code valueFactory} function passed to the constructor.
+ * Keys can be {@code null} and are compared by identity while sub-keys returned by
+ * {@code subKeyFactory} or values returned by {@code valueFactory}
+ * can not be null. Sub-keys are compared using their {@link #equals} method.
+ * Entries are expunged from cache lazily on each invocation to {@link #get},
+ * {@link #containsValue} or {@link #size} methods when the WeakReferences to
+ * keys are cleared. Cleared WeakReferences to individual values don't cause
+ * expunging, but such entries are logically treated as non-existent and
+ * trigger re-evaluation of {@code valueFactory} on request for their
+ * key/subKey.
+ *
+ * @author Peter Levart
+ * @param <K> type of keys
+ * @param <P> type of parameters
+ * @param <V> type of values
+ */
+final class WeakCache<K, P, V> {
+
+    interface BiFunction<T, U, R> {
+
+        /**
+         * Applies this function to the given arguments.
+         *
+         * @param t the first function argument
+         * @param u the second function argument
+         * @return the function result
+         */
+        R apply(T t, U u);
+    }
+
+    interface Supplier<T> {
+        T get();
+    }
+
+    private final ReferenceQueue<K> refQueue
+        = new ReferenceQueue<>();
+    // the key type is Object for supporting null key
+    private final ConcurrentMap<Object, ConcurrentMap<Object, Supplier<V>>> map
+        = new ConcurrentHashMap<>();
+    private final ConcurrentMap<Supplier<V>, Boolean> reverseMap
+        = new ConcurrentHashMap<>();
+    private final BiFunction<K, P, ?> subKeyFactory;
+    private final BiFunction<K, P, V> valueFactory;
+
+    /**
+     * Construct an instance of {@code WeakCache}
+     *
+     * @param subKeyFactory a function mapping a pair of
+     *                      {@code (key, parameter) -> sub-key}
+     * @param valueFactory  a function mapping a pair of
+     *                      {@code (key, parameter) -> value}
+     * @throws NullPointerException if {@code subKeyFactory} or
+     *                              {@code valueFactory} is null.
+     */
+    public WeakCache(BiFunction<K, P, ?> subKeyFactory,
+                     BiFunction<K, P, V> valueFactory) {
+        this.subKeyFactory = Objects.requireNonNull(subKeyFactory);
+        this.valueFactory = Objects.requireNonNull(valueFactory);
+    }
+
+    /**
+     * Look-up the value through the cache. This always evaluates the
+     * {@code subKeyFactory} function and optionally evaluates
+     * {@code valueFactory} function if there is no entry in the cache for given
+     * pair of (key, subKey) or the entry has already been cleared.
+     *
+     * @param key       possibly null key
+     * @param parameter parameter used together with key to create sub-key and
+     *                  value (should not be null)
+     * @return the cached value (never null)
+     * @throws NullPointerException if {@code parameter} passed in or
+     *                              {@code sub-key} calculated by
+     *                              {@code subKeyFactory} or {@code value}
+     *                              calculated by {@code valueFactory} is null.
+     */
+    public V get(K key, P parameter) {
+        Objects.requireNonNull(parameter);
+
+        expungeStaleEntries();
+
+        Object cacheKey = CacheKey.valueOf(key, refQueue);
+
+        // lazily install the 2nd level valuesMap for the particular cacheKey
+        ConcurrentMap<Object, Supplier<V>> valuesMap = map.get(cacheKey);
+        if (valuesMap == null) {
+            ConcurrentMap<Object, Supplier<V>> oldValuesMap
+                = map.putIfAbsent(cacheKey,
+                                  valuesMap = new ConcurrentHashMap<>());
+            if (oldValuesMap != null) {
+                valuesMap = oldValuesMap;
+            }
+        }
+
+        // create subKey and retrieve the possible Supplier<V> stored by that
+        // subKey from valuesMap
+        Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));
+        Supplier<V> supplier = valuesMap.get(subKey);
+        Factory factory = null;
+
+        while (true) {
+            if (supplier != null) {
+                // supplier might be a Factory or a CacheValue<V> instance
+                V value = supplier.get();
+                if (value != null) {
+                    return value;
+                }
+            }
+            // else no supplier in cache
+            // or a supplier that returned null (could be a cleared CacheValue
+            // or a Factory that wasn't successful in installing the CacheValue)
+
+            // lazily construct a Factory
+            if (factory == null) {
+                factory = new Factory(key, parameter, subKey, valuesMap);
+            }
+
+            if (supplier == null) {
+                supplier = valuesMap.putIfAbsent(subKey, factory);
+                if (supplier == null) {
+                    // successfully installed Factory
+                    supplier = factory;
+                }
+                // else retry with winning supplier
+            } else {
+                if (valuesMap.replace(subKey, supplier, factory)) {
+                    // successfully replaced
+                    // cleared CacheEntry / unsuccessful Factory
+                    // with our Factory
+                    supplier = factory;
+                } else {
+                    // retry with current supplier
+                    supplier = valuesMap.get(subKey);
+                }
+            }
+        }
+    }
+
+    /**
+     * Checks whether the specified non-null value is already present in this
+     * {@code WeakCache}. The check is made using identity comparison regardless
+     * of whether value's class overrides {@link Object#equals} or not.
+     *
+     * @param value the non-null value to check
+     * @return true if given {@code value} is already cached
+     * @throws NullPointerException if value is null
+     */
+    public boolean containsValue(V value) {
+        Objects.requireNonNull(value);
+
+        expungeStaleEntries();
+        return reverseMap.containsKey(new LookupValue<>(value));
+    }
+
+    /**
+     * Returns the current number of cached entries that
+     * can decrease over time when keys/values are GC-ed.
+     */
+    public int size() {
+        expungeStaleEntries();
+        return reverseMap.size();
+    }
+
+    private void expungeStaleEntries() {
+        CacheKey<K> cacheKey;
+        while ((cacheKey = (CacheKey<K>)refQueue.poll()) != null) {
+            cacheKey.expungeFrom(map, reverseMap);
+        }
+    }
+
+    /**
+     * A factory {@link Supplier} that implements the lazy synchronized
+     * construction of the value and installment of it into the cache.
+     */
+    private final class Factory implements Supplier<V> {
+
+        private final K key;
+        private final P parameter;
+        private final Object subKey;
+        private final ConcurrentMap<Object, Supplier<V>> valuesMap;
+
+        Factory(K key, P parameter, Object subKey,
+                ConcurrentMap<Object, Supplier<V>> valuesMap) {
+            this.key = key;
+            this.parameter = parameter;
+            this.subKey = subKey;
+            this.valuesMap = valuesMap;
+        }
+
+        @Override
+        public synchronized V get() { // serialize access
+            // re-check
+            Supplier<V> supplier = valuesMap.get(subKey);
+            if (supplier != this) {
+                // something changed while we were waiting:
+                // might be that we were replaced by a CacheValue
+                // or were removed because of failure ->
+                // return null to signal WeakCache.get() to retry
+                // the loop
+                return null;
+            }
+            // else still us (supplier == this)
+
+            // create new value
+            V value = null;
+            try {
+                value = Objects.requireNonNull(valueFactory.apply(key, parameter));
+            } finally {
+                if (value == null) { // remove us on failure
+                    valuesMap.remove(subKey, this);
+                }
+            }
+            // the only path to reach here is with non-null value
+            assert value != null;
+
+            // wrap value with CacheValue (WeakReference)
+            CacheValue<V> cacheValue = new CacheValue<>(value);
+
+            // try replacing us with CacheValue (this should always succeed)
+            if (valuesMap.replace(subKey, this, cacheValue)) {
+                // put also in reverseMap
+                reverseMap.put(cacheValue, Boolean.TRUE);
+            } else {
+                throw new AssertionError("Should not reach here");
+            }
+
+            // successfully replaced us with new CacheValue -> return the value
+            // wrapped by it
+            return value;
+        }
+    }
+
+    /**
+     * Common type of value suppliers that are holding a referent.
+     * The {@link #equals} and {@link #hashCode} of implementations is defined
+     * to compare the referent by identity.
+     */
+    private interface Value<V> extends Supplier<V> {}
+
+    /**
+     * An optimized {@link Value} used to look-up the value in
+     * {@link WeakCache#containsValue} method so that we are not
+     * constructing the whole {@link CacheValue} just to look-up the referent.
+     */
+    private static final class LookupValue<V> implements Value<V> {
+        private final V value;
+
+        LookupValue(V value) {
+            this.value = value;
+        }
+
+        @Override
+        public V get() {
+            return value;
+        }
+
+        @Override
+        public int hashCode() {
+            return System.identityHashCode(value); // compare by identity
+        }
+
+        @Override
+        public boolean equals(Object obj) {
+            return obj == this ||
+                   obj instanceof Value &&
+                   this.value == ((Value<?>) obj).get();  // compare by identity
+        }
+    }
+
+    /**
+     * A {@link Value} that weakly references the referent.
+     */
+    private static final class CacheValue<V>
+        extends WeakReference<V> implements Value<V>
+    {
+        private final int hash;
+
+        CacheValue(V value) {
+            super(value);
+            this.hash = System.identityHashCode(value); // compare by identity
+        }
+
+        @Override
+        public int hashCode() {
+            return hash;
+        }
+
+        @Override
+        public boolean equals(Object obj) {
+            V value;
+            return obj == this ||
+                   obj instanceof Value &&
+                   // cleared CacheValue is only equal to itself
+                   (value = get()) != null &&
+                   value == ((Value<?>) obj).get(); // compare by identity
+        }
+    }
+
+    /**
+     * CacheKey containing a weakly referenced {@code key}. It registers
+     * itself with the {@code refQueue} so that it can be used to expunge
+     * the entry when the {@link WeakReference} is cleared.
+     */
+    private static final class CacheKey<K> extends WeakReference<K> {
+
+        // a replacement for null keys
+        private static final Object NULL_KEY = new Object();
+
+        static <K> Object valueOf(K key, ReferenceQueue<K> refQueue) {
+            return key == null
+                   // null key means we can't weakly reference it,
+                   // so we use a NULL_KEY singleton as cache key
+                   ? NULL_KEY
+                   // non-null key requires wrapping with a WeakReference
+                   : new CacheKey<>(key, refQueue);
+        }
+
+        private final int hash;
+
+        private CacheKey(K key, ReferenceQueue<K> refQueue) {
+            super(key, refQueue);
+            this.hash = System.identityHashCode(key);  // compare by identity
+        }
+
+        @Override
+        public int hashCode() {
+            return hash;
+        }
+
+        @Override
+        public boolean equals(Object obj) {
+            K key;
+            return obj == this ||
+                   obj != null &&
+                   obj.getClass() == this.getClass() &&
+                   // cleared CacheKey is only equal to itself
+                   (key = this.get()) != null &&
+                   // compare key by identity
+                   key == ((CacheKey<K>) obj).get();
+        }
+
+        void expungeFrom(ConcurrentMap<?, ? extends ConcurrentMap<?, ?>> map,
+                         ConcurrentMap<?, Boolean> reverseMap) {
+            // removing just by key is always safe here because after a CacheKey
+            // is cleared and enqueue-ed it is only equal to itself
+            // (see equals method)...
+            ConcurrentMap<?, ?> valuesMap = map.remove(this);
+            // remove also from reverseMap if needed
+            if (valuesMap != null) {
+                for (Object cacheValue : valuesMap.values()) {
+                    reverseMap.remove(cacheValue);
+                }
+            }
+        }
+    }
+}
--- ./jdk/src/share/classes/java/net/IDN.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/java/net/IDN.java	Wed May 07 19:26:47 2014 -0700
@@ -271,13 +271,17 @@
         if (useSTD3ASCIIRules) {
             for (int i = 0; i < dest.length(); i++) {
                 int c = dest.charAt(i);
-                if (!isLDHChar(c)) {
-                    throw new IllegalArgumentException("Contains non-LDH characters");
+                if (isNonLDHAsciiCodePoint(c)) {
+                    throw new IllegalArgumentException(
+                        "Contains non-LDH ASCII characters");
                 }
             }
 
-            if (dest.charAt(0) == '-' || dest.charAt(dest.length() - 1) == '-') {
-                throw new IllegalArgumentException("Has leading or trailing hyphen");
+            if (dest.charAt(0) == '-' ||
+                dest.charAt(dest.length() - 1) == '-') {
+
+                throw new IllegalArgumentException(
+                        "Has leading or trailing hyphen");
             }
         }
 
@@ -380,26 +384,20 @@
     //
     // LDH stands for "letter/digit/hyphen", with characters restricted to the
     // 26-letter Latin alphabet <A-Z a-z>, the digits <0-9>, and the hyphen
-    // <->
-    // non-LDH = 0..0x2C, 0x2E..0x2F, 0x3A..0x40, 0x56..0x60, 0x7B..0x7F
+    // <->.
+    // Non LDH refers to characters in the ASCII range, but which are not
+    // letters, digits or the hypen.
     //
-    private static boolean isLDHChar(int ch){
-        // high runner case
-        if(ch > 0x007A){
-            return false;
-        }
-        //['-' '0'..'9' 'A'..'Z' 'a'..'z']
-        if((ch == 0x002D) ||
-           (0x0030 <= ch && ch <= 0x0039) ||
-           (0x0041 <= ch && ch <= 0x005A) ||
-           (0x0061 <= ch && ch <= 0x007A)
-          ){
-            return true;
-        }
-        return false;
+    // non-LDH = 0..0x2C, 0x2E..0x2F, 0x3A..0x40, 0x5B..0x60, 0x7B..0x7F
+    //
+    private static boolean isNonLDHAsciiCodePoint(int ch){
+        return (0x0000 <= ch && ch <= 0x002C) ||
+               (0x002E <= ch && ch <= 0x002F) ||
+               (0x003A <= ch && ch <= 0x0040) ||
+               (0x005B <= ch && ch <= 0x0060) ||
+               (0x007B <= ch && ch <= 0x007F);
     }
 
-
     //
     // search dots in a string and return the index of that character;
     // or if there is no dots, return the length of input string
--- ./jdk/src/share/classes/java/nio/charset/Charset.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/java/nio/charset/Charset.java	Wed May 07 19:26:47 2014 -0700
@@ -426,39 +426,32 @@
     }
 
     /* The extended set of charsets */
-    private static Object extendedProviderLock = new Object();
-    private static boolean extendedProviderProbed = false;
-    private static CharsetProvider extendedProvider = null;
-
-    private static void probeExtendedProvider() {
-        AccessController.doPrivileged(new PrivilegedAction<Object>() {
-                public Object run() {
-                    try {
-                        Class epc
-                            = Class.forName("sun.nio.cs.ext.ExtendedCharsets");
-                        extendedProvider = (CharsetProvider)epc.newInstance();
-                    } catch (ClassNotFoundException x) {
-                        // Extended charsets not available
-                        // (charsets.jar not present)
-                    } catch (InstantiationException x) {
-                        throw new Error(x);
-                    } catch (IllegalAccessException x) {
-                        throw new Error(x);
-                    }
-                    return null;
-                }
-            });
+    private static class ExtendedProviderHolder {
+        static final CharsetProvider extendedProvider = extendedProvider();
+        // returns ExtendedProvider, if installed
+        private static CharsetProvider extendedProvider() {
+            return AccessController.doPrivileged(
+                       new PrivilegedAction<CharsetProvider>() {
+                           public CharsetProvider run() {
+                                try {
+                                    Class<?> epc
+                                        = Class.forName("sun.nio.cs.ext.ExtendedCharsets");
+                                    return (CharsetProvider)epc.newInstance();
+                                } catch (ClassNotFoundException x) {
+                                    // Extended charsets not available
+                                    // (charsets.jar not present)
+                                } catch (InstantiationException |
+                                         IllegalAccessException x) {
+                                  throw new Error(x);
+                                }
+                                return null;
+                            }
+                        });
+        }
     }
 
     private static Charset lookupExtendedCharset(String charsetName) {
-        CharsetProvider ecp = null;
-        synchronized (extendedProviderLock) {
-            if (!extendedProviderProbed) {
-                probeExtendedProvider();
-                extendedProviderProbed = true;
-            }
-            ecp = extendedProvider;
-        }
+        CharsetProvider ecp = ExtendedProviderHolder.extendedProvider;
         return (ecp != null) ? ecp.charsetForName(charsetName) : null;
     }
 
@@ -588,6 +581,9 @@
                         new TreeMap<String,Charset>(
                             ASCIICaseInsensitiveComparator.CASE_INSENSITIVE_ORDER);
                     put(standardProvider.charsets(), m);
+                    CharsetProvider ecp = ExtendedProviderHolder.extendedProvider;
+                    if (ecp != null)
+                        put(ecp.charsets(), m);
                     for (Iterator i = providers(); i.hasNext();) {
                         CharsetProvider cp = (CharsetProvider)i.next();
                         put(cp.charsets(), m);
--- ./jdk/src/share/classes/java/nio/file/Files.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/java/nio/file/Files.java	Wed May 07 19:26:47 2014 -0700
@@ -28,6 +28,8 @@
 import java.nio.file.attribute.*;
 import java.nio.file.spi.FileSystemProvider;
 import java.nio.file.spi.FileTypeDetector;
+import java.nio.channels.Channels;
+import java.nio.channels.FileChannel;
 import java.nio.channels.SeekableByteChannel;
 import java.io.InputStream;
 import java.io.OutputStream;
@@ -2896,41 +2898,63 @@
     }
 
     /**
-     * Read all the bytes from an input stream. The {@code initialSize}
-     * parameter indicates the initial size of the byte[] to allocate.
+     * The maximum size of array to allocate.
+     * Some VMs reserve some header words in an array.
+     * Attempts to allocate larger arrays may result in
+     * OutOfMemoryError: Requested array size exceeds VM limit
+     */
+    private static final int MAX_BUFFER_SIZE = Integer.MAX_VALUE - 8;
+
+    /**
+     * Reads all the bytes from an input stream. Uses {@code initialSize} as a hint
+     * about how many bytes the stream will have.
+     *
+     * @param   source
+     *          the input stream to read from
+     * @param   initialSize
+     *          the initial size of the byte array to allocate
+     *
+     * @return  a byte array containing the bytes read from the file
+     *
+     * @throws  IOException
+     *          if an I/O error occurs reading from the stream
+     * @throws  OutOfMemoryError
+     *          if an array of the required size cannot be allocated
      */
     private static byte[] read(InputStream source, int initialSize)
-        throws IOException
+            throws IOException
     {
         int capacity = initialSize;
         byte[] buf = new byte[capacity];
         int nread = 0;
-        int rem = buf.length;
         int n;
-        // read to EOF which may read more or less than initialSize (eg: file
-        // is truncated while we are reading)
-        while ((n = source.read(buf, nread, rem)) > 0) {
-            nread += n;
-            rem -= n;
-            assert rem >= 0;
-            if (rem == 0) {
-                // need larger buffer
-                int newCapacity = capacity << 1;
-                if (newCapacity < 0) {
-                    if (capacity == Integer.MAX_VALUE)
-                        throw new OutOfMemoryError("Required array size too large");
-                    newCapacity = Integer.MAX_VALUE;
-                }
-                rem = newCapacity - capacity;
-                buf = Arrays.copyOf(buf, newCapacity);
-                capacity = newCapacity;
+        for (;;) {
+            // read to EOF which may read more or less than initialSize (eg: file
+            // is truncated while we are reading)
+            while ((n = source.read(buf, nread, capacity - nread)) > 0)
+                nread += n;
+
+            // if last call to source.read() returned -1, we are done
+            // otherwise, try to read one more byte; if that failed we're done too
+            if (n < 0 || (n = source.read()) < 0)
+                break;
+
+            // one more byte was read; need to allocate a larger buffer
+            if (capacity <= MAX_BUFFER_SIZE - capacity) {
+                capacity = Math.max(capacity << 1, BUFFER_SIZE);
+            } else {
+                if (capacity == MAX_BUFFER_SIZE)
+                    throw new OutOfMemoryError("Required array size too large");
+                capacity = MAX_BUFFER_SIZE;
             }
+            buf = Arrays.copyOf(buf, capacity);
+            buf[nread++] = (byte)n;
         }
         return (capacity == nread) ? buf : Arrays.copyOf(buf, nread);
     }
 
     /**
-     * Read all the bytes from a file. The method ensures that the file is
+     * Reads all the bytes from a file. The method ensures that the file is
      * closed when all bytes have been read or an I/O error, or other runtime
      * exception, is thrown.
      *
@@ -2954,12 +2978,13 @@
      *          method is invoked to check read access to the file.
      */
     public static byte[] readAllBytes(Path path) throws IOException {
-        long size = size(path);
-        if (size > (long)Integer.MAX_VALUE)
-            throw new OutOfMemoryError("Required array size too large");
+        try (SeekableByteChannel sbc = Files.newByteChannel(path);
+             InputStream in = Channels.newInputStream(sbc)) {
+            long size = sbc.size();
+            if (size > (long)MAX_BUFFER_SIZE)
+                throw new OutOfMemoryError("Required array size too large");
 
-        try (InputStream in = newInputStream(path)) {
-             return read(in, (int)size);
+            return read(in, (int)size);
         }
     }
 
--- ./jdk/src/share/classes/java/util/ComparableTimSort.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/java/util/ComparableTimSort.java	Wed May 07 19:26:47 2014 -0700
@@ -131,7 +131,7 @@
          */
         int stackLen = (len <    120  ?  5 :
                         len <   1542  ? 10 :
-                        len < 119151  ? 19 : 40);
+                        len < 119151  ? 24 : 40);
         runBase = new int[stackLen];
         runLen = new int[stackLen];
     }
--- ./jdk/src/share/classes/java/util/HashMap.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/java/util/HashMap.java	Wed May 07 19:26:47 2014 -0700
@@ -300,13 +300,9 @@
 
     private static int roundUpToPowerOf2(int number) {
         // assert number >= 0 : "number must be non-negative";
-        int rounded = number >= MAXIMUM_CAPACITY
+        return number >= MAXIMUM_CAPACITY
                 ? MAXIMUM_CAPACITY
-                : (rounded = Integer.highestOneBit(number)) != 0
-                    ? (Integer.bitCount(number) > 1) ? rounded << 1 : rounded
-                    : 1;
-
-        return rounded;
+                : (number > 1) ? Integer.highestOneBit((number - 1) << 1) : 1;
     }
 
     /**
--- ./jdk/src/share/classes/java/util/TimSort.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/java/util/TimSort.java	Wed May 07 19:26:47 2014 -0700
@@ -158,7 +158,7 @@
          */
         int stackLen = (len <    120  ?  5 :
                         len <   1542  ? 10 :
-                        len < 119151  ? 19 : 40);
+                        len < 119151  ? 24 : 40);
         runBase = new int[stackLen];
         runLen = new int[stackLen];
     }
--- ./jdk/src/share/classes/java/util/TimeZone.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/java/util/TimeZone.java	Wed May 07 19:26:47 2014 -0700
@@ -168,7 +168,7 @@
     // TimeZone.setDefault maintains the compatible behavior of the AppContext-based
     // default setting for untrusted code if allowSetDefault is true.
     private static final boolean allowSetDefault = AccessController.doPrivileged(
-        new sun.security.action.GetPropertyAction("jdk.util.TimeZone.allowSetDefault")) != null;
+    new sun.security.action.GetPropertyAction("jdk.util.TimeZone.allowSetDefault")) != null;
 
     /**
      * Gets the time zone offset, for current date, modified in case of
@@ -738,17 +738,16 @@
         if (allowSetDefault) {
             // JavaAWTAccess provides access implementation-private methods without using reflection.
             JavaAWTAccess javaAWTAccess = SharedSecrets.getJavaAWTAccess();
-            if (javaAWTAccess == null) {
+            if (System.getSecurityManager() == null || javaAWTAccess == null) {
                 return mainAppContextDefault;
+            } else if (javaAWTAccess.isDisposed()) {
+                return null;
             } else {
-                if (!javaAWTAccess.isDisposed()) {
-                    TimeZone tz = (TimeZone)
-                        javaAWTAccess.get(TimeZone.class);
-                    if (tz == null && javaAWTAccess.isMainAppContext()) {
-                        return mainAppContextDefault;
-                    } else {
-                        return tz;
-                    }
+                TimeZone tz = (TimeZone) javaAWTAccess.get(TimeZone.class);
+                if (tz == null && javaAWTAccess.isMainAppContext()) {
+                    return mainAppContextDefault;
+                } else {
+                    return tz;
                 }
             }
         }
@@ -770,14 +769,12 @@
         if (allowSetDefault) {
             // JavaAWTAccess provides access implementation-private methods without using reflection.
             JavaAWTAccess javaAWTAccess = SharedSecrets.getJavaAWTAccess();
-            if (javaAWTAccess == null) {
+            if (System.getSecurityManager() == null || javaAWTAccess == null) {
                 mainAppContextDefault = tz;
-            } else {
-                if (!javaAWTAccess.isDisposed()) {
-                    javaAWTAccess.put(TimeZone.class, tz);
-                    if (javaAWTAccess.isMainAppContext()) {
-                        mainAppContextDefault = null;
-                    }
+            } else if (!javaAWTAccess.isDisposed()) {
+                javaAWTAccess.put(TimeZone.class, tz);
+                if (javaAWTAccess.isMainAppContext()) {
+                    mainAppContextDefault = null;
                 }
             }
         }
--- ./jdk/src/share/classes/java/util/jar/JarFile.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/java/util/jar/JarFile.java	Wed May 07 19:26:47 2014 -0700
@@ -38,6 +38,7 @@
 import sun.security.action.GetPropertyAction;
 import sun.security.util.ManifestEntryVerifier;
 import sun.misc.SharedSecrets;
+import sun.security.util.SignatureFileVerifier;
 
 /**
  * The <code>JarFile</code> class is used to read the contents of a jar file
@@ -329,11 +330,13 @@
             String[] names = getMetaInfEntryNames();
             if (names != null) {
                 for (int i = 0; i < names.length; i++) {
-                    JarEntry e = getJarEntry(names[i]);
-                    if (e == null) {
-                        throw new JarException("corrupted jar file");
-                    }
-                    if (!e.isDirectory()) {
+                    String uname = names[i].toUpperCase(Locale.ENGLISH);
+                    if (MANIFEST_NAME.equals(uname)
+                            || SignatureFileVerifier.isBlockOrSF(uname)) {
+                        JarEntry e = getJarEntry(names[i]);
+                        if (e == null) {
+                            throw new JarException("corrupted jar file");
+                        }
                         if (mev == null) {
                             mev = new ManifestEntryVerifier
                                 (getManifestFromReference());
--- ./jdk/src/share/classes/java/util/jar/JarVerifier.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/java/util/jar/JarVerifier.java	Wed May 07 19:26:47 2014 -0700
@@ -32,6 +32,7 @@
 import java.security.cert.CertificateException;
 import java.util.zip.ZipEntry;
 
+import sun.misc.JarIndex;
 import sun.security.util.ManifestDigester;
 import sun.security.util.ManifestEntryVerifier;
 import sun.security.util.SignatureFileVerifier;
@@ -139,13 +140,22 @@
                     return;
                 }
 
+                if (uname.equals(JarFile.MANIFEST_NAME) ||
+                        uname.equals(JarIndex.INDEX_NAME)) {
+                    return;
+                }
+
                 if (SignatureFileVerifier.isBlockOrSF(uname)) {
                     /* We parse only DSA, RSA or EC PKCS7 blocks. */
                     parsingBlockOrSF = true;
                     baos.reset();
                     mev.setEntry(null, je);
+                    return;
                 }
-                return;
+
+                // If a META-INF entry is not MF or block or SF, they should
+                // be normal entries. According to 2 above, no more block or
+                // SF will appear. Let's doneWithMeta.
             }
         }
 
--- ./jdk/src/share/classes/java/util/logging/Level.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/java/util/logging/Level.java	Wed May 07 19:26:47 2014 -0700
@@ -27,6 +27,7 @@
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
+import java.util.Locale;
 import java.util.Map;
 import java.util.ResourceBundle;
 
@@ -63,7 +64,7 @@
  */
 
 public class Level implements java.io.Serializable {
-    private static String defaultBundle = "sun.util.logging.resources.logging";
+    private static final String defaultBundle = "sun.util.logging.resources.logging";
 
     /**
      * @serial  The non-localized name of the level.
@@ -81,7 +82,8 @@
     private final String resourceBundleName;
 
     // localized level name
-    private String localizedLevelName;
+    private transient String localizedLevelName;
+    private transient Locale cachedLocale;
 
     /**
      * OFF is a special level that can be used to turn off logging.
@@ -209,6 +211,7 @@
         this.value = value;
         this.resourceBundleName = resourceBundleName;
         this.localizedLevelName = resourceBundleName == null ? name : null;
+        this.cachedLocale = null;
         KnownLevel.add(this);
     }
 
@@ -250,17 +253,71 @@
         return this.name;
     }
 
-    final synchronized String getLocalizedLevelName() {
+    private String computeLocalizedLevelName(Locale newLocale) {
+        ResourceBundle rb = ResourceBundle.getBundle(resourceBundleName, newLocale);
+        final String localizedName = rb.getString(name);
+
+        final boolean isDefaultBundle = defaultBundle.equals(resourceBundleName);
+        if (!isDefaultBundle) return localizedName;
+
+        // This is a trick to determine whether the name has been translated
+        // or not. If it has not been translated, we need to use Locale.ROOT
+        // when calling toUpperCase().
+        final Locale rbLocale = rb.getLocale();
+        final Locale locale =
+                Locale.ROOT.equals(rbLocale)
+                || name.equals(localizedName.toUpperCase(Locale.ROOT))
+                ? Locale.ROOT : rbLocale;
+
+        // ALL CAPS in a resource bundle's message indicates no translation
+        // needed per Oracle translation guideline.  To workaround this
+        // in Oracle JDK implementation, convert the localized level name
+        // to uppercase for compatibility reason.
+        return Locale.ROOT.equals(locale) ? name : localizedName.toUpperCase(locale);
+    }
+
+    // Avoid looking up the localizedLevelName twice if we already
+    // have it.
+    final String getCachedLocalizedLevelName() {
+
         if (localizedLevelName != null) {
-            return localizedLevelName;
+            if (cachedLocale != null) {
+                if (cachedLocale.equals(Locale.getDefault())) {
+                    // OK: our cached value was looked up with the same
+                    //     locale. We can use it.
+                    return localizedLevelName;
+                }
+            }
         }
 
+        if (resourceBundleName == null) {
+            // No resource bundle: just use the name.
+            return name;
+        }
+
+        // We need to compute the localized name.
+        // Either because it's the first time, or because our cached
+        // value is for a different locale. Just return null.
+        return null;
+    }
+
+    final synchronized String getLocalizedLevelName() {
+
+        // See if we have a cached localized name
+        final String cachedLocalizedName = getCachedLocalizedLevelName();
+        if (cachedLocalizedName != null) {
+            return cachedLocalizedName;
+        }
+
+        // No cached localized name or cache invalid.
+        // Need to compute the localized name.
+        final Locale newLocale = Locale.getDefault();
         try {
-            ResourceBundle rb = ResourceBundle.getBundle(resourceBundleName);
-            localizedLevelName = rb.getString(name);
+            localizedLevelName = computeLocalizedLevelName(newLocale);
         } catch (Exception ex) {
             localizedLevelName = name;
         }
+        cachedLocale = newLocale;
         return localizedLevelName;
     }
 
@@ -318,6 +375,7 @@
      *
      * @return the non-localized name of the Level, for example "INFO".
      */
+    @Override
     public final String toString() {
         return name;
     }
@@ -420,6 +478,7 @@
      * Compare two objects for value equality.
      * @return true if and only if the two objects have the same level value.
      */
+    @Override
     public boolean equals(Object ox) {
         try {
             Level lx = (Level)ox;
@@ -433,6 +492,7 @@
      * Generate a hashcode.
      * @return a hashcode based on the level value
      */
+    @Override
     public int hashCode() {
         return this.value;
     }
--- ./jdk/src/share/classes/java/util/logging/LogManager.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/java/util/logging/LogManager.java	Wed May 07 19:26:47 2014 -0700
@@ -149,7 +149,15 @@
     // The global LogManager object
     private static LogManager manager;
 
-    private Properties props = new Properties();
+    // 'props' is assigned within a lock but accessed without it.
+    // Declaring it volatile makes sure that another thread will not
+    // be able to see a partially constructed 'props' object.
+    // (seeing a partially constructed 'props' object can result in
+    // NPE being thrown in Hashtable.get(), because it leaves the door
+    // open for props.getProperties() to be called before the construcor
+    // of Hashtable is actually completed).
+    private volatile Properties props = new Properties();
+
     private PropertyChangeSupport changes
                          = new PropertyChangeSupport(LogManager.class);
     private final static Level defaultLevel = Level.INFO;
@@ -540,7 +548,7 @@
             if (logger == null) {
                 // Hashtable holds stale weak reference
                 // to a logger which has been GC-ed.
-                removeLogger(name);
+                ref.dispose();
             }
             return logger;
         }
@@ -627,7 +635,7 @@
                     // It's possible that the Logger was GC'ed after a
                     // drainLoggerRefQueueBounded() call so allow
                     // a new one to be registered.
-                    removeLogger(name);
+                    ref.dispose();
                 } else {
                     // We already have a registered logger with the given name.
                     return false;
@@ -673,10 +681,10 @@
             return true;
         }
 
-        // note: all calls to removeLogger are synchronized on LogManager's
-        // intrinsic lock
-        void removeLogger(String name) {
-            namedLoggers.remove(name);
+        synchronized void removeLoggerRef(String name, LoggerWeakRef ref) {
+            if (namedLoggers.get(name) == ref) {
+                namedLoggers.remove(name);
+            }
         }
 
         synchronized Enumeration<String> getLoggerNames() {
@@ -854,6 +862,7 @@
         private String                name;       // for namedLoggers cleanup
         private LogNode               node;       // for loggerRef cleanup
         private WeakReference<Logger> parentRef;  // for kids cleanup
+        private boolean disposed = false;         // avoid calling dispose twice
 
         LoggerWeakRef(Logger logger) {
             super(logger, loggerRefQueue);
@@ -863,14 +872,45 @@
 
         // dispose of this LoggerWeakRef object
         void dispose() {
-            if (node != null) {
-                // if we have a LogNode, then we were a named Logger
-                // so clear namedLoggers weak ref to us
-                node.context.removeLogger(name);
-                name = null;  // clear our ref to the Logger's name
+            // Avoid calling dispose twice. When a Logger is gc'ed, its
+            // LoggerWeakRef will be enqueued.
+            // However, a new logger of the same name may be added (or looked
+            // up) before the queue is drained. When that happens, dispose()
+            // will be called by addLocalLogger() or findLogger().
+            // Later when the queue is drained, dispose() will be called again
+            // for the same LoggerWeakRef. Marking LoggerWeakRef as disposed
+            // avoids processing the data twice (even though the code should
+            // now be reentrant).
+            synchronized(this) {
+                // Note to maintainers:
+                // Be careful not to call any method that tries to acquire
+                // another lock from within this block - as this would surely
+                // lead to deadlocks, given that dispose() can be called by
+                // multiple threads, and from within different synchronized
+                // methods/blocks.
+                if (disposed) return;
+                disposed = true;
+            }
 
-                node.loggerRef = null;  // clear LogNode's weak ref to us
-                node = null;            // clear our ref to LogNode
+            final LogNode n = node;
+            if (n != null) {
+                // n.loggerRef can only be safely modified from within
+                // a lock on LoggerContext. removeLoggerRef is already
+                // synchronized on LoggerContext so calling
+                // n.context.removeLoggerRef from within this lock is safe.
+                synchronized (n.context) {
+                    // if we have a LogNode, then we were a named Logger
+                    // so clear namedLoggers weak ref to us
+                    n.context.removeLoggerRef(name, this);
+                    name = null;  // clear our ref to the Logger's name
+
+                    // LogNode may have been reused - so only clear
+                    // LogNode.loggerRef if LogNode.loggerRef == this
+                    if (n.loggerRef == this) {
+                        n.loggerRef = null;  // clear LogNode's weak ref to us
+                    }
+                    node = null;            // clear our ref to LogNode
+                }
             }
 
             if (parentRef != null) {
@@ -923,7 +963,7 @@
     //   - maximum: 10.9 ms
     //
     private final static int MAX_ITERATIONS = 400;
-    final synchronized void drainLoggerRefQueueBounded() {
+    final void drainLoggerRefQueueBounded() {
         for (int i = 0; i < MAX_ITERATIONS; i++) {
             if (loggerRefQueue == null) {
                 // haven't finished loading LogManager yet
--- ./jdk/src/share/classes/java/util/logging/Logger.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/java/util/logging/Logger.java	Wed May 07 19:26:47 2014 -0700
@@ -174,7 +174,7 @@
 public class Logger {
     private static final Handler emptyHandlers[] = new Handler[0];
     private static final int offValue = Level.OFF.intValue();
-    private LogManager manager;
+    private volatile LogManager manager;
     private String name;
     private final CopyOnWriteArrayList<Handler> handlers =
         new CopyOnWriteArrayList<>();
@@ -1573,6 +1573,9 @@
         if (parent == null) {
             throw new NullPointerException();
         }
+        if (manager == null) {
+            manager = LogManager.getLogManager();
+        }
         manager.checkPermission();
         doSetParent(parent);
     }
--- ./jdk/src/share/classes/javax/management/MBeanAttributeInfo.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/javax/management/MBeanAttributeInfo.java	Wed May 07 19:26:47 2014 -0700
@@ -30,6 +30,7 @@
 
 import com.sun.jmx.mbeanserver.GetPropertyAction;
 import com.sun.jmx.mbeanserver.Introspector;
+import java.util.Objects;
 
 
 /**
@@ -285,10 +286,10 @@
         if (!(o instanceof MBeanAttributeInfo))
             return false;
         MBeanAttributeInfo p = (MBeanAttributeInfo) o;
-        return (p.getName().equals(getName()) &&
-                p.getType().equals(getType()) &&
-                p.getDescription().equals(getDescription()) &&
-                p.getDescriptor().equals(getDescriptor()) &&
+        return (Objects.equals(p.getName(), getName()) &&
+                Objects.equals(p.getType(), getType()) &&
+                Objects.equals(p.getDescription(), getDescription()) &&
+                Objects.equals(p.getDescriptor(), getDescriptor()) &&
                 p.isReadable() == isReadable() &&
                 p.isWritable() == isWritable() &&
                 p.isIs() == isIs());
@@ -301,7 +302,7 @@
        right and we needlessly hashed in the description and parameter
        array.  */
     public int hashCode() {
-        return getName().hashCode() ^ getType().hashCode();
+        return Objects.hash(getName(), getType());
     }
 
     private static boolean isIs(Method getter) {
--- ./jdk/src/share/classes/javax/management/MBeanConstructorInfo.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/javax/management/MBeanConstructorInfo.java	Wed May 07 19:26:47 2014 -0700
@@ -29,6 +29,7 @@
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Constructor;
 import java.util.Arrays;
+import java.util.Objects;
 
 /**
  * Describes a constructor exposed by an MBean.  Instances of this
@@ -190,10 +191,10 @@
         if (!(o instanceof MBeanConstructorInfo))
             return false;
         MBeanConstructorInfo p = (MBeanConstructorInfo) o;
-        return (p.getName().equals(getName()) &&
-                p.getDescription().equals(getDescription()) &&
+        return (Objects.equals(p.getName(), getName()) &&
+                Objects.equals(p.getDescription(), getDescription()) &&
                 Arrays.equals(p.fastGetSignature(), fastGetSignature()) &&
-                p.getDescriptor().equals(getDescriptor()));
+                Objects.equals(p.getDescriptor(), getDescriptor()));
     }
 
     /* Unlike attributes and operations, it's quite likely we'll have
@@ -203,11 +204,7 @@
        quite long and yet the same between constructors.  Likewise for
        the descriptor.  */
     public int hashCode() {
-        int hash = getName().hashCode();
-        MBeanParameterInfo[] sig = fastGetSignature();
-        for (int i = 0; i < sig.length; i++)
-            hash ^= sig[i].hashCode();
-        return hash;
+        return Objects.hash(getName()) ^ Arrays.hashCode(fastGetSignature());
     }
 
     private static MBeanParameterInfo[] constructorSignature(Constructor<?> cn) {
--- ./jdk/src/share/classes/javax/management/MBeanFeatureInfo.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/javax/management/MBeanFeatureInfo.java	Wed May 07 19:26:47 2014 -0700
@@ -30,6 +30,7 @@
 import java.io.ObjectOutputStream;
 import java.io.Serializable;
 import java.io.StreamCorruptedException;
+import java.util.Objects;
 
 /**
  * <p>Provides general information for an MBean descriptor object.
@@ -147,9 +148,9 @@
         if (!(o instanceof MBeanFeatureInfo))
             return false;
         MBeanFeatureInfo p = (MBeanFeatureInfo) o;
-        return (p.getName().equals(getName()) &&
-                p.getDescription().equals(getDescription()) &&
-                p.getDescriptor().equals(getDescriptor()));
+        return (Objects.equals(p.getName(), getName()) &&
+                Objects.equals(p.getDescription(), getDescription()) &&
+                Objects.equals(p.getDescriptor(), getDescriptor()));
     }
 
     public int hashCode() {
--- ./jdk/src/share/classes/javax/management/MBeanInfo.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/javax/management/MBeanInfo.java	Wed May 07 19:26:47 2014 -0700
@@ -36,6 +36,7 @@
 import java.util.WeakHashMap;
 import java.security.AccessController;
 import java.security.PrivilegedAction;
+import java.util.Objects;
 
 import static javax.management.ImmutableDescriptor.nonNullDescriptor;
 
@@ -515,24 +516,15 @@
         if (hashCode != 0)
             return hashCode;
 
-        hashCode =
-            getClassName().hashCode() ^
-            getDescriptor().hashCode() ^
-            arrayHashCode(fastGetAttributes()) ^
-            arrayHashCode(fastGetOperations()) ^
-            arrayHashCode(fastGetConstructors()) ^
-            arrayHashCode(fastGetNotifications());
+        hashCode = Objects.hash(getClassName(), getDescriptor())
+                ^ Arrays.hashCode(fastGetAttributes())
+                ^ Arrays.hashCode(fastGetOperations())
+                ^ Arrays.hashCode(fastGetConstructors())
+                ^ Arrays.hashCode(fastGetNotifications());
 
         return hashCode;
     }
 
-    private static int arrayHashCode(Object[] array) {
-        int hash = 0;
-        for (int i = 0; i < array.length; i++)
-            hash ^= array[i].hashCode();
-        return hash;
-    }
-
     /**
      * Cached results of previous calls to arrayGettersSafe.  This is
      * a WeakHashMap so that we don't prevent a class from being
--- ./jdk/src/share/classes/javax/management/MBeanNotificationInfo.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/javax/management/MBeanNotificationInfo.java	Wed May 07 19:26:47 2014 -0700
@@ -29,6 +29,7 @@
 import java.io.InvalidObjectException;
 import java.io.ObjectInputStream;
 import java.util.Arrays;
+import java.util.Objects;
 
 /**
  * <p>The <CODE>MBeanNotificationInfo</CODE> class is used to describe the
@@ -193,9 +194,9 @@
         if (!(o instanceof MBeanNotificationInfo))
             return false;
         MBeanNotificationInfo p = (MBeanNotificationInfo) o;
-        return (p.getName().equals(getName()) &&
-                p.getDescription().equals(getDescription()) &&
-                p.getDescriptor().equals(getDescriptor()) &&
+        return (Objects.equals(p.getName(), getName()) &&
+                Objects.equals(p.getDescription(), getDescription()) &&
+                Objects.equals(p.getDescriptor(), getDescriptor()) &&
                 Arrays.equals(p.fastGetNotifTypes(), fastGetNotifTypes()));
     }
 
--- ./jdk/src/share/classes/javax/management/MBeanOperationInfo.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/javax/management/MBeanOperationInfo.java	Wed May 07 19:26:47 2014 -0700
@@ -29,6 +29,7 @@
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Method;
 import java.util.Arrays;
+import java.util.Objects;
 
 /**
  * Describes a management operation exposed by an MBean.  Instances of
@@ -293,12 +294,12 @@
         if (!(o instanceof MBeanOperationInfo))
             return false;
         MBeanOperationInfo p = (MBeanOperationInfo) o;
-        return (p.getName().equals(getName()) &&
-                p.getReturnType().equals(getReturnType()) &&
-                p.getDescription().equals(getDescription()) &&
+        return (Objects.equals(p.getName(), getName()) &&
+                Objects.equals(p.getReturnType(), getReturnType()) &&
+                Objects.equals(p.getDescription(), getDescription()) &&
                 p.getImpact() == getImpact() &&
                 Arrays.equals(p.fastGetSignature(), fastGetSignature()) &&
-                p.getDescriptor().equals(getDescriptor()));
+                Objects.equals(p.getDescriptor(), getDescriptor()));
     }
 
     /* We do not include everything in the hashcode.  We assume that
@@ -309,7 +310,7 @@
        parameter array.  */
     @Override
     public int hashCode() {
-        return getName().hashCode() ^ getReturnType().hashCode();
+        return Objects.hash(getName(), getReturnType());
     }
 
     private static MBeanParameterInfo[] methodSignature(Method method) {
--- ./jdk/src/share/classes/javax/management/MBeanParameterInfo.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/javax/management/MBeanParameterInfo.java	Wed May 07 19:26:47 2014 -0700
@@ -25,6 +25,8 @@
 
 package javax.management;
 
+import java.util.Objects;
+
 
 /**
  * Describes an argument of an operation exposed by an MBean.
@@ -136,13 +138,13 @@
         if (!(o instanceof MBeanParameterInfo))
             return false;
         MBeanParameterInfo p = (MBeanParameterInfo) o;
-        return (p.getName().equals(getName()) &&
-                p.getType().equals(getType()) &&
-                p.getDescription().equals(getDescription()) &&
-                p.getDescriptor().equals(getDescriptor()));
+        return (Objects.equals(p.getName(), getName()) &&
+                Objects.equals(p.getType(), getType()) &&
+                Objects.equals(p.getDescription(), getDescription()) &&
+                Objects.equals(p.getDescriptor(), getDescriptor()));
     }
 
     public int hashCode() {
-        return getName().hashCode() ^ getType().hashCode();
+        return Objects.hash(getName(), getType());
     }
 }
--- ./jdk/src/share/classes/javax/management/openmbean/OpenMBeanInfoSupport.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/javax/management/openmbean/OpenMBeanInfoSupport.java	Wed May 07 19:26:47 2014 -0700
@@ -31,6 +31,7 @@
 //
 import java.util.Arrays;
 import java.util.HashSet;
+import java.util.Objects;
 
 import javax.management.Descriptor;
 import javax.management.MBeanAttributeInfo;
@@ -269,8 +270,9 @@
         //
 
         // their MBean className should be equal
-        if ( ! this.getClassName().equals(other.getClassName()) )
+        if (!Objects.equals(this.getClassName(), other.getClassName())) {
             return false;
+        }
 
         // their infos on attributes should be equal (order not
         // significant => equality between sets, not arrays or lists)
@@ -342,7 +344,9 @@
         //
         if (myHashCode == null) {
             int value = 0;
-            value += this.getClassName().hashCode();
+            if (this.getClassName() != null) {
+                value += this.getClassName().hashCode();
+            }
             value += arraySetHash(this.getAttributes());
             value += arraySetHash(this.getConstructors());
             value += arraySetHash(this.getOperations());
--- ./jdk/src/share/classes/javax/management/relation/RelationNotification.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/javax/management/relation/RelationNotification.java	Wed May 07 19:26:47 2014 -0700
@@ -260,7 +260,7 @@
 
         super(notifType, sourceObj, sequence, timeStamp, message);
 
-        if (!isValidBasic(notifType,sourceObj,id,typeName) || !isValidCreate(notifType)) {
+        if (!isValidBasicStrict(notifType,sourceObj,id,typeName) || !isValidCreate(notifType)) {
             throw new IllegalArgumentException("Invalid parameter.");
         }
 
@@ -310,7 +310,7 @@
 
         super(notifType, sourceObj, sequence, timeStamp, message);
 
-        if (!isValidBasic(notifType,sourceObj,id,typeName) || !isValidUpdate(notifType,name,newValue,oldValue)) {
+        if (!isValidBasicStrict(notifType,sourceObj,id,typeName) || !isValidUpdate(notifType,name,newValue,oldValue)) {
             throw new IllegalArgumentException("Invalid parameter.");
         }
 
@@ -457,14 +457,26 @@
     //  - no role old value (for role update)
     //  - no role new value (for role update)
 
+    // Despite the fact, that validation in constructor of RelationNotification prohibit
+    // creation of the class instance with null sourceObj its possible to set it to null later
+    // by public setSource() method.
+    // So we should relax validation rules to preserve serialization behavior compatibility.
+
+    private boolean isValidBasicStrict(String notifType, Object sourceObj, String id, String typeName){
+        if (sourceObj == null) {
+            return false;
+        }
+        return isValidBasic(notifType,sourceObj,id,typeName);
+    }
+
     private boolean isValidBasic(String notifType, Object sourceObj, String id, String typeName){
-        if (notifType == null || sourceObj == null ||
-            id == null || typeName == null) {
+        if (notifType == null || id == null || typeName == null) {
             return false;
         }
 
-        if (!(sourceObj instanceof RelationService) &&
-            !(sourceObj instanceof ObjectName)) {
+        if (sourceObj != null && (
+            !(sourceObj instanceof RelationService) &&
+            !(sourceObj instanceof ObjectName))) {
             return false;
         }
 
--- ./jdk/src/share/classes/javax/management/remote/rmi/RMIConnector.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/javax/management/remote/rmi/RMIConnector.java	Wed May 07 19:26:47 2014 -0700
@@ -405,14 +405,7 @@
             throw new IOException("Not connected");
         }
 
-        MBeanServerConnection rmbsc = rmbscMap.get(delegationSubject);
-        if (rmbsc != null) {
-            return rmbsc;
-        }
-
-        rmbsc = new RemoteMBeanServerConnection(delegationSubject);
-        rmbscMap.put(delegationSubject, rmbsc);
-        return rmbsc;
+        return getConnectionWithSubject(delegationSubject);
     }
 
     public void
@@ -1831,7 +1824,7 @@
 
     // Initialization of transient variables.
     private void initTransients() {
-        rmbscMap = new WeakHashMap<Subject, MBeanServerConnection>();
+        rmbscMap = new WeakHashMap<Subject, WeakReference<MBeanServerConnection>>();
         connected = false;
         terminated = false;
 
@@ -2011,6 +2004,25 @@
         private final ClassLoader loader;
     }
 
+    private MBeanServerConnection getConnectionWithSubject(Subject delegationSubject) {
+        MBeanServerConnection conn = null;
+
+        if (delegationSubject == null) {
+            if (nullSubjectConnRef == null
+                    || (conn = nullSubjectConnRef.get()) == null) {
+                conn = new RemoteMBeanServerConnection(null);
+                nullSubjectConnRef = new WeakReference(conn);
+            }
+        } else {
+            WeakReference<MBeanServerConnection> wr = rmbscMap.get(delegationSubject);
+            if (wr == null || (conn = wr.get()) == null) {
+                conn = new RemoteMBeanServerConnection(delegationSubject);
+                rmbscMap.put(delegationSubject, new WeakReference(conn));
+            }
+        }
+        return conn;
+    }
+
     /*
        The following section of code avoids a class loading problem
        with RMI.  The problem is that an RMI stub, when deserializing
@@ -2559,7 +2571,8 @@
 
     private transient long clientNotifSeqNo = 0;
 
-    private transient WeakHashMap<Subject, MBeanServerConnection> rmbscMap;
+    private transient WeakHashMap<Subject, WeakReference<MBeanServerConnection>> rmbscMap;
+    private transient WeakReference<MBeanServerConnection> nullSubjectConnRef = null;
 
     private transient RMINotifClient rmiNotifClient;
     // = new RMINotifClient(new Integer(0));
--- ./jdk/src/share/classes/javax/swing/plaf/basic/BasicTreeUI.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/javax/swing/plaf/basic/BasicTreeUI.java	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -42,6 +42,7 @@
 import javax.swing.tree.*;
 import javax.swing.text.Position;
 import javax.swing.plaf.basic.DragRecognitionSupport.BeforeDrag;
+import sun.awt.AWTAccessor;
 import sun.swing.SwingUtilities2;
 
 import sun.swing.DefaultLookup;
@@ -2165,11 +2166,7 @@
                                            nodeBounds.width,
                                            nodeBounds.height);
                 editingPath = path;
-                if (editingComponent instanceof JComponent) {
-                    ((JComponent)editingComponent).revalidate();
-                } else {
-                    editingComponent.validate();
-                }
+                AWTAccessor.getComponentAccessor().revalidateSynchronously(editingComponent);
                 editingComponent.repaint();
                 if(cellEditor.shouldSelectCell(event)) {
                     stopEditingInCompleteEditing = false;
--- ./jdk/src/share/classes/javax/swing/text/FlowView.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/javax/swing/text/FlowView.java	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -796,6 +796,22 @@
             v.setParent(parent);
         }
 
+        /** {@inheritDoc} */
+        @Override
+        protected void forwardUpdate(DocumentEvent.ElementChange ec,
+                                          DocumentEvent e, Shape a, ViewFactory f) {
+            calculateUpdateIndexes(e);
+            // Send update event to all views followed by the changed place.
+            lastUpdateIndex = Math.max((getViewCount() - 1), 0);
+            for (int i = firstUpdateIndex; i <= lastUpdateIndex; i++) {
+                View v = getView(i);
+                if (v != null) {
+                    Shape childAlloc = getChildAllocation(i, a);
+                    forwardUpdateToView(v, e, childAlloc, f);
+                }
+            }
+        }
+
         // The following methods don't do anything useful, they
         // simply keep the class from being abstract.
 
--- ./jdk/src/share/classes/javax/swing/text/GlyphView.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/javax/swing/text/GlyphView.java	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -514,7 +514,7 @@
             int x1 = x0 + (int) painter.getSpan(this, p0, p1, getTabExpander(), x0);
 
             // calculate y coordinate
-            int y = alloc.y + alloc.height - (int) painter.getDescent(this);
+            int y = alloc.y + (int)(painter.getHeight(this) - painter.getDescent(this));
             if (underline) {
                 int yTmp = y + 1;
                 g.drawLine(x0, yTmp, x1, yTmp);
--- ./jdk/src/share/classes/javax/swing/text/View.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/javax/swing/text/View.java	Wed May 07 19:26:47 2014 -0700
@@ -1137,32 +1137,9 @@
      */
     protected void forwardUpdate(DocumentEvent.ElementChange ec,
                                       DocumentEvent e, Shape a, ViewFactory f) {
-        Element elem = getElement();
-        int pos = e.getOffset();
-        int index0 = getViewIndex(pos, Position.Bias.Forward);
-        if (index0 == -1 && e.getType() == DocumentEvent.EventType.REMOVE &&
-            pos >= getEndOffset()) {
-            // Event beyond our offsets. We may have represented this, that is
-            // the remove may have removed one of our child Elements that
-            // represented this, so, we should foward to last element.
-            index0 = getViewCount() - 1;
-        }
-        int index1 = index0;
-        View v = (index0 >= 0) ? getView(index0) : null;
-        if (v != null) {
-            if ((v.getStartOffset() == pos) && (pos > 0)) {
-                // If v is at a boundary, forward the event to the previous
-                // view too.
-                index0 = Math.max(index0 - 1, 0);
-            }
-        }
-        if (e.getType() != DocumentEvent.EventType.REMOVE) {
-            index1 = getViewIndex(pos + e.getLength(), Position.Bias.Forward);
-            if (index1 < 0) {
-                index1 = getViewCount() - 1;
-            }
-        }
-        int hole0 = index1 + 1;
+        calculateUpdateIndexes(e);
+
+        int hole0 = lastUpdateIndex + 1;
         int hole1 = hole0;
         Element[] addedElems = (ec != null) ? ec.getChildrenAdded() : null;
         if ((addedElems != null) && (addedElems.length > 0)) {
@@ -1173,11 +1150,9 @@
         // forward to any view not in the forwarding hole
         // formed by added elements (i.e. they will be updated
         // by initialization.
-        index0 = Math.max(index0, 0);
-        index1 = Math.max((getViewCount() - 1), 0);
-        for (int i = index0; i <= index1; i++) {
+        for (int i = firstUpdateIndex; i <= lastUpdateIndex; i++) {
             if (! ((i >= hole0) && (i <= hole1))) {
-                v = getView(i);
+                View v = getView(i);
                 if (v != null) {
                     Shape childAlloc = getChildAllocation(i, a);
                     forwardUpdateToView(v, e, childAlloc, f);
@@ -1187,6 +1162,39 @@
     }
 
     /**
+     * Calculates the first and the last indexes of the child views
+     * that need to be notified of the change to the model.
+     * @param e the change information from the associated document
+     */
+    void calculateUpdateIndexes(DocumentEvent e) {
+        int pos = e.getOffset();
+        firstUpdateIndex = getViewIndex(pos, Position.Bias.Forward);
+        if (firstUpdateIndex == -1 && e.getType() == DocumentEvent.EventType.REMOVE &&
+            pos >= getEndOffset()) {
+            // Event beyond our offsets. We may have represented this, that is
+            // the remove may have removed one of our child Elements that
+            // represented this, so, we should forward to last element.
+            firstUpdateIndex = getViewCount() - 1;
+        }
+        lastUpdateIndex = firstUpdateIndex;
+        View v = (firstUpdateIndex >= 0) ? getView(firstUpdateIndex) : null;
+        if (v != null) {
+            if ((v.getStartOffset() == pos) && (pos > 0)) {
+                // If v is at a boundary, forward the event to the previous
+                // view too.
+                firstUpdateIndex = Math.max(firstUpdateIndex - 1, 0);
+            }
+        }
+        if (e.getType() != DocumentEvent.EventType.REMOVE) {
+            lastUpdateIndex = getViewIndex(pos + e.getLength(), Position.Bias.Forward);
+            if (lastUpdateIndex < 0) {
+                lastUpdateIndex = getViewCount() - 1;
+            }
+        }
+        firstUpdateIndex = Math.max(firstUpdateIndex, 0);
+    }
+
+    /**
      * Forwards the <code>DocumentEvent</code> to the give child view.  This
      * simply messages the view with a call to <code>insertUpdate</code>,
      * <code>removeUpdate</code>, or <code>changedUpdate</code> depending
@@ -1345,4 +1353,14 @@
     private View parent;
     private Element elem;
 
+    /**
+     * The index of the first child view to be notified.
+     */
+    int firstUpdateIndex;
+
+    /**
+     * The index of the last child view to be notified.
+     */
+    int lastUpdateIndex;
+
 };
--- ./jdk/src/share/classes/sun/applet/resources/MsgAppletViewer_ja.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/sun/applet/resources/MsgAppletViewer_ja.java	Wed May 07 19:26:47 2014 -0700
@@ -57,9 +57,9 @@
             {"appletviewer.appletinfo.applet", "-- \u30A2\u30D7\u30EC\u30C3\u30C8\u60C5\u5831\u306A\u3057 --"},
             {"appletviewer.appletinfo.param", "-- \u30D1\u30E9\u30E1\u30FC\u30BF\u60C5\u5831\u306A\u3057 --"},
             {"appletviewer.appletinfo.textframe", "\u30A2\u30D7\u30EC\u30C3\u30C8\u60C5\u5831"},
-            {"appletviewer.appletprint.fail", "\u5370\u5237\u306B\u5931\u6557\u3057\u307E\u3057\u305F\u3002"},
-            {"appletviewer.appletprint.finish", "\u5370\u5237\u304C\u5B8C\u4E86\u3057\u307E\u3057\u305F\u3002"},
-            {"appletviewer.appletprint.cancel", "\u5370\u5237\u304C\u4E2D\u6B62\u3055\u308C\u307E\u3057\u305F\u3002"},
+            {"appletviewer.appletprint.fail", "\u5370\u5237\u304C\u5931\u6557\u3057\u307E\u3057\u305F\u3002"},
+            {"appletviewer.appletprint.finish", "\u5370\u5237\u3092\u7D42\u4E86\u3057\u307E\u3057\u305F\u3002"},
+            {"appletviewer.appletprint.cancel", "\u5370\u5237\u304C\u53D6\u308A\u6D88\u3055\u308C\u307E\u3057\u305F\u3002"},
             {"appletviewer.appletencoding", "\u6587\u5B57\u30A8\u30F3\u30B3\u30FC\u30C7\u30A3\u30F3\u30B0: {0}"},
             {"appletviewer.parse.warning.requiresname", "\u8B66\u544A: <param name=... value=...>\u30BF\u30B0\u306Bname\u5C5E\u6027\u304C\u5FC5\u8981\u3067\u3059\u3002"},
             {"appletviewer.parse.warning.paramoutside", "\u8B66\u544A: <param>\u30BF\u30B0\u304C<applet> ... </applet>\u306E\u5916\u5074\u3067\u3059\u3002"},
@@ -98,7 +98,7 @@
             {"appletioexception.loadclass.throw.notloaded", "\u30AF\u30E9\u30B9\u304C\u30ED\u30FC\u30C9\u3055\u308C\u307E\u305B\u3093: {0}"},
             {"appletclassloader.loadcode.verbose", "{1}\u3092\u53D6\u5F97\u3059\u308B\u305F\u3081\u306E{0}\u3078\u306E\u30B9\u30C8\u30EA\u30FC\u30E0\u3092\u958B\u304D\u307E\u3059"},
             {"appletclassloader.filenotfound", "{0}\u306E\u691C\u7D22\u4E2D\u306B\u30D5\u30A1\u30A4\u30EB\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093"},
-            {"appletclassloader.fileformat", "{0}\u306E\u30ED\u30FC\u30C9\u4E2D\u306B\u30D5\u30A1\u30A4\u30EB\u30FB\u30D5\u30A9\u30FC\u30DE\u30C3\u30C8\u4F8B\u5916\u304C\u767A\u751F\u3057\u307E\u3057\u305F"},
+            {"appletclassloader.fileformat", "{0}\u306E\u30ED\u30FC\u30C9\u4E2D\u306B\u30D5\u30A1\u30A4\u30EB\u5F62\u5F0F\u4F8B\u5916\u304C\u767A\u751F\u3057\u307E\u3057\u305F"},
             {"appletclassloader.fileioexception", "{0}\u306E\u30ED\u30FC\u30C9\u4E2D\u306B\u5165\u51FA\u529B\u4F8B\u5916\u304C\u767A\u751F\u3057\u307E\u3057\u305F"},
             {"appletclassloader.fileexception", "{1}\u306E\u30ED\u30FC\u30C9\u4E2D\u306B{0}\u4F8B\u5916\u304C\u767A\u751F\u3057\u307E\u3057\u305F"},
             {"appletclassloader.filedeath", "{1}\u306E\u30ED\u30FC\u30C9\u4E2D\u306B{0}\u304C\u5F37\u5236\u7D42\u4E86\u3057\u307E\u3057\u305F"},
@@ -132,7 +132,7 @@
             {"appletpanel.notdisposed", "\u30ED\u30FC\u30C9: \u30A2\u30D7\u30EC\u30C3\u30C8\u304C\u7834\u68C4\u3055\u308C\u3066\u3044\u307E\u305B\u3093\u3002"},
             {"appletpanel.bail", "\u4E2D\u65AD\u6E08: \u7D42\u4E86\u3057\u3066\u3044\u307E\u3059\u3002"},
             {"appletpanel.filenotfound", "{0}\u306E\u691C\u7D22\u4E2D\u306B\u30D5\u30A1\u30A4\u30EB\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093"},
-            {"appletpanel.fileformat", "{0}\u306E\u30ED\u30FC\u30C9\u4E2D\u306B\u30D5\u30A1\u30A4\u30EB\u30FB\u30D5\u30A9\u30FC\u30DE\u30C3\u30C8\u4F8B\u5916\u304C\u767A\u751F\u3057\u307E\u3057\u305F"},
+            {"appletpanel.fileformat", "{0}\u306E\u30ED\u30FC\u30C9\u4E2D\u306B\u30D5\u30A1\u30A4\u30EB\u5F62\u5F0F\u4F8B\u5916\u304C\u767A\u751F\u3057\u307E\u3057\u305F"},
             {"appletpanel.fileioexception", "{0}\u306E\u30ED\u30FC\u30C9\u4E2D\u306B\u5165\u51FA\u529B\u4F8B\u5916\u304C\u767A\u751F\u3057\u307E\u3057\u305F"},
             {"appletpanel.fileexception", "{1}\u306E\u30ED\u30FC\u30C9\u4E2D\u306B{0}\u4F8B\u5916\u304C\u767A\u751F\u3057\u307E\u3057\u305F"},
             {"appletpanel.filedeath", "{1}\u306E\u30ED\u30FC\u30C9\u4E2D\u306B{0}\u304C\u5F37\u5236\u7D42\u4E86\u3057\u307E\u3057\u305F"},
--- ./jdk/src/share/classes/sun/applet/resources/MsgAppletViewer_pt_BR.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/sun/applet/resources/MsgAppletViewer_pt_BR.java	Wed May 07 19:26:47 2014 -0700
@@ -93,7 +93,7 @@
             {"appletviewer.main.nosecmgr", "Advert\u00EAncia: SecurityManager n\u00E3o instalado!"},
             {"appletviewer.main.warning", "Advert\u00EAncia: Nenhum applet iniciado. Certifique-se de que a entrada contenha uma tag <applet>."},
             {"appletviewer.main.warn.prop.overwrite", "Advert\u00EAncia: Substituindo a propriedade do sistema temporariamente a pedido do usu\u00E1rio: chave: {0} valor antigo: {1} valor novo: {2}"},
-            {"appletviewer.main.warn.cantreadprops", "Advert\u00EAncia: N\u00E3o \u00E9 poss\u00EDvel ler o arquivo de propriedades AppletViewer: {0} Usando defaults."},
+            {"appletviewer.main.warn.cantreadprops", "Advert\u00EAncia: N\u00E3o \u00E9 poss\u00EDvel ler o arquivo de propriedades AppletViewer: {0} Usando padr\u00F5es."},
             {"appletioexception.loadclass.throw.interrupted", "carregamento de classe interrompido: {0}"},
             {"appletioexception.loadclass.throw.notloaded", "classe n\u00E3o carregada: {0}"},
             {"appletclassloader.loadcode.verbose", "Fluxo de abertura para: {0} para obter {1}"},
--- ./jdk/src/share/classes/sun/applet/resources/MsgAppletViewer_sv.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/sun/applet/resources/MsgAppletViewer_sv.java	Wed May 07 19:26:47 2014 -0700
@@ -85,7 +85,7 @@
             {"appletviewer.main.prop.store", "Anv\u00E4ndarspecifika egenskaper f\u00F6r AppletViewer"},
             {"appletviewer.main.err.prop.cantread", "Kan inte l\u00E4sa egenskapsfilen: {0}"},
             {"appletviewer.main.err.prop.cantsave", "Kan inte spara egenskapsfilen: {0}"},
-            {"appletviewer.main.warn.nosecmgr", "Varning: s\u00E4kerheten inaktiveras."},
+            {"appletviewer.main.warn.nosecmgr", "Varning! S\u00E4kerheten avaktiveras."},
             {"appletviewer.main.debug.cantfinddebug", "Hittar inte fels\u00F6kningsprogrammet!"},
             {"appletviewer.main.debug.cantfindmain", "Hittar inte huvudmetoden i fels\u00F6kningsprogrammet!"},
             {"appletviewer.main.debug.exceptionindebug", "Undantag i fels\u00F6kningsprogrammet!"},
--- ./jdk/src/share/classes/sun/awt/AWTAccessor.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/sun/awt/AWTAccessor.java	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -40,6 +40,7 @@
 import java.security.AccessControlContext;
 
 import java.io.File;
+import java.util.ResourceBundle;
 import java.util.Vector;
 
 /**
@@ -237,6 +238,11 @@
          */
         AccessControlContext getAccessControlContext(Component comp);
 
+        /**
+        * Revalidates the component synchronously.
+        */
+        void revalidateSynchronously(Component comp);
+
     }
 
     /*
@@ -691,6 +697,13 @@
     }
 
     /*
+     *An accessor for the toolkit class
+     */
+    public interface ToolkitAccessor {
+        void setPlatformResources(ResourceBundle bundle);
+    }
+
+    /*
      * An accessor object for the InvocationEvent class
      */
     public interface InvocationEventAccessor {
@@ -737,6 +750,7 @@
     private static DefaultKeyboardFocusManagerAccessor defaultKeyboardFocusManagerAccessor;
     private static SequencedEventAccessor sequencedEventAccessor;
     private static InvocationEventAccessor invocationEventAccessor;
+    private static ToolkitAccessor toolkitAccessor;
 
     /*
      * Set an accessor object for the java.awt.Component class.
@@ -1133,6 +1147,24 @@
     }
 
     /*
+     * Set an accessor object for the java.awt.Toolkit class.
+     */
+    public static void setToolkitAccessor(ToolkitAccessor ta) {
+        toolkitAccessor = ta;
+    }
+
+    /*
+     * Get the accessor object for the java.awt.Toolkit class.
+     */
+    public static ToolkitAccessor getToolkitAccessor() {
+        if (toolkitAccessor == null) {
+            unsafe.ensureClassInitialized(Toolkit.class);
+        }
+
+        return toolkitAccessor;
+    }
+
+    /*
      * Get the accessor object for the java.awt.event.InvocationEvent class.
      */
     public static void setInvocationEventAccessor(InvocationEventAccessor invocationEventAccessor) {
--- ./jdk/src/share/classes/sun/awt/datatransfer/ClipboardTransferable.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/sun/awt/datatransfer/ClipboardTransferable.java	Wed May 07 19:26:47 2014 -0700
@@ -98,8 +98,7 @@
                 }
 
                 flavors = DataTransferer.getInstance().
-                    setToSortedDataFlavorArray(flavorsToData.keySet(),
-                                               flavorsForFormats);
+                    setToSortedDataFlavorArray(flavorsToData.keySet());
             }
         } finally {
             clipboard.closeClipboard();
--- ./jdk/src/share/classes/sun/awt/datatransfer/DataTransferer.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/sun/awt/datatransfer/DataTransferer.java	Wed May 07 19:26:47 2014 -0700
@@ -2406,15 +2406,6 @@
     }
 
     /**
-     * Helper function to reduce a Map with DataFlavor keys to a DataFlavor
-     * array. The array will be sorted according to
-     * <code>DataFlavorComparator</code>.
-     */
-    public static DataFlavor[] keysToDataFlavorArray(Map map) {
-        return setToSortedDataFlavorArray(map.keySet(), map);
-    }
-
-    /**
      * Helper function to convert a Set of DataFlavors to a sorted array.
      * The array will be sorted according to <code>DataFlavorComparator</code>.
      */
@@ -2428,24 +2419,6 @@
     }
 
     /**
-     * Helper function to convert a Set of DataFlavors to a sorted array.
-     * The array will be sorted according to a
-     * <code>DataFlavorComparator</code> created with the specified
-     * flavor-to-native map as an argument.
-     */
-    public static DataFlavor[] setToSortedDataFlavorArray
-        (Set flavorsSet, Map flavorToNativeMap)
-    {
-        DataFlavor[] flavors = new DataFlavor[flavorsSet.size()];
-        flavorsSet.toArray(flavors);
-        Comparator comparator =
-            new DataFlavorComparator(flavorToNativeMap,
-                                     IndexedComparator.SELECT_WORST);
-        Arrays.sort(flavors, comparator);
-        return flavors;
-    }
-
-    /**
      * Helper function to convert an InputStream to a byte[] array.
      */
     protected static byte[] inputStreamToByteArray(InputStream str)
@@ -2723,11 +2696,9 @@
      * application/x-java-* MIME types. Unknown application types are preferred
      * because if the user provides his own data flavor, it will likely be the
      * most descriptive one. For flavors which are otherwise equal, the
-     * flavors' native formats are compared, with greater long values
-     * taking precedence.
+     * flavors' string representation are compared in the alphabetical order.
      */
     public static class DataFlavorComparator extends IndexedComparator {
-        protected final Map flavorToFormatMap;
 
         private final CharsetComparator charsetComparator;
 
@@ -2863,20 +2834,6 @@
             super(order);
 
             charsetComparator = new CharsetComparator(order);
-            flavorToFormatMap = Collections.EMPTY_MAP;
-        }
-
-        public DataFlavorComparator(Map map) {
-            this(map, SELECT_BEST);
-        }
-
-        public DataFlavorComparator(Map map, boolean order) {
-            super(order);
-
-            charsetComparator = new CharsetComparator(order);
-            HashMap hashMap = new HashMap(map.size());
-            hashMap.putAll(map);
-            flavorToFormatMap = Collections.unmodifiableMap(hashMap);
         }
 
         public int compare(Object obj1, Object obj2) {
@@ -2972,10 +2929,9 @@
                 }
             }
 
-            // As a last resort, take the DataFlavor with the greater integer
-            // format.
-            return compareLongs(flavorToFormatMap, flavor1, flavor2,
-                                UNKNOWN_OBJECT_LOSES_L);
+            // The flavours are not equal but still not distinguishable.
+            // Compare String representations in alphabetical order
+            return flavor1.getMimeType().compareTo(flavor2.getMimeType());
         }
     }
 
--- ./jdk/src/share/classes/sun/awt/resources/awt_pt_BR.properties	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/sun/awt/resources/awt_pt_BR.properties	Wed May 07 19:26:47 2014 -0700
@@ -151,7 +151,7 @@
 AWT.undefined=Indefinido
 
 # Predefined cursor names
-AWT.DefaultCursor=Cursor Default
+AWT.DefaultCursor=Cursor Padr\u00E3o
 AWT.CrosshairCursor=Cursor em Forma de Cruz
 AWT.TextCursor=Cursor de Texto
 AWT.WaitCursor=Cursor em Forma de Ampulheta
@@ -165,9 +165,9 @@
 AWT.EResizeCursor=Cursor de Seta Que Aponta \u00E0 Direita
 AWT.HandCursor=Cursor em Forma de M\u00E3o
 AWT.MoveCursor=Cursor de Movimento
-AWT.DefaultDragCursor=Cursor Default de Arrastar
-AWT.DefaultNoDropCursor=Cursor Default sem Arrastar
-AWT.DefaultDropCursor=Cursor Default de Soltar
+AWT.DefaultDragCursor=Cursor Padr\u00E3o de Arrastar
+AWT.DefaultNoDropCursor=Cursor Padr\u00E3o sem Arrastar
+AWT.DefaultDropCursor=Cursor Padr\u00E3o de Soltar
 
 # Input method related strings
 AWT.CompositionWindowTitle=Janela de Entrada
--- ./jdk/src/share/classes/sun/launcher/resources/launcher_de.properties	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/sun/launcher/resources/launcher_de.properties	Wed May 07 19:26:47 2014 -0700
@@ -37,7 +37,7 @@
 java.launcher.opt.footer     =\    -cp <Klassensuchpfad von Verzeichnissen und ZIP-/JAR-Dateien>\n    -classpath <Klassensuchpfad von Verzeichnissen und ZIP-/JAR-Dateien>\n                  Eine durch {0} getrennte Liste mit Verzeichnissen, JAR-Archiven\n                  und ZIP-Archiven zur Suche nach Klassendateien.\n    -D<name>=<value>\n                  Legt eine Systemeigenschaft fest\n    -verbose:[class|gc|jni]\n                  Aktiviert die Verbose-Ausgabe\n    -version      Druckt Produktversion und beendet das Programm\n    -version:<value>\n                  Erfordert die angegebene Version zur Ausf\u00FChrung\n    -showversion  Druckt Produktversion und f\u00E4hrt fort\n    -jre-restrict-search | -no-jre-restrict-search\n                  Bezieht private JREs des Benutzers in Versionssuche ein bzw. schlie\u00DFt sie aus\n    -? -help      Druckt diese Hilfemeldung\n    -X            Druckt Hilfe zu Nicht-Standardoptionen\n    -ea[:<packagename>...|:<classname>]\n    -enableassertions[:<packagename>...|:<classname>]\n                  Aktiviert Assertionen mit angegebener Granularit\u00E4t\n    -da[:<packagename>...|:<classname>]\n    -disableassertions[:<packagename>...|:<classname>]\n                  Deaktiviert Assertionen mit angegebener Granularit\u00E4t\n    -esa | -enablesystemassertions\n                  Aktiviert Systemassertionen\n    -dsa | -disablesystemassertions\n                  Deaktiviert Systemassertionen\n    -agentlib:<libname>[=<options>]\n                  L\u00E4dt native Agent Library <libname>, z.B. -agentlib:hprof\n                  siehe auch -agentlib:jdwp=help und -agentlib:hprof=help\n    -agentpath:<pathname>[=<options>]\n                  L\u00E4dt native Agent Library nach vollem Pfadnamen\n    -javaagent:<jarpath>[=<options>]\n                  L\u00E4dt Java-Programmiersprachen-Agent, siehe java.lang.instrument\n    -splash:<imagepath>\n                  Zeigt Startbildschirm mit angegebenem Bild\nWeitere Einzelheiten finden Sie unter http://www.oracle.com/technetwork/java/javase/documentation/index.html
 
 # Translators please note do not translate the options themselves
-java.launcher.X.usage=\    -Xmixed           Ausf\u00FChrung im gemischten Modus (Standard)\n    -Xint             Nur Ausf\u00FChrung im interpretierten Modus\n    -Xbootclasspath:<Verzeichnisse und ZIP-/JAR-Dateien durch {0} getrennt>\n                      Legt Suchpfad f\u00FCr Bootstrap-Klassen und Ressourcen fest\n    -Xbootclasspath/a:<Verzeichnisse und ZIP-/JAR-Dateien durch {0} getrennt>\n                      H\u00E4ngt an das Ende des Bootstrap Classpath an\n    -Xbootclasspath/p:<Verzeichnisse und ZIP-/JAR-Dateien durch {0} getrennt>\n                      Stellt Bootstrap Classpath voran\n    -Xdiag            Zeigt zus\u00E4tzliche Diagnosemeldungen an\n    -Xnoclassgc       Deaktiviert Klassen-Garbage Collection\n    -Xincgc           Aktiviert inkrementelle Garbage Collection\n    -Xloggc:<file>    Loggt GC-Status in einer Datei mit Zeitstempeln\n    -Xbatch           Deaktiviert Hintergrundkompilierung\n    -Xms<size>        Legt anf\u00E4ngliche Java Heap-Gr\u00F6\u00DFe fest\n    -Xmx<size>        Legt maximale Java Heap-Gr\u00F6\u00DFe fest\n    -Xss<size>        Legt Java-Thread-Stackgr\u00F6\u00DFe fest\n    -Xprof            Gibt CPU-Profiling-Daten aus\n    -Xfuture          Aktiviert strengste Pr\u00FCfungen, antizipiert zuk\u00FCnftigen Standardwert\n    -Xrs              Reduziert Verwendung von BS-Signalen durch Java/VM (siehe Dokumentation)\n    -Xcheck:jni       F\u00FChrt zus\u00E4tzliche Pr\u00FCfungen f\u00FCr JNI-Funktionen durch\n    -Xshare:off       Kein Versuch, gemeinsame Klassendaten zu verwenden\n    -Xshare:auto      Verwendet gemeinsame Klassendaten, wenn m\u00F6glich (Standard)\n    -Xshare:on        Erfordert die Verwendung gemeinsamer Klassendaten, sonst verl\u00E4uft der Vorgang nicht erfolgreich.\n    -XshowSettings    Zeigt alle Einstellungen und f\u00E4hrt fort\n    -XshowSettings:all\n                      Zeigt alle Einstellungen und f\u00E4hrt fort\n    -XshowSettings:vm Zeigt alle VM-bezogenen Einstellungen und f\u00E4hrt fort\n    -XshowSettings:properties\n                      Zeigt alle Eigenschaftseinstellungen und f\u00E4hrt fort\n    -XshowSettings:locale\n                      Zeigt alle gebietsschemabezogenen Einstellungen und f\u00E4hrt fort\n\nDie -X-Optionen sind keine Standardoptionen und k\u00F6nnen ohne Vorank\u00FCndigung ge\u00E4ndert werden.\n
+java.launcher.X.usage=\    -Xmixed           Ausf\u00FChrung im gemischten Modus (Standard)\n    -Xint             Nur Ausf\u00FChrung im interpretierten Modus\n    -Xbootclasspath:<Verzeichnisse und ZIP-/JAR-Dateien durch {0} getrennt>\n                      Legt Suchpfad f\u00FCr Bootstrap-Klassen und Ressourcen fest\n    -Xbootclasspath/a:<Verzeichnisse und ZIP-/JAR-Dateien durch {0} getrennt>\n                      H\u00E4ngt an das Ende des Bootstrap Classpath an\n    -Xbootclasspath/p:<Verzeichnisse und ZIP-/JAR-Dateien durch {0} getrennt>\n                      Stellt Bootstrap Classpath voran\n    -Xdiag            Zeigt zus\u00E4tzliche Diagnosemeldungen an\n    -Xnoclassgc       Deaktiviert Klassen-Garbage Collection\n    -Xincgc           Aktiviert inkrementelle Garbage Collection\n    -Xloggc:<file>    Loggt GC-Status in einer Datei mit Zeitstempeln\n    -Xbatch           Deaktiviert Hintergrundkompilierung\n    -Xms<size>        Legt anf\u00E4ngliche Java Heap-Gr\u00F6\u00DFe fest\n    -Xmx<size>        Legt maximale Java Heap-Gr\u00F6\u00DFe fest\n    -Xss<size>        Legt Java-Threadstackgr\u00F6\u00DFe fest\n    -Xprof            Gibt CPU-Profiling-Daten aus\n    -Xfuture          Aktiviert strengste Pr\u00FCfungen, antizipiert zuk\u00FCnftigen Standardwert\n    -Xrs              Reduziert Verwendung von BS-Signalen durch Java/VM (siehe Dokumentation)\n    -Xcheck:jni       F\u00FChrt zus\u00E4tzliche Pr\u00FCfungen f\u00FCr JNI-Funktionen durch\n    -Xshare:off       Kein Versuch, gemeinsame Klassendaten zu verwenden\n    -Xshare:auto      Verwendet gemeinsame Klassendaten, wenn m\u00F6glich (Standard)\n    -Xshare:on        Erfordert die Verwendung gemeinsamer Klassendaten, sonst verl\u00E4uft der Vorgang nicht erfolgreich.\n    -XshowSettings    Zeigt alle Einstellungen und f\u00E4hrt fort\n    -XshowSettings:all\n                      Zeigt alle Einstellungen und f\u00E4hrt fort\n    -XshowSettings:vm Zeigt alle VM-bezogenen Einstellungen und f\u00E4hrt fort\n    -XshowSettings:properties\n                      Zeigt alle Eigenschaftseinstellungen und f\u00E4hrt fort\n    -XshowSettings:locale\n                      Zeigt alle gebietsschemabezogenen Einstellungen und f\u00E4hrt fort\n\nDie -X-Optionen sind keine Standardoptionen und k\u00F6nnen ohne Vorank\u00FCndigung ge\u00E4ndert werden.\n
 
 # Translators please note do not translate the options themselves
 java.launcher.X.macosx.usage=\nDie folgenden Optionen sind f\u00FCr Mac OS X spezifisch:\n    -XstartOnFirstThread\n                      f\u00FChrt die main()-Methode f\u00FCr den ersten (AppKit) Thread aus\n    -Xdock:name=<Anwendungsname>"\n                      \u00DCberschreibt den in der Uhr angezeigten Standardanwendungsnamen\n    -Xdock:icon=<Pfad zu Symboldatei>\n                      \u00DCberschreibt das in der Uhr angezeigte Standardsymbol\n\n
--- ./jdk/src/share/classes/sun/launcher/resources/launcher_pt_BR.properties	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/sun/launcher/resources/launcher_pt_BR.properties	Wed May 07 19:26:47 2014 -0700
@@ -30,17 +30,17 @@
 java.launcher.opt.vmselect   =\    {0}\t  para selecionar a VM "{1}"\n
 java.launcher.opt.hotspot    =\    {0}\t  \u00E9 um sin\u00F4nimo da VM "{1}" [obsoleto]\n
 
-java.launcher.ergo.message1  =\                  A VM default \u00E9 {0}
+java.launcher.ergo.message1  =\                  A VM padr\u00E3o \u00E9 {0}
 java.launcher.ergo.message2  =\                  porque a execu\u00E7\u00E3o est\u00E1 sendo feita em uma m\u00E1quina de classe de servidor.\n
 
 # Translators please note do not translate the options themselves
 java.launcher.opt.footer     =\    -cp <caminho de pesquisa da classe dos diret\u00F3rios e arquivos zip/jar>\n    -classpath <caminho de pesquisa da classe dos diret\u00F3rios e arquivos zip/jar>\n                  Uma lista separada por {0} de diret\u00F3rios, archives JAR\n                  e archives ZIP nos quais ser\u00E3o procurados os arquivos de classe.\n    -D<nome>=<valor>\n                  define uma propriedade do sistema\n    -verbose:[class|gc|jni]\n                  ativa a sa\u00EDda detalhada\n    -version      imprime a vers\u00E3o do produto e sai do programa\n    -version:<valor>\n                  requer a execu\u00E7\u00E3o da vers\u00E3o especificada\n    -showversion  imprime a vers\u00E3o do produto e continua\n    -jre-restrict-search | -no-jre-restrict-search\n                  inclui/exclui JREs privados do usu\u00E1rio na pesquisa de vers\u00E3o\n    -? -help      imprime esta mensagem de ajuda\n    -X            imprime a ajuda sobre op\u00E7\u00F5es n\u00E3o padronizadas\n    -ea[:<nome do pacote>...|:<nome da classe>]\n    -enableassertions[:<nome do pacote>...|:<nome da classe>]\n                  ativa asser\u00E7\u00F5es com granularidade especificada\n    -da[:<nome do pacote>...|:<nome da classe>]\n    -disableassertions[:<nome do pacote>...|:<nome da classe>]\n                  desativa asser\u00E7\u00F5es com granularidade especificada\n    -esa | -enablesystemassertions\n                  ativa asser\u00E7\u00F5es do sistema\n    -dsa | -disablesystemassertions\n                  desativa asser\u00E7\u00F5es do sistema\n    -agentlib:<nome da biblioteca>[=<op\u00E7\u00F5es>]\n                  carrega a biblioteca de agentes nativa <nome da biblioteca>, por exemplo: -agentlib:hprof\n                  consulte tamb\u00E9m: -agentlib:jdwp=help e -agentlib:hprof=help\n    -agentpath:<nome do caminho>[=<op\u00E7\u00F5es>]\n                  carrega a biblioteca de agentes nativa com base no nome do caminho completo\n    -javaagent:<caminho do arquivo jar>[=<op\u00E7\u00F5es>]\n                  carrega o agente da linguagem de programa\u00E7\u00E3o Java; consulte java.lang.instrument\n    -splash:<caminho da imagem>\n                  mostra a tela de abertura com a imagem especificada\nConsulte http://www.oracle.com/technetwork/java/javase/documentation/index.html para obter mais detalhes.
 
 # Translators please note do not translate the options themselves
-java.launcher.X.usage=\    -Xmixed           execu\u00E7\u00E3o no modo misto (default)\n    -Xint             execu\u00E7\u00E3o somente no modo interpretado\n    -Xbootclasspath:<diret\u00F3rios e arquivos zip/jar separados por {0}>\n                      define o caminho de pesquisa para classes e recursos de inicializa\u00E7\u00E3o\n    -Xbootclasspath/a:<diret\u00F3rios e arquivos zip/jar separados por {0}>\n                      anexa no final do caminho da classe de inicializa\u00E7\u00E3o\n    -Xbootclasspath/p:<diret\u00F3rios e arquivos zip/jar separados por {0}>\n                      anexa no in\u00EDcio do caminho da classe de inicializa\u00E7\u00E3o\n    -Xdiag            mostra mensagens de diagn\u00F3stico adicionais\n    -Xnoclassgc       desativa a coleta de lixo da classe\n    -Xincgc           ativa a coleta de lixo incremental\n    -Xloggc:<arquivo>    registra o status do GC status em um arquivo com marca\u00E7\u00F5es de data e hor\u00E1rio\n    -Xbatch           desativa a compila\u00E7\u00E3o em segundo plano\n    -Xms<tamanho>        define o tamanho inicial do heap Java\n    -Xmx<tamanho>        define o tamanho m\u00E1ximo do heap Java\n    -Xss<tamanho>        define o tamanho da pilha de threads java\n    -Xprof            produz dados de perfil da cpu\n    -Xfuture          ativa verifica\u00E7\u00F5es de n\u00EDvel m\u00E1ximo de exig\u00EAncia, prevendo o valor default futuro\n    -Xrs              reduz o uso de sinais do SO pelo(a) Java/VM (consulte a documenta\u00E7\u00E3o)\n    -Xcheck:jni       executa verifica\u00E7\u00F5es adicionais de fun\u00E7\u00F5es da JNI\n    -Xshare:off       n\u00E3o tenta usar dados da classe compartilhada\n    -Xshare:auto      se poss\u00EDvel, usa dados da classe compartilhada (default)\n    -Xshare:on        requer o uso de dados da classe compartilhada, caso contr\u00E1rio haver\u00E1 falha.\n    -XshowSettings    mostra todas as defini\u00E7\u00F5es e continua\n    -XshowSettings:all\n                      mostra todas as defini\u00E7\u00F5es e continua\n    -XshowSettings:vm mostra todas as defini\u00E7\u00F5es relacionadas \u00E0 vm e continua\n    -XshowSettings:properties\n                      mostra todas as defini\u00E7\u00F5es da propriedade e continua\n    -XshowSettings:locale\n                      mostra todas as defini\u00E7\u00F5es relativas \u00E0s configura\u00E7\u00F5es regionais e continua\n\nAs -X options n\u00E3o s\u00E3o padronizadas e est\u00E3o sujeitas a altera\u00E7\u00F5es sem aviso.\n
+java.launcher.X.usage=\    -Xmixed           execu\u00E7\u00E3o no modo misto (padr\u00E3o)\n    -Xint             execu\u00E7\u00E3o somente no modo interpretado\n    -Xbootclasspath:<diret\u00F3rios e arquivos zip/jar separados por {0}>\n                      define o caminho de pesquisa para classes e recursos de inicializa\u00E7\u00E3o\n    -Xbootclasspath/a:<diret\u00F3rios e arquivos zip/jar separados por {0}>\n                      anexa no final do caminho da classe de inicializa\u00E7\u00E3o\n    -Xbootclasspath/p:<diret\u00F3rios e arquivos zip/jar separados por {0}>\n                      anexa no in\u00EDcio do caminho da classe de inicializa\u00E7\u00E3o\n    -Xdiag            mostra mensagens de diagn\u00F3stico adicionais\n    -Xnoclassgc       desativa a coleta de lixo da classe\n    -Xincgc           ativa a coleta de lixo incremental\n    -Xloggc:<arquivo>    registra o status do GC status em um arquivo com marca\u00E7\u00F5es de data e hor\u00E1rio\n    -Xbatch           desativa a compila\u00E7\u00E3o em segundo plano\n    -Xms<tamanho>        define o tamanho inicial do heap Java\n    -Xmx<tamanho>        define o tamanho m\u00E1ximo do heap Java\n    -Xss<tamanho>        define o tamanho da pilha de threads java\n    -Xprof            produz dados de perfil da cpu\n    -Xfuture          ativa verifica\u00E7\u00F5es de n\u00EDvel m\u00E1ximo de exig\u00EAncia, prevendo o valor padr\u00E3o futuro\n    -Xrs              reduz o uso de sinais do SO pelo(a) Java/VM (consulte a documenta\u00E7\u00E3o)\n    -Xcheck:jni       executa verifica\u00E7\u00F5es adicionais de fun\u00E7\u00F5es da JNI\n    -Xshare:off       n\u00E3o tenta usar dados da classe compartilhada\n    -Xshare:auto      se poss\u00EDvel, usa dados da classe compartilhada (padr\u00E3o)\n    -Xshare:on        requer o uso de dados da classe compartilhada, caso contr\u00E1rio haver\u00E1 falha.\n    -XshowSettings    mostra todas as defini\u00E7\u00F5es e continua\n    -XshowSettings:all\n                      mostra todas as defini\u00E7\u00F5es e continua\n    -XshowSettings:vm mostra todas as defini\u00E7\u00F5es relacionadas \u00E0 vm e continua\n    -XshowSettings:properties\n                      mostra todas as defini\u00E7\u00F5es da propriedade e continua\n    -XshowSettings:locale\n                      mostra todas as defini\u00E7\u00F5es relativas \u00E0s configura\u00E7\u00F5es regionais e continua\n\nAs -X options n\u00E3o s\u00E3o padronizadas e est\u00E3o sujeitas a altera\u00E7\u00F5es sem aviso.\n
 
 # Translators please note do not translate the options themselves
-java.launcher.X.macosx.usage=\nAs op\u00E7\u00F5es a seguir s\u00E3o espec\u00EDficas para o Mac OS X:\n    -XstartOnFirstThread\n                      executa o m\u00E9todo main() no primeiro thread (AppKit)\n    -Xdock:name=<nome da aplica\u00E7\u00E3o>"\n                      substitui o nome da aplica\u00E7\u00E3o default exibido no encaixe\n    -Xdock:icon=<caminho para o arquivo do \u00EDcone>\n                      substitui o \u00EDcone exibido no encaixe\n\n
+java.launcher.X.macosx.usage=\nAs op\u00E7\u00F5es a seguir s\u00E3o espec\u00EDficas para o Mac OS X:\n    -XstartOnFirstThread\n                      executa o m\u00E9todo main() no primeiro thread (AppKit)\n    -Xdock:name=<nome da aplica\u00E7\u00E3o>"\n                      substitui o nome da aplica\u00E7\u00E3o padr\u00E3o exibido no encaixe\n    -Xdock:icon=<caminho para o arquivo do \u00EDcone>\n                      substitui o \u00EDcone exibido no encaixe\n\n
 
 java.launcher.cls.error1=Erro: N\u00E3o foi poss\u00EDvel localizar nem carregar a classe principal {0}
 java.launcher.cls.error2=Erro: o m\u00E9todo main n\u00E3o \u00E9 {0} na classe {1}; defina o m\u00E9todo main como:\n   public static void main(String[] args)
--- ./jdk/src/share/classes/sun/management/resources/agent_ja.properties	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/sun/management/resources/agent_ja.properties	Wed May 07 19:26:47 2014 -0700
@@ -36,7 +36,7 @@
 agent.err.configfile.closed.failed = \u69CB\u6210\u30D5\u30A1\u30A4\u30EB\u3092\u9589\u3058\u308B\u3053\u3068\u304C\u3067\u304D\u307E\u305B\u3093\u3067\u3057\u305F
 agent.err.configfile.access.denied = \u69CB\u6210\u30D5\u30A1\u30A4\u30EB\u3078\u306E\u30A2\u30AF\u30BB\u30B9\u304C\u62D2\u5426\u3055\u308C\u307E\u3057\u305F
 
-agent.err.exportaddress.failed	   = JMX\u30B3\u30CD\u30AF\u30BF\u30FB\u30A2\u30C9\u30EC\u30B9\u306E\u8A08\u6E2C\u30D0\u30C3\u30D5\u30A1\u3078\u306E\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\u306B\u5931\u6557\u3057\u307E\u3057\u305F
+agent.err.exportaddress.failed	   = JMX\u30B3\u30CD\u30AF\u30BF\u30FB\u30A2\u30C9\u30EC\u30B9\u306E\u8A08\u6E2C\u30D0\u30C3\u30D5\u30A1\u3078\u306E\u30A8\u30AF\u30B9\u30DD\u30FC\u30C8\u304C\u5931\u6557\u3057\u307E\u3057\u305F
 
 agent.err.agentclass.notfound      = \u7BA1\u7406\u30A8\u30FC\u30B8\u30A7\u30F3\u30C8\u30FB\u30AF\u30E9\u30B9\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093
 agent.err.agentclass.failed        = \u7BA1\u7406\u30A8\u30FC\u30B8\u30A7\u30F3\u30C8\u30FB\u30AF\u30E9\u30B9\u304C\u5931\u6557\u3057\u307E\u3057\u305F 
--- ./jdk/src/share/classes/sun/misc/FloatingDecimal.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/sun/misc/FloatingDecimal.java	Wed May 07 19:26:47 2014 -0700
@@ -70,6 +70,15 @@
     static final int    minDecimalExponent = -324;
     static final int    bigDecimalExponent = 324; // i.e. abs(minDecimalExponent)
 
+    //
+    // The value below is chosen as a conservative threshold. It
+    // can be demonstrated that a decimal ulp less than 10^(-1075)
+    // is enough to guarantee correctness. Compensation is also made
+    // for the binary mantissa which takes 53 binary digits, or
+    // 17 decimal ones. Hence 1075 + 17 =~ 1100.
+    //
+    static final int    MAX_NDIGITS = 1100;
+
     static final long   highbyte = 0xff00000000000000L;
     static final long   highbit  = 0x8000000000000000L;
     static final long   lowbytes = ~highbyte;
@@ -1468,6 +1477,10 @@
              * Formulate the EXACT big-number result as
              * bigD0 * 10^exp
              */
+            if (nDigits > MAX_NDIGITS) {
+                nDigits = MAX_NDIGITS + 1;
+                digits[MAX_NDIGITS] = '1';
+            }
             FDBigInt bigD0 = new FDBigInt( lValue, digits, kDigits, nDigits );
             exp   = decExponent - nDigits;
 
--- ./jdk/src/share/classes/sun/misc/JavaLangAccess.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/sun/misc/JavaLangAccess.java	Wed May 07 19:26:47 2014 -0700
@@ -95,4 +95,9 @@
      * inherited AccessControlContext.
      */
     Thread newThreadWithAcc(Runnable target, AccessControlContext acc);
+
+    /**
+     * Invokes the finalize method of the given object.
+     */
+    void invokeFinalize(Object o) throws Throwable;
 }
--- ./jdk/src/share/classes/sun/misc/VM.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/sun/misc/VM.java	Wed May 07 19:26:47 2014 -0700
@@ -147,6 +147,7 @@
 
 
     private static volatile boolean booted = false;
+    private static final Object lock = new Object();
 
     // Invoked by by System.initializeSystemClass just before returning.
     // Subsystems that are invoked during initialization can check this
@@ -154,13 +155,27 @@
     // application class loader has been set up.
     //
     public static void booted() {
-        booted = true;
+        synchronized (lock) {
+            booted = true;
+            lock.notifyAll();
+        }
     }
 
     public static boolean isBooted() {
         return booted;
     }
 
+    // Waits until VM completes initialization
+    //
+    // This method is invoked by the Finalizer thread
+    public static void awaitBooted() throws InterruptedException {
+        synchronized (lock) {
+            while (!booted) {
+                lock.wait();
+            }
+        }
+    }
+
     // A user-settable upper limit on the maximum amount of allocatable direct
     // buffer memory.  This value may be changed during VM initialization if
     // "java" is launched with "-XX:MaxDirectMemorySize=<size>".
--- ./jdk/src/share/classes/sun/nio/cs/ext/META-INF/services/java.nio.charset.spi.CharsetProvider	Tue Mar 18 12:35:25 2014 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,2 +0,0 @@
-# NIO charset SPI extended charset provider
-sun.nio.cs.ext.ExtendedCharsets
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/src/share/classes/sun/print/DocumentPropertiesUI.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,62 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package sun.print;
+
+import java.awt.Window;
+import java.awt.print.PrinterJob;
+import javax.print.PrintService;
+import javax.print.ServiceUIFactory;
+import javax.print.attribute.PrintRequestAttributeSet;
+
+public abstract class DocumentPropertiesUI {
+
+    /**
+     * For Win32 doc properties sheet.
+     */
+    public static final int
+        DOCUMENTPROPERTIES_ROLE = ServiceUIFactory.RESERVED_UIROLE +100;
+
+    /**
+     * Name of (this) abstract class for Document Properties.
+     */
+    public static final String
+        DOCPROPERTIESCLASSNAME = DocumentPropertiesUI.class.getName();
+
+    /**
+     * Invokes whatever code is needed to display a native dialog
+     * with the specified owner. The owner should be the cross-platform
+     * dialog. If the user cancels the dialog the return value is null.
+     * A non-null return value is always a new attribute set (or is it?)
+     * The cross-platform dialog may need to be updated to reflect the
+     * updated properties.
+     */
+    public abstract PrintRequestAttributeSet
+        showDocumentProperties(PrinterJob job,
+                               Window owner,
+                               PrintService service,
+                               PrintRequestAttributeSet aset);
+
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/src/share/classes/sun/print/PrinterJobWrapper.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,60 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package sun.print;
+
+import java.awt.print.PrinterJob;
+import javax.print.attribute.PrintRequestAttribute;
+
+public class PrinterJobWrapper implements PrintRequestAttribute {
+
+    private static final long serialVersionUID = -8792124426995707237L;
+
+    private PrinterJob job;
+
+    public PrinterJobWrapper(PrinterJob job) {
+        this.job = job;
+    }
+
+    public PrinterJob getPrinterJob() {
+        return job;
+    }
+
+    public final Class getCategory() {
+        return PrinterJobWrapper.class;
+    }
+
+    public final String getName() {
+        return "printerjob-wrapper";
+    }
+
+    public String toString() {
+       return "printerjob-wrapper: " + job.toString();
+    }
+
+    public int hashCode() {
+        return job.hashCode();
+    }
+}
--- ./jdk/src/share/classes/sun/print/RasterPrinterJob.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/sun/print/RasterPrinterJob.java	Wed May 07 19:26:47 2014 -0700
@@ -879,6 +879,9 @@
         int x = bounds.x+bounds.width/3;
         int y = bounds.y+bounds.height/3;
         PrintService newService;
+        // temporarily add an attribute pointing back to this job.
+        PrinterJobWrapper jobWrapper = new PrinterJobWrapper(this);
+        attributes.add(jobWrapper);
         try {
             newService =
             ServiceUI.printDialog(gc, x, y,
@@ -891,6 +894,7 @@
                                   DocFlavor.SERVICE_FORMATTED.PAGEABLE,
                                   attributes);
         }
+        attributes.remove(PrinterJobWrapper.class);
 
         if (newService == null) {
             return false;
--- ./jdk/src/share/classes/sun/print/ServiceDialog.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/sun/print/ServiceDialog.java	Wed May 07 19:26:47 2014 -0700
@@ -46,6 +46,7 @@
 import java.awt.event.ItemListener;
 import java.awt.event.WindowEvent;
 import java.awt.event.WindowAdapter;
+import java.awt.print.PrinterJob;
 import java.io.File;
 import java.io.FilePermission;
 import java.io.IOException;
@@ -119,8 +120,6 @@
     private AppearancePanel pnlAppearance;
 
     private boolean isAWT = false;
-
-
     static {
         initResource();
     }
@@ -801,9 +800,32 @@
                     if (dialog != null) {
                         dialog.show();
                     } else {
-                        // REMIND: may want to notify the user why we're
-                        //         disabling the button
-                        btnProperties.setEnabled(false);
+                        DocumentPropertiesUI docPropertiesUI = null;
+                        try {
+                            docPropertiesUI =
+                                (DocumentPropertiesUI)uiFactory.getUI
+                                (DocumentPropertiesUI.DOCUMENTPROPERTIES_ROLE,
+                                 DocumentPropertiesUI.DOCPROPERTIESCLASSNAME);
+                        } catch (Exception ex) {
+                        }
+                        if (docPropertiesUI != null) {
+                            PrinterJobWrapper wrapper = (PrinterJobWrapper)
+                                asCurrent.get(PrinterJobWrapper.class);
+                            if (wrapper == null) {
+                                return; // should not happen, defensive only.
+                            }
+                            PrinterJob job = wrapper.getPrinterJob();
+                            if (job == null) {
+                                return;  // should not happen, defensive only.
+                            }
+                            PrintRequestAttributeSet newAttrs =
+                               docPropertiesUI.showDocumentProperties
+                               (job, ServiceDialog.this, psCurrent, asCurrent);
+                            if (newAttrs != null) {
+                                asCurrent.addAll(newAttrs);
+                                updatePanels();
+                            }
+                        }
                     }
                 }
             }
--- ./jdk/src/share/classes/sun/security/jgss/spnego/SpNegoContext.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/sun/security/jgss/spnego/SpNegoContext.java	Wed May 07 19:26:47 2014 -0700
@@ -525,6 +525,10 @@
 
                 // get the mechanism token
                 byte[] mechToken = initToken.getMechToken();
+                if (mechToken == null) {
+                    throw new GSSException(GSSException.FAILURE, -1,
+                            "mechToken is missing");
+                }
 
                 /*
                  * Select the best match between the list of mechs
--- ./jdk/src/share/classes/sun/security/krb5/Credentials.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/sun/security/krb5/Credentials.java	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -62,7 +62,9 @@
     private static CredentialsCache cache;
     static boolean alreadyLoaded = false;
     private static boolean alreadyTried = false;
-    private static native Credentials acquireDefaultNativeCreds();
+
+    // Read native ticket with session key type in the given list
+    private static native Credentials acquireDefaultNativeCreds(int[] eTypes);
 
     public Credentials(Ticket new_ticket,
                        PrincipalName new_client,
@@ -373,6 +375,8 @@
     // It assumes that the GSS call has
     // the privilege to access the default cache file.
 
+    // This method is only called on Windows and Mac OS X, the native
+    // acquireDefaultNativeCreds is also available on these platforms.
     public static synchronized Credentials acquireDefaultCreds() {
         Credentials result = null;
 
@@ -416,10 +420,11 @@
             }
             if (alreadyLoaded) {
                 // There is some native code
-                if (DEBUG)
-                   System.out.println(">> Acquire default native Credentials");
-                result = acquireDefaultNativeCreds();
-                // only TGT with DES key will be returned by native method
+                if (DEBUG) {
+                    System.out.println(">> Acquire default native Credentials");
+                }
+                result = acquireDefaultNativeCreds(
+                        EType.getDefaults("default_tkt_enctypes"));
             }
         }
         return result;
--- ./jdk/src/share/classes/sun/security/krb5/Realm.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/sun/security/krb5/Realm.java	Wed May 07 19:26:47 2014 -0700
@@ -34,6 +34,7 @@
 import sun.security.krb5.internal.Krb5;
 import sun.security.util.*;
 import java.io.IOException;
+import java.util.LinkedList;
 import java.util.StringTokenizer;
 import java.util.Vector;
 import java.util.Stack;
@@ -301,21 +302,25 @@
         }
 
     /**
-     * Parses the [capaths] stanza of the configuration file
-     * for a list of realms to traverse
-     * to obtain credentials from the initiating realm cRealm to
-     * the target realm sRealm.
-     * @param cRealm the initiating realm
-     * @param sRealm the target realm
-     * @returns array of realms
-     * @ throws KrbException
-     */
-
-    /*
-     * parseCapaths works for a capaths organized such that
-     * for a given client realm C there is a tag C that
-     * contains subtags Ci ... Cn that completely define intermediate
-     * realms from C to target T. For example:
+     * Parses the [capaths] stanza of the configuration file for a
+     * list of realms to traverse to obtain credentials from the
+     * initiating realm cRealm to the target realm sRealm.
+     *
+     * For a given client realm C there is a tag C in [capaths] whose
+     * subtag S has a value which is a (possibly partial) path from C
+     * to S. When the path is partial, it contains only the tail of the
+     * full path. Values of other subtags will be used to build the full
+     * path. The value "." means a direct path from C to S. If realm S
+     * does not appear as a subtag, there is no path defined here.
+     *
+     * The implementation ignores all values which equals to C or S, or
+     * a "." in multiple values, or any duplicated realm names.
+     *
+     * When a path value has more than two realms, they can be specified
+     * with multiple key-value pairs each having a single value, but the
+     * order must not change.
+     *
+     * For example:
      *
      * [capaths]
      *    TIVOLI.COM = {
@@ -324,19 +329,24 @@
      *        LDAPCENTRAL.NET = .
      *    }
      *
-     * The tag TIVOLI.COM contains subtags IBM.COM, IBM_LDAPCENTRAL.COM
-     * and LDAPCENTRAL.NET that completely define the path from TIVOLI.COM
-     * to IBM.COM (TIVOLI.COM->LADAPCENTRAL.NET->IBM_LDAPCENTRAL.COM->IBM
-     * or TIVOLI.COM->MOONLITE.ORG->IBM.COM).
+     * TIVOLI.COM has a direct path to LDAPCENTRAL.NET, which has a direct
+     * path to IBM_LDAPCENTRAL.COM. It also has a partial path to IBM.COM
+     * being "IBM_LDAPCENTRAL.COM MOONLITE.ORG". Merging these info together,
+     * a full path from TIVOLI.COM to IBM.COM will be
      *
-     * A direct path is assumed for an intermediary whose entry is not
-     * "closed" by a "." In the above example, TIVOLI.COM is assumed
-     * to have a direct path to MOONLITE.ORG and MOONLITE.COM
-     * in turn to IBM.COM.
+     *   TIVOLI.COM -> LDAPCENTRAL.NET -> IBM_LDAPCENTRAL.COM
+     *              -> IBM_LDAPCENTRAL.COM -> MOONLITE.ORG
+     *
+     * Please note the sRealm IBM.COM does not appear in the path.
+     *
+     * @param cRealm the initiating realm
+     * @param sRealm the target realm, not the same as cRealm
+     * @returns array of realms including at least cRealm as the first
+     *          element, or null if the config does not contain a sub-stanza
+     *          for cRealm in [capaths] or the sub-stanza does not contain
+     *          sRealm as a tag
      */
-
-    private static String[] parseCapaths(String cRealm, String sRealm) throws KrbException {
-        String[] retList = null;
+    private static String[] parseCapaths(String cRealm, String sRealm) {
 
         Config cfg = null;
         try {
@@ -358,323 +368,102 @@
             return null;
         }
 
-        String tempTarget = null, tempRealm = null;
-        Stack<String> iStack = new Stack<>();
+        LinkedList<String> path = new LinkedList<>();
 
-        /*
-         * The half-established reversed-path, starting from the final target
-         * (sRealm), each item can be connected to by the next one.
-         * Might contains wrong item, if found, a bad track is performed
-         */
-        Vector<String> tempList = new Vector<>(8, 8);
-        tempList.add(sRealm);
-
-        int count = 0; // For debug only
-        tempTarget = sRealm;
-
-        out: do {
-            if (DEBUG) {
-                count++;
-                System.out.println(">>> Realm parseCapaths: loop " +
-                                   count + ": target=" + tempTarget);
-            }
-
-            if (intermediaries != null &&
-                !intermediaries.equals(".") &&
-                !intermediaries.equals(cRealm)) {
-                if (DEBUG) {
-                    System.out.println(">>> Realm parseCapaths: loop " +
-                                       count + ": intermediaries=[" +
-                                       intermediaries + "]");
-                }
-
-                /*
-                 * We have one or more space-separated intermediary realms.
-                 * Stack them. A null is always added between intermedies of
-                 * different targets. When this null is popped, it means none
-                 * of the intermedies for this target is useful (because of
-                 * infinite loop), the target is then removed from the partial
-                 * tempList, and the next possible intermediary is tried.
-                 */
-                iStack.push(null);
-                String[] ints = intermediaries.split("\\s+");
-                for (int i = ints.length-1; i>=0; i--)
-                {
-                    tempRealm = ints[i];
-                    if (tempRealm.equals(PrincipalName.REALM_COMPONENT_SEPARATOR_STR)) {
-                        break out;
-                    }
-                    if (!tempList.contains(tempRealm)) {
-                        iStack.push(tempRealm);
-                        if (DEBUG) {
-                            System.out.println(">>> Realm parseCapaths: loop " +
-                                               count +
-                                               ": pushed realm on to stack: " +
-                                               tempRealm);
-                        }
-                    } else if (DEBUG) {
-                        System.out.println(">>> Realm parseCapaths: loop " +
-                                           count +
-                                           ": ignoring realm: [" +
-                                           tempRealm + "]");
-                    }
-                }
-            } else {
-                if (DEBUG) {
-                    System.out.println(">>> Realm parseCapaths: loop " +
-                                       count +
-                                       ": no intermediaries");
-                }
+        String head = sRealm;
+        while (true) {
+            String value = cfg.getDefault(head, cRealm);
+            if (value == null) {
                 break;
             }
-
-            /*
-             * Get next intermediary realm from the stack
-             */
-
-            try {
-                while ((tempTarget = iStack.pop()) == null) {
-                    tempList.removeElementAt(tempList.size()-1);
-                    if (DEBUG) {
-                        System.out.println(">>> Realm parseCapaths: backtrack, remove tail");
-                    }
+            String[] more = value.split("\\s+");
+            boolean changed = false;
+            for (int i=more.length-1; i>=0; i--) {
+                if (path.contains(more[i])
+                        || more[i].equals(".")
+                        || more[i].equals(cRealm)
+                        || more[i].equals(sRealm)
+                        || more[i].equals(head)) {
+                    // Ignore invalid values
+                    continue;
                 }
-            } catch (EmptyStackException exc) {
-                tempTarget = null;
+                changed = true;
+                path.addFirst(more[i]);
             }
-
-            if (tempTarget == null) {
-                /*
-                 * No more intermediaries. We're done.
-                 */
-                break;
-            }
-
-            tempList.add(tempTarget);
-
-            if (DEBUG) {
-                System.out.println(">>> Realm parseCapaths: loop " + count +
-                                   ": added intermediary to list: " +
-                                   tempTarget);
-            }
-
-            intermediaries = cfg.getDefault(tempTarget, cRealm);
-
-        } while (true);
-
-        if (tempList.isEmpty()) {
-            return null;
+            if (!changed) break;
+            head = path.getFirst();
         }
-
-        // From (SREALM, T1, T2) to (CREALM, T2, T1)
-        retList = new String[tempList.size()];
-        retList[0] = cRealm;
-        for (int i=1; i<tempList.size(); i++) {
-            retList[i] = tempList.elementAt(tempList.size()-i);
-        }
-
-        if (DEBUG && retList != null) {
-            for (int i = 0; i < retList.length; i++) {
-                System.out.println(">>> Realm parseCapaths [" + i +
-                                   "]=" + retList[i]);
-            }
-        }
-
-        return retList;
-    }
+        path.addFirst(cRealm);
+        return path.toArray(new String[path.size()]);
+   }
 
     /**
      * Build a list of realm that can be traversed
      * to obtain credentials from the initiating realm cRealm
      * for a service in the target realm sRealm.
      * @param cRealm the initiating realm
-     * @param sRealm the target realm
-     * @returns array of realms
-     * @throws KrbException
+     * @param sRealm the target realm, not the same as cRealm
+     * @returns array of realms including cRealm as the first element
      */
-    private static String[] parseHierarchy(String cRealm, String sRealm)
-        throws KrbException
-    {
-        String[] retList = null;
+    private static String[] parseHierarchy(String cRealm, String sRealm) {
 
-        // Parse the components and determine common part, if any.
+        String[] cComponents = cRealm.split("\\.");
+        String[] sComponents = sRealm.split("\\.");
 
-        String[] cComponents = null;
-        String[] sComponents = null;
+        int cPos = cComponents.length;
+        int sPos = sComponents.length;
 
-        StringTokenizer strTok =
-        new StringTokenizer(cRealm,
-                            PrincipalName.REALM_COMPONENT_SEPARATOR_STR);
-
-        // Parse cRealm
-
-        int cCount = strTok.countTokens();
-        cComponents = new String[cCount];
-
-        for (cCount = 0; strTok.hasMoreTokens(); cCount++) {
-            cComponents[cCount] = strTok.nextToken();
+        boolean hasCommon = false;
+        for (sPos--, cPos--; sPos >=0 && cPos >= 0 &&
+                sComponents[sPos].equals(cComponents[cPos]);
+                sPos--, cPos--) {
+            hasCommon = true;
         }
 
-        if (DEBUG) {
-            System.out.println(">>> Realm parseHierarchy: cRealm has " +
-                               cCount + " components:");
-            int j = 0;
-            while (j < cCount) {
-                System.out.println(">>> Realm parseHierarchy: " +
-                                   "cComponents["+j+"]=" + cComponents[j++]);
-            }
+        // For those with common components:
+        //                            length  pos
+        // SITES1.SALES.EXAMPLE.COM   4       1
+        //   EVERYWHERE.EXAMPLE.COM   3       0
+
+        // For those without common components:
+        //                     length  pos
+        // DEVEL.EXAMPLE.COM   3       2
+        // PROD.EXAMPLE.ORG    3       2
+
+        LinkedList<String> path = new LinkedList<>();
+
+        // Un-common ones for client side
+        for (int i=0; i<=cPos; i++) {
+            path.addLast(subStringFrom(cComponents, i));
         }
 
-        // Parse sRealm
-
-        strTok = new StringTokenizer(sRealm,
-                                     PrincipalName.REALM_COMPONENT_SEPARATOR_STR);
-
-        int sCount = strTok.countTokens();
-        sComponents = new String[sCount];
-
-        for (sCount = 0; strTok.hasMoreTokens(); sCount++) {
-            sComponents[sCount] = strTok.nextToken();
+        // Common one
+        if (hasCommon) {
+            path.addLast(subStringFrom(cComponents, cPos+1));
         }
 
-        if (DEBUG) {
-            System.out.println(">>> Realm parseHierarchy: sRealm has " +
-                               sCount + " components:");
-            int j = 0;
-            while (j < sCount) {
-                System.out.println(">>> Realm parseHierarchy: sComponents["+j+
-                                   "]=" + sComponents[j++]);
-            }
+        // Un-common ones for server side
+        for (int i=sPos; i>=0; i--) {
+            path.addLast(subStringFrom(sComponents, i));
         }
 
-        // Determine common components, if any.
+        // Remove sRealm from path. Note that it might be added at last loop
+        // or as a common component, if sRealm is a parent of cRealm
+        path.removeLast();
 
-        int commonComponents = 0;
-
-        //while (sCount > 0 && cCount > 0 &&
-        //          sComponents[--sCount].equals(cComponents[--cCount]))
-
-        for (sCount--, cCount--; sCount >=0 && cCount >= 0 &&
-                 sComponents[sCount].equals(cComponents[cCount]);
-             sCount--, cCount--) {
-            commonComponents++;
-        }
-
-        int cCommonStart = -1;
-        int sCommonStart = -1;
-
-        int links = 0;
-
-        if (commonComponents > 0) {
-            sCommonStart = sCount+1;
-            cCommonStart = cCount+1;
-
-            // components from common to ancestors
-            links += sCommonStart;
-            links += cCommonStart;
-        } else {
-            links++;
-        }
-
-        if (DEBUG) {
-            if (commonComponents > 0) {
-                System.out.println(">>> Realm parseHierarchy: " +
-                                   commonComponents + " common component" +
-                                   (commonComponents > 1 ? "s" : " "));
-
-                System.out.println(">>> Realm parseHierarchy: common part "
-                                   +
-                                   "in cRealm (starts at index " +
-                                   cCommonStart + ")");
-                System.out.println(">>> Realm parseHierarchy: common part in sRealm (starts at index " +
-                                   sCommonStart + ")");
-
-
-                String commonPart = substring(cRealm, cCommonStart);
-                System.out.println(">>> Realm parseHierarchy: common part in cRealm=" +
-                                   commonPart);
-
-                commonPart = substring(sRealm, sCommonStart);
-                System.out.println(">>> Realm parseHierarchy: common part in sRealm=" +
-                                   commonPart);
-
-            } else
-            System.out.println(">>> Realm parseHierarchy: no common part");
-        }
-
-        if (DEBUG) {
-            System.out.println(">>> Realm parseHierarchy: total links=" + links);
-        }
-
-        retList = new String[links];
-
-        retList[0] = new String(cRealm);
-
-        if (DEBUG) {
-            System.out.println(">>> Realm parseHierarchy A: retList[0]=" +
-                               retList[0]);
-        }
-
-        // For an initiator realm A.B.C.D.COM,
-        // build a list krbtgt/B.C.D.COM@A.B.C.D.COM up to the common part,
-        // ie the issuer realm is the immediate descendant
-        // of the target realm.
-
-        String cTemp = null, sTemp = null;
-        int i;
-        for (i = 1, cCount = 0; i < links && cCount < cCommonStart; cCount++) {
-            sTemp = substring(cRealm, cCount+1);
-            //cTemp = substring(cRealm, cCount);
-            retList[i++] = new String(sTemp);
-
-            if (DEBUG) {
-                System.out.println(">>> Realm parseHierarchy B: retList[" +
-                                   (i-1) +"]="+retList[i-1]);
-            }
-        }
-
-
-        for (sCount = sCommonStart; i < links && sCount - 1 > 0; sCount--) {
-            sTemp = substring(sRealm, sCount-1);
-            //cTemp = substring(sRealm, sCount);
-            retList[i++] = new String(sTemp);
-            if (DEBUG) {
-                System.out.println(">>> Realm parseHierarchy D: retList[" +
-                                   (i-1) +"]="+retList[i-1]);
-            }
-        }
-
-        return retList;
+        return path.toArray(new String[path.size()]);
     }
 
-    private static String substring(String realm, int componentIndex)
-    {
-        int i = 0 , j = 0, len = realm.length();
-
-        while(i < len && j != componentIndex) {
-            if (realm.charAt(i++) != PrincipalName.REALM_COMPONENT_SEPARATOR)
-                continue;
-            j++;
+    /**
+     * Creates a realm name using components from the given postion.
+     * For example, subStringFrom({"A", "B", "C"}, 1) is "B.C".
+     */
+    private static String subStringFrom(String[] components, int from) {
+        StringBuilder sb = new StringBuilder();
+        for (int i=from; i<components.length; i++) {
+            if (sb.length() != 0) sb.append('.');
+            sb.append(components[i]);
         }
-
-        return realm.substring(i);
+        return sb.toString();
     }
-
-    static int getRandIndex(int arraySize) {
-        return (int)(Math.random() * 16384.0) % arraySize;
-    }
-
-    static void printNames(String[] names) {
-        if (names == null || names.length == 0)
-            return;
-
-        int len = names.length;
-        int i = 0;
-        System.out.println("List length = " + len);
-        while (i < names.length) {
-            System.out.println("["+ i +"]=" + names[i]);
-            i++;
-        }
-    }
-
 }
--- ./jdk/src/share/classes/sun/security/krb5/internal/CredentialsUtil.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/sun/security/krb5/internal/CredentialsUtil.java	Wed May 07 19:26:47 2014 -0700
@@ -155,13 +155,11 @@
                 }
 
                 /*
-                 * No tgt found. Try to get one for a
-                 * realm as close to the target as possible.
-                 * That means traversing the realms list backwards.
+                 * No tgt found. Let's go thru the realms list one by one.
                  */
 
-                for (newTgt = null, k = realms.length - 1;
-                     newTgt == null && k > i; k--)
+                for (newTgt = null, k = i+1;
+                        newTgt == null && k < realms.length; k++)
                 {
 
                     tempService = new ServiceName(
--- ./jdk/src/share/classes/sun/security/ssl/SSLSocketImpl.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/sun/security/ssl/SSLSocketImpl.java	Wed May 07 19:26:47 2014 -0700
@@ -172,7 +172,7 @@
     /*
      * Drives the protocol state machine.
      */
-    private int                 connectionState;
+    private volatile int        connectionState;
 
     /*
      * Flag indicating if the next record we receive MUST be a Finished
@@ -1443,7 +1443,7 @@
      * Return whether the socket has been explicitly closed by the application.
      */
     public boolean isClosed() {
-        return getConnectionState() == cs_APP_CLOSED;
+        return connectionState == cs_APP_CLOSED;
     }
 
     /**
--- ./jdk/src/share/classes/sun/security/tools/JarSignerResources_zh_CN.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/sun/security/tools/JarSignerResources_zh_CN.java	Wed May 07 19:26:47 2014 -0700
@@ -55,7 +55,7 @@
         {"Usage.jarsigner.options.jar.file.alias",
                 "\u7528\u6CD5: jarsigner [\u9009\u9879] jar-file \u522B\u540D"},
         {".jarsigner.verify.options.jar.file.alias.",
-                "       jarsigner -verify [options] jar-file [alias...]"},
+                "       jarsigner -verify [\u9009\u9879] jar-file [\u522B\u540D...]"},
         {".keystore.url.keystore.location",
                 "[-keystore <url>]           \u5BC6\u94A5\u5E93\u4F4D\u7F6E"},
         {".storepass.password.password.for.keystore.integrity",
@@ -65,7 +65,7 @@
         {".keypass.password.password.for.private.key.if.different.",
                 "[-keypass <\u53E3\u4EE4>]           \u79C1\u6709\u5BC6\u94A5\u7684\u53E3\u4EE4 (\u5982\u679C\u4E0D\u540C)"},
         {".certchain.file.name.of.alternative.certchain.file",
-                "[-certchain <file>]         \u66FF\u4EE3 certchain \u6587\u4EF6\u7684\u540D\u79F0"},
+                "[-certchain <\u6587\u4EF6>]         \u66FF\u4EE3\u8BC1\u4E66\u94FE\u6587\u4EF6\u7684\u540D\u79F0"},
         {".sigfile.file.name.of.SF.DSA.file",
                 "[-sigfile <\u6587\u4EF6>]           .SF/.DSA \u6587\u4EF6\u7684\u540D\u79F0"},
         {".signedjar.file.name.of.signed.JAR.file",
--- ./jdk/src/share/classes/sun/swing/SwingUtilities2.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/sun/swing/SwingUtilities2.java	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2002, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2002, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -34,6 +34,7 @@
 import java.awt.geom.*;
 import java.awt.print.PrinterGraphics;
 import java.text.Bidi;
+import java.text.CharacterIterator;
 import java.text.AttributedCharacterIterator;
 import java.text.AttributedString;
 
@@ -503,22 +504,25 @@
                  * it to fit in the screen width. This distributes the spacing
                  * more evenly than directly laying out to the screen advances.
                  */
-                float screenWidth = (float)
-                   g2d.getFont().getStringBounds(text, DEFAULT_FRC).getWidth();
-                TextLayout layout = createTextLayout(c, text, g2d.getFont(),
-                                                   g2d.getFontRenderContext());
+                String trimmedText = trimTrailingSpaces(text);
+                if (!trimmedText.isEmpty()) {
+                    float screenWidth = (float) g2d.getFont().getStringBounds
+                            (trimmedText, DEFAULT_FRC).getWidth();
+                    TextLayout layout = createTextLayout(c, text, g2d.getFont(),
+                                                       g2d.getFontRenderContext());
 
-                layout = layout.getJustifiedLayout(screenWidth);
-                /* Use alternate print color if specified */
-                Color col = g2d.getColor();
-                if (col instanceof PrintColorUIResource) {
-                    g2d.setColor(((PrintColorUIResource)col).getPrintColor());
+                    layout = layout.getJustifiedLayout(screenWidth);
+                    /* Use alternate print color if specified */
+                    Color col = g2d.getColor();
+                    if (col instanceof PrintColorUIResource) {
+                        g2d.setColor(((PrintColorUIResource)col).getPrintColor());
+                    }
+
+                    layout.draw(g2d, x, y);
+
+                    g2d.setColor(col);
                 }
 
-                layout.draw(g2d, x, y);
-
-                g2d.setColor(col);
-
                 return;
             }
         }
@@ -777,25 +781,27 @@
                 if (frc != null &&
                     !isFontRenderContextPrintCompatible
                     (deviceFontRenderContext, frc)) {
-                    TextLayout layout =
-                        createTextLayout(c, new String(data, offset, length),
-                                       g2d.getFont(),
-                                       deviceFontRenderContext);
-                    float screenWidth = (float)g2d.getFont().
-                        getStringBounds(data, offset, offset + length, frc).
-                        getWidth();
-                    layout = layout.getJustifiedLayout(screenWidth);
 
-                    /* Use alternate print color if specified */
-                    Color col = g2d.getColor();
-                    if (col instanceof PrintColorUIResource) {
-                        g2d.setColor(((PrintColorUIResource)col).getPrintColor());
+                    String text = new String(data, offset, length);
+                    TextLayout layout = new TextLayout(text, g2d.getFont(),
+                                    deviceFontRenderContext);
+                    String trimmedText = trimTrailingSpaces(text);
+                    if (!trimmedText.isEmpty()) {
+                        float screenWidth = (float)g2d.getFont().
+                            getStringBounds(trimmedText, frc).getWidth();
+                        layout = layout.getJustifiedLayout(screenWidth);
+
+                        /* Use alternate print color if specified */
+                        Color col = g2d.getColor();
+                        if (col instanceof PrintColorUIResource) {
+                            g2d.setColor(((PrintColorUIResource)col).getPrintColor());
+                        }
+
+                        layout.draw(g2d,x,y);
+
+                        g2d.setColor(col);
                     }
 
-                    layout.draw(g2d,x,y);
-
-                    g2d.setColor(col);
-
                     return nextX;
                 }
             }
@@ -876,14 +882,23 @@
             } else {
                 frc = g2d.getFontRenderContext();
             }
-            TextLayout layout = new TextLayout(iterator, frc);
+            TextLayout layout;
             if (isPrinting) {
                 FontRenderContext deviceFRC = g2d.getFontRenderContext();
                 if (!isFontRenderContextPrintCompatible(frc, deviceFRC)) {
-                    float screenWidth = layout.getAdvance();
                     layout = new TextLayout(iterator, deviceFRC);
-                    layout = layout.getJustifiedLayout(screenWidth);
+                    AttributedCharacterIterator trimmedIt =
+                            getTrimmedTrailingSpacesIterator(iterator);
+                    if (trimmedIt != null) {
+                        float screenWidth = new TextLayout(trimmedIt, frc).
+                                getAdvance();
+                        layout = layout.getJustifiedLayout(screenWidth);
+                    }
+                } else {
+                    layout = new TextLayout(iterator, frc);
                 }
+            } else {
+                layout = new TextLayout(iterator, frc);
             }
             layout.draw(g2d, x, y);
             retVal = layout.getAdvance();
@@ -1035,6 +1050,39 @@
         return (g instanceof PrinterGraphics || g instanceof PrintGraphics);
     }
 
+    private static String trimTrailingSpaces(String s) {
+        int i = s.length() - 1;
+        while(i >= 0 && Character.isWhitespace(s.charAt(i))) {
+            i--;
+        }
+        return s.substring(0, i + 1);
+    }
+
+    private static AttributedCharacterIterator getTrimmedTrailingSpacesIterator
+            (AttributedCharacterIterator iterator) {
+        int curIdx = iterator.getIndex();
+
+        char c = iterator.last();
+        while(c != CharacterIterator.DONE && Character.isWhitespace(c)) {
+            c = iterator.previous();
+        }
+
+        if (c != CharacterIterator.DONE) {
+            int endIdx = iterator.getIndex();
+
+            if (endIdx == iterator.getEndIndex() - 1) {
+                iterator.setIndex(curIdx);
+                return iterator;
+            } else {
+                AttributedString trimmedText = new AttributedString(iterator,
+                        iterator.getBeginIndex(), endIdx + 1);
+                return trimmedText.getIterator();
+            }
+        } else {
+            return null;
+        }
+    }
+
     /**
      * Determines whether the SelectedTextColor should be used for painting text
      * foreground for the specified highlight.
--- ./jdk/src/share/classes/sun/tools/jar/resources/jar_pt_BR.properties	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/sun/tools/jar/resources/jar_pt_BR.properties	Wed May 07 19:26:47 2014 -0700
@@ -44,4 +44,4 @@
 out.inflated=\ inflado: {0}
 out.size=(entrada = {0}) (sa\u00EDda= {1})
 
-usage=Uso: jar {ctxui}[vfm0Me] [jar-file] [manifest-file] [entry-point] [-C dir] arquivos ...\nOp\u00E7\u00F5es:\n    -c  cria novo arquivo compactado\n    -t  lista o sum\u00E1rio do arquivo compactado\n    -x  extrai arquivos com o nome (ou todos) do arquivo compactado\n    -u  atualizar o arquivo compactado existente\n    -v  gera sa\u00EDda detalhada na sa\u00EDda padr\u00E3o\n    -f  especifica o nome do arquivo do arquivo compactado\n    -m  inclui as informa\u00E7\u00F5es do manifesto do arquivo de manifesto especificado\n    -e  especifica o ponto de entrada da aplica\u00E7\u00E3o para aplica\u00E7\u00E3o independente \n        empacotando em um arquivo jar execut\u00E1vel\n    -0  armazena somente; n\u00E3o usa compacta\u00E7\u00E3o ZIP\n    -M  n\u00E3o cria um arquivo de manifesto para as entradas\n    -i  gera informa\u00E7\u00F5es de \u00EDndice para os arquivos especificados\n    -C  altera para o diret\u00F3rio e inclui o arquivo seguinte\nSe nenhum arquivo for um diret\u00F3rio, ent\u00E3o ser\u00E1 processado repetidamente.\nO nome do arquivo de manifesto, o nome do arquivo compactado e o nome do ponto de entrada s\u00E3o\nespecificados na mesma ordem dos flags  'm', 'f' e 'e'.\n\nExemplo 1: para arquivar dois arquivos de classe em um arquivo compactado com o nome classes.jar: \n       jar cvf classes.jar Foo.class Bar.class \nExemplo 2: use um arquivo de manifesto existente 'mymanifest' e arquive todos os\n           arquivos no diret\u00F3rio foo/ na 'classes.jar': \n       jar cvfm classes.jar mymanifest -C foo/ .\n
+usage=Uso: jar {ctxui}[vfm0Me] [jar-file] [manifest-file] [entry-point] [-C dir] arquivos ...\nOp\u00E7\u00F5es:\n    -c  cria novo arquivo compactado\n    -t  lista o sum\u00E1rio do arquivo compactado\n    -x  extrai arquivos com o nome (ou todos) do arquivo compactado\n    -u  atualiza o arquivo compactado existente\n    -v  gera sa\u00EDda detalhada na sa\u00EDda padr\u00E3o\n    -f  especifica o nome do arquivo do arquivo compactado\n    -m  inclui as informa\u00E7\u00F5es do manifesto do arquivo de manifesto especificado\n    -e  especifica o ponto de entrada da aplica\u00E7\u00E3o para aplica\u00E7\u00E3o independente \n        empacotando em um arquivo jar execut\u00E1vel\n    -0  armazena somente; n\u00E3o usa compacta\u00E7\u00E3o ZIP\n    -M  n\u00E3o cria um arquivo de manifesto para as entradas\n    -i  gera informa\u00E7\u00F5es de \u00EDndice para os arquivos especificados\n    -C  passa para o diret\u00F3rio especificado e inclui o arquivo a seguir\nSe um arquivo tamb\u00E9m for um diret\u00F3rio, ele ser\u00E1 processado repetidamente.\nO nome do arquivo de manifesto, o nome do arquivo compactado e o nome do ponto de entrada s\u00E3o\nespecificados na mesma ordem dos flags 'm', 'f' e 'e'.\n\nExemplo 1: para arquivar dois arquivos de classe em um arquivo compactado denominado classes.jar: \n       jar cvf classes.jar Foo.class Bar.class \nExemplo 2: use um arquivo de manifesto existente 'mymanifest' e arquive todos os\n           arquivos no diret\u00F3rio foo/ na 'classes.jar': \n       jar cvfm classes.jar mymanifest -C foo/ .\n
--- ./jdk/src/share/classes/sun/tools/jconsole/Messages.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/sun/tools/jconsole/Messages.java	Wed May 07 19:26:47 2014 -0700
@@ -36,7 +36,7 @@
         Resources.initializeMessages(Messages.class, BUNDLE_NAME);
     }
     // TODO:
-    // The names of some of the constants below looks strange.
+    // The names of some of the constants below look strange.
     // That's because they  were generated programmatically
     // from the messages. They should be cleaned up,
     // ___ should be removed etc.
@@ -265,6 +265,7 @@
     public static String SUMMARY_TAB_TAB_NAME;
     public static String SUMMARY_TAB_VM_VERSION;
     public static String THREADS;
+    public static String THREAD_TAB_INFO_LABEL_FORMAT;
     public static String THREAD_TAB_THREAD_INFO_ACCESSIBLE_NAME;
     public static String THREAD_TAB_THREAD_PLOTTER_ACCESSIBLE_NAME;
     public static String THRESHOLD;
@@ -304,9 +305,9 @@
     public static String WRITABLE;
     public static String CONNECTION_FAILED1;
     public static String CONNECTION_FAILED2;
+    public static String CONNECTION_FAILED_SSL1;
+    public static String CONNECTION_FAILED_SSL2;
     public static String CONNECTION_LOST1;
-    public static String CONNECTION_INSECURE1;
-    public static String CONNECTION_INSECURE2;
     public static String CONNECTING_TO1;
     public static String CONNECTING_TO2;
     public static String DEADLOCK_TAB;
--- ./jdk/src/share/classes/sun/tools/jconsole/SummaryTab.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/sun/tools/jconsole/SummaryTab.java	Wed May 07 19:26:47 2014 -0700
@@ -213,8 +213,8 @@
                 String[] strings2 = formatKByteStrings(u.getCommitted());
                 append(Messages.COMMITTED_MEMORY,  strings2[0]);
                 append(Messages.SUMMARY_TAB_PENDING_FINALIZATION_LABEL,
-                       Messages.SUMMARY_TAB_PENDING_FINALIZATION_VALUE,
-                       memoryBean.getObjectPendingFinalizationCount());
+                       Resources.format(Messages.SUMMARY_TAB_PENDING_FINALIZATION_VALUE,
+                                        memoryBean.getObjectPendingFinalizationCount()));
                 append(endTable);
 
                 append(newTable);
--- ./jdk/src/share/classes/sun/tools/jconsole/ThreadTab.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/sun/tools/jconsole/ThreadTab.java	Wed May 07 19:26:47 2014 -0700
@@ -66,9 +66,6 @@
 
     private static final Border thinEmptyBorder  = new EmptyBorder(2, 2, 2, 2);
 
-    private static final String infoLabelFormat = "ThreadTab.infoLabelFormat";
-
-
     /*
       Hierarchy of panels and layouts for this tab:
 
@@ -690,7 +687,7 @@
 
         private void updateThreadsInfo(long tlCount, long tpCount, long ttCount, long timeStamp) {
             getPlotter().addValues(timeStamp, tlCount);
-            getInfoLabel().setText(Resources.format(infoLabelFormat, tlCount, tpCount, ttCount));
+            getInfoLabel().setText(Resources.format(Messages.THREAD_TAB_INFO_LABEL_FORMAT, tlCount, tpCount, ttCount));
         }
     }
 }
--- ./jdk/src/share/classes/sun/tools/jconsole/VMPanel.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/sun/tools/jconsole/VMPanel.java	Wed May 07 19:26:47 2014 -0700
@@ -469,8 +469,8 @@
             msgExplanation = Resources.format(Messages.CONNECTING_TO2, getConnectionName());
             buttonStr = Messages.RECONNECT;
         } else if (shouldUseSSL) {
-            msgTitle = Messages.CONNECTION_INSECURE1;
-            msgExplanation = Resources.format(Messages.CONNECTION_INSECURE2, getConnectionName());
+            msgTitle = Messages.CONNECTION_FAILED_SSL1;
+            msgExplanation = Resources.format(Messages.CONNECTION_FAILED_SSL2, getConnectionName());
             buttonStr = Messages.INSECURE;
         } else {
             msgTitle = Messages.CONNECTION_FAILED1;
--- ./jdk/src/share/classes/sun/tools/jconsole/resources/messages.properties	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/sun/tools/jconsole/resources/messages.properties	Wed May 07 19:26:47 2014 -0700
@@ -223,6 +223,7 @@
 SUMMARY_TAB_TAB_NAME=VM Summary
 SUMMARY_TAB_VM_VERSION={0} version {1}
 THREADS=Threads
+THREAD_TAB_INFO_LABEL_FORMAT=<html>Live: {0}    Peak: {1}    Total: {2}</html>
 THREAD_TAB_THREAD_INFO_ACCESSIBLE_NAME=Thread Information
 THREAD_TAB_THREAD_PLOTTER_ACCESSIBLE_NAME=Chart for number of threads.
 THRESHOLD=Threshold
@@ -244,7 +245,7 @@
 UNREGISTER=Unregister
 UPTIME=Uptime
 USAGE_THRESHOLD=Usage Threshold
-REMOTE_TF_USAGE=<b>Usage</b>: &lt;hostname&gt;:&lt;port&gt; OR service:jmx:&lt;protocol&gt;:&lt;sap&gt;
+REMOTE_TF_USAGE=<b>Usage</b>: &&lt;hostname&&gt;:&&lt;port&&gt; OR service:jmx:&&lt;protocol&&gt;:&&lt;sap&&gt;
 USED=Used
 USERNAME_COLON_=&Username:
 USERNAME_ACCESSIBLE_NAME=User Name
@@ -262,9 +263,9 @@
 WRITABLE=Writable
 CONNECTION_FAILED1=Connection Failed: Retry?
 CONNECTION_FAILED2=The connection to {0} did not succeed.<br>Would you like to try again?
+CONNECTION_FAILED_SSL1=Secure connection failed. Retry insecurely?
+CONNECTION_FAILED_SSL2=The connection to {0} could not be made using SSL.<br>Would you like to try without SSL?<br>(Username and password will be sent in plain text.)
 CONNECTION_LOST1=Connection Lost: Reconnect?
-CONNECTION_INSECURE1=ConnectionFailedSSL1
-CONNECTION_INSECURE2=ConnectionFailedSSL2
 CONNECTING_TO1=Connecting to {0}
 CONNECTING_TO2=You are currently being connected to {0}.<br>This will take a few moments.
 DEADLOCK_TAB=Deadlock
--- ./jdk/src/share/classes/sun/tools/jconsole/resources/messages_ja.properties	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/sun/tools/jconsole/resources/messages_ja.properties	Wed May 07 19:26:47 2014 -0700
@@ -52,7 +52,7 @@
 CONNECT_DIALOG_STATUS_BAR_ACCESSIBLE_NAME=\u30B9\u30C6\u30FC\u30BF\u30B9\u30FB\u30D0\u30FC
 CONNECT_DIALOG_TITLE=JConsole: \u65B0\u898F\u63A5\u7D9A
 CONNECTED_PUNCTUATION_CLICK_TO_DISCONNECT_=\u63A5\u7D9A\u3055\u308C\u3066\u3044\u307E\u3059\u3002\u30AF\u30EA\u30C3\u30AF\u3059\u308B\u3068\u5207\u65AD\u3057\u307E\u3059\u3002
-CONNECTION_FAILED=\u63A5\u7D9A\u306B\u5931\u6557\u3057\u307E\u3057\u305F
+CONNECTION_FAILED=\u63A5\u7D9A\u304C\u5931\u6557\u3057\u307E\u3057\u305F
 CONNECTION=\u63A5\u7D9A(&C)
 CONNECTION_NAME=\u63A5\u7D9A\u540D
 CONNECTION_NAME__DISCONNECTED_={0} (\u5207\u65AD\u6E08)
@@ -88,8 +88,8 @@
 FILE_CHOOSER_FILE_EXISTS_OK_OPTION=\u7F6E\u63DB
 FILE_CHOOSER_FILE_EXISTS_TITLE=\u30D5\u30A1\u30A4\u30EB\u304C\u5B58\u5728\u3057\u3066\u3044\u307E\u3059
 FILE_CHOOSER_SAVED_FILE=<html>\u30D5\u30A1\u30A4\u30EB\u306B\u4FDD\u5B58\u3057\u307E\u3057\u305F:<br>{0}<br>({1}\u30D0\u30A4\u30C8)
-FILE_CHOOSER_SAVE_FAILED_MESSAGE=<html><center>\u30D5\u30A1\u30A4\u30EB\u3078\u306E\u4FDD\u5B58\u306B\u5931\u6557\u3057\u307E\u3057\u305F:<br>{0}<br>{1}
-FILE_CHOOSER_SAVE_FAILED_TITLE=\u4FDD\u5B58\u306B\u5931\u6557\u3057\u307E\u3057\u305F
+FILE_CHOOSER_SAVE_FAILED_MESSAGE=<html><center>\u30D5\u30A1\u30A4\u30EB\u3078\u306E\u4FDD\u5B58\u304C\u5931\u6557\u3057\u307E\u3057\u305F:<br>{0}<br>{1}
+FILE_CHOOSER_SAVE_FAILED_TITLE=\u4FDD\u5B58\u304C\u5931\u6557\u3057\u307E\u3057\u305F
 FREE_PHYSICAL_MEMORY=\u7A7A\u304D\u7269\u7406\u30E1\u30E2\u30EA\u30FC
 FREE_SWAP_SPACE=\u7A7A\u304D\u30B9\u30EF\u30C3\u30D7\u30FB\u30B9\u30DA\u30FC\u30B9
 GARBAGE_COLLECTOR=\u30AC\u30D9\u30FC\u30B8\u30FB\u30B3\u30EC\u30AF\u30BF
@@ -161,7 +161,7 @@
 MESSAGE=\u30E1\u30C3\u30BB\u30FC\u30B8
 METHOD_SUCCESSFULLY_INVOKED=\u30E1\u30BD\u30C3\u30C9\u304C\u6B63\u5E38\u306B\u8D77\u52D5\u3055\u308C\u307E\u3057\u305F
 MINIMIZE_ALL=\u3059\u3079\u3066\u6700\u5C0F\u5316(&M)
-MONITOR_LOCKED=\ \ \ - \u30ED\u30C3\u30AF\u6E08{0}\n
+MONITOR_LOCKED=\   - \u30ED\u30C3\u30AF\u6E08{0}\n
 NAME=\u540D\u524D
 NAME_AND_BUILD={0} (\u30D3\u30EB\u30C9{1})
 NAME_STATE=\u540D\u524D: {0}\n\u72B6\u614B: {1}\n
@@ -205,6 +205,7 @@
 PROCESS_CPU_TIME=\u30D7\u30ED\u30BB\u30B9CPU\u6642\u9593
 READABLE=\u8AAD\u53D6\u308A\u53EF\u80FD
 RECONNECT=\u518D\u63A5\u7D9A
+INSECURE=\u975E\u30BB\u30AD\u30E5\u30A2
 REMOTE_PROCESS_COLON=\u30EA\u30E2\u30FC\u30C8\u30FB\u30D7\u30ED\u30BB\u30B9(&R):
 REMOTE_PROCESS_TEXT_FIELD_ACCESSIBLE_NAME=\u30EA\u30E2\u30FC\u30C8\u30FB\u30D7\u30ED\u30BB\u30B9
 RESTORE_ALL=\u3059\u3079\u3066\u5FA9\u5143(&R)
@@ -222,6 +223,7 @@
 SUMMARY_TAB_TAB_NAME=VM\u30B5\u30DE\u30EA\u30FC
 SUMMARY_TAB_VM_VERSION={0}\u30D0\u30FC\u30B8\u30E7\u30F3{1}
 THREADS=\u30B9\u30EC\u30C3\u30C9
+THREAD_TAB_INFO_LABEL_FORMAT=<html>\u5B9F\u884C\u4E2D: {0}    \u30D4\u30FC\u30AF: {1}    \u5408\u8A08: {2}</html>
 THREAD_TAB_THREAD_INFO_ACCESSIBLE_NAME=\u30B9\u30EC\u30C3\u30C9\u60C5\u5831
 THREAD_TAB_THREAD_PLOTTER_ACCESSIBLE_NAME=\u30B9\u30EC\u30C3\u30C9\u6570\u306E\u30C1\u30E3\u30FC\u30C8\u3002
 THRESHOLD=\u3057\u304D\u3044\u5024
@@ -243,7 +245,7 @@
 UNREGISTER=\u767B\u9332\u89E3\u9664
 UPTIME=\u7A3C\u50CD\u6642\u9593
 USAGE_THRESHOLD=\u4F7F\u7528\u3057\u304D\u3044\u5024
-REMOTE_TF_USAGE=<b>\u4F7F\u7528\u65B9\u6CD5</b>: &lt;hostname&gt;:&lt;port&gt;\u307E\u305F\u306Fservice:jmx:&lt;protocol&gt;:&lt;sap&gt;
+REMOTE_TF_USAGE=<b>\u4F7F\u7528\u65B9\u6CD5</b>: &&lt;hostname&&gt;:&&lt;port&&gt; OR service:jmx:&&lt;protocol&&gt;:&&lt;sap&&gt;
 USED=\u4F7F\u7528\u6E08
 USERNAME_COLON_=\u30E6\u30FC\u30B6\u30FC\u540D(&U):
 USERNAME_ACCESSIBLE_NAME=\u30E6\u30FC\u30B6\u30FC\u540D
@@ -259,8 +261,10 @@
 WINDOW=\u30A6\u30A3\u30F3\u30C9\u30A6(&W)
 WINDOWS=\u30A6\u30A3\u30F3\u30C9\u30A6
 WRITABLE=\u66F8\u8FBC\u307F\u53EF\u80FD
-CONNECTION_FAILED1=\u63A5\u7D9A\u306B\u5931\u6557\u3057\u307E\u3057\u305F: \u518D\u8A66\u884C\u3057\u307E\u3059\u304B\u3002
-CONNECTION_FAILED2={0}\u3078\u306E\u63A5\u7D9A\u304C\u6210\u529F\u3057\u307E\u305B\u3093\u3067\u3057\u305F\u3002<br>\u3082\u3046\u4E00\u5EA6\u8A66\u3057\u307E\u3059\u304B\u3002
+CONNECTION_FAILED1=\u63A5\u7D9A\u304C\u5931\u6557\u3057\u307E\u3057\u305F: \u518D\u8A66\u884C\u3057\u307E\u3059\u304B\u3002
+CONNECTION_FAILED2={0}\u3078\u306E\u63A5\u7D9A\u304C\u6210\u529F\u3057\u307E\u305B\u3093\u3067\u3057\u305F\u3002<br>\u518D\u8A66\u884C\u3057\u307E\u3059\u304B\u3002
+CONNECTION_FAILED_SSL1=\u30BB\u30AD\u30E5\u30A2\u306A\u63A5\u7D9A\u304C\u5931\u6557\u3057\u307E\u3057\u305F\u3002\u975E\u30BB\u30AD\u30E5\u30A2\u3067\u518D\u8A66\u884C\u3057\u307E\u3059\u304B\u3002
+CONNECTION_FAILED_SSL2=SSL\u3092\u4F7F\u7528\u3057\u3066{0}\u306B\u63A5\u7D9A\u3067\u304D\u307E\u305B\u3093\u3002<br>SSL\u306A\u3057\u3067\u63A5\u7D9A\u3057\u307E\u3059\u304B\u3002<br>(\u30E6\u30FC\u30B6\u30FC\u540D\u304A\u3088\u3073\u30D1\u30B9\u30EF\u30FC\u30C9\u306F\u30D7\u30EC\u30FC\u30F3\u30FB\u30C6\u30AD\u30B9\u30C8\u3067\u9001\u4FE1\u3055\u308C\u307E\u3059\u3002)
 CONNECTION_LOST1=\u63A5\u7D9A\u304C\u5931\u308F\u308C\u307E\u3057\u305F: \u518D\u63A5\u7D9A\u3057\u307E\u3059\u304B\u3002
 CONNECTING_TO1={0}\u306B\u63A5\u7D9A\u4E2D
 CONNECTING_TO2={0}\u306B\u73FE\u5728\u63A5\u7D9A\u4E2D\u3067\u3059\u3002<br>\u3053\u308C\u306B\u306F\u6570\u5206\u304B\u304B\u308A\u307E\u3059\u3002
@@ -270,4 +274,4 @@
 KBYTES={0} KB
 PLOT=\u30D7\u30ED\u30C3\u30C8
 VISUALIZE=\u8996\u899A\u5316
-ZZ_USAGE_TEXT=\u4F7F\u7528\u65B9\u6CD5: {0} [ -interval=n ] [ -notile ] [ -pluginpath <path> ] [ -version ] [ connection ... ]\n\n  -interval   \u66F4\u65B0\u9593\u9694\u3092n\u79D2\u306B\u8A2D\u5B9A\u3059\u308B(\u30C7\u30D5\u30A9\u30EB\u30C8\u306F4\u79D2)\n  -notile     \u30A6\u30A3\u30F3\u30C9\u30A6\u3092\u6700\u521D\u306B\u4E26\u3079\u3066\u8868\u793A\u3057\u306A\u3044(2\u3064\u4EE5\u4E0A\u306E\u63A5\u7D9A\u306B\u3064\u3044\u3066)\n  -pluginpath JConsole\u304C\u30D7\u30E9\u30B0\u30A4\u30F3\u3092\u53C2\u7167\u3059\u308B\u305F\u3081\u306B\u4F7F\u7528\u3059\u308B\u30D1\u30B9\u3092\u6307\u5B9A\u3059\u308B\n  -version    \u30D7\u30ED\u30B0\u30E9\u30E0\u30FB\u30D0\u30FC\u30B8\u30E7\u30F3\u3092\u5370\u5237\u3059\u308B\n\n  connection = pid || host:port || JMX URL (service:jmx:<protocol>://...)\n  pid         \u30BF\u30FC\u30B2\u30C3\u30C8\u30FB\u30D7\u30ED\u30BB\u30B9\u306E\u30D7\u30ED\u30BB\u30B9ID\n  host        \u30EA\u30E2\u30FC\u30C8\u30FB\u30DB\u30B9\u30C8\u540D\u307E\u305F\u306FIP\u30A2\u30C9\u30EC\u30B9\n  port        \u30EA\u30E2\u30FC\u30C8\u63A5\u7D9A\u7528\u306E\u30DD\u30FC\u30C8\u756A\u53F7\n\n  -J          JConsole\u304C\u5B9F\u884C\u4E2D\u306EJava\u4EEE\u60F3\u30DE\u30B7\u30F3\u3078\u306E\n              \u5165\u529B\u5F15\u6570\u3092\u6307\u5B9A\u3059\u308B
+ZZ_USAGE_TEXT=\u4F7F\u7528\u65B9\u6CD5: {0} [ -interval=n ] [ -notile ] [ -pluginpath <path> ] [ -version ] [ connection ... ]\n\n  -interval   \u66F4\u65B0\u9593\u9694\u3092n\u79D2\u306B\u8A2D\u5B9A\u3059\u308B(\u30C7\u30D5\u30A9\u30EB\u30C8\u306F4\u79D2)\n  -notile     \u30A6\u30A3\u30F3\u30C9\u30A6\u3092\u6700\u521D\u306B\u4E26\u3079\u3066\u8868\u793A\u3057\u306A\u3044(2\u3064\u4EE5\u4E0A\u306E\u63A5\u7D9A\u306B\u3064\u3044\u3066)\n  -pluginpath JConsole\u304C\u30D7\u30E9\u30B0\u30A4\u30F3\u3092\u53C2\u7167\u3059\u308B\u305F\u3081\u306B\u4F7F\u7528\u3059\u308B\u30D1\u30B9\u3092\u6307\u5B9A\u3059\u308B\n  -version    \u30D7\u30ED\u30B0\u30E9\u30E0\u30FB\u30D0\u30FC\u30B8\u30E7\u30F3\u3092\u51FA\u529B\u3059\u308B\n\n  connection = pid || host:port || JMX URL (service:jmx:<protocol>://...)\n  pid         \u30BF\u30FC\u30B2\u30C3\u30C8\u30FB\u30D7\u30ED\u30BB\u30B9\u306E\u30D7\u30ED\u30BB\u30B9ID\n  host        \u30EA\u30E2\u30FC\u30C8\u30FB\u30DB\u30B9\u30C8\u540D\u307E\u305F\u306FIP\u30A2\u30C9\u30EC\u30B9\n  port        \u30EA\u30E2\u30FC\u30C8\u63A5\u7D9A\u7528\u306E\u30DD\u30FC\u30C8\u756A\u53F7\n\n  -J          JConsole\u304C\u5B9F\u884C\u4E2D\u306EJava\u4EEE\u60F3\u30DE\u30B7\u30F3\u3078\u306E\n              \u5165\u529B\u5F15\u6570\u3092\u6307\u5B9A\u3059\u308B
--- ./jdk/src/share/classes/sun/tools/jconsole/resources/messages_zh_CN.properties	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/sun/tools/jconsole/resources/messages_zh_CN.properties	Wed May 07 19:26:47 2014 -0700
@@ -161,7 +161,7 @@
 MESSAGE=\u6D88\u606F
 METHOD_SUCCESSFULLY_INVOKED=\u5DF2\u6210\u529F\u8C03\u7528\u65B9\u6CD5
 MINIMIZE_ALL=\u5168\u90E8\u6700\u5C0F\u5316(&M)
-MONITOR_LOCKED=\ \ \ - \u5DF2\u9501\u5B9A {0}\n
+MONITOR_LOCKED=\   - \u5DF2\u9501\u5B9A {0}\n
 NAME=\u540D\u79F0
 NAME_AND_BUILD={0} (\u5DE5\u4F5C\u7248\u672C {1})
 NAME_STATE=\u540D\u79F0: {0}\n\u72B6\u6001: {1}\n
@@ -205,6 +205,7 @@
 PROCESS_CPU_TIME=\u8FDB\u7A0B CPU \u65F6\u95F4
 READABLE=\u53EF\u8BFB
 RECONNECT=\u91CD\u65B0\u8FDE\u63A5
+INSECURE=\u4E0D\u5B89\u5168
 REMOTE_PROCESS_COLON=\u8FDC\u7A0B\u8FDB\u7A0B(&R):
 REMOTE_PROCESS_TEXT_FIELD_ACCESSIBLE_NAME=\u8FDC\u7A0B\u8FDB\u7A0B
 RESTORE_ALL=\u5168\u90E8\u8FD8\u539F(&R)
@@ -222,6 +223,7 @@
 SUMMARY_TAB_TAB_NAME=VM \u6982\u8981
 SUMMARY_TAB_VM_VERSION={0}\u7248\u672C {1}
 THREADS=\u7EBF\u7A0B
+THREAD_TAB_INFO_LABEL_FORMAT=<html>\u6D3B\u52A8: {0}    \u5CF0\u503C: {1}    \u603B\u8BA1: {2}</html>
 THREAD_TAB_THREAD_INFO_ACCESSIBLE_NAME=\u7EBF\u7A0B\u4FE1\u606F
 THREAD_TAB_THREAD_PLOTTER_ACCESSIBLE_NAME=\u8868\u793A\u7EBF\u7A0B\u6570\u7684\u56FE\u8868\u3002
 THRESHOLD=\u9608\u503C
@@ -243,7 +245,7 @@
 UNREGISTER=\u6CE8\u9500
 UPTIME=\u8FD0\u884C\u65F6\u95F4
 USAGE_THRESHOLD=\u7528\u6CD5\u9608\u503C
-REMOTE_TF_USAGE=<b>\u7528\u6CD5</b>: &lt;hostname&gt;:&lt;port&gt; \u6216 service:jmx:&lt;protocol&gt;:&lt;sap&gt;
+REMOTE_TF_USAGE=<b>\u7528\u6CD5</b>: &&lt;hostname&&gt;:&&lt;port&&gt; \u6216 service:jmx:&&lt;protocol&&gt;:&&lt;sap&&gt;
 USED=\u5DF2\u7528
 USERNAME_COLON_=\u7528\u6237\u540D(&U):
 USERNAME_ACCESSIBLE_NAME=\u7528\u6237\u540D
@@ -261,6 +263,8 @@
 WRITABLE=\u53EF\u5199\u5165
 CONNECTION_FAILED1=\u8FDE\u63A5\u5931\u8D25: \u662F\u5426\u91CD\u8BD5?
 CONNECTION_FAILED2=\u672A\u6210\u529F\u8FDE\u63A5\u5230{0}\u3002<br>\u662F\u5426\u8981\u91CD\u8BD5?
+CONNECTION_FAILED_SSL1=\u5B89\u5168\u8FDE\u63A5\u5931\u8D25\u3002\u662F\u5426\u4EE5\u4E0D\u5B89\u5168\u7684\u65B9\u5F0F\u91CD\u8BD5?
+CONNECTION_FAILED_SSL2=\u65E0\u6CD5\u4F7F\u7528 SSL \u8FDE\u63A5\u5230{0}\u3002<br>\u662F\u5426\u5728\u4E0D\u4F7F\u7528 SSL \u7684\u60C5\u51B5\u4E0B\u8FDB\u884C\u5C1D\u8BD5?<br>(\u7528\u6237\u540D\u548C\u53E3\u4EE4\u5C06\u4EE5\u7EAF\u6587\u672C\u683C\u5F0F\u53D1\u9001\u3002)
 CONNECTION_LOST1=\u8FDE\u63A5\u4E22\u5931: \u662F\u5426\u91CD\u65B0\u8FDE\u63A5?
 CONNECTING_TO1=\u6B63\u5728\u8FDE\u63A5\u5230{0}
 CONNECTING_TO2=\u60A8\u5F53\u524D\u6B63\u5728\u8FDE\u63A5\u5230{0}\u3002<br>\u8FD9\u5C06\u9700\u8981\u51E0\u5206\u949F\u7684\u65F6\u95F4\u3002
--- ./jdk/src/share/classes/sun/util/logging/resources/logging.properties	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/sun/util/logging/resources/logging.properties	Wed May 07 19:26:47 2014 -0700
@@ -27,20 +27,20 @@
 # these are the same as the non-localized level name.
 
 # The following ALL CAPS words should be translated.
-ALL=ALL
+ALL=All
 # The following ALL CAPS words should be translated.
-SEVERE=SEVERE
+SEVERE=Severe
 # The following ALL CAPS words should be translated.
-WARNING=WARNING
+WARNING=Warning
 # The following ALL CAPS words should be translated.
-INFO=INFO
+INFO=Info
 # The following ALL CAPS words should be translated.
-CONFIG= CONFIG
+CONFIG= Config
 # The following ALL CAPS words should be translated.
-FINE=FINE
+FINE=Fine
 # The following ALL CAPS words should be translated.
-FINER=FINER
+FINER=Finer
 # The following ALL CAPS words should be translated.
-FINEST=FINEST
+FINEST=Finest
 # The following ALL CAPS words should be translated.
-OFF=OFF
+OFF=Off
--- ./jdk/src/share/classes/sun/util/logging/resources/logging_zh_TW.properties	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/sun/util/logging/resources/logging_zh_TW.properties	Wed May 07 19:26:47 2014 -0700
@@ -27,7 +27,7 @@
 # these are the same as the non-localized level name.
 
 # The following ALL CAPS words should be translated.
-ALL=\u5168\u90E8
+ALL=\u6240\u6709
 # The following ALL CAPS words should be translated.
 SEVERE=\u56B4\u91CD
 # The following ALL CAPS words should be translated.
--- ./jdk/src/share/classes/sun/util/resources/TimeZoneNames.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/sun/util/resources/TimeZoneNames.java	Wed May 07 19:26:47 2014 -0700
@@ -477,6 +477,8 @@
             {"Antarctica/South_Pole", NZST},
             {"Antarctica/Syowa", new String[] {"Syowa Time", "SYOT",
                                                "Syowa Summer Time", "SYOST"}},
+            {"Antarctica/Troll", new String[] {"Coordinated Universal Time", "UTC",
+                                               "Central European Summer Time", "CEST"}},
             {"Antarctica/Vostok", new String[] {"Vostok Time", "VOST",
                                                 "Vostok Summer Time", "VOSST"}},
             {"Arctic/Longyearbyen", CET},
@@ -707,7 +709,7 @@
                                             "Samara Summer Time", "SAMST"}},
             {"Europe/San_Marino", CET},
             {"Europe/Sarajevo", CET},
-            {"Europe/Simferopol", EET},
+            {"Europe/Simferopol", MSK},
             {"Europe/Skopje", CET},
             {"Europe/Sofia", EET},
             {"Europe/Stockholm", CET},
--- ./jdk/src/share/classes/sun/util/resources/TimeZoneNames_de.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/sun/util/resources/TimeZoneNames_de.java	Wed May 07 19:26:47 2014 -0700
@@ -477,6 +477,8 @@
             {"Antarctica/South_Pole", NZST},
             {"Antarctica/Syowa", new String[] {"Syowa Zeit", "SYOT",
                                                "Syowa Sommerzeit", "SYOST"}},
+            {"Antarctica/Troll", new String[] {"Koordinierte Universalzeit", "UTC",
+                                               "Mitteleurop\u00e4ische Sommerzeit", "MESZ"}},
             {"Antarctica/Vostok", new String[] {"Vostok Zeit", "VOST",
                                                 "Vostok Sommerzeit", "VOSST"}},
             {"Arctic/Longyearbyen", CET},
@@ -707,7 +709,7 @@
                                             "Samarische Sommerzeit", "SAMST"}},
             {"Europe/San_Marino", CET},
             {"Europe/Sarajevo", CET},
-            {"Europe/Simferopol", EET},
+            {"Europe/Simferopol", MSK},
             {"Europe/Skopje", CET},
             {"Europe/Sofia", EET},
             {"Europe/Stockholm", CET},
--- ./jdk/src/share/classes/sun/util/resources/TimeZoneNames_es.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/sun/util/resources/TimeZoneNames_es.java	Wed May 07 19:26:47 2014 -0700
@@ -477,6 +477,8 @@
             {"Antarctica/South_Pole", NZST},
             {"Antarctica/Syowa", new String[] {"Hora de Syowa", "SYOT",
                                                "Hora de verano de Syowa", "SYOST"}},
+            {"Antarctica/Troll", new String[] {"Hora Universal Coordinada", "UTC",
+                                               "Hora de verano de Europa Central", "CEST"}},
             {"Antarctica/Vostok", new String[] {"Hora de Vostok", "VOST",
                                                 "Hora de verano de Vostok", "VOSST"}},
             {"Arctic/Longyearbyen", CET},
@@ -707,7 +709,7 @@
                                             "Hora de verano de Samara", "SAMST"}},
             {"Europe/San_Marino", CET},
             {"Europe/Sarajevo", CET},
-            {"Europe/Simferopol", EET},
+            {"Europe/Simferopol", MSK},
             {"Europe/Skopje", CET},
             {"Europe/Sofia", EET},
             {"Europe/Stockholm", CET},
--- ./jdk/src/share/classes/sun/util/resources/TimeZoneNames_fr.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/sun/util/resources/TimeZoneNames_fr.java	Wed May 07 19:26:47 2014 -0700
@@ -477,6 +477,8 @@
             {"Antarctica/South_Pole", NZST},
             {"Antarctica/Syowa", new String[] {"Heure de Syowa", "SYOT",
                                                "Heure d'\u00e9t\u00e9 de Syowa", "SYOST"}},
+            {"Antarctica/Troll", new String[] {"Temps universel coordonn\u00e9", "UTC",
+                                               "Heure d'\u00e9t\u00e9 d'Europe centrale", "CEST"}},
             {"Antarctica/Vostok", new String[] {"Heure de Vostok", "VOST",
                                                 "Heure d'\u00e9t\u00e9 de Vostok", "VOSST"}},
             {"Arctic/Longyearbyen", CET},
@@ -707,7 +709,7 @@
                                             "Heure d'\u00e9t\u00e9 de Samara", "SAMST"}},
             {"Europe/San_Marino", CET},
             {"Europe/Sarajevo", CET},
-            {"Europe/Simferopol", EET},
+            {"Europe/Simferopol", MSK},
             {"Europe/Skopje", CET},
             {"Europe/Sofia", EET},
             {"Europe/Stockholm", CET},
--- ./jdk/src/share/classes/sun/util/resources/TimeZoneNames_it.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/sun/util/resources/TimeZoneNames_it.java	Wed May 07 19:26:47 2014 -0700
@@ -477,6 +477,8 @@
             {"Antarctica/South_Pole", NZST},
             {"Antarctica/Syowa", new String[] {"Ora di Syowa", "SYOT",
                                                "Ora estiva di Syowa", "SYOST"}},
+            {"Antarctica/Troll", new String[] {"Tempo universale coordinato", "UTC",
+                                               "Ora estiva dell'Europa centrale", "CEST"}},
             {"Antarctica/Vostok", new String[] {"Ora di Vostok", "VOST",
                                                 "Ora estiva di Vostok", "VOSST"}},
             {"Arctic/Longyearbyen", CET},
@@ -707,7 +709,7 @@
                                             "Ora estiva di Samara", "SAMST"}},
             {"Europe/San_Marino", CET},
             {"Europe/Sarajevo", CET},
-            {"Europe/Simferopol", EET},
+            {"Europe/Simferopol", MSK},
             {"Europe/Skopje", CET},
             {"Europe/Sofia", EET},
             {"Europe/Stockholm", CET},
--- ./jdk/src/share/classes/sun/util/resources/TimeZoneNames_ja.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/sun/util/resources/TimeZoneNames_ja.java	Wed May 07 19:26:47 2014 -0700
@@ -477,6 +477,8 @@
             {"Antarctica/South_Pole", NZST},
             {"Antarctica/Syowa", new String[] {"\u662d\u548c\u57fa\u5730\u6642\u9593", "SYOT",
                                                "\u662d\u548c\u57fa\u5730\u590f\u6642\u9593", "SYOST"}},
+            {"Antarctica/Troll", new String[] {"\u5354\u5b9a\u4e16\u754c\u6642", "UTC",
+                                               "\u4e2d\u90e8\u30e8\u30fc\u30ed\u30c3\u30d1\u590f\u6642\u9593", "CEST"}},
             {"Antarctica/Vostok", new String[] {"\u30dc\u30b9\u30c8\u30fc\u30af\u57fa\u5730\u6642\u9593", "VOST",
                                                 "\u30dc\u30b9\u30c8\u30fc\u30af\u57fa\u5730\u590f\u6642\u9593", "VOSST"}},
             {"Arctic/Longyearbyen", CET},
@@ -707,7 +709,7 @@
                                             "\u30b5\u30de\u30e9\u590f\u6642\u9593", "SAMST"}},
             {"Europe/San_Marino", CET},
             {"Europe/Sarajevo", CET},
-            {"Europe/Simferopol", EET},
+            {"Europe/Simferopol", MSK},
             {"Europe/Skopje", CET},
             {"Europe/Sofia", EET},
             {"Europe/Stockholm", CET},
--- ./jdk/src/share/classes/sun/util/resources/TimeZoneNames_ko.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/sun/util/resources/TimeZoneNames_ko.java	Wed May 07 19:26:47 2014 -0700
@@ -477,6 +477,8 @@
             {"Antarctica/South_Pole", NZST},
             {"Antarctica/Syowa", new String[] {"Syowa \uc2dc\uac04", "SYOT",
                                                "Syowa \uc77c\uad11\uc808\uc57d\uc2dc\uac04", "SYOST"}},
+            {"Antarctica/Troll", new String[] {"\uc138\uacc4 \ud45c\uc900\uc2dc", "UTC",
+                                               "\uc911\uc559 \uc720\ub7fd \uc77c\uad11\uc808\uc57d\uc2dc\uac04", "CEST"}},
             {"Antarctica/Vostok", new String[] {"Vostok \uc2dc\uac04", "VOST",
                                                 "Vostok \uc77c\uad11\uc808\uc57d\uc2dc\uac04", "VOSST"}},
             {"Arctic/Longyearbyen", CET},
@@ -707,7 +709,7 @@
                                             "\uc0ac\ub9c8\ub77c \uc77c\uad11\uc808\uc57d\uc2dc\uac04", "SAMST"}},
             {"Europe/San_Marino", CET},
             {"Europe/Sarajevo", CET},
-            {"Europe/Simferopol", EET},
+            {"Europe/Simferopol", MSK},
             {"Europe/Skopje", CET},
             {"Europe/Sofia", EET},
             {"Europe/Stockholm", CET},
--- ./jdk/src/share/classes/sun/util/resources/TimeZoneNames_pt_BR.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/sun/util/resources/TimeZoneNames_pt_BR.java	Wed May 07 19:26:47 2014 -0700
@@ -477,6 +477,8 @@
             {"Antarctica/South_Pole", NZST},
             {"Antarctica/Syowa", new String[] {"Fuso hor\u00e1rio de Syowa", "SYOT",
                                                "Fuso hor\u00e1rio de ver\u00e3o de Syowa", "SYOST"}},
+            {"Antarctica/Troll", new String[] {"Tempo universal coordenado", "UTC",
+                                               "Fuso hor\u00e1rio de ver\u00e3o da Europa Central", "CEST"}},
             {"Antarctica/Vostok", new String[] {"Fuso hor\u00e1rio de Vostok", "VOST",
                                                 "Fuso hor\u00e1rio de ver\u00e3o de Vostok", "VOSST"}},
             {"Arctic/Longyearbyen", CET},
@@ -707,7 +709,7 @@
                                             "Fuso hor\u00e1rio de ver\u00e3o de Samara", "SAMST"}},
             {"Europe/San_Marino", CET},
             {"Europe/Sarajevo", CET},
-            {"Europe/Simferopol", EET},
+            {"Europe/Simferopol", MSK},
             {"Europe/Skopje", CET},
             {"Europe/Sofia", EET},
             {"Europe/Stockholm", CET},
--- ./jdk/src/share/classes/sun/util/resources/TimeZoneNames_sv.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/sun/util/resources/TimeZoneNames_sv.java	Wed May 07 19:26:47 2014 -0700
@@ -477,6 +477,8 @@
             {"Antarctica/South_Pole", NZST},
             {"Antarctica/Syowa", new String[] {"Syowa, normaltid", "SYOT",
                                                "Syowa, sommartid", "SYOST"}},
+            {"Antarctica/Troll", new String[] {"Koordinerad universell tid", "UTC",
+                                               "Centraleuropeisk sommartid", "CEST"}},
             {"Antarctica/Vostok", new String[] {"Vostok, normaltid", "VOST",
                                                 "Vostok, sommartid", "VOSST"}},
             {"Arctic/Longyearbyen", CET},
@@ -707,7 +709,7 @@
                                             "Samara, sommartid", "SAMST"}},
             {"Europe/San_Marino", CET},
             {"Europe/Sarajevo", CET},
-            {"Europe/Simferopol", EET},
+            {"Europe/Simferopol", MSK},
             {"Europe/Skopje", CET},
             {"Europe/Sofia", EET},
             {"Europe/Stockholm", CET},
--- ./jdk/src/share/classes/sun/util/resources/TimeZoneNames_zh_CN.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/sun/util/resources/TimeZoneNames_zh_CN.java	Wed May 07 19:26:47 2014 -0700
@@ -477,6 +477,8 @@
             {"Antarctica/South_Pole", NZST},
             {"Antarctica/Syowa", new String[] {"Syowa \u65f6\u95f4", "SYOT",
                                                "Syowa \u590f\u4ee4\u65f6", "SYOST"}},
+            {"Antarctica/Troll", new String[] {"\u534f\u8c03\u4e16\u754c\u65f6\u95f4", "UTC",
+                                               "\u4e2d\u6b27\u590f\u4ee4\u65f6", "CEST"}},
             {"Antarctica/Vostok", new String[] {"\u83ab\u65af\u6258\u514b\u65f6\u95f4", "VOST",
                                                 "\u83ab\u65af\u6258\u514b\u590f\u4ee4\u65f6", "VOSST"}},
             {"Arctic/Longyearbyen", CET},
@@ -707,7 +709,7 @@
                                             "\u6c99\u9a6c\u62c9\u590f\u4ee4\u65f6", "SAMST"}},
             {"Europe/San_Marino", CET},
             {"Europe/Sarajevo", CET},
-            {"Europe/Simferopol", EET},
+            {"Europe/Simferopol", MSK},
             {"Europe/Skopje", CET},
             {"Europe/Sofia", EET},
             {"Europe/Stockholm", CET},
--- ./jdk/src/share/classes/sun/util/resources/TimeZoneNames_zh_TW.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/classes/sun/util/resources/TimeZoneNames_zh_TW.java	Wed May 07 19:26:47 2014 -0700
@@ -477,6 +477,8 @@
             {"Antarctica/South_Pole", NZST},
             {"Antarctica/Syowa", new String[] {"\u5915\u6b50\u74e6 (Syowa) \u6642\u9593", "SYOT",
                                                "\u5915\u6b50\u74e6 (Syowa) \u590f\u4ee4\u6642\u9593", "SYOST"}},
+            {"Antarctica/Troll", new String[] {"\u5354\u8abf\u4e16\u754c\u6642\u9593", "UTC",
+                                               "\u4e2d\u6b50\u590f\u4ee4\u6642\u9593", "CEST"}},
             {"Antarctica/Vostok", new String[] {"\u4f5b\u65af\u6258 (Vostok) \u6642\u9593", "VOST",
                                                 "\u4f5b\u65af\u6258 (Vostok) \u590f\u4ee4\u6642\u9593", "VOSST"}},
             {"Arctic/Longyearbyen", CET},
@@ -708,7 +710,7 @@
                                             "\u6c99\u99ac\u62c9\u590f\u4ee4\u6642\u9593", "SAMST"}},
             {"Europe/San_Marino", CET},
             {"Europe/Sarajevo", CET},
-            {"Europe/Simferopol", EET},
+            {"Europe/Simferopol", MSK},
             {"Europe/Skopje", CET},
             {"Europe/Sofia", EET},
             {"Europe/Stockholm", CET},
--- ./jdk/src/share/demo/jvmti/hprof/hprof_init.c	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/demo/jvmti/hprof/hprof_init.c	Wed May 07 19:26:47 2014 -0700
@@ -1899,11 +1899,17 @@
      */
     getSystemProperty("sun.boot.library.path", &boot_path);
     md_build_library_name(lname, FILENAME_MAX, boot_path, name);
+    if ( strlen(lname) == 0 ) {
+        HPROF_ERROR(JNI_TRUE, "Could not find library");
+    }
     jvmtiDeallocate(boot_path);
     handle = md_load_library(lname, err_buf, (int)sizeof(err_buf));
     if ( handle == NULL ) {
         /* This may be necessary on Windows. */
         md_build_library_name(lname, FILENAME_MAX, "", name);
+        if ( strlen(lname) == 0 ) {
+            HPROF_ERROR(JNI_TRUE, "Could not find library");
+        }
         handle = md_load_library(lname, err_buf, (int)sizeof(err_buf));
         if ( handle == NULL ) {
             HPROF_ERROR(JNI_TRUE, err_buf);
@@ -1968,6 +1974,9 @@
     getSystemProperty("sun.boot.library.path", &boot_path);
     /* Load in NPT library for character conversions */
     md_build_library_name(npt_lib, sizeof(npt_lib), boot_path, NPT_LIBNAME);
+    if ( strlen(npt_lib) == 0 ) {
+        HPROF_ERROR(JNI_TRUE, "Could not find npt library");
+    }
     jvmtiDeallocate(boot_path);
     NPT_INITIALIZE(npt_lib, &(gdata->npt), NPT_VERSION, NULL);
     if ( gdata->npt == NULL ) {
--- ./jdk/src/share/demo/jvmti/hprof/hprof_md.h	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/demo/jvmti/hprof/hprof_md.h	Wed May 07 19:26:47 2014 -0700
@@ -69,7 +69,7 @@
 unsigned md_ntohs(unsigned short s);
 unsigned md_ntohl(unsigned l);
 
-void   md_build_library_name(char *holder, int holderlen, char *pname, char *fname);
+void   md_build_library_name(char *holder, int holderlen, const char *pname, const char *fname);
 void * md_load_library(const char *name, char *err_buf, int err_buflen);
 void   md_unload_library(void *handle);
 void * md_find_library_entry(void *handle, const char *name);
--- ./jdk/src/share/demo/scripting/jconsole-plugin/src/com/sun/demo/scripting/jconsole/ScriptShellPanel.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/demo/scripting/jconsole-plugin/src/com/sun/demo/scripting/jconsole/ScriptShellPanel.java	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2006, 2013 Oracle and/or its affiliates. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -54,7 +54,7 @@
  * jconsole's script console.
  */
 
-class ScriptShellPanel extends JPanel {
+public class ScriptShellPanel extends JPanel {
 
     private static final long serialVersionUID = 4116273141148726319L;
 
--- ./jdk/src/share/native/com/sun/java/util/jar/pack/zip.cpp	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/native/com/sun/java/util/jar/pack/zip.cpp	Wed May 07 19:26:47 2014 -0700
@@ -62,7 +62,7 @@
 
 #endif // End of ZLIB
 
-#ifdef sparc
+#ifdef _BIG_ENDIAN
 #define SWAP_BYTES(a) \
     ((((a) << 8) & 0xff00) | 0x00ff) & (((a) >> 8) | 0xff00)
 #else
--- ./jdk/src/share/native/common/check_code.c	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/native/common/check_code.c	Wed May 07 19:26:47 2014 -0700
@@ -90,6 +90,12 @@
 #include "classfile_constants.h"
 #include "opcodes.in_out"
 
+#ifdef __APPLE__
+/* use setjmp/longjmp versions that do not save/restore the signal mask */
+#define setjmp _setjmp
+#define longjmp _longjmp
+#endif
+
 #define MAX_ARRAY_DIMENSIONS 255
 /* align byte code */
 #ifndef ALIGN_UP
--- ./jdk/src/share/native/java/lang/Class.c	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/native/java/lang/Class.c	Wed May 07 19:26:47 2014 -0700
@@ -187,3 +187,16 @@
 
     return result;
 }
+
+JNIEXPORT jobject JNICALL
+Java_java_lang_Class_getCheckMemberAccessMethod(JNIEnv *env, jclass cls, jclass smClass)
+{
+    jmethodID mid;
+
+    mid = (*env)->GetMethodID(env, smClass, "checkMemberAccess", "(Ljava/lang/Class;I)V");
+    if (mid == NULL) {
+        return NULL;
+    }
+    return (*env)->ToReflectedMethod(env, smClass, mid, JNI_FALSE);
+}
+
--- ./jdk/src/share/native/java/lang/ref/Finalizer.c	Tue Mar 18 12:35:25 2014 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,42 +0,0 @@
-/*
- * Copyright (c) 1997, 1998, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-#include "jni.h"
-#include "java_lang_ref_Finalizer.h"
-
-
-JNIEXPORT void JNICALL
-Java_java_lang_ref_Finalizer_invokeFinalizeMethod(JNIEnv *env, jclass clazz,
-                                                  jobject ob)
-{
-    jclass cls;
-    jmethodID mid;
-
-    cls = (*env)->GetObjectClass(env, ob);
-    if (cls == NULL) return;
-    mid = (*env)->GetMethodID(env, cls, "finalize", "()V");
-    if (mid == NULL) return;
-    (*env)->CallVoidMethod(env, ob, mid);
-}
--- ./jdk/src/share/native/sun/security/krb5/nativeccache.c	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/share/native/sun/security/krb5/nativeccache.c	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011,2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -264,13 +264,22 @@
 
 }
 
+int isIn(krb5_enctype e, int n, jint* etypes)
+{
+    int i;
+    for (i=0; i<n; i++) {
+        if (e == etypes[i]) return 1;
+    }
+    return 0;
+}
+
 /*
  * Class:     sun_security_krb5_Credentials
  * Method:    acquireDefaultNativeCreds
  * Signature: ()Lsun/security/krb5/Credentials;
  */
 JNIEXPORT jobject JNICALL Java_sun_security_krb5_Credentials_acquireDefaultNativeCreds
-(JNIEnv *env, jclass krbcredsClass)
+(JNIEnv *env, jclass krbcredsClass, jintArray jetypes)
 {
     jobject krbCreds = NULL;
     krb5_error_code err = 0;
@@ -279,6 +288,8 @@
     krb5_creds creds;
     krb5_flags flags = 0;
     krb5_context kcontext = NULL;
+    int netypes;
+    jint *etypes = NULL;
 
     /* Initialize the Kerberos 5 context */
     err = krb5_init_context (&kcontext);
@@ -295,6 +306,9 @@
         err = krb5_cc_start_seq_get (kcontext, ccache, &cursor);
     }
 
+    netypes = (*env)->GetArrayLength(env, jetypes);
+    etypes = (jint *) (*env)->GetIntArrayElements(env, jetypes, NULL);
+
     if (!err) {
         while ((err = krb5_cc_next_cred (kcontext, ccache, &cursor, &creds)) == 0) {
             char *serverName = NULL;
@@ -305,7 +319,8 @@
             }
 
             if (!err) {
-                if (strncmp (serverName, "krbtgt", strlen("krbtgt")) == 0) {
+                if (strncmp (serverName, "krbtgt", sizeof("krbtgt")-1) == 0 &&
+                        isIn(creds.keyblock.enctype, netypes, etypes)) {
                     jobject ticket, clientPrincipal, targetPrincipal, encryptionKey;
                     jobject ticketFlags, startTime, endTime;
                     jobject authTime, renewTillTime, hostAddresses;
@@ -321,7 +336,7 @@
                     targetPrincipal = BuildClientPrincipal(env, kcontext, creds.server);
                     if (targetPrincipal == NULL) goto cleanup;
 
-                    // Build a com.ibm.security.krb5.Ticket
+                    // Build a sun/security/krb5/internal/Ticket
                     ticket = BuildTicket(env, &creds.ticket);
                     if (ticket == NULL) goto cleanup;
 
@@ -353,7 +368,7 @@
                         krbcredsConstructor = (*env)->GetMethodID(env, krbcredsClass, "<init>",
                                                                   "(Lsun/security/krb5/internal/Ticket;Lsun/security/krb5/PrincipalName;Lsun/security/krb5/PrincipalName;Lsun/security/krb5/EncryptionKey;Lsun/security/krb5/internal/TicketFlags;Lsun/security/krb5/internal/KerberosTime;Lsun/security/krb5/internal/KerberosTime;Lsun/security/krb5/internal/KerberosTime;Lsun/security/krb5/internal/KerberosTime;Lsun/security/krb5/internal/HostAddresses;)V");
                         if (krbcredsConstructor == 0) {
-                            printf("Couldn't find com.ibm.security.krb5.Credentials constructor\n");
+                            printf("Couldn't find sun.security.krb5.internal.Ticket constructor\n");
                             break;
                         }
                     }
@@ -409,6 +424,10 @@
         printiferr (err, "while finishing ticket retrieval");
     }
 
+    if (etypes != NULL) {
+        (*env)->ReleaseIntArrayElements(env, jetypes, etypes, 0);
+    }
+
     krb5_free_context (kcontext);
     return krbCreds;
 }
--- ./jdk/src/solaris/back/linker_md.c	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/solaris/back/linker_md.c	Wed May 07 19:26:47 2014 -0700
@@ -55,29 +55,27 @@
 #endif
 
 static void dll_build_name(char* buffer, size_t buflen,
-                           const char* pname, const char* fname) {
-    // Based on os_solaris.cpp
+                           const char* paths, const char* fname) {
+    char *path, *paths_copy, *next_token;
 
-    char *path_sep = PATH_SEPARATOR;
-    char *pathname = (char *)pname;
-    while (strlen(pathname) > 0) {
-        char *p = strchr(pathname, *path_sep);
-        if (p == NULL) {
-            p = pathname + strlen(pathname);
-        }
-        /* check for NULL path */
-        if (p == pathname) {
-            continue;
-        }
-        (void)snprintf(buffer, buflen, "%.*s/lib%s." LIB_SUFFIX, (p - pathname),
-                       pathname, fname);
+    paths_copy = strdup(paths);
+    if (paths_copy == NULL) {
+        return;
+    }
 
+    next_token = NULL;
+    path = strtok_r(paths_copy, PATH_SEPARATOR, &next_token);
+
+    while (path != NULL) {
+        snprintf(buffer, buflen, "%s/lib%s." LIB_SUFFIX, path, fname);
         if (access(buffer, F_OK) == 0) {
             break;
         }
-        pathname = p + 1;
         *buffer = '\0';
+        path = strtok_r(NULL, PATH_SEPARATOR, &next_token);
     }
+
+    free(paths_copy);
 }
 
 /*
@@ -98,7 +96,7 @@
  * appropriate pre and extensions to a filename and the path
  */
 void
-dbgsysBuildLibName(char *holder, int holderlen, char *pname, char *fname)
+dbgsysBuildLibName(char *holder, int holderlen, const char *pname, const char *fname)
 {
     const int pnamelen = pname ? strlen(pname) : 0;
 
--- ./jdk/src/solaris/classes/java/lang/UNIXProcess.java.bsd	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/solaris/classes/java/lang/UNIXProcess.java.bsd	Wed May 07 19:26:47 2014 -0700
@@ -303,40 +303,54 @@
      * able to read any buffered data lingering in the OS pipe buffer.
      */
     static class ProcessPipeInputStream extends BufferedInputStream {
+        private final Object closeLock = new Object();
+
         ProcessPipeInputStream(int fd) {
             super(new FileInputStream(newFileDescriptor(fd)));
         }
 
-        private static byte[] drainInputStream(InputStream in)
+        private InputStream drainInputStream(InputStream in)
                 throws IOException {
-            if (in == null) return null;
             int n = 0;
             int j;
             byte[] a = null;
-            while ((j = in.available()) > 0) {
+            synchronized (closeLock) {
+                if (buf == null) // asynchronous close()?
+                    return null; // discard
+                j = in.available();
+            }
+            while (j > 0) {
                 a = (a == null) ? new byte[j] : Arrays.copyOf(a, n + j);
-                n += in.read(a, n, j);
+                synchronized (closeLock) {
+                    if (buf == null) // asynchronous close()?
+                        return null; // discard
+                    n += in.read(a, n, j);
+                    j = in.available();
+                }
             }
-            return (a == null || n == a.length) ? a : Arrays.copyOf(a, n);
+            return (a == null) ?
+                    ProcessBuilder.NullInputStream.INSTANCE :
+                    new ByteArrayInputStream(n == a.length ? a : Arrays.copyOf(a, n));
         }
 
         /** Called by the process reaper thread when the process exits. */
         synchronized void processExited() {
-            // Most BufferedInputStream methods are synchronized, but close()
-            // is not, and so we have to handle concurrent racing close().
             try {
                 InputStream in = this.in;
                 if (in != null) {
-                    byte[] stragglers = drainInputStream(in);
+                    InputStream stragglers = drainInputStream(in);
                     in.close();
-                    this.in = (stragglers == null) ?
-                        ProcessBuilder.NullInputStream.INSTANCE :
-                        new ByteArrayInputStream(stragglers);
-                    if (buf == null) // asynchronous close()?
-                        this.in = null;
+                    this.in = stragglers;
                 }
-            } catch (IOException ignored) {
-                // probably an asynchronous close().
+            } catch (IOException ignored) { }
+        }
+
+        @Override
+        public void close() throws IOException {
+            // BufferedInputStream#close() is not synchronized unlike most other methods.
+            // Synchronizing helps avoid racing with drainInputStream().
+            synchronized (closeLock) {
+                super.close();
             }
         }
     }
--- ./jdk/src/solaris/classes/java/lang/UNIXProcess.java.linux	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/solaris/classes/java/lang/UNIXProcess.java.linux	Wed May 07 19:26:47 2014 -0700
@@ -305,40 +305,54 @@
      * able to read any buffered data lingering in the OS pipe buffer.
      */
     static class ProcessPipeInputStream extends BufferedInputStream {
+        private final Object closeLock = new Object();
+
         ProcessPipeInputStream(int fd) {
             super(new FileInputStream(newFileDescriptor(fd)));
         }
 
-        private static byte[] drainInputStream(InputStream in)
+        private InputStream drainInputStream(InputStream in)
                 throws IOException {
-            if (in == null) return null;
             int n = 0;
             int j;
             byte[] a = null;
-            while ((j = in.available()) > 0) {
+            synchronized (closeLock) {
+                if (buf == null) // asynchronous close()?
+                    return null; // discard
+                j = in.available();
+            }
+            while (j > 0) {
                 a = (a == null) ? new byte[j] : Arrays.copyOf(a, n + j);
-                n += in.read(a, n, j);
+                synchronized (closeLock) {
+                    if (buf == null) // asynchronous close()?
+                        return null; // discard
+                    n += in.read(a, n, j);
+                    j = in.available();
+                }
             }
-            return (a == null || n == a.length) ? a : Arrays.copyOf(a, n);
+            return (a == null) ?
+                    ProcessBuilder.NullInputStream.INSTANCE :
+                    new ByteArrayInputStream(n == a.length ? a : Arrays.copyOf(a, n));
         }
 
         /** Called by the process reaper thread when the process exits. */
         synchronized void processExited() {
-            // Most BufferedInputStream methods are synchronized, but close()
-            // is not, and so we have to handle concurrent racing close().
             try {
                 InputStream in = this.in;
                 if (in != null) {
-                    byte[] stragglers = drainInputStream(in);
+                    InputStream stragglers = drainInputStream(in);
                     in.close();
-                    this.in = (stragglers == null) ?
-                        ProcessBuilder.NullInputStream.INSTANCE :
-                        new ByteArrayInputStream(stragglers);
-                    if (buf == null) // asynchronous close()?
-                        this.in = null;
+                    this.in = stragglers;
                 }
-            } catch (IOException ignored) {
-                // probably an asynchronous close().
+            } catch (IOException ignored) { }
+        }
+
+        @Override
+        public void close() throws IOException {
+            // BufferedInputStream#close() is not synchronized unlike most other methods.
+            // Synchronizing helps avoid racing with drainInputStream().
+            synchronized (closeLock) {
+                super.close();
             }
         }
     }
--- ./jdk/src/solaris/classes/sun/awt/X11/MotifDnDConstants.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/solaris/classes/sun/awt/X11/MotifDnDConstants.java	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -190,7 +190,7 @@
                 try {
                     Native.putLong(data, motifWindow);
 
-                    XToolkit.WITH_XERROR_HANDLER(XErrorHandler.VerifyChangePropertyHandler.getInstance());
+                    XErrorHandlerUtil.WITH_XERROR_HANDLER(XErrorHandler.VerifyChangePropertyHandler.getInstance());
                     XlibWrapper.XChangeProperty(XToolkit.getDisplay(),
                                                 defaultRootWindow,
                                                 XA_MOTIF_DRAG_WINDOW.getAtom(),
@@ -198,10 +198,10 @@
                                                 XConstants.PropModeReplace,
                                                 data, 1);
 
-                    XToolkit.RESTORE_XERROR_HANDLER();
+                    XErrorHandlerUtil.RESTORE_XERROR_HANDLER();
 
-                    if (XToolkit.saved_error != null &&
-                        XToolkit.saved_error.get_error_code() != XConstants.Success) {
+                    if ((XErrorHandlerUtil.saved_error != null) &&
+                        (XErrorHandlerUtil.saved_error.get_error_code() != XConstants.Success)) {
                         throw new XException("Cannot write motif drag window handle.");
                     }
 
@@ -394,7 +394,7 @@
                 }
             }
 
-            XToolkit.WITH_XERROR_HANDLER(XErrorHandler.VerifyChangePropertyHandler.getInstance());
+            XErrorHandlerUtil.WITH_XERROR_HANDLER(XErrorHandler.VerifyChangePropertyHandler.getInstance());
             XlibWrapper.XChangeProperty(XToolkit.getDisplay(),
                                         motifWindow,
                                         XA_MOTIF_DRAG_TARGETS.getAtom(),
@@ -402,15 +402,15 @@
                                         XConstants.PropModeReplace,
                                         data, tableSize);
 
-            XToolkit.RESTORE_XERROR_HANDLER();
+            XErrorHandlerUtil.RESTORE_XERROR_HANDLER();
 
-            if (XToolkit.saved_error != null &&
-                XToolkit.saved_error.get_error_code() != XConstants.Success) {
+            if ((XErrorHandlerUtil.saved_error != null) &&
+                (XErrorHandlerUtil.saved_error.get_error_code() != XConstants.Success)) {
 
                 // Create a new motif window and retry.
                 motifWindow = createMotifWindow();
 
-                XToolkit.WITH_XERROR_HANDLER(XErrorHandler.VerifyChangePropertyHandler.getInstance());
+                XErrorHandlerUtil.WITH_XERROR_HANDLER(XErrorHandler.VerifyChangePropertyHandler.getInstance());
                 XlibWrapper.XChangeProperty(XToolkit.getDisplay(),
                                             motifWindow,
                                             XA_MOTIF_DRAG_TARGETS.getAtom(),
@@ -418,10 +418,10 @@
                                             XConstants.PropModeReplace,
                                             data, tableSize);
 
-                XToolkit.RESTORE_XERROR_HANDLER();
+                XErrorHandlerUtil.RESTORE_XERROR_HANDLER();
 
-                if (XToolkit.saved_error != null &&
-                    XToolkit.saved_error.get_error_code() != XConstants.Success) {
+                if ((XErrorHandlerUtil.saved_error != null) &&
+                    (XErrorHandlerUtil.saved_error.get_error_code() != XConstants.Success)) {
                     throw new XException("Cannot write motif drag targets property.");
                 }
             }
@@ -534,16 +534,16 @@
             // CARD32 icc_handle
             unsafe.putInt(structData + 4, (int)XA_MOTIF_ATOM_0.getAtom());
 
-            XToolkit.WITH_XERROR_HANDLER(XErrorHandler.VerifyChangePropertyHandler.getInstance());
+            XErrorHandlerUtil.WITH_XERROR_HANDLER(XErrorHandler.VerifyChangePropertyHandler.getInstance());
             XlibWrapper.XChangeProperty(XToolkit.getDisplay(), window,
                                         XA_MOTIF_ATOM_0.getAtom(),
                                         XA_MOTIF_DRAG_INITIATOR_INFO.getAtom(),
                                         8, XConstants.PropModeReplace,
                                         structData, MOTIF_INITIATOR_INFO_SIZE);
-            XToolkit.RESTORE_XERROR_HANDLER();
+            XErrorHandlerUtil.RESTORE_XERROR_HANDLER();
 
-            if (XToolkit.saved_error != null &&
-                XToolkit.saved_error.get_error_code() != XConstants.Success) {
+            if ((XErrorHandlerUtil.saved_error != null) &&
+                (XErrorHandlerUtil.saved_error.get_error_code() != XConstants.Success)) {
                 throw new XException("Cannot write drag initiator info");
             }
         } finally {
@@ -567,16 +567,16 @@
             unsafe.putShort(data + 10, (short)0); /* pad */
             unsafe.putInt(data + 12, dataSize);
 
-            XToolkit.WITH_XERROR_HANDLER(XErrorHandler.VerifyChangePropertyHandler.getInstance());
+            XErrorHandlerUtil.WITH_XERROR_HANDLER(XErrorHandler.VerifyChangePropertyHandler.getInstance());
             XlibWrapper.XChangeProperty(XToolkit.getDisplay(), window,
                                         XA_MOTIF_DRAG_RECEIVER_INFO.getAtom(),
                                         XA_MOTIF_DRAG_RECEIVER_INFO.getAtom(),
                                         8, XConstants.PropModeReplace,
                                         data, dataSize);
-            XToolkit.RESTORE_XERROR_HANDLER();
+            XErrorHandlerUtil.RESTORE_XERROR_HANDLER();
 
-            if (XToolkit.saved_error != null &&
-                XToolkit.saved_error.get_error_code() != XConstants.Success) {
+            if ((XErrorHandlerUtil.saved_error != null) &&
+                (XErrorHandlerUtil.saved_error.get_error_code() != XConstants.Success)) {
                 throw new XException("Cannot write Motif receiver info property");
             }
         } finally {
--- ./jdk/src/solaris/classes/sun/awt/X11/MotifDnDDropTargetProtocol.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/solaris/classes/sun/awt/X11/MotifDnDDropTargetProtocol.java	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -162,16 +162,16 @@
                 unsafe.putInt(data + 12, dataSize);
             }
 
-            XToolkit.WITH_XERROR_HANDLER(XErrorHandler.VerifyChangePropertyHandler.getInstance());
+            XErrorHandlerUtil.WITH_XERROR_HANDLER(XErrorHandler.VerifyChangePropertyHandler.getInstance());
             XlibWrapper.XChangeProperty(XToolkit.getDisplay(), embedder,
                                         MotifDnDConstants.XA_MOTIF_DRAG_RECEIVER_INFO.getAtom(),
                                         MotifDnDConstants.XA_MOTIF_DRAG_RECEIVER_INFO.getAtom(),
                                         8, XConstants.PropModeReplace,
                                         data, dataSize);
-            XToolkit.RESTORE_XERROR_HANDLER();
+            XErrorHandlerUtil.RESTORE_XERROR_HANDLER();
 
-            if (XToolkit.saved_error != null &&
-                XToolkit.saved_error.get_error_code() != XConstants.Success) {
+            if ((XErrorHandlerUtil.saved_error != null) &&
+                (XErrorHandlerUtil.saved_error.get_error_code() != XConstants.Success)) {
                 throw new XException("Cannot write Motif receiver info property");
             }
         } finally {
@@ -236,16 +236,16 @@
 
                     unsafe.putInt(data + 4, tproxy);
 
-                    XToolkit.WITH_XERROR_HANDLER(XErrorHandler.VerifyChangePropertyHandler.getInstance());
+                    XErrorHandlerUtil.WITH_XERROR_HANDLER(XErrorHandler.VerifyChangePropertyHandler.getInstance());
                     XlibWrapper.XChangeProperty(XToolkit.getDisplay(), embedder,
                                                 MotifDnDConstants.XA_MOTIF_DRAG_RECEIVER_INFO.getAtom(),
                                                 MotifDnDConstants.XA_MOTIF_DRAG_RECEIVER_INFO.getAtom(),
                                                 8, XConstants.PropModeReplace,
                                                 data, dataSize);
-                    XToolkit.RESTORE_XERROR_HANDLER();
+                    XErrorHandlerUtil.RESTORE_XERROR_HANDLER();
 
-                    if (XToolkit.saved_error != null &&
-                        XToolkit.saved_error.get_error_code() != XConstants.Success) {
+                    if ((XErrorHandlerUtil.saved_error != null) &&
+                        (XErrorHandlerUtil.saved_error.get_error_code() != XConstants.Success)) {
                         throw new XException("Cannot write Motif receiver info property");
                     }
                 }
@@ -412,15 +412,15 @@
          */
         XWindowAttributes wattr = new XWindowAttributes();
         try {
-            XToolkit.WITH_XERROR_HANDLER(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+            XErrorHandlerUtil.WITH_XERROR_HANDLER(XErrorHandler.IgnoreBadWindowHandler.getInstance());
             int status = XlibWrapper.XGetWindowAttributes(XToolkit.getDisplay(),
                                                           source_win, wattr.pData);
 
-            XToolkit.RESTORE_XERROR_HANDLER();
+            XErrorHandlerUtil.RESTORE_XERROR_HANDLER();
 
-            if (status == 0 ||
-                (XToolkit.saved_error != null &&
-                 XToolkit.saved_error.get_error_code() != XConstants.Success)) {
+            if ((status == 0) ||
+                ((XErrorHandlerUtil.saved_error != null) &&
+                (XErrorHandlerUtil.saved_error.get_error_code() != XConstants.Success))) {
                 throw new XException("XGetWindowAttributes failed");
             }
 
@@ -429,15 +429,15 @@
             wattr.dispose();
         }
 
-        XToolkit.WITH_XERROR_HANDLER(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+        XErrorHandlerUtil.WITH_XERROR_HANDLER(XErrorHandler.IgnoreBadWindowHandler.getInstance());
         XlibWrapper.XSelectInput(XToolkit.getDisplay(), source_win,
                                  source_win_mask |
                                  XConstants.StructureNotifyMask);
 
-        XToolkit.RESTORE_XERROR_HANDLER();
+        XErrorHandlerUtil.RESTORE_XERROR_HANDLER();
 
-        if (XToolkit.saved_error != null &&
-            XToolkit.saved_error.get_error_code() != XConstants.Success) {
+        if ((XErrorHandlerUtil.saved_error != null) &&
+            (XErrorHandlerUtil.saved_error.get_error_code() != XConstants.Success)) {
             throw new XException("XSelectInput failed");
         }
 
@@ -1024,10 +1024,10 @@
         if (sourceWindow != 0) {
             XToolkit.awtLock();
             try {
-                XToolkit.WITH_XERROR_HANDLER(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+                XErrorHandlerUtil.WITH_XERROR_HANDLER(XErrorHandler.IgnoreBadWindowHandler.getInstance());
                 XlibWrapper.XSelectInput(XToolkit.getDisplay(), sourceWindow,
                                          sourceWindowMask);
-                XToolkit.RESTORE_XERROR_HANDLER();
+                XErrorHandlerUtil.RESTORE_XERROR_HANDLER();
             } finally {
                 XToolkit.awtUnlock();
             }
--- ./jdk/src/solaris/classes/sun/awt/X11/WindowPropertyGetter.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/solaris/classes/sun/awt/X11/WindowPropertyGetter.java	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -99,7 +99,7 @@
             }
 
             if (errorHandler != null) {
-                XToolkit.WITH_XERROR_HANDLER(errorHandler);
+                XErrorHandlerUtil.WITH_XERROR_HANDLER(errorHandler);
             }
             Native.putLong(data, 0);
             int status = XlibWrapper.XGetWindowProperty(XToolkit.getDisplay(), window, property.getAtom(),
@@ -112,7 +112,7 @@
             }
 
             if (errorHandler != null) {
-                XToolkit.RESTORE_XERROR_HANDLER();
+                XErrorHandlerUtil.RESTORE_XERROR_HANDLER();
             }
             return status;
         } finally {
--- ./jdk/src/solaris/classes/sun/awt/X11/XConstants.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/solaris/classes/sun/awt/X11/XConstants.java	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2009, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jdk/src/solaris/classes/sun/awt/X11/XDnDDragSourceProtocol.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/solaris/classes/sun/awt/X11/XDnDDragSourceProtocol.java	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -96,14 +96,14 @@
                 action_count++;
             }
 
-            XToolkit.WITH_XERROR_HANDLER(XErrorHandler.VerifyChangePropertyHandler.getInstance());
+            XErrorHandlerUtil.WITH_XERROR_HANDLER(XErrorHandler.VerifyChangePropertyHandler.getInstance());
             XDnDConstants.XA_XdndActionList.setAtomData(window,
                                                         XAtom.XA_ATOM,
                                                         data, action_count);
-            XToolkit.RESTORE_XERROR_HANDLER();
+            XErrorHandlerUtil.RESTORE_XERROR_HANDLER();
 
-            if (XToolkit.saved_error != null &&
-                XToolkit.saved_error.get_error_code() != XConstants.Success) {
+            if ((XErrorHandlerUtil.saved_error != null) &&
+                (XErrorHandlerUtil.saved_error.get_error_code() != XConstants.Success)) {
                 cleanup();
                 throw new XException("Cannot write XdndActionList property");
             }
@@ -117,14 +117,14 @@
         try {
             Native.put(data, formats);
 
-            XToolkit.WITH_XERROR_HANDLER(XErrorHandler.VerifyChangePropertyHandler.getInstance());
+            XErrorHandlerUtil.WITH_XERROR_HANDLER(XErrorHandler.VerifyChangePropertyHandler.getInstance());
             XDnDConstants.XA_XdndTypeList.setAtomData(window,
                                                       XAtom.XA_ATOM,
                                                       data, formats.length);
-            XToolkit.RESTORE_XERROR_HANDLER();
+            XErrorHandlerUtil.RESTORE_XERROR_HANDLER();
 
-            if (XToolkit.saved_error != null &&
-                XToolkit.saved_error.get_error_code() != XConstants.Success) {
+            if ((XErrorHandlerUtil.saved_error != null) &&
+                (XErrorHandlerUtil.saved_error.get_error_code() != XConstants.Success)) {
                 cleanup();
                 throw new XException("Cannot write XdndActionList property");
             }
--- ./jdk/src/solaris/classes/sun/awt/X11/XDnDDropTargetProtocol.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/solaris/classes/sun/awt/X11/XDnDDropTargetProtocol.java	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -88,12 +88,12 @@
         try {
             Native.putLong(data, 0, XDnDConstants.XDND_PROTOCOL_VERSION);
 
-            XToolkit.WITH_XERROR_HANDLER(XErrorHandler.VerifyChangePropertyHandler.getInstance());
+            XErrorHandlerUtil.WITH_XERROR_HANDLER(XErrorHandler.VerifyChangePropertyHandler.getInstance());
             XDnDConstants.XA_XdndAware.setAtomData(window, XAtom.XA_ATOM, data, 1);
-            XToolkit.RESTORE_XERROR_HANDLER();
+            XErrorHandlerUtil.RESTORE_XERROR_HANDLER();
 
-            if (XToolkit.saved_error != null &&
-                XToolkit.saved_error.get_error_code() != XConstants.Success) {
+            if ((XErrorHandlerUtil.saved_error != null) &&
+                (XErrorHandlerUtil.saved_error.get_error_code() != XConstants.Success)) {
                 throw new XException("Cannot write XdndAware property");
             }
         } finally {
@@ -205,54 +205,50 @@
 
             /* The proxy window must have the XdndAware set, as XDnD protocol
                prescribes to check the proxy window for XdndAware. */
-            XToolkit.WITH_XERROR_HANDLER(XErrorHandler.VerifyChangePropertyHandler.getInstance());
+            XErrorHandlerUtil.WITH_XERROR_HANDLER(XErrorHandler.VerifyChangePropertyHandler.getInstance());
             XDnDConstants.XA_XdndAware.setAtomData(newProxy, XAtom.XA_ATOM,
                                                    data, 1);
-            XToolkit.RESTORE_XERROR_HANDLER();
+            XErrorHandlerUtil.RESTORE_XERROR_HANDLER();
 
-            if (XToolkit.saved_error != null &&
-                XToolkit.saved_error.get_error_code() !=
-                XConstants.Success) {
+            if ((XErrorHandlerUtil.saved_error != null) &&
+                (XErrorHandlerUtil.saved_error.get_error_code() != XConstants.Success)) {
                 throw new XException("Cannot write XdndAware property");
             }
 
             Native.putLong(data, 0, newProxy);
 
             /* The proxy window must have the XdndProxy set to point to itself.*/
-            XToolkit.WITH_XERROR_HANDLER(XErrorHandler.VerifyChangePropertyHandler.getInstance());
+            XErrorHandlerUtil.WITH_XERROR_HANDLER(XErrorHandler.VerifyChangePropertyHandler.getInstance());
             XDnDConstants.XA_XdndProxy.setAtomData(newProxy, XAtom.XA_WINDOW,
                                                    data, 1);
-            XToolkit.RESTORE_XERROR_HANDLER();
+            XErrorHandlerUtil.RESTORE_XERROR_HANDLER();
 
-            if (XToolkit.saved_error != null &&
-                XToolkit.saved_error.get_error_code() !=
-                XConstants.Success) {
+            if ((XErrorHandlerUtil.saved_error != null) &&
+                (XErrorHandlerUtil.saved_error.get_error_code() != XConstants.Success)) {
                 throw new XException("Cannot write XdndProxy property");
             }
 
             Native.putLong(data, 0, XDnDConstants.XDND_PROTOCOL_VERSION);
 
-            XToolkit.WITH_XERROR_HANDLER(XErrorHandler.VerifyChangePropertyHandler.getInstance());
+            XErrorHandlerUtil.WITH_XERROR_HANDLER(XErrorHandler.VerifyChangePropertyHandler.getInstance());
             XDnDConstants.XA_XdndAware.setAtomData(embedder, XAtom.XA_ATOM,
                                                    data, 1);
-            XToolkit.RESTORE_XERROR_HANDLER();
+            XErrorHandlerUtil.RESTORE_XERROR_HANDLER();
 
-            if (XToolkit.saved_error != null &&
-                XToolkit.saved_error.get_error_code() !=
-                XConstants.Success) {
+            if ((XErrorHandlerUtil.saved_error != null) &&
+                (XErrorHandlerUtil.saved_error.get_error_code() != XConstants.Success)) {
                 throw new XException("Cannot write XdndAware property");
             }
 
             Native.putLong(data, 0, newProxy);
 
-            XToolkit.WITH_XERROR_HANDLER(XErrorHandler.VerifyChangePropertyHandler.getInstance());
+            XErrorHandlerUtil.WITH_XERROR_HANDLER(XErrorHandler.VerifyChangePropertyHandler.getInstance());
             XDnDConstants.XA_XdndProxy.setAtomData(embedder, XAtom.XA_WINDOW,
                                                    data, 1);
-            XToolkit.RESTORE_XERROR_HANDLER();
+            XErrorHandlerUtil.RESTORE_XERROR_HANDLER();
 
-            if (XToolkit.saved_error != null &&
-                XToolkit.saved_error.get_error_code() !=
-                XConstants.Success) {
+            if ((XErrorHandlerUtil.saved_error != null) &&
+                (XErrorHandlerUtil.saved_error.get_error_code() != XConstants.Success)) {
                 throw new XException("Cannot write XdndProxy property");
             }
         } finally {
@@ -278,27 +274,25 @@
             try {
                 Native.putLong(data, 0, entry.getVersion());
 
-                XToolkit.WITH_XERROR_HANDLER(XErrorHandler.VerifyChangePropertyHandler.getInstance());
+                XErrorHandlerUtil.WITH_XERROR_HANDLER(XErrorHandler.VerifyChangePropertyHandler.getInstance());
                 XDnDConstants.XA_XdndAware.setAtomData(embedder, XAtom.XA_ATOM,
                                                        data, 1);
-                XToolkit.RESTORE_XERROR_HANDLER();
+                XErrorHandlerUtil.RESTORE_XERROR_HANDLER();
 
-                if (XToolkit.saved_error != null &&
-                    XToolkit.saved_error.get_error_code() !=
-                    XConstants.Success) {
+                if ((XErrorHandlerUtil.saved_error != null) &&
+                    (XErrorHandlerUtil.saved_error.get_error_code() != XConstants.Success)) {
                     throw new XException("Cannot write XdndAware property");
                 }
 
                 Native.putLong(data, 0, (int)entry.getProxy());
 
-                XToolkit.WITH_XERROR_HANDLER(XErrorHandler.VerifyChangePropertyHandler.getInstance());
+                XErrorHandlerUtil.WITH_XERROR_HANDLER(XErrorHandler.VerifyChangePropertyHandler.getInstance());
                 XDnDConstants.XA_XdndProxy.setAtomData(embedder, XAtom.XA_WINDOW,
                                                        data, 1);
-                XToolkit.RESTORE_XERROR_HANDLER();
+                XErrorHandlerUtil.RESTORE_XERROR_HANDLER();
 
-                if (XToolkit.saved_error != null &&
-                    XToolkit.saved_error.get_error_code() !=
-                    XConstants.Success) {
+                if ((XErrorHandlerUtil.saved_error != null) &&
+                    (XErrorHandlerUtil.saved_error.get_error_code() != XConstants.Success)) {
                     throw new XException("Cannot write XdndProxy property");
                 }
             } finally {
@@ -541,15 +535,15 @@
          */
         XWindowAttributes wattr = new XWindowAttributes();
         try {
-            XToolkit.WITH_XERROR_HANDLER(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+            XErrorHandlerUtil.WITH_XERROR_HANDLER(XErrorHandler.IgnoreBadWindowHandler.getInstance());
             int status = XlibWrapper.XGetWindowAttributes(XToolkit.getDisplay(),
                                                           source_win, wattr.pData);
 
-            XToolkit.RESTORE_XERROR_HANDLER();
+            XErrorHandlerUtil.RESTORE_XERROR_HANDLER();
 
-            if (status == 0 ||
-                (XToolkit.saved_error != null &&
-                 XToolkit.saved_error.get_error_code() != XConstants.Success)) {
+            if ((status == 0) ||
+                ((XErrorHandlerUtil.saved_error != null) &&
+                (XErrorHandlerUtil.saved_error.get_error_code() != XConstants.Success))) {
                 throw new XException("XGetWindowAttributes failed");
             }
 
@@ -558,15 +552,15 @@
             wattr.dispose();
         }
 
-        XToolkit.WITH_XERROR_HANDLER(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+        XErrorHandlerUtil.WITH_XERROR_HANDLER(XErrorHandler.IgnoreBadWindowHandler.getInstance());
         XlibWrapper.XSelectInput(XToolkit.getDisplay(), source_win,
                                  source_win_mask |
                                  XConstants.StructureNotifyMask);
 
-        XToolkit.RESTORE_XERROR_HANDLER();
+        XErrorHandlerUtil.RESTORE_XERROR_HANDLER();
 
-        if (XToolkit.saved_error != null &&
-            XToolkit.saved_error.get_error_code() != XConstants.Success) {
+        if ((XErrorHandlerUtil.saved_error != null) &&
+            (XErrorHandlerUtil.saved_error.get_error_code() != XConstants.Success)) {
             throw new XException("XSelectInput failed");
         }
 
@@ -963,10 +957,10 @@
         if (sourceWindow != 0) {
             XToolkit.awtLock();
             try {
-                XToolkit.WITH_XERROR_HANDLER(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+                XErrorHandlerUtil.WITH_XERROR_HANDLER(XErrorHandler.IgnoreBadWindowHandler.getInstance());
                 XlibWrapper.XSelectInput(XToolkit.getDisplay(), sourceWindow,
                                          sourceWindowMask);
-                XToolkit.RESTORE_XERROR_HANDLER();
+                XErrorHandlerUtil.RESTORE_XERROR_HANDLER();
             } finally {
                 XToolkit.awtUnlock();
             }
@@ -1111,15 +1105,15 @@
 
                             XToolkit.awtLock();
                             try {
-                                XToolkit.WITH_XERROR_HANDLER(XErrorHandler.VerifyChangePropertyHandler.getInstance());
+                                XErrorHandlerUtil.WITH_XERROR_HANDLER(XErrorHandler.VerifyChangePropertyHandler.getInstance());
                                 XDnDConstants.XA_XdndTypeList.setAtomData(xclient.get_window(),
                                                                           XAtom.XA_ATOM,
                                                                           wpg.getData(),
                                                                           wpg.getNumberOfItems());
-                                XToolkit.RESTORE_XERROR_HANDLER();
+                                XErrorHandlerUtil.RESTORE_XERROR_HANDLER();
 
-                                if (XToolkit.saved_error != null &&
-                                    XToolkit.saved_error.get_error_code() != XConstants.Success) {
+                                if ((XErrorHandlerUtil.saved_error != null) &&
+                                    (XErrorHandlerUtil.saved_error.get_error_code() != XConstants.Success)) {
                                     if (logger.isLoggable(PlatformLogger.WARNING)) {
                                         logger.warning("Cannot set XdndTypeList on the proxy window");
                                     }
--- ./jdk/src/solaris/classes/sun/awt/X11/XDragSourceProtocol.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/solaris/classes/sun/awt/X11/XDragSourceProtocol.java	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -181,15 +181,15 @@
                                    long time) {
         XWindowAttributes wattr = new XWindowAttributes();
         try {
-            XToolkit.WITH_XERROR_HANDLER(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+            XErrorHandlerUtil.WITH_XERROR_HANDLER(XErrorHandler.IgnoreBadWindowHandler.getInstance());
             int status = XlibWrapper.XGetWindowAttributes(XToolkit.getDisplay(),
                                                           targetWindow, wattr.pData);
 
-            XToolkit.RESTORE_XERROR_HANDLER();
+            XErrorHandlerUtil.RESTORE_XERROR_HANDLER();
 
-            if (status == 0 ||
-                (XToolkit.saved_error != null &&
-                 XToolkit.saved_error.get_error_code() != XConstants.Success)) {
+            if ((status == 0) ||
+                ((XErrorHandlerUtil.saved_error != null) &&
+                (XErrorHandlerUtil.saved_error.get_error_code() != XConstants.Success))) {
                 throw new XException("XGetWindowAttributes failed");
             }
 
@@ -198,15 +198,15 @@
             wattr.dispose();
         }
 
-        XToolkit.WITH_XERROR_HANDLER(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+        XErrorHandlerUtil.WITH_XERROR_HANDLER(XErrorHandler.IgnoreBadWindowHandler.getInstance());
         XlibWrapper.XSelectInput(XToolkit.getDisplay(), targetWindow,
                                  targetWindowMask |
                                  XConstants.StructureNotifyMask);
 
-        XToolkit.RESTORE_XERROR_HANDLER();
+        XErrorHandlerUtil.RESTORE_XERROR_HANDLER();
 
-        if (XToolkit.saved_error != null &&
-            XToolkit.saved_error.get_error_code() != XConstants.Success) {
+        if ((XErrorHandlerUtil.saved_error != null) &&
+            (XErrorHandlerUtil.saved_error.get_error_code() != XConstants.Success)) {
             throw new XException("XSelectInput failed");
         }
 
@@ -214,10 +214,10 @@
     }
 
     protected final void finalizeDrop() {
-        XToolkit.WITH_XERROR_HANDLER(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+        XErrorHandlerUtil.WITH_XERROR_HANDLER(XErrorHandler.IgnoreBadWindowHandler.getInstance());
         XlibWrapper.XSelectInput(XToolkit.getDisplay(), targetWindow,
                                  targetWindowMask);
-        XToolkit.RESTORE_XERROR_HANDLER();
+        XErrorHandlerUtil.RESTORE_XERROR_HANDLER();
     }
 
     public abstract boolean processProxyModeEvent(XClientMessageEvent xclient,
--- ./jdk/src/solaris/classes/sun/awt/X11/XDropTargetRegistry.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/solaris/classes/sun/awt/X11/XDropTargetRegistry.java	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -168,14 +168,14 @@
                 if (dest_x >= 0 && dest_y >= 0) {
                     XWindowAttributes wattr = new XWindowAttributes();
                     try {
-                        XToolkit.WITH_XERROR_HANDLER(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+                        XErrorHandlerUtil.WITH_XERROR_HANDLER(XErrorHandler.IgnoreBadWindowHandler.getInstance());
                         int status = XlibWrapper.XGetWindowAttributes(XToolkit.getDisplay(),
                                                                       window, wattr.pData);
-                        XToolkit.RESTORE_XERROR_HANDLER();
+                        XErrorHandlerUtil.RESTORE_XERROR_HANDLER();
 
-                        if (status == 0 ||
-                            (XToolkit.saved_error != null &&
-                             XToolkit.saved_error.get_error_code() != XConstants.Success)) {
+                        if ((status == 0) ||
+                            ((XErrorHandlerUtil.saved_error != null) &&
+                            (XErrorHandlerUtil.saved_error.get_error_code() != XConstants.Success))) {
                             continue;
                         }
 
@@ -222,14 +222,14 @@
             long event_mask = 0;
             XWindowAttributes wattr = new XWindowAttributes();
             try {
-                XToolkit.WITH_XERROR_HANDLER(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+                XErrorHandlerUtil.WITH_XERROR_HANDLER(XErrorHandler.IgnoreBadWindowHandler.getInstance());
                 int status = XlibWrapper.XGetWindowAttributes(XToolkit.getDisplay(),
                                                               embedder, wattr.pData);
-                XToolkit.RESTORE_XERROR_HANDLER();
+                XErrorHandlerUtil.RESTORE_XERROR_HANDLER();
 
-                if (status == 0 ||
-                    (XToolkit.saved_error != null &&
-                     XToolkit.saved_error.get_error_code() != XConstants.Success)) {
+                if ((status == 0) ||
+                    ((XErrorHandlerUtil.saved_error != null) &&
+                    (XErrorHandlerUtil.saved_error.get_error_code() != XConstants.Success))) {
                     throw new XException("XGetWindowAttributes failed");
                 }
 
@@ -240,13 +240,13 @@
             }
 
             if ((event_mask & XConstants.PropertyChangeMask) == 0) {
-                XToolkit.WITH_XERROR_HANDLER(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+                XErrorHandlerUtil.WITH_XERROR_HANDLER(XErrorHandler.IgnoreBadWindowHandler.getInstance());
                 XlibWrapper.XSelectInput(XToolkit.getDisplay(), embedder,
                                          event_mask | XConstants.PropertyChangeMask);
-                XToolkit.RESTORE_XERROR_HANDLER();
+                XErrorHandlerUtil.RESTORE_XERROR_HANDLER();
 
-                if (XToolkit.saved_error != null &&
-                    XToolkit.saved_error.get_error_code() != XConstants.Success) {
+                if ((XErrorHandlerUtil.saved_error != null) &&
+                    (XErrorHandlerUtil.saved_error.get_error_code() != XConstants.Success)) {
                     throw new XException("XSelectInput failed");
                 }
             }
@@ -394,13 +394,13 @@
 
             /* Restore the original event mask for the embedder. */
             if ((event_mask & XConstants.PropertyChangeMask) == 0) {
-                XToolkit.WITH_XERROR_HANDLER(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+                XErrorHandlerUtil.WITH_XERROR_HANDLER(XErrorHandler.IgnoreBadWindowHandler.getInstance());
                 XlibWrapper.XSelectInput(XToolkit.getDisplay(), embedder,
                                          event_mask);
-                XToolkit.RESTORE_XERROR_HANDLER();
+                XErrorHandlerUtil.RESTORE_XERROR_HANDLER();
 
-                if (XToolkit.saved_error != null &&
-                    XToolkit.saved_error.get_error_code() != XConstants.Success) {
+                if ((XErrorHandlerUtil.saved_error != null) &&
+                    (XErrorHandlerUtil.saved_error.get_error_code() != XConstants.Success)) {
                     throw new XException("XSelectInput failed");
                 }
             }
--- ./jdk/src/solaris/classes/sun/awt/X11/XEmbedCanvasPeer.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/solaris/classes/sun/awt/X11/XEmbedCanvasPeer.java	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -295,15 +295,15 @@
         try {
             XWindowAttributes wattr = new XWindowAttributes();
             try {
-                XToolkit.WITH_XERROR_HANDLER(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+                XErrorHandlerUtil.WITH_XERROR_HANDLER(XErrorHandler.IgnoreBadWindowHandler.getInstance());
                 int status = XlibWrapper.XGetWindowAttributes(XToolkit.getDisplay(),
                                                               xembed.handle, wattr.pData);
 
-                XToolkit.RESTORE_XERROR_HANDLER();
+                XErrorHandlerUtil.RESTORE_XERROR_HANDLER();
 
-                if (status == 0 ||
-                    (XToolkit.saved_error != null &&
-                     XToolkit.saved_error.get_error_code() != XConstants.Success)) {
+                if ((status == 0) ||
+                    ((XErrorHandlerUtil.saved_error != null) &&
+                    (XErrorHandlerUtil.saved_error.get_error_code() != XConstants.Success))) {
                     return null;
                 }
 
--- ./jdk/src/solaris/classes/sun/awt/X11/XErrorHandler.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/solaris/classes/sun/awt/X11/XErrorHandler.java	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2009, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2009, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -38,7 +38,7 @@
     public static class XBaseErrorHandler extends XErrorHandler {
         @Override
         public int handleError(long display, XErrorEvent err) {
-            return XToolkit.SAVED_ERROR_HANDLER(display, err);
+            return XErrorHandlerUtil.SAVED_XERROR_HANDLER(display, err);
         }
     }
 
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/src/solaris/classes/sun/awt/X11/XErrorHandlerUtil.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,168 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package sun.awt.X11;
+
+import java.security.AccessController;
+import sun.awt.SunToolkit;
+import sun.security.action.GetBooleanAction;
+import sun.util.logging.PlatformLogger;
+
+/**
+ * This class contains code of the global toolkit error handler, exposes static
+ * methods which allow to set and unset synthetic error handlers.
+ */
+public final class XErrorHandlerUtil {
+    private static final PlatformLogger log = PlatformLogger.getLogger("sun.awt.X11.XErrorHandlerUtil");
+
+    /**
+     * The connection to X11 window server.
+     */
+    private static long display;
+
+    /**
+     * Error handler at the moment of {@code XErrorHandlerUtil} initialization.
+     */
+    private static long saved_error_handler;
+
+    /**
+     * XErrorEvent being handled.
+     */
+    static volatile XErrorEvent saved_error;
+
+    /**
+     * Current error handler or null if no error handler is set.
+     */
+    private static XErrorHandler current_error_handler;
+
+    /**
+     * Value of sun.awt.noisyerrorhandler system property.
+     */
+    private static boolean noisyAwtHandler = AccessController.doPrivileged(
+        new GetBooleanAction("sun.awt.noisyerrorhandler"));
+
+    /**
+     * The flag indicating that {@code init} was called already.
+     */
+    private static boolean initPassed;
+
+    /**
+     * Guarantees that no instance of this class can be created.
+     */
+    private XErrorHandlerUtil() {}
+
+    /**
+     * Sets the toolkit global error handler, stores the connection to X11 server,
+     * which will be used during an error handling process. This method is called
+     * once from {@code awt_init_Display} function defined in {@code awt_GraphicsEnv.c}
+     * file immediately after the connection to X11 window server is opened.
+     * @param display the connection to X11 server which should be stored
+     */
+    private static void init(long display) {
+        SunToolkit.awtLock();
+        try {
+            if (!initPassed) {
+                XErrorHandlerUtil.display = display;
+                saved_error_handler = XlibWrapper.SetToolkitErrorHandler();
+                initPassed = true;
+            }
+        } finally {
+            SunToolkit.awtUnlock();
+        }
+    }
+
+    /**
+     * Sets a synthetic error handler. Must be called with the acquired AWT lock.
+     * @param handler the synthetic error handler to set
+     */
+    public static void WITH_XERROR_HANDLER(XErrorHandler handler) {
+        saved_error = null;
+        current_error_handler = handler;
+    }
+
+    /**
+     * Unsets a current synthetic error handler. Must be called with the acquired AWT lock.
+     */
+    public static void RESTORE_XERROR_HANDLER() {
+        RESTORE_XERROR_HANDLER(true);
+    }
+
+    private static void RESTORE_XERROR_HANDLER(boolean doXSync) {
+        if (doXSync) {
+            // Wait until all requests are processed by the X server
+            // and only then uninstall the error handler.
+            XSync();
+        }
+        current_error_handler = null;
+    }
+
+    /**
+     * Should be called under LOCK.
+     */
+    public static int SAVED_XERROR_HANDLER(long display, XErrorEvent error) {
+        if (saved_error_handler != 0) {
+            // Default XErrorHandler may just terminate the process. Don't call it.
+            // return XlibWrapper.CallErrorHandler(saved_error_handler, display, error.pData);
+        }
+        if (log.isLoggable(PlatformLogger.FINE)) {
+            log.fine("Unhandled XErrorEvent: " +
+                "id=" + error.get_resourceid() + ", " +
+                "serial=" + error.get_serial() + ", " +
+                "ec=" + error.get_error_code() + ", " +
+                "rc=" + error.get_request_code() + ", " +
+                "mc=" + error.get_minor_code());
+        }
+        return 0;
+    }
+
+    /**
+     * Called from the native code when an error occurs.
+     */
+    private static int globalErrorHandler(long display, long event_ptr) {
+        if (noisyAwtHandler) {
+            XlibWrapper.PrintXErrorEvent(display, event_ptr);
+        }
+        XErrorEvent event = new XErrorEvent(event_ptr);
+        saved_error = event;
+        try {
+            if (current_error_handler != null) {
+                return current_error_handler.handleError(display, event);
+            } else {
+                return SAVED_XERROR_HANDLER(display, event);
+            }
+        } catch (Throwable z) {
+            log.fine("Error in GlobalErrorHandler", z);
+        }
+        return 0;
+    }
+
+    private static void XSync() {
+        SunToolkit.awtLock();
+        try {
+            XlibWrapper.XSync(display, 0);
+        } finally {
+            SunToolkit.awtUnlock();
+        }
+    }
+}
--- ./jdk/src/solaris/classes/sun/awt/X11/XKeyboardFocusManagerPeer.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/solaris/classes/sun/awt/X11/XKeyboardFocusManagerPeer.java	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -26,9 +26,11 @@
 
 import java.awt.Component;
 import java.awt.Window;
-import sun.util.logging.PlatformLogger;
+
+import sun.awt.AWTAccessor;
 import sun.awt.CausedFocusEvent;
 import sun.awt.KeyboardFocusManagerPeerImpl;
+import sun.util.logging.PlatformLogger;
 
 public class XKeyboardFocusManagerPeer extends KeyboardFocusManagerPeerImpl {
     private static final PlatformLogger focusLog = PlatformLogger.getLogger("sun.awt.X11.focus.XKeyboardFocusManagerPeer");
@@ -68,13 +70,13 @@
 
         synchronized(this) {
             if (currentFocusedWindow != null) {
-                from = (XWindowPeer)currentFocusedWindow.getPeer();
+                from = (XWindowPeer)AWTAccessor.getComponentAccessor().getPeer(currentFocusedWindow);
             }
 
             currentFocusedWindow = win;
 
             if (currentFocusedWindow != null) {
-                to = (XWindowPeer)currentFocusedWindow.getPeer();
+                to = (XWindowPeer)AWTAccessor.getComponentAccessor().getPeer(currentFocusedWindow);
             }
         }
 
--- ./jdk/src/solaris/classes/sun/awt/X11/XQueryTree.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/solaris/classes/sun/awt/X11/XQueryTree.java	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2005, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -61,7 +61,7 @@
                         }
                         __executed = true;
                         if (errorHandler != null) {
-                            XToolkit.WITH_XERROR_HANDLER(errorHandler);
+                            XErrorHandlerUtil.WITH_XERROR_HANDLER(errorHandler);
                         }
                         Native.putLong(children_ptr, 0);
                         int status =
@@ -72,7 +72,7 @@
                                 children_ptr,
                                 nchildren_ptr                   );
                         if (errorHandler != null) {
-                            XToolkit.RESTORE_XERROR_HANDLER();
+                            XErrorHandlerUtil.RESTORE_XERROR_HANDLER();
                         }
                         return status;
                 } finally {
--- ./jdk/src/solaris/classes/sun/awt/X11/XToolkit.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/solaris/classes/sun/awt/X11/XToolkit.java	Wed May 07 19:26:47 2014 -0700
@@ -128,7 +128,6 @@
             initIDs();
             setBackingStoreType();
         }
-        noisyAwtHandler = AccessController.doPrivileged(new GetBooleanAction("sun.awt.noisyerrorhandler"));
     }
 
     /*
@@ -137,78 +136,6 @@
      */
     static native long getTrayIconDisplayTimeout();
 
-    //---- ERROR HANDLER CODE ----//
-
-    /*
-     * Error handler at the moment of XToolkit initialization
-     */
-    private static long saved_error_handler;
-
-    /*
-     * XErrorEvent being handled
-     */
-    static volatile XErrorEvent saved_error;
-
-    /*
-     * Current error handler or null if no error handler is set
-     */
-    private static XErrorHandler current_error_handler;
-
-    /*
-     * Value of sun.awt.noisyerrorhandler system property
-     */
-    private static boolean noisyAwtHandler;
-
-    public static void WITH_XERROR_HANDLER(XErrorHandler handler) {
-        saved_error = null;
-        current_error_handler = handler;
-    }
-
-    public static void RESTORE_XERROR_HANDLER() {
-        // wait until all requests are processed by the X server
-        // and only then uninstall the error handler
-        XSync();
-        current_error_handler = null;
-    }
-
-    // Should be called under LOCK
-    public static int SAVED_ERROR_HANDLER(long display, XErrorEvent error) {
-        if (saved_error_handler != 0) {
-            // Default XErrorHandler may just terminate the process. Don't call it.
-            // return XlibWrapper.CallErrorHandler(saved_error_handler, display, error.pData);
-        }
-        if (log.isLoggable(PlatformLogger.FINE)) {
-            log.fine("Unhandled XErrorEvent: " +
-                     "id=" + error.get_resourceid() + ", " +
-                     "serial=" + error.get_serial() + ", " +
-                     "ec=" + error.get_error_code() + ", " +
-                     "rc=" + error.get_request_code() + ", " +
-                     "mc=" + error.get_minor_code());
-        }
-        return 0;
-    }
-
-    // Called from the native code when an error occurs
-    private static int globalErrorHandler(long display, long event_ptr) {
-        if (noisyAwtHandler) {
-            XlibWrapper.PrintXErrorEvent(display, event_ptr);
-        }
-        XErrorEvent event = new XErrorEvent(event_ptr);
-        saved_error = event;
-        try {
-            if (current_error_handler != null) {
-                return current_error_handler.handleError(display, event);
-            } else {
-                return SAVED_ERROR_HANDLER(display, event);
-            }
-        } catch (Throwable z) {
-            log.fine("Error in GlobalErrorHandler", z);
-        }
-        return 0;
-    }
-
-    //---- END OF ERROR HANDLER CODE ----//
-
     private native static void initIDs();
     native static void waitForEvents(long nextTaskTime);
     static Thread toolkitThread;
@@ -305,8 +232,6 @@
             areExtraMouseButtonsEnabled = Boolean.parseBoolean(System.getProperty("sun.awt.enableExtraMouseButtons", "true"));
             //set system property if not yet assigned
             System.setProperty("sun.awt.enableExtraMouseButtons", ""+areExtraMouseButtonsEnabled);
-
-            saved_error_handler = XlibWrapper.SetToolkitErrorHandler();
         } finally {
             awtUnlock();
         }
--- ./jdk/src/solaris/classes/sun/awt/X11/XTranslateCoordinates.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/solaris/classes/sun/awt/X11/XTranslateCoordinates.java	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2005, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -68,7 +68,7 @@
                         }
                         __executed = true;
                         if (errorHandler != null) {
-                            XToolkit.WITH_XERROR_HANDLER(errorHandler);
+                            XErrorHandlerUtil.WITH_XERROR_HANDLER(errorHandler);
                         }
                         int status =
                         XlibWrapper.XTranslateCoordinates(XToolkit.getDisplay(),
@@ -80,7 +80,7 @@
                                 dest_y_ptr,
                                 child_ptr                       );
                         if (errorHandler != null) {
-                            XToolkit.RESTORE_XERROR_HANDLER();
+                            XErrorHandlerUtil.RESTORE_XERROR_HANDLER();
                         }
                         return status;
                 } finally {
--- ./jdk/src/solaris/classes/sun/awt/X11/XWM.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/solaris/classes/sun/awt/X11/XWM.java	Wed May 07 19:26:47 2014 -0700
@@ -283,12 +283,12 @@
             winmgr_running = false;
             substruct.set_event_mask(XConstants.SubstructureRedirectMask);
 
-            XToolkit.WITH_XERROR_HANDLER(detectWMHandler);
+            XErrorHandlerUtil.WITH_XERROR_HANDLER(detectWMHandler);
             XlibWrapper.XChangeWindowAttributes(XToolkit.getDisplay(),
                                                 XToolkit.getDefaultRootWindow(),
                                                 XConstants.CWEventMask,
                                                 substruct.pData);
-            XToolkit.RESTORE_XERROR_HANDLER();
+            XErrorHandlerUtil.RESTORE_XERROR_HANDLER();
 
             /*
              * If no WM is running then our selection for SubstructureRedirect
@@ -617,15 +617,16 @@
 
         XToolkit.awtLock();
         try {
-            XToolkit.WITH_XERROR_HANDLER(XErrorHandler.VerifyChangePropertyHandler.getInstance());
+            XErrorHandlerUtil.WITH_XERROR_HANDLER(XErrorHandler.VerifyChangePropertyHandler.getInstance());
             XlibWrapper.XChangePropertyS(XToolkit.getDisplay(), XToolkit.getDefaultRootWindow(),
                                          XA_ICEWM_WINOPTHINT.getAtom(),
                                          XA_ICEWM_WINOPTHINT.getAtom(),
                                          8, XConstants.PropModeReplace,
                                          new String(opt));
-            XToolkit.RESTORE_XERROR_HANDLER();
+            XErrorHandlerUtil.RESTORE_XERROR_HANDLER();
 
-            if (XToolkit.saved_error != null && XToolkit.saved_error.get_error_code() != XConstants.Success) {
+            if ((XErrorHandlerUtil.saved_error != null) &&
+                (XErrorHandlerUtil.saved_error.get_error_code() != XConstants.Success)) {
                 log.finer("Erorr getting XA_ICEWM_WINOPTHINT property");
                 return false;
             }
--- ./jdk/src/solaris/classes/sun/awt/X11/XlibUtil.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/solaris/classes/sun/awt/X11/XlibUtil.java	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2006, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -151,8 +151,8 @@
             {
                 int status = xtc.execute(XErrorHandler.IgnoreBadWindowHandler.getInstance());
                 if ((status != 0) &&
-                    ((XToolkit.saved_error == null) ||
-                     (XToolkit.saved_error.get_error_code() == XConstants.Success)))
+                    ((XErrorHandlerUtil.saved_error == null) ||
+                    (XErrorHandlerUtil.saved_error.get_error_code() == XConstants.Success)))
                 {
                     translated = new Point(xtc.get_dest_x(), xtc.get_dest_y());
                 }
@@ -345,13 +345,13 @@
         XWindowAttributes wattr = new XWindowAttributes();
         try
         {
-            XToolkit.WITH_XERROR_HANDLER(XErrorHandler.IgnoreBadWindowHandler.getInstance());
+            XErrorHandlerUtil.WITH_XERROR_HANDLER(XErrorHandler.IgnoreBadWindowHandler.getInstance());
             int status = XlibWrapper.XGetWindowAttributes(XToolkit.getDisplay(),
                                                           window, wattr.pData);
-            XToolkit.RESTORE_XERROR_HANDLER();
+            XErrorHandlerUtil.RESTORE_XERROR_HANDLER();
             if ((status != 0) &&
-                ((XToolkit.saved_error == null) ||
-                 (XToolkit.saved_error.get_error_code() == XConstants.Success)))
+                ((XErrorHandlerUtil.saved_error == null) ||
+                (XErrorHandlerUtil.saved_error.get_error_code() == XConstants.Success)))
             {
                 return wattr.get_map_state();
             }
--- ./jdk/src/solaris/classes/sun/awt/X11/generator/WrapperGenerator.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/solaris/classes/sun/awt/X11/generator/WrapperGenerator.java	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2009, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -992,7 +992,7 @@
             pw.println("\t\t\t}");
             pw.println("\t\t\t__executed = true;");
             pw.println("\t\t\tif (errorHandler != null) {");
-            pw.println("\t\t\t    XToolkit.WITH_XERROR_HANDLER(errorHandler);");
+            pw.println("\t\t\t    XErrorHandlerUtil.WITH_XERROR_HANDLER(errorHandler);");
             pw.println("\t\t\t}");
             iter = ft.getArguments().iterator();
             while (iter.hasNext()) {
@@ -1021,7 +1021,7 @@
             }
             pw.println("\t\t\t);");
             pw.println("\t\t\tif (errorHandler != null) {");
-            pw.println("\t\t\t    XToolkit.RESTORE_XERROR_HANDLER();");
+            pw.println("\t\t\t    XErrorHandlerUtil.RESTORE_XERROR_HANDLER();");
             pw.println("\t\t\t}");
             if (!ft.isVoid()) {
                 pw.println("\t\t\treturn status;");
--- ./jdk/src/solaris/demo/jvmti/hprof/hprof_md.c	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/solaris/demo/jvmti/hprof/hprof_md.c	Wed May 07 19:26:47 2014 -0700
@@ -376,33 +376,32 @@
 }
 
 static void dll_build_name(char* buffer, size_t buflen,
-                           const char* pname, const char* fname) {
-    // Loosely based on os_solaris.cpp
+                           const char* paths, const char* fname) {
+    char *path, *paths_copy, *next_token;
 
-      char *pathname = (char *)pname;
-      while (strlen(pathname) > 0) {
-          char *p = strchr(pathname, ':');
-          if (p == NULL) {
-              p = pathname + strlen(pathname);
-          }
-          /* check for NULL path */
-          if (p == pathname) {
-              continue;
-          }
-          (void)snprintf(buffer, buflen, "%.*s/lib%s" JNI_LIB_SUFFIX,
-                         (p - pathname), pathname, fname);
+    paths_copy = strdup(paths);
+    if (paths_copy == NULL) {
+        return;
+    }
 
-          if (access(buffer, F_OK) == 0) {
+    next_token = NULL;
+    path = strtok_r(paths_copy, ":", &next_token);
+
+    while (path != NULL) {
+        snprintf(buffer, buflen, "%s/lib%s" JNI_LIB_SUFFIX, path, fname);
+        if (access(buffer, F_OK) == 0) {
             break;
-          }
-          pathname = p + 1;
-          *buffer = '\0';
-      }
+        }
+        *buffer = '\0';
+        path = strtok_r(NULL, ":", &next_token);
+    }
+
+    free(paths_copy);
 }
 
 /* Create the actual fill filename for a dynamic library.  */
 void
-md_build_library_name(char *holder, int holderlen, char *pname, char *fname)
+md_build_library_name(char *holder, int holderlen, const char *pname, const char *fname)
 {
     int   pnamelen;
 
--- ./jdk/src/solaris/native/java/lang/java_props_macosx.c	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/solaris/native/java/lang/java_props_macosx.c	Wed May 07 19:26:47 2014 -0700
@@ -31,6 +31,7 @@
 #include <Security/AuthSession.h>
 #include <CoreFoundation/CoreFoundation.h>
 #include <SystemConfiguration/SystemConfiguration.h>
+#include <Foundation/Foundation.h>
 
 #include "java_props_macosx.h"
 
@@ -262,9 +263,20 @@
     return c_exception;
 }
 
+/*
+ * Method for fetching the user.home path and storing it in the property list.
+ * For signed .apps running in the Mac App Sandbox, user.home is set to the
+ * app's sandbox container.
+ */
+void setUserHome(java_props_t *sprops) {
+    if (sprops == NULL) { return; }
+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
+    sprops->user_home = createUTF8CString((CFStringRef)NSHomeDirectory());
+    [pool drain];
+}
 
 /*
- * Method for fetching proxy info and storing it in the propery list.
+ * Method for fetching proxy info and storing it in the property list.
  */
 void setProxyProperties(java_props_t *sProps) {
     if (sProps == NULL) return;
--- ./jdk/src/solaris/native/java/lang/java_props_macosx.h	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/solaris/native/java/lang/java_props_macosx.h	Wed May 07 19:26:47 2014 -0700
@@ -27,6 +27,7 @@
 
 char *setupMacOSXLocale(int cat);
 void setOSNameAndVersion(java_props_t *sprops);
+void setUserHome(java_props_t *sprops);
 void setProxyProperties(java_props_t *sProps);
 
 enum PreferredToolkit_enum {
--- ./jdk/src/solaris/native/java/lang/java_props_md.c	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/solaris/native/java/lang/java_props_md.c	Wed May 07 19:26:47 2014 -0700
@@ -324,6 +324,25 @@
             *std_encoding = "Big5-HKSCS-2001";
         }
 #endif
+#ifdef MACOSX
+        /*
+         * For the case on MacOS X where encoding is set to US-ASCII, but we
+         * don't have any encoding hints from LANG/LC_ALL/LC_CTYPE, use UTF-8
+         * instead.
+         *
+         * The contents of ASCII files will still be read and displayed
+         * correctly, but so will files containing UTF-8 characters beyond the
+         * standard ASCII range.
+         *
+         * Specifically, this allows apps launched by double-clicking a .jar
+         * file to correctly read UTF-8 files using the default encoding (see
+         * 8011194).
+         */
+        if (strcmp(p,"US-ASCII") == 0 && getenv("LANG") == NULL &&
+            getenv("LC_ALL") == NULL && getenv("LC_CTYPE") == NULL) {
+            *std_encoding = "UTF-8";
+        }
+#endif
     }
 
     return 1;
@@ -527,7 +546,14 @@
     {
         struct passwd *pwent = getpwuid(getuid());
         sprops.user_name = pwent ? strdup(pwent->pw_name) : "?";
-        sprops.user_home = pwent ? strdup(pwent->pw_dir) : "?";
+#ifdef MACOSX
+        setUserHome(&sprops);
+#else
+        sprops.user_home = pwent ? strdup(pwent->pw_dir) : NULL;
+#endif
+        if (sprops.user_home == NULL) {
+            sprops.user_home = "?";
+        }
     }
 
     /* User TIMEZONE */
--- ./jdk/src/solaris/native/java/net/NetworkInterface.c	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/solaris/native/java/net/NetworkInterface.c	Wed May 07 19:26:47 2014 -0700
@@ -559,11 +559,9 @@
 
     if ((sock = openSocketWithFallback(env, name_utf)) < 0) {
         (*env)->ReleaseStringUTFChars(env, name, name_utf);
-         return -1;
+        return -1;
     }
 
-    name_utf = (*env)->GetStringUTFChars(env, name, &isCopy);
-
     ret = getFlags(sock, name_utf, &flags);
 
     close(sock);
--- ./jdk/src/solaris/native/java/net/PlainDatagramSocketImpl.c	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/solaris/native/java/net/PlainDatagramSocketImpl.c	Wed May 07 19:26:47 2014 -0700
@@ -574,6 +574,8 @@
         } else if (ret == JVM_IO_ERR) {
             if (errno == EBADF) {
                  JNU_ThrowByName(env, JNU_JAVANETPKG "SocketException", "Socket closed");
+            } else if (errno == ENOMEM) {
+                 JNU_ThrowOutOfMemoryError(env, "NET_Timeout native heap allocation failed");
             } else {
                  NET_ThrowByNameWithLastError(env, JNU_JAVANETPKG "SocketException", "Peek failed");
             }
@@ -674,15 +676,18 @@
                             "Receive timed out");
             return -1;
         } else if (ret == JVM_IO_ERR) {
+            if (errno == ENOMEM) {
+                JNU_ThrowOutOfMemoryError(env, "NET_Timeout native heap allocation failed");
 #ifdef __linux__
-            if (errno == EBADF) {
+            } else if (errno == EBADF) {
                 JNU_ThrowByName(env, JNU_JAVANETPKG "SocketException", "Socket closed");
             } else {
                 NET_ThrowByNameWithLastError(env, JNU_JAVANETPKG "SocketException", "Receive failed");
+#else
+            } else {
+                JNU_ThrowByName(env, JNU_JAVANETPKG "SocketException", "Socket closed");
+#endif
             }
-#else
-            JNU_ThrowByName(env, JNU_JAVANETPKG "SocketException", "Socket closed");
-#endif
             return -1;
         } else if (ret == JVM_IO_INTR) {
             JNU_ThrowByName(env, JNU_JAVAIOPKG "InterruptedIOException",
@@ -910,15 +915,18 @@
                     JNU_ThrowByName(env, JNU_JAVANETPKG "SocketTimeoutException",
                                     "Receive timed out");
                 } else if (ret == JVM_IO_ERR) {
+                     if (errno == ENOMEM) {
+                        JNU_ThrowOutOfMemoryError(env, "NET_Timeout native heap allocation failed");
 #ifdef __linux__
-                    if (errno == EBADF) {
+                     } else if (errno == EBADF) {
                          JNU_ThrowByName(env, JNU_JAVANETPKG "SocketException", "Socket closed");
                      } else {
                          NET_ThrowByNameWithLastError(env, JNU_JAVANETPKG "SocketException", "Receive failed");
+#else
+                     } else {
+                         JNU_ThrowByName(env, JNU_JAVANETPKG "SocketException", "Socket closed");
+#endif
                      }
-#else
-                     JNU_ThrowByName(env, JNU_JAVANETPKG "SocketException", "Socket closed");
-#endif
                 } else if (ret == JVM_IO_INTR) {
                     JNU_ThrowByName(env, JNU_JAVAIOPKG "InterruptedIOException",
                                     "operation interrupted");
--- ./jdk/src/solaris/native/java/net/PlainSocketImpl.c	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/solaris/native/java/net/PlainSocketImpl.c	Wed May 07 19:26:47 2014 -0700
@@ -708,7 +708,6 @@
         } else {
             ret = NET_Timeout(fd, timeout);
         }
-
         if (ret == 0) {
             JNU_ThrowByName(env, JNU_JAVANETPKG "SocketTimeoutException",
                             "Accept timed out");
@@ -716,6 +715,8 @@
         } else if (ret == JVM_IO_ERR) {
             if (errno == EBADF) {
                JNU_ThrowByName(env, JNU_JAVANETPKG "SocketException", "Socket closed");
+            } else if (errno == ENOMEM) {
+               JNU_ThrowOutOfMemoryError(env, "NET_Timeout native heap allocation failed");
             } else {
                NET_ThrowByNameWithLastError(env, JNU_JAVANETPKG "SocketException", "Accept failed");
             }
--- ./jdk/src/solaris/native/java/net/SocketInputStream.c	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/solaris/native/java/net/SocketInputStream.c	Wed May 07 19:26:47 2014 -0700
@@ -108,6 +108,8 @@
             } else if (nread == JVM_IO_ERR) {
                 if (errno == EBADF) {
                      JNU_ThrowByName(env, JNU_JAVANETPKG "SocketException", "Socket closed");
+                 } else if (errno == ENOMEM) {
+                     JNU_ThrowOutOfMemoryError(env, "NET_Timeout native heap allocation failed");
                  } else {
                      NET_ThrowByNameWithLastError(env, JNU_JAVANETPKG "SocketException",
                                                   "select/poll failed");
--- ./jdk/src/solaris/native/java/net/bsd_close.c	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/solaris/native/java/net/bsd_close.c	Wed May 07 19:26:47 2014 -0700
@@ -25,6 +25,7 @@
 
 #include <stdio.h>
 #include <stdlib.h>
+#include <sys/param.h>
 #include <signal.h>
 #include <pthread.h>
 #include <sys/types.h>
@@ -35,7 +36,6 @@
 #include <sys/uio.h>
 #include <unistd.h>
 #include <errno.h>
-
 #include <sys/poll.h>
 
 /*
@@ -347,6 +347,10 @@
 int NET_Timeout(int s, long timeout) {
     long prevtime = 0, newtime;
     struct timeval t, *tp = &t;
+    fd_set fds;
+    fd_set* fdsp = NULL;
+    int allocated = 0;
+    threadEntry_t self;
     fdEntry_t *fdEntry = getFdEntry(s);
 
     /*
@@ -376,20 +380,29 @@
         t.tv_usec = 0;
     }
 
+    if (s < FD_SETSIZE) {
+        fdsp = &fds;
+        FD_ZERO(fdsp);
+    } else {
+        int length = (howmany(s+1, NFDBITS)) * sizeof(int);
+        fdsp = (fd_set *) calloc(1, length);
+        if (fdsp == NULL) {
+            return -1;   // errno will be set to ENOMEM
+        }
+        allocated = 1;
+    }
+    FD_SET(s, fdsp);
+
     for(;;) {
-        fd_set rfds;
         int rv;
-        threadEntry_t self;
 
         /*
          * call select on the fd. If interrupted by our wakeup signal
          * errno will be set to EBADF.
          */
-        FD_ZERO(&rfds);
-        FD_SET(s, &rfds);
 
         startOp(fdEntry, &self);
-        rv = select(s+1, &rfds, 0, 0, tp);
+        rv = select(s+1, fdsp, 0, 0, tp);
         endOp(fdEntry, &self);
 
         /*
@@ -403,6 +416,8 @@
                 newtime = now.tv_sec * 1000  +  now.tv_usec / 1000;
                 timeout -= newtime - prevtime;
                 if (timeout <= 0) {
+                    if (allocated != 0)
+                        free(fdsp);
                     return 0;
                 }
                 prevtime = newtime;
@@ -410,6 +425,8 @@
                 t.tv_usec = (timeout % 1000) * 1000;
             }
         } else {
+            if (allocated != 0)
+                free(fdsp);
             return rv;
         }
 
--- ./jdk/src/solaris/native/java/net/linux_close.c	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/solaris/native/java/net/linux_close.c	Wed May 07 19:26:47 2014 -0700
@@ -34,7 +34,6 @@
 #include <sys/uio.h>
 #include <unistd.h>
 #include <errno.h>
-
 #include <sys/poll.h>
 
 /*
@@ -192,17 +191,6 @@
 
     {
         /*
-         * Send a wakeup signal to all threads blocked on this
-         * file descriptor.
-         */
-        threadEntry_t *curr = fdEntry->threads;
-        while (curr != NULL) {
-            curr->intr = 1;
-            pthread_kill( curr->thr, sigWakeup );
-            curr = curr->next;
-        }
-
-        /*
          * And close/dup the file descriptor
          * (restart if interrupted by signal)
          */
@@ -214,6 +202,16 @@
             }
         } while (rv == -1 && errno == EINTR);
 
+        /*
+         * Send a wakeup signal to all threads blocked on this
+         * file descriptor.
+         */
+        threadEntry_t *curr = fdEntry->threads;
+        while (curr != NULL) {
+            curr->intr = 1;
+            pthread_kill( curr->thr, sigWakeup );
+            curr = curr->next;
+        }
     }
 
     /*
--- ./jdk/src/solaris/native/java/net/net_util_md.c	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/solaris/native/java/net/net_util_md.c	Wed May 07 19:26:47 2014 -0700
@@ -114,9 +114,9 @@
     static jfieldID ni_defaultIndexID;
     if (ni_class == NULL) {
         jclass c = (*env)->FindClass(env, "java/net/NetworkInterface");
-        CHECK_NULL(c);
+        CHECK_NULL_RETURN(c, 0);
         c = (*env)->NewGlobalRef(env, c);
-        CHECK_NULL(c);
+        CHECK_NULL_RETURN(c, 0);
         ni_defaultIndexID = (*env)->GetStaticFieldID(
             env, c, "defaultIndex", "I");
         ni_class = c;
--- ./jdk/src/solaris/native/sun/awt/awt_DrawingSurface.c	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/solaris/native/sun/awt/awt_DrawingSurface.c	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1996, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1996, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -405,7 +405,14 @@
         target = (*env)->GetObjectField(env, peer, mComponentPeerIDs.target);
     }
 #else
-    target =  (*env)->GetObjectField(env, peer, targetID);
+    if (window != None) {
+        peer = JNU_CallStaticMethodByName(env, NULL, "sun/awt/X11/XToolkit",
+            "windowToXWindow", "(J)Lsun/awt/X11/XBaseWindow;", (jlong)window).l;
+    }
+    if ((peer != NULL) &&
+        (JNU_IsInstanceOfByName(env, peer, "sun/awt/X11/XWindow") == 1)) {
+        target = (*env)->GetObjectField(env, peer, targetID);
+    }
 #endif
 
     if (target == NULL) {
@@ -414,7 +421,6 @@
         return (jobject)NULL;
     }
 
-
     AWT_UNLOCK();
 
     return target;
--- ./jdk/src/solaris/native/sun/awt/awt_GraphicsEnv.c	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/solaris/native/sun/awt/awt_GraphicsEnv.c	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -830,6 +830,8 @@
     }
 
     XSetIOErrorHandler(xioerror_handler);
+    JNU_CallStaticMethodByName(env, NULL, "sun/awt/X11/XErrorHandlerUtil", "init", "(J)V",
+        ptr_to_jlong(awt_display));
 
     /* set awt_numScreens, and whether or not we're using Xinerama */
     xineramaInit();
@@ -978,16 +980,11 @@
 static jint canUseShmExtPixmaps = UNSET_MITSHM;
 static jboolean xshmAttachFailed = JNI_FALSE;
 
-extern int mitShmPermissionMask;
-
-int J2DXErrHandler(Display *display, XErrorEvent *xerr) {
-    int ret = 0;
+int XShmAttachXErrHandler(Display *display, XErrorEvent *xerr) {
     if (xerr->minor_code == X_ShmAttach) {
         xshmAttachFailed = JNI_TRUE;
-    } else {
-        ret = (*xerror_saved_handler)(display, xerr);
     }
-    return ret;
+    return 0;
 }
 jboolean isXShmAttachFailed() {
     return xshmAttachFailed;
@@ -996,6 +993,8 @@
     xshmAttachFailed = JNI_FALSE;
 }
 
+extern int mitShmPermissionMask;
+
 void TryInitMITShm(JNIEnv *env, jint *shmExt, jint *shmPixmaps) {
     XShmSegmentInfo shminfo;
     int XShmMajor, XShmMinor;
@@ -1043,7 +1042,7 @@
          * The J2DXErrHandler handler will set xshmAttachFailed
          * to JNI_TRUE if any Shm error has occured.
          */
-        EXEC_WITH_XERROR_HANDLER(J2DXErrHandler,
+        EXEC_WITH_XERROR_HANDLER(XShmAttachXErrHandler,
                                  XShmAttach(awt_display, &shminfo));
 
         /**
--- ./jdk/src/solaris/native/sun/awt/awt_GraphicsEnv.h	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/solaris/native/sun/awt/awt_GraphicsEnv.h	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1998, 2003, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jdk/src/solaris/native/sun/awt/awt_util.c	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/solaris/native/sun/awt/awt_util.c	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1995, 2003, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1995, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -58,16 +58,14 @@
 #include "java_awt_event_MouseWheelEvent.h"
 
 /*
- * Since X reports protocol errors asynchronously, we often need to
- * install an error handler that acts like a callback.  While that
- * specialized handler is installed we save original handler here.
+ * Called by "ToolkitErrorHandler" function in "XlibWrapper.c" file.
  */
-XErrorHandler xerror_saved_handler;
+XErrorHandler current_native_xerror_handler = NULL;
 
 /*
  * A place for error handler to report the error code.
  */
-unsigned char xerror_code;
+unsigned char xerror_code = Success;
 
 extern jint getModifiers(uint32_t state, jint button, jint keyCode);
 extern jint getButton(uint32_t button);
--- ./jdk/src/solaris/native/sun/awt/awt_util.h	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/solaris/native/sun/awt/awt_util.h	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1995, 2004, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1995, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -82,7 +82,7 @@
 #define WITH_XERROR_HANDLER(f) do {             \
     XSync(awt_display, False);                  \
     xerror_code = Success;                      \
-    xerror_saved_handler = XSetErrorHandler(f); \
+    current_native_xerror_handler = (f);        \
 } while (0)
 
 /* Convenience macro for handlers to use */
@@ -92,7 +92,7 @@
 
 #define RESTORE_XERROR_HANDLER do {             \
     XSync(awt_display, False);                  \
-    XSetErrorHandler(xerror_saved_handler);     \
+    current_native_xerror_handler = NULL;       \
 } while (0)
 
 #define EXEC_WITH_XERROR_HANDLER(f, code) do {  \
@@ -104,11 +104,9 @@
 } while (0)
 
 /*
- * Since X reports protocol errors asynchronously, we often need to
- * install an error handler that acts like a callback.  While that
- * specialized handler is installed we save original handler here.
+ * Called by "ToolkitErrorHandler" function in "XlibWrapper.c" file.
  */
-extern XErrorHandler xerror_saved_handler;
+extern XErrorHandler current_native_xerror_handler;
 
 /*
  * A place for error handler to report the error code.
--- ./jdk/src/solaris/native/sun/awt/awt_wm.c	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/solaris/native/sun/awt/awt_wm.c	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2001, 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2001, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -382,14 +382,10 @@
     XERROR_SAVE(err);
     if (err->error_code == BadWindow) {
         DTRACE_PRINTLN("IGNORING BadWindow");
-        return 0; /* ok to fail */
     }
-    else {
-        return (*xerror_saved_handler)(dpy, err);
-    }
+    return 0; /* ok to fail */
 }
 
-
 /*
  * Convenience wrapper for XGetWindowProperty for XA_ATOM properties.
  * E.g. WM_PROTOCOLS, _NET_WM_STATE, _OL_DECOR_DEL.
@@ -1011,7 +1007,6 @@
     return awt_wm_isNetWMName("Metacity");
 }
 
-
 /*
  * Temporary error handler that ensures that we know if
  * XChangeProperty succeeded or not.
@@ -1020,15 +1015,10 @@
 xerror_verify_change_property(Display *dpy, XErrorEvent *err)
 {
     XERROR_SAVE(err);
-    if (err->request_code == X_ChangeProperty) {
-        return 0;
-    }
-    else {
-        return (*xerror_saved_handler)(dpy, err);
-    }
+    if (err->request_code == X_ChangeProperty) { }
+    return 0;
 }
 
-
 /*
  * Prepare IceWM check.
  *
@@ -1159,8 +1149,6 @@
     return True;
 }
 
-
-
 static Boolean winmgr_running = False;
 
 /*
@@ -1176,14 +1164,10 @@
     {
         DTRACE_PRINTLN("some WM is running (hmm, we'll see)");
         winmgr_running = True;
-        return 0;
     }
-    else {
-        return (*xerror_saved_handler)(dpy, err);
-    }
+    return 0;
 }
 
-
 /*
  * Make an educated guess about running window manager.
  * XXX: ideally, we should detect wm restart.
--- ./jdk/src/solaris/native/sun/awt/awt_xembed_server.c	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/solaris/native/sun/awt/awt_xembed_server.c	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2005, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
--- ./jdk/src/solaris/native/sun/java2d/opengl/GLXSurfaceData.c	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/solaris/native/sun/java2d/opengl/GLXSurfaceData.c	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -396,13 +396,10 @@
 static int
 GLXSD_BadAllocXErrHandler(Display *display, XErrorEvent *xerr)
 {
-    int ret = 0;
     if (xerr->error_code == BadAlloc) {
         surfaceCreationFailed = JNI_TRUE;
-    } else {
-        ret = (*xerror_saved_handler)(display, xerr);
     }
-    return ret;
+    return 0;
 }
 
 JNIEXPORT jboolean JNICALL
--- ./jdk/src/solaris/native/sun/java2d/x11/X11SurfaceData.c	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/solaris/native/sun/java2d/x11/X11SurfaceData.c	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -68,7 +68,7 @@
 #ifndef XAWT
 extern struct MComponentPeerIDs mComponentPeerIDs;
 #endif
-extern int J2DXErrHandler(Display *display, XErrorEvent *xerr);
+extern int XShmAttachXErrHandler(Display *display, XErrorEvent *xerr);
 extern AwtGraphicsConfigDataPtr
     getGraphicsConfigFromComponentPeer(JNIEnv *env, jobject this);
 extern struct X11GraphicsConfigIDs x11GraphicsConfigIDs;
@@ -591,7 +591,7 @@
     shminfo->readOnly = False;
 
     resetXShmAttachFailed();
-    EXEC_WITH_XERROR_HANDLER(J2DXErrHandler,
+    EXEC_WITH_XERROR_HANDLER(XShmAttachXErrHandler,
                              XShmAttach(awt_display, shminfo));
 
     /*
--- ./jdk/src/solaris/native/sun/nio/ch/SctpChannelImpl.c	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/solaris/native/sun/nio/ch/SctpChannelImpl.c	Wed May 07 19:26:47 2014 -0700
@@ -38,8 +38,7 @@
 #include "sun_nio_ch_SctpResultContainer.h"
 #include "sun_nio_ch_SctpPeerAddrChange.h"
 
-/* sizeof(union sctp_notification */
-#define NOTIFICATION_BUFFER_SIZE 280
+static int SCTP_NOTIFICATION_SIZE = sizeof(union sctp_notification);
 
 #define MESSAGE_IMPL_CLASS              "sun/nio/ch/SctpMessageInfoImpl"
 #define RESULT_CONTAINER_CLASS          "sun/nio/ch/SctpResultContainer"
@@ -458,20 +457,47 @@
         if (msg->msg_flags & MSG_NOTIFICATION) {
             char *bufp = (char*)addr;
             union sctp_notification *snp;
+            jboolean allocated = JNI_FALSE;
 
-            if (!(msg->msg_flags & MSG_EOR) && length < NOTIFICATION_BUFFER_SIZE) {
-                char buf[NOTIFICATION_BUFFER_SIZE];
+            if (rv > SCTP_NOTIFICATION_SIZE) {
+                JNU_ThrowInternalError(env, "should not reach here");
+                return -1;
+            }
+
+            if (!(msg->msg_flags & MSG_EOR) && length < SCTP_NOTIFICATION_SIZE) {
+                char* newBuf;
                 int rvSAVE = rv;
-                memcpy(buf, addr, rv);
-                iov->iov_base = buf + rv;
-                iov->iov_len = NOTIFICATION_BUFFER_SIZE - rv;
+
+                if ((newBuf = malloc(SCTP_NOTIFICATION_SIZE)) == NULL) {
+                    JNU_ThrowOutOfMemoryError(env, "Out of native heap space.");
+                    return -1;
+                }
+                allocated = JNI_TRUE;
+
+                memcpy(newBuf, addr, rv);
+                iov->iov_base = newBuf + rv;
+                iov->iov_len = SCTP_NOTIFICATION_SIZE - rv;
                 if ((rv = recvmsg(fd, msg, flags)) < 0) {
                     handleSocketError(env, errno);
                     return 0;
                 }
-                bufp = buf;
+                bufp = newBuf;
                 rv += rvSAVE;
             }
+#ifdef __sparc
+              else if ((intptr_t)addr & 0x3) {
+                /* the given buffer is not 4 byte aligned */
+                char* newBuf;
+                if ((newBuf = malloc(SCTP_NOTIFICATION_SIZE)) == NULL) {
+                    JNU_ThrowOutOfMemoryError(env, "Out of native heap space.");
+                    return -1;
+                }
+                allocated = JNI_TRUE;
+
+                memcpy(newBuf, addr, rv);
+                bufp = newBuf;
+            }
+#endif
             snp = (union sctp_notification *) bufp;
             if (handleNotification(env, fd, resultContainerObj, snp, rv,
                                    (msg->msg_flags & MSG_EOR),
@@ -479,9 +505,16 @@
                 /* We have received a notification that is of interest to
                    to the Java API. The appropriate notification will be
                    set in the result container. */
+                if (allocated == JNI_TRUE) {
+                    free(bufp);
+                }
                 return 0;
             }
 
+            if (allocated == JNI_TRUE) {
+                free(bufp);
+            }
+
             // set iov back to addr, and reset msg_controllen
             iov->iov_base = addr;
             iov->iov_len = length;
--- ./jdk/src/solaris/native/sun/xawt/XlibWrapper.c	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/solaris/native/sun/xawt/XlibWrapper.c	Wed May 07 19:26:47 2014 -0700
@@ -41,6 +41,7 @@
 #include <sizecalc.h>
 
 #include <awt.h>
+#include <awt_util.h>
 #include <jvm.h>
 
 #include <Region.h>
@@ -1262,11 +1263,15 @@
 JavaVM* jvm = NULL;
 static int ToolkitErrorHandler(Display * dpy, XErrorEvent * event) {
     JNIEnv * env;
+    // First call the native synthetic error handler declared in "awt_util.h" file.
+    if (current_native_xerror_handler != NULL) {
+        current_native_xerror_handler(dpy, event);
+    }
     if (jvm != NULL) {
         env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
         if (env) {
-            return JNU_CallStaticMethodByName(env, NULL, "sun/awt/X11/XToolkit", "globalErrorHandler", "(JJ)I",
-                                              ptr_to_jlong(dpy), ptr_to_jlong(event)).i;
+            return JNU_CallStaticMethodByName(env, NULL, "sun/awt/X11/XErrorHandlerUtil",
+                "globalErrorHandler", "(JJ)I", ptr_to_jlong(dpy), ptr_to_jlong(event)).i;
         }
     }
     return 0;
--- ./jdk/src/windows/back/linker_md.c	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/windows/back/linker_md.c	Wed May 07 19:26:47 2014 -0700
@@ -39,33 +39,27 @@
 #include "path_md.h"
 
 static void dll_build_name(char* buffer, size_t buflen,
-                           const char* pname, const char* fname) {
-    // Based on os_windows.cpp
+                           const char* paths, const char* fname) {
+    char *path, *paths_copy, *next_token;
 
-    char *path_sep = PATH_SEPARATOR;
-    char *pathname = (char *)pname;
-    while (strlen(pathname) > 0) {
-        char *p = strchr(pathname, *path_sep);
-        if (p == NULL) {
-            p = pathname + strlen(pathname);
-        }
-        /* check for NULL path */
-        if (p == pathname) {
-            continue;
-        }
-        if (*(p-1) == ':' || *(p-1) == '\\') {
-            (void)_snprintf(buffer, buflen, "%.*s%s.dll", (p - pathname),
-                            pathname, fname);
-        } else {
-            (void)_snprintf(buffer, buflen, "%.*s\\%s.dll", (p - pathname),
-                            pathname, fname);
-        }
+    paths_copy = strdup(paths);
+    if (paths_copy == NULL) {
+        return;
+    }
+
+    next_token = NULL;
+    path = strtok_s(paths_copy, PATH_SEPARATOR, &next_token);
+
+    while (path != NULL) {
+        _snprintf(buffer, buflen, "%s\\%s.dll", path, fname);
         if (_access(buffer, 0) == 0) {
             break;
         }
-        pathname = p + 1;
         *buffer = '\0';
+        path = strtok_s(NULL, PATH_SEPARATOR, &next_token);
     }
+
+    free(paths_copy);
 }
 
 /*
@@ -108,7 +102,7 @@
  * Build a machine dependent library name out of a path and file name.
  */
 void
-dbgsysBuildLibName(char *holder, int holderlen, char *pname, char *fname)
+dbgsysBuildLibName(char *holder, int holderlen, const char *pname, const char *fname)
 {
     const int pnamelen = pname ? (int)strlen(pname) : 0;
 
--- ./jdk/src/windows/bin/cmdtoargs.c	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/windows/bin/cmdtoargs.c	Wed May 07 19:26:47 2014 -0700
@@ -53,6 +53,16 @@
 static StdArg *stdargs;
 static int    stdargc;
 
+static int copyCh(USHORT ch, char* dest) {
+    if (HIBYTE(ch) == 0) {
+        *dest = (char)ch;
+        return 1;
+    } else {
+        *((USHORT *)dest) = ch;
+        return 2;
+    }
+}
+
 static char* next_arg(char* cmdline, char* arg, jboolean* wildcard) {
 
     char* src = cmdline;
@@ -61,31 +71,43 @@
     int quotes = 0;
     int slashes = 0;
 
-    char prev = 0;
-    char ch = 0;
+    // "prev"/"ch" may contain either a single byte, or a double byte
+    // character encoded in CP_ACP.
+    USHORT prev = 0;
+    USHORT ch = 0;
     int i;
     jboolean done = JNI_FALSE;
+    int charLength;
 
     *wildcard = JNI_FALSE;
-    while ((ch = *src) != 0 && !done) {
+    while (!done) {
+        charLength = CharNextExA(CP_ACP, src, 0) - src;
+        if (charLength == 0) {
+            break;
+        } else if (charLength == 1) {
+            ch = (USHORT)(UCHAR)src[0];
+        } else {
+            ch = ((USHORT *)src)[0];
+        }
+
         switch (ch) {
-        case '"':
+        case L'"':
             if (separator) {
                 done = JNI_TRUE;
                 break;
             }
-            if (prev == '\\') {
+            if (prev == L'\\') {
                 for (i = 1; i < slashes; i += 2) {
-                    *dest++ = prev;
+                    dest += copyCh(prev, dest);
                 }
                 if (slashes % 2 == 1) {
-                    *dest++ = ch;
+                    dest += copyCh(ch, dest);
                 } else {
                     quotes++;
                 }
-            } else if (prev == '"' && quotes % 2 == 0) {
+            } else if (prev == L'"' && quotes % 2 == 0) {
                 quotes++;
-                *dest++ = ch; // emit every other consecutive quote
+                dest += copyCh(ch, dest); // emit every other consecutive quote
             } else if (quotes == 0) {
                 quotes++; // starting quote
             } else {
@@ -94,7 +116,7 @@
             slashes = 0;
             break;
 
-        case '\\':
+        case L'\\':
             slashes++;
             if (separator) {
                 done = JNI_TRUE;
@@ -102,23 +124,23 @@
             }
             break;
 
-        case ' ':
-        case '\t':
-            if (prev == '\\') {
+        case L' ':
+        case L'\t':
+            if (prev == L'\\') {
                 for (i = 0 ; i < slashes; i++) {
-                   *dest++ = prev;
+                    dest += copyCh(prev, dest);
                 }
             }
             if (quotes % 2 == 1) {
-                *dest++ = ch;
+                dest += copyCh(ch, dest);
             } else {
                 separator = JNI_TRUE;
             }
             slashes = 0;
             break;
 
-        case '*':
-        case '?':
+        case L'*':
+        case L'?':
             if (separator) {
                 done = JNI_TRUE;
                 separator = JNI_FALSE;
@@ -127,36 +149,36 @@
             if (quotes % 2 == 0) {
                 *wildcard = JNI_TRUE;
             }
-            if (prev == '\\') {
+            if (prev == L'\\') {
                 for (i = 0 ; i < slashes ; i++) {
-                    *dest++ = prev;
+                    dest += copyCh(prev, dest);
                 }
             }
-            *dest++ = ch;
+            dest += copyCh(ch, dest);
             break;
 
         default:
-            if (prev == '\\') {
+            if (prev == L'\\') {
                 for (i = 0 ; i < slashes ; i++) {
-                   *dest++ = prev;
+                    dest += copyCh(prev, dest);
                 }
-                *dest++ = ch;
+                dest += copyCh(ch, dest);
             } else if (separator) {
                 done = JNI_TRUE;
             } else {
-                *dest++ = ch;
+                dest += copyCh(ch, dest);
             }
             slashes = 0;
         }
 
         if (!done) {
             prev = ch;
-            src++;
+            src += charLength;
         }
     }
-    if (prev == '\\') {
+    if (prev == L'\\') {
         for (i = 0; i < slashes; i++) {
-            *dest++ = prev;
+            dest += copyCh(prev, dest);
         }
     }
     *dest = 0;
--- ./jdk/src/windows/classes/java/lang/ProcessImpl.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/windows/classes/java/lang/ProcessImpl.java	Wed May 07 19:26:47 2014 -0700
@@ -457,8 +457,10 @@
 
     /**
      * Create a process using the win32 function CreateProcess.
+     * The method is synchronized due to MS kb315939 problem.
+     * All native handles should restore the inherit flag at the end of call.
      *
-     * @param cmdstr the Windows commandline
+     * @param cmdstr the Windows command line
      * @param envblock NUL-separated, double-NUL-terminated list of
      *        environment strings in VAR=VALUE form
      * @param dir the working directory of the process, or null if
@@ -474,7 +476,7 @@
      * @param redirectErrorStream redirectErrorStream attribute
      * @return the native subprocess HANDLE returned by CreateProcess
      */
-    private static native long create(String cmdstr,
+    private static synchronized native long create(String cmdstr,
                                       String envblock,
                                       String dir,
                                       long[] stdHandles,
--- ./jdk/src/windows/classes/java/net/DualStackPlainSocketImpl.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/windows/classes/java/net/DualStackPlainSocketImpl.java	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2007, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -162,8 +162,9 @@
         if (!fd.valid())
             return;
 
-        close0(fdAccess.get(fd));
+        final int nativefd = fdAccess.get(fd);
         fdAccess.set(fd, -1);
+        close0(nativefd);
     }
 
     void socketShutdown(int howto) throws IOException {
--- ./jdk/src/windows/classes/java/net/PlainSocketImpl.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/windows/classes/java/net/PlainSocketImpl.java	Wed May 07 19:26:47 2014 -0700
@@ -191,14 +191,17 @@
     }
 
     protected synchronized void accept(SocketImpl s) throws IOException {
-        // pass in the real impl not the wrapper.
-        SocketImpl delegate = ((PlainSocketImpl)s).impl;
-        delegate.address = new InetAddress();
-        delegate.fd = new FileDescriptor();
-        impl.accept(delegate);
-
-        // set fd to delegate's fd to be compatible with older releases
-        s.fd = delegate.fd;
+        if (s instanceof PlainSocketImpl) {
+            // pass in the real impl not the wrapper.
+            SocketImpl delegate = ((PlainSocketImpl)s).impl;
+            delegate.address = new InetAddress();
+            delegate.fd = new FileDescriptor();
+            impl.accept(delegate);
+            // set fd to delegate's fd to be compatible with older releases
+            s.fd = delegate.fd;
+        } else {
+            impl.accept(s);
+        }
     }
 
     void setFileDescriptor(FileDescriptor fd) {
--- ./jdk/src/windows/classes/sun/awt/windows/WPrinterJob.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/windows/classes/sun/awt/windows/WPrinterJob.java	Wed May 07 19:26:47 2014 -0700
@@ -179,6 +179,7 @@
     private static final int SET_RES_LOW = 0x00000080;
     private static final int SET_COLOR = 0x00000200;
     private static final int SET_ORIENTATION = 0x00004000;
+    private static final int SET_COLLATED    = 0x00008000;
 
     /**
      * Values must match those defined in wingdi.h & commdlg.h
@@ -189,10 +190,33 @@
     private static final int PD_NOSELECTION = 0x00000004;
     private static final int PD_COLLATE = 0x00000010;
     private static final int PD_PRINTTOFILE = 0x00000020;
-    private static final int DM_ORIENTATION = 0x00000001;
-    private static final int DM_PRINTQUALITY = 0x00000400;
-    private static final int DM_COLOR = 0x00000800;
-    private static final int DM_DUPLEX = 0x00001000;
+    private static final int DM_ORIENTATION   = 0x00000001;
+    private static final int DM_PAPERSIZE     = 0x00000002;
+    private static final int DM_COPIES        = 0x00000100;
+    private static final int DM_DEFAULTSOURCE = 0x00000200;
+    private static final int DM_PRINTQUALITY  = 0x00000400;
+    private static final int DM_COLOR         = 0x00000800;
+    private static final int DM_DUPLEX        = 0x00001000;
+    private static final int DM_YRESOLUTION   = 0x00002000;
+    private static final int DM_COLLATE       = 0x00008000;
+
+    private static final short DMCOLLATE_FALSE  = 0;
+    private static final short DMCOLLATE_TRUE   = 1;
+
+    private static final short DMORIENT_PORTRAIT  = 1;
+    private static final short DMORIENT_LANDSCAPE = 2;
+
+    private static final short DMCOLOR_MONOCHROME = 1;
+    private static final short DMCOLOR_COLOR      = 2;
+
+    private static final short DMRES_DRAFT  = -1;
+    private static final short DMRES_LOW    = -2;
+    private static final short DMRES_MEDIUM = -3;
+    private static final short DMRES_HIGH   = -4;
+
+    private static final short DMDUP_SIMPLEX    = 1;
+    private static final short DMDUP_VERTICAL   = 2;
+    private static final short DMDUP_HORIZONTAL = 3;
 
     /**
      * Pageable MAX pages
@@ -592,13 +616,23 @@
         }
         driverDoesMultipleCopies = false;
         driverDoesCollation = false;
-        setNativePrintService(service.getName());
+        setNativePrintServiceIfNeeded(service.getName());
     }
 
     /* associates this job with the specified native service */
     private native void setNativePrintService(String name)
         throws PrinterException;
 
+    private String lastNativeService = null;
+    private void setNativePrintServiceIfNeeded(String name)
+        throws PrinterException {
+
+        if (name != null && !(name.equals(lastNativeService))) {
+            setNativePrintService(name);
+            lastNativeService = name;
+        }
+    }
+
     public PrintService getPrintService() {
         if (myService == null) {
             String printerName = getNativePrintService();
@@ -616,7 +650,7 @@
             myService = PrintServiceLookup.lookupDefaultPrintService();
             if (myService != null) {
                 try {
-                    setNativePrintService(myService.getName());
+                    setNativePrintServiceIfNeeded(myService.getName());
                 } catch (Exception e) {
                     myService = null;
                 }
@@ -1742,8 +1776,13 @@
         mAttMediaSizeName = ((Win32PrintService)myService).findPaperID(msn);
     }
 
-    private void setWin32MediaAttrib(int dmIndex, int width, int length) {
-       MediaSizeName msn =
+    private void addPaperSize(PrintRequestAttributeSet aset,
+                              int dmIndex, int width, int length) {
+
+        if (aset == null) {
+            return;
+        }
+        MediaSizeName msn =
            ((Win32PrintService)myService).findWin32Media(dmIndex);
         if (msn == null) {
             msn = ((Win32PrintService)myService).
@@ -1751,10 +1790,12 @@
         }
 
         if (msn != null) {
-            if (attributes != null) {
-                attributes.add(msn);
-            }
+            aset.add(msn);
         }
+    }
+
+    private void setWin32MediaAttrib(int dmIndex, int width, int length) {
+        addPaperSize(attributes, dmIndex, width, length);
         mAttMediaSizeName = dmIndex;
     }
 
@@ -1776,7 +1817,7 @@
             // no equivalent predefined value
             mAttMediaTray = 7;              // DMBIN_AUTO
         } else if (attr == MediaTray.TOP) {
-            mAttMediaTray =1;               // DMBIN_UPPER
+            mAttMediaTray = 1;              // DMBIN_UPPER
         } else {
             if (attr instanceof Win32MediaTray) {
                 mAttMediaTray = ((Win32MediaTray)attr).winID;
@@ -1902,6 +1943,254 @@
         }
     }
 
+    private static final class DevModeValues {
+        int dmFields;
+        short copies;
+        short collate;
+        short color;
+        short duplex;
+        short orient;
+        short paper;
+        short bin;
+        short xres_quality;
+        short yres;
+    }
+
+    private void getDevModeValues(PrintRequestAttributeSet aset,
+                                  DevModeValues info) {
+
+        Copies c = (Copies)aset.get(Copies.class);
+        if (c != null) {
+            info.dmFields |= DM_COPIES;
+            info.copies = (short)c.getValue();
+        }
+
+        SheetCollate sc = (SheetCollate)aset.get(SheetCollate.class);
+        if (sc != null) {
+            info.dmFields |= DM_COLLATE;
+            info.collate = (sc == SheetCollate.COLLATED) ?
+                DMCOLLATE_TRUE : DMCOLLATE_FALSE;
+        }
+
+        Chromaticity ch = (Chromaticity)aset.get(Chromaticity.class);
+        if (ch != null) {
+            info.dmFields |= DM_COLOR;
+            if (ch == Chromaticity.COLOR) {
+                info.color = DMCOLOR_COLOR;
+            } else {
+                info.color = DMCOLOR_MONOCHROME;
+            }
+        }
+
+        Sides s = (Sides)aset.get(Sides.class);
+        if (s != null) {
+            info.dmFields |= DM_DUPLEX;
+            if (s == Sides.TWO_SIDED_LONG_EDGE) {
+                info.duplex = DMDUP_VERTICAL;
+            } else if (s == Sides.TWO_SIDED_SHORT_EDGE) {
+                info.duplex = DMDUP_HORIZONTAL;
+            } else { // Sides.ONE_SIDED
+                info.duplex = DMDUP_SIMPLEX;
+            }
+        }
+
+        OrientationRequested or =
+            (OrientationRequested)aset.get(OrientationRequested.class);
+        if (or != null) {
+            info.dmFields |= DM_ORIENTATION;
+            info.orient = (or == OrientationRequested.LANDSCAPE)
+                ? DMORIENT_LANDSCAPE : DMORIENT_PORTRAIT;
+        }
+
+        Media m = (Media)aset.get(Media.class);
+        if (m instanceof MediaSizeName) {
+            info.dmFields |= DM_PAPERSIZE;
+            MediaSizeName msn = (MediaSizeName)m;
+            info.paper =
+                (short)((Win32PrintService)myService).findPaperID(msn);
+        }
+
+        MediaTray mt = null;
+        if (m instanceof MediaTray) {
+            mt = (MediaTray)m;
+        }
+        if (mt == null) {
+            SunAlternateMedia sam =
+                (SunAlternateMedia)aset.get(SunAlternateMedia.class);
+            if (sam != null && (sam.getMedia() instanceof MediaTray)) {
+                mt = (MediaTray)sam.getMedia();
+            }
+        }
+
+        if (mt != null) {
+            info.dmFields |= DM_DEFAULTSOURCE;
+            info.bin = (short)(((Win32PrintService)myService).findTrayID(mt));
+        }
+
+        PrintQuality q = (PrintQuality)aset.get(PrintQuality.class);
+        if (q != null) {
+            info.dmFields |= DM_PRINTQUALITY;
+            if (q == PrintQuality.DRAFT) {
+                info.xres_quality = DMRES_DRAFT;
+            } else if (q == PrintQuality.HIGH) {
+                info.xres_quality = DMRES_HIGH;
+            } else {
+                info.xres_quality = DMRES_MEDIUM;
+            }
+        }
+
+        PrinterResolution r =
+            (PrinterResolution)aset.get(PrinterResolution.class);
+        if (r != null) {
+            info.dmFields |= DM_PRINTQUALITY | DM_YRESOLUTION;
+            info.xres_quality =
+                (short)r.getCrossFeedResolution(PrinterResolution.DPI);
+            info.yres = (short)r.getFeedResolution(PrinterResolution.DPI);
+        }
+    }
+
+    /* This method is called from native to update the values in the
+     * attribute set which originates from the cross-platform dialog,
+     * but updated by the native DocumentPropertiesUI which updates the
+     * devmode. This syncs the devmode back in to the attributes so that
+     * we can update the cross-platform dialog.
+     * The attribute set here is a temporary one installed whilst this
+     * happens,
+     */
+    private final void setJobAttributes(PrintRequestAttributeSet attributes,
+                                        int fields, int values,
+                                        short copies,
+                                        short dmPaperSize,
+                                        short dmPaperWidth,
+                                        short dmPaperLength,
+                                        short dmDefaultSource,
+                                        short xRes,
+                                        short yRes) {
+
+        if (attributes == null) {
+            return;
+        }
+
+        if ((fields & DM_COPIES) != 0) {
+            attributes.add(new Copies(copies));
+        }
+
+        if ((fields & DM_COLLATE) != 0) {
+            if ((values & SET_COLLATED) != 0) {
+                attributes.add(SheetCollate.COLLATED);
+            } else {
+                attributes.add(SheetCollate.UNCOLLATED);
+            }
+        }
+
+        if ((fields & DM_ORIENTATION) != 0) {
+            if ((values & SET_ORIENTATION) != 0) {
+                attributes.add(OrientationRequested.LANDSCAPE);
+            } else {
+                attributes.add(OrientationRequested.PORTRAIT);
+            }
+        }
+
+        if ((fields & DM_COLOR) != 0) {
+            if ((values & SET_COLOR) != 0) {
+                attributes.add(Chromaticity.COLOR);
+            } else {
+                attributes.add(Chromaticity.MONOCHROME);
+            }
+        }
+
+        if ((fields & DM_PRINTQUALITY) != 0) {
+            /* value < 0 indicates quality setting.
+             * value > 0 indicates X resolution. In that case
+             * hopefully we will also find y-resolution specified.
+             * If its not, assume its the same as x-res.
+             * Maybe Java code should try to reconcile this against
+             * the printers claimed set of supported resolutions.
+             */
+            if (xRes < 0) {
+                PrintQuality quality;
+                if ((values & SET_RES_LOW) != 0) {
+                    quality = PrintQuality.DRAFT;
+                } else if ((fields & SET_RES_HIGH) != 0) {
+                    quality = PrintQuality.HIGH;
+                } else {
+                    quality = PrintQuality.NORMAL;
+                }
+                attributes.add(quality);
+            } else if (xRes > 0 && yRes > 0) {
+                attributes.add(
+                    new PrinterResolution(xRes, yRes, PrinterResolution.DPI));
+            }
+        }
+
+        if ((fields & DM_DUPLEX) != 0) {
+            Sides sides;
+            if ((values & SET_DUP_VERTICAL) != 0) {
+                sides = Sides.TWO_SIDED_LONG_EDGE;
+            } else if ((values & SET_DUP_HORIZONTAL) != 0) {
+                sides = Sides.TWO_SIDED_SHORT_EDGE;
+            } else {
+                sides = Sides.ONE_SIDED;
+            }
+            attributes.add(sides);
+        }
+
+        if ((fields & DM_PAPERSIZE) != 0) {
+            addPaperSize(attributes, dmPaperSize, dmPaperWidth, dmPaperLength);
+        }
+
+        if ((fields & DM_DEFAULTSOURCE) != 0) {
+            MediaTray tray =
+                ((Win32PrintService)myService).findMediaTray(dmDefaultSource);
+            attributes.add(new SunAlternateMedia(tray));
+        }
+    }
+
+    private native boolean showDocProperties(long hWnd,
+                                             PrintRequestAttributeSet aset,
+                                             int dmFields,
+                                             short copies,
+                                             short collate,
+                                             short color,
+                                             short duplex,
+                                             short orient,
+                                             short paper,
+                                             short bin,
+                                             short xres_quality,
+                                             short yres);
+
+    @SuppressWarnings("deprecation")
+    public PrintRequestAttributeSet
+        showDocumentProperties(Window owner,
+                               PrintService service,
+                               PrintRequestAttributeSet aset)
+    {
+        try {
+            setNativePrintServiceIfNeeded(service.getName());
+        } catch (PrinterException e) {
+        }
+        long hWnd = ((WWindowPeer)(owner.getPeer())).getHWnd();
+        DevModeValues info = new DevModeValues();
+        getDevModeValues(aset, info);
+        boolean ok =
+            showDocProperties(hWnd, aset,
+                              info.dmFields,
+                              info.copies,
+                              info.collate,
+                              info.color,
+                              info.duplex,
+                              info.orient,
+                              info.paper,
+                              info.bin,
+                              info.xres_quality,
+                              info.yres);
+
+        if (ok) {
+            return aset;
+        } else {
+            return null;
+        }
+    }
 
     /* Printer Resolution. See also getXRes() and getYRes() */
     private final void setResolutionDPI(int xres, int yres) {
@@ -1944,7 +2233,7 @@
         }
     //** END Functions called by native code for querying/updating attributes
 
-   }
+    }
 
 class PrintToFileErrorDialog extends Dialog implements ActionListener{
     public PrintToFileErrorDialog(Frame parent, String title, String message,
--- ./jdk/src/windows/classes/sun/awt/windows/WToolkit.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/windows/classes/sun/awt/windows/WToolkit.java	Wed May 07 19:26:47 2014 -0700
@@ -37,6 +37,7 @@
 import java.security.AccessController;
 import java.security.PrivilegedAction;
 import sun.awt.AWTAutoShutdown;
+import sun.awt.AppContext;
 import sun.awt.SunToolkit;
 import sun.misc.ThreadGroupUtils;
 import sun.awt.Win32GraphicsDevice;
@@ -864,6 +865,7 @@
      */
     private void windowsSettingChange() {
         EventQueue.invokeLater(new Runnable() {
+            @Override
             public void run() {
                 updateProperties();
             }
--- ./jdk/src/windows/classes/sun/nio/ch/WindowsAsynchronousFileChannelImpl.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/windows/classes/sun/nio/ch/WindowsAsynchronousFileChannelImpl.java	Wed May 07 19:26:47 2014 -0700
@@ -230,6 +230,7 @@
         @Override
         public void run() {
             long overlapped = 0L;
+            boolean pending = false;
             try {
                 begin();
 
@@ -243,6 +244,7 @@
                                      overlapped);
                     if (n == IOStatus.UNAVAILABLE) {
                         // I/O is pending
+                        pending = true;
                         return;
                     }
                     // acquired lock immediately
@@ -252,10 +254,10 @@
             } catch (Throwable x) {
                 // lock failed or channel closed
                 removeFromFileLockTable(fli);
-                if (overlapped != 0L)
-                    ioCache.remove(overlapped);
                 result.setFailure(toIOException(x));
             } finally {
+                if (!pending && overlapped != 0L)
+                    ioCache.remove(overlapped);
                 end();
             }
 
--- ./jdk/src/windows/classes/sun/nio/fs/WindowsConstants.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/windows/classes/sun/nio/fs/WindowsConstants.java	Wed May 07 19:26:47 2014 -0700
@@ -100,6 +100,7 @@
     public static final int ERROR_INVALID_LEVEL         = 124;
     public static final int ERROR_DIR_NOT_EMPTY         = 145;
     public static final int ERROR_ALREADY_EXISTS        = 183;
+    public static final int ERROR_MORE_DATA             = 234;
     public static final int ERROR_DIRECTORY             = 267;
     public static final int ERROR_NOTIFY_ENUM_DIR       = 1022;
     public static final int ERROR_NONE_MAPPED           = 1332;
--- ./jdk/src/windows/classes/sun/nio/fs/WindowsNativeDispatcher.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/windows/classes/sun/nio/fs/WindowsNativeDispatcher.java	Wed May 07 19:26:47 2014 -0700
@@ -973,19 +973,19 @@
      * HANDLE CreateIoCompletionPort (
      *   HANDLE FileHandle,
      *   HANDLE ExistingCompletionPort,
-     *   DWORD CompletionKey,
+     *   ULONG_PTR CompletionKey,
      *   DWORD NumberOfConcurrentThreads
      * )
      */
     static native long CreateIoCompletionPort(long fileHandle, long existingPort,
-        int completionKey) throws WindowsException;
+        long completionKey) throws WindowsException;
 
 
     /**
      * GetQueuedCompletionStatus(
      *   HANDLE CompletionPort,
      *   LPDWORD lpNumberOfBytesTransferred,
-     *   LPDWORD lpCompletionKey,
+     *   PULONG_PTR lpCompletionKey,
      *   LPOVERLAPPED *lpOverlapped,
      *   DWORD dwMilliseconds
      */
@@ -999,12 +999,12 @@
     static class CompletionStatus {
         private int error;
         private int bytesTransferred;
-        private int completionKey;
+        private long completionKey;
         private CompletionStatus() { }
 
         int error() { return error; }
         int bytesTransferred() { return bytesTransferred; }
-        int completionKey() { return completionKey; }
+        long completionKey() { return completionKey; }
     }
     private static native void GetQueuedCompletionStatus0(long completionPort,
         CompletionStatus status) throws WindowsException;
@@ -1013,12 +1013,12 @@
      * PostQueuedCompletionStatus(
      *   HANDLE CompletionPort,
      *   DWORD dwNumberOfBytesTransferred,
-     *   DWORD dwCompletionKey,
+     *   ULONG_PTR dwCompletionKey,
      *   LPOVERLAPPED lpOverlapped
      * )
      */
     static native void PostQueuedCompletionStatus(long completionPort,
-        int completionKey) throws WindowsException;
+        long completionKey) throws WindowsException;
 
     /**
      * ReadDirectoryChangesW(
--- ./jdk/src/windows/classes/sun/nio/fs/WindowsWatchService.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/windows/classes/sun/nio/fs/WindowsWatchService.java	Wed May 07 19:26:47 2014 -0700
@@ -41,6 +41,7 @@
 class WindowsWatchService
     extends AbstractWatchService
 {
+    private final static int WAKEUP_COMPLETION_KEY = 0;
     private final Unsafe unsafe = Unsafe.getUnsafe();
 
     // background thread to service I/O completion port
@@ -83,7 +84,7 @@
      */
     private class WindowsWatchKey extends AbstractWatchKey {
         // file key (used to detect existing registrations)
-        private FileKey fileKey;
+        private final FileKey fileKey;
 
         // handle to directory
         private volatile long handle = INVALID_HANDLE_VALUE;
@@ -223,8 +224,7 @@
             FileKey other = (FileKey)obj;
             if (this.volSerialNumber != other.volSerialNumber) return false;
             if (this.fileIndexHigh != other.fileIndexHigh) return false;
-            if (this.fileIndexLow != other.fileIndexLow) return false;
-            return true;
+            return this.fileIndexLow == other.fileIndexLow;
         }
     }
 
@@ -268,6 +268,7 @@
         private static final short OFFSETOF_FILENAME        = 12;
 
         // size of per-directory buffer for events (FIXME - make this configurable)
+        // Need to be less than 4*16384 = 65536. DWORD align.
         private static final int CHANGES_BUFFER_SIZE    = 16 * 1024;
 
         private final WindowsFileSystem fs;
@@ -275,27 +276,28 @@
         private final long port;
 
         // maps completion key to WatchKey
-        private final Map<Integer,WindowsWatchKey> int2key;
+        private final Map<Integer,WindowsWatchKey> ck2key;
 
         // maps file key to WatchKey
         private final Map<FileKey,WindowsWatchKey> fk2key;
 
         // unique completion key for each directory
+        // native completion key capacity is 64 bits on Win64.
         private int lastCompletionKey;
 
         Poller(WindowsFileSystem fs, WindowsWatchService watcher, long port) {
             this.fs = fs;
             this.watcher = watcher;
             this.port = port;
-            this.int2key = new HashMap<Integer,WindowsWatchKey>();
-            this.fk2key = new HashMap<FileKey,WindowsWatchKey>();
+            this.ck2key = new HashMap<>();
+            this.fk2key = new HashMap<>();
             this.lastCompletionKey = 0;
         }
 
         @Override
         void wakeup() throws IOException {
             try {
-                PostQueuedCompletionStatus(port, 0);
+                PostQueuedCompletionStatus(port, WAKEUP_COMPLETION_KEY);
             } catch (WindowsException x) {
                 throw new IOException(x.getMessage());
             }
@@ -322,7 +324,6 @@
             for (WatchEvent.Modifier modifier: modifiers) {
                 if (modifier == ExtendedWatchEventModifier.FILE_TREE) {
                     watchSubtree = true;
-                    continue;
                 } else {
                     if (modifier == null)
                         return new NullPointerException();
@@ -333,7 +334,7 @@
             }
 
             // open directory
-            long handle = -1L;
+            long handle;
             try {
                 handle = CreateFile(dir.getPathForWin32Calls(),
                                     FILE_LIST_DIRECTORY,
@@ -347,7 +348,7 @@
             boolean registered = false;
             try {
                 // read attributes and check file is a directory
-                WindowsFileAttributes attrs = null;
+                WindowsFileAttributes attrs;
                 try {
                     attrs = WindowsFileAttributes.readAttributes(handle);
                 } catch (WindowsException x) {
@@ -370,9 +371,10 @@
                     return existing;
                 }
 
-                // unique completion key (skip 0)
+                // Can overflow the int type capacity.
+                // Skip WAKEUP_COMPLETION_KEY value.
                 int completionKey = ++lastCompletionKey;
-                if (completionKey == 0)
+                if (completionKey == WAKEUP_COMPLETION_KEY)
                     completionKey = ++lastCompletionKey;
 
                 // associate handle with completion port
@@ -418,13 +420,13 @@
                     // 1. remove mapping from old completion key to existing watch key
                     // 2. release existing key's resources (handle/buffer)
                     // 3. re-initialize key with new handle/buffer
-                    int2key.remove(existing.completionKey());
+                    ck2key.remove(existing.completionKey());
                     existing.releaseResources();
                     watchKey = existing.init(handle, events, watchSubtree, buffer,
                         countAddress, overlappedAddress, completionKey);
                 }
                 // map completion map to watch key
-                int2key.put(completionKey, watchKey);
+                ck2key.put(completionKey, watchKey);
 
                 registered = true;
                 return watchKey;
@@ -440,7 +442,7 @@
             WindowsWatchKey key = (WindowsWatchKey)obj;
             if (key.isValid()) {
                 fk2key.remove(key.fileKey());
-                int2key.remove(key.completionKey());
+                ck2key.remove(key.completionKey());
                 key.invalidate();
             }
         }
@@ -449,11 +451,11 @@
         @Override
         void implCloseAll() {
             // cancel all keys
-            for (Map.Entry<Integer,WindowsWatchKey> entry: int2key.entrySet()) {
+            for (Map.Entry<Integer, WindowsWatchKey> entry: ck2key.entrySet()) {
                 entry.getValue().invalidate();
             }
             fk2key.clear();
-            int2key.clear();
+            ck2key.clear();
 
             // close I/O completion port
             CloseHandle(port);
@@ -517,7 +519,7 @@
         @Override
         public void run() {
             for (;;) {
-                CompletionStatus info = null;
+                CompletionStatus info;
                 try {
                     info = GetQueuedCompletionStatus(port);
                 } catch (WindowsException x) {
@@ -527,7 +529,7 @@
                 }
 
                 // wakeup
-                if (info.completionKey() == 0) {
+                if (info.completionKey() == WAKEUP_COMPLETION_KEY) {
                     boolean shutdown = processRequests();
                     if (shutdown) {
                         return;
@@ -536,7 +538,7 @@
                 }
 
                 // map completionKey to get WatchKey
-                WindowsWatchKey key = int2key.get(info.completionKey());
+                WindowsWatchKey key = ck2key.get((int)info.completionKey());
                 if (key == null) {
                     // We get here when a registration is changed. In that case
                     // the directory is closed which causes an event with the
@@ -544,38 +546,44 @@
                     continue;
                 }
 
-                // ReadDirectoryChangesW failed
-                if (info.error() != 0) {
+                boolean criticalError = false;
+                int errorCode = info.error();
+                int messageSize = info.bytesTransferred();
+                if (errorCode == ERROR_NOTIFY_ENUM_DIR) {
                     // buffer overflow
-                    if (info.error() == ERROR_NOTIFY_ENUM_DIR) {
+                    key.signalEvent(StandardWatchEventKinds.OVERFLOW, null);
+                } else if (errorCode != 0 && errorCode != ERROR_MORE_DATA) {
+                    // ReadDirectoryChangesW failed
+                    criticalError = true;
+                } else {
+                    // ERROR_MORE_DATA is a warning about incomplite
+                    // data transfer over TCP/UDP stack. For the case
+                    // [messageSize] is zero in the most of cases.
+
+                    if (messageSize > 0) {
+                        // process non-empty events.
+                        processEvents(key, messageSize);
+                    } else if (errorCode == 0) {
+                        // insufficient buffer size
+                        // not described, but can happen.
                         key.signalEvent(StandardWatchEventKinds.OVERFLOW, null);
-                    } else {
-                        // other error so cancel key
-                        implCancelKey(key);
-                        key.signal();
                     }
-                    continue;
+
+                    // start read for next batch of changes
+                    try {
+                        ReadDirectoryChangesW(key.handle(),
+                                              key.buffer().address(),
+                                              CHANGES_BUFFER_SIZE,
+                                              key.watchSubtree(),
+                                              ALL_FILE_NOTIFY_EVENTS,
+                                              key.countAddress(),
+                                              key.overlappedAddress());
+                    } catch (WindowsException x) {
+                        // no choice but to cancel key
+                        criticalError = true;
+                    }
                 }
-
-                // process the events
-                if (info.bytesTransferred() > 0) {
-                    processEvents(key, info.bytesTransferred());
-                } else {
-                    // insufficient buffer size
-                    key.signalEvent(StandardWatchEventKinds.OVERFLOW, null);
-                }
-
-                // start read for next batch of changes
-                try {
-                    ReadDirectoryChangesW(key.handle(),
-                                          key.buffer().address(),
-                                          CHANGES_BUFFER_SIZE,
-                                          key.watchSubtree(),
-                                          ALL_FILE_NOTIFY_EVENTS,
-                                          key.countAddress(),
-                                          key.overlappedAddress());
-                } catch (WindowsException x) {
-                    // no choice but to cancel key
+                if (criticalError) {
                     implCancelKey(key);
                     key.signal();
                 }
--- ./jdk/src/windows/classes/sun/print/Win32MediaTray.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/windows/classes/sun/print/Win32MediaTray.java	Wed May 07 19:26:47 2014 -0700
@@ -70,6 +70,10 @@
         winEnumTable.add(this);
     }
 
+    public int getDMBinID() {
+        return winID;
+    }
+
     private static final String[] myStringTable ={
         "Manual-Envelope",
         "Automatic-Feeder",
--- ./jdk/src/windows/classes/sun/print/Win32PrintService.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/windows/classes/sun/print/Win32PrintService.java	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -25,14 +25,13 @@
 
 package sun.print;
 
+import java.awt.Window;
+import java.awt.print.PrinterJob;
 import java.io.File;
 import java.net.URI;
 import java.net.URISyntaxException;
-import java.net.URL;
-
-import java.util.Vector;
+import java.util.ArrayList;
 import java.util.HashMap;
-
 import javax.print.DocFlavor;
 import javax.print.DocPrintJob;
 import javax.print.PrintService;
@@ -42,6 +41,7 @@
 import javax.print.attribute.AttributeSetUtilities;
 import javax.print.attribute.EnumSyntax;
 import javax.print.attribute.HashAttributeSet;
+import javax.print.attribute.PrintRequestAttributeSet;
 import javax.print.attribute.PrintServiceAttribute;
 import javax.print.attribute.PrintServiceAttributeSet;
 import javax.print.attribute.HashPrintServiceAttributeSet;
@@ -69,22 +69,15 @@
 import javax.print.attribute.standard.Sides;
 import javax.print.attribute.standard.ColorSupported;
 import javax.print.attribute.standard.PrintQuality;
-import javax.print.attribute.ResolutionSyntax;
 import javax.print.attribute.standard.PrinterResolution;
 import javax.print.attribute.standard.SheetCollate;
 import javax.print.event.PrintServiceAttributeListener;
-import java.util.ArrayList;
-
-import sun.print.SunPrinterJobService;
+import sun.awt.windows.WPrinterJob;
 
 public class Win32PrintService implements PrintService, AttributeUpdater,
                                           SunPrinterJobService {
 
-    public static MediaSize[] predefMedia;
-
-    static {
-        Class c = Win32MediaSize.class;
-    }
+    public static MediaSize[] predefMedia = Win32MediaSize.getPredefMedia();
 
     private static final DocFlavor[] supportedFlavors = {
         DocFlavor.BYTE_ARRAY.GIF,
@@ -290,6 +283,22 @@
         return 0;
     }
 
+    public int findTrayID(MediaTray tray) {
+
+        getMediaTrays(); // make sure they are initialised.
+
+        if (tray instanceof Win32MediaTray) {
+            Win32MediaTray winTray = (Win32MediaTray)tray;
+            return winTray.getDMBinID();
+        }
+        for (int id=0; id<dmPaperBinToPrintService.length; id++) {
+            if (tray.equals(dmPaperBinToPrintService[id])) {
+                return id+1; // DMBIN_FIRST = 1;
+            }
+        }
+        return 0; // didn't find the tray
+    }
+
     public MediaTray findMediaTray(int dmBin) {
         if (dmBin >= 1 && dmBin <= dmPaperBinToPrintService.length) {
             return dmPaperBinToPrintService[dmBin-1];
@@ -310,7 +319,9 @@
 
     public MediaSizeName findWin32Media(int dmIndex) {
         if (dmIndex >= 1 && dmIndex <= dmPaperToPrintService.length) {
-           switch(dmIndex) {
+            return dmPaperToPrintService[dmIndex - 1];
+        }
+        switch(dmIndex) {
             /* matching media sizes with indices beyond
                dmPaperToPrintService's length */
             case DMPAPER_A2:
@@ -320,11 +331,8 @@
             case DMPAPER_B6_JIS:
                 return MediaSizeName.JIS_B6;
             default:
-                return dmPaperToPrintService[dmIndex - 1];
-            }
+                return null;
         }
-
-        return null;
     }
 
     private boolean addToUniqueList(ArrayList msnList, MediaSizeName mediaName) {
@@ -350,6 +358,7 @@
         }
 
         ArrayList msnList = new ArrayList();
+        ArrayList<Win32MediaSize> trailingWmsList = new ArrayList<Win32MediaSize>();
         ArrayList printableList = new ArrayList();
         MediaSizeName mediaName;
         boolean added;
@@ -368,7 +377,8 @@
             idList.add(Integer.valueOf(media[i]));
         }
 
-        mediaSizes = getMediaSizes(idList, media);
+        ArrayList<String> dmPaperNameList = new ArrayList<String>();
+        mediaSizes = getMediaSizes(idList, media, dmPaperNameList);
         for (int i = 0; i < idList.size(); i++) {
 
             // match Win ID with our predefined ID using table
@@ -387,6 +397,7 @@
                    mediaName = null;
                 }
             }
+            boolean dmPaperIDMatched = (mediaName != null);
 
             // No match found, then we get the MediaSizeName out of the MediaSize
             // This requires 1-1 correspondence, lengths must be checked.
@@ -395,9 +406,32 @@
             }
 
             // Add mediaName to the msnList
+            added = false;
             if (mediaName != null) {
                 added = addToUniqueList(msnList, mediaName);
             }
+            if ((!dmPaperIDMatched || !added) && (idList.size() == dmPaperNameList.size())) {
+                /* The following block allows to add such media names to the list, whose sizes
+                 * matched with media sizes predefined in JDK, while whose paper IDs did not,
+                 * or whose sizes and paper IDs both did not match with any predefined in JDK.
+                 */
+                Win32MediaSize wms = Win32MediaSize.findMediaName(dmPaperNameList.get(i));
+                if ((wms == null) && (idList.size() == mediaSizes.length)) {
+                    wms = new Win32MediaSize(dmPaperNameList.get(i), (Integer)idList.get(i));
+                    mediaSizes[i] = new MediaSize(mediaSizes[i].getX(MediaSize.MM),
+                        mediaSizes[i].getY(MediaSize.MM), MediaSize.MM, wms);
+                }
+                if ((wms != null) && (wms != mediaName)) {
+                    if (!added) {
+                        added = addToUniqueList(msnList, mediaName = wms);
+                    } else {
+                        trailingWmsList.add(wms);
+                    }
+                }
+            }
+        }
+        for (Win32MediaSize wms : trailingWmsList) {
+            added = addToUniqueList(msnList, wms);
         }
 
         // init mediaSizeNames
@@ -588,7 +622,11 @@
     }
 
 
-    private MediaSize[] getMediaSizes(ArrayList idList, int[] media) {
+    private MediaSize[] getMediaSizes(ArrayList idList, int[] media, ArrayList<String> dmPaperNameList) {
+        if (dmPaperNameList == null) {
+            dmPaperNameList = new ArrayList<String>();
+        }
+
         String prnPort = getPort();
         int[] mediaSz = getAllMediaSizes(printer, prnPort);
         String[] winMediaNames = getAllMediaNames(printer, prnPort);
@@ -607,40 +645,43 @@
             wid = mediaSz[i*2]/10f;
             ht = mediaSz[i*2+1]/10f;
 
-          // Make sure to validate wid & ht.
-          // HP LJ 4050 (german) causes IAE in Sonderformat paper, wid & ht
-          // returned is not constant.
-          if ((wid <= 0) || (ht <= 0)) {
-            //Remove corresponding ID from list
-            if (nMedia == media.length) {
-                Integer remObj = Integer.valueOf(media[i]);
-              idList.remove(idList.indexOf(remObj));
+            // Make sure to validate wid & ht.
+            // HP LJ 4050 (german) causes IAE in Sonderformat paper, wid & ht
+            // returned is not constant.
+            if ((wid <= 0) || (ht <= 0)) {
+                //Remove corresponding ID from list
+                if (nMedia == media.length) {
+                    Integer remObj = Integer.valueOf(media[i]);
+                    idList.remove(idList.indexOf(remObj));
+                }
+                continue;
             }
-            continue;
-          }
-          // Find matching media using dimensions.
-          // This call matches only with our own predefined sizes.
-          msn = findMatchingMediaSizeNameMM(wid, ht);
-          if (msn != null) {
-            ms = MediaSize.getMediaSizeForName(msn);
-          }
+            // Find matching media using dimensions.
+            // This call matches only with our own predefined sizes.
+            msn = findMatchingMediaSizeNameMM(wid, ht);
+            if (msn != null) {
+                ms = MediaSize.getMediaSizeForName(msn);
+            }
 
-          if (ms != null) {
-            msList.add(ms);
-          } else {
-              Win32MediaSize wms =
-                new Win32MediaSize(winMediaNames[i], media[i]);
-            try {
-              ms = new MediaSize(wid, ht, MediaSize.MM, wms);
-              msList.add(ms);
-            } catch(IllegalArgumentException e) {
-              if (nMedia == media.length) {
-                  Integer remObj = Integer.valueOf(media[i]);
-                idList.remove(idList.indexOf(remObj));
-              }
+            if (ms != null) {
+                msList.add(ms);
+                dmPaperNameList.add(winMediaNames[i]);
+            } else {
+                Win32MediaSize wms = Win32MediaSize.findMediaName(winMediaNames[i]);
+                if (wms == null) {
+                    wms = new Win32MediaSize(winMediaNames[i], media[i]);
+                }
+                try {
+                    ms = new MediaSize(wid, ht, MediaSize.MM, wms);
+                    msList.add(ms);
+                    dmPaperNameList.add(winMediaNames[i]);
+                } catch(IllegalArgumentException e) {
+                    if (nMedia == media.length) {
+                        Integer remObj = Integer.valueOf(media[i]);
+                        idList.remove(idList.indexOf(remObj));
+                    }
+                }
             }
-          }
-
         }
 
         MediaSize[] arr2 = new MediaSize[msList.size()];
@@ -649,7 +690,6 @@
         return arr2;
     }
 
-
     private PrinterIsAcceptingJobs getPrinterIsAcceptingJobs() {
         if (getJobStatus(printer, 2) != 1) {
             return PrinterIsAcceptingJobs.NOT_ACCEPTING_JOBS;
@@ -1572,8 +1612,76 @@
         }
     }
 
-    public ServiceUIFactory getServiceUIFactory() {
-        return null;
+    private Win32DocumentPropertiesUI docPropertiesUI = null;
+
+    private static class Win32DocumentPropertiesUI
+        extends DocumentPropertiesUI {
+
+        Win32PrintService service;
+
+        private Win32DocumentPropertiesUI(Win32PrintService s) {
+            service = s;
+        }
+
+        public PrintRequestAttributeSet
+            showDocumentProperties(PrinterJob job,
+                                   Window owner,
+                                   PrintService service,
+                                   PrintRequestAttributeSet aset) {
+
+            if (!(job instanceof WPrinterJob)) {
+                return null;
+            }
+            WPrinterJob wJob = (WPrinterJob)job;
+            return wJob.showDocumentProperties(owner, service, aset);
+        }
+    }
+
+    private synchronized DocumentPropertiesUI getDocumentPropertiesUI() {
+        return new Win32DocumentPropertiesUI(this);
+    }
+
+    private static class Win32ServiceUIFactory extends ServiceUIFactory {
+
+        Win32PrintService service;
+
+        Win32ServiceUIFactory(Win32PrintService s) {
+            service = s;
+        }
+
+        public Object getUI(int role, String ui) {
+            if (role <= ServiceUIFactory.MAIN_UIROLE) {
+                return null;
+            }
+            if (role == DocumentPropertiesUI.DOCUMENTPROPERTIES_ROLE &&
+                DocumentPropertiesUI.DOCPROPERTIESCLASSNAME.equals(ui))
+            {
+                return service.getDocumentPropertiesUI();
+            }
+            throw new IllegalArgumentException("Unsupported role");
+        }
+
+        public String[] getUIClassNamesForRole(int role) {
+
+            if (role <= ServiceUIFactory.MAIN_UIROLE) {
+                return null;
+            }
+            if (role == DocumentPropertiesUI.DOCUMENTPROPERTIES_ROLE) {
+                String[] names = new String[0];
+                names[0] = DocumentPropertiesUI.DOCPROPERTIESCLASSNAME;
+                return names;
+            }
+            throw new IllegalArgumentException("Unsupported role");
+        }
+    }
+
+    private Win32ServiceUIFactory uiFactory = null;
+
+    public synchronized ServiceUIFactory getServiceUIFactory() {
+        if (uiFactory == null) {
+            uiFactory = new Win32ServiceUIFactory(this);
+        }
+        return uiFactory;
     }
 
     public String toString() {
@@ -1614,6 +1722,7 @@
 class Win32MediaSize extends MediaSizeName {
     private static ArrayList winStringTable = new ArrayList();
     private static ArrayList winEnumTable = new ArrayList();
+    private static MediaSize[] predefMedia;
 
     private int dmPaperID; // driver ID for this paper.
 
@@ -1627,6 +1736,18 @@
       return (winStringTable.size()-1);
     }
 
+    public static synchronized Win32MediaSize findMediaName(String name) {
+        int nameIndex = winStringTable.indexOf(name);
+        if (nameIndex != -1) {
+            return (Win32MediaSize)winEnumTable.get(nameIndex);
+        }
+        return null;
+    }
+
+    public static MediaSize[] getPredefMedia() {
+        return predefMedia;
+    }
+
     public Win32MediaSize(String name, int dmPaper) {
         super(nextValue(name));
         dmPaperID = dmPaper;
@@ -1638,18 +1759,17 @@
     }
 
     static {
-         /* initialize Win32PrintService.predefMedia */
+         /* initialize predefMedia */
         {
             Win32MediaSize winMedia = new Win32MediaSize(-1);
 
             // cannot call getSuperEnumTable directly because of static context
             MediaSizeName[] enumMedia = winMedia.getSuperEnumTable();
             if (enumMedia != null) {
-                Win32PrintService.predefMedia = new MediaSize[enumMedia.length];
+                predefMedia = new MediaSize[enumMedia.length];
 
                 for (int i=0; i<enumMedia.length; i++) {
-                    Win32PrintService.predefMedia[i] =
-                        MediaSize.getMediaSizeForName(enumMedia[i]);
+                    predefMedia[i] = MediaSize.getMediaSizeForName(enumMedia[i]);
                 }
             }
         }
--- ./jdk/src/windows/demo/jvmti/hprof/hprof_md.c	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/windows/demo/jvmti/hprof/hprof_md.c	Wed May 07 19:26:47 2014 -0700
@@ -368,37 +368,32 @@
 }
 
 static void dll_build_name(char* buffer, size_t buflen,
-                           const char* pname, const char* fname) {
-    // Loosley based on os_windows.cpp
+                           const char* paths, const char* fname) {
+    char *path, *paths_copy, *next_token;
 
-    char *pathname = (char *)pname;
-    while (strlen(pathname) > 0) {
-        char *p = strchr(pathname, ';');
-        if (p == NULL) {
-            p = pathname + strlen(pathname);
-        }
-        /* check for NULL path */
-        if (p == pathname) {
-            continue;
-        }
-        if (*(p-1) == ':' || *(p-1) == '\\') {
-            (void)_snprintf(buffer, buflen, "%.*s%s.dll", (p - pathname),
-                            pathname, fname);
-        } else {
-            (void)_snprintf(buffer, buflen, "%.*s\\%s.dll", (p - pathname),
-                            pathname, fname);
-        }
+    paths_copy = strdup(paths);
+    if (paths_copy == NULL) {
+        return;
+    }
+
+    next_token = NULL;
+    path = strtok_s(paths_copy, ";", &next_token);
+
+    while (path != NULL) {
+        _snprintf(buffer, buflen, "%s\\%s.dll", path, fname);
         if (_access(buffer, 0) == 0) {
             break;
         }
-        pathname = p + 1;
         *buffer = '\0';
+        path = strtok_s(NULL, ";", &next_token);
     }
+
+    free(paths_copy);
 }
 
 /* Build a machine dependent library name out of a path and file name.  */
 void
-md_build_library_name(char *holder, int holderlen, char *pname, char *fname)
+md_build_library_name(char *holder, int holderlen, const char *pname, const char *fname)
 {
     int   pnamelen;
 
--- ./jdk/src/windows/native/java/lang/ProcessImpl_md.c	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/windows/native/java/lang/ProcessImpl_md.c	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -63,46 +63,52 @@
     return source;
 }
 
+static const char EXE_EXT[] = ".exe";
+
 DWORD
 selectProcessFlag(JNIEnv *env, jstring cmd0)
 {
-    char buf[MAX_PATH];
     DWORD newFlag = 0;
-    char *exe, *p, *name;
-    unsigned char buffer[2];
-    long headerLoc = 0;
-    int fd = 0;
-
-    exe = (char *)JNU_GetStringPlatformChars(env, cmd0, 0);
-    exe = extractExecutablePath(env, exe);
-
+    char *exe = (char *)JNU_GetStringPlatformChars(env, cmd0, 0);
     if (exe != NULL) {
-        if ((p = strchr(exe, '\\')) == NULL) {
-            SearchPath(NULL, exe, ".exe", MAX_PATH, buf, &name);
-        } else {
-            p = strrchr(exe, '\\');
-            *p = 0;
-            p++;
-            SearchPath(exe, p, ".exe", MAX_PATH, buf, &name);
-        }
-    }
-
-    fd = _open(buf, _O_RDONLY);
-    if (fd > 0) {
-        _read(fd, buffer, 2);
-        if (buffer[0] == 'M' && buffer[1] == 'Z') {
-            _lseek(fd, 60L, SEEK_SET);
-            _read(fd, buffer, 2);
-            headerLoc = (long)buffer[1] << 8 | (long)buffer[0];
-            _lseek(fd, headerLoc, SEEK_SET);
-            _read(fd, buffer, 2);
-            if (buffer[0] == 'P' && buffer[1] == 'E') {
-                newFlag = DETACHED_PROCESS;
+        char buf[MAX_PATH];
+        char *name;
+        DWORD len;
+        exe = extractExecutablePath(env, exe);
+        if (exe != NULL) {
+            /* We are here for Win9x/Me, so the [/] is not the path sep */
+            char *p = strrchr(exe, '\\');
+            if (p == NULL) {
+                len = SearchPath(NULL, exe, EXE_EXT, MAX_PATH, buf, &name);
+            } else {
+                *p = 0;
+                len = SearchPath(exe, p + 1, EXE_EXT, MAX_PATH, buf, &name);
             }
         }
-        _close(fd);
+
+        if (len > 0 && len < MAX_PATH) {
+            /* Here the [buf] path is valid and null terminated */
+            int fd = _open(buf, _O_RDONLY);
+            if (fd != -1) {
+                unsigned char buffer[2];
+                if (_read(fd, buffer, 2) == 2
+                    && buffer[0] == 'M' && buffer[1] == 'Z'
+                    && _lseek(fd, 60L, SEEK_SET) == 60L
+                    && _read(fd, buffer, 2) == 2)
+                {
+                    long headerLoc = (long)buffer[1] << 8 | (long)buffer[0];
+                    if (_lseek(fd, headerLoc, SEEK_SET) == headerLoc
+                        && _read(fd, buffer, 2) == 2
+                        && buffer[0] == 'P' && buffer[1] == 'E')
+                    {
+                        newFlag = DETACHED_PROCESS;
+                    }
+                }
+                _close(fd);
+            }
+        }
+        JNU_ReleaseStringPlatformChars(env, cmd0, exe);
     }
-    JNU_ReleaseStringPlatformChars(env, cmd0, exe);
     return newFlag;
 }
 
@@ -129,6 +135,237 @@
         CloseHandle(handle);
 }
 
+static BOOL hasInheritFlag(HANDLE handle)
+{
+    DWORD mask;
+    if (GetHandleInformation(handle, &mask)) {
+        return mask & HANDLE_FLAG_INHERIT;
+    }
+    return FALSE;
+}
+
+#define HANDLE_STORAGE_SIZE 6
+#define OFFSET_READ  0
+#define OFFSET_WRITE 1
+//long signed version of INVALID_HANDLE_VALUE
+#define JAVA_INVALID_HANDLE_VALUE ((jlong) -1)
+#define OPPOSITE_END(offset) (offset==OFFSET_READ ? OFFSET_WRITE : OFFSET_READ)
+
+/* Pipe holder structure */
+typedef struct _STDHOLDER {
+    HANDLE  pipe[2];
+    int     offset;
+} STDHOLDER;
+
+/* Responsible for correct initialization of the [pHolder] structure
+   (that is used for handles recycling) if needs,
+   and appropriate setup of IOE handle [phStd] for child process based
+   on created pipe or Java handle. */
+static BOOL initHolder(
+    JNIEnv *env,
+    jlong *pjhandles,   /* IN OUT - the handle form Java,
+                                    that can be a file, console or undefined */
+    STDHOLDER *pHolder, /* OUT    - initialized structure that holds pipe
+                                    handles */
+    HANDLE *phStd       /* OUT    - initialized handle for child process */
+) {
+    /* Here we test the value from Java against invalid
+       handle value. We are not using INVALID_HANDLE_VALUE macro
+       due to double signed/unsigned and 32/64bit ambiguity.
+       Otherwise it will be easy to get the wrong
+       value   0x00000000FFFFFFFF
+       instead 0xFFFFFFFFFFFFFFFF. */
+    if (*pjhandles != JAVA_INVALID_HANDLE_VALUE) {
+        /* Java file or console redirection */
+        *phStd = (HANDLE) *pjhandles;
+        /* Here we set the related Java stream (Process.getXXXXStream())
+           to [ProcessBuilder.NullXXXXStream.INSTANCE] value.
+           The initial Java handle [*pjhandles] will be closed in
+           ANY case. It is not a handle leak. */
+        *pjhandles = JAVA_INVALID_HANDLE_VALUE;
+    } else {
+        /* Creation of parent-child pipe */
+        if (!CreatePipe(
+            &pHolder->pipe[OFFSET_READ],
+            &pHolder->pipe[OFFSET_WRITE],
+            NULL, /* we would like to inherit
+                     default process access,
+                     instead of 'Everybody' access */
+            PIPE_SIZE))
+        {
+            win32Error(env, "CreatePipe");
+            return FALSE;
+        } else {
+            /* [thisProcessEnd] has no the inherit flag because
+               the [lpPipeAttributes] param of [CreatePipe]
+               had the NULL value. */
+            HANDLE thisProcessEnd = pHolder->pipe[OPPOSITE_END(pHolder->offset)];
+            *phStd = pHolder->pipe[pHolder->offset];
+            *pjhandles = (jlong) thisProcessEnd;
+        }
+    }
+    /* Pipe handle will be closed in the [releaseHolder] call,
+       file handle will be closed in Java.
+       The long-live handle need to restore the inherit flag,
+       we do it later in the [prepareIOEHandleState] call. */
+    SetHandleInformation(
+        *phStd,
+        HANDLE_FLAG_INHERIT, HANDLE_FLAG_INHERIT);
+    return TRUE;
+}
+
+/* Smart recycling of pipe handles in [pHolder]. For the failed
+   create process attempts, both ends of pipe need to be released.
+   The [complete] has the [TRUE] value in the failed attempt. */
+static void releaseHolder(BOOL complete, STDHOLDER *pHolder) {
+    closeSafely(pHolder->pipe[pHolder->offset]);
+    if (complete) {
+        /* Error occur, close this process pipe end */
+        closeSafely(pHolder->pipe[OPPOSITE_END(pHolder->offset)]);
+    }
+}
+
+/* Stores and drops the inherit flag of handles that should not
+   be shared with the child process by default, but can hold the
+   inherit flag due to MS process birth specific. */
+static void prepareIOEHandleState(
+    HANDLE *stdIOE,
+    BOOL *inherit)
+{
+    int i;
+    for (i = 0; i < HANDLE_STORAGE_SIZE; ++i) {
+        HANDLE hstd = stdIOE[i];
+        if (INVALID_HANDLE_VALUE != hstd && hasInheritFlag(hstd)) {
+            /* FALSE by default */
+            inherit[i] = TRUE;
+            /* Java does not need implicit inheritance for IOE handles,
+               so we drop inherit flag that probably was installed by
+               previous CreateProcess call that launched current process.
+               We will return the handle state back after CreateProcess call.
+               By clearing inherit flag we prevent "greedy grandchild" birth.
+               The explicit inheritance for child process IOE handles is
+               implemented in the [initHolder] call. */
+            SetHandleInformation(hstd, HANDLE_FLAG_INHERIT, 0);
+        }
+    }
+}
+
+/* Restores the inheritance flag of handles from stored values. */
+static void restoreIOEHandleState(
+    const HANDLE *stdIOE,
+    const BOOL *inherit)
+{
+    /* The set of current process standard IOE handles and
+       the set of child process IOE handles can intersect.
+       To restore the inherit flag right, we use backward
+       array iteration. */
+    int i;
+    for (i = HANDLE_STORAGE_SIZE - 1; i >= 0; --i)
+        if (INVALID_HANDLE_VALUE != stdIOE[i]) {
+           /* Restore inherit flag for any case.
+              The handle can be changed by explicit inheritance.*/
+            SetHandleInformation(stdIOE[i],
+                HANDLE_FLAG_INHERIT,
+                inherit[i] ? HANDLE_FLAG_INHERIT : 0);
+        }
+}
+
+/* Please, read about the MS inheritance problem
+   http://support.microsoft.com/kb/315939
+   and critical section/synchronized block solution. */
+static jlong processCreate(
+    JNIEnv *env,
+    const jchar *pcmd,
+    const jchar *penvBlock,
+    const jchar *pdir,
+    jlong *handles,
+    jboolean redirectErrorStream)
+{
+    jlong ret = 0L;
+    STARTUPINFOW si = {sizeof(si)};
+
+    /* Handles for which the inheritance flag must be restored. */
+    HANDLE stdIOE[HANDLE_STORAGE_SIZE] = {
+        /* Current process standard IOE handles: JDK-7147084 */
+        INVALID_HANDLE_VALUE, INVALID_HANDLE_VALUE, INVALID_HANDLE_VALUE,
+        /* Child process IOE handles: JDK-6921885 */
+        (HANDLE)handles[0], (HANDLE)handles[1], (HANDLE)handles[2]};
+    BOOL inherit[HANDLE_STORAGE_SIZE] = {
+        FALSE, FALSE, FALSE,
+        FALSE, FALSE, FALSE};
+
+    {
+        /* Extraction of current process standard IOE handles */
+        DWORD idsIOE[3] = {STD_INPUT_HANDLE, STD_OUTPUT_HANDLE, STD_ERROR_HANDLE};
+        int i;
+        for (i = 0; i < 3; ++i)
+            /* Should not be closed by CloseHandle! */
+            stdIOE[i] = GetStdHandle(idsIOE[i]);
+    }
+
+    prepareIOEHandleState(stdIOE, inherit);
+    {
+        /* Input */
+        STDHOLDER holderIn = {{INVALID_HANDLE_VALUE, INVALID_HANDLE_VALUE}, OFFSET_READ};
+        if (initHolder(env, &handles[0], &holderIn, &si.hStdInput)) {
+
+            /* Output */
+            STDHOLDER holderOut = {{INVALID_HANDLE_VALUE, INVALID_HANDLE_VALUE}, OFFSET_WRITE};
+            if (initHolder(env, &handles[1], &holderOut, &si.hStdOutput)) {
+
+                /* Error */
+                STDHOLDER holderErr = {{INVALID_HANDLE_VALUE, INVALID_HANDLE_VALUE}, OFFSET_WRITE};
+                BOOL success;
+                if (redirectErrorStream) {
+                    si.hStdError = si.hStdOutput;
+                    /* Here we set the error stream to [ProcessBuilder.NullInputStream.INSTANCE]
+                       value. That is in accordance with Java Doc for the redirection case.
+                       The Java file for the [ handles[2] ] will be closed in ANY case. It is not
+                       a handle leak. */
+                    handles[2] = JAVA_INVALID_HANDLE_VALUE;
+                    success = TRUE;
+                } else {
+                    success = initHolder(env, &handles[2], &holderErr, &si.hStdError);
+                }
+
+                if (success) {
+                    PROCESS_INFORMATION pi;
+                    DWORD processFlag = CREATE_UNICODE_ENVIRONMENT;
+
+                    /* Suppress popping-up of a console window for non-console applications */
+                    if (GetConsoleWindow() == NULL)
+                        processFlag |= CREATE_NO_WINDOW;
+
+                    si.dwFlags = STARTF_USESTDHANDLES;
+                    if (!CreateProcessW(
+                        NULL,             /* executable name */
+                        (LPWSTR)pcmd,     /* command line */
+                        NULL,             /* process security attribute */
+                        NULL,             /* thread security attribute */
+                        TRUE,             /* inherits system handles */
+                        processFlag,      /* selected based on exe type */
+                        (LPVOID)penvBlock,/* environment block */
+                        (LPCWSTR)pdir,    /* change to the new current directory */
+                        &si,              /* (in)  startup information */
+                        &pi))             /* (out) process information */
+                    {
+                        win32Error(env, "CreateProcess");
+                    } else {
+                        closeSafely(pi.hThread);
+                        ret = (jlong)pi.hProcess;
+                    }
+                }
+                releaseHolder(ret == 0, &holderErr);
+                releaseHolder(ret == 0, &holderOut);
+            }
+            releaseHolder(ret == 0, &holderIn);
+        }
+    }
+    restoreIOEHandleState(stdIOE, inherit);
+
+    return ret;
+}
+
 JNIEXPORT jlong JNICALL
 Java_java_lang_ProcessImpl_create(JNIEnv *env, jclass ignored,
                                   jstring cmd,
@@ -137,142 +374,35 @@
                                   jlongArray stdHandles,
                                   jboolean redirectErrorStream)
 {
-    HANDLE inRead   = INVALID_HANDLE_VALUE;
-    HANDLE inWrite  = INVALID_HANDLE_VALUE;
-    HANDLE outRead  = INVALID_HANDLE_VALUE;
-    HANDLE outWrite = INVALID_HANDLE_VALUE;
-    HANDLE errRead  = INVALID_HANDLE_VALUE;
-    HANDLE errWrite = INVALID_HANDLE_VALUE;
-    SECURITY_ATTRIBUTES sa;
-    PROCESS_INFORMATION pi;
-    STARTUPINFOW si;
-    const jchar*  pcmd = NULL;
-    const jchar*  pdir = NULL;
-    const jchar*  penvBlock = NULL;
-    jlong  *handles = NULL;
     jlong ret = 0;
-    OSVERSIONINFO ver;
-    jboolean onNT = JNI_FALSE;
-    DWORD processFlag;
-
-    ver.dwOSVersionInfoSize = sizeof(ver);
-    GetVersionEx(&ver);
-    if (ver.dwPlatformId == VER_PLATFORM_WIN32_NT)
-        onNT = JNI_TRUE;
-
-    assert(cmd != NULL);
-    pcmd = (*env)->GetStringChars(env, cmd, NULL);
-    if (pcmd == NULL) goto Catch;
-
-    if (dir != 0) {
-        pdir = (*env)->GetStringChars(env, dir, NULL);
-        if (pdir == NULL) goto Catch;
+    if (cmd != NULL && stdHandles != NULL) {
+        const jchar *pcmd = (*env)->GetStringChars(env, cmd, NULL);
+        if (pcmd != NULL) {
+            const jchar *penvBlock = (envBlock != NULL)
+                ? (*env)->GetStringChars(env, envBlock, NULL)
+                : NULL;
+            const jchar *pdir = (dir != NULL)
+                ? (*env)->GetStringChars(env, dir, NULL)
+                : NULL;
+            jlong *handles = (*env)->GetLongArrayElements(env, stdHandles, NULL);
+            if (handles != NULL) {
+                ret = processCreate(
+                    env,
+                    pcmd,
+                    penvBlock,
+                    pdir,
+                    handles,
+                    redirectErrorStream);
+                (*env)->ReleaseLongArrayElements(env, stdHandles, handles, 0);
+            }
+            if (pdir != NULL)
+                (*env)->ReleaseStringChars(env, dir, pdir);
+            if (penvBlock != NULL)
+                (*env)->ReleaseStringChars(env, envBlock, penvBlock);
+            (*env)->ReleaseStringChars(env, cmd, pcmd);
+        }
     }
-    if (envBlock != NULL) {
-        penvBlock = ((*env)->GetStringChars(env, envBlock, NULL));
-        if (penvBlock == NULL) goto Catch;
-    }
-    assert(stdHandles != NULL);
-    handles = (*env)->GetLongArrayElements(env, stdHandles, NULL);
-    if (handles == NULL) goto Catch;
-
-    memset(&si, 0, sizeof(si));
-    si.cb = sizeof(si);
-    si.dwFlags = STARTF_USESTDHANDLES;
-
-    sa.nLength = sizeof(sa);
-    sa.lpSecurityDescriptor = 0;
-    sa.bInheritHandle = TRUE;
-
-    if (handles[0] != (jlong) -1) {
-        si.hStdInput = (HANDLE) handles[0];
-        handles[0] = (jlong) -1;
-    } else {
-        if (! CreatePipe(&inRead,  &inWrite,  &sa, PIPE_SIZE)) {
-            win32Error(env, "CreatePipe");
-            goto Catch;
-        }
-        si.hStdInput = inRead;
-        SetHandleInformation(inWrite, HANDLE_FLAG_INHERIT, FALSE);
-        handles[0] = (jlong) inWrite;
-    }
-    SetHandleInformation(si.hStdInput, HANDLE_FLAG_INHERIT, TRUE);
-
-    if (handles[1] != (jlong) -1) {
-        si.hStdOutput = (HANDLE) handles[1];
-        handles[1] = (jlong) -1;
-    } else {
-        if (! CreatePipe(&outRead, &outWrite, &sa, PIPE_SIZE)) {
-            win32Error(env, "CreatePipe");
-            goto Catch;
-        }
-        si.hStdOutput = outWrite;
-        SetHandleInformation(outRead, HANDLE_FLAG_INHERIT, FALSE);
-        handles[1] = (jlong) outRead;
-    }
-    SetHandleInformation(si.hStdOutput, HANDLE_FLAG_INHERIT, TRUE);
-
-    if (redirectErrorStream) {
-        si.hStdError = si.hStdOutput;
-        handles[2] = (jlong) -1;
-    } else if (handles[2] != (jlong) -1) {
-        si.hStdError = (HANDLE) handles[2];
-        handles[2] = (jlong) -1;
-    } else {
-        if (! CreatePipe(&errRead, &errWrite, &sa, PIPE_SIZE)) {
-            win32Error(env, "CreatePipe");
-            goto Catch;
-        }
-        si.hStdError = errWrite;
-        SetHandleInformation(errRead, HANDLE_FLAG_INHERIT, FALSE);
-        handles[2] = (jlong) errRead;
-    }
-    SetHandleInformation(si.hStdError, HANDLE_FLAG_INHERIT, TRUE);
-
-    if (onNT)
-        processFlag = CREATE_NO_WINDOW | CREATE_UNICODE_ENVIRONMENT;
-    else
-        processFlag = selectProcessFlag(env, cmd) | CREATE_UNICODE_ENVIRONMENT;
-    ret = CreateProcessW(0,                /* executable name */
-                         (LPWSTR)pcmd,     /* command line */
-                         0,                /* process security attribute */
-                         0,                /* thread security attribute */
-                         TRUE,             /* inherits system handles */
-                         processFlag,      /* selected based on exe type */
-                         (LPVOID)penvBlock,/* environment block */
-                         (LPCWSTR)pdir,    /* change to the new current directory */
-                         &si,              /* (in)  startup information */
-                         &pi);             /* (out) process information */
-    if (!ret) {
-        win32Error(env, "CreateProcess");
-        goto Catch;
-    }
-
-    CloseHandle(pi.hThread);
-    ret = (jlong)pi.hProcess;
-
- Finally:
-    /* Always clean up the child's side of the pipes */
-    closeSafely(inRead);
-    closeSafely(outWrite);
-    closeSafely(errWrite);
-
-    if (pcmd != NULL)
-        (*env)->ReleaseStringChars(env, cmd, pcmd);
-    if (pdir != NULL)
-        (*env)->ReleaseStringChars(env, dir, pdir);
-    if (penvBlock != NULL)
-        (*env)->ReleaseStringChars(env, envBlock, penvBlock);
-    if (handles != NULL)
-        (*env)->ReleaseLongArrayElements(env, stdHandles, handles, 0);
     return ret;
-
- Catch:
-    /* Clean up the parent's side of the pipes in case of failure only */
-    closeSafely(inWrite);
-    closeSafely(outRead);
-    closeSafely(errRead);
-    goto Finally;
 }
 
 JNIEXPORT jint JNICALL
--- ./jdk/src/windows/native/java/net/SocketInputStream.c	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/windows/native/java/net/SocketInputStream.c	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2003, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -134,32 +134,34 @@
         (*env)->SetByteArrayRegion(env, data, off, nread, (jbyte *)bufP);
     } else {
         if (nread < 0) {
-            /*
-             * Recv failed.
-             */
-            switch (WSAGetLastError()) {
-                case WSAEINTR:
-                    JNU_ThrowByName(env, JNU_JAVANETPKG "SocketException",
-                        "socket closed");
-                    break;
+            // Check if the socket has been closed since we last checked.
+            // This could be a reason for recv failing.
+            if ((*env)->GetIntField(env, fdObj, IO_fd_fdID) == -1) {
+                NET_ThrowSocketException(env, "Socket closed");
+            } else {
+                switch (WSAGetLastError()) {
+                    case WSAEINTR:
+                        JNU_ThrowByName(env, JNU_JAVANETPKG "SocketException",
+                            "socket closed");
+                        break;
+                    case WSAECONNRESET:
+                    case WSAESHUTDOWN:
+                        /*
+                         * Connection has been reset - Windows sometimes reports
+                         * the reset as a shutdown error.
+                         */
+                        JNU_ThrowByName(env, "sun/net/ConnectionResetException",
+                            "");
+                        break;
 
-                case WSAECONNRESET:
-                case WSAESHUTDOWN:
-                    /*
-                     * Connection has been reset - Windows sometimes reports
-                     * the reset as a shutdown error.
-                     */
-                    JNU_ThrowByName(env, "sun/net/ConnectionResetException",
-                        "");
-                    break;
+                    case WSAETIMEDOUT :
+                        JNU_ThrowByName(env, JNU_JAVANETPKG "SocketTimeoutException",
+                                       "Read timed out");
+                        break;
 
-                case WSAETIMEDOUT :
-                    JNU_ThrowByName(env, JNU_JAVANETPKG "SocketTimeoutException",
-                                   "Read timed out");
-                    break;
-
-                default:
-                    NET_ThrowCurrent(env, "recv failed");
+                    default:
+                        NET_ThrowCurrent(env, "recv failed");
+                }
             }
         }
     }
--- ./jdk/src/windows/native/sun/nio/ch/SocketDispatcher.c	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/windows/native/sun/nio/ch/SocketDispatcher.c	Wed May 07 19:26:47 2014 -0700
@@ -192,45 +192,66 @@
                                          jobject fdo, jlong address, jint len)
 {
     /* set up */
-    int i = 0;
+    int next_index, next_offset, ret=0;
     DWORD written = 0;
     jint fd = fdval(env, fdo);
     struct iovec *iovp = (struct iovec *)address;
     WSABUF *bufs = malloc(len * sizeof(WSABUF));
-    jint rem = MAX_BUFFER_SIZE;
+    jlong count = 0;
 
     if (bufs == 0) {
         JNU_ThrowOutOfMemoryError(env, 0);
         return IOS_THROWN;
     }
 
-    /* copy iovec into WSABUF */
-    for(i=0; i<len; i++) {
-        jint iov_len = iovp[i].iov_len;
-        if (iov_len > rem)
-            iov_len = rem;
-        bufs[i].buf = (char *)iovp[i].iov_base;
-        bufs[i].len = (u_long)iov_len;
-        rem -= iov_len;
-        if (rem == 0) {
-            len = i+1;
+    // next buffer and offset to consume
+    next_index = 0;
+    next_offset = 0;
+
+    while (next_index  < len) {
+        DWORD buf_count = 0;
+
+        /* Prepare the WSABUF array to a maximum total size of MAX_BUFFER_SIZE */
+        jint rem = MAX_BUFFER_SIZE;
+        while (next_index < len && rem > 0) {
+            jint iov_len = iovp[next_index].iov_len - next_offset;
+            char* ptr = (char *)iovp[next_index].iov_base;
+            ptr += next_offset;
+            if (iov_len > rem) {
+                iov_len = rem;
+                next_offset += rem;
+            } else {
+                next_index ++;
+                next_offset = 0;
+            }
+
+            bufs[buf_count].buf = ptr;
+            bufs[buf_count].len = (u_long)iov_len;
+            buf_count++;
+
+            rem -= iov_len;
+        }
+
+        /* write the buffers */
+        ret = WSASend((SOCKET)fd,           /* Socket */
+                              bufs,         /* pointers to the buffers */
+                              buf_count,    /* number of buffers to process */
+                              &written,     /* receives number of bytes written */
+                              0,            /* no flags */
+                              0,            /* no overlapped sockets */
+                              0);           /* no completion routine */
+
+        if (ret == SOCKET_ERROR) {
             break;
         }
+
+        count += written;
     }
 
-    /* read into the buffers */
-    i = WSASend((SOCKET)fd, /* Socket */
-            bufs,           /* pointers to the buffers */
-            (DWORD)len,     /* number of buffers to process */
-            &written,       /* receives number of bytes written */
-            0,              /* no flags */
-            0,              /* no overlapped sockets */
-            0);             /* no completion routine */
-
     /* clean up */
     free(bufs);
 
-    if (i != 0) {
+    if (ret == SOCKET_ERROR && count == 0) {
         int theErr = (jint)WSAGetLastError();
         if (theErr == WSAEWOULDBLOCK) {
             return IOS_UNAVAILABLE;
@@ -239,7 +260,7 @@
         return IOS_THROWN;
     }
 
-    return convertLongReturnVal(env, (jlong)written, JNI_FALSE);
+    return convertLongReturnVal(env, count, JNI_FALSE);
 }
 
 JNIEXPORT void JNICALL
--- ./jdk/src/windows/native/sun/nio/fs/WindowsNativeDispatcher.c	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/windows/native/sun/nio/fs/WindowsNativeDispatcher.c	Wed May 07 19:26:47 2014 -0700
@@ -162,7 +162,7 @@
     }
     completionStatus_error = (*env)->GetFieldID(env, clazz, "error", "I");
     completionStatus_bytesTransferred = (*env)->GetFieldID(env, clazz, "bytesTransferred", "I");
-    completionStatus_completionKey = (*env)->GetFieldID(env, clazz, "completionKey", "I");
+    completionStatus_completionKey = (*env)->GetFieldID(env, clazz, "completionKey", "J");
 
     clazz = (*env)->FindClass(env, "sun/nio/fs/WindowsNativeDispatcher$BackupResult");
     if (clazz == NULL) {
@@ -1169,12 +1169,11 @@
 
 JNIEXPORT jlong JNICALL
 Java_sun_nio_fs_WindowsNativeDispatcher_CreateIoCompletionPort(JNIEnv* env, jclass this,
-    jlong fileHandle, jlong existingPort, jint completionKey)
+    jlong fileHandle, jlong existingPort, jlong completionKey)
 {
-    ULONG_PTR ck = completionKey;
     HANDLE port = CreateIoCompletionPort((HANDLE)jlong_to_ptr(fileHandle),
                                          (HANDLE)jlong_to_ptr(existingPort),
-                                         ck,
+                                         (ULONG_PTR)completionKey,
                                          0);
     if (port == NULL) {
         throwWindowsException(env, GetLastError());
@@ -1203,21 +1202,20 @@
         (*env)->SetIntField(env, obj, completionStatus_error, ioResult);
         (*env)->SetIntField(env, obj, completionStatus_bytesTransferred,
             (jint)bytesTransferred);
-        (*env)->SetIntField(env, obj, completionStatus_completionKey,
-            (jint)completionKey);
-
+        (*env)->SetLongField(env, obj, completionStatus_completionKey,
+            (jlong)completionKey);
     }
 }
 
 JNIEXPORT void JNICALL
 Java_sun_nio_fs_WindowsNativeDispatcher_PostQueuedCompletionStatus(JNIEnv* env, jclass this,
-    jlong completionPort, jint completionKey)
+    jlong completionPort, jlong completionKey)
 {
     BOOL res;
 
     res = PostQueuedCompletionStatus((HANDLE)jlong_to_ptr(completionPort),
                                      (DWORD)0,  /* dwNumberOfBytesTransferred */
-                                     (DWORD)completionKey,
+                                     (ULONG_PTR)completionKey,
                                      NULL);  /* lpOverlapped */
     if (res == 0) {
         throwWindowsException(env, GetLastError());
@@ -1232,7 +1230,17 @@
     BOOL res;
     BOOL subtree = (watchSubTree == JNI_TRUE) ? TRUE : FALSE;
 
-    ((LPOVERLAPPED)jlong_to_ptr(pOverlapped))->hEvent = NULL;
+    /* Any unused members of [OVERLAPPED] structure should always be initialized to zero
+       before the structure is used in a function call.
+       Otherwise, the function may fail and return ERROR_INVALID_PARAMETER.
+       http://msdn.microsoft.com/en-us/library/windows/desktop/ms684342%28v=vs.85%29.aspx
+
+       The [Offset] and [OffsetHigh] members of this structure are not used.
+       http://msdn.microsoft.com/en-us/library/windows/desktop/aa365465%28v=vs.85%29.aspx
+
+       [hEvent] should be zero, other fields are the return values. */
+    ZeroMemory((LPOVERLAPPED)jlong_to_ptr(pOverlapped), sizeof(OVERLAPPED));
+
     res = ReadDirectoryChangesW((HANDLE)jlong_to_ptr(hDirectory),
                                 (LPVOID)jlong_to_ptr(bufferAddress),
                                 (DWORD)bufferLength,
--- ./jdk/src/windows/native/sun/security/krb5/NativeCreds.c	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/windows/native/sun/security/krb5/NativeCreds.c	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -380,7 +380,8 @@
  */
 JNIEXPORT jobject JNICALL Java_sun_security_krb5_Credentials_acquireDefaultNativeCreds(
         JNIEnv *env,
-        jclass krbcredsClass) {
+        jclass krbcredsClass,
+        jintArray jetypes) {
 
     KERB_QUERY_TKT_CACHE_REQUEST CacheRequest;
     PKERB_RETRIEVE_TKT_RESPONSE TktCacheResponse = NULL;
@@ -396,9 +397,12 @@
     jobject ticketFlags, startTime, endTime, krbCreds = NULL;
     jobject authTime, renewTillTime, hostAddresses = NULL;
     KERB_EXTERNAL_TICKET *msticket;
-    int ignore_cache = 0;
+    int found_in_cache = 0;
     FILETIME Now, EndTime, LocalEndTime;
 
+    int i, netypes;
+    jint *etypes = NULL;
+
     while (TRUE) {
 
         if (krbcredsConstructor == 0) {
@@ -465,31 +469,33 @@
         // got the native MS TGT
         msticket = &(TktCacheResponse->Ticket);
 
+        netypes = (*env)->GetArrayLength(env, jetypes);
+        etypes = (jint *) (*env)->GetIntArrayElements(env, jetypes, NULL);
+
         // check TGT validity
-        switch (msticket->SessionKey.KeyType) {
-            case KERB_ETYPE_DES_CBC_CRC:
-            case KERB_ETYPE_DES_CBC_MD5:
-            case KERB_ETYPE_NULL:
-            case KERB_ETYPE_RC4_HMAC_NT:
-                GetSystemTimeAsFileTime(&Now);
-                EndTime.dwLowDateTime = msticket->EndTime.LowPart;
-                EndTime.dwHighDateTime = msticket->EndTime.HighPart;
-                FileTimeToLocalFileTime(&EndTime, &LocalEndTime);
-                if (CompareFileTime(&Now, &LocalEndTime) >= 0) {
-                    ignore_cache = 1;
-                }
-                if (msticket->TicketFlags & KERB_TICKET_FLAGS_invalid) {
-                    ignore_cache = 1;
-                }
-                break;
-            case KERB_ETYPE_RC4_MD4:
-            default:
-                // not supported
-                ignore_cache = 1;
-                break;
+        if (native_debug) {
+            printf("LSA: TICKET SessionKey KeyType is %d\n", msticket->SessionKey.KeyType);
         }
 
-        if (ignore_cache) {
+        if ((msticket->TicketFlags & KERB_TICKET_FLAGS_invalid) == 0) {
+            GetSystemTimeAsFileTime(&Now);
+            EndTime.dwLowDateTime = msticket->EndTime.LowPart;
+            EndTime.dwHighDateTime = msticket->EndTime.HighPart;
+            FileTimeToLocalFileTime(&EndTime, &LocalEndTime);
+            if (CompareFileTime(&Now, &LocalEndTime) < 0) {
+                for (i=0; i<netypes; i++) {
+                    if (etypes[i] == msticket->SessionKey.KeyType) {
+                        found_in_cache = 1;
+                        if (native_debug) {
+                            printf("LSA: Valid etype found: %d\n", etypes[i]);
+                        }
+                        break;
+                    }
+                }
+            }
+        }
+
+        if (!found_in_cache) {
             if (native_debug) {
                 printf("LSA: MS TGT in cache is invalid/not supported; request new ticket\n");
             }
@@ -503,34 +509,40 @@
             }
 
             pTicketRequest->MessageType = KerbRetrieveEncodedTicketMessage;
-            pTicketRequest->EncryptionType = KERB_ETYPE_DES_CBC_MD5;
             pTicketRequest->CacheOptions = KERB_RETRIEVE_TICKET_DONT_USE_CACHE;
 
-            Status = LsaCallAuthenticationPackage(
-                        LogonHandle,
-                        PackageId,
-                        pTicketRequest,
-                        requestSize,
-                        &pTicketResponse,
-                        &responseSize,
-                        &SubStatus
-                        );
+            for (i=0; i<netypes; i++) {
+                pTicketRequest->EncryptionType = etypes[i];
+                Status = LsaCallAuthenticationPackage(
+                            LogonHandle,
+                            PackageId,
+                            pTicketRequest,
+                            requestSize,
+                            &pTicketResponse,
+                            &responseSize,
+                            &SubStatus
+                            );
 
-            if (native_debug) {
-                printf("LSA: Response size is %d\n", responseSize);
-            }
+                if (native_debug) {
+                    printf("LSA: Response size is %d for %d\n", responseSize, etypes[i]);
+                }
 
-            if (!LSA_SUCCESS(Status) || !LSA_SUCCESS(SubStatus)) {
-                if (!LSA_SUCCESS(Status)) {
-                    ShowNTError("LsaCallAuthenticationPackage", Status);
-                } else {
-                    ShowNTError("Protocol status", SubStatus);
+                if (!LSA_SUCCESS(Status) || !LSA_SUCCESS(SubStatus)) {
+                    if (!LSA_SUCCESS(Status)) {
+                        ShowNTError("LsaCallAuthenticationPackage", Status);
+                    } else {
+                        ShowNTError("Protocol status", SubStatus);
+                    }
+                    continue;
                 }
+
+                // got the native MS Kerberos TGT
+                msticket = &(pTicketResponse->Ticket);
                 break;
             }
-
-            // got the native MS Kerberos TGT
-            msticket = &(pTicketResponse->Ticket);
+        }
+        if (etypes != NULL) {
+            (*env)->ReleaseIntArrayElements(env, jetypes, etypes, 0);
         }
 
         /*
@@ -653,7 +665,7 @@
                 hostAddresses);
 
         break;
-    } // end of WHILE
+    } // end of WHILE. This WHILE will never loop.
 
     // clean up resources
     if (TktCacheResponse != NULL) {
--- ./jdk/src/windows/native/sun/windows/awt_FileDialog.cpp	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/windows/native/sun/windows/awt_FileDialog.cpp	Wed May 07 19:26:47 2014 -0700
@@ -372,7 +372,9 @@
 
         // Report result to peer.
         if (result) {
-            jint length = (jint)GetBufferLength(ofn.lpstrFile, ofn.nMaxFile);
+            jint length = multipleMode
+                    ? (jint)GetBufferLength(ofn.lpstrFile, ofn.nMaxFile)
+                    : (jint)_tcslen(ofn.lpstrFile);
             jcharArray jnames = env->NewCharArray(length);
             env->SetCharArrayRegion(jnames, 0, length, (jchar*)ofn.lpstrFile);
 
--- ./jdk/src/windows/native/sun/windows/awt_PrintControl.cpp	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/windows/native/sun/windows/awt_PrintControl.cpp	Wed May 07 19:26:47 2014 -0700
@@ -81,6 +81,7 @@
 jmethodID AwtPrintControl::setNativeAttID;
 jmethodID AwtPrintControl::setRangeCopiesID;
 jmethodID AwtPrintControl::setResID;
+jmethodID AwtPrintControl::setJobAttributesID;
 
 
 BOOL AwtPrintControl::IsSupportedLevel(HANDLE hPrinter, DWORD dwLevel) {
@@ -297,6 +298,10 @@
     AwtPrintControl::setPrinterID =
       env->GetMethodID(cls, "setPrinterNameAttrib", "(Ljava/lang/String;)V");
 
+    AwtPrintControl::setJobAttributesID =
+        env->GetMethodID(cls, "setJobAttributes",
+        "(Ljavax/print/attribute/PrintRequestAttributeSet;IISSSSSSS)V");
+
     DASSERT(AwtPrintControl::driverDoesMultipleCopiesID != NULL);
     DASSERT(AwtPrintControl::getPrintDCID != NULL);
     DASSERT(AwtPrintControl::setPrintDCID != NULL);
@@ -327,6 +332,7 @@
     DASSERT(AwtPrintControl::getSidesID != NULL);
     DASSERT(AwtPrintControl::getSelectID != NULL);
     DASSERT(AwtPrintControl::getPrintToFileEnabledID != NULL);
+    DASSERT(AwtPrintControl::setJobAttributesID != NULL);
 
 
     CATCH_BAD_ALLOC;
--- ./jdk/src/windows/native/sun/windows/awt_PrintControl.h	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/windows/native/sun/windows/awt_PrintControl.h	Wed May 07 19:26:47 2014 -0700
@@ -47,7 +47,6 @@
     static jmethodID setDevmodeID;
     static jmethodID getDevnamesID;
     static jmethodID setDevnamesID;
-
     static jmethodID getWin32MediaID;
     static jmethodID setWin32MediaID;
     static jmethodID getWin32MediaTrayID;
@@ -73,6 +72,7 @@
     static jmethodID setNativeAttID;
     static jmethodID setRangeCopiesID;
     static jmethodID setResID;
+    static jmethodID setJobAttributesID;
 
     static void initIDs(JNIEnv *env, jclass cls);
     static BOOL FindPrinter(jstring printerName, LPBYTE pPrinterEnum,
--- ./jdk/src/windows/native/sun/windows/awt_PrintJob.cpp	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/src/windows/native/sun/windows/awt_PrintJob.cpp	Wed May 07 19:26:47 2014 -0700
@@ -329,6 +329,156 @@
 static int embolden(int currentWeight);
 static BOOL getPrintableArea(HDC pdc, HANDLE hDevMode, RectDouble *margin);
 
+
+
+/************************************************************************
+ * DocumentProperties native support
+ */
+
+/* Values must match those defined in WPrinterJob.java */
+static const DWORD SET_COLOR = 0x00000200;
+static const DWORD SET_ORIENTATION = 0x00004000;
+static const DWORD SET_COLLATED    = 0x00008000;
+static const DWORD SET_DUP_VERTICAL = 0x00000010;
+static const DWORD SET_DUP_HORIZONTAL = 0x00000020;
+static const DWORD SET_RES_HIGH = 0x00000040;
+static const DWORD SET_RES_LOW = 0x00000080;
+
+/*
+ * Copy DEVMODE state back into JobAttributes.
+ */
+
+static void UpdateJobAttributes(JNIEnv *env,
+                                jobject wJob,
+                                jobject attrSet,
+                                DEVMODE *devmode) {
+
+    DWORD dmValues = 0;
+    int xRes = 0, yRes = 0;
+
+    if (devmode->dmFields & DM_COLOR) {
+        if (devmode->dmColor == DMCOLOR_COLOR) {
+            dmValues |= SET_COLOR;
+        }
+    }
+
+    if (devmode->dmFields & DM_ORIENTATION) {
+        if (devmode->dmOrientation == DMORIENT_LANDSCAPE) {
+            dmValues |= SET_ORIENTATION;
+        }
+    }
+
+    if (devmode->dmFields & DM_COLLATE &&
+        devmode->dmCollate == DMCOLLATE_TRUE) {
+            dmValues |= SET_COLLATED;
+    }
+
+    if (devmode->dmFields & DM_PRINTQUALITY) {
+        /* value < 0 indicates quality setting.
+         * value > 0 indicates X resolution. In that case
+         * hopefully we will also find y-resolution specified.
+         * If its not, assume its the same as x-res.
+         * Maybe Java code should try to reconcile this against
+          * the printers claimed set of supported resolutions.
+         */
+        if (devmode->dmPrintQuality < 0) {
+            if (devmode->dmPrintQuality == DMRES_HIGH) {
+                dmValues |= SET_RES_HIGH;
+            } else if ((devmode->dmPrintQuality == DMRES_LOW) ||
+                       (devmode->dmPrintQuality == DMRES_DRAFT)) {
+                dmValues |= SET_RES_LOW;
+            }
+            /* else if (devmode->dmPrintQuality == DMRES_MEDIUM)
+             * will set to NORMAL.
+             */
+        } else {
+            xRes = devmode->dmPrintQuality;
+            yRes = (devmode->dmFields & DM_YRESOLUTION) ?
+                devmode->dmYResolution : devmode->dmPrintQuality;
+        }
+    }
+
+    if (devmode->dmFields & DM_DUPLEX) {
+        if (devmode->dmDuplex == DMDUP_HORIZONTAL) {
+            dmValues |= SET_DUP_HORIZONTAL;
+        } else if (devmode->dmDuplex == DMDUP_VERTICAL) {
+            dmValues |= SET_DUP_VERTICAL;
+        }
+    }
+
+    env->CallVoidMethod(wJob, AwtPrintControl::setJobAttributesID, attrSet,
+                        devmode->dmFields, dmValues, devmode->dmCopies,
+                        devmode->dmPaperSize, devmode->dmPaperWidth,
+                        devmode->dmPaperLength, devmode->dmDefaultSource,
+                        xRes, yRes);
+
+}
+
+JNIEXPORT jboolean JNICALL
+Java_sun_awt_windows_WPrinterJob_showDocProperties(JNIEnv *env,
+                                                   jobject wJob,
+                                                   jlong hWndParent,
+                                                   jobject attrSet,
+                                                   jint dmFields,
+                                                   jshort copies,
+                                                   jshort collate,
+                                                   jshort color,
+                                                   jshort duplex,
+                                                   jshort orient,
+                                                   jshort paper,
+                                                   jshort bin,
+                                                   jshort xres_quality,
+                                                   jshort yres)
+{
+    TRY;
+
+    HGLOBAL hDevMode = AwtPrintControl::getPrintHDMode(env, wJob);
+    HGLOBAL hDevNames = AwtPrintControl::getPrintHDName(env, wJob);
+    DEVMODE *devmode = NULL;
+    DEVNAMES *devnames = NULL;
+    LONG rval = IDCANCEL;
+    jboolean ret = JNI_FALSE;
+
+    if (hDevMode != NULL && hDevNames != NULL) {
+        devmode = (DEVMODE *)::GlobalLock(hDevMode);
+        devnames = (DEVNAMES *)::GlobalLock(hDevNames);
+
+        LPTSTR lpdevnames = (LPTSTR)devnames;
+        // No need to call _tcsdup as we won't unlock until we are done.
+        LPTSTR printerName = lpdevnames+devnames->wDeviceOffset;
+        LPTSTR portName = lpdevnames+devnames->wOutputOffset;
+
+        HANDLE hPrinter;
+        if (::OpenPrinter(printerName, &hPrinter, NULL) == TRUE) {
+            devmode->dmFields |= dmFields;
+            devmode->dmCopies = copies;
+            devmode->dmCollate = collate;
+            devmode->dmColor = color;
+            devmode->dmDuplex = duplex;
+            devmode->dmOrientation = orient;
+            devmode->dmPrintQuality = xres_quality;
+            devmode->dmYResolution = yres;
+            devmode->dmPaperSize = paper;
+            devmode->dmDefaultSource = bin;
+
+            rval = ::DocumentProperties((HWND)hWndParent,
+                           hPrinter, printerName, devmode, devmode,
+                           DM_IN_BUFFER | DM_OUT_BUFFER | DM_IN_PROMPT);
+            if (rval == IDOK) {
+                UpdateJobAttributes(env, wJob, attrSet, devmode);
+                ret = JNI_TRUE;
+            }
+            VERIFY(::ClosePrinter(hPrinter));
+        }
+        ::GlobalUnlock(hDevNames);
+        ::GlobalUnlock(hDevMode);
+    }
+
+    return ret;
+
+    CATCH_BAD_ALLOC_RET(0);
+}
+
 /************************************************************************
  * WPageDialog native methods
  */
@@ -732,7 +882,6 @@
         memset(&pd, 0, sizeof(PRINTDLG));
         pd.lStructSize = sizeof(PRINTDLG);
         pd.Flags = PD_RETURNDEFAULT | PD_RETURNDC;
-
         if (::PrintDlg(&pd)) {
             printDC = pd.hDC;
             hDevMode = pd.hDevMode;
@@ -792,8 +941,19 @@
     jint imgPixelWid = GetDeviceCaps(printDC, HORZRES);
     jint imgPixelHgt = GetDeviceCaps(printDC, VERTRES);
 
+    // The DC may be obtained when we first selected the printer as a
+    // result of a call to setNativePrintService.
+    // If the Devmode was obtained later on from the DocumentProperties dialog
+    // the DC won't have been updated and its settings may be for PORTRAIT.
+    // This may happen in other cases too, but was observed for the above.
+    // To get a DC compatible with this devmode we should really call
+    // CreateDC() again to get a DC for the devmode we are using.
+    // The changes for that are a lot more risk, so to minimise that
+    // risk, assume its not LANDSCAPE unless width > height, even if the
+    // devmode says its LANDSCAPE.
     // if the values were obtained from a rotated device, swap.
-    if (getOrientationFromDevMode2(hDevMode) == DMORIENT_LANDSCAPE) {
+    if ((getOrientationFromDevMode2(hDevMode) == DMORIENT_LANDSCAPE) &&
+        (imgPixelWid > imgPixelHgt)) {
       jint tmp;
       tmp = xPixelRes;
       xPixelRes = yPixelRes;
@@ -941,6 +1101,9 @@
             setBooleanField(env, self, DRIVER_COLLATE_STR, JNI_FALSE);
         }
 
+        if (dmFields & DM_COPIES) {
+            setBooleanField(env, self, DRIVER_COPIES_STR, JNI_TRUE);
+        }
     }
 
     CATCH_BAD_ALLOC;
--- ./jdk/test/ProblemList.txt	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/test/ProblemList.txt	Wed May 07 19:26:47 2014 -0700
@@ -369,15 +369,6 @@
 # 7147060
 com/sun/org/apache/xml/internal/security/transforms/ClassLoaderTest.java        generic-all
 
-# 8000439: NPG: REGRESSION : sun/security/krb5/auto/MaxRetries.java fails with timeout
-sun/security/krb5/auto/MaxRetries.java                          solaris-sparcv9
-
-# 8006690: sun/security/krb5/auto/BadKdc1.java fails intermittently
-sun/security/krb5/auto/BadKdc1.java                             solaris-sparcv9
-sun/security/krb5/auto/BadKdc2.java                             solaris-sparcv9
-sun/security/krb5/auto/BadKdc3.java                             solaris-sparcv9
-sun/security/krb5/auto/BadKdc4.java                             solaris-sparcv9
-
 ############################################################################
 
 # jdk_swing
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/com/apple/eawt/DefaultMenuBar/DefaultMenuBarTest.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,108 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 8007267
+ * @summary [macosx] com.apple.eawt.Application.setDefaultMenuBar is not working
+ * @author leonid.romanov@oracle.com
+ * @run main DefaultMenuBarTest
+ */
+
+import java.awt.*;
+import java.awt.event.*;
+import javax.swing.*;
+import sun.awt.*;
+import java.lang.reflect.Method;
+
+
+public class DefaultMenuBarTest {
+    static KeyStroke ks = KeyStroke.getKeyStroke(KeyEvent.VK_O, InputEvent.META_MASK);
+
+    static volatile int listenerCallCounter = 0;
+    public static void main(String[] args) throws Exception {
+        if (sun.awt.OSInfo.getOSType() != sun.awt.OSInfo.OSType.MACOSX) {
+            System.out.println("This test is for MacOS only. Automatically passed on other platforms.");
+            return;
+        }
+
+        System.setProperty("apple.laf.useScreenMenuBar", "true");
+        SwingUtilities.invokeAndWait(new Runnable() {
+            public void run() {
+                createAndShowGUI();
+            }
+        });
+
+        SunToolkit toolkit = (SunToolkit) Toolkit.getDefaultToolkit();
+        Robot robot = new Robot();
+        robot.setAutoDelay(100);
+
+        robot.keyPress(KeyEvent.VK_META);
+        robot.keyPress(ks.getKeyCode());
+        robot.keyRelease(ks.getKeyCode());
+        robot.keyRelease(KeyEvent.VK_META);
+
+        toolkit.realSync();
+
+        if (listenerCallCounter != 1) {
+            throw new Exception("Test failed: ActionListener either wasn't called or was called more than once");
+        }
+    }
+
+    private static void createAndShowGUI() {
+        JMenu menu = new JMenu("File");
+        JMenuItem newItem = new JMenuItem("Open");
+
+        newItem.setAccelerator(ks);
+        newItem.addActionListener(
+            new ActionListener(){
+                public void actionPerformed(ActionEvent e) {
+                    listenerCallCounter++;
+                }
+            }
+        );
+        menu.add(newItem);
+
+        JMenuBar defaultMenu = new JMenuBar();
+        defaultMenu.add(menu);
+
+        // Application.getApplication().setDefaultMenuBar(defaultMenu);
+        try {
+            Class appClass = Class.forName("com.apple.eawt.Application");
+            if (appClass != null) {
+                Method method = appClass.getMethod("getApplication");
+                if (method != null) {
+                    Object app = method.invoke(null, new Object[]{});
+                    if (app != null) {
+                        method = appClass.getMethod("setDefaultMenuBar", new Class[]{JMenuBar.class});
+                        if (method != null) {
+                            method.invoke(app, new Object[]{defaultMenu});
+                        }
+                    }
+                }
+            }
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/com/sun/corba/transport/KeepAliveSockets.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,68 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 8017195
+ * @summary Introduce option to setKeepAlive parameter on CORBA sockets
+ *
+ * @run main/othervm KeepAliveSockets
+ * @run main/othervm -Dcom.sun.CORBA.transport.enableTcpKeepAlive KeepAliveSockets
+ * @run main/othervm -Dcom.sun.CORBA.transport.enableTcpKeepAlive=true KeepAliveSockets
+ * @run main/othervm -Dcom.sun.CORBA.transport.enableTcpKeepAlive=false KeepAliveSockets
+ */
+
+import java.lang.*;
+import java.net.InetSocketAddress;
+import java.net.Socket;
+import java.nio.channels.ServerSocketChannel;
+import java.util.*;
+import com.sun.corba.se.impl.orb.*;
+
+import com.sun.corba.se.impl.transport.*;
+
+public class KeepAliveSockets {
+
+    public static void main(String[] args) throws Exception {
+
+        boolean keepAlive = false;
+        String prop = System.getProperty("com.sun.CORBA.transport.enableTcpKeepAlive");
+        if (prop != null)
+            keepAlive = !"false".equalsIgnoreCase(prop);
+
+        DefaultSocketFactoryImpl sfImpl = new DefaultSocketFactoryImpl();
+        ORBImpl orb = new ORBImpl();
+        orb.set_parameters(null);
+        sfImpl.setORB(orb);
+
+        ServerSocketChannel ssc = ServerSocketChannel.open();
+        ssc.socket().bind(new InetSocketAddress(0));
+
+        InetSocketAddress isa = new InetSocketAddress("localhost", ssc.socket().getLocalPort());
+        Socket s = sfImpl.createSocket("ignore", isa);
+        System.out.println("Received factory socket" + s);
+        if (keepAlive != s.getKeepAlive())
+            throw new RuntimeException("KeepAlive value not honoured in CORBA socket");
+    }
+
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/com/sun/nio/sctp/SctpChannel/ReceiveIntoDirect.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,276 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/* @test
+ * @bug 8034181
+ * @summary SIGBUS in SctpChannelImpl receive
+ * @author chegar
+ */
+
+import java.net.InetSocketAddress;
+import java.net.SocketAddress;
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import com.sun.nio.sctp.AbstractNotificationHandler;
+import com.sun.nio.sctp.AssociationChangeNotification;
+import com.sun.nio.sctp.AssociationChangeNotification.AssocChangeEvent;
+import com.sun.nio.sctp.HandlerResult;
+import com.sun.nio.sctp.MessageInfo;
+import com.sun.nio.sctp.Notification;
+import com.sun.nio.sctp.PeerAddressChangeNotification;
+import com.sun.nio.sctp.SctpChannel;
+import com.sun.nio.sctp.SctpServerChannel;
+import com.sun.nio.sctp.ShutdownNotification;
+import static java.lang.System.out;
+import static java.lang.System.err;
+import static java.nio.charset.StandardCharsets.US_ASCII;
+
+public class ReceiveIntoDirect {
+    /* suitably small message to NOT overrun small buffers */
+    final byte[] msgBytes =  "Hello".getBytes(US_ASCII);
+
+    /* number of client connections/combinations (accepted by the server) */
+    final int NUM_CONNECTIONS = 75;
+
+    void test(String[] args) throws IOException {
+        SocketAddress address = null;
+        Server server;
+
+        if (!Util.isSCTPSupported()) {
+            out.println("SCTP protocol is not supported");
+            out.println("Test cannot be run");
+            return;
+        }
+
+        if (args.length == 2) {
+            /* requested to connecct to a specific address */
+            try {
+                int port = Integer.valueOf(args[1]);
+                address = new InetSocketAddress(args[0], port);
+            } catch (NumberFormatException nfe) {
+                err.println(nfe);
+            }
+        } else {
+            /* start server on local machine, default */
+            server = new Server();
+            server.start();
+            address = server.address();
+            debug("Server started and listening on " + address);
+        }
+
+        /* many combinations with varing buffer sizes, and offsets */
+        runWithManyOffsets(address, 20);
+        runWithManyOffsets(address, 49);
+        runWithManyOffsets(address, 50);
+        runWithManyOffsets(address, 51);
+        runWithManyOffsets(address, 1024);
+    }
+
+    void runWithManyOffsets(SocketAddress addr, int bufferSize)
+        throws IOException
+    {
+        doTest(addr, bufferSize, 1);
+        doTest(addr, bufferSize, 2);
+        doTest(addr, bufferSize, 3);
+        doTest(addr, bufferSize, 4);
+        doTest(addr, bufferSize, 5);
+        doTest(addr, bufferSize, 6);
+        doTest(addr, bufferSize, 7);
+        doTest(addr, bufferSize, 8);
+        doTest(addr, bufferSize, 9);
+        doTest(addr, bufferSize, 10);
+        doTest(addr, bufferSize, 11);
+        doTest(addr, bufferSize, 12);
+        doTest(addr, bufferSize, 13);
+        doTest(addr, bufferSize, 14);
+        doTest(addr, bufferSize, 15);
+    }
+
+    void doTest(SocketAddress peerAddress, int bufferSize, int bufferOffset)
+        throws IOException
+    {
+        debug("\n\nTesting with bufferSize " + bufferSize + " and offset " + bufferOffset);
+        assert bufferOffset + msgBytes.length <= bufferSize :
+               "buffer offset + message length greater than buffer size ";
+
+        ByteBuffer buffer = ByteBuffer.allocateDirect(bufferSize);
+        MessageInfo info;
+
+        try (SctpChannel channel = SctpChannel.open()) {
+            channel.connect(peerAddress);
+
+            ReceiveNotificationHandler handler =
+                new ReceiveNotificationHandler();
+
+            /* TEST 1: Assoc/peer change notif into direct buffer with offest */
+            do {
+                debug("Test 1: Assoc/peer change with offset " + bufferOffset);
+                buffer.position(bufferOffset);
+                info = channel.receive(buffer, null, handler);
+                if (info == null) {
+                    fail("unexpected null from receive");
+                    return;
+                }
+            } while (!info.isComplete());
+
+            buffer.flip().position(bufferOffset);
+            check(handler.receivedCommUp(), "SCTP_COMM_UP not received");
+            check(info != null, "info is null");
+            check(info.address() != null, "address is null");
+            check(info.association() != null, "association is null");
+            check(info.isComplete(), "message is not complete");
+            check(info.isUnordered() != true,
+                  "message should not be unordered");
+            check(info.streamNumber() >= 0, "invalid stream number");
+            check(info.bytes() == msgBytes.length,
+                  "bytes received not equal to message length");
+            check(info.bytes() == buffer.remaining(), "bytes != remaining");
+            check(Util.compare(buffer, msgBytes),
+                  "received message not the same as sent message");
+
+            /* TEST 2: shutdown notification with offset */
+            debug("Test 2: shutdown notif with offset " + bufferOffset);
+            buffer.clear().position(bufferOffset);
+            while ((info = channel.receive(buffer, null, handler )) != null &&
+                    info.bytes() != -1 );
+        }
+    }
+
+    class Server implements Runnable
+    {
+        private final InetSocketAddress serverAddr;
+        private final SctpServerChannel ssc;
+
+        public Server() throws IOException {
+            ssc = SctpServerChannel.open().bind(null);
+            java.util.Set<SocketAddress> addrs = ssc.getAllLocalAddresses();
+            if (addrs.isEmpty())
+                debug("addrs should not be empty");
+
+            serverAddr = (InetSocketAddress) addrs.iterator().next();
+        }
+
+        public void start() {
+            (new Thread(this, "Server-"  + serverAddr.getPort())).start();
+        }
+
+        public InetSocketAddress address() {
+            return serverAddr;
+        }
+
+        @Override
+        public void run() {
+            try {
+                for (int i=0; i<NUM_CONNECTIONS; i++) {
+                    SctpChannel sc = ssc.accept();
+
+                    /* send a small message */
+                    MessageInfo info = MessageInfo.createOutgoing(null, 0);
+                    ByteBuffer buf = ByteBuffer.allocateDirect(Util.SMALL_BUFFER);
+                    buf.put(msgBytes);
+                    buf.flip();
+
+                    debug("sending small message: " + buf);
+                    sc.send(buf, info);
+
+                    sc.shutdown();
+                    sc.close();
+                }
+            } catch (IOException x) {
+                unexpected(x);
+            } finally {
+                try { ssc.close(); }
+                catch (IOException x) { unexpected(x); }
+            }
+        }
+    }
+
+    class ReceiveNotificationHandler extends AbstractNotificationHandler<Object>
+    {
+        boolean receivedCommUp;  // false
+
+        public ReceiveNotificationHandler() { }
+
+        public boolean receivedCommUp() {
+            return receivedCommUp;
+        }
+
+        @Override
+        public HandlerResult handleNotification(
+                Notification notification, Object attachment) {
+            fail("Unknown notification type");
+            return HandlerResult.CONTINUE;
+        }
+
+        @Override
+        public HandlerResult handleNotification(
+                AssociationChangeNotification notification, Object attachment) {
+            AssocChangeEvent event = notification.event();
+            debug("AssociationChangeNotification");
+            debug("  Association: " + notification.association());
+            debug("  Event: " + event);
+
+            if (event.equals(AssocChangeEvent.COMM_UP))
+                receivedCommUp = true;
+
+            return HandlerResult.CONTINUE;
+        }
+
+        @Override
+        public HandlerResult handleNotification(
+                PeerAddressChangeNotification pacn, Object unused)
+        {
+            debug("PeerAddressChangeNotification: " +  pacn);
+            return HandlerResult.CONTINUE;
+        }
+
+        @Override
+        public HandlerResult handleNotification(
+                ShutdownNotification notification, Object attachment) {
+            debug("ShutdownNotification");
+            debug("  Association: " + notification.association());
+            return HandlerResult.CONTINUE;
+        }
+    }
+        //--------------------- Infrastructure ---------------------------
+    boolean debug = true;
+    volatile int passed = 0, failed = 0;
+    void pass() {passed++;}
+    void fail() {failed++; Thread.dumpStack();}
+    void fail(String msg) {System.err.println(msg); fail();}
+    void unexpected(Throwable t) {failed++; t.printStackTrace();}
+    void check(boolean cond) {if (cond) pass(); else fail();}
+    void check(boolean cond, String failMessage) {if (cond) pass(); else fail(failMessage);}
+    void debug(String message) {if(debug) {
+          System.out.println(Thread.currentThread() + " " + message); } }
+    public static void main(String[] args) throws Throwable {
+        Class<?> k = new Object(){}.getClass().getEnclosingClass();
+        try {k.getMethod("instanceMain",String[].class)
+                .invoke( k.newInstance(), (Object) args);}
+        catch (Throwable e) {throw e.getCause();}}
+    public void instanceMain(String[] args) throws Throwable {
+        try {test(args);} catch (Throwable t) {unexpected(t);}
+        System.out.printf("%nPassed = %d, failed = %d%n%n", passed, failed);
+        if (failed > 0) throw new AssertionError("Some tests failed");}
+
+}
--- ./jdk/test/java/awt/DataFlavor/MissedHtmlAndRtfBug/InterprocessMessages.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/test/java/awt/DataFlavor/MissedHtmlAndRtfBug/InterprocessMessages.java	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2013, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -24,5 +24,6 @@
 interface InterprocessMessages {
     final static int EXECUTION_IS_SUCCESSFULL = 0;
     final static int DATA_IS_CORRUPTED = 212;
+    final static int NO_DROP_HAPPENED = 112;
 }
 
--- ./jdk/test/java/awt/DataFlavor/MissedHtmlAndRtfBug/MissedHtmlAndRtfBug.html	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/test/java/awt/DataFlavor/MissedHtmlAndRtfBug/MissedHtmlAndRtfBug.html	Wed May 07 19:26:47 2014 -0700
@@ -1,7 +1,30 @@
 <html>
 <!--
+   Copyright (c) 2013, 2014, Oracle and/or its affiliates. All rights reserved.
+   DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+  
+   This code is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License version 2 only, as
+   published by the Free Software Foundation.
+  
+   This code is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   version 2 for more details (a copy is included in the LICENSE file that
+   accompanied this code).
+  
+   You should have received a copy of the GNU General Public License version
+   2 along with this work; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+  
+   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+   or visit www.oracle.com if you need additional information or have any
+   questions.
+ -->
+ 
+<!--
   @test
-  @bug 8005932
+  @bug 8005932 8017456
   @summary Java 7 on mac os x only provides text clipboard formats
   @author mikhail.cherkasov@oracle.com
   @library ../../regtesthelpers
--- ./jdk/test/java/awt/DataFlavor/MissedHtmlAndRtfBug/MissedHtmlAndRtfBug.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/test/java/awt/DataFlavor/MissedHtmlAndRtfBug/MissedHtmlAndRtfBug.java	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2013, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -42,6 +42,7 @@
 import static java.lang.Thread.sleep;
 
 public class MissedHtmlAndRtfBug extends Applet {
+
     public void init() {
         setLayout(new BorderLayout());
     }//End  init()
@@ -77,9 +78,6 @@
         args.add(concatStrings(DataFlavorSearcher.RICH_TEXT_NAMES));
 
         ProcessResults processResults =
-//                ProcessCommunicator.executeChildProcess(this.getClass(), "/Users/mcherkasov/ws/clipboard/DataFlover/out/production/DataFlover" +
-//                        " -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=5005 ",
-//                        args.toArray(new String[0]));
                 ProcessCommunicator.executeChildProcess(this.getClass(),
                         "." + File.separator + System.getProperty("java.class.path"), args.toArray(new String[]{}));
 
@@ -112,6 +110,13 @@
             throw new RuntimeException("TEST IS FAILED: Target has received" +
                     " corrupted data.");
         }
+        if (InterprocessMessages.NO_DROP_HAPPENED ==
+                processResults.getExitValue()) {
+            processResults.printProcessErrorOutput(System.err);
+            throw new RuntimeException("Error. Drop did not happen." +
+                " Target frame is possibly covered by a window of other application." +
+                " Please, rerun the test with all windows minimized.");
+        }
         processResults.verifyStdErr(System.err);
         processResults.verifyProcessExitValue(System.err);
         processResults.printProcessStandartOutput(System.out);
@@ -179,7 +184,7 @@
         }
     }
 
-    public static void main(String[] args) {
+    public static void main(String[] args) throws InterruptedException {
         Point dragSourcePoint = new Point(InterprocessArguments.DRAG_SOURCE_POINT_X_ARGUMENT.extractInt(args),
                 InterprocessArguments.DRAG_SOURCE_POINT_Y_ARGUMENT.extractInt(args));
         Point targetFrameLocation = new Point(InterprocessArguments.TARGET_FRAME_X_POSITION_ARGUMENT.extractInt(args),
@@ -192,6 +197,8 @@
         } catch (InterruptedException e) {
             e.printStackTrace();
         }
+        sleep(5000);
+        System.exit(InterprocessMessages.NO_DROP_HAPPENED);
     }
 
 
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/awt/Focus/KeyEventForBadFocusOwnerTest/KeyEventForBadFocusOwnerTest.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,144 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+/*
+  @test
+  @bug 4476629
+  @library ../../../../javax/swing/regtesthelpers
+  @build Util
+  @summary KeyEvents dispatched to old focus owner that is no longer showing
+  @author son@sparc.spb.su: area=awt.focus
+  @run main KeyEventForBadFocusOwnerTest
+*/
+
+/**
+ * KeyEventForBadFocusOwnerTest.java
+ *
+ * summary: KeyEvents dispatched to old focus owner that is no longer showing
+ */
+
+
+import java.awt.Robot;
+import java.awt.Toolkit;
+
+import java.awt.event.*;
+
+import javax.swing.*;
+import javax.swing.event.*;
+import sun.awt.SunToolkit;
+
+public class KeyEventForBadFocusOwnerTest {
+    final static String ITEM_ONE_TEXT = "one";
+    final static String ITEM_TWO_TEXT = "two";
+
+    volatile static boolean itemOneSelected = false;
+    volatile static boolean itemTwoSelected = false;
+    volatile static boolean unexpectedItemSelected = false;
+
+    static Robot robot;
+    static SunToolkit toolkit;
+
+    public static void main(String[] args) throws Exception {
+        SwingUtilities.invokeAndWait(new Runnable() {
+            public void run() {
+                JFrame frame = new JFrame("TEST");
+                JMenuBar mb = new JMenuBar();
+                JMenu one = new JMenu(ITEM_ONE_TEXT);
+                JMenu two = new JMenu(ITEM_TWO_TEXT);
+
+                mb.add(one);
+                mb.add(two);
+
+                ActionListener al = new ActionListener() {
+                    public void actionPerformed(ActionEvent ae) {
+                        String itemText = ((JMenuItem)ae.getSource()).getText();
+                        System.out.println("--> " + itemText);
+                        unexpectedItemSelected = true;
+                    }
+                };
+                one.setMnemonic(KeyEvent.VK_O);
+                JMenuItem item = new JMenuItem("one 1");
+                item.setMnemonic(KeyEvent.VK_O);
+                item.addActionListener(al);
+                one.add(item);
+                one.add("two");
+                one.add("three");
+
+                two.setMnemonic(KeyEvent.VK_T);
+                item = new JMenuItem("two 2");
+                item.setMnemonic(KeyEvent.VK_T);
+                item.addActionListener(al);
+                two.add(item);
+                two.add("three");
+                two.add("four");
+
+                PopupMenuListener popupMenuListener = new PopupMenuListener() {
+                    public void popupMenuWillBecomeVisible(PopupMenuEvent e) {
+                        System.out.print(e);
+                        System.out.print(e.getSource());
+                        String itemText = ((JPopupMenu)e.getSource()).getName();
+                        System.out.println("Menu " + itemText + "is opened.");
+                        switch(itemText) {
+                            case ITEM_ONE_TEXT:
+                                itemOneSelected = true;
+                                break;
+                            case ITEM_TWO_TEXT:
+                                itemTwoSelected = true;
+                                break;
+                        }
+                    }
+
+                    public void popupMenuWillBecomeInvisible(PopupMenuEvent e) {}
+                    public void popupMenuCanceled(PopupMenuEvent e) {}
+                };
+                one.getPopupMenu().setName(ITEM_ONE_TEXT);
+                two.getPopupMenu().setName(ITEM_TWO_TEXT);
+                one.getPopupMenu().addPopupMenuListener(popupMenuListener);
+                two.getPopupMenu().addPopupMenuListener(popupMenuListener);
+                frame.setJMenuBar(mb);
+                frame.setSize(100,100);
+                frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
+                frame.pack();
+                frame.setVisible(true);
+            }
+        });
+
+        toolkit = (SunToolkit) Toolkit.getDefaultToolkit();
+        toolkit.realSync();
+
+        robot = new Robot();
+        robot.setAutoDelay(100);
+
+        Util.hitMnemonics(robot, KeyEvent.VK_O);
+        Util.hitMnemonics(robot, KeyEvent.VK_T);
+
+        toolkit.realSync();
+        Thread.sleep(1000); // workaround for MacOS
+
+        if (unexpectedItemSelected) {
+            throw new Exception("Test failed. KeyEvent dispatched to old focus owner. ");
+        }
+        if (!itemOneSelected || !itemTwoSelected) {
+            throw new Exception("Not all expected events were received");
+        }
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/awt/Frame/DefaultUnixIcon/TestUnixDefaultIcon.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,448 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+@test
+@bug 4934843
+@summary Tests that Frame/Dialog have java-cup icon on Unix
+@author dom@sparc.spb.su: area=awt.toplevel
+@run main/manual TestUnixDefaultIcon
+*/
+
+import java.awt.*;
+import java.awt.event.*;
+import java.awt.image.*;
+import javax.imageio.ImageIO;
+import java.lang.reflect.*;
+import java.io.*;
+import java.awt.color.*;
+
+public class TestUnixDefaultIcon
+{
+    private static void init()
+    {
+        //*** Create instructions for the user here ***
+        boolean isWindows = Toolkit.getDefaultToolkit().getClass().getName().equals("sun.awt.windows.WToolkit");
+
+        String[] instructions;
+        if (isWindows){
+            instructions = new String[]{"This test is for linux only. Passed automatically."};
+        } else {
+            instructions = new String[]{
+                "This test verifies that Frame and Dialog on Unix have Java-cup",
+                "icon by default as their icon.  For your convenience, the example ",
+                "of such icons of different sizes are displayed inside of the frame",
+                "Press Pass if it is so, Fail otherwise."
+            };
+        }
+        Sysout.createDialog( );
+        Sysout.printInstructions( instructions );
+
+        if (isWindows){
+            pass();
+            return;
+        }
+
+        Frame frame = new Frame("frame");
+        frame.setLayout(new FlowLayout());
+        frame.add(new IconCanvas(16, getImage("16")));
+        frame.add(new IconCanvas(24, getImage("24")));
+        frame.add(new IconCanvas(32, getImage("32")));
+        frame.add(new IconCanvas(48, getImage("48")));
+        frame.setBounds(0, 500, 200, 100);
+        frame.setVisible(true);
+
+        Dialog d = new Dialog(frame, "Dialog", false);
+        d.setBounds(200, 500, 200, 100);
+        d.setVisible(true);
+
+    }//End  init()
+
+    private static BufferedImage createImage(int[] bits) {
+        ColorModel cm =
+            new DirectColorModel(ColorSpace.getInstance(ColorSpace.CS_sRGB), 32,
+                                 0x00ff0000, 0x0000ff00, 0x000000ff, 0xff000000,
+                                 false, DataBuffer.TYPE_INT);
+        DataBuffer buffer = new DataBufferInt(bits, bits.length-2, 2);
+        WritableRaster raster =
+            Raster.createPackedRaster(buffer, bits[0], bits[1],
+                                      bits[0],
+                                      new int[] {0x00ff0000, 0x0000ff00,
+                                                 0x000000ff, 0xff000000},
+                                      null);
+        BufferedImage im = new BufferedImage(cm, raster, false, null);
+        return im;
+    }
+    private static Image getImage(String name) {
+        try {
+            Class cl = Class.forName("sun.awt.AWTIcon32_java_icon" + name + "_png");
+            Field f = cl.getField("java_icon" + name + "_png");
+            int[] ints = (int[])f.get(cl);
+
+            return createImage(ints);
+        } catch (ClassNotFoundException | IllegalAccessException | NoSuchFieldException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    static class IconCanvas extends Canvas {
+        private Image im;
+        private int s;
+        public IconCanvas(int s, Image im) {
+            this.im = im;
+            this.s = s;
+        }
+
+        public Dimension getPreferredSize() {
+            return new Dimension(s, s);
+        }
+
+        public void paint(Graphics g) {
+            if (im != null) {
+                g.drawImage(im, 0, 0, this);
+            }
+        }
+    }
+
+    /*****************************************************
+     * Standard Test Machinery Section
+     * DO NOT modify anything in this section -- it's a
+     * standard chunk of code which has all of the
+     * synchronisation necessary for the test harness.
+     * By keeping it the same in all tests, it is easier
+     * to read and understand someone else's test, as
+     * well as insuring that all tests behave correctly
+     * with the test harness.
+     * There is a section following this for test-defined
+     * classes
+     ******************************************************/
+    private static boolean theTestPassed = false;
+    private static boolean testGeneratedInterrupt = false;
+    private static String failureMessage = "";
+
+    private static Thread mainThread = null;
+
+    private static int sleepTime = 300000;
+
+    public static void main( String args[] ) throws InterruptedException
+    {
+        mainThread = Thread.currentThread();
+        try
+        {
+            init();
+        }
+        catch( TestPassedException e )
+        {
+            //The test passed, so just return from main and harness will
+            // interepret this return as a pass
+            return;
+        }
+        //At this point, neither test passed nor test failed has been
+        // called -- either would have thrown an exception and ended the
+        // test, so we know we have multiple threads.
+
+        //Test involves other threads, so sleep and wait for them to
+        // called pass() or fail()
+        try
+        {
+            Thread.sleep( sleepTime );
+            //Timed out, so fail the test
+            throw new RuntimeException( "Timed out after " + sleepTime/1000 + " seconds" );
+        }
+        catch (InterruptedException e)
+        {
+            if( ! testGeneratedInterrupt ) throw e;
+
+            //reset flag in case hit this code more than once for some reason (just safety)
+            testGeneratedInterrupt = false;
+            if ( theTestPassed == false )
+            {
+                throw new RuntimeException( failureMessage );
+            }
+        }
+
+    }//main
+
+    public static synchronized void setTimeoutTo( int seconds )
+    {
+        sleepTime = seconds * 1000;
+    }
+
+    public static synchronized void pass()
+    {
+        Sysout.println( "The test passed." );
+        Sysout.println( "The test is over, hit  Ctl-C to stop Java VM" );
+        //first check if this is executing in main thread
+        if ( mainThread == Thread.currentThread() )
+        {
+            //Still in the main thread, so set the flag just for kicks,
+            // and throw a test passed exception which will be caught
+            // and end the test.
+            theTestPassed = true;
+            throw new TestPassedException();
+        }
+        //pass was called from a different thread, so set the flag and interrupt
+        // the main thead.
+        theTestPassed = true;
+        testGeneratedInterrupt = true;
+        mainThread.interrupt();
+    }//pass()
+
+    public static synchronized void fail()
+    {
+        //test writer didn't specify why test failed, so give generic
+        fail( "it just plain failed! :-)" );
+    }
+
+    public static synchronized void fail( String whyFailed )
+    {
+        Sysout.println( "The test failed: " + whyFailed );
+        Sysout.println( "The test is over, hit  Ctl-C to stop Java VM" );
+        //check if this called from main thread
+        if ( mainThread == Thread.currentThread() )
+        {
+            //If main thread, fail now 'cause not sleeping
+            throw new RuntimeException( whyFailed );
+        }
+        theTestPassed = false;
+        testGeneratedInterrupt = true;
+        failureMessage = whyFailed;
+        mainThread.interrupt();
+    }//fail()
+
+}// class TestUnixDefaultIcon
+
+//This exception is used to exit from any level of call nesting
+// when it's determined that the test has passed, and immediately
+// end the test.
+class TestPassedException extends RuntimeException
+{
+}
+
+//*********** End Standard Test Machinery Section **********
+
+
+//************ Begin classes defined for the test ****************
+
+// make listeners in a class defined here, and instantiate them in init()
+
+/* Example of a class which may be written as part of a test
+class NewClass implements anInterface
+ {
+   static int newVar = 0;
+
+   public void eventDispatched(AWTEvent e)
+    {
+      //Counting events to see if we get enough
+      eventCount++;
+
+      if( eventCount == 20 )
+       {
+         //got enough events, so pass
+
+         TestUnixDefaultIcon.pass();
+       }
+      else if( tries == 20 )
+       {
+         //tried too many times without getting enough events so fail
+
+         TestUnixDefaultIcon.fail();
+       }
+
+    }// eventDispatched()
+
+ }// NewClass class
+
+*/
+
+
+//************** End classes defined for the test *******************
+
+
+
+
+/****************************************************
+ Standard Test Machinery
+ DO NOT modify anything below -- it's a standard
+  chunk of code whose purpose is to make user
+  interaction uniform, and thereby make it simpler
+  to read and understand someone else's test.
+ ****************************************************/
+
+/**
+ This is part of the standard test machinery.
+ It creates a dialog (with the instructions), and is the interface
+  for sending text messages to the user.
+ To print the instructions, send an array of strings to Sysout.createDialog
+  WithInstructions method.  Put one line of instructions per array entry.
+ To display a message for the tester to see, simply call Sysout.println
+  with the string to be displayed.
+ This mimics System.out.println but works within the test harness as well
+  as standalone.
+ */
+
+class Sysout
+{
+    private static TestDialog dialog;
+
+    public static void createDialogWithInstructions( String[] instructions )
+    {
+        dialog = new TestDialog( new Frame(), "Instructions" );
+        dialog.printInstructions( instructions );
+        dialog.setVisible(true);
+        println( "Any messages for the tester will display here." );
+    }
+
+    public static void createDialog( )
+    {
+        dialog = new TestDialog( new Frame(), "Instructions" );
+        String[] defInstr = { "Instructions will appear here. ", "" } ;
+        dialog.printInstructions( defInstr );
+        dialog.setVisible(true);
+        println( "Any messages for the tester will display here." );
+    }
+
+
+    public static void printInstructions( String[] instructions )
+    {
+        dialog.printInstructions( instructions );
+    }
+
+
+    public static void println( String messageIn )
+    {
+        dialog.displayMessage( messageIn );
+    }
+
+}// Sysout  class
+
+/**
+  This is part of the standard test machinery.  It provides a place for the
+   test instructions to be displayed, and a place for interactive messages
+   to the user to be displayed.
+  To have the test instructions displayed, see Sysout.
+  To have a message to the user be displayed, see Sysout.
+  Do not call anything in this dialog directly.
+  */
+class TestDialog extends Dialog implements ActionListener
+{
+
+    TextArea instructionsText;
+    TextArea messageText;
+    int maxStringLength = 80;
+    Panel  buttonP = new Panel();
+    Button passB = new Button( "pass" );
+    Button failB = new Button( "fail" );
+
+    //DO NOT call this directly, go through Sysout
+    public TestDialog( Frame frame, String name )
+    {
+        super( frame, name );
+        int scrollBoth = TextArea.SCROLLBARS_BOTH;
+        instructionsText = new TextArea( "", 15, maxStringLength, scrollBoth );
+        add( "North", instructionsText );
+
+        messageText = new TextArea( "", 5, maxStringLength, scrollBoth );
+        add("Center", messageText);
+
+        passB = new Button( "pass" );
+        passB.setActionCommand( "pass" );
+        passB.addActionListener( this );
+        buttonP.add( "East", passB );
+
+        failB = new Button( "fail" );
+        failB.setActionCommand( "fail" );
+        failB.addActionListener( this );
+        buttonP.add( "West", failB );
+
+        add( "South", buttonP );
+        pack();
+
+        setVisible(true);
+    }// TestDialog()
+
+    //DO NOT call this directly, go through Sysout
+    public void printInstructions( String[] instructions )
+    {
+        //Clear out any current instructions
+        instructionsText.setText( "" );
+
+        //Go down array of instruction strings
+
+        String printStr, remainingStr;
+        for( int i=0; i < instructions.length; i++ )
+        {
+            //chop up each into pieces maxSringLength long
+            remainingStr = instructions[ i ];
+            while( remainingStr.length() > 0 )
+            {
+                //if longer than max then chop off first max chars to print
+                if( remainingStr.length() >= maxStringLength )
+                {
+                    //Try to chop on a word boundary
+                    int posOfSpace = remainingStr.
+                        lastIndexOf( ' ', maxStringLength - 1 );
+
+                    if( posOfSpace <= 0 ) posOfSpace = maxStringLength - 1;
+
+                    printStr = remainingStr.substring( 0, posOfSpace + 1 );
+                    remainingStr = remainingStr.substring( posOfSpace + 1 );
+                }
+                //else just print
+                else
+                {
+                    printStr = remainingStr;
+                    remainingStr = "";
+                }
+
+                instructionsText.append( printStr + "\n" );
+
+            }// while
+
+        }// for
+
+    }//printInstructions()
+
+    //DO NOT call this directly, go through Sysout
+    public void displayMessage( String messageIn )
+    {
+        messageText.append( messageIn + "\n" );
+        System.out.println(messageIn);
+    }
+
+    //catch presses of the passed and failed buttons.
+    //simply call the standard pass() or fail() static methods of
+    //TestUnixDefaultIcon
+    public void actionPerformed( ActionEvent e )
+    {
+        if( e.getActionCommand() == "pass" )
+        {
+            TestUnixDefaultIcon.pass();
+        }
+        else
+        {
+            TestUnixDefaultIcon.fail();
+        }
+    }
+
+}// TestDialog  class
--- ./jdk/test/java/awt/FullScreen/TranslucentWindow/TranslucentWindow.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/test/java/awt/FullScreen/TranslucentWindow/TranslucentWindow.java	Wed May 07 19:26:47 2014 -0700
@@ -42,6 +42,7 @@
         GraphicsDevice gd = ge.getDefaultScreenDevice();
 
         Frame f = new Frame("Test frame");
+        f.setUndecorated(true);
         f.setBounds(100, 100, 320, 240);
 
         // First, check it can be made fullscreen window without any effects applied
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/awt/JAWT/JAWT.sh	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,173 @@
+#!/bin/sh
+
+# Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+
+# @test JAWT.sh
+# @bug 7190587
+# @summary Tests Java AWT native interface library
+# @author kshefov
+# @run shell JAWT.sh
+
+# NB: To run on Windows with MKS and Visual Studio compiler
+# add the following options to jtreg: -e INCLUDE="%INCLUDE%;." -e LIB="%LIB%;."
+
+if [ "${TESTSRC}" = "" ]
+then TESTSRC=.
+fi
+
+if [ "${TESTJAVA}" = "" ]
+then
+  PARENT=`dirname \`which java\``
+  TESTJAVA=`dirname ${PARENT}`
+  echo "TESTJAVA not set, selecting " ${TESTJAVA}
+  echo "If this is incorrect, try setting the variable manually."
+fi
+
+# set platform-dependent variables
+OS=`uname -s`
+case "$OS" in
+  Linux )
+    NULL=/dev/null
+    PS=":"
+    FS="/"
+    ${TESTJAVA}${FS}bin${FS}java -version 2>&1 | grep '64-Bit' > $NULL
+    if [ $? -eq '0' ]
+    then
+        ARCH="amd64"
+    else
+        ARCH="i386"
+    fi
+    SYST="linux"
+    MAKEFILE="Makefile.unix"
+    CC="gcc"
+	MAKE="make"
+	LD_LIBRARY_PATH=".":${TESTJAVA}${FS}jre${FS}lib${FS}${ARCH}
+    ;;
+  SunOS )
+    NULL=/dev/null
+    PS=":"
+    FS="/"
+    if [ `uname -p | grep -c 'sparc'` -gt '0' ]
+    then
+        ARCH="sparc"
+    else
+        ARCH="i386"
+    fi
+    SYST="solaris"
+    MAKEFILE="Makefile.unix"
+    CC="gcc"
+	MAKE="make"
+	LD_LIBRARY_PATH=".":${TESTJAVA}${FS}jre${FS}lib${FS}${ARCH}
+    ;;
+  Windows* )
+    NULL=null
+    PS=";"
+    FS="\\"
+    MAKEFILE="Makefile.win"
+    CC="cl"
+	MAKE="nmake"
+	${TESTJAVA}${FS}bin${FS}java -d64 -version 2>&1 | grep '64-Bit' > $NULL
+    if [ "$?" -eq '0' ]
+    then
+        ARCH="amd64"
+    else
+        ARCH="i386"
+    fi
+	SYST="windows"
+    ;;
+  CYGWIN* )
+    NULL=/dev/null
+    PS=":"
+    FS="/"
+    MAKEFILE="Makefile.cygwin"
+    CC="gcc"
+	${TESTJAVA}${FS}bin${FS}java -d64 -version 2>&1 | grep '64-Bit' > $NULL
+    if [ "$?" -eq '0' ]
+    then
+        ARCH="amd64"
+    else
+        ARCH="i386"
+    fi
+	SYST="cygwin"	
+	MAKE="make"
+    ;;
+  Darwin )
+    echo "Test passed. This test is not for MacOS."
+    exit 0;
+    ;;
+  * )
+    echo "Unrecognized system!"
+    exit 1;
+    ;;
+esac
+
+# Skip unsupported platforms
+case `uname -m` in
+    arm* | ppc* )
+      echo "Test passed. Not supported on current architecture."
+      exit 0
+      ;;
+esac
+
+echo "OS-ARCH is" ${SYST}-${ARCH}
+${TESTJAVA}${FS}jre${FS}bin${FS}java -fullversion 2>&1
+
+which ${MAKE} >${NULL} 2>&1
+if [ "$?" -ne '0' ]
+then
+    echo "No make found. Test passed."
+    exit 0
+fi
+
+which ${CC} >${NULL} 2>&1
+if [ "$?" -ne '0' ]
+then
+    echo "No C compiler found. Test passed."
+    exit 0
+fi
+case "$OS" in
+    SunOS )
+      ${CC} -v >${NULL} 2>&1
+      if [ "$?" -ne '0' ]
+      then
+          echo "No C compiler found. Test passed."
+          exit 0
+      fi
+esac
+
+cp ${TESTSRC}${FS}${MAKEFILE} .
+
+JAVA=${TESTJAVA}${FS}jre${FS}bin${FS}java
+JAVAC=${TESTJAVA}${FS}bin${FS}javac
+JAVAH=${TESTJAVA}${FS}bin${FS}javah
+
+export CC SYST ARCH LD_LIBRARY_PATH
+
+${JAVAC} -d . ${TESTSRC}${FS}MyCanvas.java
+${JAVAH} -jni -classpath . -d . MyCanvas
+${MAKE} -f ${MAKEFILE}
+${JAVA} -classpath . MyCanvas
+
+exit $?
+
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/awt/JAWT/Makefile.cygwin	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,49 @@
+# Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+
+CFLAGS =	
+OBJS =		myfile.o
+HEADERS =	MyCanvas.h
+CLASSES =	MyCanvas.class
+
+JAVA =		$(TESTJAVA)/bin/java -classpath .
+JAVAC =		$(TESTJAVA)/bin/javac
+JAVAH =		$(TESTJAVA)/bin/javah
+DEL =		rm -rf
+LINK =		$(CC)
+
+INCLUDES =	-I $(TESTJAVA)/include/win32 -I $(TESTJAVA)/include -I .
+
+LIBS =		$(TESTJAVA)/lib/jawt.lib -lgdi32
+
+all:		$(CLASSES) mylib.dll
+
+mylib.dll: $(HEADERS) $(OBJS) 
+	$(LINK) -shared -o mylib.dll $(OBJS) $(LIBS) 
+
+myfile.o:
+	$(CC) $(CFLAGS)  $(INCLUDES) -c $(TESTSRC)/myfile.cpp
+
+clean:
+	$(DEL) mylib.* *.h *.class *.o
+ 
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/awt/JAWT/Makefile.unix	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,48 @@
+# Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+
+CFLAGS =	-fPIC -O
+OBJS =		myfile.o
+HEADERS =	MyCanvas.h
+CLASSES =	MyCanvas.class
+
+ENV =		/usr/bin/env
+JAVA =		$(TESTJAVA)/bin/java -classpath .
+JAVAC =		$(TESTJAVA)/bin/javac
+JAVAH =		$(TESTJAVA)/bin/javah
+LINK =		ld
+
+J_INC =		$(TESTJAVA)/include
+INCLUDES =	-I$(J_INC) -I$(J_INC)/$(SYST) -I.
+LIBS =		-L$(TESTJAVA)/jre/lib/$(ARCH) -ljawt -lX11
+
+all:		$(CLASSES) libmylib.so
+
+libmylib.so: $(HEADERS) $(OBJS) 
+	$(LINK) -G -o libmylib.so $(OBJS) $(LIBS)
+
+myfile.o:	$(TESTSRC)/myfile.c
+	$(CC)  $(CFLAGS) $(INCLUDES) -c $(TESTSRC)/myfile.c
+
+clean:
+	rm -rf libmylib.so $(HEADERS) $(CLASSES) $(OBJS)
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/awt/JAWT/Makefile.win	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,47 @@
+# Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+
+CFLAGS =	-nologo
+OBJS =		myfile.obj
+HEADERS =	MyCanvas.h
+CLASSES =	MyCanvas.class
+
+DEL =		del /Q
+LINK =		link
+
+INCLUDES =	-I$(TESTJAVA)\include\win32 -I$(TESTJAVA)\include
+
+LIBS =		gdi32.lib user32.lib $(TESTJAVA)\lib\jawt.lib
+
+all:		$(CLASSES) mylib.dll
+
+mylib.dll: $(HEADERS) $(OBJS) 
+	$(LINK) -nologo -dll -out:mylib.dll $(OBJS) $(LIBS)
+
+myfile.obj: $(TESTSRC)\myfile.cpp
+	$(CC) $(CFLAGS) $(INCLUDES) -c $(TESTSRC)\myfile.cpp
+
+clean:
+	$(DEL) mylib.* 
+	$(DEL) $(HEADERS) $(CLASSES)
+	$(DEL) *.obj
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/awt/JAWT/MyCanvas.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,72 @@
+/**
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import java.awt.*;
+import java.awt.event.*;
+
+public class MyCanvas extends Canvas {
+
+    static {
+        try {
+            System.loadLibrary("mylib");
+        } catch (Throwable t) {
+            System.out.println("Test failed!!");
+            t.printStackTrace();
+            System.exit(1);
+        }
+    }
+
+    public native void paint(Graphics g);
+
+    public static void main(String[] args) {
+        try {
+            Robot robot = new Robot();
+            Frame f = new Frame();
+            f.setBounds(0, 0, 100, 100);
+            f.add(new MyCanvas());
+            f.addWindowListener(new WindowAdapter() {
+                public void windowClosing(WindowEvent ev) {
+                    System.exit(0);
+                }
+            });
+            f.setVisible(true);
+            robot.delay(5000);
+            Color col1 = new Color(0, 0, 0);
+            Color col2 = robot.getPixelColor(f.getX()+50, f.getY()+50);
+            if (col1.equals(col2)) {
+                System.out.println("Test passed!");
+            } else {
+                throw new RuntimeException("Color of JAWT canvas is wrong or " +
+                        "it was not rendered. " + "Check that other windows " +
+                        "do not block the test frame.");
+            }
+            System.exit(0);
+        } catch (Throwable t) {
+            System.out.println("Test failed!");
+            t.printStackTrace();
+            System.exit(1);
+        }
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/awt/JAWT/myfile.c	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,106 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#include "MyCanvas.h"
+#include "jawt_md.h"
+
+/*
+ * Class:     MyCanvas
+ * Method:    paint
+ * Signature: (Ljava/awt/Graphics;)V
+ */
+JNIEXPORT void JNICALL Java_MyCanvas_paint
+(JNIEnv* env, jobject canvas, jobject graphics)
+{
+    JAWT awt;
+    JAWT_DrawingSurface* ds;
+    JAWT_DrawingSurfaceInfo* dsi;
+    JAWT_X11DrawingSurfaceInfo* dsi_x11;
+    jboolean result;
+    jint lock;
+    GC gc;
+    jobject ref;
+
+    /* Get the AWT */
+    awt.version = JAWT_VERSION_1_4;
+    if (JAWT_GetAWT(env, &awt) == JNI_FALSE) {
+        printf("AWT Not found\n");
+        return;
+    }
+
+    /* Lock the AWT */
+    awt.Lock(env);
+
+    /* Unlock the AWT */
+    awt.Unlock(env);
+
+    /* Get the drawing surface */
+    ds = awt.GetDrawingSurface(env, canvas);
+    if (ds == NULL) {
+        printf("NULL drawing surface\n");
+        return;
+    }
+
+    /* Lock the drawing surface */
+    lock = ds->Lock(ds);
+    printf("Lock value %d\n", (int)lock);
+    if((lock & JAWT_LOCK_ERROR) != 0) {
+        printf("Error locking surface\n");
+        awt.FreeDrawingSurface(ds);
+        return;
+    }
+
+    /* Get the drawing surface info */
+    dsi = ds->GetDrawingSurfaceInfo(ds);
+    if (dsi == NULL) {
+        printf("Error getting surface info\n");
+        ds->Unlock(ds);
+        awt.FreeDrawingSurface(ds);
+        return;
+    }
+
+    /* Get the platform-specific drawing info */
+    dsi_x11 = (JAWT_X11DrawingSurfaceInfo*)dsi->platformInfo;
+
+    /* Now paint */
+    gc = XCreateGC(dsi_x11->display, dsi_x11->drawable, 0, 0);
+    XSetForeground(dsi_x11->display, gc, 0);
+    XFillRectangle(dsi_x11->display, dsi_x11->drawable, gc,
+                   5, 5, 90, 90);
+    XFreeGC(dsi_x11->display, gc);
+    ref = awt.GetComponent(env, (void*)(dsi_x11->drawable));
+    if (!(*env)->IsSameObject(env, ref, canvas)) {
+        printf("Error! Different objects!\n");
+    }
+
+    /* Free the drawing surface info */
+    ds->FreeDrawingSurfaceInfo(dsi);
+
+    /* Unlock the drawing surface */
+    ds->Unlock(ds);
+
+    /* Free the drawing surface */
+    awt.FreeDrawingSurface(ds);
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/awt/JAWT/myfile.cpp	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,110 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+#include <windows.h>
+#include "MyCanvas.h"
+#include "jawt_md.h"
+
+/*
+ * Class:     MyCanvas
+ * Method:    paint
+ * Signature: (Ljava/awt/Graphics;)V
+ */
+
+extern "C" {
+
+JNIEXPORT void JNICALL Java_MyCanvas_paint
+(JNIEnv* env, jobject canvas, jobject graphics)
+{
+    /* Get the AWT */
+    JAWT awt;
+    awt.version = JAWT_VERSION_1_4;
+    if (JAWT_GetAWT(env, &awt) == JNI_FALSE) {
+        printf("AWT Not found\n");
+        return;
+    }
+
+    /* Lock the AWT */
+    awt.Lock(env);
+
+    /* Unlock the AWT */
+    awt.Unlock(env);
+
+    /* Get the drawing surface */
+    JAWT_DrawingSurface* ds = awt.GetDrawingSurface(env, canvas);
+    if (ds == NULL) {
+        printf("NULL drawing surface\n");
+        return;
+    }
+
+    /* Lock the drawing surface */
+    jint lock = ds->Lock(ds);
+    printf("Lock value %d\n", (int)lock);
+    if((lock & JAWT_LOCK_ERROR) != 0) {
+        printf("Error locking surface\n");
+        return;
+    }
+
+    /* Get the drawing surface info */
+    JAWT_DrawingSurfaceInfo* dsi = ds->GetDrawingSurfaceInfo(ds);
+    if (dsi == NULL) {
+        printf("Error getting surface info\n");
+        ds->Unlock(ds);
+        return;
+    }
+
+    /* Get the platform-specific drawing info */
+    JAWT_Win32DrawingSurfaceInfo* dsi_win =
+        (JAWT_Win32DrawingSurfaceInfo*)dsi->platformInfo;
+
+    /* Now paint */
+    PAINTSTRUCT ps;
+    /* Do not use the HDC returned from BeginPaint()!! */
+    ::BeginPaint(dsi_win->hwnd, &ps);
+    HBRUSH hbrush = (HBRUSH)::GetStockObject(BLACK_BRUSH);
+    RECT rect;
+    rect.left = 5;
+    rect.top = 5;
+    rect.right = 95;
+    rect.bottom = 95;
+    ::FillRect(dsi_win->hdc, &rect, hbrush);
+    ::EndPaint(dsi_win->hwnd, &ps);
+
+    jobject ref = awt.GetComponent(env, (void*)(dsi_win->hwnd));
+    if (!env->IsSameObject(ref, canvas)) {
+        printf("Error! Different objects!\n");
+    }
+
+    /* Free the drawing surface info */
+    ds->FreeDrawingSurfaceInfo(dsi);
+
+    /* Unlock the drawing surface */
+    ds->Unlock(ds);
+
+    /* Free the drawing surface */
+    awt.FreeDrawingSurface(ds);
+}
+
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/awt/List/FirstItemRemoveTest/FirstItemRemoveTest.html	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,43 @@
+<html>
+<!--
+  Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ 
+  This code is free software; you can redistribute it and/or modify it
+  under the terms of the GNU General Public License version 2 only, as
+  published by the Free Software Foundation.
+ 
+  This code is distributed in the hope that it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+  version 2 for more details (a copy is included in the LICENSE file that
+  accompanied this code).
+ 
+  You should have received a copy of the GNU General Public License version
+  2 along with this work; if not, write to the Free Software Foundation,
+  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ 
+  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+  or visit www.oracle.com if you need additional information or have any
+  questions.
+ -->
+<!--  
+  @test
+  @bug 6299858
+  @summary PIT. Focused border not shown on List if selected item is removed, XToolkit
+  @author Dmitry.Cherepanov@SUN.COM area=awt.list
+  @run applet FirstItemRemoveTest.html
+  -->
+<head>
+<title>  </title>
+</head>
+<body>
+
+<h1>FirstItemRemoveTest<br>Bug ID: 6299858 </h1>
+
+<p> This is an AUTOMATIC test, simply wait for completion </p>
+
+<APPLET CODE="FirstItemRemoveTest.class" WIDTH=200 HEIGHT=200></APPLET>
+</body>
+</html>
+
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/awt/List/FirstItemRemoveTest/FirstItemRemoveTest.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,119 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+  test
+  @bug 6299858 7124338
+  @summary PIT. Focused border not shown on List if selected item is removed, XToolkit
+  @author Dmitry.Cherepanov@SUN.COM area=awt.list
+  @run applet FirstItemRemoveTest.html
+*/
+
+import java.applet.Applet;
+import java.awt.*;
+import java.awt.event.*;
+
+public class FirstItemRemoveTest extends Applet
+{
+    List list = new List(4, false);
+    Panel panel = new Panel();
+
+    public void init()
+    {
+        list.add("000");
+        list.add("111");
+        list.add("222");
+        list.add("333");
+        list.add("444");
+        list.add("555");
+
+        panel.setLayout(new FlowLayout ());
+        panel.add(list);
+
+        this.add(panel);
+        this.setLayout (new FlowLayout ());
+    }//End  init()
+
+    public void start ()
+    {
+        setSize (200,200);
+        setVisible(true);
+        validate();
+
+        test();
+    }// start()
+
+    private void test(){
+
+        if (sun.awt.OSInfo.getOSType() == sun.awt.OSInfo.OSType.MACOSX) {
+            System.err.println("Skipped. This test is not for OS X.");
+            return;
+        }
+
+        Robot r;
+        try {
+            r = new Robot();
+        } catch(AWTException e) {
+            throw new RuntimeException(e.getMessage());
+        }
+
+        // Removing first item in order to reproduce incorrect behaviour
+        r.delay(1000);
+        list.remove(0);
+        r.delay(1000);
+
+        // Request focus to list
+        Point loc = this.getLocationOnScreen();
+        r.delay(1000);
+
+        r.mouseMove(loc.x+10, loc.y+10);
+        r.delay(10);
+        r.mousePress(InputEvent.BUTTON1_MASK);
+        r.delay(10);
+        r.mouseRelease(InputEvent.BUTTON1_MASK);
+        r.delay(1000);
+
+        list.requestFocusInWindow();
+        r.delay(1000);
+        r.waitForIdle();
+        if (KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusOwner() != list){
+            throw new RuntimeException("Test failed - list isn't focus owner.");
+        }
+
+        // The focus index should be set to first item after removing
+        // So if we press VK_SPACE then the selected item will be equals 0.
+        r.delay(100);
+        r.keyPress(KeyEvent.VK_SPACE);
+        r.delay(10);
+        r.keyRelease(KeyEvent.VK_SPACE);
+        r.delay(1000);
+        r.waitForIdle();
+
+        int selectedIndex = list.getSelectedIndex();
+        if (selectedIndex != 0){
+            throw new RuntimeException("Test failed. list.getSelectedIndex() = "+selectedIndex);
+        }
+
+    }
+
+}// class AutomaticAppletTest
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/awt/Toolkit/ToolkitPropertyTest/bug7129133.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,50 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 7129133
+ * @summary [macosx] Accelerators are displayed as Meta instead of the Command symbol
+ * @author leonid.romanov@oracle.com
+ * @run main bug7129133
+ */
+
+import java.awt.*;
+
+public class bug7129133 {
+    public static void main(String[] args) throws Exception {
+        if (sun.awt.OSInfo.getOSType() != sun.awt.OSInfo.OSType.MACOSX) {
+            System.out.println("This test is for MacOS only. Automatically passed on other platforms.");
+            return;
+        }
+
+        Toolkit.getDefaultToolkit();
+
+        String cmdSymbol = "\u2318";
+        String val = Toolkit.getProperty("AWT.meta", "Meta");
+
+        if (!val.equals(cmdSymbol)) {
+           throw new Exception("Wrong property value for AWT.meta. Expected: " + cmdSymbol + ", actual: " + val);
+        }
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/awt/TrayIcon/ShowAfterDisposeTest/ShowAfterDisposeTest.html	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,43 @@
+<html>
+<!--
+ Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+
+ This code is free software; you can redistribute it and/or modify it
+ under the terms of the GNU General Public License version 2 only, as
+ published by the Free Software Foundation.
+
+ This code is distributed in the hope that it will be useful, but WITHOUT
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ version 2 for more details (a copy is included in the LICENSE file that
+ accompanied this code).
+
+ You should have received a copy of the GNU General Public License version
+ 2 along with this work; if not, write to the Free Software Foundation,
+ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+
+ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ or visit www.oracle.com if you need additional information or have any
+ questions.
+-->
+
+<!--
+  @test
+  @bug 6384984 8004032
+  @summary TrayIcon try to dispay a tooltip when is not visible
+  @author Dmitry.Cherepanov@sun.com area=awt.tray
+  @run applet/manual=yesno ShowAfterDisposeTest.html
+  -->
+<head>
+<title> ShowAfterDisposeTest </title>
+</head>
+<body>
+
+<h1>ShowAfterDisposeTest<br>Bug ID: 6384984</h1>
+
+<p> See the dialog box (usually in upper left corner) for instructions</p>
+
+<APPLET CODE="ShowAfterDisposeTest.class" WIDTH=200 HEIGHT=200></APPLET>
+</body>
+</html>
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/awt/TrayIcon/ShowAfterDisposeTest/ShowAfterDisposeTest.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,246 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+  test
+  @bug 6384984 8004032
+  @summary TrayIcon try to dispay a tooltip when is not visible
+  @author Dmitry.Cherepanov@sun.com area=awt.tray
+  @run applet/manual=yesno ShowAfterDisposeTest.html
+*/
+
+import java.applet.*;
+
+import java.awt.*;
+import java.awt.event.*;
+import java.awt.image.*;
+
+public class ShowAfterDisposeTest extends Applet
+{
+    boolean traySupported;
+
+    public void init()
+    {
+        this.setLayout (new BorderLayout ());
+
+        String[] instructions;
+        traySupported = SystemTray.isSupported();
+        if (traySupported)
+        {
+            String[] s =
+            {
+                "1) When the test starts an icon is added to the SystemTray area.",
+                "2a) If you use Apple OS X,",
+                "    right click on this icon (it's important to click before the tooltip is shown).",
+                "    The icon should disappear.",
+                "2b) If you use other os (Windows, Linux, Solaris),",
+                "    double click on this icon (it's important to click before the tooltip is shown).",
+                "    The icon should disappear.",
+                "3) If the bug is reproducible then the test will fail without assistance.",
+                "4) Just press the 'pass' button."
+            };
+            instructions = s;
+        }
+        else
+        {
+            String[] s =
+            {
+              "The test cannot be run because SystemTray is not supported.",
+              "Simply press PASS button."
+            };
+            instructions = s;
+        }
+        Sysout.createDialogWithInstructions(instructions);
+    }
+
+    public void start ()
+    {
+        setSize (200,200);
+        setVisible(true);
+        validate();
+
+        if (!traySupported)
+        {
+            return;
+        }
+
+        BufferedImage img = new BufferedImage(32, 32, BufferedImage.TYPE_INT_ARGB);
+        Graphics g = img.createGraphics();
+        g.setColor(Color.WHITE);
+        g.fillRect(0, 0, 32, 32);
+        g.setColor(Color.RED);
+        g.fillRect(6, 6, 20, 20);
+        g.dispose();
+
+        final SystemTray tray = SystemTray.getSystemTray();
+        final TrayIcon icon = new TrayIcon(img);
+        icon.setImageAutoSize(true);
+        icon.addActionListener(new ActionListener()
+            {
+                public void actionPerformed(ActionEvent ev)
+                {
+                    tray.remove(icon);
+                }
+            }
+        );
+
+        try {
+            tray.add(icon);
+        } catch (AWTException e) {
+            Sysout.println(e.toString());
+            Sysout.println("!!! The test coudn't be performed !!!");
+            return;
+        }
+        icon.setToolTip("tooltip");
+    }
+}
+
+/****************************************************
+ Standard Test Machinery
+ DO NOT modify anything below -- it's a standard
+  chunk of code whose purpose is to make user
+  interaction uniform, and thereby make it simpler
+  to read and understand someone else's test.
+ ****************************************************/
+
+/**
+ This is part of the standard test machinery.
+ It creates a dialog (with the instructions), and is the interface
+  for sending text messages to the user.
+ To print the instructions, send an array of strings to Sysout.createDialog
+  WithInstructions method.  Put one line of instructions per array entry.
+ To display a message for the tester to see, simply call Sysout.println
+  with the string to be displayed.
+ This mimics System.out.println but works within the test harness as well
+  as standalone.
+ */
+
+class Sysout
+{
+    private static TestDialog dialog;
+
+    public static void createDialogWithInstructions( String[] instructions )
+    {
+        dialog = new TestDialog( new Frame(), "Instructions" );
+        dialog.printInstructions( instructions );
+        dialog.setVisible(true);
+        println( "Any messages for the tester will display here." );
+    }
+
+    public static void createDialog( )
+    {
+        dialog = new TestDialog( new Frame(), "Instructions" );
+        String[] defInstr = { "Instructions will appear here. ", "" } ;
+        dialog.printInstructions( defInstr );
+        dialog.setVisible(true);
+        println( "Any messages for the tester will display here." );
+    }
+
+    public static void printInstructions( String[] instructions )
+    {
+        dialog.printInstructions( instructions );
+    }
+
+    public static void println( String messageIn )
+    {
+        dialog.displayMessage( messageIn );
+    }
+}
+
+/**
+  This is part of the standard test machinery.  It provides a place for the
+   test instructions to be displayed, and a place for interactive messages
+   to the user to be displayed.
+  To have the test instructions displayed, see Sysout.
+  To have a message to the user be displayed, see Sysout.
+  Do not call anything in this dialog directly.
+  */
+class TestDialog extends Dialog
+{
+
+    TextArea instructionsText;
+    TextArea messageText;
+    int maxStringLength = 80;
+
+    //DO NOT call this directly, go through Sysout
+    public TestDialog( Frame frame, String name )
+    {
+        super( frame, name );
+        int scrollBoth = TextArea.SCROLLBARS_BOTH;
+        instructionsText = new TextArea( "", 15, maxStringLength, scrollBoth );
+        add( "North", instructionsText );
+
+        messageText = new TextArea( "", 5, maxStringLength, scrollBoth );
+        add("Center", messageText);
+
+        pack();
+
+        setVisible(true);
+    }
+
+    //DO NOT call this directly, go through Sysout
+    public void printInstructions( String[] instructions )
+    {
+        //Clear out any current instructions
+        instructionsText.setText( "" );
+
+        //Go down array of instruction strings
+
+        String printStr, remainingStr;
+        for( int i=0; i < instructions.length; i++ )
+        {
+            //chop up each into pieces maxSringLength long
+            remainingStr = instructions[ i ];
+            while( remainingStr.length() > 0 )
+            {
+                //if longer than max then chop off first max chars to print
+                if( remainingStr.length() >= maxStringLength )
+                {
+                    //Try to chop on a word boundary
+                    int posOfSpace = remainingStr.
+                        lastIndexOf( ' ', maxStringLength - 1 );
+
+                    if( posOfSpace <= 0 ) posOfSpace = maxStringLength - 1;
+
+                    printStr = remainingStr.substring( 0, posOfSpace + 1 );
+                    remainingStr = remainingStr.substring( posOfSpace + 1 );
+                }
+                //else just print
+                else
+                {
+                    printStr = remainingStr;
+                    remainingStr = "";
+                }
+
+                instructionsText.append( printStr + "\n" );
+            }
+        }
+    }
+
+    //DO NOT call this directly, go through Sysout
+    public void displayMessage( String messageIn )
+    {
+        messageText.append( messageIn + "\n" );
+        System.out.println(messageIn);
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/awt/dnd/DropTargetEnterExitTest/ExtraDragEnterTest.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,133 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/**
+ * @test
+ * @bug 8024163
+ * @summary Checks the dragEnter event is correctly generated
+ * @library ../../regtesthelpers
+ * @build Util
+ * @compile ExtraDragEnterTest.java
+ * @run main/othervm ExtraDragEnterTest
+ * @author Petr Pchelko
+ */
+
+import test.java.awt.regtesthelpers.Util;
+
+import javax.swing.*;
+import java.awt.*;
+import java.awt.datatransfer.StringSelection;
+import java.awt.dnd.DnDConstants;
+import java.awt.dnd.DragGestureEvent;
+import java.awt.dnd.DragGestureListener;
+import java.awt.dnd.DragSource;
+import java.awt.dnd.DropTarget;
+import java.awt.dnd.DropTargetAdapter;
+import java.awt.dnd.DropTargetDragEvent;
+import java.awt.dnd.DropTargetDropEvent;
+import java.awt.event.InputEvent;
+import java.util.concurrent.atomic.AtomicInteger;
+
+public class ExtraDragEnterTest {
+
+    private static final int FRAME_SIZE = 100;
+    private static final int FRAME_LOCATION = 100;
+
+    private static AtomicInteger dragEnterCalled = new AtomicInteger(0);
+
+    private static volatile Panel mainPanel;
+    private static volatile Frame f;
+
+    private static void initAndShowUI() {
+        f = new Frame("Test frame");
+        f.setBounds(FRAME_LOCATION,FRAME_LOCATION,FRAME_SIZE,FRAME_SIZE);
+        mainPanel = new Panel();
+        mainPanel.setBounds(0, 0, FRAME_SIZE, FRAME_SIZE);
+        mainPanel.setBackground(Color.black);
+        mainPanel.setLayout(new GridLayout(2, 1));
+
+        final DraggablePanel dragSource = new DraggablePanel();
+        dragSource.setBackground(Color.yellow);
+        dragSource.setDropTarget(null);
+        mainPanel.add(dragSource);
+
+        Panel dropTarget = new Panel();
+        dropTarget.setBackground(Color.red);
+        DropTarget dt = new DropTarget(dropTarget, new DropTargetAdapter() {
+            @Override public void drop(DropTargetDropEvent dtde) { }
+
+            @Override
+            public void dragEnter(DropTargetDragEvent dtde) {
+                dragEnterCalled.incrementAndGet();
+            }
+        });
+        dropTarget.setDropTarget(dt);
+        mainPanel.add(dropTarget);
+
+        f.add(mainPanel);
+        f.setVisible(true);
+    }
+
+    public static void main(String[] args) throws Throwable {
+        try {
+
+            SwingUtilities.invokeAndWait(new Runnable() {
+                @Override
+                public void run() {
+                    initAndShowUI();
+                }
+            });
+
+            Robot r = new Robot();
+            Util.waitForIdle(r);
+            Point leftCorner = new Point(mainPanel.getLocationOnScreen());
+            leftCorner.translate(5, 5);
+            Point rightCorner = new Point(mainPanel.getLocationOnScreen());
+            rightCorner.translate(mainPanel.getWidth(), mainPanel.getHeight());
+            rightCorner.translate(-5, -5);
+            Util.drag(r, leftCorner, rightCorner, InputEvent.BUTTON1_MASK);
+            Util.waitForIdle(r);
+
+            int called = dragEnterCalled.get();
+            if (called != 1) {
+                throw new RuntimeException("Failed. Drag enter called " + called + " times. Expected 1" );
+            }
+        } finally {
+            if (f != null) {
+                f.dispose();
+            }
+        }
+    }
+
+    private static class DraggablePanel extends Panel implements DragGestureListener {
+
+        public DraggablePanel() {
+            (new DragSource()).createDefaultDragGestureRecognizer(this, DnDConstants.ACTION_COPY, this);
+        }
+
+        @Override
+        public void dragGestureRecognized(DragGestureEvent dge) {
+            dge.startDrag(Cursor.getDefaultCursor(), new StringSelection("test"));
+        }
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/awt/dnd/DropTargetEnterExitTest/MissedDragExitTest.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,128 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/**
+ * @test
+ * @bug 8024163
+ * @summary Checks that dragExit is generated when the new DropTarget is created under the drag
+ * @library ../../regtesthelpers
+ * @build Util
+ * @compile MissedDragExitTest.java
+ * @run main/othervm MissedDragExitTest
+ * @author Petr Pchelko
+ */
+
+import test.java.awt.regtesthelpers.Util;
+
+import javax.swing.*;
+import java.awt.*;
+import java.awt.datatransfer.StringSelection;
+import java.awt.dnd.DnDConstants;
+import java.awt.dnd.DragGestureEvent;
+import java.awt.dnd.DragGestureListener;
+import java.awt.dnd.DragSource;
+import java.awt.dnd.DropTarget;
+import java.awt.dnd.DropTargetAdapter;
+import java.awt.dnd.DropTargetDragEvent;
+import java.awt.dnd.DropTargetDropEvent;
+import java.awt.dnd.DropTargetEvent;
+import java.awt.event.InputEvent;
+
+public class MissedDragExitTest {
+
+    private static final int FRAME_SIZE = 100;
+    private static final int FRAME_LOCATION = 100;
+
+    private static volatile boolean dragExitCalled = false;
+
+    private static volatile Frame f;
+
+    private static void initAndShowUI() {
+        f = new Frame("Test frame");
+        f.setBounds(FRAME_LOCATION,FRAME_LOCATION,FRAME_SIZE,FRAME_SIZE);
+
+        final DraggablePanel dragSource = new DraggablePanel();
+        dragSource.setBackground(Color.yellow);
+        DropTarget dt = new DropTarget(dragSource, new DropTargetAdapter() {
+            @Override public void drop(DropTargetDropEvent dtde) { }
+
+            @Override
+            public void dragExit(DropTargetEvent dte) {
+                dragExitCalled = true;
+            }
+
+            @Override
+            public void dragOver(DropTargetDragEvent dtde) {
+                Panel newDropTarget = new Panel();
+                newDropTarget.setDropTarget(new DropTarget());
+                newDropTarget.setBackground(Color.red);
+                newDropTarget.setBounds(0, 0, FRAME_SIZE, FRAME_SIZE);
+                dragSource.add(newDropTarget);
+            }
+        });
+        dragSource.setDropTarget(dt);
+        f.add(dragSource);
+
+        f.setVisible(true);
+    }
+
+    public static void main(String[] args) throws Throwable {
+        try {
+
+            SwingUtilities.invokeAndWait(new Runnable() {
+                @Override
+                public void run() {
+                    initAndShowUI();
+                }
+            });
+
+            Robot r = new Robot();
+            Util.waitForIdle(r);
+            Util.drag(r,
+                    new Point(FRAME_LOCATION + FRAME_SIZE / 3, FRAME_LOCATION + FRAME_SIZE / 3),
+                    new Point(FRAME_LOCATION + FRAME_SIZE / 3 * 2, FRAME_LOCATION + FRAME_SIZE / 3 * 2),
+                    InputEvent.BUTTON1_MASK);
+            Util.waitForIdle(r);
+
+            if (!dragExitCalled) {
+                throw new RuntimeException("Failed. Drag exit was not called" );
+            }
+        } finally {
+            if (f != null) {
+                f.dispose();
+            }
+        }
+    }
+
+    private static class DraggablePanel extends Panel implements DragGestureListener {
+
+        public DraggablePanel() {
+            (new DragSource()).createDefaultDragGestureRecognizer(this, DnDConstants.ACTION_COPY, this);
+        }
+
+        @Override
+        public void dragGestureRecognized(DragGestureEvent dge) {
+            dge.startDrag(Cursor.getDefaultCursor(), new StringSelection("test"));
+        }
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/awt/print/bug8023392/bug8023392.html	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,20 @@
+<html>
+<!--
+  @test
+  @bug 8023392
+  @summary Swing text components printed with spaces between chars
+  @author Anton Nashatyrev
+  @run applet/manual=yesno bug8023392.html
+  -->
+<head>
+    <title> Bug 8023392 </title>
+</head>
+<body>
+
+<h1>Bug ID: 8023392</h1>
+
+<p> See the dialog box (usually in upper left corner) for instructions</p>
+
+<APPLET CODE="bug8023392.class" WIDTH=400 HEIGHT=400></APPLET>
+</body>
+</html>
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/awt/print/bug8023392/bug8023392.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,286 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+  test
+  @bug 8023392
+  @summary Swing text components printed with spaces between chars
+  @author Anton Nashatyrev
+  @run applet/manual=yesno bug8023392.html
+*/
+
+import javax.swing.*;
+import javax.swing.border.LineBorder;
+import java.applet.Applet;
+import java.awt.*;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+import java.awt.font.TextAttribute;
+import java.awt.print.PageFormat;
+import java.awt.print.Printable;
+import java.awt.print.PrinterException;
+import java.awt.print.PrinterJob;
+import java.text.AttributedCharacterIterator;
+import java.text.AttributedString;
+
+
+public class bug8023392 extends Applet {
+    static final String[] instructions = {
+        "A Frame containing several pairs of labels ((a) and (b)) is displayed.",
+        "Labels of each pair look the same and are left-aligned (with spaces ",
+        "between chars).",
+        "1. Hit the print button.",
+        "2. Select any available printer (printing to file is also fine).",
+        "3. Look at the printing result (paper, PDF, PS, etc.):",
+        "   The (a) and (b) labels should look almost the same and the (a) labels",
+        "   shouldn't appear as if they are stretched along X axis."};
+
+    public void init() {
+        this.setLayout(new BorderLayout());
+        add(new SimplePrint2(), BorderLayout.CENTER);
+
+        Sysout.createDialogWithInstructions(instructions);
+
+    }
+
+    public static class SimplePrint2 extends JPanel
+            implements ActionListener, Printable {
+        JLabel label1;
+        JLabel label2;
+        JButton printButton;
+
+
+        public SimplePrint2() {
+            setLayout(new BorderLayout());
+            label1 = new JLabel("2a) a b c d e" +
+                    "                         ");
+            label2 = new JLabel("2b) a b c d e");
+
+            Box p1 = new Box(BoxLayout.Y_AXIS);
+            p1.add(label1);
+            p1.add(label2);
+            p1.add(new JLabel("wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww") {
+                String s = "3a) a b c d e                                     ";
+                @Override
+                protected void paintComponent(Graphics g) {
+                    sun.swing.SwingUtilities2.drawChars(this, g, s.toCharArray(),
+                            0, s.length(), 0, 15);
+                }
+            });
+            p1.add(new JLabel("wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww") {
+                String s = "3b) a b c d e";
+                @Override
+                protected void paintComponent(Graphics g) {
+                    sun.swing.SwingUtilities2.drawChars(this, g, s.toCharArray(),
+                            0, s.length(), 0, 15);
+                }
+            });
+            p1.add(new JLabel("wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww") {
+                String s = "4a) a b c d e                                     ";
+                AttributedCharacterIterator it;
+                {
+                    AttributedString as = new AttributedString(s);
+                    as.addAttribute(TextAttribute.FONT, getFont());
+                    as.addAttribute(TextAttribute.FOREGROUND, Color.RED, 3, 8);
+                    it = as.getIterator();
+                }
+                @Override
+                protected void paintComponent(Graphics g) {
+                    sun.swing.SwingUtilities2.drawString(this, g, it, 0, 15);
+                }
+            });
+
+            p1.add(new JLabel("wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww") {
+                String s = "4b) a b c d e";
+                AttributedCharacterIterator it;
+                {
+                    AttributedString as = new AttributedString(s);
+                    as.addAttribute(TextAttribute.FONT, getFont());
+                    as.addAttribute(TextAttribute.FOREGROUND, Color.RED, 3, 8);
+                    it = as.getIterator();
+                }
+                @Override
+                protected void paintComponent(Graphics g) {
+                    sun.swing.SwingUtilities2.drawString(this, g, it, 0, 15);
+                }
+            });
+
+            JPanel p2 = new JPanel();
+            printButton = new JButton("Print");
+            printButton.addActionListener(this);
+            p2.add(printButton);
+
+            Container c = this;
+            c.add(p1, BorderLayout.CENTER);
+            c.add(p2, BorderLayout.SOUTH);
+
+            String[] data = {
+                    "1a) \u30aa\u30f3\u30e9\u30a4\u30f3\u6d88\u8fbc" +
+                    "                                              ",
+                    "1b) \u30aa\u30f3\u30e9\u30a4\u30f3\u6d88\u8fbc"
+            };
+            JList l0 = new JList(data);
+            l0.setVisibleRowCount(l0.getModel().getSize());
+            JScrollPane jsp = new JScrollPane(l0);
+            l0.setBorder(new LineBorder(Color.GRAY));
+            c.add(jsp, BorderLayout.NORTH);
+
+            for (Component comp : new Component[]{label1, label2, printButton}) {
+                comp.setFont(new Font("Monospaced", 0, 16));
+            }
+        }
+
+        public void actionPerformed(ActionEvent e) {
+            PrinterJob job = PrinterJob.getPrinterJob();
+            job.setPrintable(this);
+            if (job.printDialog()) {
+                try {
+                    job.print();
+                } catch (PrinterException ex) {
+                    ex.printStackTrace();
+                }
+            }
+        }
+
+        public int print(Graphics graphics,
+                         PageFormat pageFormat,
+                         int pageIndex)
+                throws PrinterException {
+            if (pageIndex >= 1) {
+                return Printable.NO_SUCH_PAGE;
+            }
+
+            this.paint(graphics);
+            return Printable.PAGE_EXISTS;
+        }
+    }
+}
+
+
+/**
+ * *************************************************
+ * Standard Test Machinery
+ * DO NOT modify anything below -- it's a standard
+ * chunk of code whose purpose is to make user
+ * interaction uniform, and thereby make it simpler
+ * to read and understand someone else's test.
+ * **************************************************
+ */
+class Sysout {
+    private static TestDialog dialog;
+
+    public static void createDialogWithInstructions(String[] instructions) {
+        dialog = new TestDialog(new Frame(), "Instructions");
+        dialog.printInstructions(instructions);
+        dialog.show();
+        println("Any messages for the tester will display here.");
+    }
+
+    public static void createDialog() {
+        dialog = new TestDialog(new Frame(), "Instructions");
+        String[] defInstr = {"Instructions will appear here. ", ""};
+        dialog.printInstructions(defInstr);
+        dialog.show();
+        println("Any messages for the tester will display here.");
+    }
+
+
+    public static void printInstructions(String[] instructions) {
+        dialog.printInstructions(instructions);
+    }
+
+
+    public static void println(String messageIn) {
+        dialog.displayMessage(messageIn);
+    }
+
+}// Sysout  class
+
+
+class TestDialog extends Dialog {
+
+    TextArea instructionsText;
+    TextArea messageText;
+    int maxStringLength = 80;
+
+    //DO NOT call this directly, go through Sysout
+    public TestDialog(Frame frame, String name) {
+        super(frame, name);
+        int scrollBoth = TextArea.SCROLLBARS_BOTH;
+        instructionsText = new TextArea("", 15, maxStringLength, scrollBoth);
+        add("North", instructionsText);
+
+        messageText = new TextArea("", 5, maxStringLength, scrollBoth);
+        add("South", messageText);
+
+        pack();
+
+        show();
+    }// TestDialog()
+
+    //DO NOT call this directly, go through Sysout
+    public void printInstructions(String[] instructions) {
+        //Clear out any current instructions
+        instructionsText.setText("");
+
+        //Go down array of instruction strings
+
+        String printStr, remainingStr;
+        for (int i = 0; i < instructions.length; i++) {
+            //chop up each into pieces maxSringLength long
+            remainingStr = instructions[i];
+            while (remainingStr.length() > 0) {
+                //if longer than max then chop off first max chars to print
+                if (remainingStr.length() >= maxStringLength) {
+                    //Try to chop on a word boundary
+                    int posOfSpace = remainingStr.
+                            lastIndexOf(' ', maxStringLength - 1);
+
+                    if (posOfSpace <= 0) posOfSpace = maxStringLength - 1;
+
+                    printStr = remainingStr.substring(0, posOfSpace + 1);
+                    remainingStr = remainingStr.substring(posOfSpace + 1);
+                }
+                //else just print
+                else {
+                    printStr = remainingStr;
+                    remainingStr = "";
+                }
+
+                instructionsText.append(printStr + "\n");
+
+            }// while
+
+        }// for
+
+    }//printInstructions()
+
+    //DO NOT call this directly, go through Sysout
+    public void displayMessage(String messageIn) {
+        messageText.append(messageIn + "\n");
+    }
+
+}// TestDialog  class
+
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/beans/XMLDecoder/8028054/Task.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,99 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import java.util.ArrayList;
+import java.util.Enumeration;
+import java.util.List;
+import java.util.jar.JarEntry;
+import java.util.jar.JarFile;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+abstract class Task<T> implements Runnable {
+    private transient boolean working = true;
+    private final List<T> methods;
+    private final Thread thread;
+
+    Task(List<T> methods) {
+        this.methods = methods;
+        this.thread = new Thread(this);
+        this.thread.start();
+    }
+
+    boolean isAlive() {
+        return this.thread.isAlive();
+    }
+
+    boolean isWorking() {
+        boolean working = this.working && this.thread.isAlive();
+        this.working = false;
+        return working;
+    }
+
+    @Override
+    public void run() {
+        long time = -System.currentTimeMillis();
+        for (T method : this.methods) {
+            this.working = true;
+            try {
+                for (int i = 0; i < 100; i++) {
+                    process(method);
+                }
+            } catch (NoSuchMethodException ignore) {
+            }
+        }
+        time += System.currentTimeMillis();
+        print("thread done in " + time / 1000 + " seconds");
+    }
+
+    protected abstract void process(T method) throws NoSuchMethodException;
+
+    static synchronized void print(Object message) {
+        System.out.println(message);
+        System.out.flush();
+    }
+
+    static List<Class<?>> getClasses(int count) throws Exception {
+        String resource = ClassLoader.getSystemClassLoader().getResource("java/lang/Object.class").toString();
+
+        Pattern pattern = Pattern.compile("jar:file:(.*)!.*");
+        Matcher matcher = pattern.matcher(resource);
+        matcher.matches();
+        resource = matcher.group(1);
+
+        List<Class<?>> classes = new ArrayList<>();
+        try (JarFile jarFile = new JarFile(resource)) {
+            Enumeration<JarEntry> entries = jarFile.entries();
+            while (entries.hasMoreElements()) {
+                String name = entries.nextElement().getName();
+                if (name.startsWith("java") && name.endsWith(".class")) {
+                    classes.add(Class.forName(name.substring(0, name.indexOf(".")).replace('/', '.')));
+                    if (count == classes.size()) {
+                        break;
+                    }
+                }
+            }
+        }
+        return classes;
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/beans/XMLDecoder/8028054/TestConstructorFinder.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,81 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import com.sun.beans.finder.ConstructorFinder;
+
+import java.lang.reflect.Constructor;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+/*
+ * @test
+ * @bug 8028054
+ * @summary Tests that cached constructors have synchronized access
+ * @author Sergey Malenkov
+ * @compile -XDignore.symbol.file TestConstructorFinder.java
+ * @run main TestConstructorFinder
+ */
+
+public class TestConstructorFinder {
+    public static void main(String[] args) throws Exception {
+        List<Class<?>> classes = Task.getClasses(Integer.MAX_VALUE);
+        List<Constructor> constructors = new ArrayList<>();
+        for (Class<?> type : classes) {
+            Collections.addAll(constructors, type.getConstructors());
+        }
+        Task.print("found " + constructors.size() + " constructors in " + classes.size() + " classes");
+
+        List<Task> tasks = new ArrayList<>();
+        for (int i = 0; i < 50; i++) {
+            tasks.add(new Task<Constructor>(constructors) {
+                @Override
+                protected void process(Constructor constructor) throws NoSuchMethodException {
+                    ConstructorFinder.findConstructor(constructor.getDeclaringClass(), constructor.getParameterTypes());
+                }
+            });
+        }
+        int alarm = 0;
+        while (true) {
+            int alive = 0;
+            int working = 0;
+            for (Task task : tasks) {
+                if (task.isWorking()) {
+                    working++;
+                    alive++;
+                } else if (task.isAlive()) {
+                    alive++;
+                }
+            }
+            if (alive == 0) {
+                break;
+            }
+            Task.print(working + " out of " + alive + " threads are working");
+            if ((working == 0) && (++alarm == 10)) {
+                Task.print("DEADLOCK DETECTED");
+                System.exit(100);
+            }
+            Thread.sleep(1000);
+        }
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/beans/XMLDecoder/8028054/TestMethodFinder.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,81 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import com.sun.beans.finder.MethodFinder;
+
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+/*
+ * @test
+ * @bug 8028054
+ * @summary Tests that cached methods have synchronized access
+ * @author Sergey Malenkov
+ * @compile -XDignore.symbol.file TestMethodFinder.java
+ * @run main TestMethodFinder
+ */
+
+public class TestMethodFinder {
+    public static void main(String[] args) throws Exception {
+        List<Class<?>> classes = Task.getClasses(4000);
+        List<Method> methods = new ArrayList<>();
+        for (Class<?> type : classes) {
+            Collections.addAll(methods, type.getMethods());
+        }
+        Task.print("found " + methods.size() + " methods in " + classes.size() + " classes");
+
+        List<Task> tasks = new ArrayList<>();
+        for (int i = 0; i < 50; i++) {
+            tasks.add(new Task<Method>(methods) {
+                @Override
+                protected void process(Method method) throws NoSuchMethodException {
+                    MethodFinder.findMethod(method.getDeclaringClass(), method.getName(), method.getParameterTypes());
+                }
+            });
+        }
+        int alarm = 0;
+        while (true) {
+            int alive = 0;
+            int working = 0;
+            for (Task task : tasks) {
+                if (task.isWorking()) {
+                    working++;
+                    alive++;
+                } else if (task.isAlive()) {
+                    alive++;
+                }
+            }
+            if (alive == 0) {
+                break;
+            }
+            Task.print(working + " out of " + alive + " threads are working");
+            if ((working == 0) && (++alarm == 10)) {
+                Task.print("DEADLOCK DETECTED");
+                System.exit(100);
+            }
+            Thread.sleep(1000);
+        }
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/beans/XMLEncoder/Test8027066.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 8027066
+ * @summary Tests that the same array can be encoded twice
+ * @author Anton Nashatyrev
+ */
+public class Test8027066 extends AbstractTest<String[][]> {
+    public static void main(String[] args) {
+        new Test8027066().test(true);
+    }
+
+    @Override
+    protected String[][] getObject() {
+        String[] strings = {"first", "second"};
+        String[][] arrays = {strings, strings};
+        return arrays;
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/lang/Class/checkMemberAccess/CheckMemberAccess.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,123 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import java.io.IOException;
+import java.lang.reflect.Method;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+
+/*
+ * @test
+ * @bug 8021368
+ * @summary SecurityManager.checkMemberAccess call should not resolve
+ *          and load other classes
+ * @run main/othervm/policy=test.policy CheckMemberAccess
+ */
+
+public class CheckMemberAccess {
+    private static int count = 0;
+    public static void main(String[] args) throws Exception {
+        String testClasses = System.getProperty("test.classes", ".");
+        // remove Foo class
+        // the test will verify SecurityManager.checkMemberAccess should not
+        // cause any class loading of implementation classes
+        Path p = Paths.get(testClasses, "CheckMemberAccess$Foo.class");
+        if (Files.exists(p)) {
+            // Foo already deleted in rerun
+            Files.delete(p);
+        }
+        // patch the checkMemberAcces_ method name
+        patch(Paths.get(testClasses, "CheckMemberAccess$PrivateCheckMemberAccess.class"));
+        patch(Paths.get(testClasses, "CheckMemberAccess$StaticCheckMemberAccess.class"));
+
+        test(new OverriddedCheckMemberAccess(), count+1);
+        test(new NoOverriddedCheckMemberAccess(), count+1);
+        test(new PrivateCheckMemberAccess(), count);
+        test(new StaticCheckMemberAccess(), count);
+    }
+
+    private static void patch(Path p) throws IOException {
+        // s/checkMemberAcces_/checkMemberAccess
+        byte[] bytes = Files.readAllBytes(p);
+        int len = "Acces_".length();
+        for (int i=0; i < bytes.length-len; i++) {
+            if (bytes[i] == 'A' &&
+                bytes[i+1] == 'c' &&
+                bytes[i+2] == 'c' &&
+                bytes[i+3] == 'e' &&
+                bytes[i+4] == 's' &&
+                bytes[i+5] == '_') {
+                bytes[i+5] = 's';
+                break;
+            }
+        }
+        Files.write(p, bytes);
+    }
+
+    public void findMe() {};
+    public static void test(SecurityManager smgr, int expected) throws Exception {
+        System.setSecurityManager(smgr);
+        // this will trigger SecurityManager.checkMemberAccess to be called
+        Method m = CheckMemberAccess.class.getMethod("findMe", new Class<?>[0]);
+        if (count != expected) {
+            throw new RuntimeException(smgr.getClass() + ": " + count + " != " + expected);
+        }
+    }
+
+    static class OverriddedCheckMemberAccess extends SecurityManager {
+        @Override
+        public void checkMemberAccess(Class<?> clazz, int which) {
+            System.out.println("OverriddedCheckMemberAccess.checkMemberAccess called");
+            count++;
+        }
+        // implementation-specific class should not be loaded when
+        // this.checkMemberAccess is called
+        public Foo foo() {
+            return null;
+        }
+    }
+    static class NoOverriddedCheckMemberAccess extends OverriddedCheckMemberAccess {
+    }
+    static class PrivateCheckMemberAccess extends SecurityManager {
+        private void checkMemberAcces_(Class<?> clazz, int which) {
+            throw new RuntimeException("should not reach here");
+        }
+        // implementation-specific class should not be loaded when
+        // this.checkMemberAccess is called
+        public Foo foo() {
+            return null;
+        }
+    }
+    static class StaticCheckMemberAccess extends SecurityManager {
+        public static void checkMemberAcces_(Class<?> clazz, int which) {
+            throw new RuntimeException("should not reach here");
+        }
+        // implementation-specific class should not be loaded when
+        // this.checkMemberAccess is called
+        public Foo foo() {
+            return null;
+        }
+    }
+    static class Foo {}
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/lang/Class/checkMemberAccess/test.policy	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,6 @@
+grant {
+    permission java.lang.RuntimePermission "createSecurityManager";
+    permission java.lang.RuntimePermission "setSecurityManager";
+    permission java.io.FilePermission "<<ALL FILES>>", "read,write,delete";
+    permission java.util.PropertyPermission "*", "read";
+};
--- ./jdk/test/java/lang/ProcessBuilder/Basic.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/test/java/lang/ProcessBuilder/Basic.java	Wed May 07 19:26:47 2014 -0700
@@ -296,11 +296,15 @@
                     System.exit(5);
                 System.err.print("standard error");
                 System.out.print("standard output");
-            } else if (action.equals("testInheritIO")) {
+            } else if (action.equals("testInheritIO")
+                    || action.equals("testRedirectInherit")) {
                 List<String> childArgs = new ArrayList<String>(javaChildArgs);
                 childArgs.add("testIO");
                 ProcessBuilder pb = new ProcessBuilder(childArgs);
-                pb.inheritIO();
+                if (action.equals("testInheritIO"))
+                    pb.inheritIO();
+                else
+                    redirectIO(pb, INHERIT, INHERIT, INHERIT);
                 ProcessResults r = run(pb);
                 if (! r.out().equals(""))
                     System.exit(7);
@@ -555,9 +559,10 @@
         System.getProperty("java.class.path");
 
     private static final List<String> javaChildArgs =
-        Arrays.asList(new String[]
-            { javaExe, "-classpath", absolutifyPath(classpath),
-              "Basic$JavaChild"});
+        Arrays.asList(javaExe,
+                      "-XX:+DisplayVMOutputToStderr",
+                      "-classpath", absolutifyPath(classpath),
+                      "Basic$JavaChild");
 
     private static void testEncoding(String encoding, String tested) {
         try {
@@ -989,10 +994,10 @@
         // Note that this requires __FOUR__ nested JVMs involved in one test,
         // if you count the harness JVM.
         //----------------------------------------------------------------
-        {
+        for (String testName : new String[] { "testInheritIO", "testRedirectInherit" } ) {
             redirectIO(pb, PIPE, PIPE, PIPE);
             List<String> command = pb.command();
-            command.set(command.size() - 1, "testInheritIO");
+            command.set(command.size() - 1, testName);
             Process p = pb.start();
             new PrintStream(p.getOutputStream()).print("standard input");
             p.getOutputStream().close();
@@ -1593,8 +1598,8 @@
                                       javaExe));
             list.add("ArrayOOME");
             ProcessResults r = run(new ProcessBuilder(list));
-            check(r.out().contains("java.lang.OutOfMemoryError:"));
-            check(r.out().contains(javaExe));
+            check(r.err().contains("java.lang.OutOfMemoryError:"));
+            check(r.err().contains(javaExe));
             check(r.err().contains(System.getProperty("java.version")));
             equal(r.exitValue(), 1);
         } catch (Throwable t) { unexpected(t); }
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/lang/ProcessBuilder/InheritIO/InheritIO.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,47 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import static java.lang.ProcessBuilder.Redirect.*;
+
+class InheritIO {
+
+    public static class TestInheritIO {
+        public static void main(String args[]) throws Throwable {
+            int err = new ProcessBuilder(args).inheritIO().start().waitFor();
+            System.err.print("exit value: " + err);
+            System.exit(err);
+        }
+    }
+
+    public static class TestRedirectInherit {
+        public static void main(String args[]) throws Throwable {
+            int err = new ProcessBuilder(args)
+                    .redirectInput(INHERIT)
+                    .redirectOutput(INHERIT)
+                    .redirectError(INHERIT)
+                    .start().waitFor();
+            System.err.print("exit value: " + err);
+            System.exit(err);
+        }
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/lang/ProcessBuilder/InheritIO/InheritIO.sh	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,81 @@
+#
+# Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+
+# @test
+# @bug 8023130
+# @summary (process) ProcessBuilder#inheritIO does not work on Windows
+# @run shell InheritIO.sh
+
+if [ "x${TESTSRC}" = "x" ]; then
+  echo "TESTSRC not set.  Test cannot execute.  Failed."
+  exit 1
+fi
+
+if [ "x${TESTJAVA}" = "x" ]; then
+  echo "TESTJAVA not set.  Test cannot execute.  Failed."
+  exit 1
+fi
+
+
+JAVA="${TESTJAVA}/bin/java"
+JAVAC="${TESTJAVA}/bin/javac"
+
+cp -f ${TESTSRC}/InheritIO.java .
+
+# compile the class ourselves, so this can run as a standalone test
+
+${JAVAC} InheritIO.java
+RES="$?"
+if [ ${RES} != 0 ]; then
+    echo 'FAIL: Cannot compile InheritIO.java'
+    exit ${RES}
+fi
+
+
+for TEST_NAME in TestInheritIO TestRedirectInherit
+do
+    ${JAVA} ${TESTVMOPTS} -classpath . \
+        'InheritIO$'${TEST_NAME} printf message > stdout.txt 2> stderr.txt
+
+    RES="$?"
+    if [ ${RES} != 0 ]; then
+        echo 'FAIL: InheritIO$'${TEST_NAME}' failed with '${RES}
+        exit ${RES}
+    fi
+
+    OUT_EXPECTED='message'
+    OUT_RECEIVED=`cat stdout.txt`
+    if [ "x${OUT_RECEIVED}" != "x${OUT_EXPECTED}" ]; then
+        echo "FAIL: unexpected '${OUT_RECEIVED}' in stdout"
+        exit 1
+    fi
+
+    ERR_EXPECTED='exit value: 0'
+    ERR_RECEIVED=`cat stderr.txt`
+    if [ "x${ERR_RECEIVED}" != "x${ERR_EXPECTED}" ]; then
+        echo "FAIL: unexpected '${ERR_RECEIVED}' in stderr"
+        exit 1
+    fi
+done
+
+echo 'PASS: InheritIO works as expected'
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/lang/ProcessBuilder/InheritIOEHandle.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,147 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/**
+ * @test
+ * @bug 7147084
+ * @run main/othervm InheritIOEHandle
+ * @summary inherit IOE handles and MS CreateProcess limitations (kb315939)
+ */
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStreamReader;
+
+public class InheritIOEHandle {
+    private static enum APP {
+        B, C;
+    }
+    private static File stopC = new File(".\\StopC.txt");
+    private static String SIGNAL = "After call child process";
+    private static String JAVA_EXE = System.getProperty("java.home")
+        + File.separator + "bin"
+        + File.separator + "java";
+
+    private static String[] getCommandArray(String processName) {
+        String[] cmdArray = {
+            JAVA_EXE,
+            "-cp",
+            System.getProperty("java.class.path"),
+            InheritIOEHandle.class.getName(),
+            processName
+        };
+        return cmdArray;
+    }
+
+    public static void main(String[] args) throws Exception {
+        if (!System.getProperty("os.name").startsWith("Windows")) {
+            return;
+        }
+
+        if (args.length > 0) {
+            APP app = APP.valueOf(args[0]);
+            switch (app) {
+            case B:
+                performB();
+                break;
+            case C:
+                performC();
+                break;
+            }
+            return;
+        }
+        performA();
+    }
+
+    private static void performA() {
+        try {
+            stopC.delete();
+
+            ProcessBuilder builder = new ProcessBuilder(
+                    getCommandArray(APP.B.name()));
+            builder.redirectErrorStream(true);
+
+            Process process = builder.start();
+
+            process.getOutputStream().close();
+            process.getErrorStream().close();
+
+            try (BufferedReader in = new BufferedReader( new InputStreamReader(
+                         process.getInputStream(), "utf-8")))
+            {
+                String result;
+                while ((result = in.readLine()) != null) {
+                    if (!SIGNAL.equals(result)) {
+                        throw new Error("Catastrophe in process B! Bad output.");
+                    }
+                }
+            }
+
+            // If JDK-7147084 is not fixed that point is unreachable.
+
+            // write signal file
+            stopC.createNewFile();
+
+            System.err.println("Read stream finished.");
+        } catch (IOException ex) {
+            throw new Error("Catastrophe in process A!", ex);
+        }
+    }
+
+    private static void performB() {
+        try {
+            ProcessBuilder builder = new ProcessBuilder(
+                    getCommandArray(APP.C.name()));
+
+            Process process = builder.start();
+
+            process.getInputStream().close();
+            process.getOutputStream().close();
+            process.getErrorStream().close();
+
+            System.out.println(SIGNAL);
+
+            // JDK-7147084 subject:
+            // Process C inherits the [System.out] handle and
+            // handle close in B does not finalize the streaming for A.
+            // (handle reference count > 1).
+        } catch (IOException ex) {
+            throw new Error("Catastrophe in process B!", ex);
+        }
+    }
+
+    private static void performC() {
+        // If JDK-7147084 is not fixed the loop is 5min long.
+        for (int i = 0; i < 5*60; ++i) {
+            try {
+                Thread.sleep(1000);
+                // check for sucess
+                if (stopC.exists())
+                    break;
+            } catch (InterruptedException ex) {
+                // that is ok. Longer sleep - better effect.
+            }
+        }
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/lang/ProcessBuilder/SiblingIOEHandle.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,205 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/**
+ * @test
+ * @bug 6921885
+ * @run main/othervm SiblingIOEHandle
+ * @summary inherit IOE handles and MS CreateProcess limitations (kb315939)
+ */
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.util.concurrent.BrokenBarrierException;
+import java.util.concurrent.CyclicBarrier;
+
+public class SiblingIOEHandle {
+    private static enum APP {
+        B, C;
+    }
+    private static File stopC = new File(".\\StopCs.txt");
+    private static String SIGNAL = "B child reported.";
+    private static String JAVA_EXE = System.getProperty("java.home")
+        + File.separator + "bin"
+        + File.separator + "java";
+
+    private static String[] getCommandArray(String processName) {
+        String[] cmdArray = {
+            JAVA_EXE,
+            "-cp",
+            System.getProperty("java.class.path"),
+            SiblingIOEHandle.class.getName(),
+            processName
+        };
+        return cmdArray;
+    }
+
+    public static void main(String[] args) {
+        if (!System.getProperty("os.name").startsWith("Windows")) {
+            return;
+        }
+
+        if (args.length > 0) {
+            APP app = APP.valueOf(args[0]);
+            switch (app) {
+            case B:
+                performB();
+                break;
+            case C:
+                performC();
+                break;
+            }
+            return;
+        }
+        performA(true);
+        performA(false);
+    }
+
+    static boolean procClaunched = false;
+
+    private static void waitAbit() {
+        try {
+            Thread.sleep(0);
+        } catch (InterruptedException ex) {
+            // that was long enough
+        }
+    }
+    private static boolean waitBarrier(CyclicBarrier barrier) {
+        while (true) try {
+            barrier.await();
+            return true;
+        } catch (InterruptedException ex) {
+            continue;
+        } catch (BrokenBarrierException ex) {
+            ex.printStackTrace();
+            return false;
+        }
+    }
+
+    private static void performA(boolean fileOut) {
+        try {
+            stopC.delete();
+            ProcessBuilder builderB = new ProcessBuilder(
+                    getCommandArray(APP.B.name()));
+
+            File outB = null;
+            if (fileOut) {
+                outB = new File("outB.txt");
+                builderB.redirectOutput(outB);
+            }
+            builderB.redirectErrorStream(true);
+
+            final CyclicBarrier barrier = new CyclicBarrier(2);
+            Thread procCRunner = new Thread(new Runnable() {
+                @Override public void run() {
+                    try {
+                        if (waitBarrier(barrier)) {
+                            waitAbit();
+                            // Run process C next to B ASAP to make an attempt
+                            // to capture the B-process IOE handles in C process.
+                            Runtime.getRuntime().exec(getCommandArray(APP.C.name()));
+                            procClaunched = true;
+                        }
+                    } catch (IOException ex) {
+                        ex.printStackTrace();
+                    }
+                }
+            });
+            procCRunner.start();
+
+
+            if (!waitBarrier(barrier)) {
+                throw new Error("Catastrophe in process A! Synchronization failed.");
+            }
+            // Run process B first.
+            Process processB = builderB.start();
+
+            while (true) try {
+                procCRunner.join();
+                break;
+            } catch (InterruptedException ex) {
+                continue;
+            }
+
+            if (!procClaunched) {
+                throw new Error("Catastrophe in process A! C was not launched.");
+            }
+
+            processB.getOutputStream().close();
+            processB.getErrorStream().close();
+
+            if (fileOut) {
+                try {
+                    processB.waitFor();
+                } catch (InterruptedException ex) {
+                    throw new Error("Catastrophe in process B! B hung up.");
+                }
+                System.err.println("Trying to delete [outB.txt].");
+                if (!outB.delete()) {
+                    throw new Error("Greedy brother C deadlock! File share.");
+                }
+                System.err.println("Succeeded in delete [outB.txt].");
+            } else {
+                System.err.println("Read stream start.");
+                try (BufferedReader in = new BufferedReader( new InputStreamReader(
+                             processB.getInputStream(), "utf-8")))
+                {
+                    String result;
+                    while ((result = in.readLine()) != null) {
+                        if (!SIGNAL.equals(result)) {
+                            throw new Error("Catastrophe in process B! Bad output.");
+                        }
+                    }
+                }
+                System.err.println("Read stream finished.");
+            }
+            // If JDK-6921885 is not fixed that point is unreachable.
+            // Test timeout exception.
+
+            // write signal file to stop C process.
+            stopC.createNewFile();
+        } catch (IOException ex) {
+            throw new Error("Catastrophe in process A!", ex);
+        }
+    }
+
+    private static void performB() {
+        System.out.println(SIGNAL);
+    }
+
+    private static void performC() {
+        // If JDK-7147084 is not fixed the loop is 5min long.
+        for (int i = 0; i < 5*60; ++i) {
+            try {
+                Thread.sleep(1000);
+                // check for sucess
+                if (stopC.exists())
+                    break;
+            } catch (InterruptedException ex) {
+                // that is ok. Longer sleep - better effect.
+            }
+        }
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/lang/Runtime/exec/CloseRace.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,146 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/**
+ * @test
+ * @bug 8024521
+ * @summary Closing ProcessPipeInputStream at the time the process exits is racy
+ *          and leads to the data corruption.
+ * @library /lib/testlibrary
+ * @run main/othervm/timeout=80 CloseRace
+ */
+
+/**
+ * This test has a little chance to catch the race during the given default
+ * time gap of 20 seconds. To increase the time gap, set the system property
+ * CloseRaceTimeGap=N to the number of seconds.
+ * Jtreg's timeoutFactor should also be set appropriately.
+ *
+ * For example, to run the test for 10 minutes:
+ * > jtreg \
+ *       -testjdk:$(PATH_TO_TESTED_JDK) \
+ *       -timeoutFactor:10 \
+ *       -DCloseRaceTimeGap=600 \
+ *       $(PATH_TO_TESTED_JDK_SOURCE)/test/java/lang/Runtime/exec/CloseRace.java
+ */
+
+import java.io.*;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.LinkedList;
+import java.util.List;
+import jdk.testlibrary.OutputAnalyzer;
+import static jdk.testlibrary.ProcessTools.*;
+
+public class CloseRace {
+
+    public static void main(String args[]) throws Exception {
+        ProcessBuilder pb = createJavaProcessBuilder("-Xmx64M", "CloseRace$Child",
+                System.getProperty("CloseRaceTimeGap", "20"));
+        OutputAnalyzer oa = new OutputAnalyzer(pb.start());
+        oa.stderrShouldNotContain("java.lang.OutOfMemoryError");
+    }
+
+    public static class Child {
+        private static final String BIG_FILE = "bigfile";
+        private static final String SMALL_FILE = "smallfile";
+        private static int timeGap = 20; // seconds
+
+        public static void main(String args[]) throws Exception {
+            if (args.length > 0) {
+                try {
+                    timeGap = Integer.parseInt(args[0]);
+                    timeGap = Math.max(timeGap, 10);
+                    timeGap = Math.min(timeGap, 10 * 60 * 60); // no more than 10 hours
+                } catch (NumberFormatException ignore) {}
+            }
+            try (RandomAccessFile f = new RandomAccessFile(BIG_FILE, "rw")) {
+                f.setLength(1024 * 1024 * 1024); // 1 Gb, greater than max heap size
+            }
+            try (FileOutputStream fs = new FileOutputStream(SMALL_FILE);
+                 PrintStream ps = new PrintStream(fs)) {
+                for (int i = 0; i < 128; ++i)
+                    ps.println("line of text");
+            }
+
+            List<Thread> threads = new LinkedList<>();
+            for (int i = 0; i < 99; ++i) {
+                Thread t = new Thread (new OpenLoop());
+                t.start();
+                threads.add(t);
+            }
+            Thread t2 = new Thread (new ExecLoop());
+            t2.start();
+            threads.add(t2);
+
+            Thread.sleep(timeGap);
+
+            for (Thread t : threads) {
+                t.interrupt();
+                t.join();
+            }
+        }
+
+        private static class OpenLoop implements Runnable {
+            public void run() {
+                final Path bigFilePath = Paths.get(BIG_FILE);
+                while (!Thread.interrupted()) {
+                    try (InputStream in = Files.newInputStream(bigFilePath)) {
+                        // Widen the race window by sleeping 1ms
+                        Thread.sleep(1);
+                    } catch (InterruptedException e) {
+                        break;
+                    } catch (Exception e) {
+                        System.err.println(e);
+                    }
+                }
+            }
+        }
+
+        private static class ExecLoop implements Runnable {
+            public void run() {
+                List<String> command = new ArrayList<>(
+                        Arrays.asList("/bin/cat", SMALL_FILE));
+                while (!Thread.interrupted()) {
+                    try {
+                        ProcessBuilder builder = new ProcessBuilder(command);
+                        final Process process = builder.start();
+                        InputStream is = process.getInputStream();
+                        InputStreamReader isr = new InputStreamReader(is);
+                        BufferedReader br = new BufferedReader(isr);
+                        while (br.readLine() != null) {}
+                        process.waitFor();
+                        isr.close();
+                    } catch (InterruptedException e) {
+                        break;
+                    } catch (Exception e) {
+                        System.err.println(e);
+                    }
+                }
+            }
+        }
+    }
+}
--- ./jdk/test/java/lang/String/ToLowerCase.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/test/java/lang/String/ToLowerCase.java	Wed May 07 19:26:47 2014 -0700
@@ -23,7 +23,7 @@
 
 /*
     @test
-    @bug 4217441 4533872 4900935
+    @bug 4217441 4533872 4900935 8020037
     @summary toLowerCase should lower-case Greek Sigma correctly depending
              on the context (final/non-final).  Also it should handle
              Locale specific (lt, tr, and az) lowercasings and supplementary
@@ -69,10 +69,11 @@
         test("\u00CD", Locale.US, "\u00ED");
         test("\u0128", Locale.US, "\u0129");
 
-        // I-dot tests (Turkish and Azeri)
+        // I-dot tests
         test("\u0130", turkish, "i");
         test("\u0130", az, "i");
-        test("\u0130", Locale.US, "i\u0307");
+        test("\u0130", lt, "i");
+        test("\u0130", Locale.US, "i");
 
         // Remove dot_above in the sequence I + dot_above (Turkish and Azeri)
         test("I\u0307", turkish, "i");
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/lang/System/MacEncoding/ExpectedEncoding.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,66 @@
+/*
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/**
+ * Check that the value of file.encoding and sun.jnu.encoding match the expected
+ * values passed in on the command-line.
+ */
+public class ExpectedEncoding {
+    public static void main(String[] args) {
+        boolean failed = false;
+        if (args.length != 2) {
+            System.out.println("Usage:");
+            System.out.println("$ java ExpectedEncoding <expected file.encoding> <expected sun.jnu.encoding>");
+            System.out.println("$   use \"skip\" to skip checking property's value");
+            System.exit(1);
+        }
+        String expectFileEnc = args[0];
+        String expectSunJnuEnc = args[1];
+
+        String fileEnc = System.getProperty("file.encoding");
+        String jnuEnc = System.getProperty("sun.jnu.encoding");
+
+        if ("skip".equals(expectFileEnc)) {
+            System.err.println("Expected file.encoding is \"skip\", ignoring");
+        } else {
+            System.err.println("Expected file.encoding: " + expectFileEnc);
+            System.err.println("Actual file.encoding: " + fileEnc);
+            if (fileEnc == null || !fileEnc.equals(expectFileEnc)) {
+                failed = true;
+            }
+        }
+        if ("skip".equals(expectSunJnuEnc)) {
+            System.err.println("Expected sun.jnu.encoding is \"skip\", ignoring");
+        } else {
+            if (jnuEnc == null || !jnuEnc.equals(expectSunJnuEnc)) {
+                System.err.println("Expected sun.jnu.encoding: " + expectSunJnuEnc);
+                System.err.println("Actual sun.jnu.encoding: " + jnuEnc);
+                failed = true;
+            }
+        }
+
+        if (failed) {
+            throw new RuntimeException("Test Failed");
+        }
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/lang/System/MacEncoding/MacJNUEncoding.sh	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,96 @@
+#!/bin/sh
+
+#
+# Copyright (c) 2012 Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+
+# @test
+# @bug 8003228
+# @summary Test the value of sun.jnu.encoding on Mac
+# @author Brent Christian
+#
+# @run shell MacJNUEncoding.sh
+
+# Only run test on Mac
+OS=`uname -s`
+case "$OS" in
+  Darwin )  ;;
+  * )
+    exit 0
+    ;;
+esac
+
+if [ "${TESTJAVA}" = "" ]
+then
+  echo "TESTJAVA not set.  Test cannot execute.  Failed."
+  exit 1
+fi
+
+if [ "${TESTSRC}" = "" ]
+then
+  echo "TESTSRC not set.  Test cannot execute.  Failed."
+  exit 1
+fi
+
+if [ "${TESTCLASSES}" = "" ]
+then
+  echo "TESTCLASSES not set.  Test cannot execute.  Failed."
+  exit 1
+fi
+
+JAVAC="${TESTJAVA}"/bin/javac
+JAVA="${TESTJAVA}"/bin/java
+
+echo "Building test classes..."
+"$JAVAC" -d "${TESTCLASSES}" "${TESTSRC}"/ExpectedEncoding.java 
+
+echo ""
+echo "Running test for C locale"
+export LANG=C
+export LC_ALL=C
+"${JAVA}" ${TESTVMOPTS} -classpath "${TESTCLASSES}" ExpectedEncoding US-ASCII UTF-8
+result1=$?
+
+echo ""
+echo "Running test for en_US.UTF-8 locale"
+export LANG=en_US.UTF-8
+export LC_ALL=en_US.UTF-8
+"${JAVA}" ${TESTVMOPTS} -classpath "${TESTCLASSES}" ExpectedEncoding UTF-8 UTF-8
+result2=$?
+
+echo ""
+echo "Cleanup"
+rm ${TESTCLASSES}/ExpectedEncoding.class
+
+if [ ${result1} -ne 0 ] ; then
+    echo "Test failed for C locale"
+    echo "  LANG=\"${LANG}\""
+    echo "  LC_ALL=\"${LC_ALL}\""
+    exit ${result1}
+fi
+if [ ${result2} -ne 0 ] ; then
+    echo "Test failed for en_US.UTF-8 locale"
+    echo "  LANG=\"${LANG}\""
+    echo "  LC_ALL=\"${LC_ALL}\""
+    exit ${result2}
+fi
+exit 0
+
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/lang/System/MacEncoding/TestFileEncoding.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,168 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import java.util.*;
+
+/*
+ * @test
+ * @bug 8011194
+ * @summary Test value of file.encoding for corresponding value of LANG, etc
+ * @library ../../../../tools/launcher/ ../
+ * @build TestHelper TestFileEncoding ExpectedEncoding
+ * @run main TestFileEncoding UTF-8
+ * @run main/othervm -Dfile.encoding=MyEncoding -DuserEncoding=MyEncoding TestFileEncoding MyEncoding
+ * @run main TestFileEncoding UTF-8 en_US.UTF-8
+ * @run main/othervm -Dfile.encoding=MyEncoding -DuserEncoding=MyEncoding TestFileEncoding MyEncoding en_US.UTF-8
+ * @run main TestFileEncoding US-ASCII C
+ * @run main/othervm -Dfile.encoding=MyEncoding -DuserEncoding=MyEncoding TestFileEncoding MyEncoding C
+ * @author Brent Christian
+ */
+
+/**
+ * Setup the environment and run a sub-test to check the expected value of
+ * file.encoding, based on the value(s) of encoding-related environment vars
+ * (LANG, LC_ALL, LC_CTYPE).
+ *
+ * The first argument (required) is the expected value of the
+ * file.encoding System property.
+ * The second argument (optional) is the value to set to the LANG/etc env vars.
+ */
+public class TestFileEncoding {
+    private static final String TEST_NAME = "ExpectedEncoding";
+
+    private String expectedEncoding; // Expected value for file.encoding
+    private String langVar = null; // Value to set for LANG, etc
+
+    private static Set<String> envToRm = new HashSet<>(3);
+    static {
+        // Take these vars out of the test's run environment, possibly adding
+        // our own value back in.
+        envToRm.add("LANG");
+        envToRm.add("LC_ALL");
+        envToRm.add("LC_CTYPE");
+    }
+
+    public TestFileEncoding(String expectedEncoding) {
+        this.expectedEncoding = expectedEncoding;
+    }
+
+    public TestFileEncoding(String expectedEncoding, String langVar) {
+        this.expectedEncoding = expectedEncoding;
+        this.langVar = langVar;
+    }
+
+    /*
+     * Launch ExpectedEncoding with the given parameters, check for the
+     * expected file.encoding.
+     */
+    private void run() {
+        String testClasses = System.getProperty("test.classes");
+
+        // Pick up VM opts
+        String vmOptsStr = System.getProperty("test.vm.opts");
+        System.out.println("test.vm.opts: " + vmOptsStr);
+        String[] vmOpts = new String[0];
+        if (vmOptsStr != null && !"".equals(vmOptsStr)) {
+            vmOpts = vmOptsStr.split(" ");
+            System.out.println("found vm options:");
+            for (String opt : vmOpts) {
+                System.out.println("  <" + opt + ">");
+            }
+        }
+
+        // Build java cmd
+        LinkedList<String> cmdList = new LinkedList<>();
+        cmdList.add(TestHelper.javaCmd);
+        for (String vmOpt : vmOpts) {
+            if (vmOpt != null && !vmOpt.equals("")) {
+                cmdList.add(vmOpt);
+            }
+        }
+
+        // See if the user specified a file.encoding that we should pass through
+        String userEncoding = System.getProperty("userEncoding");
+        if (userEncoding != null) {
+            cmdList.add("-Dfile.encoding="+userEncoding);
+        }
+
+        cmdList.add("-cp");
+        cmdList.add(testClasses);
+        cmdList.add(TEST_NAME);
+        cmdList.add(expectedEncoding);
+        cmdList.add("skip"); // ignore sun.jnu.encoding for this test
+
+        String cmdArray[] = new String[cmdList.size()];
+        cmdList.toArray(cmdArray);
+
+        // Run the test(s)
+        if (langVar == null) {
+            System.out.println("TestFileEncoding: Running with no envvars set");
+            TestHelper.TestResult tr = TestHelper.doExec(null, envToRm,
+                                                         cmdArray);
+            checkResult(tr);
+        } else {
+            runWithEnvVar("LANG", cmdArray);
+            runWithEnvVar("LC_ALL", cmdArray);
+            runWithEnvVar("LC_CTYPE", cmdArray);
+        }
+    }
+
+    /*
+     * Run the test, setting the environment named by envVarName to the value
+     * in langVar.
+     */
+    private void runWithEnvVar(String envVarName, String[] cmdArray) {
+        Map<String, String> envToAdd = new HashMap<>(1);
+        TestHelper.TestResult tr = null;
+
+        System.out.println("TestFileEncoding: Running with " + envVarName + "=" + langVar);
+        envToAdd.put(envVarName, langVar);
+        tr = TestHelper.doExec(envToAdd, envToRm, cmdArray);
+        checkResult(tr);
+    }
+
+    private void checkResult(TestHelper.TestResult tr) {
+        System.out.println(tr);
+        if (!tr.isOK()) {
+            throw new RuntimeException("TEST FAILED: !tr.isOK()");
+        }
+    }
+
+    public static void main(String[] args) {
+        TestFileEncoding cfe = null;
+        if (!TestHelper.isMacOSX) {
+            System.out.println("Test is currently only for Mac OS X - pass.");
+            return;
+        }
+        if (args.length == 1) {
+            cfe = new TestFileEncoding(args[0]);
+        } else if (args.length == 2) {
+            cfe = new TestFileEncoding(args[0], args[1]);
+        } else {
+            System.out.println("Usage: TestFileEncoding <expected file.encoding>");
+            System.out.println("       TestFileEncoding <expected file.encoding> <value for LANG/etc env var>");
+            return;
+        }
+        cfe.run();
+    }
+}
--- ./jdk/test/java/lang/System/MacJNUEncoding/ExpectedEncoding.java	Tue Mar 18 12:35:25 2014 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,56 +0,0 @@
-/*
- * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-
-/**
- * Check that the value of file.encoding and sun.jnu.encoding match the expected
- * values passed in on the command-line.
- */
-public class ExpectedEncoding {
-    public static void main(String[] args) {
-        boolean failed = false;
-        if (args.length != 2) {
-            System.out.println("Usage:");
-            System.out.println("$ java ExpectedEncoding <expected file.encoding> <expected sun.jnu.encoding>");
-            System.exit(1);
-        }
-        String expectFileEnc = args[0];
-        String expectSunJnuEnc = args[1];
-
-        String fileEnc = System.getProperty("file.encoding");
-        String jnuEnc = System.getProperty("sun.jnu.encoding");
-
-        if (fileEnc == null || !fileEnc.equals(expectFileEnc)) {
-            System.err.println("Expected file.encoding: " + expectFileEnc);
-            System.err.println("Actual file.encoding: " + fileEnc);
-            failed = true;
-        }
-        if (jnuEnc == null || !jnuEnc.equals(expectSunJnuEnc)) {
-            System.err.println("Expected sun.jnu.encoding: " + expectSunJnuEnc);
-            System.err.println("Actual sun.jnu.encoding: " + jnuEnc);
-            failed = true;
-        }
-        if (failed) {
-            throw new RuntimeException("Test Failed");
-        }
-    }
-}
--- ./jdk/test/java/lang/System/MacJNUEncoding/MacJNUEncoding.sh	Tue Mar 18 12:35:25 2014 -0700
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,96 +0,0 @@
-#!/bin/sh
-
-#
-# Copyright (c) 2012 Oracle and/or its affiliates. All rights reserved.
-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
-#
-# This code is free software; you can redistribute it and/or modify it
-# under the terms of the GNU General Public License version 2 only, as
-# published by the Free Software Foundation.
-#
-# This code is distributed in the hope that it will be useful, but WITHOUT
-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-# version 2 for more details (a copy is included in the LICENSE file that
-# accompanied this code).
-#
-# You should have received a copy of the GNU General Public License version
-# 2 along with this work; if not, write to the Free Software Foundation,
-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
-#
-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
-# or visit www.oracle.com if you need additional information or have any
-# questions.
-
-# @test
-# @bug 8003228
-# @summary Test the value of sun.jnu.encoding on Mac
-# @author Brent Christian
-#
-# @run shell MacJNUEncoding.sh
-
-# Only run test on Mac
-OS=`uname -s`
-case "$OS" in
-  Darwin )  ;;
-  * )
-    exit 0
-    ;;
-esac
-
-if [ "${TESTJAVA}" = "" ]
-then
-  echo "TESTJAVA not set.  Test cannot execute.  Failed."
-  exit 1
-fi
-
-if [ "${TESTSRC}" = "" ]
-then
-  echo "TESTSRC not set.  Test cannot execute.  Failed."
-  exit 1
-fi
-
-if [ "${TESTCLASSES}" = "" ]
-then
-  echo "TESTCLASSES not set.  Test cannot execute.  Failed."
-  exit 1
-fi
-
-JAVAC="${TESTJAVA}"/bin/javac
-JAVA="${TESTJAVA}"/bin/java
-
-echo "Building test classes..."
-"$JAVAC" -d "${TESTCLASSES}" "${TESTSRC}"/ExpectedEncoding.java 
-
-echo ""
-echo "Running test for C locale"
-export LANG=C
-export LC_ALL=C
-"${JAVA}" ${TESTVMOPTS} -classpath "${TESTCLASSES}" ExpectedEncoding US-ASCII UTF-8
-result1=$?
-
-echo ""
-echo "Running test for en_US.UTF-8 locale"
-export LANG=en_US.UTF-8
-export LC_ALL=en_US.UTF-8
-"${JAVA}" ${TESTVMOPTS} -classpath "${TESTCLASSES}" ExpectedEncoding UTF-8 UTF-8
-result2=$?
-
-echo ""
-echo "Cleanup"
-rm ${TESTCLASSES}/ExpectedEncoding.class
-
-if [ ${result1} -ne 0 ] ; then
-    echo "Test failed for C locale"
-    echo "  LANG=\"${LANG}\""
-    echo "  LC_ALL=\"${LC_ALL}\""
-    exit ${result1}
-fi
-if [ ${result2} -ne 0 ] ; then
-    echo "Test failed for en_US.UTF-8 locale"
-    echo "  LANG=\"${LANG}\""
-    echo "  LC_ALL=\"${LC_ALL}\""
-    exit ${result2}
-fi
-exit 0
-
--- ./jdk/test/java/lang/ThreadGroup/Suspend.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/test/java/lang/ThreadGroup/Suspend.java	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -23,47 +23,55 @@
 
 /**
  * @test
- * @bug 4176355
+ * @bug 4176355 7181748
  * @summary Suspending a ThreadGroup that contains the current thread has
  *          unpredictable results.
  */
 
 public class Suspend implements Runnable {
-    private static Thread first=null;
-    private static Thread second=null;
-    private static ThreadGroup group = new ThreadGroup("");
-    private static int count = 0;
 
-    Suspend() {
-        Thread thread = new Thread(group, this);
-        if (first == null)
-            first = thread;
-        else
-            second = thread;
-
-        thread.start();
-    }
+    private static volatile int count = 0;
+    private static final ThreadGroup group = new ThreadGroup("");
+    private static final Thread first = new Thread(group, new Suspend());
+    private static final Thread second = new Thread(group, new Suspend());
 
     public void run() {
         while (true) {
             try {
-                Thread.sleep(1000); // Give other thread a chance to start
-                if (Thread.currentThread() == first)
-                    group.suspend();
-                else
+                Thread.sleep(100);
+                if (Thread.currentThread() == first) {
+                    if (second.isAlive()) {
+                        group.suspend();
+                    }
+                } else {
                     count++;
-            } catch(InterruptedException e){
+                }
+            } catch (InterruptedException e) {
             }
         }
     }
 
     public static void main(String[] args) throws Exception {
-        for (int i=0; i<2; i++)
-            new Suspend();
-        Thread.sleep(3000);
+        // Launch two threads as part of the same thread group
+        first.start();
+        second.start();
+
+        // Wait for the thread group suspend to be issued
+        while (!first.isAlive() || !second.isAlive()) {
+            Thread.sleep(100);
+        }
+        Thread.sleep(1000);
+        // Suppose, the thread group is now suspended
+
+        count = 0;
+        Thread.sleep(1000);
+
+        // Increment of the count indicates that the second thread is still running
         boolean failed = (count > 1);
-        first.stop(); second.stop();
-        if (failed)
+        first.stop();
+        second.stop();
+        if (failed) {
             throw new RuntimeException("Failure.");
+        }
     }
 }
--- ./jdk/test/java/lang/instrument/RedefineBigClass.sh	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/test/java/lang/instrument/RedefineBigClass.sh	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2011, 2013 Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -22,7 +22,7 @@
 #
 
 # @test
-# @bug 7121600
+# @bug 7121600 8016838
 # @summary Redefine a big class.
 # @author Daniel D. Daugherty
 #
--- ./jdk/test/java/lang/instrument/RedefineBigClassApp.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/test/java/lang/instrument/RedefineBigClassApp.java	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2013 Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -21,12 +21,21 @@
  * questions.
  */
 
+import java.io.*;
+
 public class RedefineBigClassApp {
+    /**
+     * Memory leak is assumed, if application consumes more than specified amount of memory during its execution.
+     * The number is given in Kb.
+     */
+    private static final long MEM_LEAK_THRESHOLD = 32 * 1024; // 32Mb
+
     public static void main(String[] args) throws Exception {
         System.out.println("Creating instance of " +
             RedefineBigClassAgent.clz);
         RedefineBigClassAgent.clz.newInstance();
 
+        long vMemBefore = getVMemSize();
         int count = 0;
         while (!RedefineBigClassAgent.doneRedefining) {
             System.out.println("App loop count: " + ++count);
@@ -37,6 +46,39 @@
         }
         System.out.println("App looped  " + count + " times.");
 
+        long vMemAfter = getVMemSize();
+        if (vMemBefore == 0 || vMemAfter == 0) {
+            System.err.println("WARNING: Cannot perform memory leak detection on this OS");
+        } else {
+            long vMemDelta = vMemAfter - vMemBefore;
+            if (vMemDelta > MEM_LEAK_THRESHOLD) {
+                System.err.println("FAIL: Virtual memory usage increased by " + vMemDelta + "Kb " +
+                        "(greater than " + MEM_LEAK_THRESHOLD + "Kb)");
+                System.exit(1);
+            }
+            System.err.println("PASS: Virtual memory usage increased by " + vMemDelta + "Kb " +
+                    "(not greater than " + MEM_LEAK_THRESHOLD + "Kb)");
+        }
         System.exit(0);
     }
+
+    /**
+     * Return size of virtual memory allocated to the process in Kb.
+     * Linux specific. On other platforms and in case of any errors return 0.
+     */
+    private static long getVMemSize() {
+
+        // Refer to the Linux proc(5) man page for details about /proc/self/stat file
+        //
+        // In short, this file contains status information about the current process
+        // written in one line. The fields are separated with spaces.
+        // The 23rd field is defined as 'vsize %lu   Virtual memory size in bytes'
+
+        try (FileReader fileReader = new FileReader("/proc/self/stat");
+             BufferedReader bufferedReader = new BufferedReader(fileReader)) {
+            String line = bufferedReader.readLine();
+            return Long.parseLong(line.split(" ")[22]) / 1024;
+        } catch (Exception ex) {}
+        return 0;
+    }
 }
--- ./jdk/test/java/lang/instrument/RetransformBigClass.sh	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/test/java/lang/instrument/RetransformBigClass.sh	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2011, 2013 Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -22,7 +22,7 @@
 #
 
 # @test
-# @bug 7122253
+# @bug 7122253 8016838
 # @ignore until the fix for 7122253 (from HotSpot) is in a promoted build
 # @summary Retransform a big class.
 # @author Daniel D. Daugherty
--- ./jdk/test/java/lang/instrument/RetransformBigClassApp.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/test/java/lang/instrument/RetransformBigClassApp.java	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2013 Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -21,12 +21,21 @@
  * questions.
  */
 
+import java.io.*;
+
 public class RetransformBigClassApp {
+    /**
+     * Memory leak is assumed, if application consumes more than specified amount of memory during its execution.
+     * The number is given in Kb.
+     */
+    private static final long MEM_LEAK_THRESHOLD = 32 * 1024; // 32Mb
+
     public static void main(String[] args) throws Exception {
         System.out.println("Creating instance of " +
             RetransformBigClassAgent.clz);
         RetransformBigClassAgent.clz.newInstance();
 
+        long vMemBefore = getVMemSize();
         int count = 0;
         while (!RetransformBigClassAgent.doneRetransforming) {
             System.out.println("App loop count: " + ++count);
@@ -37,6 +46,39 @@
         }
         System.out.println("App looped  " + count + " times.");
 
+        long vMemAfter = getVMemSize();
+        if (vMemBefore == 0 || vMemAfter == 0) {
+            System.err.println("WARNING: Cannot perform memory leak detection on this OS");
+        } else {
+            long vMemDelta = vMemAfter - vMemBefore;
+            if (vMemDelta > MEM_LEAK_THRESHOLD) {
+                System.err.println("FAIL: Virtual memory usage increased by " + vMemDelta + "Kb " +
+                        "(greater than " + MEM_LEAK_THRESHOLD + "Kb)");
+                System.exit(1);
+            }
+            System.err.println("PASS: Virtual memory usage increased by " + vMemDelta + "Kb " +
+                    "(not greater than " + MEM_LEAK_THRESHOLD + "Kb)");
+        }
         System.exit(0);
     }
+
+    /**
+     * Return size of virtual memory allocated to the process in Kb.
+     * Linux specific. On other platforms and in case of any errors return 0.
+     */
+    private static long getVMemSize() {
+
+        // Refer to the Linux proc(5) man page for details about /proc/self/stat file
+        //
+        // In short, this file contains status information about the current process
+        // written in one line. The fields are separated with spaces.
+        // The 23rd field is defined as 'vsize %lu   Virtual memory size in bytes'
+
+        try (FileReader fileReader = new FileReader("/proc/self/stat");
+             BufferedReader bufferedReader = new BufferedReader(fileReader)) {
+            String line = bufferedReader.readLine();
+            return Long.parseLong(line.split(" ")[22]) / 1024;
+        } catch (Exception ex) {}
+        return 0;
+    }
 }
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/lang/invoke/8009222/Test8009222.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ *
+ */
+
+/**
+ * @test
+ * @bug 8009222
+ * @summary java.lang.IllegalArgumentException: not invocable, no method type
+ * when attempting to get getter method handle for a static field
+ *
+ * @run main/othervm Test8009222
+ */
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+
+interface Intf {
+    static int i = 0;
+}
+
+public class Test8009222 {
+    public static void main(String[] args) throws Exception {
+        MethodHandles.lookup()
+                .findStaticGetter(Intf.class, "i", int.class)
+                .getClass(); // null check
+
+        System.out.println("TEST PASSED");
+    }
+}
--- ./jdk/test/java/lang/invoke/BigArityTest.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/test/java/lang/invoke/BigArityTest.java	Wed May 07 19:26:47 2014 -0700
@@ -26,7 +26,7 @@
 /* @test
  * @summary High arity invocations, up to the maximum of 255 arguments
  * @compile BigArityTest.java
- * @run junit/othervm -DBigArityTest.ITERATION_COUNT=1 test.java.lang.invoke.BigArityTest
+ * @run junit/othervm/timeout=2500 -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies -esa -DBigArityTest.ITERATION_COUNT=1 test.java.lang.invoke.BigArityTest
  */
 
 package test.java.lang.invoke;
--- ./jdk/test/java/lang/invoke/CallSiteTest.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/test/java/lang/invoke/CallSiteTest.java	Wed May 07 19:26:47 2014 -0700
@@ -28,7 +28,7 @@
  *
  * @build indify.Indify
  * @compile CallSiteTest.java
- * @run main/othervm
+ * @run main/othervm/timeout=3600 -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies
  *      indify.Indify
  *      --expand-properties --classpath ${test.classes}
  *      --java test.java.lang.invoke.CallSiteTest
--- ./jdk/test/java/lang/invoke/MethodHandlesTest.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/test/java/lang/invoke/MethodHandlesTest.java	Wed May 07 19:26:47 2014 -0700
@@ -26,7 +26,7 @@
 /* @test
  * @summary unit tests for java.lang.invoke.MethodHandles
  * @compile MethodHandlesTest.java remote/RemoteExample.java
- * @run junit/othervm test.java.lang.invoke.MethodHandlesTest
+ * @run junit/othervm/timeout=2500 -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies -esa test.java.lang.invoke.MethodHandlesTest
  */
 
 package test.java.lang.invoke;
--- ./jdk/test/java/lang/invoke/RicochetTest.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/test/java/lang/invoke/RicochetTest.java	Wed May 07 19:26:47 2014 -0700
@@ -25,7 +25,7 @@
 
 /* @test
  * @summary unit tests for recursive method handles
- * @run junit/othervm -DRicochetTest.MAX_ARITY=50 test.java.lang.invoke.RicochetTest
+ * @run junit/othervm/timeout=3600 -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies -DRicochetTest.MAX_ARITY=10 test.java.lang.invoke.RicochetTest
  */
 /*
  * @ignore The following test creates an unreasonable number of adapters in -Xcomp mode (7049122)
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/lang/invoke/TestCatchExceptionWithVarargs.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,97 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 8019184
+ * @summary MethodHandles.catchException() fails when methods have 8 args + varargs
+ */
+
+import java.util.*;
+import java.lang.invoke.*;
+
+public class TestCatchExceptionWithVarargs {
+
+    private static final Class<?> CLASS = TestCatchExceptionWithVarargs.class;
+    private static final int MAX_MH_ARITY = 254;
+
+    public static MethodHandle target;
+    public static MethodHandle handler;
+
+    private static Object firstArg;
+
+    static class MyException extends Exception {
+    }
+
+    public static Object target(Object... a) throws Exception {
+        if (a[0] != firstArg) {
+            throw new AssertionError("first argument different than expected: " + a[0] + " != " + firstArg);
+        }
+        throw new MyException();
+    }
+
+    public static Object handler(Object... a) {
+        if (a[0] != firstArg) {
+            throw new AssertionError("first argument different than expected: " + a[0] + " != " + firstArg);
+        }
+        return a[0];
+    }
+
+    static {
+        try {
+            MethodType mtype = MethodType.methodType(Object.class, Object[].class);
+            target = MethodHandles.lookup().findStatic(CLASS, "target", mtype);
+            handler = MethodHandles.lookup().findStatic(CLASS, "handler", mtype);
+        } catch (Exception e) {
+            throw new AssertionError(e);
+        }
+    }
+
+    public static void main(String[] args) throws Throwable {
+        List<Class<?>> ptypes = new LinkedList<>();
+        ptypes.add(Object[].class);
+
+        // We use MAX_MH_ARITY - 1 here to account for the Object[] argument.
+        for (int i = 1; i < MAX_MH_ARITY - 1; i++) {
+            ptypes.add(0, Object.class);
+
+            MethodHandle targetWithArgs = target.asType(MethodType.methodType(Object.class, ptypes));
+            MethodHandle handlerWithArgs = handler.asType(MethodType.methodType(Object.class, ptypes));
+            handlerWithArgs = MethodHandles.dropArguments(handlerWithArgs, 0, MyException.class);
+
+            MethodHandle gwc1 = MethodHandles.catchException(targetWithArgs, MyException.class, handlerWithArgs);
+
+            // The next line throws an IllegalArgumentException if there is a bug.
+            MethodHandle gwc2 = MethodHandles.catchException(gwc1, MyException.class, handlerWithArgs);
+
+            // This is only to verify that the method handles can actually be invoked and do the right thing.
+            firstArg = new Object();
+            Object o = gwc2.asSpreader(Object[].class, ptypes.size() - 1).invoke(firstArg, new Object[i]);
+            if (o != firstArg) {
+                throw new AssertionError("return value different than expected: " + o + " != " + firstArg);
+            }
+        }
+    }
+}
--- ./jdk/test/java/lang/management/PlatformLoggingMXBean/LoggingMXBeanTest.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/test/java/lang/management/PlatformLoggingMXBean/LoggingMXBeanTest.java	Wed May 07 19:26:47 2014 -0700
@@ -23,7 +23,7 @@
 
 /*
  * @test
- * @bug 7024172
+ * @bug 7024172 7067691
  * @summary Test if proxy for PlatformLoggingMXBean is equivalent
  *          to proxy for LoggingMXBean
  *
@@ -36,12 +36,21 @@
 import java.util.logging.*;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Map;
+import java.util.HashMap;
 
 public class LoggingMXBeanTest
 {
-    static String LOGGER_NAME_1 = "com.sun.management.Logger";
-    static String LOGGER_NAME_2 = "com.sun.management.Logger.Logger2";
-    static String UNKNOWN_LOGGER_NAME = "com.sun.management.Unknown";
+    static final String LOGGER_NAME_1 = "com.sun.management.Logger";
+    static final String LOGGER_NAME_2 = "com.sun.management.Logger.Logger2";
+    static final String UNKNOWN_LOGGER_NAME = "com.sun.management.Unknown";
+
+    // These instance variables prevent premature logger garbage collection
+    // See getLogger() weak reference warnings.
+    Logger logger1;
+    Logger logger2;
+
+    static LoggingMXBeanTest test;
 
     public static void main(String[] argv) throws Exception {
         MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
@@ -51,7 +60,7 @@
                 LoggingMXBean.class);
 
         // test LoggingMXBean proxy
-        LoggingMXBeanTest p = new LoggingMXBeanTest(proxy);
+        test = new LoggingMXBeanTest(proxy);
 
         // check if the attributes implemented by PlatformLoggingMXBean
         // and LoggingMXBean return the same value
@@ -64,9 +73,9 @@
     // same verification as in java/util/logging/LoggingMXBeanTest2
     public LoggingMXBeanTest(LoggingMXBean mbean) throws Exception {
 
-        Logger logger1 = Logger.getLogger( LOGGER_NAME_1 );
+        logger1 = Logger.getLogger( LOGGER_NAME_1 );
         logger1.setLevel(Level.FINE);
-        Logger logger2 = Logger.getLogger( LOGGER_NAME_2 );
+        logger2 = Logger.getLogger( LOGGER_NAME_2 );
         logger2.setLevel(null);
 
         /*
@@ -206,20 +215,36 @@
                                         PlatformLoggingMXBean mxbean2) {
         // verify logger names
         List<String> loggers1 = mxbean1.getLoggerNames();
+        System.out.println("Loggers: " + loggers1);
+
+        // Retrieve the named loggers to prevent them from being
+        // spontaneously gc'ed.
+        Map<String, Logger> loggersMap = new HashMap<>();
+        for (String n : loggers1) {
+            loggersMap.put(n, Logger.getLogger(n));
+        }
+
         List<String> loggers2 = mxbean2.getLoggerNames();
+
+        // loggers1 and loggers2 should be identical - no new logger should
+        // have been created in between (at least no new logger name)
+        //
         if (loggers1.size() != loggers2.size())
             throw new RuntimeException("LoggerNames: unmatched number of entries");
-        List<String> loggers3 = new ArrayList<>(loggers1);
-        loggers3.removeAll(loggers2);
-        if (loggers3.size() != 0)
+        if (!loggers2.containsAll(loggersMap.keySet()))
             throw new RuntimeException("LoggerNames: unmatched loggers");
 
+
         // verify logger's level  and parent
         for (String logger : loggers1) {
-            if (!mxbean1.getLoggerLevel(logger)
-                    .equals(mxbean2.getLoggerLevel(logger)))
+            String level1 = mxbean1.getLoggerLevel(logger);
+            String level2 = mxbean2.getLoggerLevel(logger);
+            if (!java.util.Objects.equals(level1, level2)) {
                 throw new RuntimeException(
-                    "LoggerLevel: unmatched level for " + logger);
+                        "LoggerLevel: unmatched level for " + logger
+                        + ", " + level1 + ", " + level2);
+            }
+
             if (!mxbean1.getParentLoggerName(logger)
                     .equals(mxbean2.getParentLoggerName(logger)))
                 throw new RuntimeException(
--- ./jdk/test/java/lang/management/PlatformLoggingMXBean/PlatformLoggingMXBeanTest.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/test/java/lang/management/PlatformLoggingMXBean/PlatformLoggingMXBeanTest.java	Wed May 07 19:26:47 2014 -0700
@@ -23,7 +23,7 @@
 
 /*
  * @test
- * @bug     6876135 7024172
+ * @bug     6876135 7024172 7067691
  *
  * @summary Test PlatformLoggingMXBean
  *          This test performs similar testing as
@@ -41,11 +41,15 @@
 
 public class PlatformLoggingMXBeanTest
 {
-
     ObjectName objectName = null;
     static String LOGGER_NAME_1 = "com.sun.management.Logger1";
     static String LOGGER_NAME_2 = "com.sun.management.Logger2";
 
+    // Use Logger instance variables to prevent premature garbage collection
+    // of weak references.
+    Logger logger1;
+    Logger logger2;
+
     public PlatformLoggingMXBeanTest() throws Exception {
     }
 
@@ -135,8 +139,8 @@
         System.out.println( "*********** Phase 3 ***********" );
         System.out.println( "*******************************" );
         System.out.println( " Create and test new Loggers" );
-        Logger logger1 = Logger.getLogger( LOGGER_NAME_1 );
-        Logger logger2 = Logger.getLogger( LOGGER_NAME_2 );
+        logger1 = Logger.getLogger( LOGGER_NAME_1 );
+        logger2 = Logger.getLogger( LOGGER_NAME_2 );
 
         // check that Level object are returned properly
         try {
@@ -187,6 +191,7 @@
         System.out.println( " Set and Check the Logger Level" );
         log1 = false;
         log2 = false;
+
         try {
             // Set the level of logger1 to ALL
             params = new Object[2];
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/lang/ref/FinalizeOverride.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,167 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.concurrent.atomic.AtomicInteger;
+
+/* @test
+ * @bug 8027351
+ * @summary Basic test of the finalize method
+ */
+
+public class FinalizeOverride {
+    // finalizedCount is incremented when the finalize method is invoked
+    private static AtomicInteger finalizedCount = new AtomicInteger();
+
+    // finalizedSum and privateFinalizedInvoke are used to verify
+    // the right overrided finalize method is invoked
+    private static AtomicInteger finalizedSum = new AtomicInteger();
+    private static volatile boolean privateFinalizeInvoked = false;
+
+    public static void main(String[] argvs) throws IOException {
+        patchPrivateFinalize();
+
+        test(new Base(10), 10);
+        test(new Subclass(20), 0);
+        test(new SubSubclass(30), 30);
+        test(new PublicFinalize(40), 40*100+40);
+        test(new PrivateFinalize(50), 50);
+        test(new NoOverride(60), 60);
+    }
+
+    static void test(Object o, int expected) {
+        int count = finalizedCount.get();
+        int sum = finalizedSum.get();
+        privateFinalizeInvoked = false;
+
+        // force GC and finalization
+        o = null;
+        while (finalizedCount.get() != (count+1)) {
+            System.gc();
+            System.runFinalization();
+        }
+
+        if (privateFinalizeInvoked) {
+            throw new RuntimeException("private finalize method invoked");
+        }
+        if (finalizedCount.get() != (count+1)) {
+            throw new RuntimeException("Unexpected count=" + finalizedCount +
+                " expected=" + (count+1));
+        }
+        if (finalizedSum.get() != (sum+expected)) {
+            throw new RuntimeException("Unexpected sum=" + finalizedSum +
+                " prev=" + sum + " value=" + expected);
+        }
+    }
+
+    static void patchPrivateFinalize() throws IOException {
+        // patch the private f_nal_ze method name to "finalize"
+        String testClasses = System.getProperty("test.classes", ".");
+        Path p = Paths.get(testClasses, "FinalizeOverride$PrivateFinalize.class");
+        byte[] bytes = Files.readAllBytes(p);
+        int len = "f_nal_ze".length();
+        for (int i=0; i < bytes.length-len; i++) {
+            if (bytes[i] == 'f' &&
+                bytes[i+1] == '_' &&
+                bytes[i+2] == 'n' &&
+                bytes[i+3] == 'a' &&
+                bytes[i+4] == 'l' &&
+                bytes[i+5] == '_' &&
+                bytes[i+6] == 'z' &&
+                bytes[i+7] == 'e')
+            {
+                // s%_%i%
+                bytes[i+1] = 'i';
+                bytes[i+5] = 'i';
+                break;
+            }
+        }
+        Files.write(p, bytes);
+    }
+
+    static class Base {
+        protected int value;
+        Base(int v) {
+            this.value = v;
+        }
+        int called() {
+            finalizedSum.addAndGet(value);
+            return value;
+        }
+        protected void finalize() {
+            System.out.println("Base.finalize() sum += " + called());
+            finalizedCount.incrementAndGet();
+        }
+    }
+    static class PublicFinalize extends Base {
+        PublicFinalize(int v) {
+            super(v);
+        }
+        public void finalize() {
+            finalizedSum.addAndGet(value * 100);
+            System.out.println("PublicFinalize.finalize() sum += " + called() +
+                "+"+value+"*100");
+            finalizedCount.incrementAndGet();
+        }
+    }
+    static class Subclass extends Base {
+        Subclass(int v) {
+            super(v);
+        }
+        protected void finalize() {
+            // no value added to sum
+            System.out.println("Subclass.finalize() sum += 0");
+            finalizedCount.incrementAndGet();
+        }
+    }
+    static class SubSubclass extends Subclass {
+        SubSubclass(int v) {
+            super(v);
+        }
+        protected final void finalize() {
+            finalizedSum.addAndGet(value);
+            System.out.println("SubSubclass.finalize() sum +=" +value);
+            finalizedCount.incrementAndGet();
+        }
+    }
+    static class PrivateFinalize extends Base {
+        PrivateFinalize(int v) {
+            super(v);
+        }
+        private void f_nal_ze() {
+            // finalization catches any exception
+            System.out.println("Error: private finalize invoked!!");
+            privateFinalizeInvoked = true;
+            finalizedCount.incrementAndGet();
+        }
+    }
+    static class NoOverride extends PrivateFinalize {
+        NoOverride(int v) {
+            super(v);
+        }
+    }
+}
--- ./jdk/test/java/net/Authenticator/B4769350.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/test/java/net/Authenticator/B4769350.java	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2002, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2002, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -23,9 +23,7 @@
 
 /**
  * @test
- * @bug 4769350
- * @library ../../../sun/net/www/httptest/
- * @build HttpCallback HttpServer ClosedChannelList HttpTransaction AbstractCallback
+ * @bug 4769350 8017779
  * @run main/othervm B4769350 server
  * @run main/othervm B4769350 proxy
  * @summary proxy authentication username and password caching only works in serial case
@@ -34,8 +32,17 @@
  * tests may already have invoked the HTTP handler.
  */
 
+import com.sun.net.httpserver.HttpExchange;
+import com.sun.net.httpserver.HttpHandler;
+import com.sun.net.httpserver.HttpServer;
 import java.io.*;
 import java.net.*;
+import java.util.concurrent.BrokenBarrierException;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.CyclicBarrier;
+import java.util.concurrent.Executor;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
 
 public class B4769350 {
 
@@ -43,13 +50,12 @@
     static boolean error = false;
 
     static void read (InputStream is) throws IOException {
-        int c;
-        while ((c=is.read()) != -1) {
+        while (is.read() != -1) {
             //System.out.write (c);
         }
     }
 
-    static class Client extends Thread {
+     static class Client extends Thread {
         String authority, path;
         boolean allowerror;
 
@@ -64,8 +70,8 @@
             try {
                 URI u = new URI ("http", authority, path, null, null);
                 URL url = u.toURL();
-                URLConnection urlc = url.openConnection ();
-                InputStream is = urlc.getInputStream ();
+                URLConnection urlc = url.openConnection();
+                InputStream is = urlc.getInputStream();
                 read (is);
                 is.close();
             } catch (URISyntaxException  e) {
@@ -73,7 +79,8 @@
                 error = true;
             } catch (IOException e) {
                 if (!allowerror) {
-                    System.out.println (Thread.currentThread().getName() + " " + e);
+                    System.out.println (Thread.currentThread().getName()
+                            + " " + e);
                     e.printStackTrace();
                     error = true;
                 }
@@ -81,55 +88,58 @@
         }
     }
 
-    static class CallBack extends AbstractCallback {
+    class Server implements AutoCloseable {
+        HttpServer server;
+        Executor executor;
+        CyclicBarrier t1Cond1;
+        CyclicBarrier t1Cond2;
 
-        void errorReply (HttpTransaction req, String reply) throws IOException {
-            req.addResponseHeader ("Connection", "close");
-            req.addResponseHeader ("WWW-Authenticate", reply);
-            req.sendResponse (401, "Unauthorized");
-            req.orderlyClose();
+        public String getAddress() {
+            return server.getAddress().getHostName();
         }
 
-        void proxyReply (HttpTransaction req, String reply) throws IOException {
-            req.addResponseHeader ("Proxy-Authenticate", reply);
-            req.sendResponse (407, "Proxy Authentication Required");
+        public void startServer() {
+            InetSocketAddress addr = new InetSocketAddress(0);
+
+            try {
+                server = HttpServer.create(addr, 0);
+            } catch (IOException ioe) {
+                throw new RuntimeException("Server could not be created");
+            }
+            executor = Executors.newFixedThreadPool(10);
+            server.setExecutor(executor);
+            server.createContext("/test/realm1/t1a",
+                    new AuthenticationHandlerT1a() );
+            server.createContext("/test/realm2/t1b",
+                    new AuthenticationHandlerT1b());
+            server.createContext("/test/realm1/t1c",
+                    new AuthenticationHandlerT1c());
+            server.createContext("/test/realm2/t1d",
+                    new AuthenticationHandlerT1d());
+            server.createContext("/test/realm3/t2a",
+                    new AuthenticationHandlerT2a());
+            server.createContext("/test/realm3/t2b",
+                    new AuthenticationHandlerT2b());
+            server.createContext("/test/realm4/t3a",
+                    new AuthenticationHandlerT3a());
+            server.createContext("/test/realm4/t3b",
+                    new AuthenticationHandlerT3bc());
+            server.createContext("/test/realm4/t3c",
+                    new AuthenticationHandlerT3bc());
+            t1Cond1 = new CyclicBarrier(2);
+            t1Cond2 = new CyclicBarrier(2);
+            server.start();
         }
 
-        void okReply (HttpTransaction req) throws IOException {
-            req.addResponseHeader ("Connection", "close");
-            req.setResponseEntityBody ("Hello .");
-            req.sendResponse (200, "Ok");
-            req.orderlyClose();
+        public int getPort() {
+            return server.getAddress().getPort();
         }
 
-        public void request (HttpTransaction req, int count) {
-            try {
-                URI uri = req.getRequestURI();
-                String path = uri.getPath();
-                if (path.endsWith ("/t1a")) {
-                    doT1a (req, count);
-                } else if (path.endsWith ("/t1b")) {
-                    doT1b (req, count);
-                } else if (path.endsWith ("/t1c")) {
-                    doT1c (req, count);
-                } else if (path.endsWith ("/t1d")) {
-                    doT1d (req, count);
-                } else if (path.endsWith ("/t2a")) {
-                    doT2a (req, count);
-                } else if (path.endsWith ("/t2b")) {
-                    doT2b (req, count);
-                } else if (path.endsWith ("/t3a")) {
-                    doT3a (req, count);
-                } else if (path.endsWith ("/t3b")) {
-                    doT3bc (req, count);
-                } else if (path.endsWith ("/t3c")) {
-                    doT3bc (req, count);
-                } else {
-                   System.out.println ("unexpected request URI");
-                }
-            } catch (IOException e) {
-                e.printStackTrace();
-            }
+        public void close() {
+            if (executor != null)
+                ((ExecutorService)executor).shutdownNow();
+            if (server != null)
+                server.stop(0);
         }
 
         /* T1 tests the client by sending 4 requests to 2 different realms
@@ -138,90 +148,158 @@
          * the second requests should be executed without calling the authenticator.
          * The test succeeds if the authenticator was only called twice.
          */
-        void doT1a (HttpTransaction req, int count) throws IOException {
-            switch (count) {
-            case 0:
-                errorReply (req, "Basic realm=\"realm1\"");
-                HttpServer.rendezvous ("one", 2);
-                break;
-            case 1:
-                HttpServer.waitForCondition ("cond2");
-                okReply (req);
-                break;
-            default:
-                System.out.println ("Unexpected request");
+        class AuthenticationHandlerT1a implements HttpHandler
+        {
+            volatile int count = -1;
+
+            @Override
+            public void handle(HttpExchange exchange) throws IOException {
+                count++;
+                try {
+                    switch(count) {
+                        case 0:
+                            AuthenticationHandler.errorReply(exchange,
+                                    "Basic realm=\"realm1\"");
+                            break;
+                        case 1:
+                            t1Cond1.await();
+                            t1cond2latch.await();
+                            AuthenticationHandler.okReply(exchange);
+                            break;
+                        default:
+                            System.out.println ("Unexpected request");
+                    }
+                } catch (InterruptedException |
+                                 BrokenBarrierException e)
+                        {
+                            throw new RuntimeException(e);
+                        }
             }
         }
 
+        class AuthenticationHandlerT1b implements HttpHandler
+        {
+            volatile int count = -1;
 
-        void doT1b (HttpTransaction req, int count) throws IOException {
-            switch (count) {
-            case 0:
-                errorReply (req, "Basic realm=\"realm2\"");
-                HttpServer.rendezvous ("one", 2);
-                HttpServer.setCondition ("cond1");
-                break;
-            case 1:
-                HttpServer.waitForCondition ("cond2");
-                okReply (req);
-                break;
-            default:
-                System.out.println ("Unexpected request");
+            @Override
+            public void handle(HttpExchange exchange) throws IOException {
+                count++;
+                try {
+                    switch(count) {
+                        case 0:
+                            AuthenticationHandler.errorReply(exchange,
+                                    "Basic realm=\"realm2\"");
+                            break;
+                        case 1:
+                            t1Cond1.await();
+                            t1cond1latch.countDown();
+                            t1cond2latch.await();
+                            AuthenticationHandler.okReply(exchange);
+                            break;
+                        default:
+                            System.out.println ("Unexpected request");
+                    }
+                } catch (InterruptedException | BrokenBarrierException e) {
+                    throw new RuntimeException(e);
+                }
             }
         }
 
-        void doT1c (HttpTransaction req, int count) throws IOException {
-            switch (count) {
-            case 0:
-                errorReply (req, "Basic realm=\"realm1\"");
-                HttpServer.rendezvous ("two", 2);
-                break;
-            case 1:
-                okReply (req);
-                break;
-            default:
-                System.out.println ("Unexpected request");
+        class AuthenticationHandlerT1c implements HttpHandler
+        {
+            volatile int count = -1;
+
+            @Override
+            public void handle(HttpExchange exchange) throws IOException {
+                count++;
+                switch(count) {
+                    case 0:
+                        AuthenticationHandler.errorReply(exchange,
+                                "Basic realm=\"realm1\"");
+                        try {
+                            t1Cond2.await();
+                        } catch (InterruptedException |
+                                 BrokenBarrierException e)
+                        {
+                            throw new RuntimeException(e);
+                        }
+                        break;
+                    case 1:
+                        AuthenticationHandler.okReply(exchange);
+                        break;
+                    default:
+                        System.out.println ("Unexpected request");
+                }
             }
         }
 
-        void doT1d (HttpTransaction req, int count) throws IOException {
-            switch (count) {
-            case 0:
-                errorReply (req, "Basic realm=\"realm2\"");
-                HttpServer.rendezvous ("two", 2);
-                HttpServer.setCondition ("cond2");
-                break;
-            case 1:
-                okReply (req);
-                break;
-            default:
-                System.out.println ("Unexpected request");
+        class AuthenticationHandlerT1d implements HttpHandler
+        {
+            volatile int count = -1;
+
+            @Override
+            public void handle(HttpExchange exchange) throws IOException {
+                count++;
+                switch(count) {
+                    case 0:
+                        AuthenticationHandler.errorReply(exchange,
+                                "Basic realm=\"realm2\"");
+                        try {
+                            t1Cond2.await();
+                        } catch (InterruptedException |
+                                 BrokenBarrierException e)
+                        {
+                            throw new RuntimeException(e);
+                        }
+                        t1cond2latch.countDown();
+                        break;
+                    case 1:
+                        AuthenticationHandler.okReply(exchange);
+                        break;
+                    default:
+                        System.out.println ("Unexpected request");
+                }
             }
         }
 
-
         /* T2 tests to check that if initial authentication fails, the second will
          * succeed, and the authenticator is called twice
          */
 
-        void doT2a (HttpTransaction req, int count) throws IOException {
-            /* This will be called several times */
-            if (count == 1) {
-                HttpServer.setCondition ("T2cond1");
+        class AuthenticationHandlerT2a implements HttpHandler
+        {
+            volatile int count = -1;
+
+            @Override
+            public void handle(HttpExchange exchange) throws IOException {
+                count++;
+                if (count == 1) {
+                    t2condlatch.countDown();
+                }
+                AuthenticationHandler.errorReply(exchange,
+                        "Basic realm=\"realm3\"");
+
             }
-            errorReply (req, "Basic realm=\"realm3\"");
         }
 
-        void doT2b (HttpTransaction req, int count) throws IOException {
-            switch (count) {
-            case 0:
-                errorReply (req, "Basic realm=\"realm3\"");
-                break;
-            case 1:
-                okReply (req);
-                break;
-            default:
-                System.out.println ("Unexpected request");
+         class AuthenticationHandlerT2b implements HttpHandler
+        {
+            volatile int count = -1;
+
+            @Override
+            public void handle(HttpExchange exchange) throws IOException {
+                count++;
+                switch(count) {
+                    case 0:
+                        AuthenticationHandler.errorReply(exchange,
+                                "Basic realm=\"realm3\"");
+                        break;
+                    case 1:
+                        AuthenticationHandler.okReply(exchange);
+                        break;
+                    default:
+                        System.out.println ("Unexpected request");
+                }
             }
         }
 
@@ -229,36 +307,82 @@
          * resource at same time. Authenticator should be called once for server
          * and once for proxy
          */
-        void doT3a (HttpTransaction req, int count) throws IOException {
-            switch (count) {
-            case 0:
-                proxyReply (req, "Basic realm=\"proxy\"");
-                HttpServer.setCondition ("T3cond1");
-                break;
-            case 1:
-                errorReply (req, "Basic realm=\"realm4\"");
-                break;
-            case 2:
-                okReply (req);
-                break;
-            default:
-                System.out.println ("Unexpected request");
+
+        class AuthenticationHandlerT3a implements HttpHandler
+        {
+            volatile int count = -1;
+
+            @Override
+            public void handle(HttpExchange exchange) throws IOException {
+                count++;
+                switch(count) {
+                    case 0:
+                        AuthenticationHandler.proxyReply(exchange,
+                                "Basic realm=\"proxy\"");
+                        break;
+                    case 1:
+                        t3cond1.countDown();
+                        AuthenticationHandler.errorReply(exchange,
+                                "Basic realm=\"realm4\"");
+                        break;
+                    case 2:
+                        AuthenticationHandler.okReply(exchange);
+                        break;
+                    default:
+                        System.out.println ("Unexpected request");
+                }
             }
         }
 
-        void doT3bc (HttpTransaction req, int count) throws IOException {
-            switch (count) {
-            case 0:
-                proxyReply (req, "Basic realm=\"proxy\"");
-                break;
-            case 1:
-                okReply (req);
-                break;
-            default:
-                System.out.println ("Unexpected request");
+        class AuthenticationHandlerT3bc implements HttpHandler
+        {
+            volatile int count = -1;
+
+            @Override
+            public void handle(HttpExchange exchange) throws IOException {
+                count++;
+                switch(count) {
+                    case 0:
+                        AuthenticationHandler.proxyReply(exchange,
+                                "Basic realm=\"proxy\"");
+                        break;
+                    case 1:
+                        AuthenticationHandler.okReply(exchange);
+                        break;
+                    default:
+                        System.out.println ("Unexpected request");
+                }
             }
         }
-    };
+    }
+
+   static class AuthenticationHandler {
+       static void errorReply(HttpExchange exchange, String reply)
+               throws IOException
+       {
+           exchange.getResponseHeaders().add("Connection", "close");
+           exchange.getResponseHeaders().add("WWW-Authenticate", reply);
+           exchange.sendResponseHeaders(401, 0);
+           exchange.close();
+       }
+
+       static void proxyReply (HttpExchange exchange, String reply)
+               throws IOException
+       {
+           exchange.getResponseHeaders().add("Proxy-Authenticate", reply);
+           exchange.sendResponseHeaders(407, 0);
+       }
+
+       static void okReply (HttpExchange exchange) throws IOException {
+           exchange.getResponseHeaders().add("Connection", "close");
+           String response = "Hello .";
+           exchange.sendResponseHeaders(200, response.getBytes().length);
+           OutputStream os = exchange.getResponseBody();
+           os.write(response.getBytes());
+           os.close();
+           exchange.close();
+       }
+    }
 
     static HttpServer server;
     static MyAuthenticator auth = new MyAuthenticator ();
@@ -267,7 +391,14 @@
 
     static Client c1,c2,c3,c4,c5,c6,c7,c8,c9;
 
-    static void doServerTests (String authority) throws Exception {
+    static CountDownLatch t1cond1latch;
+    static CountDownLatch t1cond2latch;
+    static CountDownLatch t2condlatch;
+    static CountDownLatch t3cond1;
+
+    static void doServerTests (String authority, Server server) throws Exception
+    {
+
         System.out.println ("Doing Server tests");
         System.out.println ("T1");
         c1 = new Client (authority, "/test/realm1/t1a", false);
@@ -275,17 +406,20 @@
         c3 = new Client (authority, "/test/realm1/t1c", false);
         c4 = new Client (authority, "/test/realm2/t1d", false);
 
+        t1cond1latch = new CountDownLatch(1);
+        t1cond2latch = new CountDownLatch(1);
         c1.start(); c2.start();
-        HttpServer.waitForCondition ("cond1");
+        t1cond1latch.await();
         c3.start(); c4.start();
         c1.join(); c2.join(); c3.join(); c4.join();
 
         int f = auth.getCount();
         if (f != 2) {
-            except ("Authenticator was called "+f+" times. Should be 2");
+            except ("Authenticator was called "+f+" times. Should be 2",
+                    server);
         }
         if (error) {
-            except ("error occurred");
+            except ("error occurred", server);
         }
 
         auth.resetCount();
@@ -293,73 +427,71 @@
 
         c5 = new Client (authority, "/test/realm3/t2a", true);
         c6 = new Client (authority, "/test/realm3/t2b", false);
+        t2condlatch = new CountDownLatch(1);
         c5.start ();
-        HttpServer.waitForCondition ("T2cond1");
+        t2condlatch.await();
         c6.start ();
         c5.join(); c6.join();
 
         f = auth.getCount();
         if (f != redirects+1) {
-            except ("Authenticator was called "+f+" times. Should be: " + redirects+1);
+           except ("Authenticator was called "+f+" times. Should be: "
+                   + redirects+1, server);
         }
         if (error) {
-            except ("error occurred");
+            except ("error occurred", server);
         }
     }
 
-    static void doProxyTests (String authority) throws Exception {
+    static void doProxyTests (String authority, Server server) throws Exception
+    {
         System.out.println ("Doing Proxy tests");
         c7 = new Client (authority, "/test/realm4/t3a", false);
         c8 = new Client (authority, "/test/realm4/t3b", false);
         c9 = new Client (authority, "/test/realm4/t3c", false);
+        t3cond1 = new CountDownLatch(1);
         c7.start ();
-        HttpServer.waitForCondition ("T3cond1");
+        t3cond1.await();
         c8.start ();
         c9.start ();
         c7.join(); c8.join(); c9.join();
 
         int f = auth.getCount();
         if (f != 2) {
-            except ("Authenticator was called "+f+" times. Should be: " + 2);
+            except ("Authenticator was called "+f+" times. Should be: " + 2,
+                    server);
         }
         if (error) {
-            except ("error occurred");
+            except ("error occurred", server);
         }
     }
 
     public static void main (String[] args) throws Exception {
+        new B4769350().runTest(args[0].equals ("proxy"));
+    }
+
+    public void runTest(boolean proxy) throws Exception {
         System.setProperty ("http.maxRedirects", Integer.toString (redirects));
         System.setProperty ("http.auth.serializeRequests", "true");
         Authenticator.setDefault (auth);
-        boolean proxy = args[0].equals ("proxy");
-        try {
-            server = new HttpServer (new CallBack(), 10, 1, 0);
-            System.out.println ("Server: listening on port: " + server.getLocalPort());
+        try (Server server = new Server()) {
+            server.startServer();
+            System.out.println ("Server: listening on port: "
+                    + server.getPort());
             if (proxy) {
                 System.setProperty ("http.proxyHost", "localhost");
-                System.setProperty ("http.proxyPort",Integer.toString(server.getLocalPort()));
-                doProxyTests ("www.foo.com");
+                System.setProperty ("http.proxyPort",
+                        Integer.toString(server.getPort()));
+                doProxyTests ("www.foo.com", server);
             } else {
-                doServerTests ("localhost:"+server.getLocalPort());
+                doServerTests ("localhost:"+server.getPort(), server);
             }
-            server.terminate();
+        }
 
-        } catch (Exception e) {
-            if (server != null) {
-                server.terminate();
-            }
-            throw e;
-        }
     }
 
-    static void pause (int millis) {
-        try {
-            Thread.sleep (millis);
-        } catch (InterruptedException e) {}
-    }
-
-    public static void except (String s) {
-        server.terminate();
+    public static void except (String s, Server server) {
+        server.close();
         throw new RuntimeException (s);
     }
 
@@ -368,13 +500,10 @@
             super ();
         }
 
-        int count = 0;
+        volatile int count = 0;
 
+        @Override
         public PasswordAuthentication getPasswordAuthentication () {
-            //System.out.println ("Authenticator called: " + getRequestingPrompt());
-            //try {
-                //Thread.sleep (1000);
-            //} catch (InterruptedException e) {}
             PasswordAuthentication pw;
             pw = new PasswordAuthentication ("user", "pass1".toCharArray());
             count ++;
@@ -386,7 +515,7 @@
         }
 
         public int getCount () {
-            return (count);
+            return count;
         }
     }
 }
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/net/IDN/UseSTD3ASCIIRules.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,80 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 8023881
+ * @summary IDN.USE_STD3_ASCII_RULES option is too strict to use Unicode
+ *          in IDN.toASCII
+ */
+
+import java.net.*;
+
+public class UseSTD3ASCIIRules {
+
+    public static void main(String[] args) throws Exception {
+        // Per Section 4.1, RFC 3490, if the UseSTD3ASCIIRules flag is set,
+        // then perform these checks:
+        //
+        // (a) Verify the absence of non-LDH ASCII code points; that is, the
+        //     absence of 0..2C, 2E..2F, 3A..40, 5B..60, and 7B..7F.
+        //
+        // (b) Verify the absence of leading and trailing hyphen-minus; that
+        //     is, the absence of U+002D at the beginning and end of the
+        //     sequence.
+        String[] illegalNames = {
+                "www.example.com-",
+                "-www.example.com",
+                "-www.example.com-",
+                "www.ex\u002Cmple.com",
+                "www.ex\u007Bmple.com",
+                "www.ex\u007Fmple.com"
+            };
+
+        String[] legalNames = {
+                "www.ex-ample.com",
+                "www.ex\u002Dmple.com",         // www.ex-mple.com
+                "www.ex\u007Ample.com",         // www.exzmple.com
+                "www.ex\u3042mple.com",         // www.xn--exmple-j43e.com
+                "www.\u3042\u3044\u3046.com",   // www.xn--l8jeg.com
+                "www.\u793A\u4F8B.com"          // www.xn--fsq092h.com
+            };
+
+        for (String name : illegalNames) {
+            try {
+                System.out.println("Convering illegal IDN: " + name);
+                IDN.toASCII(name, IDN.USE_STD3_ASCII_RULES);
+                throw new Exception(
+                    "Expected to get IllegalArgumentException for " + name);
+            } catch (IllegalArgumentException iae) {
+                // That's the right behavior.
+            }
+        }
+
+        for (String name : legalNames) {
+            System.out.println("Convering legal IDN: " + name);
+            System.out.println("\tThe ACE form is: " +
+                        IDN.toASCII(name, IDN.USE_STD3_ASCII_RULES));
+        }
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/net/PlainSocketImpl/CustomSocketImplFactory.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,107 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 8024952
+ * @summary ClassCastException in PlainSocketImpl.accept() when using custom socketImpl
+ * @run main/othervm CustomSocketImplFactory
+ */
+
+import java.net.*;
+import java.io.*;
+
+public class CustomSocketImplFactory implements SocketImplFactory {
+
+    @Override
+    public SocketImpl createSocketImpl() {
+        try {
+            SocketImpl s = new CustomSocketImpl();
+            System.out.println("Created " + s);
+            return s;
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public static void main(String[] args) throws Exception {
+
+        Socket.setSocketImplFactory(new CustomSocketImplFactory());
+        try (ServerSocket ss = new ServerSocket(0)) {
+            ss.setSoTimeout(1);
+            ss.accept();
+            System.out.println("PASS");
+        } catch (SocketTimeoutException | NullPointerException e) {
+            // Not a real socket impl
+        }
+    }
+
+    class CustomSocketImpl extends SocketImpl {
+
+        public void create(boolean stream) throws IOException {
+        }
+
+        public void connect(String host, int port) throws IOException {
+        }
+
+        public void connect(InetAddress addr, int port) throws IOException {
+        }
+
+        public void connect(SocketAddress addr, int timeout) throws IOException {
+        }
+
+        public void bind(InetAddress host, int port) throws IOException {
+        }
+
+        public void listen(int backlog) throws IOException {
+        }
+
+        public void accept(SocketImpl s) throws IOException {
+        }
+
+        public InputStream getInputStream() throws IOException {
+            return null;
+        }
+
+        public OutputStream getOutputStream() throws IOException {
+            return null;
+        }
+
+        public int available() throws IOException {
+            return 0;
+        }
+
+        public void close() throws IOException {
+        }
+
+        public void sendUrgentData(int data) throws IOException {
+        }
+
+        public Object getOption(int i) throws SocketException {
+            return null;
+        }
+
+        public void setOption(int i, Object o) throws SocketException {
+        }
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/net/ServerSocket/AnotherSelectFdsLimit.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,78 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 8035897
+ * @summary FD_SETSIZE should be set on macosx
+ * @run main/othervm AnotherSelectFdsLimit 1023
+ * @run main/othervm AnotherSelectFdsLimit 1024
+ * @run main/othervm AnotherSelectFdsLimit 1025
+ * @run main/othervm AnotherSelectFdsLimit 1600
+ */
+
+import java.io.IOException;
+import java.net.ServerSocket;
+import java.net.SocketTimeoutException;
+import java.util.ArrayList;
+import java.util.List;
+
+public class AnotherSelectFdsLimit {
+    static final int DEFAULT_FDS_TO_USE = 1600;
+
+    public static void main(String [] args) throws Exception {
+        if (!System.getProperty("os.name").contains("OS X")) {
+            System.out.println("Test only run on MAC. Exiting.");
+            return;
+        }
+
+        int fdsToUse = DEFAULT_FDS_TO_USE;
+        if (args.length == 1)
+            fdsToUse = Integer.parseInt(args[0]);
+
+        System.out.println("Using " + fdsToUse + " fds.");
+
+        List<Thread> threads = new ArrayList<>();
+        for (int i=0; i<fdsToUse; i++)
+            threads.add(new WorkerThread());
+
+        for (Thread t : threads)
+            t.start();
+
+        for (Thread t : threads)
+            t.join();
+    }
+
+    static class WorkerThread extends Thread {
+        public void run() {
+            try (ServerSocket ss = new ServerSocket(0)) {
+                ss.setSoTimeout(2000);
+                ss.accept();
+            } catch (SocketTimeoutException x) {
+                // expected
+            } catch (IOException x) {
+                throw new RuntimeException(x);
+            }
+        }
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/net/ServerSocket/SelectFdsLimit.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,104 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 8021820
+ * @summary The total number of file descriptors is limited to
+ * 1024(FDSET_SIZE) on MacOSX (the size of fd array passed to select()
+ * call in java.net classes is limited to this value).
+ * @run main/othervm SelectFdsLimit
+ * @author aleksej.efimov@oracle.com
+ */
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.ServerSocket;
+import java.net.SocketTimeoutException;
+
+
+/*
+ * Test must be run in othervm mode to ensure that all files
+ * opened by openFiles() are closed propertly.
+*/
+public class SelectFdsLimit {
+    static final int FDTOOPEN = 1023;
+    static final String TESTFILE = "testfile";
+    static FileInputStream [] testFIS;
+
+    static void prepareTestEnv() throws IOException {
+            File fileToCreate = new File(TESTFILE);
+            if (!fileToCreate.exists())
+                if (!fileToCreate.createNewFile())
+                    throw new RuntimeException("Can't create test file");
+    }
+
+    //If there will be some problem (i.e. ulimits on number of opened files will fail)
+    //then this method will fail with exception and test will be considered as
+    //failed. But allocated fds will be released because the test is executed by
+    //dedicated VM (@run main/othervm).
+    static void openFiles(int fn, File f) throws FileNotFoundException, IOException {
+        testFIS = new FileInputStream[FDTOOPEN];
+        for (;;) {
+            if (0 == fn)
+                break;
+            FileInputStream fis = new FileInputStream(f);
+            testFIS[--fn] = fis;
+        }
+    }
+
+    public static void main(String [] args) throws IOException, FileNotFoundException {
+
+        //The bug 8021820 is a Mac specific and because of that test will pass on all
+        //other platforms
+        if (!System.getProperty("os.name").contains("OS X")) {
+           return;
+        }
+
+        //Create test directory with test files
+        prepareTestEnv();
+
+        //Consume FD ids for this java process to overflow the 1024
+        openFiles(FDTOOPEN,new File(TESTFILE));
+
+        //Wait for incoming connection and make the select() used in java.net
+        //classes fail the limitation on FDSET_SIZE
+        ServerSocket socket = new ServerSocket(0);
+
+        //Set the minimal timeout, no one is
+        //going to connect to this server socket
+        socket.setSoTimeout(1);
+
+        // The accept() call will throw SocketException if the
+        // select() has failed due to limitation on fds size,
+        // indicating test failure. A SocketTimeoutException
+        // is expected, so it is caught and ignored, and the test
+        // passes.
+        try {
+           socket.accept();
+        } catch (SocketTimeoutException e) { }
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/net/Socket/asyncClose/Race.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,77 @@
+/*
+ * Copyright (c) 2013, 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 8006395 8012244
+ * @summary Tests racing code that reads and closes a Socket
+ */
+
+import java.io.InputStream;
+import java.net.ServerSocket;
+import java.net.Socket;
+import java.net.SocketException;
+import java.util.concurrent.Phaser;
+
+// Racey test, will not always fail, but if it does then we have a problem.
+
+public class Race {
+    final static int THREADS = 100;
+
+    public static void main(String[] args) throws Exception {
+        try (ServerSocket ss = new ServerSocket(0)) {
+            final int port = ss.getLocalPort();
+            final Phaser phaser = new Phaser(THREADS + 1);
+            for (int i=0; i<100; i++) {
+                final Socket s = new Socket("localhost", port);
+                s.setSoLinger(false, 0);
+                try (Socket sa = ss.accept()) {
+                    sa.setSoLinger(false, 0);
+                    final InputStream is = s.getInputStream();
+                    Thread[] threads = new Thread[THREADS];
+                    for (int j=0; j<THREADS; j++) {
+                        threads[j] = new Thread() {
+                        public void run() {
+                            try {
+                                phaser.arriveAndAwaitAdvance();
+                                while (is.read() != -1)
+                                    Thread.sleep(50);
+                            } catch (Exception x) {
+                                if (!(x instanceof SocketException
+                                      && x.getMessage().equalsIgnoreCase("socket closed")))
+                                    x.printStackTrace();
+                                // ok, expect Socket closed
+                            }
+                        }};
+                    }
+                    for (int j=0; j<100; j++)
+                        threads[j].start();
+                    phaser.arriveAndAwaitAdvance();
+                    s.close();
+                    for (int j=0; j<100; j++)
+                        threads[j].join();
+                }
+            }
+        }
+    }
+}
--- ./jdk/test/java/net/URLClassLoader/closetest/CloseTest.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/test/java/net/URLClassLoader/closetest/CloseTest.java	Wed May 07 19:26:47 2014 -0700
@@ -25,7 +25,8 @@
  * @test
  * @bug 4167874
  * @library ../../../../com/sun/net/httpserver
- * @build FileServerHandler
+ * @library /lib/testlibrary
+ * @build FileServerHandler jdk.testlibrary.FileUtils
  * @run shell build.sh
  * @run main/othervm CloseTest
  * @summary URL-downloaded jar files can consume all available file descriptors
--- ./jdk/test/java/net/URLClassLoader/closetest/Common.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/test/java/net/URLClassLoader/closetest/Common.java	Wed May 07 19:26:47 2014 -0700
@@ -23,6 +23,9 @@
 
 import java.io.*;
 import java.net.*;
+import java.nio.file.Files;
+import jdk.testlibrary.FileUtils;
+import static java.nio.file.StandardCopyOption.*;
 
 public class Common {
 
@@ -39,42 +42,16 @@
             if (!src.isFile()) {
                 throw new RuntimeException ("File not found: " + src.toString());
             }
-            dst.delete();
-            dst.createNewFile();
-            FileInputStream i = new FileInputStream (src);
-            FileOutputStream o = new FileOutputStream (dst);
-            byte[] buf = new byte [1024];
-            int count;
-            while ((count=i.read(buf)) >= 0) {
-                o.write (buf, 0, count);
-            }
-            i.close();
-            o.close();
+            Files.copy(src.toPath(), dst.toPath(), REPLACE_EXISTING);
         } catch (IOException e) {
             throw new RuntimeException (e);
         }
     }
 
-    static void rm_minus_rf (File path) {
-        if (!path.exists()) {
+    static void rm_minus_rf (File path) throws IOException, InterruptedException {
+        if (!path.exists())
             return;
-        }
-        if (path.isFile()) {
-            if (!path.delete()) {
-                throw new RuntimeException ("Could not delete " + path);
-            }
-        } else if (path.isDirectory ()) {
-            String[] names = path.list();
-            File[] files = path.listFiles();
-            for (int i=0; i<files.length; i++) {
-                rm_minus_rf (new File(path, names[i]));
-            }
-            if (!path.delete()) {
-                throw new RuntimeException ("Could not delete " + path);
-            }
-        } else {
-            throw new RuntimeException ("Trying to delete something that isn't a file or a directory");
-        }
+        FileUtils.deleteFileTreeWithRetry(path.toPath());
     }
 
     static void copyDir (File src, File dst) {
--- ./jdk/test/java/net/URLClassLoader/closetest/GetResourceAsStream.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/test/java/net/URLClassLoader/closetest/GetResourceAsStream.java	Wed May 07 19:26:47 2014 -0700
@@ -24,6 +24,8 @@
 /**
  * @test
  * @bug 6899919
+ * @library /lib/testlibrary
+ * @build jdk.testlibrary.FileUtils
  * @run shell build2.sh
  * @run main/othervm GetResourceAsStream
  */
--- ./jdk/test/java/nio/channels/AsynchronousChannelGroup/Unbounded.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/test/java/nio/channels/AsynchronousChannelGroup/Unbounded.java	Wed May 07 19:26:47 2014 -0700
@@ -36,44 +36,31 @@
     // number of concurrent completion handlers
     static final int CONCURRENCY_COUNT = 256;
 
+    // set to true if an I/O operation fails
+    static volatile boolean failed;
+
+    // set to true when the test is done
+    static volatile boolean finished;
+
     public static void main(String[] args) throws Exception {
-        // all accepted connections are added to a queue
-        final ArrayBlockingQueue<AsynchronousSocketChannel> queue =
-            new ArrayBlockingQueue<AsynchronousSocketChannel>(CONCURRENCY_COUNT);
-
         // create listener to accept connections
-        final AsynchronousServerSocketChannel listener =
+        AsynchronousServerSocketChannel listener =
             AsynchronousServerSocketChannel.open()
                 .bind(new InetSocketAddress(0));
-        listener.accept((Void)null, new CompletionHandler<AsynchronousSocketChannel,Void>() {
-            public void completed(AsynchronousSocketChannel ch, Void att) {
-                queue.add(ch);
-                listener.accept((Void)null, this);
-            }
-            public void failed(Throwable exc, Void att) {
-            }
-        });
-        System.out.println("Listener created.");
 
-        // establish lots of connections
+        // establish connections
+
+        AsynchronousSocketChannel[] clients = new AsynchronousSocketChannel[CONCURRENCY_COUNT];
+        AsynchronousSocketChannel[] peers = new AsynchronousSocketChannel[CONCURRENCY_COUNT];
+
         int port = ((InetSocketAddress)(listener.getLocalAddress())).getPort();
         SocketAddress sa = new InetSocketAddress(InetAddress.getLocalHost(), port);
-        AsynchronousSocketChannel[] channels =
-            new AsynchronousSocketChannel[CONCURRENCY_COUNT];
+
         for (int i=0; i<CONCURRENCY_COUNT; i++) {
-            int attempts = 0;
-            for (;;) {
-                try {
-                    channels[i] = AsynchronousSocketChannel.open();
-                    channels[i].connect(sa).get();
-                    break;
-                } catch (IOException x) {
-                    // probably resource issue so back off and retry
-                    if (++attempts >= 3)
-                        throw x;
-                    Thread.sleep(50);
-                }
-            }
+            clients[i] = AsynchronousSocketChannel.open();
+            Future<Void> result = clients[i].connect(sa);
+            peers[i] = listener.accept().get();
+            result.get();
         }
         System.out.println("All connection established.");
 
@@ -81,9 +68,9 @@
         final CyclicBarrier barrier = new CyclicBarrier(CONCURRENCY_COUNT+1);
 
         // initiate a read operation on each channel.
-        for (int i=0; i<CONCURRENCY_COUNT; i++) {
+        for (AsynchronousSocketChannel client: clients) {
             ByteBuffer buf = ByteBuffer.allocateDirect(100);
-            channels[i].read( buf, channels[i],
+            client.read(buf, client,
                 new CompletionHandler<Integer,AsynchronousSocketChannel>() {
                     public void completed(Integer bytesRead, AsynchronousSocketChannel ch) {
                         try {
@@ -94,23 +81,29 @@
                         }
                     }
                     public void failed(Throwable exc, AsynchronousSocketChannel ch) {
+                        failed = true;
+                        System.err.println("read failed: " + exc);
+                        completed(0, ch);
                     }
                 });
         }
         System.out.println("All read operations outstanding.");
 
         // write data to each of the accepted connections
-        int remaining = CONCURRENCY_COUNT;
-        while (remaining > 0) {
-            AsynchronousSocketChannel ch = queue.take();
-            ch.write(ByteBuffer.wrap("welcome".getBytes())).get();
-            ch.close();
-            remaining--;
+        for (AsynchronousSocketChannel peer: peers) {
+            peer.write(ByteBuffer.wrap("welcome".getBytes())).get();
+            peer.shutdownOutput();
+            peer.close();
         }
 
         // wait for all threads to reach the barrier
         System.out.println("Waiting for all threads to reach barrier");
         barrier.await();
+
+        // finish up
+        finished = true;
         listener.close();
+        if (failed)
+            throw new RuntimeException("I/O operation failed, see log for details");
     }
 }
--- ./jdk/test/java/nio/channels/SocketChannel/ShortWrite.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/test/java/nio/channels/SocketChannel/ShortWrite.java	Wed May 07 19:26:47 2014 -0700
@@ -22,7 +22,7 @@
  */
 
 /* @test
- * @bug 7176630
+ * @bug 7176630 7074436
  * @summary Check for short writes on SocketChannels configured in blocking mode
  */
 
@@ -40,9 +40,10 @@
     /**
      * Returns a checksum on the remaining bytes in the given buffer.
      */
-    static long computeChecksum(ByteBuffer bb) {
+    static long computeChecksum(ByteBuffer... bufs) {
         CRC32 crc32 = new CRC32();
-        crc32.update(bb.array());
+        for (int i=0; i<bufs.length; i++)
+            crc32.update(bufs[i].array());
         return crc32.getValue();
     }
 
@@ -71,15 +72,15 @@
     }
 
     /**
-     * Run test with a write of the given number of bytes.
+     * Exercise write(ByteBuffer) with given number of bytes.
      */
-    static void test(ExecutorService pool,
-                     SocketChannel source,
-                     SocketChannel sink,
-                     int size)
+    static void test1(ExecutorService pool,
+                      SocketChannel source,
+                      SocketChannel sink,
+                      int size)
         throws Exception
     {
-        System.out.println(size);
+        System.out.println("write(ByteBuffer), size=" + size);
 
         // random bytes in the buffer
         ByteBuffer buf = ByteBuffer.allocate(size);
@@ -101,6 +102,47 @@
             throw new RuntimeException("Checksum did not match");
     }
 
+    /**
+     * Exercise write(ByteBuffer[]) with buffers of the given sizes.
+     */
+    static void testN(ExecutorService pool,
+                      SocketChannel source,
+                      SocketChannel sink,
+                      int... sizes)
+        throws Exception
+    {
+        System.out.print("write(ByteBuffer[]), sizes=");
+        for (int size: sizes)
+            System.out.print(size + " ");
+        System.out.println();
+
+        int total = 0;
+        int len = sizes.length;
+        ByteBuffer[] bufs = new ByteBuffer[len];
+        for (int i=0; i<len; i++) {
+            int size = sizes[i];
+            ByteBuffer buf = ByteBuffer.allocate(size);
+            rand.nextBytes(buf.array());
+            bufs[i] = buf;
+            total += size;
+        }
+
+        // submit task to read the bytes
+        Future<Long> result = pool.submit(new Reader(sink, total));
+
+        // write the bytes
+        long n = source.write(bufs);
+        if (n != total)
+            throw new RuntimeException("Short write detected");
+
+        // check the bytes that were received match
+        for (int i=0; i<len; i++)
+            bufs[i].rewind();
+        long expected = computeChecksum(bufs);
+        long actual = result.get();
+        if (actual != expected)
+            throw new RuntimeException("Checksum did not match");
+    }
 
     public static void main(String[] args) throws Exception {
         ExecutorService pool = Executors.newSingleThreadExecutor();
@@ -114,17 +156,47 @@
                 try (SocketChannel source = SocketChannel.open(sa);
                      SocketChannel sink = ssc.accept())
                 {
-                    // run tests on sizes around 128k as that is the problem
-                    // area on Windows.
+                    // Exercise write(BufferBuffer) on sizes around 128k
                     int BOUNDARY = 128 * 1024;
                     for (int size=(BOUNDARY-2); size<=(BOUNDARY+2); size++) {
-                        test(pool, source, sink, size);
+                        test1(pool, source, sink, size);
                     }
 
-                    // run tests on random sizes
+                    // Exercise write(BufferBuffer) on random sizes
                     for (int i=0; i<20; i++) {
                         int size = rand.nextInt(1024*1024);
-                        test(pool, source, sink, size);
+                        test1(pool, source, sink, size);
+                    }
+
+                    // Exercise write(BufferBuffer[]) on sizes around 128k
+                    for (int i=BOUNDARY-2; i<=BOUNDARY+2; i++) {
+                        testN(pool, source, sink, i);
+                        testN(pool, source, sink, 0, i);
+                        testN(pool, source, sink, i, 0);
+                        for (int j=BOUNDARY-2; j<=BOUNDARY+2; j++) {
+                            testN(pool, source, sink, i, j);
+                            testN(pool, source, sink, 0, i, j);
+                            testN(pool, source, sink, i, 0, j);
+                            testN(pool, source, sink, i, j, 0);
+                            for (int k=BOUNDARY-2; k<=BOUNDARY+2; k++) {
+                                testN(pool, source, sink, i, j, k);
+                                testN(pool, source, sink, 0, i, j, k);
+                                testN(pool, source, sink, i, 0, j, k);
+                                testN(pool, source, sink, i, j, 0, k);
+                                testN(pool, source, sink, i, j, k, 0);
+                            }
+                        }
+                    }
+
+                    // Exercise write(BufferBuffer[]) on random sizes
+                    // (assumes IOV_MAX >= 8)
+                    for (int i=0; i<20; i++) {
+                        int n = rand.nextInt(9);
+                        int[] sizes = new int[n];
+                        for (int j=0; j<n; j++) {
+                            sizes[j] = rand.nextInt(1024*1024);
+                        }
+                        testN(pool, source, sink, sizes);
                     }
                 }
             }
--- ./jdk/test/java/nio/file/Files/BytesAndLines.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/test/java/nio/file/Files/BytesAndLines.java	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2013 Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -22,7 +22,9 @@
  */
 
 /* @test
- * @bug 7006126
+ * @bug 7006126 8020669 8024788
+ * @build BytesAndLines PassThroughFileSystem
+ * @run main BytesAndLines
  * @summary Unit test for methods for Files readAllBytes, readAllLines and
  *     and write methods.
  */
@@ -82,6 +84,26 @@
             write(file, lines, Charset.defaultCharset(), opts);
             throw new RuntimeException("NullPointerException expected");
         } catch (NullPointerException ignore) { }
+
+        // read from procfs
+        if (System.getProperty("os.name").equals("Linux")) {
+            // Refer to the Linux proc(5) man page for details about /proc/self/stat file
+            // procfs reports it to be zero sized, even though data can be read from it
+            String statFile = "/proc/self/stat";
+            Path pathStat = Paths.get(statFile);
+            byte[] data = Files.readAllBytes(pathStat);
+            assertTrue(data.length > 0, "Files.readAllBytes('" + statFile + "') failed to read");
+        }
+
+        // test readAllBytes on custom file system
+        Path myfile = PassThroughFileSystem.create().getPath(file.toString());
+        for (int size=0; size<=1024; size+=512) {
+            byte[] b1 = new byte[size];
+            rand.nextBytes(b1);
+            Files.write(myfile, b1);
+            byte[] b2 = Files.readAllBytes(myfile);
+            assertTrue(Arrays.equals(b1, b2), "bytes not equal");
+        }
     }
 
 
@@ -174,6 +196,16 @@
                 throw new RuntimeException("NullPointerException expected");
             } catch (NullPointerException ignore) { }
 
+            // read from procfs
+            if (System.getProperty("os.name").equals("Linux")) {
+                // Refer to the Linux proc(5) man page for details about /proc/self/status file
+                // procfs reports this file to be zero sized, even though data can be read from it
+                String statusFile = "/proc/self/status";
+                Path pathStatus = Paths.get(statusFile);
+                lines = Files.readAllLines(pathStatus, US_ASCII);
+                assertTrue(lines.size() > 0, "Files.readAllLines('" + pathStatus + "') failed to read");
+            }
+
         } finally {
             delete(tmpfile);
         }
--- ./jdk/test/java/rmi/testlibrary/TestLibrary.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/test/java/rmi/testlibrary/TestLibrary.java	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1998, 2012, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -127,6 +127,33 @@
         bomb(null, e);
     }
 
+    /**
+     * Helper method to determine if registry has started
+     *
+     * @param port The port number to check
+     * @param msTimeout The amount of milliseconds to spend checking
+     */
+
+    public static boolean checkIfRegistryRunning(int port, int msTimeout) {
+        long stopTime = System.currentTimeMillis() + msTimeout;
+        do {
+            try {
+                Registry r = LocateRegistry.getRegistry(port);
+                String[] s = r.list();
+                // no exception. We're now happy that registry is running
+                return true;
+            } catch (RemoteException e) {
+                // problem - not ready ? Try again
+                try {
+                    Thread.sleep(500);
+                } catch (InterruptedException ie) {
+                    // not expected
+                }
+            }
+        } while (stopTime > System.currentTimeMillis());
+        return false;
+    }
+
     public static String getProperty(String property, String defaultVal) {
         final String prop = property;
         final String def = defaultVal;
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/util/Arrays/TimSortStackSize.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,123 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 8011944
+ * @summary Test TimSort stack size
+ */
+import java.util.Arrays;
+import java.util.ArrayDeque;
+import java.util.Comparator;
+
+public class TimSortStackSize {
+
+    public static void main(String[] args) {
+        testComparableTimSort();
+        testTimSort();
+    }
+
+    static void testComparableTimSort() {
+        System.out.printf("testComparableTimSort()%n");
+        Arrays.sort(genData());
+    }
+
+    static void testTimSort() {
+        System.out.printf("testTimSort()%n");
+        //Arrays.sort(genData(), Integer::compare);
+        Arrays.sort(genData(),
+            new java.util.Comparator<Integer>() {
+                public int compare(Integer a1, Integer a2){
+                    return Integer.compare(a1.intValue(), a2.intValue());
+                }
+            });
+    }
+
+    private static final int MIN = 16;
+
+    private static final int BOUND1 = 2 * MIN + 1;
+    private static final int BOUND2 = BOUND1 + MIN + 2;
+    private static final int BOUND3 = BOUND1 + 1 + BOUND2;
+    private static final int BOUND4 = BOUND2 + 1 + BOUND3;
+    private static final int BOUND5 = BOUND3 + 1 + BOUND4;
+
+    static int build(int size, int B, ArrayDeque<Integer> chunks) {
+        chunks.addFirst(B);
+        if (size < BOUND1) {
+            chunks.addFirst(size);
+            return size;
+        }
+
+        int asize = (size + 2) / 2;
+        if (size >= BOUND2 && asize < BOUND1) {
+            asize = BOUND1;
+        } else if (size >= BOUND3 && asize < BOUND2) {
+            asize = BOUND2;
+        } else if (size >= BOUND4 && asize < BOUND3) {
+            asize = BOUND3;
+        } else if (size >= BOUND5 && asize < BOUND4) {
+            asize = BOUND4;
+        }
+        if (size - asize >= B) {
+            throw new AssertionError(" " + size + " , " + asize + " , " + B);
+        }
+        return build(asize, size - asize, chunks);
+    }
+
+    static Integer[] genData() {
+        ArrayDeque<Integer> chunks = new ArrayDeque<Integer>();
+        chunks.addFirst(MIN);
+
+        int B = MIN + 4;
+        int A = B + MIN + 1;
+
+        for (int i = 0; i < 8; i++) {
+            int eps = build(A, B, chunks);
+            B = B + A + 1;
+            A = B + eps + 1;
+        }
+        chunks.addFirst(B);
+        chunks.addFirst(A);
+        int total = 0;
+        for (Integer len : chunks) {
+            total += len;
+        }
+        int pow = MIN;
+        while (pow < total) {
+            pow += pow;
+        }
+        chunks.addLast(pow - total);
+        System.out.println(" Total: " + total);
+        Integer[] array = new Integer[pow];
+        int off = 0;
+        int pos = 0;
+        for (Integer len : chunks) {
+            for (int i = 0; i < len; i++) {
+                array[pos++] = Integer.valueOf(i == 0 ? 0 : 1);
+            }
+            off++;
+        }
+        return array;
+    }
+
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/util/jar/JarInputStream/ExtraFileInMetaInf.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,71 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ *  @bug 8021788
+ *  @summary JarInputStream doesn't provide certificates for some file under META-INF
+ */
+
+import java.util.jar.*;
+import java.io.*;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipOutputStream;
+
+public class ExtraFileInMetaInf {
+    public static void main(String args[]) throws Exception {
+
+        // Create a zip file with 2 entries
+        try (ZipOutputStream zos =
+                     new ZipOutputStream(new FileOutputStream("x.jar"))) {
+            zos.putNextEntry(new ZipEntry("META-INF/SUB/file"));
+            zos.write(new byte[10]);
+            zos.putNextEntry(new ZipEntry("x"));
+            zos.write(new byte[10]);
+            zos.close();
+        }
+
+        // Sign it
+        new File("ks").delete();
+        sun.security.tools.KeyTool.main(
+                ("-keystore ks -storepass changeit -keypass changeit " +
+                        "-alias a -dname CN=A -genkeypair").split(" "));
+        sun.security.tools.JarSigner.main(
+                "-keystore ks -storepass changeit x.jar a".split(" "));
+
+        // Check if the entries are signed
+        try (JarInputStream jis =
+                     new JarInputStream(new FileInputStream("x.jar"))) {
+            JarEntry je;
+            while ((je = jis.getNextJarEntry()) != null) {
+                String name = je.toString();
+                if (name.equals("META-INF/SUB/file") || name.equals("x")) {
+                    while (jis.read(new byte[1000]) >= 0);
+                    if (je.getCertificates() == null) {
+                        throw new Exception(name + " not signed");
+                    }
+                }
+            }
+        }
+    }
+}
--- ./jdk/test/java/util/logging/LevelResourceBundle.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/test/java/util/logging/LevelResourceBundle.java	Wed May 07 19:26:47 2014 -0700
@@ -33,15 +33,19 @@
 
 public class LevelResourceBundle {
     public static void main(String args[]) throws Exception {
-        final String name = "SEVERE";
-        String en = getLocalizedMessage(Locale.getDefault(), name);
-        String fr = getLocalizedMessage(Locale.FRANCE, name);
+        final String key = "SEVERE";
+        final String name = "Severe";
+        String en = getLocalizedMessage(Locale.getDefault(), key);
+        String fr = getLocalizedMessage(Locale.FRANCE, key);
         if (!name.equals(en)) {
              throw new RuntimeException("Expect " + name + " equals " + en);
         }
         if (name.equals(fr)) {
              throw new RuntimeException("Expect " + name + " not equals " + fr);
         }
+        if (key.equals(fr)) {
+             throw new RuntimeException("Expect " + key + " not equals " + fr);
+        }
     }
 
     private static final String RBNAME = "sun.util.logging.resources.logging";
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/util/logging/LocalizedLevelName.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,103 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import java.util.*;
+import java.util.logging.*;
+
+/*
+ * @test
+ * @bug 8016127 8024131
+ * @summary test logging.properties localized
+ * @run main/othervm LocalizedLevelName
+ */
+
+public class LocalizedLevelName {
+    private static Object[] namesMap = {
+        "SEVERE",  Locale.ENGLISH, "Severe",        Level.SEVERE,
+        "WARNING", Locale.FRENCH,  "Avertissement", Level.WARNING,
+        "INFO",    Locale.ITALIAN, "Informazioni",  Level.INFO,
+        "SEVERE",  Locale.FRENCH,  "Grave",         Level.SEVERE,
+        "CONFIG",  Locale.GERMAN,  "Konfiguration", Level.CONFIG,
+        "ALL",     Locale.ROOT,    "All",           Level.ALL,
+        "SEVERE",  Locale.ROOT,    "Severe",        Level.SEVERE,
+        "WARNING", Locale.ROOT,    "Warning",       Level.WARNING,
+        "CONFIG",  Locale.ROOT,    "Config",        Level.CONFIG,
+        "INFO",    Locale.ROOT,    "Info",          Level.INFO,
+        "FINE",    Locale.ROOT,    "Fine",          Level.FINE,
+        "FINER",   Locale.ROOT,    "Finer",         Level.FINER,
+        "FINEST",  Locale.ROOT,    "Finest",        Level.FINEST
+    };
+
+    public static void main(String args[]) throws Exception {
+        Locale defaultLocale = Locale.getDefault();
+        for (int i=0; i<namesMap.length; i += 4) {
+            final String key = (String) namesMap[i];
+            final Locale locale = (Locale) namesMap[i+1];
+            final String expectedTranslation = (String) namesMap[i+2];
+            final Level level = (Level) namesMap[i+3];
+
+            final String en = getLocalizedMessage(Locale.ENGLISH, key);
+            final String other = getLocalizedMessage(locale, key);
+
+            System.out.println(locale + ": " + key + "=" + expectedTranslation
+                    + ", (Level." + level.getName() + ")");
+            System.out.println("     => localized(" + Locale.ENGLISH + ", "
+                    + key + ")=" + en);
+            System.out.println("     => localized(" + locale + ", " + key
+                    + ")=" + other);
+            if (!key.equals(en.toUpperCase(Locale.ROOT))) {
+                throw new RuntimeException("Expect " + key
+                        + " equals upperCase(" + en + ")");
+            }
+            if (!Locale.ENGLISH.equals(locale) && !Locale.ROOT.equals(locale)
+                    && key.equals(other.toUpperCase(Locale.ROOT))) {
+                throw new RuntimeException("Expect " + key
+                        + " not equals upperCase(" + other +")");
+            }
+            if ((Locale.ENGLISH.equals(locale) || Locale.ROOT.equals(locale))
+                    && !key.equals(other.toUpperCase(Locale.ROOT))) {
+                throw new RuntimeException("Expect " + key
+                        + " equals upperCase(" + other +")");
+            }
+            if (!other.equals(expectedTranslation)) {
+                throw new RuntimeException("Expected \"" + expectedTranslation
+                        + "\" for '" + locale + "' but got \"" + other + "\"");
+            }
+            Locale.setDefault(locale);
+            final String levelName = level.getLocalizedName();
+            System.out.println("Level.getLocalizedName() is: " + levelName);
+            if (!levelName.equals(other.toUpperCase(locale))) {
+                throw new RuntimeException("Expected \""
+                        + other.toUpperCase(locale) + "\" for '"
+                        + locale + "' but got \"" + levelName + "\"");
+            }
+            Locale.setDefault(defaultLocale);
+       }
+    }
+
+    private static final String RBNAME = "sun.util.logging.resources.logging";
+    private static String getLocalizedMessage(Locale locale, String key) {
+        ResourceBundle rb = ResourceBundle.getBundle(RBNAME, locale);
+        return rb.getString(key);
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/util/logging/TestGetLoggerNPE.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,91 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+import java.io.PrintStream;
+import java.security.Permission;
+import java.security.Policy;
+import java.security.ProtectionDomain;
+import java.util.logging.LogManager;
+import java.util.logging.Logger;
+import sun.awt.SunToolkit;
+
+/*
+ * @test
+ * @bug 8025512
+ *
+ * @summary NPE with logging while launching webstart
+ *
+ * @build TestGetLoggerNPE
+ * @run main/othervm TestGetLoggerNPE getLogger
+ * @run main/othervm TestGetLoggerNPE getLogManager
+ */
+public class TestGetLoggerNPE {
+    static volatile Throwable thrown = null;
+    static volatile sun.awt.AppContext context = null;
+    public static void main(String[] args) throws Exception {
+        final String testCase = args.length == 0 ? "getLogger" : args[0];
+        final ThreadGroup tg = new ThreadGroup("TestGroup");
+        Thread t = new Thread(tg, "test") {
+            public void run() {
+                try {
+                    context = SunToolkit.createNewAppContext();
+                    final PrintStream out = System.out;
+                    System.setOut(null);
+                    try {
+                        if ("getLogger".equals(testCase)) {
+                           Logger.getLogger("sun.plugin");
+                        } else {
+                           LogManager.getLogManager();
+                        }
+                    } finally {
+                        System.setOut(out);
+                    }
+
+                    System.out.println(Logger.global);
+                } catch (Throwable x) {
+                    x.printStackTrace();
+                    thrown = x;
+                }
+            }
+        };
+        Policy.setPolicy(new Policy() {
+             public boolean implies(ProtectionDomain domain,
+                                    Permission permission) {
+                 return true; // all permissions
+             }
+        });
+        System.setSecurityManager(new SecurityManager());
+        t.start();
+        t.join();
+        if (context != null && !context.isDisposed()) {
+            context.dispose();
+        }
+        if (thrown == null) {
+            System.out.println("PASSED: " + testCase);
+        } else {
+            System.err.println("FAILED: " + testCase);
+            throw new Error("Test failed: " + testCase + " - " + thrown, thrown);
+        }
+
+    }
+
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/util/logging/TestLogConfigurationDeadLock.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,256 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+import java.lang.management.ManagementFactory;
+import java.lang.management.ThreadInfo;
+import java.security.Permission;
+import java.security.Policy;
+import java.security.ProtectionDomain;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.logging.LogManager;
+import java.util.logging.Logger;
+
+
+/**
+ * @test
+ * @bug 8029281 8027670
+ * @summary Synchronization issues in Logger and LogManager. This test
+ *       focusses more particularly on potential deadlock in
+ *       drainLoggerRefQueueBounded / readConfiguration
+ * @run main/othervm TestLogConfigurationDeadLock
+ * @author danielfuchs
+ */
+// This test is a best effort to try & detect issues. The test itself will run
+// for 8secs. This is usually unsufficient to detect issues.
+// To get a greater confidence it is recommended to run this test in a loop:
+// e.g. use something like:
+// $ while jtreg -jdk:$JDK -verbose:all  \
+//      test/java/util/logging/TestLogConfigurationDeadLock.java ; \
+//      do echo Running test again ; done
+// and let it run for a few hours...
+//
+public class TestLogConfigurationDeadLock {
+
+    static volatile Exception thrown = null;
+    static volatile boolean goOn = true;
+
+    static final int READERS = 2;
+    static final int LOGGERS = 2;
+    static final long TIME = 4 * 1000; // 4 sec.
+    static final long STEP = 1 * 1000;  // message every 1 sec.
+    static final int  LCOUNT = 50; // 50 loggers created in a row...
+    static final AtomicLong nextLogger = new AtomicLong(0);
+    static final AtomicLong readCount = new AtomicLong(0);
+    static final AtomicLong checkCount = new AtomicLong(0);
+
+    /**
+     * This test will run both with and without a security manager.
+     *
+     * The test starts a number of threads that will call
+     *     LogManager.readConfiguration() concurrently (ReadConf), then starts
+     *     a number of threads that will create new loggers concurrently
+     *     (AddLogger), and then two additional threads: one (Stopper) that
+     *     will stop the test after 4secs (TIME ms), and one DeadlockDetector
+     *     that will attempt to detect deadlocks.
+     * If after 4secs no deadlock was detected and no exception was thrown
+     * then the test is considered a success and passes.
+     *
+     * This procedure is done twice: once without a security manager and once
+     * again with a security manager - which means the test takes ~8secs to
+     * run.
+     *
+     * Note that 8sec may not be enough to detect issues if there are some.
+     * This is a best effort test.
+     *
+     * @param args the command line arguments
+     */
+    public static void main(String[] args) throws Exception {
+
+        // test without security
+        System.out.println("No security");
+        test();
+
+        // test with security
+        System.out.println("\nWith security");
+        Policy.setPolicy(new Policy() {
+            @Override
+            public boolean implies(ProtectionDomain domain, Permission permission) {
+                if (super.implies(domain, permission)) return true;
+                // System.out.println("Granting " + permission);
+                return true; // all permissions
+            }
+        });
+        System.setSecurityManager(new SecurityManager());
+        test();
+    }
+
+    /**
+     * Starts all threads, wait 4secs, then stops all threads.
+     * @throws Exception if a deadlock was detected or an error occurred.
+     */
+    public static void test() throws Exception {
+          goOn = true;
+          thrown = null;
+          long sNextLogger = nextLogger.get();
+          long sReadCount  = readCount.get();
+          long sCheckCount = checkCount.get();
+          List<Thread> threads = new ArrayList<>();
+          for (int i = 0; i<READERS; i++) {
+              threads.add(new ReadConf());
+          }
+          for (int i = 0; i<LOGGERS; i++) {
+              threads.add(new AddLogger());
+          }
+          threads.add(new DeadlockDetector());
+          threads.add(0, new Stopper(TIME));
+          for (Thread t : threads) {
+              t.start();
+          }
+          for (Thread t : threads) {
+              try {
+                  t.join();
+              } catch (Exception x) {
+                  fail(x);
+              }
+          }
+          if (thrown != null) {
+              throw thrown;
+          }
+          System.out.println("Passed: " + (nextLogger.get() - sNextLogger)
+                  + " loggers created by " + LOGGERS + " Thread(s),");
+          System.out.println("\t LogManager.readConfiguration() called "
+                  + (readCount.get() - sReadCount) + " times by " + READERS
+                  + " Thread(s).");
+          System.out.println("\t ThreadMXBean.findDeadlockedThreads called "
+                  + (checkCount.get() -sCheckCount) + " times by 1 Thread.");
+
+    }
+
+
+    final static class ReadConf extends Thread {
+        @Override
+        public void run() {
+            while (goOn) {
+                try {
+                    LogManager.getLogManager().readConfiguration();
+                    readCount.incrementAndGet();
+                    Thread.sleep(1);
+                } catch (Exception x) {
+                    fail(x);
+                }
+            }
+        }
+    }
+
+    final static class AddLogger extends Thread {
+        @Override
+        public void run() {
+            try {
+                while (goOn) {
+                    Logger l;
+                    Logger foo = Logger.getLogger("foo");
+                    Logger bar = Logger.getLogger("foo.bar");
+                    for (int i=0; i < LCOUNT ; i++) {
+                        l = Logger.getLogger("foo.bar.l"+nextLogger.incrementAndGet());
+                        l.fine("I'm fine");
+                        if (!goOn) break;
+                        Thread.sleep(1);
+                    }
+                }
+            } catch (InterruptedException | RuntimeException x ) {
+                fail(x);
+            }
+        }
+    }
+
+    final static class DeadlockDetector extends Thread {
+
+        @Override
+        public void run() {
+            while(goOn) {
+                try {
+                    long[] ids = ManagementFactory.getThreadMXBean().findDeadlockedThreads();
+                    checkCount.incrementAndGet();
+                    ids = ids == null ? new long[0] : ids;
+                    if (ids.length == 1) {
+                        throw new RuntimeException("Found 1 deadlocked thread: "+ids[0]);
+                    } else if (ids.length > 0) {
+                        ThreadInfo[] infos = ManagementFactory.getThreadMXBean()
+                            .getThreadInfo(ids, Integer.MAX_VALUE);
+                        System.err.println("Found "+ids.length+" deadlocked threads: ");
+                        for (ThreadInfo inf : infos) {
+                            System.err.println(inf.toString());
+                        }
+                        throw new RuntimeException("Found "+ids.length+" deadlocked threads");
+                    }
+                    Thread.sleep(100);
+                } catch(InterruptedException | RuntimeException x) {
+                    fail(x);
+                }
+            }
+        }
+
+    }
+
+    static final class Stopper extends Thread {
+        long start;
+        long time;
+
+        Stopper(long time) {
+            start = System.currentTimeMillis();
+            this.time = time;
+        }
+
+        @Override
+        public void run() {
+            try {
+                long rest, previous;
+                previous = time;
+                while (goOn && (rest = start - System.currentTimeMillis() + time) > 0) {
+                    if (previous == time || previous - rest >= STEP) {
+                        Logger.getLogger("remaining").info(String.valueOf(rest)+"ms remaining...");
+                        previous = rest == time ? rest -1 : rest;
+                        System.gc();
+                    }
+                    if (goOn == false) break;
+                    Thread.sleep(Math.min(rest, 100));
+                }
+                System.out.println(System.currentTimeMillis() - start
+                        + " ms elapsed ("+time+ " requested)");
+                goOn = false;
+            } catch(InterruptedException | RuntimeException x) {
+                fail(x);
+            }
+        }
+
+    }
+
+    static void fail(Exception x) {
+        x.printStackTrace();
+        if (thrown == null) {
+            thrown = x;
+        }
+        goOn = false;
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/util/logging/TestLogConfigurationDeadLockWithConf.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,340 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+import java.io.File;
+import java.io.PrintStream;
+import java.lang.management.ManagementFactory;
+import java.lang.management.ThreadInfo;
+import java.security.Permission;
+import java.security.Policy;
+import java.security.ProtectionDomain;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Random;
+import java.util.Set;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.logging.Level;
+import java.util.logging.LogManager;
+import java.util.logging.Logger;
+
+
+/**
+ * @test
+ * @bug 8027670 8029281
+ * @summary Deadlock in drainLoggerRefQueueBounded / readConfiguration
+ *          caused by synchronization issues in Logger and LogManager.
+ * @run main/othervm TestLogConfigurationDeadLockWithConf
+ * @author danielfuchs
+ */
+// This test is a best effort to try & detect issues. The test itself will run
+// for 8secs. This is usually sufficient to detect issues.
+// However to get a greater confidence it is recommended to run this test in a loop:
+// e.g. use something like:
+// $ while jtreg -jdk:$JDK -verbose:all  \
+//      test/java/util/logging/TestLogConfigurationDeadLockWithConf.java ; \
+//      do echo Running test again ; done
+// and let it run for a few hours...
+//
+public class TestLogConfigurationDeadLockWithConf {
+
+    static volatile Exception thrown = null;
+    static volatile boolean goOn = true;
+
+    static final int READERS = 2;
+    static final int LOGGERS = 2;
+    static final long TIME = 4 * 1000; // 4 sec.
+    static final long STEP = 1 * 1000;  // message every 1 sec.
+    static final int  LCOUNT = 50; // 50 loggers created in a row...
+    static final AtomicLong nextLogger = new AtomicLong(0);
+    static final AtomicLong readCount = new AtomicLong(0);
+    static final AtomicLong checkCount = new AtomicLong(0);
+
+    /**
+     * This test will run both with and without a security manager.
+     *
+     * The test starts a number of threads that will call
+     *     LogManager.readConfiguration() concurrently (ReadConf), then starts
+     *     a number of threads that will create new loggers concurrently
+     *     (AddLogger), and then two additional threads: one (Stopper) that
+     *     will stop the test after 4secs (TIME ms), and one DeadlockDetector
+     *     that will attempt to detect deadlocks.
+     * If after 4secs no deadlock was detected and no exception was thrown
+     * then the test is considered a success and passes.
+     *
+     * This procedure is done twice: once without a security manager and once
+     * again with a security manager - which means the test takes ~8secs to
+     * run.
+     *
+     * Note that 8sec may not be enough to detect issues if there are some.
+     * This is a best effort test.
+     *
+     * @param args the command line arguments
+     * @throws java.lang.Exception if the test fails.
+     */
+    public static void main(String[] args) throws Exception {
+        File config =  new File(System.getProperty("test.src", "."),
+                        "deadlockconf.properties");
+        if (!config.canRead()) {
+            System.err.println("Can't read config file: test cannot execute.");
+            System.err.println("Please check your test environment: ");
+            System.err.println("\t -Dtest.src=" + System.getProperty("test.src", "."));
+            System.err.println("\t config file is: " + config.getAbsolutePath());
+            throw new RuntimeException("Can't read config file: "
+                + config.getAbsolutePath());
+        }
+
+        System.setProperty("java.util.logging.config.file",
+               config.getAbsolutePath());
+
+        // test without security
+        System.out.println("No security");
+        test();
+
+        // test with security
+        System.out.println("\nWith security");
+        Policy.setPolicy(new Policy() {
+            @Override
+            public boolean implies(ProtectionDomain domain, Permission permission) {
+                if (super.implies(domain, permission)) return true;
+                // System.out.println("Granting " + permission);
+                return true; // all permissions
+            }
+        });
+        System.setSecurityManager(new SecurityManager());
+        test();
+    }
+
+    static Random rand = new Random(System.currentTimeMillis());
+    private static int getBarCount() {
+        return rand.nextInt(10);
+    }
+
+    /**
+     * Starts all threads, wait 4secs, then stops all threads.
+     * @throws Exception if a deadlock was detected or an error occurred.
+     */
+    public static void test() throws Exception {
+          goOn = true;
+          thrown = null;
+          long sNextLogger = nextLogger.get();
+          long sReadCount  = readCount.get();
+          long sCheckCount = checkCount.get();
+          List<Thread> threads = new ArrayList<>();
+          for (int i = 0; i<READERS; i++) {
+              threads.add(new ReadConf());
+          }
+          for (int i = 0; i<LOGGERS; i++) {
+              threads.add(new AddLogger());
+          }
+          DeadlockDetector detector = new DeadlockDetector();
+          threads.add(detector);
+          threads.add(0, new Stopper(TIME));
+          for (Thread t : threads) {
+              t.start();
+          }
+
+          // wait for the detector to finish.
+          detector.join();
+
+          final PrintStream out = thrown == null ? System.out : System.err;
+
+          // Try to wait for all threads to finish.
+          // This is a best effort: if some threads are in deadlock we can't
+          //    obviously wait for them, and other threads may have joined in
+          //    the deadlock since we last checked.
+          //    However, all threads which are succeptible of deadlocking
+          //    extend DeamonThread.
+          for (Thread t : threads) {
+              if (t == detector) {
+                  continue;
+              }
+              if (detector.deadlocked.contains(t.getId())) {
+                  out.println("Skipping deadlocked thread "
+                          + t.getClass().getSimpleName() + ": " + t);
+                  continue; // don't wait for deadlocked thread: they won't terminate
+              }
+              try {
+                  if (detector.deadlocked.isEmpty()) {
+                      t.join();
+                  } else {
+                      if (t instanceof DaemonThread) {
+                          // Some other threads may have join the deadlock.
+                          // don't wait forever.
+                          t.join(100);
+                      } else {
+                          // Those threads that don't extend DaemonThread
+                          // should be safe from deadlock.
+                          out.println("Waiting for "
+                                  + t.getClass().getSimpleName() + ": " + t);
+                          t.join();
+                      }
+                  }
+              } catch (Exception x) {
+                  fail(x);
+              }
+          }
+          out.println("All threads joined.");
+
+          final String status = thrown == null ? "Passed" : "FAILED";
+
+          out.println(status + ": " + (nextLogger.get() - sNextLogger)
+                  + " loggers created by " + LOGGERS + " Thread(s),");
+          out.println("\t LogManager.readConfiguration() called "
+                  + (readCount.get() - sReadCount) + " times by " + READERS
+                  + " Thread(s).");
+          out.println("\t ThreadMXBean.findDeadlockedThreads called "
+                  + (checkCount.get() -sCheckCount) + " times by 1 Thread.");
+
+          if (thrown != null) {
+              out.println("\t Error is: "+thrown.getMessage());
+              throw thrown;
+          }
+    }
+
+    static class DaemonThread extends Thread {
+        public DaemonThread() {
+            this.setDaemon(true);
+        }
+    }
+
+    final static class ReadConf extends DaemonThread {
+        @Override
+        public void run() {
+            while (goOn) {
+                try {
+                    LogManager.getLogManager().readConfiguration();
+                    readCount.incrementAndGet();
+                    Thread.sleep(1);
+                } catch (Exception x) {
+                    fail(x);
+                }
+            }
+        }
+    }
+
+    final static class AddLogger extends DaemonThread {
+        @Override
+        public void run() {
+            try {
+                while (goOn) {
+                    Logger l;
+                    int barcount = getBarCount();
+                    for (int i=0; i < LCOUNT ; i++) {
+                        l = Logger.getLogger("foo.bar"+barcount+".l"+nextLogger.incrementAndGet());
+                        l.fine("I'm fine");
+                        if (!goOn) break;
+                        Thread.sleep(1);
+                    }
+                }
+            } catch (InterruptedException | RuntimeException x ) {
+                fail(x);
+            }
+        }
+    }
+
+    final static class DeadlockDetector extends Thread {
+
+        final Set<Long> deadlocked = Collections.synchronizedSet(new HashSet<Long>());
+
+        static List<Long> asList(long... ids) {
+            final List<Long> list = new ArrayList<>(ids.length);
+            for (long id : ids) {
+                list.add(id);
+            }
+            return list;
+        }
+
+        @Override
+        public void run() {
+            while(goOn) {
+                try {
+                    long[] ids = ManagementFactory.getThreadMXBean().findDeadlockedThreads();
+                    checkCount.incrementAndGet();
+                    ids = ids == null ? new long[0] : ids;
+                    if (ids.length > 0) {
+                        deadlocked.addAll(asList(ids));
+                    }
+                    if (ids.length == 1) {
+                        throw new RuntimeException("Found 1 deadlocked thread: "+ids[0]);
+                    } else if (ids.length > 0) {
+                        ThreadInfo[] infos = ManagementFactory.getThreadMXBean().getThreadInfo(ids, Integer.MAX_VALUE);
+                        System.err.println("Found "+ids.length+" deadlocked threads: ");
+                        for (ThreadInfo inf : infos) {
+                            System.err.println(inf.toString());
+                        }
+                        throw new RuntimeException("Found "+ids.length+" deadlocked threads");
+                    }
+                    Thread.sleep(100);
+                } catch(InterruptedException | RuntimeException x) {
+                    fail(x);
+                }
+            }
+        }
+
+    }
+
+    static final class Stopper extends Thread {
+        long start;
+        long time;
+
+        static final Logger logger = Logger.getLogger("remaining");
+
+        Stopper(long time) {
+            start = System.currentTimeMillis();
+            this.time = time;
+        }
+
+        @Override
+        public void run() {
+            try {
+                long rest, previous;
+                previous = time;
+                while (goOn && (rest = start - System.currentTimeMillis() + time) > 0) {
+                    if (previous == time || previous - rest >= STEP) {
+                        logger.log(Level.INFO,
+                                "{0}ms remaining...", String.valueOf(rest));
+                        previous = rest == time ? rest -1 : rest;
+                        System.gc();
+                    }
+                    if (goOn == false) break;
+                    Thread.sleep(Math.min(rest, 100));
+                }
+                System.out.println(System.currentTimeMillis() - start
+                        + " ms elapsed ("+time+ " requested)");
+                goOn = false;
+            } catch(InterruptedException | RuntimeException x) {
+                fail(x);
+            }
+        }
+
+    }
+
+    static void fail(Exception x) {
+        x.printStackTrace();
+        if (thrown == null) {
+            thrown = x;
+        }
+        goOn = false;
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/util/logging/TestLoggerBundleSync.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,535 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import java.lang.management.ManagementFactory;
+import java.lang.management.ThreadInfo;
+import java.security.Permission;
+import java.security.Policy;
+import java.security.ProtectionDomain;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.ListResourceBundle;
+import java.util.Objects;
+import java.util.ResourceBundle;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.FutureTask;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.logging.Handler;
+import java.util.logging.Level;
+import java.util.logging.LogRecord;
+import java.util.logging.Logger;
+
+/**
+ * @test
+ * @bug 8029281 8028763
+ * @summary Attempts to detect synchronization issues with getResourceBundle()
+ *          and getResourceBundleName(). It might also detect issues in the way
+ *          that the logger tree is cleaned up after a logger has been garbage
+ *          collected. This test helped find the root cause of 8029092, so if
+ *          this test fails one might also expect failures in
+ *          java/util/logging/Logger/logrb/TestLogrbResourceBundle.java and
+ *          java/util/logging/Logger/setResourceBundle/TestSetResourceBundle.java.
+ *          Note that this is a best effort test. Running it in a loop to
+ *          reproduce intermittent issues can be a good idea.
+ * @run main/othervm TestLoggerBundleSync
+ * @author danielfuchs
+ */
+public class TestLoggerBundleSync {
+
+    static volatile Exception thrown = null;
+    static volatile boolean goOn = true;
+
+    static final int READERS = 3;
+    static final long TIME = 4 * 1000; // 4 sec.
+    static final long STEP = 1 * 1000;  // message every 1 sec.
+    static final int  LCOUNT = 50; // change bundle 50 times...
+    static final AtomicLong setRBcount = new AtomicLong(0);
+    static final AtomicLong setRBNameCount = new AtomicLong(0);
+    static final AtomicLong getRBcount = new AtomicLong(0);
+    static final AtomicLong checkCount = new AtomicLong(0);
+    static final AtomicLong nextLong = new AtomicLong(0);
+
+    public static class MyBundle extends ListResourceBundle {
+        @Override
+        protected Object[][] getContents() {
+            return new Object[][] {
+               {"dummy", "foo"}
+            };
+        }
+    }
+
+    public static final class MyBundle1 extends MyBundle { };
+    public static final class MyBundle2 extends MyBundle { };
+    public static final class MyBundle3 extends MyBundle { };
+
+
+    public static final class LoggerRB {
+        public final String resourceBundleName;
+        public final ResourceBundle userBundle;
+        public LoggerRB(String name, ResourceBundle bundle) {
+            resourceBundleName = name;
+            userBundle = bundle;
+        }
+    }
+
+    static final List<Class<? extends ResourceBundle>> classes = new ArrayList<>();
+    static {
+        classes.add(MyBundle1.class);
+        classes.add(MyBundle2.class);
+        classes.add(MyBundle3.class);
+    }
+
+
+    /**
+     * This test will run both with and without a security manager.
+     *
+     * The test starts a number of threads that will attempt to concurrently
+     * set resource bundles on Logger, and verifies the consistency of the
+     * obtained results.
+     *
+     * This is a best effort test.
+     *
+     * @param args the command line arguments
+     */
+    public static void main(String[] args) throws Exception {
+
+        try {
+            // test without security
+            System.out.println("No security");
+            test();
+
+            // test with security
+            System.out.println("\nWith security");
+            Policy.setPolicy(new Policy() {
+                @Override
+                public boolean implies(ProtectionDomain domain, Permission permission) {
+                    if (super.implies(domain, permission)) return true;
+                    // System.out.println("Granting " + permission);
+                    return true; // all permissions
+                }
+            });
+            System.setSecurityManager(new SecurityManager());
+            test();
+        } finally {
+            SetRB.executor.shutdownNow();
+            SetRBName.executor.shutdownNow();
+        }
+    }
+
+    /**
+     * Starts all threads, wait 15secs, then stops all threads.
+     * @throws Exception if a deadlock was detected or an error occurred.
+     */
+    public static void test() throws Exception {
+          goOn = true;
+          thrown = null;
+          long sGetRBCount = getRBcount.get();
+          long sSetRBCount  = setRBcount.get();
+          long sSetRBNameCount  = setRBNameCount.get();
+          long sCheckCount = checkCount.get();
+          long sNextLong = nextLong.get();
+          List<Thread> threads = new ArrayList<>();
+          for (Class<? extends ResourceBundle> type : classes) {
+              threads.add(new SetRB(type));
+              threads.add(new SetRBName(type));
+          }
+          for (int i =0 ; i < READERS ; i++) {
+              threads.add(new GetRB());
+          }
+          threads.add(new DeadlockDetector());
+          threads.add(0, new Stopper(TIME));
+          for (Thread t : threads) {
+              t.start();
+          }
+          for (Thread t : threads) {
+              try {
+                  t.join();
+              } catch (Exception x) {
+                  fail(x);
+              }
+          }
+          if (thrown != null) {
+              throw thrown;
+          }
+          System.out.println("Passed: " + (nextLong.longValue() - sNextLong)
+                  + " unique loggers created");
+          System.out.println("\t " +(getRBcount.get() - sGetRBCount)
+                  + " loggers tested by " + READERS + " Thread(s),");
+          System.out.println("\t " + (setRBcount.get() - sSetRBCount)
+                  + " resource bundles set by " + classes.size() + " Thread(s),");
+          System.out.println("\t " + (setRBNameCount.get() - sSetRBNameCount)
+                  + " resource bundle names set by " + classes.size() + " Thread(s),");
+          System.out.println("\t ThreadMXBean.findDeadlockedThreads called "
+                  + (checkCount.get() -sCheckCount) + " times by 1 Thread.");
+
+    }
+
+    final static class GetRB extends Thread {
+        final static class MyHandler extends Handler {
+            volatile ResourceBundle rb;
+            volatile String rbName;
+            @Override
+            public synchronized void publish(LogRecord record) {
+                rb = record.getResourceBundle();
+                rbName = record.getResourceBundleName();
+            }
+
+            @Override
+            public void flush() {
+            }
+
+            @Override
+            public void close() throws SecurityException {
+            }
+        };
+        final MyHandler handler = new MyHandler();
+        @Override
+        public void run() {
+            try {
+                handler.setLevel(Level.FINEST);
+                while (goOn) {
+                    Logger l;
+                    Logger foo = Logger.getLogger("foo");
+                    Logger bar = Logger.getLogger("foo.bar");
+                    for (long i=0; i < nextLong.longValue() + 100 ; i++) {
+                        if (!goOn) break;
+                        l = Logger.getLogger("foo.bar.l"+i);
+                        final ResourceBundle b = l.getResourceBundle();
+                        final String name = l.getResourceBundleName();
+                        if (b != null) {
+                            if (!name.equals(b.getClass().getName())) {
+                                throw new RuntimeException("Unexpected bundle name: "
+                                        +b.getClass().getName());
+                            }
+                        }
+                        Logger ll = Logger.getLogger(l.getName()+".bie.bye");
+                        ResourceBundle hrb;
+                        String hrbName;
+                        ll.setLevel(Level.FINEST);
+                        ll.addHandler(handler);
+                        ll.fine("dummy");
+                        ll.removeHandler(handler);
+                        hrb = handler.rb;
+                        hrbName = handler.rbName;
+                        if (name != null) {
+                            if (!name.equals(hrbName)) {
+                                throw new RuntimeException("Unexpected bundle name: "
+                                        +hrb.getClass().getName());
+                            }
+                            if (!name.equals(hrb.getClass().getName())) {
+                                throw new RuntimeException("Unexpected bundle name: "
+                                        +hrb.getClass().getName());
+                            }
+                        }
+
+                        getRBcount.incrementAndGet();
+                        if (!goOn) break;
+                        Thread.sleep(1);
+                    }
+                }
+           } catch (Exception x) {
+               fail(x);
+           }
+        }
+    }
+
+    final static class SetRB extends Thread {
+        final Class<? extends ResourceBundle> type;
+        final static ExecutorService executor = Executors.newSingleThreadExecutor();
+        final static class CheckRBTask implements Callable<Exception> {
+            final Logger logger;
+            volatile String rbName;
+            volatile ResourceBundle rb;
+
+            public CheckRBTask(Logger logger) {
+                this.logger = logger;
+            }
+
+            @Override
+            public Exception call() throws Exception {
+                try {
+                    final String name = logger.getResourceBundleName();
+                    if (!Objects.equals(name, rbName)) {
+                        throw new RuntimeException("Unexpected rbname for "
+                            + logger.getName() + ": " + name);
+                    }
+                    final ResourceBundle b = logger.getResourceBundle();
+                    if (b != rb) {
+                        throw new RuntimeException("Unexpected rb for "
+                            + logger.getName() + ": " + b);
+                    }
+                } catch(Exception x) {
+                    return x;
+                }
+                return null;
+            }
+
+            public void check() throws Exception {
+                final FutureTask<Exception> futureTask = new FutureTask<>(this);
+                executor.submit(futureTask);
+                Exception x = futureTask.get();
+                if ( x != null) {
+                    throw new RuntimeException("Check failed: "+x,x);
+                }
+            }
+        }
+        SetRB(Class<? extends ResourceBundle> type) {
+            super("SetRB["+type.getSimpleName()+"]");
+            this.type = type;
+        }
+        @Override
+        public void run() {
+            try {
+                while (goOn) {
+                    Logger l;
+                    Logger foo = Logger.getLogger("foo");
+                    Logger bar = Logger.getLogger("foo.bar");
+                    l = Logger.getLogger("foo.bar.l"+nextLong.incrementAndGet());
+                    final CheckRBTask checkTask = new CheckRBTask(l);
+                    checkTask.check();
+                    Logger l1 = l;
+
+                    for (int i=0; i < LCOUNT ; i++) {
+                        if (!goOn) break;
+
+                        ResourceBundle b = ResourceBundle.getBundle(type.getName());
+                        try {
+                            l = Logger.getLogger(l1.getName(), type.getName());
+                            checkTask.rb = b;
+                            checkTask.rbName = type.getName();
+                            checkTask.check();
+                            if (!goOn) break;
+
+                            String name = l.getResourceBundleName();
+                            ResourceBundle bb = l.getResourceBundle();
+                            if (!type.getName().equals(name)) {
+                                throw new RuntimeException(this.getName()
+                                        + ": Unexpected name: "+name);
+                            }
+                            if (!b.getClass().getName().equals(name)) {
+                                throw new RuntimeException(this.getName()
+                                        + ": Unexpected base name: " +
+                                        b.getClass().getName());
+                            }
+                            if (b != bb) {
+                                throw new RuntimeException(this.getName()
+                                        + ": Unexpected bundle: "+bb);
+                            }
+                            setRBcount.incrementAndGet();
+                        } catch (IllegalArgumentException x) {
+                            final String name = l.getResourceBundleName();
+                            if (!name.startsWith(MyBundle.class.getName())) {
+                                throw new RuntimeException(this.getName()
+                                        + ": Unexpected name: "+name, x);
+                            } else if (type.getName().equals(name)) {
+                                throw new RuntimeException(this.getName()
+                                        + ": Unexpected exception for "+name, x);
+                            }
+                            throw x;
+                        }
+                        l.fine("I'm fine");
+                        if (!goOn) break;
+                        Thread.sleep(1);
+                    }
+                }
+            } catch (Exception x) {
+                fail(x);
+            }
+        }
+    }
+
+    final static class SetRBName extends Thread {
+        int nexti = 0;
+        final Class<? extends ResourceBundle> type;
+        final static ExecutorService executor = Executors.newSingleThreadExecutor();
+        final static class CheckRBNameTask implements Callable<Exception> {
+            final Logger logger;
+            volatile String rbName;
+
+            public CheckRBNameTask(Logger logger) {
+                this.logger = logger;
+            }
+
+            @Override
+            public Exception call() throws Exception {
+                try {
+                    final String name = logger.getResourceBundleName();
+                    if (!Objects.equals(name, rbName)) {
+                        throw new RuntimeException("Unexpected rbname for "
+                            + logger.getName() + ": " + name);
+                    }
+                    final ResourceBundle b = logger.getResourceBundle();
+                    if (!Objects.equals(b == null ? null : b.getClass().getName(), rbName)) {
+                        throw new RuntimeException("Unexpected base name for "
+                            + logger.getName() + ": " + b.getClass().getName());
+                    }
+                } catch(Exception x) {
+                    return x;
+                }
+                return null;
+            }
+
+            public void check() throws Exception {
+                final FutureTask<Exception> futureTask = new FutureTask<>(this);
+                executor.submit(futureTask);
+                Exception x = futureTask.get();
+                if ( x != null) {
+                    throw new RuntimeException("Check failed: "+x,x);
+                }
+            }
+
+        }
+        SetRBName(Class<? extends ResourceBundle> type) {
+            super("SetRB["+type.getSimpleName()+"]");
+            this.type = type;
+        }
+        @Override
+        public void run() {
+            try {
+                while (goOn) {
+                    Logger foo = Logger.getLogger("foo");
+                    Logger bar = Logger.getLogger("foo.bar");
+                    Logger l = Logger.getLogger("foo.bar.l"+nextLong.incrementAndGet());
+                    final CheckRBNameTask checkTask = new CheckRBNameTask(l);
+                    checkTask.check();
+
+                    for (int i=0; i < LCOUNT ; i++) {
+                        if (!goOn) break;
+
+                        try {
+                            Logger l2 = Logger.getLogger(l.getName(), type.getName());
+                            if (l2 != l) {
+                                System.err.println("**** ERROR WITH "+l.getName());
+                                throw new RuntimeException("l2 != l ["
+                                        + l2 + "(" + l2.getName() + ") != "
+                                        + l  + "(" + l.getName()  + ")]");
+                            }
+                            checkTask.rbName = type.getName();
+                            checkTask.check();
+                            if (!goOn) break;
+
+                            String name = l.getResourceBundleName();
+                            ResourceBundle bb = l.getResourceBundle();
+                            if (!type.getName().equals(name)) {
+                                throw new RuntimeException(this.getName()
+                                        + ": Unexpected name: "+name);
+                            }
+                            if (!bb.getClass().getName().equals(name)) {
+                                throw new RuntimeException(this.getName()
+                                        + ": Unexpected base name: "
+                                        + bb.getClass().getName());
+                            }
+                            setRBNameCount.incrementAndGet();
+                        } catch (IllegalArgumentException x) {
+                            final String name = l.getResourceBundleName();
+                            if (!name.startsWith(MyBundle.class.getName())) {
+                                throw new RuntimeException(this.getName()
+                                        + ": Unexpected name: "+name, x);
+                            } else if (type.getName().equals(name)) {
+                                throw new RuntimeException(this.getName()
+                                        + ": Unexpected exception for "+name, x);
+                            }
+                            throw x;
+                        }
+                        l.fine("I'm fine");
+                        if (!goOn) break;
+                        Thread.sleep(1);
+                    }
+                }
+            } catch (Exception x) {
+                fail(x);
+            }
+        }
+    }
+
+    final static class DeadlockDetector extends Thread {
+
+        @Override
+        public void run() {
+            while(goOn) {
+                try {
+                    long[] ids = ManagementFactory.getThreadMXBean().findDeadlockedThreads();
+                    checkCount.incrementAndGet();
+                    ids = ids == null ? new long[0] : ids;
+                    if (ids.length == 1) {
+                        throw new RuntimeException("Found 1 deadlocked thread: "+ids[0]);
+                    } else if (ids.length > 0) {
+                        ThreadInfo[] infos = ManagementFactory.getThreadMXBean().getThreadInfo(ids);
+                        System.err.println("Found "+ids.length+" deadlocked threads: ");
+                        for (ThreadInfo inf : infos) {
+                            System.err.println(inf.toString());
+                        }
+                        throw new RuntimeException("Found "+ids.length+" deadlocked threads");
+                    }
+                    Thread.sleep(100);
+                } catch(InterruptedException | RuntimeException x) {
+                    fail(x);
+                }
+            }
+        }
+
+    }
+
+    static final class Stopper extends Thread {
+        long start;
+        long time;
+
+        Stopper(long time) {
+            start = System.currentTimeMillis();
+            this.time = time;
+        }
+
+        @Override
+        public void run() {
+            try {
+                long rest, previous;
+                previous = time;
+                while (goOn && (rest = start - System.currentTimeMillis() + time) > 0) {
+                    if (previous == time || previous - rest >= STEP) {
+                        Logger.getLogger("remaining").info(String.valueOf(rest)+"ms remaining...");
+                        previous = rest == time ? rest -1 : rest;
+                        System.gc();
+                    }
+                    if (goOn == false) break;
+                    Thread.sleep(Math.min(rest, 100));
+                }
+                System.out.println(System.currentTimeMillis() - start
+                        + " ms elapsed ("+time+ " requested)");
+                goOn = false;
+            } catch(InterruptedException | RuntimeException x) {
+                fail(x);
+            }
+        }
+
+    }
+
+    static void fail(Exception x) {
+        x.printStackTrace();
+        if (thrown == null) {
+            thrown = x;
+        }
+        goOn = false;
+    }
+}
--- ./jdk/test/java/util/logging/bundlesearch/ResourceBundleSearchTest.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/test/java/util/logging/bundlesearch/ResourceBundleSearchTest.java	Wed May 07 19:26:47 2014 -0700
@@ -59,9 +59,32 @@
     private static int numFail = 0;
     private static List<String> msgs = new ArrayList<>();
 
+    // This test has been falling in timeout - so we're adding some
+    // time stamp here and there to help diagnose whether it's a
+    // simple system slowness or whether there's a deeper issue,
+    // like a deadlock. The timeout issue should be fixed now,
+    // but we leave the time stamps in case it reappears.
+    //
+    static final long stamp = System.currentTimeMillis();
+    private static String getTimeStamp() {
+        long time = System.currentTimeMillis();
+        long delta = time - stamp;
+        long min = delta/60000;
+        long sec = (delta - min * 60000) / 10000;
+        long msec = delta - min * 60000 - sec * 1000;
+        return (min == 0 ? "" : (min + " min. ")) +
+               (sec == 0 ? "" : (sec + " sec. ")) +
+               (msec == 0 ? "" : (msec + "ms."));
+    }
+
     public static void main(String[] args) throws Throwable {
+        System.out.println("ResourceBundleSearchTest starting: "+getTimeStamp());
         ResourceBundleSearchTest test = new ResourceBundleSearchTest();
-        test.runTests();
+        try {
+            test.runTests();
+        } finally {
+            System.out.println("ResourceBundleSearchTest terminated: "+getTimeStamp());
+        }
     }
 
     private void runTests() throws Throwable {
@@ -82,7 +105,8 @@
         // Test 1 - can we find a Logger bundle from doing a stack search?
         // We shouldn't be able to
         // unless -Djdk.logging.allowStackWalkSearch=true is set
-
+        int testnb = 1;
+        System.out.println("ResourceBundleSearchTest starting test #"+(testnb++)+": "+getTimeStamp());
         boolean allowStackWalkSearch = Boolean.getBoolean("jdk.logging.allowStackWalkSearch");
         if (allowStackWalkSearch) {
             assertTrue(testGetBundleFromStackSearch(), "1-testGetBundleFromStackSearch");
@@ -93,6 +117,7 @@
 
         // Test 2 - can we find a Logger bundle off of the Thread context class
         // loader? We should be able to.
+        System.out.println("ResourceBundleSearchTest starting test #"+(testnb++)+": "+getTimeStamp());
         assertTrue(testGetBundleFromTCCL(TCCL_TEST_BUNDLE, rbClassLoader),
                    "2-testGetBundleFromTCCL");
 
@@ -100,6 +125,7 @@
         // able to.  We'll first check to make sure the setup is correct and
         // it actually is on the classpath before checking whether logging
         // can see it there.
+        System.out.println("ResourceBundleSearchTest starting test #"+(testnb++)+": "+getTimeStamp());
         if (isOnClassPath(PROP_RB_NAME, myClassLoader)) {
             debug("We should be able to see " + PROP_RB_NAME + " on the classpath");
             assertTrue(testGetBundleFromSystemClassLoader(PROP_RB_NAME),
@@ -111,17 +137,20 @@
 
         // Test 4 - we should be able to find a bundle from the caller's
         // classloader, but only one level up.
+        System.out.println("ResourceBundleSearchTest starting test #"+(testnb++)+": "+getTimeStamp());
         assertTrue(testGetBundleFromCallersClassLoader(),
                    "4-testGetBundleFromCallersClassLoader");
 
         // Test 5 - this ensures that getAnonymousLogger(String rbName)
         // can find the bundle from the caller's classloader
+        System.out.println("ResourceBundleSearchTest starting test #"+(testnb++)+": "+getTimeStamp());
         assertTrue(testGetAnonymousLogger(), "5-testGetAnonymousLogger");
 
         // Test 6 - first call getLogger("myLogger").
         // Then call getLogger("myLogger","bundleName") from a different ClassLoader
         // Make sure we find the bundle
         if (!allowStackWalkSearch) {
+            System.out.println("ResourceBundleSearchTest starting test #"+(testnb++)+": "+getTimeStamp());
             assertTrue(testGetBundleFromSecondCallersClassLoader(),
                        "6-testGetBundleFromSecondCallersClassLoader");
         }
@@ -144,6 +173,7 @@
     public void assertTrue(boolean testResult, String testName) {
         if (testResult) {
             numPass++;
+            System.out.println("PASSED: " + testName);
         } else {
             numFail++;
             System.out.println("FAILED: " + testName
@@ -154,6 +184,7 @@
     public void assertFalse(boolean testResult, String testName) {
         if (!testResult) {
             numPass++;
+            System.out.println("PASSED: " + testName);
         } else {
             numFail++;
             System.out.println("FAILED: " + testName
@@ -182,12 +213,10 @@
         debug("Looking for " + bundleName + " using TCCL");
         LoggingThread lr = new LoggingThread(bundleName, setOnTCCL);
         lr.start();
-        synchronized (lr) {
-            try {
-                lr.wait();
-            } catch (InterruptedException ex) {
-                throw ex;
-            }
+        try {
+            lr.join();
+        } catch (InterruptedException ex) {
+            throw ex;
         }
         msgs.add(lr.msg);
         return lr.foundBundle;
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/java/util/logging/deadlockconf.properties	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,22 @@
+# This file is used by TestLogConfigurationDeadLockWithConf
+handlers= java.util.logging.ConsoleHandler
+.level= INFO
+java.util.logging.ConsoleHandler.level = INFO
+java.util.logging.ConsoleHandler.formatter = java.util.logging.SimpleFormatter
+
+
+foo.bar0.level = INFO
+foo.bar1.level = INFO
+foo.bar2.level = INFO
+foo.bar3.level = INFO
+foo.bar4.level = INFO
+
+# We leave foo.bar5 out so that we have at least
+# one logger whose parent won't be in the configuration
+# file
+#foo.bar5.level = INFO
+
+foo.bar6.level = INFO
+foo.bar7.level = INFO
+foo.bar8.level = INFO
+foo.bar9.level = INFO
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/javax/management/MBeanInfo/MBeanInfoEqualsNPETest.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,216 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import javax.management.MBeanAttributeInfo;
+import javax.management.MBeanConstructorInfo;
+import javax.management.MBeanFeatureInfo;
+import javax.management.MBeanInfo;
+import javax.management.MBeanNotificationInfo;
+import javax.management.MBeanOperationInfo;
+import javax.management.MBeanParameterInfo;
+import javax.management.modelmbean.DescriptorSupport;
+import javax.management.openmbean.SimpleType;
+
+/*
+ * @test
+ * @bug 8023954
+ * @summary Test that MBean*Info.equals do not throw NPE
+ * @author Shanliang JIANG
+ * @run clean MBeanInfoEqualsNPETest
+ * @run build MBeanInfoEqualsNPETest
+ * @run main MBeanInfoEqualsNPETest
+ */
+public class MBeanInfoEqualsNPETest {
+    private static int failed = 0;
+
+    public static void main(String[] args) throws Exception {
+        System.out.println("---MBeanInfoEqualsNPETest-main ...");
+
+        // ----
+        System.out.println("\n---Testing on MBeanAttributeInfo...");
+        MBeanAttributeInfo mbeanAttributeInfo0 = new MBeanAttributeInfo(
+                "name", SimpleType.INTEGER.getClassName(), "description", true, true, false);
+        MBeanAttributeInfo mbeanAttributeInfo = new MBeanAttributeInfo(
+                null, SimpleType.INTEGER.getClassName(), "description", true, true, false);
+        test(mbeanAttributeInfo0, mbeanAttributeInfo, "class name");
+
+        mbeanAttributeInfo = new MBeanAttributeInfo(
+                "name", null, "description", true, true, false);
+        test(mbeanAttributeInfo0, mbeanAttributeInfo, "type");
+
+        mbeanAttributeInfo = new MBeanAttributeInfo(
+                "name", SimpleType.INTEGER.getClassName(), null, true, true, false);
+        test(mbeanAttributeInfo0, mbeanAttributeInfo, "description");
+
+        // ----
+        System.out.println("\n---Testing on MBeanConstructorInfo...");
+        MBeanConstructorInfo mbeanConstructorInfo0 = new MBeanConstructorInfo(
+                "", "", new MBeanParameterInfo[]{}, new DescriptorSupport());
+        MBeanConstructorInfo mbeanConstructorInfo = new MBeanConstructorInfo(
+                null, "", new MBeanParameterInfo[]{}, new DescriptorSupport());
+        test(mbeanConstructorInfo0, mbeanConstructorInfo, "name");
+
+        mbeanConstructorInfo = new MBeanConstructorInfo(
+                "", null, new MBeanParameterInfo[]{}, new DescriptorSupport());
+        test(mbeanConstructorInfo0, mbeanConstructorInfo, "description");
+
+        mbeanConstructorInfo = new MBeanConstructorInfo(
+                "", "", null, new DescriptorSupport());
+        test(mbeanConstructorInfo0, mbeanConstructorInfo, "MBeanParameterInfo");
+
+        mbeanConstructorInfo = new MBeanConstructorInfo(
+                "", "", new MBeanParameterInfo[]{}, null);
+        test(mbeanConstructorInfo0, mbeanConstructorInfo, "descriptor");
+
+        // ----
+        System.out.println("\n---Testing on MBeanOperationInfo...");
+        MBeanOperationInfo mbeanOperationInfo0 = new MBeanOperationInfo(
+                "name", "description", new MBeanParameterInfo[]{}, "type",
+                MBeanOperationInfo.UNKNOWN, new DescriptorSupport());
+
+        MBeanOperationInfo mbeanOperationInfo = new MBeanOperationInfo(
+                null, "description", new MBeanParameterInfo[]{}, "type",
+                MBeanOperationInfo.UNKNOWN, new DescriptorSupport());
+        test(mbeanOperationInfo0, mbeanOperationInfo, "name");
+
+        mbeanOperationInfo = new MBeanOperationInfo(
+                "name", null, new MBeanParameterInfo[]{}, "type",
+                MBeanOperationInfo.UNKNOWN, new DescriptorSupport());
+        test(mbeanOperationInfo0, mbeanOperationInfo, "description");
+
+        mbeanOperationInfo = new MBeanOperationInfo(
+                "name", "description", null, "type", 1, new DescriptorSupport());
+        test(mbeanOperationInfo0, mbeanOperationInfo, "MBeanParameterInfo");
+
+        mbeanOperationInfo = new MBeanOperationInfo(
+                "name", "description", new MBeanParameterInfo[]{}, null,
+                MBeanOperationInfo.UNKNOWN, new DescriptorSupport());
+        test(mbeanOperationInfo0, mbeanOperationInfo, "type");
+
+        mbeanOperationInfo = new MBeanOperationInfo(
+                "name", "description", new MBeanParameterInfo[]{}, null,
+                MBeanOperationInfo.UNKNOWN, null);
+        test(mbeanOperationInfo0, mbeanOperationInfo, "Descriptor");
+
+        // ----
+        System.out.println("\n---Testing on MBeanParameterInfo...");
+        MBeanParameterInfo mbeanParameterInfo0 = new MBeanParameterInfo(
+                "name", "type", "description", new DescriptorSupport());
+        MBeanParameterInfo mbeanParameterInfo = new MBeanParameterInfo(
+                null, "type", "description", new DescriptorSupport());
+        test(mbeanParameterInfo0, mbeanParameterInfo, "name");
+
+        mbeanParameterInfo = new MBeanParameterInfo(
+                "name", null, "description", new DescriptorSupport());
+        test(mbeanParameterInfo0, mbeanParameterInfo, "type");
+
+        mbeanParameterInfo = new MBeanParameterInfo(
+                "name", "type", null, new DescriptorSupport());
+        test(mbeanParameterInfo0, mbeanParameterInfo, "description");
+
+        mbeanParameterInfo = new MBeanParameterInfo(
+                "name", "type", "description", null);
+        test(mbeanParameterInfo0, mbeanParameterInfo, "Descriptor");
+
+        // ----
+        System.out.println("\n---Testing on MBeanFeatureInfo ...");
+        MBeanFeatureInfo mbeanFeatureInfo0 = new MBeanFeatureInfo(
+                "name", "description", new DescriptorSupport());
+        MBeanFeatureInfo mbeanFeatureInfo = new MBeanFeatureInfo(
+                null, "description", new DescriptorSupport());
+        test(mbeanFeatureInfo0, mbeanFeatureInfo, "name");
+
+        mbeanFeatureInfo = new MBeanFeatureInfo(
+                "name", null, new DescriptorSupport());
+        test(mbeanParameterInfo0, mbeanParameterInfo, "description");
+
+        mbeanFeatureInfo = new MBeanFeatureInfo(
+                "name", "description", null);
+        test(mbeanParameterInfo0, mbeanParameterInfo, "Descriptor");
+
+        // ----
+        System.out.println("\n---Testing on MBeanInfo...");
+        String className = "toto";
+        String description = "titi";
+        MBeanAttributeInfo[] attrInfos = new MBeanAttributeInfo[]{};
+        MBeanConstructorInfo[] constrInfos = new MBeanConstructorInfo[]{};
+        MBeanOperationInfo[] operaInfos = new MBeanOperationInfo[]{};
+        MBeanNotificationInfo[] notifInfos = new MBeanNotificationInfo[]{};
+
+        MBeanInfo minfo0 = new MBeanInfo("toto", description, attrInfos, constrInfos, operaInfos, notifInfos);
+        MBeanInfo minfo = new MBeanInfo(null, description, attrInfos, constrInfos, operaInfos, notifInfos);
+        test(minfo0, minfo, "class name");
+
+        minfo = new MBeanInfo(className, null, attrInfos, constrInfos, operaInfos, notifInfos);
+        test(minfo0, minfo, "description");
+
+        minfo = new MBeanInfo(className, description, null, constrInfos, operaInfos, notifInfos);
+        test(minfo0, minfo, "attrInfos");
+
+        minfo = new MBeanInfo(className, description, attrInfos, null, operaInfos, notifInfos);
+        test(minfo0, minfo, "constrInfos");
+
+        minfo = new MBeanInfo(className, description, attrInfos, constrInfos, null, notifInfos);
+        test(minfo0, minfo, "operaInfos");
+
+        minfo = new MBeanInfo(className, description, attrInfos, constrInfos, operaInfos, null);
+        test(minfo0, minfo, "notifInfos");
+
+        if (failed > 0) {
+            throw new RuntimeException("Test failed: "+failed);
+        } else {
+            System.out.println("---Test: PASSED");
+        }
+    }
+
+    private static void test(Object obj1, Object obj2, String param) {
+        try {
+            obj1.equals(obj2);
+            System.out.println("OK-1: "+obj1.getClass().getSimpleName()+".equals worked with a null paramer: "+param);
+        } catch (NullPointerException npe) {
+            System.out.println("--->KO-1!!! "+obj1.getClass().getSimpleName()+".equals got NPE with a null paramer: "+param);
+            npe.printStackTrace();
+            failed++;
+        }
+
+        try {
+            obj2.equals(obj1);
+            System.out.println("OK-2: "+obj2.getClass().getSimpleName()+".equals worked with a null paramer: "+param);
+        } catch (NullPointerException npe) {
+            System.out.println("--->KO-2!!! "+obj2.getClass().getSimpleName()+".equals got NPE with a null paramer: "+param);
+            npe.printStackTrace();
+            failed++;
+        }
+
+        try {
+            obj1.equals(null);
+            obj2.equals(null);
+
+            System.out.println("OK-3: "+obj1.getClass().getSimpleName()+".equals worked with a null field.");
+        } catch (NullPointerException npe) {
+            System.out.println("--->KO-3!!! "+obj1.getClass().getSimpleName()+".equals got NPE with a null field.");
+            npe.printStackTrace();
+            failed++;
+        }
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/javax/management/MBeanInfo/MBeanInfoHashCodeNPETest.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,176 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import javax.management.MBeanAttributeInfo;
+import javax.management.MBeanConstructorInfo;
+import javax.management.MBeanInfo;
+import javax.management.MBeanNotificationInfo;
+import javax.management.MBeanOperationInfo;
+import javax.management.MBeanParameterInfo;
+import javax.management.modelmbean.DescriptorSupport;
+import javax.management.openmbean.SimpleType;
+
+/*
+ * @test
+ * @bug 8023669
+ * @summary Test that hashCode()throws NullPointerException
+ * @author Shanliang JIANG
+ * @run clean MBeanInfoHashCodeNPETest
+ * @run build MBeanInfoHashCodeNPETest
+ * @run main MBeanInfoHashCodeNPETest
+ */
+public class MBeanInfoHashCodeNPETest {
+    private static int failed = 0;
+
+    public static void main(String[] args) throws Exception {
+        System.out.println("---MBeanInfoHashCodeNPETest-main ...");
+
+        // ----
+        System.out.println("\n---Testing on MBeanAttributeInfo...");
+        MBeanAttributeInfo mbeanAttributeInfo = new MBeanAttributeInfo(
+                null, SimpleType.INTEGER.getClassName(), "description", true, true, false);
+        test(mbeanAttributeInfo, "class name");
+
+        mbeanAttributeInfo = new MBeanAttributeInfo(
+                "name", null, "description", true, true, false);
+        test(mbeanAttributeInfo, "type");
+
+        mbeanAttributeInfo = new MBeanAttributeInfo(
+                "name", SimpleType.INTEGER.getClassName(), null, true, true, false);
+        test(mbeanAttributeInfo, "description");
+
+        // ----
+        System.out.println("\n---Testing on MBeanConstructorInfo...");
+        MBeanConstructorInfo mbeanConstructorInfo = new MBeanConstructorInfo(
+                null, "", new MBeanParameterInfo[]{}, new DescriptorSupport());
+        test(mbeanConstructorInfo, "name");
+
+        mbeanConstructorInfo = new MBeanConstructorInfo(
+                "", null, new MBeanParameterInfo[]{}, new DescriptorSupport());
+        test(mbeanConstructorInfo, "description");
+
+        mbeanConstructorInfo = new MBeanConstructorInfo(
+                "", "", null, new DescriptorSupport());
+        test(mbeanConstructorInfo, "MBeanParameterInfo");
+
+        mbeanConstructorInfo = new MBeanConstructorInfo(
+                "", "", new MBeanParameterInfo[]{}, null);
+        test(mbeanConstructorInfo, "descriptor");
+
+        // ----
+        System.out.println("\n---Testing on MBeanOperationInfo...");
+        MBeanOperationInfo mbeanOperationInfo = new MBeanOperationInfo(
+                null, "description", new MBeanParameterInfo[]{}, "type", 1, new DescriptorSupport());
+        test(mbeanOperationInfo, "name");
+
+        mbeanOperationInfo = new MBeanOperationInfo(
+                "name", null, new MBeanParameterInfo[]{}, "type", 1, new DescriptorSupport());
+        test(mbeanOperationInfo, "description");
+
+        mbeanOperationInfo = new MBeanOperationInfo(
+                "name", "description", null, "type", 1, new DescriptorSupport());
+        test(mbeanOperationInfo, "MBeanParameterInfo");
+
+        mbeanOperationInfo = new MBeanOperationInfo(
+                "name", "description", new MBeanParameterInfo[]{}, null, 1, new DescriptorSupport());
+        test(mbeanOperationInfo, "type");
+
+        mbeanOperationInfo = new MBeanOperationInfo(
+                "name", "description", new MBeanParameterInfo[]{}, "type", -1, new DescriptorSupport());
+        test(mbeanOperationInfo, "native impact");
+
+        mbeanOperationInfo = new MBeanOperationInfo(
+                "name", "description", new MBeanParameterInfo[]{}, "type", 1, null);
+        test(mbeanOperationInfo, "Descriptor");
+
+        // ----
+        System.out.println("\n---Testing on MBeanParameterInfo...");
+        MBeanParameterInfo mbeanParameterInfo = new MBeanParameterInfo(
+                null, "type", "description", new DescriptorSupport());
+        test(mbeanParameterInfo, "name");
+
+        mbeanParameterInfo = new MBeanParameterInfo(
+                "name", null, "description", new DescriptorSupport());
+        test(mbeanParameterInfo, "description");
+
+        mbeanParameterInfo = new MBeanParameterInfo(
+                "name", "type", null, new DescriptorSupport());
+        test(mbeanParameterInfo, "description");
+
+        mbeanParameterInfo = new MBeanParameterInfo(
+                "name", "type", "description", null);
+        test(mbeanParameterInfo, "Descriptor");
+
+        // ----
+        System.out.println("\n---Testing on MBeanInfo...");
+        String className = "toto";
+        String description = "titi";
+        MBeanAttributeInfo[] attrInfos = new MBeanAttributeInfo[]{};
+        MBeanConstructorInfo[] constrInfos = new MBeanConstructorInfo[]{};
+        MBeanOperationInfo[] operaInfos = new MBeanOperationInfo[]{};
+        MBeanNotificationInfo[] notifInfos = new MBeanNotificationInfo[]{};
+
+        MBeanInfo minfo = new MBeanInfo(null, description, attrInfos, constrInfos, operaInfos, notifInfos);
+        test(minfo, "class name");
+
+        minfo = new MBeanInfo(className, description, attrInfos, constrInfos, operaInfos, notifInfos);
+        test(minfo, "name");
+
+        minfo = new MBeanInfo(className, null, attrInfos, constrInfos, operaInfos, notifInfos);
+        test(minfo, "description");
+
+        minfo = new MBeanInfo(className, description, null, constrInfos, operaInfos, notifInfos);
+        test(minfo, "attrInfos");
+
+        minfo = new MBeanInfo(className, description, attrInfos, constrInfos, null, notifInfos);
+        test(minfo, "operaInfos");
+
+        minfo = new MBeanInfo(className, description, attrInfos, constrInfos, operaInfos, null);
+        test(minfo, "notifInfos");
+
+        Thread.sleep(100);
+        if (failed > 0) {
+            throw new RuntimeException("Test failed: "+failed);
+        } else {
+            System.out.println("---Test: PASSED");
+        }
+    }
+
+    private static void test(Object obj, String param) {
+        try {
+            obj.hashCode();
+            System.out.println("OK: "+obj.getClass().getSimpleName()+".hashCode worked with a null "+param);
+        } catch (NullPointerException npe) {
+            System.out.println("--->KO!!! "+obj.getClass().getSimpleName()+".hashCode got NPE with a null "+param);
+            failed++;
+        }
+
+        try {
+            obj.toString();
+            System.out.println("OK: "+obj.getClass().getSimpleName()+".toString worked with a null "+param);
+        } catch (NullPointerException npe) {
+            System.out.println("--->KO!!! "+obj.getClass().getSimpleName()+".toString got NPE.");
+            failed++;
+        }
+    }
+}
--- ./jdk/test/javax/management/monitor/CounterMonitorThresholdTest.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/test/javax/management/monitor/CounterMonitorThresholdTest.java	Wed May 07 19:26:47 2014 -0700
@@ -23,7 +23,7 @@
 
 /*
  * @test
- * @bug 6229368
+ * @bug 6229368 8025207
  * @summary Wrong threshold value in CounterMonitor with offset and modulus.
  * @author Luis-Miguel Alventosa
  * @run clean CounterMonitorThresholdTest
@@ -144,16 +144,14 @@
         for (int i = 0; i < counter.length; i++) {
             mbean.setCounter(counter[i]);
             System.out.println("\nCounter = " + mbean.getCounter());
-            Thread.sleep(300);
-            Integer derivedGaugeValue = (Integer) cm.getDerivedGauge(name);
-            System.out.println("Derived Gauge = " + derivedGaugeValue);
-            if (derivedGaugeValue.intValue() != derivedGauge[i]) {
-                System.out.println("Wrong derived gauge! Current value = " +
-                    derivedGaugeValue + " Expected value = " + derivedGauge[i]);
-                System.out.println("\nStop monitoring...");
-                cm.stop();
-                throw new IllegalArgumentException("wrong derived gauge");
-            }
+            Integer derivedGaugeValue;
+            // either pass or test timeout (killed by test harness)
+            // see 8025207
+            do {
+                Thread.sleep(150);
+                derivedGaugeValue = (Integer) cm.getDerivedGauge(name);
+            } while (derivedGaugeValue.intValue() != derivedGauge[i]);
+
             Number thresholdValue = cm.getThreshold(name);
             System.out.println("Threshold = " + thresholdValue);
             if (thresholdValue.intValue() != threshold[i]) {
@@ -163,7 +161,6 @@
                 cm.stop();
                 throw new IllegalArgumentException("wrong threshold");
             }
-            Thread.sleep(300);
         }
 
         // Stop the monitor
--- ./jdk/test/javax/management/monitor/NullAttributeValueTest.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/test/javax/management/monitor/NullAttributeValueTest.java	Wed May 07 19:26:47 2014 -0700
@@ -23,11 +23,12 @@
 
 /*
  * @test
- * @bug 6200031
+ * @bug 6200031 8025206
  * @summary Test that the counter/gauge/string monitors emit a
  *          jmx.monitor.error.type notification when the attribute
  *          being monitored returns a null value.
  * @author Luis-Miguel Alventosa
+ * @author Shanliang JIANG
  * @run clean NullAttributeValueTest
  * @run build NullAttributeValueTest
  * @run main NullAttributeValueTest
@@ -39,7 +40,7 @@
 public class NullAttributeValueTest implements NotificationListener {
 
     // Flag to notify that a message has been received
-    private boolean messageReceived = false;
+    private volatile boolean messageReceived = false;
 
     // MBean class
     public class ObservedObject implements ObservedObjectMBean {
@@ -83,7 +84,6 @@
      * Update the counter and check for notifications
      */
     public int counterMonitorNotification() throws Exception {
-
         CounterMonitor counterMonitor = null;
         try {
             MBeanServer server = MBeanServerFactory.newMBeanServer();
@@ -134,31 +134,17 @@
             echo(">>> START the CounterMonitor");
             counterMonitor.start();
 
-            // Wait for granularity period (multiplied by 2 for sure)
-            //
-            Thread.sleep(granularityperiod * 2);
-
-            // Check if notification was received
-            //
-            if (messageReceived) {
-                echo("\tOK: CounterMonitor notification received");
-            } else {
-                echo("\tKO: CounterMonitor notification missed or not emitted");
-                return 1;
-            }
+            return checkReceived(granularityperiod, "CounterMonitor");
         } finally {
             if (counterMonitor != null)
                 counterMonitor.stop();
         }
-
-        return 0;
     }
 
     /**
      * Update the gauge and check for notifications
      */
     public int gaugeMonitorNotification() throws Exception {
-
         GaugeMonitor gaugeMonitor = null;
         try {
             MBeanServer server = MBeanServerFactory.newMBeanServer();
@@ -212,31 +198,17 @@
             echo(">>> START the GaugeMonitor");
             gaugeMonitor.start();
 
-            // Wait for granularity period (multiplied by 2 for sure)
-            //
-            Thread.sleep(granularityperiod * 2);
-
-            // Check if notification was received
-            //
-            if (messageReceived) {
-                echo("\tOK: GaugeMonitor notification received");
-            } else {
-                echo("\tKO: GaugeMonitor notification missed or not emitted");
-                return 1;
-            }
+            return checkReceived(granularityperiod, "GaugeMonitor");
         } finally {
             if (gaugeMonitor != null)
                 gaugeMonitor.stop();
         }
-
-        return 0;
     }
 
     /**
      * Update the string and check for notifications
      */
     public int stringMonitorNotification() throws Exception {
-
         StringMonitor stringMonitor = null;
         try {
             MBeanServer server = MBeanServerFactory.newMBeanServer();
@@ -289,24 +261,11 @@
             echo(">>> START the StringMonitor");
             stringMonitor.start();
 
-            // Wait for granularity period (multiplied by 2 for sure)
-            //
-            Thread.sleep(granularityperiod * 2);
-
-            // Check if notification was received
-            //
-            if (messageReceived) {
-                echo("\tOK: StringMonitor notification received");
-            } else {
-                echo("\tKO: StringMonitor notification missed or not emitted");
-                return 1;
-            }
+            return checkReceived(granularityperiod, "StringMonitor");
         } finally {
             if (stringMonitor != null)
                 stringMonitor.stop();
         }
-
-        return 0;
     }
 
     /**
@@ -326,6 +285,21 @@
         return error;
     }
 
+    private int checkReceived(long granularityperiod, String caller) throws InterruptedException {
+        int i = 100;
+        do {
+            Thread.sleep(granularityperiod);
+        } while (!messageReceived && i-- > 0);
+
+        if (messageReceived) {
+            echo("\tOK: " + caller + " notification received");
+        } else {
+            echo("\tKO: " + caller + " notification missed or not emitted");
+        }
+
+        return messageReceived ? 0 : 1;
+    }
+
     /*
      * Print message
      */
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/javax/management/openmbean/OpenMBeanInfoEqualsNPETest.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,196 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import javax.management.MBeanNotificationInfo;
+import javax.management.MBeanOperationInfo;
+import javax.management.modelmbean.DescriptorSupport;
+import javax.management.openmbean.OpenMBeanAttributeInfo;
+import javax.management.openmbean.OpenMBeanAttributeInfoSupport;
+import javax.management.openmbean.OpenMBeanConstructorInfo;
+import javax.management.openmbean.OpenMBeanConstructorInfoSupport;
+import javax.management.openmbean.OpenMBeanInfo;
+import javax.management.openmbean.OpenMBeanInfoSupport;
+import javax.management.openmbean.OpenMBeanOperationInfo;
+import javax.management.openmbean.OpenMBeanOperationInfoSupport;
+import javax.management.openmbean.OpenMBeanParameterInfo;
+import javax.management.openmbean.OpenMBeanParameterInfoSupport;
+import javax.management.openmbean.SimpleType;
+
+/*
+ * @test
+ * @bug 8023529
+ * @summary Test that OpenMBean*Info.equals do not throw NPE
+ * @author Shanliang JIANG
+ * @run clean OpenMBeanInfoEqualsNPETest
+ * @run build OpenMBeanInfoEqualsNPETest
+ * @run main OpenMBeanInfoEqualsNPETest
+ */
+public class OpenMBeanInfoEqualsNPETest {
+    private static int failed = 0;
+
+    public static void main(String[] args) throws Exception {
+        System.out.println("---OpenMBeanInfoEqualsNPETest-main ...");
+
+        // ----
+        System.out.println("\n---Testing on OpenMBeanAttributeInfoSupport...");
+        OpenMBeanAttributeInfo openMBeanAttributeInfo0 = new OpenMBeanAttributeInfoSupport(
+                "name", "description", SimpleType.INTEGER, true, true, false, 1, new Integer[]{1, 2, 3});
+        OpenMBeanAttributeInfo openMBeanAttributeInfo = new OpenMBeanAttributeInfoSupport(
+                "name", "description", SimpleType.INTEGER, true, true, false, null, new Integer[]{1, 2, 3});
+        test(openMBeanAttributeInfo0, openMBeanAttributeInfo, "defaultValue");
+
+        openMBeanAttributeInfo = new OpenMBeanAttributeInfoSupport(
+                "name", "description", SimpleType.INTEGER, true, true, false, 1, null);
+        test(openMBeanAttributeInfo0, openMBeanAttributeInfo, "legalValues");
+
+        // ----
+        System.out.println("\n---Testing on OpenMBeanConstructorInfoSupport...");
+        OpenMBeanConstructorInfo openMBeanConstructorInfo0 = new OpenMBeanConstructorInfoSupport(
+                "name", "description", new OpenMBeanParameterInfo[]{}, new DescriptorSupport());
+        OpenMBeanConstructorInfo openMBeanConstructorInfo;
+
+        openMBeanConstructorInfo = new OpenMBeanConstructorInfoSupport(
+                "name", "description", null, new DescriptorSupport());
+        test(openMBeanConstructorInfo0, openMBeanConstructorInfo, "sigs");
+
+        openMBeanConstructorInfo = new OpenMBeanConstructorInfoSupport(
+                "name", "description", new OpenMBeanParameterInfo[]{}, null);
+        test(openMBeanConstructorInfo0, openMBeanConstructorInfo, "Descriptor");
+
+        // ----
+        System.out.println("\n---Testing on OpenMBeanOperationInfoSupport...");
+        OpenMBeanOperationInfo openMBeanOperationInfo0 = new OpenMBeanOperationInfoSupport(
+                "name", "description", new OpenMBeanParameterInfo[]{},  SimpleType.INTEGER, 1, new DescriptorSupport());
+        OpenMBeanOperationInfo openMBeanOperationInfo;
+
+        openMBeanOperationInfo = new OpenMBeanOperationInfoSupport(
+                "name", "description", null,  SimpleType.INTEGER, 1, new DescriptorSupport());
+        test(openMBeanOperationInfo0, openMBeanOperationInfo, "sigs");
+
+        openMBeanOperationInfo = new OpenMBeanOperationInfoSupport(
+                "name", "description", new OpenMBeanParameterInfo[]{},  SimpleType.INTEGER, MBeanOperationInfo.UNKNOWN, null);
+        test(openMBeanOperationInfo0, openMBeanOperationInfo, "Descriptor");
+
+        // ----
+        System.out.println("\n---Testing on OpenMBeanParameterInfoSupport 1...");
+        OpenMBeanParameterInfo openMBeanParameterInfo0 = new OpenMBeanParameterInfoSupport(
+                "name", "description", SimpleType.INTEGER, 0, -1, 1);
+        OpenMBeanParameterInfo openMBeanParameterInfo;
+
+        openMBeanParameterInfo = new OpenMBeanParameterInfoSupport(
+                "name", "description", SimpleType.INTEGER, null, -1, 1);
+        test(openMBeanParameterInfo0, openMBeanParameterInfo, "default value");
+
+        openMBeanParameterInfo = new OpenMBeanParameterInfoSupport(
+                "name", "description", SimpleType.INTEGER, 0, null, 1);
+        test(openMBeanParameterInfo0, openMBeanParameterInfo, "min value");
+
+        openMBeanParameterInfo = new OpenMBeanParameterInfoSupport(
+                "name", "description", SimpleType.INTEGER, 0, -1, null);
+        test(openMBeanParameterInfo0, openMBeanParameterInfo, "max value");
+
+        // ----
+        System.out.println("\n---Testing on OpenMBeanParameterInfoSupport 2...");
+        openMBeanParameterInfo0 = new OpenMBeanParameterInfoSupport(
+                "name", "description", SimpleType.INTEGER, 1, new Integer[]{-1, 1, 2});
+
+        openMBeanParameterInfo = new OpenMBeanParameterInfoSupport(
+                "name", "description", SimpleType.INTEGER, null, new Integer[]{-1, 1, 2});
+        test(openMBeanParameterInfo0, openMBeanParameterInfo, "default value");
+
+        openMBeanParameterInfo = new OpenMBeanParameterInfoSupport(
+                "name", "description", SimpleType.INTEGER, 1, null);
+        test(openMBeanParameterInfo0, openMBeanParameterInfo, "legal values");
+
+        // ----
+        System.out.println("\n---Testing on OpenMBeanInfoSupport...");
+        String className = "toto";
+        String description = "titi";
+        OpenMBeanAttributeInfo[] attrInfos = new OpenMBeanAttributeInfo[]{};
+        OpenMBeanConstructorInfo[] constrInfos = new OpenMBeanConstructorInfo[]{};
+        OpenMBeanOperationInfo[] operaInfos = new OpenMBeanOperationInfo[]{};
+        MBeanNotificationInfo[] notifInfos = new MBeanNotificationInfo[]{};
+
+        OpenMBeanInfo ominfo0 = new OpenMBeanInfoSupport("toto", description, attrInfos, constrInfos, operaInfos, notifInfos);
+        OpenMBeanInfo ominfo = new OpenMBeanInfoSupport(null, description, attrInfos, constrInfos, operaInfos, notifInfos);
+        test(ominfo0, ominfo, "class name");
+
+        ominfo = new OpenMBeanInfoSupport(className, null, attrInfos, constrInfos, operaInfos, notifInfos);
+        test(ominfo0, ominfo, "description");
+
+        ominfo = new OpenMBeanInfoSupport(className, description, null, constrInfos, operaInfos, notifInfos);
+        test(ominfo0, ominfo, "attrInfos");
+
+        ominfo = new OpenMBeanInfoSupport(className, description, attrInfos, null, operaInfos, notifInfos);
+        test(ominfo0, ominfo, "constructor infos");
+
+        ominfo = new OpenMBeanInfoSupport(className, description, attrInfos, constrInfos, null, notifInfos);
+        test(ominfo0, ominfo, "operation infos");
+
+        ominfo = new OpenMBeanInfoSupport(className, description, attrInfos, constrInfos, operaInfos, null);
+        test(ominfo0, ominfo, "notif infos");
+
+        if (failed > 0) {
+            throw new RuntimeException("Test failed: "+failed);
+        } else {
+            System.out.println("---Test: PASSED");
+        }
+    }
+
+    private static void test(Object obj1, Object obj2, String param) {
+        try {
+            obj1.equals(obj2);
+            System.out.println("OK-1: "+obj1.getClass().getSimpleName()+
+                    ".equals worked with a null field: "+param);
+        } catch (NullPointerException npe) {
+            System.out.println("--->KO-1!!! "+obj1.getClass().getSimpleName()+
+                    ".equals got NPE with a null field: "+param);
+            npe.printStackTrace();
+            failed++;
+        }
+
+        try {
+            obj2.equals(obj1);
+            System.out.println("OK-2: "+obj2.getClass().getSimpleName()+
+                    ".equals worked with a null field: "+param);
+        } catch (NullPointerException npe) {
+            System.out.println("--->KO-2!!! "+obj2.getClass().getSimpleName()+
+                    ".equals got NPE with a null field: "+param);
+            npe.printStackTrace();
+            failed++;
+        }
+
+        try {
+            obj1.equals(null);
+            obj2.equals(null);
+
+            System.out.println("OK-3: "+obj1.getClass().getSimpleName()+
+                    ".equals worked with a null object.");
+        } catch (NullPointerException npe) {
+            System.out.println("--->KO-3!!! "+obj1.getClass().getSimpleName()+
+                    ".equals got NPE with a null object.");
+            npe.printStackTrace();
+            failed++;
+        }
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/javax/management/openmbean/OpenMBeanInfoHashCodeNPETest.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,173 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import javax.management.MBeanNotificationInfo;
+import javax.management.modelmbean.DescriptorSupport;
+import javax.management.openmbean.OpenMBeanAttributeInfo;
+import javax.management.openmbean.OpenMBeanAttributeInfoSupport;
+import javax.management.openmbean.OpenMBeanConstructorInfo;
+import javax.management.openmbean.OpenMBeanConstructorInfoSupport;
+import javax.management.openmbean.OpenMBeanInfo;
+import javax.management.openmbean.OpenMBeanInfoSupport;
+import javax.management.openmbean.OpenMBeanOperationInfo;
+import javax.management.openmbean.OpenMBeanOperationInfoSupport;
+import javax.management.openmbean.OpenMBeanParameterInfo;
+import javax.management.openmbean.OpenMBeanParameterInfoSupport;
+import javax.management.openmbean.SimpleType;
+
+/*
+ * @test
+ * @bug 8023529
+ * @summary Test that OpenMBean*Info.hashCode do not throw NPE
+ * @author Shanliang JIANG
+ * @run clean OpenMBeanInfoHashCodeNPETest
+ * @run build OpenMBeanInfoHashCodeNPETest
+ * @run main OpenMBeanInfoHashCodeNPETest
+ */
+public class OpenMBeanInfoHashCodeNPETest {
+    private static int failed = 0;
+
+    public static void main(String[] args) throws Exception {
+        System.out.println("---OpenMBeanInfoHashCodeNPETest-main ...");
+
+        // ----
+        System.out.println("\n---Testing on OpenMBeanInfohashCodeTest...");
+        OpenMBeanAttributeInfo openMBeanAttributeInfo = new OpenMBeanAttributeInfoSupport(
+                "name", "description", SimpleType.INTEGER, true, true, false, null, new Integer[]{1, 2, 3});
+        test(openMBeanAttributeInfo, "defaultValue");
+
+        openMBeanAttributeInfo = new OpenMBeanAttributeInfoSupport(
+                "name", "description", SimpleType.INTEGER, true, true, false, 1, null);
+        test(openMBeanAttributeInfo, "legalValues");
+
+        // ----
+        System.out.println("\n---Testing on OpenMBeanConstructorInfoSupport...");
+        OpenMBeanConstructorInfo openMBeanConstructorInfo;
+
+        openMBeanConstructorInfo = new OpenMBeanConstructorInfoSupport(
+                "name", "description", null, new DescriptorSupport());
+        test(openMBeanConstructorInfo, "sigs");
+
+        openMBeanConstructorInfo = new OpenMBeanConstructorInfoSupport(
+                "name", "description", new OpenMBeanParameterInfo[]{}, null);
+        test(openMBeanConstructorInfo, "Descriptor");
+
+        // ----
+        System.out.println("\n---Testing on OpenMBeanOperationInfoSupport...");
+        OpenMBeanOperationInfo openMBeanOperationInfo;
+
+        openMBeanOperationInfo = new OpenMBeanOperationInfoSupport(
+                "name", "description", null,  SimpleType.INTEGER, 1, new DescriptorSupport());
+        test(openMBeanOperationInfo, "sigs");
+
+        openMBeanOperationInfo = new OpenMBeanOperationInfoSupport(
+                "name", "description", new OpenMBeanParameterInfo[]{},  SimpleType.INTEGER, 1, null);
+        test(openMBeanOperationInfo, "Descriptor");
+
+        // ----
+        System.out.println("\n---Testing on OpenMBeanParameterInfoSupport 1...");
+        OpenMBeanParameterInfo openMBeanParameterInfo;
+
+        openMBeanParameterInfo = new OpenMBeanParameterInfoSupport(
+                "name", "description", SimpleType.INTEGER, null, -1, 1);
+        test(openMBeanParameterInfo, "default value");
+
+        openMBeanParameterInfo = new OpenMBeanParameterInfoSupport(
+                "name", "description", SimpleType.INTEGER, 0, null, 1);
+        test(openMBeanParameterInfo, "min value");
+
+        openMBeanParameterInfo = new OpenMBeanParameterInfoSupport(
+                "name", "description", SimpleType.INTEGER, 0, -1, null);
+        test(openMBeanParameterInfo, "max value");
+
+        // ----
+        System.out.println("\n---Testing on OpenMBeanParameterInfoSupport 2...");
+        openMBeanParameterInfo = new OpenMBeanParameterInfoSupport(
+                "name", "description", SimpleType.INTEGER, 1, new Integer[]{-1, 1, 2});
+
+        openMBeanParameterInfo = new OpenMBeanParameterInfoSupport(
+                "name", "description", SimpleType.INTEGER, null, new Integer[]{-1, 1, 2});
+        test(openMBeanParameterInfo, "default value");
+
+        openMBeanParameterInfo = new OpenMBeanParameterInfoSupport(
+                "name", "description", SimpleType.INTEGER, 1, null);
+        test(openMBeanParameterInfo, "legal values");
+
+        // ----
+        System.out.println("\n---Testing on OpenMBeanInfoSupport...");
+        String className = "toto";
+        String description = "titi";
+        OpenMBeanAttributeInfo[] attrInfos = new OpenMBeanAttributeInfo[]{};
+        OpenMBeanConstructorInfo[] constrInfos = new OpenMBeanConstructorInfo[]{};
+        OpenMBeanOperationInfo[] operaInfos = new OpenMBeanOperationInfo[]{};
+        MBeanNotificationInfo[] notifInfos = new MBeanNotificationInfo[]{};
+
+        OpenMBeanInfo ominfo = new OpenMBeanInfoSupport(null, description, attrInfos, constrInfos, operaInfos, notifInfos);
+        test(ominfo, "class name");
+
+        ominfo = new OpenMBeanInfoSupport(className, null, attrInfos, constrInfos, operaInfos, notifInfos);
+        test(ominfo, "description");
+
+        ominfo = new OpenMBeanInfoSupport(className, description, null, constrInfos, operaInfos, notifInfos);
+        test(ominfo, "attrInfos");
+
+        ominfo = new OpenMBeanInfoSupport(className, description, attrInfos, null, operaInfos, notifInfos);
+        test(ominfo, "constructor infos");
+
+        ominfo = new OpenMBeanInfoSupport(className, description, attrInfos, constrInfos, null, notifInfos);
+        test(ominfo, "operation infos");
+
+        ominfo = new OpenMBeanInfoSupport(className, description, attrInfos, constrInfos, operaInfos, null);
+        test(ominfo, "notif infos");
+
+        if (failed > 0) {
+            throw new RuntimeException("Test failed: "+failed);
+        } else {
+            System.out.println("---Test: PASSED");
+        }
+    }
+
+    private static void test(Object obj, String param) {
+        try {
+            obj.hashCode();
+            System.out.println("OK-1: "+obj.getClass().getSimpleName()+
+                    ".hashCode worked with a null paramer: "+param);
+        } catch (NullPointerException npe) {
+            System.out.println("--->KO-1!!! "+obj.getClass().getSimpleName()+
+                    ".hashCode got NPE with null paramer: "+param);
+            npe.printStackTrace();
+            failed++;
+        }
+
+        try {
+            obj.toString();
+            System.out.println("OK-1: "+obj.getClass().getSimpleName()+
+                    ".toString worked with a null paramer: "+param);
+        } catch (NullPointerException npe) {
+            System.out.println("--->KO-1!!! "+obj.getClass().getSimpleName()+
+                    ".toString got NPE with null paramer: "+param);
+            npe.printStackTrace();
+            failed++;
+        }
+    }
+}
--- ./jdk/test/javax/management/remote/mandatory/URLTest.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/test/javax/management/remote/mandatory/URLTest.java	Wed May 07 19:26:47 2014 -0700
@@ -24,8 +24,6 @@
 /*
  * @test
  * @bug 5057532
- * @ignore Test will fail until 6338951 is resolved (java.net.URI now
- * accepts "http://-a").
  * @summary Tests that host names are parsed correctly in URLs
  * @author Eamonn McManus
  * @run clean URLTest
--- ./jdk/test/javax/management/remote/mandatory/connection/BrokenConnectionTest.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/test/javax/management/remote/mandatory/connection/BrokenConnectionTest.java	Wed May 07 19:26:47 2014 -0700
@@ -23,7 +23,7 @@
 
 /*
  * @test
- * @bug 4940957
+ * @bug 4940957 8025205
  * @summary Tests behaviour when connections break
  * @author Eamonn McManus
  * @run clean BrokenConnectionTest
@@ -485,14 +485,13 @@
             }
             if (thisok) {
                 System.out.println("Waiting for failure notif");
-                long deadline = System.currentTimeMillis() + 5000;
-                while (failureListener.count < 1
-                       && System.currentTimeMillis() < deadline)
-                    Thread.sleep(500);
-                if (failureListener.count < 1) {
-                    System.out.println("Did not get failure notif!");
-                    thisok = false;
-                } else if (failureListener.count > 1) {
+                // pass or test timeout. see 8025205
+                do {
+                    Thread.sleep(100);
+                } while (failureListener.count < 1);
+
+                Thread.sleep(1000); // if more notif coming ...
+                if (failureListener.count > 1) {
                     System.out.println("Got too many failure notifs: " +
                                        failureListener.count);
                     thisok = false;
--- ./jdk/test/javax/management/remote/mandatory/connection/IdleTimeoutTest.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/test/javax/management/remote/mandatory/connection/IdleTimeoutTest.java	Wed May 07 19:26:47 2014 -0700
@@ -23,7 +23,7 @@
 
 /*
  * @test
- * @bug 4886838 4886830
+ * @bug 4886838 4886830 8025204
  * @summary Tests that idle timeouts happen at appropriate times
  * @author Eamonn McManus
  * @run clean IdleTimeoutTest
@@ -272,19 +272,11 @@
                 }
 
                 System.out.println("Waiting for id list to drop ours");
-                deadline = System.currentTimeMillis() + timeout*2 + 10000;
-                while (true) {
-                    ids = Arrays.asList(server.getConnectionIds());
-                    if (!ids.contains(connId)
-                        || System.currentTimeMillis() >= deadline)
-                        break;
-                    Thread.sleep(500);
-                }
-                if (ids.contains(connId)) {
-                    System.out.println("Client id still in list after " +
-                                       "deadline: " + ids);
-                    return false;
-                }
+                // pass or timed out by test harness - see 8025204
+                do {
+                   Thread.sleep(100);
+                   ids = Arrays.asList(server.getConnectionIds());
+                } while (ids.contains(connId));
 
                 conn.getDefaultDomain();
                 if (connId.equals(client.getConnectionId())) {
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/javax/management/remote/mandatory/connection/RMIConnectorInternalMapTest.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,122 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import java.lang.management.ManagementFactory;
+import java.lang.ref.WeakReference;
+import java.lang.reflect.Field;
+import java.util.Collections;
+import java.util.Map;
+import javax.management.MBeanServer;
+import javax.management.MBeanServerConnection;
+import javax.management.remote.JMXConnector;
+import javax.management.remote.JMXConnectorFactory;
+import javax.management.remote.JMXConnectorServer;
+import javax.management.remote.JMXConnectorServerFactory;
+import javax.management.remote.JMXPrincipal;
+import javax.management.remote.JMXServiceURL;
+import javax.management.remote.rmi.RMIConnector;
+import javax.security.auth.Subject;
+
+/*
+ * @test
+ * @bug 6566891
+ * @summary Check no memory leak on RMIConnector's rmbscMap
+ * @author Shanliang JIANG
+ * @run clean RMIConnectorInternalMapTest
+ * @run build RMIConnectorInternalMapTest
+ * @run main RMIConnectorInternalMapTest
+ */
+
+public class RMIConnectorInternalMapTest {
+    public static void main(String[] args) throws Exception {
+        System.out.println("---RMIConnectorInternalMapTest starting...");
+
+        JMXConnectorServer connectorServer = null;
+        JMXConnector connectorClient = null;
+
+        try {
+            MBeanServer mserver = ManagementFactory.getPlatformMBeanServer();
+            JMXServiceURL serverURL = new JMXServiceURL("rmi", "localhost", 0);
+            connectorServer = JMXConnectorServerFactory.newJMXConnectorServer(serverURL, null, mserver);
+            connectorServer.start();
+
+            JMXServiceURL serverAddr = connectorServer.getAddress();
+            connectorClient = JMXConnectorFactory.connect(serverAddr, null);
+            connectorClient.connect();
+
+            Field rmbscMapField = RMIConnector.class.getDeclaredField("rmbscMap");
+            rmbscMapField.setAccessible(true);
+            Map<Subject, WeakReference<MBeanServerConnection>> map =
+                    (Map<Subject, WeakReference<MBeanServerConnection>>) rmbscMapField.get(connectorClient);
+            if (map != null && !map.isEmpty()) { // failed
+                throw new RuntimeException("RMIConnector's rmbscMap must be empty at the initial time.");
+            }
+
+            Subject delegationSubject =
+                    new Subject(true,
+                    Collections.singleton(new JMXPrincipal("delegate")),
+                    Collections.EMPTY_SET,
+                    Collections.EMPTY_SET);
+            MBeanServerConnection mbsc1 =
+                    connectorClient.getMBeanServerConnection(delegationSubject);
+            MBeanServerConnection mbsc2 =
+                    connectorClient.getMBeanServerConnection(delegationSubject);
+
+            if (mbsc1 == null) {
+                throw new RuntimeException("Got null connection.");
+            }
+            if (mbsc1 != mbsc2) {
+                throw new RuntimeException("Not got same connection with a same subject.");
+            }
+
+            map = (Map<Subject, WeakReference<MBeanServerConnection>>) rmbscMapField.get(connectorClient);
+            if (map == null || map.isEmpty()) { // failed
+                throw new RuntimeException("RMIConnector's rmbscMap has wrong size "
+                        + "after creating a delegated connection.");
+            }
+
+            delegationSubject = null;
+            mbsc1 = null;
+            mbsc2 = null;
+
+            int i = 0;
+            while (!map.isEmpty() && i++ < 60) {
+                System.gc();
+                Thread.sleep(100);
+            }
+            System.out.println("---GC times: " + i);
+
+            if (!map.isEmpty()) {
+                throw new RuntimeException("Failed to clean RMIConnector's rmbscMap");
+            } else {
+                System.out.println("---RMIConnectorInternalMapTest: PASSED!");
+            }
+        } finally {
+            try {
+                connectorClient.close();
+                connectorServer.stop();
+            } catch (Exception e) {
+            }
+        }
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/javax/management/remote/mandatory/connection/RMIConnectorNullSubjectConnTest.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,105 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import java.lang.management.ManagementFactory;
+import java.lang.ref.WeakReference;
+import java.lang.reflect.Field;
+import javax.management.MBeanServer;
+import javax.management.MBeanServerConnection;
+import javax.management.remote.JMXConnector;
+import javax.management.remote.JMXConnectorFactory;
+import javax.management.remote.JMXConnectorServer;
+import javax.management.remote.JMXConnectorServerFactory;
+import javax.management.remote.JMXServiceURL;
+import javax.management.remote.rmi.RMIConnector;
+
+/*
+ * @test
+ * @bug 6566891
+ * @summary Check no memory leak on RMIConnector's nullSubjectConn
+ * @author Shanliang JIANG
+ * @run clean RMIConnectorNullSubjectConnTest
+ * @run build RMIConnectorNullSubjectConnTest
+ * @run main RMIConnectorNullSubjectConnTest
+ */
+
+public class RMIConnectorNullSubjectConnTest {
+    public static void main(String[] args) throws Exception {
+        System.out.println("---RMIConnectorNullSubjectConnTest starting...");
+
+        JMXConnectorServer connectorServer = null;
+        JMXConnector connectorClient = null;
+
+        try {
+            MBeanServer mserver = ManagementFactory.getPlatformMBeanServer();
+            JMXServiceURL serverURL = new JMXServiceURL("rmi", "localhost", 0);
+            connectorServer = JMXConnectorServerFactory.newJMXConnectorServer(serverURL, null, mserver);
+            connectorServer.start();
+
+            JMXServiceURL serverAddr = connectorServer.getAddress();
+            connectorClient = JMXConnectorFactory.connect(serverAddr, null);
+            connectorClient.connect();
+
+            Field nullSubjectConnField = RMIConnector.class.getDeclaredField("nullSubjectConnRef");
+            nullSubjectConnField.setAccessible(true);
+
+            WeakReference<MBeanServerConnection> weak =
+                    (WeakReference<MBeanServerConnection>)nullSubjectConnField.get(connectorClient);
+
+            if (weak != null && weak.get() != null) {
+                throw new RuntimeException("nullSubjectConnRef must be null at initial time.");
+            }
+
+            MBeanServerConnection conn1 = connectorClient.getMBeanServerConnection(null);
+            MBeanServerConnection conn2 = connectorClient.getMBeanServerConnection(null);
+            if (conn1 == null) {
+                throw new RuntimeException("A connection with null subject should not be null.");
+            } else if (conn1 != conn2) {
+                throw new RuntimeException("The 2 connections with null subject are not equal.");
+            }
+
+            conn1 = null;
+            conn2 = null;
+            int i = 1;
+            do {
+                System.gc();
+                Thread.sleep(100);
+                weak = (WeakReference<MBeanServerConnection>)nullSubjectConnField.get(connectorClient);
+            } while ((weak != null && weak.get() != null) && i++ < 60);
+
+            System.out.println("---GC times: " + i);
+
+            if (weak != null && weak.get() != null) {
+                throw new RuntimeException("Failed to clean RMIConnector's nullSubjectConn");
+            } else {
+                System.out.println("---RMIConnectorNullSubjectConnTest: PASSED!");
+            }
+        } finally {
+            try {
+                connectorClient.close();
+                connectorServer.stop();
+            } catch (Exception e) {
+            }
+        }
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/javax/swing/JComboBox/6236162/bug6236162.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,119 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+/* @test
+   @bug 6236162
+   @summary Checks that there is no an inconsistence in combo box
+            behavior when user points an item in combo popup
+            by mouse and then uses UP/DOWN keys.
+   @library ../../regtesthelpers
+   @build Util
+   @author Mikhail Lapshin
+   @run main bug6236162
+*/
+
+import sun.awt.SunToolkit;
+
+import javax.swing.*;
+import javax.swing.plaf.basic.*;
+import javax.swing.plaf.metal.MetalComboBoxUI;
+import java.awt.*;
+import java.awt.event.KeyEvent;
+
+public class bug6236162 {
+    private static final SunToolkit toolkit = (SunToolkit) Toolkit.getDefaultToolkit();
+    private static JFrame frame;
+    private static JComboBox combo;
+    private static MyComboUI comboUI;
+
+    public static void main(String[] args) throws Exception {
+        UIManager.setLookAndFeel(UIManager.getCrossPlatformLookAndFeelClassName());
+        SwingUtilities.invokeAndWait(new Runnable() {
+            public void run() {
+                createAndShowGUI();
+            }
+        });
+        toolkit.realSync();
+        test();
+        System.out.println("Test passed");
+    }
+
+    private static void createAndShowGUI() {
+        frame = new JFrame("bug6236162");
+
+        combo = new JComboBox(new String[]{"one", "two", "three", "four", "five"});
+        combo.setEditable(true);
+        comboUI = new MyComboUI();
+        combo.setUI(comboUI);
+        combo.setSelectedIndex(3);
+        frame.getContentPane().add(combo);
+
+        frame.pack();
+        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
+        frame.setLocationRelativeTo(null);
+        frame.setVisible(true);
+    }
+
+    private static void test() throws AWTException {
+        Robot robot = new Robot();
+        robot.setAutoDelay(50);
+
+        // Open popup menu
+        realSync();
+        Util.hitKeys(robot, KeyEvent.VK_DOWN);
+
+        // Move mouse to the first popup menu item
+        realSync();
+        Point p = combo.getLocationOnScreen();
+        Dimension size = combo.getSize();
+        p.x += size.width / 2;
+        p.y += size.height;
+        float dy = 1;
+        robot.mouseMove(p.x, p.y - 5);
+        for (int i=1; i <= 10; i++) {
+            robot.mouseMove((int)(p.x), (int)(p.y - 5 + dy*i));
+        }
+
+        // Select the second popup menu item
+        realSync();
+        Util.hitKeys(robot, KeyEvent.VK_DOWN);
+
+        realSync();
+        JList list = comboUI.getComboPopup().getList();
+        if (list.getSelectedIndex() != 1) {
+            throw new RuntimeException("There is an inconsistence in combo box " +
+                    "behavior when user points an item in combo popup " +
+                    "by mouse and then uses UP/DOWN keys.");
+        }
+    }
+
+    private static void realSync() {
+        ((SunToolkit)Toolkit.getDefaultToolkit()).realSync();
+    }
+
+    // Gives access to BasicComboBoxUI.popup field
+    private static class MyComboUI extends MetalComboBoxUI {
+        public ComboPopup getComboPopup() {
+            return popup;
+        }
+    }
+}
--- ./jdk/test/javax/swing/JFileChooser/4150029/bug4150029.html	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/test/javax/swing/JFileChooser/4150029/bug4150029.html	Wed May 07 19:26:47 2014 -0700
@@ -1,6 +1,38 @@
 <html>
+<!--
+ Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+
+ This code is free software; you can redistribute it and/or modify it
+ under the terms of the GNU General Public License version 2 only, as
+ published by the Free Software Foundation.
+
+ This code is distributed in the hope that it will be useful, but WITHOUT
+ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ version 2 for more details (a copy is included in the LICENSE file that
+ accompanied this code).
+
+ You should have received a copy of the GNU General Public License version
+ 2 along with this work; if not, write to the Free Software Foundation,
+ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+
+ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ or visit www.oracle.com if you need additional information or have any
+ questions.
+-->
+
+<!--
+ @test
+ @bug 4150029 8006087
+ @summary BackSpace keyboard button does not lead to parent directory
+ @author Oleg Mokhovikov
+ @run applet/manual=done bug4150029.html
+-->
+
 <body>
 <applet  code="bug4150029.class" width=200 height=200></applet>
+Follow the instructions below.
 1.Go into 'subDir' folder.
 2.Press BACKSPACE key.
 3.Push OPEN button.
--- ./jdk/test/javax/swing/JFileChooser/4150029/bug4150029.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/test/javax/swing/JFileChooser/4150029/bug4150029.java	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -21,11 +21,10 @@
  * questions.
  */
 
-/* @test
-   @bug 4150029
-   @summary BackSpace keyboard button does not lead to parent directory
-   @author Oleg Mokhovikov
-   @run applet/manual=done bug4150029.html
+/*
+   bug 4150029 8006087
+   summary BackSpace keyboard button does not lead to parent directory
+   author Oleg Mokhovikov
 */
 
 import javax.swing.*;
@@ -36,6 +35,14 @@
     private boolean res;
 
     public void init() {
+        if (sun.awt.OSInfo.getOSType() == sun.awt.OSInfo.OSType.MACOSX) {
+            try {
+                UIManager.setLookAndFeel("javax.swing.plaf.metal.MetalLookAndFeel");
+            } catch (Exception e) {
+                throw new RuntimeException(e);
+            }
+        }
+
         String tmpDir = System.getProperty("java.io.tmpdir");
 
         if (tmpDir.length() == 0) {//'java.io.tmpdir' isn't guaranteed to be defined
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/javax/swing/JInternalFrame/4193219/IconCoord.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,161 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+/*
+  @test
+  @bug 4193219
+  @summary
+  @author Your Name: Hania Gajewska area=swing
+  @run main/manual IconCoord
+*/
+
+import java.awt.*;
+import java.awt.event.*;
+import javax.swing.*;
+
+public class IconCoord {
+    static Test test = new Test();
+
+    public static void main(String[] args) throws Exception {
+        UIManager.setLookAndFeel(UIManager.getCrossPlatformLookAndFeelClassName());
+        SwingUtilities.invokeAndWait(new Runnable() {
+            public void run() {
+                new IconCoord().createAndShowGUI();
+            }
+        });
+        test.waitTestResult();
+    }
+
+    private void createAndShowGUI() {
+        StringBuilder instrText = new StringBuilder();
+        instrText.append("First, iconify internal frame \"Frame 1\" by clicking on its iconify button.\n");
+        instrText.append("Now, maximize the top-level window \"IconCoord\".\n");
+        instrText.append("The \"Frame 1\" icon should stay in the lower left corner of the desktop; ");
+        instrText.append("if it doesn't, press \"Fail\".\n");
+        instrText.append("Now move the icon to the middle of the desktop by dragging it by its ");
+        instrText.append("bumpy left side. Then iconify \"Frame 2\" by clicking on its iconify button.\n");
+        instrText.append("If the icon for frame two gets placed in the lower left corner of the ");
+        instrText.append("desktop (where the icon for \"Frame 1\" used to be before you moved it), ");
+        instrText.append("press \"Pass\". Otherwise, press \"Fail\".\n");
+
+        JDesktopPane dt = new JDesktopPane();
+
+        JButton tf;
+        JInternalFrame if1 = new JInternalFrame("Frame 1", false, false, false, true);
+        JComponent c = (JComponent) if1.getContentPane();
+        c.setLayout(new BorderLayout());
+
+        tf = new JButton ("ignore");
+        c.add (tf, BorderLayout.NORTH);
+
+        tf = new JButton ("ignore");
+        c.add (tf, BorderLayout.CENTER);
+
+        JInternalFrame if2 = new JInternalFrame("Frame 2", false, false, false, true);
+        c = (JComponent) if2.getContentPane();
+        c.setLayout(new BorderLayout());
+
+        tf = new JButton ("ignore");
+        c.add (tf, BorderLayout.NORTH);
+
+        tf = new JButton ("ignore");
+        c.add (tf, BorderLayout.CENTER);
+
+        if1.pack();
+        if1.setBounds(300, 0, 300, 80);
+        if2.pack();
+        if2.setBounds(0, 0, 300, 80);
+        dt.add(if1);
+        dt.add(if2);
+
+        if1.setVisible(true);
+        if2.setVisible(true);
+
+        int frameHeight = 500;
+
+        JScrollPane dtScrollPane = new JScrollPane(dt);
+        JFrame frame = test.createTestFrame("IconCoord", dtScrollPane, instrText.toString(), 250);
+        dt.setPreferredSize(new Dimension(650, frameHeight - 250));
+        frame.setSize (600,500);
+        frame.setVisible(true);
+    }
+
+    static class Test {
+        private boolean pass;
+        JFrame createTestFrame(String name, Component topComponent, String instructions, int instrHeight) {
+            final String PASS = "Pass";
+            final String FAIL = "Fail";
+            JFrame frame = new JFrame(name);
+            frame.setLayout(new BorderLayout());
+
+            JPanel testButtonsPanel = new JPanel();
+            testButtonsPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, 20));
+
+            ActionListener btnAL = new ActionListener() {
+                public void actionPerformed(ActionEvent event) {
+                    switch (event.getActionCommand()) {
+                        case PASS:
+                            pass();
+                            break;
+                        default:
+                            throw new RuntimeException("Test failed.");
+                    }
+                }
+            };
+            JButton passBtn = new JButton(PASS);
+            passBtn.addActionListener(btnAL);
+            passBtn.setActionCommand(PASS);
+
+            JButton failBtn = new JButton(FAIL);
+            failBtn.addActionListener(btnAL);
+            failBtn.setActionCommand(FAIL);
+
+            testButtonsPanel.add(BorderLayout.WEST, passBtn);
+            testButtonsPanel.add(BorderLayout.EAST, failBtn);
+
+            JTextArea instrText = new JTextArea();
+            instrText.setLineWrap(true);
+            instrText.setEditable(false);
+            JScrollPane instrScrollPane = new JScrollPane(instrText);
+            instrScrollPane.setMaximumSize(new Dimension(Integer.MAX_VALUE, instrHeight));
+            instrText.append(instructions);
+
+            JPanel servicePanel = new JPanel();
+            servicePanel.setLayout(new BorderLayout());
+            servicePanel.add(BorderLayout.CENTER, instrScrollPane);
+            servicePanel.add(BorderLayout.SOUTH, testButtonsPanel);
+
+            frame.add(BorderLayout.SOUTH, servicePanel);
+            frame.add(BorderLayout.CENTER, topComponent);
+            return frame;
+        }
+        synchronized void pass() {
+            pass = true;
+            notifyAll();
+        }
+        synchronized void waitTestResult() throws InterruptedException {
+            while (!pass) {
+                wait();
+            }
+        }
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/javax/swing/JInternalFrame/4251301/bug4251301.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,139 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+/* @test
+   @bug 4251301
+   @summary Keybinding for show/hide the system menu.
+   @author Andrey Pikalev
+   @run main/manual bug4251301
+*/
+
+import javax.swing.*;
+import java.awt.*;
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+import java.beans.*;
+import sun.awt.OSInfo;
+import sun.awt.SunToolkit;
+
+
+public class bug4251301 {
+    private static final SunToolkit toolkit = (SunToolkit) Toolkit.getDefaultToolkit();
+    static Test test = new Test();
+    public static void main(String[] args) throws Exception {
+        if (OSInfo.getOSType() == OSInfo.OSType.MACOSX) {
+            System.out.println("This test is not applicable for MacOS. Passed.");
+            return;
+        }
+        UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
+        SwingUtilities.invokeAndWait(new Runnable() {
+            public void run() {
+                createAndShowGUI();
+            }
+        });
+        toolkit.realSync();
+        test.waitTestResult();
+    }
+
+    public static void createAndShowGUI() {
+        final StringBuilder instructions = new StringBuilder();
+        instructions.append("Click with your mouse the content area of the internal frame with the title \"IFrame\" ");
+        instructions.append("and press Ctrl+Space. \n");
+        instructions.append("If the system menu shows up, press Esc. Then system menu should hide. \n");
+        instructions.append("If you success then press \"Pass\", else press \"Fail\".\n");
+
+        JDesktopPane dp = new JDesktopPane();
+        JInternalFrame jif = new JInternalFrame("IFrame",true,true,true,true);
+        dp.add(jif);
+        jif.setBounds(20, 20, 220, 100);
+        jif.setVisible(true);
+        try {
+            jif.setSelected(true);
+        } catch(PropertyVetoException pve) {
+            pve.printStackTrace();
+            throw new Error("Occures PropertyVetoException while set selection...");
+        }
+        JScrollPane dtScrollPane = new JScrollPane(dp);
+        JFrame testFrame = test.createTestFrame("Instructions", dtScrollPane, instructions.toString(), 500);
+        testFrame.setSize(500, 400);
+        testFrame.setVisible(true);
+    }
+    static class Test {
+        private boolean pass;
+        JFrame createTestFrame(String name, Component topComponent, String instructions, int instrHeight) {
+            final String PASS = "Pass";
+            final String FAIL = "Fail";
+            JFrame frame = new JFrame(name);
+            frame.setLayout(new BorderLayout());
+
+            JPanel testButtonsPanel = new JPanel();
+            testButtonsPanel.setMaximumSize(new Dimension(Integer.MAX_VALUE, 20));
+
+            ActionListener btnAL = new ActionListener() {
+                public void actionPerformed(ActionEvent event) {
+                    switch (event.getActionCommand()) {
+                        case PASS:
+                            pass();
+                            break;
+                        default:
+                            throw new RuntimeException("Test failed.");
+                    }
+                }
+            };
+            JButton passBtn = new JButton(PASS);
+            passBtn.addActionListener(btnAL);
+            passBtn.setActionCommand(PASS);
+
+            JButton failBtn = new JButton(FAIL);
+            failBtn.addActionListener(btnAL);
+            failBtn.setActionCommand(FAIL);
+
+            testButtonsPanel.add(BorderLayout.WEST, passBtn);
+            testButtonsPanel.add(BorderLayout.EAST, failBtn);
+
+            JTextArea instrText = new JTextArea();
+            instrText.setLineWrap(true);
+            instrText.setEditable(false);
+            JScrollPane instrScrollPane = new JScrollPane(instrText);
+            instrScrollPane.setMaximumSize(new Dimension(Integer.MAX_VALUE, instrHeight));
+            instrText.append(instructions);
+
+            JPanel servicePanel = new JPanel();
+            servicePanel.setLayout(new BorderLayout());
+            servicePanel.add(BorderLayout.CENTER, instrScrollPane);
+            servicePanel.add(BorderLayout.SOUTH, testButtonsPanel);
+
+            frame.add(BorderLayout.SOUTH, servicePanel);
+            frame.add(BorderLayout.CENTER, topComponent);
+            return frame;
+        }
+        synchronized void pass() {
+            pass = true;
+            notifyAll();
+        }
+        synchronized void waitTestResult() throws InterruptedException {
+            while (!pass) {
+                wait();
+            }
+        }
+    }
+}
--- ./jdk/test/javax/swing/JInternalFrame/InternalFrameIsNotCollectedTest.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/test/javax/swing/JInternalFrame/InternalFrameIsNotCollectedTest.java	Wed May 07 19:26:47 2014 -0700
@@ -27,19 +27,19 @@
     @author mcherkas
     @run main InternalFrameIsNotCollectedTest
  */
-
 import sun.awt.SunToolkit;
 
 import javax.swing.*;
 import java.awt.*;
-import java.awt.event.KeyEvent;
 import java.beans.PropertyVetoException;
 import java.util.Date;
 
 public class InternalFrameIsNotCollectedTest {
 
-    public static final int waitTime = 10000;
+    public static final int maxWaitTime = 100000;
+    public static final int waitTime = 5000;
     private static Robot robot;
+    private static CustomInternalFrame iFrame;
 
     public static void sync() {
 
@@ -62,12 +62,13 @@
         });
         sync();
         invokeGC();
+        System.runFinalization();
         Thread.sleep(1000); // it's better to wait 1 sec now then 10 sec later
         Date startWaiting = new Date();
         synchronized (CustomInternalFrame.waiter) {
             // Sync with finalization thread.
             Date now = new Date();
-            while (now.getTime() - startWaiting.getTime() < waitTime && !CustomInternalFrame.finalized) {
+            while (now.getTime() - startWaiting.getTime() < maxWaitTime && !CustomInternalFrame.finalized) {
                 CustomInternalFrame.waiter.wait(waitTime);
                 now = new Date();
             }
@@ -83,10 +84,8 @@
     }
 
     private static void closeInternalFrame() throws PropertyVetoException {
-        robot.keyPress(KeyEvent.VK_CONTROL);
-        robot.keyPress(KeyEvent.VK_F4);
-        robot.keyRelease(KeyEvent.VK_F4);
-        robot.keyRelease(KeyEvent.VK_CONTROL);
+        iFrame.setClosed(true);
+        iFrame = null;
     }
 
     private static void initUI() {
@@ -96,7 +95,7 @@
         desktopPane.setDesktopManager(new DefaultDesktopManager());
         frame.getContentPane().add(desktopPane, BorderLayout.CENTER);
 
-        CustomInternalFrame iFrame = new CustomInternalFrame("Dummy Frame");
+        iFrame = new CustomInternalFrame("Dummy Frame");
 
         iFrame.setSize(200, 200);
         iFrame.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/javax/swing/JMenuBar/4750590/bug4750590.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,98 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/* @test
+ @library ../../regtesthelpers
+ @build Util
+ @bug 4750590 8015597
+ @summary SwingSet: Cannot change Themes using menu accelerators
+ @author Alexander Zuev
+ @run main bug4750590
+ */
+
+import javax.swing.*;
+import java.awt.event.*;
+import java.awt.*;
+
+public class bug4750590 {
+
+    public static PassedListener pass = new PassedListener();
+    public static volatile boolean passed = false;
+
+    public static void main(String args[]) throws Throwable {
+
+        SwingUtilities.invokeAndWait(new Runnable() {
+            @Override
+            public void run() {
+                createAndShowGUI();
+            }
+        });
+
+        sun.awt.SunToolkit toolkit = (sun.awt.SunToolkit) Toolkit.getDefaultToolkit();
+        toolkit.realSync();
+
+        Robot robo = new Robot();
+        robo.setAutoDelay(500);
+        Util.hitMnemonics(robo, KeyEvent.VK_F);
+        robo.keyPress(KeyEvent.VK_M);
+        robo.keyRelease(KeyEvent.VK_M);
+
+        toolkit.realSync();
+
+        if (passed) {
+            System.out.println("Test passed!");
+        } else {
+            throw new RuntimeException("Test FAILED!");
+        }
+    }
+
+    private static void createAndShowGUI() {
+        JFrame mainFrame = new JFrame("Bug 4750590");
+        JMenuBar mbar = new JMenuBar();
+        JMenu menu = new JMenu("File");
+        menu.setMnemonic('F');
+        JMenu submenu = new JMenu("Submenu");
+        submenu.add(new JMenuItem("SubMenu Item 1")).setMnemonic('S');
+        submenu.add(new JMenuItem("SubMenu Item 2"));
+        menu.add(submenu);
+
+        menu.add(new JMenuItem("Menu Item 1"));
+        JMenuItem menuItem = menu.add(new JMenuItem("Menu Item 2"));
+        menuItem.setMnemonic('M');
+        menuItem.addActionListener(pass);
+        mbar.add(menu);
+        mainFrame.setJMenuBar(mbar);
+
+        mainFrame.setSize(200, 200);
+        mainFrame.setLocation(200, 200);
+        mainFrame.setVisible(true);
+        mainFrame.toFront();
+    }
+
+    public static class PassedListener implements ActionListener {
+        public void actionPerformed(ActionEvent ev) {
+            passed = true;
+        }
+    }
+
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/javax/swing/JMenuItem/4171437/bug4171437.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,108 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+/* @test
+   @bug 4171437
+   @library ../../regtesthelpers
+   @build Util
+   @author Georges Saab
+   @run main bug4171437
+*/
+import java.awt.*;
+import java.awt.event.*;
+import java.util.ArrayList;
+import javax.swing.*;
+import javax.swing.event.*;
+import sun.awt.SunToolkit;
+
+public class bug4171437 {
+    static volatile boolean closeActivated = false;
+    static volatile boolean customActivated = false;
+
+    public static void main(String[] args) throws Exception {
+        SwingUtilities.invokeAndWait(new Runnable() {
+            public void run() {
+                createAndShowGUI();
+            }
+        });
+
+        SunToolkit toolkit = (SunToolkit) Toolkit.getDefaultToolkit();
+        toolkit.realSync();
+
+        Robot robot = new Robot();
+        robot.setAutoDelay(50);
+
+        Util.hitMnemonics(robot, KeyEvent.VK_F);
+        Util.hitKeys(robot, KeyEvent.VK_C);
+
+        toolkit.realSync();
+        Thread.sleep(1000);
+
+        if (!closeActivated || customActivated) {
+            throw new RuntimeException("Didn't pass the muster");
+        }
+    }
+    public static void createAndShowGUI() {
+        JMenuBar menubar = new JMenuBar();
+
+        JMenu fileMenu = new JMenu("File");
+        fileMenu.setMnemonic('f');
+
+        JMenuItem fmi1 = new JMenuItem();
+        fmi1 = new JMenuItem("Open");
+        JMenuItem fmi2 = new JMenuItem();
+        fmi2 = new JMenuItem("Close");
+        fmi2.setMnemonic('c');
+        fmi2.addActionListener(new ActionListener() {
+            public void actionPerformed(ActionEvent e) {
+                closeActivated = true;
+            }
+        });
+
+        fileMenu.add( fmi1);
+        fileMenu.add( fmi2);
+
+        menubar.add( fileMenu);
+
+        JMenu custom = new JMenu("Custom");
+        custom.setMnemonic('c');
+        JMenuItem cmi = new JMenuItem();
+        cmi = new JMenuItem("Properties");
+        cmi.setMnemonic('p');
+        custom.add( cmi);
+        custom.addMenuListener(new MenuListener() {
+            public void menuSelected(MenuEvent e) {
+                customActivated = true;
+            }
+            public void menuDeselected(MenuEvent e) {}
+            public void menuCanceled(MenuEvent e) {}
+        });
+        menubar.add( custom);
+
+        JFrame frame = new JFrame();
+        frame.setJMenuBar( menubar);
+        frame.setSize(300, 300);
+        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
+        frame.pack();
+        frame.setVisible(true);
+    }
+}
--- ./jdk/test/javax/swing/JMenuItem/ActionListenerCalledTwice/ActionListenerCalledTwiceTest.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/test/javax/swing/JMenuItem/ActionListenerCalledTwice/ActionListenerCalledTwiceTest.java	Wed May 07 19:26:47 2014 -0700
@@ -35,11 +35,12 @@
 import javax.swing.*;
 
 public class ActionListenerCalledTwiceTest {
-    static String menuItems[] = { "Item1", "Item2", "Item3" };
+    static String menuItems[] = { "Item1", "Item2", "Item3", "Item4" };
     static KeyStroke keyStrokes[] = {
         KeyStroke.getKeyStroke(KeyEvent.VK_E, InputEvent.META_MASK),
         KeyStroke.getKeyStroke(KeyEvent.VK_DELETE, 0),
         KeyStroke.getKeyStroke(KeyEvent.VK_UP, InputEvent.SHIFT_MASK),
+        KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, InputEvent.META_MASK)
     };
 
     static volatile int listenerCallCounter = 0;
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/javax/swing/JPopupMenu/4458079/bug4458079.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,110 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+/* @test
+   @bug 4458079
+   @library ../../regtesthelpers
+   @build Util
+   @summary Tests calling removeAll() from PopupMenuListener
+   @author Peter Zhelezniakov
+   @run main bug4458079
+*/
+import java.awt.Robot;
+import java.awt.Toolkit;
+import java.awt.event.*;
+import javax.swing.*;
+import javax.swing.event.*;
+import java.awt.event.KeyEvent;
+import java.util.ArrayList;
+import sun.awt.SunToolkit;
+
+public class bug4458079 extends JFrame implements PopupMenuListener {
+    public JMenu menu;
+
+    static volatile boolean itemASelected = false;
+    public static void main(String[] args) throws Exception {
+        SwingUtilities.invokeAndWait(new Runnable() {
+            public void run() {
+                new bug4458079().createAndShowGUI();
+            }
+        });
+        SunToolkit toolkit = (SunToolkit) Toolkit.getDefaultToolkit();
+        toolkit.realSync();
+
+        Robot robot = new Robot();
+        robot.setAutoDelay(50);
+
+        Util.hitMnemonics(robot, KeyEvent.VK_M);
+
+        toolkit.realSync();
+        Thread.sleep(1000);
+
+        Util.hitKeys(robot, KeyEvent.VK_DOWN);
+        Util.hitKeys(robot, KeyEvent.VK_ENTER);
+
+        toolkit.realSync();
+        Thread.sleep(1000);
+
+        if (!itemASelected) {
+            throw new RuntimeException("Test failed: arrow key traversal in JMenu broken!");
+        }
+    }
+    public void createAndShowGUI() {
+        JMenuBar bar = new JMenuBar();
+        menu = new JMenu("Menu");
+        menu.add(new JMenuItem("1"));
+        menu.add(new JMenuItem("2"));
+        menu.setMnemonic(KeyEvent.VK_M);
+        menu.getPopupMenu().addPopupMenuListener(this);
+        bar.add(menu);
+
+        setJMenuBar(bar);
+        getContentPane().add(new JButton(""));
+        setSize(300, 300);
+        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
+        pack();
+        setVisible(true);
+    }
+
+    public void rebuildMenu() {
+        menu.removeAll();
+        final String itemCommand = "A";
+        JMenuItem item = new JMenuItem(itemCommand);
+        item.addActionListener(new ActionListener() {
+            public void actionPerformed(ActionEvent e) {
+                JMenuItem item = ((JMenuItem)e.getSource());
+                if (e.getActionCommand() == itemCommand) {
+                    itemASelected = true;
+                }
+            }
+        });
+        menu.add(item);
+        menu.add(new JMenuItem("B"));
+    }
+
+    public void popupMenuWillBecomeVisible(PopupMenuEvent e) {
+        rebuildMenu();
+    }
+
+    public void popupMenuWillBecomeInvisible(PopupMenuEvent e) {}
+    public void popupMenuCanceled(PopupMenuEvent e) {}
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/javax/swing/JSplitPane/4816114/bug4816114.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,151 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+/* @test
+   @bug 4816114
+   @summary REGRESSION: Regression in divider location behavior when JSplitPane is resized
+   @author Andrey Pikalev
+   @run main bug4816114
+*/
+
+import javax.swing.*;
+import java.awt.*;
+import java.lang.reflect.*;
+import sun.awt.SunToolkit;
+
+
+public class bug4816114 {
+
+    JFrame fr;
+    JSplitPane splitPane;
+
+    boolean[] resized = new boolean[] { false, false, false,
+                                        false, false, false };
+    static int step = 0;
+    boolean h_passed = false;
+    boolean v_passed = false;
+
+    static bug4816114 test = new bug4816114();
+
+    public static void main(String[] args) throws InterruptedException, InvocationTargetException {
+        SwingUtilities.invokeAndWait(new Runnable() {
+            public void run() {
+                test.createAndShowGUI();
+            }
+        });
+        SunToolkit toolkit = (SunToolkit) Toolkit.getDefaultToolkit();
+        toolkit.realSync();
+        Thread.sleep(1000);
+
+        step++;
+        test.doTest(150, 300);
+
+        step++;
+        test.doTest(650, 300);
+
+        SwingUtilities.invokeAndWait(new Runnable() {
+            public void run() {
+                test.splitPane.setOrientation(JSplitPane.VERTICAL_SPLIT);
+            }
+        });
+
+        step++;
+        test.doTest(300, 650);
+
+        step++;
+        test.doTest(300, 150);
+
+        step++;
+        test.doTest(300, 650);
+
+        if ( !test.isPassed() ) {
+            throw new Error("The divider location is wrong.");
+        }
+    }
+    public void createAndShowGUI() {
+        fr = new JFrame("Test");
+
+        splitPane = new TestSplitPane();
+        splitPane.setOrientation(JSplitPane.HORIZONTAL_SPLIT);
+        splitPane.setResizeWeight(0);
+        splitPane.setBorder(BorderFactory.createEmptyBorder(1, 1, 1, 1));
+
+        JButton leftButton = new JButton("LEFT");
+        leftButton.setPreferredSize(new Dimension(300, 300));
+        leftButton.setMinimumSize(new Dimension(150, 150));
+        splitPane.setLeftComponent(leftButton);
+
+        JButton rightButton = new JButton("RIGHT");
+        rightButton.setPreferredSize(new Dimension(300, 300));
+        rightButton.setMinimumSize(new Dimension(150, 150));
+        splitPane.setRightComponent(rightButton);
+
+        fr.getContentPane().add(splitPane, BorderLayout.CENTER);
+
+        fr.pack();
+        fr.setVisible(true);
+    }
+
+    void doTest(final int width, final int height)  throws InterruptedException, InvocationTargetException {
+        SwingUtilities.invokeAndWait(new Runnable() {
+            public void run() {
+                splitPane.setPreferredSize(new Dimension(width, height));
+                fr.pack();
+            }
+        });
+
+        synchronized (bug4816114.this) {
+            while (!resized[step]) {
+                bug4816114.this.wait();
+            }
+        }
+    }
+
+   synchronized void setPassed(int orientation, boolean passed) {
+       if (orientation == JSplitPane.HORIZONTAL_SPLIT) {
+           this.h_passed = passed;
+       }
+       else {
+           this.v_passed = passed;
+       }
+   }
+
+    synchronized boolean isPassed() {
+        return h_passed && v_passed;
+    }
+
+
+    class TestSplitPane extends JSplitPane {
+        public void setDividerLocation(int location) {
+            super.setDividerLocation(location);
+
+            if ( splitPane.getDividerLocation() == 151 ) {
+                setPassed(getOrientation(), true);
+            }
+
+            synchronized (bug4816114.this) {
+                resized[step] = true;
+                bug4816114.this.notifyAll();
+            }
+        }
+    }
+}
--- ./jdk/test/javax/swing/JTable/7068740/bug7068740.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/test/javax/swing/JTable/7068740/bug7068740.java	Wed May 07 19:26:47 2014 -0700
@@ -37,6 +37,7 @@
 import java.awt.*;
 import java.awt.event.KeyEvent;
 import java.lang.reflect.InvocationTargetException;
+import java.util.concurrent.atomic.AtomicInteger;
 
 public class bug7068740 extends JFrame {
 
@@ -66,6 +67,7 @@
         };
 
         table = new JTable(model);
+        table.setRowSelectionInterval(0, 0);
         LayerUI<JComponent> layerUI = new LayerUI<>();
         JLayer<JComponent> layer = new JLayer<>(table, layerUI);
         JScrollPane scrollPane = new JScrollPane(layer);
@@ -78,7 +80,7 @@
         try {
             if (robot == null) {
                 robot = new Robot();
-                robot.setAutoDelay(20);
+                robot.setAutoDelay(50);
             }
 
             if (toolkit == null) {
@@ -104,24 +106,37 @@
         }
     }
 
-    private static void doTest() {
+    private static int getSelectedRow() throws Exception {
+        final AtomicInteger row = new AtomicInteger(-1);
+        SwingUtilities.invokeAndWait(new Runnable() {
+            @Override
+            public void run() {
+                row.set(table.getSelectedRow());
+            }
+        });
+        return row.intValue();
+    }
+
+    private static void doTest() throws Exception {
         toolkit.realSync();
-        table.setRowSelectionInterval(0, 0);
 
         robot.keyPress(KeyEvent.VK_PAGE_DOWN);
+        robot.keyRelease(KeyEvent.VK_PAGE_DOWN);
         toolkit.realSync();
-        if (table.getSelectedRow() != 19) {
+
+        if (getSelectedRow() != 19) {
             throw new RuntimeException("Test failed");
         }
 
         robot.keyPress(KeyEvent.VK_PAGE_UP);
+        robot.keyRelease(KeyEvent.VK_PAGE_UP);
         toolkit.realSync();
-        if (table.getSelectedRow() != 0) {
+        if (getSelectedRow() != 0) {
             throw new RuntimeException("Test failed");
         }
     }
 
-    public static void main(String[] args) {
+    public static void main(String[] args) throws Exception {
         try {
             UIManager.setLookAndFeel(new MetalLookAndFeel());
             setUp();
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/javax/swing/JTree/4927934/bug4927934.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,247 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+/* @test
+   @bug 4927934
+   @summary JTree traversal is unlike Native windows tree traversal
+   @author Andrey Pikalev
+   @run main bug4927934
+*/
+
+import javax.swing.*;
+import javax.swing.event.*;
+import javax.swing.tree.*;
+import java.awt.*;
+import java.awt.event.*;
+import java.lang.reflect.InvocationTargetException;
+import sun.awt.*;
+
+public class bug4927934 implements TreeSelectionListener, TreeExpansionListener, FocusListener {
+
+    final static Object listener = new bug4927934();
+
+    static boolean focusGained = false;
+    public static boolean selectionChanged = false;
+    public static boolean treeExpanded = false;
+    public static boolean treeCollapsed = false;
+
+    static JFrame frame;
+    static JTree tree;
+    static Robot robot;
+
+    public static void main(String args[]) throws Exception {
+        UIManager.setLookAndFeel(new javax.swing.plaf.metal.MetalLookAndFeel());
+
+        robot = new Robot();
+        robot.setAutoDelay(50);
+
+        SwingUtilities.invokeAndWait(new Runnable() {
+            public void run() {
+                frame = new JFrame();
+
+                DefaultMutableTreeNode root = new DefaultMutableTreeNode("root");
+                createNodes(root);
+                tree = new JTree(root);
+                JScrollPane scrollPane = new JScrollPane(tree);
+                frame.getContentPane().add(scrollPane);
+
+                tree.addFocusListener((FocusListener)listener);
+                tree.addTreeSelectionListener((TreeSelectionListener)listener);
+                tree.addTreeExpansionListener((TreeExpansionListener)listener);
+
+                frame.setSize(300, 300);
+                frame.setVisible(true);
+            }
+        });
+
+        SunToolkit toolkit = (SunToolkit) Toolkit.getDefaultToolkit();
+        toolkit.realSync();
+        Thread.sleep(1000);
+
+        SwingUtilities.invokeLater(new Runnable() {
+            public void run() {
+                tree.requestFocus();
+            }
+        });
+
+        synchronized(listener) {
+            if (!focusGained) {
+                System.out.println("waiting focusGained...");
+                try {
+                    listener.wait(10000);
+                } catch (InterruptedException e) {
+                    e.printStackTrace();
+                }
+            }
+        }
+
+        // GO TO RIGHT
+        selectionChanged = false;
+        hitKey(KeyEvent.VK_RIGHT);
+        toolkit.realSync();
+        if (!checkSelectionChanged(tree, 0)) {
+            throw new RuntimeException("Root should be selected");
+        }
+
+        selectionChanged = false;
+        hitKey(KeyEvent.VK_RIGHT);
+        toolkit.realSync();
+        if (!checkSelectionChanged(tree, 1)) {
+            throw new RuntimeException("Node should be selected");
+        }
+
+        treeExpanded = false;
+        hitKey(KeyEvent.VK_RIGHT);
+        toolkit.realSync();
+        if (!isTreeExpanded()) {
+            throw new RuntimeException("Node should be expanded");
+        }
+
+        selectionChanged = false;
+        hitKey(KeyEvent.VK_RIGHT);
+        toolkit.realSync();
+        if (!checkSelectionChanged(tree, 2)) {
+            throw new RuntimeException("Leaf1 should be selected");
+        }
+
+        selectionChanged = false;
+        hitKey(KeyEvent.VK_RIGHT);
+        toolkit.realSync();
+        if (!checkSelectionChanged(tree, 2)) {
+            throw new RuntimeException("Leaf1 should be selected");
+        }
+
+        // GO TO LEFT
+        selectionChanged = false;
+        hitKey(KeyEvent.VK_LEFT);
+        toolkit.realSync();
+        if (!checkSelectionChanged(tree, 1)) {
+            throw new RuntimeException("Node should be selected");
+        }
+
+        treeCollapsed = false;
+        hitKey(KeyEvent.VK_LEFT);
+        if (!isTreeCollapsed()) {
+            throw new RuntimeException("Node should be collapsed");
+        }
+
+        selectionChanged = false;
+        hitKey(KeyEvent.VK_LEFT);
+        toolkit.realSync();
+        if (!checkSelectionChanged(tree, 0)) {
+            throw new RuntimeException("Root should be selected");
+        }
+
+        treeCollapsed = false;
+        hitKey(KeyEvent.VK_LEFT);
+        toolkit.realSync();
+        if (!isTreeCollapsed()) {
+            throw new RuntimeException("Root should be collapsed");
+        }
+    }
+
+
+    synchronized public void focusLost(FocusEvent e) {
+    }
+
+    synchronized public void focusGained(FocusEvent e) {
+        focusGained = true;
+        System.out.println("focusGained");
+        listener.notifyAll();
+    }
+
+    private static void createNodes(DefaultMutableTreeNode root) {
+        DefaultMutableTreeNode node = new DefaultMutableTreeNode("Node");
+        node.add(new DefaultMutableTreeNode("Leaf1"));
+        node.add(new DefaultMutableTreeNode("Leaf2"));
+        root.add(node);
+        root.add(new DefaultMutableTreeNode("Leaf3"));
+    }
+
+    synchronized public void valueChanged(TreeSelectionEvent e) {
+        selectionChanged = true;
+        System.out.println("selectionChanged");
+        notifyAll();
+    }
+
+    synchronized public void treeCollapsed(TreeExpansionEvent e) {
+        System.out.println("treeCollapsed");
+        treeCollapsed = true;
+        notifyAll();
+    }
+
+    synchronized public void treeExpanded(TreeExpansionEvent e) {
+        System.out.println("treeExpanded");
+        treeExpanded = true;
+        notifyAll();
+    }
+
+    private static void hitKey(int key) {
+        System.out.println("key " + key + " pressed");
+        robot.keyPress(key);
+        robot.keyRelease(key);
+    }
+
+    private static boolean checkSelectionChanged(JTree tree, int shouldBeSel) {
+        synchronized(listener) {
+            if (!selectionChanged) {
+                System.out.println("waiting for selectionChanged...");
+                try {
+                    listener.wait(5000);
+                } catch (InterruptedException e) {
+                    e.printStackTrace();
+                }
+            }
+        }
+        int selRow = tree.getLeadSelectionRow();
+        System.out.println("Selected row: " + selRow);
+        return selRow == shouldBeSel;
+    }
+
+    private static boolean isTreeExpanded() {
+        synchronized(listener) {
+            if (!treeExpanded) {
+                System.out.println("waiting for treeExpanded...");
+                try {
+                    listener.wait(5000);
+                } catch (InterruptedException e) {
+                    e.printStackTrace();
+                }
+            }
+        }
+        return treeExpanded;
+    }
+
+    private static boolean isTreeCollapsed() {
+        synchronized(listener) {
+            if (!treeCollapsed) {
+                System.out.println("waiting for treeCollapsed...");
+                try {
+                    listener.wait(5000);
+                } catch (InterruptedException e) {
+                    e.printStackTrace();
+                }
+            }
+        }
+        return treeCollapsed;
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/javax/swing/Popup/TaskbarPositionTest.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,340 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import java.awt.*;
+import java.awt.event.*;
+import javax.swing.*;
+import javax.swing.event.*;
+
+/**
+ * @test @bug 4245587 4474813 4425878 4767478 8015599
+ * @author Mark Davidson
+ * @summary Tests the location of the heavy weight popup portion of JComboBox,
+ * JMenu and JPopupMenu.
+ * @library ../regtesthelpers
+ * @build Util
+ * @run main TaskbarPositionTest
+ */
+public class TaskbarPositionTest extends JFrame implements ActionListener {
+
+    private boolean done;
+    private Throwable error;
+    private static TaskbarPositionTest test;
+    private static JPopupMenu popupMenu;
+    private static JPanel panel;
+    private static JComboBox<String> combo1;
+    private static JComboBox<String> combo2;
+    private static JMenuBar menubar;
+    private static JMenu menu1;
+    private static JMenu menu2;
+    private static Rectangle fullScreenBounds;
+    // The usable desktop space: screen size - screen insets.
+    private static Rectangle screenBounds;
+    private static String[] numData = {
+        "One", "Two", "Three", "Four", "Five", "Six", "Seven"
+    };
+    private static String[] dayData = {
+        "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"
+    };
+    private static char[] mnDayData = {
+        'M', 'T', 'W', 'R', 'F', 'S', 'U'
+    };
+
+    public TaskbarPositionTest() {
+        super("Use CTRL-down to show a JPopupMenu");
+        setContentPane(panel = createContentPane());
+        setJMenuBar(createMenuBar("1 - First Menu", true));
+        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
+
+        // CTRL-down will show the popup.
+        panel.getInputMap().put(KeyStroke.getKeyStroke(
+                KeyEvent.VK_DOWN, InputEvent.CTRL_MASK), "OPEN_POPUP");
+        panel.getActionMap().put("OPEN_POPUP", new PopupHandler());
+
+        pack();
+
+        Toolkit toolkit = Toolkit.getDefaultToolkit();
+        fullScreenBounds = new Rectangle(new Point(), toolkit.getScreenSize());
+        screenBounds = new Rectangle(new Point(), toolkit.getScreenSize());
+
+        // Place the frame near the bottom. This is a pretty wild guess.
+        this.setLocation(0, (int) screenBounds.getHeight() - 2 * this.getHeight());
+
+        // Reduce the screen bounds by the insets.
+        GraphicsConfiguration gc = this.getGraphicsConfiguration();
+        if (gc != null) {
+            Insets screenInsets = toolkit.getScreenInsets(gc);
+            screenBounds = gc.getBounds();
+            screenBounds.width -= (screenInsets.left + screenInsets.right);
+            screenBounds.height -= (screenInsets.top + screenInsets.bottom);
+            screenBounds.x += screenInsets.left;
+            screenBounds.y += screenInsets.top;
+        }
+
+        setVisible(true);
+    }
+
+    public static class ComboPopupCheckListener implements PopupMenuListener {
+
+        public void popupMenuCanceled(PopupMenuEvent ev) {
+        }
+
+        public void popupMenuWillBecomeVisible(PopupMenuEvent ev) {
+        }
+
+        public void popupMenuWillBecomeInvisible(PopupMenuEvent ev) {
+            Point cpos = combo1.getLocation();
+            SwingUtilities.convertPointToScreen(cpos, panel);
+
+            JPopupMenu pm = (JPopupMenu) combo1.getUI().getAccessibleChild(combo1, 0);
+
+            if (pm != null) {
+                Point p = pm.getLocation();
+                SwingUtilities.convertPointToScreen(p, pm);
+                if (p.y < cpos.y) {
+                    throw new RuntimeException("ComboBox popup is wrongly aligned");
+                }  // check that popup was opened down
+            }
+        }
+    }
+
+    private class PopupHandler extends AbstractAction {
+
+        public void actionPerformed(ActionEvent e) {
+            if (!popupMenu.isVisible()) {
+                popupMenu.show((Component) e.getSource(), 40, 40);
+            }
+            isPopupOnScreen(popupMenu, fullScreenBounds);
+        }
+    }
+
+    class PopupListener extends MouseAdapter {
+
+        private JPopupMenu popup;
+
+        public PopupListener(JPopupMenu popup) {
+            this.popup = popup;
+        }
+
+        public void mousePressed(MouseEvent e) {
+            maybeShowPopup(e);
+        }
+
+        public void mouseReleased(MouseEvent e) {
+            maybeShowPopup(e);
+        }
+
+        private void maybeShowPopup(MouseEvent e) {
+            if (e.isPopupTrigger()) {
+                popup.show(e.getComponent(), e.getX(), e.getY());
+                isPopupOnScreen(popup, fullScreenBounds);
+            }
+        }
+    }
+
+    /**
+     * Tests if the popup is on the screen.
+     */
+    public static void isPopupOnScreen(JPopupMenu popup, Rectangle checkBounds) {
+        Dimension dim = popup.getSize();
+        Point pt = new Point();
+        SwingUtilities.convertPointToScreen(pt, popup);
+        Rectangle bounds = new Rectangle(pt, dim);
+
+        if (!SwingUtilities.isRectangleContainingRectangle(checkBounds, bounds)) {
+            throw new RuntimeException("We do not match! " + checkBounds + " / " + bounds);
+        }
+
+    }
+
+    private JPanel createContentPane() {
+        JPanel panel = new JPanel();
+
+        combo1 = new JComboBox<>(numData);
+        panel.add(combo1);
+        combo2 = new JComboBox<>(dayData);
+        combo2.setEditable(true);
+        panel.add(combo2);
+        panel.setSize(300, 200);
+
+        popupMenu = new JPopupMenu();
+        JMenuItem item;
+        for (int i = 0; i < dayData.length; i++) {
+            item = popupMenu.add(new JMenuItem(dayData[i], mnDayData[i]));
+            item.addActionListener(this);
+        }
+        panel.addMouseListener(new PopupListener(popupMenu));
+
+        JTextField field = new JTextField("CTRL+down for Popup");
+        // CTRL-down will show the popup.
+        field.getInputMap().put(KeyStroke.getKeyStroke(
+                KeyEvent.VK_DOWN, InputEvent.CTRL_MASK), "OPEN_POPUP");
+        field.getActionMap().put("OPEN_POPUP", new PopupHandler());
+
+        panel.add(field);
+
+        return panel;
+    }
+
+    /**
+     * @param str name of Menu
+     * @param bFlag set mnemonics on menu items
+     */
+    private JMenuBar createMenuBar(String str, boolean bFlag) {
+        menubar = new JMenuBar();
+
+        menu1 = new JMenu(str);
+        menu1.setMnemonic(str.charAt(0));
+        menu1.addActionListener(this);
+
+        menubar.add(menu1);
+        for (int i = 0; i < 8; i++) {
+            JMenuItem menuitem = new JMenuItem("1 JMenuItem" + i);
+            menuitem.addActionListener(this);
+            if (bFlag) {
+                menuitem.setMnemonic('0' + i);
+            }
+            menu1.add(menuitem);
+        }
+
+        // second menu
+        menu2 = new JMenu("2 - Second Menu");
+        menu2.addActionListener(this);
+        menu2.setMnemonic('2');
+
+        menubar.add(menu2);
+        for (int i = 0; i < 5; i++) {
+            JMenuItem menuitem = new JMenuItem("2 JMenuItem" + i);
+            menuitem.addActionListener(this);
+
+            if (bFlag) {
+                menuitem.setMnemonic('0' + i);
+            }
+            menu2.add(menuitem);
+        }
+        JMenu submenu = new JMenu("Sub Menu");
+        submenu.setMnemonic('S');
+        submenu.addActionListener(this);
+        for (int i = 0; i < 5; i++) {
+            JMenuItem menuitem = new JMenuItem("S JMenuItem" + i);
+            menuitem.addActionListener(this);
+            if (bFlag) {
+                menuitem.setMnemonic('0' + i);
+            }
+            submenu.add(menuitem);
+        }
+        menu2.add(new JSeparator());
+        menu2.add(submenu);
+
+        return menubar;
+    }
+
+    public void actionPerformed(ActionEvent evt) {
+        Object obj = evt.getSource();
+        if (obj instanceof JMenuItem) {
+            // put the focus on the noneditable combo.
+            combo1.requestFocus();
+        }
+    }
+
+    public static void main(String[] args) throws Throwable {
+
+        sun.awt.SunToolkit toolkit = (sun.awt.SunToolkit) Toolkit.getDefaultToolkit();
+
+        SwingUtilities.invokeAndWait(new Runnable() {
+            public void run() {
+                test = new TaskbarPositionTest();
+            }
+        });
+
+        // Use Robot to automate the test
+        Robot robot;
+        robot = new Robot();
+        robot.setAutoDelay(125);
+
+        // 1 - menu
+        Util.hitMnemonics(robot, KeyEvent.VK_1);
+
+        toolkit.realSync();
+        isPopupOnScreen(menu1.getPopupMenu(), screenBounds);
+
+        // 2 menu with sub menu
+        robot.keyPress(KeyEvent.VK_RIGHT);
+        robot.keyRelease(KeyEvent.VK_RIGHT);
+        Util.hitMnemonics(robot, KeyEvent.VK_S);
+
+        toolkit.realSync();
+        isPopupOnScreen(menu2.getPopupMenu(), screenBounds);
+
+        robot.keyPress(KeyEvent.VK_ENTER);
+        robot.keyRelease(KeyEvent.VK_ENTER);
+
+        // Focus should go to non editable combo box
+        toolkit.realSync();
+        Thread.sleep(500);
+
+        robot.keyPress(KeyEvent.VK_DOWN);
+
+        // How do we check combo boxes?
+
+        // Editable combo box
+        robot.keyPress(KeyEvent.VK_TAB);
+        robot.keyRelease(KeyEvent.VK_TAB);
+        robot.keyPress(KeyEvent.VK_DOWN);
+        robot.keyRelease(KeyEvent.VK_DOWN);
+
+        // combo1.getUI();
+
+        // Popup from Text field
+        robot.keyPress(KeyEvent.VK_TAB);
+        robot.keyRelease(KeyEvent.VK_TAB);
+        robot.keyPress(KeyEvent.VK_CONTROL);
+        robot.keyPress(KeyEvent.VK_DOWN);
+        robot.keyRelease(KeyEvent.VK_DOWN);
+        robot.keyRelease(KeyEvent.VK_CONTROL);
+
+        // Popup from a mouse click.
+        Point pt = new Point(2, 2);
+        SwingUtilities.convertPointToScreen(pt, panel);
+        robot.mouseMove((int) pt.getX(), (int) pt.getY());
+        robot.mousePress(InputEvent.BUTTON3_MASK);
+        robot.mouseRelease(InputEvent.BUTTON3_MASK);
+
+        toolkit.realSync();
+        SwingUtilities.invokeAndWait(new Runnable() {
+            public void run() {
+                test.setLocation(-30, 100);
+                combo1.addPopupMenuListener(new ComboPopupCheckListener());
+                combo1.requestFocus();
+            }
+        });
+
+        robot.keyPress(KeyEvent.VK_DOWN);
+        robot.keyRelease(KeyEvent.VK_DOWN);
+        robot.keyPress(KeyEvent.VK_ESCAPE);
+        robot.keyRelease(KeyEvent.VK_ESCAPE);
+
+        toolkit.realSync();
+        Thread.sleep(500);
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/javax/swing/plaf/basic/BasicMenuUI/4983388/bug4983388.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,89 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/* @test
+   @bug 4983388 8015600
+   @summary shortcuts on menus do not work on JDS
+   @author Oleg Mokhovikov
+   @library ../../../../regtesthelpers
+   @build Util
+   @run main bug4983388
+*/
+
+import sun.awt.*;
+import java.awt.*;
+import javax.swing.*;
+import javax.swing.event.MenuListener;
+import javax.swing.event.MenuEvent;
+import java.awt.event.KeyEvent;
+
+public class bug4983388 {
+    static volatile boolean bMenuSelected = false;
+
+    private static class TestMenuListener implements MenuListener {
+        public void menuCanceled(MenuEvent e) {}
+        public void menuDeselected(MenuEvent e) {}
+        public void menuSelected(MenuEvent e) {
+            System.out.println("menuSelected");
+            bMenuSelected = true;
+        }
+    }
+
+    private static void createAndShowGUI() {
+        JMenuBar menuBar = new JMenuBar();
+        JMenu menu = new JMenu("File");
+        menu.setMnemonic('F');
+        menuBar.add(menu);
+        JFrame frame = new JFrame();
+        frame.setJMenuBar(menuBar);
+        frame.pack();
+        frame.setVisible(true);
+        MenuListener listener = new TestMenuListener();
+        menu.addMenuListener(listener);
+    }
+
+    public static void main(String[] args) throws Exception {
+
+        SunToolkit toolkit = (SunToolkit) Toolkit.getDefaultToolkit();
+        try {
+            UIManager.setLookAndFeel("com.sun.java.swing.plaf.gtk.GTKLookAndFeel");
+        } catch (UnsupportedLookAndFeelException | ClassNotFoundException ex) {
+            System.err.println("GTKLookAndFeel is not supported on this platform. Using defailt LaF for this platform.");
+        }
+
+        SwingUtilities.invokeAndWait(new Runnable() {
+            public void run() {
+                createAndShowGUI();
+            }
+        });
+
+        Robot robot = new Robot();
+        Util.hitMnemonics(robot, KeyEvent.VK_F);
+
+        toolkit.realSync();
+
+        if (!bMenuSelected) {
+            throw new RuntimeException("shortcuts on menus do not work");
+        }
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/javax/swing/plaf/basic/BasicTreeUI/8023474/bug8023474.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,174 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 8023474
+ * @summary Tests that the first mouse press starts editing in JTree
+ * @author Dmitry Markov
+ * @run main bug8023474
+ */
+
+import sun.awt.SunToolkit;
+
+import javax.swing.*;
+import javax.swing.event.CellEditorListener;
+import javax.swing.tree.DefaultMutableTreeNode;
+import javax.swing.tree.DefaultTreeModel;
+import javax.swing.tree.TreeCellEditor;
+import javax.swing.tree.TreeCellRenderer;
+import java.awt.*;
+import java.awt.event.InputEvent;
+import java.util.EventObject;
+
+public class bug8023474 {
+    private static JTree tree;
+
+    public static void main(String[] args) throws Exception {
+        SunToolkit toolkit = (SunToolkit) Toolkit.getDefaultToolkit();
+        Robot robot = new Robot();
+        robot.setAutoDelay(50);
+
+        SwingUtilities.invokeAndWait(new Runnable() {
+            public void run() {
+                createAndShowGUI();
+            }
+        });
+
+        toolkit.realSync();
+
+        Point point = getRowPointToClick(1);
+        robot.mouseMove(point.x, point.y);
+        robot.mousePress(InputEvent.BUTTON1_MASK);
+        robot.mouseRelease(InputEvent.BUTTON1_MASK);
+
+        toolkit.realSync();
+
+        Boolean result = (Boolean)tree.getCellEditor().getCellEditorValue();
+        if (!result) {
+            throw new RuntimeException("Test Failed!");
+        }
+    }
+
+    private static void createAndShowGUI() {
+        try {
+            UIManager.setLookAndFeel("javax.swing.plaf.metal.MetalLookAndFeel");
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+
+        DefaultMutableTreeNode root = new DefaultMutableTreeNode("root");
+        DefaultMutableTreeNode item = new DefaultMutableTreeNode("item");
+        DefaultMutableTreeNode subItem = new DefaultMutableTreeNode("subItem");
+
+        root.add(item);
+        item.add(subItem);
+
+        DefaultTreeModel model = new DefaultTreeModel(root);
+        tree = new JTree(model);
+
+        tree.setCellEditor(new Editor());
+        tree.setEditable(true);
+        tree.setRowHeight(30);
+        tree.setCellRenderer(new CheckboxCellRenderer());
+
+        JFrame frame = new JFrame("bug8023474");
+        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
+        frame.add(new JScrollPane(tree));
+        frame.setSize(400, 300);
+        frame.setVisible(true);
+    }
+
+    private static Point getRowPointToClick(final int row) throws Exception {
+        final Point[] result = new Point[1];
+
+        SwingUtilities.invokeAndWait(new Runnable() {
+            public void run() {
+                Rectangle rect = tree.getRowBounds(row);
+                Point point = new Point(rect.x + 10, rect.y + rect.height / 2);
+                SwingUtilities.convertPointToScreen(point, tree);
+                result[0] = point;
+            }
+        });
+        return result[0];
+    }
+
+    private static class Editor extends JPanel implements TreeCellEditor {
+        private JCheckBox checkbox;
+
+        public Editor() {
+            setOpaque(false);
+            checkbox = new JCheckBox();
+            add(checkbox);
+        }
+
+        public Component getTreeCellEditorComponent(JTree tree, Object value, boolean isSelected,
+                                                    boolean expanded, boolean leaf, int row) {
+            checkbox.setText(value.toString());
+            checkbox.setSelected(false);
+            return this;
+        }
+
+        public Object getCellEditorValue() {
+            return checkbox.isSelected();
+        }
+
+        public boolean isCellEditable(EventObject anEvent) {
+            return true;
+        }
+
+        public boolean shouldSelectCell(EventObject anEvent) {
+            return true;
+        }
+
+        public boolean stopCellEditing() {
+            return true;
+        }
+
+        public void cancelCellEditing() {
+        }
+
+        public void addCellEditorListener(CellEditorListener l) {
+        }
+
+        public void removeCellEditorListener(CellEditorListener l) {
+        }
+    }
+
+    private static class CheckboxCellRenderer extends JPanel implements TreeCellRenderer {
+        private JCheckBox checkbox;
+
+        public CheckboxCellRenderer() {
+            setOpaque(false);
+            checkbox = new JCheckBox();
+            add(checkbox);
+        }
+
+        public Component getTreeCellRendererComponent(JTree tree, Object value, boolean selected, boolean expanded,
+                                                      boolean leaf, int row, boolean hasFocus) {
+            checkbox.setText(value.toString());
+            checkbox.setSelected(false);
+            return this;
+        }
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/javax/swing/text/StyledEditorKit/8016833/bug8016833.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,270 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/* @test
+   @bug 8016833
+   @summary underlines and strikethroughs should be  painted at the correct
+            positions for different kind of text styles: normal, superscript and subscript
+   @author Anton Nashatyrev
+   @run main bug8016833
+*/
+import javax.swing.*;
+import javax.swing.text.BadLocationException;
+import javax.swing.text.Style;
+import javax.swing.text.StyleConstants;
+import javax.swing.text.StyledDocument;
+import java.awt.*;
+import java.awt.image.BufferedImage;
+import java.lang.reflect.InvocationTargetException;
+
+public class bug8016833 {
+
+    void drawText(final Graphics g, final boolean underline, final boolean strikethrough, final boolean background) {
+        drawText(g, "mama", underline, strikethrough, background);
+    }
+
+    void drawText(final Graphics g, final String text, final boolean underline, final boolean strikethrough, final boolean background) {
+        try {
+            SwingUtilities.invokeAndWait(new Runnable() {
+                @Override
+                public void run() {
+                    final JTextPane comp = new JTextPane();
+                    final StyledDocument doc = comp.getStyledDocument();
+
+                    Style style = comp.addStyle("superscript", null);
+                    setNormalStyle(style);
+
+                    if (underline) {
+                        StyleConstants.setUnderline(style, true);
+                    }
+                    if (strikethrough) {
+                        StyleConstants.setStrikeThrough(style, true);
+                    }
+                    if (background) {
+                        StyleConstants.setBackground(style, Color.BLUE);
+                    }
+                    try {
+                        doc.insertString(doc.getLength(), "mama", style);
+                    } catch (BadLocationException e) {
+                        throw new RuntimeException(e);
+                    }
+
+                    comp.setSize(200, 100);
+                    comp.paint(g);
+                }
+            });
+        } catch (InterruptedException e) {
+            throw new RuntimeException(e);
+        } catch (InvocationTargetException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    void setNormalStyle(Style style) {
+        StyleConstants.setSuperscript(style, true);
+    }
+
+    int getEmptyPixel() {
+        return 0xFFFFFFFF;
+    }
+
+    boolean isPixelEmpty(int argb) {
+        return (argb & 0x00FFFFFF) == (getEmptyPixel() & 0x00FFFFFF);
+    }
+
+    boolean isLineEmpty(BufferedImage img, int coord, boolean isHorizontal) {
+        int len = isHorizontal ? img.getWidth() : img.getHeight();
+        for (int i = 0; i < len; i++) {
+            int pixel = isHorizontal ? img.getRGB(i, coord) : img.getRGB(coord, i);
+            if (!isPixelEmpty(pixel)) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    Rectangle getPixelsOutline(BufferedImage img) {
+        int x1 = 0;
+        while (x1 < img.getWidth() && isLineEmpty(img, x1, false)) {
+            x1++;
+        }
+        int x2 = img.getWidth() - 1;
+        while (x2 >= 0 && isLineEmpty(img, x2, false)) {
+            x2--;
+        }
+        int y1 = 0;
+        while (y1 < img.getHeight() && isLineEmpty(img, y1, true)) {
+            y1++;
+        }
+        int y2 = img.getHeight() - 1;
+        while (y2 >= 0 && isLineEmpty(img, y2, true)) {
+            y2--;
+        }
+
+        return new Rectangle(x1, y1, x2 - x1 + 1, y2 - y1 + 1);
+    }
+
+    BufferedImage createImage() {
+        final BufferedImage img = new BufferedImage(200, 100, BufferedImage.TYPE_INT_ARGB);
+        try {
+            SwingUtilities.invokeAndWait(new Runnable() {
+                @Override
+                public void run() {
+                    Graphics g = img.getGraphics();
+                    g.setColor(new Color(getEmptyPixel()));
+                    g.fillRect(0, 0, 10000, 10000);
+                }
+            });
+        } catch (InterruptedException e) {
+            throw new RuntimeException(e);
+        } catch (InvocationTargetException e) {
+            throw new RuntimeException(e);
+        }
+        return img;
+    }
+
+    int subPixels(int pix1, int pix2) {
+        if (pix1 == pix2) {
+            return getEmptyPixel();
+        }
+        return pix1;
+    }
+
+    /**
+     * Subtracts img2 from img1
+     */
+    BufferedImage subImages(BufferedImage img1, BufferedImage img2) {
+        if (img1.getHeight() != img2.getHeight() ||
+                img1.getWidth() != img2.getWidth()) {
+            throw new RuntimeException("Different sizes");
+        }
+        BufferedImage ret = new BufferedImage(img1.getWidth(), img1.getHeight(), img1.getType());
+
+        for (int x = 0; x < ret.getWidth(); x++) {
+            for (int y = 0; y < ret.getHeight(); y++) {
+                ret.setRGB(x, y, subPixels(img1.getRGB(x, y), img2.getRGB(x, y)));
+            }
+        }
+        return ret;
+    }
+
+    void testUnderline() {
+        System.out.println("  testUnderline()");
+
+        final BufferedImage img1 = createImage();
+        drawText(img1.getGraphics(), true, false, false);
+        final Rectangle out1 = getPixelsOutline(img1);
+        System.out.println("   Underlined: " + out1);
+
+        final BufferedImage img2 = createImage();
+        drawText(img2.getGraphics(), false, false, false);
+        final Rectangle out2 = getPixelsOutline(img2);
+        System.out.println("   Normal: " + out2);
+
+        final BufferedImage img3 = subImages(img1, img2);
+        final Rectangle out3 = getPixelsOutline(img3);
+        System.out.println("   Sub: " + out3);
+
+        // underline is not too thick
+        assertTrue(out3.getHeight() <= 2);
+        // not too wide
+        assertTrue(out3.getWidth() * 0.8 < out2.getWidth());
+        // not too low
+        assertTrue(out3.getY() - (out1.getY() + out2.getHeight()) < 3);
+        // not too high
+        assertTrue(out3.getY() - (out1.getY() + out2.getHeight()) > 0);
+    }
+
+    void testStrikthrough() {
+        System.out.println("  testStrikthrough()");
+
+        final BufferedImage img1 = createImage();
+        drawText(img1.getGraphics(), false, true, false);
+        final Rectangle out1 = getPixelsOutline(img1);
+        System.out.println("   Striked: " + out1);
+
+        final BufferedImage img2 = createImage();
+        drawText(img2.getGraphics(), false, false, false);
+        final Rectangle out2 = getPixelsOutline(img2);
+        System.out.println("   Normal: " + out2);
+
+        final BufferedImage img3 = subImages(img1, img2);
+        final Rectangle out3 = getPixelsOutline(img3);
+        System.out.println("   Sub: " + out3);
+
+        // strikethrough is not too thick
+        assertTrue(out3.getHeight() <= 2);
+        // not too wide
+        assertTrue(out3.getWidth() * 0.8 < out2.getWidth());
+        // not too low
+        assertTrue(out3.getY() - (out1.getY() + out2.getHeight()) < 0);
+        // not too high
+        assertTrue(out3.getY() - out1.getY() > 1);
+    }
+    void assertTrue(boolean b) {
+        if (!b) {
+            throw new RuntimeException("Assertion failed");
+        }
+    }
+
+    static void testSuperScript() {
+        System.out.println("testSuperScript()");
+        bug8016833 b = new bug8016833() {
+            @Override
+            void setNormalStyle(Style style) {
+                StyleConstants.setSuperscript(style, true);
+            }
+        };
+        b.testUnderline();
+        b.testStrikthrough();
+    }
+
+    static void testSubScript() {
+        System.out.println("testSubScript()");
+        bug8016833 b = new bug8016833() {
+            @Override
+            void setNormalStyle(Style style) {
+                StyleConstants.setSubscript(style, true);
+            }
+        };
+        b.testUnderline();
+        b.testStrikthrough();
+    }
+
+    static void testNormalScript() {
+        System.out.println("testNormalScript()");
+        bug8016833 b = new bug8016833() {
+            @Override
+            void setNormalStyle(Style style) {
+            }
+        };
+        b.testUnderline();
+        b.testStrikthrough();
+    }
+
+    public static void main(String[] args) {
+        testSubScript();
+        testSuperScript();
+        testNormalScript();
+    }
+}
--- ./jdk/test/javax/swing/text/View/8014863/bug8014863.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/test/javax/swing/text/View/8014863/bug8014863.java	Wed May 07 19:26:47 2014 -0700
@@ -24,6 +24,7 @@
 /*
  * @test
  * @bug 8014863
+ * @bug 8024395
  * @summary  Tests the calculation of the line breaks when a text is inserted
  * @author Dmitry Markov
  * @library ../../../regtesthelpers
@@ -34,91 +35,107 @@
 import sun.awt.SunToolkit;
 
 import javax.swing.*;
+import javax.swing.text.GlyphView;
+import javax.swing.text.View;
 import javax.swing.text.html.HTMLEditorKit;
 import java.awt.*;
 import java.awt.event.KeyEvent;
+import java.lang.reflect.Field;
+import java.util.ArrayList;
+import java.util.Arrays;
 
 public class bug8014863 {
 
     private static JEditorPane editorPane;
+    private static JFrame frame;
     private static Robot robot;
     private static SunToolkit toolkit;
 
+    private static String text1 = "<p>one two qqqq <em>this is a test sentence</em> qqqq <em>pp</em> qqqq <em>pp</em> " +
+            "qqqq <em>pp</em> qqqq <em>pp</em> qqqq <em>pp</em> qqqq <em>pp</em> qqqq <em>pp</em> qqqq <em>pp</em> qqqq</p>";
+    private static String text2 = "<p>qqqq <em>this is a test sentence</em> qqqq <em>pp</em> qqqq <em>pp</em> " +
+            "qqqq <em>pp</em> qqqq <em>pp</em> qqqq <em>pp</em> qqqq <em>pp</em> qqqq <em>pp</em> qqqq <em>pp</em> qqqq</p>";
+
+    private static ArrayList<GlyphView> glyphViews;
+
     public static void main(String[] args) throws Exception {
         toolkit = (SunToolkit) Toolkit.getDefaultToolkit();
         robot = new Robot();
+        robot.setAutoDelay(50);
+        glyphViews = new ArrayList<GlyphView>();
 
-        createAndShowGUI();
+        createAndShowGUI(text1);
+
+        toolkit.realSync();
+
+        SwingUtilities.invokeAndWait(new Runnable() {
+            public void run() {
+                retrieveGlyphViews(editorPane.getUI().getRootView(editorPane));
+            }
+        });
+        GlyphView [] arr1 = glyphViews.toArray(new GlyphView[glyphViews.size()]);
+
+        frame.dispose();
+        glyphViews.clear();
+
+        createAndShowGUI(text2);
 
         toolkit.realSync();
 
         Util.hitKeys(robot, KeyEvent.VK_HOME);
-        Util.hitKeys(robot, KeyEvent.VK_O);
-
         toolkit.realSync();
 
-        if (3 != getNumberOfTextLines()) {
-            throw new RuntimeException("The number of texts lines does not meet the expectation");
-        }
-
+        Util.hitKeys(robot, KeyEvent.VK_O);
         Util.hitKeys(robot, KeyEvent.VK_N);
-
-        toolkit.realSync();
-
-        if (3 != getNumberOfTextLines()) {
-            throw new RuntimeException("The number of texts lines does not meet the expectation");
-        }
-
         Util.hitKeys(robot, KeyEvent.VK_E);
         Util.hitKeys(robot, KeyEvent.VK_SPACE);
         Util.hitKeys(robot, KeyEvent.VK_T);
         Util.hitKeys(robot, KeyEvent.VK_W);
+        Util.hitKeys(robot, KeyEvent.VK_O);
+        Util.hitKeys(robot, KeyEvent.VK_SPACE);
 
         toolkit.realSync();
 
-        if (3 != getNumberOfTextLines()) {
-            throw new RuntimeException("The number of texts lines does not meet the expectation");
+        SwingUtilities.invokeAndWait(new Runnable() {
+            public void run() {
+                retrieveGlyphViews(editorPane.getUI().getRootView(editorPane));
+            }
+        });
+        GlyphView [] arr2 = glyphViews.toArray(new GlyphView[glyphViews.size()]);
+
+        if (arr1.length != arr2.length) {
+            throw new RuntimeException("Test Failed!");
+        }
+
+        for (int i=0; i<arr1.length; i++) {
+            GlyphView v1 = arr1[i];
+            GlyphView v2 = arr2[i];
+            Field field = GlyphView.class.getDeclaredField("breakSpots");
+            field.setAccessible(true);
+            int[] breakSpots1 = (int[])field.get(v1);
+            int[] breakSpots2 = (int[])field.get(v2);
+            if (!Arrays.equals(breakSpots1,breakSpots2)) {
+                throw new RuntimeException("Test Failed!");
+            }
+        }
+
+        frame.dispose();
+    }
+
+    private static void retrieveGlyphViews(View root) {
+        for (int i=0; i<= root.getViewCount()-1; i++) {
+            View view = root.getView(i);
+            if (view instanceof GlyphView && view.isVisible()) {
+                if (!glyphViews.contains(view)) {
+                    glyphViews.add((GlyphView)view);
+                }
+            } else {
+                retrieveGlyphViews(view);
+            }
         }
     }
 
-    private static int getNumberOfTextLines() throws Exception {
-        int numberOfLines = 0;
-        int caretPosition = getCaretPosition();
-        int current = 1;
-        int previous;
-
-        setCaretPosition(current);
-        do {
-            previous = current;
-            Util.hitKeys(robot, KeyEvent.VK_DOWN);
-            toolkit.realSync();
-            current = getCaretPosition();
-            numberOfLines++;
-        } while (current != previous);
-
-        setCaretPosition(caretPosition);
-        return numberOfLines;
-    }
-
-    private static int getCaretPosition() throws Exception {
-        final int[] result = new int[1];
-        SwingUtilities.invokeAndWait(new Runnable() {
-            public void run() {
-                result[0] = editorPane.getCaretPosition();
-            }
-        });
-        return result[0];
-    }
-
-    private static void setCaretPosition(final int position) throws Exception {
-        SwingUtilities.invokeAndWait(new Runnable() {
-            public void run() {
-                editorPane.setCaretPosition(position);
-            }
-        });
-    }
-
-    private static void createAndShowGUI() throws Exception {
+    private static void createAndShowGUI(final String text) throws Exception {
         SwingUtilities.invokeAndWait(new Runnable() {
             public void run() {
                 try {
@@ -126,17 +143,14 @@
                 } catch (Exception ex) {
                     throw new RuntimeException(ex);
                 }
-                JFrame frame = new JFrame();
+                frame = new JFrame();
                 frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
 
                 editorPane = new JEditorPane();
                 HTMLEditorKit editorKit = new HTMLEditorKit();
                 editorPane.setEditorKit(editorKit);
-                editorPane.setText("<p>qqqq <em>pp</em> qqqq <em>pp</em> " +
-                        "qqqq <em>pp</em> qqqq <em>pp</em> qqqq <em>pp</em> qqqq <em>pp" +
-                        "</em> qqqq <em>pp</em> qqqq <em>pp</em> qqqq <em>pp</em> qqqq</p>");
+                editorPane.setText(text);
                 editorPane.setCaretPosition(1);
-
                 frame.add(editorPane);
                 frame.setSize(200, 200);
                 frame.setVisible(true);
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/javax/xml/jaxp/XPath/8009579/XPathExceptionInitCause.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,220 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 8009579
+ * @summary The initCause() incorrectly initialise the cause in
+ * XPathException class when used with XPathException(String)
+ * constructor.
+ * @run main XPathExceptionInitCause
+ * @author aleksej.efimov@oracle.com
+ */
+
+import javax.xml.xpath.XPathException;
+import java.io.ByteArrayOutputStream;
+import java.io.ByteArrayInputStream;
+import java.io.ObjectOutputStream;
+import java.io.ObjectInputStream;
+import java.io.IOException;
+import java.io.InvalidClassException;
+
+
+public class XPathExceptionInitCause {
+
+    /* This is a serial form of XPathException with two causes serialized
+     * by JDK7 code:
+     *
+     *  ByteArrayOutputStream fser = new ByteArrayOutputStream();
+     *  ObjectOutputStream oos = new ObjectOutputStream(fser);
+     *  oos.writeObject(new XPathException(new Exception()).initCause(null));
+     *  oos.close();
+     */
+    static final byte [] TWOCAUSES = {-84,-19,0,5,115,114,0,30,106,97,118,97,120,46,120,
+        109,108,46,120,112,97,116,104,46,88,80,97,116,104,69,120,99,101,112,116,
+        105,111,110,-26,-127,97,60,-120,119,127,28,2,0,1,76,0,5,99,97,117,115,101,
+        116,0,21,76,106,97,118,97,47,108,97,110,103,47,84,104,114,111,119,97,98,
+        108,101,59,120,114,0,19,106,97,118,97,46,108,97,110,103,46,69,120,99,101,
+        112,116,105,111,110,-48,-3,31,62,26,59,28,-60,2,0,0,120,114,0,19,106,97,
+        118,97,46,108,97,110,103,46,84,104,114,111,119,97,98,108,101,-43,-58,53,
+        39,57,119,-72,-53,3,0,4,76,0,5,99,97,117,115,101,113,0,126,0,1,76,0,13,
+        100,101,116,97,105,108,77,101,115,115,97,103,101,116,0,18,76,106,97,118,
+        97,47,108,97,110,103,47,83,116,114,105,110,103,59,91,0,10,115,116,97,99,
+        107,84,114,97,99,101,116,0,30,91,76,106,97,118,97,47,108,97,110,103,47,83,
+        116,97,99,107,84,114,97,99,101,69,108,101,109,101,110,116,59,76,0,20,115,
+        117,112,112,114,101,115,115,101,100,69,120,99,101,112,116,105,111,110,115,
+        116,0,16,76,106,97,118,97,47,117,116,105,108,47,76,105,115,116,59,120,112,
+        112,112,117,114,0,30,91,76,106,97,118,97,46,108,97,110,103,46,83,116,97,99,
+        107,84,114,97,99,101,69,108,101,109,101,110,116,59,2,70,42,60,60,-3,34,57,
+        2,0,0,120,112,0,0,0,1,115,114,0,27,106,97,118,97,46,108,97,110,103,46,83,
+        116,97,99,107,84,114,97,99,101,69,108,101,109,101,110,116,97,9,-59,-102,
+        38,54,-35,-123,2,0,4,73,0,10,108,105,110,101,78,117,109,98,101,114,76,0,
+        14,100,101,99,108,97,114,105,110,103,67,108,97,115,115,113,0,126,0,4,76,
+        0,8,102,105,108,101,78,97,109,101,113,0,126,0,4,76,0,10,109,101,116,104,
+        111,100,78,97,109,101,113,0,126,0,4,120,112,0,0,0,31,116,0,23,88,80,97,116,
+        104,69,120,99,101,112,116,105,111,110,83,101,114,105,97,108,105,122,101,
+        116,0,28,88,80,97,116,104,69,120,99,101,112,116,105,111,110,83,101,114,105,
+        97,108,105,122,101,46,106,97,118,97,116,0,4,109,97,105,110,115,114,0,38,
+        106,97,118,97,46,117,116,105,108,46,67,111,108,108,101,99,116,105,111,110,
+        115,36,85,110,109,111,100,105,102,105,97,98,108,101,76,105,115,116,-4,15,
+        37,49,-75,-20,-114,16,2,0,1,76,0,4,108,105,115,116,113,0,126,0,6,120,114,
+        0,44,106,97,118,97,46,117,116,105,108,46,67,111,108,108,101,99,116,105,111,
+        110,115,36,85,110,109,111,100,105,102,105,97,98,108,101,67,111,108,108,101,
+        99,116,105,111,110,25,66,0,-128,-53,94,-9,30,2,0,1,76,0,1,99,116,0,22,76,
+        106,97,118,97,47,117,116,105,108,47,67,111,108,108,101,99,116,105,111,110,
+        59,120,112,115,114,0,19,106,97,118,97,46,117,116,105,108,46,65,114,114,97,
+        121,76,105,115,116,120,-127,-46,29,-103,-57,97,-99,3,0,1,73,0,4,115,105,
+        122,101,120,112,0,0,0,0,119,4,0,0,0,0,120,113,0,126,0,20,120,115,113,0,126,
+        0,2,113,0,126,0,21,112,117,113,0,126,0,8,0,0,0,1,115,113,0,126,0,10,0,0,0,
+        31,113,0,126,0,12,113,0,126,0,13,113,0,126,0,14,113,0,126,0,18,120
+    };
+
+    /* This is a serial form of ordinary XPathException serialized by JDK7 code:
+     *
+     *  Throwable cause = new Throwable( "message 1" );
+     *  XPathException xpathexcep = new XPathException( "message 2" );
+     *  xpathexcep.initCause( cause );
+     *  ByteArrayOutputStream fser = new ByteArrayOutputStream();
+     *  ObjectOutputStream oos = new ObjectOutputStream(fser);
+     *  oos.writeObject(xpathexcep);
+     *  oos.close();
+     */
+    static final byte [] NORMALJDK7SER = {-84,-19,0,5,115,114,0,30,106,97,118,97,120,
+        46,120,109,108,46,120,112,97,116,104,46,88,80,97,116,104,69,120,99,101,112,
+        116,105,111,110,-26,-127,97,60,-120,119,127,28,2,0,1,76,0,5,99,97,117,115,
+        101,116,0,21,76,106,97,118,97,47,108,97,110,103,47,84,104,114,111,119,97,
+        98,108,101,59,120,114,0,19,106,97,118,97,46,108,97,110,103,46,69,120,99,
+        101,112,116,105,111,110,-48,-3,31,62,26,59,28,-60,2,0,0,120,114,0,19,106,
+        97,118,97,46,108,97,110,103,46,84,104,114,111,119,97,98,108,101,-43,-58,
+        53,39,57,119,-72,-53,3,0,4,76,0,5,99,97,117,115,101,113,0,126,0,1,76,0,13,
+        100,101,116,97,105,108,77,101,115,115,97,103,101,116,0,18,76,106,97,118,
+        97,47,108,97,110,103,47,83,116,114,105,110,103,59,91,0,10,115,116,97,99,
+        107,84,114,97,99,101,116,0,30,91,76,106,97,118,97,47,108,97,110,103,47,83,
+        116,97,99,107,84,114,97,99,101,69,108,101,109,101,110,116,59,76,0,20,115,
+        117,112,112,114,101,115,115,101,100,69,120,99,101,112,116,105,111,110,115,
+        116,0,16,76,106,97,118,97,47,117,116,105,108,47,76,105,115,116,59,120,112,
+        115,113,0,126,0,3,113,0,126,0,8,116,0,9,109,101,115,115,97,103,101,32,49,
+        117,114,0,30,91,76,106,97,118,97,46,108,97,110,103,46,83,116,97,99,107,84,
+        114,97,99,101,69,108,101,109,101,110,116,59,2,70,42,60,60,-3,34,57,2,0,0,
+        120,112,0,0,0,1,115,114,0,27,106,97,118,97,46,108,97,110,103,46,83,116,97,
+        99,107,84,114,97,99,101,69,108,101,109,101,110,116,97,9,-59,-102,38,54,-35,
+        -123,2,0,4,73,0,10,108,105,110,101,78,117,109,98,101,114,76,0,14,100,101,
+        99,108,97,114,105,110,103,67,108,97,115,115,113,0,126,0,4,76,0,8,102,105,
+        108,101,78,97,109,101,113,0,126,0,4,76,0,10,109,101,116,104,111,100,78,97,
+        109,101,113,0,126,0,4,120,112,0,0,0,19,116,0,23,88,80,97,116,104,69,120,
+        99,101,112,116,105,111,110,83,101,114,105,97,108,105,122,101,116,0,28,88,
+        80,97,116,104,69,120,99,101,112,116,105,111,110,83,101,114,105,97,108,105,
+        122,101,46,106,97,118,97,116,0,4,109,97,105,110,115,114,0,38,106,97,118,
+        97,46,117,116,105,108,46,67,111,108,108,101,99,116,105,111,110,115,36,85,
+        110,109,111,100,105,102,105,97,98,108,101,76,105,115,116,-4,15,37,49,-75,
+        -20,-114,16,2,0,1,76,0,4,108,105,115,116,113,0,126,0,6,120,114,0,44,106,
+        97,118,97,46,117,116,105,108,46,67,111,108,108,101,99,116,105,111,110,115,
+        36,85,110,109,111,100,105,102,105,97,98,108,101,67,111,108,108,101,99,116,
+        105,111,110,25,66,0,-128,-53,94,-9,30,2,0,1,76,0,1,99,116,0,22,76,106,97,
+        118,97,47,117,116,105,108,47,67,111,108,108,101,99,116,105,111,110,59,120,
+        112,115,114,0,19,106,97,118,97,46,117,116,105,108,46,65,114,114,97,121,76,
+        105,115,116,120,-127,-46,29,-103,-57,97,-99,3,0,1,73,0,4,115,105,122,101,
+        120,112,0,0,0,0,119,4,0,0,0,0,120,113,0,126,0,22,120,116,0,9,109,101,115,
+        115,97,103,101,32,50,117,113,0,126,0,10,0,0,0,1,115,113,0,126,0,12,0,0,0,
+        20,113,0,126,0,14,113,0,126,0,15,113,0,126,0,16,113,0,126,0,20,120,112
+    };
+
+    //Serialize XPathException
+    static byte [] pickleXPE(XPathException xpe) throws IOException {
+        ByteArrayOutputStream bos =  new ByteArrayOutputStream();
+        ObjectOutputStream xpeos = new ObjectOutputStream(bos);
+        xpeos.writeObject(xpe);
+        xpeos.close();
+        return bos.toByteArray();
+    }
+
+    //Deserialize XPathException with byte array as serial data source
+    static XPathException unpickleXPE(byte [] ser)
+            throws IOException, ClassNotFoundException {
+        XPathException xpe;
+        ByteArrayInputStream bis = new ByteArrayInputStream(ser);
+        ObjectInputStream xpeis = new ObjectInputStream(bis);
+        xpe = (XPathException) xpeis.readObject();
+        xpeis.close();
+        return xpe;
+    }
+
+    public static void main(String[] args) throws Exception {
+        Throwable cause = new Throwable("message 1");
+        XPathException xpathexcep = new XPathException("message 2");
+
+        //Test XPE initCause() method
+        xpathexcep.initCause(cause);
+        System.out.println("getCause() result: '" + xpathexcep.getCause()
+                + "' Cause itself: '" + cause + "'");
+        if (!xpathexcep.getCause().toString().equals(cause.toString())) {
+            throw new Exception("Incorrect cause is set by initCause()");
+        }
+
+        //Test serialization/deserialization of initialized XPE
+        byte [] xpeserial;
+        XPathException xpedeser;
+        xpeserial = pickleXPE(xpathexcep);
+        xpedeser = unpickleXPE(xpeserial);
+        System.out.println("Serialized XPE: message='" + xpathexcep.getMessage()
+                + "' cause='" + xpathexcep.getCause().toString() + "'");
+        System.out.println("Deserialized XPE: message='" + xpedeser.getMessage()
+                + "' cause='" + xpedeser.getCause().toString()+"'");
+        if(xpedeser.getCause() == null ||
+                !xpedeser.getCause().toString().equals(cause.toString()) ||
+                !xpedeser.getMessage().toString().equals("message 2") )
+            throw new Exception("XPathException incorrectly serialized/deserialized");
+
+        //Test serialization/deserialization of uninitialized cause in XPE
+        XPathException xpeuninit = new XPathException("uninitialized cause");
+        xpeserial = pickleXPE(xpeuninit);
+        xpedeser = unpickleXPE(xpeserial);
+        System.out.println("Serialized XPE: message='" + xpeuninit.getMessage()
+                + "' cause='" + xpeuninit.getCause()+"'");
+        System.out.println("Deserialized XPE: message='" + xpedeser.getMessage()
+                + "' cause='" + xpedeser.getCause()+"'");
+        if(xpedeser.getCause() != null ||
+                !xpedeser.getMessage().toString().equals("uninitialized cause") )
+            throw new Exception("XPathException incorrectly serialized/deserialized");
+
+        //Test deserialization of normal XPathException serialized by JDK7
+        XPathException xpejdk7 = unpickleXPE(NORMALJDK7SER);
+        if(xpejdk7 == null || xpejdk7.getCause() == null ||
+                !xpejdk7.getMessage().equals("message 2") ||
+                !xpejdk7.getCause().getMessage().equals("message 1"))
+            throw new Exception("XpathException serialized by JDK7 was "
+                    + "incorrectly deserialized.");
+
+        //Test deserialization of XPathException with two causes from JDK7.
+        //The serialization are done for the following XPathException object:
+        // new XPathException(new Exception()).initCause(null)
+        try {
+            xpejdk7 = unpickleXPE(TWOCAUSES);
+            throw new Exception("Expected InvalidClassException but it wasn't"
+                    + " observed");
+        } catch(InvalidClassException e) {
+            System.out.println("InvalidClassException caught as expected.");
+        }
+
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/javax/xml/jaxp/XPath/8015978/XPathNegativeZero.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,72 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 8015978
+ * @summary Incorrect transformation of XPath expression "string(-0)"
+ * @run main XPathNegativeZero
+ * @author aleksej.efimov@oracle.com
+ */
+
+import java.io.File;
+import java.io.StringWriter;
+import javax.xml.transform.TransformerFactory;
+import javax.xml.transform.Templates;
+import javax.xml.transform.Transformer;
+import javax.xml.transform.Source;
+import javax.xml.transform.Result;
+import javax.xml.transform.stream.StreamSource;
+import javax.xml.transform.stream.StreamResult;
+
+
+public class XPathNegativeZero {
+
+    static final String EXPECTEDXML = "<newtop>\"0\"</newtop>";
+
+    public static void main(final String[] args) throws Exception {
+        //file name of XML file to transform
+        final String xml = System.getProperty("test.src", ".")+"/dummy.xml";
+        //file name of XSL file w/ transformation
+        final String xsl = System.getProperty("test.src", ".")+"/negativezero.xsl";
+        final String result = xform(xml, xsl).trim();
+
+        System.out.println("transformed XML: '"+result+ "' expected XML: '"+EXPECTEDXML+"'");
+        if (!result.equals(EXPECTEDXML))
+            throw new Exception("Negative zero was incorrectly transformed");
+    }
+
+    private static String xform(final String xml, final String xsl) throws Exception {
+        final TransformerFactory tf = TransformerFactory.newInstance();
+        final Source xslsrc = new StreamSource(new File(xsl));
+        final Templates tmpl = tf.newTemplates(xslsrc);
+        final Transformer t = tmpl.newTransformer();
+
+        StringWriter writer = new StringWriter();
+        final Source src = new StreamSource(new File(xml));
+        final Result res = new StreamResult(writer);
+
+        t.transform(src, res);
+        return writer.toString();
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/javax/xml/jaxp/XPath/8015978/dummy.xml	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,1 @@
+<top/>
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/javax/xml/jaxp/XPath/8015978/negativezero.xsl	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,4 @@
+<xsl:stylesheet version='1.0' xmlns:xsl='http://www.w3.org/1999/XSL/Transform'>
+   <xsl:output method='xml' indent='yes' omit-xml-declaration='yes'/>
+   <xsl:template match='/'><newtop>"<xsl:value-of select='string(-0.0)'/>"</newtop></xsl:template>
+</xsl:stylesheet>
--- ./jdk/test/javax/xml/jaxp/parsers/8022548/XOMParserTest.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/test/javax/xml/jaxp/parsers/8022548/XOMParserTest.java	Wed May 07 19:26:47 2014 -0700
@@ -22,7 +22,8 @@
  */
 
 /**
- * @test @bug 8022548
+ * @test
+ * @bug 8022548
  * @summary test that a parser can use DTDConfiguration
  * @run main XOMParserTest
  */
@@ -60,30 +61,27 @@
     }
 
     public final void testTransform() {
+        String inFilename = filePath + "/JDK8022548.xml";
+        String xslFilename = filePath + "/JDK8022548.xsl";
+        String outFilename = "JDK8022548.out";
 
-        try {
+        try (InputStream xslInput = new FileInputStream(xslFilename);
+             InputStream xmlInput = new FileInputStream(inFilename);
+             OutputStream out = new FileOutputStream(outFilename);
+        ) {
 
-            String inFilename = filePath + "/JDK8022548.xml";
-            String xslFilename = filePath + "/JDK8022548.xsl";
-            String outFilename = filePath + "/JDK8022548.out";
 
             StringWriter sw = new StringWriter();
             // Create transformer factory
             TransformerFactory factory = TransformerFactory.newInstance();
-            // set the translet name
-//            factory.setAttribute("translet-name", "myTranslet");
-
-            // set the destination directory
-//            factory.setAttribute("destination-directory", "c:\\temp");
-//            factory.setAttribute("generate-translet", Boolean.TRUE);
 
             // Use the factory to create a template containing the xsl file
-            Templates template = factory.newTemplates(new StreamSource(new FileInputStream(xslFilename)));
+            Templates template = factory.newTemplates(new StreamSource(xslInput));
             // Use the template to create a transformer
             Transformer xformer = template.newTransformer();
             // Prepare the input and output files
-            Source source = new StreamSource(new FileInputStream(inFilename));
-            Result result = new StreamResult(new FileOutputStream(outFilename));
+            Source source = new StreamSource(xmlInput);
+            Result result = new StreamResult(outFilename);
             //Result result = new StreamResult(sw);
             // Apply the xsl file to the source file and write the result to the output file
             xformer.transform(source, result);
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/javax/xml/jaxp/parsers/8024707/TestFunc.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,35 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import org.w3c.dom.Node;
+import org.w3c.dom.NodeList;
+
+/**
+ * bug 8024707
+ */
+
+public class TestFunc {
+        public static Node test( NodeList list ) {
+            return list.item(0);
+        }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/javax/xml/jaxp/parsers/8024707/XSLT.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/**
+ * @test
+ * @bug 8024707
+ * @summary Test for XSLT extension function with 1 element sized nodelist
+ * @compile TestFunc.java XSLT.java
+ * @run main/othervm XSLT
+ * @author aleksej.efimov@oracle.com
+ */
+
+import javax.xml.transform.*;
+import javax.xml.transform.stream.*;
+import java.io.ByteArrayOutputStream;
+
+public class XSLT {
+    static final String XMLTOTRANSFORM = "/in.xml";
+    static final String XSLTRANSFORMER = "/test.xsl";
+    static final String EXPECTEDRESULT = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>inp1_1";
+
+    public static void main(String[] args) throws Exception {
+        ByteArrayOutputStream resStream = new ByteArrayOutputStream();
+        TransformerFactory trf = TransformerFactory.newInstance();
+        Transformer tr = trf.newTransformer( new StreamSource(System.getProperty("test.src", ".")+XSLTRANSFORMER));
+        tr.transform( new StreamSource(System.getProperty("test.src", ".")+XMLTOTRANSFORM), new StreamResult(resStream));
+        System.out.println("Transformation completed. Result:"+resStream.toString());
+        if (!resStream.toString().equals(EXPECTEDRESULT))
+            throw new RuntimeException("Incorrect transformation result");
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/javax/xml/jaxp/parsers/8024707/in.xml	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<root>
+<input1><seq-elem1>inp1_1</seq-elem1></input1>
+</root>
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/javax/xml/jaxp/parsers/8024707/test.xsl	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<xsl:transform exclude-result-prefixes="cscdt_ufunc" version="1.0"
+    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
+    xmlns:cscdt_ufunc="http://xml.apache.org/xalan/java">
+    <xsl:template match="/">
+        <xsl:value-of
+            select="cscdt_ufunc:TestFunc.test(/root/input1/seq-elem1)"
+        />
+    </xsl:template>
+</xsl:transform>
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/javax/xml/jaxp/transform/8004476/SecureProcessingTest.xml	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,2 @@
+<?xml version="1.0"?>
+<helloWorld/>
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/javax/xml/jaxp/transform/8004476/TestBase.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,82 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
+ */
+import java.security.Policy;
+
+/**
+ *
+ *
+ * @author huizhe.wang@oracle.com
+ */
+public class TestBase {
+    public static boolean isWindows = false;
+    static {
+        if (System.getProperty("os.name").indexOf("Windows")>-1) {
+            isWindows = true;
+        }
+    };
+
+    String filepath;
+    boolean hasSM;
+    String curDir;
+    Policy origPolicy;
+    String testName;
+    static String errMessage;
+
+    int passed = 0, failed = 0;
+
+    /**
+     * Creates a new instance of StreamReader
+     */
+    public TestBase(String name) {
+        testName = name;
+    }
+
+    //junit @Override
+    protected void setUp() {
+        if (System.getSecurityManager() != null) {
+            hasSM = true;
+            System.setSecurityManager(null);
+        }
+
+        filepath = System.getProperty("test.src");
+        if (filepath == null) {
+            //current directory
+            filepath = System.getProperty("user.dir");
+        }
+        origPolicy = Policy.getPolicy();
+
+    }
+
+    //junit @Override
+    public void tearDown() {
+        // turn off security manager and restore policy
+        System.setSecurityManager(null);
+        Policy.setPolicy(origPolicy);
+        if (hasSM) {
+            System.setSecurityManager(new SecurityManager());
+        }
+        System.out.println("\nNumber of tests passed: " + passed);
+        System.out.println("Number of tests failed: " + failed + "\n");
+
+        if (errMessage != null ) {
+            throw new RuntimeException(errMessage);
+        }
+    }
+
+    void fail(String errMsg) {
+        if (errMessage == null) {
+            errMessage = errMsg;
+        } else {
+            errMessage = errMessage + "\n" + errMsg;
+        }
+        failed++;
+    }
+
+    void success(String msg) {
+        passed++;
+        System.out.println(msg);
+    }
+
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/javax/xml/jaxp/transform/8004476/XPathExFuncTest.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,287 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+/**
+ * @test
+ * @bug 8004476
+ * @summary test XPath extension functions
+ * @run main/othervm XPathExFuncTest
+ */
+import java.io.FileInputStream;
+import java.io.InputStream;
+import java.security.AllPermission;
+import java.security.CodeSource;
+import java.security.Permission;
+import java.security.PermissionCollection;
+import java.security.Permissions;
+import java.security.Policy;
+import java.security.ProtectionDomain;
+import java.util.Iterator;
+import java.util.List;
+import javax.xml.XMLConstants;
+import javax.xml.namespace.NamespaceContext;
+import javax.xml.namespace.QName;
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.DocumentBuilderFactory;
+import javax.xml.xpath.XPath;
+import javax.xml.xpath.XPathExpressionException;
+import javax.xml.xpath.XPathFactory;
+import javax.xml.xpath.XPathFactoryConfigurationException;
+import javax.xml.xpath.XPathFunction;
+import javax.xml.xpath.XPathFunctionException;
+import javax.xml.xpath.XPathFunctionResolver;
+import org.w3c.dom.Document;
+
+/**
+ * test XPath extension functions
+ *
+ * @author huizhe.wang@oracle.com
+ */
+public class XPathExFuncTest extends TestBase {
+
+    final static String ENABLE_EXTENSION_FUNCTIONS = "http://www.oracle.com/xml/jaxp/properties/enableExtensionFunctions";
+    final static String CLASSNAME = "DocumentBuilderFactoryImpl";
+    final String XPATH_EXPRESSION = "ext:helloWorld()";
+
+    /**
+     * Creates a new instance of StreamReader
+     */
+    public XPathExFuncTest(String name) {
+        super(name);
+    }
+    boolean hasSM;
+    String xslFile, xslFileId;
+    String xmlFile, xmlFileId;
+
+    protected void setUp() {
+        super.setUp();
+        xmlFile = filepath + "/SecureProcessingTest.xml";
+
+    }
+
+    /**
+     * @param args the command line arguments
+     */
+    public static void main(String[] args) {
+        XPathExFuncTest test = new XPathExFuncTest("OneTest");
+        test.setUp();
+
+        test.testExtFunc();
+        test.testExtFuncNotAllowed();
+        test.testEnableExtFunc();
+        test.tearDown();
+
+    }
+
+    /**
+     * by default, extension function is enabled
+     */
+    public void testExtFunc() {
+
+        try {
+            evaluate(false);
+            System.out.println("testExtFunc: OK");
+        } catch (XPathFactoryConfigurationException e) {
+            fail(e.getMessage());
+        } catch (XPathExpressionException e) {
+            fail(e.getMessage());
+        }
+    }
+
+    /**
+     * Security is enabled, extension function not allowed
+     */
+    public void testExtFuncNotAllowed() {
+        Policy p = new SimplePolicy(new AllPermission());
+        Policy.setPolicy(p);
+        System.setSecurityManager(new SecurityManager());
+
+        try {
+            evaluate(false);
+        } catch (XPathFactoryConfigurationException e) {
+            fail(e.getMessage());
+        } catch (XPathExpressionException ex) {
+            //expected since extension function is disallowed
+            System.out.println("testExtFuncNotAllowed: OK");
+        } finally {
+            System.setSecurityManager(null);
+        }
+    }
+
+    /**
+     * Security is enabled, use new feature: enableExtensionFunctions
+     */
+    public void testEnableExtFunc() {
+        Policy p = new SimplePolicy(new AllPermission());
+        Policy.setPolicy(p);
+        System.setSecurityManager(new SecurityManager());
+
+
+        try {
+            evaluate(true);
+            System.out.println("testEnableExt: OK");
+        } catch (XPathFactoryConfigurationException e) {
+            fail(e.getMessage());
+        } catch (XPathExpressionException e) {
+            fail(e.getMessage());
+        } finally {
+            System.setSecurityManager(null);
+        }
+    }
+
+    Document getDocument() {
+        // the xml source
+        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();
+        DocumentBuilder documentBuilder = null;
+        Document document = null;
+
+        try {
+            documentBuilder = documentBuilderFactory.newDocumentBuilder();
+            InputStream xmlStream = new FileInputStream(xmlFile);
+            document = documentBuilder.parse(xmlStream);
+        } catch (Exception e) {
+            fail(e.toString());
+        }
+        return document;
+    }
+
+    void evaluate(boolean enableExt) throws XPathFactoryConfigurationException, XPathExpressionException {
+        Document document = getDocument();
+
+        XPathFactory xPathFactory = XPathFactory.newInstance();
+        /**
+         * Use of the extension function 'http://exslt.org/strings:tokenize' is
+         * not allowed when the secure processing feature is set to true.
+         * Attempt to use the new property to enable extension function
+         */
+        if (enableExt) {
+            boolean isExtensionSupported = enableExtensionFunction(xPathFactory);
+        }
+
+        xPathFactory.setXPathFunctionResolver(new MyXPathFunctionResolver());
+        if (System.getSecurityManager() == null) {
+            xPathFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, false);
+        }
+
+        XPath xPath = xPathFactory.newXPath();
+        xPath.setNamespaceContext(new MyNamespaceContext());
+
+        String xPathResult = xPath.evaluate(XPATH_EXPRESSION, document);
+        System.out.println(
+                "XPath result (enableExtensionFunction == " + enableExt + ") = \""
+                + xPathResult
+                + "\"");
+    }
+
+    public class MyXPathFunctionResolver
+            implements XPathFunctionResolver {
+
+        public XPathFunction resolveFunction(QName functionName, int arity) {
+
+            // not a real ewsolver, always return a default XPathFunction
+            return new MyXPathFunction();
+        }
+    }
+
+    public class MyXPathFunction
+            implements XPathFunction {
+
+        public Object evaluate(List list) throws XPathFunctionException {
+
+            return "Hello World";
+        }
+    }
+
+    public class MyNamespaceContext implements NamespaceContext {
+
+        public String getNamespaceURI(String prefix) {
+            if (prefix == null) {
+                throw new IllegalArgumentException("The prefix cannot be null.");
+            }
+
+            if (prefix.equals("ext")) {
+                return "http://ext.com";
+            } else {
+                return null;
+            }
+        }
+
+        public String getPrefix(String namespace) {
+
+            if (namespace == null) {
+                throw new IllegalArgumentException("The namespace uri cannot be null.");
+            }
+
+            if (namespace.equals("http://ext.com")) {
+                return "ext";
+            } else {
+                return null;
+            }
+        }
+
+        public Iterator getPrefixes(String namespace) {
+            return null;
+        }
+    }
+
+    boolean enableExtensionFunction(XPathFactory factory) {
+        boolean isSupported = true;
+        try {
+            factory.setFeature(ENABLE_EXTENSION_FUNCTIONS, true);
+        } catch (XPathFactoryConfigurationException ex) {
+            isSupported = false;
+        }
+        return isSupported;
+    }
+
+    class SimplePolicy extends Policy {
+
+        private final Permissions perms;
+
+        public SimplePolicy(Permission... permissions) {
+            perms = new Permissions();
+            for (Permission permission : permissions) {
+                perms.add(permission);
+            }
+        }
+
+        @Override
+        public PermissionCollection getPermissions(CodeSource cs) {
+            return perms;
+        }
+
+        @Override
+        public PermissionCollection getPermissions(ProtectionDomain pd) {
+            return perms;
+        }
+
+        @Override
+        public boolean implies(ProtectionDomain pd, Permission p) {
+            return perms.implies(p);
+        }
+
+        //for older jdk
+        @Override
+        public void refresh() {
+        }
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/javax/xml/jaxp/transform/8004476/XSLTExFuncTest.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,248 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+/**
+ * @test
+ * @bug 8004476
+ * @summary test XSLT extension functions
+ * @run main/othervm XSLTExFuncTest
+ */
+
+import java.io.StringWriter;
+import java.security.AllPermission;
+import java.security.CodeSource;
+import java.security.Permission;
+import java.security.PermissionCollection;
+import java.security.Permissions;
+import java.security.Policy;
+import java.security.ProtectionDomain;
+import javax.xml.transform.*;
+import javax.xml.transform.sax.SAXSource;
+import javax.xml.transform.stream.StreamResult;
+import org.xml.sax.InputSource;
+
+/**
+ * test XSLT extension functions
+ *
+ * @author huizhe.wang@oracle.com
+ */
+public class XSLTExFuncTest extends TestBase {
+
+    final static String ENABLE_EXTENSION_FUNCTIONS = "http://www.oracle.com/xml/jaxp/properties/enableExtensionFunctions";
+    final static String CLASSNAME = "DocumentBuilderFactoryImpl";
+
+    /**
+     * Creates a new instance of StreamReader
+     */
+    public XSLTExFuncTest(String name) {
+        super(name);
+    }
+    boolean hasSM;
+    String xslFile, xslFileId;
+    String xmlFile, xmlFileId;
+
+    protected void setUp() {
+        super.setUp();
+        xmlFile = filepath + "/tokenize.xml";
+        xslFile = filepath + "/tokenize.xsl";
+
+        /**
+         * On Windows platform it needs triple '/' for valid URL while double '/' is enough on Linux or Solaris.
+         * Here use file:/// directly to make it work on Windows and it will not impact other platforms.
+         */
+        xslFileId = "file:///" + xslFile;
+    }
+
+    /**
+     * @param args the command line arguments
+     */
+    public static void main(String[] args) {
+        XSLTExFuncTest test = new XSLTExFuncTest("OneTest");
+        test.setUp();
+
+        test.testExtFunc();
+        test.testExtFuncNotAllowed();
+        test.testEnableExtFunc();
+        test.testTemplatesEnableExtFunc();
+        test.tearDown();
+
+    }
+
+    /**
+     * by default, extension function is enabled
+     */
+    public void testExtFunc() {
+        TransformerFactory factory = TransformerFactory.newInstance();
+
+        try {
+            transform(factory);
+            System.out.println("testExtFunc: OK");
+        } catch (TransformerConfigurationException e) {
+            fail(e.getMessage());
+        } catch (TransformerException ex) {
+            fail(ex.getMessage());
+        }
+    }
+
+    /**
+     * Security is enabled, extension function not allowed
+     */
+    public void testExtFuncNotAllowed() {
+        Policy p = new SimplePolicy(new AllPermission());
+        Policy.setPolicy(p);
+        System.setSecurityManager(new SecurityManager());
+        TransformerFactory factory = TransformerFactory.newInstance();
+
+        try {
+            transform(factory);
+        } catch (TransformerConfigurationException e) {
+            fail(e.getMessage());
+        } catch (TransformerException ex) {
+            //expected since extension function is disallowed
+            System.out.println("testExtFuncNotAllowed: OK");
+        } finally {
+            System.setSecurityManager(null);
+        }
+    }
+
+    /**
+     * Security is enabled, use new feature: enableExtensionFunctions
+     */
+    public void testEnableExtFunc() {
+        Policy p = new SimplePolicy(new AllPermission());
+        Policy.setPolicy(p);
+        System.setSecurityManager(new SecurityManager());
+        TransformerFactory factory = TransformerFactory.newInstance();
+
+        /**
+         * Use of the extension function 'http://exslt.org/strings:tokenize' is
+         * not allowed when the secure processing feature is set to true.
+         * Attempt to use the new property to enable extension function
+         */
+        boolean isExtensionSupported = enableExtensionFunction(factory);
+
+        try {
+            transform(factory);
+            System.out.println("testEnableExt: OK");
+        } catch (TransformerConfigurationException e) {
+            fail(e.getMessage());
+        } catch (TransformerException e) {
+            fail(e.getMessage());
+        } finally {
+            System.setSecurityManager(null);
+        }
+    }
+
+    /**
+     * use Templates template = factory.newTemplates(new StreamSource( new
+     * FileInputStream(xslFilename))); // Use the template to create a
+     * transformer Transformer xformer = template.newTransformer();
+     *
+     * @param factory
+     * @return
+     */
+    /**
+     * Security is enabled, use new feature: enableExtensionFunctions Use the
+     * template to create a transformer
+     */
+    public void testTemplatesEnableExtFunc() {
+        Policy p = new SimplePolicy(new AllPermission());
+        Policy.setPolicy(p);
+        System.setSecurityManager(new SecurityManager());
+        TransformerFactory factory = TransformerFactory.newInstance();
+
+        /**
+         * Use of the extension function 'http://exslt.org/strings:tokenize' is
+         * not allowed when the secure processing feature is set to true.
+         * Attempt to use the new property to enable extension function
+         */
+        boolean isExtensionSupported = enableExtensionFunction(factory);
+
+        try {
+            SAXSource xslSource = new SAXSource(new InputSource(xslFile));
+            xslSource.setSystemId(xslFileId);
+            Templates template = factory.newTemplates(xslSource);
+            Transformer transformer = template.newTransformer();
+            StringWriter stringResult = new StringWriter();
+            Result result = new StreamResult(stringResult);
+            transformer.transform(new SAXSource(new InputSource(xmlFile)), result);
+            System.out.println("testTemplatesEnableExtFunc: OK");
+        } catch (TransformerConfigurationException e) {
+            fail(e.getMessage());
+        } catch (TransformerException e) {
+            fail(e.getMessage());
+        } finally {
+            System.setSecurityManager(null);
+        }
+    }
+
+    boolean enableExtensionFunction(TransformerFactory factory) {
+        boolean isSupported = true;
+        try {
+            factory.setFeature(ENABLE_EXTENSION_FUNCTIONS, true);
+        } catch (TransformerConfigurationException ex) {
+            isSupported = false;
+        }
+        return isSupported;
+    }
+
+    void transform(TransformerFactory factory) throws TransformerConfigurationException, TransformerException {
+        SAXSource xslSource = new SAXSource(new InputSource(xslFile));
+        xslSource.setSystemId(xslFileId);
+        Transformer transformer = factory.newTransformer(xslSource);
+        StringWriter stringResult = new StringWriter();
+        Result result = new StreamResult(stringResult);
+        transformer.transform(new SAXSource(new InputSource(xmlFile)), result);
+    }
+
+    class SimplePolicy extends Policy {
+
+        private final Permissions perms;
+
+        public SimplePolicy(Permission... permissions) {
+            perms = new Permissions();
+            for (Permission permission : permissions) {
+                perms.add(permission);
+            }
+        }
+
+        @Override
+        public PermissionCollection getPermissions(CodeSource cs) {
+            return perms;
+        }
+
+        @Override
+        public PermissionCollection getPermissions(ProtectionDomain pd) {
+            return perms;
+        }
+
+        @Override
+        public boolean implies(ProtectionDomain pd, Permission p) {
+            return perms.implies(p);
+        }
+
+        //for older jdk
+        @Override
+        public void refresh() {
+        }
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/javax/xml/jaxp/transform/8004476/tokenize.xml	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+<html>
+<a>
+   <b>Is this EXSLT? No. no</b>
+   <c>Is this EXSLT? No. no</c>
+</a>
+</html>
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/javax/xml/jaxp/transform/8004476/tokenize.xsl	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,30 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
+                xmlns:str="http://exslt.org/strings"
+                xmlns:xalan="http://xml.apache.org/xalan"
+                version="1.0">
+<xsl:template match="a">
+   <xsl:apply-templates />
+</xsl:template>
+<xsl:template match="//a/c">
+   <xsl:value-of select="." />
+ -
+      <xsl:value-of select="str:tokenize(string(.), ' ')" />
+   <xsl:value-of select="str:tokenize(string(.), '')" />
+   <xsl:for-each select="str:tokenize(string(.), ' ')">
+      <xsl:value-of select="." />
+   </xsl:for-each>
+   <xsl:apply-templates select="*" />
+</xsl:template>
+<xsl:template match="//a/b">
+   <xsl:value-of select="." />
+ -
+      <xsl:value-of select="xalan:tokenize(string(.), ' ')" />
+   <xsl:value-of select="xalan:tokenize(string(.), '')" />
+   <xsl:for-each select="xalan:tokenize(string(.), ' ')">
+      <xsl:value-of select="." />
+   </xsl:for-each>
+   <xsl:apply-templates select="*" />
+</xsl:template>
+
+</xsl:stylesheet>
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/javax/xml/jaxp/validation/8015092/XPathWhiteSpaceTest.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,60 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+
+/**
+ * @test
+ * @bug 8015092
+ * @summary whitespace within patterns in Selector XPath expression is accepted
+ * @run main/othervm XPathWhiteSpaceTest
+ */
+
+import java.io.*;
+import javax.xml.XMLConstants;
+import javax.xml.validation.Schema;
+import javax.xml.validation.SchemaFactory;
+import org.xml.sax.SAXException;
+
+/**
+ * http://www.w3.org/TR/xmlschema-1/#coss-identity-constraint
+ * For readability, whitespace may be used in selector XPath expressions even though
+ * not explicitly allowed by the grammar:
+ * whitespace may be freely added within patterns before or after any token.
+ *
+ * @author huizhe.wang@oracle.com
+ */
+public class XPathWhiteSpaceTest {
+    static final String XSDFILE = "/idJ029.xsd";
+
+    public static void main(String[] args) throws Exception {
+        try{
+            SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
+            Schema schema = schemaFactory.newSchema(new File(System.getProperty("test.src", ".")+XSDFILE));
+        } catch (SAXException e) {
+            throw new RuntimeException(e.getMessage());
+        }
+
+
+    }
+
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/javax/xml/jaxp/validation/8015092/idIxpns.xsd	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,12 @@
+<?xml version="1.0"?>
+<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema" targetNamespace="xpns.org" xmlns:xpns="xpns.org">
+	<xsd:element name="xsid" type="xsd:string"/>
+	<xsd:element name="xiid">
+		<xsd:complexType>
+			<xsd:sequence>
+				<xsd:element name="xiid2" type="xsd:string" maxOccurs="unbounded"/>
+			</xsd:sequence>
+			<xsd:attribute name="val" type="xsd:string"/>
+		</xsd:complexType>
+	</xsd:element>
+</xsd:schema>
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/javax/xml/jaxp/validation/8015092/idIxpns1.xsd	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,12 @@
+<?xml version="1.0"?>
+<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema" targetNamespace="xpns1.org" xmlns:xpns="xpns1.org">
+	<xsd:element name="xsid" type="xsd:string"/>
+	<xsd:element name="xiid">
+		<xsd:complexType>
+			<xsd:sequence>
+				<xsd:element name="xiid2" type="xsd:string" maxOccurs="unbounded"/>
+			</xsd:sequence>
+			<xsd:attribute name="val" type="xsd:string"/>
+		</xsd:complexType>
+	</xsd:element>
+</xsd:schema>
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/javax/xml/jaxp/validation/8015092/idJ029.xsd	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,21 @@
+<?xml version="1.0"?>
+<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xpns="xpns.org" xmlns:xpns1="xpns1.org" xmlns:xpns2="xpns2.org" xmlns:imp="importNS">
+	<xsd:import namespace="importNS" schemaLocation="idJimp.xsd"/>
+	<xsd:import namespace="xpns.org" schemaLocation="idIxpns.xsd"/>
+	<xsd:import namespace="xpns1.org" schemaLocation="idIxpns1.xsd"/>
+	<xsd:element name="root">
+		<xsd:complexType>
+			<xsd:sequence>
+				<xsd:element ref="tid" maxOccurs="unbounded"/>
+				<xsd:element ref="imp:iid1" maxOccurs="unbounded"/>
+				<xsd:element ref="imp:sid" maxOccurs="unbounded"/>
+				<xsd:element ref="xpns:xiid" maxOccurs="unbounded"/>
+			</xsd:sequence>
+		</xsd:complexType>
+		<xsd:unique id="foo123" name="uid">
+			<xsd:selector xpath=".//tid"/>
+			<xsd:field xpath=". //."/>
+		</xsd:unique>
+	</xsd:element>
+	<xsd:element name="tid" type="xsd:string"/>
+</xsd:schema>
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/javax/xml/jaxp/validation/8015092/idJimp.xsd	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,11 @@
+<?xml version="1.0"?>
+<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema" targetNamespace="importNS" xmlns:imp="importNS">
+	<xsd:element name="sid" type="xsd:string"/>
+	<xsd:element name="iid1">
+		<xsd:complexType>
+			<xsd:sequence>
+				<xsd:element name="iid2" type="xsd:string" maxOccurs="unbounded"/>
+			</xsd:sequence>
+		</xsd:complexType>
+	</xsd:element>
+</xsd:schema>
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/javax/xml/jaxp/validation/8015243/AnyURITest.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,60 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+
+/**
+ * @test
+ * @bug 8015243
+ * @summary verifies that illegal URI such as // is rejected
+ * @run main/othervm AnyURITest
+ */
+
+import java.io.*;
+import javax.xml.XMLConstants;
+import javax.xml.validation.Schema;
+import javax.xml.validation.SchemaFactory;
+import org.xml.sax.SAXException;
+
+/**
+ * Similar to java.net.URI, allow empty authority prior to non-empty
+ * path, query component or fragment identifier
+ *
+ * @author huizhe.wang@oracle.com
+ */
+public class AnyURITest {
+    static final String XSDFILE = "anyURI_b006.xsd";
+
+    public static void main(String[] args) throws Exception {
+        try{
+            SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
+            Schema schema = schemaFactory.newSchema(new File(System.getProperty("test.src", "."), XSDFILE));
+            throw new RuntimeException("Illegal URI // should be rejected.");
+        } catch (SAXException e) {
+            //expected:
+            //Enumeration value '//' is not in the value space of the base type, anyURI.
+        }
+
+
+    }
+
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/javax/xml/jaxp/validation/8015243/anyURI_b006.xsd	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,32 @@
+<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema">
+
+    	<xsd:element name="root">
+		<xsd:complexType>
+			<xsd:choice maxOccurs="unbounded">
+				<xsd:element ref="foo"/>
+				<xsd:element ref="bar"/>
+			</xsd:choice>
+		</xsd:complexType>
+	</xsd:element>
+
+    	<xsd:element type="xsd:anyURI" name="foo"></xsd:element>
+    	<xsd:element type="st" name="bar"></xsd:element>
+
+	<xsd:simpleType name="st">
+		<xsd:restriction base="xsd:anyURI">
+			<xsd:enumeration value="/"/>
+			<xsd:enumeration value="//"/>
+			<xsd:enumeration value="///"/>
+			<xsd:enumeration value="//a\\b"/>
+			<xsd:enumeration value="\"/>
+			<xsd:enumeration value="\\"/>
+			<xsd:enumeration value="\\\"/>
+			<xsd:enumeration value="\\/"/>
+			<xsd:enumeration value="\\a\b"/>
+			<xsd:enumeration value="\a\b"/>
+			<xsd:enumeration value="/a\b"/>
+			<xsd:enumeration value="..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\..\a"/>
+		</xsd:restriction>
+	</xsd:simpleType>
+
+</xsd:schema>
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/javax/xml/ws/clientjar/TestService.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,39 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import javax.jws.WebService;
+
+@WebService(serviceName ="TestService", targetNamespace = "http://test/jaxws/sample/")
+public class TestService {
+    public void foo() {
+        try {
+            bar();
+        } catch (Exception e) {
+            throw new AssertionError(e);
+        }
+    }
+
+    private void bar() {
+        // nothing done
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/javax/xml/ws/clientjar/TestWsImport.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,151 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 8016271 8026405
+ * @summary wsimport -clientjar does not create portable jar on windows due to hardcoded '\'
+ * @run main/othervm TestWsImport
+ */
+
+import javax.xml.namespace.QName;
+import javax.xml.ws.Endpoint;
+import javax.xml.ws.Service;
+import java.io.InputStreamReader;
+import java.io.IOException;
+import java.io.BufferedReader;
+import java.io.File;
+import java.net.InetSocketAddress;
+import java.net.URL;
+import java.nio.file.Files;
+import java.nio.file.FileVisitResult;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.nio.file.SimpleFileVisitor;
+import java.nio.file.attribute.BasicFileAttributes;
+import static java.nio.file.FileVisitResult.*;
+import java.util.Enumeration;
+import java.util.jar.JarFile;
+
+import com.sun.net.httpserver.HttpContext;
+import com.sun.net.httpserver.HttpServer;
+
+public class TestWsImport {
+
+    public static void main(String[] args) throws IOException {
+
+        String javaHome = System.getProperty("java.home");
+        if (javaHome.endsWith("jre")) {
+            javaHome = new File(javaHome).getParent();
+        }
+        String wsimport = javaHome + File.separator + "bin" + File.separator + "wsimport";
+        if (System.getProperty("os.name").startsWith("Windows")) {
+            wsimport = wsimport.concat(".exe");
+        }
+
+        Endpoint endpoint = Endpoint.create(new TestService());
+        HttpServer httpServer = null;
+        try {
+            // Manually create HttpServer here using ephemeral address for port
+            // so as to not end up with attempt to bind to an in-use port
+            httpServer = HttpServer.create(new InetSocketAddress(0), 0);
+            HttpContext httpContext = httpServer.createContext("/hello");
+            int port = httpServer.getAddress().getPort();
+            System.out.println("port = " + port);
+            httpServer.start();
+            endpoint.publish(httpContext);
+            String address = "http://localhost:" + port + "/hello";
+
+            Service service = Service.create(new URL(address + "?wsdl"),
+                new QName("http://test/jaxws/sample/", "TestService"));
+
+            String[] wsargs = {
+                wsimport,
+                "-p",
+                "wstest",
+                "-J-Djavax.xml.accessExternalSchema=all",
+                "-J-Dcom.sun.tools.internal.ws.Invoker.noSystemProxies=true",
+                address + "?wsdl",
+                "-clientjar",
+                "wsjar.jar"
+            };
+            ProcessBuilder pb = new ProcessBuilder(wsargs);
+            pb.redirectErrorStream(true);
+            Process p = pb.start();
+            BufferedReader r = new BufferedReader(new InputStreamReader(p.getInputStream()));
+            String s = r.readLine();
+            while (s != null) {
+                System.out.println(s.trim());
+                s = r.readLine();
+            }
+            p.waitFor();
+            p.destroy();
+
+            try (JarFile jarFile = new JarFile("wsjar.jar")) {
+                for (Enumeration em = jarFile.entries(); em.hasMoreElements();) {
+                    String fileName = em.nextElement().toString();
+                    if (fileName.contains("\\")) {
+                        throw new RuntimeException("\"\\\" character detected in jar file: " + fileName);
+                    }
+                }
+            }
+        } catch (Exception e) {
+            e.printStackTrace();
+            throw new RuntimeException(e.getMessage());
+        } finally {
+            endpoint.stop();
+            if (httpServer != null) {
+                httpServer.stop(0);
+            }
+            Path p = Paths.get("wsjar.jar");
+            Files.deleteIfExists(p);
+            p = Paths.get("wstest");
+            if (Files.exists(p)) {
+                try {
+                    Files.walkFileTree(p, new SimpleFileVisitor<Path>() {
+                        @Override
+                        public FileVisitResult visitFile(Path file,
+                            BasicFileAttributes attrs) throws IOException {
+
+                            Files.delete(file);
+                            return CONTINUE;
+                        }
+                        @Override
+                        public FileVisitResult postVisitDirectory(Path dir,
+                            IOException exc) throws IOException {
+
+                            if (exc == null) {
+                                Files.delete(dir);
+                                return CONTINUE;
+                            } else {
+                                throw exc;
+                            }
+                        }
+                    });
+                } catch (IOException ioe) {
+                    ioe.printStackTrace();
+                }
+            }
+        }
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/lib/testlibrary/jdk/testlibrary/FileUtils.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,194 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package jdk.testlibrary;
+
+import java.io.IOException;
+import java.nio.file.DirectoryNotEmptyException;
+import java.nio.file.FileVisitResult;
+import java.nio.file.Files;
+import java.nio.file.NoSuchFileException;
+import java.nio.file.Path;
+import java.nio.file.SimpleFileVisitor;
+import java.nio.file.attribute.BasicFileAttributes;
+import java.util.ArrayList;
+import java.util.List;
+
+
+/**
+ * Common library for various test file utility functions.
+ */
+public final class FileUtils {
+
+    private static final boolean isWindows =
+                            System.getProperty("os.name").startsWith("Windows");
+    private static final int RETRY_DELETE_MILLIS = isWindows ? 500 : 0;
+    private static final int MAX_RETRY_DELETE_TIMES = isWindows ? 15 : 0;
+
+    /**
+     * Deletes a file, retrying if necessary.
+     *
+     * @param path  the file to delete
+     *
+     * @throws NoSuchFileException
+     *         if the file does not exist (optional specific exception)
+     * @throws DirectoryNotEmptyException
+     *         if the file is a directory and could not otherwise be deleted
+     *         because the directory is not empty (optional specific exception)
+     * @throws IOException
+     *         if an I/O error occurs
+     */
+    public static void deleteFileWithRetry(Path path)
+        throws IOException
+    {
+        try {
+            deleteFileWithRetry0(path);
+        } catch (InterruptedException x) {
+            throw new IOException("Interrupted while deleting.", x);
+        }
+    }
+
+    /**
+     * Deletes a file, retrying if necessary.
+     * No exception thrown if file doesn't exist.
+     *
+     * @param path  the file to delete
+     *
+     * @throws NoSuchFileException
+     *         if the file does not exist (optional specific exception)
+     * @throws DirectoryNotEmptyException
+     *         if the file is a directory and could not otherwise be deleted
+     *         because the directory is not empty (optional specific exception)
+     * @throws IOException
+     *         if an I/O error occurs
+     */
+    public static void deleteFileIfExistsWithRetry(Path path)
+        throws IOException
+    {
+        try {
+            if(Files.exists(path))
+                deleteFileWithRetry0(path);
+        } catch (InterruptedException x) {
+            throw new IOException("Interrupted while deleting.", x);
+        }
+    }
+
+    private static void deleteFileWithRetry0(Path path)
+        throws IOException, InterruptedException
+    {
+        int times = 0;
+        IOException ioe = null;
+        while (true) {
+            try {
+                Files.delete(path);
+                while (Files.exists(path)) {
+                    times++;
+                    if (times > MAX_RETRY_DELETE_TIMES)
+                        throw new IOException("File still exists after " + times + " waits.");
+                    Thread.sleep(RETRY_DELETE_MILLIS);
+                }
+                break;
+            } catch (NoSuchFileException | DirectoryNotEmptyException x) {
+                throw x;
+            } catch (IOException x) {
+                // Backoff/retry in case another process is accessing the file
+                times++;
+                if (ioe == null)
+                    ioe = x;
+                else
+                    ioe.addSuppressed(x);
+
+                if (times > MAX_RETRY_DELETE_TIMES)
+                    throw ioe;
+                Thread.sleep(RETRY_DELETE_MILLIS);
+            }
+        }
+    }
+
+    /**
+     * Deletes a directory and its subdirectories, retrying if necessary.
+     *
+     * @param dir  the directory to delete
+     *
+     * @throws  IOException
+     *          If an I/O error occurs. Any such exceptions are caught
+     *          internally. If only one is caught, then it is re-thrown.
+     *          If more than one exception is caught, then the second and
+     *          following exceptions are added as suppressed exceptions of the
+     *          first one caught, which is then re-thrown.
+     */
+    public static void deleteFileTreeWithRetry(Path dir)
+         throws IOException
+    {
+        IOException ioe = null;
+        final List<IOException> excs = deleteFileTreeUnchecked(dir);
+        if (!excs.isEmpty()) {
+            ioe = excs.remove(0);
+            for (IOException x : excs)
+                ioe.addSuppressed(x);
+        }
+        if (ioe != null)
+            throw ioe;
+    }
+
+    public static List<IOException> deleteFileTreeUnchecked(Path dir) {
+        final List<IOException> excs = new ArrayList<>();
+        try {
+            java.nio.file.Files.walkFileTree(dir, new SimpleFileVisitor<Path>() {
+                @Override
+                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {
+                    try {
+                        deleteFileWithRetry0(file);
+                    } catch (IOException x) {
+                        excs.add(x);
+                    } catch (InterruptedException x) {
+                        excs.add(new IOException("Interrupted while deleting.", x));
+                        return FileVisitResult.TERMINATE;
+                    }
+                    return FileVisitResult.CONTINUE;
+                }
+                @Override
+                public FileVisitResult postVisitDirectory(Path dir, IOException exc) {
+                    try {
+                        deleteFileWithRetry0(dir);
+                    } catch (IOException x) {
+                        excs.add(x);
+                    } catch (InterruptedException x) {
+                        excs.add(new IOException("Interrupted while deleting.", x));
+                        return FileVisitResult.TERMINATE;
+                    }
+                    return FileVisitResult.CONTINUE;
+                }
+                @Override
+                public FileVisitResult visitFileFailed(Path file, IOException exc) {
+                    excs.add(exc);
+                    return FileVisitResult.CONTINUE;
+                }
+            });
+        } catch (IOException x) {
+            excs.add(x);
+        }
+        return excs;
+    }
+}
+
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/sun/awt/datatransfer/DataFlavorComparatorTest.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/* @test
+   @bug 7173464
+   @summary Clipboard.getAvailableDataFlavors: Comparison method violates contract
+   @author Petr Pchelko
+   @run main DataFlavorComparatorTest
+*/
+
+import sun.awt.datatransfer.DataTransferer;
+
+import java.awt.datatransfer.DataFlavor;
+
+public class DataFlavorComparatorTest {
+
+    public static void main(String[] args) {
+        DataTransferer.DataFlavorComparator comparator = new DataTransferer.DataFlavorComparator();
+        DataFlavor flavor1 = new DataFlavor("application/image", "Image");
+        DataFlavor flavor2 = new DataFlavor("application/html", "HTML");
+        if (comparator.compare(flavor1, flavor2) == 0) {
+            throw new RuntimeException(flavor1.getMimeType() + " and " + flavor2.getMimeType() +
+                " should not be equal");
+        }
+    }
+}
--- ./jdk/test/sun/management/jdp/JdpTest.sh	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/test/sun/management/jdp/JdpTest.sh	Wed May 07 19:26:47 2014 -0700
@@ -84,15 +84,29 @@
   ${TESTJAVA}/bin/java -server $* -cp ${_testclasses} ${testappname}  >> ${_logname} 2>&1 &
  _last_pid=$!
 
-  npid=`_get_pid`
-  if [ "${npid}" = "" ]
-  then
-     echo "ERROR: Test app not started. Please check machine resources before filing a bug."
-     if [ "${_jtreg}" = "yes" ]
-     then
-       exit 255
-     fi
-  fi
+# wait until VM is actually starts. 
+# please note, if vm doesn't start for some reason
+# jtreg kills the test by timeout. Don't file a bug.
+  cnt=1 
+  while true
+  do
+    npid=`_get_pid`
+    if [ "${npid}" != "" ]
+    then
+      break
+    fi
+    if [ "${cnt}" = "10" ]
+    then
+      echo "ERROR: Test app not started. Please check machine resources before filing a bug."
+      if [ "${_jtreg}" = "yes" ]
+      then
+          exit 255
+      fi
+      break
+    fi
+    cnt=`expr $cnt + 1`
+    sleep 1
+  done
 }
 
 _get_pid(){
--- ./jdk/test/sun/misc/IoTrace/IoTraceAgent.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/test/sun/misc/IoTrace/IoTraceAgent.java	Wed May 07 19:26:47 2014 -0700
@@ -27,6 +27,7 @@
 import static com.sun.xml.internal.ws.org.objectweb.asm.Opcodes.ACC_STATIC;
 import static com.sun.xml.internal.ws.org.objectweb.asm.Opcodes.ACC_SUPER;
 import static com.sun.xml.internal.ws.org.objectweb.asm.Opcodes.ILOAD;
+import static com.sun.xml.internal.ws.org.objectweb.asm.Opcodes.ALOAD;
 import static com.sun.xml.internal.ws.org.objectweb.asm.Opcodes.INVOKESPECIAL;
 import static com.sun.xml.internal.ws.org.objectweb.asm.Opcodes.INVOKESTATIC;
 import static com.sun.xml.internal.ws.org.objectweb.asm.Opcodes.IRETURN;
@@ -165,6 +166,7 @@
 
             // return the value from the called method
             mv.visitInsn(retType.getOpcode(IRETURN));
+            mv.visitMaxs(0, 0);
             mv.visitEnd();
         }
 
@@ -172,8 +174,10 @@
         MethodVisitor mv = cw.visitMethod(ACC_PRIVATE, "<init>", "()V", null,
                 null);
         mv.visitCode();
+        mv.visitVarInsn(ALOAD, 0);
         mv.visitMethodInsn(INVOKESPECIAL, "java/lang/Object", "<init>", "()V");
         mv.visitInsn(RETURN);
+        mv.visitMaxs(0, 0);
         mv.visitEnd();
 
         cw.visitEnd();
--- ./jdk/test/sun/misc/IoTrace/ioTraceTest.sh	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/test/sun/misc/IoTrace/ioTraceTest.sh	Wed May 07 19:26:47 2014 -0700
@@ -31,4 +31,4 @@
 ${TESTJAVA}/bin/jar cfm iotraceagent.jar ${TESTSRC}/iotraceagent.mf IoTraceAgent.class IoTraceListener.class
 
 cd ${PWD}
-${TESTJAVA}/bin/java ${TESTVMOPTS} -javaagent:${TESTCLASSES}/iotraceagent.jar -cp ${TESTCLASSES} $*
+${TESTJAVA}/bin/java -Xverify:all ${TESTVMOPTS} -javaagent:${TESTCLASSES}/iotraceagent.jar -cp ${TESTCLASSES} $*
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/sun/security/jgss/spnego/MechTokenMissing.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 8024861
+ * @summary Incomplete token triggers GSS-API NullPointerException
+ */
+
+import org.ietf.jgss.GSSContext;
+import org.ietf.jgss.GSSCredential;
+import org.ietf.jgss.GSSException;
+import org.ietf.jgss.GSSManager;
+
+public class MechTokenMissing {
+    public static void main(String[] args) throws Exception {
+        GSSCredential cred = null;
+        GSSContext ctx = GSSManager.getInstance().createContext(cred);
+
+        String var =
+            /*0000*/ "60 1C 06 06 2B 06 01 05 05 02 A0 12 30 10 A0 0E " +
+            /*0010*/ "30 0C 06 0A 2B 06 01 04 01 82 37 02 02 0A ";
+        byte[] token = new byte[var.length()/3];
+        for (int i=0; i<token.length; i++) {
+            token[i] = Integer.valueOf(var.substring(3*i,3*i+2), 16).byteValue();
+        }
+        try {
+            ctx.acceptSecContext(token, 0, token.length);
+        } catch (GSSException gsse) {
+            System.out.println("Expected exception: " + gsse);
+        }
+    }
+}
--- ./jdk/test/sun/security/krb5/ParseCAPaths.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/test/sun/security/krb5/ParseCAPaths.java	Wed May 07 19:26:47 2014 -0700
@@ -22,7 +22,7 @@
  */
 /*
  * @test
- * @bug 6789935
+ * @bug 6789935 8012615
  * @run main/othervm ParseCAPaths
  * @summary cross-realm capath search error
  */
@@ -35,37 +35,75 @@
     public static void main(String[] args) throws Exception {
         System.setProperty("java.security.krb5.conf",
                 System.getProperty("test.src", ".") +"/krb5-capaths.conf");
-        //System.setProperty("sun.security.krb5.debug", "true");
 
-        // Standard example
+        // MIT
         check("ANL.GOV", "TEST.ANL.GOV", "ANL.GOV");
         check("ANL.GOV", "ES.NET", "ANL.GOV");
         check("ANL.GOV", "PNL.GOV", "ANL.GOV", "ES.NET");
         check("ANL.GOV", "NERSC.GOV", "ANL.GOV", "ES.NET");
+        check("NERSC.GOV", "TEST.ANL.GOV", "NERSC.GOV", "ES.NET", "ANL.GOV");
+
+        // RedHat
+        // 3.6.2.1. Configuring a Shared Hierarchy of Names
+        check("AA.EXAMPLE.COM", "BB.EXAMPLE.COM",
+                "AA.EXAMPLE.COM", "EXAMPLE.COM");
+        check("SITE1.SALES.EXAMPLE.COM", "EVERYWHERE.EXAMPLE.COM",
+                "SITE1.SALES.EXAMPLE.COM", "SALES.EXAMPLE.COM",
+                "EXAMPLE.COM");
+        check("DEVEL.EXAMPLE.COM", "PROD.EXAMPLE.ORG",
+                "DEVEL.EXAMPLE.COM", "EXAMPLE.COM", "COM",
+                "ORG", "EXAMPLE.ORG");
+        // 3.6.2.2. Configuring Paths in krb5.conf
+        check("A.EXAMPLE.COM", "B.EXAMPLE.COM", "A.EXAMPLE.COM");
+        check("A.EXAMPLE.COM", "C.EXAMPLE.COM",
+                "A.EXAMPLE.COM", "B.EXAMPLE.COM");
+        check("A.EXAMPLE.COM", "D.EXAMPLE.COM",
+                "A.EXAMPLE.COM", "B.EXAMPLE.COM", "C.EXAMPLE.COM");
+
+        // The original JDK example
+        check("TIVOLI.COM", "IBM.COM", "TIVOLI.COM", "LDAPCENTRAL.NET",
+            "IBM_LDAPCENTRAL.COM", "MOONLITE.ORG");
+
         // Hierachical
-        check("N1.N.COM", "N2.N.COM", "N1.N.COM", "N.COM");     // 2 common
-        check("N1.N.COM", "N2.N3.COM", "N1.N.COM", "N.COM",     // 1 common
+        check("N1.N.COM", "N2.N.COM", "N1.N.COM", "N.COM");
+        check("N1.N.COM", "N2.N3.COM", "N1.N.COM", "N.COM",
                 "COM", "N3.COM");
-        check("N1.COM", "N2.COM", "N1.COM", "COM");             // 1 common
-        check("N1", "N2", "N1");                                // 0 common
-        // Extra garbages
-        check("A1.COM", "A4.COM", "A1.COM", "A2.COM");
+        check("N1.COM", "N2.COM", "N1.COM", "COM");
+        check("N1", "N2", "N1");
+        check("N1.COM", "N2.ORG", "N1.COM", "COM", "ORG");
+        check("N1.N.COM", "N.COM", "N1.N.COM");
+        check("X.N1.N.COM", "N.COM", "X.N1.N.COM", "N1.N.COM");
+        check("N.COM", "N1.N.COM", "N.COM");
+        check("N.COM", "X.N1.N.COM", "N.COM", "N1.N.COM");
+        check("A.B.C", "D.E.F", "A.B.C", "B.C", "C", "F", "E.F");
+
+        // Full path
+        check("A1.COM", "A2.COM", "A1.COM");
+        check("A1.COM", "A3.COM", "A1.COM", "A2.COM");
+        check("A1.COM", "A4.COM", "A1.COM", "A2.COM", "A3.COM");
+
+        // Shortest path
+        check("B1.COM", "B2.COM", "B1.COM");
         check("B1.COM", "B3.COM", "B1.COM", "B2.COM");
+        check("B1.COM", "B4.COM", "B1.COM", "B2.COM", "B3.COM");
+
         // Missing is "."
+        check("C1.COM", "C2.COM", "C1.COM", "COM");
         check("C1.COM", "C3.COM", "C1.COM", "C2.COM");
-        // Multiple path
-        check("D1.COM", "D4.COM", "D1.COM", "D2.COM");
-        check("E1.COM", "E4.COM", "E1.COM", "E2.COM");
-        check("F1.COM", "F4.COM", "F1.COM", "F9.COM");
-        // Infinite loop
-        check("G1.COM", "G3.COM", "G1.COM", "COM");
-        check("H1.COM", "H3.COM", "H1.COM");
+
+        // cRealm = .
+        check("D1.COM", "D2.COM", "D1.COM");
+
+        // Bad cases
+        check("E1.COM", "E2.COM", "E1.COM");
+        check("E1.COM", "E3.COM", "E1.COM", "E4.COM");
+        check("G1.COM", "G3.COM", "G1.COM", "G2.COM");
         check("I1.COM", "I4.COM", "I1.COM", "I5.COM");
-        // J2=J1 is the same as J2=.
-        check("J1.COM", "J2.COM", "J1.COM");
+
         // 7019384
         check("A9.PRAGUE.XXX.CZ", "SERVIS.XXX.CZ",
                 "A9.PRAGUE.XXX.CZ", "PRAGUE.XXX.CZ", "ROOT.XXX.CZ");
+
         if (failed != null) {
             throw failed;
         }
@@ -75,6 +113,7 @@
         try {
             check2(from, to, paths);
         } catch (Exception e) {
+            System.out.println("         " + e.getMessage());
             failed = e;
         }
     }
@@ -84,18 +123,15 @@
         System.out.println(from + " -> " + to);
         System.out.println("    expected: " + Arrays.toString(paths));
         String[] result = Realm.getRealmsList(from, to);
-        System.out.println("    result:   " + Arrays.toString(result));
-        if (result == null) {
-            if (paths.length == 0) {
-                // OK
-            } else {
-                throw new Exception("Shouldn't have a valid path.");
-            }
+        System.out.println("      result: " + Arrays.toString(result));
+        if (result == null || result.length == 0) {
+            throw new Exception("There is always a valid path.");
         } else if(result.length != paths.length) {
             throw new Exception("Length of path not correct");
         } else {
             for (int i=0; i<result.length; i++) {
                 if (!result[i].equals(paths[i])) {
+                    System.out.println("    result:   " + Arrays.toString(result));
                     throw new Exception("Path not same");
                 }
             }
--- ./jdk/test/sun/security/krb5/auto/BadKdc.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/test/sun/security/krb5/auto/BadKdc.java	Wed May 07 19:26:47 2014 -0700
@@ -39,7 +39,29 @@
     //                                               ^ kdc#         ^ timeout
     static final Pattern re = Pattern.compile(
             ">>> KDCCommunication: kdc=kdc.rabbit.hole UDP:(\\d)...., " +
-            "timeout=(\\d)000,");
+            "timeout=(\\d+),");
+
+    // Ratio for timeout values of all timeout tests. Not final so that
+    // each test can choose their own.
+    static float ratio = 2f;
+
+    static void setRatio(float ratio) {
+        BadKdc.ratio = ratio;
+    }
+
+    static float getRatio() {
+        return ratio;
+    }
+
+    // Gets real timeout value. This method is called when writing krb5.conf
+    static int toReal(int from) {
+        return (int)(from * ratio + .5);
+    }
+
+    // De-ratio a millisecond value to second
+    static int toSymbolicSec(int from) {
+        return (int)(from / ratio / 1000f + 0.5);
+    }
 
     /*
      * There are several cases this test fails:
@@ -97,7 +119,7 @@
 
         fw.write("[libdefaults]\n" +
                 "default_realm = " + OneKDC.REALM + "\n" +
-                "kdc_timeout = 2000\n");
+                "kdc_timeout = " + toReal(2000) + "\n");
         fw.write("[realms]\n" + OneKDC.REALM + " = {\n" +
                 "kdc = " + OneKDC.KDCHOST + ":" + p1 + "\n" +
                 "kdc = " + OneKDC.KDCHOST + ":" + p2 + "\n" +
@@ -171,7 +193,8 @@
             Matcher m = re.matcher(line);
             if (m.find()) {
                 System.out.println(line);
-                sb.append(m.group(1)).append(m.group(2));
+                sb.append(m.group(1))
+                        .append(toSymbolicSec(Integer.parseInt(m.group(2))));
             }
         }
         if (failed) sb.append('-');
--- ./jdk/test/sun/security/krb5/auto/BadKdc1.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/test/sun/security/krb5/auto/BadKdc1.java	Wed May 07 19:26:47 2014 -0700
@@ -28,14 +28,21 @@
  * @summary krb5 should not try to access unavailable kdc too often
  */
 
-import java.io.*;
 import java.security.Security;
 
 public class BadKdc1 {
 
    public static void main(String[] args)
            throws Exception {
-       Security.setProperty("krb5.kdc.bad.policy", "tryLess");
+
+       // 5 sec is default timeout for tryLess
+       if (BadKdc.getRatio() > 2.5) {
+           Security.setProperty("krb5.kdc.bad.policy",
+                   "tryLess:1," + BadKdc.toReal(2000));
+       } else {
+           Security.setProperty("krb5.kdc.bad.policy", "tryLess");
+       }
+
        BadKdc.go(
                "121212222222(32){1,2}1222(32){1,2}", // 1 2
                // The above line means try kdc1 for 2 seconds then kdc1
--- ./jdk/test/sun/security/krb5/auto/BadKdc2.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/test/sun/security/krb5/auto/BadKdc2.java	Wed May 07 19:26:47 2014 -0700
@@ -35,7 +35,12 @@
 
     public static void main(String[] args)
             throws Exception {
-        Security.setProperty("krb5.kdc.bad.policy", "tryLess:2,1000");
+
+        // 1 sec is too short.
+        BadKdc.setRatio(3.0f);
+
+        Security.setProperty(
+                "krb5.kdc.bad.policy", "tryLess:2," + BadKdc.toReal(1000));
         BadKdc.go(
                 "121212222222(32){1,2}11112121(32){1,2}", // 1 2
                 "11112121(32){1,2}11112121(32){1,2}", // 1 2
--- ./jdk/test/sun/security/krb5/auto/KDC.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/test/sun/security/krb5/auto/KDC.java	Wed May 07 19:26:47 2014 -0700
@@ -630,7 +630,7 @@
      * @return the response
      * @throws java.lang.Exception for various errors
      */
-    private byte[] processMessage(byte[] in) throws Exception {
+    protected byte[] processMessage(byte[] in) throws Exception {
         if ((in[0] & 0x1f) == Krb5.KRB_AS_REQ)
             return processAsReq(in);
         else
@@ -643,7 +643,7 @@
      * @return the response
      * @throws java.lang.Exception for various errors
      */
-    private byte[] processTgsReq(byte[] in) throws Exception {
+    protected byte[] processTgsReq(byte[] in) throws Exception {
         TGSReq tgsReq = new TGSReq(in);
         PrincipalName service = tgsReq.reqBody.sname;
         if (options.containsKey(KDC.Option.RESP_NT)) {
@@ -809,7 +809,7 @@
      * @return the response
      * @throws java.lang.Exception for various errors
      */
-    private byte[] processAsReq(byte[] in) throws Exception {
+    protected byte[] processAsReq(byte[] in) throws Exception {
         ASReq asReq = new ASReq(in);
         int[] eTypes = null;
         List<PAData> outPAs = new ArrayList<>();
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/sun/security/krb5/auto/LoginNoPass.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,73 @@
+/*
+ * Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 8028351
+ * @summary JWS doesn't get authenticated when using kerberos auth proxy
+ * @compile -XDignore.symbol.file LoginNoPass.java
+ * @run main/othervm LoginNoPass
+ */
+
+import sun.security.jgss.GSSUtil;
+
+import javax.security.auth.callback.Callback;
+import javax.security.auth.callback.CallbackHandler;
+import javax.security.auth.callback.NameCallback;
+import javax.security.auth.callback.PasswordCallback;
+import java.security.Security;
+
+public class LoginNoPass {
+
+    static boolean kdcTouched = false;
+    public static void main(String[] args) throws Exception {
+
+        new OneKDC(null) {
+            protected byte[] processAsReq(byte[] in) throws Exception {
+                kdcTouched = true;
+                return super.processAsReq(in);
+            }
+        }.writeJAASConf();
+        Security.setProperty("auth.login.defaultCallbackHandler",
+                "LoginNoPass$CallbackForClient");
+        System.setProperty("javax.security.auth.useSubjectCredsOnly", "false");
+
+        try {
+            Context c;
+            c = Context.fromJAAS("client");
+            c.startAsClient(OneKDC.SERVER, GSSUtil.GSS_KRB5_MECH_OID);
+            c.take(new byte[0]);
+        } catch (Exception e) {
+            e.printStackTrace(System.out);
+            // OK
+        }
+        if (kdcTouched) {
+            throw new Exception("Failed");
+        }
+    }
+    public static class CallbackForClient implements CallbackHandler {
+        public void handle(Callback[] callbacks) {
+            // Do nothing
+        }
+    }
+}
--- ./jdk/test/sun/security/krb5/auto/MaxRetries.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/test/sun/security/krb5/auto/MaxRetries.java	Wed May 07 19:26:47 2014 -0700
@@ -54,7 +54,7 @@
         test1(5000, 2);         // 2 2
 
         // For tryLess
-        Security.setProperty("krb5.kdc.bad.policy", "tryless");
+        Security.setProperty("krb5.kdc.bad.policy", "tryless:1," + BadKdc.toReal(5000));
         rewriteMaxRetries(4);
         test1(4000, 7);         // 1 1 1 1 2 1 2
         test1(4000, 4);         // 1 2 1 2
@@ -86,7 +86,7 @@
      * @param count the expected total try
      */
     private static void test1(int timeout, int count) throws Exception {
-        String timeoutTag = "timeout=" + timeout;
+        String timeoutTag = "timeout=" + BadKdc.toReal(timeout);
         ByteArrayOutputStream bo = new ByteArrayOutputStream();
         PrintStream oldout = System.out;
         System.setOut(new PrintStream(bo));
@@ -184,12 +184,12 @@
             if (s.startsWith("[realms]")) {
                 // Reconfig global setting
                 fw.write("max_retries = 2\n");
-                fw.write("kdc_timeout = 5000\n");
+                fw.write("kdc_timeout = " + BadKdc.toReal(5000) + "\n");
             } else if (s.trim().startsWith("kdc = ")) {
                 if (value != -1) {
                     // Reconfig for realm
                     fw.write("    max_retries = " + value + "\n");
-                    fw.write("    kdc_timeout = " + (value*1000) + "\n");
+                    fw.write("    kdc_timeout = " + BadKdc.toReal(value*1000) + "\n");
                 }
                 // Add a bad KDC as the first candidate
                 fw.write("    kdc = localhost:33333\n");
--- ./jdk/test/sun/security/krb5/auto/SaslGSS.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/test/sun/security/krb5/auto/SaslGSS.java	Wed May 07 19:26:47 2014 -0700
@@ -23,7 +23,7 @@
 
 /*
  * @test
- * @bug 8012082
+ * @bug 8012082 8019267
  * @summary SASL: auth-conf negotiated, but unencrypted data is accepted,
   *         reset to unencrypt
  * @compile -XDignore.symbol.file SaslGSS.java
@@ -37,9 +37,16 @@
 import javax.security.sasl.RealmCallback;
 import javax.security.sasl.Sasl;
 import javax.security.sasl.SaslServer;
+import java.io.ByteArrayOutputStream;
 import java.io.IOException;
+import java.io.PrintStream;
 import java.util.HashMap;
 import java.util.Locale;
+import java.util.logging.ConsoleHandler;
+import java.util.logging.Handler;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
 import org.ietf.jgss.*;
 import sun.security.jgss.GSSUtil;
 
@@ -79,14 +86,28 @@
                     }
                 });
 
-        // Handshake
+        ByteArrayOutputStream bout = new ByteArrayOutputStream();
+        PrintStream oldErr = System.err;
+        System.setErr(new PrintStream(bout));
+
+        Logger.getLogger("javax.security.sasl").setLevel(Level.ALL);
+        Handler h = new ConsoleHandler();
+        h.setLevel(Level.ALL);
+        Logger.getLogger("javax.security.sasl").addHandler(h);
+
         byte[] token = new byte[0];
-        token = sc.initSecContext(token, 0, token.length);
-        token = ss.evaluateResponse(token);
-        token = sc.unwrap(token, 0, token.length, new MessageProp(0, false));
-        token[0] = (byte)(((token[0] & 4) != 0) ? 4 : 2);
-        token = sc.wrap(token, 0, token.length, new MessageProp(0, false));
-        ss.evaluateResponse(token);
+
+        try {
+            // Handshake
+            token = sc.initSecContext(token, 0, token.length);
+            token = ss.evaluateResponse(token);
+            token = sc.unwrap(token, 0, token.length, new MessageProp(0, false));
+            token[0] = (byte)(((token[0] & 4) != 0) ? 4 : 2);
+            token = sc.wrap(token, 0, token.length, new MessageProp(0, false));
+            ss.evaluateResponse(token);
+        } finally {
+            System.setErr(oldErr);
+        }
 
         // Talk
         // 1. Client sends a auth-int message
@@ -102,5 +123,15 @@
         if (!qop.getPrivacy()) {
             throw new Exception();
         }
+
+        for (String s: bout.toString().split("\\n")) {
+            if (s.contains("KRB5SRV04") && s.contains("NULL")) {
+                return;
+            }
+        }
+        System.out.println("=======================");
+        System.out.println(bout.toString());
+        System.out.println("=======================");
+        throw new Exception("Haven't seen KRB5SRV04 with NULL");
     }
 }
--- ./jdk/test/sun/security/krb5/auto/TcpTimeout.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/test/sun/security/krb5/auto/TcpTimeout.java	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2010, 2012, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -24,7 +24,8 @@
 /*
  * @test
  * @bug 6952519
- * @run main/timeout=40/othervm TcpTimeout
+ * @compile -XDignore.symbol.file TcpTimeout.java
+ * @run main/othervm TcpTimeout
  * @summary kdc_timeout is not being honoured when using TCP
  */
 
@@ -36,103 +37,71 @@
     public static void main(String[] args)
             throws Exception {
 
+        // Set debug to grab debug output like ">>> KDCCommunication"
         System.setProperty("sun.security.krb5.debug", "true");
-        final int p1 = 10000 + new java.util.Random().nextInt(10000);
-        final int p2 = 20000 + new java.util.Random().nextInt(10000);
-        final int p3 = 30000 + new java.util.Random().nextInt(10000);
 
-        KDC k = new KDC(OneKDC.REALM, OneKDC.KDCHOST, p3, true);
+        // Called before new ServerSocket on p1 and p2 to make sure
+        // customized nameservice is used
+        KDC k = new KDC(OneKDC.REALM, OneKDC.KDCHOST, 0, true);
+        int p3 = k.getPort();
         k.addPrincipal(OneKDC.USER, OneKDC.PASS);
         k.addPrincipalRandKey("krbtgt/" + OneKDC.REALM);
 
         // Start two listener that does not communicate, simulate timeout
-        new Thread() {
-            public void run() {
-                try {
-                    new ServerSocket(p1).accept();
-                } catch (Exception e) {
-                }}
-        }.start();
-        new Thread() {
-            public void run() {
-                try {
-                    new ServerSocket(p2).accept();
-                } catch (Exception e) {
-                }}
-        }.start();
+        ServerSocket ss1 = null;
+        ServerSocket ss2 = null;
 
-        FileWriter fw = new FileWriter("alternative-krb5.conf");
+        try {
+            ss1 = new ServerSocket(0);
+            ss2 = new ServerSocket(0);
+            int p1 = ss1.getLocalPort();
+            int p2 = ss2.getLocalPort();
 
-        fw.write("[libdefaults]\n" +
-                "udp_preference_limit = 1\n" +
-                "max_retries = 2\n" +
-                "default_realm = " + OneKDC.REALM + "\n" +
-                "kdc_timeout = 5000\n");
-        fw.write("[realms]\n" + OneKDC.REALM + " = {\n" +
-                "kdc = " + OneKDC.KDCHOST + ":" + p1 + "\n" +
-                "kdc = " + OneKDC.KDCHOST + ":" + p2 + "\n" +
-                "kdc = " + OneKDC.KDCHOST + ":" + p3 + "\n" +
-                "}\n");
+            FileWriter fw = new FileWriter("alternative-krb5.conf");
 
-        fw.close();
-        System.setProperty("java.security.krb5.conf", "alternative-krb5.conf");
-        Config.refresh();
+            fw.write("[libdefaults]\n" +
+                    "udp_preference_limit = 1\n" +
+                    "max_retries = 2\n" +
+                    "default_realm = " + OneKDC.REALM + "\n" +
+                    "kdc_timeout = " + BadKdc.toReal(5000) + "\n");
+            fw.write("[realms]\n" + OneKDC.REALM + " = {\n" +
+                    "kdc = " + OneKDC.KDCHOST + ":" + p1 + "\n" +
+                    "kdc = " + OneKDC.KDCHOST + ":" + p2 + "\n" +
+                    "kdc = " + OneKDC.KDCHOST + ":" + p3 + "\n" +
+                    "}\n");
 
-        // The correct behavior should be:
-        // 5 sec on p1, 5 sec on p1, fail
-        // 5 sec on p2, 5 sec on p2, fail
-        // p3 ok, p3 ok again for preauth.
-        // The total time should be 20sec + 2x. x is processing time for AS-REQ.
-        int count = 6;
-        long start = System.nanoTime();
+            fw.close();
+            System.setProperty("java.security.krb5.conf",
+                    "alternative-krb5.conf");
+            Config.refresh();
 
-        ByteArrayOutputStream bo = new ByteArrayOutputStream();
-        PrintStream oldout = System.out;
-        System.setOut(new PrintStream(bo));
-        Context c = Context.fromUserPass(OneKDC.USER, OneKDC.PASS, false);
-        System.setOut(oldout);
+            System.out.println("Ports opened on " + p1 + ", " + p2 + ", " + p3);
 
-        String[] lines = new String(bo.toByteArray()).split("\n");
-        for (String line: lines) {
-            if (line.startsWith(">>> KDCCommunication")) {
-                System.out.println(line);
-                count--;
+            // The correct behavior should be:
+            // 5 sec on p1, 5 sec on p1, fail
+            // 5 sec on p2, 5 sec on p2, fail
+            // p3 ok, p3 ok again for preauth.
+            int count = 6;
+
+            ByteArrayOutputStream bo = new ByteArrayOutputStream();
+            PrintStream oldout = System.out;
+            System.setOut(new PrintStream(bo));
+            Context c = Context.fromUserPass(OneKDC.USER, OneKDC.PASS, false);
+            System.setOut(oldout);
+
+            String[] lines = new String(bo.toByteArray()).split("\n");
+            for (String line: lines) {
+                if (line.startsWith(">>> KDCCommunication")) {
+                    System.out.println(line);
+                    count--;
+                }
             }
-        }
-        if (count != 0) {
-            throw new Exception("Retry count is " + count + " less");
-        }
-
-        long end = System.nanoTime();
-        if ((end - start)/1000000000L < 20) {
-            throw new Exception("Too fast? " + (end - start)/1000000000L);
+            if (count != 0) {
+                throw new Exception("Retry count is " + count + " less");
+            }
+        } finally {
+            if (ss1 != null) ss1.close();
+            if (ss2 != null) ss2.close();
         }
     }
-
-    private static KDC on(int p) throws Exception {
-        KDC k = new KDC(OneKDC.REALM, OneKDC.KDCHOST, p, true);
-        k.addPrincipal(OneKDC.USER, OneKDC.PASS);
-        k.addPrincipalRandKey("krbtgt/" + OneKDC.REALM);
-        return k;
-    }
-
-    private static void addFakeKDCs()
-            throws Exception {
-        BufferedReader fr = new BufferedReader(new FileReader(OneKDC.KRB5_CONF));
-        FileWriter fw = new FileWriter("alternative-krb5.conf");
-        while (true) {
-            String s = fr.readLine();
-            if (s == null) {
-                break;
-            }
-            if (s.trim().startsWith("kdc = ")) {
-                fw.write("    kdc = localhost:33333\n");
-                fw.write("    kdc = localhost:22222\n");
-            }
-            fw.write(s + "\n");
-        }
-        fr.close();
-        fw.close();
-        sun.security.krb5.Config.refresh();
-    }
 }
--- ./jdk/test/sun/security/krb5/krb5-capaths.conf	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/test/sun/security/krb5/krb5-capaths.conf	Wed May 07 19:26:47 2014 -0700
@@ -1,6 +1,6 @@
 [capaths]
 
-# Standard
+# http://web.mit.edu/kerberos/krb5-1.5/krb5-1.5.4/doc/krb5-admin/capaths.html
 
 ANL.GOV = {
     TEST.ANL.GOV = .
@@ -14,81 +14,86 @@
 PNL.GOV = {
     ANL.GOV = ES.NET
 }
-NERSC.GOV = {
-    ANL.GOV = ES.NET
-}
+#NERSC.GOV = {
+#    ANL.GOV = ES.NET
+#}
 ES.NET = {
     ANL.GOV = .
 }
+NERSC.GOV = {
+    ANL.GOV = ES.NET
+    TEST.ANL.GOV = ES.NET
+    TEST.ANL.GOV = ANL.GOV
+    PNL.GOV = ES.NET
+    ES.NET = .
+}
 
-# Extra garbages
+# The original JDK example
+
+TIVOLI.COM = {
+    IBM.COM = IBM_LDAPCENTRAL.COM MOONLITE.ORG
+    IBM_LDAPCENTRAL.COM = LDAPCENTRAL.NET
+    LDAPCENTRAL.NET = .
+}
+
+# https://access.redhat.com/site/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Managing_Smart_Cards/Setting_Up_Cross_Realm_Authentication.html
+
+A.EXAMPLE.COM = {
+    B.EXAMPLE.COM = .
+    C.EXAMPLE.COM = B.EXAMPLE.COM
+    D.EXAMPLE.COM = B.EXAMPLE.COM
+    D.EXAMPLE.COM = C.EXAMPLE.COM
+}
+
+# Full path
 
 A1.COM = {
     A2.COM = .
+    A3.COM = A2.COM
     A4.COM = A2.COM
-    A3.COM = A4.COM
-    A3.COM = A2.COM
+    A4.COM = A3.COM
 }
 
+# Shortest path
+
 B1.COM = {
     B2.COM = .
     B3.COM = B2.COM
-    B3.COM = B4.COM
+    B4.COM = B3.COM
 }
 
-# Missing is "."
+# If no sRealm key, fallback to hierarchy
 
 C1.COM = {
     C3.COM = C2.COM
 }
 
-# Multiple paths
+# cRealm is "."
 
 D1.COM = {
-    D2.COM = .
-    D3.COM = .
-    D4.COM = D2.COM
-    D4.COM = D3.COM
+    D2.COM=D1.COM
 }
 
+# Bad cases
+
 E1.COM = {
-    E2.COM = .
+    E2.COM = E2.COM
+    E3.COM = E4.COM
     E3.COM = .
-    E4.COM = E2.COM   E3.COM   E2.COM
 }
 
-# Shortest or First?
-
-F1.COM = {
-    F2.COM = .
-    F3.COM = F2.COM
-    F4.COM = F9.COM
-    F4.COM = F3.COM
-    F4.COM = F2.COM
-}
-
-# Infinite loop
-
 G1.COM = {
     G2.COM = G3.COM
     G3.COM = G2.COM
 }
 
-H1.COM = {
-    H2.COM = H3.COM
-    H3.COM = H2.COM
-    H3.COM = .
-}
-
 I1.COM = {
     I2.COM = I3.COM
     I3.COM = I2.COM
-    I4.COM = I2.COM I5.COM
+    I4.COM = I5.COM
 }
 
-J1.COM = {
-    J2.COM=J1.COM
-}
+# 7019384
 
 A9.PRAGUE.XXX.CZ = {
     PRAGUE.XXX.CZ = .
--- ./jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/SSLEngineImpl/SSLEngineDeadlock.java	Tue Mar 18 12:35:25 2014 -0700
+++ ./jdk/test/sun/security/ssl/com/sun/net/ssl/internal/ssl/SSLEngineImpl/SSLEngineDeadlock.java	Wed May 07 19:26:47 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -75,6 +75,7 @@
 import java.io.*;
 import java.security.*;
 import java.nio.*;
+import java.lang.management.*;
 
 public class SSLEngineDeadlock {
 
@@ -145,6 +146,8 @@
             }
             SSLEngineDeadlock test = new SSLEngineDeadlock();
             test.runTest();
+
+            detectDeadLock();
         }
         System.out.println("Test Passed.");
     }
@@ -362,6 +365,22 @@
     }
 
     /*
+     * Detect dead lock
+     */
+    private static void detectDeadLock() throws Exception {
+        ThreadMXBean threadBean = ManagementFactory.getThreadMXBean();
+        long[] threadIds = threadBean.findDeadlockedThreads();
+        if (threadIds != null && threadIds.length != 0) {
+            for (long id : threadIds) {
+                ThreadInfo info =
+                    threadBean.getThreadInfo(id, Integer.MAX_VALUE);
+                System.out.println("Deadlocked ThreadInfo: " + info);
+            }
+            throw new Exception("Found Deadlock!");
+        }
+    }
+
+    /*
      * Logging code
      */
     private static boolean resultOnce = true;
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/sun/security/tools/jarsigner/EntriesOrder.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,204 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/**
+ * @test
+ * @bug 8031572
+ * @summary jarsigner -verify exits with 0 when a jar file is not properly signed
+ */
+
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.nio.file.Files;
+import java.nio.file.Paths;
+import java.security.cert.Certificate;
+import java.util.*;
+import java.util.jar.JarEntry;
+import java.util.jar.JarFile;
+import java.util.jar.JarInputStream;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipOutputStream;
+
+public class EntriesOrder {
+
+    public static void main(String[] args) throws Exception {
+
+        String[] entries = {
+                "META-INF/",
+                "META-INF/MANIFEST.MF",
+                "META-INF/A.RSA",
+                "META-INF/A.SF",
+                "META-INF/inf",
+                "a"};
+
+        Map<String,byte[]> content = new HashMap<>();
+
+        // We will create a jar containing entries above. Try all permutations
+        // and confirm 1) When opened as a JarFile, we can always get 3 signed
+        // ones (MANIFEST, inf, a), and 2) When opened as a JarInputStream,
+        // when the order is correct (MANIFEST at beginning, followed by RSA/SF,
+        // directory ignored), we can get 2 signed ones (inf, a).
+
+        // Prepares raw files
+        Files.write(Paths.get("a"), "a".getBytes());
+        Files.createDirectory(Paths.get("META-INF/"));
+        Files.write(Paths.get("META-INF/inf"), "inf".getBytes());
+
+        // Pack, sign, and extract to get all files
+        sun.tools.jar.Main m =
+                new sun.tools.jar.Main(System.out, System.err, "jar");
+        if (!m.run("cvf a.jar a META-INF/inf".split(" "))) {
+            throw new Exception("jar creation failed");
+        }
+        sun.security.tools.KeyTool.main(
+                ("-keystore jks -storepass changeit -keypass changeit -dname" +
+                        " CN=A -alias a -genkeypair -keyalg rsa").split(" "));
+        sun.security.tools.JarSigner.main(
+                "-keystore jks -storepass changeit a.jar a".split(" "));
+        m = new sun.tools.jar.Main(System.out, System.err, "jar");
+        if (!m.run("xvf a.jar".split(" "))) {
+            throw new Exception("jar extraction failed");
+        }
+
+        // Data
+        for (String s: entries) {
+            if (!s.endsWith("/")) {
+                content.put(s, Files.readAllBytes(Paths.get(s)));
+            }
+        }
+
+        // Test
+        for (List<String> perm: Permute(entries)) {
+
+            // Recreate a jar
+            try (ZipOutputStream zos
+                         = new ZipOutputStream(new FileOutputStream("x.jar"))) {
+                for (String e: perm) {
+                    zos.putNextEntry(new ZipEntry(e));
+                    if (Paths.get(e).toFile().isDirectory()) continue;
+                    zos.write(content.get(e));
+                }
+            }
+
+            // Open with JarFile, number of signed entries should be 3.
+            int cc = 0;
+            try (JarFile jf = new JarFile("x.jar")) {
+                Enumeration<JarEntry> jes = jf.entries();
+                while (jes.hasMoreElements()) {
+                    JarEntry je = jes.nextElement();
+                    sun.misc.IOUtils.readFully(jf.getInputStream(je), -1, true);
+                    Certificate[] certs = je.getCertificates();
+                    if (certs != null && certs.length > 0) {
+                        cc++;
+                    }
+                }
+            }
+
+            if (cc != 3) {
+                System.out.println(perm + " - jf - " + cc);
+                throw new Exception();
+            }
+
+            // Open with JarInputStream
+            int signed;
+
+            perm.remove("META-INF/");
+            if (perm.get(0).equals("META-INF/MANIFEST.MF") &&
+                    perm.get(1).contains("/A.") &&
+                    perm.get(2).contains("/A.")) {
+                signed = 2;     // Good order
+            } else {
+                signed = 0;     // Bad order. In this case, the number of signed
+                                // entries is not documented. Just test impl.
+            }
+
+            cc = 0;
+            try (JarInputStream jis
+                         = new JarInputStream(new FileInputStream("x.jar"))) {
+                while (true) {
+                    JarEntry je = jis.getNextJarEntry();
+                    if (je == null) break;
+                    sun.misc.IOUtils.readFully(jis, -1, true);
+                    Certificate[] certs = je.getCertificates();
+                    if (certs != null && certs.length > 0) {
+                        cc++;
+                    }
+                }
+            }
+
+            if (cc != signed) {
+                System.out.println(perm + " - jis - " + cc + " " + signed);
+                throw new Exception();
+            }
+        }
+    }
+
+    // Helper method to return all permutations of an array. Each output can
+    // be altered without damaging the iteration process.
+    static Iterable<List<String>> Permute(final String[] entries) {
+        return new Iterable<List<String>>() {
+
+            int s = entries.length;
+            long c = factorial(s) - 1;      // number of permutations
+
+            private long factorial(int n) {
+                return (n == 1) ? 1: (n * factorial(n-1));
+            }
+
+            @Override
+            public Iterator<List<String>> iterator() {
+                return new Iterator<List<String>>() {
+                    @Override
+                    public boolean hasNext() {
+                        return c >= 0;
+                    }
+
+                    @Override
+                    public void remove() {
+                        throw new UnsupportedOperationException("remove");
+                    }
+
+                    @Override
+                    public List<String> next() {
+                        if (c < 0) return null;
+                        List<String> result = new ArrayList<>(s);
+                        LinkedList<String> source = new LinkedList<>(
+                                Arrays.asList(entries));
+                        // Treat c as a integer with different radixes at
+                        // different digits, i.e. at digit 0, radix is s;
+                        // at digit 1, radix is s-1. Thus a s-digit number
+                        // is able to represent s! different values.
+                        long n = c;
+                        for (int i=s; i>=1; i--) {
+                            int x = (int)(n % i);
+                            result.add(source.remove(x));
+                            n = n / i;
+                        }
+                        c--;
+                        return result;
+                    }
+                };
+            }
+        };
+    }
+}
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/sun/security/tools/jarsigner/jvindex.sh	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,76 @@
+#
+# Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+
+# @test
+# @bug 8022761
+# @summary regression: SecurityException is NOT thrown while trying to pack a wrongly signed Indexed Jar file
+#
+
+if [ "${TESTJAVA}" = "" ] ; then
+  JAVAC_CMD=`which javac`
+  TESTJAVA=`dirname $JAVAC_CMD`/..
+fi
+
+# set platform-dependent variables
+OS=`uname -s`
+case "$OS" in
+  Windows_* )
+    FS="\\"
+    ;;
+  * )
+    FS="/"
+    ;;
+esac
+
+F=abcde
+KS=jvindex.jks
+JFILE=jvindex.jar
+
+KT="$TESTJAVA${FS}bin${FS}keytool -storepass changeit -keypass changeit \
+        -keystore $KS"
+JAR=$TESTJAVA${FS}bin${FS}jar
+JARSIGNER="$TESTJAVA${FS}bin${FS}jarsigner -keystore $KS -storepass changeit"
+
+rm $F $KS $JFILE 2> /dev/null
+
+echo 12345 > $F
+$JAR cvf $JFILE $F
+
+ERR=""
+
+$KT -alias a -dname CN=a -genkey -validity 300 || ERR="$ERR 1"
+
+$JARSIGNER $JFILE a || ERR="$ERR 2"
+$JAR i $JFILE
+
+# Make sure the $F line has "sm" (signed and in manifest)
+$JARSIGNER -verify -verbose $JFILE | grep $F | grep sm || ERR="$ERR 3"
+
+if [ "$ERR" = "" ]; then
+    exit 0
+else
+    echo "ERR is $ERR"
+    exit 1
+fi
+
+
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./jdk/test/tools/launcher/I18NArgTest.java	Wed May 07 19:26:47 2014 -0700
@@ -0,0 +1,111 @@
+/*
+ * Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 8016110
+ * @summary verify Japanese character in an argument are treated correctly
+ * @compile -XDignore.symbol.file I18NArgTest.java
+ * @run main I18NArgTest
+ */
+import java.io.IOException;
+
+public class I18NArgTest extends TestHelper {
+    public static void main(String... args) throws IOException {
+        if (!isWindows) {
+            return;
+        }
+        if (!"MS932".equals(System.getProperty("sun.jnu.encoding"))) {
+            System.err.println("MS932 encoding not set, test skipped");
+            return;
+        }
+        if (args.length == 0) {
+            execTest(0x30bd); // MS932 Katakana SO, 0x835C
+        } else {
+            testCharacters(args);
+        }
+    }
+    static void execTest(int unicodeValue) {
+        String hexValue = Integer.toHexString(unicodeValue);
+        String unicodeStr = Character.toString((char)unicodeValue);
+        execTest("\"" + unicodeStr + "\"", hexValue);
+        execTest("\\" + unicodeStr + "\\", hexValue);
+        execTest(" " + unicodeStr + " ", hexValue);
+        execTest("'" + unicodeStr + "'", hexValue);
+        execTest("\t" + unicodeStr + "\t", hexValue);
+        execTest("*" + unicodeStr + "*", hexValue);
+        execTest("?" + unicodeStr + "?", hexValue);
+
+        execTest("\"" + unicodeStr + unicodeStr + "\"", hexValue + hexValue);
+        execTest("\\" + unicodeStr + unicodeStr + "\\", hexValue + hexValue);
+        execTest(" " + unicodeStr + unicodeStr + " ", hexValue + hexValue);
+        execTest("'" + unicodeStr + unicodeStr + "'", hexValue + hexValue);
+        execTest("\t" + unicodeStr + unicodeStr + "\t", hexValue + hexValue);
+        execTest("*" + unicodeStr + unicodeStr + "*", hexValue + hexValue);
+        execTest("?" + unicodeStr + unicodeStr + "?", hexValue + hexValue);
+
+        execTest("\"" + unicodeStr + "a" + unicodeStr + "\"", hexValue + "61" + hexValue);
+        execTest("\\" + unicodeStr + "a" + unicodeStr + "\\", hexValue + "61" + hexValue);
+        execTest(" " + unicodeStr + "a" + unicodeStr + " ", hexValue + "61"+ hexValue);
+        execTest("'" + unicodeStr + "a" + unicodeStr + "'", hexValue + "61"+ hexValue);
+        execTest("\t" + unicodeStr + "a" + unicodeStr + "\t", hexValue + "61"+ hexValue);
+        execTest("*" + unicodeStr + "a" + unicodeStr + "*", hexValue + "61"+ hexValue);
+        execTest("?" + unicodeStr + "a" + unicodeStr + "?", hexValue + "61"+ hexValue);
+
+        execTest("\"" + unicodeStr + "\u00b1" + unicodeStr + "\"", hexValue + "b1" + hexValue);
+        execTest("\\" + unicodeStr + "\u00b1" + unicodeStr + "\\", hexValue + "b1" + hexValue);
+        execTest(" " + unicodeStr + "\u00b1" + unicodeStr + " ", hexValue + "b1"+ hexValue);
+        execTest("'" + unicodeStr + "\u00b1" + unicodeStr + "'", hexValue + "b1"+ hexValue);
+        execTest("\t" + unicodeStr + "\u00b1" + unicodeStr + "\t", hexValue + "b1"+ hexValue);
+        execTest("*" + unicodeStr + "\u00b1" + unicodeStr + "*", hexValue + "b1"+ hexValue);
+        execTest("?" + unicodeStr + "\u00b1" + unicodeStr + "?", hexValue + "b1"+ hexValue);
+    }
+    static void execTest(String unicodeStr, String hexValue) {
+        TestResult tr = doExec(javaCmd,
+                "-Dtest.src=" + TEST_SOURCES_DIR.getAbsolutePath(),
+                "-Dtest.classes=" + TEST_CLASSES_DIR.getAbsolutePath(),
+                "-cp", TEST_CLASSES_DIR.getAbsolutePath(),
+                "I18NArgTest", unicodeStr, hexValue);
+        System.out.println(tr.testOutput);
+        if (!tr.isOK()) {
+            System.err.println(tr);
+            throw new RuntimeException("test fails");
+        }
+    }
+    static void testCharacters(String... args) {
+        String input = args[0];
+        String expected = args[1];
+        String hexValue = "";
+        for (int i = 0; i < input.length(); i++) {
+            hexValue = hexValue.concat(Integer.toHexString((int)input.charAt(i)));
+        }
+        System.out.println("input:" + input);
+        System.out.println("expected:" + expected);
+        System.out.println("obtained:" + hexValue);
+        if (!hexValue.contains(expected)) {
+            String message = "Error: output does not contain expected value" +
+                "expected:" + expected + " obtained:" + hexValue;
+            throw new RuntimeException(message);
+        }
+    }
+}
--- ./langtools/.hgtags	Tue Mar 18 12:45:26 2014 -0700
+++ ./langtools/.hgtags	Wed May 07 19:27:09 2014 -0700
@@ -359,6 +359,7 @@
 765bea9bfcfc8c472df0a2daced5e576095f46ac jdk7u40-b42
 988ece7b686564084770e99ca26746c45ffb933f jdk7u40-b43
 a67dbf96bf86989d0392cc5b66e5d4139cbceec7 jdk7u40-b60
+849b17bc6e9a08fa41e0ef631e51366a09842e64 jdk7u60-b00
 b2e29b79e54e58349c1dbcf5449f67fc5d5a235a jdk7u40-b61
 94ea3d062a3c28c64a837fa8f999c6b6956ff7c4 jdk7u40-b62
 9bbfba4981e1db5016bbfbc23025763966021c26 jdk7u45-b01
@@ -416,3 +417,26 @@
 2bdd105e433da7fbf7f37ec2f75fc4bed4e54280 jdk7u55-b11
 a3cdca5d3773f67a49091f9131a4d073bc6b83d9 jdk7u55-b12
 81bf1ca3a3a71c628b7d952ba47c6f200a223f27 jdk7u55-b13
+96d55b4d88fea1d9f8227e70003210a6c10a1dba jdk7u55-b30
+c1964a222000b4884b992fdbaf8f62a45fb893c9 jdk7u55-b14
+4f6115ba266e5489b5e1968a28304f82be1f5641 jdk7u55-b31
+849b17bc6e9a08fa41e0ef631e51366a09842e64 jdk7u60-b00
+b19e375d9829daf207b1bdc7f908a3e1d548462c jdk7u60-b01
+954e1616449af74f68aed57261cbeb62403377f1 jdk7u60-b02
+4170784840d510b4e8ae7ae250b92279aaf5eb25 jdk7u60-b03
+772aad4e9681828b8ee193b9ed971cbfe6c7f347 jdk7u60-b04
+744287fccf3b2c4fba2abf105863f0a44c3bd4da jdk7u60-b05
+8f6db72756f3e4c3cca8731d20e978fb741846d2 jdk7u60-b06
+02f050bc5569fb058ace44ed705bbb0f9022a6fe jdk7u60-b07
+be8e34e4920ebd1cfb89739d636e363c7881a548 jdk7u60-b08
+3f8b585403e596b7eadc231484f5480361c52c4b jdk7u60-b09
+3ee98cd07065dfa9a982e6692a3e875684a7e820 jdk7u60-b10
+3cc64ba8cf85942929b15c5ef21360f96db3b99c jdk7u60-b11
+b79b8b1dc88faa73229b2bce04e979ff5ec854f5 jdk7u60-b12
+3dc3e59e9580dfdf95dac57c54fe1a4209401125 jdk7u60-b13
+a8b9c1929e50a9f3ae9ae1a23c06fa73a57afce3 jdk7u60-b14
+7568ebdada118da1d1a6addcf6316ffda21801fd jdk7u60-b15
+057caf9e0774e7c530c5710127f70c8d5f46deab jdk7u60-b16
+b7cc00c573c294b144317d44803758a291b3deda jdk7u60-b18
+b7cc00c573c294b144317d44803758a291b3deda jdk7u60-b17
+40aa95c8477aa0a3f090859570f5536afc9026b7 jdk7u60-b19
--- ./langtools/src/share/classes/com/sun/tools/doclets/formats/html/markup/HtmlDocWriter.java	Tue Mar 18 12:45:26 2014 -0700
+++ ./langtools/src/share/classes/com/sun/tools/doclets/formats/html/markup/HtmlDocWriter.java	Wed May 07 19:27:09 2014 -0700
@@ -181,12 +181,14 @@
                                String label, boolean strong,
                                String stylename, String title, String target) {
         StringBuffer retlink = new StringBuffer();
+        StringBuilder lnk = new StringBuilder();
         retlink.append("<a href=\"");
-        retlink.append(link);
+        lnk.append(link);
         if (where != null && where.length() != 0) {
-            retlink.append("#");
-            retlink.append(where);
+            lnk.append("#");
+            lnk.append(where);
         }
+        retlink.append(HtmlTree.encodeURL(lnk.toString()));
         retlink.append("\"");
         if (title != null && title.length() != 0) {
             retlink.append(" title=\"" + title + "\"");
--- ./langtools/src/share/classes/com/sun/tools/doclets/formats/html/markup/HtmlTree.java	Tue Mar 18 12:45:26 2014 -0700
+++ ./langtools/src/share/classes/com/sun/tools/doclets/formats/html/markup/HtmlTree.java	Wed May 07 19:27:09 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2010, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2010, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -26,6 +26,7 @@
 package com.sun.tools.doclets.formats.html.markup;
 
 import java.util.*;
+import java.nio.charset.*;
 import com.sun.tools.doclets.internal.toolkit.Content;
 import com.sun.tools.doclets.internal.toolkit.util.*;
 
@@ -116,6 +117,46 @@
     }
 
     /**
+     * A set of ASCII URI characters to be left unencoded.
+     */
+    public static final BitSet NONENCODING_CHARS = new BitSet(256);
+
+    static {
+        // alphabetic characters
+        for (int i = 'a'; i <= 'z'; i++) {
+            NONENCODING_CHARS.set(i);
+        }
+        for (int i = 'A'; i <= 'Z'; i++) {
+            NONENCODING_CHARS.set(i);
+        }
+        // numeric characters
+        for (int i = '0'; i <= '9'; i++) {
+            NONENCODING_CHARS.set(i);
+        }
+        // Reserved characters as per RFC 3986. These are set of delimiting characters.
+        String noEnc = ":/?#[]@!$&'()*+,;=";
+        // Unreserved characters as per RFC 3986 which should not be percent encoded.
+        noEnc += "-._~";
+        for (int i = 0; i < noEnc.length(); i++) {
+            NONENCODING_CHARS.set(noEnc.charAt(i));
+        }
+    }
+
+    protected static String encodeURL(String url) {
+        byte[] urlBytes = url.getBytes(Charset.forName("UTF-8"));
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0; i < urlBytes.length; i++) {
+            int c = urlBytes[i];
+            if (NONENCODING_CHARS.get(c & 0xFF)) {
+                sb.append((char) c);
+            } else {
+                sb.append(String.format("%%%02X", c & 0xFF));
+            }
+        }
+        return sb.toString();
+    }
+
+    /**
      * Generates an HTML anchor tag.
      *
      * @param ref reference url for the anchor tag
@@ -124,7 +165,7 @@
      */
     public static HtmlTree A(String ref, Content body) {
         HtmlTree htmltree = new HtmlTree(HtmlTag.A, nullCheck(body));
-        htmltree.addAttr(HtmlAttr.HREF, nullCheck(ref));
+        htmltree.addAttr(HtmlAttr.HREF, encodeURL(ref));
         return htmltree;
     }
 
--- ./langtools/src/share/classes/com/sun/tools/doclets/formats/html/markup/HtmlWriter.java	Tue Mar 18 12:45:26 2014 -0700
+++ ./langtools/src/share/classes/com/sun/tools/doclets/formats/html/markup/HtmlWriter.java	Wed May 07 19:27:09 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1997, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -362,6 +362,12 @@
                 "    if (targetPage.indexOf(\":\") != -1 || (targetPage != \"\" && !validURL(targetPage)))" + DocletConstants.NL +
                 "        targetPage = \"undefined\";" + DocletConstants.NL +
                 "    function validURL(url) {" + DocletConstants.NL +
+                "        try {" + DocletConstants.NL +
+                "            url = decodeURIComponent(url);" + DocletConstants.NL +
+                "        }" + DocletConstants.NL +
+                "        catch (error) {" + DocletConstants.NL +
+                "            return false;" + DocletConstants.NL +
+                "        }" + DocletConstants.NL +
                 "        var pos = url.indexOf(\".html\");" + DocletConstants.NL +
                 "        if (pos == -1 || pos != url.length - 5)" + DocletConstants.NL +
                 "            return false;" + DocletConstants.NL +
@@ -373,7 +379,8 @@
                 "            if ('a' <= ch && ch <= 'z' ||" + DocletConstants.NL +
                 "                    'A' <= ch && ch <= 'Z' ||" + DocletConstants.NL +
                 "                    ch == '$' ||" + DocletConstants.NL +
-                "                    ch == '_') {" + DocletConstants.NL +
+                "                    ch == '_' ||" + DocletConstants.NL +
+                "                    ch.charCodeAt(0) > 127) {" + DocletConstants.NL +
                 "                allowNumber = true;" + DocletConstants.NL +
                 "                allowSep = true;" + DocletConstants.NL +
                 "            } else if ('0' <= ch && ch <= '9'" + DocletConstants.NL +
--- ./langtools/src/share/classes/com/sun/tools/doclets/formats/html/resources/standard_ja.properties	Tue Mar 18 12:45:26 2014 -0700
+++ ./langtools/src/share/classes/com/sun/tools/doclets/formats/html/resources/standard_ja.properties	Wed May 07 19:27:09 2014 -0700
@@ -25,7 +25,7 @@
 doclet.Href_Enum_Title={0}\u5185\u306E\u5217\u6319\u578B
 doclet.Href_Type_Param_Title={0}\u5185\u306E\u578B\u30D1\u30E9\u30E1\u30FC\u30BF
 doclet.Href_Class_Or_Interface_Title={0}\u5185\u306E\u30AF\u30E9\u30B9\u307E\u305F\u306F\u30A4\u30F3\u30BF\u30D5\u30A7\u30FC\u30B9
-doclet.Summary=\u6982\u8981:
+doclet.Summary=\u30B5\u30DE\u30EA\u30FC:
 doclet.Detail=\u8A73\u7D30:
 doclet.navNested=\u30CD\u30B9\u30C8
 doclet.navAnnotationTypeOptionalMember=\u30AA\u30D7\u30B7\u30E7\u30F3
@@ -68,7 +68,7 @@
 doclet.see.class_or_package_not_found=\u30BF\u30B0{0}: \u53C2\u7167\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093: {1}
 doclet.see.class_or_package_not_accessible=\u30BF\u30B0{0}: \u53C2\u7167\u306B\u30A2\u30AF\u30BB\u30B9\u3067\u304D\u307E\u305B\u3093: {1}
 doclet.see.malformed_tag={0}\u30BF\u30B0: \u4E0D\u6B63\u306A{1}\u30BF\u30B0
-doclet.Inherited_API_Summary=\u7D99\u627F\u3055\u308C\u305FAPI\u306E\u6982\u8981
+doclet.Inherited_API_Summary=\u7D99\u627F\u3055\u308C\u305FAPI\u306E\u30B5\u30DE\u30EA\u30FC
 doclet.Deprecated_API=\u975E\u63A8\u5968\u306EAPI
 doclet.Deprecated_Packages=\u975E\u63A8\u5968\u306E\u30D1\u30C3\u30B1\u30FC\u30B8
 doclet.Deprecated_Classes=\u975E\u63A8\u5968\u306E\u30AF\u30E9\u30B9
@@ -135,18 +135,18 @@
 doclet.Help_title=API\u30D8\u30EB\u30D7
 doclet.Window_Help_title=API\u30D8\u30EB\u30D7
 doclet.Help_line_1=API\u30C9\u30AD\u30E5\u30E1\u30F3\u30C8\u306E\u69CB\u6210
-doclet.Help_line_2=\u3053\u306EAPI(Application Programming Interface)\u30C9\u30AD\u30E5\u30E1\u30F3\u30C8\u306B\u306F\u3001\u6B21\u306B\u8AAC\u660E\u3059\u308B\u30CA\u30D3\u30B2\u30FC\u30B7\u30E7\u30F3\u30FB\u30D0\u30FC\u306B\u3042\u308B\u9805\u76EE\u306B\u5BFE\u5FDC\u3059\u308B\u30DA\u30FC\u30B8\u304C\u542B\u307E\u308C\u307E\u3059\u3002
-doclet.Help_line_3={0}\u30DA\u30FC\u30B8\u306FAPI\u30C9\u30AD\u30E5\u30E1\u30F3\u30C8\u306E\u30D5\u30ED\u30F3\u30C8\u30FB\u30DA\u30FC\u30B8\u3067\u3001\u5404\u30D1\u30C3\u30B1\u30FC\u30B8\u306E\u6982\u8981\u3092\u542B\u3080\u5168\u30D1\u30C3\u30B1\u30FC\u30B8\u306E\u30EA\u30B9\u30C8\u304C\u8868\u793A\u3055\u308C\u307E\u3059\u3002\u4E00\u9023\u306E\u30D1\u30C3\u30B1\u30FC\u30B8\u306E\u6982\u8981\u8AAC\u660E\u3082\u8868\u793A\u3055\u308C\u307E\u3059\u3002
-doclet.Help_line_4=\u5404\u30D1\u30C3\u30B1\u30FC\u30B8\u306B\u306F\u3001\u305D\u306E\u30D1\u30C3\u30B1\u30FC\u30B8\u306E\u30AF\u30E9\u30B9\u304A\u3088\u3073\u30A4\u30F3\u30BF\u30D5\u30A7\u30FC\u30B9\u306E\u30EA\u30B9\u30C8\u3068\u3001\u305D\u308C\u305E\u308C\u306E\u6982\u8981\u3092\u542B\u3080\u30DA\u30FC\u30B8\u304C\u3042\u308A\u307E\u3059\u3002\u3053\u306E\u30DA\u30FC\u30B8\u306F6\u3064\u306E\u30AB\u30C6\u30B4\u30EA\u3067\u69CB\u6210\u3055\u308C\u307E\u3059\u3002
+doclet.Help_line_2=\u3053\u306EAPI (Application Programming Interface)\u30C9\u30AD\u30E5\u30E1\u30F3\u30C8\u306B\u306F\u3001\u6B21\u306B\u8AAC\u660E\u3059\u308B\u30CA\u30D3\u30B2\u30FC\u30B7\u30E7\u30F3\u30FB\u30D0\u30FC\u306B\u3042\u308B\u9805\u76EE\u306B\u5BFE\u5FDC\u3059\u308B\u30DA\u30FC\u30B8\u304C\u542B\u307E\u308C\u307E\u3059\u3002
+doclet.Help_line_3={0}\u30DA\u30FC\u30B8\u306FAPI\u30C9\u30AD\u30E5\u30E1\u30F3\u30C8\u306E\u30D5\u30ED\u30F3\u30C8\u30FB\u30DA\u30FC\u30B8\u3067\u3001\u5404\u30D1\u30C3\u30B1\u30FC\u30B8\u306E\u30B5\u30DE\u30EA\u30FC\u3092\u542B\u3080\u5168\u30D1\u30C3\u30B1\u30FC\u30B8\u306E\u30EA\u30B9\u30C8\u304C\u8868\u793A\u3055\u308C\u307E\u3059\u3002\u4E00\u9023\u306E\u30D1\u30C3\u30B1\u30FC\u30B8\u306E\u5168\u4F53\u7684\u306A\u8AAC\u660E\u3082\u8868\u793A\u3055\u308C\u307E\u3059\u3002
+doclet.Help_line_4=\u5404\u30D1\u30C3\u30B1\u30FC\u30B8\u306B\u306F\u3001\u305D\u306E\u30D1\u30C3\u30B1\u30FC\u30B8\u306E\u30AF\u30E9\u30B9\u304A\u3088\u3073\u30A4\u30F3\u30BF\u30D5\u30A7\u30FC\u30B9\u306E\u30EA\u30B9\u30C8\u3068\u3001\u305D\u308C\u305E\u308C\u306E\u30B5\u30DE\u30EA\u30FC\u3092\u542B\u3080\u30DA\u30FC\u30B8\u304C\u3042\u308A\u307E\u3059\u3002\u3053\u306E\u30DA\u30FC\u30B8\u306F6\u3064\u306E\u30AB\u30C6\u30B4\u30EA\u3067\u69CB\u6210\u3055\u308C\u307E\u3059\u3002
 doclet.Help_line_5=\u30AF\u30E9\u30B9\u307E\u305F\u306F\u30A4\u30F3\u30BF\u30D5\u30A7\u30FC\u30B9
-doclet.Help_line_6=\u5404\u30AF\u30E9\u30B9\u3001\u30A4\u30F3\u30BF\u30D5\u30A7\u30FC\u30B9\u3001\u30CD\u30B9\u30C8\u3055\u308C\u305F\u30AF\u30E9\u30B9\u304A\u3088\u3073\u30CD\u30B9\u30C8\u3055\u308C\u305F\u30A4\u30F3\u30BF\u30D5\u30A7\u30FC\u30B9\u306B\u306F\u500B\u5225\u306E\u30DA\u30FC\u30B8\u304C\u3042\u308A\u307E\u3059\u3002\u5404\u30DA\u30FC\u30B8\u306B\u306F\u6B21\u306E\u3088\u3046\u306B\u3001\u30AF\u30E9\u30B9\u307E\u305F\u306F\u30A4\u30F3\u30BF\u30D5\u30A7\u30FC\u30B9\u306E\u8AAC\u660E\u3068\u3001\u6982\u8981\u8868\u304A\u3088\u3073\u30E1\u30F3\u30D0\u30FC\u306E\u8A73\u7D30\u8AAC\u660E\u304C\u542B\u307E\u308C\u307E\u3059\u3002
+doclet.Help_line_6=\u5404\u30AF\u30E9\u30B9\u3001\u30A4\u30F3\u30BF\u30D5\u30A7\u30FC\u30B9\u3001\u30CD\u30B9\u30C8\u3055\u308C\u305F\u30AF\u30E9\u30B9\u304A\u3088\u3073\u30CD\u30B9\u30C8\u3055\u308C\u305F\u30A4\u30F3\u30BF\u30D5\u30A7\u30FC\u30B9\u306B\u306F\u500B\u5225\u306E\u30DA\u30FC\u30B8\u304C\u3042\u308A\u307E\u3059\u3002\u5404\u30DA\u30FC\u30B8\u306B\u306F\u6B21\u306E\u3088\u3046\u306B\u3001\u30AF\u30E9\u30B9\u307E\u305F\u306F\u30A4\u30F3\u30BF\u30D5\u30A7\u30FC\u30B9\u306E\u8AAC\u660E\u3068\u3001\u30B5\u30DE\u30EA\u30FC\u8868\u304A\u3088\u3073\u30E1\u30F3\u30D0\u30FC\u306E\u8A73\u7D30\u8AAC\u660E\u304C\u542B\u307E\u308C\u307E\u3059\u3002
 doclet.Help_line_7=\u30AF\u30E9\u30B9\u968E\u5C64\u8868\u793A
 doclet.Help_line_8=\u76F4\u7CFB\u306E\u30B5\u30D6\u30AF\u30E9\u30B9
 doclet.Help_line_9=\u65E2\u77E5\u306E\u30B5\u30D6\u30A4\u30F3\u30BF\u30D5\u30A7\u30FC\u30B9\u306E\u30EA\u30B9\u30C8
 doclet.Help_line_10=\u65E2\u77E5\u306E\u5B9F\u88C5\u30AF\u30E9\u30B9\u306E\u30EA\u30B9\u30C8
 doclet.Help_line_11=\u30AF\u30E9\u30B9\u307E\u305F\u306F\u30A4\u30F3\u30BF\u30D5\u30A7\u30FC\u30B9\u306E\u5BA3\u8A00
 doclet.Help_line_12=\u30AF\u30E9\u30B9\u307E\u305F\u306F\u30A4\u30F3\u30BF\u30D5\u30A7\u30FC\u30B9\u306E\u8AAC\u660E
-doclet.Help_line_13=\u5404\u6982\u8981\u30A8\u30F3\u30C8\u30EA\u306B\u306F\u3001\u305D\u306E\u9805\u76EE\u306E\u8A73\u7D30\u306A\u8AAC\u660E\u306E\u4E2D\u304B\u30891\u884C\u76EE\u306E\u6587\u304C\u8868\u793A\u3055\u308C\u307E\u3059\u3002\u8A73\u7D30\u306A\u8AAC\u660E\u306F\u30BD\u30FC\u30B9\u30FB\u30B3\u30FC\u30C9\u306B\u73FE\u308C\u308B\u9806\u306B\u4E26\u3079\u3089\u308C\u307E\u3059\u304C\u3001\u6982\u8981\u30A8\u30F3\u30C8\u30EA\u306F\u30A2\u30EB\u30D5\u30A1\u30D9\u30C3\u30C8\u9806\u306B\u4E26\u3079\u3089\u308C\u307E\u3059\u3002\u3053\u308C\u306B\u3088\u3063\u3066\u3001\u30D7\u30ED\u30B0\u30E9\u30DE\u304C\u8A2D\u5B9A\u3057\u305F\u8AD6\u7406\u7684\u306A\u30B0\u30EB\u30FC\u30D7\u5206\u3051\u304C\u4FDD\u6301\u3055\u308C\u307E\u3059\u3002
+doclet.Help_line_13=\u5404\u30B5\u30DE\u30EA\u30FC\u30FB\u30A8\u30F3\u30C8\u30EA\u306B\u306F\u3001\u305D\u306E\u9805\u76EE\u306E\u8A73\u7D30\u8AAC\u660E\u306E\u4E2D\u304B\u30891\u884C\u76EE\u306E\u6587\u304C\u8868\u793A\u3055\u308C\u307E\u3059\u3002\u30B5\u30DE\u30EA\u30FC\u30FB\u30A8\u30F3\u30C8\u30EA\u306F\u30A2\u30EB\u30D5\u30A1\u30D9\u30C3\u30C8\u9806\u3067\u3059\u304C\u3001\u8A73\u7D30\u8AAC\u660E\u306F\u30BD\u30FC\u30B9\u30FB\u30B3\u30FC\u30C9\u306B\u73FE\u308C\u308B\u9806\u306B\u306A\u3063\u3066\u3044\u307E\u3059\u3002\u3053\u308C\u306B\u3088\u3063\u3066\u3001\u30D7\u30ED\u30B0\u30E9\u30DE\u304C\u8A2D\u5B9A\u3057\u305F\u8AD6\u7406\u7684\u306A\u30B0\u30EB\u30FC\u30D7\u5206\u3051\u304C\u4FDD\u6301\u3055\u308C\u307E\u3059\u3002
 doclet.Help_line_14=\u4F7F\u7528
 doclet.Help_line_15=\u5404\u30C9\u30AD\u30E5\u30E1\u30F3\u30C8\u5316\u3055\u308C\u305F\u30D1\u30C3\u30B1\u30FC\u30B8\u3001\u30AF\u30E9\u30B9\u304A\u3088\u3073\u30A4\u30F3\u30BF\u30D5\u30A7\u30FC\u30B9\u306B\u306F\u305D\u308C\u305E\u308C\u300C\u4F7F\u7528\u300D\u30DA\u30FC\u30B8\u304C\u3042\u308A\u307E\u3059\u3002\u3053\u306E\u30DA\u30FC\u30B8\u306B\u306F\u3001\u3069\u306E\u3088\u3046\u306A\u30D1\u30C3\u30B1\u30FC\u30B8\u3001\u30AF\u30E9\u30B9\u3001\u30E1\u30BD\u30C3\u30C9\u3001\u30B3\u30F3\u30B9\u30C8\u30E9\u30AF\u30BF\u304A\u3088\u3073\u30D5\u30A3\u30FC\u30EB\u30C9\u304C\u3001\u7279\u5B9A\u306E\u30AF\u30E9\u30B9\u307E\u305F\u306F\u30D1\u30C3\u30B1\u30FC\u30B8\u306E\u4E00\u90E8\u3092\u4F7F\u7528\u3057\u3066\u3044\u308B\u304B\u304C\u8A18\u8FF0\u3055\u308C\u3066\u3044\u307E\u3059\u3002\u305F\u3068\u3048\u3070\u3001\u30AF\u30E9\u30B9A\u307E\u305F\u306F\u30A4\u30F3\u30BF\u30D5\u30A7\u30FC\u30B9A\u306E\u5834\u5408\u3001\u305D\u306E\u300C\u4F7F\u7528\u300D\u30DA\u30FC\u30B8\u306B\u306F\u3001A\u306E\u30B5\u30D6\u30AF\u30E9\u30B9\u3001A\u3068\u3057\u3066\u5BA3\u8A00\u3055\u308C\u308B\u30D5\u30A3\u30FC\u30EB\u30C9\u3001A\u3092\u8FD4\u3059\u30E1\u30BD\u30C3\u30C9\u3068\u3001\u578BA\u3092\u6301\u3064\u30E1\u30BD\u30C3\u30C9\u304A\u3088\u3073\u30B3\u30F3\u30B9\u30C8\u30E9\u30AF\u30BF\u304C\u542B\u307E\u308C\u307E\u3059\u3002\u3053\u306E\u30DA\u30FC\u30B8\u306B\u30A2\u30AF\u30BB\u30B9\u3059\u308B\u306B\u306F\u3001\u307E\u305A\u305D\u306E\u30D1\u30C3\u30B1\u30FC\u30B8\u3001\u30AF\u30E9\u30B9\u307E\u305F\u306F\u30A4\u30F3\u30BF\u30D5\u30A7\u30FC\u30B9\u306B\u79FB\u52D5\u3057\u3001\u30CA\u30D3\u30B2\u30FC\u30B7\u30E7\u30F3\u30FB\u30D0\u30FC\u306E\u300C\u4F7F\u7528\u300D\u30EA\u30F3\u30AF\u3092\u30AF\u30EA\u30C3\u30AF\u3057\u3066\u304F\u3060\u3055\u3044\u3002
 doclet.Help_line_16=\u968E\u5C64\u30C4\u30EA\u30FC(\u30AF\u30E9\u30B9\u968E\u5C64)
--- ./langtools/src/share/classes/com/sun/tools/doclets/internal/toolkit/resources/doclets.properties	Tue Mar 18 12:45:26 2014 -0700
+++ ./langtools/src/share/classes/com/sun/tools/doclets/internal/toolkit/resources/doclets.properties	Wed May 07 19:27:09 2014 -0700
@@ -182,25 +182,32 @@
 doclet.0_and_1={0} and {1}
 
 #Documentation for Enums
-doclet.enum_values_doc=\n\
+doclet.enum_values_doc.main=\n\
  Returns an array containing the constants of this enum type, in\n\
  the order they are declared.  This method may be used to iterate\n\
  over the constants as follows:\n\
  <pre>\n\
  for ({0} c : {0}.values())\n\
  &nbsp;   System.out.println(c);\n\
- </pre>\n\
- @return an array containing the constants of this enum type, in\n\
- the order they are declared
+ </pre>
 
-doclet.enum_valueof_doc=\n\
+doclet.enum_values_doc.return=\n\
+ an array containing the constants of this enum type, in the order they are declared
+
+doclet.enum_valueof_doc.main=\n\
  Returns the enum constant of this type with the specified name.\n\
  The string must match <i>exactly</i> an identifier used to declare an\n\
  enum constant in this type.  (Extraneous whitespace characters are \n\
- not permitted.)\n\
- \n\
- @param name the name of the enum constant to be returned.\n\
- @return the enum constant with the specified name\n\
- @throws IllegalArgumentException if this enum type has no constant\n\
-         with the specified name\n\
- @throws NullPointerException if the argument is null
+ not permitted.)
+
+doclet.enum_valueof_doc.param_name=\
+ the name of the enum constant to be returned.
+
+doclet.enum_valueof_doc.return=\
+ the enum constant with the specified name
+
+doclet.enum_valueof_doc.throws_ila=\
+ if this enum type has no constant with the specified name
+
+doclet.enum_valueof_doc.throws_npe=\
+ if the argument is null
--- ./langtools/src/share/classes/com/sun/tools/doclets/internal/toolkit/resources/doclets_ja.properties	Tue Mar 18 12:45:26 2014 -0700
+++ ./langtools/src/share/classes/com/sun/tools/doclets/internal/toolkit/resources/doclets_ja.properties	Wed May 07 19:27:09 2014 -0700
@@ -66,22 +66,22 @@
 doclet.malformed_html_link_tag=<a> \u30BF\u30B0\u306E\u5F62\u5F0F\u304C\u4E0D\u6B63:\n"{0}"
 doclet.tag_misuse={0}\u30BF\u30B0\u306F{1}\u30C9\u30AD\u30E5\u30E1\u30F3\u30C8\u5185\u3067\u306F\u4F7F\u7528\u3067\u304D\u307E\u305B\u3093\u3002\u4F7F\u7528\u3067\u304D\u308B\u306E\u306F\u6B21\u306E\u30BF\u30A4\u30D7\u306E\u30C9\u30AD\u30E5\u30E1\u30F3\u30C8\u5185\u306E\u307F\u3067\u3059: {2}\u3002
 doclet.javafx_tag_misuse=\u30BF\u30B0@propertyGetter\u3001@propertySetter\u304A\u3088\u3073@propertyDescription\u306F\u3001JavaFX\u306E\u30D7\u30ED\u30D1\u30C6\u30A3getter\u3068setter\u306E\u307F\u3067\u4F7F\u7528\u3067\u304D\u307E\u3059\u3002
-doclet.Package_Summary=\u30D1\u30C3\u30B1\u30FC\u30B8\u306E\u6982\u8981
-doclet.Interface_Summary=\u30A4\u30F3\u30BF\u30D5\u30A7\u30FC\u30B9\u306E\u6982\u8981
-doclet.Annotation_Types_Summary=\u6CE8\u91C8\u578B\u306E\u6982\u8981
-doclet.Enum_Summary=\u5217\u6319\u578B\u306E\u6982\u8981
-doclet.Exception_Summary=\u4F8B\u5916\u306E\u6982\u8981
-doclet.Error_Summary=\u30A8\u30E9\u30FC\u306E\u6982\u8981
-doclet.Class_Summary=\u30AF\u30E9\u30B9\u306E\u6982\u8981
-doclet.Nested_Class_Summary=\u30CD\u30B9\u30C8\u3055\u308C\u305F\u30AF\u30E9\u30B9\u306E\u6982\u8981
-doclet.Annotation_Type_Optional_Member_Summary=\u4EFB\u610F\u8981\u7D20\u306E\u6982\u8981
-doclet.Annotation_Type_Required_Member_Summary=\u5FC5\u9808\u8981\u7D20\u306E\u6982\u8981
-doclet.Field_Summary=\u30D5\u30A3\u30FC\u30EB\u30C9\u306E\u6982\u8981
-doclet.Property_Summary=\u30D7\u30ED\u30D1\u30C6\u30A3\u306E\u6982\u8981
-doclet.Enum_Constant_Summary=\u5217\u6319\u578B\u5B9A\u6570\u306E\u6982\u8981
-doclet.Constructor_Summary=\u30B3\u30F3\u30B9\u30C8\u30E9\u30AF\u30BF\u306E\u6982\u8981
-doclet.Method_Summary=\u30E1\u30BD\u30C3\u30C9\u306E\u6982\u8981
-doclet.Factory_Method_Summary=static\u30D5\u30A1\u30AF\u30C8\u30EA\u30FB\u30E1\u30BD\u30C3\u30C9\u306E\u6982\u8981
+doclet.Package_Summary=\u30D1\u30C3\u30B1\u30FC\u30B8\u306E\u30B5\u30DE\u30EA\u30FC
+doclet.Interface_Summary=\u30A4\u30F3\u30BF\u30D5\u30A7\u30FC\u30B9\u306E\u30B5\u30DE\u30EA\u30FC
+doclet.Annotation_Types_Summary=\u6CE8\u91C8\u578B\u306E\u30B5\u30DE\u30EA\u30FC
+doclet.Enum_Summary=\u5217\u6319\u578B\u306E\u30B5\u30DE\u30EA\u30FC
+doclet.Exception_Summary=\u4F8B\u5916\u306E\u30B5\u30DE\u30EA\u30FC
+doclet.Error_Summary=\u30A8\u30E9\u30FC\u306E\u30B5\u30DE\u30EA\u30FC
+doclet.Class_Summary=\u30AF\u30E9\u30B9\u306E\u30B5\u30DE\u30EA\u30FC
+doclet.Nested_Class_Summary=\u30CD\u30B9\u30C8\u3055\u308C\u305F\u30AF\u30E9\u30B9\u306E\u30B5\u30DE\u30EA\u30FC
+doclet.Annotation_Type_Optional_Member_Summary=\u4EFB\u610F\u8981\u7D20\u306E\u30B5\u30DE\u30EA\u30FC
+doclet.Annotation_Type_Required_Member_Summary=\u5FC5\u9808\u8981\u7D20\u306E\u30B5\u30DE\u30EA\u30FC
+doclet.Field_Summary=\u30D5\u30A3\u30FC\u30EB\u30C9\u306E\u30B5\u30DE\u30EA\u30FC
+doclet.Property_Summary=\u30D7\u30ED\u30D1\u30C6\u30A3\u306E\u30B5\u30DE\u30EA\u30FC
+doclet.Enum_Constant_Summary=\u5217\u6319\u578B\u5B9A\u6570\u306E\u30B5\u30DE\u30EA\u30FC
+doclet.Constructor_Summary=\u30B3\u30F3\u30B9\u30C8\u30E9\u30AF\u30BF\u306E\u30B5\u30DE\u30EA\u30FC
+doclet.Method_Summary=\u30E1\u30BD\u30C3\u30C9\u306E\u30B5\u30DE\u30EA\u30FC
+doclet.Factory_Method_Summary=static\u30D5\u30A1\u30AF\u30C8\u30EA\u30FB\u30E1\u30BD\u30C3\u30C9\u306E\u30B5\u30DE\u30EA\u30FC
 doclet.Interfaces=\u30A4\u30F3\u30BF\u30D5\u30A7\u30FC\u30B9
 doclet.Enums=\u5217\u6319\u578B
 doclet.AnnotationTypes=\u6CE8\u91C8\u578B
@@ -180,6 +180,16 @@
 doclet.0_and_1={0}\u3068{1}
 
 #Documentation for Enums
-doclet.enum_values_doc=\n\u3053\u306E\u5217\u6319\u578B\u306E\u5B9A\u6570\u3092\u542B\u3080\u914D\u5217\u3092\u5BA3\u8A00\u3055\u308C\u3066\u3044\u308B\u9806\u5E8F\u3067\u8FD4\u3057\u307E\u3059\u3002\n\u3053\u306E\u30E1\u30BD\u30C3\u30C9\u306F\u6B21\u306E\u3088\u3046\u306B\u3057\u3066\u5B9A\u6570\u3092\u53CD\u5FA9\u3059\u308B\u305F\u3081\u306B\n\u4F7F\u7528\u3067\u304D\u307E\u3059:\n<pre>\nfor({0} c: {0}.values())\n&nbsp; System.out.println(c);\n</pre>\n@return \u3053\u306E\u5217\u6319\u578B\u306E\u5B9A\u6570\u3092\u5BA3\u8A00\u3055\u308C\u3066\u3044\u308B\u9806\u5E8F\u3067\n\u542B\u3080\u914D\u5217
+doclet.enum_values_doc.main=\n\u3053\u306E\u5217\u6319\u578B\u306E\u5B9A\u6570\u3092\u542B\u3080\u914D\u5217\u3092\u5BA3\u8A00\u3055\u308C\u3066\u3044\u308B\u9806\u5E8F\u3067\u8FD4\u3057\u307E\u3059\u3002\n\u3053\u306E\u30E1\u30BD\u30C3\u30C9\u306F\u6B21\u306E\u3088\u3046\u306B\u3057\u3066\u5B9A\u6570\u3092\u53CD\u5FA9\u3059\u308B\u305F\u3081\u306B\n\u4F7F\u7528\u3067\u304D\u307E\u3059:\n<pre>\nfor({0} c: {0}.values())\n&nbsp; System.out.println(c);\n</pre>\n
 
-doclet.enum_valueof_doc=\n\u6307\u5B9A\u3057\u305F\u540D\u524D\u3092\u6301\u3064\u3053\u306E\u578B\u306E\u5217\u6319\u578B\u5B9A\u6570\u3092\u8FD4\u3057\u307E\u3059\u3002\n\u6587\u5B57\u5217\u306F\u3001\u3053\u306E\u578B\u306E\u5217\u6319\u578B\u5B9A\u6570\u3092\u5BA3\u8A00\u3059\u308B\u306E\u306B\u4F7F\u7528\u3057\u305F\u8B58\u5225\u5B50\u3068<i>\u6B63\u78BA\u306B</i>\n\u4E00\u81F4\u3057\u3066\u3044\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059\u3002\n(\u4F59\u5206\u306A\u7A7A\u767D\u6587\u5B57\u3092\u542B\u3081\u308B\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093\u3002)\n\n@param name \u8FD4\u3055\u308C\u308B\u5217\u6319\u578B\u5B9A\u6570\u306E\u540D\u524D\n@return \u6307\u5B9A\u3055\u308C\u305F\u540D\u524D\u3092\u6301\u3064\u5217\u6319\u578B\u5B9A\u6570\n@throws IllegalArgumentException \u6307\u5B9A\u3055\u308C\u305F\u540D\u524D\u3092\u6301\u3064\u5B9A\u6570\u3092\n\u3053\u306E\u5217\u6319\u578B\u304C\u6301\u3063\u3066\u3044\u306A\u3044\u5834\u5408\n@throws NullPointerException \u5F15\u6570\u304Cnull\u306E\u5834\u5408
+doclet.enum_values_doc.return=\n\u3053\u306E\u5217\u6319\u578B\u306E\u5B9A\u6570\u3092\u542B\u3080\u3001\u5BA3\u8A00\u3055\u308C\u3066\u3044\u308B\u9806\u5E8F\u3067\u306E\u914D\u5217
+
+doclet.enum_valueof_doc.main=\n\u6307\u5B9A\u3057\u305F\u540D\u524D\u3092\u6301\u3064\u3053\u306E\u578B\u306E\u5217\u6319\u578B\u5B9A\u6570\u3092\u8FD4\u3057\u307E\u3059\u3002\n\u6587\u5B57\u5217\u306F\u3001\u3053\u306E\u578B\u306E\u5217\u6319\u578B\u5B9A\u6570\u3092\u5BA3\u8A00\u3059\u308B\u306E\u306B\u4F7F\u7528\u3057\u305F\u8B58\u5225\u5B50\u3068<i>\u6B63\u78BA\u306B</i>\n\u4E00\u81F4\u3057\u3066\u3044\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059\u3002\n(\u4F59\u5206\u306A\u7A7A\u767D\u6587\u5B57\u3092\u542B\u3081\u308B\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093\u3002)\n
+
+doclet.enum_valueof_doc.param_name=\u8FD4\u3055\u308C\u308B\u5217\u6319\u578B\u5B9A\u6570\u306E\u540D\u524D\u3002
+
+doclet.enum_valueof_doc.return=\u6307\u5B9A\u3057\u305F\u540D\u524D\u306E\u5217\u6319\u578B\u5B9A\u6570
+
+doclet.enum_valueof_doc.throws_ila=\u3053\u306E\u5217\u6319\u578B\u306B\u3001\u6307\u5B9A\u3057\u305F\u540D\u524D\u306E\u5B9A\u6570\u304C\u306A\u3044\u5834\u5408
+
+doclet.enum_valueof_doc.throws_npe=\u5F15\u6570\u304Cnull\u306E\u5834\u5408
--- ./langtools/src/share/classes/com/sun/tools/doclets/internal/toolkit/resources/doclets_zh_CN.properties	Tue Mar 18 12:45:26 2014 -0700
+++ ./langtools/src/share/classes/com/sun/tools/doclets/internal/toolkit/resources/doclets_zh_CN.properties	Wed May 07 19:27:09 2014 -0700
@@ -180,6 +180,16 @@
 doclet.0_and_1={0}\u548C{1}
 
 #Documentation for Enums
-doclet.enum_values_doc=\n\u6309\u7167\u58F0\u660E\u8BE5\u679A\u4E3E\u7C7B\u578B\u7684\u5E38\u91CF\u7684\u987A\u5E8F, \u8FD4\u56DE\n\u5305\u542B\u8FD9\u4E9B\u5E38\u91CF\u7684\u6570\u7EC4\u3002\u8BE5\u65B9\u6CD5\u53EF\u7528\u4E8E\u8FED\u4EE3\n\u5E38\u91CF, \u5982\u4E0B\u6240\u793A:\n<pre>\nfor ({0} c : {0}.values())\n&nbsp;   System.out.println(c);\n</pre>\n@return \u6309\u7167\u58F0\u660E\u8BE5\u679A\u4E3E\u7C7B\u578B\u7684\u5E38\u91CF\u7684\u987A\u5E8F, \u8FD4\u56DE\n\u5305\u542B\u8FD9\u4E9B\u5E38\u91CF\u7684\u6570\u7EC4
+doclet.enum_values_doc.main=\n\u6309\u7167\u58F0\u660E\u8BE5\u679A\u4E3E\u7C7B\u578B\u7684\u5E38\u91CF\u7684\u987A\u5E8F, \u8FD4\u56DE\n\u5305\u542B\u8FD9\u4E9B\u5E38\u91CF\u7684\u6570\u7EC4\u3002\u8BE5\u65B9\u6CD5\u53EF\u7528\u4E8E\u8FED\u4EE3\n\u5E38\u91CF, \u5982\u4E0B\u6240\u793A:\n<pre>\nfor ({0} c : {0}.values())\n&nbsp;   System.out.println(c);\n</pre>
 
-doclet.enum_valueof_doc=\n\u8FD4\u56DE\u5E26\u6709\u6307\u5B9A\u540D\u79F0\u7684\u8BE5\u7C7B\u578B\u7684\u679A\u4E3E\u5E38\u91CF\u3002\n\u5B57\u7B26\u4E32\u5FC5\u987B\u4E0E\u7528\u4E8E\u58F0\u660E\u8BE5\u7C7B\u578B\u7684\u679A\u4E3E\u5E38\u91CF\u7684\n\u6807\u8BC6\u7B26<i>\u5B8C\u5168</i>\u5339\u914D\u3002(\u4E0D\u5141\u8BB8\u6709\u591A\u4F59\n\u7684\u7A7A\u683C\u5B57\u7B26\u3002)\n\n@param name \u8981\u8FD4\u56DE\u7684\u679A\u4E3E\u5E38\u91CF\u7684\u540D\u79F0\u3002\n@return \u8FD4\u56DE\u5E26\u6709\u6307\u5B9A\u540D\u79F0\u7684\u679A\u4E3E\u5E38\u91CF\n@throws IllegalArgumentException \u5982\u679C\u8BE5\u679A\u4E3E\u7C7B\u578B\u6CA1\u6709\u5E26\u6709\u6307\u5B9A\u540D\u79F0\u7684\u5E38\u91CF, \n\u5219\u629B\u51FA IllegalArgumentException\n@throws NullPointerException \u5982\u679C\u53C2\u6570\u4E3A\u7A7A\u503C, \u5219\u629B\u51FA NullPointerException
+doclet.enum_values_doc.return=\n\u6309\u7167\u58F0\u660E\u8BE5\u679A\u4E3E\u7C7B\u578B\u7684\u5E38\u91CF\u7684\u987A\u5E8F\u8FD4\u56DE\u7684\u5305\u542B\u8FD9\u4E9B\u5E38\u91CF\u7684\u6570\u7EC4
+
+doclet.enum_valueof_doc.main=\n\u8FD4\u56DE\u5E26\u6709\u6307\u5B9A\u540D\u79F0\u7684\u8BE5\u7C7B\u578B\u7684\u679A\u4E3E\u5E38\u91CF\u3002\n\u5B57\u7B26\u4E32\u5FC5\u987B\u4E0E\u7528\u4E8E\u58F0\u660E\u8BE5\u7C7B\u578B\u7684\u679A\u4E3E\u5E38\u91CF\u7684\n\u6807\u8BC6\u7B26<i>\u5B8C\u5168</i>\u5339\u914D\u3002(\u4E0D\u5141\u8BB8\u6709\u591A\u4F59\n\u7684\u7A7A\u683C\u5B57\u7B26\u3002)
+
+doclet.enum_valueof_doc.param_name=\u8981\u8FD4\u56DE\u7684\u679A\u4E3E\u5E38\u91CF\u7684\u540D\u79F0\u3002
+
+doclet.enum_valueof_doc.return=\u8FD4\u56DE\u5E26\u6709\u6307\u5B9A\u540D\u79F0\u7684\u679A\u4E3E\u5E38\u91CF
+
+doclet.enum_valueof_doc.throws_ila=\u5982\u679C\u8BE5\u679A\u4E3E\u7C7B\u578B\u6CA1\u6709\u5E26\u6709\u6307\u5B9A\u540D\u79F0\u7684\u5E38\u91CF
+
+doclet.enum_valueof_doc.throws_npe=\u5982\u679C\u53C2\u6570\u4E3A\u7A7A\u503C
--- ./langtools/src/share/classes/com/sun/tools/doclets/internal/toolkit/util/Util.java	Tue Mar 18 12:45:26 2014 -0700
+++ ./langtools/src/share/classes/com/sun/tools/doclets/internal/toolkit/util/Util.java	Wed May 07 19:27:09 2014 -0700
@@ -852,16 +852,28 @@
         for (int j = 0; j < methods.length; j++) {
             MethodDoc currentMethod = methods[j];
             if (currentMethod.name().equals("values") &&
-                currentMethod.parameters().length == 0) {
-                currentMethod.setRawCommentText(
-                    configuration.getText("doclet.enum_values_doc", classDoc.name()));
+                    currentMethod.parameters().length == 0) {
+                StringBuilder sb = new StringBuilder();
+                sb.append(configuration.getText("doclet.enum_values_doc.main", classDoc.name()));
+                sb.append("\n@return ");
+                sb.append(configuration.getText("doclet.enum_values_doc.return"));
+                currentMethod.setRawCommentText(sb.toString());
             } else if (currentMethod.name().equals("valueOf") &&
-                currentMethod.parameters().length == 1) {
+                    currentMethod.parameters().length == 1) {
                 Type paramType = currentMethod.parameters()[0].type();
                 if (paramType != null &&
-                    paramType.qualifiedTypeName().equals(String.class.getName())) {
-                    currentMethod.setRawCommentText(
-                        configuration.getText("doclet.enum_valueof_doc"));
+                        paramType.qualifiedTypeName().equals(String.class.getName())) {
+                StringBuilder sb = new StringBuilder();
+                sb.append(configuration.getText("doclet.enum_valueof_doc.main", classDoc.name()));
+                sb.append("\n@param name ");
+                sb.append(configuration.getText("doclet.enum_valueof_doc.param_name"));
+                sb.append("\n@return ");
+                sb.append(configuration.getText("doclet.enum_valueof_doc.return"));
+                sb.append("\n@throws IllegalArgumentException ");
+                sb.append(configuration.getText("doclet.enum_valueof_doc.throws_ila"));
+                sb.append("\n@throws NullPointerException ");
+                sb.append(configuration.getText("doclet.enum_valueof_doc.throws_npe"));
+                currentMethod.setRawCommentText(sb.toString());
                 }
             }
         }
--- ./langtools/src/share/classes/com/sun/tools/javac/code/Type.java	Tue Mar 18 12:45:26 2014 -0700
+++ ./langtools/src/share/classes/com/sun/tools/javac/code/Type.java	Wed May 07 19:27:09 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -597,6 +597,10 @@
                 };
         }
 
+        public List<Type> getComponents() {
+            return interfaces_field.prepend(supertype_field);
+        }
+
         /** The Java source which this type represents.
          */
         public String toString() {
--- ./langtools/src/share/classes/com/sun/tools/javac/code/Types.java	Tue Mar 18 12:45:26 2014 -0700
+++ ./langtools/src/share/classes/com/sun/tools/javac/code/Types.java	Wed May 07 19:27:09 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -1012,23 +1012,10 @@
                     }
                 }
 
-                if (t.isCompound()) {
-                    Warner oldWarner = warnStack.head;
-                    warnStack.head = Warner.noWarnings;
-                    if (!visit(supertype(t), s))
-                        return false;
-                    for (Type intf : interfaces(t)) {
-                        if (!visit(intf, s))
-                            return false;
-                    }
-                    if (warnStack.head.hasLint(LintCategory.UNCHECKED))
-                        oldWarner.warn(LintCategory.UNCHECKED);
-                    return true;
-                }
-
-                if (s.isCompound()) {
-                    // call recursively to reuse the above code
-                    return visitClassType((ClassType)s, t);
+                if (t.isCompound() || s.isCompound()) {
+                    return !t.isCompound() ?
+                            visitIntersectionType((ClassType)s, t, true) :
+                            visitIntersectionType(t, s, false);
                 }
 
                 if (s.tag == CLASS || s.tag == ARRAY) {
@@ -1106,6 +1093,18 @@
                 return false;
             }
 
+            boolean visitIntersectionType(ClassType ict, Type s, boolean reverse) {
+                Warner warn = Warner.noWarnings;
+                for (Type c : ict.getComponents()) {
+                    warn.clear();
+                    if (reverse ? !isCastable(s, c, warn) : !isCastable(c, s, warn))
+                        return false;
+                }
+                if (warn.hasLint(LintCategory.UNCHECKED))
+                    warnStack.head.warn(LintCategory.UNCHECKED);
+                return true;
+            }
+
             @Override
             public Boolean visitArrayType(ArrayType t, Type s) {
                 switch (s.tag) {
@@ -3369,11 +3368,18 @@
     }
 
     private boolean giveWarning(Type from, Type to) {
-        Type subFrom = asSub(from, to.tsym);
-        return to.isParameterized() &&
-                (!(isUnbounded(to) ||
-                isSubtype(from, to) ||
-                ((subFrom != null) && containsType(to.allparams(), subFrom.allparams()))));
+        List<Type> bounds = to.isCompound() ?
+                ((ClassType)to).getComponents() : List.of(to);
+        for (Type b : bounds) {
+            Type subFrom = asSub(from, b.tsym);
+            if (b.isParameterized() &&
+                    (!(isUnbounded(b) ||
+                    isSubtype(from, b) ||
+                    ((subFrom != null) && containsType(b.allparams(), subFrom.allparams()))))) {
+                return true;
+            }
+        }
+        return false;
     }
 
     private List<Type> superClosure(Type t, Type s) {
--- ./langtools/src/share/classes/com/sun/tools/javac/resources/javac_ja.properties	Tue Mar 18 12:45:26 2014 -0700
+++ ./langtools/src/share/classes/com/sun/tools/javac/resources/javac_ja.properties	Wed May 07 19:27:09 2014 -0700
@@ -30,14 +30,14 @@
 javac.opt.g.lines.vars.source=\u3044\u304F\u3064\u304B\u306E\u30C7\u30D0\u30C3\u30B0\u60C5\u5831\u306E\u307F\u3092\u751F\u6210\u3059\u308B
 javac.opt.nowarn=\u8B66\u544A\u3092\u767A\u751F\u3055\u305B\u306A\u3044
 javac.opt.verbose=\u30B3\u30F3\u30D1\u30A4\u30E9\u306E\u52D5\u4F5C\u306B\u3064\u3044\u3066\u30E1\u30C3\u30BB\u30FC\u30B8\u3092\u51FA\u529B\u3059\u308B
-javac.opt.deprecation=\u975E\u63A8\u5968\u306EAPI\u304C\u4F7F\u7528\u3055\u308C\u3066\u3044\u308B\u30BD\u30FC\u30B9\u306E\u4F4D\u7F6E\u3092\u51FA\u529B\u3059\u308B
+javac.opt.deprecation=\u975E\u63A8\u5968\u306EAPI\u304C\u4F7F\u7528\u3055\u308C\u3066\u3044\u308B\u30BD\u30FC\u30B9\u306E\u5834\u6240\u3092\u51FA\u529B\u3059\u308B
 javac.opt.classpath=\u30E6\u30FC\u30B6\u30FC\u30FB\u30AF\u30E9\u30B9\u30FB\u30D5\u30A1\u30A4\u30EB\u304A\u3088\u3073\u6CE8\u91C8\u30D7\u30ED\u30BB\u30C3\u30B5\u3092\u691C\u7D22\u3059\u308B\u4F4D\u7F6E\u3092\u6307\u5B9A\u3059\u308B
 javac.opt.sourcepath=\u5165\u529B\u30BD\u30FC\u30B9\u30FB\u30D5\u30A1\u30A4\u30EB\u3092\u691C\u7D22\u3059\u308B\u4F4D\u7F6E\u3092\u6307\u5B9A\u3059\u308B
-javac.opt.bootclasspath=\u30D6\u30FC\u30C8\u30B9\u30C8\u30E9\u30C3\u30D7\u30FB\u30AF\u30E9\u30B9\u30FB\u30D1\u30B9\u306E\u4F4D\u7F6E\u3092\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3059\u308B
+javac.opt.bootclasspath=\u30D6\u30FC\u30C8\u30B9\u30C8\u30E9\u30C3\u30D7\u30FB\u30AF\u30E9\u30B9\u30FB\u30D1\u30B9\u306E\u5834\u6240\u3092\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3059\u308B
 javac.opt.Xbootclasspath.p=\u30D6\u30FC\u30C8\u30B9\u30C8\u30E9\u30C3\u30D7\u30FB\u30AF\u30E9\u30B9\u30FB\u30D1\u30B9\u306B\u4ED8\u52A0\u3059\u308B
 javac.opt.Xbootclasspath.a=\u30D6\u30FC\u30C8\u30B9\u30C8\u30E9\u30C3\u30D7\u30FB\u30AF\u30E9\u30B9\u30FB\u30D1\u30B9\u306B\u8FFD\u52A0\u3059\u308B
-javac.opt.endorseddirs=\u63A8\u5968\u898F\u683C\u30D1\u30B9\u306E\u4F4D\u7F6E\u3092\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3059\u308B
-javac.opt.extdirs=\u30A4\u30F3\u30B9\u30C8\u30FC\u30EB\u6E08\u307F\u62E1\u5F35\u6A5F\u80FD\u306E\u4F4D\u7F6E\u3092\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3059\u308B
+javac.opt.endorseddirs=\u63A8\u5968\u898F\u683C\u30D1\u30B9\u306E\u5834\u6240\u3092\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3059\u308B
+javac.opt.extdirs=\u30A4\u30F3\u30B9\u30C8\u30FC\u30EB\u6E08\u307F\u62E1\u5F35\u6A5F\u80FD\u306E\u5834\u6240\u3092\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3059\u308B
 javac.opt.processorpath=\u6CE8\u91C8\u30D7\u30ED\u30BB\u30C3\u30B5\u3092\u691C\u7D22\u3059\u308B\u4F4D\u7F6E\u3092\u6307\u5B9A\u3059\u308B
 javac.opt.processor=\u5B9F\u884C\u3059\u308B\u6CE8\u91C8\u30D7\u30ED\u30BB\u30C3\u30B5\u306E\u540D\u524D\u3002\u30C7\u30D5\u30A9\u30EB\u30C8\u306E\u691C\u51FA\u51E6\u7406\u3092\u30D0\u30A4\u30D1\u30B9
 javac.opt.proc.none.only=\u6CE8\u91C8\u51E6\u7406\u3084\u30B3\u30F3\u30D1\u30A4\u30EB\u3092\u5B9F\u884C\u3059\u308B\u304B\u3069\u3046\u304B\u3092\u5236\u5FA1\u3057\u307E\u3059\u3002
@@ -115,7 +115,7 @@
 
 javac.msg.usage.nonstandard.footer=\u3053\u308C\u3089\u306F\u975E\u6A19\u6E96\u30AA\u30D7\u30B7\u30E7\u30F3\u3067\u3042\u308A\u4E88\u544A\u306A\u3057\u306B\u5909\u66F4\u3055\u308C\u308B\u3053\u3068\u304C\u3042\u308A\u307E\u3059\u3002
 
-javac.msg.bug=\u30B3\u30F3\u30D1\u30A4\u30E9\u3067\u4F8B\u5916\u304C\u767A\u751F\u3057\u307E\u3057\u305F({0})\u3002Bug Parade\u306B\u540C\u3058\u30D0\u30B0\u304C\u767B\u9332\u3055\u308C\u3066\u3044\u306A\u3044\u3053\u3068\u3092\u3054\u78BA\u8A8D\u306E\u4E0A\u3001Java Developer Connection(http://java.sun.com/webapps/bugreport)\u3067\u30D0\u30B0\u306E\u767B\u9332\u3092\u304A\u9858\u3044\u3044\u305F\u3057\u307E\u3059\u3002\u30EC\u30DD\u30FC\u30C8\u306B\u306F\u3001\u305D\u306E\u30D7\u30ED\u30B0\u30E9\u30E0\u3068\u4E0B\u8A18\u306E\u8A3A\u65AD\u5185\u5BB9\u3092\u542B\u3081\u3066\u304F\u3060\u3055\u3044\u3002\u3054\u5354\u529B\u3042\u308A\u304C\u3068\u3046\u3054\u3056\u3044\u307E\u3059\u3002
+javac.msg.bug=\u30B3\u30F3\u30D1\u30A4\u30E9\u3067\u4F8B\u5916\u304C\u767A\u751F\u3057\u307E\u3057\u305F({0})\u3002Bug Parade\u306B\u540C\u3058\u30D0\u30B0\u304C\u767B\u9332\u3055\u308C\u3066\u3044\u306A\u3044\u3053\u3068\u3092\u3054\u78BA\u8A8D\u306E\u4E0A\u3001Java Developer Connection (http://java.sun.com/webapps/bugreport)\u3067\u30D0\u30B0\u306E\u767B\u9332\u3092\u304A\u9858\u3044\u3044\u305F\u3057\u307E\u3059\u3002\u30EC\u30DD\u30FC\u30C8\u306B\u306F\u3001\u305D\u306E\u30D7\u30ED\u30B0\u30E9\u30E0\u3068\u4E0B\u8A18\u306E\u8A3A\u65AD\u5185\u5BB9\u3092\u542B\u3081\u3066\u304F\u3060\u3055\u3044\u3002\u3054\u5354\u529B\u3042\u308A\u304C\u3068\u3046\u3054\u3056\u3044\u307E\u3059\u3002
 
 javac.msg.io=\n\n\u5165\u51FA\u529B\u30A8\u30E9\u30FC\u304C\u767A\u751F\u3057\u307E\u3057\u305F\u3002\n\u8A73\u7D30\u306F\u6B21\u306E\u30B9\u30BF\u30C3\u30AF\u30FB\u30C8\u30EC\u30FC\u30B9\u3067\u8ABF\u67FB\u3057\u3066\u304F\u3060\u3055\u3044\u3002\n
 
--- ./langtools/src/share/classes/com/sun/tools/javah/resources/l10n_ja.properties	Tue Mar 18 12:45:26 2014 -0700
+++ ./langtools/src/share/classes/com/sun/tools/javah/resources/l10n_ja.properties	Wed May 07 19:27:09 2014 -0700
@@ -55,8 +55,8 @@
 main.opt.o=\  -o <file>                \u51FA\u529B\u30D5\u30A1\u30A4\u30EB(-d\u304B-o\u306E\u3069\u3061\u3089\u304B\u4E00\u65B9\u3092\u4F7F\u7528\u3059\u308B)
 main.opt.d=\  -d <dir>                 \u51FA\u529B\u30C7\u30A3\u30EC\u30AF\u30C8\u30EA
 main.opt.v=\  -v  -verbose             \u8A73\u7D30\u306A\u51FA\u529B\u3092\u884C\u3046
-main.opt.h=\  -h  --help  -?           \u3053\u306E\u30E1\u30C3\u30BB\u30FC\u30B8\u3092\u8868\u793A\u3059\u308B
-main.opt.version=\  -version                 \u30D0\u30FC\u30B8\u30E7\u30F3\u60C5\u5831\u3092\u8868\u793A\u3059\u308B
+main.opt.h=\  -h  --help  -?           \u3053\u306E\u30E1\u30C3\u30BB\u30FC\u30B8\u3092\u51FA\u529B\u3059\u308B
+main.opt.version=\  -version                 \u30D0\u30FC\u30B8\u30E7\u30F3\u60C5\u5831\u3092\u51FA\u529B\u3059\u308B
 main.opt.jni=\  -jni                     JNI\u5F62\u5F0F\u306E\u30D8\u30C3\u30C0\u30FC\u30FB\u30D5\u30A1\u30A4\u30EB\u3092\u751F\u6210\u3059\u308B(\u30C7\u30D5\u30A9\u30EB\u30C8)
 main.opt.force=\  -force                   \u5E38\u306B\u51FA\u529B\u30D5\u30A1\u30A4\u30EB\u3092\u66F8\u304D\u8FBC\u3080
 main.opt.classpath=\  -classpath <path>        \u30AF\u30E9\u30B9\u3092\u30ED\u30FC\u30C9\u3059\u308B\u30D1\u30B9
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./langtools/src/share/classes/com/sun/tools/javap/resources/javap_ja.properties	Wed May 07 19:27:09 2014 -0700
@@ -0,0 +1,63 @@
+
+err.prefix=\u30A8\u30E9\u30FC: 
+
+err.bad.constant.pool={0}\u306E\u5B9A\u6570\u30D7\u30FC\u30EB\u306E\u8AAD\u53D6\u308A\u4E2D\u306B\u30A8\u30E9\u30FC\u304C\u767A\u751F\u3057\u307E\u3057\u305F: {1}
+err.class.not.found=\u30AF\u30E9\u30B9\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093: {0}
+err.crash=\u91CD\u5927\u306A\u5185\u90E8\u30A8\u30E9\u30FC\u304C\u767A\u751F\u3057\u307E\u3057\u305F: {0}\n\u6B21\u306E\u60C5\u5831\u3092\u542B\u3080\u30D0\u30B0\u30FB\u30EC\u30DD\u30FC\u30C8\u3092\u30D5\u30A1\u30A4\u30EB\u3057\u3066\u304F\u3060\u3055\u3044:\n{1}
+err.end.of.file={0}\u306E\u8AAD\u53D6\u308A\u4E2D\u306B\u4E88\u671F\u3057\u306A\u3044\u30D5\u30A1\u30A4\u30EB\u306E\u7D42\u308F\u308A\u304C\u691C\u51FA\u3055\u308C\u307E\u3057\u305F
+err.file.not.found=\u30D5\u30A1\u30A4\u30EB\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093: {0}
+err.h.not.supported=-h\u306F\u4F7F\u7528\u53EF\u80FD\u3067\u306A\u304F\u306A\u308A\u307E\u3057\u305F - 'javah'\u30D7\u30ED\u30B0\u30E9\u30E0\u3092\u4F7F\u7528\u3057\u3066\u304F\u3060\u3055\u3044
+err.incompatible.options=\u30AA\u30D7\u30B7\u30E7\u30F3\u306E\u7D44\u5408\u305B\u304C\u4E0D\u6B63\u3067\u3059: {0}
+err.internal.error=\u5185\u90E8\u30A8\u30E9\u30FC: {0} {1} {2}
+err.invalid.arg.for.option=\u30AA\u30D7\u30B7\u30E7\u30F3\u306E\u5F15\u6570\u304C\u7121\u52B9\u3067\u3059: {0}
+err.ioerror={0}\u306E\u8AAD\u53D6\u308A\u4E2D\u306BIO\u30A8\u30E9\u30FC\u304C\u767A\u751F\u3057\u307E\u3057\u305F: {1}
+err.missing.arg={0}\u306B\u5024\u304C\u6307\u5B9A\u3055\u308C\u3066\u3044\u307E\u305B\u3093
+err.no.classes.specified=\u30AF\u30E9\u30B9\u304C\u6307\u5B9A\u3055\u308C\u3066\u3044\u307E\u305B\u3093
+err.not.standard.file.manager=\u6A19\u6E96\u30D5\u30A1\u30A4\u30EB\u30FB\u30DE\u30CD\u30FC\u30B8\u30E3\u3092\u4F7F\u7528\u3057\u3066\u3044\u308B\u5834\u5408\u306F\u30AF\u30E9\u30B9\u30FB\u30D5\u30A1\u30A4\u30EB\u306E\u307F\u6307\u5B9A\u3067\u304D\u307E\u3059
+err.unknown.option=\u4E0D\u660E\u306A\u30AA\u30D7\u30B7\u30E7\u30F3: {0}
+err.verify.not.supported=-verify\u306F\u30B5\u30DD\u30FC\u30C8\u3055\u308C\u3066\u3044\u307E\u305B\u3093
+err.no.SourceFile.attribute=SourceFile\u5C5E\u6027\u304C\u3042\u308A\u307E\u305B\u3093
+err.source.file.not.found=\u30BD\u30FC\u30B9\u30FB\u30D5\u30A1\u30A4\u30EB\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093
+err.bad.innerclasses.attribute={0}\u306EInnerClasses\u5C5E\u6027\u304C\u4E0D\u6B63\u3067\u3059
+warn.Xold.not.supported=-Xold\u306F\u4F7F\u7528\u3067\u304D\u306A\u304F\u306A\u308A\u307E\u3057\u305F
+
+main.usage.summary=\u4F7F\u7528\u65B9\u6CD5: {0} <options> <classes>\n\u4F7F\u7528\u53EF\u80FD\u306A\u30AA\u30D7\u30B7\u30E7\u30F3\u306E\u30EA\u30B9\u30C8\u306B\u3064\u3044\u3066\u306F\u3001-help\u3092\u4F7F\u7528\u3057\u307E\u3059
+
+warn.prefix=\u8B66\u544A:
+warn.unexpected.class=\u30D0\u30A4\u30CA\u30EA\u30FB\u30D5\u30A1\u30A4\u30EB{0}\u306B{1}\u304C\u542B\u307E\u308C\u3066\u3044\u307E\u3059
+
+note.prefix=\u6CE8:
+
+main.usage.summary=\u4F7F\u7528\u65B9\u6CD5: {0} <options> <classes>\n\u4F7F\u7528\u53EF\u80FD\u306A\u30AA\u30D7\u30B7\u30E7\u30F3\u306E\u30EA\u30B9\u30C8\u306B\u3064\u3044\u3066\u306F\u3001-help\u3092\u4F7F\u7528\u3057\u307E\u3059
+
+main.usage=\u4F7F\u7528\u65B9\u6CD5: {0} <options> <classes>\n\u4F7F\u7528\u53EF\u80FD\u306A\u30AA\u30D7\u30B7\u30E7\u30F3\u306B\u306F\u6B21\u306E\u3082\u306E\u304C\u3042\u308A\u307E\u3059:
+
+
+main.opt.help=\  -help  --help  -?        \u3053\u306E\u4F7F\u7528\u65B9\u6CD5\u306E\u30E1\u30C3\u30BB\u30FC\u30B8\u3092\u51FA\u529B\u3059\u308B
+
+main.opt.version=\  -version                 \u30D0\u30FC\u30B8\u30E7\u30F3\u60C5\u5831
+
+main.opt.v=\  -v  -verbose             \u8FFD\u52A0\u60C5\u5831\u3092\u51FA\u529B\u3059\u308B
+
+main.opt.l=\  -l                       \u884C\u756A\u53F7\u3068\u30ED\u30FC\u30AB\u30EB\u5909\u6570\u8868\u3092\u51FA\u529B\u3059\u308B
+
+main.opt.public=\  -public                  public\u30AF\u30E9\u30B9\u304A\u3088\u3073\u30E1\u30F3\u30D0\u30FC\u306E\u307F\u3092\u8868\u793A\u3059\u308B
+
+main.opt.protected=\  -protected               protected/public\u30AF\u30E9\u30B9\u304A\u3088\u3073\u30E1\u30F3\u30D0\u30FC\u306E\u307F\u3092\u8868\u793A\u3059\u308B
+
+main.opt.package=\  -package                 package/protected/public\u30AF\u30E9\u30B9\u304A\u3088\u3073\n                           \u30E1\u30F3\u30D0\u30FC\u306E\u307F\u3092\u8868\u793A\u3059\u308B(\u30C7\u30D5\u30A9\u30EB\u30C8)
+
+main.opt.p=\  -p  -private             \u3059\u3079\u3066\u306E\u30AF\u30E9\u30B9\u3068\u30E1\u30F3\u30D0\u30FC\u3092\u8868\u793A\u3059\u308B
+
+main.opt.c=\  -c                       \u30B3\u30FC\u30C9\u3092\u9006\u30A2\u30BB\u30F3\u30D6\u30EB\u3059\u308B
+
+main.opt.s=\  -s                       \u5185\u90E8\u30BF\u30A4\u30D7\u7F72\u540D\u3092\u51FA\u529B\u3059\u308B
+
+main.opt.classpath=\  -classpath <path>        \u30E6\u30FC\u30B6\u30FC\u30FB\u30AF\u30E9\u30B9\u30FB\u30D5\u30A1\u30A4\u30EB\u3092\u691C\u7D22\u3059\u308B\u5834\u6240\u3092\u6307\u5B9A\u3059\u308B
+
+main.opt.bootclasspath=\  -bootclasspath <path>    \u30D6\u30FC\u30C8\u30B9\u30C8\u30E9\u30C3\u30D7\u30FB\u30AF\u30E9\u30B9\u30FB\u30D5\u30A1\u30A4\u30EB\u306E\u5834\u6240\u3092\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3059\u308B
+
+main.opt.constants=\  -constants               \u9759\u7684final\u5B9A\u6570\u3092\u8868\u793A\u3059\u308B
+
+
+main.opt.sysinfo=\  -sysinfo                 \u51E6\u7406\u3057\u3066\u3044\u308B\u30AF\u30E9\u30B9\u306E\u30B7\u30B9\u30C6\u30E0\u60C5\u5831(\u30D1\u30B9\u3001\u30B5\u30A4\u30BA\u3001\u65E5\u4ED8\u3001MD5\u30CF\u30C3\u30B7\u30E5)\n                           \u3092\u8868\u793A\u3059\u308B
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./langtools/src/share/classes/com/sun/tools/javap/resources/javap_zh_CN.properties	Wed May 07 19:27:09 2014 -0700
@@ -0,0 +1,63 @@
+
+err.prefix=\u9519\u8BEF: 
+
+err.bad.constant.pool=\u8BFB\u53D6{0}\u7684\u5E38\u91CF\u6C60\u65F6\u51FA\u9519: {1}
+err.class.not.found=\u627E\u4E0D\u5230\u7C7B: {0}
+err.crash=\u51FA\u73B0\u4E25\u91CD\u7684\u5185\u90E8\u9519\u8BEF: {0}\n\u8BF7\u5EFA\u7ACB Bug \u62A5\u544A, \u5E76\u5305\u62EC\u4EE5\u4E0B\u4FE1\u606F:\n{1}
+err.end.of.file=\u8BFB\u53D6{0}\u65F6\u51FA\u73B0\u610F\u5916\u7684\u6587\u4EF6\u7ED3\u5C3E
+err.file.not.found=\u627E\u4E0D\u5230\u6587\u4EF6: {0}
+err.h.not.supported=-h \u4E0D\u518D\u53EF\u7528 - \u8BF7\u4F7F\u7528 'javah' \u7A0B\u5E8F
+err.incompatible.options=\u9009\u9879\u7EC4\u5408\u9519\u8BEF: {0}
+err.internal.error=\u5185\u90E8\u9519\u8BEF: {0} {1} {2}
+err.invalid.arg.for.option=\u9009\u9879\u7684\u53C2\u6570\u65E0\u6548: {0}
+err.ioerror=\u8BFB\u53D6{0}\u65F6\u51FA\u73B0 IO \u9519\u8BEF: {1}
+err.missing.arg=\u6CA1\u6709\u4E3A{0}\u6307\u5B9A\u503C
+err.no.classes.specified=\u672A\u6307\u5B9A\u7C7B
+err.not.standard.file.manager=\u4F7F\u7528\u6807\u51C6\u6587\u4EF6\u7BA1\u7406\u5668\u65F6\u53EA\u80FD\u6307\u5B9A\u7C7B\u6587\u4EF6
+err.unknown.option=\u672A\u77E5\u9009\u9879: {0}
+err.verify.not.supported=\u4E0D\u652F\u6301 -verify
+err.no.SourceFile.attribute=\u6CA1\u6709 SourceFile \u5C5E\u6027
+err.source.file.not.found=\u627E\u4E0D\u5230\u6E90\u6587\u4EF6
+err.bad.innerclasses.attribute={0}\u7684 InnerClasses \u5C5E\u6027\u9519\u8BEF
+warn.Xold.not.supported=-Xold \u4E0D\u518D\u53EF\u7528
+
+main.usage.summary=\u7528\u6CD5: {0} <options> <classes>\n\u4F7F\u7528 -help \u5217\u51FA\u53EF\u80FD\u7684\u9009\u9879
+
+warn.prefix=\u8B66\u544A:
+warn.unexpected.class=\u4E8C\u8FDB\u5236\u6587\u4EF6{0}\u5305\u542B{1}
+
+note.prefix=\u6CE8:
+
+main.usage.summary=\u7528\u6CD5: {0} <options> <classes>\n\u4F7F\u7528 -help \u5217\u51FA\u53EF\u80FD\u7684\u9009\u9879
+
+main.usage=\u7528\u6CD5: {0} <options> <classes>\n\u5176\u4E2D, \u53EF\u80FD\u7684\u9009\u9879\u5305\u62EC:
+
+
+main.opt.help=\  -help  --help  -?        \u8F93\u51FA\u6B64\u7528\u6CD5\u6D88\u606F
+
+main.opt.version=\  -version                 \u7248\u672C\u4FE1\u606F
+
+main.opt.v=\  -v  -verbose             \u8F93\u51FA\u9644\u52A0\u4FE1\u606F
+
+main.opt.l=\  -l                       \u8F93\u51FA\u884C\u53F7\u548C\u672C\u5730\u53D8\u91CF\u8868
+
+main.opt.public=\  -public                  \u4EC5\u663E\u793A\u516C\u5171\u7C7B\u548C\u6210\u5458
+
+main.opt.protected=\  -protected               \u663E\u793A\u53D7\u4FDD\u62A4\u7684/\u516C\u5171\u7C7B\u548C\u6210\u5458
+
+main.opt.package=\  -package                 \u663E\u793A\u7A0B\u5E8F\u5305/\u53D7\u4FDD\u62A4\u7684/\u516C\u5171\u7C7B\n                           \u548C\u6210\u5458 (\u9ED8\u8BA4)
+
+main.opt.p=\  -p  -private             \u663E\u793A\u6240\u6709\u7C7B\u548C\u6210\u5458
+
+main.opt.c=\  -c                       \u5BF9\u4EE3\u7801\u8FDB\u884C\u53CD\u6C47\u7F16
+
+main.opt.s=\  -s                       \u8F93\u51FA\u5185\u90E8\u7C7B\u578B\u7B7E\u540D
+
+main.opt.classpath=\  -classpath <path>        \u6307\u5B9A\u67E5\u627E\u7528\u6237\u7C7B\u6587\u4EF6\u7684\u4F4D\u7F6E
+
+main.opt.bootclasspath=\  -bootclasspath <path>    \u8986\u76D6\u5F15\u5BFC\u7C7B\u6587\u4EF6\u7684\u4F4D\u7F6E
+
+main.opt.constants=\  -constants               \u663E\u793A\u9759\u6001\u6700\u7EC8\u5E38\u91CF
+
+
+main.opt.sysinfo=\  -sysinfo                 \u663E\u793A\u6B63\u5728\u5904\u7406\u7684\u7C7B\u7684\n                           \u7CFB\u7EDF\u4FE1\u606F (\u8DEF\u5F84, \u5927\u5C0F, \u65E5\u671F, MD5 \u6563\u5217)
--- ./langtools/test/com/sun/javadoc/testHref/TestHref.java	Tue Mar 18 12:45:26 2014 -0700
+++ ./langtools/test/com/sun/javadoc/testHref/TestHref.java	Wed May 07 19:27:09 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -23,7 +23,7 @@
 
 /*
  * @test
- * @bug      4663254
+ * @bug      4663254 8016328
  * @summary  Verify that spaces do not appear in hrefs and anchors.
  * @author   jamieh
  * @library  ../lib/
@@ -46,11 +46,11 @@
     private static final String[][] TEST = {
         //External link.
         {BUG_ID + FS + "pkg" + FS + "C1.html",
-            "href=\"http://java.sun.com/j2se/1.4/docs/api/java/lang/Object.html?is-external=true#wait(long, int)\""
+            "href=\"http://java.sun.com/j2se/1.4/docs/api/java/lang/Object.html?is-external=true#wait(long,%20int)\""
         },
         //Member summary table link.
         {BUG_ID + FS + "pkg" + FS + "C1.html",
-            "href=\"../pkg/C1.html#method(int, int, java.util.ArrayList)\""
+            "href=\"../pkg/C1.html#method(int,%20int,%20java.util.ArrayList)\""
         },
         //Anchor test.
         {BUG_ID + FS + "pkg" + FS + "C1.html",
@@ -66,11 +66,11 @@
         },
         //{@link} test.
         {BUG_ID + FS + "pkg" + FS + "C2.html",
-            "Link: <a href=\"../pkg/C1.html#method(int, int, java.util.ArrayList)\">"
+            "Link: <a href=\"../pkg/C1.html#method(int,%20int,%20java.util.ArrayList)\">"
         },
         //@see test.
         {BUG_ID + FS + "pkg" + FS + "C2.html",
-            "See Also:</span></dt><dd><a href=\"../pkg/C1.html#method(int, int, java.util.ArrayList)\">"
+            "See Also:</span></dt><dd><a href=\"../pkg/C1.html#method(int,%20int,%20java.util.ArrayList)\">"
         },
 
         //Header does not link to the page itself.
--- ./langtools/test/com/sun/javadoc/testJavascript/TestJavascript.java	Tue Mar 18 12:45:26 2014 -0700
+++ ./langtools/test/com/sun/javadoc/testJavascript/TestJavascript.java	Wed May 07 19:27:09 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -23,7 +23,7 @@
 
 /*
  * @test
- * @bug      4665566 4855876 7025314 8012375 8015998
+ * @bug      4665566 4855876 7025314 8012375 8015998 8016328
  * @summary  Verify that the output has the right javascript.
  * @author   jamieh
  * @library  ../lib/
@@ -56,6 +56,12 @@
             "    if (targetPage.indexOf(\":\") != -1 || (targetPage != \"\" && !validURL(targetPage)))" + NL +
             "        targetPage = \"undefined\";" + NL +
             "    function validURL(url) {" + NL +
+            "        try {" + NL +
+            "            url = decodeURIComponent(url);" + NL +
+            "        }" + NL +
+            "        catch (error) {" + NL +
+            "            return false;" + NL +
+            "        }" + NL +
             "        var pos = url.indexOf(\".html\");" + NL +
             "        if (pos == -1 || pos != url.length - 5)" + NL +
             "            return false;" + NL +
@@ -67,7 +73,8 @@
             "            if ('a' <= ch && ch <= 'z' ||" + NL +
             "                    'A' <= ch && ch <= 'Z' ||" + NL +
             "                    ch == '$' ||" + NL +
-            "                    ch == '_') {" + NL +
+            "                    ch == '_' ||" + NL +
+            "                    ch.charCodeAt(0) > 127) {" + NL +
             "                allowNumber = true;" + NL +
             "                allowSep = true;" + NL +
             "            } else if ('0' <= ch && ch <= '9'" + NL +
--- ./langtools/test/com/sun/javadoc/testLinkTaglet/TestLinkTaglet.java	Tue Mar 18 12:45:26 2014 -0700
+++ ./langtools/test/com/sun/javadoc/testLinkTaglet/TestLinkTaglet.java	Wed May 07 19:27:09 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2004, 2011, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2004, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -23,7 +23,7 @@
 
 /*
  * @test
- * @bug      4732864 6280605 7064544
+ * @bug      4732864 6280605 7064544 8016328
  * @summary  Make sure that you can link from one member to another using
  *           non-qualified name, furthermore, ensure the right one is linked.
  * @author   jamieh
@@ -49,9 +49,9 @@
             "Qualified Link: <a href=\"../pkg/C.InnerC.html\" title=\"class in pkg\"><code>C.InnerC</code></a>.<br/>\n" +
             " Unqualified Link1: <a href=\"../pkg/C.InnerC.html\" title=\"class in pkg\"><code>C.InnerC</code></a>.<br/>\n" +
             " Unqualified Link2: <a href=\"../pkg/C.InnerC.html\" title=\"class in pkg\"><code>C.InnerC</code></a>.<br/>\n" +
-            " Qualified Link: <a href=\"../pkg/C.html#method(pkg.C.InnerC, pkg.C.InnerC2)\"><code>method(pkg.C.InnerC, pkg.C.InnerC2)</code></a>.<br/>\n" +
-            " Unqualified Link: <a href=\"../pkg/C.html#method(pkg.C.InnerC, pkg.C.InnerC2)\"><code>method(C.InnerC, C.InnerC2)</code></a>.<br/>\n" +
-            " Unqualified Link: <a href=\"../pkg/C.html#method(pkg.C.InnerC, pkg.C.InnerC2)\"><code>method(InnerC, InnerC2)</code></a>.<br/>"
+            " Qualified Link: <a href=\"../pkg/C.html#method(pkg.C.InnerC,%20pkg.C.InnerC2)\"><code>method(pkg.C.InnerC, pkg.C.InnerC2)</code></a>.<br/>\n" +
+            " Unqualified Link: <a href=\"../pkg/C.html#method(pkg.C.InnerC,%20pkg.C.InnerC2)\"><code>method(C.InnerC, C.InnerC2)</code></a>.<br/>\n" +
+            " Unqualified Link: <a href=\"../pkg/C.html#method(pkg.C.InnerC,%20pkg.C.InnerC2)\"><code>method(InnerC, InnerC2)</code></a>.<br/>"
         },
         {BUG_ID + FS + "pkg" + FS + "C.InnerC.html",
             "Link to member in outer class: <a href=\"../pkg/C.html#MEMBER\"><code>C.MEMBER</code></a> <br/>\n" +
--- ./langtools/test/com/sun/javadoc/testPrivateClasses/TestPrivateClasses.java	Tue Mar 18 12:45:26 2014 -0700
+++ ./langtools/test/com/sun/javadoc/testPrivateClasses/TestPrivateClasses.java	Wed May 07 19:27:09 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -23,7 +23,7 @@
 
 /*
  * @test
- * @bug      4780441 4874845 4978816
+ * @bug      4780441 4874845 4978816 8016328
  * @summary  Make sure that when the -private flag is not used, members
  *           inherited from package private class are documented in the child.
  *
@@ -175,7 +175,7 @@
         // Should document that a method overrides method from private class.
        {BUG_ID + "-2" + FS + "pkg" + FS + "PublicChild.html",
             "<dt><strong>Overrides:</strong></dt>" + NL +
-            "<dd><code><a href=\"../pkg/PrivateParent.html#methodOverridenFromParent(char[], int, T, V, java.util.List)\">" +
+            "<dd><code><a href=\"../pkg/PrivateParent.html#methodOverridenFromParent(char[],%20int,%20T,%20V,%20java.util.List)\">" +
             "methodOverridenFromParent</a></code>&nbsp;in class&nbsp;<code>" +
             "<a href=\"../pkg/PrivateParent.html\" title=\"class in pkg\">" +
             "PrivateParent</a></code></dd>"},
--- ./langtools/test/tools/javac/6567415/T6567415.java	Tue Mar 18 12:45:26 2014 -0700
+++ ./langtools/test/tools/javac/6567415/T6567415.java	Wed May 07 19:27:09 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2010, 2014, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -137,7 +137,7 @@
             }
         };
         t.start();
-        t.join(1000*10);
+        t.join(1000*60);
         System.out.println(t.getState());
         if (t.isAlive()) {
             throw new RuntimeException("Error: compilation is looping");
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ ./langtools/test/tools/javac/T8033294/RedundantWarningInIntersectionTest.java	Wed May 07 19:27:09 2014 -0700
@@ -0,0 +1,58 @@
+/*
+ * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @bug 8033294
+ * @summary javac, spurious warning for instanceof operator
+ * @compile -Werror -Xlint:unchecked RedundantWarningInIntersectionTest.java
+ */
+
+import java.math.BigDecimal;
+
+public class RedundantWarningInIntersectionTest {
+
+    class A<S extends A<S, T>, T> {
+
+        protected T p;
+
+        A(T p) {}
+
+        public S m(T parameter) {
+            @SuppressWarnings("unchecked")
+            S self = (S) new A<>(parameter);
+            return self;
+        }
+    }
+
+    class B<K extends Number & Comparable<? super K>> extends A<B<K>, K> {
+
+        B(K parameter) {
+            super(parameter);
+        }
+
+        public boolean m2() {
+            return (p instanceof BigDecimal);
+        }
+    }
+}
--- ./langtools/test/tools/javac/api/6406133/T6406133.java	Tue Mar 18 12:45:26 2014 -0700
+++ ./langtools/test/tools/javac/api/6406133/T6406133.java	Wed May 07 19:27:09 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,6 +27,8 @@
  * @summary Compiler API ignores locale settings
  * @author  Maurizio Cimadamore
  * @library ../lib
+ * @build ToolTester
+ * @run main T6406133
  */
 
 import javax.tools.*;
--- ./langtools/test/tools/javac/api/6410643/T6410643.java	Tue Mar 18 12:45:26 2014 -0700
+++ ./langtools/test/tools/javac/api/6410643/T6410643.java	Wed May 07 19:27:09 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2006, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,6 +27,8 @@
  * @summary JSR 199: The method JavaCompilerTool.run fails to handle null arguments
  * @author  Peter von der Ah\u00e9
  * @library ../lib
+ * @build ToolTester
+ * @run main T6410643
  */
 
 import javax.tools.JavaFileObject;
--- ./langtools/test/tools/javac/api/6411310/T6411310.java	Tue Mar 18 12:45:26 2014 -0700
+++ ./langtools/test/tools/javac/api/6411310/T6411310.java	Wed May 07 19:27:09 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2006, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,6 +27,7 @@
  * @summary JSR 199: FileObject should support user-friendly names via getName()
  * @author  Peter von der Ah\u00e9
  * @library ../lib
+ * @build ToolTester
  * @compile T6411310.java
  * @run main T6411310
  */
--- ./langtools/test/tools/javac/api/6411333/T6411333.java	Tue Mar 18 12:45:26 2014 -0700
+++ ./langtools/test/tools/javac/api/6411333/T6411333.java	Wed May 07 19:27:09 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2006, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,6 +27,7 @@
  * @summary Ensure 6400208, 6400225, and 6400267 are tested
  * @author  Peter von der Ah\u00e9
  * @library ../lib
+ * @build ToolTester
  * @compile T6411333.java
  * @run main T6411333
  */
--- ./langtools/test/tools/javac/api/6412656/T6412656.java	Tue Mar 18 12:45:26 2014 -0700
+++ ./langtools/test/tools/javac/api/6412656/T6412656.java	Wed May 07 19:27:09 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2006, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,6 +27,8 @@
  * @summary JSR 199: pass annotation processor instances to compiler
  * @author  Peter von der Ah\u00e9
  * @library ../lib
+ * @build ToolTester
+ * @run main T6412656
  */
 
 import java.util.Set;
--- ./langtools/test/tools/javac/api/6415780/T6415780.java	Tue Mar 18 12:45:26 2014 -0700
+++ ./langtools/test/tools/javac/api/6415780/T6415780.java	Wed May 07 19:27:09 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006, 2007, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2006, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -28,6 +28,8 @@
  * @author  igor.tseytin@...
  * @author  Peter von der Ah\u00e9
  * @library ../lib
+ * @build ToolTester
+ * @run main T6415780
  */
 
 import static javax.tools.StandardLocation.CLASS_PATH;
--- ./langtools/test/tools/javac/api/6418694/T6418694.java	Tue Mar 18 12:45:26 2014 -0700
+++ ./langtools/test/tools/javac/api/6418694/T6418694.java	Wed May 07 19:27:09 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2006, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,6 +27,7 @@
  * @summary JSR 199: JavaFileManager.hasLocation(Location)
  * @author  Peter von der Ah\u00e9
  * @library ../lib
+ * @build ToolTester
  * @compile T6418694.java
  * @run main T6418694
  */
--- ./langtools/test/tools/javac/api/6421111/T6421111.java	Tue Mar 18 12:45:26 2014 -0700
+++ ./langtools/test/tools/javac/api/6421111/T6421111.java	Wed May 07 19:27:09 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2006, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,6 +27,7 @@
  * @summary NullPointerException thrown when retrieving bounds for the type parameter
  * @author  Peter von der Ah\u00e9
  * @library ../lib
+ * @build ToolTester
  * @compile -Xlint:all T6421111.java
  * @run main T6421111
  */
--- ./langtools/test/tools/javac/api/6421756/T6421756.java	Tue Mar 18 12:45:26 2014 -0700
+++ ./langtools/test/tools/javac/api/6421756/T6421756.java	Wed May 07 19:27:09 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2006, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,6 +27,7 @@
  * @summary 6421756 JSR 199: In the method JavaCompilerTool.getTask 'options' can be supplied in the place of 'classes'
  * @author  Peter von der Ah\u00e9
  * @library ../lib
+ * @build ToolTester
  * @compile T6421756.java
  * @run main T6421756
  */
--- ./langtools/test/tools/javac/api/6422215/T6422215.java	Tue Mar 18 12:45:26 2014 -0700
+++ ./langtools/test/tools/javac/api/6422215/T6422215.java	Wed May 07 19:27:09 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2006, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,6 +27,8 @@
  * @summary JSR 199: What happens if a directory is missing
  * @author  Peter von der Ah\u00e9
  * @library ../lib
+ * @build ToolTester
+ * @run main T6422215
  */
 
 import java.io.File;
--- ./langtools/test/tools/javac/api/6422327/T6422327.java	Tue Mar 18 12:45:26 2014 -0700
+++ ./langtools/test/tools/javac/api/6422327/T6422327.java	Wed May 07 19:27:09 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2006, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,6 +27,8 @@
  * @summary JSR 199: JavaCompilerTool can compile and generate '.class' of non '.java' files
  * @author  Peter von der Ah\u00e9
  * @library ../lib
+ * @build ToolTester
+ * @run main T6422327
  */
 
 import java.io.File;
--- ./langtools/test/tools/javac/api/6423003/T6423003.java	Tue Mar 18 12:45:26 2014 -0700
+++ ./langtools/test/tools/javac/api/6423003/T6423003.java	Wed May 07 19:27:09 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2006, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,6 +27,7 @@
  * @summary JSR 199: confusing help message with compiler API
  * @author  Peter von der Ah\u00e9
  * @library ../lib
+ * @build ToolTester
  * @compile T6423003.java
  * @run main T6423003
  */
--- ./langtools/test/tools/javac/api/6431257/T6431257.java	Tue Mar 18 12:45:26 2014 -0700
+++ ./langtools/test/tools/javac/api/6431257/T6431257.java	Wed May 07 19:27:09 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006, 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2006, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,6 +27,7 @@
  * @summary JSR 199: Changes to JavaFileManager to support JSR 269 Filer API
  * @author  Peter von der Ah\u00e9
  * @library ../lib
+ * @build ToolTester
  * @compile T6431257.java package-info.java
  * @run main T6431257 foo.bar.baz foo/bar/baz
  */
--- ./langtools/test/tools/javac/api/6437349/T6437349.java	Tue Mar 18 12:45:26 2014 -0700
+++ ./langtools/test/tools/javac/api/6437349/T6437349.java	Wed May 07 19:27:09 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2006, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -26,6 +26,7 @@
  * @bug     6437349
  * @summary JSR 199: JavaFileObject.isNameCompatible() will give true with some incompatible kinds
  * @library ../lib
+ * @build ToolTester
  * @compile T6437349.java
  * @run main T6437349
  */
--- ./langtools/test/tools/javac/api/6437999/T6437999.java	Tue Mar 18 12:45:26 2014 -0700
+++ ./langtools/test/tools/javac/api/6437999/T6437999.java	Wed May 07 19:27:09 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2006, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,6 +27,7 @@
  * @summary Unit test for encoding argument to standard file manager
  * @author  Peter von der Ah\u00e9
  * @library ../lib
+ * @build ToolTester
  * @compile T6437999.java
  * @run main T6437999
  */
--- ./langtools/test/tools/javac/api/6440333/T6440333.java	Tue Mar 18 12:45:26 2014 -0700
+++ ./langtools/test/tools/javac/api/6440333/T6440333.java	Wed May 07 19:27:09 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006, 2009, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2006, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,6 +27,7 @@
  * @summary SimpleJavaFileObject.toString() generates URI with some extra message
  * @author  Peter von der Ah\u00e9
  * @library ../lib
+ * @build ToolTester
  * @compile T6440333.java
  * @run main T6440333
  */
--- ./langtools/test/tools/javac/api/6440528/T6440528.java	Tue Mar 18 12:45:26 2014 -0700
+++ ./langtools/test/tools/javac/api/6440528/T6440528.java	Wed May 07 19:27:09 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2006, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,6 +27,7 @@
  * @summary javac deposits package-info.class in bogus directory
  * @author  Peter von der Ah\u00e9
  * @library ../lib
+ * @build ToolTester
  * @compile T6440528.java
  * @run main T6440528
  */
--- ./langtools/test/tools/javac/api/6468404/T6468404.java	Tue Mar 18 12:45:26 2014 -0700
+++ ./langtools/test/tools/javac/api/6468404/T6468404.java	Wed May 07 19:27:09 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2006, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -28,6 +28,7 @@
  * @author  jesse.glick@...
  * @author  Peter von der Ah\u00e9
  * @library ../lib
+ * @build ToolTester
  * @compile T6468404.java
  * @run main T6468404
  */
--- ./langtools/test/tools/javac/api/6731573/T6731573.java	Tue Mar 18 12:45:26 2014 -0700
+++ ./langtools/test/tools/javac/api/6731573/T6731573.java	Wed May 07 19:27:09 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, 2010, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,6 +27,8 @@
  * @summary diagnostic output should optionally include source line
  * @author  Maurizio Cimadamore
  * @library ../lib
+ * @build ToolTester
+ * @run main T6731573
  */
 
 import java.io.*;
--- ./langtools/test/tools/javac/api/6733837/T6733837.java	Tue Mar 18 12:45:26 2014 -0700
+++ ./langtools/test/tools/javac/api/6733837/T6733837.java	Wed May 07 19:27:09 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,6 +27,8 @@
  * @summary Compiler API ignores locale settings
  * @author  Maurizio Cimadamore
  * @library ../lib
+ * @build ToolTester
+ * @run main T6733837
  */
 
 import java.io.StringWriter;
--- ./langtools/test/tools/javac/api/TestJavacTaskScanner.java	Tue Mar 18 12:45:26 2014 -0700
+++ ./langtools/test/tools/javac/api/TestJavacTaskScanner.java	Wed May 07 19:27:09 2014 -0700
@@ -27,6 +27,7 @@
  * @summary Additional functionality test of task and JSR 269
  * @author  Peter von der Ah\u00e9
  * @library ./lib
+ * @build ToolTester
  * @run main TestJavacTaskScanner TestJavacTaskScanner.java
  */
 
@@ -159,7 +160,7 @@
         StandardJavaFileManager fm = tool.getStandardFileManager(dl, null, encoding);
         try {
             fm.setLocation(SOURCE_PATH,  Arrays.asList(test_src));
-            fm.setLocation(CLASS_PATH,   Arrays.asList(test_classes, javac_classes));
+            fm.setLocation(CLASS_PATH,   join(test_class_path, Arrays.asList(javac_classes)));
             fm.setLocation(CLASS_OUTPUT, Arrays.asList(test_classes));
         } catch (IOException e) {
             throw new AssertionError(e);
--- ./langtools/test/tools/javac/api/guide/Test.java	Tue Mar 18 12:45:26 2014 -0700
+++ ./langtools/test/tools/javac/api/guide/Test.java	Wed May 07 19:27:09 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2006, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -27,6 +27,7 @@
  * @summary Various bugs fixed while writing Compiler API Guide
  * @author  Peter von der Ah\u0081
  * @library ../lib
+ * @build ToolTester
  * @compile Test.java
  * @run main Test
  */
--- ./langtools/test/tools/javac/api/lib/ToolTester.java	Tue Mar 18 12:45:26 2014 -0700
+++ ./langtools/test/tools/javac/api/lib/ToolTester.java	Wed May 07 19:27:09 2014 -0700
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2006, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2006, 2013, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -24,7 +24,7 @@
 import java.io.File;
 import java.io.IOException;
 import java.nio.charset.Charset;
-import java.util.Arrays;
+import java.util.*;
 import javax.tools.*;
 
 import static javax.tools.StandardLocation.CLASS_PATH;
@@ -34,6 +34,8 @@
 public class ToolTester {
     public final File test_src     = new File(System.getProperty("test.src", "."));
     public final File test_classes = new File(System.getProperty("test.classes", "."));
+    public final List<File> test_class_path = pathToFiles(System.getProperty("test.class.path"),
+                                     Arrays.asList(test_classes));
     public final JavaCompiler tool = ToolProvider.getSystemJavaCompiler();
     public final StandardJavaFileManager fm = getFileManager(tool, null, null);
     public JavaCompiler.CompilationTask task = null;
@@ -43,11 +45,36 @@
         StandardJavaFileManager fm = tool.getStandardFileManager(dl, null, encoding);
         try {
             fm.setLocation(SOURCE_PATH,  Arrays.asList(test_src));
-            fm.setLocation(CLASS_PATH,   Arrays.asList(test_classes));
+            fm.setLocation(CLASS_PATH,   test_class_path);
             fm.setLocation(CLASS_OUTPUT, Arrays.asList(test_classes));
         } catch (IOException e) {
             throw new AssertionError(e);
         }
         return fm;
     }
+
+    protected List<File> pathToFiles(String path, List<File> defaultPath) {
+        List<File> files = new ArrayList<>();
+        for (String f: path.split(File.pathSeparator)) {
+            if (f.isEmpty())
+                continue;
+            File file = new File(f);
+            if (file.exists())
+                files.add(file);
+        }
+        if (files.isEmpty())
+            files.addAll(defaultPath);
+        return files;
+    }
+
+    protected <T> List<T> join(List<T> a, List<T> b) {
+        if (a.isEmpty())
+            return b;
+        if (b.isEmpty())
+            return a;
+        List<T> result = new ArrayList<>();
+        result.addAll(a);
+        result.addAll(b);
+        return result;
+    }
 }
