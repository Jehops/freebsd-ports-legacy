--- io.c.orig	Sat Mar 14 23:22:07 1992
+++ io.c	Sun Jan 21 20:46:00 2007
@@ -28,6 +28,17 @@
  *     need to #define VMS since it is inherent in the compiler.
  */
 
+#include <signal.h>
+#include <string.h>
+#include <stdlib.h>
+
+static on_alrm();
+static chk_arrow (register char c);
+static tload();
+static char *egetstr (char *name, char **sptr);
+static setuptty();
+
+
 /* unless you are on VMS define one of these... */
 #define UNIX
 /* #define TURBO_C */
@@ -35,16 +46,16 @@
 /* then if you defined UNIX you must use one of these ways to do non-blocking
  * tty reads
  */
-#define USE_FIONREAD
-/* #define USE_NDELAY */
+/* #define USE_FIONREAD */
+#define USE_NDELAY
 /* #define USE_ATTSELECT */
 /* #define USE_BSDSELECT */
 
 /* and then if you defined UNIX you must also use one of these ways to control
  * the tty modes.
  */
-#define USE_TERMIO
-/* #define USE_SGTTY */
+/* #define USE_TERMIO */
+#define USE_SGTTY
 
 /* if you defined TURBO_C you might want this too if screen io looks garbled */
 /* #define USE_ANSISYS */
@@ -199,11 +210,19 @@
 	    seqa[0] = c;
 	    if (l > 1) {
 		extern unsigned alarm();
+		int ch_read, ch_expected, seqa_i;
 		/* cautiously read rest of arrow sequence */
 		got_alrm = 0;
 		(void) signal (SIGALRM, on_alrm);
 		alarm(2);
-		read (0, seqa+1, l-1);
+		/* to make the arrow keys work with FreeBSD ... */
+		ch_expected = l-1;
+		seqa_i = 1;
+		while ((ch_read = read (0, seqa+seqa_i, ch_expected)) > 0 &&
+			ch_read < ch_expected) {
+		    ch_expected -= ch_read;
+		    seqa_i += ch_read;
+		}
 		alarm(0);
 		if (got_alrm)
 		    return (c);
