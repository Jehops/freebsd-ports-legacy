diff --git bgpd/bgp_open.c bgpd/bgp_open.c
index d4f7cdf..cd23577 100644
--- bgpd/bgp_open.c
+++ bgpd/bgp_open.c
@@ -177,7 +177,7 @@ bgp_capability_mp (struct peer *peer, struct capability_header *hdr)
   peer->afc_recv[mpc.afi][mpc.safi] = 1;
   
   if (peer->afc[mpc.afi][mpc.safi])
-    peer->afc_nego[mpc.safi][mpc.safi] = 1;
+    peer->afc_nego[mpc.afi][mpc.safi] = 1;
   else 
     return -1;
 
diff --git bgpd/bgpd.c bgpd/bgpd.c
diff --git tests/bgp_capability_test.c tests/bgp_capability_test.c
index 5595ecf..4729f5c 100644
--- tests/bgp_capability_test.c
+++ tests/bgp_capability_test.c
@@ -27,6 +27,14 @@ static struct test_segment {
 #define SHOULD_PARSE	0
 #define SHOULD_ERR	-1
   int parses; /* whether it should parse or not */
+
+  /* AFI/SAFI validation */
+  int validate_afi;
+  afi_t afi;
+  safi_t safi;
+#define VALID_AFI 1
+#define INVALID_AFI 0
+  int afi_valid;
 } test_segments [] = 
 {
   /* 0 */
@@ -53,47 +61,63 @@ static struct test_segment {
     { CAPABILITY_CODE_ORF, 0x2, 0x0, 0x0 },
     4, SHOULD_ERR,
   },
-  /* 4 */
-  { "MP1",
+  { NULL, NULL, {0}, 0, 0},
+};
+
+static struct test_segment mp_segments[] =
+{
+  { "MP4",
     "MP IP/Uni",
     { 0x1, 0x4, 0x0, 0x1, 0x0, 0x1 },
-    6, SHOULD_PARSE,
+    6, SHOULD_PARSE, AFI_IP, SAFI_UNICAST,
+  },
+  { "MPv6",
+    "MP IPv6/Uni",
+    { 0x1, 0x4, 0x0, 0x2, 0x0, 0x1 },
+    6, SHOULD_PARSE, 
+    1, AFI_IP6, SAFI_UNICAST, VALID_AFI,
   },
   /* 5 */
   { "MP2",
     "MP IP/Multicast",
     { CAPABILITY_CODE_MP, 0x4, 0x0, 0x1, 0x0, 0x2 },
-    6, SHOULD_PARSE,
+    6, SHOULD_PARSE, 
+    1, AFI_IP, SAFI_MULTICAST, VALID_AFI,
   },
   /* 6 */
   { "MP3",
     "MP IP6/VPNv4",
     { CAPABILITY_CODE_MP, 0x4, 0x0, 0x2, 0x0, 0x80 },
     6, SHOULD_PARSE, /* parses, but invalid afi,safi */
+    1, AFI_IP6, BGP_SAFI_VPNV4, INVALID_AFI,
   },
   /* 7 */
   { "MP5",
     "MP IP6/MPLS-VPN",
     { CAPABILITY_CODE_MP, 0x4, 0x0, 0x2, 0x0, 0x4 },
-    6, SHOULD_PARSE,
+    6, SHOULD_PARSE, 
+    1, AFI_IP6, SAFI_MPLS_VPN, VALID_AFI,
   },
   /* 8 */
   { "MP6",
     "MP IP4/VPNv4",
     { CAPABILITY_CODE_MP, 0x4, 0x0, 0x1, 0x0, 0x80 },
-    6, SHOULD_PARSE,
+    6, SHOULD_PARSE, 
+    1, AFI_IP, BGP_SAFI_VPNV4, VALID_AFI,
   },  
   /* 9 */
   { "MP7",
     "MP IP4/VPNv6",
     { CAPABILITY_CODE_MP, 0x4, 0x0, 0x1, 0x0, 0x81 },
-    6, SHOULD_PARSE, /* parses, but invalid afi,safi tuple! - manually inspect */
+    6, SHOULD_PARSE, /* parses, but invalid afi,safi tuple */
+    1, AFI_IP, BGP_SAFI_VPNV6, INVALID_AFI,
   },
   /* 10 */
   { "MP8",
     "MP unknown AFI",
     { CAPABILITY_CODE_MP, 0x4, 0x0, 0xa, 0x0, 0x81 },
-    6, SHOULD_PARSE, /* parses, but unknown */
+    6, SHOULD_PARSE, 
+    1, 0xa, 0x81, INVALID_AFI, /* parses, but unknown */
   },
   /* 11 */
   { "MP-short",
@@ -106,7 +130,13 @@ static struct test_segment {
     "MP IP4/Unicast, length too long",
     { CAPABILITY_CODE_MP, 0x6, 0x0, 0x1, 0x0, 0x1 },
     6, SHOULD_ERR,
+    1, AFI_IP, SAFI_UNICAST, VALID_AFI,
   },
+  { NULL, NULL, {0}, 0, 0}
+};
+
+static struct test_segment misc_segments[] =
+{
   /* 13 */
   { "ORF",
     "ORF, simple, single entry, single tuple",
@@ -366,6 +396,7 @@ parse_test (struct peer *peer, struct test_segment *t, int type)
 {
   int ret;
   int capability = 0;
+  int oldfailed = failed;
   
   stream_reset (peer->ibuf);
   switch (type)
@@ -398,16 +429,34 @@ parse_test (struct peer *peer, struct test_segment *t, int type)
         exit(1);
     }
   
-  printf ("parsed?: %s\n", ret ? "no" : "yes");
-  
-  if (ret == t->parses)
-    printf ("OK\n");
-  else
+  if (!ret && t->validate_afi)
     {
-      printf ("failed\n");
-      failed++;
+      safi_t safi = t->safi;
+      
+      if (bgp_afi_safi_valid_indices (t->afi, &safi) != t->afi_valid)
+        failed++;
+      
+      printf ("MP: %u/%u (%u): recv %u, nego %u\n",
+              t->afi, t->safi, safi,
+              peer->afc_recv[t->afi][safi],
+              peer->afc_nego[t->afi][safi]);
+        
+      if (t->afi_valid == VALID_AFI)
+        {
+        
+          if (!peer->afc_recv[t->afi][safi])
+            failed++;
+          if (!peer->afc_nego[t->afi][safi])
+            failed++;
+        }
     }
   
+  printf ("parsed?: %s\n", ret ? "no" : "yes");
+  
+  if (ret != t->parses)
+    failed++;
+  
+  printf ("%s\n", (failed > oldfailed) ? "[31mfailed![0m" : "[32mOK[0m");
   printf ("\n");
 }
 
@@ -439,12 +488,26 @@ main (void)
   
   for (i = AFI_IP; i < AFI_MAX; i++)
     for (j = SAFI_UNICAST; j < SAFI_MAX; j++)
-      peer->afc_nego[i][j] = 1;
+      {
+        peer->afc[i][j] = 1;
+        peer->afc_adv[i][j] = 1;
+      }
   
-  i =0;
+  i = 0;
+  while (mp_segments[i].name)
+    parse_test (peer, &mp_segments[i++], OPEN);
+
+  /* These tests assume mp_segments tests set at least
+   * one of the afc_nego's
+   */
+  i = 0;
   while (test_segments[i].name)   
     parse_test (peer, &test_segments[i++], OPEN);
   
+  i = 0;
+  while (misc_segments[i].name)
+    parse_test (peer, &misc_segments[i++], OPEN);
+
   SET_FLAG (peer->cap, PEER_CAP_DYNAMIC_ADV);
   peer->status = Established;
   
