--- apps/app_dial.c.orig	2009-01-30 19:47:41.000000000 +0200
+++ apps/app_dial.c	2009-03-25 18:13:22.000000000 +0200
@@ -311,6 +311,8 @@
 	OPT_CALLEE_MONITOR | OPT_CALLER_MONITOR | OPT_CALLEE_PARK | OPT_CALLER_PARK) && \
 	!chan->audiohooks && !peer->audiohooks)
 
+static int detect_disconnect(struct ast_channel *chan, char code);
+
 /* We define a custom "local user" structure because we
    use it not only for keeping track of what is in use but
    also for keeping track of who we're dialing. */
@@ -743,9 +745,9 @@
 				}
 
 				if (ast_test_flag(peerflags, OPT_CALLER_HANGUP) && 
-						  (f->subclass == '*')) { /* hmm it it not guaranteed to be '*' anymore. */
+						  detect_disconnect(in, f->subclass)) { /* hmm it it not guaranteed to be '*' anymore. */
 					if (option_verbose > 2)
-						ast_verbose(VERBOSE_PREFIX_3 "User hit %c to disconnect call.\n", f->subclass);
+						ast_verbose(VERBOSE_PREFIX_3 "User requested call disconnect.\n");
 					*to=0;
 					ast_cdr_noanswer(in->cdr);
 					strcpy(status, "CANCEL");
@@ -786,6 +788,56 @@
 	return peer;
 }
 
+static char featurecode[FEATURE_MAX_LEN + 1] = "";
+
+static int detect_disconnect(struct ast_channel *chan, char code)
+{
+	struct feature_interpret_result result;
+	int x;
+	struct ast_flags features;
+	int res = FEATURE_RETURN_PASSDIGITS;
+	struct ast_call_feature *feature;
+	char *cptr;
+	int len;
+
+	len = strlen(featurecode);
+	if (len >= FEATURE_MAX_LEN) {
+		featurecode[0] = '\0';
+	}
+	cptr = &featurecode[strlen(featurecode)];
+	cptr[0] = code;
+	cptr[1] = '\0';
+
+	memset(&features, 0, sizeof(struct ast_flags));
+	ast_set_flag(&features, AST_FEATURE_DISCONNECT);
+
+	ast_features_lock();
+
+	res = ast_feature_detect(chan, &features, featurecode, &result);
+
+	if (res != FEATURE_RETURN_STOREDIGITS)
+		featurecode[0] = '\0';
+
+	if (result.builtin_feature && result.builtin_feature->feature_mask & AST_FEATURE_DISCONNECT) {
+		ast_features_unlock();
+		return 1;
+	}
+		
+	for (x = 0; x < result.num_dyn_features; ++x) {
+		feature = result.dynamic_features[x];
+		if (feature->feature_mask & AST_FEATURE_DISCONNECT) {
+			ast_features_unlock();
+			return 1;
+		}
+	}
+
+	ast_features_unlock();
+
+	return 0;
+}
+
+
+
 static void replace_macro_delimiter(char *s)
 {
 	for (; *s; s++)
--- include/asterisk/features.h.orig	2008-11-02 21:51:17.000000000 +0200
+++ include/asterisk/features.h	2009-03-25 18:14:38.000000000 +0200
@@ -35,6 +35,19 @@
 
 #define PARK_APP_NAME "Park"
 
+#define FEATURE_RETURN_HANGUP		-1
+#define FEATURE_RETURN_SUCCESSBREAK	 0
+#define FEATURE_RETURN_PASSDIGITS	 21
+#define FEATURE_RETURN_STOREDIGITS	 22
+#define FEATURE_RETURN_SUCCESS	 	 23
+#define FEATURE_RETURN_KEEPTRYING    24
+#define FEATURE_RETURN_PARKFAILED               25
+
+#define FEATURE_SENSE_CHAN	(1 << 0)
+#define FEATURE_SENSE_PEER	(1 << 1)
+
+typedef int (*feature_operation)(struct ast_channel *chan, struct ast_channel *peer, struct ast_bridge_config *config, char *code, int sense, void *data);
+
 /*! \brief main call feature structure */
 struct ast_call_feature {
 	int feature_mask;
@@ -42,7 +55,7 @@
 	char sname[FEATURE_SNAME_LEN];
 	char exten[FEATURE_MAX_LEN];
 	char default_exten[FEATURE_MAX_LEN];
-	int (*operation)(struct ast_channel *chan, struct ast_channel *peer, struct ast_bridge_config *config, char *code, int sense, void *data);
+	feature_operation operation;
 	unsigned int flags;
 	char app[FEATURE_APP_LEN];		
 	char app_args[FEATURE_APP_ARGS_LEN];
@@ -51,6 +64,12 @@
 };
 
 
+struct feature_interpret_result {
+    struct ast_call_feature *builtin_feature;
+    struct ast_call_feature *dynamic_features[20];
+    int num_dyn_features;
+};
+
 
 /*! \brief Park a call and read back parked location 
  *  \param chan the channel to actually be parked
@@ -98,4 +117,10 @@
     \param feature the ast_call_feature object which was registered before*/
 void ast_unregister_feature(struct ast_call_feature *feature);
 
+int ast_feature_detect(struct ast_channel *chan, const struct ast_flags *features, char *code, struct feature_interpret_result *result);
+
+void ast_features_lock(void);
+void ast_features_unlock(void);
+
+
 #endif /* _AST_FEATURES_H */
--- res/res_features.c.orig	2009-03-25 18:13:42.000000000 +0200
+++ res/res_features.c	2009-03-25 19:22:17.000000000 +0200
@@ -72,14 +72,6 @@
 #define AST_MAX_WATCHERS 256
 #define MAX_DIAL_FEATURE_OPTIONS 30
 
-#define FEATURE_RETURN_HANGUP                  -1
-#define FEATURE_RETURN_SUCCESSBREAK             0
-#define FEATURE_RETURN_PASSDIGITS               21
-#define FEATURE_RETURN_STOREDIGITS              22
-#define FEATURE_RETURN_SUCCESS                  23
-#define FEATURE_RETURN_KEEPTRYING               24
-#define FEATURE_RETURN_PARKFAILED               25
-
 enum {
 	AST_FEATURE_FLAG_NEEDSDTMF = (1 << 0),
 	AST_FEATURE_FLAG_ONPEER =    (1 << 1),
@@ -614,9 +606,6 @@
 	return masq_park_call(rchan, peer, timeout, extout, 1, orig_chan_name);
 }
 
-#define FEATURE_SENSE_CHAN	(1 << 0)
-#define FEATURE_SENSE_PEER	(1 << 1)
-
 /*! \brief
  * set caller and callee according to the direction
  */
@@ -1223,36 +1212,39 @@
 	return res;
 }
 
-static int ast_feature_interpret(struct ast_channel *chan, struct ast_channel *peer, struct ast_bridge_config *config, char *code, int sense)
+void ast_features_lock(void)
+{
+        ast_rwlock_wrlock(&features_lock);
+        AST_RWLIST_WRLOCK(&feature_list);
+}
+
+void ast_features_unlock(void)
+{
+        AST_RWLIST_UNLOCK(&feature_list);
+        ast_rwlock_unlock(&features_lock);
+}
+
+int ast_feature_detect(struct ast_channel *chan, const struct ast_flags *features, char *code, struct feature_interpret_result *result)
 {
 	int x;
-	struct ast_flags features;
 	struct ast_call_feature *feature;
-	const char *dynamic_features;
+        const char *dynamic_features = pbx_builtin_getvar_helper(chan, "DYNAMIC_FEATURES");
 	char *tmp, *tok;
 	int res = FEATURE_RETURN_PASSDIGITS;
 	int feature_detected = 0;
 
-	if (sense == FEATURE_SENSE_CHAN) {
-		ast_copy_flags(&features, &(config->features_caller), AST_FLAGS_ALL);	
-		dynamic_features = pbx_builtin_getvar_helper(chan, "DYNAMIC_FEATURES");
-	} else {
-		ast_copy_flags(&features, &(config->features_callee), AST_FLAGS_ALL);	
-		dynamic_features = pbx_builtin_getvar_helper(peer, "DYNAMIC_FEATURES");
-	}
-	if (option_debug > 2)
-		ast_log(LOG_DEBUG, "Feature interpret: chan=%s, peer=%s, code=%s, sense=%d, features=%d dynamic=%s\n", chan->name, peer->name, code, sense, features.flags, dynamic_features);
+        result->builtin_feature = NULL;
+        result->num_dyn_features = 0;
 
-	ast_rwlock_rdlock(&features_lock);
 	for (x = 0; x < FEATURES_COUNT; x++) {
-		if ((ast_test_flag(&features, builtin_features[x].feature_mask)) &&
+		if ((ast_test_flag(features, builtin_features[x].feature_mask)) &&
 		    !ast_strlen_zero(builtin_features[x].exten)) {
 			/* Feature is up for consideration */
 			if (!strcmp(builtin_features[x].exten, code)) {
 				if (option_debug > 2) {
 					ast_log(LOG_DEBUG, "Feature detected: fname=%s sname=%s exten=%s\n", builtin_features[x].fname, builtin_features[x].sname, builtin_features[x].exten);
 				}
-				res = builtin_features[x].operation(chan, peer, config, code, sense, NULL);
+                                result->builtin_feature = &builtin_features[x];
 				feature_detected = 1;
 				break;
 			} else if (!strncmp(builtin_features[x].exten, code, strlen(code))) {
@@ -1261,7 +1253,6 @@
 			}
 		}
 	}
-	ast_rwlock_unlock(&features_lock);
 
 	if (ast_strlen_zero(dynamic_features) || feature_detected)
 		return res;
@@ -1269,9 +1260,7 @@
 	tmp = ast_strdupa(dynamic_features);
 
 	while ((tok = strsep(&tmp, "#"))) {
-		AST_RWLIST_RDLOCK(&feature_list);	
 		if (!(feature = find_dynamic_feature(tok))) {
-			AST_RWLIST_UNLOCK(&feature_list);
 			continue;
 		}
 			
@@ -1279,9 +1268,8 @@
 		if (!strcmp(feature->exten, code)) {
 			if (option_verbose > 2)
 				ast_verbose(VERBOSE_PREFIX_3 " Feature Found: %s exten: %s\n",feature->sname, tok);
-			res = feature->operation(chan, peer, config, code, sense, feature);
-			if (res != FEATURE_RETURN_KEEPTRYING) {
-				AST_RWLIST_UNLOCK(&feature_list);
+                        result->dynamic_features[result->num_dyn_features++] = feature;
+                        if (result->num_dyn_features >= (sizeof(result->dynamic_features) / sizeof(result->dynamic_features[0]))) {
 				break;
 			}
 			res = FEATURE_RETURN_PASSDIGITS;
@@ -1294,6 +1282,39 @@
 	return res;
 }
 
+static int ast_feature_interpret(struct ast_channel *chan, struct ast_channel *peer, struct ast_bridge_config *config, char *code, int sense)
+{
+        struct feature_interpret_result result;
+        int x;
+        struct ast_flags features;
+        int res = FEATURE_RETURN_PASSDIGITS;
+        struct ast_call_feature *feature;
+
+        if (sense == FEATURE_SENSE_CHAN)
+                ast_copy_flags(&features, &(config->features_caller), AST_FLAGS_ALL);
+        else
+                ast_copy_flags(&features, &(config->features_callee), AST_FLAGS_ALL);
+        if (option_debug > 2)
+                ast_log(LOG_DEBUG, "Feature interpret: chan=%s, peer=%s, sense=%d, features=%d\n", chan->name, peer->name, sense, features.flags);
+
+        ast_features_lock();
+        res = ast_feature_detect(chan, &features, code, &result);
+
+        if (result.builtin_feature)
+                res = result.builtin_feature->operation(chan, peer, config, code, sense, NULL);
+
+        for (x = 0; x < result.num_dyn_features; ++x) {
+                feature = result.dynamic_features[x];
+                res = feature->operation(chan, peer, config, code, sense, feature);
+                if (res != FEATURE_RETURN_KEEPTRYING)
+                        break;
+                res = FEATURE_RETURN_PASSDIGITS;
+        }
+
+        ast_features_unlock();
+        return res;
+}
+
 static void set_config_flags(struct ast_channel *chan, struct ast_channel *peer, struct ast_bridge_config *config)
 {
 	int x;
