diff -urN AUTHORS AUTHORS
--- AUTHORS	1970-01-01 10:00:00.000000000 +1000
+++ AUTHORS	2014-01-08 02:31:52.000000000 +1100
@@ -0,0 +1,4 @@
+Please check the application About dialog or the official web site for a full list of authors.
+
+http://remmina.sourceforge.net/contact.shtml
+
diff -urN CMakeLists.txt CMakeLists.txt
--- CMakeLists.txt	2012-02-11 05:54:23.000000000 +1100
+++ CMakeLists.txt	2014-01-08 02:31:52.000000000 +1100
@@ -17,7 +17,7 @@
 # Foundation, Inc., 59 Temple Place, Suite 330, 
 # Boston, MA 02111-1307, USA.
 
-cmake_minimum_required(VERSION 2.6)
+cmake_minimum_required(VERSION 2.8)
 set(CMAKE_COLOR_MAKEFILE ON)
 project(Remmina C)
 
@@ -25,23 +25,17 @@
 include(CheckLibraryExists)
 include(FindPkgConfig)
 include(CheckCCompilerFlag)
+include(GNUInstallDirs)
 
 set(CMAKE_MODULE_PATH ${CMAKE_SOURCE_DIR}/cmake/)
 
 include(FindOptionalPackage)
+include(ConfigOptions)
 
 if(NOT CMAKE_BUILD_TYPE)
 	set(CMAKE_BUILD_TYPE "Release")
 endif()
 
-if(NOT DEFINED CMAKE_INSTALL_LIBDIR)
-	set(CMAKE_INSTALL_LIBDIR "lib")
-endif()
-
-if(NOT DEFINED CMAKE_INSTALL_BINDIR)
-	set(CMAKE_INSTALL_BINDIR "bin")
-endif()
-
 if(NOT BUILD_SHARED_LIBS)
     set(BUILD_SHARED_LIBS ON)
 endif()
@@ -77,34 +71,34 @@
 include_directories(.)
 include_directories(remmina/include)
 
-set(REMMINA_VERSION "0.9.99.1")
-set(REMMINA_DATADIR "${CMAKE_INSTALL_PREFIX}/share/remmina")
-set(REMMINA_LOCALEDIR "${CMAKE_INSTALL_PREFIX}/share/locale")
-set(REMMINA_PLUGINDIR "${CMAKE_INSTALL_PREFIX}/lib/remmina/plugins")
+set(REMMINA_VERSION "1.0.0")
+set(REMMINA_DATADIR "${CMAKE_INSTALL_FULL_DATADIR}")
+set(REMMINA_LOCALEDIR "${CMAKE_INSTALL_FULL_DATADIR}/locale")
+set(REMMINA_PLUGINDIR "${CMAKE_INSTALL_FULL_LIBDIR}/remmina/plugins")
 
+find_required_package(GTK)
 find_suggested_package(PTHREAD)
+find_suggested_package(GCRYPT)
+find_suggested_package(AVAHI)
+
 if(PTHREAD_FOUND)
 	add_definitions(-DHAVE_PTHREAD)
 endif()
 
-find_suggested_package(GCRYPT)
 if(GCRYPT_FOUND)
 	add_definitions(-DHAVE_LIBGCRYPT)
 endif()
 
-find_required_package(GTK)
+if(AVAHI_FOUND)
+	add_definitions(-DHAVE_LIBAVAHI_UI)
+	add_definitions(-DHAVE_LIBAVAHI_CLIENT)
+endif()
+
 if(GTK_FOUND)
 	add_subdirectory(remmina)
 	add_subdirectory(remmina-plugins)
 	add_subdirectory(remmina-plugins-gnome)
 endif()
 
-find_suggested_package(AVAHI)
-if(AVAHI_FOUND)
-	add_definitions(-DHAVE_LIBAVAHI_UI)
-	add_definitions(-DHAVE_LIBAVAHI_CLIENT)
-endif()
-
 configure_file(${CMAKE_CURRENT_SOURCE_DIR}/config.h.in ${CMAKE_CURRENT_SOURCE_DIR}/config.h)
 
-install(DIRECTORY include/remmina DESTINATION include/remmina FILES_MATCHING PATTERN "*.h")
diff -urN COPYING COPYING
--- COPYING	1970-01-01 10:00:00.000000000 +1000
+++ COPYING	2014-01-08 02:31:52.000000000 +1100
@@ -0,0 +1,340 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year  name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
diff -urN ChangeLog ChangeLog
--- ChangeLog	1970-01-01 10:00:00.000000000 +1000
+++ ChangeLog	2014-01-08 02:31:52.000000000 +1100
@@ -0,0 +1,234 @@
+***** 1.0.0 - 2012-02-10 *****
+Main program design and functionality:
+o Switch to the CMake build system
+o Refactoring of code style
+o Changing file name convention
+
+RDP protocol related:
+o Support for FreeRDP 1.0
+o Support for RemoteFX
+o Support for Network Level Authentication
+o Added certificate validation prompt
+
+***** 0.9.0 - 2010-12-12 *****
+Main program design and functionality:
+o Rewrite plugin system so that plugins can have more flexibilities
+o Integrate scrolled window and fullscreen view modes into one button
+o Remove quick connect menu and consolidate the feature with Connection->New
+  menu. Move other Edit menu items under Connection menu as well. See
+  http://bugs.debian.org/591755
+o Change 'Quit' menu item to 'Close'
+o Show version information in plugin window
+o Add link button to resolution field to bring up to resolution preference
+o Calculate auto-fit window size more correctly
+o Add subgroup feature, using '/' as subgroup delimiter
+o Remember group expansion status
+o Add shortcut key names to toolbar tooltips
+o Support shortcut key to be same as hostkey, which will be activated by just
+  press(down and up) the hostkey. By default, this is the Keyboard grabbing
+  shortcut.
+o Add pin button to floating toolbar
+o Add tray icon and various related preferences options. All featues in the
+  original GNOME/XFCE panel applet have been ported in it, plus all windows
+  can be minimized to tray (default is off)
+o Add Help/Homepage menu
+
+RDP protocol related:
+o Support TLS negotiation added in FreeRDP 0.8
+o Support audio input redirection added in FreeRDP 0.8
+o Add new preference option 'Use client keyboard mapping' to obey X key
+  mappings (wfaulk)
+
+VNC protocol related:
+o Change 'Proxy Destination' to 'Repeater' to make it clearer. Now the 'Server'
+  is the server and 'Repeater' is the repeater. :)
+
+NX protocol related:
+o Add SSH tunnel
+
+SSH protocol related:
+o Add ability to spawn new session from toolbar menu
+o Add Copy/Paste toolbar menu for SSH terminal
+o Add Font and Scrollback lines preference option
+o Add ability to show/hide hidden files in SFTP
+o Remember paned position in SFTP window
+o Add startup path option in SFTP
+
+***** 0.8.0 - 2010-07-10 *****
+Main program design and functionality:
+o Introduce a new plugin system. All protocols except SSH are moved to a new
+  source package 'remmina-plugins' so that they can have bug-fixes and releases
+  separately. A new Plugins menu is added accordingly
+o Add Hostkey feature and related Preference options. Hostkey feature provides
+  an easy and reliable way to access various remote desktop toolbar functions
+  through customizable shortcut key combinations
+o Add Attachable / Detachable Tabs feature. Tabs now can be merged or separated
+  between windows.
+o Add ability to show / hide the toolbar through Hostkey
+o Add Quick Search filter feature
+o Add 'Save Settings When Starting the Connection' preference option, default
+  is true. If set to false, profile will not be saved if only 'Connect' button
+  is clicked
+o Add 'Always show tab' option
+o Add a little cosmetic motion effect to the floating toolbar
+o Add Debug Window feature in Help menu
+o Add Online Wiki link in Help menu
+o Support IPv6 address notation
+ 
+RDP protocol related:
+o Bring in FreeRDP (http://freerdp.sourceforge.net) project as rdesktop
+  replacement. Most of the features described below are direct benefits
+  from the FreeRDP project
+o FreeRDP provides a new keyboard system which is based on XKB and Windows
+  keyboard layouts. In most cases it can detect the keyboard layout and work
+  out of the box. It's also possible to manually assign a keyboard layout.
+o Scaling remote screen is supported
+o More clipboard formats (HTML, bitmaps, etc) are supported
+o Better disk/printer sharing. Works with Windows 7 and Windows 2008
+o Countless of original rdesktop bug-fixes and clean up
+o Support importing Windows and tsclient .rdp file, either by drag-n-drop to
+  the main window, by Tools / Import menu, or by -e / -c command line argument
+o Support exporting Windows .rdp file
+
+VNC protocol related:
+o Support disabling TLS/VeNCrypt encryption when connecting to VNC servers
+  that supports it, like Vino
+o Support Refresh screen
+o Add UltraVNC repeater support
+o Add reverse SSH tunnel support for VNC incoming connection
+o Add disabling clipboard synchronization option
+o Better cursor and color handling
+
+NX protocol related:
+o New protocol NX is supported. Depends on libssh and nxproxy
+o Support resizing of remote session and scaling of console session
+o Support session management, including resume, attach, terminate
+o Support custom private key and various trivial options
+
+SSH protocol related:
+o SSH terminal and SFTP now works as internal plugins, and can be tabbed or
+  toggled fullscreen like any other protocols
+o Add startup program support in SSH terminal
+o Add folder uploading support in SFTP
+o Add new 'Tunnel via loopback' option
+o Support tunneling through same server at custom port using ':port' custom
+  server notation
+
+XDMCP protocol related:
+o Support running a startup program from SSH tunnel, without launching XDMCP
+  login window
+
+Telepathy support:
+o Implement as a special plugin so it will work with desktop sharing feature
+  in Empathy IM client
+
+***** 0.7.0 - 2009-12-12 *****
+o Add new XDMCP protocol (using Xephyr)
+o Implement XDMCP session over SSH (using xqproxy on SSH server side)
+o Add Public Key (Automatic) option to support ssh-agent, by Alex Chateau <ash@zednet.lv>
+o A lot of cosmetic changes
+o Use icon theme approach to install all icons
+o Fix RGB color issue with VMware VNC server
+o Enhanced groups and resolution editing
+o Remove "run in separated process" option. Manage all windows in single process
+o Upgrade glib dependancy to 2.20 and gtk to 2.16
+o Implement single instance application using libunique
+o Add Copy feature to create a new copy of existing connection profile
+o Add RDP Sound (off/local/remote) option
+o Add RDP local printer sharing option
+o Support Tab Interface and related options (Tab by Group / Tab by Protocol / Tab All / Tab None)
+o Simplify Groups setting by using combobox. Groups tab in preference dialog removed.
+o New application logo designed by Martin Lettner <m.lettner@gmail.com>
+o Support more VNC security types: TLS, VeNCrypt, MSLogon
+o Remember sort column id and order in main window
+
+***** 0.6.0 - 2009-07-07 *****
+o Add Avahi support using libavahi-ui
+o Option to start a connection in view-only mode
+o Enhanced command line arguments to support new grdc-applet features
+o Black Scrolled Viewport border (Nikolay Botev)
+o Better mouse cursor (both server and client side) (Nikolay Botev)
+o Keyboard mapping option for rdesktop (RDP)
+o VNC Chat feature
+o Fix VNC desktop resize bug (Nikolay Botev)
+o VNC Beep feature (Nikolay Botev)
+o A SFTP client (stand-alone or integrate with SSH tunnel)
+o SSH terminal feature integrated with SSH tunnel
+o Add RDP options: Share folder, Startup program/path and Advanced arguments
+o New Preference option Default View Mode
+o Better default window size to match server resolution
+o New VNC advanced option: Horizontal and Vertical scale
+o Saved password is now encrypted
+o Quick Connect protocol sub menus and connection protocol icons
+o Support VNC keyboard mapping
+o Fix VNC peer disconnect bug (Alex Chateau)
+o Greek translation added by Elias Sofronas <esofronas@gmail.com>
+
+***** 0.5.1 - 2009-05-01 *****
+o Fixed VNC crash in scrolled viewport mode
+o Fixed VNC cuttext "loopback"
+
+***** 0.5.0 - 2009-04-14 *****
+o Recent server names in quick connect
+o Invisible floating toolbar option
+o Floating toolbar transparency feature (by mouse scrolling)
+o Enhanced Keyboard grabbing feature
+o Support VNC incoming connections
+o Changed Keyboard grabbing icon
+o Center the client in the window when the remote desktop area is smaller than the window (Nikolay)
+o Change the background color of the viewport to black (Nikolay)
+o Use a blank dot as local cursor if remote cursor is shown in VNC
+o Change button order in all dialogs and apply alternative order
+o Popup menu for list/tree view in main window
+o Support UltraVNC extension "Disable Server Input"
+o Eliminate passphrase prompt if SSH private key has empty passphrase
+o Reuse existing SSH session in case of VNC authentication failure
+o Change desktop file's Name and Comments
+
+***** 0.4.0 - 2009-02-24 *****
+o SSH Tunneling support and SSH Tunnel local port option
+o VNC Color Depth support
+o VNC Scaled Mode toggle and Scale Quality option
+o VNC Poor quality level changed to the lowest to reduce a little bandwidth (marmuta)
+o RDP new option to attach to console
+o Auto-fit window button in scrolled window mode (resize to fit remote resolution)
+o Viewport fullscreen mode nows works with GTK 2.14
+o Keyboard grabbing enabled in scrolled window mode
+o Tree View / List View option
+o Double-click Action option
+o New Applet Option: Show Quick Connect on top of the Menu
+o New Applet Option: Hide Total Count in Group Expander
+
+***** 0.3.1 - 2009-01-26 *****
+o Fixed: Pressed keys won't release when focus lost in VNC
+o Remember main window and connection window state (size/maximized)
+o Shortcut key changed for Quit(^q) and Quick Connect(^u)
+
+***** 0.3.0 - 2009-01-16 *****
+o Double-click to open the connection
+o Customizable RDP resolution list
+o Ability to change VNC quality while connected
+o Support View-Only VNC
+o New View menu to show/hide toolbar or statusbar
+o Small toolbar button option
+o A label in floating toolbar indicating the current connection
+o New Grouping feature
+o Ability to save the connection settings as default values
+o Polish translation added by: Jakub Tomczak <tomczak.jakub@gmail.com>
+o New option to remember the last view mode of each connection
+o New option to open the connections in separated processes
+o A new Preferences dialog for the new options
+o A new look of the remote desktop preference dialog
+
+***** 0.2.0 - 2009-01-05 *****
+o VNC support is added
+o A lot of code arrangement plus some bug fixes
+
+***** 0.1.1 - 2008-12-28 *****
+o Spainish translation added by: Julio Napurí Carlos <julionc@gmail.com>
+o Added a .desktop file
+o Gnome panel applet support completed
+
+***** 0.1.0 - 2008-12-25 *****
+o First public release!
+
diff -urN README README
--- README	2012-02-11 05:54:23.000000000 +1100
+++ README	2014-01-08 23:23:49.430202080 +1100
@@ -24,15 +24,23 @@
 Prerequisites
 -------------
 
-On Ubuntu 11.10 (Oneiric), install the following packages before compiling:
+On Ubuntu 12.04, install the following packages to compile Remmina:
 
-sudo add-apt-repository ppa:chihchun/freerdp # for freerdp v1
-sudo apt-get update
-sudo apt-get install cmake intltool \
-  libgtk-3-dev libssh-dev libavahi-ui-gtk3-dev libvte-2.90-dev libxkbfile-dev \ 
-  libtelepathy-glib-dev libgnome-keyring-dev \
-  libappindicator3-dev libgcrypt11-dev libgnutls-dev \
-  libfreerdp-dev libjpeg-dev
+cmake (>= 2.6)
+libgtk-3-dev
+libgcrypt11-dev
+libssh-dev (>= 0.4)
+libvte-2.90-dev
+libxkbfile-dev
+libfreerdp-dev (>= 1.0)
+libtelepathy-glib-dev
+libjpeg-dev
+libgnutls-dev
+libgnome-keyring-dev
+libavahi-ui-gtk3-dev (>= 0.6.0)
+libvncserver-dev
+libappindicator3-dev
+intltool
 
 Compilation
 -----------
diff -urN cmake/ConfigOptions.cmake cmake/ConfigOptions.cmake
--- cmake/ConfigOptions.cmake	1970-01-01 10:00:00.000000000 +1000
+++ cmake/ConfigOptions.cmake	2014-01-08 02:31:52.000000000 +1100
@@ -0,0 +1,21 @@
+# Remmina - The GTK+ Remote Desktop Client
+#
+# Copyright (C) 2012 Jean-Louis Dupond
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, 
+# Boston, MA 02111-1307, USA.
+
+
+option(WITH_TRANSLATIONS "Generate translations." ON)
diff -urN cmake/FindAVAHI.cmake cmake/FindAVAHI.cmake
--- cmake/FindAVAHI.cmake	2012-02-11 05:54:23.000000000 +1100
+++ cmake/FindAVAHI.cmake	2014-01-08 02:31:52.000000000 +1100
@@ -17,29 +17,42 @@
 # Foundation, Inc., 59 Temple Place, Suite 330, 
 # Boston, MA 02111-1307, USA.
 
-if(GTK3_FOUND)
-	set(_AVAHI_LIB_NAME avahi-ui-gtk3)
-	set(_AVAHI_PKG_NAME avahi-ui-gtk3>=0.6.30 avahi-client>=0.6.30)
-else()
-	set(_AVAHI_LIB_NAME avahi-ui)
-	set(_AVAHI_PKG_NAME avahi-ui>=0.6.30 avahi-client>=0.6.30)
-endif()
+include(FindPkgConfig)
 
-find_package(PkgConfig)
-pkg_check_modules(PC_AVAHI ${_AVAHI_PKG_NAME})
+if(PKG_CONFIG_FOUND)
+	pkg_check_modules(PC_AVAHI_CLIENT avahi-client)
+	if(GTK3_FOUND)
+		set(_AVAHI_UI_LIB_NAME avahi-ui-gtk3)
+		set(_AVAHI_UI_PKG_NAME avahi-ui-gtk3>=0.6.30 avahi-client>=0.6.30)
+	else()
+		set(_AVAHI_UI_LIB_NAME avahi-ui)
+		set(_AVAHI_UI_PKG_NAME avahi-ui>=0.6.30 avahi-client>=0.6.30)
+	endif()
+	pkg_check_modules(PC_AVAHI_UI ${_AVAHI_UI_PKG_NAME})
+endif()
 
-find_path(AVAHI_INCLUDE_DIR avahi-ui/avahi-ui.h
-	HINTS ${PC_AVAHI_INCLUDEDIR} ${PC_AVAHI_INCLUDE_DIRS})
 
-find_library(AVAHI_LIBRARY NAMES ${_AVAHI_LIB_NAME}
-	HINTS ${PC_AVAHI_LIBDIR} ${PC_AVAHI_LIBRARY_DIRS})
+find_library(AVAHI_COMMON_LIBRARY NAMES avahi-common PATHS ${PC_AVAHI_CLIENT_LIBRARY_DIRS})
+if(AVAHI_COMMON_LIBRARY)
+	set(AVAHI_COMMON_FOUND TRUE)
+endif()
 
-include(FindPackageHandleStandardArgs)
+find_library(AVAHI_CLIENT_LIBRARY NAMES avahi-client PATHS ${PC_AVAHI_CLIENT_LIBRARY_DIRS})
+if(AVAHI_CLIENT_LIBRARY)
+	set(AVAHI_CLIENT_FOUND TRUE)
+endif()
 
-find_package_handle_standard_args(AVAHI DEFAULT_MSG AVAHI_LIBRARY AVAHI_INCLUDE_DIR)
+find_path(AVAHI_UI_INCLUDE_DIR avahi-ui/avahi-ui.h PATHS ${PC_AVAHI_UI_INCLUDE_DIRS})
+find_library(AVAHI_UI_LIBRARY NAMES ${_AVAHI_UI_LIB_NAME} PATHS ${PC_AVAHI_UI_LIBRARY_DIRS})
+if(AVAHI_UI_INCLUDE_DIR AND AVAHI_UI_LIBRARY)
+	set(AVAHI_UI_FOUND TRUE)
+endif()
 
-set(AVAHI_LIBRARIES ${AVAHI_LIBRARY})
-set(AVAHI_INCLUDE_DIRS ${AVAHI_INCLUDE_DIR})
+FIND_PACKAGE_HANDLE_STANDARD_ARGS(AVAHI DEFAULT_MSG AVAHI_COMMON_FOUND AVAHI_CLIENT_FOUND AVAHI_UI_FOUND)
 
-mark_as_advanced(AVAHI_INCLUDE_DIR AVAHI_LIBRARY)
+if (AVAHI_FOUND)
+	set(AVAHI_INCLUDE_DIRS ${AVAHI_UI_INCLUDE_DIR})
+	set(AVAHI_LIBRARIES ${AVAHI_COMMON_LIBRARY} ${AVAHI_CLIENT_LIBRARY} ${AVAHI_UI_LIBRARY})
+endif()
 
+mark_as_advanced(AVAHI_INCLUDE_DIRS AVAHI_LIBRARIES)
diff -urN cmake/FindFREERDP.cmake cmake/FindFREERDP.cmake
--- cmake/FindFREERDP.cmake	2012-02-11 05:54:23.000000000 +1100
+++ cmake/FindFREERDP.cmake	2014-01-08 02:31:52.000000000 +1100
@@ -14,7 +14,7 @@
 #
 # You should have received a copy of the GNU General Public License
 # along with this program; if not, write to the Free Software
-# Foundation, Inc., 59 Temple Place, Suite 330, 
+# Foundation, Inc., 59 Temple Place, Suite 330,
 # Boston, MA 02111-1307, USA.
 
 find_package(PkgConfig)
@@ -30,7 +30,7 @@
 find_library(FREERDP_GDI_LIBRARY NAMES freerdp-gdi
 	HINTS ${PC_FREERDP_LIBDIR} ${PC_FREERDP_LIBRARY_DIRS})
 
-find_library(FREERDP_KBD_LIBRARY NAMES freerdp-kbd
+find_library(FREERDP_LOCALE_LIBRARY NAMES freerdp-locale
 	HINTS ${PC_FREERDP_LIBDIR} ${PC_FREERDP_LIBRARY_DIRS})
 
 find_library(FREERDP_RAIL_LIBRARY NAMES freerdp-rail
@@ -39,14 +39,14 @@
 find_library(FREERDP_CODEC_LIBRARY NAMES freerdp-codec
 	HINTS ${PC_FREERDP_LIBDIR} ${PC_FREERDP_LIBRARY_DIRS})
 
-find_library(FREERDP_CHANNELS_LIBRARY NAMES freerdp-channels
+find_library(FREERDP_CLIENT_LIBRARY NAMES freerdp-client
 	HINTS ${PC_FREERDP_LIBDIR} ${PC_FREERDP_LIBRARY_DIRS})
 
 include(FindPackageHandleStandardArgs)
 
 find_package_handle_standard_args(FREERDP DEFAULT_MSG FREERDP_LIBRARY FREERDP_INCLUDE_DIR)
 
-set(FREERDP_LIBRARIES ${FREERDP_LIBRARY} ${FREERDP_GDI_LIBRARY} ${FREERDP_KBD_LIBRARY} ${FREERDP_RAIL_LIBRARY} ${FREERDP_CODEC_LIBRARY} ${FREERDP_CHANNELS_LIBRARY})
+set(FREERDP_LIBRARIES ${FREERDP_LIBRARY} ${FREERDP_GDI_LIBRARY} ${FREERDP_LOCALE_LIBRARY} ${FREERDP_RAIL_LIBRARY} ${FREERDP_CODEC_LIBRARY} ${FREERDP_CLIENT_LIBRARY})
 set(FREERDP_INCLUDE_DIRS ${FREERDP_INCLUDE_DIR})
 
 mark_as_advanced(FREERDP_INCLUDE_DIR FREERDP_LIBRARY)
diff -urN cmake/FindGLIB2.cmake cmake/FindGLIB2.cmake
--- cmake/FindGLIB2.cmake	1970-01-01 10:00:00.000000000 +1000
+++ cmake/FindGLIB2.cmake	2014-01-08 02:31:52.000000000 +1100
@@ -0,0 +1,120 @@
+# Remmina - The GTK+ Remote Desktop Client
+#
+# Copyright (C) 2012 Andrey Gankov
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, 
+# Boston, MA 02111-1307, USA.
+
+set(_GLIB_found_all true)
+
+# Glib
+
+pkg_check_modules(PC_GLIB2 glib-2.0>=2.28)
+
+if(NOT PC_GLIB2_FOUND)
+	set(_GLIB_found_all false)
+endif()
+
+find_path(GLIB2_INCLUDE_DIR_PART1 NAMES glib.h
+	HINTS ${PC_GLIB2_INCLUDEDIR} ${PC_GLIB2_INCLUDE_DIRS}
+	PATH_SUFFIXES glib-2.0)
+
+find_path(GLIB2_INCLUDE_DIR_PART2 NAMES glibconfig.h
+	HINTS ${PC_GLIB2_INCLUDEDIR} ${PC_GLIB2_INCLUDE_DIRS}
+	PATH_SUFFIXES glib-2.0/include)
+
+set(GLIB2_INCLUDE_DIR ${GLIB2_INCLUDE_DIR_PART1} ${GLIB2_INCLUDE_DIR_PART2})
+
+find_library(GLIB2_LIBRARY NAMES glib-2.0)
+
+# GIO
+
+pkg_check_modules(PC_GIO gio-2.0)
+
+if(NOT PC_GIO_FOUND)
+	set(_GLIB_found_all false)
+endif()
+
+find_path(GIO_INCLUDE_DIR gio/gio.h
+	HINTS ${PC_GIO_INCLUDEDIR} ${PC_GIO_INCLUDE_DIRS}
+	PATH_SUFFIXES gio-2.0)
+
+find_library(GIO_LIBRARY NAMES gio-2.0
+	HINTS ${PC_GIO_LIBDIR} ${PC_GIO_LIBRARY_DIRS})
+
+# gobject
+
+pkg_check_modules(PC_GOBJECT gobject-2.0)
+
+if(NOT PC_GOBJECT_FOUND)
+	set(_GLIB_found_all false)
+endif()
+
+find_path(GOBJECT_INCLUDE_DIR gobject/gobject.h
+	HINTS ${PC_GOBJECT_INCLUDEDIR} ${PC_GOBJECT_INCLUDE_DIRS}
+	PATH_SUFFIXES gobject-2.0)
+
+find_library(GOBJECT_LIBRARY NAMES gobject-2.0
+	HINTS ${PC_GOBJECT_LIBDIR} ${PC_GOBJECT_LIBRARY_DIRS})
+
+# gmodule
+
+pkg_check_modules(PC_GMODULE gmodule-2.0)
+
+if(NOT PC_GMODULE_FOUND)
+	set(_GLIB_found_all false)
+endif()
+
+find_path(GMODULE_INCLUDE_DIR gmodule.h
+	HINTS ${PC_GMODULE_INCLUDEDIR} ${PC_GMODULE_INCLUDE_DIRS}
+	PATH_SUFFIXES gmodule-2.0)
+
+find_library(GMODULE_LIBRARY NAMES gmodule-2.0
+	HINTS ${PC_GMODULE_LIBDIR} ${PC_GMODULE_LIBRARY_DIRS})
+
+# gthread
+
+pkg_check_modules(PC_GTHREAD gthread-2.0)
+
+if(NOT PC_GTHREAD_FOUND)
+	set(_GLIB_found_all false)
+endif()
+
+find_path(GTHREAD_INCLUDE_DIR glib/gthread.h
+	HINTS ${PC_GTHREAD_INCLUDEDIR} ${PC_GTHREAD_INCLUDE_DIRS}
+	PATH_SUFFIXES gthread-2.0)
+
+find_library(GTHREAD_LIBRARY NAMES gthread-2.0
+	HINTS ${PC_GTHREAD_LIBDIR} ${PC_GTHREAD_LIBRARY_DIRS})
+
+# Finalize
+
+if(_GLIB_found_all)
+	include(FindPackageHandleStandardArgs)
+
+	find_package_handle_standard_args(GLIB2 DEFAULT_MSG GLIB2_LIBRARY GLIB2_INCLUDE_DIR)
+
+	set(GLIB2_LIBRARIES ${GLIB2_LIBRARY} ${GIO_LIBRARY} ${GOBJECT_LIBRARY} ${GMODULE_LIBRARY} ${GTHREAD_LIBRARY})
+	set(GLIB2_INCLUDE_DIRS ${GLIB2_INCLUDE_DIR} ${GIO_INCLUDE_DIR} ${GOBJECT_INCLUDE_DIR} ${GMODULE_INCLUDE_DIR} ${GTHREAD_INCLUDE_DIR})
+
+	mark_as_advanced(GLIB2_INCLUDE_DIR GLIB2_LIBRARY)
+
+	set(GLIB_FOUND true)
+else()
+	unset(GLIB2_LIBRARY)
+	unset(GLIB2_INCLUDE_DIR)
+
+	set(GLIB_FOUND false)
+endif()
diff -urN cmake/FindGTK2.cmake cmake/FindGTK2.cmake
--- cmake/FindGTK2.cmake	2012-02-11 05:54:23.000000000 +1100
+++ cmake/FindGTK2.cmake	2014-01-08 02:31:52.000000000 +1100
@@ -63,24 +63,11 @@
 
 # Glib
 
-pkg_check_modules(PC_GLIB2 glib-2.0)
-
-if(NOT PC_GLIB2_FOUND)
+find_required_package(GLIB2)
+if(NOT GLIB2_FOUND)
 	set(_GTK2_found_all false)
 endif()
 
-find_path(GLIB2_INCLUDE_DIR_PART1 NAMES glib.h
-	HINTS ${PC_GLIB2_INCLUDEDIR} ${PC_GLIB2_INCLUDE_DIRS}
-	PATH_SUFFIXES glib-2.0)
-
-find_path(GLIB2_INCLUDE_DIR_PART2 NAMES glibconfig.h
-	HINTS ${PC_GLIB2_INCLUDEDIR} ${PC_GLIB2_INCLUDE_DIRS}
-	PATH_SUFFIXES glib-2.0/include)
-
-set(GLIB2_INCLUDE_DIR ${GLIB2_INCLUDE_DIR_PART1} ${GLIB2_INCLUDE_DIR_PART2})
-
-find_library(GLIB2_LIBRARY NAMES glib-2.0)
-
 # Pango
 
 pkg_check_modules(PC_PANGO pango)
@@ -129,8 +116,8 @@
 
 	find_package_handle_standard_args(GTK2 DEFAULT_MSG GTK2_LIBRARY GTK2_INCLUDE_DIR)
 
-	set(GTK2_LIBRARIES ${GTK2_LIBRARY} ${GDK2_LIBRARY} ${GLIB2_LIBRARY} ${PANGO_LIBRARY} ${CAIRO_LIBRARY} ${GDKPIXBUF_LIBRARY} ${ATK_LIBRARY})
-	set(GTK2_INCLUDE_DIRS ${GTK2_INCLUDE_DIR} ${GDK2_INCLUDE_DIR} ${GLIB2_INCLUDE_DIR} ${PANGO_INCLUDE_DIR} ${CAIRO_INCLUDE_DIR} ${GDKPIXBUF_INCLUDE_DIR} ${ATK_INCLUDE_DIR})
+	set(GTK2_LIBRARIES ${GTK2_LIBRARY} ${GDK2_LIBRARY} ${GLIB2_LIBRARIES} ${PANGO_LIBRARY} ${CAIRO_LIBRARY} ${GDKPIXBUF_LIBRARY} ${ATK_LIBRARY})
+	set(GTK2_INCLUDE_DIRS ${GTK2_INCLUDE_DIR} ${GDK2_INCLUDE_DIR} ${GLIB2_INCLUDE_DIRS} ${PANGO_INCLUDE_DIR} ${CAIRO_INCLUDE_DIR} ${GDKPIXBUF_INCLUDE_DIR} ${ATK_INCLUDE_DIR})
 
 	mark_as_advanced(GTK2_INCLUDE_DIR GTK2_LIBRARY)
 
diff -urN cmake/FindGTK3.cmake cmake/FindGTK3.cmake
--- cmake/FindGTK3.cmake	2012-02-11 05:54:23.000000000 +1100
+++ cmake/FindGTK3.cmake	2014-01-08 02:31:52.000000000 +1100
@@ -48,29 +48,16 @@
 	HINTS ${PC_GDKPIXBUF_INCLUDEDIR} ${PC_GDKPIXBUF_INCLUDE_DIRS}
 	PATH_SUFFIXES gdk-pixbuf-2.0)
 
-find_library(GDKPIXBUF_LIBRARY NAMES gdk-3
+find_library(GDKPIXBUF_LIBRARY NAMES gdk_pixbuf-2.0
 	HINTS ${PC_GDKPIXBUF_LIBDIR} ${PC_GDKPIXBUF_LIBRARY_DIRS})
 
 # Glib
 
-pkg_check_modules(PC_GLIB2 glib-2.0)
-
-if(NOT PC_GLIB2_FOUND)
+find_required_package(GLIB2)
+if(NOT GLIB2_FOUND)
 	set(_GTK3_found_all false)
 endif()
 
-find_path(GLIB2_INCLUDE_DIR_PART1 NAMES glib.h
-	HINTS ${PC_GLIB2_INCLUDEDIR} ${PC_GLIB2_INCLUDE_DIRS}
-	PATH_SUFFIXES glib-2.0)
-
-find_path(GLIB2_INCLUDE_DIR_PART2 NAMES glibconfig.h
-	HINTS ${PC_GLIB2_INCLUDEDIR} ${PC_GLIB2_INCLUDE_DIRS}
-	PATH_SUFFIXES glib-2.0/include)
-
-set(GLIB2_INCLUDE_DIR ${GLIB2_INCLUDE_DIR_PART1} ${GLIB2_INCLUDE_DIR_PART2})
-
-find_library(GLIB2_LIBRARY NAMES glib-2.0)
-
 # Pango
 
 pkg_check_modules(PC_PANGO pango)
@@ -119,14 +106,17 @@
 
 	find_package_handle_standard_args(GTK3 DEFAULT_MSG GTK3_LIBRARY GTK3_INCLUDE_DIR)
 
-	set(GTK3_LIBRARIES ${GTK3_LIBRARY} ${GDK3_LIBRARY} ${GLIB2_LIBRARY} ${PANGO_LIBRARY} ${CAIRO_LIBRARY} ${GDKPIXBUF_LIBRARY} ${ATK_LIBRARY})
-	set(GTK3_INCLUDE_DIRS ${GTK3_INCLUDE_DIR} ${GLIB2_INCLUDE_DIR} ${PANGO_INCLUDE_DIR} ${CAIRO_INCLUDE_DIR} ${GDKPIXBUF_INCLUDE_DIR} ${ATK_INCLUDE_DIR})
+	set(GTK3_LIBRARIES ${GTK3_LIBRARY} ${GDK3_LIBRARY} ${GLIB2_LIBRARIES} ${PANGO_LIBRARY} ${CAIRO_LIBRARY} ${GDKPIXBUF_LIBRARY} ${ATK_LIBRARY})
+	set(GTK3_INCLUDE_DIRS ${GTK3_INCLUDE_DIR} ${GLIB2_INCLUDE_DIRS} ${PANGO_INCLUDE_DIR} ${CAIRO_INCLUDE_DIR} ${GDKPIXBUF_INCLUDE_DIR} ${ATK_INCLUDE_DIR})
 
 	mark_as_advanced(GTK3_INCLUDE_DIR GTK3_LIBRARY)
 
 	set(GTK3_FOUND true)
 else()
 	unset(GTK3_LIBRARY)
+	unset(GTK3_INCLUDE_DIR)
+
+	unset(GDK3_LIBRARY)
 	unset(GDK3_INCLUDE_DIR)
 
 	set(GTK3_FOUND false)
diff -urN cmake/FindLIBVNCSERVER.cmake cmake/FindLIBVNCSERVER.cmake
--- cmake/FindLIBVNCSERVER.cmake	1970-01-01 10:00:00.000000000 +1000
+++ cmake/FindLIBVNCSERVER.cmake	2014-01-08 02:31:52.000000000 +1100
@@ -0,0 +1,37 @@
+# Remmina - The GTK+ Remote Desktop Client
+#
+# Copyright (C) 2012 Luca Falavigna
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, 
+# Boston, MA 02111-1307, USA.
+
+find_package(PkgConfig)
+pkg_check_modules(PC_LIBVNCSERVER libvncserver)
+set(LIBVNCSERVER_DEFINITIONS ${PC_LIBVNCSERVER_CFLAGS_OTHER})
+
+find_path(LIBVNCSERVER_INCLUDE_DIR NAMES rfb/rfb.h
+	HINTS ${PC_LIBVNCSERVER_INCLUDEDIR} ${PC_LIBVNCSERVER_INCLUDE_DIRS})
+
+find_library(LIBVNCSERVER_LIBRARY NAMES vncserver
+	HINTS ${PC_LIBVNCSERVER_LIBDIR} ${PC_LIBVNCSERVER_LIBRARY_DIRS})
+
+include(FindPackageHandleStandardArgs)
+
+find_package_handle_standard_args(LIBVNCSERVER DEFAULT_MSG LIBVNCSERVER_LIBRARY LIBVNCSERVER_INCLUDE_DIR)
+
+set(LIBVNCSERVER_LIBRARIES ${LIBVNCSERVER_LIBRARY})
+set(LIBVNCSERVER_INCLUDE_DIRS ${LIBVNCSERVER_INCLUDE_DIR})
+
+mark_as_advanced(LIBVNCSERVER_INCLUDE_DIR LIBVNCSERVER_LIBRARY)
diff -urN remmina/AUTHORS remmina/AUTHORS
--- remmina/AUTHORS	2012-02-11 05:54:23.000000000 +1100
+++ remmina/AUTHORS	1970-01-01 10:00:00.000000000 +1000
@@ -1,4 +0,0 @@
-Please check the application About dialog or the official web site for a full list of authors.
-
-http://remmina.sourceforge.net/contact.shtml
-
diff -urN remmina/CMakeLists.txt remmina/CMakeLists.txt
--- remmina/CMakeLists.txt	2012-02-11 05:54:23.000000000 +1100
+++ remmina/CMakeLists.txt	2014-01-08 02:31:52.000000000 +1100
@@ -86,6 +86,8 @@
 	src/remmina_string_list.h
 	src/remmina_widget_pool.c
 	src/remmina_widget_pool.h
+	src/remmina_external_tools.c
+	src/remmina_external_tools.h
 	)
 
 add_executable(remmina ${REMMINA_SRCS})
@@ -93,6 +95,10 @@
 include_directories(${GTK_INCLUDE_DIRS})
 target_link_libraries(remmina ${GTK_LIBRARIES})
 
+find_package(X11)
+include_directories(${X11_INCLUDE_DIR})
+target_link_libraries(remmina ${X11_LIBRARIES})
+
 find_suggested_package(LIBSSH)
 if(LIBSSH_FOUND)
 	add_definitions(-DHAVE_LIBSSH)
@@ -100,6 +106,11 @@
 	target_link_libraries(remmina ${LIBSSH_LIBRARIES})
 endif()
 
+if(PTHREAD_FOUND)
+	include_directories(${PTHREAD_INCLUDE_DIRS})
+	target_link_libraries(remmina ${PTHREAD_LIBRARIES})
+endif()
+
 if(GCRYPT_FOUND)
 	include_directories(${GCRYPT_INCLUDE_DIRS})
 	target_link_libraries(remmina ${GCRYPT_LIBRARIES})
@@ -132,9 +143,12 @@
 	endif()
 endif()
 
-add_subdirectory(po)
+if(WITH_TRANSLATIONS)
+	add_subdirectory(po)
+endif()
 add_subdirectory(icons)
 add_subdirectory(desktop)
+add_subdirectory(external_tools)
 
 install(TARGETS remmina DESTINATION ${CMAKE_INSTALL_BINDIR})
 
diff -urN remmina/COPYING remmina/COPYING
--- remmina/COPYING	2012-02-11 05:54:23.000000000 +1100
+++ remmina/COPYING	1970-01-01 10:00:00.000000000 +1000
@@ -1,340 +0,0 @@
-		    GNU GENERAL PUBLIC LICENSE
-		       Version 2, June 1991
-
- Copyright (C) 1989, 1991 Free Software Foundation, Inc.
-     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-			    Preamble
-
-  The licenses for most software are designed to take away your
-freedom to share and change it.  By contrast, the GNU General Public
-License is intended to guarantee your freedom to share and change free
-software--to make sure the software is free for all its users.  This
-General Public License applies to most of the Free Software
-Foundation's software and to any other program whose authors commit to
-using it.  (Some other Free Software Foundation software is covered by
-the GNU Library General Public License instead.)  You can apply it to
-your programs, too.
-
-  When we speak of free software, we are referring to freedom, not
-price.  Our General Public Licenses are designed to make sure that you
-have the freedom to distribute copies of free software (and charge for
-this service if you wish), that you receive source code or can get it
-if you want it, that you can change the software or use pieces of it
-in new free programs; and that you know you can do these things.
-
-  To protect your rights, we need to make restrictions that forbid
-anyone to deny you these rights or to ask you to surrender the rights.
-These restrictions translate to certain responsibilities for you if you
-distribute copies of the software, or if you modify it.
-
-  For example, if you distribute copies of such a program, whether
-gratis or for a fee, you must give the recipients all the rights that
-you have.  You must make sure that they, too, receive or can get the
-source code.  And you must show them these terms so they know their
-rights.
-
-  We protect your rights with two steps: (1) copyright the software, and
-(2) offer you this license which gives you legal permission to copy,
-distribute and/or modify the software.
-
-  Also, for each author's protection and ours, we want to make certain
-that everyone understands that there is no warranty for this free
-software.  If the software is modified by someone else and passed on, we
-want its recipients to know that what they have is not the original, so
-that any problems introduced by others will not reflect on the original
-authors' reputations.
-
-  Finally, any free program is threatened constantly by software
-patents.  We wish to avoid the danger that redistributors of a free
-program will individually obtain patent licenses, in effect making the
-program proprietary.  To prevent this, we have made it clear that any
-patent must be licensed for everyone's free use or not licensed at all.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.
-
-		    GNU GENERAL PUBLIC LICENSE
-   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
-
-  0. This License applies to any program or other work which contains
-a notice placed by the copyright holder saying it may be distributed
-under the terms of this General Public License.  The "Program", below,
-refers to any such program or work, and a "work based on the Program"
-means either the Program or any derivative work under copyright law:
-that is to say, a work containing the Program or a portion of it,
-either verbatim or with modifications and/or translated into another
-language.  (Hereinafter, translation is included without limitation in
-the term "modification".)  Each licensee is addressed as "you".
-
-Activities other than copying, distribution and modification are not
-covered by this License; they are outside its scope.  The act of
-running the Program is not restricted, and the output from the Program
-is covered only if its contents constitute a work based on the
-Program (independent of having been made by running the Program).
-Whether that is true depends on what the Program does.
-
-  1. You may copy and distribute verbatim copies of the Program's
-source code as you receive it, in any medium, provided that you
-conspicuously and appropriately publish on each copy an appropriate
-copyright notice and disclaimer of warranty; keep intact all the
-notices that refer to this License and to the absence of any warranty;
-and give any other recipients of the Program a copy of this License
-along with the Program.
-
-You may charge a fee for the physical act of transferring a copy, and
-you may at your option offer warranty protection in exchange for a fee.
-
-  2. You may modify your copy or copies of the Program or any portion
-of it, thus forming a work based on the Program, and copy and
-distribute such modifications or work under the terms of Section 1
-above, provided that you also meet all of these conditions:
-
-    a) You must cause the modified files to carry prominent notices
-    stating that you changed the files and the date of any change.
-
-    b) You must cause any work that you distribute or publish, that in
-    whole or in part contains or is derived from the Program or any
-    part thereof, to be licensed as a whole at no charge to all third
-    parties under the terms of this License.
-
-    c) If the modified program normally reads commands interactively
-    when run, you must cause it, when started running for such
-    interactive use in the most ordinary way, to print or display an
-    announcement including an appropriate copyright notice and a
-    notice that there is no warranty (or else, saying that you provide
-    a warranty) and that users may redistribute the program under
-    these conditions, and telling the user how to view a copy of this
-    License.  (Exception: if the Program itself is interactive but
-    does not normally print such an announcement, your work based on
-    the Program is not required to print an announcement.)
-
-These requirements apply to the modified work as a whole.  If
-identifiable sections of that work are not derived from the Program,
-and can be reasonably considered independent and separate works in
-themselves, then this License, and its terms, do not apply to those
-sections when you distribute them as separate works.  But when you
-distribute the same sections as part of a whole which is a work based
-on the Program, the distribution of the whole must be on the terms of
-this License, whose permissions for other licensees extend to the
-entire whole, and thus to each and every part regardless of who wrote it.
-
-Thus, it is not the intent of this section to claim rights or contest
-your rights to work written entirely by you; rather, the intent is to
-exercise the right to control the distribution of derivative or
-collective works based on the Program.
-
-In addition, mere aggregation of another work not based on the Program
-with the Program (or with a work based on the Program) on a volume of
-a storage or distribution medium does not bring the other work under
-the scope of this License.
-
-  3. You may copy and distribute the Program (or a work based on it,
-under Section 2) in object code or executable form under the terms of
-Sections 1 and 2 above provided that you also do one of the following:
-
-    a) Accompany it with the complete corresponding machine-readable
-    source code, which must be distributed under the terms of Sections
-    1 and 2 above on a medium customarily used for software interchange; or,
-
-    b) Accompany it with a written offer, valid for at least three
-    years, to give any third party, for a charge no more than your
-    cost of physically performing source distribution, a complete
-    machine-readable copy of the corresponding source code, to be
-    distributed under the terms of Sections 1 and 2 above on a medium
-    customarily used for software interchange; or,
-
-    c) Accompany it with the information you received as to the offer
-    to distribute corresponding source code.  (This alternative is
-    allowed only for noncommercial distribution and only if you
-    received the program in object code or executable form with such
-    an offer, in accord with Subsection b above.)
-
-The source code for a work means the preferred form of the work for
-making modifications to it.  For an executable work, complete source
-code means all the source code for all modules it contains, plus any
-associated interface definition files, plus the scripts used to
-control compilation and installation of the executable.  However, as a
-special exception, the source code distributed need not include
-anything that is normally distributed (in either source or binary
-form) with the major components (compiler, kernel, and so on) of the
-operating system on which the executable runs, unless that component
-itself accompanies the executable.
-
-If distribution of executable or object code is made by offering
-access to copy from a designated place, then offering equivalent
-access to copy the source code from the same place counts as
-distribution of the source code, even though third parties are not
-compelled to copy the source along with the object code.
-
-  4. You may not copy, modify, sublicense, or distribute the Program
-except as expressly provided under this License.  Any attempt
-otherwise to copy, modify, sublicense or distribute the Program is
-void, and will automatically terminate your rights under this License.
-However, parties who have received copies, or rights, from you under
-this License will not have their licenses terminated so long as such
-parties remain in full compliance.
-
-  5. You are not required to accept this License, since you have not
-signed it.  However, nothing else grants you permission to modify or
-distribute the Program or its derivative works.  These actions are
-prohibited by law if you do not accept this License.  Therefore, by
-modifying or distributing the Program (or any work based on the
-Program), you indicate your acceptance of this License to do so, and
-all its terms and conditions for copying, distributing or modifying
-the Program or works based on it.
-
-  6. Each time you redistribute the Program (or any work based on the
-Program), the recipient automatically receives a license from the
-original licensor to copy, distribute or modify the Program subject to
-these terms and conditions.  You may not impose any further
-restrictions on the recipients' exercise of the rights granted herein.
-You are not responsible for enforcing compliance by third parties to
-this License.
-
-  7. If, as a consequence of a court judgment or allegation of patent
-infringement or for any other reason (not limited to patent issues),
-conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot
-distribute so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you
-may not distribute the Program at all.  For example, if a patent
-license would not permit royalty-free redistribution of the Program by
-all those who receive copies directly or indirectly through you, then
-the only way you could satisfy both it and this License would be to
-refrain entirely from distribution of the Program.
-
-If any portion of this section is held invalid or unenforceable under
-any particular circumstance, the balance of the section is intended to
-apply and the section as a whole is intended to apply in other
-circumstances.
-
-It is not the purpose of this section to induce you to infringe any
-patents or other property right claims or to contest validity of any
-such claims; this section has the sole purpose of protecting the
-integrity of the free software distribution system, which is
-implemented by public license practices.  Many people have made
-generous contributions to the wide range of software distributed
-through that system in reliance on consistent application of that
-system; it is up to the author/donor to decide if he or she is willing
-to distribute software through any other system and a licensee cannot
-impose that choice.
-
-This section is intended to make thoroughly clear what is believed to
-be a consequence of the rest of this License.
-
-  8. If the distribution and/or use of the Program is restricted in
-certain countries either by patents or by copyrighted interfaces, the
-original copyright holder who places the Program under this License
-may add an explicit geographical distribution limitation excluding
-those countries, so that distribution is permitted only in or among
-countries not thus excluded.  In such case, this License incorporates
-the limitation as if written in the body of this License.
-
-  9. The Free Software Foundation may publish revised and/or new versions
-of the General Public License from time to time.  Such new versions will
-be similar in spirit to the present version, but may differ in detail to
-address new problems or concerns.
-
-Each version is given a distinguishing version number.  If the Program
-specifies a version number of this License which applies to it and "any
-later version", you have the option of following the terms and conditions
-either of that version or of any later version published by the Free
-Software Foundation.  If the Program does not specify a version number of
-this License, you may choose any version ever published by the Free Software
-Foundation.
-
-  10. If you wish to incorporate parts of the Program into other free
-programs whose distribution conditions are different, write to the author
-to ask for permission.  For software which is copyrighted by the Free
-Software Foundation, write to the Free Software Foundation; we sometimes
-make exceptions for this.  Our decision will be guided by the two goals
-of preserving the free status of all derivatives of our free software and
-of promoting the sharing and reuse of software generally.
-
-			    NO WARRANTY
-
-  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
-FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
-OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
-PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
-OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
-TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
-PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
-REPAIR OR CORRECTION.
-
-  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
-WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
-REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
-INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
-OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
-TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
-YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
-PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGES.
-
-		     END OF TERMS AND CONDITIONS
-
-	    How to Apply These Terms to Your New Programs
-
-  If you develop a new program, and you want it to be of the greatest
-possible use to the public, the best way to achieve this is to make it
-free software which everyone can redistribute and change under these terms.
-
-  To do so, attach the following notices to the program.  It is safest
-to attach them to the start of each source file to most effectively
-convey the exclusion of warranty; and each file should have at least
-the "copyright" line and a pointer to where the full notice is found.
-
-    <one line to give the program's name and a brief idea of what it does.>
-    Copyright (C) <year>  <name of author>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-
-
-Also add information on how to contact you by electronic and paper mail.
-
-If the program is interactive, make it output a short notice like this
-when it starts in an interactive mode:
-
-    Gnomovision version 69, Copyright (C) year  name of author
-    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
-    This is free software, and you are welcome to redistribute it
-    under certain conditions; type `show c' for details.
-
-The hypothetical commands `show w' and `show c' should show the appropriate
-parts of the General Public License.  Of course, the commands you use may
-be called something other than `show w' and `show c'; they could even be
-mouse-clicks or menu items--whatever suits your program.
-
-You should also get your employer (if you work as a programmer) or your
-school, if any, to sign a "copyright disclaimer" for the program, if
-necessary.  Here is a sample; alter the names:
-
-  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
-  `Gnomovision' (which makes passes at compilers) written by James Hacker.
-
-  <signature of Ty Coon>, 1 April 1989
-  Ty Coon, President of Vice
-
-This General Public License does not permit incorporating your program into
-proprietary programs.  If your program is a subroutine library, you may
-consider it more useful to permit linking proprietary applications with the
-library.  If this is what you want to do, use the GNU Library General
-Public License instead of this License.
diff -urN remmina/ChangeLog remmina/ChangeLog
--- remmina/ChangeLog	2012-02-11 05:54:23.000000000 +1100
+++ remmina/ChangeLog	1970-01-01 10:00:00.000000000 +1000
@@ -1,234 +0,0 @@
-***** 1.0.0 - 2012-02-10 *****
-Main program design and functionality:
-o Switch to the CMake build system
-o Refactoring of code style
-o Changing file name convention
-
-RDP protocol related:
-o Support for FreeRDP 1.0
-o Support for RemoteFX
-o Support for Network Level Authentication
-o Added certificate validation prompt
-
-***** 0.9.0 - 2010-12-12 *****
-Main program design and functionality:
-o Rewrite plugin system so that plugins can have more flexibilities
-o Integrate scrolled window and fullscreen view modes into one button
-o Remove quick connect menu and consolidate the feature with Connection->New
-  menu. Move other Edit menu items under Connection menu as well. See
-  http://bugs.debian.org/591755
-o Change 'Quit' menu item to 'Close'
-o Show version information in plugin window
-o Add link button to resolution field to bring up to resolution preference
-o Calculate auto-fit window size more correctly
-o Add subgroup feature, using '/' as subgroup delimiter
-o Remember group expansion status
-o Add shortcut key names to toolbar tooltips
-o Support shortcut key to be same as hostkey, which will be activated by just
-  press(down and up) the hostkey. By default, this is the Keyboard grabbing
-  shortcut.
-o Add pin button to floating toolbar
-o Add tray icon and various related preferences options. All featues in the
-  original GNOME/XFCE panel applet have been ported in it, plus all windows
-  can be minimized to tray (default is off)
-o Add Help/Homepage menu
-
-RDP protocol related:
-o Support TLS negotiation added in FreeRDP 0.8
-o Support audio input redirection added in FreeRDP 0.8
-o Add new preference option 'Use client keyboard mapping' to obey X key
-  mappings (wfaulk)
-
-VNC protocol related:
-o Change 'Proxy Destination' to 'Repeater' to make it clearer. Now the 'Server'
-  is the server and 'Repeater' is the repeater. :)
-
-NX protocol related:
-o Add SSH tunnel
-
-SSH protocol related:
-o Add ability to spawn new session from toolbar menu
-o Add Copy/Paste toolbar menu for SSH terminal
-o Add Font and Scrollback lines preference option
-o Add ability to show/hide hidden files in SFTP
-o Remember paned position in SFTP window
-o Add startup path option in SFTP
-
-***** 0.8.0 - 2010-07-10 *****
-Main program design and functionality:
-o Introduce a new plugin system. All protocols except SSH are moved to a new
-  source package 'remmina-plugins' so that they can have bug-fixes and releases
-  separately. A new Plugins menu is added accordingly
-o Add Hostkey feature and related Preference options. Hostkey feature provides
-  an easy and reliable way to access various remote desktop toolbar functions
-  through customizable shortcut key combinations
-o Add Attachable / Detachable Tabs feature. Tabs now can be merged or separated
-  between windows.
-o Add ability to show / hide the toolbar through Hostkey
-o Add Quick Search filter feature
-o Add 'Save Settings When Starting the Connection' preference option, default
-  is true. If set to false, profile will not be saved if only 'Connect' button
-  is clicked
-o Add 'Always show tab' option
-o Add a little cosmetic motion effect to the floating toolbar
-o Add Debug Window feature in Help menu
-o Add Online Wiki link in Help menu
-o Support IPv6 address notation
- 
-RDP protocol related:
-o Bring in FreeRDP (http://freerdp.sourceforge.net) project as rdesktop
-  replacement. Most of the features described below are direct benefits
-  from the FreeRDP project
-o FreeRDP provides a new keyboard system which is based on XKB and Windows
-  keyboard layouts. In most cases it can detect the keyboard layout and work
-  out of the box. It's also possible to manually assign a keyboard layout.
-o Scaling remote screen is supported
-o More clipboard formats (HTML, bitmaps, etc) are supported
-o Better disk/printer sharing. Works with Windows 7 and Windows 2008
-o Countless of original rdesktop bug-fixes and clean up
-o Support importing Windows and tsclient .rdp file, either by drag-n-drop to
-  the main window, by Tools / Import menu, or by -e / -c command line argument
-o Support exporting Windows .rdp file
-
-VNC protocol related:
-o Support disabling TLS/VeNCrypt encryption when connecting to VNC servers
-  that supports it, like Vino
-o Support Refresh screen
-o Add UltraVNC repeater support
-o Add reverse SSH tunnel support for VNC incoming connection
-o Add disabling clipboard synchronization option
-o Better cursor and color handling
-
-NX protocol related:
-o New protocol NX is supported. Depends on libssh and nxproxy
-o Support resizing of remote session and scaling of console session
-o Support session management, including resume, attach, terminate
-o Support custom private key and various trivial options
-
-SSH protocol related:
-o SSH terminal and SFTP now works as internal plugins, and can be tabbed or
-  toggled fullscreen like any other protocols
-o Add startup program support in SSH terminal
-o Add folder uploading support in SFTP
-o Add new 'Tunnel via loopback' option
-o Support tunneling through same server at custom port using ':port' custom
-  server notation
-
-XDMCP protocol related:
-o Support running a startup program from SSH tunnel, without launching XDMCP
-  login window
-
-Telepathy support:
-o Implement as a special plugin so it will work with desktop sharing feature
-  in Empathy IM client
-
-***** 0.7.0 - 2009-12-12 *****
-o Add new XDMCP protocol (using Xephyr)
-o Implement XDMCP session over SSH (using xqproxy on SSH server side)
-o Add Public Key (Automatic) option to support ssh-agent, by Alex Chateau <ash@zednet.lv>
-o A lot of cosmetic changes
-o Use icon theme approach to install all icons
-o Fix RGB color issue with VMware VNC server
-o Enhanced groups and resolution editing
-o Remove "run in separated process" option. Manage all windows in single process
-o Upgrade glib dependancy to 2.20 and gtk to 2.16
-o Implement single instance application using libunique
-o Add Copy feature to create a new copy of existing connection profile
-o Add RDP Sound (off/local/remote) option
-o Add RDP local printer sharing option
-o Support Tab Interface and related options (Tab by Group / Tab by Protocol / Tab All / Tab None)
-o Simplify Groups setting by using combobox. Groups tab in preference dialog removed.
-o New application logo designed by Martin Lettner <m.lettner@gmail.com>
-o Support more VNC security types: TLS, VeNCrypt, MSLogon
-o Remember sort column id and order in main window
-
-***** 0.6.0 - 2009-07-07 *****
-o Add Avahi support using libavahi-ui
-o Option to start a connection in view-only mode
-o Enhanced command line arguments to support new grdc-applet features
-o Black Scrolled Viewport border (Nikolay Botev)
-o Better mouse cursor (both server and client side) (Nikolay Botev)
-o Keyboard mapping option for rdesktop (RDP)
-o VNC Chat feature
-o Fix VNC desktop resize bug (Nikolay Botev)
-o VNC Beep feature (Nikolay Botev)
-o A SFTP client (stand-alone or integrate with SSH tunnel)
-o SSH terminal feature integrated with SSH tunnel
-o Add RDP options: Share folder, Startup program/path and Advanced arguments
-o New Preference option Default View Mode
-o Better default window size to match server resolution
-o New VNC advanced option: Horizontal and Vertical scale
-o Saved password is now encrypted
-o Quick Connect protocol sub menus and connection protocol icons
-o Support VNC keyboard mapping
-o Fix VNC peer disconnect bug (Alex Chateau)
-o Greek translation added by Elias Sofronas <esofronas@gmail.com>
-
-***** 0.5.1 - 2009-05-01 *****
-o Fixed VNC crash in scrolled viewport mode
-o Fixed VNC cuttext "loopback"
-
-***** 0.5.0 - 2009-04-14 *****
-o Recent server names in quick connect
-o Invisible floating toolbar option
-o Floating toolbar transparency feature (by mouse scrolling)
-o Enhanced Keyboard grabbing feature
-o Support VNC incoming connections
-o Changed Keyboard grabbing icon
-o Center the client in the window when the remote desktop area is smaller than the window (Nikolay)
-o Change the background color of the viewport to black (Nikolay)
-o Use a blank dot as local cursor if remote cursor is shown in VNC
-o Change button order in all dialogs and apply alternative order
-o Popup menu for list/tree view in main window
-o Support UltraVNC extension "Disable Server Input"
-o Eliminate passphrase prompt if SSH private key has empty passphrase
-o Reuse existing SSH session in case of VNC authentication failure
-o Change desktop file's Name and Comments
-
-***** 0.4.0 - 2009-02-24 *****
-o SSH Tunneling support and SSH Tunnel local port option
-o VNC Color Depth support
-o VNC Scaled Mode toggle and Scale Quality option
-o VNC Poor quality level changed to the lowest to reduce a little bandwidth (marmuta)
-o RDP new option to attach to console
-o Auto-fit window button in scrolled window mode (resize to fit remote resolution)
-o Viewport fullscreen mode nows works with GTK 2.14
-o Keyboard grabbing enabled in scrolled window mode
-o Tree View / List View option
-o Double-click Action option
-o New Applet Option: Show Quick Connect on top of the Menu
-o New Applet Option: Hide Total Count in Group Expander
-
-***** 0.3.1 - 2009-01-26 *****
-o Fixed: Pressed keys won't release when focus lost in VNC
-o Remember main window and connection window state (size/maximized)
-o Shortcut key changed for Quit(^q) and Quick Connect(^u)
-
-***** 0.3.0 - 2009-01-16 *****
-o Double-click to open the connection
-o Customizable RDP resolution list
-o Ability to change VNC quality while connected
-o Support View-Only VNC
-o New View menu to show/hide toolbar or statusbar
-o Small toolbar button option
-o A label in floating toolbar indicating the current connection
-o New Grouping feature
-o Ability to save the connection settings as default values
-o Polish translation added by: Jakub Tomczak <tomczak.jakub@gmail.com>
-o New option to remember the last view mode of each connection
-o New option to open the connections in separated processes
-o A new Preferences dialog for the new options
-o A new look of the remote desktop preference dialog
-
-***** 0.2.0 - 2009-01-05 *****
-o VNC support is added
-o A lot of code arrangement plus some bug fixes
-
-***** 0.1.1 - 2008-12-28 *****
-o Spainish translation added by: Julio Napurí Carlos <julionc@gmail.com>
-o Added a .desktop file
-o Gnome panel applet support completed
-
-***** 0.1.0 - 2008-12-25 *****
-o First public release!
-
diff -urN remmina/INSTALL remmina/INSTALL
--- remmina/INSTALL	2012-02-11 05:54:23.000000000 +1100
+++ remmina/INSTALL	1970-01-01 10:00:00.000000000 +1000
@@ -1,237 +0,0 @@
-Installation Instructions
-*************************
-
-Copyright (C) 1994, 1995, 1996, 1999, 2000, 2001, 2002, 2004, 2005,
-2006, 2007 Free Software Foundation, Inc.
-
-This file is free documentation; the Free Software Foundation gives
-unlimited permission to copy, distribute and modify it.
-
-Basic Installation
-==================
-
-Briefly, the shell commands `./configure; make; make install' should
-configure, build, and install this package.  The following
-more-detailed instructions are generic; see the `README' file for
-instructions specific to this package.
-
-   The `configure' shell script attempts to guess correct values for
-various system-dependent variables used during compilation.  It uses
-those values to create a `Makefile' in each directory of the package.
-It may also create one or more `.h' files containing system-dependent
-definitions.  Finally, it creates a shell script `config.status' that
-you can run in the future to recreate the current configuration, and a
-file `config.log' containing compiler output (useful mainly for
-debugging `configure').
-
-   It can also use an optional file (typically called `config.cache'
-and enabled with `--cache-file=config.cache' or simply `-C') that saves
-the results of its tests to speed up reconfiguring.  Caching is
-disabled by default to prevent problems with accidental use of stale
-cache files.
-
-   If you need to do unusual things to compile the package, please try
-to figure out how `configure' could check whether to do them, and mail
-diffs or instructions to the address given in the `README' so they can
-be considered for the next release.  If you are using the cache, and at
-some point `config.cache' contains results you don't want to keep, you
-may remove or edit it.
-
-   The file `configure.ac' (or `configure.in') is used to create
-`configure' by a program called `autoconf'.  You need `configure.ac' if
-you want to change it or regenerate `configure' using a newer version
-of `autoconf'.
-
-The simplest way to compile this package is:
-
-  1. `cd' to the directory containing the package's source code and type
-     `./configure' to configure the package for your system.
-
-     Running `configure' might take a while.  While running, it prints
-     some messages telling which features it is checking for.
-
-  2. Type `make' to compile the package.
-
-  3. Optionally, type `make check' to run any self-tests that come with
-     the package.
-
-  4. Type `make install' to install the programs and any data files and
-     documentation.
-
-  5. You can remove the program binaries and object files from the
-     source code directory by typing `make clean'.  To also remove the
-     files that `configure' created (so you can compile the package for
-     a different kind of computer), type `make distclean'.  There is
-     also a `make maintainer-clean' target, but that is intended mainly
-     for the package's developers.  If you use it, you may have to get
-     all sorts of other programs in order to regenerate files that came
-     with the distribution.
-
-  6. Often, you can also type `make uninstall' to remove the installed
-     files again.
-
-Compilers and Options
-=====================
-
-Some systems require unusual options for compilation or linking that the
-`configure' script does not know about.  Run `./configure --help' for
-details on some of the pertinent environment variables.
-
-   You can give `configure' initial values for configuration parameters
-by setting variables in the command line or in the environment.  Here
-is an example:
-
-     ./configure CC=c99 CFLAGS=-g LIBS=-lposix
-
-   *Note Defining Variables::, for more details.
-
-Compiling For Multiple Architectures
-====================================
-
-You can compile the package for more than one kind of computer at the
-same time, by placing the object files for each architecture in their
-own directory.  To do this, you can use GNU `make'.  `cd' to the
-directory where you want the object files and executables to go and run
-the `configure' script.  `configure' automatically checks for the
-source code in the directory that `configure' is in and in `..'.
-
-   With a non-GNU `make', it is safer to compile the package for one
-architecture at a time in the source code directory.  After you have
-installed the package for one architecture, use `make distclean' before
-reconfiguring for another architecture.
-
-Installation Names
-==================
-
-By default, `make install' installs the package's commands under
-`/usr/local/bin', include files under `/usr/local/include', etc.  You
-can specify an installation prefix other than `/usr/local' by giving
-`configure' the option `--prefix=PREFIX'.
-
-   You can specify separate installation prefixes for
-architecture-specific files and architecture-independent files.  If you
-pass the option `--exec-prefix=PREFIX' to `configure', the package uses
-PREFIX as the prefix for installing programs and libraries.
-Documentation and other data files still use the regular prefix.
-
-   In addition, if you use an unusual directory layout you can give
-options like `--bindir=DIR' to specify different values for particular
-kinds of files.  Run `configure --help' for a list of the directories
-you can set and what kinds of files go in them.
-
-   If the package supports it, you can cause programs to be installed
-with an extra prefix or suffix on their names by giving `configure' the
-option `--program-prefix=PREFIX' or `--program-suffix=SUFFIX'.
-
-Optional Features
-=================
-
-Some packages pay attention to `--enable-FEATURE' options to
-`configure', where FEATURE indicates an optional part of the package.
-They may also pay attention to `--with-PACKAGE' options, where PACKAGE
-is something like `gnu-as' or `x' (for the X Window System).  The
-`README' should mention any `--enable-' and `--with-' options that the
-package recognizes.
-
-   For packages that use the X Window System, `configure' can usually
-find the X include and library files automatically, but if it doesn't,
-you can use the `configure' options `--x-includes=DIR' and
-`--x-libraries=DIR' to specify their locations.
-
-Specifying the System Type
-==========================
-
-There may be some features `configure' cannot figure out automatically,
-but needs to determine by the type of machine the package will run on.
-Usually, assuming the package is built to be run on the _same_
-architectures, `configure' can figure that out, but if it prints a
-message saying it cannot guess the machine type, give it the
-`--build=TYPE' option.  TYPE can either be a short name for the system
-type, such as `sun4', or a canonical name which has the form:
-
-     CPU-COMPANY-SYSTEM
-
-where SYSTEM can have one of these forms:
-
-     OS KERNEL-OS
-
-   See the file `config.sub' for the possible values of each field.  If
-`config.sub' isn't included in this package, then this package doesn't
-need to know the machine type.
-
-   If you are _building_ compiler tools for cross-compiling, you should
-use the option `--target=TYPE' to select the type of system they will
-produce code for.
-
-   If you want to _use_ a cross compiler, that generates code for a
-platform different from the build platform, you should specify the
-"host" platform (i.e., that on which the generated programs will
-eventually be run) with `--host=TYPE'.
-
-Sharing Defaults
-================
-
-If you want to set default values for `configure' scripts to share, you
-can create a site shell script called `config.site' that gives default
-values for variables like `CC', `cache_file', and `prefix'.
-`configure' looks for `PREFIX/share/config.site' if it exists, then
-`PREFIX/etc/config.site' if it exists.  Or, you can set the
-`CONFIG_SITE' environment variable to the location of the site script.
-A warning: not all `configure' scripts look for a site script.
-
-Defining Variables
-==================
-
-Variables not defined in a site shell script can be set in the
-environment passed to `configure'.  However, some packages may run
-configure again during the build, and the customized values of these
-variables may be lost.  In order to avoid this problem, you should set
-them in the `configure' command line, using `VAR=value'.  For example:
-
-     ./configure CC=/usr/local2/bin/gcc
-
-causes the specified `gcc' to be used as the C compiler (unless it is
-overridden in the site shell script).
-
-Unfortunately, this technique does not work for `CONFIG_SHELL' due to
-an Autoconf bug.  Until the bug is fixed you can use this workaround:
-
-     CONFIG_SHELL=/bin/bash /bin/bash ./configure CONFIG_SHELL=/bin/bash
-
-`configure' Invocation
-======================
-
-`configure' recognizes the following options to control how it operates.
-
-`--help'
-`-h'
-     Print a summary of the options to `configure', and exit.
-
-`--version'
-`-V'
-     Print the version of Autoconf used to generate the `configure'
-     script, and exit.
-
-`--cache-file=FILE'
-     Enable the cache: use and save the results of the tests in FILE,
-     traditionally `config.cache'.  FILE defaults to `/dev/null' to
-     disable caching.
-
-`--config-cache'
-`-C'
-     Alias for `--cache-file=config.cache'.
-
-`--quiet'
-`--silent'
-`-q'
-     Do not print messages saying which checks are being made.  To
-     suppress all normal output, redirect it to `/dev/null' (any error
-     messages will still be shown).
-
-`--srcdir=DIR'
-     Look for the package's source code in directory DIR.  Usually
-     `configure' can determine that directory automatically.
-
-`configure' also accepts some other, not widely useful, options.  Run
-`configure --help' for more details.
-
diff -urN remmina/README remmina/README
--- remmina/README	2012-02-11 05:54:23.000000000 +1100
+++ remmina/README	1970-01-01 10:00:00.000000000 +1000
@@ -1,22 +0,0 @@
-To compile with full feature support in Debian, please install the following packages:
-
-libgtk2.0-dev libssh-dev libavahi-ui-dev libvte-dev libgcrypt11-dev libunique-dev
-
-(libpthread is recommended for VNC support and required for SSH support. libpthread-stub0-dev package will be installed as dependency in the above packages in Debian)
-
-To compile and install Remmina, please run the following command as root:
-
-$ ./configure
-$ make
-$ make install
-
-Please visit the following projects that Remmina depends on:
-
-Gnome: http://www.gnome.org
-LibVNCServer: http://libvncserver.sourceforge.net
-rdesktop: http://www.rdesktop.org
-libssh: http://www.libssh.org
-Avahi: http://avahi.org
-libvte: http://library.gnome.org/devel/vte/
-libgcrypt: http://www.gnupg.org
-
diff -urN remmina/desktop/CMakeLists.txt remmina/desktop/CMakeLists.txt
--- remmina/desktop/CMakeLists.txt	2012-02-11 05:54:23.000000000 +1100
+++ remmina/desktop/CMakeLists.txt	2014-01-08 02:31:52.000000000 +1100
@@ -38,3 +38,4 @@
 install(FILES ${ICON48_DATA} DESTINATION ${ICON48_DIR})
 install(FILES ${ICONSVG_DATA} DESTINATION ${ICONSVG_DIR})
 
+install(FILES remmina.desktop DESTINATION "${REMMINA_DATADIR}/applications")
diff -urN remmina/desktop/remmina.desktop remmina/desktop/remmina.desktop
--- remmina/desktop/remmina.desktop	1970-01-01 10:00:00.000000000 +1000
+++ remmina/desktop/remmina.desktop	2014-01-08 02:31:52.000000000 +1100
@@ -0,0 +1,23 @@
+[Desktop Entry]
+Version=1.0
+Name=Remmina
+GenericName=Remote Desktop Client
+X-GNOME-FullName=Remmina Remote Desktop Client
+Comment=Connect to remote desktops
+TryExec=remmina
+Exec=remmina
+Icon=remmina
+Terminal=false
+Type=Application
+Categories=GTK;GNOME;X-GNOME-NetworkSettings;Network;
+Actions=Profile;Tray;
+
+[Desktop Action Profile]
+Name=Create a New Connection Profile
+Exec=remmina --new
+OnlyShowIn=Unity;
+
+[Desktop Action Tray]
+Name=Start Remmina Minimized
+Exec=remmina --icon
+OnlyShowIn=Unity;
diff -urN remmina/desktop/remmina.desktop.in remmina/desktop/remmina.desktop.in
--- remmina/desktop/remmina.desktop.in	2012-02-11 05:54:23.000000000 +1100
+++ remmina/desktop/remmina.desktop.in	1970-01-01 10:00:00.000000000 +1000
@@ -1,12 +0,0 @@
-[Desktop Entry]
-Version=1.0
-_Name=Remmina Remote Desktop Client
-_Comment=Connect to remote desktops
-TryExec=remmina
-Exec=remmina
-Icon=remmina
-Terminal=false
-Type=Application
-Actions=
-Categories=GTK;GNOME;X-GNOME-NetworkSettings;Network;
-
diff -urN remmina/external_tools/CMakeLists.txt remmina/external_tools/CMakeLists.txt
--- remmina/external_tools/CMakeLists.txt	1970-01-01 10:00:00.000000000 +1000
+++ remmina/external_tools/CMakeLists.txt	2014-01-08 02:31:52.000000000 +1100
@@ -0,0 +1,25 @@
+# desktop/remmina - The GTK+ Remote Desktop Client
+#
+# Copyright (C) 2011 Marc-Andre Moreau
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330,
+# Boston, MA 02111-1307, USA.
+
+set(EXTERNAL_TOOLS_DIR "$ENV{HOME}/.remmina/external_tools")
+
+file(MAKE_DIRECTORY ${EXTERNAL_TOOLS_DIR})
+
+INSTALL(PROGRAMS launcher.sh pause.sh remmina_filezilla_sftp.sh remmina_filezilla_sftp_pki.sh remmina_nslookup.sh remmina_ping.sh remmina_traceroute.sh DESTINATION ${EXTERNAL_TOOLS_DIR})
+
diff -urN remmina/external_tools/launcher.sh remmina/external_tools/launcher.sh
--- remmina/external_tools/launcher.sh	1970-01-01 10:00:00.000000000 +1000
+++ remmina/external_tools/launcher.sh	2014-01-08 02:31:52.000000000 +1100
@@ -0,0 +1,11 @@
+####################
+# Main Script
+####################
+#gnome-terminal -e $(dirname $0)/$1 
+gnome-terminal -e $1 &
+
+#if [ "$2" = "1" ]
+#then
+#  echo "Hit a key to continue ..."
+#  Pause
+#fi
diff -urN remmina/external_tools/pause.sh remmina/external_tools/pause.sh
--- remmina/external_tools/pause.sh	1970-01-01 10:00:00.000000000 +1000
+++ remmina/external_tools/pause.sh	2014-01-08 02:31:52.000000000 +1100
@@ -0,0 +1,9 @@
+# Waits for user key press.
+pause ()
+{
+ echo "Hit a key to continue ..."
+ OLDCONFIG=`stty -g`
+ stty -icanon -echo min 1 time 0
+ dd count=1 2>/dev/null
+ stty $OLDCONFIG
+}
diff -urN remmina/external_tools/remmina_filezilla_sftp.sh remmina/external_tools/remmina_filezilla_sftp.sh
--- remmina/external_tools/remmina_filezilla_sftp.sh	1970-01-01 10:00:00.000000000 +1000
+++ remmina/external_tools/remmina_filezilla_sftp.sh	2014-01-08 02:31:52.000000000 +1100
@@ -0,0 +1,4 @@
+. $(dirname $0)/pause.sh
+
+filezilla sftp://$ssh_username:$password@$server 
+
diff -urN remmina/external_tools/remmina_filezilla_sftp_pki.sh remmina/external_tools/remmina_filezilla_sftp_pki.sh
--- remmina/external_tools/remmina_filezilla_sftp_pki.sh	1970-01-01 10:00:00.000000000 +1000
+++ remmina/external_tools/remmina_filezilla_sftp_pki.sh	2014-01-08 02:31:52.000000000 +1100
@@ -0,0 +1,4 @@
+. $(dirname $0)/pause.sh
+
+filezilla sftp://$ssh_username@$server 
+
diff -urN remmina/external_tools/remmina_nslookup.sh remmina/external_tools/remmina_nslookup.sh
--- remmina/external_tools/remmina_nslookup.sh	1970-01-01 10:00:00.000000000 +1000
+++ remmina/external_tools/remmina_nslookup.sh	2014-01-08 02:31:52.000000000 +1100
@@ -0,0 +1,5 @@
+. $(dirname $0)/pause.sh
+
+nslookup $server
+
+pause
diff -urN remmina/external_tools/remmina_ping.sh remmina/external_tools/remmina_ping.sh
--- remmina/external_tools/remmina_ping.sh	1970-01-01 10:00:00.000000000 +1000
+++ remmina/external_tools/remmina_ping.sh	2014-01-08 02:31:52.000000000 +1100
@@ -0,0 +1,5 @@
+. $(dirname $0)/pause.sh
+
+ping -c3 $server
+
+pause
diff -urN remmina/external_tools/remmina_traceroute.sh remmina/external_tools/remmina_traceroute.sh
--- remmina/external_tools/remmina_traceroute.sh	1970-01-01 10:00:00.000000000 +1000
+++ remmina/external_tools/remmina_traceroute.sh	2014-01-08 02:31:52.000000000 +1100
@@ -0,0 +1,5 @@
+. $(dirname $0)/pause.sh
+
+traceroute $server
+
+pause
diff -urN remmina/include/remmina/plugin.h remmina/include/remmina/plugin.h
--- remmina/include/remmina/plugin.h	2012-02-11 05:54:23.000000000 +1100
+++ remmina/include/remmina/plugin.h	2014-01-08 02:31:52.000000000 +1100
@@ -157,6 +157,7 @@
     gint         (* protocol_plugin_init_authpwd)         (RemminaProtocolWidget *gp, RemminaAuthpwdType authpwd_type);
     gint         (* protocol_plugin_init_authuserpwd)     (RemminaProtocolWidget *gp, gboolean want_domain);
     gint         (* protocol_plugin_init_certificate)     (RemminaProtocolWidget *gp, const gchar* subject, const gchar* issuer, const gchar* fingerprint);
+    gint         (* protocol_plugin_changed_certificate)  (RemminaProtocolWidget *gp, const gchar* subject, const gchar* issuer, const gchar* new_fingerprint, const gchar* old_fingerprint);
     gchar*       (* protocol_plugin_init_get_username)    (RemminaProtocolWidget *gp);
     gchar*       (* protocol_plugin_init_get_password)    (RemminaProtocolWidget *gp);
     gchar*       (* protocol_plugin_init_get_domain)      (RemminaProtocolWidget *gp);
diff -urN remmina/po/fr.po remmina/po/fr.po
--- remmina/po/fr.po	2012-02-11 05:54:23.000000000 +1100
+++ remmina/po/fr.po	2014-01-08 02:31:52.000000000 +1100
@@ -7,8 +7,8 @@
 "Project-Id-Version: remmina\n"
 "Report-Msgid-Bugs-To: \n"
 "POT-Creation-Date: 2010-12-11 23:54+0800\n"
-"PO-Revision-Date: 2010-12-12 09:16+0000\n"
-"Last-Translator: Davy Defaud <davy.defaud@free.fr>\n"
+"PO-Revision-Date: 2012-02-26 00:04+0100\n"
+"Last-Translator: Emmanuel Grognet <emmanuel@grognet.fr>\n"
 "Language-Team: French <fr@li.org>\n"
 "MIME-Version: 1.0\n"
 "Content-Type: text/plain; charset=UTF-8\n"
@@ -21,8 +21,10 @@
 msgid "Connect to remote desktops"
 msgstr "Connectez-vous à des bureaux distants"
 
-#: ../desktop/remmina.desktop.in.h:2 ../src/remminamain.c:1157
-#: ../src/remminaicon.c:362 ../src/remminaicon.c:363
+#: ../desktop/remmina.desktop.in.h:2
+#: ../src/remminamain.c:1157
+#: ../src/remminaicon.c:362
+#: ../src/remminaicon.c:363
 msgid "Remmina Remote Desktop Client"
 msgstr "Visionneur de bureaux distants Remmina"
 
@@ -47,7 +49,8 @@
 "Importation impossible :\n"
 "%s"
 
-#: ../src/remminamain.c:770 ../src/remminamain.c:937
+#: ../src/remminamain.c:770
+#: ../src/remminamain.c:937
 msgid "Import"
 msgstr "Importer"
 
@@ -57,7 +60,7 @@
 
 #: ../src/remminamain.c:919
 msgid "_Connection"
-msgstr ""
+msgstr "_Connexion"
 
 #: ../src/remminamain.c:920
 msgid "_Edit"
@@ -83,13 +86,14 @@
 msgid "Open the preferences dialog"
 msgstr "Ouvrir la boîte de dialogue des préférences"
 
-#: ../src/remminamain.c:941 ../src/remminapluginmanager.c:239
+#: ../src/remminamain.c:941
+#: ../src/remminapluginmanager.c:239
 msgid "Plugins"
 msgstr "Greffons"
 
 #: ../src/remminamain.c:945
 msgid "Homepage"
-msgstr ""
+msgstr "Site Web"
 
 #: ../src/remminamain.c:949
 msgid "Online Wiki"
@@ -144,19 +148,23 @@
 msgstr "Affichage arborescent"
 
 #. Profile: Name
-#: ../src/remminamain.c:1230 ../src/remminafileeditor.c:1286
+#: ../src/remminamain.c:1230
+#: ../src/remminafileeditor.c:1286
 #: ../src/remminapluginmanager.c:259
 msgid "Name"
 msgstr "Nom"
 
 #. Profile: Group
-#: ../src/remminamain.c:1243 ../src/remminafileeditor.c:1308
+#: ../src/remminamain.c:1243
+#: ../src/remminafileeditor.c:1308
 #: ../src/remminaftpclient.c:1020
 msgid "Group"
 msgstr "Groupe"
 
-#: ../src/remminamain.c:1251 ../src/remminafileeditor.c:342
-#: ../src/remminafileeditor.c:795 ../src/remminafileeditor.c:808
+#: ../src/remminamain.c:1251
+#: ../src/remminafileeditor.c:342
+#: ../src/remminafileeditor.c:795
+#: ../src/remminafileeditor.c:808
 #: ../src/remminaprotocolwidget.c:1032
 msgid "Server"
 msgstr "Serveur"
@@ -191,7 +199,8 @@
 msgid "Choose a Remote Desktop Server"
 msgstr "Choisir un serveur de bureau distant"
 
-#: ../src/remminafileeditor.c:297 ../src/remminafileeditor.c:304
+#: ../src/remminafileeditor.c:297
+#: ../src/remminafileeditor.c:304
 msgid "Identity file"
 msgstr "Fichier d’identité"
 
@@ -200,8 +209,10 @@
 msgid "Browse the network to find a %s server"
 msgstr "Parcourir le réseau à la recherche d’un serveur %s"
 
-#: ../src/remminafileeditor.c:387 ../src/remminafileeditor.c:850
-#: ../src/remminaprotocolwidget.c:833 ../src/remminainitdialog.c:278
+#: ../src/remminafileeditor.c:387
+#: ../src/remminafileeditor.c:850
+#: ../src/remminaprotocolwidget.c:833
+#: ../src/remminainitdialog.c:278
 msgid "Password"
 msgstr "Mot de passe"
 
@@ -217,7 +228,8 @@
 msgid "Use client resolution"
 msgstr "Utiliser la résolution du client"
 
-#: ../src/remminafileeditor.c:444 ../src/remminafileeditor.c:775
+#: ../src/remminafileeditor.c:444
+#: ../src/remminafileeditor.c:775
 msgid "Custom"
 msgstr "Personnalisé"
 
@@ -225,11 +237,13 @@
 msgid "Keyboard mapping"
 msgstr "Agencement du clavier"
 
-#: ../src/remminafileeditor.c:631 ../src/remminascaler.c:138
+#: ../src/remminafileeditor.c:631
+#: ../src/remminascaler.c:138
 msgid "Horizontal scale"
 msgstr "Échelle horizontale"
 
-#: ../src/remminafileeditor.c:636 ../src/remminascaler.c:145
+#: ../src/remminafileeditor.c:636
+#: ../src/remminascaler.c:145
 msgid "Vertical scale"
 msgstr "Échelle verticale"
 
@@ -269,7 +283,8 @@
 msgstr "Authentification SSH"
 
 #. Entries
-#: ../src/remminafileeditor.c:847 ../src/remminainitdialog.c:265
+#: ../src/remminafileeditor.c:847
+#: ../src/remminainitdialog.c:265
 msgid "User name"
 msgstr "Nom d’utilisateur"
 
@@ -310,14 +325,16 @@
 #: ../src/remminafileeditor.c:1320
 #, c-format
 msgid "Use '%s' as subgroup delimiter"
-msgstr ""
+msgstr "Utiliser \"%s\" comme délimiteur de sous-groupe "
 
 #. Profile: Protocol
-#: ../src/remminafileeditor.c:1325 ../src/remminapluginmanager.c:38
+#: ../src/remminafileeditor.c:1325
+#: ../src/remminapluginmanager.c:38
 msgid "Protocol"
 msgstr "Protocole"
 
-#: ../src/remminafileeditor.c:1384 ../src/remminafileeditor.c:1405
+#: ../src/remminafileeditor.c:1384
+#: ../src/remminafileeditor.c:1405
 #: ../src/remminaconnectionwindow.c:2421
 #, c-format
 msgid "File %s not found."
@@ -325,33 +342,33 @@
 
 #: ../src/remminaconnectionwindow.c:183
 #, c-format
-msgid ""
-"There are %i active connections in the current window. Are you sure to close?"
-msgstr ""
-"Il y a %i connexion(s) active(s) sur la fenêtre courante. Êtes-vous sûr de "
-"vouloir quitter ?"
+msgid "There are %i active connections in the current window. Are you sure to close?"
+msgstr "Il y a %i connexion(s) active(s) sur la fenêtre courante. Êtes-vous sûr de vouloir quitter ?"
 
 #: ../src/remminaconnectionwindow.c:563
 msgid "Viewport fullscreen mode"
-msgstr ""
+msgstr "Mode zone de visualisation (viewport) en plein écran"
 
 #: ../src/remminaconnectionwindow.c:574
 msgid "Scrolled fullscreen mode"
-msgstr ""
+msgstr "Mode plein écran avec défilement"
 
 #: ../src/remminaconnectionwindow.c:1177
 msgid "Resize the window to fit in remote resolution"
 msgstr "Redimensionner la fenêtre en fonction de la résolution distante"
 
-#: ../src/remminaconnectionwindow.c:1188 ../src/remminaprefdialog.c:559
+#: ../src/remminaconnectionwindow.c:1188
+#: ../src/remminaprefdialog.c:559
 msgid "Toggle fullscreen mode"
 msgstr "Basculer en mode plein écran"
 
-#: ../src/remminaconnectionwindow.c:1229 ../src/remminaprefdialog.c:579
+#: ../src/remminaconnectionwindow.c:1229
+#: ../src/remminaprefdialog.c:579
 msgid "Switch tab pages"
 msgstr "Changer d’onglet"
 
-#: ../src/remminaconnectionwindow.c:1243 ../src/remminaprefdialog.c:598
+#: ../src/remminaconnectionwindow.c:1243
+#: ../src/remminaprefdialog.c:598
 msgid "Toggle scaled mode"
 msgstr "Basculer en mode réduit"
 
@@ -363,15 +380,18 @@
 msgid "Preferences"
 msgstr "Préférences"
 
-#: ../src/remminaconnectionwindow.c:1295 ../src/remminaconnectionwindow.c:1296
+#: ../src/remminaconnectionwindow.c:1295
+#: ../src/remminaconnectionwindow.c:1296
 msgid "Tools"
 msgstr "Outils"
 
-#: ../src/remminaconnectionwindow.c:1308 ../src/remminaprefdialog.c:618
+#: ../src/remminaconnectionwindow.c:1308
+#: ../src/remminaprefdialog.c:618
 msgid "Minimize window"
 msgstr "Réduire la fenêtre"
 
-#: ../src/remminaconnectionwindow.c:1316 ../src/remminaprefdialog.c:628
+#: ../src/remminaconnectionwindow.c:1316
+#: ../src/remminaprefdialog.c:628
 msgid "Disconnect"
 msgstr "Se déconnecter"
 
@@ -383,7 +403,7 @@
 #: ../src/remminaprotocolwidget.c:202
 #, c-format
 msgid "Protocol plugin %s is not installed."
-msgstr ""
+msgstr "Le greffon du protocole %s n'est pas installé"
 
 #: ../src/remminaprotocolwidget.c:240
 msgid "Open Secure Shell in New Terminal..."
@@ -398,7 +418,8 @@
 msgid "Connecting to SSH server %s..."
 msgstr "Connexion au serveur SSH %s..."
 
-#: ../src/remminaprotocolwidget.c:516 ../src/remminaprotocolwidget.c:686
+#: ../src/remminaprotocolwidget.c:516
+#: ../src/remminaprotocolwidget.c:686
 #, c-format
 msgid "Connecting to %s through SSH tunnel..."
 msgstr "Connexion à %s via tunnel SSH..."
@@ -428,11 +449,13 @@
 msgid "%s password"
 msgstr "Mot de passe %s"
 
-#: ../src/remminaprotocolwidget.c:827 ../src/remminassh.c:248
+#: ../src/remminaprotocolwidget.c:827
+#: ../src/remminassh.c:248
 msgid "SSH password"
 msgstr "Mot de passe SSH"
 
-#: ../src/remminaprotocolwidget.c:830 ../src/remminassh.c:252
+#: ../src/remminaprotocolwidget.c:830
+#: ../src/remminassh.c:252
 msgid "SSH private key passphrase"
 msgstr "Phrase de passe de la clef privée"
 
@@ -480,38 +503,16 @@
 msgstr "Contributeurs :"
 
 #: ../src/remminaabout.c:47
-msgid ""
-"Remmina is free software; you can redistribute it and/or modify it under the "
-"terms of the GNU General Public License as published by the Free Software "
-"Foundation; either version 2 of the License, or (at your option) any later "
-"version."
-msgstr ""
-"Remmina est un logiciel libre ; vous pouvez le redistribuer et / ou le "
-"modifier en respectant les termes de la Licence Publique Générale GNU "
-"publiée par la Free Software Foundation ; ou de la version 2 de la licence, "
-"ou (à votre choix) toutes les versions supérieures."
+msgid "Remmina is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version."
+msgstr "Remmina est un logiciel libre ; vous pouvez le redistribuer et / ou le modifier en respectant les termes de la Licence Publique Générale GNU publiée par la Free Software Foundation ; ou de la version 2 de la licence, ou (à votre choix) toutes les versions supérieures."
 
 #: ../src/remminaabout.c:51
-msgid ""
-"Remmina is distributed in the hope that it will be useful, but WITHOUT ANY "
-"WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS "
-"FOR A PARTICULAR PURPOSE. See the GNU General Public License for more "
-"details."
-msgstr ""
-"Remmina est distribué dans l’espoir qu’il sera utile, mais SANS AUCUNE "
-"GARANTIE, sans même la garantie implicite de COMMERCIALISATION ou "
-"D'ADAPTATION À UN USAGE PARTICULIER. Voir la Licence Publique Générale GNU "
-"pour plus de détails."
+msgid "Remmina is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details."
+msgstr "Remmina est distribué dans l’espoir qu’il sera utile, mais SANS AUCUNE GARANTIE, sans même la garantie implicite de COMMERCIALISATION ou D'ADAPTATION À UN USAGE PARTICULIER. Voir la Licence Publique Générale GNU pour plus de détails."
 
 #: ../src/remminaabout.c:55
-msgid ""
-"You should have received a copy of the GNU General Public License along with "
-"this program; if not, write to the Free Software Foundation, Inc., 59 Temple "
-"Place, Suite 330, Boston, MA 02111-1307, USA."
-msgstr ""
-"Si devriez avoir reçu une copie de la Licence Publique Générale GNU utilisée "
-"par ce programme ; sinon, écrivez à la Free Software Foundation, Inc., 59 "
-"Temple Place, Suite 330, Boston, MA 02111-1307, USA."
+msgid "You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA."
+msgstr "Si devriez avoir reçu une copie de la Licence Publique Générale GNU utilisée par ce programme ; sinon, écrivez à la Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA."
 
 #: ../src/remminaabout.c:68
 msgid "The GTK+ Remote Desktop Client"
@@ -520,6 +521,7 @@
 #: ../src/remminaabout.c:74
 msgid "translator-credits"
 msgstr ""
+"Emmanuel Grognet <emmanuel@grognet.fr>\n"
 "Launchpad Contributions:\n"
 "  Davy Defaud https://launchpad.net/~davy-defaud\n"
 "  Florent DEUTSCH https://launchpad.net/~florent-arawn\n"
@@ -661,23 +663,23 @@
 
 #: ../src/remminaprefdialog.c:498
 msgid "Show new connection on top of the menu"
-msgstr ""
+msgstr "Positionner \"Nouvelle connexion\" en haut du menu"
 
 #: ../src/remminaprefdialog.c:504
 msgid "Hide total count in group menu"
-msgstr ""
+msgstr "Cacher le nombre de connexion par groupe dans le menu"
 
 #: ../src/remminaprefdialog.c:510
 msgid "Disable tray icon"
-msgstr ""
+msgstr "Désactiver l'icône de la zone de notification"
 
 #: ../src/remminaprefdialog.c:516
 msgid "Start tray icon automatically"
-msgstr ""
+msgstr "Démarrer l'icône de la zone de notification automatiquement"
 
 #: ../src/remminaprefdialog.c:523
 msgid "Minimize windows to tray"
-msgstr ""
+msgstr "Réduire dans la zone de notification"
 
 #. Keyboard tab
 #: ../src/remminaprefdialog.c:534
@@ -703,26 +705,28 @@
 #. Terminal tab
 #: ../src/remminaprefdialog.c:649
 msgid "Terminal"
-msgstr ""
+msgstr "Terminal"
 
 #: ../src/remminaprefdialog.c:664
 msgid "Font"
-msgstr ""
+msgstr "Police"
 
 #: ../src/remminaprefdialog.c:669
 msgid "Use system default font"
-msgstr ""
+msgstr "Utiliser la police système par défaut"
 
 #: ../src/remminaprefdialog.c:694
 msgid "Scrollback lines"
-msgstr ""
+msgstr "Limite de défilement"
 
 #: ../src/remminassh.c:129
 #, c-format
 msgid "SSH password authentication failed: %s"
 msgstr "L’authentification SSH par mot de passe a échoué : %s"
 
-#: ../src/remminassh.c:149 ../src/remminassh.c:157 ../src/remminassh.c:168
+#: ../src/remminassh.c:149
+#: ../src/remminassh.c:157
+#: ../src/remminassh.c:168
 #: ../src/remminassh.c:178
 #, c-format
 msgid "SSH public key authentication failed: %s"
@@ -762,7 +766,8 @@
 msgid "Failed to execute %s on SSH server : %%s"
 msgstr "Impossible d’exécuter %s sur le serveur SSH : %%s"
 
-#: ../src/remminassh.c:705 ../src/remminassh.c:730
+#: ../src/remminassh.c:705
+#: ../src/remminassh.c:730
 #, c-format
 msgid "Failed to request port forwarding : %s"
 msgstr "Échec de la demande de redirection de port : %s"
@@ -805,8 +810,7 @@
 
 #: ../src/remminaftpclient.c:614
 msgid "Are you sure to delete the selected files on server?"
-msgstr ""
-"Êtes-vous sûr de vouloir supprimer les fichiers sélectionnés sur le serveur ?"
+msgstr "Êtes-vous sûr de vouloir supprimer les fichiers sélectionnés sur le serveur ?"
 
 #: ../src/remminaftpclient.c:671
 msgid "Choose a file to upload"
@@ -816,11 +820,13 @@
 msgid "Upload folder"
 msgstr "Réportoire d’envoi"
 
-#: ../src/remminaftpclient.c:747 ../src/remminaftpclient.c:876
+#: ../src/remminaftpclient.c:747
+#: ../src/remminaftpclient.c:876
 msgid "Download"
 msgstr "Télécharger"
 
-#: ../src/remminaftpclient.c:755 ../src/remminaftpclient.c:887
+#: ../src/remminaftpclient.c:755
+#: ../src/remminaftpclient.c:887
 msgid "Upload"
 msgstr "Envoyer"
 
@@ -848,11 +854,13 @@
 msgid "Delete files on server"
 msgstr "Effacer les fichiers sur le serveur"
 
-#: ../src/remminaftpclient.c:992 ../src/remminaftpclient.c:1064
+#: ../src/remminaftpclient.c:992
+#: ../src/remminaftpclient.c:1064
 msgid "File Name"
 msgstr "Nom du fichier"
 
-#: ../src/remminaftpclient.c:1005 ../src/remminaftpclient.c:1094
+#: ../src/remminaftpclient.c:1005
+#: ../src/remminaftpclient.c:1094
 msgid "Size"
 msgstr "Taille"
 
@@ -921,7 +929,8 @@
 msgid "Error writing file %s on server. %s"
 msgstr "Erreur lors de l’écriture du fichier %s sur le serveur. %s"
 
-#: ../src/remminasftpclient.c:607 ../src/remminasftpclient.c:678
+#: ../src/remminasftpclient.c:607
+#: ../src/remminasftpclient.c:678
 #, c-format
 msgid "Failed to open directory %s. %s"
 msgstr "Échec de l’ouverture du répertoire %s. %s"
@@ -946,7 +955,7 @@
 
 #: ../src/remminasftpplugin.c:244
 msgid "Show Hidden Files"
-msgstr ""
+msgstr "Voir les fichiers cachés"
 
 #: ../src/remminasftpplugin.c:252
 msgid "SFTP - Secure File Transfer"
@@ -966,11 +975,11 @@
 
 #: ../src/remminapluginmanager.c:41
 msgid "Tool"
-msgstr ""
+msgstr "Outil"
 
 #: ../src/remminapluginmanager.c:42
 msgid "Preference"
-msgstr ""
+msgstr "Préférence"
 
 #: ../src/remminapluginmanager.c:266
 msgid "Type"
@@ -982,7 +991,7 @@
 
 #: ../src/remminapluginmanager.c:280
 msgid "Version"
-msgstr ""
+msgstr "Version"
 
 #: ../src/remminakeychooser.c:43
 msgid "<None>"
@@ -1010,11 +1019,13 @@
 msgstr "Activer la découverte de services"
 
 #. Refresh it in case translation is updated
-#: ../src/remminaicon.c:342 ../src/remminaicon.c:421
+#: ../src/remminaicon.c:342
+#: ../src/remminaicon.c:421
 msgid "Remmina Applet"
-msgstr ""
+msgstr "Applet Remmina"
 
-#: ../src/remminaicon.c:343 ../src/remminaicon.c:422
+#: ../src/remminaicon.c:343
+#: ../src/remminaicon.c:422
 msgid "Connect to remote desktops through the applet menu"
 msgstr "Se connecter aux bureaux distants via le menu de l'applet"
 
@@ -1025,3 +1036,4 @@
 #: ../src/remminaappletmenuitem.c:97
 msgid "New Connection"
 msgstr "Nouvelle connexion"
+
diff -urN remmina/src/remmina.c remmina/src/remmina.c
--- remmina/src/remmina.c	2012-02-11 05:54:23.000000000 +1100
+++ remmina/src/remmina.c	2014-01-08 02:31:52.000000000 +1100
@@ -55,6 +55,7 @@
 static gboolean remmina_option_quit;
 static gchar *remmina_option_server;
 static gchar *remmina_option_protocol;
+static gchar *remmina_option_icon;
 
 static GOptionEntry remmina_options[] =
 {
@@ -68,6 +69,7 @@
 { "quit", 'q', 0, G_OPTION_ARG_NONE, &remmina_option_quit, "Quit the application", NULL },
 { "server", 's', 0, G_OPTION_ARG_STRING, &remmina_option_server, "Use default server name S", "S" },
 { "protocol", 't', 0, G_OPTION_ARG_STRING, &remmina_option_protocol, "Use default protocol T", "T" },
+{ "icon", 'i', 0, G_OPTION_ARG_NONE, &remmina_option_icon, "Start as tray icon", NULL },
 { NULL } };
 
 static gint remmina_on_command_line(GApplication *app, GApplicationCommandLine *cmdline)
@@ -90,6 +92,7 @@
 	remmina_option_plugin = NULL;
 	remmina_option_server = NULL;
 	remmina_option_protocol = NULL;
+	remmina_option_icon = FALSE;
 
 	argv = g_application_command_line_get_arguments(cmdline, &argc);
 
@@ -157,6 +160,11 @@
 		remmina_exec_command(REMMINA_COMMAND_PLUGIN, remmina_option_plugin);
 		executed = TRUE;
 	}
+	if (remmina_option_icon)
+	{
+		remmina_exec_command(REMMINA_COMMAND_NONE, remmina_option_icon);
+		executed = TRUE;
+	}
 	if (!executed)
 	{
 		remmina_exec_command(REMMINA_COMMAND_MAIN, NULL);
@@ -194,7 +202,7 @@
 	textdomain(GETTEXT_PACKAGE);
 
 #ifdef HAVE_PTHREAD
-	g_thread_init (NULL);
+	g_type_init ();
 	gdk_threads_init ();
 #endif
 
diff -urN remmina/src/remmina_about.c remmina/src/remmina_about.c
--- remmina/src/remmina_about.c	2012-02-11 05:54:23.000000000 +1100
+++ remmina/src/remmina_about.c	2014-01-08 02:31:52.000000000 +1100
@@ -68,7 +68,7 @@
 
 	gtk_about_dialog_set_program_name(GTK_ABOUT_DIALOG(dialog), "Remmina");
 	gtk_about_dialog_set_version(GTK_ABOUT_DIALOG(dialog), VERSION);
-	gtk_about_dialog_set_copyright(GTK_ABOUT_DIALOG(dialog), "Copyright (C) 2009-2010 Vic Lee");
+	gtk_about_dialog_set_copyright(GTK_ABOUT_DIALOG(dialog), "Copyright (C) 2009-2012 Vic Lee");
 	gtk_about_dialog_set_comments(GTK_ABOUT_DIALOG(dialog), _("The GTK+ Remote Desktop Client")), gtk_about_dialog_set_license(
 			GTK_ABOUT_DIALOG(dialog), license);
 	gtk_about_dialog_set_wrap_license(GTK_ABOUT_DIALOG(dialog), TRUE);
diff -urN remmina/src/remmina_connection_window.c remmina/src/remmina_connection_window.c
--- remmina/src/remmina_connection_window.c	2012-02-11 05:54:23.000000000 +1100
+++ remmina/src/remmina_connection_window.c	2014-01-08 02:31:52.000000000 +1100
@@ -126,17 +126,39 @@
 static void remmina_connection_holder_create_fullscreen(RemminaConnectionHolder* cnnhld, RemminaConnectionObject* cnnobj,
 		gint view_mode);
 
+#if GTK_VERSION == 3
 static void remmina_connection_window_class_init(RemminaConnectionWindowClass* klass)
 {
-	gtk_rc_parse_string("style \"remmina-small-button-style\"\n"
+	GtkCssProvider  *provider;
+
+	provider = gtk_css_provider_new();
+	gtk_css_provider_load_from_data (provider,
+			"*.remmina-small-button\n"
 			"{\n"
-			"  GtkWidget::focus-padding = 0\n"
-			"  GtkWidget::focus-line-width = 0\n"
+			"  -GtkWidget::focus-padding = 0\n"
+			"  -GtkWidget::focus-line-width = 0\n"
 			"  xthickness = 0\n"
 			"  ythickness = 0\n"
-			"}\n"
-			"widget \"*.remmina-small-button\" style \"remmina-small-button-style\"");
+			"}\n",
+			-1, NULL);
+	gtk_style_context_add_provider_for_screen (gdk_screen_get_default(),
+							GTK_STYLE_PROVIDER (provider),
+							GTK_STYLE_PROVIDER_PRIORITY_APPLICATION);
+	g_object_unref(provider);
 }
+#elif GTK_VERSION == 2
+static void remmina_connection_window_class_init(RemminaConnectionWindowClass* klass)
+{
+	gtk_rc_parse_string("style \"remmina-small-button-style\"\n"
+				"{\n"
+				" GtkWidget::focus-padding = 0\n"
+				" GtkWidget::focus-line-width = 0\n"
+				" xthickness = 0\n"
+				" ythickness = 0\n"
+				"}\n"
+				"widget \"*.remmina-small-button\" style \"remmina-small-button-style\"");
+}
+#endif
 
 static void remmina_connection_holder_disconnect(RemminaConnectionHolder* cnnhld)
 {
@@ -147,6 +169,31 @@
 	remmina_protocol_widget_close_connection(REMMINA_PROTOCOL_WIDGET(cnnobj->proto));
 }
 
+#if GTK_VERSION == 3
+static void remmina_connection_holder_keyboard_grab(RemminaConnectionHolder* cnnhld)
+{
+	DECLARE_CNNOBJ
+	GdkDisplay *display;
+	GdkDeviceManager *manager;
+	GdkDevice *keyboard = NULL;
+
+	display = gtk_widget_get_display(GTK_WIDGET(cnnhld->cnnwin));
+	manager = gdk_display_get_device_manager(display);
+	keyboard = gdk_device_manager_get_client_pointer(manager);
+
+	if (keyboard != NULL)
+	{
+		if (remmina_file_get_int(cnnobj->remmina_file, "keyboard_grab", FALSE))
+		{
+			gdk_device_grab(keyboard, gtk_widget_get_window(GTK_WIDGET(cnnhld->cnnwin)), GDK_OWNERSHIP_WINDOW, TRUE, GDK_KEY_PRESS | GDK_KEY_RELEASE, NULL, GDK_CURRENT_TIME);
+		}
+		else
+		{
+			gdk_device_ungrab(keyboard, GDK_CURRENT_TIME);
+		}
+	}
+}
+#elif GTK_VERSION == 2
 static void remmina_connection_holder_keyboard_grab(RemminaConnectionHolder* cnnhld)
 {
 	DECLARE_CNNOBJ
@@ -160,6 +207,7 @@
 		gdk_keyboard_ungrab(GDK_CURRENT_TIME);
 	}
 }
+#endif
 
 static gboolean remmina_connection_window_delete_event(GtkWidget* widget, GdkEvent* event, gpointer data)
 {
@@ -245,7 +293,11 @@
 		return FALSE;
 	}
 
+#if GTK_VERSION == 3
+	gtk_widget_get_preferred_size(priv->floating_toolbar, &req, NULL);
+#elif GTK_VERSION == 2
 	gtk_widget_size_request(priv->floating_toolbar, &req);
+#endif
 	gtk_window_get_position(GTK_WINDOW(priv->floating_toolbar), &x, &y);
 
 	if (priv->floating_toolbar_motion_show || priv->floating_toolbar_motion_visible)
@@ -384,7 +436,7 @@
 		remmina_connection_holder_get_desktop_size(cnnhld, &width, &height, TRUE);
 		gtk_widget_get_allocation(priv->notebook, &na);
 		gtk_widget_get_allocation(cnnobj->scrolled_container, &ca);
-		gtk_widget_get_allocation(priv->toolbar, &ca);
+		gtk_widget_get_allocation(priv->toolbar, &ta);
 		gtk_window_resize(GTK_WINDOW(cnnhld->cnnwin), MAX(1, width + na.width - ca.width),
 				MAX(1, height + ta.height + na.height - ca.height));
 		gtk_container_check_resize(GTK_CONTAINER(cnnhld->cnnwin));
@@ -420,17 +472,23 @@
 static void remmina_connection_object_init_adjustment(RemminaConnectionObject* cnnobj)
 {
 	GdkScreen* screen;
-	GtkAdjustment* adj;
+	GtkAdjustment* adjh;
+	GtkAdjustment* adjv;
 	gint screen_width, screen_height;
 
 	screen = gdk_screen_get_default();
 	screen_width = gdk_screen_get_width(screen);
 	screen_height = gdk_screen_get_height(screen);
 
-	adj = gtk_viewport_get_hadjustment(GTK_VIEWPORT(cnnobj->viewport));
-	gtk_adjustment_set_page_size(adj, screen_width);
-	adj = gtk_viewport_get_vadjustment(GTK_VIEWPORT(cnnobj->viewport));
-	gtk_adjustment_set_page_size(adj, screen_height);
+#if GTK_VERSION == 3
+	adjh = gtk_scrollable_get_hadjustment(GTK_SCROLLABLE(cnnobj->viewport));
+	adjv = gtk_scrollable_get_vadjustment(GTK_SCROLLABLE(cnnobj->viewport));
+#elif GTK_VERSION == 2
+	adjh = gtk_viewport_get_hadjustment(GTK_VIEWPORT(cnnobj->viewport));
+	adjv = gtk_viewport_get_vadjustment(GTK_VIEWPORT(cnnobj->viewport));
+#endif
+	gtk_adjustment_set_page_size(adjh, screen_width);
+	gtk_adjustment_set_page_size(adjv, screen_height);
 }
 
 static void remmina_connection_holder_check_resize(RemminaConnectionHolder* cnnhld)
@@ -438,13 +496,21 @@
 	DECLARE_CNNOBJ
 	gboolean scroll_required = FALSE;
 	GdkScreen* screen;
+	gint monitor;
+	GdkRectangle screen_size;
 	gint screen_width, screen_height;
 	gint server_width, server_height;
 
 	remmina_connection_holder_get_desktop_size(cnnhld, &server_width, &server_height, FALSE);
-	screen = gdk_screen_get_default();
-	screen_width = gdk_screen_get_width(screen);
-	screen_height = gdk_screen_get_height(screen);
+	screen = gtk_window_get_screen(GTK_WINDOW(cnnhld->cnnwin));
+	monitor = gdk_screen_get_monitor_at_window(screen, gtk_widget_get_window(GTK_WIDGET(cnnhld->cnnwin)));
+#ifdef gdk_screen_get_monitor_workarea
+	gdk_screen_get_monitor_workarea(screen, monitor, &screen_size);
+#else
+	gdk_screen_get_monitor_geometry(screen, monitor, &screen_size);
+#endif
+	screen_width = screen_size.width;
+	screen_height = screen_size.height;
 
 	if (!remmina_protocol_widget_get_expand(REMMINA_PROTOCOL_WIDGET(cnnobj->proto))
 			&& (server_width <= 0 || server_height <= 0 || screen_width < server_width
@@ -455,52 +521,50 @@
 
 	switch (cnnhld->cnnwin->priv->view_mode)
 	{
-
 		case SCROLLED_FULLSCREEN_MODE:
 			gtk_window_resize(GTK_WINDOW(cnnhld->cnnwin), screen_width, screen_height);
 			gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(cnnobj->scrolled_container),
 					(scroll_required ? GTK_POLICY_AUTOMATIC : GTK_POLICY_NEVER),
 					(scroll_required ? GTK_POLICY_AUTOMATIC : GTK_POLICY_NEVER));
-					break;
+			break;
 
-					case VIEWPORT_FULLSCREEN_MODE:
-					gtk_window_resize (GTK_WINDOW(cnnhld->cnnwin), screen_width, screen_height);
-					gtk_container_set_border_width (GTK_CONTAINER (cnnhld->cnnwin), scroll_required ? 1 : 0);
-        break;
-
-    case SCROLLED_WINDOW_MODE:
-        if (remmina_file_get_int (cnnobj->remmina_file, "viewmode", AUTO_MODE) == AUTO_MODE)
-        {
-            gtk_window_set_default_size (GTK_WINDOW(cnnhld->cnnwin),
-                MIN (server_width, screen_width), MIN (server_height, screen_height));
-            if (server_width >= screen_width ||
-                server_height >= screen_height)
-            {
-                gtk_window_maximize (GTK_WINDOW(cnnhld->cnnwin));
-                remmina_file_set_int (cnnobj->remmina_file, "window_maximize", TRUE);
-            }
-            else
-            {
-                remmina_connection_holder_toolbar_autofit (NULL, cnnhld);
-                remmina_file_set_int (cnnobj->remmina_file, "window_maximize", FALSE);
-            }
-        }
-        else
-        {
-            gtk_window_set_default_size (GTK_WINDOW(cnnhld->cnnwin),
-                remmina_file_get_int (cnnobj->remmina_file, "window_width", 640),
-                remmina_file_get_int (cnnobj->remmina_file, "window_height", 480));
-            if (remmina_file_get_int (cnnobj->remmina_file, "window_maximize", FALSE))
-            {
-                gtk_window_maximize (GTK_WINDOW(cnnhld->cnnwin));
-            }
-        }
-        break;
-
-    default:
-        break;
-    }
-		}
+		case VIEWPORT_FULLSCREEN_MODE:
+				gtk_window_resize (GTK_WINDOW(cnnhld->cnnwin), screen_width, screen_height);
+				gtk_container_set_border_width (GTK_CONTAINER (cnnhld->cnnwin), scroll_required ? 1 : 0);
+			break;
+
+		case SCROLLED_WINDOW_MODE:
+			if (remmina_file_get_int (cnnobj->remmina_file, "viewmode", AUTO_MODE) == AUTO_MODE)
+			{
+				gtk_window_set_default_size (GTK_WINDOW(cnnhld->cnnwin),
+					MIN (server_width, screen_width), MIN (server_height, screen_height));
+				if (server_width >= screen_width || server_height >= screen_height)
+				{
+					gtk_window_maximize (GTK_WINDOW(cnnhld->cnnwin));
+					remmina_file_set_int (cnnobj->remmina_file, "window_maximize", TRUE);
+				}
+				else
+				{
+					remmina_connection_holder_toolbar_autofit (NULL, cnnhld);
+					remmina_file_set_int (cnnobj->remmina_file, "window_maximize", FALSE);
+				}
+			}
+			else
+			{
+				gtk_window_set_default_size (GTK_WINDOW(cnnhld->cnnwin),
+					remmina_file_get_int (cnnobj->remmina_file, "window_width", 640),
+				remmina_file_get_int (cnnobj->remmina_file, "window_height", 480));
+				if (remmina_file_get_int (cnnobj->remmina_file, "window_maximize", FALSE))
+				{
+					gtk_window_maximize (GTK_WINDOW(cnnhld->cnnwin));
+				}
+			}
+			break;
+
+		default:
+			break;
+	}
+}
 
 static void remmina_connection_holder_set_tooltip(GtkWidget* item, const gchar* tip, guint key1, guint key2)
 {
@@ -764,13 +828,30 @@
 static void remmina_connection_holder_scale_option_popdown(RemminaConnectionHolder* cnnhld)
 {
 	RemminaConnectionWindowPriv* priv = cnnhld->cnnwin->priv;
+#if GTK_VERSION == 3
+	GdkDisplay *display;
+	GdkDeviceManager *manager;
+	GdkDevice *device = NULL;
+
+	priv->sticky = FALSE;
+
+	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(priv->scale_option_button), FALSE);
 
+	display = gtk_widget_get_display(GTK_WIDGET(cnnhld));
+	manager = gdk_display_get_device_manager(display);
+	device = gdk_device_manager_get_client_pointer(manager);
+	if (device != NULL)
+	{
+		gdk_device_ungrab(device, GDK_CURRENT_TIME);
+	}
+#elif GTK_VERSION == 2
 	priv->sticky = FALSE;
 
 	gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(priv->scale_option_button), FALSE);
 
 	gdk_keyboard_ungrab(GDK_CURRENT_TIME);
 	gdk_pointer_ungrab(GDK_CURRENT_TIME);
+#endif
 	if (scale_option_window)
 	{
 		gtk_grab_remove(scale_option_window);
@@ -813,6 +894,11 @@
 	GtkWidget* eventbox;
 	GtkWidget* frame;
 	GtkWidget* scaler;
+#if GTK_VERSION == 3
+	GdkDisplay* display;
+	GdkDevice* pointer;
+	GdkDeviceManager* device_manager;
+#endif
 	gint x, y;
 	gboolean pushin;
 
@@ -863,11 +949,19 @@
 			gtk_widget_show(window);
 
 			gtk_grab_add(window);
+#if GTK_VERSION == 3
+			display = gdk_window_get_display(gtk_widget_get_window(window));
+			device_manager = gdk_display_get_device_manager(display);
+			pointer = gdk_device_manager_get_client_pointer(device_manager);
+			gdk_device_grab(pointer, gtk_widget_get_window(window), GDK_OWNERSHIP_NONE, TRUE,
+					GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK | GDK_POINTER_MOTION_MASK | GDK_KEY_PRESS_MASK | GDK_KEY_RELEASE_MASK, NULL,
+					GDK_CURRENT_TIME);
+#elif GTK_VERSION == 2
 			gdk_pointer_grab(gtk_widget_get_window(window), TRUE,
 					GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK | GDK_POINTER_MOTION_MASK, NULL, NULL,
 					GDK_CURRENT_TIME);
 			gdk_keyboard_grab(gtk_widget_get_window(window), TRUE, GDK_CURRENT_TIME);
-
+#endif
 			scale_option_window = window;
 			priv->sticky = TRUE;
 		}
@@ -1356,7 +1450,11 @@
 						& GDK_WINDOW_STATE_MAXIMIZED) == 0)
 		{
 			gtk_window_get_size(GTK_WINDOW(cnnhld->cnnwin), &width, &height);
+#if GTK_VERSION == 3
+			gtk_widget_get_preferred_size(priv->toolbar, &req, NULL);
+#elif GTK_VERSION == 2
 			gtk_widget_size_request(priv->toolbar, &req);
+#endif
 			if (remmina_pref.hide_connection_toolbar)
 			{
 				gtk_widget_hide(priv->toolbar);
@@ -1442,15 +1540,37 @@
 	return FALSE;
 }
 
+#if GTK_VERSION == 3
 static gboolean remmina_connection_window_on_leave(GtkWidget* widget, GdkEventCrossing* event, RemminaConnectionHolder* cnnhld)
 {
+	GdkDisplay *display;
+	GdkDeviceManager *manager;
+	GdkDevice *device = NULL;
+	
 	if (event->detail == GDK_NOTIFY_VIRTUAL || event->detail == GDK_NOTIFY_NONLINEAR
 			|| event->detail == GDK_NOTIFY_NONLINEAR_VIRTUAL)
 	{
+		display = gtk_widget_get_display(widget);
+		manager = gdk_display_get_device_manager(display);
+		device = gdk_device_manager_get_client_pointer(manager);
+		if (device != NULL)
+		{
+			gdk_device_ungrab(device, GDK_CURRENT_TIME);
+		}
+	}
+	return FALSE;
+}
+#elif GTK_VERSION == 2
+static gboolean remmina_connection_window_on_leave(GtkWidget* widget, GdkEventCrossing* event, RemminaConnectionHolder* cnnhld)
+{
+	if (event->detail == GDK_NOTIFY_VIRTUAL || event->detail == GDK_NOTIFY_NONLINEAR
+		|| event->detail == GDK_NOTIFY_NONLINEAR_VIRTUAL)
+	{
 		gdk_keyboard_ungrab(GDK_CURRENT_TIME);
 	}
 	return FALSE;
 }
+#endif
 
 static gboolean remmina_connection_holder_toolbar_scroll(GtkWidget* widget, GdkEventScroll* event,
 		RemminaConnectionHolder* cnnhld)
@@ -1477,6 +1597,22 @@
 				return TRUE;
 			}
 			break;
+#ifdef GDK_SCROLL_SMOOTH
+		case GDK_SCROLL_SMOOTH:
+			if (event->delta_y < 0 && opacity > 0)
+                        {
+                                remmina_file_set_int(cnnobj->remmina_file, "toolbar_opacity", opacity - 1);
+                                remmina_connection_holder_update_toolbar_opacity(cnnhld);
+                                return TRUE;
+                        }
+			if (event->delta_y > 0 && opacity < TOOLBAR_OPACITY_LEVEL)
+                        {
+                                remmina_file_set_int(cnnobj->remmina_file, "toolbar_opacity", opacity + 1);
+                                remmina_connection_holder_update_toolbar_opacity(cnnhld);
+                                return TRUE;
+                        }
+                        break;
+#endif
 		default:
 			break;
 	}
@@ -1517,7 +1653,11 @@
 
 	if (priv->floating_toolbar)
 	{
+#if GTK_VERSION == 3
+		gtk_widget_get_preferred_size(priv->floating_toolbar, &req, NULL);
+#elif GTK_VERSION == 2
 		gtk_widget_size_request(priv->floating_toolbar, &req);
+#endif
 		gtk_window_get_position(GTK_WINDOW(priv->floating_toolbar), NULL, &y);
 		gtk_window_move(GTK_WINDOW(priv->floating_toolbar), event->x + MAX(0, (event->width - req.width) / 2), y);
 
@@ -1565,14 +1705,22 @@
 	/* This has to be a popup window to become visible in fullscreen mode */
 	window = gtk_window_new(GTK_WINDOW_POPUP);
 
+#if GTK_VERSION == 3
+	vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);
+#elif GTK_VERSION == 2
 	vbox = gtk_vbox_new(FALSE, 0);
+#endif
 	gtk_widget_show(vbox);
 	gtk_container_add(GTK_CONTAINER(window), vbox);
 
 	widget = remmina_connection_holder_create_toolbar(cnnhld, mode);
 	gtk_box_pack_start(GTK_BOX(vbox), widget, FALSE, FALSE, 0);
 
+#if GTK_VERSION == 3
+	hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
+#elif GTK_VERSION == 2
 	hbox = gtk_hbox_new(FALSE, 0);
+#endif
 	gtk_widget_show(hbox);
 	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);
 
@@ -1749,7 +1897,11 @@
 	GtkWidget* widget;
 	GtkWidget* button;
 
+#if GTK_VERSION == 3
+	hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 4);
+#elif GTK_VERSION == 2
 	hbox = gtk_hbox_new(FALSE, 4);
+#endif
 	gtk_widget_show(hbox);
 
 	widget = gtk_image_new_from_icon_name(remmina_file_get_icon_name(cnnobj->remmina_file), GTK_ICON_SIZE_MENU);
@@ -1908,8 +2060,17 @@
 	gint srcpagenum;
 	GdkWindow* window;
 
-	srccnnwin = REMMINA_CONNECTION_WINDOW(gtk_widget_get_toplevel(GTK_WIDGET(notebook)));
+#if GTK_VERSION == 3
+	GdkDeviceManager* manager;
+	GdkDevice* device = NULL;
+
+	manager = gdk_display_get_device_manager(gdk_display_get_default());
+	device = gdk_device_manager_get_client_pointer(manager);
+	window = gdk_device_get_window_at_position(device, &x, &y);
+#elif GTK_VERSION == 2
 	window = gdk_display_get_window_at_pointer(gdk_display_get_default(), &x, &y);
+#endif
+	srccnnwin = REMMINA_CONNECTION_WINDOW(gtk_widget_get_toplevel(GTK_WIDGET(notebook)));
 	dstcnnwin = REMMINA_CONNECTION_WINDOW(remmina_widget_pool_find_by_window(REMMINA_TYPE_CONNECTION_WINDOW, window));
 
 	if (srccnnwin == dstcnnwin)
@@ -1971,7 +2132,11 @@
 	cnnhld->cnnwin = REMMINA_CONNECTION_WINDOW(window);
 
 	/* Create the vbox container */
+#if GTK_VERSION == 3
+	vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);
+#elif GTK_VERSION == 2
 	vbox = gtk_vbox_new(FALSE, 0);
+#endif
 	gtk_widget_show(vbox);
 	gtk_container_add(GTK_CONTAINER(window), vbox);
 
diff -urN remmina/src/remmina_external_tools.c remmina/src/remmina_external_tools.c
--- remmina/src/remmina_external_tools.c	1970-01-01 10:00:00.000000000 +1000
+++ remmina/src/remmina_external_tools.c	2014-01-08 02:31:52.000000000 +1100
@@ -0,0 +1,109 @@
+#include <gtk/gtk.h>
+#include <glib/gi18n.h>
+#include <glib/gstdio.h>
+#include <stdlib.h>
+#include "remmina/types.h"
+#include "remmina_public.h"
+#include "remmina_external_tools.h"
+
+typedef struct _RemminaExternalTools
+{
+	gchar remminafilename[MAX_PATH_LEN];
+	gchar scriptfilename[MAX_PATH_LEN];
+} RemminaExternalTools;
+
+void view_popup_menu_onDoSomething (GtkWidget *menuitem, gpointer userdata)
+{
+	/* we passed the view as userdata when we connected the signal */
+	RemminaExternalTools *ret = (RemminaExternalTools *)userdata;
+	//gchar* filename_remmina = ret->remminafilename;
+	//gchar* filename_script = ret->scriptfilename;
+
+	remmina_external_tools_launcher(ret->remminafilename,ret->scriptfilename);
+}
+
+gboolean remmina_external_tools_from_filename(RemminaMain *remminamain,gchar* remminafilename)
+{
+	GtkWidget *menu, *menuitem;
+	menu = gtk_menu_new();
+	gchar dirname[MAX_PATH_LEN];
+	gchar filename[MAX_PATH_LEN];
+	GDir* dir;
+	const gchar* name;
+	GNode* root;
+	root = g_node_new(NULL);
+
+	g_snprintf(dirname, MAX_PATH_LEN, "%s/.remmina/external_tools", g_get_home_dir());
+	dir = g_dir_open(dirname, 0, NULL);
+
+	if (dir == NULL)
+		return FALSE;
+
+	while ((name = g_dir_read_name(dir)) != NULL)
+	{
+		if (!g_str_has_prefix(name, "remmina_"))
+			continue;
+		g_snprintf(filename, MAX_PATH_LEN, "%s/%s", dirname, name);
+		RemminaExternalTools *ret;
+		ret = (RemminaExternalTools *)malloc(sizeof(RemminaExternalTools));
+		strcpy(ret->remminafilename,remminafilename);
+		strcpy(ret->scriptfilename,filename);
+		menuitem = gtk_menu_item_new_with_label(strndup(name + 8, strlen(name) -8));
+		g_signal_connect(menuitem, "activate", (GCallback) view_popup_menu_onDoSomething, ret);
+
+		//g_signal_connect(menuitem, "activate",
+		//                  (GCallback) view_popup_menu_onDoSomething, treeview);
+
+		gtk_menu_shell_append(GTK_MENU_SHELL(menu), menuitem);
+	}
+	g_dir_close(dir);
+
+	gtk_widget_show_all(menu);
+
+	/* Note: event can be NULL here when called from view_onPopupMenu;
+	*  gdk_event_get_time() accepts a NULL argument
+	*/
+	gtk_menu_popup(GTK_MENU(menu), NULL, NULL, NULL, NULL,0,0);
+
+	return TRUE;
+}
+
+gboolean remmina_external_tools_launcher(const gchar* filename,const gchar* scriptname)
+{
+	RemminaFile *remminafile;
+	gchar launcher[MAX_PATH_LEN];
+	g_snprintf(launcher, MAX_PATH_LEN, "%s/.remmina/external_tools/launcher.sh", g_get_home_dir());
+
+	remminafile = remmina_file_load(filename);
+	GHashTableIter iter;
+	const gchar *key, *value;
+	g_hash_table_iter_init(&iter, remminafile->settings);
+	while (g_hash_table_iter_next(&iter, (gpointer*) &key, (gpointer*) &value))
+	{
+		const char *env_format = "%s=%s";
+		const size_t len = strlen(key) +strlen(value) + strlen(env_format);
+		char *env = (char *) malloc(len);
+		if (env == NULL)
+		{
+			return -1;
+		}
+
+		int retval = snprintf(env, len, env_format, key,value);
+		if (retval < 0 || (size_t) retval >= len)
+		{
+			/* Handle error */
+		}
+
+		if (putenv(env) != 0)
+		{
+			free(env);
+		}
+	}
+	const size_t cmdlen = strlen(launcher) +strlen(scriptname) + 2;
+	gchar *cmd = (gchar *)malloc(cmdlen);
+	g_snprintf(cmd, cmdlen, "%s %s", launcher, scriptname);
+	system(cmd);
+	free(cmd);
+
+	return TRUE;
+}
diff -urN remmina/src/remmina_external_tools.h remmina/src/remmina_external_tools.h
--- remmina/src/remmina_external_tools.h	1970-01-01 10:00:00.000000000 +1000
+++ remmina/src/remmina_external_tools.h	2014-01-08 02:31:52.000000000 +1100
@@ -0,0 +1,37 @@
+/*
+ * Remmina - The GTK+ Remote Desktop Client
+ * Copyright (C) 2009 - Vic Lee
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __REMMINAEXTERNALTOOLS_H__
+#define __REMMINAEXTERNALTOOLS_H__
+
+#include <gtk/gtk.h>
+#include "remmina_file.h"
+#include "remmina_main.h"
+
+G_BEGIN_DECLS
+
+/* Open a new connection window for a .remmina file */
+gboolean remmina_external_tools_from_filename(RemminaMain *remminamain,gchar* filename);
+gboolean remmina_external_tools_launcher(const gchar* filename,const gchar* scriptname);
+
+G_END_DECLS
+
+#endif  /* __REMMINAEXTERNALTOOLS_H__  */
+
diff -urN remmina/src/remmina_file.c remmina/src/remmina_file.c
--- remmina/src/remmina_file.c	2012-02-11 05:54:23.000000000 +1100
+++ remmina/src/remmina_file.c	2014-01-08 02:31:52.000000000 +1100
@@ -22,6 +22,7 @@
 #include <glib/gi18n.h>
 #include <glib/gstdio.h>
 #include <stdlib.h>
+#include "config.h"
 #include "remmina_public.h"
 #include "remmina_pref.h"
 #include "remmina_crypt.h"
@@ -31,12 +32,6 @@
 #define MIN_WINDOW_WIDTH 10
 #define MIN_WINDOW_HEIGHT 10
 
-struct _RemminaFile
-{
-	gchar *filename;
-	GHashTable *settings;
-};
-
 typedef struct _RemminaSetting
 {
 	const gchar *setting;
@@ -405,6 +400,11 @@
 
 void remmina_file_update_screen_resolution(RemminaFile *remminafile)
 {
+#if GTK_VERSION == 3
+	GdkDisplay *display;
+	GdkDeviceManager *device_manager;
+	GdkDevice *device;
+#endif
 	GdkScreen *screen;
 	gchar *pos;
 	gchar *resolution;
@@ -415,7 +415,14 @@
 	resolution = g_strdup(remmina_file_get_string(remminafile, "resolution"));
 	if (resolution == NULL || strchr(resolution, 'x') == NULL)
 	{
+#if GTK_VERSION == 3
+		display = gdk_display_get_default();
+		device_manager = gdk_display_get_device_manager(display);
+		device = gdk_device_manager_get_client_pointer(device_manager);
+		gdk_device_get_position(device, &screen, &x, &y);
+#elif GTK_VERSION == 2
 		gdk_display_get_pointer(gdk_display_get_default(), &screen, &x, &y, NULL);
+#endif
 		monitor = gdk_screen_get_monitor_at_point(screen, x, y);
 		gdk_screen_get_monitor_geometry(screen, monitor, &rect);
 		remmina_file_set_int(remminafile, "resolution_width", rect.width);
diff -urN remmina/src/remmina_file.h remmina/src/remmina_file.h
--- remmina/src/remmina_file.h	2012-02-11 05:54:23.000000000 +1100
+++ remmina/src/remmina_file.h	2014-01-08 02:31:52.000000000 +1100
@@ -25,6 +25,12 @@
 
 G_BEGIN_DECLS
 
+struct _RemminaFile
+{
+	gchar *filename;
+	GHashTable *settings;
+};
+
 enum
 {
 	SSH_AUTH_PASSWORD, SSH_AUTH_PUBLICKEY, SSH_AUTH_AUTO_PUBLICKEY
diff -urN remmina/src/remmina_file_editor.c remmina/src/remmina_file_editor.c
--- remmina/src/remmina_file_editor.c	2012-02-11 05:54:23.000000000 +1100
+++ remmina/src/remmina_file_editor.c	2014-01-08 23:32:47.550426079 +1100
@@ -195,7 +195,11 @@
 	GtkWidget* table;
 	GtkWidget* widget;
 
+#if GTK_VERSION == 3
+	tablabel = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
+#elif GTK_VERSION == 2
 	tablabel = gtk_hbox_new(FALSE, 0);
+#endif
 	gtk_widget_show(tablabel);
 
 	widget = gtk_image_new_from_stock(stock_id, GTK_ICON_SIZE_MENU);
@@ -206,7 +210,11 @@
 	gtk_box_pack_start(GTK_BOX(tablabel), widget, FALSE, FALSE, 0);
 	gtk_widget_show(widget);
 
+#if GTK_VERSION == 3
+	tabbody = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);
+#elif GTK_VERSION == 2
 	tabbody = gtk_vbox_new(FALSE, 0);
+#endif
 	gtk_widget_show(tabbody);
 	gtk_notebook_append_page(GTK_NOTEBOOK(gfe->priv->config_container), tabbody, tablabel);
 
@@ -354,7 +362,11 @@
 	{
 		gfe->priv->avahi_service_type = (const gchar*) setting->opt1;
 
+#if GTK_VERSION == 3
+		hbox = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 0);
+#elif GTK_VERSION == 2
 		hbox = gtk_hbox_new (FALSE, 0);
+#endif
 		gtk_widget_show(hbox);
 		gtk_box_pack_start (GTK_BOX (hbox), widget, TRUE, TRUE, 0);
 
@@ -433,7 +445,11 @@
 	gtk_table_attach_defaults(GTK_TABLE(table), widget, 1, 2, row, row + 1);
 	gfe->priv->resolution_auto_radio = widget;
 
-	hbox = gtk_hbox_new(FALSE, 0);
+#if GTK_VERSION == 3
+	hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
+#elif GTK_VERSION == 2
+	hbox = gtk_hbox_new (FALSE, 0);
+#endif
 	gtk_widget_show(hbox);
 	gtk_table_attach_defaults(GTK_TABLE(table), hbox, 1, 2, row + 1, row + 2);
 
@@ -556,7 +572,11 @@
 	gtk_misc_set_alignment(GTK_MISC(widget), 0.0, 0.5);
 	gtk_table_attach(GTK_TABLE(table), widget, col, col + 1, row, row + 1, GTK_FILL, 0, 0, 0);
 
+#if GTK_VERSION == 3
+	hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
+#elif GTK_VERSION == 2
 	hbox = gtk_hbox_new(FALSE, 0);
+#endif
 	gtk_widget_show(hbox);
 	gtk_table_attach_defaults(GTK_TABLE(table), hbox, col + 1, col + 2, row, row + 1);
 
@@ -594,7 +614,11 @@
 		{
 			if (hbox == NULL)
 			{
-				hbox = gtk_hbox_new(TRUE, 0);
+#if GTK_VERSION == 3
+				hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
+#elif GTK_VERSION == 2
+				hbox = gtk_hbox_new(FALSE, 0);
+#endif
 				gtk_widget_show(hbox);
 				gtk_table_attach_defaults(GTK_TABLE(table), hbox, 0, 2, row, row + 1);
 			}
@@ -734,7 +758,11 @@
 		table = remmina_file_editor_create_notebook_tab (gfe, GTK_STOCK_DIALOG_AUTHENTICATION,
 				"SSH", 9, 3);
 
-		hbox = gtk_hbox_new (TRUE, 0);
+#if GTK_VERSION == 3
+		hbox = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 0);
+#elif GTK_VERSION == 2
+		hbox = gtk_hbox_new(FALSE, 0);
+#endif
 		gtk_widget_show(hbox);
 		gtk_table_attach_defaults (GTK_TABLE(table), hbox, 0, 3, 0, 1);
 		row++;
diff -urN remmina/src/remmina_ftp_client.c remmina/src/remmina_ftp_client.c
--- remmina/src/remmina_ftp_client.c	2012-02-11 05:54:23.000000000 +1100
+++ remmina/src/remmina_ftp_client.c	2014-01-08 02:31:52.000000000 +1100
@@ -23,6 +23,7 @@
 #include <gtk/gtk.h>
 #include <glib/gi18n.h>
 #include <glib/gstdio.h>
+#include "config.h"
 #include "remmina_public.h"
 #include "remmina_pref.h"
 #include "remmina_marshals.h"
@@ -749,7 +750,11 @@
 	GtkWidget *image;
 	gint i = 0;
 
+#if GTK_VERSION == 3
+	box = gtk_button_box_new(GTK_ORIENTATION_HORIZONTAL);
+#elif GTK_VERSION == 2
 	box = gtk_hbutton_box_new();
+#endif
 	gtk_widget_show(box);
 	gtk_button_box_set_layout(GTK_BUTTON_BOX(box), GTK_BUTTONBOX_START);
 	gtk_box_pack_start(GTK_BOX(client), box, FALSE, TRUE, 0);
@@ -849,14 +854,22 @@
 	remmina_ftp_client_create_toolbar(client);
 
 	/* The Paned to separate File List and Task List */
+#if GTK_VERSION == 3
+	vpaned = gtk_paned_new(GTK_ORIENTATION_VERTICAL);
+#elif GTK_VERSION == 2
 	vpaned = gtk_vpaned_new();
+#endif
 	gtk_widget_show(vpaned);
 	gtk_box_pack_start(GTK_BOX(client), vpaned, TRUE, TRUE, 0);
 
 	priv->vpaned = vpaned;
 
 	/* Remote */
+#if GTK_VERSION == 3
+	vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);
+#elif GTK_VERSION == 2
 	vbox = gtk_vbox_new(FALSE, 0);
+#endif
 	gtk_widget_show(vbox);
 	gtk_paned_pack1(GTK_PANED(vpaned), vbox, TRUE, FALSE);
 
diff -urN remmina/src/remmina_icon.c remmina/src/remmina_icon.c
--- remmina/src/remmina_icon.c	2012-02-11 05:54:23.000000000 +1100
+++ remmina/src/remmina_icon.c	2014-01-08 02:31:52.000000000 +1100
@@ -394,8 +394,10 @@
 	{
 #ifdef HAVE_LIBAPPINDICATOR
 		remmina_icon.icon = app_indicator_new ("remmina-icon", "remmina", APP_INDICATOR_CATEGORY_OTHER);
+		app_indicator_set_icon_theme_path (remmina_icon.icon, REMMINA_DATADIR G_DIR_SEPARATOR_S "icons");
 
 		app_indicator_set_status (remmina_icon.icon, APP_INDICATOR_STATUS_ACTIVE);
+		app_indicator_set_title (remmina_icon.icon, "Remmina");
 		remmina_icon_populate_menu ();
 #else
 		remmina_icon.icon = gtk_status_icon_new_from_icon_name("remmina");
diff -urN remmina/src/remmina_init_dialog.c remmina/src/remmina_init_dialog.c
--- remmina/src/remmina_init_dialog.c	2012-02-11 05:54:23.000000000 +1100
+++ remmina/src/remmina_init_dialog.c	2014-01-08 02:31:52.000000000 +1100
@@ -20,6 +20,7 @@
 
 #include <gtk/gtk.h>
 #include <glib/gi18n.h>
+#include "config.h"
 #include "remmina_widget_pool.h"
 #include "remmina_init_dialog.h"
 
@@ -44,7 +45,7 @@
 
 static void remmina_init_dialog_init(RemminaInitDialog *dialog)
 {
-	GtkWidget *hbox;
+	GtkWidget *hbox = NULL;
 	GtkWidget *widget;
 
 	dialog->image = NULL;
@@ -73,7 +74,11 @@
 	/**** Create the dialog content from here ****/
 
 	/* Create top-level hbox */
+#if GTK_VERSION == 3
+	hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 4);
+#elif GTK_VERSION == 2
 	hbox = gtk_hbox_new(FALSE, 4);
+#endif
 	gtk_widget_show(hbox);
 	gtk_container_set_border_width(GTK_CONTAINER(hbox), 15);
 	gtk_box_pack_start(GTK_BOX(gtk_dialog_get_content_area(GTK_DIALOG(dialog))), hbox, TRUE, TRUE, 0);
@@ -85,7 +90,11 @@
 	dialog->image = widget;
 
 	/* Create vbox for other dialog content */
+#if GTK_VERSION == 3
+	widget = gtk_box_new(GTK_ORIENTATION_VERTICAL, 4);
+#elif GTK_VERSION == 2
 	widget = gtk_vbox_new(FALSE, 4);
+#endif
 	gtk_widget_show(widget);
 	gtk_box_pack_start(GTK_BOX(hbox), widget, TRUE, TRUE, 4);
 	dialog->content_vbox = widget;
@@ -420,6 +429,88 @@
 
 	return status;
 }
+gint remmina_init_dialog_certificate_changed(RemminaInitDialog* dialog, const gchar* subject, const gchar* issuer, const gchar* new_fingerprint, const gchar* old_fingerprint)
+{
+	gint status;
+	GtkWidget* table;
+	GtkWidget* widget;
+
+	gtk_label_set_text(GTK_LABEL(dialog->status_label), "Certificate Changed! Details:");
+
+	/* Create table */
+	table = gtk_table_new(6, 2, FALSE);
+	gtk_widget_show(table);
+	gtk_table_set_row_spacings(GTK_TABLE(table), 8);
+	gtk_table_set_col_spacings(GTK_TABLE(table), 8);
+
+	/* Icon */
+	gtk_image_set_from_stock(GTK_IMAGE(dialog->image), GTK_STOCK_DIALOG_AUTHENTICATION, GTK_ICON_SIZE_DIALOG);
+
+	/* Entries */
+	widget = gtk_label_new(_("Subject:"));
+	gtk_misc_set_alignment(GTK_MISC(widget), 0.0, 0.5);
+	gtk_widget_show(widget);
+	gtk_table_attach(GTK_TABLE(table), widget, 0, 1, 0, 1, GTK_FILL, 0, 0, 0);
+
+	widget = gtk_label_new(subject);
+	gtk_misc_set_alignment(GTK_MISC(widget), 0.0, 0.5);
+	gtk_widget_show(widget);
+	gtk_table_attach(GTK_TABLE(table), widget, 1, 2, 0, 1, GTK_FILL, 0, 0, 0);
+
+	widget = gtk_label_new(_("Issuer:"));
+	gtk_misc_set_alignment(GTK_MISC(widget), 0.0, 0.5);
+	gtk_widget_show(widget);
+	gtk_table_attach(GTK_TABLE(table), widget, 0, 1, 1, 2, GTK_FILL, 0, 0, 0);
+
+	widget = gtk_label_new(issuer);
+	gtk_misc_set_alignment(GTK_MISC(widget), 0.0, 0.5);
+	gtk_widget_show(widget);
+	gtk_table_attach(GTK_TABLE(table), widget, 1, 2, 1, 2, GTK_FILL, 0, 0, 0);
+
+	widget = gtk_label_new(_("Old Fingerprint:"));
+	gtk_misc_set_alignment(GTK_MISC(widget), 0.0, 0.5);
+	gtk_widget_show(widget);
+	gtk_table_attach(GTK_TABLE(table), widget, 0, 1, 2, 3, GTK_FILL, 0, 0, 0);
+
+	widget = gtk_label_new(old_fingerprint);
+	gtk_misc_set_alignment(GTK_MISC(widget), 0.0, 0.5);
+	gtk_widget_show(widget);
+	gtk_table_attach(GTK_TABLE(table), widget, 1, 2, 2, 3, GTK_FILL, 0, 0, 0);
+
+	widget = gtk_label_new(_("New Fingerprint:"));
+	gtk_misc_set_alignment(GTK_MISC(widget), 0.0, 0.5);
+	gtk_widget_show(widget);
+	gtk_table_attach(GTK_TABLE(table), widget, 0, 1, 3, 4, GTK_FILL, 0, 0, 0);
+
+	widget = gtk_label_new(new_fingerprint);
+	gtk_misc_set_alignment(GTK_MISC(widget), 0.0, 0.5);
+	gtk_widget_show(widget);
+	gtk_table_attach(GTK_TABLE(table), widget, 1, 2, 3, 4, GTK_FILL, 0, 0, 0);
+
+	widget = gtk_label_new(_("Accept Changed Certificate?"));
+	gtk_misc_set_alignment(GTK_MISC(widget), 1.0, 0.5);
+	gtk_widget_show(widget);
+	gtk_table_attach(GTK_TABLE(table), widget, 0, 2, 4, 5, GTK_FILL, 0, 0, 0);
+
+	/* Pack it into the dialog */
+	gtk_box_pack_start(GTK_BOX(dialog->content_vbox), table, TRUE, TRUE, 4);
+
+	gtk_dialog_set_response_sensitive(GTK_DIALOG(dialog), GTK_RESPONSE_OK, TRUE);
+
+	dialog->mode = REMMINA_INIT_MODE_CERTIFICATE;
+
+	/* Now run it */
+	status = gtk_dialog_run(GTK_DIALOG(dialog));
+
+	if (status == GTK_RESPONSE_OK)
+	{
+
+	}
+
+	gtk_container_remove(GTK_CONTAINER(dialog->content_vbox), table);
+
+	return status;
+}
 
 static GtkWidget* remmina_init_dialog_create_file_button(GtkTable *table, const gchar *label, gint row, const gchar *filename)
 {
@@ -505,14 +596,18 @@
 
 static gint remmina_init_dialog_serverkey_confirm(RemminaInitDialog *dialog, const gchar *serverkey, const gchar *prompt)
 {
-	GtkWidget *vbox;
+	GtkWidget *vbox = NULL;
 	GtkWidget *widget;
 	gint ret;
 
 	gtk_label_set_text(GTK_LABEL(dialog->status_label), (dialog->status ? dialog->status : dialog->title));
 
 	/* Create vbox */
+#if GTK_VERSION == 3
+	vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 4);
+#elif GTK_VERSION == 2
 	vbox = gtk_vbox_new(FALSE, 4);
+#endif
 	gtk_widget_show(vbox);
 
 	/* Icon */
diff -urN remmina/src/remmina_init_dialog.h remmina/src/remmina_init_dialog.h
--- remmina/src/remmina_init_dialog.h	2012-02-11 05:54:23.000000000 +1100
+++ remmina/src/remmina_init_dialog.h	2014-01-08 02:31:52.000000000 +1100
@@ -78,6 +78,7 @@
 gint remmina_init_dialog_authuserpwd(RemminaInitDialog *dialog, gboolean want_domain, const gchar *default_username,
 		const gchar *default_domain, gboolean allow_save);
 gint remmina_init_dialog_certificate(RemminaInitDialog* dialog, const gchar* subject, const gchar* issuer, const gchar* fingerprint);
+gint remmina_init_dialog_certificate_changed(RemminaInitDialog* dialog, const gchar* subject, const gchar* issuer, const gchar* old_fingerprint, const gchar* new_fingerprint);
 gint remmina_init_dialog_authx509(RemminaInitDialog *dialog, const gchar *cacert, const gchar *cacrl, const gchar *clientcert,
 		const gchar *clientkey);
 gint remmina_init_dialog_serverkey_unknown(RemminaInitDialog *dialog, const gchar *serverkey);
diff -urN remmina/src/remmina_main.c remmina/src/remmina_main.c
--- remmina/src/remmina_main.c	2012-02-11 05:54:23.000000000 +1100
+++ remmina/src/remmina_main.c	2014-01-08 02:31:52.000000000 +1100
@@ -20,6 +20,7 @@
 
 #include "config.h"
 #include <gtk/gtk.h>
+#include <gdk/gdkkeysyms.h>
 #include <glib/gi18n.h>
 #include "remmina_string_array.h"
 #include "remmina_public.h"
@@ -35,34 +36,11 @@
 #include "remmina_log.h"
 #include "remmina_icon.h"
 #include "remmina_main.h"
+#include "remmina_external_tools.h"
 
 G_DEFINE_TYPE( RemminaMain, remmina_main, GTK_TYPE_WINDOW)
 
-struct _RemminaMainPriv
-{
-	GtkWidget *file_list;
-	GtkTreeModel *file_model;
-	GtkTreeModel *file_model_filter;
-	GtkTreeModel *file_model_sort;
-	GtkUIManager *uimanager;
-	GtkWidget *toolbar;
-	GtkWidget *statusbar;
-
-	GtkToolItem *quick_search_separator;
-	GtkToolItem *quick_search_item;
-	GtkWidget *quick_search_entry;
-
-	GtkTreeViewColumn *group_column;
-
-	GtkActionGroup *main_group;
-	GtkActionGroup *file_sensitive_group;
-
-	gboolean initialized;
 
-	gchar *selected_filename;
-	gchar *selected_name;
-	RemminaStringArray *expanded_group;
-};
 
 static void remmina_main_class_init(RemminaMainClass *klass)
 {
@@ -480,6 +458,11 @@
 	remmina_connection_window_open_from_filename(remminamain->priv->selected_filename);
 }
 
+static void remmina_main_action_connection_external_tools(GtkAction *action, RemminaMain *remminamain)
+{
+	remmina_external_tools_from_filename(remminamain, remminamain->priv->selected_filename);
+}
+
 static void remmina_main_file_editor_destroy(GtkWidget *widget, RemminaMain *remminamain)
 {
 	if (GTK_IS_WIDGET(remminamain))
@@ -853,6 +836,7 @@
 		"    <menuitem action='ConnectionCopy'/>"
 		"    <menuitem action='ConnectionEdit'/>"
 		"    <menuitem action='ConnectionDelete'/>"
+		"    <menuitem action='ConnectionExternalTools'/>"
 		"  </popup>"
 		"</ui>";
 
@@ -898,7 +882,12 @@
 { "ConnectionDelete", GTK_STOCK_DELETE, NULL, "<control>D", N_("Delete the selected remote desktop file"), G_CALLBACK(
 		remmina_main_action_connection_delete) },
 
-{ "ToolsExport", NULL, N_("Export"), NULL, NULL, G_CALLBACK(remmina_main_action_tools_export) } };
+{ "ToolsExport", NULL, N_("Export"), NULL, NULL, G_CALLBACK(remmina_main_action_tools_export) },
+
+{ "ConnectionExternalTools", NULL, N_("External Tools"), "<control>T", NULL,
+		G_CALLBACK(remmina_main_action_connection_external_tools) }
+
+};
 
 static const GtkToggleActionEntry remmina_main_ui_toggle_menu_entries[] =
 {
@@ -916,6 +905,62 @@
 { "ViewFileList", NULL, N_("List View"), NULL, NULL, REMMINA_VIEW_FILE_LIST },
 { "ViewFileTree", NULL, N_("Tree View"), NULL, NULL, REMMINA_VIEW_FILE_TREE } };
 
+static gboolean remmina_main_quickconnect(RemminaMain *remminamain)
+{
+	RemminaFile* remminafile;
+	gint index;
+	gchar* server;
+	gchar* protocol;
+
+	remminafile = remmina_file_new();
+	server = strdup(gtk_entry_get_text(GTK_ENTRY(remminamain->priv->quickconnect_server)));
+	index = gtk_combo_box_get_active(GTK_COMBO_BOX(remminamain->priv->quickconnect_protocol));
+
+	switch (index)
+	{
+		case 0:
+			protocol = "RDP";
+			break;
+		case 1:
+			protocol = "VNC";
+			break;
+		case 2:
+			protocol = "NX";
+			break;
+		case 3:
+			protocol = "SSH";
+			break;
+		default:
+			protocol = "RDP";
+			break;
+	}
+
+	remmina_file_set_string(remminafile, "sound", "off");
+	remmina_file_set_string(remminafile, "server", server);
+	remmina_file_set_string(remminafile, "name", server);
+	remmina_file_set_string(remminafile, "protocol", protocol);
+
+	remmina_connection_window_open_from_file(remminafile);
+
+	return FALSE;
+}
+static gboolean remmina_main_quickconnect_on_click(GtkWidget *widget, RemminaMain *remminamain)
+{
+	return remmina_main_quickconnect(remminamain);
+}
+static gboolean remmina_main_quickconnect_on_key_press(GtkWidget *widget, GdkEventKey *event, RemminaMain *remminamain)
+{
+#if GTK_VERSION == 3
+    if (event->type == GDK_KEY_PRESS && (event->keyval == GDK_KEY_Return || event->keyval == GDK_KEY_KP_Enter))
+#else
+    if (event->type == GDK_KEY_PRESS && (event->keyval == GDK_Return || event->keyval == GDK_KP_Enter))
+#endif
+    {
+		return remmina_main_quickconnect(remminamain);
+    }
+    return FALSE;
+}
+
 static gboolean remmina_main_file_list_on_button_press(GtkWidget *widget, GdkEventButton *event, RemminaMain *remminamain)
 {
 	GtkWidget *popup;
@@ -944,6 +989,27 @@
 		}
 	return FALSE;
 }
+static gboolean remmina_main_file_list_on_key_press(GtkWidget *widget, GdkEventKey *event, RemminaMain *remminamain)
+{
+#if GTK_VERSION == 3
+	if (event->type == GDK_KEY_PRESS && (event->keyval == GDK_KEY_Return || event->keyval == GDK_KEY_KP_Enter) && remminamain->priv->selected_filename)
+#else
+	if (event->type == GDK_KEY_PRESS && (event->keyval == GDK_Return || event->keyval == GDK_KP_Enter) && remminamain->priv->selected_filename)
+#endif
+	{
+		switch (remmina_pref.default_action)
+		{
+			case REMMINA_ACTION_EDIT:
+				remmina_main_action_connection_edit(NULL, remminamain);
+				break;
+			case REMMINA_ACTION_CONNECT:
+			default:
+				remmina_main_action_connection_connect(NULL, remminamain);
+				break;
+		}
+	}
+	return FALSE;
+}
 
 static void remmina_main_quick_search_on_icon_press(GtkEntry *entry, GtkEntryIconPosition icon_pos, GdkEvent *event,
 		RemminaMain *remminamain)
@@ -1048,6 +1114,9 @@
 	RemminaMainPriv *priv;
 	GtkWidget *vbox;
 	GtkWidget *menubar;
+	GtkWidget *hbox;
+	GtkWidget *quickconnect;
+	GtkWidget *tool_item;
 	GtkUIManager *uimanager;
 	GtkActionGroup *action_group;
 	GtkWidget *scrolledwindow;
@@ -1075,7 +1144,11 @@
 	}
 
 	/* Create the main container */
+#if GTK_VERSION == 3
+	vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);
+#elif GTK_VERSION == 2
 	vbox = gtk_vbox_new(FALSE, 0);
+#endif
 	gtk_container_add(GTK_CONTAINER(remminamain), vbox);
 	gtk_widget_show(vbox);
 
@@ -1120,14 +1193,60 @@
 	gtk_box_pack_start(GTK_BOX(vbox), menubar, FALSE, FALSE, 0);
 
 	priv->toolbar = gtk_ui_manager_get_widget(uimanager, "/ToolBar");
+#if GTK_VERSION == 3
+	gtk_style_context_add_class(gtk_widget_get_style_context(priv->toolbar), GTK_STYLE_CLASS_PRIMARY_TOOLBAR);
+#endif
 	gtk_box_pack_start(GTK_BOX(vbox), priv->toolbar, FALSE, FALSE, 0);
 
+	tool_item = gtk_ui_manager_get_widget(uimanager, "/ToolBar/ConnectionConnect");
+	gtk_tool_item_set_is_important (GTK_TOOL_ITEM(tool_item), TRUE);
+
+	tool_item = gtk_ui_manager_get_widget(uimanager, "/ToolBar/ConnectionNew");
+	gtk_tool_item_set_is_important (GTK_TOOL_ITEM(tool_item), TRUE);
+
 	remmina_main_create_quick_search(remminamain);
 
 	gtk_window_add_accel_group(GTK_WINDOW(remminamain), gtk_ui_manager_get_accel_group(uimanager));
 
 	gtk_action_group_set_sensitive(priv->file_sensitive_group, FALSE);
 
+	/* Add a Fast Connection box */
+#if GTK_VERSION == 3
+	hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
+#elif GTK_VERSION == 2
+	hbox = gtk_hbox_new(FALSE, 0);
+#endif
+
+	priv->quickconnect_protocol = gtk_combo_box_text_new();
+#if GTK_VERSION == 3
+	gtk_combo_box_text_append(GTK_COMBO_BOX_TEXT(priv->quickconnect_protocol), "RDP", "RDP");
+	gtk_combo_box_text_append(GTK_COMBO_BOX_TEXT(priv->quickconnect_protocol), "VNC", "VNC");
+	gtk_combo_box_text_append(GTK_COMBO_BOX_TEXT(priv->quickconnect_protocol), "NX", "NX");
+	gtk_combo_box_text_append(GTK_COMBO_BOX_TEXT(priv->quickconnect_protocol), "SSH", "SSH");
+#elif GTK_VERSION == 2
+	gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(priv->quickconnect_protocol), "RDP");
+	gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(priv->quickconnect_protocol), "VNC");
+	gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(priv->quickconnect_protocol), "NX");
+	gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(priv->quickconnect_protocol), "SSH");
+#endif
+	gtk_combo_box_set_active(GTK_COMBO_BOX(priv->quickconnect_protocol), 0);
+	gtk_widget_show(priv->quickconnect_protocol);
+	gtk_box_pack_start(GTK_BOX(hbox), priv->quickconnect_protocol, FALSE, FALSE, 0);
+
+	priv->quickconnect_server = gtk_entry_new();
+	gtk_entry_set_width_chars(GTK_ENTRY(priv->quickconnect_server), 25);
+	gtk_widget_show(priv->quickconnect_server);
+	gtk_box_pack_start(GTK_BOX(hbox), priv->quickconnect_server, FALSE, FALSE, 0);
+	g_signal_connect(G_OBJECT(priv->quickconnect_server), "key-press-event", G_CALLBACK(remmina_main_quickconnect_on_key_press), remminamain);
+
+	quickconnect = gtk_button_new_with_label("Connect !");
+	gtk_widget_show(quickconnect);
+	gtk_box_pack_start(GTK_BOX(hbox), quickconnect, FALSE, FALSE, 0);
+	g_signal_connect(G_OBJECT(quickconnect), "clicked", G_CALLBACK(remmina_main_quickconnect_on_click), remminamain);
+
+	gtk_container_add(GTK_CONTAINER(vbox), hbox);
+	gtk_widget_show(hbox);
+
 	/* Create the scrolled window for the file list */
 	scrolledwindow = gtk_scrolled_window_new(NULL, NULL);
 	gtk_widget_show(scrolledwindow);
@@ -1169,6 +1288,7 @@
 	gtk_tree_selection_set_select_function(gtk_tree_view_get_selection(GTK_TREE_VIEW(tree)), remmina_main_selection_func,
 			remminamain, NULL);
 	g_signal_connect(G_OBJECT(tree), "button-press-event", G_CALLBACK(remmina_main_file_list_on_button_press), remminamain);
+	g_signal_connect(G_OBJECT(tree), "key-press-event", G_CALLBACK(remmina_main_file_list_on_key_press), remminamain);
 
 	priv->file_list = tree;
 
diff -urN remmina/src/remmina_main.h remmina/src/remmina_main.h
--- remmina/src/remmina_main.h	2012-02-11 05:54:23.000000000 +1100
+++ remmina/src/remmina_main.h	2014-01-08 02:31:52.000000000 +1100
@@ -18,6 +18,8 @@
  * Boston, MA 02111-1307, USA.
  */
 
+#include "remmina_string_array.h"
+
 #ifndef __REMMINAMAIN_H__
 #define __REMMINAMAIN_H__
 
@@ -39,6 +41,35 @@
 	RemminaMainPriv *priv;
 } RemminaMain;
 
+struct _RemminaMainPriv
+{
+	GtkWidget *file_list;
+	GtkTreeModel *file_model;
+	GtkTreeModel *file_model_filter;
+	GtkTreeModel *file_model_sort;
+	GtkUIManager *uimanager;
+	GtkWidget *toolbar;
+	GtkWidget *statusbar;
+
+	GtkToolItem *quick_search_separator;
+	GtkToolItem *quick_search_item;
+	GtkWidget *quick_search_entry;
+
+	GtkWidget *quickconnect_protocol;
+	GtkWidget *quickconnect_server;
+
+	GtkTreeViewColumn *group_column;
+
+	GtkActionGroup *main_group;
+	GtkActionGroup *file_sensitive_group;
+
+	gboolean initialized;
+
+	gchar *selected_filename;
+	gchar *selected_name;
+	RemminaStringArray *expanded_group;
+};
+
 typedef struct _RemminaMainClass
 {
 	GtkWindowClass parent_class;
diff -urN remmina/src/remmina_plugin_manager.c remmina/src/remmina_plugin_manager.c
--- remmina/src/remmina_plugin_manager.c	2012-02-11 05:54:23.000000000 +1100
+++ remmina/src/remmina_plugin_manager.c	2014-01-08 02:31:52.000000000 +1100
@@ -86,6 +86,7 @@
 		remmina_protocol_widget_init_authpwd,
 		remmina_protocol_widget_init_authuserpwd,
 		remmina_protocol_widget_init_certificate,
+		remmina_protocol_widget_changed_certificate,
 		remmina_protocol_widget_init_get_username,
 		remmina_protocol_widget_init_get_password,
 		remmina_protocol_widget_init_get_domain,
@@ -137,6 +138,7 @@
 	if (!module)
 	{
 		g_print("Failed to load plugin: %s.\n", name);
+		g_print("Error: %s\n", g_module_error());
 		return;
 	}
 
diff -urN remmina/src/remmina_pref_dialog.c remmina/src/remmina_pref_dialog.c
--- remmina/src/remmina_pref_dialog.c	2012-02-11 05:54:23.000000000 +1100
+++ remmina/src/remmina_pref_dialog.c	2014-01-08 02:31:52.000000000 +1100
@@ -21,6 +21,7 @@
 #include <gtk/gtk.h>
 #include <glib/gi18n.h>
 #include <stdlib.h>
+#include "config.h"
 #include "remmina_public.h"
 #include "remmina_string_list.h"
 #include "remmina_widget_pool.h"
@@ -265,7 +266,11 @@
 	widget = gtk_label_new(pref_plugin->pref_label);
 	gtk_widget_show(widget);
 
+#if GTK_VERSION == 3
+	vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);
+#elif GTK_VERSION == 2
 	vbox = gtk_vbox_new(FALSE, 0);
+#endif
 	gtk_widget_show(vbox);
 	gtk_notebook_append_page(GTK_NOTEBOOK(priv->notebook), vbox, widget);
 
@@ -324,7 +329,11 @@
 	gtk_widget_show(tablabel);
 
 	/* Options body */
+#if GTK_VERSION == 3
+	vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);
+#elif GTK_VERSION == 2
 	vbox = gtk_vbox_new(FALSE, 0);
+#endif
 	gtk_widget_show(vbox);
 	gtk_notebook_append_page(GTK_NOTEBOOK(notebook), vbox, tablabel);
 
@@ -443,7 +452,11 @@
 	gtk_misc_set_alignment(GTK_MISC(widget), 0.0, 0.5);
 	gtk_table_attach_defaults(GTK_TABLE(table), widget, 0, 1, 11, 12);
 
+#if GTK_VERSION == 3
+	hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 2);
+#elif GTK_VERSION == 2
 	hbox = gtk_hbox_new(FALSE, 2);
+#endif
 	gtk_widget_show(hbox);
 	gtk_table_attach_defaults(GTK_TABLE(table), hbox, 1, 2, 11, 12);
 
@@ -465,7 +478,11 @@
 	gtk_widget_show(tablabel);
 
 	/* Resolutions body */
+#if GTK_VERSION == 3
+	vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 2);
+#elif GTK_VERSION == 2
 	vbox = gtk_vbox_new(FALSE, 2);
+#endif
 	gtk_widget_show(vbox);
 	gtk_container_set_border_width(GTK_CONTAINER(vbox), 8);
 	gtk_notebook_append_page(GTK_NOTEBOOK(notebook), vbox, tablabel);
@@ -484,7 +501,11 @@
 	gtk_widget_show(tablabel);
 
 	/* Applet body */
+#if GTK_VERSION == 3
+	vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);
+#elif GTK_VERSION == 2
 	vbox = gtk_vbox_new(FALSE, 0);
+#endif
 	gtk_widget_show(vbox);
 	gtk_notebook_append_page(GTK_NOTEBOOK(notebook), vbox, tablabel);
 
@@ -535,7 +556,11 @@
 	gtk_widget_show(tablabel);
 
 	/* Keyboard body */
+#if GTK_VERSION == 3
+	vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);
+#elif GTK_VERSION == 2
 	vbox = gtk_vbox_new(FALSE, 0);
+#endif
 	gtk_widget_show(vbox);
 	gtk_notebook_append_page(GTK_NOTEBOOK(notebook), vbox, tablabel);
 
@@ -581,7 +606,11 @@
 	gtk_misc_set_alignment(GTK_MISC(widget), 0.0, 0.5);
 	gtk_table_attach(GTK_TABLE(table), widget, 0, 1, 3, 4, GTK_FILL, 0, 0, 0);
 
+#if GTK_VERSION == 3
+	hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 2);
+#elif GTK_VERSION == 2
 	hbox = gtk_hbox_new(TRUE, 2);
+#endif
 	gtk_widget_show(hbox);
 	gtk_table_attach_defaults(GTK_TABLE(table), hbox, 1, 2, 3, 4);
 
@@ -650,7 +679,11 @@
 	gtk_widget_show(tablabel);
 
 	/* Terminal body */
+#if GTK_VERSION == 3
+	vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);
+#elif GTK_VERSION == 2
 	vbox = gtk_vbox_new(FALSE, 0);
+#endif
 	gtk_widget_show(vbox);
 	gtk_notebook_append_page(GTK_NOTEBOOK(notebook), vbox, tablabel);
 
@@ -715,7 +748,11 @@
 	gtk_misc_set_alignment(GTK_MISC(widget), 0.0, 0.5);
 	gtk_table_attach(GTK_TABLE(table), widget, 0, 1, 4, 5, GTK_FILL, 0, 0, 0);
 
+#if GTK_VERSION == 3
+	hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 2);
+#elif GTK_VERSION == 2
 	hbox = gtk_hbox_new(FALSE, 2);
+#endif
 	gtk_widget_show(hbox);
 	gtk_table_attach_defaults(GTK_TABLE(table), hbox, 1, 2, 4, 5);
 
@@ -736,7 +773,11 @@
 	gtk_box_pack_start(GTK_BOX(hbox), widget, TRUE, TRUE, 0);
 	priv->vte_shortcutkey_copy_chooser = widget;
 
+#if GTK_VERSION == 3
+	hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 2);
+#elif GTK_VERSION == 2
 	hbox = gtk_hbox_new(FALSE, 2);
+#endif
 	gtk_widget_show(hbox);
 	gtk_table_attach_defaults(GTK_TABLE(table), hbox, 1, 2, 5, 6);
 
diff -urN remmina/src/remmina_protocol_widget.c remmina/src/remmina_protocol_widget.c
--- remmina/src/remmina_protocol_widget.c	2012-02-11 05:54:23.000000000 +1100
+++ remmina/src/remmina_protocol_widget.c	2014-01-08 02:31:52.000000000 +1100
@@ -255,11 +255,28 @@
 
 gboolean remmina_protocol_widget_close_connection(RemminaProtocolWidget* gp)
 {
+#if GTK_VERSION == 3
+	GdkDisplay *display;
+	GdkDeviceManager *manager;
+	GdkDevice *device = NULL;
+#endif
+	gboolean retval;
+
 	if (!GTK_IS_WIDGET(gp) || gp->priv->closed)
 		return FALSE;
 
 	gp->priv->closed = TRUE;
+#if GTK_VERSION == 3
+	display = gtk_widget_get_display(GTK_WIDGET(gp));
+	manager = gdk_display_get_device_manager(display);
+	device = gdk_device_manager_get_client_pointer(manager);
+	if (device != NULL)
+	{
+		gdk_device_ungrab(device, GDK_CURRENT_TIME);
+	}
+#elif GTK_VERSION == 2
 	gdk_keyboard_ungrab(GDK_CURRENT_TIME);
+#endif
 
 	if (gp->priv->chat_window)
 	{
@@ -267,21 +284,23 @@
 		gp->priv->chat_window = NULL;
 	}
 
-#ifdef HAVE_LIBSSH
-	if (gp->priv->ssh_tunnel)
-	{
-		remmina_ssh_tunnel_free(gp->priv->ssh_tunnel);
-		gp->priv->ssh_tunnel = NULL;
-	}
-#endif
-
 	if (!gp->priv->plugin || !gp->priv->plugin->close_connection)
 	{
 		remmina_protocol_widget_emit_signal(gp, "disconnect");
 		return FALSE;
 	}
 
-	return gp->priv->plugin->close_connection(gp);
+	retval = gp->priv->plugin->close_connection(gp);
+
+	#ifdef HAVE_LIBSSH
+	if (gp->priv->ssh_tunnel)
+	{
+		remmina_ssh_tunnel_free(gp->priv->ssh_tunnel);
+		gp->priv->ssh_tunnel = NULL;
+	}
+	#endif
+
+	return retval;
 }
 
 static gboolean remmina_protocol_widget_emit_signal_timeout(gpointer user_data)
@@ -810,6 +829,10 @@
 {
 	return remmina_init_dialog_certificate(REMMINA_INIT_DIALOG(gp->priv->init_dialog), subject, issuer, fingerprint);
 }
+gint remmina_protocol_widget_changed_certificate(RemminaProtocolWidget *gp, const gchar* subject, const gchar* issuer, const gchar* new_fingerprint, const gchar* old_fingerprint)
+{
+	return remmina_init_dialog_certificate_changed(REMMINA_INIT_DIALOG(gp->priv->init_dialog), subject, issuer, new_fingerprint, old_fingerprint);
+}
 
 gchar* remmina_protocol_widget_init_get_username(RemminaProtocolWidget* gp)
 {
diff -urN remmina/src/remmina_protocol_widget.h remmina/src/remmina_protocol_widget.h
--- remmina/src/remmina_protocol_widget.h	2012-02-11 05:54:23.000000000 +1100
+++ remmina/src/remmina_protocol_widget.h	2014-01-08 02:31:52.000000000 +1100
@@ -108,6 +108,7 @@
 gint remmina_protocol_widget_init_authpwd(RemminaProtocolWidget *gp, RemminaAuthpwdType authpwd_type);
 gint remmina_protocol_widget_init_authuserpwd(RemminaProtocolWidget *gp, gboolean want_domain);
 gint remmina_protocol_widget_init_certificate(RemminaProtocolWidget* gp, const gchar* subject, const gchar* issuer, const gchar* fingerprint);
+gint remmina_protocol_widget_changed_certificate(RemminaProtocolWidget *gp, const gchar* subject, const gchar* issuer, const gchar* new_fingerprint, const gchar* old_fingerprint);
 gchar* remmina_protocol_widget_init_get_username(RemminaProtocolWidget *gp);
 gchar* remmina_protocol_widget_init_get_password(RemminaProtocolWidget *gp);
 gchar* remmina_protocol_widget_init_get_domain(RemminaProtocolWidget *gp);
diff -urN remmina/src/remmina_scaler.c remmina/src/remmina_scaler.c
--- remmina/src/remmina_scaler.c	2012-02-11 05:54:23.000000000 +1100
+++ remmina/src/remmina_scaler.c	2014-01-08 02:31:52.000000000 +1100
@@ -20,6 +20,7 @@
 
 #include <gtk/gtk.h>
 #include <glib/gi18n.h>
+#include "config.h"
 #include "remmina_chain_button.h"
 #include "remmina_scaler.h"
 
@@ -113,7 +114,7 @@
 static void remmina_scaler_init(RemminaScaler *scaler)
 {
 	RemminaScalerPriv *priv;
-	GtkWidget *widget;
+	GtkWidget *widget = NULL;
 
 	priv = g_new(RemminaScalerPriv, 1);
 	scaler->priv = priv;
@@ -123,14 +124,22 @@
 
 	gtk_table_resize(GTK_TABLE(scaler), 2, 2);
 
+#if GTK_VERSION == 3
+	widget = gtk_scale_new_with_range(GTK_ORIENTATION_HORIZONTAL, MIN_SCALE_VALUE, 1.0, 0.01);
+#elif GTK_VERSION == 2
 	widget = gtk_hscale_new_with_range(MIN_SCALE_VALUE, 1.0, 0.01);
+#endif
 	gtk_widget_show(widget);
 	gtk_widget_set_tooltip_text(widget, _("Horizontal scale"));
 	gtk_table_attach_defaults(GTK_TABLE(scaler), widget, 1, 2, 0, 1);
 	g_signal_connect(G_OBJECT(widget), "format-value", G_CALLBACK(remmina_scaler_format_scale_value), NULL);
 	priv->hscale_widget = widget;
 
+#if GTK_VERSION == 3
+	widget = gtk_scale_new_with_range(GTK_ORIENTATION_HORIZONTAL, MIN_SCALE_VALUE, 1.0, 0.01);
+#elif GTK_VERSION == 2
 	widget = gtk_hscale_new_with_range(MIN_SCALE_VALUE, 1.0, 0.01);
+#endif
 	gtk_widget_show(widget);
 	gtk_widget_set_tooltip_text(widget, _("Vertical scale"));
 	gtk_table_attach_defaults(GTK_TABLE(scaler), widget, 1, 2, 1, 2);
diff -urN remmina/src/remmina_scrolled_viewport.c remmina/src/remmina_scrolled_viewport.c
--- remmina/src/remmina_scrolled_viewport.c	2012-02-11 05:54:23.000000000 +1100
+++ remmina/src/remmina_scrolled_viewport.c	2014-01-08 02:31:52.000000000 +1100
@@ -19,6 +19,7 @@
  */
 
 #include <gtk/gtk.h>
+#include "config.h"
 #include "remmina_scrolled_viewport.h"
 #include "remmina_pref.h"
 
@@ -30,6 +31,10 @@
 	RemminaScrolledViewport *gsv;
 	GtkWidget *child;
 	GdkDisplay *display;
+#if GTK_VERSION == 3
+	GdkDeviceManager *device_manager;
+	GdkDevice  *pointer;
+#endif
 	GdkScreen *screen;
 	gint x, y, mx, my, w, h;
 	GtkAdjustment *adj;
@@ -49,7 +54,13 @@
 	display = gdk_display_get_default();
 	if (!display)
 		return FALSE;
+#if GTK_VERSION == 3
+	device_manager = gdk_display_get_device_manager (display);
+	pointer = gdk_device_manager_get_client_pointer (device_manager);
+	gdk_device_get_position(pointer, &screen, &x, &y);
+#elif GTK_VERSION == 2
 	gdk_display_get_pointer(display, &screen, &x, &y, NULL);
+#endif
 
 	w = gdk_screen_get_width(screen);
 	h = gdk_screen_get_height(screen);
@@ -58,7 +69,11 @@
 	if (mx != 0)
 	{
 		gint step = MAX(10, MIN(remmina_pref.auto_scroll_step, w / 5));
+#if GTK_VERSION == 3
+		adj = gtk_scrollable_get_hadjustment(GTK_SCROLLABLE(child));
+#elif GTK_VERSION == 2
 		adj = gtk_viewport_get_hadjustment(GTK_VIEWPORT(child));
+#endif
 		value = gtk_adjustment_get_value(GTK_ADJUSTMENT(adj)) + (gdouble)(mx * step);
 		value = MAX(0, MIN(value, gtk_adjustment_get_upper(GTK_ADJUSTMENT(adj)) - (gdouble) w + 2.0));
 		gtk_adjustment_set_value(GTK_ADJUSTMENT(adj), value);
@@ -66,7 +81,11 @@
 	if (my != 0)
 	{
 		gint step = MAX(10, MIN(remmina_pref.auto_scroll_step, h / 5));
+#if GTK_VERSION == 3
+		adj = gtk_scrollable_get_vadjustment(GTK_SCROLLABLE(child));
+#elif GTK_VERSION == 2
 		adj = gtk_viewport_get_vadjustment(GTK_VIEWPORT(child));
+#endif
 		value = gtk_adjustment_get_value(GTK_ADJUSTMENT(adj)) + (gdouble)(my * step);
 		value = MAX(0, MIN(value, gtk_adjustment_get_upper(GTK_ADJUSTMENT(adj)) - (gdouble) h + 2.0));
 		gtk_adjustment_set_value(GTK_ADJUSTMENT(adj), value);
diff -urN remmina/src/remmina_sftp_client.c remmina/src/remmina_sftp_client.c
--- remmina/src/remmina_sftp_client.c	2012-02-11 05:54:23.000000000 +1100
+++ remmina/src/remmina_sftp_client.c	2014-01-08 02:31:52.000000000 +1100
@@ -955,7 +955,11 @@
 			NULL);
 	gtk_container_set_border_width (GTK_CONTAINER (dialog), 4);
 
+#if GTK_VERSION == 3
+	hbox = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 4);
+#elif GTK_VERSION == 2
 	hbox = gtk_hbox_new (FALSE, 4);
+#endif
 	gtk_widget_show(hbox);
 	gtk_box_pack_start (GTK_BOX (gtk_dialog_get_content_area (GTK_DIALOG(dialog))),
 			hbox, TRUE, TRUE, 4);
@@ -964,7 +968,11 @@
 	gtk_widget_show(widget);
 	gtk_box_pack_start (GTK_BOX (hbox), widget, TRUE, TRUE, 4);
 
+#if GTK_VERSION == 3
+	vbox = gtk_box_new (GTK_ORIENTATION_VERTICAL, 4);
+#elif GTK_VERSION == 2
 	vbox = gtk_vbox_new (FALSE, 4);
+#endif
 	gtk_widget_show(vbox);
 	gtk_box_pack_start (GTK_BOX (hbox), vbox, TRUE, TRUE, 4);
 
diff -urN remmina/src/remmina_ssh.c remmina/src/remmina_ssh.c
--- remmina/src/remmina_ssh.c	2012-02-11 05:54:23.000000000 +1100
+++ remmina/src/remmina_ssh.c	2014-01-08 02:31:52.000000000 +1100
@@ -139,7 +139,7 @@
 			}
 		}
 	}
-	else
+	if (ret != SSH_AUTH_SUCCESS && authlist & SSH_AUTH_METHOD_PASSWORD)
 	{
 		ret = ssh_userauth_password (ssh->session, NULL, ssh->password);
 	}
diff -urN remmina/src/remmina_ssh_plugin.c remmina/src/remmina_ssh_plugin.c
--- remmina/src/remmina_ssh_plugin.c	2012-02-11 05:54:23.000000000 +1100
+++ remmina/src/remmina_ssh_plugin.c	2014-01-08 02:31:52.000000000 +1100
@@ -189,7 +189,11 @@
 	gpdata = g_new0 (RemminaPluginSshData, 1);
 	g_object_set_data_full (G_OBJECT(gp), "plugin-data", gpdata, g_free);
 
+#if GTK_VERSION == 3
+	hbox = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 0);
+#elif GTK_VERSION == 2
 	hbox = gtk_hbox_new (FALSE, 0);
+#endif
 	gtk_widget_show(hbox);
 	gtk_container_add(GTK_CONTAINER (gp), hbox);
 	g_signal_connect(G_OBJECT(hbox), "focus-in-event", G_CALLBACK(remmina_plugin_ssh_on_focus_in), gp);
@@ -205,7 +209,11 @@
 
 	remmina_plugin_service->protocol_plugin_register_hostkey (gp, vte);
 
+#if GTK_VERSION == 3
+	vscrollbar = gtk_scrollbar_new (GTK_ORIENTATION_VERTICAL, vte_terminal_get_adjustment (VTE_TERMINAL (vte)));
+#elif GTK_VERSION == 2
 	vscrollbar = gtk_vscrollbar_new (vte_terminal_get_adjustment (VTE_TERMINAL (vte)));
+#endif
 	gtk_widget_show(vscrollbar);
 	gtk_box_pack_start (GTK_BOX (hbox), vscrollbar, FALSE, TRUE, 0);
 }
diff -urN remmina/src/remmina_string_list.c remmina/src/remmina_string_list.c
--- remmina/src/remmina_string_list.c	2012-02-11 05:54:23.000000000 +1100
+++ remmina/src/remmina_string_list.c	2014-01-08 02:31:52.000000000 +1100
@@ -20,6 +20,7 @@
 
 #include <gtk/gtk.h>
 #include <string.h>
+#include "config.h"
 #include "remmina_public.h"
 #include "remmina_string_list.h"
 
@@ -206,7 +207,11 @@
 	gtk_tree_view_append_column(GTK_TREE_VIEW(gsl->list), column);
 
 	/* buttons packed into a vbox */
+#if GTK_VERSION == 3
+	vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 0);
+#elif GTK_VERSION == 2
 	vbox = gtk_vbox_new(FALSE, 0);
+#endif
 	gtk_widget_show(vbox);
 	gtk_table_attach(GTK_TABLE(gsl), vbox, 1, 2, 0, 3, 0, GTK_EXPAND | GTK_FILL, 0, 0);
 
diff -urN remmina-plugins/AUTHORS remmina-plugins/AUTHORS
--- remmina-plugins/AUTHORS	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins/AUTHORS	1970-01-01 10:00:00.000000000 +1000
@@ -1,4 +0,0 @@
-Please check the application About dialog or the official web site for a full list of authors.
-
-http://remmina.sourceforge.net/contact.shtml
-
diff -urN remmina-plugins/CMakeLists.txt remmina-plugins/CMakeLists.txt
--- remmina-plugins/CMakeLists.txt	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins/CMakeLists.txt	2014-01-08 02:31:52.000000000 +1100
@@ -32,6 +32,8 @@
 	target_link_libraries(remmina ${SSH_LIBRARIES})
 endif()
 
+find_required_package(LIBVNCSERVER)
+
 find_required_package(XKBFILE)
 
 if(LIBSSH_FOUND AND XKBFILE_FOUND)
@@ -53,9 +55,10 @@
 find_suggested_package(ZLIB)
 
 if(ZLIB_FOUND)
-	add_subdirectory(vnc/libvncserver)
 	add_subdirectory(vnc)
 endif()
 
-add_subdirectory(po)
+if(WITH_TRANSLATIONS)
+	add_subdirectory(po)
+endif()
 
diff -urN remmina-plugins/COPYING remmina-plugins/COPYING
--- remmina-plugins/COPYING	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins/COPYING	1970-01-01 10:00:00.000000000 +1000
@@ -1,340 +0,0 @@
-		    GNU GENERAL PUBLIC LICENSE
-		       Version 2, June 1991
-
- Copyright (C) 1989, 1991 Free Software Foundation, Inc.
-     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-			    Preamble
-
-  The licenses for most software are designed to take away your
-freedom to share and change it.  By contrast, the GNU General Public
-License is intended to guarantee your freedom to share and change free
-software--to make sure the software is free for all its users.  This
-General Public License applies to most of the Free Software
-Foundation's software and to any other program whose authors commit to
-using it.  (Some other Free Software Foundation software is covered by
-the GNU Library General Public License instead.)  You can apply it to
-your programs, too.
-
-  When we speak of free software, we are referring to freedom, not
-price.  Our General Public Licenses are designed to make sure that you
-have the freedom to distribute copies of free software (and charge for
-this service if you wish), that you receive source code or can get it
-if you want it, that you can change the software or use pieces of it
-in new free programs; and that you know you can do these things.
-
-  To protect your rights, we need to make restrictions that forbid
-anyone to deny you these rights or to ask you to surrender the rights.
-These restrictions translate to certain responsibilities for you if you
-distribute copies of the software, or if you modify it.
-
-  For example, if you distribute copies of such a program, whether
-gratis or for a fee, you must give the recipients all the rights that
-you have.  You must make sure that they, too, receive or can get the
-source code.  And you must show them these terms so they know their
-rights.
-
-  We protect your rights with two steps: (1) copyright the software, and
-(2) offer you this license which gives you legal permission to copy,
-distribute and/or modify the software.
-
-  Also, for each author's protection and ours, we want to make certain
-that everyone understands that there is no warranty for this free
-software.  If the software is modified by someone else and passed on, we
-want its recipients to know that what they have is not the original, so
-that any problems introduced by others will not reflect on the original
-authors' reputations.
-
-  Finally, any free program is threatened constantly by software
-patents.  We wish to avoid the danger that redistributors of a free
-program will individually obtain patent licenses, in effect making the
-program proprietary.  To prevent this, we have made it clear that any
-patent must be licensed for everyone's free use or not licensed at all.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.
-
-		    GNU GENERAL PUBLIC LICENSE
-   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
-
-  0. This License applies to any program or other work which contains
-a notice placed by the copyright holder saying it may be distributed
-under the terms of this General Public License.  The "Program", below,
-refers to any such program or work, and a "work based on the Program"
-means either the Program or any derivative work under copyright law:
-that is to say, a work containing the Program or a portion of it,
-either verbatim or with modifications and/or translated into another
-language.  (Hereinafter, translation is included without limitation in
-the term "modification".)  Each licensee is addressed as "you".
-
-Activities other than copying, distribution and modification are not
-covered by this License; they are outside its scope.  The act of
-running the Program is not restricted, and the output from the Program
-is covered only if its contents constitute a work based on the
-Program (independent of having been made by running the Program).
-Whether that is true depends on what the Program does.
-
-  1. You may copy and distribute verbatim copies of the Program's
-source code as you receive it, in any medium, provided that you
-conspicuously and appropriately publish on each copy an appropriate
-copyright notice and disclaimer of warranty; keep intact all the
-notices that refer to this License and to the absence of any warranty;
-and give any other recipients of the Program a copy of this License
-along with the Program.
-
-You may charge a fee for the physical act of transferring a copy, and
-you may at your option offer warranty protection in exchange for a fee.
-
-  2. You may modify your copy or copies of the Program or any portion
-of it, thus forming a work based on the Program, and copy and
-distribute such modifications or work under the terms of Section 1
-above, provided that you also meet all of these conditions:
-
-    a) You must cause the modified files to carry prominent notices
-    stating that you changed the files and the date of any change.
-
-    b) You must cause any work that you distribute or publish, that in
-    whole or in part contains or is derived from the Program or any
-    part thereof, to be licensed as a whole at no charge to all third
-    parties under the terms of this License.
-
-    c) If the modified program normally reads commands interactively
-    when run, you must cause it, when started running for such
-    interactive use in the most ordinary way, to print or display an
-    announcement including an appropriate copyright notice and a
-    notice that there is no warranty (or else, saying that you provide
-    a warranty) and that users may redistribute the program under
-    these conditions, and telling the user how to view a copy of this
-    License.  (Exception: if the Program itself is interactive but
-    does not normally print such an announcement, your work based on
-    the Program is not required to print an announcement.)
-
-These requirements apply to the modified work as a whole.  If
-identifiable sections of that work are not derived from the Program,
-and can be reasonably considered independent and separate works in
-themselves, then this License, and its terms, do not apply to those
-sections when you distribute them as separate works.  But when you
-distribute the same sections as part of a whole which is a work based
-on the Program, the distribution of the whole must be on the terms of
-this License, whose permissions for other licensees extend to the
-entire whole, and thus to each and every part regardless of who wrote it.
-
-Thus, it is not the intent of this section to claim rights or contest
-your rights to work written entirely by you; rather, the intent is to
-exercise the right to control the distribution of derivative or
-collective works based on the Program.
-
-In addition, mere aggregation of another work not based on the Program
-with the Program (or with a work based on the Program) on a volume of
-a storage or distribution medium does not bring the other work under
-the scope of this License.
-
-  3. You may copy and distribute the Program (or a work based on it,
-under Section 2) in object code or executable form under the terms of
-Sections 1 and 2 above provided that you also do one of the following:
-
-    a) Accompany it with the complete corresponding machine-readable
-    source code, which must be distributed under the terms of Sections
-    1 and 2 above on a medium customarily used for software interchange; or,
-
-    b) Accompany it with a written offer, valid for at least three
-    years, to give any third party, for a charge no more than your
-    cost of physically performing source distribution, a complete
-    machine-readable copy of the corresponding source code, to be
-    distributed under the terms of Sections 1 and 2 above on a medium
-    customarily used for software interchange; or,
-
-    c) Accompany it with the information you received as to the offer
-    to distribute corresponding source code.  (This alternative is
-    allowed only for noncommercial distribution and only if you
-    received the program in object code or executable form with such
-    an offer, in accord with Subsection b above.)
-
-The source code for a work means the preferred form of the work for
-making modifications to it.  For an executable work, complete source
-code means all the source code for all modules it contains, plus any
-associated interface definition files, plus the scripts used to
-control compilation and installation of the executable.  However, as a
-special exception, the source code distributed need not include
-anything that is normally distributed (in either source or binary
-form) with the major components (compiler, kernel, and so on) of the
-operating system on which the executable runs, unless that component
-itself accompanies the executable.
-
-If distribution of executable or object code is made by offering
-access to copy from a designated place, then offering equivalent
-access to copy the source code from the same place counts as
-distribution of the source code, even though third parties are not
-compelled to copy the source along with the object code.
-
-  4. You may not copy, modify, sublicense, or distribute the Program
-except as expressly provided under this License.  Any attempt
-otherwise to copy, modify, sublicense or distribute the Program is
-void, and will automatically terminate your rights under this License.
-However, parties who have received copies, or rights, from you under
-this License will not have their licenses terminated so long as such
-parties remain in full compliance.
-
-  5. You are not required to accept this License, since you have not
-signed it.  However, nothing else grants you permission to modify or
-distribute the Program or its derivative works.  These actions are
-prohibited by law if you do not accept this License.  Therefore, by
-modifying or distributing the Program (or any work based on the
-Program), you indicate your acceptance of this License to do so, and
-all its terms and conditions for copying, distributing or modifying
-the Program or works based on it.
-
-  6. Each time you redistribute the Program (or any work based on the
-Program), the recipient automatically receives a license from the
-original licensor to copy, distribute or modify the Program subject to
-these terms and conditions.  You may not impose any further
-restrictions on the recipients' exercise of the rights granted herein.
-You are not responsible for enforcing compliance by third parties to
-this License.
-
-  7. If, as a consequence of a court judgment or allegation of patent
-infringement or for any other reason (not limited to patent issues),
-conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot
-distribute so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you
-may not distribute the Program at all.  For example, if a patent
-license would not permit royalty-free redistribution of the Program by
-all those who receive copies directly or indirectly through you, then
-the only way you could satisfy both it and this License would be to
-refrain entirely from distribution of the Program.
-
-If any portion of this section is held invalid or unenforceable under
-any particular circumstance, the balance of the section is intended to
-apply and the section as a whole is intended to apply in other
-circumstances.
-
-It is not the purpose of this section to induce you to infringe any
-patents or other property right claims or to contest validity of any
-such claims; this section has the sole purpose of protecting the
-integrity of the free software distribution system, which is
-implemented by public license practices.  Many people have made
-generous contributions to the wide range of software distributed
-through that system in reliance on consistent application of that
-system; it is up to the author/donor to decide if he or she is willing
-to distribute software through any other system and a licensee cannot
-impose that choice.
-
-This section is intended to make thoroughly clear what is believed to
-be a consequence of the rest of this License.
-
-  8. If the distribution and/or use of the Program is restricted in
-certain countries either by patents or by copyrighted interfaces, the
-original copyright holder who places the Program under this License
-may add an explicit geographical distribution limitation excluding
-those countries, so that distribution is permitted only in or among
-countries not thus excluded.  In such case, this License incorporates
-the limitation as if written in the body of this License.
-
-  9. The Free Software Foundation may publish revised and/or new versions
-of the General Public License from time to time.  Such new versions will
-be similar in spirit to the present version, but may differ in detail to
-address new problems or concerns.
-
-Each version is given a distinguishing version number.  If the Program
-specifies a version number of this License which applies to it and "any
-later version", you have the option of following the terms and conditions
-either of that version or of any later version published by the Free
-Software Foundation.  If the Program does not specify a version number of
-this License, you may choose any version ever published by the Free Software
-Foundation.
-
-  10. If you wish to incorporate parts of the Program into other free
-programs whose distribution conditions are different, write to the author
-to ask for permission.  For software which is copyrighted by the Free
-Software Foundation, write to the Free Software Foundation; we sometimes
-make exceptions for this.  Our decision will be guided by the two goals
-of preserving the free status of all derivatives of our free software and
-of promoting the sharing and reuse of software generally.
-
-			    NO WARRANTY
-
-  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
-FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
-OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
-PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
-OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
-TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
-PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
-REPAIR OR CORRECTION.
-
-  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
-WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
-REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
-INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
-OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
-TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
-YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
-PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGES.
-
-		     END OF TERMS AND CONDITIONS
-
-	    How to Apply These Terms to Your New Programs
-
-  If you develop a new program, and you want it to be of the greatest
-possible use to the public, the best way to achieve this is to make it
-free software which everyone can redistribute and change under these terms.
-
-  To do so, attach the following notices to the program.  It is safest
-to attach them to the start of each source file to most effectively
-convey the exclusion of warranty; and each file should have at least
-the "copyright" line and a pointer to where the full notice is found.
-
-    <one line to give the program's name and a brief idea of what it does.>
-    Copyright (C) <year>  <name of author>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-
-
-Also add information on how to contact you by electronic and paper mail.
-
-If the program is interactive, make it output a short notice like this
-when it starts in an interactive mode:
-
-    Gnomovision version 69, Copyright (C) year  name of author
-    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
-    This is free software, and you are welcome to redistribute it
-    under certain conditions; type `show c' for details.
-
-The hypothetical commands `show w' and `show c' should show the appropriate
-parts of the General Public License.  Of course, the commands you use may
-be called something other than `show w' and `show c'; they could even be
-mouse-clicks or menu items--whatever suits your program.
-
-You should also get your employer (if you work as a programmer) or your
-school, if any, to sign a "copyright disclaimer" for the program, if
-necessary.  Here is a sample; alter the names:
-
-  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
-  `Gnomovision' (which makes passes at compilers) written by James Hacker.
-
-  <signature of Ty Coon>, 1 April 1989
-  Ty Coon, President of Vice
-
-This General Public License does not permit incorporating your program into
-proprietary programs.  If your program is a subroutine library, you may
-consider it more useful to permit linking proprietary applications with the
-library.  If this is what you want to do, use the GNU Library General
-Public License instead of this License.
diff -urN remmina-plugins/INSTALL remmina-plugins/INSTALL
--- remmina-plugins/INSTALL	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins/INSTALL	1970-01-01 10:00:00.000000000 +1000
@@ -1,237 +0,0 @@
-Installation Instructions
-*************************
-
-Copyright (C) 1994, 1995, 1996, 1999, 2000, 2001, 2002, 2004, 2005,
-2006, 2007 Free Software Foundation, Inc.
-
-This file is free documentation; the Free Software Foundation gives
-unlimited permission to copy, distribute and modify it.
-
-Basic Installation
-==================
-
-Briefly, the shell commands `./configure; make; make install' should
-configure, build, and install this package.  The following
-more-detailed instructions are generic; see the `README' file for
-instructions specific to this package.
-
-   The `configure' shell script attempts to guess correct values for
-various system-dependent variables used during compilation.  It uses
-those values to create a `Makefile' in each directory of the package.
-It may also create one or more `.h' files containing system-dependent
-definitions.  Finally, it creates a shell script `config.status' that
-you can run in the future to recreate the current configuration, and a
-file `config.log' containing compiler output (useful mainly for
-debugging `configure').
-
-   It can also use an optional file (typically called `config.cache'
-and enabled with `--cache-file=config.cache' or simply `-C') that saves
-the results of its tests to speed up reconfiguring.  Caching is
-disabled by default to prevent problems with accidental use of stale
-cache files.
-
-   If you need to do unusual things to compile the package, please try
-to figure out how `configure' could check whether to do them, and mail
-diffs or instructions to the address given in the `README' so they can
-be considered for the next release.  If you are using the cache, and at
-some point `config.cache' contains results you don't want to keep, you
-may remove or edit it.
-
-   The file `configure.ac' (or `configure.in') is used to create
-`configure' by a program called `autoconf'.  You need `configure.ac' if
-you want to change it or regenerate `configure' using a newer version
-of `autoconf'.
-
-The simplest way to compile this package is:
-
-  1. `cd' to the directory containing the package's source code and type
-     `./configure' to configure the package for your system.
-
-     Running `configure' might take a while.  While running, it prints
-     some messages telling which features it is checking for.
-
-  2. Type `make' to compile the package.
-
-  3. Optionally, type `make check' to run any self-tests that come with
-     the package.
-
-  4. Type `make install' to install the programs and any data files and
-     documentation.
-
-  5. You can remove the program binaries and object files from the
-     source code directory by typing `make clean'.  To also remove the
-     files that `configure' created (so you can compile the package for
-     a different kind of computer), type `make distclean'.  There is
-     also a `make maintainer-clean' target, but that is intended mainly
-     for the package's developers.  If you use it, you may have to get
-     all sorts of other programs in order to regenerate files that came
-     with the distribution.
-
-  6. Often, you can also type `make uninstall' to remove the installed
-     files again.
-
-Compilers and Options
-=====================
-
-Some systems require unusual options for compilation or linking that the
-`configure' script does not know about.  Run `./configure --help' for
-details on some of the pertinent environment variables.
-
-   You can give `configure' initial values for configuration parameters
-by setting variables in the command line or in the environment.  Here
-is an example:
-
-     ./configure CC=c99 CFLAGS=-g LIBS=-lposix
-
-   *Note Defining Variables::, for more details.
-
-Compiling For Multiple Architectures
-====================================
-
-You can compile the package for more than one kind of computer at the
-same time, by placing the object files for each architecture in their
-own directory.  To do this, you can use GNU `make'.  `cd' to the
-directory where you want the object files and executables to go and run
-the `configure' script.  `configure' automatically checks for the
-source code in the directory that `configure' is in and in `..'.
-
-   With a non-GNU `make', it is safer to compile the package for one
-architecture at a time in the source code directory.  After you have
-installed the package for one architecture, use `make distclean' before
-reconfiguring for another architecture.
-
-Installation Names
-==================
-
-By default, `make install' installs the package's commands under
-`/usr/local/bin', include files under `/usr/local/include', etc.  You
-can specify an installation prefix other than `/usr/local' by giving
-`configure' the option `--prefix=PREFIX'.
-
-   You can specify separate installation prefixes for
-architecture-specific files and architecture-independent files.  If you
-pass the option `--exec-prefix=PREFIX' to `configure', the package uses
-PREFIX as the prefix for installing programs and libraries.
-Documentation and other data files still use the regular prefix.
-
-   In addition, if you use an unusual directory layout you can give
-options like `--bindir=DIR' to specify different values for particular
-kinds of files.  Run `configure --help' for a list of the directories
-you can set and what kinds of files go in them.
-
-   If the package supports it, you can cause programs to be installed
-with an extra prefix or suffix on their names by giving `configure' the
-option `--program-prefix=PREFIX' or `--program-suffix=SUFFIX'.
-
-Optional Features
-=================
-
-Some packages pay attention to `--enable-FEATURE' options to
-`configure', where FEATURE indicates an optional part of the package.
-They may also pay attention to `--with-PACKAGE' options, where PACKAGE
-is something like `gnu-as' or `x' (for the X Window System).  The
-`README' should mention any `--enable-' and `--with-' options that the
-package recognizes.
-
-   For packages that use the X Window System, `configure' can usually
-find the X include and library files automatically, but if it doesn't,
-you can use the `configure' options `--x-includes=DIR' and
-`--x-libraries=DIR' to specify their locations.
-
-Specifying the System Type
-==========================
-
-There may be some features `configure' cannot figure out automatically,
-but needs to determine by the type of machine the package will run on.
-Usually, assuming the package is built to be run on the _same_
-architectures, `configure' can figure that out, but if it prints a
-message saying it cannot guess the machine type, give it the
-`--build=TYPE' option.  TYPE can either be a short name for the system
-type, such as `sun4', or a canonical name which has the form:
-
-     CPU-COMPANY-SYSTEM
-
-where SYSTEM can have one of these forms:
-
-     OS KERNEL-OS
-
-   See the file `config.sub' for the possible values of each field.  If
-`config.sub' isn't included in this package, then this package doesn't
-need to know the machine type.
-
-   If you are _building_ compiler tools for cross-compiling, you should
-use the option `--target=TYPE' to select the type of system they will
-produce code for.
-
-   If you want to _use_ a cross compiler, that generates code for a
-platform different from the build platform, you should specify the
-"host" platform (i.e., that on which the generated programs will
-eventually be run) with `--host=TYPE'.
-
-Sharing Defaults
-================
-
-If you want to set default values for `configure' scripts to share, you
-can create a site shell script called `config.site' that gives default
-values for variables like `CC', `cache_file', and `prefix'.
-`configure' looks for `PREFIX/share/config.site' if it exists, then
-`PREFIX/etc/config.site' if it exists.  Or, you can set the
-`CONFIG_SITE' environment variable to the location of the site script.
-A warning: not all `configure' scripts look for a site script.
-
-Defining Variables
-==================
-
-Variables not defined in a site shell script can be set in the
-environment passed to `configure'.  However, some packages may run
-configure again during the build, and the customized values of these
-variables may be lost.  In order to avoid this problem, you should set
-them in the `configure' command line, using `VAR=value'.  For example:
-
-     ./configure CC=/usr/local2/bin/gcc
-
-causes the specified `gcc' to be used as the C compiler (unless it is
-overridden in the site shell script).
-
-Unfortunately, this technique does not work for `CONFIG_SHELL' due to
-an Autoconf bug.  Until the bug is fixed you can use this workaround:
-
-     CONFIG_SHELL=/bin/bash /bin/bash ./configure CONFIG_SHELL=/bin/bash
-
-`configure' Invocation
-======================
-
-`configure' recognizes the following options to control how it operates.
-
-`--help'
-`-h'
-     Print a summary of the options to `configure', and exit.
-
-`--version'
-`-V'
-     Print the version of Autoconf used to generate the `configure'
-     script, and exit.
-
-`--cache-file=FILE'
-     Enable the cache: use and save the results of the tests in FILE,
-     traditionally `config.cache'.  FILE defaults to `/dev/null' to
-     disable caching.
-
-`--config-cache'
-`-C'
-     Alias for `--cache-file=config.cache'.
-
-`--quiet'
-`--silent'
-`-q'
-     Do not print messages saying which checks are being made.  To
-     suppress all normal output, redirect it to `/dev/null' (any error
-     messages will still be shown).
-
-`--srcdir=DIR'
-     Look for the package's source code in directory DIR.  Usually
-     `configure' can determine that directory automatically.
-
-`configure' also accepts some other, not widely useful, options.  Run
-`configure --help' for more details.
-
diff -urN remmina-plugins/README.LibVNCServer remmina-plugins/README.LibVNCServer
--- remmina-plugins/README.LibVNCServer	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins/README.LibVNCServer	1970-01-01 10:00:00.000000000 +1000
@@ -1,15 +0,0 @@
-LibVNCServer
-
-Project web: http://sourceforge.net/projects/libvncserver
-Authors: Johannes Schindelin, Karl J. Runge
-License: GPL
-
-Remmina redistributes libvncclient related codes originally from LibVNCServer project. All sources under libvncserver/* should follow these rules:
-o Remmina only maintains Makefile.am. All other files remain untouched
-o Remmina can synchronize it with LibVNCServer project any time
-o All fixes and new features should be accepted by LibVNCServer project first
-
-Reasons why Remmina redistributes it:
-o Remmina only requires small portion of the codes
-o Although LibVNCServer is maintained, it does not have any release schedules
-
diff -urN remmina-plugins/nx/CMakeLists.txt remmina-plugins/nx/CMakeLists.txt
--- remmina-plugins/nx/CMakeLists.txt	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins/nx/CMakeLists.txt	2014-01-08 02:31:52.000000000 +1100
@@ -28,6 +28,7 @@
 
 add_library(remmina-plugin-nx ${REMMINA_PLUGIN_NX_SRCS})
 set_target_properties(remmina-plugin-nx PROPERTIES PREFIX "")
+set_target_properties(remmina-plugin-nx PROPERTIES NO_SONAME 1)
 
 include_directories(${REMMINA_COMMON_INCLUDE_DIRS} ${XKBFILE_INCLUDE_DIRS} ${LIBSSH_INCLUDE_DIRS})
 target_link_libraries(remmina-plugin-nx ${REMMINA_COMMON_LIBRARIES} ${XKBFILE_LIBRARIES} ${LIBSSH_LIBRARIES})
diff -urN remmina-plugins/rdp/CMakeLists.txt remmina-plugins/rdp/CMakeLists.txt
--- remmina-plugins/rdp/CMakeLists.txt	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins/rdp/CMakeLists.txt	2014-01-08 02:31:52.000000000 +1100
@@ -33,10 +33,13 @@
 	rdp_gdi.h
 	rdp_graphics.c
 	rdp_graphics.h
+	rdp_cliprdr.c
+	rdp_cliprdr.h
 	)
 
 add_library(remmina-plugin-rdp ${REMMINA_PLUGIN_RDP_SRCS})
 set_target_properties(remmina-plugin-rdp PROPERTIES PREFIX "")
+set_target_properties(remmina-plugin-rdp PROPERTIES NO_SONAME 1)
 
 include_directories(${REMMINA_COMMON_INCLUDE_DIRS} ${FREERDP_INCLUDE_DIRS})
 target_link_libraries(remmina-plugin-rdp ${REMMINA_COMMON_LIBRARIES} ${FREERDP_LIBRARIES})
diff -urN remmina-plugins/rdp/rdp_cliprdr.c remmina-plugins/rdp/rdp_cliprdr.c
--- remmina-plugins/rdp/rdp_cliprdr.c	1970-01-01 10:00:00.000000000 +1000
+++ remmina-plugins/rdp/rdp_cliprdr.c	2014-01-08 02:31:52.000000000 +1100
@@ -0,0 +1,504 @@
+/*
+ * Remmina - The GTK+ Remote Desktop Client
+ * Copyright (C) 2012-2012 Jean-Louis Dupond
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, 
+ * Boston, MA 02111-1307, USA.
+ */
+
+#include "rdp_plugin.h"
+#include "rdp_cliprdr.h"
+
+#include <freerdp/freerdp.h>
+#include <freerdp/utils/event.h>
+#include <freerdp/channels/channels.h>
+#include <freerdp/client/cliprdr.h>
+
+
+UINT32 remmina_rdp_cliprdr_get_format_from_gdkatom(GdkAtom atom)
+{
+	gchar* name = gdk_atom_name(atom);
+	if (g_strcmp0("UTF8_STRING", name) == 0 || g_strcmp0("text/plain;charset=utf-8", name) == 0)
+	{
+		return CB_FORMAT_UNICODETEXT;
+	}
+	if (g_strcmp0("TEXT", name) == 0 || g_strcmp0("text/plain", name) == 0)
+	{
+		return CB_FORMAT_TEXT;
+	}
+	if (g_strcmp0("text/html", name) == 0)
+	{
+		return CB_FORMAT_HTML;
+	}
+	if (g_strcmp0("image/png", name) == 0)
+	{
+		return CB_FORMAT_PNG;
+	}
+	if (g_strcmp0("image/jpeg", name) == 0)
+	{
+	   return CB_FORMAT_JPEG;
+	}
+	if (g_strcmp0("image/bmp", name) == 0)
+	{
+		return CB_FORMAT_DIB;
+	}
+	return CB_FORMAT_RAW;
+}
+
+void remmina_rdp_cliprdr_get_target_types(UINT32** formats, UINT16* size, GdkAtom* types, int count)
+{
+	int i;
+	*size = 1;
+	*formats = (UINT32*) malloc(sizeof(UINT32) * (count+1));
+
+	*formats[0] = CB_FORMAT_RAW;
+	for (i = 0; i < count; i++)
+	{
+		UINT32 format = remmina_rdp_cliprdr_get_format_from_gdkatom(types[i]);
+		if (format != CB_FORMAT_RAW)
+		{
+			(*formats)[*size] = format;
+			(*size)++;
+		}
+	}
+
+	*formats = realloc(*formats, sizeof(UINT32) * (*size));
+}
+
+static UINT8* lf2crlf(UINT8* data, int* size)
+{
+        UINT8 c;
+        UINT8* outbuf;
+        UINT8* out;
+        UINT8* in_end;
+        UINT8* in;
+        int out_size;
+
+        out_size = (*size) * 2 + 1;
+        outbuf = (UINT8*) malloc(out_size);
+        out = outbuf;
+        in = data;
+        in_end = data + (*size);
+
+        while (in < in_end)
+        {
+                c = *in++;
+                if (c == '\n')
+                {
+                        *out++ = '\r';
+                        *out++ = '\n';
+                }
+                else
+                {
+                        *out++ = c;
+                }
+        }
+
+        *out++ = 0;
+        *size = out - outbuf;
+
+        return outbuf;
+}
+
+static void crlf2lf(UINT8* data, int* size)
+{
+        UINT8 c;
+        UINT8* out;
+        UINT8* in;
+        UINT8* in_end;
+
+        out = data;
+        in = data;
+        in_end = data + (*size);
+
+        while (in < in_end)
+        {
+                c = *in++;
+
+                if (c != '\r')
+                        *out++ = c;
+        }
+
+        *size = out - data;
+}
+
+void remmina_rdp_cliprdr_process_monitor_ready(RemminaProtocolWidget* gp, RDP_CB_MONITOR_READY_EVENT* event)
+{
+	RemminaPluginRdpUiObject* ui;
+
+	ui = g_new0(RemminaPluginRdpUiObject, 1);
+	ui->type = REMMINA_RDP_UI_CLIPBOARD;
+	ui->clipboard.type = REMMINA_RDP_UI_CLIPBOARD_FORMATLIST;
+	rf_queue_ui(gp, ui);
+}
+
+void remmina_rdp_cliprdr_process_format_list(RemminaProtocolWidget* gp, RDP_CB_FORMAT_LIST_EVENT* event)
+{
+	RemminaPluginRdpUiObject* ui;
+	int i;
+	GtkTargetList* list = gtk_target_list_new (NULL, 0);
+
+	for (i = 0; i < event->num_formats; i++)
+	{
+		if (event->formats[i] == CB_FORMAT_UNICODETEXT)
+		{
+			GdkAtom atom = gdk_atom_intern("UTF8_STRING", TRUE);
+			gtk_target_list_add(list, atom, 0, CB_FORMAT_UNICODETEXT);
+		}
+		if (event->formats[i] == CB_FORMAT_TEXT)
+		{
+			GdkAtom atom = gdk_atom_intern("TEXT", TRUE);
+			gtk_target_list_add(list, atom, 0, CB_FORMAT_TEXT);
+		}
+		if (event->formats[i] == CB_FORMAT_DIB)
+		{
+			GdkAtom atom = gdk_atom_intern("image/bmp", TRUE);
+			gtk_target_list_add(list, atom, 0, CB_FORMAT_DIB);
+		}
+		if (event->formats[i] == CB_FORMAT_JPEG)
+		{
+			GdkAtom atom = gdk_atom_intern("image/jpeg", TRUE);
+			gtk_target_list_add(list, atom, 0, CB_FORMAT_JPEG);
+		}
+		if (event->formats[i] == CB_FORMAT_PNG)
+		{
+			GdkAtom atom = gdk_atom_intern("image/png", TRUE);
+			gtk_target_list_add(list, atom, 0, CB_FORMAT_PNG);
+		}
+	}
+
+	ui = g_new0(RemminaPluginRdpUiObject, 1);
+	ui->type = REMMINA_RDP_UI_CLIPBOARD;
+	ui->clipboard.type = REMMINA_RDP_UI_CLIPBOARD_SET_DATA;
+	ui->clipboard.targetlist = list;
+	rf_queue_ui(gp, ui);
+}
+
+void remmina_rdp_cliprdr_process_data_request(RemminaProtocolWidget* gp, RDP_CB_DATA_REQUEST_EVENT* event)
+{
+	RemminaPluginRdpUiObject* ui;
+
+	ui = g_new0(RemminaPluginRdpUiObject, 1);
+	ui->type = REMMINA_RDP_UI_CLIPBOARD;
+	ui->clipboard.type = REMMINA_RDP_UI_CLIPBOARD_GET_DATA;
+	ui->clipboard.format = event->format;
+	rf_queue_ui(gp, ui);
+}
+
+void remmina_rdp_cliprdr_process_data_response(RemminaProtocolWidget* gp, RDP_CB_DATA_RESPONSE_EVENT* event)
+{
+	UINT8* data;
+	size_t size;
+	rfContext* rfi = GET_DATA(gp);
+	GdkPixbufLoader *pixbuf;
+	gpointer output = NULL;
+
+	data = event->data;
+	size = event->size;
+
+	if (size > 0)
+	{
+		switch (rfi->format)
+		{
+			case CB_FORMAT_UNICODETEXT:
+			{
+				size = ConvertFromUnicode(CP_UTF8, 0, (WCHAR*)data, size / 2, (CHAR**)&data, 0, NULL, NULL);
+				crlf2lf(data, &size);
+				output = data;
+				break;
+			}
+
+			case CB_FORMAT_TEXT:
+			case CB_FORMAT_HTML:
+			{
+				crlf2lf(data, &size);
+				output = data;
+				break;
+			}
+
+			case CB_FORMAT_DIB:
+			{
+				wStream* s;
+				UINT16 bpp;
+				UINT32 offset;
+				UINT32 ncolors;
+
+				s = Stream_New(data, size);
+				Stream_Seek(s, 14);
+				Stream_Read_UINT16(s, bpp);
+				Stream_Read_UINT32(s, ncolors);
+				offset = 14 + 40 + (bpp <= 8 ? (ncolors == 0 ? (1 << bpp) : ncolors) * 4 : 0);
+				Stream_Free(s, TRUE);
+
+				s = Stream_New(NULL, 14 + size);
+				Stream_Write_UINT8(s, 'B');
+				Stream_Write_UINT8(s, 'M');
+				Stream_Write_UINT32(s, 14 + size);
+				Stream_Write_UINT32(s, 0);
+				Stream_Write_UINT32(s, offset);
+				Stream_Write(s, data, size);
+
+				data = Stream_Buffer(s);
+				size = Stream_Length(s);
+				pixbuf = gdk_pixbuf_loader_new();
+				gdk_pixbuf_loader_write(pixbuf, data, size, NULL);
+				Stream_Free(s, TRUE);
+				output = g_object_ref(gdk_pixbuf_loader_get_pixbuf(pixbuf));
+				gdk_pixbuf_loader_close(pixbuf, NULL);
+				g_object_unref(pixbuf);
+				break;
+			}
+
+			case CB_FORMAT_PNG:
+			case CB_FORMAT_JPEG:
+			{
+				pixbuf = gdk_pixbuf_loader_new();
+				gdk_pixbuf_loader_write(pixbuf, data, size, NULL);
+				output = g_object_ref(gdk_pixbuf_loader_get_pixbuf(pixbuf));
+				gdk_pixbuf_loader_close(pixbuf, NULL);
+				g_object_unref(pixbuf);
+				break;
+			}
+		}
+	}
+	g_async_queue_push(rfi->clipboard_queue, output);
+}
+
+void remmina_rdp_channel_cliprdr_process(RemminaProtocolWidget* gp, wMessage* event)
+{
+	switch (GetMessageType(event->id))
+	{
+		case CliprdrChannel_MonitorReady:
+			remmina_rdp_cliprdr_process_monitor_ready(gp, (RDP_CB_MONITOR_READY_EVENT*) event);
+			break;
+
+		case CliprdrChannel_FormatList:
+			remmina_rdp_cliprdr_process_format_list(gp, (RDP_CB_FORMAT_LIST_EVENT*) event);
+			break;
+
+		case CliprdrChannel_DataRequest:
+			remmina_rdp_cliprdr_process_data_request(gp, (RDP_CB_DATA_REQUEST_EVENT*) event);
+			break;
+
+		case CliprdrChannel_DataResponse:
+			remmina_rdp_cliprdr_process_data_response(gp, (RDP_CB_DATA_RESPONSE_EVENT*) event);
+			break;
+	}
+}
+
+void remmina_rdp_cliprdr_request_data(GtkClipboard *clipboard, GtkSelectionData *selection_data, guint info, RemminaProtocolWidget* gp)
+{
+	GdkAtom target;
+	gpointer data;
+	RDP_CB_DATA_REQUEST_EVENT* event;
+	rfContext* rfi = GET_DATA(gp);
+
+	target = gtk_selection_data_get_target(selection_data);
+	rfi->format = remmina_rdp_cliprdr_get_format_from_gdkatom(target);
+	rfi->clipboard_queue = g_async_queue_new();
+
+	/* Request Clipboard data of the server */
+	event = (RDP_CB_DATA_REQUEST_EVENT*)
+		freerdp_event_new(CliprdrChannel_Class, CliprdrChannel_DataRequest, NULL, NULL);
+	event->format = rfi->format;
+	freerdp_channels_send_event(rfi->channels, (wMessage*) event);
+
+	data = g_async_queue_timeout_pop(rfi->clipboard_queue, 1000000);
+	if (data != NULL)
+	{
+		if (info == CB_FORMAT_PNG || info == CB_FORMAT_DIB || info == CB_FORMAT_JPEG)
+		{
+			gtk_selection_data_set_pixbuf(selection_data, data);
+			g_object_unref(data);
+		}
+		else
+		{
+			gtk_selection_data_set_text(selection_data, data, -1);
+		}
+	}
+}
+
+void remmina_rdp_cliprdr_empty_clipboard(GtkClipboard *clipboard, RemminaProtocolWidget* gp)
+{
+	/* No need to do anything here */
+}
+
+int remmina_rdp_cliprdr_send_format_list(RemminaProtocolWidget* gp, RemminaPluginRdpUiObject* ui)
+{
+	GtkClipboard* clipboard;
+	GdkAtom* targets;
+	gboolean result = 0;
+	gint count;
+	RDP_CB_FORMAT_LIST_EVENT* event;
+
+	rfContext* rfi = GET_DATA(gp);
+
+	if (rfi->clipboard_wait)
+	{
+		rfi->clipboard_wait = FALSE;
+		return 0;
+	}
+
+	/* Lets see if we have something in our clipboard */
+	clipboard = gtk_widget_get_clipboard(rfi->drawing_area, GDK_SELECTION_CLIPBOARD);
+	if (clipboard)
+	{
+		result = gtk_clipboard_wait_for_targets(clipboard, &targets, &count);
+	}
+
+	if (!result)
+		return 0;
+
+	event = (RDP_CB_FORMAT_LIST_EVENT*)
+		freerdp_event_new(CliprdrChannel_Class, CliprdrChannel_FormatList, NULL, NULL);
+
+	remmina_rdp_cliprdr_get_target_types(&event->formats, &event->num_formats, targets, count);
+	g_free(targets);
+
+	return freerdp_channels_send_event(rfi->channels, (wMessage*) event);
+}
+
+void remmina_rdp_cliprdr_get_clipboard_data(RemminaProtocolWidget* gp, RemminaPluginRdpUiObject* ui)
+{
+	RDP_CB_DATA_RESPONSE_EVENT* event;
+	GtkClipboard* clipboard;
+	UINT8* inbuf = NULL;
+	UINT8* outbuf = NULL;
+	GdkPixbuf *image = NULL;
+	int size = 0;
+
+	rfContext* rfi = GET_DATA(gp);
+
+	clipboard = gtk_widget_get_clipboard(rfi->drawing_area, GDK_SELECTION_CLIPBOARD);
+	if (clipboard)
+	{
+		switch (ui->clipboard.format)
+		{
+			case CB_FORMAT_TEXT:
+			case CB_FORMAT_UNICODETEXT:
+			case CB_FORMAT_HTML:
+			{
+				inbuf = (UINT8*)gtk_clipboard_wait_for_text(clipboard);
+				break;
+			}
+
+			case CB_FORMAT_PNG:
+			case CB_FORMAT_JPEG:
+			case CB_FORMAT_DIB:
+			{
+				image = gtk_clipboard_wait_for_image(clipboard);
+				break;
+			}
+		}
+	}
+
+	/* No data received, send nothing */
+	if (inbuf != NULL || image != NULL)
+	{
+		switch (ui->clipboard.format)
+		{
+			case CB_FORMAT_TEXT:
+			case CB_FORMAT_HTML:
+			{
+				size = strlen((char*)inbuf);
+				outbuf = lf2crlf(inbuf, &size);
+				break;
+			}
+			case CB_FORMAT_UNICODETEXT:
+			{
+				size = strlen((char*)inbuf);
+				inbuf = lf2crlf(inbuf, &size);
+				size = (ConvertToUnicode(CP_UTF8, 0, (CHAR*)inbuf, -1, (WCHAR**)&outbuf, 0) + 1) * 2;
+				g_free(inbuf);
+				break;
+			}
+			case CB_FORMAT_PNG:
+			{
+				gchar* data;
+				gsize buffersize;
+				gdk_pixbuf_save_to_buffer(image, &data, &buffersize, "png", NULL, NULL);
+				outbuf = (UINT8*) malloc(buffersize);
+				memcpy(outbuf, data, buffersize);
+				size = buffersize;
+				g_object_unref(image);
+				break;
+			}
+			case CB_FORMAT_JPEG:
+			{
+				gchar* data;
+				gsize buffersize;
+				gdk_pixbuf_save_to_buffer(image, &data, &buffersize, "jpeg", NULL, NULL);
+				outbuf = (UINT8*) malloc(buffersize);
+				memcpy(outbuf, data, buffersize);
+				size = buffersize;
+				g_object_unref(image);
+				break;
+			}
+			case CB_FORMAT_DIB:
+			{
+				gchar* data;
+				gsize buffersize;
+				gdk_pixbuf_save_to_buffer(image, &data, &buffersize, "bmp", NULL, NULL);
+				size = buffersize - 14;
+				outbuf = (UINT8*) malloc(size);
+				memcpy(outbuf, data + 14, size);
+				g_object_unref(image);
+				break;
+			}
+		}
+	}
+	event = (RDP_CB_DATA_RESPONSE_EVENT*)
+		        freerdp_event_new(CliprdrChannel_Class, CliprdrChannel_DataResponse, NULL, NULL);
+	event->data = outbuf;
+	event->size = size;
+	freerdp_channels_send_event(rfi->channels, (wMessage*) event);
+}
+
+void remmina_rdp_cliprdr_set_clipboard_data(RemminaProtocolWidget* gp, RemminaPluginRdpUiObject* ui)
+{
+	GtkClipboard* clipboard;
+	GtkTargetEntry* targets;
+	gint n_targets;
+	rfContext* rfi = GET_DATA(gp);
+
+	targets = gtk_target_table_new_from_list(ui->clipboard.targetlist, &n_targets);
+	clipboard = gtk_widget_get_clipboard(rfi->drawing_area, GDK_SELECTION_CLIPBOARD);
+	if (clipboard && targets)
+	{
+		rfi->clipboard_wait = TRUE;
+		gtk_clipboard_set_with_owner(clipboard, targets, n_targets,
+				(GtkClipboardGetFunc) remmina_rdp_cliprdr_request_data,
+				(GtkClipboardClearFunc) remmina_rdp_cliprdr_empty_clipboard, G_OBJECT(gp));
+		gtk_target_table_free(targets, n_targets);
+	}
+}
+
+void remmina_rdp_event_process_clipboard(RemminaProtocolWidget* gp, RemminaPluginRdpUiObject* ui)
+{
+	switch (ui->clipboard.type)
+	{
+		case REMMINA_RDP_UI_CLIPBOARD_FORMATLIST:
+			remmina_rdp_cliprdr_send_format_list(gp, ui);
+			break;
+
+		case REMMINA_RDP_UI_CLIPBOARD_GET_DATA:
+			remmina_rdp_cliprdr_get_clipboard_data(gp, ui);
+			break;
+
+		case REMMINA_RDP_UI_CLIPBOARD_SET_DATA:
+			remmina_rdp_cliprdr_set_clipboard_data(gp, ui);
+			break;
+	}
+}
diff -urN remmina-plugins/rdp/rdp_cliprdr.h remmina-plugins/rdp/rdp_cliprdr.h
--- remmina-plugins/rdp/rdp_cliprdr.h	1970-01-01 10:00:00.000000000 +1000
+++ remmina-plugins/rdp/rdp_cliprdr.h	2014-01-08 02:31:52.000000000 +1100
@@ -0,0 +1,32 @@
+/*
+ * Remmina - The GTK+ Remote Desktop Client
+ * Copyright (C) 2010-2011 Vic Lee
+ * Copyright (C) 2012-2012 Jean-Louis Dupond
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, 
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __REMMINA_RDP_CLIPRDR_H__
+#define __REMMINA_RDP_CLIPRDR_H__
+
+G_BEGIN_DECLS
+
+void remmina_rdp_channel_cliprdr_process(RemminaProtocolWidget* gp, wMessage* event);
+void remmina_rdp_event_process_clipboard(RemminaProtocolWidget* gp, RemminaPluginRdpUiObject* ui);
+
+G_END_DECLS
+
+#endif
diff -urN remmina-plugins/rdp/rdp_event.c remmina-plugins/rdp/rdp_event.c
--- remmina-plugins/rdp/rdp_event.c	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins/rdp/rdp_event.c	2014-01-08 02:31:52.000000000 +1100
@@ -16,18 +16,56 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, 
+ * Foundation, Inc., 59 Temple Place, Suite 330,
  * Boston, MA 02111-1307, USA.
  */
 
-/* X11 drawings were ported from xfreerdp */
-
 #include "rdp_plugin.h"
 #include "rdp_event.h"
 #include "rdp_gdi.h"
+#include "rdp_cliprdr.h"
 #include <gdk/gdkkeysyms.h>
 #include <cairo/cairo-xlib.h>
-#include <freerdp/kbd/kbd.h>
+#include <freerdp/locale/keyboard.h>
+
+static void remmina_rdp_event_on_focus_in(GtkWidget* widget, GdkEventKey* event, RemminaProtocolWidget* gp)
+{
+	rfContext* rfi;
+	rdpInput* input;
+	GdkModifierType state;
+#if GTK_VERSION == 3
+	GdkDeviceManager *manager;
+	GdkDevice *keyboard = NULL;
+#endif
+
+	rfi = GET_DATA(gp);
+	input = rfi->instance->input;
+	UINT32 toggle_keys_state = 0;
+
+#if GTK_VERSION == 3
+	manager = gdk_display_get_device_manager(gdk_display_get_default());
+	keyboard = gdk_device_manager_get_client_pointer(manager);
+	gdk_window_get_device_position(gdk_get_default_root_window(), keyboard, NULL, NULL, &state);
+#else
+	gdk_window_get_pointer(gdk_get_default_root_window(), NULL, NULL, &state);
+#endif
+
+	if (state & GDK_LOCK_MASK)
+	{
+		toggle_keys_state |= KBD_SYNC_CAPS_LOCK;
+	}
+	if (state & GDK_MOD2_MASK)
+	{
+		toggle_keys_state |= KBD_SYNC_NUM_LOCK;
+	}
+	if (state & GDK_MOD5_MASK)
+	{
+		toggle_keys_state |= KBD_SYNC_SCROLL_LOCK;
+	}
+
+	input->SynchronizeEvent(input, toggle_keys_state);
+	input->KeyboardEvent(input, KBD_FLAGS_RELEASE, 0x0F);
+}
 
 static void remmina_rdp_event_event_push(RemminaProtocolWidget* gp, const RemminaPluginRdpEvent* e)
 {
@@ -93,7 +131,7 @@
 
 	rfi = GET_DATA(gp);
 
-	if (!rfi->rgb_surface)
+	if (!rfi->surface)
 		return;
 
 	width = remmina_plugin_service->protocol_plugin_get_width(gp);
@@ -144,12 +182,6 @@
 
 	rfi = GET_DATA(gp);
 
-	if (rfi->sw_gdi)
-	{
-		XPutImage(rfi->display, rfi->primary, rfi->gc, rfi->image, x, y, x, y, w, h);
-		XCopyArea(rfi->display, rfi->primary, rfi->rgb_surface, rfi->gc, x, y, w, h, x, y);
-	}
-
 	if (remmina_plugin_service->protocol_plugin_get_scale(gp))
 		remmina_rdp_event_scale_area(gp, &x, &y, &w, &h);
 
@@ -162,12 +194,6 @@
 
 	rfi = GET_DATA(gp);
 
-	if (rfi->sw_gdi)
-	{
-		XPutImage(rfi->display, rfi->primary, rfi->gc, rfi->image, x, y, x, y, w, h);
-		XCopyArea(rfi->display, rfi->primary, rfi->rgb_surface, rfi->gc, x, y, w, h, x, y);
-	}
-
 	if (remmina_plugin_service->protocol_plugin_get_scale(gp))
 		remmina_rdp_event_scale_area(gp, &x, &y, &w, &h);
 
@@ -241,7 +267,7 @@
 
 	rfi = GET_DATA(gp);
 
-	if (!rfi->rgb_cairo_surface)
+	if (!rfi->surface)
 		return FALSE;
 
 	scale = remmina_plugin_service->protocol_plugin_get_scale(gp);
@@ -252,19 +278,18 @@
 
 	context = gdk_cairo_create(gtk_widget_get_window (rfi->drawing_area));
 	cairo_rectangle(context, x, y, event->area.width, event->area.height);
-#else
-	cairo_rectangle(context, 0, 0, gtk_widget_get_allocated_width(widget),
-		gtk_widget_get_allocated_height(widget));
 #endif
 
 	if (scale)
 		cairo_scale(context, rfi->scale_x, rfi->scale_y);
 
-	cairo_set_source_surface(context, rfi->rgb_cairo_surface, 0, 0);
-	cairo_fill(context);
+	cairo_set_source_surface(context, rfi->surface, 0, 0);
 
 #if GTK_VERSION == 2
+	cairo_fill(context);
 	cairo_destroy(context);
+#else
+	cairo_paint(context);
 #endif
 
 	return TRUE;
@@ -286,7 +311,7 @@
 	return FALSE;
 }
 
-static void remmina_rdp_event_translate_pos(RemminaProtocolWidget* gp, int ix, int iy, uint16* ox, uint16* oy)
+static void remmina_rdp_event_translate_pos(RemminaProtocolWidget* gp, int ix, int iy, UINT16* ox, UINT16* oy)
 {
 	rfContext* rfi;
 
@@ -294,13 +319,13 @@
 
 	if ((rfi->scale) && (rfi->scale_width >= 1) && (rfi->scale_height >= 1))
 	{
-		*ox = (uint16) (ix * remmina_plugin_service->protocol_plugin_get_width(gp) / rfi->scale_width);
-		*oy = (uint16) (iy * remmina_plugin_service->protocol_plugin_get_height(gp) / rfi->scale_height);
+		*ox = (UINT16) (ix * remmina_plugin_service->protocol_plugin_get_width(gp) / rfi->scale_width);
+		*oy = (UINT16) (iy * remmina_plugin_service->protocol_plugin_get_height(gp) / rfi->scale_height);
 	}
 	else
 	{
-		*ox = (uint16) ix;
-		*oy = (uint16) iy;
+		*ox = (UINT16) ix;
+		*oy = (UINT16) iy;
 	}
 }
 
@@ -378,6 +403,17 @@
 			flag = PTR_FLAGS_WHEEL | PTR_FLAGS_WHEEL_NEGATIVE | 0x0088;
 			break;
 
+#ifdef GDK_SCROLL_SMOOTH
+		case GDK_SCROLL_SMOOTH:
+			if (event->delta_y < 0)
+				flag = PTR_FLAGS_WHEEL | 0x0078;
+			if (event->delta_y > 0)
+				flag = PTR_FLAGS_WHEEL | PTR_FLAGS_WHEEL_NEGATIVE | 0x0088;
+			if (!flag)
+				return FALSE;
+			break;
+#endif
+
 		default:
 			return FALSE;
 	}
@@ -391,10 +427,11 @@
 
 static gboolean remmina_rdp_event_on_key(GtkWidget* widget, GdkEventKey* event, RemminaProtocolWidget* gp)
 {
-	Display* display;
-	KeyCode cooked_keycode;
+	GdkDisplay* display;
+	guint16 cooked_keycode;
 	rfContext* rfi;
 	RemminaPluginRdpEvent rdp_event;
+	DWORD scancode;
 
 	rfi = GET_DATA(gp);
 	rdp_event.type = REMMINA_RDP_EVENT_TYPE_SCANCODE;
@@ -421,17 +458,22 @@
 		default:
 			if (!rfi->use_client_keymap)
 			{
-				rdp_event.key_event.key_code = freerdp_kbd_get_scancode_by_keycode(event->hardware_keycode, &rdp_event.key_event.extended);
-				remmina_plugin_service->log_printf("[RDP]keyval=%04X keycode=%i scancode=%i extended=%i\n",
-						event->keyval, event->hardware_keycode, rdp_event.key_event.key_code, &rdp_event.key_event.extended);
+				scancode = freerdp_keyboard_get_rdp_scancode_from_x11_keycode(event->hardware_keycode);
+				rdp_event.key_event.key_code = scancode & 0xFF;
+				rdp_event.key_event.extended = scancode & 0x100;
+				remmina_plugin_service->log_printf("[RDP]keyval=%02X keycode=%02X scancode=%02X extended=%s\n",
+						event->keyval, event->hardware_keycode, rdp_event.key_event.key_code, rdp_event.key_event.extended ? "true" : "false");
 			}
 			else
 			{
-				display = GDK_DISPLAY_XDISPLAY (gdk_display_get_default());
-				cooked_keycode = XKeysymToKeycode(display, XKeycodeToKeysym(display, event->hardware_keycode, 0));
-				rdp_event.key_event.key_code = freerdp_kbd_get_scancode_by_keycode(cooked_keycode, &rdp_event.key_event.extended);
-				remmina_plugin_service->log_printf("[RDP]keyval=%04X raw_keycode=%i cooked_keycode=%i scancode=%i extended=%i\n",
-						event->keyval, event->hardware_keycode, cooked_keycode, rdp_event.key_event.key_code, &rdp_event.key_event.extended);
+				//TODO: Port to GDK functions
+				display = gdk_display_get_default();
+				cooked_keycode = XKeysymToKeycode(GDK_DISPLAY_XDISPLAY(display), XKeycodeToKeysym(GDK_DISPLAY_XDISPLAY(display), event->hardware_keycode, 0));
+				scancode = freerdp_keyboard_get_rdp_scancode_from_x11_keycode(cooked_keycode);
+				rdp_event.key_event.key_code = scancode & 0xFF;
+				rdp_event.key_event.extended = scancode & 0x100;
+				remmina_plugin_service->log_printf("[RDP]keyval=%02X raw_keycode=%02X cooked_keycode=%02X scancode=%02X extended=%s\n",
+						event->keyval, event->hardware_keycode, cooked_keycode, rdp_event.key_event.key_code, rdp_event.key_event.extended ? "true" : "false");
 			}
 
 			if (rdp_event.key_event.key_code)
@@ -452,15 +494,24 @@
 	return TRUE;
 }
 
+gboolean remmina_rdp_event_on_clipboard(GtkClipboard *clipboard, GdkEvent *event, RemminaProtocolWidget *gp)
+{
+	RemminaPluginRdpUiObject* ui;
+
+	ui = g_new0(RemminaPluginRdpUiObject, 1);
+	ui->type = REMMINA_RDP_UI_CLIPBOARD;
+	ui->clipboard.type = REMMINA_RDP_UI_CLIPBOARD_FORMATLIST;
+	rf_queue_ui(gp, ui);
+
+	return TRUE;
+}
+
 void remmina_rdp_event_init(RemminaProtocolWidget* gp)
 {
-	gint n;
-	gint i;
 	gchar* s;
 	gint flags;
-	XPixmapFormatValues* pf;
-	XPixmapFormatValues* pfs;
 	rfContext* rfi;
+	GtkClipboard* clipboard;
 
 	rfi = GET_DATA(gp);
 	rfi->drawing_area = gtk_drawing_area_new();
@@ -468,7 +519,7 @@
 	gtk_container_add(GTK_CONTAINER(gp), rfi->drawing_area);
 
 	gtk_widget_add_events(rfi->drawing_area, GDK_POINTER_MOTION_MASK | GDK_BUTTON_PRESS_MASK
-		| GDK_BUTTON_RELEASE_MASK | GDK_KEY_PRESS_MASK | GDK_KEY_RELEASE_MASK);
+		| GDK_BUTTON_RELEASE_MASK | GDK_KEY_PRESS_MASK | GDK_KEY_RELEASE_MASK | GDK_SCROLL_MASK | GDK_FOCUS_CHANGE_MASK);
 	gtk_widget_set_can_focus(rfi->drawing_area, TRUE);
 
 	remmina_plugin_service->protocol_plugin_register_hostkey(gp, rfi->drawing_area);
@@ -498,6 +549,15 @@
 		G_CALLBACK(remmina_rdp_event_on_key), gp);
 	g_signal_connect(G_OBJECT(rfi->drawing_area), "key-release-event",
 		G_CALLBACK(remmina_rdp_event_on_key), gp);
+	g_signal_connect(G_OBJECT(rfi->drawing_area), "focus-in-event",
+		G_CALLBACK(remmina_rdp_event_on_focus_in), gp);
+
+	RemminaFile* remminafile = remmina_plugin_service->protocol_plugin_get_file(gp);
+	if (!remmina_plugin_service->file_get_int(remminafile, "disableclipboard", FALSE))
+	{
+		clipboard = gtk_widget_get_clipboard(rfi->drawing_area, GDK_SELECTION_CLIPBOARD);
+		rfi->clipboard_handler = g_signal_connect(clipboard, "owner-change", G_CALLBACK(remmina_rdp_event_on_clipboard), gp);
+	}
 
 	rfi->pressed_keys = g_array_new(FALSE, TRUE, sizeof (gint));
 	rfi->event_queue = g_async_queue_new_full(g_free);
@@ -517,27 +577,8 @@
 
 	rfi->object_table = g_hash_table_new_full(NULL, NULL, NULL, g_free);
 
-	rfi->display = GDK_DISPLAY_XDISPLAY(gdk_display_get_default());
-	rfi->depth = DefaultDepth(rfi->display, DefaultScreen(rfi->display));
-	rfi->visual = GDK_VISUAL_XVISUAL(gdk_visual_get_best_with_depth(rfi->depth));
-	pfs = XListPixmapFormats(rfi->display, &n);
-
-	if (pfs)
-	{
-		for (i = 0; i < n; i++)
-		{
-			pf = pfs + i;
-
-			if (pf->depth == rfi->depth)
-			{
-				rfi->scanline_pad = pf->scanline_pad;
-				rfi->bpp = pf->bits_per_pixel;
-				break;
-			}
-		}
-
-		XFree(pfs);
-	}
+	rfi->display = gdk_display_get_default();
+	rfi->bpp = gdk_visual_get_best_depth();
 }
 
 void remmina_rdp_event_uninit(RemminaProtocolWidget* gp)
@@ -547,6 +588,13 @@
 
 	rfi = GET_DATA(gp);
 
+
+	/* unregister the clipboard monitor */
+	if (rfi->clipboard_handler)
+	{
+		g_signal_handler_disconnect(G_OBJECT(gtk_widget_get_clipboard(rfi->drawing_area, GDK_SELECTION_CLIPBOARD)), rfi->clipboard_handler);
+		rfi->clipboard_handler = 0;
+	}
 	if (rfi->scale_handler)
 	{
 		g_source_remove(rfi->scale_handler);
@@ -561,36 +609,10 @@
 	{
 		rf_object_free(gp, ui);
 	}
-
-	if (rfi->gc)
-	{
-		XFreeGC(rfi->display, rfi->gc);
-		rfi->gc = 0;
-	}
-	if (rfi->gc_default)
-	{
-		XFreeGC(rfi->display, rfi->gc_default);
-		rfi->gc_default = 0;
-	}
-	if (rfi->rgb_cairo_surface)
-	{
-		cairo_surface_destroy(rfi->rgb_cairo_surface);
-		rfi->rgb_cairo_surface = NULL;
-	}
-	if (rfi->rgb_surface)
-	{
-		XFreePixmap(rfi->display, rfi->rgb_surface);
-		rfi->rgb_surface = 0;
-	}
-	if (rfi->gc_mono)
+	if (rfi->surface)
 	{
-		XFreeGC(rfi->display, rfi->gc_mono);
-		rfi->gc_mono = 0;
-	}
-	if (rfi->bitmap_mono)
-	{
-		XFreePixmap(rfi->display, rfi->bitmap_mono);
-		rfi->bitmap_mono = 0;
+		cairo_surface_destroy(rfi->surface);
+		rfi->surface = NULL;
 	}
 
 	g_hash_table_destroy(rfi->object_table);
@@ -633,230 +655,78 @@
 	remmina_plugin_service->protocol_plugin_emit_signal(gp, "update-align");
 }
 
-static uint8 remmina_rdp_event_rop2_map[] =
-{
-	GXclear,		/* 0 */
-	GXnor,			/* DPon */
-	GXandInverted,		/* DPna */
-	GXcopyInverted,		/* Pn */
-	GXandReverse,		/* PDna */
-	GXinvert,		/* Dn */
-	GXxor,			/* DPx */
-	GXnand,			/* DPan */
-	GXand,			/* DPa */
-	GXequiv,		/* DPxn */
-	GXnoop,			/* D */
-	GXorInverted,		/* DPno */
-	GXcopy,			/* P */
-	GXorReverse,		/* PDno */
-	GXor,			/* DPo */
-	GXset			/* 1 */
-};
-
-static void remmina_rdp_event_set_rop2(rfContext* rfi, gint rop2)
-{
-	if ((rop2 < 0x01) || (rop2 > 0x10))
-	{
-		remmina_plugin_service->log_printf("[RDP]unknown rop2 0x%x", rop2);
-	}
-	else
-	{
-		XSetFunction(rfi->display, rfi->gc, remmina_rdp_event_rop2_map[rop2 - 1]);
-	}
-}
-
-static void remmina_rdp_event_set_rop3(rfContext* rfi, gint rop3)
-{
-	switch (rop3)
-	{
-		case 0x00: /* 0 - 0 */
-			XSetFunction(rfi->display, rfi->gc, GXclear);
-			break;
-		case 0x05: /* ~(P | D) - DPon */
-			XSetFunction(rfi->display, rfi->gc, GXnor);
-			break;
-		case 0x0a: /* ~P & D - DPna */
-			XSetFunction(rfi->display, rfi->gc, GXandInverted);
-			break;
-		case 0x0f: /* ~P - Pn */
-			XSetFunction(rfi->display, rfi->gc, GXcopyInverted);
-			break;
-		case 0x11: /* ~(S | D) - DSon */
-			XSetFunction(rfi->display, rfi->gc, GXnor);
-			break;
-		case 0x22: /* ~S & D - DSna */
-			XSetFunction(rfi->display, rfi->gc, GXandInverted);
-			break;
-		case 0x33: /* ~S - Sn */
-			XSetFunction(rfi->display, rfi->gc, GXcopyInverted);
-			break;
-		case 0x44: /* S & ~D - SDna */
-			XSetFunction(rfi->display, rfi->gc, GXandReverse);
-			break;
-		case 0x50: /* P & ~D - PDna */
-			XSetFunction(rfi->display, rfi->gc, GXandReverse);
-			break;
-		case 0x55: /* ~D - Dn */
-			XSetFunction(rfi->display, rfi->gc, GXinvert);
-			break;
-		case 0x5a: /* D ^ P - DPx */
-			XSetFunction(rfi->display, rfi->gc, GXxor);
-			break;
-		case 0x5f: /* ~(P & D) - DPan */
-			XSetFunction(rfi->display, rfi->gc, GXnand);
-			break;
-		case 0x66: /* D ^ S - DSx */
-			XSetFunction(rfi->display, rfi->gc, GXxor);
-			break;
-		case 0x77: /* ~(S & D) - DSan */
-			XSetFunction(rfi->display, rfi->gc, GXnand);
-			break;
-		case 0x88: /* D & S - DSa */
-			XSetFunction(rfi->display, rfi->gc, GXand);
-			break;
-		case 0x99: /* ~(S ^ D) - DSxn */
-			XSetFunction(rfi->display, rfi->gc, GXequiv);
-			break;
-		case 0xa0: /* P & D - DPa */
-			XSetFunction(rfi->display, rfi->gc, GXand);
-			break;
-		case 0xa5: /* ~(P ^ D) - PDxn */
-			XSetFunction(rfi->display, rfi->gc, GXequiv);
-			break;
-		case 0xaa: /* D - D */
-			XSetFunction(rfi->display, rfi->gc, GXnoop);
-			break;
-		case 0xaf: /* ~P | D - DPno */
-			XSetFunction(rfi->display, rfi->gc, GXorInverted);
-			break;
-		case 0xbb: /* ~S | D - DSno */
-			XSetFunction(rfi->display, rfi->gc, GXorInverted);
-			break;
-		case 0xcc: /* S - S */
-			XSetFunction(rfi->display, rfi->gc, GXcopy);
-			break;
-		case 0xdd: /* S | ~D - SDno */
-			XSetFunction(rfi->display, rfi->gc, GXorReverse);
-			break;
-		case 0xee: /* D | S - DSo */
-			XSetFunction(rfi->display, rfi->gc, GXor);
-			break;
-		case 0xf0: /* P - P */
-			XSetFunction(rfi->display, rfi->gc, GXcopy);
-			break;
-		case 0xf5: /* P | ~D - PDno */
-			XSetFunction(rfi->display, rfi->gc, GXorReverse);
-			break;
-		case 0xfa: /* P | D - DPo */
-			XSetFunction(rfi->display, rfi->gc, GXor);
-			break;
-		case 0xff: /* 1 - 1 */
-			XSetFunction(rfi->display, rfi->gc, GXset);
-			break;
-		default:
-			remmina_plugin_service->log_printf("[RDP]unknown rop3 0x%x", rop3);
-			break;
-	}
-}
-
-static void remmina_rdp_event_insert_drawable(rfContext* rfi, guint object_id, Drawable obj)
-{
-	Drawable* p;
-
-	p = g_new(Drawable, 1);
-	*p = obj;
-	g_hash_table_insert(rfi->object_table, GINT_TO_POINTER(object_id), p);
-}
-
-static Drawable remmina_rdp_event_get_drawable(rfContext* rfi, guint object_id)
-{
-	Drawable* p;
-
-	p = (Drawable*) g_hash_table_lookup(rfi->object_table, GINT_TO_POINTER(object_id));
-
-	if (!p)
-		return 0;
-
-	return *p;
-}
-
 static void remmina_rdp_event_connected(RemminaProtocolWidget* gp, RemminaPluginRdpUiObject* ui)
 {
 	rfContext* rfi;
+	int stride;
 
 	rfi = GET_DATA(gp);
 
 	gtk_widget_realize(rfi->drawing_area);
 
-	rfi->drawable = GDK_WINDOW_XID(gtk_widget_get_window(rfi->drawing_area));
-
-	rfi->rgb_surface = XCreatePixmap(rfi->display, rfi->drawable,
-		rfi->settings->width, rfi->settings->height, rfi->depth);
-
-	rfi->rgb_cairo_surface = cairo_xlib_surface_create(rfi->display,
-			rfi->rgb_surface, rfi->visual, rfi->width, rfi->height);
-
-	rfi->drw_surface = rfi->rgb_surface;
+	stride = cairo_format_stride_for_width(rfi->cairo_format, rfi->width);
+	rfi->surface = cairo_image_surface_create_for_data((unsigned char*) rfi->primary_buffer, rfi->cairo_format, rfi->width, rfi->height, stride);
+	gtk_widget_queue_draw_area(rfi->drawing_area, 0, 0, rfi->width, rfi->height);
 
+	if (rfi->clipboard_handler)
+	{
+		remmina_rdp_event_on_clipboard(NULL, NULL, gp);
+	}
 	remmina_rdp_event_update_scale(gp);
 }
 
-static void remmina_rdp_event_rfx(RemminaProtocolWidget* gp, RemminaPluginRdpUiObject* ui)
+static void remmina_rdp_event_create_cursor(RemminaProtocolWidget* gp, RemminaPluginRdpUiObject* ui)
 {
-	XImage* image;
-	gint i, tx, ty;
-	RFX_MESSAGE* message;
-	rfContext* rfi;
-
-	rfi = GET_DATA(gp);
-	message = ui->rfx.message;
-
-	XSetFunction(rfi->display, rfi->gc, GXcopy);
-	XSetFillStyle(rfi->display, rfi->gc, FillSolid);
+	cairo_surface_t* surface;
+	GdkPixbuf* pixbuf;
+	rfContext* rfi = GET_DATA(gp);
+	rdpPointer* pointer = (rdpPointer*)ui->cursor.pointer;
+	UINT8* data = malloc(pointer->width * pointer->height * 4);
 
-	XSetClipRectangles(rfi->display, rfi->gc, ui->rfx.left, ui->rfx.top,
-		(XRectangle*) message->rects, message->num_rects, YXBanded);
-
-	/* Draw the tiles to primary surface, each is 64x64. */
-	for (i = 0; i < message->num_tiles; i++)
-	{
-		image = XCreateImage(rfi->display, rfi->visual, 24, ZPixmap, 0,
-			(char*) message->tiles[i]->data, 64, 64, 32, 0);
-
-		tx = message->tiles[i]->x + ui->rfx.left;
-		ty = message->tiles[i]->y + ui->rfx.top;
-
-		XPutImage(rfi->display, rfi->rgb_surface, rfi->gc, image, 0, 0, tx, ty, 64, 64);
-		XFree(image);
+	freerdp_alpha_cursor_convert(data, pointer->xorMaskData, pointer->andMaskData, pointer->width, pointer->height, pointer->xorBpp, rfi->clrconv);
+	surface = cairo_image_surface_create_for_data(data, CAIRO_FORMAT_ARGB32, pointer->width, pointer->height, cairo_format_stride_for_width(CAIRO_FORMAT_ARGB32, pointer->width));
+	pixbuf = gdk_pixbuf_get_from_surface(surface, 0, 0, pointer->width, pointer->height);
+	cairo_surface_destroy(surface);
+	((rfPointer*)ui->cursor.pointer)->cursor = gdk_cursor_new_from_pixbuf(rfi->display, pixbuf, pointer->xPos, pointer->yPos);
+}
 
-		remmina_rdp_event_update_rect(gp, tx, ty, message->rects[i].width, message->rects[i].height);
-	}
+static void remmina_rdp_event_free_cursor(RemminaProtocolWidget* gp, RemminaPluginRdpUiObject* ui)
+{
+	rfContext* rfi = GET_DATA(gp);
 
-	XSetClipMask(rfi->display, rfi->gc, None);
+	g_mutex_lock(rfi->gmutex);
+	g_object_unref(ui->cursor.pointer->cursor);
+	ui->cursor.pointer->cursor = NULL;
+	g_cond_signal(rfi->gcond);
+	g_mutex_unlock(rfi->gmutex);
 }
 
-static void remmina_rdp_event_nocodec(RemminaProtocolWidget* gp, RemminaPluginRdpUiObject* ui)
+static void remmina_rdp_event_cursor(RemminaProtocolWidget* gp, RemminaPluginRdpUiObject* ui)
 {
-	XImage* image;
-	rfContext* rfi;
-
-	rfi = GET_DATA(gp);
+	rfContext* rfi = GET_DATA(gp);
 
-	XSetFunction(rfi->display, rfi->gc, GXcopy);
-	XSetFillStyle(rfi->display, rfi->gc, FillSolid);
+	switch (ui->cursor.type)
+	{
+		case REMMINA_RDP_POINTER_NEW:
+			remmina_rdp_event_create_cursor(gp, ui);
+			break;
 
-	image = XCreateImage(rfi->display, rfi->visual, 24, ZPixmap, 0,
-		(char*) ui->nocodec.bitmap, ui->nocodec.width, ui->nocodec.height, 32, 0);
+		case REMMINA_RDP_POINTER_FREE:
+			remmina_rdp_event_free_cursor(gp, ui);
+			break;
 
-	XPutImage(rfi->display, rfi->rgb_surface, rfi->gc, image, 0, 0,
-		ui->nocodec.left, ui->nocodec.top,
-		ui->nocodec.width, ui->nocodec.height);
+		case REMMINA_RDP_POINTER_SET:
+			gdk_window_set_cursor(gtk_widget_get_window(rfi->drawing_area), ui->cursor.pointer->cursor);
+			break;
 
-	remmina_rdp_event_update_rect(gp,
-		ui->nocodec.left, ui->nocodec.top,
-		ui->nocodec.width, ui->nocodec.height);
+		case REMMINA_RDP_POINTER_NULL:
+			gdk_window_set_cursor(gtk_widget_get_window(rfi->drawing_area), gdk_cursor_new(GDK_BLANK_CURSOR));
+			break;
 
-	XSetClipMask(rfi->display, rfi->gc, None);
+		case REMMINA_RDP_POINTER_DEFAULT:
+			gdk_window_set_cursor(gtk_widget_get_window(rfi->drawing_area), NULL);
+			break;
+	}
 }
 
 gboolean remmina_rdp_event_queue_ui(RemminaProtocolWidget* gp)
@@ -880,12 +750,12 @@
 				remmina_rdp_event_connected(gp, ui);
 				break;
 
-			case REMMINA_RDP_UI_RFX:
-				remmina_rdp_event_rfx(gp, ui);
+			case REMMINA_RDP_UI_CURSOR:
+				remmina_rdp_event_cursor(gp, ui);
 				break;
 
-			case REMMINA_RDP_UI_NOCODEC:
-				remmina_rdp_event_nocodec(gp, ui);
+			case REMMINA_RDP_UI_CLIPBOARD:
+				remmina_rdp_event_process_clipboard(gp, ui);
 				break;
 
 			default:
@@ -908,4 +778,3 @@
 {
 	remmina_rdp_event_release_key(gp, 0);
 }
-
diff -urN remmina-plugins/rdp/rdp_file.c remmina-plugins/rdp/rdp_file.c
--- remmina-plugins/rdp/rdp_file.c	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins/rdp/rdp_file.c	2014-01-08 02:31:52.000000000 +1100
@@ -80,6 +80,10 @@
 	{
 		remmina_plugin_service->file_set_int(remminafile, "shareprinter", (atoi (value) == 1));
 	}
+	else if (g_strcmp0(key, "redirectsmartcard") == 0)
+	{
+		remmina_plugin_service->file_set_int(remminafile, "sharesmartcard", (atoi (value) == 1));
+	}
 	else if (g_strcmp0(key, "redirectclipboard") == 0)
 	{
 		remmina_plugin_service->file_set_int(remminafile, "disableclipboard", (atoi (value) != 1));
@@ -268,6 +272,7 @@
 	else
 		fprintf(fp, "audiomode:i:2\r\n");
 	fprintf(fp, "redirectprinters:i:%i\r\n", remmina_plugin_service->file_get_int(remminafile, "shareprinter", FALSE) ? 1 : 0);
+	fprintf(fp, "redirectsmartcard:i:%i\r\n", remmina_plugin_service->file_get_int(remminafile, "sharesmartcard", FALSE) ? 1 : 0);
 	fprintf(fp, "redirectcomports:i:0\r\n");
 	fprintf(fp, "redirectsmartcards:i:0\r\n");
 	fprintf(fp, "redirectclipboard:i:1\r\n");
diff -urN remmina-plugins/rdp/rdp_gdi.c remmina-plugins/rdp/rdp_gdi.c
--- remmina-plugins/rdp/rdp_gdi.c	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins/rdp/rdp_gdi.c	2014-01-08 02:31:52.000000000 +1100
@@ -28,10 +28,6 @@
 #include <freerdp/freerdp.h>
 #include <freerdp/constants.h>
 #include <freerdp/cache/cache.h>
-#include <freerdp/utils/memory.h>
-#include <X11/Xlib.h>
-#include <X11/keysym.h>
-#include <gdk/gdkx.h>
 
 static void rf_desktop_resize(rdpContext* context)
 {
@@ -43,8 +39,8 @@
 
 	LOCK_BUFFER(TRUE)
 
-	remmina_plugin_service->protocol_plugin_set_width(gp, rfi->settings->width);
-	remmina_plugin_service->protocol_plugin_set_height(gp, rfi->settings->height);
+	remmina_plugin_service->protocol_plugin_set_width(gp, rfi->settings->DesktopWidth);
+	remmina_plugin_service->protocol_plugin_set_height(gp, rfi->settings->DesktopHeight);
 
 	UNLOCK_BUFFER(TRUE)
 
@@ -62,23 +58,6 @@
 
 static void rf_gdi_set_bounds(rdpContext* context, rdpBounds* bounds)
 {
-	/*
-	XRectangle clip;
-	rfContext* rfi = (rfContext*) context;
-
-	if (bounds != NULL)
-	{
-		clip.x = bounds->left;
-		clip.y = bounds->top;
-		clip.width = bounds->right - bounds->left + 1;
-		clip.height = bounds->bottom - bounds->top + 1;
-		XSetClipRectangles(rfi->display, rfi->gc, 0, 0, &clip, 1, YXBanded);
-	}
-	else
-	{
-		XSetClipMask(rfi->display, rfi->gc, None);
-	}
-	*/
 }
 
 static void rf_gdi_dstblt(rdpContext* context, DSTBLT_ORDER* dstblt)
@@ -128,12 +107,12 @@
 
 static void rf_gdi_surface_bits(rdpContext* context, SURFACE_BITS_COMMAND* surface_bits_command)
 {
-	uint8* bitmap;
+	UINT8* bitmap;
 	RFX_MESSAGE* message;
 	RemminaPluginRdpUiObject* ui;
 	rfContext* rfi = (rfContext*) context;
 
-	if (surface_bits_command->codecID == CODEC_ID_REMOTEFX && rfi->rfx_context)
+	if (surface_bits_command->codecID == RDP_CODEC_ID_REMOTEFX && rfi->rfx_context)
 	{
 		message = rfx_process_message(rfi->rfx_context, surface_bits_command->bitmapData,
 				surface_bits_command->bitmapDataLength);
@@ -146,9 +125,9 @@
 
 		rf_queue_ui(rfi->protocol_widget, ui);
 	}
-	else if (surface_bits_command->codecID == CODEC_ID_NONE)
+	else if (surface_bits_command->codecID == RDP_CODEC_ID_NONE)
 	{
-		bitmap = (uint8*) xzalloc(surface_bits_command->width * surface_bits_command->height * 4);
+		bitmap = (UINT8*) malloc(surface_bits_command->width * surface_bits_command->height * 4);
 
 		freerdp_image_flip(surface_bits_command->bitmapData, bitmap,
 				surface_bits_command->width, surface_bits_command->height, 32);
diff -urN remmina-plugins/rdp/rdp_graphics.c remmina-plugins/rdp/rdp_graphics.c
--- remmina-plugins/rdp/rdp_graphics.c	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins/rdp/rdp_graphics.c	2014-01-08 02:31:52.000000000 +1100
@@ -24,9 +24,9 @@
 #include "rdp_event.h"
 #include "rdp_graphics.h"
 
-#include <freerdp/utils/memory.h>
 #include <freerdp/codec/color.h>
 #include <freerdp/codec/bitmap.h>
+#include <winpr/memory.h>
 
 //#define RF_BITMAP
 //#define RF_GLYPH
@@ -36,7 +36,7 @@
 void rf_Bitmap_New(rdpContext* context, rdpBitmap* bitmap)
 {
 #ifdef RF_BITMAP
-	uint8* data;
+	UINT8* data;
 	Pixmap pixmap;
 	XImage* image;
 	rfContext* rfi = (rfContext*) context;
@@ -115,23 +115,23 @@
 }
 
 void rf_Bitmap_Decompress(rdpContext* context, rdpBitmap* bitmap,
-	uint8* data, int width, int height, int bpp, int length, boolean compressed)
+	BYTE* data, int width, int height, int bpp, int length, BOOL compressed, int codec_id)
 {
 #ifdef RF_BITMAP
-	uint16 size;
+	UINT16 size;
 
 	printf("rf_Bitmap_Decompress\n");
 
 	size = width * height * (bpp + 7) / 8;
 
 	if (bitmap->data == NULL)
-		bitmap->data = (uint8*) xmalloc(size);
+		bitmap->data = (UINT8*) xmalloc(size);
 	else
-		bitmap->data = (uint8*) xrealloc(bitmap->data, size);
+		bitmap->data = (UINT8*) xrealloc(bitmap->data, size);
 
 	if (compressed)
 	{
-		boolean status;
+		BOOL status;
 
 		status = bitmap_decompress(data, bitmap->data, width, height, length, bpp, bpp);
 
@@ -151,7 +151,7 @@
 #endif
 }
 
-void rf_Bitmap_SetSurface(rdpContext* context, rdpBitmap* bitmap, boolean primary)
+void rf_Bitmap_SetSurface(rdpContext* context, rdpBitmap* bitmap, BOOL primary)
 {
 #ifdef RF_BITMAP
 	rfContext* rfi = (rfContext*) context;
@@ -167,17 +167,78 @@
 
 void rf_Pointer_New(rdpContext* context, rdpPointer* pointer)
 {
+	RemminaPluginRdpUiObject* ui;
+	rfContext* rfi = (rfContext*) context;
+
+	if ((pointer->andMaskData != 0) && (pointer->xorMaskData != 0))
+	{
+		ui = g_new0(RemminaPluginRdpUiObject, 1);
+		ui->type = REMMINA_RDP_UI_CURSOR;
+		ui->cursor.pointer = (rfPointer*) pointer;
+		ui->cursor.type = REMMINA_RDP_POINTER_NEW;
 
+		rf_queue_ui(rfi->protocol_widget, ui);
+	}
 }
 
 void rf_Pointer_Free(rdpContext* context, rdpPointer* pointer)
 {
+	RemminaPluginRdpUiObject* ui;
+	rfContext* rfi = (rfContext*) context;
+
+	if (G_IS_OBJECT(((rfPointer*) pointer)->cursor))
+	{
+		ui = g_new0(RemminaPluginRdpUiObject, 1);
+		ui->type = REMMINA_RDP_UI_CURSOR;
+		ui->cursor.pointer = (rfPointer*) pointer;
+		ui->cursor.type = REMMINA_RDP_POINTER_FREE;
 
+		rf_queue_ui(rfi->protocol_widget, ui);
+
+		g_mutex_lock(rfi->gmutex);
+		while (G_IS_OBJECT(((rfPointer*) pointer)->cursor))
+		{
+			g_cond_wait(rfi->gcond, rfi->gmutex);
+		}
+		g_mutex_unlock(rfi->gmutex);
+	}
 }
 
 void rf_Pointer_Set(rdpContext* context, rdpPointer* pointer)
 {
+	RemminaPluginRdpUiObject* ui;
+	rfContext* rfi = (rfContext*) context;
+
+	ui = g_new0(RemminaPluginRdpUiObject, 1);
+	ui->type = REMMINA_RDP_UI_CURSOR;
+	ui->cursor.pointer = (rfPointer*) pointer;
+	ui->cursor.type = REMMINA_RDP_POINTER_SET;
+
+	rf_queue_ui(rfi->protocol_widget, ui);
+}
+
+void rf_Pointer_SetNull(rdpContext* context)
+{
+	RemminaPluginRdpUiObject* ui;
+	rfContext* rfi = (rfContext*) context;
+
+	ui = g_new0(RemminaPluginRdpUiObject, 1);
+	ui->type = REMMINA_RDP_UI_CURSOR;
+	ui->cursor.type = REMMINA_RDP_POINTER_NULL;
+
+	rf_queue_ui(rfi->protocol_widget, ui);
+}
+
+void rf_Pointer_SetDefault(rdpContext* context)
+{
+	RemminaPluginRdpUiObject* ui;
+	rfContext* rfi = (rfContext*) context;
+
+	ui = g_new0(RemminaPluginRdpUiObject, 1);
+	ui->type = REMMINA_RDP_UI_CURSOR;
+	ui->cursor.type = REMMINA_RDP_POINTER_DEFAULT;
 
+	rf_queue_ui(rfi->protocol_widget, ui);
 }
 
 /* Glyph Class */
@@ -234,7 +295,7 @@
 #endif
 }
 
-void rf_Glyph_BeginDraw(rdpContext* context, int x, int y, int width, int height, uint32 bgcolor, uint32 fgcolor)
+void rf_Glyph_BeginDraw(rdpContext* context, int x, int y, int width, int height, UINT32 bgcolor, UINT32 fgcolor)
 {
 #ifdef RF_GLYPH
 	rfContext* rfi = (rfContext*) context;
@@ -258,7 +319,7 @@
 #endif
 }
 
-void rf_Glyph_EndDraw(rdpContext* context, int x, int y, int width, int height, uint32 bgcolor, uint32 fgcolor)
+void rf_Glyph_EndDraw(rdpContext* context, int x, int y, int width, int height, UINT32 bgcolor, UINT32 fgcolor)
 {
 #ifdef RF_GLYPH
 	rfContext* rfi = (rfContext*) context;
@@ -279,7 +340,8 @@
 	rdpPointer* pointer;
 	rdpGlyph* glyph;
 
-	bitmap = xnew(rdpBitmap);
+	bitmap = (rdpBitmap*) malloc(sizeof(rdpBitmap));
+	ZeroMemory(bitmap, sizeof(rdpBitmap));
 	bitmap->size = sizeof(rfBitmap);
 
 	bitmap->New = rf_Bitmap_New;
@@ -289,19 +351,23 @@
 	bitmap->SetSurface = rf_Bitmap_SetSurface;
 
 	graphics_register_bitmap(graphics, bitmap);
-	xfree(bitmap);
+	free(bitmap);
 
-	pointer = xnew(rdpPointer);
+	pointer = (rdpPointer*) malloc(sizeof(rdpPointer));
+	ZeroMemory(pointer, sizeof(rdpPointer));
 	pointer->size = sizeof(rfPointer);
 
 	pointer->New = rf_Pointer_New;
 	pointer->Free = rf_Pointer_Free;
 	pointer->Set = rf_Pointer_Set;
+	pointer->SetNull = rf_Pointer_SetNull;
+	pointer->SetDefault = rf_Pointer_SetDefault;
 
 	graphics_register_pointer(graphics, pointer);
-	xfree(pointer);
+	free(pointer);
 
-	glyph = xnew(rdpGlyph);
+	glyph = (rdpGlyph*) malloc(sizeof(rdpGlyph));
+	ZeroMemory(glyph, sizeof(rdpGlyph));
 	glyph->size = sizeof(rfGlyph);
 
 	glyph->New = rf_Glyph_New;
@@ -311,5 +377,5 @@
 	glyph->EndDraw = rf_Glyph_EndDraw;
 
 	graphics_register_glyph(graphics, glyph);
-	xfree(glyph);
+	free(glyph);
 }
diff -urN remmina-plugins/rdp/rdp_plugin.c remmina-plugins/rdp/rdp_plugin.c
--- remmina-plugins/rdp/rdp_plugin.c	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins/rdp/rdp_plugin.c	2014-01-08 23:24:16.227862080 +1100
@@ -24,13 +24,15 @@
 #include "rdp_graphics.h"
 #include "rdp_file.h"
 #include "rdp_settings.h"
+#include "rdp_cliprdr.h"
 
 #include <errno.h>
 #include <pthread.h>
 #include <cairo/cairo-xlib.h>
 #include <freerdp/freerdp.h>
 #include <freerdp/constants.h>
-#include <freerdp/utils/memory.h>
+#include <freerdp/client/cliprdr.h>
+#include <freerdp/client/channels.h>
 
 #define REMMINA_RDP_FEATURE_TOOL_REFRESH		1
 #define REMMINA_RDP_FEATURE_SCALE			2
@@ -38,81 +40,6 @@
 
 RemminaPluginService* remmina_plugin_service = NULL;
 
-/* Migrated from xfreerdp */
-static gboolean rf_get_key_state(KeyCode keycode, int state, XModifierKeymap* modmap)
-{
-	int offset;
-	int modifierpos, key, keysymMask = 0;
-
-	if (keycode == NoSymbol)
-		return FALSE;
-
-	for (modifierpos = 0; modifierpos < 8; modifierpos++)
-	{
-		offset = modmap->max_keypermod * modifierpos;
-
-		for (key = 0; key < modmap->max_keypermod; key++)
-		{
-			if (modmap->modifiermap[offset + key] == keycode)
-				keysymMask |= 1 << modifierpos;
-		}
-	}
-
-	return (state & keysymMask) ? TRUE : FALSE;
-}
-
-void rf_init(RemminaProtocolWidget* gp)
-{
-	int dummy;
-	uint32 state;
-	gint keycode;
-	Window wdummy;
-	XModifierKeymap* modmap;
-	rfContext* rfi;
-
-	rfi = GET_DATA(gp);
-
-	XQueryPointer(rfi->display, GDK_ROOT_WINDOW(), &wdummy, &wdummy, &dummy, &dummy,
-		&dummy, &dummy, &state);
-
-	modmap = XGetModifierMapping(rfi->display);
-
-	keycode = XKeysymToKeycode(rfi->display, XK_Caps_Lock);
-	rfi->capslock_initstate = rf_get_key_state(keycode, state, modmap);
-
-	keycode = XKeysymToKeycode(rfi->display, XK_Num_Lock);
-	rfi->numlock_initstate = rf_get_key_state(keycode, state, modmap);
-
-	XFreeModifiermap(modmap);
-}
-
-void rf_uninit(RemminaProtocolWidget* gp)
-{
-	rfContext* rfi;
-
-	rfi = GET_DATA(gp);
-
-	if (rfi->rfx_context)
-	{
-		rfx_context_free(rfi->rfx_context);
-		rfi->rfx_context = NULL;
-	}
-
-#if 0
-	if (rfi->channels)
-	{
-		freerdp_channels_free(rfi->channels);
-		rfi->channels = NULL;
-	}
-
-	if (rfi->instance)
-	{
-		freerdp_free(rfi->instance);
-		rfi->instance = NULL;
-	}
-#endif
-}
-
 void rf_get_fds(RemminaProtocolWidget* gp, void** rfds, int* rcount)
 {
 	rfContext* rfi;
@@ -126,9 +53,9 @@
 	}
 }
 
-boolean rf_check_fds(RemminaProtocolWidget* gp)
+BOOL rf_check_fds(RemminaProtocolWidget* gp)
 {
-	uint16 flags;
+	UINT16 flags;
 	gchar buf[100];
 	rdpInput* input;
 	rfContext* rfi;
@@ -195,7 +122,7 @@
 			break;
 
 		case REMMINA_RDP_UI_NOCODEC:
-			xfree(obj->nocodec.bitmap);
+			free(obj->nocodec.bitmap);
 			break;
 
 		default:
@@ -205,17 +132,17 @@
 	g_free(obj);
 }
 
-void rf_sw_begin_paint(rdpContext* context)
+void rf_begin_paint(rdpContext* context)
 {
 	rdpGdi* gdi = context->gdi;
 	gdi->primary->hdc->hwnd->invalid->null = 1;
 	gdi->primary->hdc->hwnd->ninvalid = 0;
 }
 
-void rf_sw_end_paint(rdpContext* context)
+void rf_end_paint(rdpContext* context)
 {
-	sint32 x, y;
-	uint32 w, h;
+	INT32 x, y;
+	UINT32 w, h;
 	rdpGdi* gdi;
 	rfContext* rfi;
 	RemminaProtocolWidget* gp;
@@ -243,7 +170,7 @@
 	rf_queue_ui(rfi->protocol_widget, ui);
 }
 
-static void rf_sw_desktop_resize(rdpContext* context)
+static void rf_desktop_resize(rdpContext* context)
 {
 	rfContext* rfi;
 	RemminaProtocolWidget* gp;
@@ -253,8 +180,8 @@
 
 	LOCK_BUFFER(TRUE)
 
-	remmina_plugin_service->protocol_plugin_set_width(gp, rfi->settings->width);
-	remmina_plugin_service->protocol_plugin_set_height(gp, rfi->settings->height);
+	remmina_plugin_service->protocol_plugin_set_width(gp, rfi->settings->DesktopWidth);
+	remmina_plugin_service->protocol_plugin_set_height(gp, rfi->settings->DesktopHeight);
 
 	UNLOCK_BUFFER(TRUE)
 
@@ -265,39 +192,7 @@
 	remmina_plugin_service->protocol_plugin_emit_signal(gp, "desktop-resize");
 }
 
-void rf_hw_begin_paint(rdpContext* context)
-{
-
-}
-
-void rf_hw_end_paint(rdpContext* context)
-{
-
-}
-
-static void rf_hw_desktop_resize(rdpContext* context)
-{
-	rfContext* rfi;
-	RemminaProtocolWidget* gp;
-
-	rfi = (rfContext*) context;
-	gp = rfi->protocol_widget;
-
-	LOCK_BUFFER(TRUE)
-
-	remmina_plugin_service->protocol_plugin_set_width(gp, rfi->settings->width);
-	remmina_plugin_service->protocol_plugin_set_height(gp, rfi->settings->height);
-
-	UNLOCK_BUFFER(TRUE)
-
-	THREADS_ENTER
-	remmina_rdp_event_update_scale(gp);
-	THREADS_LEAVE
-
-	remmina_plugin_service->protocol_plugin_emit_signal(gp, "desktop-resize");
-}
-
-static boolean remmina_rdp_pre_connect(freerdp* instance)
+static BOOL remmina_rdp_pre_connect(freerdp* instance)
 {
 	rfContext* rfi;
 	rdpSettings* settings;
@@ -307,110 +202,95 @@
 	settings = instance->settings;
 	gp = rfi->protocol_widget;
 
-	settings->bitmap_cache = True;
-	settings->offscreen_bitmap_cache = True;
+	settings->BitmapCacheEnabled = True;
+	settings->OffscreenSupportLevel = True;
 
-	settings->order_support[NEG_DSTBLT_INDEX] = True;
-	settings->order_support[NEG_PATBLT_INDEX] = True;
-	settings->order_support[NEG_SCRBLT_INDEX] = True;
-	settings->order_support[NEG_OPAQUE_RECT_INDEX] = True;
-	settings->order_support[NEG_DRAWNINEGRID_INDEX] = False;
-	settings->order_support[NEG_MULTIDSTBLT_INDEX] = False;
-	settings->order_support[NEG_MULTIPATBLT_INDEX] = False;
-	settings->order_support[NEG_MULTISCRBLT_INDEX] = False;
-	settings->order_support[NEG_MULTIOPAQUERECT_INDEX] = True;
-	settings->order_support[NEG_MULTI_DRAWNINEGRID_INDEX] = False;
-	settings->order_support[NEG_LINETO_INDEX] = True;
-	settings->order_support[NEG_POLYLINE_INDEX] = True;
-	settings->order_support[NEG_MEMBLT_INDEX] = True;
-	settings->order_support[NEG_MEM3BLT_INDEX] = False;
-	settings->order_support[NEG_MEMBLT_V2_INDEX] = True;
-	settings->order_support[NEG_MEM3BLT_V2_INDEX] = False;
-	settings->order_support[NEG_SAVEBITMAP_INDEX] = False;
-	settings->order_support[NEG_GLYPH_INDEX_INDEX] = True;
-	settings->order_support[NEG_FAST_INDEX_INDEX] = True;
-	settings->order_support[NEG_FAST_GLYPH_INDEX] = False;
-	settings->order_support[NEG_POLYGON_SC_INDEX] = False;
-	settings->order_support[NEG_POLYGON_CB_INDEX] = False;
-	settings->order_support[NEG_ELLIPSE_SC_INDEX] = False;
-	settings->order_support[NEG_ELLIPSE_CB_INDEX] = False;
-
-	if (settings->rfx_codec == True)
-	{
-		settings->frame_acknowledge = False;
-		settings->large_pointer = True;
-		settings->performance_flags = PERF_FLAG_NONE;
+	settings->OrderSupport[NEG_DSTBLT_INDEX] = True;
+	settings->OrderSupport[NEG_PATBLT_INDEX] = True;
+	settings->OrderSupport[NEG_SCRBLT_INDEX] = True;
+	settings->OrderSupport[NEG_OPAQUE_RECT_INDEX] = True;
+	settings->OrderSupport[NEG_DRAWNINEGRID_INDEX] = False;
+	settings->OrderSupport[NEG_MULTIDSTBLT_INDEX] = False;
+	settings->OrderSupport[NEG_MULTIPATBLT_INDEX] = False;
+	settings->OrderSupport[NEG_MULTISCRBLT_INDEX] = False;
+	settings->OrderSupport[NEG_MULTIOPAQUERECT_INDEX] = True;
+	settings->OrderSupport[NEG_MULTI_DRAWNINEGRID_INDEX] = False;
+	settings->OrderSupport[NEG_LINETO_INDEX] = True;
+	settings->OrderSupport[NEG_POLYLINE_INDEX] = True;
+	settings->OrderSupport[NEG_MEMBLT_INDEX] = True;
+	settings->OrderSupport[NEG_MEM3BLT_INDEX] = False;
+	settings->OrderSupport[NEG_MEMBLT_V2_INDEX] = True;
+	settings->OrderSupport[NEG_MEM3BLT_V2_INDEX] = False;
+	settings->OrderSupport[NEG_SAVEBITMAP_INDEX] = False;
+	settings->OrderSupport[NEG_GLYPH_INDEX_INDEX] = True;
+	settings->OrderSupport[NEG_FAST_INDEX_INDEX] = True;
+	settings->OrderSupport[NEG_FAST_GLYPH_INDEX] = False;
+	settings->OrderSupport[NEG_POLYGON_SC_INDEX] = False;
+	settings->OrderSupport[NEG_POLYGON_CB_INDEX] = False;
+	settings->OrderSupport[NEG_ELLIPSE_SC_INDEX] = False;
+	settings->OrderSupport[NEG_ELLIPSE_CB_INDEX] = False;
+
+	if (settings->RemoteFxCodec == True)
+	{
+		settings->FrameAcknowledge = False;
+		settings->LargePointerFlag = True;
+		settings->PerformanceFlags = PERF_FLAG_NONE;
 
 		rfi->rfx_context = rfx_context_new();
-		rfx_context_set_cpu_opt(rfi->rfx_context, CPU_SSE2);
 	}
 
 	freerdp_channels_pre_connect(rfi->channels, instance);
 
-	rfi->clrconv = xnew(CLRCONV);
-	rfi->clrconv->alpha = true;
-	rfi->clrconv->invert = false;
-	rfi->clrconv->rgb555 = false;
-	rfi->clrconv->palette = xnew(rdpPalette);
+	rfi->clrconv = freerdp_clrconv_new(CLRCONV_ALPHA);
 
 	instance->context->cache = cache_new(instance->settings);
 
 	return True;
 }
 
-static boolean remmina_rdp_post_connect(freerdp* instance)
+
+static BOOL remmina_rdp_post_connect(freerdp* instance)
 {
 	rfContext* rfi;
-	XGCValues gcv = { 0 };
 	RemminaProtocolWidget* gp;
 	RemminaPluginRdpUiObject* ui;
+	rdpGdi* gdi;
+	UINT32 flags;
 
 	rfi = (rfContext*) instance->context;
 	gp = rfi->protocol_widget;
 
-	rfi->width = rfi->settings->width;
-	rfi->height = rfi->settings->height;
-	rfi->srcBpp = rfi->settings->color_depth;
-
-	rfi->drawable = DefaultRootWindow(rfi->display);
-	rfi->primary = XCreatePixmap(rfi->display, rfi->drawable, rfi->width, rfi->height, rfi->depth);
-	rfi->drawing = rfi->primary;
-
-	rfi->drawable = rfi->primary;
-	rfi->gc = XCreateGC(rfi->display, rfi->drawable, GCGraphicsExposures, &gcv);
-	rfi->gc_default = XCreateGC(rfi->display, rfi->drawable, GCGraphicsExposures, &gcv);
-	rfi->bitmap_mono = XCreatePixmap(rfi->display, rfi->drawable, 8, 8, 1);
-	rfi->gc_mono = XCreateGC(rfi->display, rfi->bitmap_mono, GCGraphicsExposures, &gcv);
+	rfi->width = rfi->settings->DesktopWidth;
+	rfi->height = rfi->settings->DesktopHeight;
+	rfi->srcBpp = rfi->settings->ColorDepth;
 
-	if (rfi->settings->rfx_codec == false)
-		rfi->sw_gdi = true;
+	if (rfi->settings->RemoteFxCodec == FALSE)
+		rfi->sw_gdi = TRUE;
 
 	rf_register_graphics(instance->context->graphics);
 
-	if (rfi->sw_gdi)
-	{
-		rdpGdi* gdi;
-		uint32 flags;
-
-		flags = CLRCONV_ALPHA;
-
-		if (rfi->bpp > 16)
-			flags |= CLRBUF_32BPP;
-		else
-			flags |= CLRBUF_16BPP;
-
-		gdi_init(instance, flags, NULL);
-		gdi = instance->context->gdi;
-		rfi->primary_buffer = gdi->primary_buffer;
+	flags = CLRCONV_ALPHA;
 
-		rfi->image = XCreateImage(rfi->display, rfi->visual, rfi->depth, ZPixmap, 0,
-				(char*) rfi->primary_buffer, rfi->width, rfi->height, rfi->scanline_pad, 0);
+	if (rfi->bpp == 32)
+	{
+		flags |= CLRBUF_32BPP;
+		rfi->cairo_format = CAIRO_FORMAT_ARGB32;
+	}
+	else if (rfi->bpp == 24)
+	{
+		flags |= CLRBUF_24BPP;
+		rfi->cairo_format = CAIRO_FORMAT_RGB24;
 	}
 	else
 	{
-		rf_gdi_register_update_callbacks(instance->update);
+		flags |= CLRBUF_16BPP;
+		rfi->cairo_format = CAIRO_FORMAT_RGB16_565;
 	}
 
+	gdi_init(instance, flags, NULL);
+	gdi = instance->context->gdi;
+	rfi->primary_buffer = gdi->primary_buffer;
+
 	rfi->hdc = gdi_GetDC();
 	rfi->hdc->bitsPerPixel = rfi->bpp;
 	rfi->hdc->bytesPerPixel = rfi->bpp / 8;
@@ -425,6 +305,7 @@
 
 	pointer_cache_register_callbacks(instance->update);
 
+/*
 	if (rfi->sw_gdi != true)
 	{
 		glyph_cache_register_callbacks(instance->update);
@@ -433,19 +314,11 @@
 		offscreen_cache_register_callbacks(instance->update);
 		palette_cache_register_callbacks(instance->update);
 	}
+*/
 
-	if (rfi->sw_gdi)
-	{
-		instance->update->BeginPaint = rf_sw_begin_paint;
-		instance->update->EndPaint = rf_sw_end_paint;
-		instance->update->DesktopResize = rf_sw_desktop_resize;
-	}
-	else
-	{
-		instance->update->BeginPaint = rf_hw_begin_paint;
-		instance->update->EndPaint = rf_hw_end_paint;
-		instance->update->DesktopResize = rf_hw_desktop_resize;
-	}
+	instance->update->BeginPaint = rf_begin_paint;
+	instance->update->EndPaint = rf_end_paint;
+	instance->update->DesktopResize = rf_desktop_resize;
 
 	freerdp_channels_post_connect(rfi->channels, instance);
 
@@ -458,7 +331,7 @@
 	return True;
 }
 
-static boolean remmina_rdp_authenticate(freerdp* instance, char** username, char** password, char** domain)
+static BOOL remmina_rdp_authenticate(freerdp* instance, char** username, char** password, char** domain)
 {
 	gchar* s;
 	gint ret;
@@ -478,7 +351,7 @@
 
 		if (s)
 		{
-			rfi->settings->username = xstrdup(s);
+			rfi->settings->Username = strdup(s);
 			g_free(s);
 		}
 
@@ -486,7 +359,7 @@
 
 		if (s)
 		{
-			rfi->settings->password = xstrdup(s);
+			rfi->settings->Password = strdup(s);
 			g_free(s);
 		}
 
@@ -494,7 +367,7 @@
 
 		if (s)
 		{
-			rfi->settings->domain = xstrdup(s);
+			rfi->settings->Domain = strdup(s);
 			g_free(s);
 		}
 
@@ -509,7 +382,7 @@
 	return True;
 }
 
-static boolean remmina_rdp_verify_certificate(freerdp* instance, char* subject, char* issuer, char* fingerprint)
+static BOOL remmina_rdp_verify_certificate(freerdp* instance, char* subject, char* issuer, char* fingerprint)
 {
 	gint status;
 	rfContext* rfi;
@@ -527,12 +400,40 @@
 
 	return False;
 }
+static BOOL remmina_rdp_verify_changed_certificate(freerdp* instance, char* subject, char* issuer, char* new_fingerprint, char* old_fingerprint)
+{
+	gint status;
+	rfContext* rfi;
+	RemminaProtocolWidget* gp;
 
-static int remmina_rdp_receive_channel_data(freerdp* instance, int channelId, uint8* data, int size, int flags, int total_size)
+	rfi = (rfContext*) instance->context;
+	gp = rfi->protocol_widget;
+
+	THREADS_ENTER
+	status = remmina_plugin_service->protocol_plugin_changed_certificate(gp, subject, issuer, new_fingerprint, old_fingerprint);
+	THREADS_LEAVE
+
+	if (status == GTK_RESPONSE_OK)
+		return True;
+
+	return False;
+}
+
+static int remmina_rdp_receive_channel_data(freerdp* instance, int channelId, UINT8* data, int size, int flags, int total_size)
 {
 	return freerdp_channels_data(instance, channelId, data, size, flags, total_size);
 }
 
+void remmina_rdp_channels_process_event(RemminaProtocolWidget* gp, wMessage* event)
+{
+	switch (GetMessageClass(event->id))
+	{
+		case CliprdrChannel_Class:
+			remmina_rdp_channel_cliprdr_process(gp, event);
+			break;
+	}
+}
+
 static void remmina_rdp_main_loop(RemminaProtocolWidget* gp)
 {
 	int i;
@@ -545,6 +446,7 @@
 	fd_set rfds_set;
 	fd_set wfds_set;
 	rfContext* rfi;
+	wMessage* event;
 
 	memset(rfds, 0, sizeof(rfds));
 	memset(wfds, 0, sizeof(wfds));
@@ -570,7 +472,7 @@
 		FD_ZERO(&rfds_set);
 		for (i = 0; i < rcount; i++)
 		{
-			fds = (int) (uint64) (rfds[i]);
+			fds = (int) (UINT64) (rfds[i]);
 
 			if (fds > max_fds)
 				max_fds = fds;
@@ -618,6 +520,12 @@
 		{
 			break;
 		}
+		else
+		{
+			event = freerdp_channels_pop_event(rfi->channels);
+			if (event)
+				remmina_rdp_channels_process_event(gp, event);
+		}
 		/* check ui */
 		if (!rf_check_fds(gp))
 		{
@@ -626,6 +534,27 @@
 	}
 }
 
+gboolean remmina_rdp_load_plugin(rdpChannels* channels, rdpSettings* settings, const char* name, RDP_PLUGIN_DATA* plugin_data)
+{
+	void* entry = NULL;
+
+	entry = freerdp_channels_client_find_static_entry("VirtualChannelEntry", name);
+
+	if (entry)
+	{
+		if (freerdp_channels_client_load(channels, settings, entry, plugin_data) == 0)
+		{
+			g_printf("loading channel %s (static)\n", name);
+			return TRUE;
+		}
+	}
+
+	g_printf("loading channel %s (plugin)\n", name);
+	freerdp_channels_load_plugin(channels, settings, name, plugin_data);
+
+	return TRUE;
+}
+
 static gboolean remmina_rdp_main(RemminaProtocolWidget* gp)
 {
 	gchar* s;
@@ -648,29 +577,29 @@
 		return FALSE;
 
 	remmina_plugin_service->get_server_port(s, 3389, &host, &port);
-	rfi->settings->hostname = xstrdup(host);
+	rfi->settings->ServerHostname = strdup(host);
 	g_free(host);
 	g_free(s);
-	rfi->settings->port = port;
+	rfi->settings->ServerPort = port;
 
-	rfi->settings->color_depth = remmina_plugin_service->file_get_int(remminafile, "colordepth", 0);
+	rfi->settings->ColorDepth = remmina_plugin_service->file_get_int(remminafile, "colordepth", 0);
 
-	if (rfi->settings->color_depth == 0)
+	if (rfi->settings->ColorDepth == 0)
 	{
-		rfi->settings->rfx_codec = True;
-		rfi->settings->color_depth = 32;
+		rfi->settings->RemoteFxCodec = True;
+		rfi->settings->ColorDepth = 32;
 	}
 
-	rfi->settings->width = remmina_plugin_service->file_get_int(remminafile, "resolution_width", 1024);
-	rfi->settings->height = remmina_plugin_service->file_get_int(remminafile, "resolution_height", 768);
-	remmina_plugin_service->protocol_plugin_set_width(gp, rfi->settings->width);
-	remmina_plugin_service->protocol_plugin_set_height(gp, rfi->settings->height);
+	rfi->settings->DesktopWidth = remmina_plugin_service->file_get_int(remminafile, "resolution_width", 1024);
+	rfi->settings->DesktopHeight = remmina_plugin_service->file_get_int(remminafile, "resolution_height", 768);
+	remmina_plugin_service->protocol_plugin_set_width(gp, rfi->settings->DesktopWidth);
+	remmina_plugin_service->protocol_plugin_set_height(gp, rfi->settings->DesktopHeight);
 
 	if (remmina_plugin_service->file_get_string(remminafile, "username"))
-		rfi->settings->username = xstrdup(remmina_plugin_service->file_get_string(remminafile, "username"));
+		rfi->settings->Username = strdup(remmina_plugin_service->file_get_string(remminafile, "username"));
 
 	if (remmina_plugin_service->file_get_string(remminafile, "domain"))
-		rfi->settings->domain = xstrdup(remmina_plugin_service->file_get_string(remminafile, "domain"));
+		rfi->settings->Domain = strdup(remmina_plugin_service->file_get_string(remminafile, "domain"));
 
 	THREADS_ENTER
 	s = remmina_plugin_service->file_get_secret(remminafile, "password");
@@ -678,29 +607,29 @@
 
 	if (s)
 	{
-		rfi->settings->password = xstrdup(s);
-		rfi->settings->autologon = 1;
+		rfi->settings->Password = strdup(s);
+		rfi->settings->AutoLogonEnabled = 1;
 		g_free(s);
 	}
 
 	if (remmina_plugin_service->file_get_string(remminafile, "clientname"))
 	{
-		strncpy(rfi->settings->client_hostname, remmina_plugin_service->file_get_string(remminafile, "clientname"),
-			sizeof(rfi->settings->client_hostname) - 1);
+		strncpy(rfi->settings->ClientHostname, remmina_plugin_service->file_get_string(remminafile, "clientname"),
+			sizeof(rfi->settings->ClientHostname) - 1);
 	}
 	else
 	{
-		strncpy(rfi->settings->client_hostname, g_get_host_name(), sizeof(rfi->settings->client_hostname) - 1);
+		strncpy(rfi->settings->ClientHostname, g_get_host_name(), sizeof(rfi->settings->ClientHostname) - 1);
 	}
 
 	if (remmina_plugin_service->file_get_string(remminafile, "exec"))
 	{
-		rfi->settings->shell = xstrdup(remmina_plugin_service->file_get_string(remminafile, "exec"));
+		rfi->settings->AlternateShell = strdup(remmina_plugin_service->file_get_string(remminafile, "exec"));
 	}
 
 	if (remmina_plugin_service->file_get_string(remminafile, "execpath"))
 	{
-		rfi->settings->directory = xstrdup(remmina_plugin_service->file_get_string(remminafile, "execpath"));
+		rfi->settings->ShellWorkingDirectory = strdup(remmina_plugin_service->file_get_string(remminafile, "execpath"));
 	}
 
 	s = g_strdup_printf("rdp_quality_%i", remmina_plugin_service->file_get_int(remminafile, "quality", DEFAULT_QUALITY_0));
@@ -709,63 +638,63 @@
 
 	if (value && value[0])
 	{
-		rfi->settings->performance_flags = strtoul(value, NULL, 16);
+		rfi->settings->PerformanceFlags = strtoul(value, NULL, 16);
 	}
 	else
 	{
 		switch (remmina_plugin_service->file_get_int(remminafile, "quality", DEFAULT_QUALITY_0))
 		{
 			case 9:
-				rfi->settings->performance_flags = DEFAULT_QUALITY_9;
+				rfi->settings->PerformanceFlags = DEFAULT_QUALITY_9;
 				break;
 
 			case 2:
-				rfi->settings->performance_flags = DEFAULT_QUALITY_2;
+				rfi->settings->PerformanceFlags = DEFAULT_QUALITY_2;
 				break;
 
 			case 1:
-				rfi->settings->performance_flags = DEFAULT_QUALITY_1;
+				rfi->settings->PerformanceFlags = DEFAULT_QUALITY_1;
 				break;
 
 			case 0:
 			default:
-				rfi->settings->performance_flags = DEFAULT_QUALITY_0;
+				rfi->settings->PerformanceFlags = DEFAULT_QUALITY_0;
 				break;
 		}
 	}
 	g_free(value);
 
-	rfi->settings->kbd_layout = remmina_rdp_settings_get_keyboard_layout();
+	rfi->settings->KeyboardLayout = remmina_rdp_settings_get_keyboard_layout();
 
 	if (remmina_plugin_service->file_get_int(remminafile, "console", FALSE))
 	{
-		rfi->settings->console_session = True;
+		rfi->settings->ConsoleSession = True;
 	}
 
 	cs = remmina_plugin_service->file_get_string(remminafile, "security");
 
 	if (g_strcmp0(cs, "rdp") == 0)
 	{
-		rfi->settings->rdp_security = True;
-		rfi->settings->tls_security = False;
-		rfi->settings->nla_security = False;
+		rfi->settings->RdpSecurity = True;
+		rfi->settings->TlsSecurity = False;
+		rfi->settings->NlaSecurity = False;
 	}
 	else if (g_strcmp0(cs, "tls") == 0)
 	{
-		rfi->settings->rdp_security = False;
-		rfi->settings->tls_security = True;
-		rfi->settings->nla_security = False;
+		rfi->settings->RdpSecurity = False;
+		rfi->settings->TlsSecurity = True;
+		rfi->settings->NlaSecurity = False;
 	}
 	else if (g_strcmp0(cs, "nla") == 0)
 	{
-		rfi->settings->rdp_security = False;
-		rfi->settings->tls_security = False;
-		rfi->settings->nla_security = True;
+		rfi->settings->RdpSecurity = False;
+		rfi->settings->TlsSecurity = False;
+		rfi->settings->NlaSecurity = True;
 	}
 
-	rfi->settings->compression = True;
-	rfi->settings->fastpath_input = True;
-	rfi->settings->fastpath_output = True;
+	rfi->settings->CompressionEnabled = True;
+	rfi->settings->FastPathInput = True;
+	rfi->settings->FastPathOutput = True;
 
 	drdynvc_num = 0;
 	rdpsnd_num = 0;
@@ -773,7 +702,7 @@
 
 	if (g_strcmp0(cs, "remote") == 0)
 	{
-		rfi->settings->console_audio = 1;
+		rfi->settings->RemoteConsoleAudio = 1;
 	}
 	else if (g_str_has_prefix(cs, "local"))
 	{
@@ -801,7 +730,7 @@
 			}
 		}
 
-		freerdp_channels_load_plugin(rfi->channels, rfi->settings, "rdpsnd", rfi->rdpsnd_data);
+		remmina_rdp_load_plugin(rfi->channels, rfi->settings, "rdpsnd", rfi->rdpsnd_data);
 
 		rfi->drdynvc_data[drdynvc_num].size = sizeof(RDP_PLUGIN_DATA);
 		rfi->drdynvc_data[drdynvc_num].data[0] = "audin";
@@ -810,12 +739,12 @@
 
 	if (drdynvc_num)
 	{
-		freerdp_channels_load_plugin(rfi->channels, rfi->settings, "drdynvc", rfi->drdynvc_data);
+		remmina_rdp_load_plugin(rfi->channels, rfi->settings, "drdynvc", rfi->drdynvc_data);
 	}
 
 	if (!remmina_plugin_service->file_get_int(remminafile, "disableclipboard", FALSE))
 	{
-		freerdp_channels_load_plugin(rfi->channels, rfi->settings, "cliprdr", NULL);
+		remmina_rdp_load_plugin(rfi->channels, rfi->settings, "cliprdr", NULL);
 	}
 
 	rdpdr_num = 0;
@@ -839,9 +768,17 @@
 		rdpdr_num++;
 	}
 
+	if (remmina_plugin_service->file_get_int(remminafile, "sharesmartcard", FALSE))
+	{
+		rfi->rdpdr_data[rdpdr_num].size = sizeof(RDP_PLUGIN_DATA);
+		rfi->rdpdr_data[rdpdr_num].data[0] = "scard";
+		rfi->rdpdr_data[rdpdr_num].data[1] = "scard";
+		rdpdr_num++;
+	}
+
 	if (rdpdr_num)
 	{
-		freerdp_channels_load_plugin(rfi->channels, rfi->settings, "rdpdr", rfi->rdpdr_data);
+		remmina_rdp_load_plugin(rfi->channels, rfi->settings, "rdpdr", rfi->rdpdr_data);
 	}
 
 	if (!freerdp_connect(rfi->instance))
@@ -849,7 +786,7 @@
 		if (!rfi->user_cancelled)
 		{
 			remmina_plugin_service->protocol_plugin_set_error(gp, _("Unable to connect to RDP server %s"),
-				rfi->settings->hostname);
+				rfi->settings->ServerHostname);
 		}
 
 		return FALSE;
@@ -886,13 +823,14 @@
 	instance->PostConnect = remmina_rdp_post_connect;
 	instance->Authenticate = remmina_rdp_authenticate;
 	instance->VerifyCertificate = remmina_rdp_verify_certificate;
+	instance->VerifyChangedCertificate = remmina_rdp_verify_changed_certificate;
 	instance->ReceiveChannelData = remmina_rdp_receive_channel_data;
 
-	instance->context_size = sizeof(rfContext);
+	instance->ContextSize = sizeof(rfContext);
 	freerdp_context_new(instance);
 	rfi = (rfContext*) instance->context;
 
-	g_object_set_data_full(G_OBJECT(gp), "plugin-data", rfi, xfree);
+	g_object_set_data_full(G_OBJECT(gp), "plugin-data", rfi, free);
 
 	rfi->protocol_widget = gp;
 	rfi->instance = instance;
@@ -901,8 +839,10 @@
 
 	pthread_mutex_init(&rfi->mutex, NULL);
 
+	rfi->gmutex = g_mutex_new();
+	rfi->gcond = g_cond_new();
+
 	remmina_rdp_event_init(gp);
-	rf_init(gp);
 }
 
 static gboolean remmina_rdp_open_connection(RemminaProtocolWidget* gp)
@@ -928,8 +868,10 @@
 static gboolean remmina_rdp_close_connection(RemminaProtocolWidget* gp)
 {
 	rfContext* rfi;
+	freerdp* instance;
 
 	rfi = GET_DATA(gp);
+	instance = rfi->instance;
 
 	if (rfi->thread)
 	{
@@ -939,22 +881,39 @@
 			pthread_join(rfi->thread, NULL);
 	}
 
-	if (rfi->instance)
+	pthread_mutex_destroy(&rfi->mutex);
+
+	g_mutex_free(rfi->gmutex);
+	g_cond_free(rfi->gcond);
+
+	remmina_rdp_event_uninit(gp);
+	remmina_plugin_service->protocol_plugin_emit_signal(gp, "disconnect");
+
+	if (instance)
 	{
 		if (rfi->channels)
 		{
-			//freerdp_channels_close(rfi->channels, rfi->instance);
+			//freerdp_channels_close(rfi->channels, instance);
+			freerdp_channels_free(rfi->channels);
+			rfi->channels = NULL;
+		}
+		if (freerdp_shall_disconnect(instance))
+		{
+			freerdp_disconnect(instance);
 		}
-
-		freerdp_disconnect(rfi->instance);
 	}
 
-	pthread_mutex_destroy(&rfi->mutex);
-
-	remmina_rdp_event_uninit(gp);
-	remmina_plugin_service->protocol_plugin_emit_signal(gp, "disconnect");
+	if (rfi->rfx_context)
+	{
+		rfx_context_free(rfi->rfx_context);
+		rfi->rfx_context = NULL;
+	}
 
-	rf_uninit(gp);
+	if (instance)
+	{
+		//freerdp_context_free(instance); /* context is rfContext* rfi */
+		freerdp_free(instance);
+	}
 
 	return FALSE;
 }
@@ -1055,6 +1014,7 @@
 	{ REMMINA_PROTOCOL_SETTING_TYPE_TEXT, "exec", N_("Startup program"), FALSE, NULL, NULL },
 	{ REMMINA_PROTOCOL_SETTING_TYPE_TEXT, "execpath", N_("Startup path"), FALSE, NULL, NULL },
 	{ REMMINA_PROTOCOL_SETTING_TYPE_CHECK, "shareprinter", N_("Share local printers"), TRUE, NULL, NULL },
+	{ REMMINA_PROTOCOL_SETTING_TYPE_CHECK, "sharesmartcard", N_("Share smartcard"), TRUE, NULL, NULL },
 	{ REMMINA_PROTOCOL_SETTING_TYPE_CHECK, "disableclipboard", N_("Disable clipboard sync"), FALSE, NULL, NULL },
 	{ REMMINA_PROTOCOL_SETTING_TYPE_CHECK, "console", N_("Attach to console (Windows 2003 / 2003 R2)"), FALSE, NULL, NULL },
 	{ REMMINA_PROTOCOL_SETTING_TYPE_END, NULL, NULL, FALSE, NULL, NULL }
diff -urN remmina-plugins/rdp/rdp_plugin.h remmina-plugins/rdp/rdp_plugin.h
--- remmina-plugins/rdp/rdp_plugin.h	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins/rdp/rdp_plugin.h	2014-01-08 02:31:52.000000000 +1100
@@ -48,7 +48,7 @@
 struct rf_pointer
 {
 	rdpPointer pointer;
-	Cursor cursor;
+	GdkCursor* cursor;
 };
 typedef struct rf_pointer rfPointer;
 
@@ -56,6 +56,7 @@
 {
 	rdpBitmap bitmap;
 	Pixmap pixmap;
+	cairo_surface_t* surface;
 };
 typedef struct rf_bitmap rfBitmap;
 
@@ -82,6 +83,9 @@
 	gboolean scale;
 	gboolean user_cancelled;
 
+	GMutex* gmutex;
+	GCond* gcond;
+
 	RDP_PLUGIN_DATA rdpdr_data[5];
 	RDP_PLUGIN_DATA drdynvc_data[5];
 	RDP_PLUGIN_DATA rdpsnd_data[5];
@@ -96,33 +100,21 @@
 	gdouble scale_x;
 	gdouble scale_y;
 	guint scale_handler;
-	gboolean capslock_initstate;
-	gboolean numlock_initstate;
 	gboolean use_client_keymap;
 
 	HGDI_DC hdc;
 	gint srcBpp;
-	Display* display;
-	Visual* visual;
-	Drawable drawable;
-	Drawable drw_surface;
-	Pixmap rgb_surface;
-	GC gc;
-	GC gc_default;
-	Pixmap bitmap_mono;
-	GC gc_mono;
-	gint depth;
+	GdkDisplay* display;
+	GdkVisual* visual;
+	cairo_surface_t* surface;
+	cairo_format_t cairo_format;
 	gint bpp;
 	gint width;
 	gint height;
 	gint scanline_pad;
 	gint* colormap;
 	HCLRCONV clrconv;
-	Pixmap primary;
-	Pixmap drawing;
-	XImage* image;
-	uint8* primary_buffer;
-	cairo_surface_t* rgb_cairo_surface;
+	UINT8* primary_buffer;
 
 	guint object_id_seq;
 	GHashTable* object_table;
@@ -133,6 +125,11 @@
 	GArray* pressed_keys;
 	GAsyncQueue* event_queue;
 	gint event_pipe[2];
+
+	GAsyncQueue* clipboard_queue;
+	UINT32 format;
+	gboolean clipboard_wait;
+	gulong clipboard_handler;
 };
 
 typedef enum
@@ -148,15 +145,15 @@
 	{
 		struct
 		{
-			boolean up;
-			boolean extended;
-			uint8 key_code;
+			BOOL up;
+			BOOL extended;
+			UINT8 key_code;
 		} key_event;
 		struct
 		{
-			uint16 flags;
-			uint16 x;
-			uint16 y;
+			UINT16 flags;
+			UINT16 x;
+			UINT16 y;
 		} mouse_event;
 	};
 };
@@ -166,10 +163,28 @@
 {
 	REMMINA_RDP_UI_UPDATE_REGION = 0,
 	REMMINA_RDP_UI_CONNECTED,
+	REMMINA_RDP_UI_CURSOR,
 	REMMINA_RDP_UI_RFX,
-	REMMINA_RDP_UI_NOCODEC
+	REMMINA_RDP_UI_NOCODEC,
+	REMMINA_RDP_UI_CLIPBOARD
 } RemminaPluginRdpUiType;
 
+typedef enum
+{
+	REMMINA_RDP_UI_CLIPBOARD_FORMATLIST,
+	REMMINA_RDP_UI_CLIPBOARD_GET_DATA,
+	REMMINA_RDP_UI_CLIPBOARD_SET_DATA
+} RemminaPluginRdpUiClipboardType;
+
+typedef enum
+{
+	REMMINA_RDP_POINTER_NEW,
+	REMMINA_RDP_POINTER_FREE,
+	REMMINA_RDP_POINTER_SET,
+	REMMINA_RDP_POINTER_NULL,
+	REMMINA_RDP_POINTER_DEFAULT
+} RemminaPluginRdpUiPointerType;
+
 struct remmina_plugin_rdp_ui_object
 {
 	RemminaPluginRdpUiType type;
@@ -184,6 +199,11 @@
 		} region;
 		struct
 		{
+			rfPointer* pointer;
+			RemminaPluginRdpUiPointerType type;
+		} cursor;
+		struct
+		{
 			gint left;
 			gint top;
 			RFX_MESSAGE* message;
@@ -194,8 +214,14 @@
 			gint top;
 			gint width;
 			gint height;
-			uint8* bitmap;
+			UINT8* bitmap;
 		} nocodec;
+		struct
+		{
+			RemminaPluginRdpUiClipboardType type;
+			GtkTargetList* targetlist;
+			UINT32 format;
+		} clipboard;
 	};
 };
 typedef struct remmina_plugin_rdp_ui_object RemminaPluginRdpUiObject;
@@ -203,7 +229,7 @@
 void rf_init(RemminaProtocolWidget* gp);
 void rf_uninit(RemminaProtocolWidget* gp);
 void rf_get_fds(RemminaProtocolWidget* gp, void** rfds, int* rcount);
-boolean rf_check_fds(RemminaProtocolWidget* gp);
+BOOL rf_check_fds(RemminaProtocolWidget* gp);
 void rf_queue_ui(RemminaProtocolWidget* gp, RemminaPluginRdpUiObject* ui);
 void rf_object_free(RemminaProtocolWidget* gp, RemminaPluginRdpUiObject* obj);
 
diff -urN remmina-plugins/rdp/rdp_settings.c remmina-plugins/rdp/rdp_settings.c
--- remmina-plugins/rdp/rdp_settings.c	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins/rdp/rdp_settings.c	2014-01-08 02:31:52.000000000 +1100
@@ -1,6 +1,6 @@
 /*
  * Remmina - The GTK+ Remote Desktop Client
- * Copyright (C) 2010-2011 Vic Lee 
+ * Copyright (C) 2010-2011 Vic Lee
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -14,20 +14,20 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, 
+ * Foundation, Inc., 59 Temple Place, Suite 330,
  * Boston, MA 02111-1307, USA.
  */
 
 #include "rdp_plugin.h"
 #include "rdp_settings.h"
-#include <freerdp/kbd/kbd.h>
+#include <freerdp/locale/keyboard.h>
 
 static guint keyboard_layout = 0;
 static guint rdp_keyboard_layout = 0;
 
 static void remmina_rdp_settings_kbd_init(void)
 {
-	keyboard_layout = freerdp_kbd_init(GDK_DISPLAY_XDISPLAY(gdk_display_get_default()), rdp_keyboard_layout);
+	keyboard_layout = freerdp_keyboard_init(rdp_keyboard_layout);
 }
 
 void remmina_rdp_settings_init(void)
@@ -141,7 +141,7 @@
 	gint i;
 	gchar* s;
 	GtkTreeIter iter;
-	rdpKeyboardLayout* layouts;
+	RDP_KEYBOARD_LAYOUT* layouts;
 
 	gtk_list_store_append(table->keyboard_layout_store, &iter);
 	gtk_list_store_set(table->keyboard_layout_store, &iter, 0, 0, 1, _("<Auto detect>"), -1);
@@ -151,7 +151,7 @@
 
 	gtk_label_set_text(GTK_LABEL(table->keyboard_layout_label), "-");
 
-	layouts = freerdp_kbd_get_layouts(RDP_KEYBOARD_LAYOUT_TYPE_STANDARD | RDP_KEYBOARD_LAYOUT_TYPE_VARIANT);
+	layouts = freerdp_keyboard_get_layouts(RDP_KEYBOARD_LAYOUT_TYPE_STANDARD | RDP_KEYBOARD_LAYOUT_TYPE_VARIANT);
 
 	for (i = 0; layouts[i].code; i++)
 	{
diff -urN remmina-plugins/telepathy/CMakeLists.txt remmina-plugins/telepathy/CMakeLists.txt
--- remmina-plugins/telepathy/CMakeLists.txt	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins/telepathy/CMakeLists.txt	2014-01-08 02:31:52.000000000 +1100
@@ -23,6 +23,7 @@
 
 add_library(remmina-plugin-telepathy ${REMMINA_PLUGIN_TELEPATHY_SRCS})
 set_target_properties(remmina-plugin-telepathy PROPERTIES PREFIX "")
+set_target_properties(remmina-plugin-telepathy PROPERTIES NO_SONAME 1)
 
 find_required_package(GTK3)
 
diff -urN remmina-plugins/vnc/CMakeLists.txt remmina-plugins/vnc/CMakeLists.txt
--- remmina-plugins/vnc/CMakeLists.txt	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins/vnc/CMakeLists.txt	2014-01-08 02:31:52.000000000 +1100
@@ -17,7 +17,7 @@
 # Foundation, Inc., 59 Temple Place, Suite 330, 
 # Boston, MA 02111-1307, USA.
 
-set(LIBVNCSERVER_INCLUDE_DIRS ${CMAKE_CURRENT_SOURCE_DIR}/libvncserver)
+set(LIBVNCSERVER_INCLUDE_DIRS)
 set(LIBVNCSERVER_LIBRARIES vncclient)
 
 set(REMMINA_PLUGIN_VNC_SRCS
@@ -26,6 +26,7 @@
 
 add_library(remmina-plugin-vnc ${REMMINA_PLUGIN_VNC_SRCS})
 set_target_properties(remmina-plugin-vnc PROPERTIES PREFIX "")
+set_target_properties(remmina-plugin-vnc PROPERTIES NO_SONAME 1)
 
 include_directories(${REMMINA_COMMON_INCLUDE_DIRS} ${LIBVNCSERVER_INCLUDE_DIRS})
 target_link_libraries(remmina-plugin-vnc ${REMMINA_COMMON_LIBRARIES} ${LIBVNCSERVER_LIBRARIES})
diff -urN remmina-plugins/vnc/libvncserver/CMakeLists.txt remmina-plugins/vnc/libvncserver/CMakeLists.txt
--- remmina-plugins/vnc/libvncserver/CMakeLists.txt	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins/vnc/libvncserver/CMakeLists.txt	1970-01-01 10:00:00.000000000 +1000
@@ -1,102 +0,0 @@
-
-include(CheckFunctionExists)
-include(CheckIncludeFile)
-include(CheckTypeSize)
-include(TestBigEndian)
-
-#set(PACKAGE_NAME           "LibVNCServer")
-#set(FULL_PACKAGE_NAME      "LibVNCServer")
-#set(PACKAGE_VERSION        "0.9.8.2")
-#set(PROJECT_BUGREPORT_PATH "http://sourceforge.net/projects/libvncserver")
-
-include_directories(${CMAKE_CURRENT_SOURCE_DIR} ${CMAKE_CURRENT_SOURCE_DIR}/common)
-
-find_package(ZLIB)
-find_package(JPEG)
-find_package(GnuTLS)
-find_package(Threads)
-find_package(X11)
-find_library(LIBGCRYPT_LIBRARIES gcrypt)
-
-if(Threads_FOUND)
-  option(TIGHTVNC_FILETRANSFER "Enable filetransfer" ON)
-endif(Threads_FOUND)
-if(ZLIB_FOUND)
-  set(LIBVNCSERVER_HAVE_LIBZ 1)
-endif(ZLIB_FOUND)
-if(JPEG_FOUND)
-  set(LIBVNCSERVER_HAVE_LIBJPEG 1)
-endif(JPEG_FOUND)
-option(LIBVNCSERVER_ALLOW24BPP "Allow 24 bpp" ON)
-if(GNUTLS_FOUND)
-  set(LIBVNCSERVER_WITH_CLIENT_TLS 1)
-endif(GNUTLS_FOUND)
-if(LIBGCRYPT_LIBRARIES)
-  message(STATUS "Found libgcrypt: ${LIBGCRYPT_LIBRARIES}")
-  set(LIBVNCSERVER_WITH_CLIENT_GCRYPT 1)
-endif(LIBGCRYPT_LIBRARIES)
-
-check_include_file("fcntl.h"       LIBVNCSERVER_HAVE_FCNTL_H)
-check_include_file("netinet/in.h"  LIBVNCSERVER_HAVE_NETINET_IN_H)
-check_include_file("sys/socket.h"  LIBVNCSERVER_HAVE_SYS_SOCKET_H)
-check_include_file("sys/stat.h"    LIBVNCSERVER_HAVE_SYS_STAT_H)
-check_include_file("sys/time.h"    LIBVNCSERVER_HAVE_SYS_TIME_H)
-check_include_file("sys/types.h"   LIBVNCSERVER_HAVE_SYS_TYPES_H)
-check_include_file("sys/wait.h"    LIBVNCSERVER_HAVE_SYS_WAIT_H)
-check_include_file("unistd.h"      LIBVNCSERVER_HAVE_UNISTD_H)
-
-# headers needed for check_type_size()
-check_include_file("arpa/inet.h"   HAVE_ARPA_INET_H)
-check_include_file("stdint.h"      HAVE_STDINT_H)
-check_include_file("stddef.h"      HAVE_STDDEF_H)
-check_include_file("sys/types.h"   HAVE_SYS_TYPES_H)
-
-check_function_exists(gettimeofday    LIBVNCSERVER_HAVE_GETTIMEOFDAY)
-
-if(CMAKE_USE_PTHREADS_INIT)
-	set(LIBVNCSERVER_HAVE_LIBPTHREAD 1)
-endif(CMAKE_USE_PTHREADS_INIT)
-if(LIBVNCSERVER_HAVE_SYS_SOCKET_H)
-	# socklen_t
-	list(APPEND CMAKE_EXTRA_INCLUDE_FILES "sys/socket.h")
-endif(LIBVNCSERVER_HAVE_SYS_SOCKET_H)
-if(HAVE_ARPA_INET_H)
-	# in_addr_t
-	list(APPEND CMAKE_EXTRA_INCLUDE_FILES "arpa/inet.h")
-endif(HAVE_ARPA_INET_H)
-
-check_type_size(pid_t     LIBVNCSERVER_PID_T)
-check_type_size(size_t    LIBVNCSERVER_SIZE_T)
-check_type_size(socklen_t LIBVNCSERVER_SOCKLEN_T)
-check_type_size(in_addr_t LIBVNCSERVER_IN_ADDR_T)
-
-if(NOT HAVE_LIBVNCSERVER_IN_ADDR_T)
-	set(LIBVNCSERVER_NEED_INADDR_T 1)
-endif(NOT HAVE_LIBVNCSERVER_IN_ADDR_T)
-
-TEST_BIG_ENDIAN(LIBVNCSERVER_WORDS_BIGENDIAN)
-
-configure_file(${CMAKE_CURRENT_SOURCE_DIR}/rfb/rfbconfig.h.cmake ${CMAKE_CURRENT_SOURCE_DIR}/rfb/rfbconfig.h)
-configure_file(${CMAKE_CURRENT_SOURCE_DIR}/rfb/rfbint.h.cmake ${CMAKE_CURRENT_SOURCE_DIR}/rfb/rfbint.h)
-
-set(COMMON_DIR ${CMAKE_CURRENT_SOURCE_DIR}/common)
-set(LIBVNCCLIENT_DIR ${CMAKE_CURRENT_SOURCE_DIR}/libvncclient)
-
-set(LIBVNCCLIENT_SOURCES
-	${LIBVNCCLIENT_DIR}/cursor.c
-	${LIBVNCCLIENT_DIR}/listen.c
-	${LIBVNCCLIENT_DIR}/rfbproto.c
-	${LIBVNCCLIENT_DIR}/sockets.c
-	${LIBVNCCLIENT_DIR}/vncviewer.c
-	${COMMON_DIR}/minilzo.c
-	${LIBVNCCLIENT_DIR}/tls.c
-)
-
-add_library(vncclient STATIC ${LIBVNCCLIENT_SOURCES})
-
-if(WIN32)
-	set(ADDITIONAL_LIBS ws2_32)
-endif(WIN32)
-
-target_link_libraries(vncclient ${ADDITIONAL_LIBS} ${ZLIB_LIBRARIES} ${JPEG_LIBRARIES})
-
diff -urN remmina-plugins/vnc/libvncserver/common/d3des.c remmina-plugins/vnc/libvncserver/common/d3des.c
--- remmina-plugins/vnc/libvncserver/common/d3des.c	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins/vnc/libvncserver/common/d3des.c	1970-01-01 10:00:00.000000000 +1000
@@ -1,436 +0,0 @@
-/*
- * This is D3DES (V5.09) by Richard Outerbridge with the double and
- * triple-length support removed for use in VNC.  Also the bytebit[] array
- * has been reversed so that the most significant bit in each byte of the
- * key is ignored, not the least significant.
- *
- * These changes are:
- *  Copyright (C) 1999 AT&T Laboratories Cambridge.  All Rights Reserved.
- *
- * This software is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-/* D3DES (V5.09) -
- *
- * A portable, public domain, version of the Data Encryption Standard.
- *
- * Written with Symantec's THINK (Lightspeed) C by Richard Outerbridge.
- * Thanks to: Dan Hoey for his excellent Initial and Inverse permutation
- * code;  Jim Gillogly & Phil Karn for the DES key schedule code; Dennis
- * Ferguson, Eric Young and Dana How for comparing notes; and Ray Lau,
- * for humouring me on.
- *
- * Copyright (c) 1988,1989,1990,1991,1992 by Richard Outerbridge.
- * (GEnie : OUTER; CIS : [71755,204]) Graven Imagery, 1992.
- */
-
-#include "d3des.h"
-
-static void scrunch(unsigned char *, unsigned long *);
-static void unscrun(unsigned long *, unsigned char *);
-static void desfunc(unsigned long *, unsigned long *);
-static void cookey(unsigned long *);
-
-static unsigned long KnL[32] = { 0L };
-/*
-static unsigned long KnR[32] = { 0L };
-static unsigned long Kn3[32] = { 0L };
-static unsigned char Df_Key[24] = {
-	0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,
-	0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10,
-	0x89,0xab,0xcd,0xef,0x01,0x23,0x45,0x67 };
-*/
-
-static unsigned short bytebit[8]	= {
-	01, 02, 04, 010, 020, 040, 0100, 0200 };
-
-static unsigned long bigbyte[24] = {
-	0x800000L,	0x400000L,	0x200000L,	0x100000L,
-	0x80000L,	0x40000L,	0x20000L,	0x10000L,
-	0x8000L,	0x4000L,	0x2000L,	0x1000L,
-	0x800L, 	0x400L, 	0x200L, 	0x100L,
-	0x80L,		0x40L,		0x20L,		0x10L,
-	0x8L,		0x4L,		0x2L,		0x1L	};
-
-/* Use the key schedule specified in the Standard (ANSI X3.92-1981). */
-
-static unsigned char pc1[56] = {
-	56, 48, 40, 32, 24, 16,  8,	 0, 57, 49, 41, 33, 25, 17,
-	 9,  1, 58, 50, 42, 34, 26,	18, 10,  2, 59, 51, 43, 35,
-	62, 54, 46, 38, 30, 22, 14,	 6, 61, 53, 45, 37, 29, 21,
-	13,  5, 60, 52, 44, 36, 28,	20, 12,  4, 27, 19, 11,  3 };
-
-static unsigned char totrot[16] = {
-	1,2,4,6,8,10,12,14,15,17,19,21,23,25,27,28 };
-
-static unsigned char pc2[48] = {
-	13, 16, 10, 23,  0,  4,  2, 27, 14,  5, 20,  9,
-	22, 18, 11,  3, 25,  7, 15,  6, 26, 19, 12,  1,
-	40, 51, 30, 36, 46, 54, 29, 39, 50, 44, 32, 47,
-	43, 48, 38, 55, 33, 52, 45, 41, 49, 35, 28, 31 };
-
-void rfbDesKey(unsigned char *key,
-               int edf)
-{
-	register int i, j, l, m, n;
-	unsigned char pc1m[56], pcr[56];
-	unsigned long kn[32];
-
-	for ( j = 0; j < 56; j++ ) {
-		l = pc1[j];
-		m = l & 07;
-		pc1m[j] = (key[l >> 3] & bytebit[m]) ? 1 : 0;
-		}
-	for( i = 0; i < 16; i++ ) {
-		if( edf == DE1 ) m = (15 - i) << 1;
-		else m = i << 1;
-		n = m + 1;
-		kn[m] = kn[n] = 0L;
-		for( j = 0; j < 28; j++ ) {
-			l = j + totrot[i];
-			if( l < 28 ) pcr[j] = pc1m[l];
-			else pcr[j] = pc1m[l - 28];
-			}
-		for( j = 28; j < 56; j++ ) {
-		    l = j + totrot[i];
-		    if( l < 56 ) pcr[j] = pc1m[l];
-		    else pcr[j] = pc1m[l - 28];
-		    }
-		for( j = 0; j < 24; j++ ) {
-			if( pcr[pc2[j]] ) kn[m] |= bigbyte[j];
-			if( pcr[pc2[j+24]] ) kn[n] |= bigbyte[j];
-			}
-		}
-	cookey(kn);
-	return;
-	}
-
-static void cookey(register unsigned long *raw1)
-{
-	register unsigned long *cook, *raw0;
-	unsigned long dough[32];
-	register int i;
-
-	cook = dough;
-	for( i = 0; i < 16; i++, raw1++ ) {
-		raw0 = raw1++;
-		*cook	 = (*raw0 & 0x00fc0000L) << 6;
-		*cook	|= (*raw0 & 0x00000fc0L) << 10;
-		*cook	|= (*raw1 & 0x00fc0000L) >> 10;
-		*cook++ |= (*raw1 & 0x00000fc0L) >> 6;
-		*cook	 = (*raw0 & 0x0003f000L) << 12;
-		*cook	|= (*raw0 & 0x0000003fL) << 16;
-		*cook	|= (*raw1 & 0x0003f000L) >> 4;
-		*cook++ |= (*raw1 & 0x0000003fL);
-		}
-	rfbUseKey(dough);
-	return;
-	}
-
-void rfbCPKey(register unsigned long *into)
-{
-	register unsigned long *from, *endp;
-
-	from = KnL, endp = &KnL[32];
-	while( from < endp ) *into++ = *from++;
-	return;
-	}
-
-void rfbUseKey(register unsigned long *from)
-{
-	register unsigned long *to, *endp;
-
-	to = KnL, endp = &KnL[32];
-	while( to < endp ) *to++ = *from++;
-	return;
-	}
-
-void rfbDes(unsigned char *inblock,
-            unsigned char *outblock)
-{
-	unsigned long work[2];
-
-	scrunch(inblock, work);
-	desfunc(work, KnL);
-	unscrun(work, outblock);
-	return;
-	}
-
-static void scrunch(register unsigned char *outof,
-                    register unsigned long *into)
-{
-	*into	 = (*outof++ & 0xffL) << 24;
-	*into	|= (*outof++ & 0xffL) << 16;
-	*into	|= (*outof++ & 0xffL) << 8;
-	*into++ |= (*outof++ & 0xffL);
-	*into	 = (*outof++ & 0xffL) << 24;
-	*into	|= (*outof++ & 0xffL) << 16;
-	*into	|= (*outof++ & 0xffL) << 8;
-	*into	|= (*outof   & 0xffL);
-	return;
-	}
-
-static void unscrun(register unsigned long *outof,
-                    register unsigned char *into)
-{
-	*into++ = (unsigned char)((*outof >> 24) & 0xffL);
-	*into++ = (unsigned char)((*outof >> 16) & 0xffL);
-	*into++ = (unsigned char)((*outof >>  8) & 0xffL);
-	*into++ = (unsigned char)( *outof++	 & 0xffL);
-	*into++ = (unsigned char)((*outof >> 24) & 0xffL);
-	*into++ = (unsigned char)((*outof >> 16) & 0xffL);
-	*into++ = (unsigned char)((*outof >>  8) & 0xffL);
-	*into	= (unsigned char)( *outof	 & 0xffL);
-	return;
-	}
-
-static unsigned long SP1[64] = {
-	0x01010400L, 0x00000000L, 0x00010000L, 0x01010404L,
-	0x01010004L, 0x00010404L, 0x00000004L, 0x00010000L,
-	0x00000400L, 0x01010400L, 0x01010404L, 0x00000400L,
-	0x01000404L, 0x01010004L, 0x01000000L, 0x00000004L,
-	0x00000404L, 0x01000400L, 0x01000400L, 0x00010400L,
-	0x00010400L, 0x01010000L, 0x01010000L, 0x01000404L,
-	0x00010004L, 0x01000004L, 0x01000004L, 0x00010004L,
-	0x00000000L, 0x00000404L, 0x00010404L, 0x01000000L,
-	0x00010000L, 0x01010404L, 0x00000004L, 0x01010000L,
-	0x01010400L, 0x01000000L, 0x01000000L, 0x00000400L,
-	0x01010004L, 0x00010000L, 0x00010400L, 0x01000004L,
-	0x00000400L, 0x00000004L, 0x01000404L, 0x00010404L,
-	0x01010404L, 0x00010004L, 0x01010000L, 0x01000404L,
-	0x01000004L, 0x00000404L, 0x00010404L, 0x01010400L,
-	0x00000404L, 0x01000400L, 0x01000400L, 0x00000000L,
-	0x00010004L, 0x00010400L, 0x00000000L, 0x01010004L };
-
-static unsigned long SP2[64] = {
-	0x80108020L, 0x80008000L, 0x00008000L, 0x00108020L,
-	0x00100000L, 0x00000020L, 0x80100020L, 0x80008020L,
-	0x80000020L, 0x80108020L, 0x80108000L, 0x80000000L,
-	0x80008000L, 0x00100000L, 0x00000020L, 0x80100020L,
-	0x00108000L, 0x00100020L, 0x80008020L, 0x00000000L,
-	0x80000000L, 0x00008000L, 0x00108020L, 0x80100000L,
-	0x00100020L, 0x80000020L, 0x00000000L, 0x00108000L,
-	0x00008020L, 0x80108000L, 0x80100000L, 0x00008020L,
-	0x00000000L, 0x00108020L, 0x80100020L, 0x00100000L,
-	0x80008020L, 0x80100000L, 0x80108000L, 0x00008000L,
-	0x80100000L, 0x80008000L, 0x00000020L, 0x80108020L,
-	0x00108020L, 0x00000020L, 0x00008000L, 0x80000000L,
-	0x00008020L, 0x80108000L, 0x00100000L, 0x80000020L,
-	0x00100020L, 0x80008020L, 0x80000020L, 0x00100020L,
-	0x00108000L, 0x00000000L, 0x80008000L, 0x00008020L,
-	0x80000000L, 0x80100020L, 0x80108020L, 0x00108000L };
-
-static unsigned long SP3[64] = {
-	0x00000208L, 0x08020200L, 0x00000000L, 0x08020008L,
-	0x08000200L, 0x00000000L, 0x00020208L, 0x08000200L,
-	0x00020008L, 0x08000008L, 0x08000008L, 0x00020000L,
-	0x08020208L, 0x00020008L, 0x08020000L, 0x00000208L,
-	0x08000000L, 0x00000008L, 0x08020200L, 0x00000200L,
-	0x00020200L, 0x08020000L, 0x08020008L, 0x00020208L,
-	0x08000208L, 0x00020200L, 0x00020000L, 0x08000208L,
-	0x00000008L, 0x08020208L, 0x00000200L, 0x08000000L,
-	0x08020200L, 0x08000000L, 0x00020008L, 0x00000208L,
-	0x00020000L, 0x08020200L, 0x08000200L, 0x00000000L,
-	0x00000200L, 0x00020008L, 0x08020208L, 0x08000200L,
-	0x08000008L, 0x00000200L, 0x00000000L, 0x08020008L,
-	0x08000208L, 0x00020000L, 0x08000000L, 0x08020208L,
-	0x00000008L, 0x00020208L, 0x00020200L, 0x08000008L,
-	0x08020000L, 0x08000208L, 0x00000208L, 0x08020000L,
-	0x00020208L, 0x00000008L, 0x08020008L, 0x00020200L };
-
-static unsigned long SP4[64] = {
-	0x00802001L, 0x00002081L, 0x00002081L, 0x00000080L,
-	0x00802080L, 0x00800081L, 0x00800001L, 0x00002001L,
-	0x00000000L, 0x00802000L, 0x00802000L, 0x00802081L,
-	0x00000081L, 0x00000000L, 0x00800080L, 0x00800001L,
-	0x00000001L, 0x00002000L, 0x00800000L, 0x00802001L,
-	0x00000080L, 0x00800000L, 0x00002001L, 0x00002080L,
-	0x00800081L, 0x00000001L, 0x00002080L, 0x00800080L,
-	0x00002000L, 0x00802080L, 0x00802081L, 0x00000081L,
-	0x00800080L, 0x00800001L, 0x00802000L, 0x00802081L,
-	0x00000081L, 0x00000000L, 0x00000000L, 0x00802000L,
-	0x00002080L, 0x00800080L, 0x00800081L, 0x00000001L,
-	0x00802001L, 0x00002081L, 0x00002081L, 0x00000080L,
-	0x00802081L, 0x00000081L, 0x00000001L, 0x00002000L,
-	0x00800001L, 0x00002001L, 0x00802080L, 0x00800081L,
-	0x00002001L, 0x00002080L, 0x00800000L, 0x00802001L,
-	0x00000080L, 0x00800000L, 0x00002000L, 0x00802080L };
-
-static unsigned long SP5[64] = {
-	0x00000100L, 0x02080100L, 0x02080000L, 0x42000100L,
-	0x00080000L, 0x00000100L, 0x40000000L, 0x02080000L,
-	0x40080100L, 0x00080000L, 0x02000100L, 0x40080100L,
-	0x42000100L, 0x42080000L, 0x00080100L, 0x40000000L,
-	0x02000000L, 0x40080000L, 0x40080000L, 0x00000000L,
-	0x40000100L, 0x42080100L, 0x42080100L, 0x02000100L,
-	0x42080000L, 0x40000100L, 0x00000000L, 0x42000000L,
-	0x02080100L, 0x02000000L, 0x42000000L, 0x00080100L,
-	0x00080000L, 0x42000100L, 0x00000100L, 0x02000000L,
-	0x40000000L, 0x02080000L, 0x42000100L, 0x40080100L,
-	0x02000100L, 0x40000000L, 0x42080000L, 0x02080100L,
-	0x40080100L, 0x00000100L, 0x02000000L, 0x42080000L,
-	0x42080100L, 0x00080100L, 0x42000000L, 0x42080100L,
-	0x02080000L, 0x00000000L, 0x40080000L, 0x42000000L,
-	0x00080100L, 0x02000100L, 0x40000100L, 0x00080000L,
-	0x00000000L, 0x40080000L, 0x02080100L, 0x40000100L };
-
-static unsigned long SP6[64] = {
-	0x20000010L, 0x20400000L, 0x00004000L, 0x20404010L,
-	0x20400000L, 0x00000010L, 0x20404010L, 0x00400000L,
-	0x20004000L, 0x00404010L, 0x00400000L, 0x20000010L,
-	0x00400010L, 0x20004000L, 0x20000000L, 0x00004010L,
-	0x00000000L, 0x00400010L, 0x20004010L, 0x00004000L,
-	0x00404000L, 0x20004010L, 0x00000010L, 0x20400010L,
-	0x20400010L, 0x00000000L, 0x00404010L, 0x20404000L,
-	0x00004010L, 0x00404000L, 0x20404000L, 0x20000000L,
-	0x20004000L, 0x00000010L, 0x20400010L, 0x00404000L,
-	0x20404010L, 0x00400000L, 0x00004010L, 0x20000010L,
-	0x00400000L, 0x20004000L, 0x20000000L, 0x00004010L,
-	0x20000010L, 0x20404010L, 0x00404000L, 0x20400000L,
-	0x00404010L, 0x20404000L, 0x00000000L, 0x20400010L,
-	0x00000010L, 0x00004000L, 0x20400000L, 0x00404010L,
-	0x00004000L, 0x00400010L, 0x20004010L, 0x00000000L,
-	0x20404000L, 0x20000000L, 0x00400010L, 0x20004010L };
-
-static unsigned long SP7[64] = {
-	0x00200000L, 0x04200002L, 0x04000802L, 0x00000000L,
-	0x00000800L, 0x04000802L, 0x00200802L, 0x04200800L,
-	0x04200802L, 0x00200000L, 0x00000000L, 0x04000002L,
-	0x00000002L, 0x04000000L, 0x04200002L, 0x00000802L,
-	0x04000800L, 0x00200802L, 0x00200002L, 0x04000800L,
-	0x04000002L, 0x04200000L, 0x04200800L, 0x00200002L,
-	0x04200000L, 0x00000800L, 0x00000802L, 0x04200802L,
-	0x00200800L, 0x00000002L, 0x04000000L, 0x00200800L,
-	0x04000000L, 0x00200800L, 0x00200000L, 0x04000802L,
-	0x04000802L, 0x04200002L, 0x04200002L, 0x00000002L,
-	0x00200002L, 0x04000000L, 0x04000800L, 0x00200000L,
-	0x04200800L, 0x00000802L, 0x00200802L, 0x04200800L,
-	0x00000802L, 0x04000002L, 0x04200802L, 0x04200000L,
-	0x00200800L, 0x00000000L, 0x00000002L, 0x04200802L,
-	0x00000000L, 0x00200802L, 0x04200000L, 0x00000800L,
-	0x04000002L, 0x04000800L, 0x00000800L, 0x00200002L };
-
-static unsigned long SP8[64] = {
-	0x10001040L, 0x00001000L, 0x00040000L, 0x10041040L,
-	0x10000000L, 0x10001040L, 0x00000040L, 0x10000000L,
-	0x00040040L, 0x10040000L, 0x10041040L, 0x00041000L,
-	0x10041000L, 0x00041040L, 0x00001000L, 0x00000040L,
-	0x10040000L, 0x10000040L, 0x10001000L, 0x00001040L,
-	0x00041000L, 0x00040040L, 0x10040040L, 0x10041000L,
-	0x00001040L, 0x00000000L, 0x00000000L, 0x10040040L,
-	0x10000040L, 0x10001000L, 0x00041040L, 0x00040000L,
-	0x00041040L, 0x00040000L, 0x10041000L, 0x00001000L,
-	0x00000040L, 0x10040040L, 0x00001000L, 0x00041040L,
-	0x10001000L, 0x00000040L, 0x10000040L, 0x10040000L,
-	0x10040040L, 0x10000000L, 0x00040000L, 0x10001040L,
-	0x00000000L, 0x10041040L, 0x00040040L, 0x10000040L,
-	0x10040000L, 0x10001000L, 0x10001040L, 0x00000000L,
-	0x10041040L, 0x00041000L, 0x00041000L, 0x00001040L,
-	0x00001040L, 0x00040040L, 0x10000000L, 0x10041000L };
-
-static void desfunc(register unsigned long *block,
-                    register unsigned long *keys)
-{
-	register unsigned long fval, work, right, leftt;
-	register int round;
-
-	leftt = block[0];
-	right = block[1];
-	work = ((leftt >> 4) ^ right) & 0x0f0f0f0fL;
-	right ^= work;
-	leftt ^= (work << 4);
-	work = ((leftt >> 16) ^ right) & 0x0000ffffL;
-	right ^= work;
-	leftt ^= (work << 16);
-	work = ((right >> 2) ^ leftt) & 0x33333333L;
-	leftt ^= work;
-	right ^= (work << 2);
-	work = ((right >> 8) ^ leftt) & 0x00ff00ffL;
-	leftt ^= work;
-	right ^= (work << 8);
-	right = ((right << 1) | ((right >> 31) & 1L)) & 0xffffffffL;
-	work = (leftt ^ right) & 0xaaaaaaaaL;
-	leftt ^= work;
-	right ^= work;
-	leftt = ((leftt << 1) | ((leftt >> 31) & 1L)) & 0xffffffffL;
-
-	for( round = 0; round < 8; round++ ) {
-		work  = (right << 28) | (right >> 4);
-		work ^= *keys++;
-		fval  = SP7[ work		 & 0x3fL];
-		fval |= SP5[(work >>  8) & 0x3fL];
-		fval |= SP3[(work >> 16) & 0x3fL];
-		fval |= SP1[(work >> 24) & 0x3fL];
-		work  = right ^ *keys++;
-		fval |= SP8[ work		 & 0x3fL];
-		fval |= SP6[(work >>  8) & 0x3fL];
-		fval |= SP4[(work >> 16) & 0x3fL];
-		fval |= SP2[(work >> 24) & 0x3fL];
-		leftt ^= fval;
-		work  = (leftt << 28) | (leftt >> 4);
-		work ^= *keys++;
-		fval  = SP7[ work		 & 0x3fL];
-		fval |= SP5[(work >>  8) & 0x3fL];
-		fval |= SP3[(work >> 16) & 0x3fL];
-		fval |= SP1[(work >> 24) & 0x3fL];
-		work  = leftt ^ *keys++;
-		fval |= SP8[ work		 & 0x3fL];
-		fval |= SP6[(work >>  8) & 0x3fL];
-		fval |= SP4[(work >> 16) & 0x3fL];
-		fval |= SP2[(work >> 24) & 0x3fL];
-		right ^= fval;
-		}
-
-	right = (right << 31) | (right >> 1);
-	work = (leftt ^ right) & 0xaaaaaaaaL;
-	leftt ^= work;
-	right ^= work;
-	leftt = (leftt << 31) | (leftt >> 1);
-	work = ((leftt >> 8) ^ right) & 0x00ff00ffL;
-	right ^= work;
-	leftt ^= (work << 8);
-	work = ((leftt >> 2) ^ right) & 0x33333333L;
-	right ^= work;
-	leftt ^= (work << 2);
-	work = ((right >> 16) ^ leftt) & 0x0000ffffL;
-	leftt ^= work;
-	right ^= (work << 16);
-	work = ((right >> 4) ^ leftt) & 0x0f0f0f0fL;
-	leftt ^= work;
-	right ^= (work << 4);
-	*block++ = right;
-	*block = leftt;
-	return;
-	}
-
-/* Validation sets:
- *
- * Single-length key, single-length plaintext -
- * Key	  : 0123 4567 89ab cdef
- * Plain  : 0123 4567 89ab cde7
- * Cipher : c957 4425 6a5e d31d
- *
- * Double-length key, single-length plaintext -
- * Key	  : 0123 4567 89ab cdef fedc ba98 7654 3210
- * Plain  : 0123 4567 89ab cde7
- * Cipher : 7f1d 0a77 826b 8aff
- *
- * Double-length key, double-length plaintext -
- * Key	  : 0123 4567 89ab cdef fedc ba98 7654 3210
- * Plain  : 0123 4567 89ab cdef 0123 4567 89ab cdff
- * Cipher : 27a0 8440 406a df60 278f 47cf 42d6 15d7
- *
- * Triple-length key, single-length plaintext -
- * Key	  : 0123 4567 89ab cdef fedc ba98 7654 3210 89ab cdef 0123 4567
- * Plain  : 0123 4567 89ab cde7
- * Cipher : de0b 7c06 ae5e 0ed5
- *
- * Triple-length key, double-length plaintext -
- * Key	  : 0123 4567 89ab cdef fedc ba98 7654 3210 89ab cdef 0123 4567
- * Plain  : 0123 4567 89ab cdef 0123 4567 89ab cdff
- * Cipher : ad0d 1b30 ac17 cf07 0ed1 1c63 81e4 4de5
- *
- * d3des V5.0a rwo 9208.07 18:44 Graven Imagery
- **********************************************************************/
diff -urN remmina-plugins/vnc/libvncserver/common/d3des.h remmina-plugins/vnc/libvncserver/common/d3des.h
--- remmina-plugins/vnc/libvncserver/common/d3des.h	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins/vnc/libvncserver/common/d3des.h	1970-01-01 10:00:00.000000000 +1000
@@ -1,56 +0,0 @@
-#ifndef D3DES_H
-#define D3DES_H
-
-/*
- * This is D3DES (V5.09) by Richard Outerbridge with the double and
- * triple-length support removed for use in VNC.
- *
- * These changes are:
- *  Copyright (C) 1999 AT&T Laboratories Cambridge.  All Rights Reserved.
- *
- * This software is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-/* d3des.h -
- *
- *	Headers and defines for d3des.c
- *	Graven Imagery, 1992.
- *
- * Copyright (c) 1988,1989,1990,1991,1992 by Richard Outerbridge
- *	(GEnie : OUTER; CIS : [71755,204])
- */
-
-#define EN0	0	/* MODE == encrypt */
-#define DE1	1	/* MODE == decrypt */
-
-extern void rfbDesKey(unsigned char *, int);
-/*		      hexkey[8]     MODE
- * Sets the internal key register according to the hexadecimal
- * key contained in the 8 bytes of hexkey, according to the DES,
- * for encryption or decryption according to MODE.
- */
-
-extern void rfbUseKey(unsigned long *);
-/*		    cookedkey[32]
- * Loads the internal key register with the data in cookedkey.
- */
-
-extern void rfbCPKey(unsigned long *);
-/*		   cookedkey[32]
- * Copies the contents of the internal key register into the storage
- * located at &cookedkey[0].
- */
-
-extern void rfbDes(unsigned char *, unsigned char *);
-/*		    from[8]	      to[8]
- * Encrypts/Decrypts (according to the key currently loaded in the
- * internal key register) one block of eight bytes at address 'from'
- * into the block at address 'to'.  They can be the same.
- */
-
-/* d3des.h V5.09 rwo 9208.04 15:06 Graven Imagery
- ********************************************************************/
-
-#endif
diff -urN remmina-plugins/vnc/libvncserver/common/lzoconf.h remmina-plugins/vnc/libvncserver/common/lzoconf.h
--- remmina-plugins/vnc/libvncserver/common/lzoconf.h	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins/vnc/libvncserver/common/lzoconf.h	1970-01-01 10:00:00.000000000 +1000
@@ -1,419 +0,0 @@
-/* lzoconf.h -- configuration for the LZO real-time data compression library
-
-   This file is part of the LZO real-time data compression library.
-
-   Copyright (C) 2010 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2009 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
-   All Rights Reserved.
-
-   The LZO library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU General Public License as
-   published by the Free Software Foundation; either version 2 of
-   the License, or (at your option) any later version.
-
-   The LZO library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with the LZO library; see the file COPYING.
-   If not, write to the Free Software Foundation, Inc.,
-   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-
-   Markus F.X.J. Oberhumer
-   <markus@oberhumer.com>
-   http://www.oberhumer.com/opensource/lzo/
- */
-
-
-#ifndef __LZOCONF_H_INCLUDED
-#define __LZOCONF_H_INCLUDED 1
-
-#define LZO_VERSION             0x2040
-#define LZO_VERSION_STRING      "2.04"
-#define LZO_VERSION_DATE        "Oct 31 2010"
-
-/* internal Autoconf configuration file - only used when building LZO */
-#if defined(LZO_HAVE_CONFIG_H)
-#  include <config.h>
-#endif
-#include <limits.h>
-#include <stddef.h>
-
-
-/***********************************************************************
-// LZO requires a conforming <limits.h>
-************************************************************************/
-
-#if !defined(CHAR_BIT) || (CHAR_BIT != 8)
-#  error "invalid CHAR_BIT"
-#endif
-#if !defined(UCHAR_MAX) || !defined(UINT_MAX) || !defined(ULONG_MAX)
-#  error "check your compiler installation"
-#endif
-#if (USHRT_MAX < 1) || (UINT_MAX < 1) || (ULONG_MAX < 1)
-#  error "your limits.h macros are broken"
-#endif
-
-/* get OS and architecture defines */
-#ifndef __LZODEFS_H_INCLUDED
-#include "lzodefs.h"
-#endif
-
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-
-/***********************************************************************
-// some core defines
-************************************************************************/
-
-#if !defined(LZO_UINT32_C)
-#  if (UINT_MAX < LZO_0xffffffffL)
-#    define LZO_UINT32_C(c)     c ## UL
-#  else
-#    define LZO_UINT32_C(c)     ((c) + 0U)
-#  endif
-#endif
-
-/* memory checkers */
-#if !defined(__LZO_CHECKER)
-#  if defined(__BOUNDS_CHECKING_ON)
-#    define __LZO_CHECKER       1
-#  elif defined(__CHECKER__)
-#    define __LZO_CHECKER       1
-#  elif defined(__INSURE__)
-#    define __LZO_CHECKER       1
-#  elif defined(__PURIFY__)
-#    define __LZO_CHECKER       1
-#  endif
-#endif
-
-
-/***********************************************************************
-// integral and pointer types
-************************************************************************/
-
-/* lzo_uint should match size_t */
-#if !defined(LZO_UINT_MAX)
-#  if defined(LZO_ABI_LLP64) /* WIN64 */
-#    if defined(LZO_OS_WIN64)
-     typedef unsigned __int64   lzo_uint;
-     typedef __int64            lzo_int;
-#    else
-     typedef unsigned long long lzo_uint;
-     typedef long long          lzo_int;
-#    endif
-#    define LZO_UINT_MAX        0xffffffffffffffffull
-#    define LZO_INT_MAX         9223372036854775807LL
-#    define LZO_INT_MIN         (-1LL - LZO_INT_MAX)
-#  elif defined(LZO_ABI_IP32L64) /* MIPS R5900 */
-     typedef unsigned int       lzo_uint;
-     typedef int                lzo_int;
-#    define LZO_UINT_MAX        UINT_MAX
-#    define LZO_INT_MAX         INT_MAX
-#    define LZO_INT_MIN         INT_MIN
-#  elif (ULONG_MAX >= LZO_0xffffffffL)
-     typedef unsigned long      lzo_uint;
-     typedef long               lzo_int;
-#    define LZO_UINT_MAX        ULONG_MAX
-#    define LZO_INT_MAX         LONG_MAX
-#    define LZO_INT_MIN         LONG_MIN
-#  else
-#    error "lzo_uint"
-#  endif
-#endif
-
-/* Integral types with 32 bits or more. */
-#if !defined(LZO_UINT32_MAX)
-#  if (UINT_MAX >= LZO_0xffffffffL)
-     typedef unsigned int       lzo_uint32;
-     typedef int                lzo_int32;
-#    define LZO_UINT32_MAX      UINT_MAX
-#    define LZO_INT32_MAX       INT_MAX
-#    define LZO_INT32_MIN       INT_MIN
-#  elif (ULONG_MAX >= LZO_0xffffffffL)
-     typedef unsigned long      lzo_uint32;
-     typedef long               lzo_int32;
-#    define LZO_UINT32_MAX      ULONG_MAX
-#    define LZO_INT32_MAX       LONG_MAX
-#    define LZO_INT32_MIN       LONG_MIN
-#  else
-#    error "lzo_uint32"
-#  endif
-#endif
-
-/* The larger type of lzo_uint and lzo_uint32. */
-#if (LZO_UINT_MAX >= LZO_UINT32_MAX)
-#  define lzo_xint              lzo_uint
-#else
-#  define lzo_xint              lzo_uint32
-#endif
-
-/* Memory model that allows to access memory at offsets of lzo_uint. */
-#if !defined(__LZO_MMODEL)
-#  if (LZO_UINT_MAX <= UINT_MAX)
-#    define __LZO_MMODEL        /*empty*/
-#  elif defined(LZO_HAVE_MM_HUGE_PTR)
-#    define __LZO_MMODEL_HUGE   1
-#    define __LZO_MMODEL        __huge
-#  else
-#    define __LZO_MMODEL        /*empty*/
-#  endif
-#endif
-
-/* no typedef here because of const-pointer issues */
-#define lzo_bytep               unsigned char __LZO_MMODEL *
-#define lzo_charp               char __LZO_MMODEL *
-#define lzo_voidp               void __LZO_MMODEL *
-#define lzo_shortp              short __LZO_MMODEL *
-#define lzo_ushortp             unsigned short __LZO_MMODEL *
-#define lzo_uint32p             lzo_uint32 __LZO_MMODEL *
-#define lzo_int32p              lzo_int32 __LZO_MMODEL *
-#define lzo_uintp               lzo_uint __LZO_MMODEL *
-#define lzo_intp                lzo_int __LZO_MMODEL *
-#define lzo_xintp               lzo_xint __LZO_MMODEL *
-#define lzo_voidpp              lzo_voidp __LZO_MMODEL *
-#define lzo_bytepp              lzo_bytep __LZO_MMODEL *
-/* deprecated - use 'lzo_bytep' instead of 'lzo_byte *' */
-#define lzo_byte                unsigned char __LZO_MMODEL
-
-typedef int lzo_bool;
-
-
-/***********************************************************************
-// function types
-************************************************************************/
-
-/* name mangling */
-#if !defined(__LZO_EXTERN_C)
-#  ifdef __cplusplus
-#    define __LZO_EXTERN_C      extern "C"
-#  else
-#    define __LZO_EXTERN_C      extern
-#  endif
-#endif
-
-/* calling convention */
-#if !defined(__LZO_CDECL)
-#  define __LZO_CDECL           __lzo_cdecl
-#endif
-
-/* DLL export information */
-#if !defined(__LZO_EXPORT1)
-#  define __LZO_EXPORT1         /*empty*/
-#endif
-#if !defined(__LZO_EXPORT2)
-#  define __LZO_EXPORT2         /*empty*/
-#endif
-
-/* __cdecl calling convention for public C and assembly functions */
-#if !defined(LZO_PUBLIC)
-#  define LZO_PUBLIC(_rettype)  __LZO_EXPORT1 _rettype __LZO_EXPORT2 __LZO_CDECL
-#endif
-#if !defined(LZO_EXTERN)
-#  define LZO_EXTERN(_rettype)  __LZO_EXTERN_C LZO_PUBLIC(_rettype)
-#endif
-#if !defined(LZO_PRIVATE)
-#  define LZO_PRIVATE(_rettype) static _rettype __LZO_CDECL
-#endif
-
-/* function types */
-typedef int
-(__LZO_CDECL *lzo_compress_t)   ( const lzo_bytep src, lzo_uint  src_len,
-                                        lzo_bytep dst, lzo_uintp dst_len,
-                                        lzo_voidp wrkmem );
-
-typedef int
-(__LZO_CDECL *lzo_decompress_t) ( const lzo_bytep src, lzo_uint  src_len,
-                                        lzo_bytep dst, lzo_uintp dst_len,
-                                        lzo_voidp wrkmem );
-
-typedef int
-(__LZO_CDECL *lzo_optimize_t)   (       lzo_bytep src, lzo_uint  src_len,
-                                        lzo_bytep dst, lzo_uintp dst_len,
-                                        lzo_voidp wrkmem );
-
-typedef int
-(__LZO_CDECL *lzo_compress_dict_t)(const lzo_bytep src, lzo_uint  src_len,
-                                         lzo_bytep dst, lzo_uintp dst_len,
-                                         lzo_voidp wrkmem,
-                                   const lzo_bytep dict, lzo_uint dict_len );
-
-typedef int
-(__LZO_CDECL *lzo_decompress_dict_t)(const lzo_bytep src, lzo_uint  src_len,
-                                           lzo_bytep dst, lzo_uintp dst_len,
-                                           lzo_voidp wrkmem,
-                                     const lzo_bytep dict, lzo_uint dict_len );
-
-
-/* Callback interface. Currently only the progress indicator ("nprogress")
- * is used, but this may change in a future release. */
-
-struct lzo_callback_t;
-typedef struct lzo_callback_t lzo_callback_t;
-#define lzo_callback_p lzo_callback_t __LZO_MMODEL *
-
-/* malloc & free function types */
-typedef lzo_voidp (__LZO_CDECL *lzo_alloc_func_t)
-    (lzo_callback_p self, lzo_uint items, lzo_uint size);
-typedef void      (__LZO_CDECL *lzo_free_func_t)
-    (lzo_callback_p self, lzo_voidp ptr);
-
-/* a progress indicator callback function */
-typedef void (__LZO_CDECL *lzo_progress_func_t)
-    (lzo_callback_p, lzo_uint, lzo_uint, int);
-
-struct lzo_callback_t
-{
-    /* custom allocators (set to 0 to disable) */
-    lzo_alloc_func_t nalloc;                /* [not used right now] */
-    lzo_free_func_t nfree;                  /* [not used right now] */
-
-    /* a progress indicator callback function (set to 0 to disable) */
-    lzo_progress_func_t nprogress;
-
-    /* NOTE: the first parameter "self" of the nalloc/nfree/nprogress
-     * callbacks points back to this struct, so you are free to store
-     * some extra info in the following variables. */
-    lzo_voidp user1;
-    lzo_xint user2;
-    lzo_xint user3;
-};
-
-
-/***********************************************************************
-// error codes and prototypes
-************************************************************************/
-
-/* Error codes for the compression/decompression functions. Negative
- * values are errors, positive values will be used for special but
- * normal events.
- */
-#define LZO_E_OK                    0
-#define LZO_E_ERROR                 (-1)
-#define LZO_E_OUT_OF_MEMORY         (-2)    /* [not used right now] */
-#define LZO_E_NOT_COMPRESSIBLE      (-3)    /* [not used right now] */
-#define LZO_E_INPUT_OVERRUN         (-4)
-#define LZO_E_OUTPUT_OVERRUN        (-5)
-#define LZO_E_LOOKBEHIND_OVERRUN    (-6)
-#define LZO_E_EOF_NOT_FOUND         (-7)
-#define LZO_E_INPUT_NOT_CONSUMED    (-8)
-#define LZO_E_NOT_YET_IMPLEMENTED   (-9)    /* [not used right now] */
-
-
-#ifndef lzo_sizeof_dict_t
-#  define lzo_sizeof_dict_t     ((unsigned)sizeof(lzo_bytep))
-#endif
-
-/* lzo_init() should be the first function you call.
- * Check the return code !
- *
- * lzo_init() is a macro to allow checking that the library and the
- * compiler's view of various types are consistent.
- */
-#define lzo_init() __lzo_init_v2(LZO_VERSION,(int)sizeof(short),(int)sizeof(int),\
-    (int)sizeof(long),(int)sizeof(lzo_uint32),(int)sizeof(lzo_uint),\
-    (int)lzo_sizeof_dict_t,(int)sizeof(char *),(int)sizeof(lzo_voidp),\
-    (int)sizeof(lzo_callback_t))
-LZO_EXTERN(int) __lzo_init_v2(unsigned,int,int,int,int,int,int,int,int,int);
-
-/* version functions (useful for shared libraries) */
-LZO_EXTERN(unsigned) lzo_version(void);
-LZO_EXTERN(const char *) lzo_version_string(void);
-LZO_EXTERN(const char *) lzo_version_date(void);
-LZO_EXTERN(const lzo_charp) _lzo_version_string(void);
-LZO_EXTERN(const lzo_charp) _lzo_version_date(void);
-
-/* string functions */
-LZO_EXTERN(int)
-    lzo_memcmp(const lzo_voidp a, const lzo_voidp b, lzo_uint len);
-LZO_EXTERN(lzo_voidp)
-    lzo_memcpy(lzo_voidp dst, const lzo_voidp src, lzo_uint len);
-LZO_EXTERN(lzo_voidp)
-    lzo_memmove(lzo_voidp dst, const lzo_voidp src, lzo_uint len);
-LZO_EXTERN(lzo_voidp)
-    lzo_memset(lzo_voidp buf, int c, lzo_uint len);
-
-/* checksum functions */
-LZO_EXTERN(lzo_uint32)
-    lzo_adler32(lzo_uint32 c, const lzo_bytep buf, lzo_uint len);
-LZO_EXTERN(lzo_uint32)
-    lzo_crc32(lzo_uint32 c, const lzo_bytep buf, lzo_uint len);
-LZO_EXTERN(const lzo_uint32p)
-    lzo_get_crc32_table(void);
-
-/* misc. */
-LZO_EXTERN(int) _lzo_config_check(void);
-typedef union { lzo_bytep p; lzo_uint u; } __lzo_pu_u;
-typedef union { lzo_bytep p; lzo_uint32 u32; } __lzo_pu32_u;
-typedef union { void *vp; lzo_bytep bp; lzo_uint u; lzo_uint32 u32; unsigned long l; } lzo_align_t;
-
-/* align a char pointer on a boundary that is a multiple of 'size' */
-LZO_EXTERN(unsigned) __lzo_align_gap(const lzo_voidp p, lzo_uint size);
-#define LZO_PTR_ALIGN_UP(p,size) \
-    ((p) + (lzo_uint) __lzo_align_gap((const lzo_voidp)(p),(lzo_uint)(size)))
-
-
-/***********************************************************************
-// deprecated macros - only for backward compatibility with LZO v1.xx
-************************************************************************/
-
-#if defined(LZO_CFG_COMPAT)
-
-#define __LZOCONF_H 1
-
-#if defined(LZO_ARCH_I086)
-#  define __LZO_i386 1
-#elif defined(LZO_ARCH_I386)
-#  define __LZO_i386 1
-#endif
-
-#if defined(LZO_OS_DOS16)
-#  define __LZO_DOS 1
-#  define __LZO_DOS16 1
-#elif defined(LZO_OS_DOS32)
-#  define __LZO_DOS 1
-#elif defined(LZO_OS_WIN16)
-#  define __LZO_WIN 1
-#  define __LZO_WIN16 1
-#elif defined(LZO_OS_WIN32)
-#  define __LZO_WIN 1
-#endif
-
-#define __LZO_CMODEL            /*empty*/
-#define __LZO_DMODEL            /*empty*/
-#define __LZO_ENTRY             __LZO_CDECL
-#define LZO_EXTERN_CDECL        LZO_EXTERN
-#define LZO_ALIGN               LZO_PTR_ALIGN_UP
-
-#define lzo_compress_asm_t      lzo_compress_t
-#define lzo_decompress_asm_t    lzo_decompress_t
-
-#endif /* LZO_CFG_COMPAT */
-
-
-#ifdef __cplusplus
-} /* extern "C" */
-#endif
-
-#endif /* already included */
-
-
-/* vim:set ts=4 et: */
diff -urN remmina-plugins/vnc/libvncserver/common/lzodefs.h remmina-plugins/vnc/libvncserver/common/lzodefs.h
--- remmina-plugins/vnc/libvncserver/common/lzodefs.h	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins/vnc/libvncserver/common/lzodefs.h	1970-01-01 10:00:00.000000000 +1000
@@ -1,1851 +0,0 @@
-/* lzodefs.h -- architecture, OS and compiler specific defines
-
-   This file is part of the LZO real-time data compression library.
-
-   Copyright (C) 2010 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2009 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
-   All Rights Reserved.
-
-   The LZO library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU General Public License as
-   published by the Free Software Foundation; either version 2 of
-   the License, or (at your option) any later version.
-
-   The LZO library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with the LZO library; see the file COPYING.
-   If not, write to the Free Software Foundation, Inc.,
-   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-
-   Markus F.X.J. Oberhumer
-   <markus@oberhumer.com>
-   http://www.oberhumer.com/opensource/lzo/
- */
-
-
-#ifndef __LZODEFS_H_INCLUDED
-#define __LZODEFS_H_INCLUDED 1
-
-#if defined(__CYGWIN32__) && !defined(__CYGWIN__)
-#  define __CYGWIN__ __CYGWIN32__
-#endif
-#if defined(__IBMCPP__) && !defined(__IBMC__)
-#  define __IBMC__ __IBMCPP__
-#endif
-#if defined(__ICL) && defined(_WIN32) && !defined(__INTEL_COMPILER)
-#  define __INTEL_COMPILER __ICL
-#endif
-#if 1 && defined(__INTERIX) && defined(__GNUC__) && !defined(_ALL_SOURCE)
-#  define _ALL_SOURCE 1
-#endif
-#if defined(__mips__) && defined(__R5900__)
-#  if !defined(__LONG_MAX__)
-#    define __LONG_MAX__ 9223372036854775807L
-#  endif
-#endif
-#if defined(__INTEL_COMPILER) && defined(__linux__)
-#  pragma warning(disable: 193)
-#endif
-#if defined(__KEIL__) && defined(__C166__)
-#  pragma warning disable = 322
-#elif 0 && defined(__C251__)
-#  pragma warning disable = 322
-#endif
-#if defined(_MSC_VER) && !defined(__INTEL_COMPILER) && !defined(__MWERKS__)
-#  if (_MSC_VER >= 1300)
-#    pragma warning(disable: 4668)
-#  endif
-#endif
-#if 0 && defined(__WATCOMC__)
-#  if (__WATCOMC__ >= 1050) && (__WATCOMC__ < 1060)
-#    pragma warning 203 9
-#  endif
-#endif
-#if defined(__BORLANDC__) && defined(__MSDOS__) && !defined(__FLAT__)
-#  pragma option -h
-#endif
-#if 0
-#define LZO_0xffffL             0xfffful
-#define LZO_0xffffffffL         0xfffffffful
-#else
-#define LZO_0xffffL             65535ul
-#define LZO_0xffffffffL         4294967295ul
-#endif
-#if (LZO_0xffffL == LZO_0xffffffffL)
-#  error "your preprocessor is broken 1"
-#endif
-#if (16ul * 16384ul != 262144ul)
-#  error "your preprocessor is broken 2"
-#endif
-#if 0
-#if (32767 >= 4294967295ul)
-#  error "your preprocessor is broken 3"
-#endif
-#if (65535u >= 4294967295ul)
-#  error "your preprocessor is broken 4"
-#endif
-#endif
-#if (UINT_MAX == LZO_0xffffL)
-#if defined(__ZTC__) && defined(__I86__) && !defined(__OS2__)
-#  if !defined(MSDOS)
-#    define MSDOS 1
-#  endif
-#  if !defined(_MSDOS)
-#    define _MSDOS 1
-#  endif
-#elif 0 && defined(__VERSION) && defined(MB_LEN_MAX)
-#  if (__VERSION == 520) && (MB_LEN_MAX == 1)
-#    if !defined(__AZTEC_C__)
-#      define __AZTEC_C__ __VERSION
-#    endif
-#    if !defined(__DOS__)
-#      define __DOS__ 1
-#    endif
-#  endif
-#endif
-#endif
-#if defined(_MSC_VER) && defined(M_I86HM) && (UINT_MAX == LZO_0xffffL)
-#  define ptrdiff_t long
-#  define _PTRDIFF_T_DEFINED 1
-#endif
-#if (UINT_MAX == LZO_0xffffL)
-#  undef __LZO_RENAME_A
-#  undef __LZO_RENAME_B
-#  if defined(__AZTEC_C__) && defined(__DOS__)
-#    define __LZO_RENAME_A 1
-#  elif defined(_MSC_VER) && defined(MSDOS)
-#    if (_MSC_VER < 600)
-#      define __LZO_RENAME_A 1
-#    elif (_MSC_VER < 700)
-#      define __LZO_RENAME_B 1
-#    endif
-#  elif defined(__TSC__) && defined(__OS2__)
-#    define __LZO_RENAME_A 1
-#  elif defined(__MSDOS__) && defined(__TURBOC__) && (__TURBOC__ < 0x0410)
-#    define __LZO_RENAME_A 1
-#  elif defined(__PACIFIC__) && defined(DOS)
-#    if !defined(__far)
-#      define __far far
-#    endif
-#    if !defined(__near)
-#      define __near near
-#    endif
-#  endif
-#  if defined(__LZO_RENAME_A)
-#    if !defined(__cdecl)
-#      define __cdecl cdecl
-#    endif
-#    if !defined(__far)
-#      define __far far
-#    endif
-#    if !defined(__huge)
-#      define __huge huge
-#    endif
-#    if !defined(__near)
-#      define __near near
-#    endif
-#    if !defined(__pascal)
-#      define __pascal pascal
-#    endif
-#    if !defined(__huge)
-#      define __huge huge
-#    endif
-#  elif defined(__LZO_RENAME_B)
-#    if !defined(__cdecl)
-#      define __cdecl _cdecl
-#    endif
-#    if !defined(__far)
-#      define __far _far
-#    endif
-#    if !defined(__huge)
-#      define __huge _huge
-#    endif
-#    if !defined(__near)
-#      define __near _near
-#    endif
-#    if !defined(__pascal)
-#      define __pascal _pascal
-#    endif
-#  elif (defined(__PUREC__) || defined(__TURBOC__)) && defined(__TOS__)
-#    if !defined(__cdecl)
-#      define __cdecl cdecl
-#    endif
-#    if !defined(__pascal)
-#      define __pascal pascal
-#    endif
-#  endif
-#  undef __LZO_RENAME_A
-#  undef __LZO_RENAME_B
-#endif
-#if (UINT_MAX == LZO_0xffffL)
-#if defined(__AZTEC_C__) && defined(__DOS__)
-#  define LZO_BROKEN_CDECL_ALT_SYNTAX 1
-#elif defined(_MSC_VER) && defined(MSDOS)
-#  if (_MSC_VER < 600)
-#    define LZO_BROKEN_INTEGRAL_CONSTANTS 1
-#  endif
-#  if (_MSC_VER < 700)
-#    define LZO_BROKEN_INTEGRAL_PROMOTION 1
-#    define LZO_BROKEN_SIZEOF 1
-#  endif
-#elif defined(__PACIFIC__) && defined(DOS)
-#  define LZO_BROKEN_INTEGRAL_CONSTANTS 1
-#elif defined(__TURBOC__) && defined(__MSDOS__)
-#  if (__TURBOC__ < 0x0150)
-#    define LZO_BROKEN_CDECL_ALT_SYNTAX 1
-#    define LZO_BROKEN_INTEGRAL_CONSTANTS 1
-#    define LZO_BROKEN_INTEGRAL_PROMOTION 1
-#  endif
-#  if (__TURBOC__ < 0x0200)
-#    define LZO_BROKEN_SIZEOF 1
-#  endif
-#  if (__TURBOC__ < 0x0400) && defined(__cplusplus)
-#    define LZO_BROKEN_CDECL_ALT_SYNTAX 1
-#  endif
-#elif (defined(__PUREC__) || defined(__TURBOC__)) && defined(__TOS__)
-#  define LZO_BROKEN_CDECL_ALT_SYNTAX 1
-#  define LZO_BROKEN_SIZEOF 1
-#endif
-#endif
-#if defined(__WATCOMC__) && (__WATCOMC__ < 900)
-#  define LZO_BROKEN_INTEGRAL_CONSTANTS 1
-#endif
-#if defined(_CRAY) && defined(_CRAY1)
-#  define LZO_BROKEN_SIGNED_RIGHT_SHIFT 1
-#endif
-#define LZO_PP_STRINGIZE(x)             #x
-#define LZO_PP_MACRO_EXPAND(x)          LZO_PP_STRINGIZE(x)
-#define LZO_PP_CONCAT2(a,b)             a ## b
-#define LZO_PP_CONCAT3(a,b,c)           a ## b ## c
-#define LZO_PP_CONCAT4(a,b,c,d)         a ## b ## c ## d
-#define LZO_PP_CONCAT5(a,b,c,d,e)       a ## b ## c ## d ## e
-#define LZO_PP_ECONCAT2(a,b)            LZO_PP_CONCAT2(a,b)
-#define LZO_PP_ECONCAT3(a,b,c)          LZO_PP_CONCAT3(a,b,c)
-#define LZO_PP_ECONCAT4(a,b,c,d)        LZO_PP_CONCAT4(a,b,c,d)
-#define LZO_PP_ECONCAT5(a,b,c,d,e)      LZO_PP_CONCAT5(a,b,c,d,e)
-#if 1
-#define LZO_CPP_STRINGIZE(x)            #x
-#define LZO_CPP_MACRO_EXPAND(x)         LZO_CPP_STRINGIZE(x)
-#define LZO_CPP_CONCAT2(a,b)            a ## b
-#define LZO_CPP_CONCAT3(a,b,c)          a ## b ## c
-#define LZO_CPP_CONCAT4(a,b,c,d)        a ## b ## c ## d
-#define LZO_CPP_CONCAT5(a,b,c,d,e)      a ## b ## c ## d ## e
-#define LZO_CPP_ECONCAT2(a,b)           LZO_CPP_CONCAT2(a,b)
-#define LZO_CPP_ECONCAT3(a,b,c)         LZO_CPP_CONCAT3(a,b,c)
-#define LZO_CPP_ECONCAT4(a,b,c,d)       LZO_CPP_CONCAT4(a,b,c,d)
-#define LZO_CPP_ECONCAT5(a,b,c,d,e)     LZO_CPP_CONCAT5(a,b,c,d,e)
-#endif
-#define __LZO_MASK_GEN(o,b)     (((((o) << ((b)-1)) - (o)) << 1) + (o))
-#if 1 && defined(__cplusplus)
-#  if !defined(__STDC_CONSTANT_MACROS)
-#    define __STDC_CONSTANT_MACROS 1
-#  endif
-#  if !defined(__STDC_LIMIT_MACROS)
-#    define __STDC_LIMIT_MACROS 1
-#  endif
-#endif
-#if defined(__cplusplus)
-#  define LZO_EXTERN_C extern "C"
-#else
-#  define LZO_EXTERN_C extern
-#endif
-#if !defined(__LZO_OS_OVERRIDE)
-#if (LZO_OS_FREESTANDING)
-#  define LZO_INFO_OS           "freestanding"
-#elif (LZO_OS_EMBEDDED)
-#  define LZO_INFO_OS           "embedded"
-#elif 1 && defined(__IAR_SYSTEMS_ICC__)
-#  define LZO_OS_EMBEDDED       1
-#  define LZO_INFO_OS           "embedded"
-#elif defined(__CYGWIN__) && defined(__GNUC__)
-#  define LZO_OS_CYGWIN         1
-#  define LZO_INFO_OS           "cygwin"
-#elif defined(__EMX__) && defined(__GNUC__)
-#  define LZO_OS_EMX            1
-#  define LZO_INFO_OS           "emx"
-#elif defined(__BEOS__)
-#  define LZO_OS_BEOS           1
-#  define LZO_INFO_OS           "beos"
-#elif defined(__Lynx__)
-#  define LZO_OS_LYNXOS         1
-#  define LZO_INFO_OS           "lynxos"
-#elif defined(__OS400__)
-#  define LZO_OS_OS400          1
-#  define LZO_INFO_OS           "os400"
-#elif defined(__QNX__)
-#  define LZO_OS_QNX            1
-#  define LZO_INFO_OS           "qnx"
-#elif defined(__BORLANDC__) && defined(__DPMI32__) && (__BORLANDC__ >= 0x0460)
-#  define LZO_OS_DOS32          1
-#  define LZO_INFO_OS           "dos32"
-#elif defined(__BORLANDC__) && defined(__DPMI16__)
-#  define LZO_OS_DOS16          1
-#  define LZO_INFO_OS           "dos16"
-#elif defined(__ZTC__) && defined(DOS386)
-#  define LZO_OS_DOS32          1
-#  define LZO_INFO_OS           "dos32"
-#elif defined(__OS2__) || defined(__OS2V2__)
-#  if (UINT_MAX == LZO_0xffffL)
-#    define LZO_OS_OS216        1
-#    define LZO_INFO_OS         "os216"
-#  elif (UINT_MAX == LZO_0xffffffffL)
-#    define LZO_OS_OS2          1
-#    define LZO_INFO_OS         "os2"
-#  else
-#    error "check your limits.h header"
-#  endif
-#elif defined(__WIN64__) || defined(_WIN64) || defined(WIN64)
-#  define LZO_OS_WIN64          1
-#  define LZO_INFO_OS           "win64"
-#elif defined(__WIN32__) || defined(_WIN32) || defined(WIN32) || defined(__WINDOWS_386__)
-#  define LZO_OS_WIN32          1
-#  define LZO_INFO_OS           "win32"
-#elif defined(__MWERKS__) && defined(__INTEL__)
-#  define LZO_OS_WIN32          1
-#  define LZO_INFO_OS           "win32"
-#elif defined(__WINDOWS__) || defined(_WINDOWS) || defined(_Windows)
-#  if (UINT_MAX == LZO_0xffffL)
-#    define LZO_OS_WIN16        1
-#    define LZO_INFO_OS         "win16"
-#  elif (UINT_MAX == LZO_0xffffffffL)
-#    define LZO_OS_WIN32        1
-#    define LZO_INFO_OS         "win32"
-#  else
-#    error "check your limits.h header"
-#  endif
-#elif defined(__DOS__) || defined(__MSDOS__) || defined(_MSDOS) || defined(MSDOS) || (defined(__PACIFIC__) && defined(DOS))
-#  if (UINT_MAX == LZO_0xffffL)
-#    define LZO_OS_DOS16        1
-#    define LZO_INFO_OS         "dos16"
-#  elif (UINT_MAX == LZO_0xffffffffL)
-#    define LZO_OS_DOS32        1
-#    define LZO_INFO_OS         "dos32"
-#  else
-#    error "check your limits.h header"
-#  endif
-#elif defined(__WATCOMC__)
-#  if defined(__NT__) && (UINT_MAX == LZO_0xffffL)
-#    define LZO_OS_DOS16        1
-#    define LZO_INFO_OS         "dos16"
-#  elif defined(__NT__) && (__WATCOMC__ < 1100)
-#    define LZO_OS_WIN32        1
-#    define LZO_INFO_OS         "win32"
-#  elif defined(__linux__) || defined(__LINUX__)
-#    define LZO_OS_POSIX        1
-#    define LZO_INFO_OS         "posix"
-#  else
-#    error "please specify a target using the -bt compiler option"
-#  endif
-#elif defined(__palmos__)
-#  define LZO_OS_PALMOS         1
-#  define LZO_INFO_OS           "palmos"
-#elif defined(__TOS__) || defined(__atarist__)
-#  define LZO_OS_TOS            1
-#  define LZO_INFO_OS           "tos"
-#elif defined(macintosh) && !defined(__ppc__)
-#  define LZO_OS_MACCLASSIC     1
-#  define LZO_INFO_OS           "macclassic"
-#elif defined(__VMS)
-#  define LZO_OS_VMS            1
-#  define LZO_INFO_OS           "vms"
-#elif ((defined(__mips__) && defined(__R5900__)) || defined(__MIPS_PSX2__))
-#  define LZO_OS_CONSOLE        1
-#  define LZO_OS_CONSOLE_PS2    1
-#  define LZO_INFO_OS           "console"
-#  define LZO_INFO_OS_CONSOLE   "ps2"
-#elif (defined(__mips__) && defined(__psp__))
-#  define LZO_OS_CONSOLE        1
-#  define LZO_OS_CONSOLE_PSP    1
-#  define LZO_INFO_OS           "console"
-#  define LZO_INFO_OS_CONSOLE   "psp"
-#else
-#  define LZO_OS_POSIX          1
-#  define LZO_INFO_OS           "posix"
-#endif
-#if (LZO_OS_POSIX)
-#  if defined(_AIX) || defined(__AIX__) || defined(__aix__)
-#    define LZO_OS_POSIX_AIX        1
-#    define LZO_INFO_OS_POSIX       "aix"
-#  elif defined(__FreeBSD__)
-#    define LZO_OS_POSIX_FREEBSD    1
-#    define LZO_INFO_OS_POSIX       "freebsd"
-#  elif defined(__hpux__) || defined(__hpux)
-#    define LZO_OS_POSIX_HPUX       1
-#    define LZO_INFO_OS_POSIX       "hpux"
-#  elif defined(__INTERIX)
-#    define LZO_OS_POSIX_INTERIX    1
-#    define LZO_INFO_OS_POSIX       "interix"
-#  elif defined(__IRIX__) || defined(__irix__)
-#    define LZO_OS_POSIX_IRIX       1
-#    define LZO_INFO_OS_POSIX       "irix"
-#  elif defined(__linux__) || defined(__linux) || defined(__LINUX__)
-#    define LZO_OS_POSIX_LINUX      1
-#    define LZO_INFO_OS_POSIX       "linux"
-#  elif defined(__APPLE__) || defined(__MACOS__)
-#    define LZO_OS_POSIX_MACOSX     1
-#    define LZO_INFO_OS_POSIX       "macosx"
-#  elif defined(__minix__) || defined(__minix)
-#    define LZO_OS_POSIX_MINIX      1
-#    define LZO_INFO_OS_POSIX       "minix"
-#  elif defined(__NetBSD__)
-#    define LZO_OS_POSIX_NETBSD     1
-#    define LZO_INFO_OS_POSIX       "netbsd"
-#  elif defined(__OpenBSD__)
-#    define LZO_OS_POSIX_OPENBSD    1
-#    define LZO_INFO_OS_POSIX       "openbsd"
-#  elif defined(__osf__)
-#    define LZO_OS_POSIX_OSF        1
-#    define LZO_INFO_OS_POSIX       "osf"
-#  elif defined(__solaris__) || defined(__sun)
-#    if defined(__SVR4) || defined(__svr4__)
-#      define LZO_OS_POSIX_SOLARIS  1
-#      define LZO_INFO_OS_POSIX     "solaris"
-#    else
-#      define LZO_OS_POSIX_SUNOS    1
-#      define LZO_INFO_OS_POSIX     "sunos"
-#    endif
-#  elif defined(__ultrix__) || defined(__ultrix)
-#    define LZO_OS_POSIX_ULTRIX     1
-#    define LZO_INFO_OS_POSIX       "ultrix"
-#  elif defined(_UNICOS)
-#    define LZO_OS_POSIX_UNICOS     1
-#    define LZO_INFO_OS_POSIX       "unicos"
-#  else
-#    define LZO_OS_POSIX_UNKNOWN    1
-#    define LZO_INFO_OS_POSIX       "unknown"
-#  endif
-#endif
-#endif
-#if (LZO_OS_DOS16 || LZO_OS_OS216 || LZO_OS_WIN16)
-#  if (UINT_MAX != LZO_0xffffL)
-#    error "this should not happen"
-#  endif
-#  if (ULONG_MAX != LZO_0xffffffffL)
-#    error "this should not happen"
-#  endif
-#endif
-#if (LZO_OS_DOS32 || LZO_OS_OS2 || LZO_OS_WIN32 || LZO_OS_WIN64)
-#  if (UINT_MAX != LZO_0xffffffffL)
-#    error "this should not happen"
-#  endif
-#  if (ULONG_MAX != LZO_0xffffffffL)
-#    error "this should not happen"
-#  endif
-#endif
-#if defined(CIL) && defined(_GNUCC) && defined(__GNUC__)
-#  define LZO_CC_CILLY          1
-#  define LZO_INFO_CC           "Cilly"
-#  if defined(__CILLY__)
-#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(__CILLY__)
-#  else
-#    define LZO_INFO_CCVER      "unknown"
-#  endif
-#elif 0 && defined(SDCC) && defined(__VERSION__) && !defined(__GNUC__)
-#  define LZO_CC_SDCC           1
-#  define LZO_INFO_CC           "sdcc"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(SDCC)
-#elif defined(__PATHSCALE__) && defined(__PATHCC_PATCHLEVEL__)
-#  define LZO_CC_PATHSCALE      (__PATHCC__ * 0x10000L + __PATHCC_MINOR__ * 0x100 + __PATHCC_PATCHLEVEL__)
-#  define LZO_INFO_CC           "Pathscale C"
-#  define LZO_INFO_CCVER        __PATHSCALE__
-#elif defined(__INTEL_COMPILER)
-#  define LZO_CC_INTELC         1
-#  define LZO_INFO_CC           "Intel C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__INTEL_COMPILER)
-#  if defined(_WIN32) || defined(_WIN64)
-#    define LZO_CC_SYNTAX_MSC 1
-#  else
-#    define LZO_CC_SYNTAX_GNUC 1
-#  endif
-#elif defined(__POCC__) && defined(_WIN32)
-#  define LZO_CC_PELLESC        1
-#  define LZO_INFO_CC           "Pelles C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__POCC__)
-#elif defined(__clang__) && defined(__llvm__) && defined(__GNUC__) && defined(__GNUC_MINOR__) && defined(__VERSION__)
-#  if defined(__GNUC_PATCHLEVEL__)
-#    define LZO_CC_CLANG_GNUC   (__GNUC__ * 0x10000L + __GNUC_MINOR__ * 0x100 + __GNUC_PATCHLEVEL__)
-#  else
-#    define LZO_CC_CLANG_GNUC   (__GNUC__ * 0x10000L + __GNUC_MINOR__ * 0x100)
-#  endif
-#  if defined(__clang_major__) && defined(__clang_minor__) && defined(__clang_patchlevel__)
-#    define LZO_CC_CLANG_CLANG  (__clang_major__ * 0x10000L + __clang_minor__ * 0x100 + __clang_patchlevel__)
-#  else
-#    define LZO_CC_CLANG_CLANG  0x020700L
-#  endif
-#  define LZO_CC_CLANG          LZO_CC_CLANG_GNUC
-#  define LZO_INFO_CC           "clang"
-#  define LZO_INFO_CCVER        __VERSION__
-#elif defined(__llvm__) && defined(__GNUC__) && defined(__GNUC_MINOR__) && defined(__VERSION__)
-#  if defined(__GNUC_PATCHLEVEL__)
-#    define LZO_CC_LLVM_GNUC    (__GNUC__ * 0x10000L + __GNUC_MINOR__ * 0x100 + __GNUC_PATCHLEVEL__)
-#  else
-#    define LZO_CC_LLVM_GNUC    (__GNUC__ * 0x10000L + __GNUC_MINOR__ * 0x100)
-#  endif
-#  define LZO_CC_LLVM           LZO_CC_LLVM_GNUC
-#  define LZO_INFO_CC           "llvm-gcc"
-#  define LZO_INFO_CCVER        __VERSION__
-#elif defined(__GNUC__) && defined(__VERSION__)
-#  if defined(__GNUC_MINOR__) && defined(__GNUC_PATCHLEVEL__)
-#    define LZO_CC_GNUC         (__GNUC__ * 0x10000L + __GNUC_MINOR__ * 0x100 + __GNUC_PATCHLEVEL__)
-#  elif defined(__GNUC_MINOR__)
-#    define LZO_CC_GNUC         (__GNUC__ * 0x10000L + __GNUC_MINOR__ * 0x100)
-#  else
-#    define LZO_CC_GNUC         (__GNUC__ * 0x10000L)
-#  endif
-#  define LZO_INFO_CC           "gcc"
-#  define LZO_INFO_CCVER        __VERSION__
-#elif defined(__ACK__) && defined(_ACK)
-#  define LZO_CC_ACK            1
-#  define LZO_INFO_CC           "Amsterdam Compiler Kit C"
-#  define LZO_INFO_CCVER        "unknown"
-#elif defined(__AZTEC_C__)
-#  define LZO_CC_AZTECC         1
-#  define LZO_INFO_CC           "Aztec C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__AZTEC_C__)
-#elif defined(__CODEGEARC__)
-#  define LZO_CC_CODEGEARC      1
-#  define LZO_INFO_CC           "CodeGear C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__CODEGEARC__)
-#elif defined(__BORLANDC__)
-#  define LZO_CC_BORLANDC       1
-#  define LZO_INFO_CC           "Borland C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__BORLANDC__)
-#elif defined(_CRAYC) && defined(_RELEASE)
-#  define LZO_CC_CRAYC          1
-#  define LZO_INFO_CC           "Cray C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(_RELEASE)
-#elif defined(__DMC__) && defined(__SC__)
-#  define LZO_CC_DMC            1
-#  define LZO_INFO_CC           "Digital Mars C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__DMC__)
-#elif defined(__DECC)
-#  define LZO_CC_DECC           1
-#  define LZO_INFO_CC           "DEC C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__DECC)
-#elif defined(__HIGHC__)
-#  define LZO_CC_HIGHC          1
-#  define LZO_INFO_CC           "MetaWare High C"
-#  define LZO_INFO_CCVER        "unknown"
-#elif defined(__IAR_SYSTEMS_ICC__)
-#  define LZO_CC_IARC           1
-#  define LZO_INFO_CC           "IAR C"
-#  if defined(__VER__)
-#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(__VER__)
-#  else
-#    define LZO_INFO_CCVER      "unknown"
-#  endif
-#elif defined(__IBMC__)
-#  define LZO_CC_IBMC           1
-#  define LZO_INFO_CC           "IBM C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__IBMC__)
-#elif defined(__KEIL__) && defined(__C166__)
-#  define LZO_CC_KEILC          1
-#  define LZO_INFO_CC           "Keil C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__C166__)
-#elif defined(__LCC__) && defined(_WIN32) && defined(__LCCOPTIMLEVEL)
-#  define LZO_CC_LCCWIN32       1
-#  define LZO_INFO_CC           "lcc-win32"
-#  define LZO_INFO_CCVER        "unknown"
-#elif defined(__LCC__)
-#  define LZO_CC_LCC            1
-#  define LZO_INFO_CC           "lcc"
-#  if defined(__LCC_VERSION__)
-#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(__LCC_VERSION__)
-#  else
-#    define LZO_INFO_CCVER      "unknown"
-#  endif
-#elif defined(_MSC_VER)
-#  define LZO_CC_MSC            1
-#  define LZO_INFO_CC           "Microsoft C"
-#  if defined(_MSC_FULL_VER)
-#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(_MSC_VER) "." LZO_PP_MACRO_EXPAND(_MSC_FULL_VER)
-#  else
-#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(_MSC_VER)
-#  endif
-#elif defined(__MWERKS__)
-#  define LZO_CC_MWERKS         1
-#  define LZO_INFO_CC           "Metrowerks C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__MWERKS__)
-#elif (defined(__NDPC__) || defined(__NDPX__)) && defined(__i386)
-#  define LZO_CC_NDPC           1
-#  define LZO_INFO_CC           "Microway NDP C"
-#  define LZO_INFO_CCVER        "unknown"
-#elif defined(__PACIFIC__)
-#  define LZO_CC_PACIFICC       1
-#  define LZO_INFO_CC           "Pacific C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__PACIFIC__)
-#elif defined(__PGI) && (defined(__linux__) || defined(__WIN32__))
-#  define LZO_CC_PGI            1
-#  define LZO_INFO_CC           "Portland Group PGI C"
-#  define LZO_INFO_CCVER        "unknown"
-#elif defined(__PUREC__) && defined(__TOS__)
-#  define LZO_CC_PUREC          1
-#  define LZO_INFO_CC           "Pure C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__PUREC__)
-#elif defined(__SC__) && defined(__ZTC__)
-#  define LZO_CC_SYMANTECC      1
-#  define LZO_INFO_CC           "Symantec C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__SC__)
-#elif defined(__SUNPRO_C)
-#  define LZO_INFO_CC           "SunPro C"
-#  if ((__SUNPRO_C)+0 > 0)
-#    define LZO_CC_SUNPROC      __SUNPRO_C
-#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(__SUNPRO_C)
-#  else
-#    define LZO_CC_SUNPROC      1
-#    define LZO_INFO_CCVER      "unknown"
-#  endif
-#elif defined(__SUNPRO_CC)
-#  define LZO_INFO_CC           "SunPro C"
-#  if ((__SUNPRO_CC)+0 > 0)
-#    define LZO_CC_SUNPROC      __SUNPRO_CC
-#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(__SUNPRO_CC)
-#  else
-#    define LZO_CC_SUNPROC      1
-#    define LZO_INFO_CCVER      "unknown"
-#  endif
-#elif defined(__TINYC__)
-#  define LZO_CC_TINYC          1
-#  define LZO_INFO_CC           "Tiny C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__TINYC__)
-#elif defined(__TSC__)
-#  define LZO_CC_TOPSPEEDC      1
-#  define LZO_INFO_CC           "TopSpeed C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__TSC__)
-#elif defined(__WATCOMC__)
-#  define LZO_CC_WATCOMC        1
-#  define LZO_INFO_CC           "Watcom C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__WATCOMC__)
-#elif defined(__TURBOC__)
-#  define LZO_CC_TURBOC         1
-#  define LZO_INFO_CC           "Turbo C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__TURBOC__)
-#elif defined(__ZTC__)
-#  define LZO_CC_ZORTECHC       1
-#  define LZO_INFO_CC           "Zortech C"
-#  if (__ZTC__ == 0x310)
-#    define LZO_INFO_CCVER      "0x310"
-#  else
-#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(__ZTC__)
-#  endif
-#else
-#  define LZO_CC_UNKNOWN        1
-#  define LZO_INFO_CC           "unknown"
-#  define LZO_INFO_CCVER        "unknown"
-#endif
-#if 0 && (LZO_CC_MSC && (_MSC_VER >= 1200)) && !defined(_MSC_FULL_VER)
-#  error "LZO_CC_MSC: _MSC_FULL_VER is not defined"
-#endif
-#if !defined(__LZO_ARCH_OVERRIDE) && !(LZO_ARCH_GENERIC) && defined(_CRAY)
-#  if (UINT_MAX > LZO_0xffffffffL) && defined(_CRAY)
-#    if defined(_CRAYMPP) || defined(_CRAYT3D) || defined(_CRAYT3E)
-#      define LZO_ARCH_CRAY_MPP     1
-#    elif defined(_CRAY1)
-#      define LZO_ARCH_CRAY_PVP     1
-#    endif
-#  endif
-#endif
-#if !defined(__LZO_ARCH_OVERRIDE)
-#if (LZO_ARCH_GENERIC)
-#  define LZO_INFO_ARCH             "generic"
-#elif (LZO_OS_DOS16 || LZO_OS_OS216 || LZO_OS_WIN16)
-#  define LZO_ARCH_I086             1
-#  define LZO_ARCH_IA16             1
-#  define LZO_INFO_ARCH             "i086"
-#elif defined(__alpha__) || defined(__alpha) || defined(_M_ALPHA)
-#  define LZO_ARCH_ALPHA            1
-#  define LZO_INFO_ARCH             "alpha"
-#elif (LZO_ARCH_CRAY_MPP) && (defined(_CRAYT3D) || defined(_CRAYT3E))
-#  define LZO_ARCH_ALPHA            1
-#  define LZO_INFO_ARCH             "alpha"
-#elif defined(__amd64__) || defined(__x86_64__) || defined(_M_AMD64)
-#  define LZO_ARCH_AMD64            1
-#  define LZO_INFO_ARCH             "amd64"
-#elif defined(__thumb__) || (defined(_M_ARM) && defined(_M_THUMB))
-#  define LZO_ARCH_ARM              1
-#  define LZO_ARCH_ARM_THUMB        1
-#  define LZO_INFO_ARCH             "arm_thumb"
-#elif defined(__IAR_SYSTEMS_ICC__) && defined(__ICCARM__)
-#  define LZO_ARCH_ARM              1
-#  if defined(__CPU_MODE__) && ((__CPU_MODE__)+0 == 1)
-#    define LZO_ARCH_ARM_THUMB      1
-#    define LZO_INFO_ARCH           "arm_thumb"
-#  elif defined(__CPU_MODE__) && ((__CPU_MODE__)+0 == 2)
-#    define LZO_INFO_ARCH           "arm"
-#  else
-#    define LZO_INFO_ARCH           "arm"
-#  endif
-#elif defined(__arm__) || defined(_M_ARM)
-#  define LZO_ARCH_ARM              1
-#  define LZO_INFO_ARCH             "arm"
-#elif (UINT_MAX <= LZO_0xffffL) && defined(__AVR__)
-#  define LZO_ARCH_AVR              1
-#  define LZO_INFO_ARCH             "avr"
-#elif defined(__avr32__) || defined(__AVR32__)
-#  define LZO_ARCH_AVR32            1
-#  define LZO_INFO_ARCH             "avr32"
-#elif defined(__bfin__)
-#  define LZO_ARCH_BLACKFIN         1
-#  define LZO_INFO_ARCH             "blackfin"
-#elif (UINT_MAX == LZO_0xffffL) && defined(__C166__)
-#  define LZO_ARCH_C166             1
-#  define LZO_INFO_ARCH             "c166"
-#elif defined(__cris__)
-#  define LZO_ARCH_CRIS             1
-#  define LZO_INFO_ARCH             "cris"
-#elif defined(__IAR_SYSTEMS_ICC__) && defined(__ICCEZ80__)
-#  define LZO_ARCH_EZ80             1
-#  define LZO_INFO_ARCH             "ez80"
-#elif defined(__H8300__) || defined(__H8300H__) || defined(__H8300S__) || defined(__H8300SX__)
-#  define LZO_ARCH_H8300            1
-#  define LZO_INFO_ARCH             "h8300"
-#elif defined(__hppa__) || defined(__hppa)
-#  define LZO_ARCH_HPPA             1
-#  define LZO_INFO_ARCH             "hppa"
-#elif defined(__386__) || defined(__i386__) || defined(__i386) || defined(_M_IX86) || defined(_M_I386)
-#  define LZO_ARCH_I386             1
-#  define LZO_ARCH_IA32             1
-#  define LZO_INFO_ARCH             "i386"
-#elif (LZO_CC_ZORTECHC && defined(__I86__))
-#  define LZO_ARCH_I386             1
-#  define LZO_ARCH_IA32             1
-#  define LZO_INFO_ARCH             "i386"
-#elif (LZO_OS_DOS32 && LZO_CC_HIGHC) && defined(_I386)
-#  define LZO_ARCH_I386             1
-#  define LZO_ARCH_IA32             1
-#  define LZO_INFO_ARCH             "i386"
-#elif defined(__ia64__) || defined(__ia64) || defined(_M_IA64)
-#  define LZO_ARCH_IA64             1
-#  define LZO_INFO_ARCH             "ia64"
-#elif (UINT_MAX == LZO_0xffffL) && defined(__m32c__)
-#  define LZO_ARCH_M16C             1
-#  define LZO_INFO_ARCH             "m16c"
-#elif defined(__IAR_SYSTEMS_ICC__) && defined(__ICCM16C__)
-#  define LZO_ARCH_M16C             1
-#  define LZO_INFO_ARCH             "m16c"
-#elif defined(__m32r__)
-#  define LZO_ARCH_M32R             1
-#  define LZO_INFO_ARCH             "m32r"
-#elif (LZO_OS_TOS) || defined(__m68k__) || defined(__m68000__) || defined(__mc68000__) || defined(__mc68020__) || defined(_M_M68K)
-#  define LZO_ARCH_M68K             1
-#  define LZO_INFO_ARCH             "m68k"
-#elif (UINT_MAX == LZO_0xffffL) && defined(__C251__)
-#  define LZO_ARCH_MCS251           1
-#  define LZO_INFO_ARCH             "mcs251"
-#elif (UINT_MAX == LZO_0xffffL) && defined(__C51__)
-#  define LZO_ARCH_MCS51            1
-#  define LZO_INFO_ARCH             "mcs51"
-#elif defined(__IAR_SYSTEMS_ICC__) && defined(__ICC8051__)
-#  define LZO_ARCH_MCS51            1
-#  define LZO_INFO_ARCH             "mcs51"
-#elif defined(__mips__) || defined(__mips) || defined(_MIPS_ARCH) || defined(_M_MRX000)
-#  define LZO_ARCH_MIPS             1
-#  define LZO_INFO_ARCH             "mips"
-#elif (UINT_MAX == LZO_0xffffL) && defined(__MSP430__)
-#  define LZO_ARCH_MSP430           1
-#  define LZO_INFO_ARCH             "msp430"
-#elif defined(__IAR_SYSTEMS_ICC__) && defined(__ICC430__)
-#  define LZO_ARCH_MSP430           1
-#  define LZO_INFO_ARCH             "msp430"
-#elif defined(__powerpc__) || defined(__powerpc) || defined(__ppc__) || defined(__PPC__) || defined(_M_PPC) || defined(_ARCH_PPC) || defined(_ARCH_PWR)
-#  define LZO_ARCH_POWERPC          1
-#  define LZO_INFO_ARCH             "powerpc"
-#elif defined(__s390__) || defined(__s390) || defined(__s390x__) || defined(__s390x)
-#  define LZO_ARCH_S390             1
-#  define LZO_INFO_ARCH             "s390"
-#elif defined(__sh__) || defined(_M_SH)
-#  define LZO_ARCH_SH               1
-#  define LZO_INFO_ARCH             "sh"
-#elif defined(__sparc__) || defined(__sparc) || defined(__sparcv8)
-#  define LZO_ARCH_SPARC            1
-#  define LZO_INFO_ARCH             "sparc"
-#elif defined(__SPU__)
-#  define LZO_ARCH_SPU              1
-#  define LZO_INFO_ARCH             "spu"
-#elif (UINT_MAX == LZO_0xffffL) && defined(__z80)
-#  define LZO_ARCH_Z80              1
-#  define LZO_INFO_ARCH             "z80"
-#elif (LZO_ARCH_CRAY_PVP)
-#  if defined(_CRAYSV1)
-#    define LZO_ARCH_CRAY_SV1       1
-#    define LZO_INFO_ARCH           "cray_sv1"
-#  elif (_ADDR64)
-#    define LZO_ARCH_CRAY_T90       1
-#    define LZO_INFO_ARCH           "cray_t90"
-#  elif (_ADDR32)
-#    define LZO_ARCH_CRAY_YMP       1
-#    define LZO_INFO_ARCH           "cray_ymp"
-#  else
-#    define LZO_ARCH_CRAY_XMP       1
-#    define LZO_INFO_ARCH           "cray_xmp"
-#  endif
-#else
-#  define LZO_ARCH_UNKNOWN          1
-#  define LZO_INFO_ARCH             "unknown"
-#endif
-#endif
-#if 1 && (LZO_ARCH_UNKNOWN) && (LZO_OS_DOS32 || LZO_OS_OS2)
-#  error "FIXME - missing define for CPU architecture"
-#endif
-#if 1 && (LZO_ARCH_UNKNOWN) && (LZO_OS_WIN32)
-#  error "FIXME - missing WIN32 define for CPU architecture"
-#endif
-#if 1 && (LZO_ARCH_UNKNOWN) && (LZO_OS_WIN64)
-#  error "FIXME - missing WIN64 define for CPU architecture"
-#endif
-#if (LZO_OS_OS216 || LZO_OS_WIN16)
-#  define LZO_ARCH_I086PM           1
-#  define LZO_ARCH_IA16PM           1
-#elif 1 && (LZO_OS_DOS16 && defined(BLX286))
-#  define LZO_ARCH_I086PM           1
-#  define LZO_ARCH_IA16PM           1
-#elif 1 && (LZO_OS_DOS16 && defined(DOSX286))
-#  define LZO_ARCH_I086PM           1
-#  define LZO_ARCH_IA16PM           1
-#elif 1 && (LZO_OS_DOS16 && LZO_CC_BORLANDC && defined(__DPMI16__))
-#  define LZO_ARCH_I086PM           1
-#  define LZO_ARCH_IA16PM           1
-#endif
-#if (LZO_ARCH_ARM_THUMB) && !(LZO_ARCH_ARM)
-#  error "this should not happen"
-#endif
-#if (LZO_ARCH_I086PM) && !(LZO_ARCH_I086)
-#  error "this should not happen"
-#endif
-#if (LZO_ARCH_I086)
-#  if (UINT_MAX != LZO_0xffffL)
-#    error "this should not happen"
-#  endif
-#  if (ULONG_MAX != LZO_0xffffffffL)
-#    error "this should not happen"
-#  endif
-#endif
-#if (LZO_ARCH_I386)
-#  if (UINT_MAX != LZO_0xffffL) && defined(__i386_int16__)
-#    error "this should not happen"
-#  endif
-#  if (UINT_MAX != LZO_0xffffffffL) && !defined(__i386_int16__)
-#    error "this should not happen"
-#  endif
-#  if (ULONG_MAX != LZO_0xffffffffL)
-#    error "this should not happen"
-#  endif
-#endif
-#if !defined(__LZO_MM_OVERRIDE)
-#if (LZO_ARCH_I086)
-#if (UINT_MAX != LZO_0xffffL)
-#  error "this should not happen"
-#endif
-#if defined(__TINY__) || defined(M_I86TM) || defined(_M_I86TM)
-#  define LZO_MM_TINY           1
-#elif defined(__HUGE__) || defined(_HUGE_) || defined(M_I86HM) || defined(_M_I86HM)
-#  define LZO_MM_HUGE           1
-#elif defined(__SMALL__) || defined(M_I86SM) || defined(_M_I86SM) || defined(SMALL_MODEL)
-#  define LZO_MM_SMALL          1
-#elif defined(__MEDIUM__) || defined(M_I86MM) || defined(_M_I86MM)
-#  define LZO_MM_MEDIUM         1
-#elif defined(__COMPACT__) || defined(M_I86CM) || defined(_M_I86CM)
-#  define LZO_MM_COMPACT        1
-#elif defined(__LARGE__) || defined(M_I86LM) || defined(_M_I86LM) || defined(LARGE_MODEL)
-#  define LZO_MM_LARGE          1
-#elif (LZO_CC_AZTECC)
-#  if defined(_LARGE_CODE) && defined(_LARGE_DATA)
-#    define LZO_MM_LARGE        1
-#  elif defined(_LARGE_CODE)
-#    define LZO_MM_MEDIUM       1
-#  elif defined(_LARGE_DATA)
-#    define LZO_MM_COMPACT      1
-#  else
-#    define LZO_MM_SMALL        1
-#  endif
-#elif (LZO_CC_ZORTECHC && defined(__VCM__))
-#  define LZO_MM_LARGE          1
-#else
-#  error "unknown memory model"
-#endif
-#if (LZO_OS_DOS16 || LZO_OS_OS216 || LZO_OS_WIN16)
-#define LZO_HAVE_MM_HUGE_PTR        1
-#define LZO_HAVE_MM_HUGE_ARRAY      1
-#if (LZO_MM_TINY)
-#  undef LZO_HAVE_MM_HUGE_ARRAY
-#endif
-#if (LZO_CC_AZTECC || LZO_CC_PACIFICC || LZO_CC_ZORTECHC)
-#  undef LZO_HAVE_MM_HUGE_PTR
-#  undef LZO_HAVE_MM_HUGE_ARRAY
-#elif (LZO_CC_DMC || LZO_CC_SYMANTECC)
-#  undef LZO_HAVE_MM_HUGE_ARRAY
-#elif (LZO_CC_MSC && defined(_QC))
-#  undef LZO_HAVE_MM_HUGE_ARRAY
-#  if (_MSC_VER < 600)
-#    undef LZO_HAVE_MM_HUGE_PTR
-#  endif
-#elif (LZO_CC_TURBOC && (__TURBOC__ < 0x0295))
-#  undef LZO_HAVE_MM_HUGE_ARRAY
-#endif
-#if (LZO_ARCH_I086PM) && !(LZO_HAVE_MM_HUGE_PTR)
-#  if (LZO_OS_DOS16)
-#    error "this should not happen"
-#  elif (LZO_CC_ZORTECHC)
-#  else
-#    error "this should not happen"
-#  endif
-#endif
-#ifdef __cplusplus
-extern "C" {
-#endif
-#if (LZO_CC_BORLANDC && (__BORLANDC__ >= 0x0200))
-   extern void __near __cdecl _AHSHIFT(void);
-#  define LZO_MM_AHSHIFT      ((unsigned) _AHSHIFT)
-#elif (LZO_CC_DMC || LZO_CC_SYMANTECC || LZO_CC_ZORTECHC)
-   extern void __near __cdecl _AHSHIFT(void);
-#  define LZO_MM_AHSHIFT      ((unsigned) _AHSHIFT)
-#elif (LZO_CC_MSC || LZO_CC_TOPSPEEDC)
-   extern void __near __cdecl _AHSHIFT(void);
-#  define LZO_MM_AHSHIFT      ((unsigned) _AHSHIFT)
-#elif (LZO_CC_TURBOC && (__TURBOC__ >= 0x0295))
-   extern void __near __cdecl _AHSHIFT(void);
-#  define LZO_MM_AHSHIFT      ((unsigned) _AHSHIFT)
-#elif ((LZO_CC_AZTECC || LZO_CC_PACIFICC || LZO_CC_TURBOC) && LZO_OS_DOS16)
-#  define LZO_MM_AHSHIFT      12
-#elif (LZO_CC_WATCOMC)
-   extern unsigned char _HShift;
-#  define LZO_MM_AHSHIFT      ((unsigned) _HShift)
-#else
-#  error "FIXME - implement LZO_MM_AHSHIFT"
-#endif
-#ifdef __cplusplus
-}
-#endif
-#endif
-#elif (LZO_ARCH_C166)
-#if !defined(__MODEL__)
-#  error "FIXME - C166 __MODEL__"
-#elif ((__MODEL__) == 0)
-#  define LZO_MM_SMALL          1
-#elif ((__MODEL__) == 1)
-#  define LZO_MM_SMALL          1
-#elif ((__MODEL__) == 2)
-#  define LZO_MM_LARGE          1
-#elif ((__MODEL__) == 3)
-#  define LZO_MM_TINY           1
-#elif ((__MODEL__) == 4)
-#  define LZO_MM_XTINY          1
-#elif ((__MODEL__) == 5)
-#  define LZO_MM_XSMALL         1
-#else
-#  error "FIXME - C166 __MODEL__"
-#endif
-#elif (LZO_ARCH_MCS251)
-#if !defined(__MODEL__)
-#  error "FIXME - MCS251 __MODEL__"
-#elif ((__MODEL__) == 0)
-#  define LZO_MM_SMALL          1
-#elif ((__MODEL__) == 2)
-#  define LZO_MM_LARGE          1
-#elif ((__MODEL__) == 3)
-#  define LZO_MM_TINY           1
-#elif ((__MODEL__) == 4)
-#  define LZO_MM_XTINY          1
-#elif ((__MODEL__) == 5)
-#  define LZO_MM_XSMALL         1
-#else
-#  error "FIXME - MCS251 __MODEL__"
-#endif
-#elif (LZO_ARCH_MCS51)
-#if !defined(__MODEL__)
-#  error "FIXME - MCS51 __MODEL__"
-#elif ((__MODEL__) == 1)
-#  define LZO_MM_SMALL          1
-#elif ((__MODEL__) == 2)
-#  define LZO_MM_LARGE          1
-#elif ((__MODEL__) == 3)
-#  define LZO_MM_TINY           1
-#elif ((__MODEL__) == 4)
-#  define LZO_MM_XTINY          1
-#elif ((__MODEL__) == 5)
-#  define LZO_MM_XSMALL         1
-#else
-#  error "FIXME - MCS51 __MODEL__"
-#endif
-#elif (LZO_ARCH_CRAY_PVP)
-#  define LZO_MM_PVP            1
-#else
-#  define LZO_MM_FLAT           1
-#endif
-#if (LZO_MM_COMPACT)
-#  define LZO_INFO_MM           "compact"
-#elif (LZO_MM_FLAT)
-#  define LZO_INFO_MM           "flat"
-#elif (LZO_MM_HUGE)
-#  define LZO_INFO_MM           "huge"
-#elif (LZO_MM_LARGE)
-#  define LZO_INFO_MM           "large"
-#elif (LZO_MM_MEDIUM)
-#  define LZO_INFO_MM           "medium"
-#elif (LZO_MM_PVP)
-#  define LZO_INFO_MM           "pvp"
-#elif (LZO_MM_SMALL)
-#  define LZO_INFO_MM           "small"
-#elif (LZO_MM_TINY)
-#  define LZO_INFO_MM           "tiny"
-#else
-#  error "unknown memory model"
-#endif
-#endif
-#if defined(SIZEOF_SHORT)
-#  define LZO_SIZEOF_SHORT          (SIZEOF_SHORT)
-#endif
-#if defined(SIZEOF_INT)
-#  define LZO_SIZEOF_INT            (SIZEOF_INT)
-#endif
-#if defined(SIZEOF_LONG)
-#  define LZO_SIZEOF_LONG           (SIZEOF_LONG)
-#endif
-#if defined(SIZEOF_LONG_LONG)
-#  define LZO_SIZEOF_LONG_LONG      (SIZEOF_LONG_LONG)
-#endif
-#if defined(SIZEOF___INT16)
-#  define LZO_SIZEOF___INT16        (SIZEOF___INT16)
-#endif
-#if defined(SIZEOF___INT32)
-#  define LZO_SIZEOF___INT32        (SIZEOF___INT32)
-#endif
-#if defined(SIZEOF___INT64)
-#  define LZO_SIZEOF___INT64        (SIZEOF___INT64)
-#endif
-#if defined(SIZEOF_VOID_P)
-#  define LZO_SIZEOF_VOID_P         (SIZEOF_VOID_P)
-#endif
-#if defined(SIZEOF_SIZE_T)
-#  define LZO_SIZEOF_SIZE_T         (SIZEOF_SIZE_T)
-#endif
-#if defined(SIZEOF_PTRDIFF_T)
-#  define LZO_SIZEOF_PTRDIFF_T      (SIZEOF_PTRDIFF_T)
-#endif
-#define __LZO_LSR(x,b)    (((x)+0ul) >> (b))
-#if !defined(LZO_SIZEOF_SHORT)
-#  if (LZO_ARCH_CRAY_PVP)
-#    define LZO_SIZEOF_SHORT        8
-#  elif (USHRT_MAX == LZO_0xffffL)
-#    define LZO_SIZEOF_SHORT        2
-#  elif (__LZO_LSR(USHRT_MAX,7) == 1)
-#    define LZO_SIZEOF_SHORT        1
-#  elif (__LZO_LSR(USHRT_MAX,15) == 1)
-#    define LZO_SIZEOF_SHORT        2
-#  elif (__LZO_LSR(USHRT_MAX,31) == 1)
-#    define LZO_SIZEOF_SHORT        4
-#  elif (__LZO_LSR(USHRT_MAX,63) == 1)
-#    define LZO_SIZEOF_SHORT        8
-#  elif (__LZO_LSR(USHRT_MAX,127) == 1)
-#    define LZO_SIZEOF_SHORT        16
-#  else
-#    error "LZO_SIZEOF_SHORT"
-#  endif
-#endif
-#if !defined(LZO_SIZEOF_INT)
-#  if (LZO_ARCH_CRAY_PVP)
-#    define LZO_SIZEOF_INT          8
-#  elif (UINT_MAX == LZO_0xffffL)
-#    define LZO_SIZEOF_INT          2
-#  elif (UINT_MAX == LZO_0xffffffffL)
-#    define LZO_SIZEOF_INT          4
-#  elif (__LZO_LSR(UINT_MAX,7) == 1)
-#    define LZO_SIZEOF_INT          1
-#  elif (__LZO_LSR(UINT_MAX,15) == 1)
-#    define LZO_SIZEOF_INT          2
-#  elif (__LZO_LSR(UINT_MAX,31) == 1)
-#    define LZO_SIZEOF_INT          4
-#  elif (__LZO_LSR(UINT_MAX,63) == 1)
-#    define LZO_SIZEOF_INT          8
-#  elif (__LZO_LSR(UINT_MAX,127) == 1)
-#    define LZO_SIZEOF_INT          16
-#  else
-#    error "LZO_SIZEOF_INT"
-#  endif
-#endif
-#if !defined(LZO_SIZEOF_LONG)
-#  if (ULONG_MAX == LZO_0xffffffffL)
-#    define LZO_SIZEOF_LONG         4
-#  elif (__LZO_LSR(ULONG_MAX,7) == 1)
-#    define LZO_SIZEOF_LONG         1
-#  elif (__LZO_LSR(ULONG_MAX,15) == 1)
-#    define LZO_SIZEOF_LONG         2
-#  elif (__LZO_LSR(ULONG_MAX,31) == 1)
-#    define LZO_SIZEOF_LONG         4
-#  elif (__LZO_LSR(ULONG_MAX,63) == 1)
-#    define LZO_SIZEOF_LONG         8
-#  elif (__LZO_LSR(ULONG_MAX,127) == 1)
-#    define LZO_SIZEOF_LONG         16
-#  else
-#    error "LZO_SIZEOF_LONG"
-#  endif
-#endif
-#if !defined(LZO_SIZEOF_LONG_LONG) && !defined(LZO_SIZEOF___INT64)
-#if (LZO_SIZEOF_LONG > 0 && LZO_SIZEOF_LONG < 8)
-#  if defined(__LONG_MAX__) && defined(__LONG_LONG_MAX__)
-#    if (LZO_CC_GNUC >= 0x030300ul)
-#      if ((__LONG_MAX__)+0 == (__LONG_LONG_MAX__)+0)
-#        define LZO_SIZEOF_LONG_LONG      LZO_SIZEOF_LONG
-#      elif (__LZO_LSR(__LONG_LONG_MAX__,30) == 1)
-#        define LZO_SIZEOF_LONG_LONG      4
-#      endif
-#    endif
-#  endif
-#endif
-#endif
-#if !defined(LZO_SIZEOF_LONG_LONG) && !defined(LZO_SIZEOF___INT64)
-#if (LZO_SIZEOF_LONG > 0 && LZO_SIZEOF_LONG < 8)
-#if (LZO_ARCH_I086 && LZO_CC_DMC)
-#elif (LZO_CC_CILLY) && defined(__GNUC__)
-#  define LZO_SIZEOF_LONG_LONG      8
-#elif (LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#  define LZO_SIZEOF_LONG_LONG      8
-#elif ((LZO_OS_WIN32 || LZO_OS_WIN64 || defined(_WIN32)) && LZO_CC_MSC && (_MSC_VER >= 1400))
-#  define LZO_SIZEOF_LONG_LONG      8
-#elif (LZO_OS_WIN64 || defined(_WIN64))
-#  define LZO_SIZEOF___INT64        8
-#elif (LZO_ARCH_I386 && (LZO_CC_DMC))
-#  define LZO_SIZEOF_LONG_LONG      8
-#elif (LZO_ARCH_I386 && (LZO_CC_SYMANTECC && (__SC__ >= 0x700)))
-#  define LZO_SIZEOF_LONG_LONG      8
-#elif (LZO_ARCH_I386 && (LZO_CC_INTELC && defined(__linux__)))
-#  define LZO_SIZEOF_LONG_LONG      8
-#elif (LZO_ARCH_I386 && (LZO_CC_MWERKS || LZO_CC_PELLESC || LZO_CC_PGI || LZO_CC_SUNPROC))
-#  define LZO_SIZEOF_LONG_LONG      8
-#elif (LZO_ARCH_I386 && (LZO_CC_INTELC || LZO_CC_MSC))
-#  define LZO_SIZEOF___INT64        8
-#elif ((LZO_OS_WIN32 || defined(_WIN32)) && (LZO_CC_MSC))
-#  define LZO_SIZEOF___INT64        8
-#elif (LZO_ARCH_I386 && (LZO_CC_BORLANDC && (__BORLANDC__ >= 0x0520)))
-#  define LZO_SIZEOF___INT64        8
-#elif (LZO_ARCH_I386 && (LZO_CC_WATCOMC && (__WATCOMC__ >= 1100)))
-#  define LZO_SIZEOF___INT64        8
-#elif (LZO_CC_WATCOMC && defined(_INTEGRAL_MAX_BITS) && (_INTEGRAL_MAX_BITS == 64))
-#  define LZO_SIZEOF___INT64        8
-#elif (LZO_OS_OS400 || defined(__OS400__)) && defined(__LLP64_IFC__)
-#  define LZO_SIZEOF_LONG_LONG      8
-#elif (defined(__vms) || defined(__VMS)) && (__INITIAL_POINTER_SIZE+0 == 64)
-#  define LZO_SIZEOF_LONG_LONG      8
-#elif (LZO_CC_SDCC) && (LZO_SIZEOF_INT == 2)
-#elif 1 && defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
-#  define LZO_SIZEOF_LONG_LONG      8
-#endif
-#endif
-#endif
-#if defined(__cplusplus) && (LZO_CC_GNUC)
-#  if (LZO_CC_GNUC < 0x020800ul)
-#    undef LZO_SIZEOF_LONG_LONG
-#  endif
-#endif
-#if (LZO_CFG_NO_LONG_LONG) || defined(__NO_LONG_LONG)
-#  undef LZO_SIZEOF_LONG_LONG
-#endif
-#if !defined(LZO_SIZEOF_VOID_P)
-#if (LZO_ARCH_I086)
-#  define __LZO_WORDSIZE            2
-#  if (LZO_MM_TINY || LZO_MM_SMALL || LZO_MM_MEDIUM)
-#    define LZO_SIZEOF_VOID_P       2
-#  elif (LZO_MM_COMPACT || LZO_MM_LARGE || LZO_MM_HUGE)
-#    define LZO_SIZEOF_VOID_P       4
-#  else
-#    error "LZO_MM"
-#  endif
-#elif (LZO_ARCH_AVR || LZO_ARCH_Z80)
-#  define __LZO_WORDSIZE            1
-#  define LZO_SIZEOF_VOID_P         2
-#elif (LZO_ARCH_C166 || LZO_ARCH_MCS51 || LZO_ARCH_MCS251 || LZO_ARCH_MSP430)
-#  define LZO_SIZEOF_VOID_P         2
-#elif (LZO_ARCH_H8300)
-#  if defined(__NORMAL_MODE__)
-#    define __LZO_WORDSIZE          4
-#    define LZO_SIZEOF_VOID_P       2
-#  elif defined(__H8300H__) || defined(__H8300S__) || defined(__H8300SX__)
-#    define __LZO_WORDSIZE          4
-#    define LZO_SIZEOF_VOID_P       4
-#  else
-#    define __LZO_WORDSIZE          2
-#    define LZO_SIZEOF_VOID_P       2
-#  endif
-#  if (LZO_CC_GNUC && (LZO_CC_GNUC < 0x040000ul)) && (LZO_SIZEOF_INT == 4)
-#    define LZO_SIZEOF_SIZE_T       LZO_SIZEOF_INT
-#    define LZO_SIZEOF_PTRDIFF_T    LZO_SIZEOF_INT
-#  endif
-#elif (LZO_ARCH_M16C)
-#  define __LZO_WORDSIZE            2
-#  if defined(__m32c_cpu__) || defined(__m32cm_cpu__)
-#    define LZO_SIZEOF_VOID_P       4
-#  else
-#    define LZO_SIZEOF_VOID_P       2
-#  endif
-#elif (LZO_SIZEOF_LONG == 8) && ((defined(__mips__) && defined(__R5900__)) || defined(__MIPS_PSX2__))
-#  define __LZO_WORDSIZE            8
-#  define LZO_SIZEOF_VOID_P         4
-#elif defined(__LLP64__) || defined(__LLP64) || defined(_LLP64) || defined(_WIN64)
-#  define __LZO_WORDSIZE            8
-#  define LZO_SIZEOF_VOID_P         8
-#elif (LZO_OS_OS400 || defined(__OS400__)) && defined(__LLP64_IFC__)
-#  define LZO_SIZEOF_VOID_P         LZO_SIZEOF_LONG
-#  define LZO_SIZEOF_SIZE_T         LZO_SIZEOF_LONG
-#  define LZO_SIZEOF_PTRDIFF_T      LZO_SIZEOF_LONG
-#elif (LZO_OS_OS400 || defined(__OS400__))
-#  define __LZO_WORDSIZE            LZO_SIZEOF_LONG
-#  define LZO_SIZEOF_VOID_P         16
-#  define LZO_SIZEOF_SIZE_T         LZO_SIZEOF_LONG
-#  define LZO_SIZEOF_PTRDIFF_T      LZO_SIZEOF_LONG
-#elif (defined(__vms) || defined(__VMS)) && (__INITIAL_POINTER_SIZE+0 == 64)
-#  define LZO_SIZEOF_VOID_P         8
-#  define LZO_SIZEOF_SIZE_T         LZO_SIZEOF_LONG
-#  define LZO_SIZEOF_PTRDIFF_T      LZO_SIZEOF_LONG
-#elif (LZO_ARCH_SPU)
-# if 0
-#  define __LZO_WORDSIZE            16
-# endif
-#  define LZO_SIZEOF_VOID_P         4
-#else
-#  define LZO_SIZEOF_VOID_P         LZO_SIZEOF_LONG
-#endif
-#endif
-#if !defined(LZO_WORDSIZE)
-#  if defined(__LZO_WORDSIZE)
-#    define LZO_WORDSIZE            __LZO_WORDSIZE
-#  else
-#    define LZO_WORDSIZE            LZO_SIZEOF_VOID_P
-#  endif
-#endif
-#if !defined(LZO_SIZEOF_SIZE_T)
-#if (LZO_ARCH_I086 || LZO_ARCH_M16C)
-#  define LZO_SIZEOF_SIZE_T         2
-#else
-#  define LZO_SIZEOF_SIZE_T         LZO_SIZEOF_VOID_P
-#endif
-#endif
-#if !defined(LZO_SIZEOF_PTRDIFF_T)
-#if (LZO_ARCH_I086)
-#  if (LZO_MM_TINY || LZO_MM_SMALL || LZO_MM_MEDIUM || LZO_MM_HUGE)
-#    define LZO_SIZEOF_PTRDIFF_T    LZO_SIZEOF_VOID_P
-#  elif (LZO_MM_COMPACT || LZO_MM_LARGE)
-#    if (LZO_CC_BORLANDC || LZO_CC_TURBOC)
-#      define LZO_SIZEOF_PTRDIFF_T  4
-#    else
-#      define LZO_SIZEOF_PTRDIFF_T  2
-#    endif
-#  else
-#    error "LZO_MM"
-#  endif
-#else
-#  define LZO_SIZEOF_PTRDIFF_T      LZO_SIZEOF_SIZE_T
-#endif
-#endif
-#if (LZO_ABI_NEUTRAL_ENDIAN)
-#  undef LZO_ABI_BIG_ENDIAN
-#  undef LZO_ABI_LITTLE_ENDIAN
-#elif !(LZO_ABI_BIG_ENDIAN) && !(LZO_ABI_LITTLE_ENDIAN)
-#if (LZO_ARCH_ALPHA) && (LZO_ARCH_CRAY_MPP)
-#  define LZO_ABI_BIG_ENDIAN        1
-#elif (LZO_ARCH_IA64) && (LZO_OS_POSIX_LINUX || LZO_OS_WIN64)
-#  define LZO_ABI_LITTLE_ENDIAN     1
-#elif (LZO_ARCH_ALPHA || LZO_ARCH_AMD64 || LZO_ARCH_BLACKFIN || LZO_ARCH_CRIS || LZO_ARCH_I086 || LZO_ARCH_I386 || LZO_ARCH_MSP430)
-#  define LZO_ABI_LITTLE_ENDIAN     1
-#elif (LZO_ARCH_AVR32 || LZO_ARCH_M68K || LZO_ARCH_S390)
-#  define LZO_ABI_BIG_ENDIAN        1
-#elif 1 && defined(__IAR_SYSTEMS_ICC__) && defined(__LITTLE_ENDIAN__)
-#  if (__LITTLE_ENDIAN__ == 1)
-#    define LZO_ABI_LITTLE_ENDIAN   1
-#  else
-#    define LZO_ABI_BIG_ENDIAN      1
-#  endif
-#elif 1 && defined(__BIG_ENDIAN__) && !defined(__LITTLE_ENDIAN__)
-#  define LZO_ABI_BIG_ENDIAN        1
-#elif 1 && defined(__LITTLE_ENDIAN__) && !defined(__BIG_ENDIAN__)
-#  define LZO_ABI_LITTLE_ENDIAN     1
-#elif 1 && (LZO_ARCH_ARM) && defined(__ARMEB__) && !defined(__ARMEL__)
-#  define LZO_ABI_BIG_ENDIAN        1
-#elif 1 && (LZO_ARCH_ARM) && defined(__ARMEL__) && !defined(__ARMEB__)
-#  define LZO_ABI_LITTLE_ENDIAN     1
-#elif 1 && (LZO_ARCH_MIPS) && defined(__MIPSEB__) && !defined(__MIPSEL__)
-#  define LZO_ABI_BIG_ENDIAN        1
-#elif 1 && (LZO_ARCH_MIPS) && defined(__MIPSEL__) && !defined(__MIPSEB__)
-#  define LZO_ABI_LITTLE_ENDIAN     1
-#endif
-#endif
-#if (LZO_ABI_BIG_ENDIAN) && (LZO_ABI_LITTLE_ENDIAN)
-#  error "this should not happen"
-#endif
-#if (LZO_ABI_BIG_ENDIAN)
-#  define LZO_INFO_ABI_ENDIAN       "be"
-#elif (LZO_ABI_LITTLE_ENDIAN)
-#  define LZO_INFO_ABI_ENDIAN       "le"
-#elif (LZO_ABI_NEUTRAL_ENDIAN)
-#  define LZO_INFO_ABI_ENDIAN       "neutral"
-#endif
-#if (LZO_SIZEOF_INT == 1 && LZO_SIZEOF_LONG == 2 && LZO_SIZEOF_VOID_P == 2)
-#  define LZO_ABI_I8LP16         1
-#  define LZO_INFO_ABI_PM       "i8lp16"
-#elif (LZO_SIZEOF_INT == 2 && LZO_SIZEOF_LONG == 2 && LZO_SIZEOF_VOID_P == 2)
-#  define LZO_ABI_ILP16         1
-#  define LZO_INFO_ABI_PM       "ilp16"
-#elif (LZO_SIZEOF_INT == 4 && LZO_SIZEOF_LONG == 4 && LZO_SIZEOF_VOID_P == 4)
-#  define LZO_ABI_ILP32         1
-#  define LZO_INFO_ABI_PM       "ilp32"
-#elif (LZO_SIZEOF_INT == 4 && LZO_SIZEOF_LONG == 4 && LZO_SIZEOF_VOID_P == 8 && LZO_SIZEOF_SIZE_T == 8)
-#  define LZO_ABI_LLP64         1
-#  define LZO_INFO_ABI_PM       "llp64"
-#elif (LZO_SIZEOF_INT == 4 && LZO_SIZEOF_LONG == 8 && LZO_SIZEOF_VOID_P == 8)
-#  define LZO_ABI_LP64          1
-#  define LZO_INFO_ABI_PM       "lp64"
-#elif (LZO_SIZEOF_INT == 8 && LZO_SIZEOF_LONG == 8 && LZO_SIZEOF_VOID_P == 8)
-#  define LZO_ABI_ILP64         1
-#  define LZO_INFO_ABI_PM       "ilp64"
-#elif (LZO_SIZEOF_INT == 4 && LZO_SIZEOF_LONG == 8 && LZO_SIZEOF_VOID_P == 4)
-#  define LZO_ABI_IP32L64       1
-#  define LZO_INFO_ABI_PM       "ip32l64"
-#endif
-#if !defined(__LZO_LIBC_OVERRIDE)
-#if (LZO_LIBC_NAKED)
-#  define LZO_INFO_LIBC         "naked"
-#elif (LZO_LIBC_FREESTANDING)
-#  define LZO_INFO_LIBC         "freestanding"
-#elif (LZO_LIBC_MOSTLY_FREESTANDING)
-#  define LZO_INFO_LIBC         "mfreestanding"
-#elif (LZO_LIBC_ISOC90)
-#  define LZO_INFO_LIBC         "isoc90"
-#elif (LZO_LIBC_ISOC99)
-#  define LZO_INFO_LIBC         "isoc99"
-#elif defined(__dietlibc__)
-#  define LZO_LIBC_DIETLIBC     1
-#  define LZO_INFO_LIBC         "dietlibc"
-#elif defined(_NEWLIB_VERSION)
-#  define LZO_LIBC_NEWLIB       1
-#  define LZO_INFO_LIBC         "newlib"
-#elif defined(__UCLIBC__) && defined(__UCLIBC_MAJOR__) && defined(__UCLIBC_MINOR__)
-#  if defined(__UCLIBC_SUBLEVEL__)
-#    define LZO_LIBC_UCLIBC     (__UCLIBC_MAJOR__ * 0x10000L + __UCLIBC_MINOR__ * 0x100 + __UCLIBC_SUBLEVEL__)
-#  else
-#    define LZO_LIBC_UCLIBC     0x00090bL
-#  endif
-#  define LZO_INFO_LIBC         "uclibc"
-#elif defined(__GLIBC__) && defined(__GLIBC_MINOR__)
-#  define LZO_LIBC_GLIBC        (__GLIBC__ * 0x10000L + __GLIBC_MINOR__ * 0x100)
-#  define LZO_INFO_LIBC         "glibc"
-#elif (LZO_CC_MWERKS) && defined(__MSL__)
-#  define LZO_LIBC_MSL          __MSL__
-#  define LZO_INFO_LIBC         "msl"
-#elif 1 && defined(__IAR_SYSTEMS_ICC__)
-#  define LZO_LIBC_ISOC90       1
-#  define LZO_INFO_LIBC         "isoc90"
-#else
-#  define LZO_LIBC_DEFAULT      1
-#  define LZO_INFO_LIBC         "default"
-#endif
-#endif
-#if !defined(__lzo_gnuc_extension__)
-#if (LZO_CC_GNUC >= 0x020800ul)
-#  define __lzo_gnuc_extension__    __extension__
-#elif (LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#  define __lzo_gnuc_extension__    __extension__
-#else
-#  define __lzo_gnuc_extension__    /*empty*/
-#endif
-#endif
-#if !defined(__lzo_ua_volatile)
-#  define __lzo_ua_volatile     volatile
-#endif
-#if !defined(__lzo_alignof)
-#if (LZO_CC_CILLY || LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE || LZO_CC_PGI)
-#  define __lzo_alignof(e)      __alignof__(e)
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 700))
-#  define __lzo_alignof(e)      __alignof__(e)
-#elif (LZO_CC_MSC && (_MSC_VER >= 1300))
-#  define __lzo_alignof(e)      __alignof(e)
-#elif (LZO_CC_SUNPROC && (LZO_CC_SUNPROC >= 0x5100))
-#  define __lzo_alignof(e)      __alignof__(e)
-#endif
-#endif
-#if defined(__lzo_alignof)
-#  define __lzo_HAVE_alignof 1
-#endif
-#if !defined(__lzo_constructor)
-#if (LZO_CC_GNUC >= 0x030400ul)
-#  define __lzo_constructor     __attribute__((__constructor__,__used__))
-#elif (LZO_CC_GNUC >= 0x020700ul)
-#  define __lzo_constructor     __attribute__((__constructor__))
-#elif (LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#  define __lzo_constructor     __attribute__((__constructor__))
-#endif
-#endif
-#if defined(__lzo_constructor)
-#  define __lzo_HAVE_constructor 1
-#endif
-#if !defined(__lzo_destructor)
-#if (LZO_CC_GNUC >= 0x030400ul)
-#  define __lzo_destructor      __attribute__((__destructor__,__used__))
-#elif (LZO_CC_GNUC >= 0x020700ul)
-#  define __lzo_destructor      __attribute__((__destructor__))
-#elif (LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#  define __lzo_destructor      __attribute__((__destructor__))
-#endif
-#endif
-#if defined(__lzo_destructor)
-#  define __lzo_HAVE_destructor 1
-#endif
-#if (__lzo_HAVE_destructor) && !(__lzo_HAVE_constructor)
-#  error "this should not happen"
-#endif
-#if !defined(__lzo_inline)
-#if (LZO_CC_TURBOC && (__TURBOC__ <= 0x0295))
-#elif defined(__cplusplus)
-#  define __lzo_inline          inline
-#elif (LZO_CC_BORLANDC && (__BORLANDC__ >= 0x0550))
-#  define __lzo_inline          __inline
-#elif (LZO_CC_CILLY || LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE || LZO_CC_PGI)
-#  define __lzo_inline          __inline__
-#elif (LZO_CC_DMC)
-#  define __lzo_inline          __inline
-#elif (LZO_CC_INTELC)
-#  define __lzo_inline          __inline
-#elif (LZO_CC_MWERKS && (__MWERKS__ >= 0x2405))
-#  define __lzo_inline          __inline
-#elif (LZO_CC_MSC && (_MSC_VER >= 900))
-#  define __lzo_inline          __inline
-#elif (LZO_CC_SUNPROC && (LZO_CC_SUNPROC >= 0x5100))
-#  define __lzo_inline          __inline__
-#elif defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
-#  define __lzo_inline          inline
-#endif
-#endif
-#if defined(__lzo_inline)
-#  define __lzo_HAVE_inline 1
-#else
-#  define __lzo_inline          /*empty*/
-#endif
-#if !defined(__lzo_forceinline)
-#if (LZO_CC_GNUC >= 0x030200ul)
-#  define __lzo_forceinline     __inline__ __attribute__((__always_inline__))
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 450) && LZO_CC_SYNTAX_MSC)
-#  define __lzo_forceinline     __forceinline
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 800) && LZO_CC_SYNTAX_GNUC)
-#  define __lzo_forceinline     __inline__ __attribute__((__always_inline__))
-#elif (LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#  define __lzo_forceinline     __inline__ __attribute__((__always_inline__))
-#elif (LZO_CC_MSC && (_MSC_VER >= 1200))
-#  define __lzo_forceinline     __forceinline
-#elif (LZO_CC_SUNPROC && (LZO_CC_SUNPROC >= 0x5100))
-#  define __lzo_forceinline     __inline__ __attribute__((__always_inline__))
-#endif
-#endif
-#if defined(__lzo_forceinline)
-#  define __lzo_HAVE_forceinline 1
-#else
-#  define __lzo_forceinline     /*empty*/
-#endif
-#if !defined(__lzo_noinline)
-#if 1 && (LZO_ARCH_I386) && (LZO_CC_GNUC >= 0x040000ul) && (LZO_CC_GNUC < 0x040003ul)
-#  define __lzo_noinline        __attribute__((__noinline__,__used__))
-#elif (LZO_CC_GNUC >= 0x030200ul)
-#  define __lzo_noinline        __attribute__((__noinline__))
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 600) && LZO_CC_SYNTAX_MSC)
-#  define __lzo_noinline        __declspec(noinline)
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 800) && LZO_CC_SYNTAX_GNUC)
-#  define __lzo_noinline        __attribute__((__noinline__))
-#elif (LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#  define __lzo_noinline        __attribute__((__noinline__))
-#elif (LZO_CC_MSC && (_MSC_VER >= 1300))
-#  define __lzo_noinline        __declspec(noinline)
-#elif (LZO_CC_MWERKS && (__MWERKS__ >= 0x3200) && (LZO_OS_WIN32 || LZO_OS_WIN64))
-#  if defined(__cplusplus)
-#  else
-#    define __lzo_noinline      __declspec(noinline)
-#  endif
-#elif (LZO_CC_SUNPROC && (LZO_CC_SUNPROC >= 0x5100))
-#  define __lzo_noinline        __attribute__((__noinline__))
-#endif
-#endif
-#if defined(__lzo_noinline)
-#  define __lzo_HAVE_noinline 1
-#else
-#  define __lzo_noinline        /*empty*/
-#endif
-#if (__lzo_HAVE_forceinline || __lzo_HAVE_noinline) && !(__lzo_HAVE_inline)
-#  error "this should not happen"
-#endif
-#if !defined(__lzo_noreturn)
-#if (LZO_CC_GNUC >= 0x020700ul)
-#  define __lzo_noreturn        __attribute__((__noreturn__))
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 450) && LZO_CC_SYNTAX_MSC)
-#  define __lzo_noreturn        __declspec(noreturn)
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 600) && LZO_CC_SYNTAX_GNUC)
-#  define __lzo_noreturn        __attribute__((__noreturn__))
-#elif (LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#  define __lzo_noreturn        __attribute__((__noreturn__))
-#elif (LZO_CC_MSC && (_MSC_VER >= 1200))
-#  define __lzo_noreturn        __declspec(noreturn)
-#endif
-#endif
-#if defined(__lzo_noreturn)
-#  define __lzo_HAVE_noreturn 1
-#else
-#  define __lzo_noreturn        /*empty*/
-#endif
-#if !defined(__lzo_nothrow)
-#if (LZO_CC_GNUC >= 0x030300ul)
-#  define __lzo_nothrow         __attribute__((__nothrow__))
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 450) && LZO_CC_SYNTAX_MSC) && defined(__cplusplus)
-#  define __lzo_nothrow         __declspec(nothrow)
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 900) && LZO_CC_SYNTAX_GNUC)
-#  define __lzo_nothrow         __attribute__((__nothrow__))
-#elif (LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#  define __lzo_nothrow         __attribute__((__nothrow__))
-#elif (LZO_CC_MSC && (_MSC_VER >= 1200)) && defined(__cplusplus)
-#  define __lzo_nothrow         __declspec(nothrow)
-#endif
-#endif
-#if defined(__lzo_nothrow)
-#  define __lzo_HAVE_nothrow 1
-#else
-#  define __lzo_nothrow         /*empty*/
-#endif
-#if !defined(__lzo_restrict)
-#if (LZO_CC_GNUC >= 0x030400ul)
-#  define __lzo_restrict        __restrict__
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 600) && LZO_CC_SYNTAX_GNUC)
-#  define __lzo_restrict        __restrict__
-#elif (LZO_CC_CLANG || LZO_CC_LLVM)
-#  define __lzo_restrict        __restrict__
-#elif (LZO_CC_MSC && (_MSC_VER >= 1400))
-#  define __lzo_restrict        __restrict
-#endif
-#endif
-#if defined(__lzo_restrict)
-#  define __lzo_HAVE_restrict 1
-#else
-#  define __lzo_restrict        /*empty*/
-#endif
-#if !defined(__lzo_likely) && !defined(__lzo_unlikely)
-#if (LZO_CC_GNUC >= 0x030200ul)
-#  define __lzo_likely(e)       (__builtin_expect(!!(e),1))
-#  define __lzo_unlikely(e)     (__builtin_expect(!!(e),0))
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 800))
-#  define __lzo_likely(e)       (__builtin_expect(!!(e),1))
-#  define __lzo_unlikely(e)     (__builtin_expect(!!(e),0))
-#elif (LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#  define __lzo_likely(e)       (__builtin_expect(!!(e),1))
-#  define __lzo_unlikely(e)     (__builtin_expect(!!(e),0))
-#endif
-#endif
-#if defined(__lzo_likely)
-#  define __lzo_HAVE_likely 1
-#else
-#  define __lzo_likely(e)       (e)
-#endif
-#if defined(__lzo_unlikely)
-#  define __lzo_HAVE_unlikely 1
-#else
-#  define __lzo_unlikely(e)     (e)
-#endif
-#if !defined(LZO_UNUSED)
-#  if (LZO_CC_BORLANDC && (__BORLANDC__ >= 0x0600))
-#    define LZO_UNUSED(var)         ((void) &var)
-#  elif (LZO_CC_BORLANDC || LZO_CC_HIGHC || LZO_CC_NDPC || LZO_CC_PELLESC || LZO_CC_TURBOC)
-#    define LZO_UNUSED(var)         if (&var) ; else
-#  elif (LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#    define LZO_UNUSED(var)         ((void) var)
-#  elif (LZO_CC_MSC && (_MSC_VER < 900))
-#    define LZO_UNUSED(var)         if (&var) ; else
-#  elif (LZO_CC_KEILC)
-#    define LZO_UNUSED(var)         {extern int __lzo_unused[1-2*!(sizeof(var)>0)];}
-#  elif (LZO_CC_PACIFICC)
-#    define LZO_UNUSED(var)         ((void) sizeof(var))
-#  elif (LZO_CC_WATCOMC) && defined(__cplusplus)
-#    define LZO_UNUSED(var)         ((void) var)
-#  else
-#    define LZO_UNUSED(var)         ((void) &var)
-#  endif
-#endif
-#if !defined(LZO_UNUSED_FUNC)
-#  if (LZO_CC_BORLANDC && (__BORLANDC__ >= 0x0600))
-#    define LZO_UNUSED_FUNC(func)   ((void) func)
-#  elif (LZO_CC_BORLANDC || LZO_CC_NDPC || LZO_CC_TURBOC)
-#    define LZO_UNUSED_FUNC(func)   if (func) ; else
-#  elif (LZO_CC_CLANG || LZO_CC_LLVM)
-#    define LZO_UNUSED_FUNC(func)   ((void) &func)
-#  elif (LZO_CC_MSC && (_MSC_VER < 900))
-#    define LZO_UNUSED_FUNC(func)   if (func) ; else
-#  elif (LZO_CC_MSC)
-#    define LZO_UNUSED_FUNC(func)   ((void) &func)
-#  elif (LZO_CC_KEILC || LZO_CC_PELLESC)
-#    define LZO_UNUSED_FUNC(func)   {extern int __lzo_unused[1-2*!(sizeof((int)func)>0)];}
-#  else
-#    define LZO_UNUSED_FUNC(func)   ((void) func)
-#  endif
-#endif
-#if !defined(LZO_UNUSED_LABEL)
-#  if (LZO_CC_WATCOMC) && defined(__cplusplus)
-#    define LZO_UNUSED_LABEL(l)     switch(0) case 1:goto l
-#  elif (LZO_CC_CLANG || LZO_CC_INTELC || LZO_CC_WATCOMC)
-#    define LZO_UNUSED_LABEL(l)     if (0) goto l
-#  else
-#    define LZO_UNUSED_LABEL(l)     switch(0) case 1:goto l
-#  endif
-#endif
-#if !defined(LZO_DEFINE_UNINITIALIZED_VAR)
-#  if 0
-#    define LZO_DEFINE_UNINITIALIZED_VAR(type,var,init)  type var
-#  elif 0 && (LZO_CC_GNUC)
-#    define LZO_DEFINE_UNINITIALIZED_VAR(type,var,init)  type var = var
-#  else
-#    define LZO_DEFINE_UNINITIALIZED_VAR(type,var,init)  type var = init
-#  endif
-#endif
-#if !defined(LZO_UNCONST_CAST)
-#  if 0 && defined(__cplusplus)
-#    define LZO_UNCONST_CAST(t,e)   (const_cast<t> (e))
-#  elif (LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#    define LZO_UNCONST_CAST(t,e)   ((t) ((void *) ((char *) ((lzo_uintptr_t) ((const void *) (e))))))
-#  else
-#    define LZO_UNCONST_CAST(t,e)   ((t) ((void *) ((char *) ((const void *) (e)))))
-#  endif
-#endif
-#if !defined(LZO_COMPILE_TIME_ASSERT_HEADER)
-#  if (LZO_CC_AZTECC || LZO_CC_ZORTECHC)
-#    define LZO_COMPILE_TIME_ASSERT_HEADER(e)  extern int __lzo_cta[1-!(e)];
-#  elif (LZO_CC_DMC || LZO_CC_SYMANTECC)
-#    define LZO_COMPILE_TIME_ASSERT_HEADER(e)  extern int __lzo_cta[1u-2*!(e)];
-#  elif (LZO_CC_TURBOC && (__TURBOC__ == 0x0295))
-#    define LZO_COMPILE_TIME_ASSERT_HEADER(e)  extern int __lzo_cta[1-!(e)];
-#  else
-#    define LZO_COMPILE_TIME_ASSERT_HEADER(e)  extern int __lzo_cta[1-2*!(e)];
-#  endif
-#endif
-#if !defined(LZO_COMPILE_TIME_ASSERT)
-#  if (LZO_CC_AZTECC)
-#    define LZO_COMPILE_TIME_ASSERT(e)  {typedef int __lzo_cta_t[1-!(e)];}
-#  elif (LZO_CC_DMC || LZO_CC_PACIFICC || LZO_CC_SYMANTECC || LZO_CC_ZORTECHC)
-#    define LZO_COMPILE_TIME_ASSERT(e)  switch(0) case 1:case !(e):break;
-#  elif (LZO_CC_MSC && (_MSC_VER < 900))
-#    define LZO_COMPILE_TIME_ASSERT(e)  switch(0) case 1:case !(e):break;
-#  elif (LZO_CC_TURBOC && (__TURBOC__ == 0x0295))
-#    define LZO_COMPILE_TIME_ASSERT(e)  switch(0) case 1:case !(e):break;
-#  else
-#    define LZO_COMPILE_TIME_ASSERT(e)  {typedef int __lzo_cta_t[1-2*!(e)];}
-#  endif
-#endif
-#if (LZO_ARCH_I086 || LZO_ARCH_I386) && (LZO_OS_DOS16 || LZO_OS_DOS32 || LZO_OS_OS2 || LZO_OS_OS216 || LZO_OS_WIN16 || LZO_OS_WIN32 || LZO_OS_WIN64)
-#  if (LZO_CC_GNUC || LZO_CC_HIGHC || LZO_CC_NDPC || LZO_CC_PACIFICC)
-#  elif (LZO_CC_DMC || LZO_CC_SYMANTECC || LZO_CC_ZORTECHC)
-#    define __lzo_cdecl                 __cdecl
-#    define __lzo_cdecl_atexit          /*empty*/
-#    define __lzo_cdecl_main            __cdecl
-#    if (LZO_OS_OS2 && (LZO_CC_DMC || LZO_CC_SYMANTECC))
-#      define __lzo_cdecl_qsort         __pascal
-#    elif (LZO_OS_OS2 && (LZO_CC_ZORTECHC))
-#      define __lzo_cdecl_qsort         _stdcall
-#    else
-#      define __lzo_cdecl_qsort         __cdecl
-#    endif
-#  elif (LZO_CC_WATCOMC)
-#    define __lzo_cdecl                 __cdecl
-#  else
-#    define __lzo_cdecl                 __cdecl
-#    define __lzo_cdecl_atexit          __cdecl
-#    define __lzo_cdecl_main            __cdecl
-#    define __lzo_cdecl_qsort           __cdecl
-#  endif
-#  if (LZO_CC_GNUC || LZO_CC_HIGHC || LZO_CC_NDPC || LZO_CC_PACIFICC || LZO_CC_WATCOMC)
-#  elif (LZO_OS_OS2 && (LZO_CC_DMC || LZO_CC_SYMANTECC))
-#    define __lzo_cdecl_sighandler      __pascal
-#  elif (LZO_OS_OS2 && (LZO_CC_ZORTECHC))
-#    define __lzo_cdecl_sighandler      _stdcall
-#  elif (LZO_CC_MSC && (_MSC_VER >= 1400)) && defined(_M_CEE_PURE)
-#    define __lzo_cdecl_sighandler      __clrcall
-#  elif (LZO_CC_MSC && (_MSC_VER >= 600 && _MSC_VER < 700))
-#    if defined(_DLL)
-#      define __lzo_cdecl_sighandler    _far _cdecl _loadds
-#    elif defined(_MT)
-#      define __lzo_cdecl_sighandler    _far _cdecl
-#    else
-#      define __lzo_cdecl_sighandler    _cdecl
-#    endif
-#  else
-#    define __lzo_cdecl_sighandler      __cdecl
-#  endif
-#elif (LZO_ARCH_I386) && (LZO_CC_WATCOMC)
-#  define __lzo_cdecl                   __cdecl
-#elif (LZO_ARCH_M68K && LZO_OS_TOS && (LZO_CC_PUREC || LZO_CC_TURBOC))
-#  define __lzo_cdecl                   cdecl
-#endif
-#if !defined(__lzo_cdecl)
-#  define __lzo_cdecl                   /*empty*/
-#endif
-#if !defined(__lzo_cdecl_atexit)
-#  define __lzo_cdecl_atexit            /*empty*/
-#endif
-#if !defined(__lzo_cdecl_main)
-#  define __lzo_cdecl_main              /*empty*/
-#endif
-#if !defined(__lzo_cdecl_qsort)
-#  define __lzo_cdecl_qsort             /*empty*/
-#endif
-#if !defined(__lzo_cdecl_sighandler)
-#  define __lzo_cdecl_sighandler        /*empty*/
-#endif
-#if !defined(__lzo_cdecl_va)
-#  define __lzo_cdecl_va                __lzo_cdecl
-#endif
-#if !(LZO_CFG_NO_WINDOWS_H)
-#if (LZO_OS_CYGWIN || (LZO_OS_EMX && defined(__RSXNT__)) || LZO_OS_WIN32 || LZO_OS_WIN64)
-#  if (LZO_CC_WATCOMC && (__WATCOMC__ < 1000))
-#  elif (LZO_OS_WIN32 && LZO_CC_GNUC) && defined(__PW32__)
-#  elif ((LZO_OS_CYGWIN || defined(__MINGW32__)) && (LZO_CC_GNUC && (LZO_CC_GNUC < 0x025f00ul)))
-#  else
-#    define LZO_HAVE_WINDOWS_H 1
-#  endif
-#endif
-#endif
-#if (LZO_ARCH_ALPHA)
-#  define LZO_OPT_AVOID_UINT_INDEX  1
-#  define LZO_OPT_AVOID_SHORT       1
-#  define LZO_OPT_AVOID_USHORT      1
-#elif (LZO_ARCH_AMD64)
-#  define LZO_OPT_AVOID_INT_INDEX   1
-#  define LZO_OPT_AVOID_UINT_INDEX  1
-#  define LZO_OPT_UNALIGNED16       1
-#  define LZO_OPT_UNALIGNED32       1
-#  define LZO_OPT_UNALIGNED64       1
-#elif (LZO_ARCH_ARM && LZO_ARCH_ARM_THUMB)
-#elif (LZO_ARCH_ARM)
-#  define LZO_OPT_AVOID_SHORT       1
-#  define LZO_OPT_AVOID_USHORT      1
-#elif (LZO_ARCH_CRIS)
-#  define LZO_OPT_UNALIGNED16       1
-#  define LZO_OPT_UNALIGNED32       1
-#elif (LZO_ARCH_I386)
-#  define LZO_OPT_UNALIGNED16       1
-#  define LZO_OPT_UNALIGNED32       1
-#elif (LZO_ARCH_IA64)
-#  define LZO_OPT_AVOID_INT_INDEX   1
-#  define LZO_OPT_AVOID_UINT_INDEX  1
-#  define LZO_OPT_PREFER_POSTINC    1
-#elif (LZO_ARCH_M68K)
-#  define LZO_OPT_PREFER_POSTINC    1
-#  define LZO_OPT_PREFER_PREDEC     1
-#  if defined(__mc68020__) && !defined(__mcoldfire__)
-#    define LZO_OPT_UNALIGNED16     1
-#    define LZO_OPT_UNALIGNED32     1
-#  endif
-#elif (LZO_ARCH_MIPS)
-#  define LZO_OPT_AVOID_UINT_INDEX  1
-#elif (LZO_ARCH_POWERPC)
-#  define LZO_OPT_PREFER_PREINC     1
-#  define LZO_OPT_PREFER_PREDEC     1
-#  if (LZO_ABI_BIG_ENDIAN)
-#    define LZO_OPT_UNALIGNED16     1
-#    define LZO_OPT_UNALIGNED32     1
-#  endif
-#elif (LZO_ARCH_S390)
-#  define LZO_OPT_UNALIGNED16       1
-#  define LZO_OPT_UNALIGNED32       1
-#  if (LZO_SIZEOF_SIZE_T == 8)
-#    define LZO_OPT_UNALIGNED64     1
-#  endif
-#elif (LZO_ARCH_SH)
-#  define LZO_OPT_PREFER_POSTINC    1
-#  define LZO_OPT_PREFER_PREDEC     1
-#endif
-#ifndef LZO_CFG_NO_INLINE_ASM
-#if (LZO_CC_LLVM)
-#  define LZO_CFG_NO_INLINE_ASM 1
-#endif
-#endif
-#ifndef LZO_CFG_NO_UNALIGNED
-#if (LZO_ABI_NEUTRAL_ENDIAN) || (LZO_ARCH_GENERIC)
-#  define LZO_CFG_NO_UNALIGNED 1
-#endif
-#endif
-#if (LZO_CFG_NO_UNALIGNED)
-#  undef LZO_OPT_UNALIGNED16
-#  undef LZO_OPT_UNALIGNED32
-#  undef LZO_OPT_UNALIGNED64
-#endif
-#if (LZO_CFG_NO_INLINE_ASM)
-#elif (LZO_ARCH_I386 && (LZO_OS_DOS32 || LZO_OS_WIN32) && (LZO_CC_DMC || LZO_CC_INTELC || LZO_CC_MSC || LZO_CC_PELLESC))
-#  define LZO_ASM_SYNTAX_MSC 1
-#elif (LZO_OS_WIN64 && (LZO_CC_DMC || LZO_CC_INTELC || LZO_CC_MSC || LZO_CC_PELLESC))
-#elif (LZO_ARCH_I386 && LZO_CC_GNUC && (LZO_CC_GNUC == 0x011f00ul))
-#elif (LZO_ARCH_I386 && (LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_INTELC || LZO_CC_PATHSCALE))
-#  define LZO_ASM_SYNTAX_GNUC 1
-#elif (LZO_ARCH_AMD64 && (LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_INTELC || LZO_CC_PATHSCALE))
-#  define LZO_ASM_SYNTAX_GNUC 1
-#endif
-#if (LZO_ASM_SYNTAX_GNUC)
-#if (LZO_ARCH_I386 && LZO_CC_GNUC && (LZO_CC_GNUC < 0x020000ul))
-#  define __LZO_ASM_CLOBBER         "ax"
-#elif (LZO_CC_INTELC)
-#  define __LZO_ASM_CLOBBER         "memory"
-#else
-#  define __LZO_ASM_CLOBBER         "cc", "memory"
-#endif
-#endif
-#if defined(__LZO_INFOSTR_MM)
-#elif (LZO_MM_FLAT) && (defined(__LZO_INFOSTR_PM) || defined(LZO_INFO_ABI_PM))
-#  define __LZO_INFOSTR_MM          ""
-#elif defined(LZO_INFO_MM)
-#  define __LZO_INFOSTR_MM          "." LZO_INFO_MM
-#else
-#  define __LZO_INFOSTR_MM          ""
-#endif
-#if defined(__LZO_INFOSTR_PM)
-#elif defined(LZO_INFO_ABI_PM)
-#  define __LZO_INFOSTR_PM          "." LZO_INFO_ABI_PM
-#else
-#  define __LZO_INFOSTR_PM          ""
-#endif
-#if defined(__LZO_INFOSTR_ENDIAN)
-#elif defined(LZO_INFO_ABI_ENDIAN)
-#  define __LZO_INFOSTR_ENDIAN      "." LZO_INFO_ABI_ENDIAN
-#else
-#  define __LZO_INFOSTR_ENDIAN      ""
-#endif
-#if defined(__LZO_INFOSTR_OSNAME)
-#elif defined(LZO_INFO_OS_CONSOLE)
-#  define __LZO_INFOSTR_OSNAME      LZO_INFO_OS "." LZO_INFO_OS_CONSOLE
-#elif defined(LZO_INFO_OS_POSIX)
-#  define __LZO_INFOSTR_OSNAME      LZO_INFO_OS "." LZO_INFO_OS_POSIX
-#else
-#  define __LZO_INFOSTR_OSNAME      LZO_INFO_OS
-#endif
-#if defined(__LZO_INFOSTR_LIBC)
-#elif defined(LZO_INFO_LIBC)
-#  define __LZO_INFOSTR_LIBC        "." LZO_INFO_LIBC
-#else
-#  define __LZO_INFOSTR_LIBC        ""
-#endif
-#if defined(__LZO_INFOSTR_CCVER)
-#elif defined(LZO_INFO_CCVER)
-#  define __LZO_INFOSTR_CCVER       " " LZO_INFO_CCVER
-#else
-#  define __LZO_INFOSTR_CCVER       ""
-#endif
-#define LZO_INFO_STRING \
-    LZO_INFO_ARCH __LZO_INFOSTR_MM __LZO_INFOSTR_PM __LZO_INFOSTR_ENDIAN \
-    " " __LZO_INFOSTR_OSNAME __LZO_INFOSTR_LIBC " " LZO_INFO_CC __LZO_INFOSTR_CCVER
-
-#endif /* already included */
-
-/* vim:set ts=4 et: */
diff -urN remmina-plugins/vnc/libvncserver/common/minilzo.c remmina-plugins/vnc/libvncserver/common/minilzo.c
--- remmina-plugins/vnc/libvncserver/common/minilzo.c	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins/vnc/libvncserver/common/minilzo.c	1970-01-01 10:00:00.000000000 +1000
@@ -1,4192 +0,0 @@
-/* minilzo.c -- mini subset of the LZO real-time data compression library
-
-   This file is part of the LZO real-time data compression library.
-
-   Copyright (C) 2010 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2009 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
-   All Rights Reserved.
-
-   The LZO library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU General Public License as
-   published by the Free Software Foundation; either version 2 of
-   the License, or (at your option) any later version.
-
-   The LZO library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with the LZO library; see the file COPYING.
-   If not, write to the Free Software Foundation, Inc.,
-   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-
-   Markus F.X.J. Oberhumer
-   <markus@oberhumer.com>
-   http://www.oberhumer.com/opensource/lzo/
- */
-
-/*
- * NOTE:
- *   the full LZO package can be found at
- *   http://www.oberhumer.com/opensource/lzo/
- */
-
-#define __LZO_IN_MINILZO 1
-
-#if defined(LZO_CFG_FREESTANDING)
-#  undef MINILZO_HAVE_CONFIG_H
-#  define LZO_LIBC_FREESTANDING 1
-#  define LZO_OS_FREESTANDING 1
-#endif
-
-#ifdef MINILZO_HAVE_CONFIG_H
-#  include <config.h>
-#endif
-#include <limits.h>
-#include <stddef.h>
-#if defined(MINILZO_CFG_USE_INTERNAL_LZODEFS)
-
-#ifndef __LZODEFS_H_INCLUDED
-#define __LZODEFS_H_INCLUDED 1
-
-#if defined(__CYGWIN32__) && !defined(__CYGWIN__)
-#  define __CYGWIN__ __CYGWIN32__
-#endif
-#if defined(__IBMCPP__) && !defined(__IBMC__)
-#  define __IBMC__ __IBMCPP__
-#endif
-#if defined(__ICL) && defined(_WIN32) && !defined(__INTEL_COMPILER)
-#  define __INTEL_COMPILER __ICL
-#endif
-#if 1 && defined(__INTERIX) && defined(__GNUC__) && !defined(_ALL_SOURCE)
-#  define _ALL_SOURCE 1
-#endif
-#if defined(__mips__) && defined(__R5900__)
-#  if !defined(__LONG_MAX__)
-#    define __LONG_MAX__ 9223372036854775807L
-#  endif
-#endif
-#if defined(__INTEL_COMPILER) && defined(__linux__)
-#  pragma warning(disable: 193)
-#endif
-#if defined(__KEIL__) && defined(__C166__)
-#  pragma warning disable = 322
-#elif 0 && defined(__C251__)
-#  pragma warning disable = 322
-#endif
-#if defined(_MSC_VER) && !defined(__INTEL_COMPILER) && !defined(__MWERKS__)
-#  if (_MSC_VER >= 1300)
-#    pragma warning(disable: 4668)
-#  endif
-#endif
-#if 0 && defined(__WATCOMC__)
-#  if (__WATCOMC__ >= 1050) && (__WATCOMC__ < 1060)
-#    pragma warning 203 9
-#  endif
-#endif
-#if defined(__BORLANDC__) && defined(__MSDOS__) && !defined(__FLAT__)
-#  pragma option -h
-#endif
-#if 0
-#define LZO_0xffffL             0xfffful
-#define LZO_0xffffffffL         0xfffffffful
-#else
-#define LZO_0xffffL             65535ul
-#define LZO_0xffffffffL         4294967295ul
-#endif
-#if (LZO_0xffffL == LZO_0xffffffffL)
-#  error "your preprocessor is broken 1"
-#endif
-#if (16ul * 16384ul != 262144ul)
-#  error "your preprocessor is broken 2"
-#endif
-#if 0
-#if (32767 >= 4294967295ul)
-#  error "your preprocessor is broken 3"
-#endif
-#if (65535u >= 4294967295ul)
-#  error "your preprocessor is broken 4"
-#endif
-#endif
-#if (UINT_MAX == LZO_0xffffL)
-#if defined(__ZTC__) && defined(__I86__) && !defined(__OS2__)
-#  if !defined(MSDOS)
-#    define MSDOS 1
-#  endif
-#  if !defined(_MSDOS)
-#    define _MSDOS 1
-#  endif
-#elif 0 && defined(__VERSION) && defined(MB_LEN_MAX)
-#  if (__VERSION == 520) && (MB_LEN_MAX == 1)
-#    if !defined(__AZTEC_C__)
-#      define __AZTEC_C__ __VERSION
-#    endif
-#    if !defined(__DOS__)
-#      define __DOS__ 1
-#    endif
-#  endif
-#endif
-#endif
-#if defined(_MSC_VER) && defined(M_I86HM) && (UINT_MAX == LZO_0xffffL)
-#  define ptrdiff_t long
-#  define _PTRDIFF_T_DEFINED 1
-#endif
-#if (UINT_MAX == LZO_0xffffL)
-#  undef __LZO_RENAME_A
-#  undef __LZO_RENAME_B
-#  if defined(__AZTEC_C__) && defined(__DOS__)
-#    define __LZO_RENAME_A 1
-#  elif defined(_MSC_VER) && defined(MSDOS)
-#    if (_MSC_VER < 600)
-#      define __LZO_RENAME_A 1
-#    elif (_MSC_VER < 700)
-#      define __LZO_RENAME_B 1
-#    endif
-#  elif defined(__TSC__) && defined(__OS2__)
-#    define __LZO_RENAME_A 1
-#  elif defined(__MSDOS__) && defined(__TURBOC__) && (__TURBOC__ < 0x0410)
-#    define __LZO_RENAME_A 1
-#  elif defined(__PACIFIC__) && defined(DOS)
-#    if !defined(__far)
-#      define __far far
-#    endif
-#    if !defined(__near)
-#      define __near near
-#    endif
-#  endif
-#  if defined(__LZO_RENAME_A)
-#    if !defined(__cdecl)
-#      define __cdecl cdecl
-#    endif
-#    if !defined(__far)
-#      define __far far
-#    endif
-#    if !defined(__huge)
-#      define __huge huge
-#    endif
-#    if !defined(__near)
-#      define __near near
-#    endif
-#    if !defined(__pascal)
-#      define __pascal pascal
-#    endif
-#    if !defined(__huge)
-#      define __huge huge
-#    endif
-#  elif defined(__LZO_RENAME_B)
-#    if !defined(__cdecl)
-#      define __cdecl _cdecl
-#    endif
-#    if !defined(__far)
-#      define __far _far
-#    endif
-#    if !defined(__huge)
-#      define __huge _huge
-#    endif
-#    if !defined(__near)
-#      define __near _near
-#    endif
-#    if !defined(__pascal)
-#      define __pascal _pascal
-#    endif
-#  elif (defined(__PUREC__) || defined(__TURBOC__)) && defined(__TOS__)
-#    if !defined(__cdecl)
-#      define __cdecl cdecl
-#    endif
-#    if !defined(__pascal)
-#      define __pascal pascal
-#    endif
-#  endif
-#  undef __LZO_RENAME_A
-#  undef __LZO_RENAME_B
-#endif
-#if (UINT_MAX == LZO_0xffffL)
-#if defined(__AZTEC_C__) && defined(__DOS__)
-#  define LZO_BROKEN_CDECL_ALT_SYNTAX 1
-#elif defined(_MSC_VER) && defined(MSDOS)
-#  if (_MSC_VER < 600)
-#    define LZO_BROKEN_INTEGRAL_CONSTANTS 1
-#  endif
-#  if (_MSC_VER < 700)
-#    define LZO_BROKEN_INTEGRAL_PROMOTION 1
-#    define LZO_BROKEN_SIZEOF 1
-#  endif
-#elif defined(__PACIFIC__) && defined(DOS)
-#  define LZO_BROKEN_INTEGRAL_CONSTANTS 1
-#elif defined(__TURBOC__) && defined(__MSDOS__)
-#  if (__TURBOC__ < 0x0150)
-#    define LZO_BROKEN_CDECL_ALT_SYNTAX 1
-#    define LZO_BROKEN_INTEGRAL_CONSTANTS 1
-#    define LZO_BROKEN_INTEGRAL_PROMOTION 1
-#  endif
-#  if (__TURBOC__ < 0x0200)
-#    define LZO_BROKEN_SIZEOF 1
-#  endif
-#  if (__TURBOC__ < 0x0400) && defined(__cplusplus)
-#    define LZO_BROKEN_CDECL_ALT_SYNTAX 1
-#  endif
-#elif (defined(__PUREC__) || defined(__TURBOC__)) && defined(__TOS__)
-#  define LZO_BROKEN_CDECL_ALT_SYNTAX 1
-#  define LZO_BROKEN_SIZEOF 1
-#endif
-#endif
-#if defined(__WATCOMC__) && (__WATCOMC__ < 900)
-#  define LZO_BROKEN_INTEGRAL_CONSTANTS 1
-#endif
-#if defined(_CRAY) && defined(_CRAY1)
-#  define LZO_BROKEN_SIGNED_RIGHT_SHIFT 1
-#endif
-#define LZO_PP_STRINGIZE(x)             #x
-#define LZO_PP_MACRO_EXPAND(x)          LZO_PP_STRINGIZE(x)
-#define LZO_PP_CONCAT2(a,b)             a ## b
-#define LZO_PP_CONCAT3(a,b,c)           a ## b ## c
-#define LZO_PP_CONCAT4(a,b,c,d)         a ## b ## c ## d
-#define LZO_PP_CONCAT5(a,b,c,d,e)       a ## b ## c ## d ## e
-#define LZO_PP_ECONCAT2(a,b)            LZO_PP_CONCAT2(a,b)
-#define LZO_PP_ECONCAT3(a,b,c)          LZO_PP_CONCAT3(a,b,c)
-#define LZO_PP_ECONCAT4(a,b,c,d)        LZO_PP_CONCAT4(a,b,c,d)
-#define LZO_PP_ECONCAT5(a,b,c,d,e)      LZO_PP_CONCAT5(a,b,c,d,e)
-#if 1
-#define LZO_CPP_STRINGIZE(x)            #x
-#define LZO_CPP_MACRO_EXPAND(x)         LZO_CPP_STRINGIZE(x)
-#define LZO_CPP_CONCAT2(a,b)            a ## b
-#define LZO_CPP_CONCAT3(a,b,c)          a ## b ## c
-#define LZO_CPP_CONCAT4(a,b,c,d)        a ## b ## c ## d
-#define LZO_CPP_CONCAT5(a,b,c,d,e)      a ## b ## c ## d ## e
-#define LZO_CPP_ECONCAT2(a,b)           LZO_CPP_CONCAT2(a,b)
-#define LZO_CPP_ECONCAT3(a,b,c)         LZO_CPP_CONCAT3(a,b,c)
-#define LZO_CPP_ECONCAT4(a,b,c,d)       LZO_CPP_CONCAT4(a,b,c,d)
-#define LZO_CPP_ECONCAT5(a,b,c,d,e)     LZO_CPP_CONCAT5(a,b,c,d,e)
-#endif
-#define __LZO_MASK_GEN(o,b)     (((((o) << ((b)-1)) - (o)) << 1) + (o))
-#if 1 && defined(__cplusplus)
-#  if !defined(__STDC_CONSTANT_MACROS)
-#    define __STDC_CONSTANT_MACROS 1
-#  endif
-#  if !defined(__STDC_LIMIT_MACROS)
-#    define __STDC_LIMIT_MACROS 1
-#  endif
-#endif
-#if defined(__cplusplus)
-#  define LZO_EXTERN_C extern "C"
-#else
-#  define LZO_EXTERN_C extern
-#endif
-#if !defined(__LZO_OS_OVERRIDE)
-#if (LZO_OS_FREESTANDING)
-#  define LZO_INFO_OS           "freestanding"
-#elif (LZO_OS_EMBEDDED)
-#  define LZO_INFO_OS           "embedded"
-#elif 1 && defined(__IAR_SYSTEMS_ICC__)
-#  define LZO_OS_EMBEDDED       1
-#  define LZO_INFO_OS           "embedded"
-#elif defined(__CYGWIN__) && defined(__GNUC__)
-#  define LZO_OS_CYGWIN         1
-#  define LZO_INFO_OS           "cygwin"
-#elif defined(__EMX__) && defined(__GNUC__)
-#  define LZO_OS_EMX            1
-#  define LZO_INFO_OS           "emx"
-#elif defined(__BEOS__)
-#  define LZO_OS_BEOS           1
-#  define LZO_INFO_OS           "beos"
-#elif defined(__Lynx__)
-#  define LZO_OS_LYNXOS         1
-#  define LZO_INFO_OS           "lynxos"
-#elif defined(__OS400__)
-#  define LZO_OS_OS400          1
-#  define LZO_INFO_OS           "os400"
-#elif defined(__QNX__)
-#  define LZO_OS_QNX            1
-#  define LZO_INFO_OS           "qnx"
-#elif defined(__BORLANDC__) && defined(__DPMI32__) && (__BORLANDC__ >= 0x0460)
-#  define LZO_OS_DOS32          1
-#  define LZO_INFO_OS           "dos32"
-#elif defined(__BORLANDC__) && defined(__DPMI16__)
-#  define LZO_OS_DOS16          1
-#  define LZO_INFO_OS           "dos16"
-#elif defined(__ZTC__) && defined(DOS386)
-#  define LZO_OS_DOS32          1
-#  define LZO_INFO_OS           "dos32"
-#elif defined(__OS2__) || defined(__OS2V2__)
-#  if (UINT_MAX == LZO_0xffffL)
-#    define LZO_OS_OS216        1
-#    define LZO_INFO_OS         "os216"
-#  elif (UINT_MAX == LZO_0xffffffffL)
-#    define LZO_OS_OS2          1
-#    define LZO_INFO_OS         "os2"
-#  else
-#    error "check your limits.h header"
-#  endif
-#elif defined(__WIN64__) || defined(_WIN64) || defined(WIN64)
-#  define LZO_OS_WIN64          1
-#  define LZO_INFO_OS           "win64"
-#elif defined(__WIN32__) || defined(_WIN32) || defined(WIN32) || defined(__WINDOWS_386__)
-#  define LZO_OS_WIN32          1
-#  define LZO_INFO_OS           "win32"
-#elif defined(__MWERKS__) && defined(__INTEL__)
-#  define LZO_OS_WIN32          1
-#  define LZO_INFO_OS           "win32"
-#elif defined(__WINDOWS__) || defined(_WINDOWS) || defined(_Windows)
-#  if (UINT_MAX == LZO_0xffffL)
-#    define LZO_OS_WIN16        1
-#    define LZO_INFO_OS         "win16"
-#  elif (UINT_MAX == LZO_0xffffffffL)
-#    define LZO_OS_WIN32        1
-#    define LZO_INFO_OS         "win32"
-#  else
-#    error "check your limits.h header"
-#  endif
-#elif defined(__DOS__) || defined(__MSDOS__) || defined(_MSDOS) || defined(MSDOS) || (defined(__PACIFIC__) && defined(DOS))
-#  if (UINT_MAX == LZO_0xffffL)
-#    define LZO_OS_DOS16        1
-#    define LZO_INFO_OS         "dos16"
-#  elif (UINT_MAX == LZO_0xffffffffL)
-#    define LZO_OS_DOS32        1
-#    define LZO_INFO_OS         "dos32"
-#  else
-#    error "check your limits.h header"
-#  endif
-#elif defined(__WATCOMC__)
-#  if defined(__NT__) && (UINT_MAX == LZO_0xffffL)
-#    define LZO_OS_DOS16        1
-#    define LZO_INFO_OS         "dos16"
-#  elif defined(__NT__) && (__WATCOMC__ < 1100)
-#    define LZO_OS_WIN32        1
-#    define LZO_INFO_OS         "win32"
-#  elif defined(__linux__) || defined(__LINUX__)
-#    define LZO_OS_POSIX        1
-#    define LZO_INFO_OS         "posix"
-#  else
-#    error "please specify a target using the -bt compiler option"
-#  endif
-#elif defined(__palmos__)
-#  define LZO_OS_PALMOS         1
-#  define LZO_INFO_OS           "palmos"
-#elif defined(__TOS__) || defined(__atarist__)
-#  define LZO_OS_TOS            1
-#  define LZO_INFO_OS           "tos"
-#elif defined(macintosh) && !defined(__ppc__)
-#  define LZO_OS_MACCLASSIC     1
-#  define LZO_INFO_OS           "macclassic"
-#elif defined(__VMS)
-#  define LZO_OS_VMS            1
-#  define LZO_INFO_OS           "vms"
-#elif ((defined(__mips__) && defined(__R5900__)) || defined(__MIPS_PSX2__))
-#  define LZO_OS_CONSOLE        1
-#  define LZO_OS_CONSOLE_PS2    1
-#  define LZO_INFO_OS           "console"
-#  define LZO_INFO_OS_CONSOLE   "ps2"
-#elif (defined(__mips__) && defined(__psp__))
-#  define LZO_OS_CONSOLE        1
-#  define LZO_OS_CONSOLE_PSP    1
-#  define LZO_INFO_OS           "console"
-#  define LZO_INFO_OS_CONSOLE   "psp"
-#else
-#  define LZO_OS_POSIX          1
-#  define LZO_INFO_OS           "posix"
-#endif
-#if (LZO_OS_POSIX)
-#  if defined(_AIX) || defined(__AIX__) || defined(__aix__)
-#    define LZO_OS_POSIX_AIX        1
-#    define LZO_INFO_OS_POSIX       "aix"
-#  elif defined(__FreeBSD__)
-#    define LZO_OS_POSIX_FREEBSD    1
-#    define LZO_INFO_OS_POSIX       "freebsd"
-#  elif defined(__hpux__) || defined(__hpux)
-#    define LZO_OS_POSIX_HPUX       1
-#    define LZO_INFO_OS_POSIX       "hpux"
-#  elif defined(__INTERIX)
-#    define LZO_OS_POSIX_INTERIX    1
-#    define LZO_INFO_OS_POSIX       "interix"
-#  elif defined(__IRIX__) || defined(__irix__)
-#    define LZO_OS_POSIX_IRIX       1
-#    define LZO_INFO_OS_POSIX       "irix"
-#  elif defined(__linux__) || defined(__linux) || defined(__LINUX__)
-#    define LZO_OS_POSIX_LINUX      1
-#    define LZO_INFO_OS_POSIX       "linux"
-#  elif defined(__APPLE__) || defined(__MACOS__)
-#    define LZO_OS_POSIX_MACOSX     1
-#    define LZO_INFO_OS_POSIX       "macosx"
-#  elif defined(__minix__) || defined(__minix)
-#    define LZO_OS_POSIX_MINIX      1
-#    define LZO_INFO_OS_POSIX       "minix"
-#  elif defined(__NetBSD__)
-#    define LZO_OS_POSIX_NETBSD     1
-#    define LZO_INFO_OS_POSIX       "netbsd"
-#  elif defined(__OpenBSD__)
-#    define LZO_OS_POSIX_OPENBSD    1
-#    define LZO_INFO_OS_POSIX       "openbsd"
-#  elif defined(__osf__)
-#    define LZO_OS_POSIX_OSF        1
-#    define LZO_INFO_OS_POSIX       "osf"
-#  elif defined(__solaris__) || defined(__sun)
-#    if defined(__SVR4) || defined(__svr4__)
-#      define LZO_OS_POSIX_SOLARIS  1
-#      define LZO_INFO_OS_POSIX     "solaris"
-#    else
-#      define LZO_OS_POSIX_SUNOS    1
-#      define LZO_INFO_OS_POSIX     "sunos"
-#    endif
-#  elif defined(__ultrix__) || defined(__ultrix)
-#    define LZO_OS_POSIX_ULTRIX     1
-#    define LZO_INFO_OS_POSIX       "ultrix"
-#  elif defined(_UNICOS)
-#    define LZO_OS_POSIX_UNICOS     1
-#    define LZO_INFO_OS_POSIX       "unicos"
-#  else
-#    define LZO_OS_POSIX_UNKNOWN    1
-#    define LZO_INFO_OS_POSIX       "unknown"
-#  endif
-#endif
-#endif
-#if (LZO_OS_DOS16 || LZO_OS_OS216 || LZO_OS_WIN16)
-#  if (UINT_MAX != LZO_0xffffL)
-#    error "this should not happen"
-#  endif
-#  if (ULONG_MAX != LZO_0xffffffffL)
-#    error "this should not happen"
-#  endif
-#endif
-#if (LZO_OS_DOS32 || LZO_OS_OS2 || LZO_OS_WIN32 || LZO_OS_WIN64)
-#  if (UINT_MAX != LZO_0xffffffffL)
-#    error "this should not happen"
-#  endif
-#  if (ULONG_MAX != LZO_0xffffffffL)
-#    error "this should not happen"
-#  endif
-#endif
-#if defined(CIL) && defined(_GNUCC) && defined(__GNUC__)
-#  define LZO_CC_CILLY          1
-#  define LZO_INFO_CC           "Cilly"
-#  if defined(__CILLY__)
-#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(__CILLY__)
-#  else
-#    define LZO_INFO_CCVER      "unknown"
-#  endif
-#elif 0 && defined(SDCC) && defined(__VERSION__) && !defined(__GNUC__)
-#  define LZO_CC_SDCC           1
-#  define LZO_INFO_CC           "sdcc"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(SDCC)
-#elif defined(__PATHSCALE__) && defined(__PATHCC_PATCHLEVEL__)
-#  define LZO_CC_PATHSCALE      (__PATHCC__ * 0x10000L + __PATHCC_MINOR__ * 0x100 + __PATHCC_PATCHLEVEL__)
-#  define LZO_INFO_CC           "Pathscale C"
-#  define LZO_INFO_CCVER        __PATHSCALE__
-#elif defined(__INTEL_COMPILER)
-#  define LZO_CC_INTELC         1
-#  define LZO_INFO_CC           "Intel C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__INTEL_COMPILER)
-#  if defined(_WIN32) || defined(_WIN64)
-#    define LZO_CC_SYNTAX_MSC 1
-#  else
-#    define LZO_CC_SYNTAX_GNUC 1
-#  endif
-#elif defined(__POCC__) && defined(_WIN32)
-#  define LZO_CC_PELLESC        1
-#  define LZO_INFO_CC           "Pelles C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__POCC__)
-#elif defined(__clang__) && defined(__llvm__) && defined(__GNUC__) && defined(__GNUC_MINOR__) && defined(__VERSION__)
-#  if defined(__GNUC_PATCHLEVEL__)
-#    define LZO_CC_CLANG_GNUC   (__GNUC__ * 0x10000L + __GNUC_MINOR__ * 0x100 + __GNUC_PATCHLEVEL__)
-#  else
-#    define LZO_CC_CLANG_GNUC   (__GNUC__ * 0x10000L + __GNUC_MINOR__ * 0x100)
-#  endif
-#  if defined(__clang_major__) && defined(__clang_minor__) && defined(__clang_patchlevel__)
-#    define LZO_CC_CLANG_CLANG  (__clang_major__ * 0x10000L + __clang_minor__ * 0x100 + __clang_patchlevel__)
-#  else
-#    define LZO_CC_CLANG_CLANG  0x020700L
-#  endif
-#  define LZO_CC_CLANG          LZO_CC_CLANG_GNUC
-#  define LZO_INFO_CC           "clang"
-#  define LZO_INFO_CCVER        __VERSION__
-#elif defined(__llvm__) && defined(__GNUC__) && defined(__GNUC_MINOR__) && defined(__VERSION__)
-#  if defined(__GNUC_PATCHLEVEL__)
-#    define LZO_CC_LLVM_GNUC    (__GNUC__ * 0x10000L + __GNUC_MINOR__ * 0x100 + __GNUC_PATCHLEVEL__)
-#  else
-#    define LZO_CC_LLVM_GNUC    (__GNUC__ * 0x10000L + __GNUC_MINOR__ * 0x100)
-#  endif
-#  define LZO_CC_LLVM           LZO_CC_LLVM_GNUC
-#  define LZO_INFO_CC           "llvm-gcc"
-#  define LZO_INFO_CCVER        __VERSION__
-#elif defined(__GNUC__) && defined(__VERSION__)
-#  if defined(__GNUC_MINOR__) && defined(__GNUC_PATCHLEVEL__)
-#    define LZO_CC_GNUC         (__GNUC__ * 0x10000L + __GNUC_MINOR__ * 0x100 + __GNUC_PATCHLEVEL__)
-#  elif defined(__GNUC_MINOR__)
-#    define LZO_CC_GNUC         (__GNUC__ * 0x10000L + __GNUC_MINOR__ * 0x100)
-#  else
-#    define LZO_CC_GNUC         (__GNUC__ * 0x10000L)
-#  endif
-#  define LZO_INFO_CC           "gcc"
-#  define LZO_INFO_CCVER        __VERSION__
-#elif defined(__ACK__) && defined(_ACK)
-#  define LZO_CC_ACK            1
-#  define LZO_INFO_CC           "Amsterdam Compiler Kit C"
-#  define LZO_INFO_CCVER        "unknown"
-#elif defined(__AZTEC_C__)
-#  define LZO_CC_AZTECC         1
-#  define LZO_INFO_CC           "Aztec C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__AZTEC_C__)
-#elif defined(__CODEGEARC__)
-#  define LZO_CC_CODEGEARC      1
-#  define LZO_INFO_CC           "CodeGear C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__CODEGEARC__)
-#elif defined(__BORLANDC__)
-#  define LZO_CC_BORLANDC       1
-#  define LZO_INFO_CC           "Borland C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__BORLANDC__)
-#elif defined(_CRAYC) && defined(_RELEASE)
-#  define LZO_CC_CRAYC          1
-#  define LZO_INFO_CC           "Cray C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(_RELEASE)
-#elif defined(__DMC__) && defined(__SC__)
-#  define LZO_CC_DMC            1
-#  define LZO_INFO_CC           "Digital Mars C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__DMC__)
-#elif defined(__DECC)
-#  define LZO_CC_DECC           1
-#  define LZO_INFO_CC           "DEC C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__DECC)
-#elif defined(__HIGHC__)
-#  define LZO_CC_HIGHC          1
-#  define LZO_INFO_CC           "MetaWare High C"
-#  define LZO_INFO_CCVER        "unknown"
-#elif defined(__IAR_SYSTEMS_ICC__)
-#  define LZO_CC_IARC           1
-#  define LZO_INFO_CC           "IAR C"
-#  if defined(__VER__)
-#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(__VER__)
-#  else
-#    define LZO_INFO_CCVER      "unknown"
-#  endif
-#elif defined(__IBMC__)
-#  define LZO_CC_IBMC           1
-#  define LZO_INFO_CC           "IBM C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__IBMC__)
-#elif defined(__KEIL__) && defined(__C166__)
-#  define LZO_CC_KEILC          1
-#  define LZO_INFO_CC           "Keil C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__C166__)
-#elif defined(__LCC__) && defined(_WIN32) && defined(__LCCOPTIMLEVEL)
-#  define LZO_CC_LCCWIN32       1
-#  define LZO_INFO_CC           "lcc-win32"
-#  define LZO_INFO_CCVER        "unknown"
-#elif defined(__LCC__)
-#  define LZO_CC_LCC            1
-#  define LZO_INFO_CC           "lcc"
-#  if defined(__LCC_VERSION__)
-#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(__LCC_VERSION__)
-#  else
-#    define LZO_INFO_CCVER      "unknown"
-#  endif
-#elif defined(_MSC_VER)
-#  define LZO_CC_MSC            1
-#  define LZO_INFO_CC           "Microsoft C"
-#  if defined(_MSC_FULL_VER)
-#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(_MSC_VER) "." LZO_PP_MACRO_EXPAND(_MSC_FULL_VER)
-#  else
-#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(_MSC_VER)
-#  endif
-#elif defined(__MWERKS__)
-#  define LZO_CC_MWERKS         1
-#  define LZO_INFO_CC           "Metrowerks C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__MWERKS__)
-#elif (defined(__NDPC__) || defined(__NDPX__)) && defined(__i386)
-#  define LZO_CC_NDPC           1
-#  define LZO_INFO_CC           "Microway NDP C"
-#  define LZO_INFO_CCVER        "unknown"
-#elif defined(__PACIFIC__)
-#  define LZO_CC_PACIFICC       1
-#  define LZO_INFO_CC           "Pacific C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__PACIFIC__)
-#elif defined(__PGI) && (defined(__linux__) || defined(__WIN32__))
-#  define LZO_CC_PGI            1
-#  define LZO_INFO_CC           "Portland Group PGI C"
-#  define LZO_INFO_CCVER        "unknown"
-#elif defined(__PUREC__) && defined(__TOS__)
-#  define LZO_CC_PUREC          1
-#  define LZO_INFO_CC           "Pure C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__PUREC__)
-#elif defined(__SC__) && defined(__ZTC__)
-#  define LZO_CC_SYMANTECC      1
-#  define LZO_INFO_CC           "Symantec C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__SC__)
-#elif defined(__SUNPRO_C)
-#  define LZO_INFO_CC           "SunPro C"
-#  if ((__SUNPRO_C)+0 > 0)
-#    define LZO_CC_SUNPROC      __SUNPRO_C
-#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(__SUNPRO_C)
-#  else
-#    define LZO_CC_SUNPROC      1
-#    define LZO_INFO_CCVER      "unknown"
-#  endif
-#elif defined(__SUNPRO_CC)
-#  define LZO_INFO_CC           "SunPro C"
-#  if ((__SUNPRO_CC)+0 > 0)
-#    define LZO_CC_SUNPROC      __SUNPRO_CC
-#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(__SUNPRO_CC)
-#  else
-#    define LZO_CC_SUNPROC      1
-#    define LZO_INFO_CCVER      "unknown"
-#  endif
-#elif defined(__TINYC__)
-#  define LZO_CC_TINYC          1
-#  define LZO_INFO_CC           "Tiny C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__TINYC__)
-#elif defined(__TSC__)
-#  define LZO_CC_TOPSPEEDC      1
-#  define LZO_INFO_CC           "TopSpeed C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__TSC__)
-#elif defined(__WATCOMC__)
-#  define LZO_CC_WATCOMC        1
-#  define LZO_INFO_CC           "Watcom C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__WATCOMC__)
-#elif defined(__TURBOC__)
-#  define LZO_CC_TURBOC         1
-#  define LZO_INFO_CC           "Turbo C"
-#  define LZO_INFO_CCVER        LZO_PP_MACRO_EXPAND(__TURBOC__)
-#elif defined(__ZTC__)
-#  define LZO_CC_ZORTECHC       1
-#  define LZO_INFO_CC           "Zortech C"
-#  if (__ZTC__ == 0x310)
-#    define LZO_INFO_CCVER      "0x310"
-#  else
-#    define LZO_INFO_CCVER      LZO_PP_MACRO_EXPAND(__ZTC__)
-#  endif
-#else
-#  define LZO_CC_UNKNOWN        1
-#  define LZO_INFO_CC           "unknown"
-#  define LZO_INFO_CCVER        "unknown"
-#endif
-#if 0 && (LZO_CC_MSC && (_MSC_VER >= 1200)) && !defined(_MSC_FULL_VER)
-#  error "LZO_CC_MSC: _MSC_FULL_VER is not defined"
-#endif
-#if !defined(__LZO_ARCH_OVERRIDE) && !(LZO_ARCH_GENERIC) && defined(_CRAY)
-#  if (UINT_MAX > LZO_0xffffffffL) && defined(_CRAY)
-#    if defined(_CRAYMPP) || defined(_CRAYT3D) || defined(_CRAYT3E)
-#      define LZO_ARCH_CRAY_MPP     1
-#    elif defined(_CRAY1)
-#      define LZO_ARCH_CRAY_PVP     1
-#    endif
-#  endif
-#endif
-#if !defined(__LZO_ARCH_OVERRIDE)
-#if (LZO_ARCH_GENERIC)
-#  define LZO_INFO_ARCH             "generic"
-#elif (LZO_OS_DOS16 || LZO_OS_OS216 || LZO_OS_WIN16)
-#  define LZO_ARCH_I086             1
-#  define LZO_ARCH_IA16             1
-#  define LZO_INFO_ARCH             "i086"
-#elif defined(__alpha__) || defined(__alpha) || defined(_M_ALPHA)
-#  define LZO_ARCH_ALPHA            1
-#  define LZO_INFO_ARCH             "alpha"
-#elif (LZO_ARCH_CRAY_MPP) && (defined(_CRAYT3D) || defined(_CRAYT3E))
-#  define LZO_ARCH_ALPHA            1
-#  define LZO_INFO_ARCH             "alpha"
-#elif defined(__amd64__) || defined(__x86_64__) || defined(_M_AMD64)
-#  define LZO_ARCH_AMD64            1
-#  define LZO_INFO_ARCH             "amd64"
-#elif defined(__thumb__) || (defined(_M_ARM) && defined(_M_THUMB))
-#  define LZO_ARCH_ARM              1
-#  define LZO_ARCH_ARM_THUMB        1
-#  define LZO_INFO_ARCH             "arm_thumb"
-#elif defined(__IAR_SYSTEMS_ICC__) && defined(__ICCARM__)
-#  define LZO_ARCH_ARM              1
-#  if defined(__CPU_MODE__) && ((__CPU_MODE__)+0 == 1)
-#    define LZO_ARCH_ARM_THUMB      1
-#    define LZO_INFO_ARCH           "arm_thumb"
-#  elif defined(__CPU_MODE__) && ((__CPU_MODE__)+0 == 2)
-#    define LZO_INFO_ARCH           "arm"
-#  else
-#    define LZO_INFO_ARCH           "arm"
-#  endif
-#elif defined(__arm__) || defined(_M_ARM)
-#  define LZO_ARCH_ARM              1
-#  define LZO_INFO_ARCH             "arm"
-#elif (UINT_MAX <= LZO_0xffffL) && defined(__AVR__)
-#  define LZO_ARCH_AVR              1
-#  define LZO_INFO_ARCH             "avr"
-#elif defined(__avr32__) || defined(__AVR32__)
-#  define LZO_ARCH_AVR32            1
-#  define LZO_INFO_ARCH             "avr32"
-#elif defined(__bfin__)
-#  define LZO_ARCH_BLACKFIN         1
-#  define LZO_INFO_ARCH             "blackfin"
-#elif (UINT_MAX == LZO_0xffffL) && defined(__C166__)
-#  define LZO_ARCH_C166             1
-#  define LZO_INFO_ARCH             "c166"
-#elif defined(__cris__)
-#  define LZO_ARCH_CRIS             1
-#  define LZO_INFO_ARCH             "cris"
-#elif defined(__IAR_SYSTEMS_ICC__) && defined(__ICCEZ80__)
-#  define LZO_ARCH_EZ80             1
-#  define LZO_INFO_ARCH             "ez80"
-#elif defined(__H8300__) || defined(__H8300H__) || defined(__H8300S__) || defined(__H8300SX__)
-#  define LZO_ARCH_H8300            1
-#  define LZO_INFO_ARCH             "h8300"
-#elif defined(__hppa__) || defined(__hppa)
-#  define LZO_ARCH_HPPA             1
-#  define LZO_INFO_ARCH             "hppa"
-#elif defined(__386__) || defined(__i386__) || defined(__i386) || defined(_M_IX86) || defined(_M_I386)
-#  define LZO_ARCH_I386             1
-#  define LZO_ARCH_IA32             1
-#  define LZO_INFO_ARCH             "i386"
-#elif (LZO_CC_ZORTECHC && defined(__I86__))
-#  define LZO_ARCH_I386             1
-#  define LZO_ARCH_IA32             1
-#  define LZO_INFO_ARCH             "i386"
-#elif (LZO_OS_DOS32 && LZO_CC_HIGHC) && defined(_I386)
-#  define LZO_ARCH_I386             1
-#  define LZO_ARCH_IA32             1
-#  define LZO_INFO_ARCH             "i386"
-#elif defined(__ia64__) || defined(__ia64) || defined(_M_IA64)
-#  define LZO_ARCH_IA64             1
-#  define LZO_INFO_ARCH             "ia64"
-#elif (UINT_MAX == LZO_0xffffL) && defined(__m32c__)
-#  define LZO_ARCH_M16C             1
-#  define LZO_INFO_ARCH             "m16c"
-#elif defined(__IAR_SYSTEMS_ICC__) && defined(__ICCM16C__)
-#  define LZO_ARCH_M16C             1
-#  define LZO_INFO_ARCH             "m16c"
-#elif defined(__m32r__)
-#  define LZO_ARCH_M32R             1
-#  define LZO_INFO_ARCH             "m32r"
-#elif (LZO_OS_TOS) || defined(__m68k__) || defined(__m68000__) || defined(__mc68000__) || defined(__mc68020__) || defined(_M_M68K)
-#  define LZO_ARCH_M68K             1
-#  define LZO_INFO_ARCH             "m68k"
-#elif (UINT_MAX == LZO_0xffffL) && defined(__C251__)
-#  define LZO_ARCH_MCS251           1
-#  define LZO_INFO_ARCH             "mcs251"
-#elif (UINT_MAX == LZO_0xffffL) && defined(__C51__)
-#  define LZO_ARCH_MCS51            1
-#  define LZO_INFO_ARCH             "mcs51"
-#elif defined(__IAR_SYSTEMS_ICC__) && defined(__ICC8051__)
-#  define LZO_ARCH_MCS51            1
-#  define LZO_INFO_ARCH             "mcs51"
-#elif defined(__mips__) || defined(__mips) || defined(_MIPS_ARCH) || defined(_M_MRX000)
-#  define LZO_ARCH_MIPS             1
-#  define LZO_INFO_ARCH             "mips"
-#elif (UINT_MAX == LZO_0xffffL) && defined(__MSP430__)
-#  define LZO_ARCH_MSP430           1
-#  define LZO_INFO_ARCH             "msp430"
-#elif defined(__IAR_SYSTEMS_ICC__) && defined(__ICC430__)
-#  define LZO_ARCH_MSP430           1
-#  define LZO_INFO_ARCH             "msp430"
-#elif defined(__powerpc__) || defined(__powerpc) || defined(__ppc__) || defined(__PPC__) || defined(_M_PPC) || defined(_ARCH_PPC) || defined(_ARCH_PWR)
-#  define LZO_ARCH_POWERPC          1
-#  define LZO_INFO_ARCH             "powerpc"
-#elif defined(__s390__) || defined(__s390) || defined(__s390x__) || defined(__s390x)
-#  define LZO_ARCH_S390             1
-#  define LZO_INFO_ARCH             "s390"
-#elif defined(__sh__) || defined(_M_SH)
-#  define LZO_ARCH_SH               1
-#  define LZO_INFO_ARCH             "sh"
-#elif defined(__sparc__) || defined(__sparc) || defined(__sparcv8)
-#  define LZO_ARCH_SPARC            1
-#  define LZO_INFO_ARCH             "sparc"
-#elif defined(__SPU__)
-#  define LZO_ARCH_SPU              1
-#  define LZO_INFO_ARCH             "spu"
-#elif (UINT_MAX == LZO_0xffffL) && defined(__z80)
-#  define LZO_ARCH_Z80              1
-#  define LZO_INFO_ARCH             "z80"
-#elif (LZO_ARCH_CRAY_PVP)
-#  if defined(_CRAYSV1)
-#    define LZO_ARCH_CRAY_SV1       1
-#    define LZO_INFO_ARCH           "cray_sv1"
-#  elif (_ADDR64)
-#    define LZO_ARCH_CRAY_T90       1
-#    define LZO_INFO_ARCH           "cray_t90"
-#  elif (_ADDR32)
-#    define LZO_ARCH_CRAY_YMP       1
-#    define LZO_INFO_ARCH           "cray_ymp"
-#  else
-#    define LZO_ARCH_CRAY_XMP       1
-#    define LZO_INFO_ARCH           "cray_xmp"
-#  endif
-#else
-#  define LZO_ARCH_UNKNOWN          1
-#  define LZO_INFO_ARCH             "unknown"
-#endif
-#endif
-#if 1 && (LZO_ARCH_UNKNOWN) && (LZO_OS_DOS32 || LZO_OS_OS2)
-#  error "FIXME - missing define for CPU architecture"
-#endif
-#if 1 && (LZO_ARCH_UNKNOWN) && (LZO_OS_WIN32)
-#  error "FIXME - missing WIN32 define for CPU architecture"
-#endif
-#if 1 && (LZO_ARCH_UNKNOWN) && (LZO_OS_WIN64)
-#  error "FIXME - missing WIN64 define for CPU architecture"
-#endif
-#if (LZO_OS_OS216 || LZO_OS_WIN16)
-#  define LZO_ARCH_I086PM           1
-#  define LZO_ARCH_IA16PM           1
-#elif 1 && (LZO_OS_DOS16 && defined(BLX286))
-#  define LZO_ARCH_I086PM           1
-#  define LZO_ARCH_IA16PM           1
-#elif 1 && (LZO_OS_DOS16 && defined(DOSX286))
-#  define LZO_ARCH_I086PM           1
-#  define LZO_ARCH_IA16PM           1
-#elif 1 && (LZO_OS_DOS16 && LZO_CC_BORLANDC && defined(__DPMI16__))
-#  define LZO_ARCH_I086PM           1
-#  define LZO_ARCH_IA16PM           1
-#endif
-#if (LZO_ARCH_ARM_THUMB) && !(LZO_ARCH_ARM)
-#  error "this should not happen"
-#endif
-#if (LZO_ARCH_I086PM) && !(LZO_ARCH_I086)
-#  error "this should not happen"
-#endif
-#if (LZO_ARCH_I086)
-#  if (UINT_MAX != LZO_0xffffL)
-#    error "this should not happen"
-#  endif
-#  if (ULONG_MAX != LZO_0xffffffffL)
-#    error "this should not happen"
-#  endif
-#endif
-#if (LZO_ARCH_I386)
-#  if (UINT_MAX != LZO_0xffffL) && defined(__i386_int16__)
-#    error "this should not happen"
-#  endif
-#  if (UINT_MAX != LZO_0xffffffffL) && !defined(__i386_int16__)
-#    error "this should not happen"
-#  endif
-#  if (ULONG_MAX != LZO_0xffffffffL)
-#    error "this should not happen"
-#  endif
-#endif
-#if !defined(__LZO_MM_OVERRIDE)
-#if (LZO_ARCH_I086)
-#if (UINT_MAX != LZO_0xffffL)
-#  error "this should not happen"
-#endif
-#if defined(__TINY__) || defined(M_I86TM) || defined(_M_I86TM)
-#  define LZO_MM_TINY           1
-#elif defined(__HUGE__) || defined(_HUGE_) || defined(M_I86HM) || defined(_M_I86HM)
-#  define LZO_MM_HUGE           1
-#elif defined(__SMALL__) || defined(M_I86SM) || defined(_M_I86SM) || defined(SMALL_MODEL)
-#  define LZO_MM_SMALL          1
-#elif defined(__MEDIUM__) || defined(M_I86MM) || defined(_M_I86MM)
-#  define LZO_MM_MEDIUM         1
-#elif defined(__COMPACT__) || defined(M_I86CM) || defined(_M_I86CM)
-#  define LZO_MM_COMPACT        1
-#elif defined(__LARGE__) || defined(M_I86LM) || defined(_M_I86LM) || defined(LARGE_MODEL)
-#  define LZO_MM_LARGE          1
-#elif (LZO_CC_AZTECC)
-#  if defined(_LARGE_CODE) && defined(_LARGE_DATA)
-#    define LZO_MM_LARGE        1
-#  elif defined(_LARGE_CODE)
-#    define LZO_MM_MEDIUM       1
-#  elif defined(_LARGE_DATA)
-#    define LZO_MM_COMPACT      1
-#  else
-#    define LZO_MM_SMALL        1
-#  endif
-#elif (LZO_CC_ZORTECHC && defined(__VCM__))
-#  define LZO_MM_LARGE          1
-#else
-#  error "unknown memory model"
-#endif
-#if (LZO_OS_DOS16 || LZO_OS_OS216 || LZO_OS_WIN16)
-#define LZO_HAVE_MM_HUGE_PTR        1
-#define LZO_HAVE_MM_HUGE_ARRAY      1
-#if (LZO_MM_TINY)
-#  undef LZO_HAVE_MM_HUGE_ARRAY
-#endif
-#if (LZO_CC_AZTECC || LZO_CC_PACIFICC || LZO_CC_ZORTECHC)
-#  undef LZO_HAVE_MM_HUGE_PTR
-#  undef LZO_HAVE_MM_HUGE_ARRAY
-#elif (LZO_CC_DMC || LZO_CC_SYMANTECC)
-#  undef LZO_HAVE_MM_HUGE_ARRAY
-#elif (LZO_CC_MSC && defined(_QC))
-#  undef LZO_HAVE_MM_HUGE_ARRAY
-#  if (_MSC_VER < 600)
-#    undef LZO_HAVE_MM_HUGE_PTR
-#  endif
-#elif (LZO_CC_TURBOC && (__TURBOC__ < 0x0295))
-#  undef LZO_HAVE_MM_HUGE_ARRAY
-#endif
-#if (LZO_ARCH_I086PM) && !(LZO_HAVE_MM_HUGE_PTR)
-#  if (LZO_OS_DOS16)
-#    error "this should not happen"
-#  elif (LZO_CC_ZORTECHC)
-#  else
-#    error "this should not happen"
-#  endif
-#endif
-#ifdef __cplusplus
-extern "C" {
-#endif
-#if (LZO_CC_BORLANDC && (__BORLANDC__ >= 0x0200))
-   extern void __near __cdecl _AHSHIFT(void);
-#  define LZO_MM_AHSHIFT      ((unsigned) _AHSHIFT)
-#elif (LZO_CC_DMC || LZO_CC_SYMANTECC || LZO_CC_ZORTECHC)
-   extern void __near __cdecl _AHSHIFT(void);
-#  define LZO_MM_AHSHIFT      ((unsigned) _AHSHIFT)
-#elif (LZO_CC_MSC || LZO_CC_TOPSPEEDC)
-   extern void __near __cdecl _AHSHIFT(void);
-#  define LZO_MM_AHSHIFT      ((unsigned) _AHSHIFT)
-#elif (LZO_CC_TURBOC && (__TURBOC__ >= 0x0295))
-   extern void __near __cdecl _AHSHIFT(void);
-#  define LZO_MM_AHSHIFT      ((unsigned) _AHSHIFT)
-#elif ((LZO_CC_AZTECC || LZO_CC_PACIFICC || LZO_CC_TURBOC) && LZO_OS_DOS16)
-#  define LZO_MM_AHSHIFT      12
-#elif (LZO_CC_WATCOMC)
-   extern unsigned char _HShift;
-#  define LZO_MM_AHSHIFT      ((unsigned) _HShift)
-#else
-#  error "FIXME - implement LZO_MM_AHSHIFT"
-#endif
-#ifdef __cplusplus
-}
-#endif
-#endif
-#elif (LZO_ARCH_C166)
-#if !defined(__MODEL__)
-#  error "FIXME - C166 __MODEL__"
-#elif ((__MODEL__) == 0)
-#  define LZO_MM_SMALL          1
-#elif ((__MODEL__) == 1)
-#  define LZO_MM_SMALL          1
-#elif ((__MODEL__) == 2)
-#  define LZO_MM_LARGE          1
-#elif ((__MODEL__) == 3)
-#  define LZO_MM_TINY           1
-#elif ((__MODEL__) == 4)
-#  define LZO_MM_XTINY          1
-#elif ((__MODEL__) == 5)
-#  define LZO_MM_XSMALL         1
-#else
-#  error "FIXME - C166 __MODEL__"
-#endif
-#elif (LZO_ARCH_MCS251)
-#if !defined(__MODEL__)
-#  error "FIXME - MCS251 __MODEL__"
-#elif ((__MODEL__) == 0)
-#  define LZO_MM_SMALL          1
-#elif ((__MODEL__) == 2)
-#  define LZO_MM_LARGE          1
-#elif ((__MODEL__) == 3)
-#  define LZO_MM_TINY           1
-#elif ((__MODEL__) == 4)
-#  define LZO_MM_XTINY          1
-#elif ((__MODEL__) == 5)
-#  define LZO_MM_XSMALL         1
-#else
-#  error "FIXME - MCS251 __MODEL__"
-#endif
-#elif (LZO_ARCH_MCS51)
-#if !defined(__MODEL__)
-#  error "FIXME - MCS51 __MODEL__"
-#elif ((__MODEL__) == 1)
-#  define LZO_MM_SMALL          1
-#elif ((__MODEL__) == 2)
-#  define LZO_MM_LARGE          1
-#elif ((__MODEL__) == 3)
-#  define LZO_MM_TINY           1
-#elif ((__MODEL__) == 4)
-#  define LZO_MM_XTINY          1
-#elif ((__MODEL__) == 5)
-#  define LZO_MM_XSMALL         1
-#else
-#  error "FIXME - MCS51 __MODEL__"
-#endif
-#elif (LZO_ARCH_CRAY_PVP)
-#  define LZO_MM_PVP            1
-#else
-#  define LZO_MM_FLAT           1
-#endif
-#if (LZO_MM_COMPACT)
-#  define LZO_INFO_MM           "compact"
-#elif (LZO_MM_FLAT)
-#  define LZO_INFO_MM           "flat"
-#elif (LZO_MM_HUGE)
-#  define LZO_INFO_MM           "huge"
-#elif (LZO_MM_LARGE)
-#  define LZO_INFO_MM           "large"
-#elif (LZO_MM_MEDIUM)
-#  define LZO_INFO_MM           "medium"
-#elif (LZO_MM_PVP)
-#  define LZO_INFO_MM           "pvp"
-#elif (LZO_MM_SMALL)
-#  define LZO_INFO_MM           "small"
-#elif (LZO_MM_TINY)
-#  define LZO_INFO_MM           "tiny"
-#else
-#  error "unknown memory model"
-#endif
-#endif
-#if defined(SIZEOF_SHORT)
-#  define LZO_SIZEOF_SHORT          (SIZEOF_SHORT)
-#endif
-#if defined(SIZEOF_INT)
-#  define LZO_SIZEOF_INT            (SIZEOF_INT)
-#endif
-#if defined(SIZEOF_LONG)
-#  define LZO_SIZEOF_LONG           (SIZEOF_LONG)
-#endif
-#if defined(SIZEOF_LONG_LONG)
-#  define LZO_SIZEOF_LONG_LONG      (SIZEOF_LONG_LONG)
-#endif
-#if defined(SIZEOF___INT16)
-#  define LZO_SIZEOF___INT16        (SIZEOF___INT16)
-#endif
-#if defined(SIZEOF___INT32)
-#  define LZO_SIZEOF___INT32        (SIZEOF___INT32)
-#endif
-#if defined(SIZEOF___INT64)
-#  define LZO_SIZEOF___INT64        (SIZEOF___INT64)
-#endif
-#if defined(SIZEOF_VOID_P)
-#  define LZO_SIZEOF_VOID_P         (SIZEOF_VOID_P)
-#endif
-#if defined(SIZEOF_SIZE_T)
-#  define LZO_SIZEOF_SIZE_T         (SIZEOF_SIZE_T)
-#endif
-#if defined(SIZEOF_PTRDIFF_T)
-#  define LZO_SIZEOF_PTRDIFF_T      (SIZEOF_PTRDIFF_T)
-#endif
-#define __LZO_LSR(x,b)    (((x)+0ul) >> (b))
-#if !defined(LZO_SIZEOF_SHORT)
-#  if (LZO_ARCH_CRAY_PVP)
-#    define LZO_SIZEOF_SHORT        8
-#  elif (USHRT_MAX == LZO_0xffffL)
-#    define LZO_SIZEOF_SHORT        2
-#  elif (__LZO_LSR(USHRT_MAX,7) == 1)
-#    define LZO_SIZEOF_SHORT        1
-#  elif (__LZO_LSR(USHRT_MAX,15) == 1)
-#    define LZO_SIZEOF_SHORT        2
-#  elif (__LZO_LSR(USHRT_MAX,31) == 1)
-#    define LZO_SIZEOF_SHORT        4
-#  elif (__LZO_LSR(USHRT_MAX,63) == 1)
-#    define LZO_SIZEOF_SHORT        8
-#  elif (__LZO_LSR(USHRT_MAX,127) == 1)
-#    define LZO_SIZEOF_SHORT        16
-#  else
-#    error "LZO_SIZEOF_SHORT"
-#  endif
-#endif
-#if !defined(LZO_SIZEOF_INT)
-#  if (LZO_ARCH_CRAY_PVP)
-#    define LZO_SIZEOF_INT          8
-#  elif (UINT_MAX == LZO_0xffffL)
-#    define LZO_SIZEOF_INT          2
-#  elif (UINT_MAX == LZO_0xffffffffL)
-#    define LZO_SIZEOF_INT          4
-#  elif (__LZO_LSR(UINT_MAX,7) == 1)
-#    define LZO_SIZEOF_INT          1
-#  elif (__LZO_LSR(UINT_MAX,15) == 1)
-#    define LZO_SIZEOF_INT          2
-#  elif (__LZO_LSR(UINT_MAX,31) == 1)
-#    define LZO_SIZEOF_INT          4
-#  elif (__LZO_LSR(UINT_MAX,63) == 1)
-#    define LZO_SIZEOF_INT          8
-#  elif (__LZO_LSR(UINT_MAX,127) == 1)
-#    define LZO_SIZEOF_INT          16
-#  else
-#    error "LZO_SIZEOF_INT"
-#  endif
-#endif
-#if !defined(LZO_SIZEOF_LONG)
-#  if (ULONG_MAX == LZO_0xffffffffL)
-#    define LZO_SIZEOF_LONG         4
-#  elif (__LZO_LSR(ULONG_MAX,7) == 1)
-#    define LZO_SIZEOF_LONG         1
-#  elif (__LZO_LSR(ULONG_MAX,15) == 1)
-#    define LZO_SIZEOF_LONG         2
-#  elif (__LZO_LSR(ULONG_MAX,31) == 1)
-#    define LZO_SIZEOF_LONG         4
-#  elif (__LZO_LSR(ULONG_MAX,63) == 1)
-#    define LZO_SIZEOF_LONG         8
-#  elif (__LZO_LSR(ULONG_MAX,127) == 1)
-#    define LZO_SIZEOF_LONG         16
-#  else
-#    error "LZO_SIZEOF_LONG"
-#  endif
-#endif
-#if !defined(LZO_SIZEOF_LONG_LONG) && !defined(LZO_SIZEOF___INT64)
-#if (LZO_SIZEOF_LONG > 0 && LZO_SIZEOF_LONG < 8)
-#  if defined(__LONG_MAX__) && defined(__LONG_LONG_MAX__)
-#    if (LZO_CC_GNUC >= 0x030300ul)
-#      if ((__LONG_MAX__)+0 == (__LONG_LONG_MAX__)+0)
-#        define LZO_SIZEOF_LONG_LONG      LZO_SIZEOF_LONG
-#      elif (__LZO_LSR(__LONG_LONG_MAX__,30) == 1)
-#        define LZO_SIZEOF_LONG_LONG      4
-#      endif
-#    endif
-#  endif
-#endif
-#endif
-#if !defined(LZO_SIZEOF_LONG_LONG) && !defined(LZO_SIZEOF___INT64)
-#if (LZO_SIZEOF_LONG > 0 && LZO_SIZEOF_LONG < 8)
-#if (LZO_ARCH_I086 && LZO_CC_DMC)
-#elif (LZO_CC_CILLY) && defined(__GNUC__)
-#  define LZO_SIZEOF_LONG_LONG      8
-#elif (LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#  define LZO_SIZEOF_LONG_LONG      8
-#elif ((LZO_OS_WIN32 || LZO_OS_WIN64 || defined(_WIN32)) && LZO_CC_MSC && (_MSC_VER >= 1400))
-#  define LZO_SIZEOF_LONG_LONG      8
-#elif (LZO_OS_WIN64 || defined(_WIN64))
-#  define LZO_SIZEOF___INT64        8
-#elif (LZO_ARCH_I386 && (LZO_CC_DMC))
-#  define LZO_SIZEOF_LONG_LONG      8
-#elif (LZO_ARCH_I386 && (LZO_CC_SYMANTECC && (__SC__ >= 0x700)))
-#  define LZO_SIZEOF_LONG_LONG      8
-#elif (LZO_ARCH_I386 && (LZO_CC_INTELC && defined(__linux__)))
-#  define LZO_SIZEOF_LONG_LONG      8
-#elif (LZO_ARCH_I386 && (LZO_CC_MWERKS || LZO_CC_PELLESC || LZO_CC_PGI || LZO_CC_SUNPROC))
-#  define LZO_SIZEOF_LONG_LONG      8
-#elif (LZO_ARCH_I386 && (LZO_CC_INTELC || LZO_CC_MSC))
-#  define LZO_SIZEOF___INT64        8
-#elif ((LZO_OS_WIN32 || defined(_WIN32)) && (LZO_CC_MSC))
-#  define LZO_SIZEOF___INT64        8
-#elif (LZO_ARCH_I386 && (LZO_CC_BORLANDC && (__BORLANDC__ >= 0x0520)))
-#  define LZO_SIZEOF___INT64        8
-#elif (LZO_ARCH_I386 && (LZO_CC_WATCOMC && (__WATCOMC__ >= 1100)))
-#  define LZO_SIZEOF___INT64        8
-#elif (LZO_CC_WATCOMC && defined(_INTEGRAL_MAX_BITS) && (_INTEGRAL_MAX_BITS == 64))
-#  define LZO_SIZEOF___INT64        8
-#elif (LZO_OS_OS400 || defined(__OS400__)) && defined(__LLP64_IFC__)
-#  define LZO_SIZEOF_LONG_LONG      8
-#elif (defined(__vms) || defined(__VMS)) && (__INITIAL_POINTER_SIZE+0 == 64)
-#  define LZO_SIZEOF_LONG_LONG      8
-#elif (LZO_CC_SDCC) && (LZO_SIZEOF_INT == 2)
-#elif 1 && defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
-#  define LZO_SIZEOF_LONG_LONG      8
-#endif
-#endif
-#endif
-#if defined(__cplusplus) && (LZO_CC_GNUC)
-#  if (LZO_CC_GNUC < 0x020800ul)
-#    undef LZO_SIZEOF_LONG_LONG
-#  endif
-#endif
-#if (LZO_CFG_NO_LONG_LONG) || defined(__NO_LONG_LONG)
-#  undef LZO_SIZEOF_LONG_LONG
-#endif
-#if !defined(LZO_SIZEOF_VOID_P)
-#if (LZO_ARCH_I086)
-#  define __LZO_WORDSIZE            2
-#  if (LZO_MM_TINY || LZO_MM_SMALL || LZO_MM_MEDIUM)
-#    define LZO_SIZEOF_VOID_P       2
-#  elif (LZO_MM_COMPACT || LZO_MM_LARGE || LZO_MM_HUGE)
-#    define LZO_SIZEOF_VOID_P       4
-#  else
-#    error "LZO_MM"
-#  endif
-#elif (LZO_ARCH_AVR || LZO_ARCH_Z80)
-#  define __LZO_WORDSIZE            1
-#  define LZO_SIZEOF_VOID_P         2
-#elif (LZO_ARCH_C166 || LZO_ARCH_MCS51 || LZO_ARCH_MCS251 || LZO_ARCH_MSP430)
-#  define LZO_SIZEOF_VOID_P         2
-#elif (LZO_ARCH_H8300)
-#  if defined(__NORMAL_MODE__)
-#    define __LZO_WORDSIZE          4
-#    define LZO_SIZEOF_VOID_P       2
-#  elif defined(__H8300H__) || defined(__H8300S__) || defined(__H8300SX__)
-#    define __LZO_WORDSIZE          4
-#    define LZO_SIZEOF_VOID_P       4
-#  else
-#    define __LZO_WORDSIZE          2
-#    define LZO_SIZEOF_VOID_P       2
-#  endif
-#  if (LZO_CC_GNUC && (LZO_CC_GNUC < 0x040000ul)) && (LZO_SIZEOF_INT == 4)
-#    define LZO_SIZEOF_SIZE_T       LZO_SIZEOF_INT
-#    define LZO_SIZEOF_PTRDIFF_T    LZO_SIZEOF_INT
-#  endif
-#elif (LZO_ARCH_M16C)
-#  define __LZO_WORDSIZE            2
-#  if defined(__m32c_cpu__) || defined(__m32cm_cpu__)
-#    define LZO_SIZEOF_VOID_P       4
-#  else
-#    define LZO_SIZEOF_VOID_P       2
-#  endif
-#elif (LZO_SIZEOF_LONG == 8) && ((defined(__mips__) && defined(__R5900__)) || defined(__MIPS_PSX2__))
-#  define __LZO_WORDSIZE            8
-#  define LZO_SIZEOF_VOID_P         4
-#elif defined(__LLP64__) || defined(__LLP64) || defined(_LLP64) || defined(_WIN64)
-#  define __LZO_WORDSIZE            8
-#  define LZO_SIZEOF_VOID_P         8
-#elif (LZO_OS_OS400 || defined(__OS400__)) && defined(__LLP64_IFC__)
-#  define LZO_SIZEOF_VOID_P         LZO_SIZEOF_LONG
-#  define LZO_SIZEOF_SIZE_T         LZO_SIZEOF_LONG
-#  define LZO_SIZEOF_PTRDIFF_T      LZO_SIZEOF_LONG
-#elif (LZO_OS_OS400 || defined(__OS400__))
-#  define __LZO_WORDSIZE            LZO_SIZEOF_LONG
-#  define LZO_SIZEOF_VOID_P         16
-#  define LZO_SIZEOF_SIZE_T         LZO_SIZEOF_LONG
-#  define LZO_SIZEOF_PTRDIFF_T      LZO_SIZEOF_LONG
-#elif (defined(__vms) || defined(__VMS)) && (__INITIAL_POINTER_SIZE+0 == 64)
-#  define LZO_SIZEOF_VOID_P         8
-#  define LZO_SIZEOF_SIZE_T         LZO_SIZEOF_LONG
-#  define LZO_SIZEOF_PTRDIFF_T      LZO_SIZEOF_LONG
-#elif (LZO_ARCH_SPU)
-# if 0
-#  define __LZO_WORDSIZE            16
-# endif
-#  define LZO_SIZEOF_VOID_P         4
-#else
-#  define LZO_SIZEOF_VOID_P         LZO_SIZEOF_LONG
-#endif
-#endif
-#if !defined(LZO_WORDSIZE)
-#  if defined(__LZO_WORDSIZE)
-#    define LZO_WORDSIZE            __LZO_WORDSIZE
-#  else
-#    define LZO_WORDSIZE            LZO_SIZEOF_VOID_P
-#  endif
-#endif
-#if !defined(LZO_SIZEOF_SIZE_T)
-#if (LZO_ARCH_I086 || LZO_ARCH_M16C)
-#  define LZO_SIZEOF_SIZE_T         2
-#else
-#  define LZO_SIZEOF_SIZE_T         LZO_SIZEOF_VOID_P
-#endif
-#endif
-#if !defined(LZO_SIZEOF_PTRDIFF_T)
-#if (LZO_ARCH_I086)
-#  if (LZO_MM_TINY || LZO_MM_SMALL || LZO_MM_MEDIUM || LZO_MM_HUGE)
-#    define LZO_SIZEOF_PTRDIFF_T    LZO_SIZEOF_VOID_P
-#  elif (LZO_MM_COMPACT || LZO_MM_LARGE)
-#    if (LZO_CC_BORLANDC || LZO_CC_TURBOC)
-#      define LZO_SIZEOF_PTRDIFF_T  4
-#    else
-#      define LZO_SIZEOF_PTRDIFF_T  2
-#    endif
-#  else
-#    error "LZO_MM"
-#  endif
-#else
-#  define LZO_SIZEOF_PTRDIFF_T      LZO_SIZEOF_SIZE_T
-#endif
-#endif
-#if (LZO_ABI_NEUTRAL_ENDIAN)
-#  undef LZO_ABI_BIG_ENDIAN
-#  undef LZO_ABI_LITTLE_ENDIAN
-#elif !(LZO_ABI_BIG_ENDIAN) && !(LZO_ABI_LITTLE_ENDIAN)
-#if (LZO_ARCH_ALPHA) && (LZO_ARCH_CRAY_MPP)
-#  define LZO_ABI_BIG_ENDIAN        1
-#elif (LZO_ARCH_IA64) && (LZO_OS_POSIX_LINUX || LZO_OS_WIN64)
-#  define LZO_ABI_LITTLE_ENDIAN     1
-#elif (LZO_ARCH_ALPHA || LZO_ARCH_AMD64 || LZO_ARCH_BLACKFIN || LZO_ARCH_CRIS || LZO_ARCH_I086 || LZO_ARCH_I386 || LZO_ARCH_MSP430)
-#  define LZO_ABI_LITTLE_ENDIAN     1
-#elif (LZO_ARCH_AVR32 || LZO_ARCH_M68K || LZO_ARCH_S390)
-#  define LZO_ABI_BIG_ENDIAN        1
-#elif 1 && defined(__IAR_SYSTEMS_ICC__) && defined(__LITTLE_ENDIAN__)
-#  if (__LITTLE_ENDIAN__ == 1)
-#    define LZO_ABI_LITTLE_ENDIAN   1
-#  else
-#    define LZO_ABI_BIG_ENDIAN      1
-#  endif
-#elif 1 && defined(__BIG_ENDIAN__) && !defined(__LITTLE_ENDIAN__)
-#  define LZO_ABI_BIG_ENDIAN        1
-#elif 1 && defined(__LITTLE_ENDIAN__) && !defined(__BIG_ENDIAN__)
-#  define LZO_ABI_LITTLE_ENDIAN     1
-#elif 1 && (LZO_ARCH_ARM) && defined(__ARMEB__) && !defined(__ARMEL__)
-#  define LZO_ABI_BIG_ENDIAN        1
-#elif 1 && (LZO_ARCH_ARM) && defined(__ARMEL__) && !defined(__ARMEB__)
-#  define LZO_ABI_LITTLE_ENDIAN     1
-#elif 1 && (LZO_ARCH_MIPS) && defined(__MIPSEB__) && !defined(__MIPSEL__)
-#  define LZO_ABI_BIG_ENDIAN        1
-#elif 1 && (LZO_ARCH_MIPS) && defined(__MIPSEL__) && !defined(__MIPSEB__)
-#  define LZO_ABI_LITTLE_ENDIAN     1
-#endif
-#endif
-#if (LZO_ABI_BIG_ENDIAN) && (LZO_ABI_LITTLE_ENDIAN)
-#  error "this should not happen"
-#endif
-#if (LZO_ABI_BIG_ENDIAN)
-#  define LZO_INFO_ABI_ENDIAN       "be"
-#elif (LZO_ABI_LITTLE_ENDIAN)
-#  define LZO_INFO_ABI_ENDIAN       "le"
-#elif (LZO_ABI_NEUTRAL_ENDIAN)
-#  define LZO_INFO_ABI_ENDIAN       "neutral"
-#endif
-#if (LZO_SIZEOF_INT == 1 && LZO_SIZEOF_LONG == 2 && LZO_SIZEOF_VOID_P == 2)
-#  define LZO_ABI_I8LP16         1
-#  define LZO_INFO_ABI_PM       "i8lp16"
-#elif (LZO_SIZEOF_INT == 2 && LZO_SIZEOF_LONG == 2 && LZO_SIZEOF_VOID_P == 2)
-#  define LZO_ABI_ILP16         1
-#  define LZO_INFO_ABI_PM       "ilp16"
-#elif (LZO_SIZEOF_INT == 4 && LZO_SIZEOF_LONG == 4 && LZO_SIZEOF_VOID_P == 4)
-#  define LZO_ABI_ILP32         1
-#  define LZO_INFO_ABI_PM       "ilp32"
-#elif (LZO_SIZEOF_INT == 4 && LZO_SIZEOF_LONG == 4 && LZO_SIZEOF_VOID_P == 8 && LZO_SIZEOF_SIZE_T == 8)
-#  define LZO_ABI_LLP64         1
-#  define LZO_INFO_ABI_PM       "llp64"
-#elif (LZO_SIZEOF_INT == 4 && LZO_SIZEOF_LONG == 8 && LZO_SIZEOF_VOID_P == 8)
-#  define LZO_ABI_LP64          1
-#  define LZO_INFO_ABI_PM       "lp64"
-#elif (LZO_SIZEOF_INT == 8 && LZO_SIZEOF_LONG == 8 && LZO_SIZEOF_VOID_P == 8)
-#  define LZO_ABI_ILP64         1
-#  define LZO_INFO_ABI_PM       "ilp64"
-#elif (LZO_SIZEOF_INT == 4 && LZO_SIZEOF_LONG == 8 && LZO_SIZEOF_VOID_P == 4)
-#  define LZO_ABI_IP32L64       1
-#  define LZO_INFO_ABI_PM       "ip32l64"
-#endif
-#if !defined(__LZO_LIBC_OVERRIDE)
-#if (LZO_LIBC_NAKED)
-#  define LZO_INFO_LIBC         "naked"
-#elif (LZO_LIBC_FREESTANDING)
-#  define LZO_INFO_LIBC         "freestanding"
-#elif (LZO_LIBC_MOSTLY_FREESTANDING)
-#  define LZO_INFO_LIBC         "mfreestanding"
-#elif (LZO_LIBC_ISOC90)
-#  define LZO_INFO_LIBC         "isoc90"
-#elif (LZO_LIBC_ISOC99)
-#  define LZO_INFO_LIBC         "isoc99"
-#elif defined(__dietlibc__)
-#  define LZO_LIBC_DIETLIBC     1
-#  define LZO_INFO_LIBC         "dietlibc"
-#elif defined(_NEWLIB_VERSION)
-#  define LZO_LIBC_NEWLIB       1
-#  define LZO_INFO_LIBC         "newlib"
-#elif defined(__UCLIBC__) && defined(__UCLIBC_MAJOR__) && defined(__UCLIBC_MINOR__)
-#  if defined(__UCLIBC_SUBLEVEL__)
-#    define LZO_LIBC_UCLIBC     (__UCLIBC_MAJOR__ * 0x10000L + __UCLIBC_MINOR__ * 0x100 + __UCLIBC_SUBLEVEL__)
-#  else
-#    define LZO_LIBC_UCLIBC     0x00090bL
-#  endif
-#  define LZO_INFO_LIBC         "uclibc"
-#elif defined(__GLIBC__) && defined(__GLIBC_MINOR__)
-#  define LZO_LIBC_GLIBC        (__GLIBC__ * 0x10000L + __GLIBC_MINOR__ * 0x100)
-#  define LZO_INFO_LIBC         "glibc"
-#elif (LZO_CC_MWERKS) && defined(__MSL__)
-#  define LZO_LIBC_MSL          __MSL__
-#  define LZO_INFO_LIBC         "msl"
-#elif 1 && defined(__IAR_SYSTEMS_ICC__)
-#  define LZO_LIBC_ISOC90       1
-#  define LZO_INFO_LIBC         "isoc90"
-#else
-#  define LZO_LIBC_DEFAULT      1
-#  define LZO_INFO_LIBC         "default"
-#endif
-#endif
-#if !defined(__lzo_gnuc_extension__)
-#if (LZO_CC_GNUC >= 0x020800ul)
-#  define __lzo_gnuc_extension__    __extension__
-#elif (LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#  define __lzo_gnuc_extension__    __extension__
-#else
-#  define __lzo_gnuc_extension__    /*empty*/
-#endif
-#endif
-#if !defined(__lzo_ua_volatile)
-#  define __lzo_ua_volatile     volatile
-#endif
-#if !defined(__lzo_alignof)
-#if (LZO_CC_CILLY || LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE || LZO_CC_PGI)
-#  define __lzo_alignof(e)      __alignof__(e)
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 700))
-#  define __lzo_alignof(e)      __alignof__(e)
-#elif (LZO_CC_MSC && (_MSC_VER >= 1300))
-#  define __lzo_alignof(e)      __alignof(e)
-#elif (LZO_CC_SUNPROC && (LZO_CC_SUNPROC >= 0x5100))
-#  define __lzo_alignof(e)      __alignof__(e)
-#endif
-#endif
-#if defined(__lzo_alignof)
-#  define __lzo_HAVE_alignof 1
-#endif
-#if !defined(__lzo_constructor)
-#if (LZO_CC_GNUC >= 0x030400ul)
-#  define __lzo_constructor     __attribute__((__constructor__,__used__))
-#elif (LZO_CC_GNUC >= 0x020700ul)
-#  define __lzo_constructor     __attribute__((__constructor__))
-#elif (LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#  define __lzo_constructor     __attribute__((__constructor__))
-#endif
-#endif
-#if defined(__lzo_constructor)
-#  define __lzo_HAVE_constructor 1
-#endif
-#if !defined(__lzo_destructor)
-#if (LZO_CC_GNUC >= 0x030400ul)
-#  define __lzo_destructor      __attribute__((__destructor__,__used__))
-#elif (LZO_CC_GNUC >= 0x020700ul)
-#  define __lzo_destructor      __attribute__((__destructor__))
-#elif (LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#  define __lzo_destructor      __attribute__((__destructor__))
-#endif
-#endif
-#if defined(__lzo_destructor)
-#  define __lzo_HAVE_destructor 1
-#endif
-#if (__lzo_HAVE_destructor) && !(__lzo_HAVE_constructor)
-#  error "this should not happen"
-#endif
-#if !defined(__lzo_inline)
-#if (LZO_CC_TURBOC && (__TURBOC__ <= 0x0295))
-#elif defined(__cplusplus)
-#  define __lzo_inline          inline
-#elif (LZO_CC_BORLANDC && (__BORLANDC__ >= 0x0550))
-#  define __lzo_inline          __inline
-#elif (LZO_CC_CILLY || LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE || LZO_CC_PGI)
-#  define __lzo_inline          __inline__
-#elif (LZO_CC_DMC)
-#  define __lzo_inline          __inline
-#elif (LZO_CC_INTELC)
-#  define __lzo_inline          __inline
-#elif (LZO_CC_MWERKS && (__MWERKS__ >= 0x2405))
-#  define __lzo_inline          __inline
-#elif (LZO_CC_MSC && (_MSC_VER >= 900))
-#  define __lzo_inline          __inline
-#elif (LZO_CC_SUNPROC && (LZO_CC_SUNPROC >= 0x5100))
-#  define __lzo_inline          __inline__
-#elif defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
-#  define __lzo_inline          inline
-#endif
-#endif
-#if defined(__lzo_inline)
-#  define __lzo_HAVE_inline 1
-#else
-#  define __lzo_inline          /*empty*/
-#endif
-#if !defined(__lzo_forceinline)
-#if (LZO_CC_GNUC >= 0x030200ul)
-#  define __lzo_forceinline     __inline__ __attribute__((__always_inline__))
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 450) && LZO_CC_SYNTAX_MSC)
-#  define __lzo_forceinline     __forceinline
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 800) && LZO_CC_SYNTAX_GNUC)
-#  define __lzo_forceinline     __inline__ __attribute__((__always_inline__))
-#elif (LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#  define __lzo_forceinline     __inline__ __attribute__((__always_inline__))
-#elif (LZO_CC_MSC && (_MSC_VER >= 1200))
-#  define __lzo_forceinline     __forceinline
-#elif (LZO_CC_SUNPROC && (LZO_CC_SUNPROC >= 0x5100))
-#  define __lzo_forceinline     __inline__ __attribute__((__always_inline__))
-#endif
-#endif
-#if defined(__lzo_forceinline)
-#  define __lzo_HAVE_forceinline 1
-#else
-#  define __lzo_forceinline     /*empty*/
-#endif
-#if !defined(__lzo_noinline)
-#if 1 && (LZO_ARCH_I386) && (LZO_CC_GNUC >= 0x040000ul) && (LZO_CC_GNUC < 0x040003ul)
-#  define __lzo_noinline        __attribute__((__noinline__,__used__))
-#elif (LZO_CC_GNUC >= 0x030200ul)
-#  define __lzo_noinline        __attribute__((__noinline__))
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 600) && LZO_CC_SYNTAX_MSC)
-#  define __lzo_noinline        __declspec(noinline)
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 800) && LZO_CC_SYNTAX_GNUC)
-#  define __lzo_noinline        __attribute__((__noinline__))
-#elif (LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#  define __lzo_noinline        __attribute__((__noinline__))
-#elif (LZO_CC_MSC && (_MSC_VER >= 1300))
-#  define __lzo_noinline        __declspec(noinline)
-#elif (LZO_CC_MWERKS && (__MWERKS__ >= 0x3200) && (LZO_OS_WIN32 || LZO_OS_WIN64))
-#  if defined(__cplusplus)
-#  else
-#    define __lzo_noinline      __declspec(noinline)
-#  endif
-#elif (LZO_CC_SUNPROC && (LZO_CC_SUNPROC >= 0x5100))
-#  define __lzo_noinline        __attribute__((__noinline__))
-#endif
-#endif
-#if defined(__lzo_noinline)
-#  define __lzo_HAVE_noinline 1
-#else
-#  define __lzo_noinline        /*empty*/
-#endif
-#if (__lzo_HAVE_forceinline || __lzo_HAVE_noinline) && !(__lzo_HAVE_inline)
-#  error "this should not happen"
-#endif
-#if !defined(__lzo_noreturn)
-#if (LZO_CC_GNUC >= 0x020700ul)
-#  define __lzo_noreturn        __attribute__((__noreturn__))
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 450) && LZO_CC_SYNTAX_MSC)
-#  define __lzo_noreturn        __declspec(noreturn)
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 600) && LZO_CC_SYNTAX_GNUC)
-#  define __lzo_noreturn        __attribute__((__noreturn__))
-#elif (LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#  define __lzo_noreturn        __attribute__((__noreturn__))
-#elif (LZO_CC_MSC && (_MSC_VER >= 1200))
-#  define __lzo_noreturn        __declspec(noreturn)
-#endif
-#endif
-#if defined(__lzo_noreturn)
-#  define __lzo_HAVE_noreturn 1
-#else
-#  define __lzo_noreturn        /*empty*/
-#endif
-#if !defined(__lzo_nothrow)
-#if (LZO_CC_GNUC >= 0x030300ul)
-#  define __lzo_nothrow         __attribute__((__nothrow__))
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 450) && LZO_CC_SYNTAX_MSC) && defined(__cplusplus)
-#  define __lzo_nothrow         __declspec(nothrow)
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 900) && LZO_CC_SYNTAX_GNUC)
-#  define __lzo_nothrow         __attribute__((__nothrow__))
-#elif (LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#  define __lzo_nothrow         __attribute__((__nothrow__))
-#elif (LZO_CC_MSC && (_MSC_VER >= 1200)) && defined(__cplusplus)
-#  define __lzo_nothrow         __declspec(nothrow)
-#endif
-#endif
-#if defined(__lzo_nothrow)
-#  define __lzo_HAVE_nothrow 1
-#else
-#  define __lzo_nothrow         /*empty*/
-#endif
-#if !defined(__lzo_restrict)
-#if (LZO_CC_GNUC >= 0x030400ul)
-#  define __lzo_restrict        __restrict__
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 600) && LZO_CC_SYNTAX_GNUC)
-#  define __lzo_restrict        __restrict__
-#elif (LZO_CC_CLANG || LZO_CC_LLVM)
-#  define __lzo_restrict        __restrict__
-#elif (LZO_CC_MSC && (_MSC_VER >= 1400))
-#  define __lzo_restrict        __restrict
-#endif
-#endif
-#if defined(__lzo_restrict)
-#  define __lzo_HAVE_restrict 1
-#else
-#  define __lzo_restrict        /*empty*/
-#endif
-#if !defined(__lzo_likely) && !defined(__lzo_unlikely)
-#if (LZO_CC_GNUC >= 0x030200ul)
-#  define __lzo_likely(e)       (__builtin_expect(!!(e),1))
-#  define __lzo_unlikely(e)     (__builtin_expect(!!(e),0))
-#elif (LZO_CC_INTELC && (__INTEL_COMPILER >= 800))
-#  define __lzo_likely(e)       (__builtin_expect(!!(e),1))
-#  define __lzo_unlikely(e)     (__builtin_expect(!!(e),0))
-#elif (LZO_CC_CLANG || LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#  define __lzo_likely(e)       (__builtin_expect(!!(e),1))
-#  define __lzo_unlikely(e)     (__builtin_expect(!!(e),0))
-#endif
-#endif
-#if defined(__lzo_likely)
-#  define __lzo_HAVE_likely 1
-#else
-#  define __lzo_likely(e)       (e)
-#endif
-#if defined(__lzo_unlikely)
-#  define __lzo_HAVE_unlikely 1
-#else
-#  define __lzo_unlikely(e)     (e)
-#endif
-#if !defined(LZO_UNUSED)
-#  if (LZO_CC_BORLANDC && (__BORLANDC__ >= 0x0600))
-#    define LZO_UNUSED(var)         ((void) &var)
-#  elif (LZO_CC_BORLANDC || LZO_CC_HIGHC || LZO_CC_NDPC || LZO_CC_PELLESC || LZO_CC_TURBOC)
-#    define LZO_UNUSED(var)         if (&var) ; else
-#  elif (LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#    define LZO_UNUSED(var)         ((void) var)
-#  elif (LZO_CC_MSC && (_MSC_VER < 900))
-#    define LZO_UNUSED(var)         if (&var) ; else
-#  elif (LZO_CC_KEILC)
-#    define LZO_UNUSED(var)         {extern int __lzo_unused[1-2*!(sizeof(var)>0)];}
-#  elif (LZO_CC_PACIFICC)
-#    define LZO_UNUSED(var)         ((void) sizeof(var))
-#  elif (LZO_CC_WATCOMC) && defined(__cplusplus)
-#    define LZO_UNUSED(var)         ((void) var)
-#  else
-#    define LZO_UNUSED(var)         ((void) &var)
-#  endif
-#endif
-#if !defined(LZO_UNUSED_FUNC)
-#  if (LZO_CC_BORLANDC && (__BORLANDC__ >= 0x0600))
-#    define LZO_UNUSED_FUNC(func)   ((void) func)
-#  elif (LZO_CC_BORLANDC || LZO_CC_NDPC || LZO_CC_TURBOC)
-#    define LZO_UNUSED_FUNC(func)   if (func) ; else
-#  elif (LZO_CC_CLANG || LZO_CC_LLVM)
-#    define LZO_UNUSED_FUNC(func)   ((void) &func)
-#  elif (LZO_CC_MSC && (_MSC_VER < 900))
-#    define LZO_UNUSED_FUNC(func)   if (func) ; else
-#  elif (LZO_CC_MSC)
-#    define LZO_UNUSED_FUNC(func)   ((void) &func)
-#  elif (LZO_CC_KEILC || LZO_CC_PELLESC)
-#    define LZO_UNUSED_FUNC(func)   {extern int __lzo_unused[1-2*!(sizeof((int)func)>0)];}
-#  else
-#    define LZO_UNUSED_FUNC(func)   ((void) func)
-#  endif
-#endif
-#if !defined(LZO_UNUSED_LABEL)
-#  if (LZO_CC_WATCOMC) && defined(__cplusplus)
-#    define LZO_UNUSED_LABEL(l)     switch(0) case 1:goto l
-#  elif (LZO_CC_CLANG || LZO_CC_INTELC || LZO_CC_WATCOMC)
-#    define LZO_UNUSED_LABEL(l)     if (0) goto l
-#  else
-#    define LZO_UNUSED_LABEL(l)     switch(0) case 1:goto l
-#  endif
-#endif
-#if !defined(LZO_DEFINE_UNINITIALIZED_VAR)
-#  if 0
-#    define LZO_DEFINE_UNINITIALIZED_VAR(type,var,init)  type var
-#  elif 0 && (LZO_CC_GNUC)
-#    define LZO_DEFINE_UNINITIALIZED_VAR(type,var,init)  type var = var
-#  else
-#    define LZO_DEFINE_UNINITIALIZED_VAR(type,var,init)  type var = init
-#  endif
-#endif
-#if !defined(LZO_UNCONST_CAST)
-#  if 0 && defined(__cplusplus)
-#    define LZO_UNCONST_CAST(t,e)   (const_cast<t> (e))
-#  elif (LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_LLVM || LZO_CC_PATHSCALE)
-#    define LZO_UNCONST_CAST(t,e)   ((t) ((void *) ((char *) ((lzo_uintptr_t) ((const void *) (e))))))
-#  else
-#    define LZO_UNCONST_CAST(t,e)   ((t) ((void *) ((char *) ((const void *) (e)))))
-#  endif
-#endif
-#if !defined(LZO_COMPILE_TIME_ASSERT_HEADER)
-#  if (LZO_CC_AZTECC || LZO_CC_ZORTECHC)
-#    define LZO_COMPILE_TIME_ASSERT_HEADER(e)  extern int __lzo_cta[1-!(e)];
-#  elif (LZO_CC_DMC || LZO_CC_SYMANTECC)
-#    define LZO_COMPILE_TIME_ASSERT_HEADER(e)  extern int __lzo_cta[1u-2*!(e)];
-#  elif (LZO_CC_TURBOC && (__TURBOC__ == 0x0295))
-#    define LZO_COMPILE_TIME_ASSERT_HEADER(e)  extern int __lzo_cta[1-!(e)];
-#  else
-#    define LZO_COMPILE_TIME_ASSERT_HEADER(e)  extern int __lzo_cta[1-2*!(e)];
-#  endif
-#endif
-#if !defined(LZO_COMPILE_TIME_ASSERT)
-#  if (LZO_CC_AZTECC)
-#    define LZO_COMPILE_TIME_ASSERT(e)  {typedef int __lzo_cta_t[1-!(e)];}
-#  elif (LZO_CC_DMC || LZO_CC_PACIFICC || LZO_CC_SYMANTECC || LZO_CC_ZORTECHC)
-#    define LZO_COMPILE_TIME_ASSERT(e)  switch(0) case 1:case !(e):break;
-#  elif (LZO_CC_MSC && (_MSC_VER < 900))
-#    define LZO_COMPILE_TIME_ASSERT(e)  switch(0) case 1:case !(e):break;
-#  elif (LZO_CC_TURBOC && (__TURBOC__ == 0x0295))
-#    define LZO_COMPILE_TIME_ASSERT(e)  switch(0) case 1:case !(e):break;
-#  else
-#    define LZO_COMPILE_TIME_ASSERT(e)  {typedef int __lzo_cta_t[1-2*!(e)];}
-#  endif
-#endif
-#if (LZO_ARCH_I086 || LZO_ARCH_I386) && (LZO_OS_DOS16 || LZO_OS_DOS32 || LZO_OS_OS2 || LZO_OS_OS216 || LZO_OS_WIN16 || LZO_OS_WIN32 || LZO_OS_WIN64)
-#  if (LZO_CC_GNUC || LZO_CC_HIGHC || LZO_CC_NDPC || LZO_CC_PACIFICC)
-#  elif (LZO_CC_DMC || LZO_CC_SYMANTECC || LZO_CC_ZORTECHC)
-#    define __lzo_cdecl                 __cdecl
-#    define __lzo_cdecl_atexit          /*empty*/
-#    define __lzo_cdecl_main            __cdecl
-#    if (LZO_OS_OS2 && (LZO_CC_DMC || LZO_CC_SYMANTECC))
-#      define __lzo_cdecl_qsort         __pascal
-#    elif (LZO_OS_OS2 && (LZO_CC_ZORTECHC))
-#      define __lzo_cdecl_qsort         _stdcall
-#    else
-#      define __lzo_cdecl_qsort         __cdecl
-#    endif
-#  elif (LZO_CC_WATCOMC)
-#    define __lzo_cdecl                 __cdecl
-#  else
-#    define __lzo_cdecl                 __cdecl
-#    define __lzo_cdecl_atexit          __cdecl
-#    define __lzo_cdecl_main            __cdecl
-#    define __lzo_cdecl_qsort           __cdecl
-#  endif
-#  if (LZO_CC_GNUC || LZO_CC_HIGHC || LZO_CC_NDPC || LZO_CC_PACIFICC || LZO_CC_WATCOMC)
-#  elif (LZO_OS_OS2 && (LZO_CC_DMC || LZO_CC_SYMANTECC))
-#    define __lzo_cdecl_sighandler      __pascal
-#  elif (LZO_OS_OS2 && (LZO_CC_ZORTECHC))
-#    define __lzo_cdecl_sighandler      _stdcall
-#  elif (LZO_CC_MSC && (_MSC_VER >= 1400)) && defined(_M_CEE_PURE)
-#    define __lzo_cdecl_sighandler      __clrcall
-#  elif (LZO_CC_MSC && (_MSC_VER >= 600 && _MSC_VER < 700))
-#    if defined(_DLL)
-#      define __lzo_cdecl_sighandler    _far _cdecl _loadds
-#    elif defined(_MT)
-#      define __lzo_cdecl_sighandler    _far _cdecl
-#    else
-#      define __lzo_cdecl_sighandler    _cdecl
-#    endif
-#  else
-#    define __lzo_cdecl_sighandler      __cdecl
-#  endif
-#elif (LZO_ARCH_I386) && (LZO_CC_WATCOMC)
-#  define __lzo_cdecl                   __cdecl
-#elif (LZO_ARCH_M68K && LZO_OS_TOS && (LZO_CC_PUREC || LZO_CC_TURBOC))
-#  define __lzo_cdecl                   cdecl
-#endif
-#if !defined(__lzo_cdecl)
-#  define __lzo_cdecl                   /*empty*/
-#endif
-#if !defined(__lzo_cdecl_atexit)
-#  define __lzo_cdecl_atexit            /*empty*/
-#endif
-#if !defined(__lzo_cdecl_main)
-#  define __lzo_cdecl_main              /*empty*/
-#endif
-#if !defined(__lzo_cdecl_qsort)
-#  define __lzo_cdecl_qsort             /*empty*/
-#endif
-#if !defined(__lzo_cdecl_sighandler)
-#  define __lzo_cdecl_sighandler        /*empty*/
-#endif
-#if !defined(__lzo_cdecl_va)
-#  define __lzo_cdecl_va                __lzo_cdecl
-#endif
-#if !(LZO_CFG_NO_WINDOWS_H)
-#if (LZO_OS_CYGWIN || (LZO_OS_EMX && defined(__RSXNT__)) || LZO_OS_WIN32 || LZO_OS_WIN64)
-#  if (LZO_CC_WATCOMC && (__WATCOMC__ < 1000))
-#  elif (LZO_OS_WIN32 && LZO_CC_GNUC) && defined(__PW32__)
-#  elif ((LZO_OS_CYGWIN || defined(__MINGW32__)) && (LZO_CC_GNUC && (LZO_CC_GNUC < 0x025f00ul)))
-#  else
-#    define LZO_HAVE_WINDOWS_H 1
-#  endif
-#endif
-#endif
-#if (LZO_ARCH_ALPHA)
-#  define LZO_OPT_AVOID_UINT_INDEX  1
-#  define LZO_OPT_AVOID_SHORT       1
-#  define LZO_OPT_AVOID_USHORT      1
-#elif (LZO_ARCH_AMD64)
-#  define LZO_OPT_AVOID_INT_INDEX   1
-#  define LZO_OPT_AVOID_UINT_INDEX  1
-#  define LZO_OPT_UNALIGNED16       1
-#  define LZO_OPT_UNALIGNED32       1
-#  define LZO_OPT_UNALIGNED64       1
-#elif (LZO_ARCH_ARM && LZO_ARCH_ARM_THUMB)
-#elif (LZO_ARCH_ARM)
-#  define LZO_OPT_AVOID_SHORT       1
-#  define LZO_OPT_AVOID_USHORT      1
-#elif (LZO_ARCH_CRIS)
-#  define LZO_OPT_UNALIGNED16       1
-#  define LZO_OPT_UNALIGNED32       1
-#elif (LZO_ARCH_I386)
-#  define LZO_OPT_UNALIGNED16       1
-#  define LZO_OPT_UNALIGNED32       1
-#elif (LZO_ARCH_IA64)
-#  define LZO_OPT_AVOID_INT_INDEX   1
-#  define LZO_OPT_AVOID_UINT_INDEX  1
-#  define LZO_OPT_PREFER_POSTINC    1
-#elif (LZO_ARCH_M68K)
-#  define LZO_OPT_PREFER_POSTINC    1
-#  define LZO_OPT_PREFER_PREDEC     1
-#  if defined(__mc68020__) && !defined(__mcoldfire__)
-#    define LZO_OPT_UNALIGNED16     1
-#    define LZO_OPT_UNALIGNED32     1
-#  endif
-#elif (LZO_ARCH_MIPS)
-#  define LZO_OPT_AVOID_UINT_INDEX  1
-#elif (LZO_ARCH_POWERPC)
-#  define LZO_OPT_PREFER_PREINC     1
-#  define LZO_OPT_PREFER_PREDEC     1
-#  if (LZO_ABI_BIG_ENDIAN)
-#    define LZO_OPT_UNALIGNED16     1
-#    define LZO_OPT_UNALIGNED32     1
-#  endif
-#elif (LZO_ARCH_S390)
-#  define LZO_OPT_UNALIGNED16       1
-#  define LZO_OPT_UNALIGNED32       1
-#  if (LZO_SIZEOF_SIZE_T == 8)
-#    define LZO_OPT_UNALIGNED64     1
-#  endif
-#elif (LZO_ARCH_SH)
-#  define LZO_OPT_PREFER_POSTINC    1
-#  define LZO_OPT_PREFER_PREDEC     1
-#endif
-#ifndef LZO_CFG_NO_INLINE_ASM
-#if (LZO_CC_LLVM)
-#  define LZO_CFG_NO_INLINE_ASM 1
-#endif
-#endif
-#ifndef LZO_CFG_NO_UNALIGNED
-#if (LZO_ABI_NEUTRAL_ENDIAN) || (LZO_ARCH_GENERIC)
-#  define LZO_CFG_NO_UNALIGNED 1
-#endif
-#endif
-#if (LZO_CFG_NO_UNALIGNED)
-#  undef LZO_OPT_UNALIGNED16
-#  undef LZO_OPT_UNALIGNED32
-#  undef LZO_OPT_UNALIGNED64
-#endif
-#if (LZO_CFG_NO_INLINE_ASM)
-#elif (LZO_ARCH_I386 && (LZO_OS_DOS32 || LZO_OS_WIN32) && (LZO_CC_DMC || LZO_CC_INTELC || LZO_CC_MSC || LZO_CC_PELLESC))
-#  define LZO_ASM_SYNTAX_MSC 1
-#elif (LZO_OS_WIN64 && (LZO_CC_DMC || LZO_CC_INTELC || LZO_CC_MSC || LZO_CC_PELLESC))
-#elif (LZO_ARCH_I386 && LZO_CC_GNUC && (LZO_CC_GNUC == 0x011f00ul))
-#elif (LZO_ARCH_I386 && (LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_INTELC || LZO_CC_PATHSCALE))
-#  define LZO_ASM_SYNTAX_GNUC 1
-#elif (LZO_ARCH_AMD64 && (LZO_CC_CLANG || LZO_CC_GNUC || LZO_CC_INTELC || LZO_CC_PATHSCALE))
-#  define LZO_ASM_SYNTAX_GNUC 1
-#endif
-#if (LZO_ASM_SYNTAX_GNUC)
-#if (LZO_ARCH_I386 && LZO_CC_GNUC && (LZO_CC_GNUC < 0x020000ul))
-#  define __LZO_ASM_CLOBBER         "ax"
-#elif (LZO_CC_INTELC)
-#  define __LZO_ASM_CLOBBER         "memory"
-#else
-#  define __LZO_ASM_CLOBBER         "cc", "memory"
-#endif
-#endif
-#if defined(__LZO_INFOSTR_MM)
-#elif (LZO_MM_FLAT) && (defined(__LZO_INFOSTR_PM) || defined(LZO_INFO_ABI_PM))
-#  define __LZO_INFOSTR_MM          ""
-#elif defined(LZO_INFO_MM)
-#  define __LZO_INFOSTR_MM          "." LZO_INFO_MM
-#else
-#  define __LZO_INFOSTR_MM          ""
-#endif
-#if defined(__LZO_INFOSTR_PM)
-#elif defined(LZO_INFO_ABI_PM)
-#  define __LZO_INFOSTR_PM          "." LZO_INFO_ABI_PM
-#else
-#  define __LZO_INFOSTR_PM          ""
-#endif
-#if defined(__LZO_INFOSTR_ENDIAN)
-#elif defined(LZO_INFO_ABI_ENDIAN)
-#  define __LZO_INFOSTR_ENDIAN      "." LZO_INFO_ABI_ENDIAN
-#else
-#  define __LZO_INFOSTR_ENDIAN      ""
-#endif
-#if defined(__LZO_INFOSTR_OSNAME)
-#elif defined(LZO_INFO_OS_CONSOLE)
-#  define __LZO_INFOSTR_OSNAME      LZO_INFO_OS "." LZO_INFO_OS_CONSOLE
-#elif defined(LZO_INFO_OS_POSIX)
-#  define __LZO_INFOSTR_OSNAME      LZO_INFO_OS "." LZO_INFO_OS_POSIX
-#else
-#  define __LZO_INFOSTR_OSNAME      LZO_INFO_OS
-#endif
-#if defined(__LZO_INFOSTR_LIBC)
-#elif defined(LZO_INFO_LIBC)
-#  define __LZO_INFOSTR_LIBC        "." LZO_INFO_LIBC
-#else
-#  define __LZO_INFOSTR_LIBC        ""
-#endif
-#if defined(__LZO_INFOSTR_CCVER)
-#elif defined(LZO_INFO_CCVER)
-#  define __LZO_INFOSTR_CCVER       " " LZO_INFO_CCVER
-#else
-#  define __LZO_INFOSTR_CCVER       ""
-#endif
-#define LZO_INFO_STRING \
-    LZO_INFO_ARCH __LZO_INFOSTR_MM __LZO_INFOSTR_PM __LZO_INFOSTR_ENDIAN \
-    " " __LZO_INFOSTR_OSNAME __LZO_INFOSTR_LIBC " " LZO_INFO_CC __LZO_INFOSTR_CCVER
-
-#endif
-
-#endif
-
-#undef LZO_HAVE_CONFIG_H
-#include "minilzo.h"
-
-#if !defined(MINILZO_VERSION) || (MINILZO_VERSION != 0x2040)
-#  error "version mismatch in miniLZO source files"
-#endif
-
-#ifdef MINILZO_HAVE_CONFIG_H
-#  define LZO_HAVE_CONFIG_H 1
-#endif
-
-#ifndef __LZO_CONF_H
-#define __LZO_CONF_H 1
-
-#if !defined(__LZO_IN_MINILZO)
-#if (LZO_CFG_FREESTANDING)
-#  define LZO_LIBC_FREESTANDING 1
-#  define LZO_OS_FREESTANDING 1
-#  define ACC_LIBC_FREESTANDING 1
-#  define ACC_OS_FREESTANDING 1
-#endif
-#if (LZO_CFG_NO_UNALIGNED)
-#  define ACC_CFG_NO_UNALIGNED 1
-#endif
-#if (LZO_ARCH_GENERIC)
-#  define ACC_ARCH_GENERIC 1
-#endif
-#if (LZO_ABI_NEUTRAL_ENDIAN)
-#  define ACC_ABI_NEUTRAL_ENDIAN 1
-#endif
-#if (LZO_HAVE_CONFIG_H)
-#  define ACC_CONFIG_NO_HEADER 1
-#endif
-#if defined(LZO_CFG_EXTRA_CONFIG_HEADER)
-#  include LZO_CFG_EXTRA_CONFIG_HEADER
-#endif
-#if defined(__LZOCONF_H) || defined(__LZOCONF_H_INCLUDED)
-#  error "include this file first"
-#endif
-#include "lzo/lzoconf.h"
-#endif
-
-#if (LZO_VERSION < 0x02000) || !defined(__LZOCONF_H_INCLUDED)
-#  error "version mismatch"
-#endif
-
-#if (LZO_CC_BORLANDC && LZO_ARCH_I086)
-#  pragma option -h
-#endif
-
-#if (LZO_CC_MSC && (_MSC_VER >= 1000))
-#  pragma warning(disable: 4127 4701)
-#endif
-#if (LZO_CC_MSC && (_MSC_VER >= 1300))
-#  pragma warning(disable: 4820)
-#  pragma warning(disable: 4514 4710 4711)
-#endif
-
-#if (LZO_CC_SUNPROC)
-#if !defined(__cplusplus)
-#  pragma error_messages(off,E_END_OF_LOOP_CODE_NOT_REACHED)
-#  pragma error_messages(off,E_LOOP_NOT_ENTERED_AT_TOP)
-#  pragma error_messages(off,E_STATEMENT_NOT_REACHED)
-#endif
-#endif
-
-#if (__LZO_MMODEL_HUGE) && !(LZO_HAVE_MM_HUGE_PTR)
-#  error "this should not happen - check defines for __huge"
-#endif
-
-#if defined(__LZO_IN_MINILZO) || defined(LZO_CFG_FREESTANDING)
-#elif (LZO_OS_DOS16 || LZO_OS_OS216 || LZO_OS_WIN16)
-#  define ACC_WANT_ACC_INCD_H 1
-#  define ACC_WANT_ACC_INCE_H 1
-#  define ACC_WANT_ACC_INCI_H 1
-#elif 1
-#  include <string.h>
-#else
-#  define ACC_WANT_ACC_INCD_H 1
-#endif
-
-#if (LZO_ARCH_I086)
-#  define ACC_MM_AHSHIFT        LZO_MM_AHSHIFT
-#  define ACC_PTR_FP_OFF(x)     (((const unsigned __far*)&(x))[0])
-#  define ACC_PTR_FP_SEG(x)     (((const unsigned __far*)&(x))[1])
-#  define ACC_PTR_MK_FP(s,o)    ((void __far*)(((unsigned long)(s)<<16)+(unsigned)(o)))
-#endif
-
-#if !defined(lzo_uintptr_t)
-#  if defined(__LZO_MMODEL_HUGE)
-#    define lzo_uintptr_t       unsigned long
-#  elif 1 && defined(LZO_OS_OS400) && (LZO_SIZEOF_VOID_P == 16)
-#    define __LZO_UINTPTR_T_IS_POINTER 1
-     typedef char*              lzo_uintptr_t;
-#    define lzo_uintptr_t       lzo_uintptr_t
-#  elif (LZO_SIZEOF_SIZE_T == LZO_SIZEOF_VOID_P)
-#    define lzo_uintptr_t       size_t
-#  elif (LZO_SIZEOF_LONG == LZO_SIZEOF_VOID_P)
-#    define lzo_uintptr_t       unsigned long
-#  elif (LZO_SIZEOF_INT == LZO_SIZEOF_VOID_P)
-#    define lzo_uintptr_t       unsigned int
-#  elif (LZO_SIZEOF_LONG_LONG == LZO_SIZEOF_VOID_P)
-#    define lzo_uintptr_t       unsigned long long
-#  else
-#    define lzo_uintptr_t       size_t
-#  endif
-#endif
-LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_uintptr_t) >= sizeof(lzo_voidp))
-
-#if 1 && !defined(LZO_CFG_FREESTANDING)
-#if 1 && !defined(HAVE_STRING_H)
-#define HAVE_STRING_H 1
-#endif
-#if 1 && !defined(HAVE_MEMCMP)
-#define HAVE_MEMCMP 1
-#endif
-#if 1 && !defined(HAVE_MEMCPY)
-#define HAVE_MEMCPY 1
-#endif
-#if 1 && !defined(HAVE_MEMMOVE)
-#define HAVE_MEMMOVE 1
-#endif
-#if 1 && !defined(HAVE_MEMSET)
-#define HAVE_MEMSET 1
-#endif
-#endif
-
-#if 1 && defined(HAVE_STRING_H)
-#include <string.h>
-#endif
-
-#if (LZO_CFG_FREESTANDING)
-#  undef HAVE_MEMCMP
-#  undef HAVE_MEMCPY
-#  undef HAVE_MEMMOVE
-#  undef HAVE_MEMSET
-#endif
-
-#if !(HAVE_MEMCMP)
-#  undef memcmp
-#  define memcmp(a,b,c)         lzo_memcmp(a,b,c)
-#elif !(__LZO_MMODEL_HUGE)
-#  undef lzo_memcmp
-#  define lzo_memcmp(a,b,c)     memcmp(a,b,c)
-#endif
-#if !(HAVE_MEMCPY)
-#  undef memcpy
-#  define memcpy(a,b,c)         lzo_memcpy(a,b,c)
-#elif !(__LZO_MMODEL_HUGE)
-#  undef lzo_memcpy
-#  define lzo_memcpy(a,b,c)     memcpy(a,b,c)
-#endif
-#if !(HAVE_MEMMOVE)
-#  undef memmove
-#  define memmove(a,b,c)        lzo_memmove(a,b,c)
-#elif !(__LZO_MMODEL_HUGE)
-#  undef lzo_memmove
-#  define lzo_memmove(a,b,c)    memmove(a,b,c)
-#endif
-#if !(HAVE_MEMSET)
-#  undef memset
-#  define memset(a,b,c)         lzo_memset(a,b,c)
-#elif !(__LZO_MMODEL_HUGE)
-#  undef lzo_memset
-#  define lzo_memset(a,b,c)     memset(a,b,c)
-#endif
-
-#undef NDEBUG
-#if (LZO_CFG_FREESTANDING)
-#  undef LZO_DEBUG
-#  define NDEBUG 1
-#  undef assert
-#  define assert(e) ((void)0)
-#else
-#  if !defined(LZO_DEBUG)
-#    define NDEBUG 1
-#  endif
-#  include <assert.h>
-#endif
-
-#if 0 && defined(__BOUNDS_CHECKING_ON)
-#  include <unchecked.h>
-#else
-#  define BOUNDS_CHECKING_OFF_DURING(stmt)      stmt
-#  define BOUNDS_CHECKING_OFF_IN_EXPR(expr)     (expr)
-#endif
-
-#if !defined(__lzo_inline)
-#  define __lzo_inline              /*empty*/
-#endif
-#if !defined(__lzo_forceinline)
-#  define __lzo_forceinline         /*empty*/
-#endif
-#if !defined(__lzo_noinline)
-#  define __lzo_noinline            /*empty*/
-#endif
-
-#if (LZO_CFG_PGO)
-#  undef __acc_likely
-#  undef __acc_unlikely
-#  undef __lzo_likely
-#  undef __lzo_unlikely
-#  define __acc_likely(e)       (e)
-#  define __acc_unlikely(e)     (e)
-#  define __lzo_likely(e)       (e)
-#  define __lzo_unlikely(e)     (e)
-#endif
-
-#if 1
-#  define LZO_BYTE(x)       ((unsigned char) (x))
-#else
-#  define LZO_BYTE(x)       ((unsigned char) ((x) & 0xff))
-#endif
-
-#define LZO_MAX(a,b)        ((a) >= (b) ? (a) : (b))
-#define LZO_MIN(a,b)        ((a) <= (b) ? (a) : (b))
-#define LZO_MAX3(a,b,c)     ((a) >= (b) ? LZO_MAX(a,c) : LZO_MAX(b,c))
-#define LZO_MIN3(a,b,c)     ((a) <= (b) ? LZO_MIN(a,c) : LZO_MIN(b,c))
-
-#define lzo_sizeof(type)    ((lzo_uint) (sizeof(type)))
-
-#define LZO_HIGH(array)     ((lzo_uint) (sizeof(array)/sizeof(*(array))))
-
-#define LZO_SIZE(bits)      (1u << (bits))
-#define LZO_MASK(bits)      (LZO_SIZE(bits) - 1)
-
-#define LZO_LSIZE(bits)     (1ul << (bits))
-#define LZO_LMASK(bits)     (LZO_LSIZE(bits) - 1)
-
-#define LZO_USIZE(bits)     ((lzo_uint) 1 << (bits))
-#define LZO_UMASK(bits)     (LZO_USIZE(bits) - 1)
-
-#if !defined(DMUL)
-#if 0
-
-#  define DMUL(a,b) ((lzo_xint) ((lzo_uint32)(a) * (lzo_uint32)(b)))
-#else
-#  define DMUL(a,b) ((lzo_xint) ((a) * (b)))
-#endif
-#endif
-
-#if 1 && !(LZO_CFG_NO_UNALIGNED)
-#if 1 && (LZO_ARCH_AMD64 || LZO_ARCH_I386 || LZO_ARCH_POWERPC)
-#  if (LZO_SIZEOF_SHORT == 2)
-#    define LZO_UNALIGNED_OK_2 1
-#  endif
-#  if (LZO_SIZEOF_INT == 4)
-#    define LZO_UNALIGNED_OK_4 1
-#  endif
-#endif
-#endif
-
-#if defined(LZO_UNALIGNED_OK_2)
-  LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(short) == 2)
-#endif
-#if defined(LZO_UNALIGNED_OK_4)
-  LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_uint32) == 4)
-#elif defined(LZO_ALIGNED_OK_4)
-  LZO_COMPILE_TIME_ASSERT_HEADER(sizeof(lzo_uint32) == 4)
-#endif
-
-#undef COPY4
-#if defined(LZO_UNALIGNED_OK_4) || defined(LZO_ALIGNED_OK_4)
-#  if 1 && defined(ACC_UA_COPY32)
-#    define COPY4(d,s)  ACC_UA_COPY32(d,s)
-#  else
-#    define COPY4(d,s)  (* (__lzo_ua_volatile lzo_uint32p)(__lzo_ua_volatile lzo_voidp)(d) = * (__lzo_ua_volatile const lzo_uint32p)(__lzo_ua_volatile const lzo_voidp)(s))
-#  endif
-#endif
-
-#define MEMCPY8_DS(dest,src,len) \
-    lzo_memcpy(dest,src,len); dest += len; src += len
-
-#define BZERO8_PTR(s,l,n) \
-    lzo_memset((lzo_voidp)(s),0,(lzo_uint)(l)*(n))
-
-#define MEMCPY_DS(dest,src,len) \
-    do *dest++ = *src++; while (--len > 0)
-
-LZO_EXTERN(const lzo_bytep) lzo_copyright(void);
-
-#ifndef __LZO_PTR_H
-#define __LZO_PTR_H 1
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#if !defined(lzo_uintptr_t)
-#  if (__LZO_MMODEL_HUGE)
-#    define lzo_uintptr_t   unsigned long
-#  else
-#    define lzo_uintptr_t   acc_uintptr_t
-#    ifdef __ACC_INTPTR_T_IS_POINTER
-#      define __LZO_UINTPTR_T_IS_POINTER 1
-#    endif
-#  endif
-#endif
-
-#if (LZO_ARCH_I086)
-#define PTR(a)              ((lzo_bytep) (a))
-#define PTR_ALIGNED_4(a)    ((ACC_PTR_FP_OFF(a) & 3) == 0)
-#define PTR_ALIGNED2_4(a,b) (((ACC_PTR_FP_OFF(a) | ACC_PTR_FP_OFF(b)) & 3) == 0)
-#elif (LZO_MM_PVP)
-#define PTR(a)              ((lzo_bytep) (a))
-#define PTR_ALIGNED_8(a)    ((((lzo_uintptr_t)(a)) >> 61) == 0)
-#define PTR_ALIGNED2_8(a,b) ((((lzo_uintptr_t)(a)|(lzo_uintptr_t)(b)) >> 61) == 0)
-#else
-#define PTR(a)              ((lzo_uintptr_t) (a))
-#define PTR_LINEAR(a)       PTR(a)
-#define PTR_ALIGNED_4(a)    ((PTR_LINEAR(a) & 3) == 0)
-#define PTR_ALIGNED_8(a)    ((PTR_LINEAR(a) & 7) == 0)
-#define PTR_ALIGNED2_4(a,b) (((PTR_LINEAR(a) | PTR_LINEAR(b)) & 3) == 0)
-#define PTR_ALIGNED2_8(a,b) (((PTR_LINEAR(a) | PTR_LINEAR(b)) & 7) == 0)
-#endif
-
-#define PTR_LT(a,b)         (PTR(a) < PTR(b))
-#define PTR_GE(a,b)         (PTR(a) >= PTR(b))
-#define PTR_DIFF(a,b)       (PTR(a) - PTR(b))
-#define pd(a,b)             ((lzo_uint) ((a)-(b)))
-
-LZO_EXTERN(lzo_uintptr_t)
-__lzo_ptr_linear(const lzo_voidp ptr);
-
-typedef union
-{
-    char            a_char;
-    unsigned char   a_uchar;
-    short           a_short;
-    unsigned short  a_ushort;
-    int             a_int;
-    unsigned int    a_uint;
-    long            a_long;
-    unsigned long   a_ulong;
-    lzo_int         a_lzo_int;
-    lzo_uint        a_lzo_uint;
-    lzo_int32       a_lzo_int32;
-    lzo_uint32      a_lzo_uint32;
-    ptrdiff_t       a_ptrdiff_t;
-    lzo_uintptr_t   a_lzo_uintptr_t;
-    lzo_voidp       a_lzo_voidp;
-    void *          a_void_p;
-    lzo_bytep       a_lzo_bytep;
-    lzo_bytepp      a_lzo_bytepp;
-    lzo_uintp       a_lzo_uintp;
-    lzo_uint *      a_lzo_uint_p;
-    lzo_uint32p     a_lzo_uint32p;
-    lzo_uint32 *    a_lzo_uint32_p;
-    unsigned char * a_uchar_p;
-    char *          a_char_p;
-}
-lzo_full_align_t;
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
-
-#define LZO_DETERMINISTIC 1
-
-#define LZO_DICT_USE_PTR 1
-#if 0 && (LZO_ARCH_I086)
-#  undef LZO_DICT_USE_PTR
-#endif
-
-#if (LZO_DICT_USE_PTR)
-#  define lzo_dict_t    const lzo_bytep
-#  define lzo_dict_p    lzo_dict_t __LZO_MMODEL *
-#else
-#  define lzo_dict_t    lzo_uint
-#  define lzo_dict_p    lzo_dict_t __LZO_MMODEL *
-#endif
-
-#endif
-
-#if !defined(MINILZO_CFG_SKIP_LZO_PTR)
-
-LZO_PUBLIC(lzo_uintptr_t)
-__lzo_ptr_linear(const lzo_voidp ptr)
-{
-    lzo_uintptr_t p;
-
-#if (LZO_ARCH_I086)
-    p = (((lzo_uintptr_t)(ACC_PTR_FP_SEG(ptr))) << (16 - ACC_MM_AHSHIFT)) + (ACC_PTR_FP_OFF(ptr));
-#elif (LZO_MM_PVP)
-    p = (lzo_uintptr_t) (ptr);
-    p = (p << 3) | (p >> 61);
-#else
-    p = (lzo_uintptr_t) PTR_LINEAR(ptr);
-#endif
-
-    return p;
-}
-
-LZO_PUBLIC(unsigned)
-__lzo_align_gap(const lzo_voidp ptr, lzo_uint size)
-{
-#if defined(__LZO_UINTPTR_T_IS_POINTER)
-    size_t n = (size_t) ptr;
-    n = (((n + size - 1) / size) * size) - n;
-#else
-    lzo_uintptr_t p, n;
-    p = __lzo_ptr_linear(ptr);
-    n = (((p + size - 1) / size) * size) - p;
-#endif
-
-    assert(size > 0);
-    assert((long)n >= 0);
-    assert(n <= size);
-    return (unsigned)n;
-}
-
-#endif
-#if !defined(MINILZO_CFG_SKIP_LZO_UTIL)
-
-/* If you use the LZO library in a product, I would appreciate that you
- * keep this copyright string in the executable of your product.
- */
-
-static const char __lzo_copyright[] =
-#if !defined(__LZO_IN_MINLZO)
-    LZO_VERSION_STRING;
-#else
-    "\r\n\n"
-    "LZO data compression library.\n"
-    "$Copyright: LZO Copyright (C) 1996-2010 Markus Franz Xaver Johannes Oberhumer\n"
-    "<markus@oberhumer.com>\n"
-    "http://www.oberhumer.com $\n\n"
-    "$Id: LZO version: v" LZO_VERSION_STRING ", " LZO_VERSION_DATE " $\n"
-    "$Info: " LZO_INFO_STRING " $\n";
-#endif
-
-LZO_PUBLIC(const lzo_bytep)
-lzo_copyright(void)
-{
-#if (LZO_OS_DOS16 && LZO_CC_TURBOC)
-    return (lzo_voidp) __lzo_copyright;
-#else
-    return (const lzo_bytep) __lzo_copyright;
-#endif
-}
-
-LZO_PUBLIC(unsigned)
-lzo_version(void)
-{
-    return LZO_VERSION;
-}
-
-LZO_PUBLIC(const char *)
-lzo_version_string(void)
-{
-    return LZO_VERSION_STRING;
-}
-
-LZO_PUBLIC(const char *)
-lzo_version_date(void)
-{
-    return LZO_VERSION_DATE;
-}
-
-LZO_PUBLIC(const lzo_charp)
-_lzo_version_string(void)
-{
-    return LZO_VERSION_STRING;
-}
-
-LZO_PUBLIC(const lzo_charp)
-_lzo_version_date(void)
-{
-    return LZO_VERSION_DATE;
-}
-
-#define LZO_BASE 65521u
-#define LZO_NMAX 5552
-
-#define LZO_DO1(buf,i)  s1 += buf[i]; s2 += s1
-#define LZO_DO2(buf,i)  LZO_DO1(buf,i); LZO_DO1(buf,i+1);
-#define LZO_DO4(buf,i)  LZO_DO2(buf,i); LZO_DO2(buf,i+2);
-#define LZO_DO8(buf,i)  LZO_DO4(buf,i); LZO_DO4(buf,i+4);
-#define LZO_DO16(buf,i) LZO_DO8(buf,i); LZO_DO8(buf,i+8);
-
-LZO_PUBLIC(lzo_uint32)
-lzo_adler32(lzo_uint32 adler, const lzo_bytep buf, lzo_uint len)
-{
-    lzo_uint32 s1 = adler & 0xffff;
-    lzo_uint32 s2 = (adler >> 16) & 0xffff;
-    unsigned k;
-
-    if (buf == NULL)
-        return 1;
-
-    while (len > 0)
-    {
-        k = len < LZO_NMAX ? (unsigned) len : LZO_NMAX;
-        len -= k;
-        if (k >= 16) do
-        {
-            LZO_DO16(buf,0);
-            buf += 16;
-            k -= 16;
-        } while (k >= 16);
-        if (k != 0) do
-        {
-            s1 += *buf++;
-            s2 += s1;
-        } while (--k > 0);
-        s1 %= LZO_BASE;
-        s2 %= LZO_BASE;
-    }
-    return (s2 << 16) | s1;
-}
-
-#undef LZO_DO1
-#undef LZO_DO2
-#undef LZO_DO4
-#undef LZO_DO8
-#undef LZO_DO16
-
-#endif
-#if !defined(MINILZO_CFG_SKIP_LZO_STRING)
-#undef lzo_memcmp
-#undef lzo_memcpy
-#undef lzo_memmove
-#undef lzo_memset
-#if !defined(__LZO_MMODEL_HUGE)
-#  undef LZO_HAVE_MM_HUGE_PTR
-#endif
-#define lzo_hsize_t             lzo_uint
-#define lzo_hvoid_p             lzo_voidp
-#define lzo_hbyte_p             lzo_bytep
-#define LZOLIB_PUBLIC(r,f)      LZO_PUBLIC(r) f
-#define lzo_hmemcmp             lzo_memcmp
-#define lzo_hmemcpy             lzo_memcpy
-#define lzo_hmemmove            lzo_memmove
-#define lzo_hmemset             lzo_memset
-#define __LZOLIB_HMEMCPY_CH_INCLUDED 1
-#if !defined(LZOLIB_PUBLIC)
-#  define LZOLIB_PUBLIC(r,f)    r __LZOLIB_FUNCNAME(f)
-#endif
-LZOLIB_PUBLIC(int, lzo_hmemcmp) (const lzo_hvoid_p s1, const lzo_hvoid_p s2, lzo_hsize_t len)
-{
-#if (LZO_HAVE_MM_HUGE_PTR) || !(HAVE_MEMCMP)
-    const lzo_hbyte_p p1 = (const lzo_hbyte_p) s1;
-    const lzo_hbyte_p p2 = (const lzo_hbyte_p) s2;
-    if __lzo_likely(len > 0) do
-    {
-        int d = *p1 - *p2;
-        if (d != 0)
-            return d;
-        p1++; p2++;
-    } while __lzo_likely(--len > 0);
-    return 0;
-#else
-    return memcmp(s1, s2, len);
-#endif
-}
-LZOLIB_PUBLIC(lzo_hvoid_p, lzo_hmemcpy) (lzo_hvoid_p dest, const lzo_hvoid_p src, lzo_hsize_t len)
-{
-#if (LZO_HAVE_MM_HUGE_PTR) || !(HAVE_MEMCPY)
-    lzo_hbyte_p p1 = (lzo_hbyte_p) dest;
-    const lzo_hbyte_p p2 = (const lzo_hbyte_p) src;
-    if (!(len > 0) || p1 == p2)
-        return dest;
-    do
-        *p1++ = *p2++;
-    while __lzo_likely(--len > 0);
-    return dest;
-#else
-    return memcpy(dest, src, len);
-#endif
-}
-LZOLIB_PUBLIC(lzo_hvoid_p, lzo_hmemmove) (lzo_hvoid_p dest, const lzo_hvoid_p src, lzo_hsize_t len)
-{
-#if (LZO_HAVE_MM_HUGE_PTR) || !(HAVE_MEMMOVE)
-    lzo_hbyte_p p1 = (lzo_hbyte_p) dest;
-    const lzo_hbyte_p p2 = (const lzo_hbyte_p) src;
-    if (!(len > 0) || p1 == p2)
-        return dest;
-    if (p1 < p2)
-    {
-        do
-            *p1++ = *p2++;
-        while __lzo_likely(--len > 0);
-    }
-    else
-    {
-        p1 += len;
-        p2 += len;
-        do
-            *--p1 = *--p2;
-        while __lzo_likely(--len > 0);
-    }
-    return dest;
-#else
-    return memmove(dest, src, len);
-#endif
-}
-LZOLIB_PUBLIC(lzo_hvoid_p, lzo_hmemset) (lzo_hvoid_p s, int c, lzo_hsize_t len)
-{
-#if (LZO_HAVE_MM_HUGE_PTR) || !(HAVE_MEMSET)
-    lzo_hbyte_p p = (lzo_hbyte_p) s;
-    if __lzo_likely(len > 0) do
-        *p++ = (unsigned char) c;
-    while __lzo_likely(--len > 0);
-    return s;
-#else
-    return memset(s, c, len);
-#endif
-}
-#undef LZOLIB_PUBLIC
-#endif
-#if !defined(MINILZO_CFG_SKIP_LZO_INIT)
-
-#if !defined(__LZO_IN_MINILZO)
-
-#define ACC_WANT_ACC_CHK_CH 1
-#undef ACCCHK_ASSERT
-
-    ACCCHK_ASSERT_IS_SIGNED_T(lzo_int)
-    ACCCHK_ASSERT_IS_UNSIGNED_T(lzo_uint)
-
-    ACCCHK_ASSERT_IS_SIGNED_T(lzo_int32)
-    ACCCHK_ASSERT_IS_UNSIGNED_T(lzo_uint32)
-    ACCCHK_ASSERT((LZO_UINT32_C(1) << (int)(8*sizeof(LZO_UINT32_C(1))-1)) > 0)
-    ACCCHK_ASSERT(sizeof(lzo_uint32) >= 4)
-
-#if !defined(__LZO_UINTPTR_T_IS_POINTER)
-    ACCCHK_ASSERT_IS_UNSIGNED_T(lzo_uintptr_t)
-#endif
-    ACCCHK_ASSERT(sizeof(lzo_uintptr_t) >= sizeof(lzo_voidp))
-
-    ACCCHK_ASSERT_IS_UNSIGNED_T(lzo_xint)
-    ACCCHK_ASSERT(sizeof(lzo_xint) >= sizeof(lzo_uint32))
-    ACCCHK_ASSERT(sizeof(lzo_xint) >= sizeof(lzo_uint))
-    ACCCHK_ASSERT(sizeof(lzo_xint) == sizeof(lzo_uint32) || sizeof(lzo_xint) == sizeof(lzo_uint))
-
-#endif
-#undef ACCCHK_ASSERT
-
-#if 0
-#define u2p(ptr,off) ((lzo_voidp) (((lzo_bytep)(lzo_voidp)(ptr)) + (off)))
-#else
-static __lzo_noinline lzo_voidp u2p(lzo_voidp ptr, lzo_uint off)
-{
-    return (lzo_voidp) ((lzo_bytep) ptr + off);
-}
-#endif
-
-LZO_PUBLIC(int)
-_lzo_config_check(void)
-{
-    lzo_bool r = 1;
-    union {
-        lzo_xint a[2]; unsigned char b[2*sizeof(lzo_xint)];
-        unsigned short x[2]; lzo_uint32 y[2]; lzo_uint z[2];
-    } u;
-    lzo_voidp p;
-
-    u.a[0] = u.a[1] = 0;
-    p = u2p(&u, 0);
-    r &= ((* (lzo_bytep) p) == 0);
-#if !defined(LZO_CFG_NO_CONFIG_CHECK)
-#if defined(LZO_ABI_BIG_ENDIAN)
-    u.a[0] = u.a[1] = 0; u.b[sizeof(lzo_uint) - 1] = 128;
-    p = u2p(&u, 0);
-    r &= ((* (lzo_uintp) p) == 128);
-#endif
-#if defined(LZO_ABI_LITTLE_ENDIAN)
-    u.a[0] = u.a[1] = 0; u.b[0] = 128;
-    p = u2p(&u, 0);
-    r &= ((* (lzo_uintp) p) == 128);
-#endif
-#if defined(LZO_UNALIGNED_OK_2)
-    u.a[0] = u.a[1] = 0;
-    u.b[0] = 1; u.b[sizeof(unsigned short) + 1] = 2;
-    p = u2p(&u, 1);
-    r &= ((* (lzo_ushortp) p) == 0);
-#endif
-#if defined(LZO_UNALIGNED_OK_4)
-    u.a[0] = u.a[1] = 0;
-    u.b[0] = 3; u.b[sizeof(lzo_uint32) + 1] = 4;
-    p = u2p(&u, 1);
-    r &= ((* (lzo_uint32p) p) == 0);
-#endif
-#endif
-
-    return r == 1 ? LZO_E_OK : LZO_E_ERROR;
-}
-
-LZO_PUBLIC(int)
-__lzo_init_v2(unsigned v, int s1, int s2, int s3, int s4, int s5,
-                          int s6, int s7, int s8, int s9)
-{
-    int r;
-
-#if defined(__LZO_IN_MINILZO)
-#elif (LZO_CC_MSC && ((_MSC_VER) < 700))
-#else
-#define ACC_WANT_ACC_CHK_CH 1
-#undef ACCCHK_ASSERT
-#define ACCCHK_ASSERT(expr)  LZO_COMPILE_TIME_ASSERT(expr)
-#endif
-#undef ACCCHK_ASSERT
-
-    if (v == 0)
-        return LZO_E_ERROR;
-
-    r = (s1 == -1 || s1 == (int) sizeof(short)) &&
-        (s2 == -1 || s2 == (int) sizeof(int)) &&
-        (s3 == -1 || s3 == (int) sizeof(long)) &&
-        (s4 == -1 || s4 == (int) sizeof(lzo_uint32)) &&
-        (s5 == -1 || s5 == (int) sizeof(lzo_uint)) &&
-        (s6 == -1 || s6 == (int) lzo_sizeof_dict_t) &&
-        (s7 == -1 || s7 == (int) sizeof(char *)) &&
-        (s8 == -1 || s8 == (int) sizeof(lzo_voidp)) &&
-        (s9 == -1 || s9 == (int) sizeof(lzo_callback_t));
-    if (!r)
-        return LZO_E_ERROR;
-
-    r = _lzo_config_check();
-    if (r != LZO_E_OK)
-        return r;
-
-    return r;
-}
-
-#if !defined(__LZO_IN_MINILZO)
-
-#if (LZO_OS_WIN16 && LZO_CC_WATCOMC) && defined(__SW_BD)
-
-#if 0
-BOOL FAR PASCAL LibMain ( HANDLE hInstance, WORD wDataSegment,
-                          WORD wHeapSize, LPSTR lpszCmdLine )
-#else
-int __far __pascal LibMain ( int a, short b, short c, long d )
-#endif
-{
-    LZO_UNUSED(a); LZO_UNUSED(b); LZO_UNUSED(c); LZO_UNUSED(d);
-    return 1;
-}
-
-#endif
-
-#endif
-
-#endif
-
-#define LZO1X           1
-#define LZO_EOF_CODE    1
-#define M2_MAX_OFFSET   0x0800
-
-#if !defined(MINILZO_CFG_SKIP_LZO1X_1_COMPRESS)
-
-#define LZO_NEED_DICT_H 1
-#define D_BITS          14
-#define D_INDEX1(d,p)       d = DM(DMUL(0x21,DX3(p,5,5,6)) >> 5)
-#define D_INDEX2(d,p)       d = (d & (D_MASK & 0x7ff)) ^ (D_HIGH | 0x1f)
-
-#ifndef __LZO_CONFIG1X_H
-#define __LZO_CONFIG1X_H 1
-
-#if !defined(LZO1X) && !defined(LZO1Y) && !defined(LZO1Z)
-#  define LZO1X 1
-#endif
-
-#if !defined(__LZO_IN_MINILZO)
-#include "lzo/lzo1x.h"
-#endif
-
-#ifndef LZO_EOF_CODE
-#define LZO_EOF_CODE 1
-#endif
-#undef LZO_DETERMINISTIC
-
-#define M1_MAX_OFFSET   0x0400
-#ifndef M2_MAX_OFFSET
-#define M2_MAX_OFFSET   0x0800
-#endif
-#define M3_MAX_OFFSET   0x4000
-#define M4_MAX_OFFSET   0xbfff
-
-#define MX_MAX_OFFSET   (M1_MAX_OFFSET + M2_MAX_OFFSET)
-
-#define M1_MIN_LEN      2
-#define M1_MAX_LEN      2
-#define M2_MIN_LEN      3
-#ifndef M2_MAX_LEN
-#define M2_MAX_LEN      8
-#endif
-#define M3_MIN_LEN      3
-#define M3_MAX_LEN      33
-#define M4_MIN_LEN      3
-#define M4_MAX_LEN      9
-
-#define M1_MARKER       0
-#define M2_MARKER       64
-#define M3_MARKER       32
-#define M4_MARKER       16
-
-#ifndef MIN_LOOKAHEAD
-#define MIN_LOOKAHEAD       (M2_MAX_LEN + 1)
-#endif
-
-#if defined(LZO_NEED_DICT_H)
-
-#ifndef LZO_HASH
-#define LZO_HASH            LZO_HASH_LZO_INCREMENTAL_B
-#endif
-#define DL_MIN_LEN          M2_MIN_LEN
-
-#ifndef __LZO_DICT_H
-#define __LZO_DICT_H 1
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#if !defined(D_BITS) && defined(DBITS)
-#  define D_BITS        DBITS
-#endif
-#if !defined(D_BITS)
-#  error "D_BITS is not defined"
-#endif
-#if (D_BITS < 16)
-#  define D_SIZE        LZO_SIZE(D_BITS)
-#  define D_MASK        LZO_MASK(D_BITS)
-#else
-#  define D_SIZE        LZO_USIZE(D_BITS)
-#  define D_MASK        LZO_UMASK(D_BITS)
-#endif
-#define D_HIGH          ((D_MASK >> 1) + 1)
-
-#if !defined(DD_BITS)
-#  define DD_BITS       0
-#endif
-#define DD_SIZE         LZO_SIZE(DD_BITS)
-#define DD_MASK         LZO_MASK(DD_BITS)
-
-#if !defined(DL_BITS)
-#  define DL_BITS       (D_BITS - DD_BITS)
-#endif
-#if (DL_BITS < 16)
-#  define DL_SIZE       LZO_SIZE(DL_BITS)
-#  define DL_MASK       LZO_MASK(DL_BITS)
-#else
-#  define DL_SIZE       LZO_USIZE(DL_BITS)
-#  define DL_MASK       LZO_UMASK(DL_BITS)
-#endif
-
-#if (D_BITS != DL_BITS + DD_BITS)
-#  error "D_BITS does not match"
-#endif
-#if (D_BITS < 6 || D_BITS > 18)
-#  error "invalid D_BITS"
-#endif
-#if (DL_BITS < 6 || DL_BITS > 20)
-#  error "invalid DL_BITS"
-#endif
-#if (DD_BITS < 0 || DD_BITS > 6)
-#  error "invalid DD_BITS"
-#endif
-
-#if !defined(DL_MIN_LEN)
-#  define DL_MIN_LEN    3
-#endif
-#if !defined(DL_SHIFT)
-#  define DL_SHIFT      ((DL_BITS + (DL_MIN_LEN - 1)) / DL_MIN_LEN)
-#endif
-
-#define LZO_HASH_GZIP                   1
-#define LZO_HASH_GZIP_INCREMENTAL       2
-#define LZO_HASH_LZO_INCREMENTAL_A      3
-#define LZO_HASH_LZO_INCREMENTAL_B      4
-
-#if !defined(LZO_HASH)
-#  error "choose a hashing strategy"
-#endif
-
-#undef DM
-#undef DX
-
-#if (DL_MIN_LEN == 3)
-#  define _DV2_A(p,shift1,shift2) \
-        (((( (lzo_xint)((p)[0]) << shift1) ^ (p)[1]) << shift2) ^ (p)[2])
-#  define _DV2_B(p,shift1,shift2) \
-        (((( (lzo_xint)((p)[2]) << shift1) ^ (p)[1]) << shift2) ^ (p)[0])
-#  define _DV3_B(p,shift1,shift2,shift3) \
-        ((_DV2_B((p)+1,shift1,shift2) << (shift3)) ^ (p)[0])
-#elif (DL_MIN_LEN == 2)
-#  define _DV2_A(p,shift1,shift2) \
-        (( (lzo_xint)(p[0]) << shift1) ^ p[1])
-#  define _DV2_B(p,shift1,shift2) \
-        (( (lzo_xint)(p[1]) << shift1) ^ p[2])
-#else
-#  error "invalid DL_MIN_LEN"
-#endif
-#define _DV_A(p,shift)      _DV2_A(p,shift,shift)
-#define _DV_B(p,shift)      _DV2_B(p,shift,shift)
-#define DA2(p,s1,s2) \
-        (((((lzo_xint)((p)[2]) << (s2)) + (p)[1]) << (s1)) + (p)[0])
-#define DS2(p,s1,s2) \
-        (((((lzo_xint)((p)[2]) << (s2)) - (p)[1]) << (s1)) - (p)[0])
-#define DX2(p,s1,s2) \
-        (((((lzo_xint)((p)[2]) << (s2)) ^ (p)[1]) << (s1)) ^ (p)[0])
-#define DA3(p,s1,s2,s3) ((DA2((p)+1,s2,s3) << (s1)) + (p)[0])
-#define DS3(p,s1,s2,s3) ((DS2((p)+1,s2,s3) << (s1)) - (p)[0])
-#define DX3(p,s1,s2,s3) ((DX2((p)+1,s2,s3) << (s1)) ^ (p)[0])
-#define DMS(v,s)        ((lzo_uint) (((v) & (D_MASK >> (s))) << (s)))
-#define DM(v)           DMS(v,0)
-
-#if (LZO_HASH == LZO_HASH_GZIP)
-#  define _DINDEX(dv,p)     (_DV_A((p),DL_SHIFT))
-
-#elif (LZO_HASH == LZO_HASH_GZIP_INCREMENTAL)
-#  define __LZO_HASH_INCREMENTAL 1
-#  define DVAL_FIRST(dv,p)  dv = _DV_A((p),DL_SHIFT)
-#  define DVAL_NEXT(dv,p)   dv = (((dv) << DL_SHIFT) ^ p[2])
-#  define _DINDEX(dv,p)     (dv)
-#  define DVAL_LOOKAHEAD    DL_MIN_LEN
-
-#elif (LZO_HASH == LZO_HASH_LZO_INCREMENTAL_A)
-#  define __LZO_HASH_INCREMENTAL 1
-#  define DVAL_FIRST(dv,p)  dv = _DV_A((p),5)
-#  define DVAL_NEXT(dv,p) \
-                dv ^= (lzo_xint)(p[-1]) << (2*5); dv = (((dv) << 5) ^ p[2])
-#  define _DINDEX(dv,p)     ((DMUL(0x9f5f,dv)) >> 5)
-#  define DVAL_LOOKAHEAD    DL_MIN_LEN
-
-#elif (LZO_HASH == LZO_HASH_LZO_INCREMENTAL_B)
-#  define __LZO_HASH_INCREMENTAL 1
-#  define DVAL_FIRST(dv,p)  dv = _DV_B((p),5)
-#  define DVAL_NEXT(dv,p) \
-                dv ^= p[-1]; dv = (((dv) >> 5) ^ ((lzo_xint)(p[2]) << (2*5)))
-#  define _DINDEX(dv,p)     ((DMUL(0x9f5f,dv)) >> 5)
-#  define DVAL_LOOKAHEAD    DL_MIN_LEN
-
-#else
-#  error "choose a hashing strategy"
-#endif
-
-#ifndef DINDEX
-#define DINDEX(dv,p)        ((lzo_uint)((_DINDEX(dv,p)) & DL_MASK) << DD_BITS)
-#endif
-#if !defined(DINDEX1) && defined(D_INDEX1)
-#define DINDEX1             D_INDEX1
-#endif
-#if !defined(DINDEX2) && defined(D_INDEX2)
-#define DINDEX2             D_INDEX2
-#endif
-
-#if !defined(__LZO_HASH_INCREMENTAL)
-#  define DVAL_FIRST(dv,p)  ((void) 0)
-#  define DVAL_NEXT(dv,p)   ((void) 0)
-#  define DVAL_LOOKAHEAD    0
-#endif
-
-#if !defined(DVAL_ASSERT)
-#if defined(__LZO_HASH_INCREMENTAL) && !defined(NDEBUG)
-#if (LZO_CC_CLANG || (LZO_CC_GNUC >= 0x020700ul) || LZO_CC_LLVM)
-static void __attribute__((__unused__))
-#else
-static void
-#endif
-DVAL_ASSERT(lzo_xint dv, const lzo_bytep p)
-{
-    lzo_xint df;
-    DVAL_FIRST(df,(p));
-    assert(DINDEX(dv,p) == DINDEX(df,p));
-}
-#else
-#  define DVAL_ASSERT(dv,p) ((void) 0)
-#endif
-#endif
-
-#if defined(LZO_DICT_USE_PTR)
-#  define DENTRY(p,in)                          (p)
-#  define GINDEX(m_pos,m_off,dict,dindex,in)    m_pos = dict[dindex]
-#else
-#  define DENTRY(p,in)                          ((lzo_uint) ((p)-(in)))
-#  define GINDEX(m_pos,m_off,dict,dindex,in)    m_off = dict[dindex]
-#endif
-
-#if (DD_BITS == 0)
-
-#  define UPDATE_D(dict,drun,dv,p,in)       dict[ DINDEX(dv,p) ] = DENTRY(p,in)
-#  define UPDATE_I(dict,drun,index,p,in)    dict[index] = DENTRY(p,in)
-#  define UPDATE_P(ptr,drun,p,in)           (ptr)[0] = DENTRY(p,in)
-
-#else
-
-#  define UPDATE_D(dict,drun,dv,p,in)   \
-        dict[ DINDEX(dv,p) + drun++ ] = DENTRY(p,in); drun &= DD_MASK
-#  define UPDATE_I(dict,drun,index,p,in)    \
-        dict[ (index) + drun++ ] = DENTRY(p,in); drun &= DD_MASK
-#  define UPDATE_P(ptr,drun,p,in)   \
-        (ptr) [ drun++ ] = DENTRY(p,in); drun &= DD_MASK
-
-#endif
-
-#if defined(LZO_DICT_USE_PTR)
-
-#define LZO_CHECK_MPOS_DET(m_pos,m_off,in,ip,max_offset) \
-        (m_pos == NULL || (m_off = pd(ip, m_pos)) > max_offset)
-
-#define LZO_CHECK_MPOS_NON_DET(m_pos,m_off,in,ip,max_offset) \
-    (BOUNDS_CHECKING_OFF_IN_EXPR(( \
-        m_pos = ip - (lzo_uint) PTR_DIFF(ip,m_pos), \
-        PTR_LT(m_pos,in) || \
-        (m_off = (lzo_uint) PTR_DIFF(ip,m_pos)) == 0 || \
-         m_off > max_offset )))
-
-#else
-
-#define LZO_CHECK_MPOS_DET(m_pos,m_off,in,ip,max_offset) \
-        (m_off == 0 || \
-         ((m_off = pd(ip, in) - m_off) > max_offset) || \
-         (m_pos = (ip) - (m_off), 0) )
-
-#define LZO_CHECK_MPOS_NON_DET(m_pos,m_off,in,ip,max_offset) \
-        (pd(ip, in) <= m_off || \
-         ((m_off = pd(ip, in) - m_off) > max_offset) || \
-         (m_pos = (ip) - (m_off), 0) )
-
-#endif
-
-#if defined(LZO_DETERMINISTIC)
-#  define LZO_CHECK_MPOS    LZO_CHECK_MPOS_DET
-#else
-#  define LZO_CHECK_MPOS    LZO_CHECK_MPOS_NON_DET
-#endif
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
-
-#endif
-
-#endif
-
-#define do_compress     _lzo1x_1_do_compress
-#define DO_COMPRESS     lzo1x_1_compress
-
-#if 1 && defined(DO_COMPRESS) && !defined(do_compress)
-#  define do_compress       LZO_CPP_ECONCAT2(DO_COMPRESS,_core)
-#endif
-
-static __lzo_noinline lzo_uint
-do_compress ( const lzo_bytep in , lzo_uint  in_len,
-                    lzo_bytep out, lzo_uintp out_len,
-                    lzo_voidp wrkmem )
-{
-    register const lzo_bytep ip;
-    lzo_bytep op;
-    const lzo_bytep const in_end = in + in_len;
-    const lzo_bytep const ip_end = in + in_len - M2_MAX_LEN - 5;
-    const lzo_bytep ii;
-    lzo_dict_p const dict = (lzo_dict_p) wrkmem;
-
-    op = out;
-    ip = in;
-    ii = ip;
-
-    ip += 4;
-    for (;;)
-    {
-        register const lzo_bytep m_pos;
-        LZO_DEFINE_UNINITIALIZED_VAR(lzo_uint, m_off, 0);
-        lzo_uint m_len;
-        lzo_uint dindex;
-
-        DINDEX1(dindex,ip);
-        GINDEX(m_pos,m_off,dict,dindex,in);
-        if (LZO_CHECK_MPOS_NON_DET(m_pos,m_off,in,ip,M4_MAX_OFFSET))
-            goto literal;
-#if 1
-        if (m_off <= M2_MAX_OFFSET || m_pos[3] == ip[3])
-            goto try_match;
-        DINDEX2(dindex,ip);
-#endif
-        GINDEX(m_pos,m_off,dict,dindex,in);
-        if (LZO_CHECK_MPOS_NON_DET(m_pos,m_off,in,ip,M4_MAX_OFFSET))
-            goto literal;
-        if (m_off <= M2_MAX_OFFSET || m_pos[3] == ip[3])
-            goto try_match;
-        goto literal;
-
-try_match:
-#if 1 && defined(LZO_UNALIGNED_OK_2)
-        if (* (const lzo_ushortp) (const lzo_voidp) m_pos != * (const lzo_ushortp) (const lzo_voidp) ip)
-#else
-        if (m_pos[0] != ip[0] || m_pos[1] != ip[1])
-#endif
-        {
-        }
-        else
-        {
-            if __lzo_likely(m_pos[2] == ip[2])
-            {
-#if 0
-                if (m_off <= M2_MAX_OFFSET)
-                    goto match;
-                if (lit <= 3)
-                    goto match;
-                if (lit == 3)
-                {
-                    assert(op - 2 > out); op[-2] |= LZO_BYTE(3);
-                    *op++ = *ii++; *op++ = *ii++; *op++ = *ii++;
-                    goto code_match;
-                }
-                if (m_pos[3] == ip[3])
-#endif
-                    goto match;
-            }
-            else
-            {
-#if 0
-#if 0
-                if (m_off <= M1_MAX_OFFSET && lit > 0 && lit <= 3)
-#else
-                if (m_off <= M1_MAX_OFFSET && lit == 3)
-#endif
-                {
-                    register lzo_uint t;
-
-                    t = lit;
-                    assert(op - 2 > out); op[-2] |= LZO_BYTE(t);
-                    do *op++ = *ii++; while (--t > 0);
-                    assert(ii == ip);
-                    m_off -= 1;
-                    *op++ = LZO_BYTE(M1_MARKER | ((m_off & 3) << 2));
-                    *op++ = LZO_BYTE(m_off >> 2);
-                    ip += 2;
-                    goto match_done;
-                }
-#endif
-            }
-        }
-
-literal:
-        UPDATE_I(dict,0,dindex,ip,in);
-        ++ip;
-        if __lzo_unlikely(ip >= ip_end)
-            break;
-        continue;
-
-match:
-        UPDATE_I(dict,0,dindex,ip,in);
-        if (pd(ip,ii) > 0)
-        {
-            register lzo_uint t = pd(ip,ii);
-
-            if (t <= 3)
-            {
-                assert(op - 2 > out);
-                op[-2] |= LZO_BYTE(t);
-            }
-            else if (t <= 18)
-                *op++ = LZO_BYTE(t - 3);
-            else
-            {
-                register lzo_uint tt = t - 18;
-
-                *op++ = 0;
-                while (tt > 255)
-                {
-                    tt -= 255;
-                    *op++ = 0;
-                }
-                assert(tt > 0);
-                *op++ = LZO_BYTE(tt);
-            }
-            do *op++ = *ii++; while (--t > 0);
-        }
-
-        assert(ii == ip);
-        ip += 3;
-        if (m_pos[3] != *ip++ || m_pos[4] != *ip++ || m_pos[5] != *ip++ ||
-            m_pos[6] != *ip++ || m_pos[7] != *ip++ || m_pos[8] != *ip++
-#ifdef LZO1Y
-            || m_pos[ 9] != *ip++ || m_pos[10] != *ip++ || m_pos[11] != *ip++
-            || m_pos[12] != *ip++ || m_pos[13] != *ip++ || m_pos[14] != *ip++
-#endif
-           )
-        {
-            --ip;
-            m_len = pd(ip, ii);
-            assert(m_len >= 3); assert(m_len <= M2_MAX_LEN);
-
-            if (m_off <= M2_MAX_OFFSET)
-            {
-                m_off -= 1;
-#if defined(LZO1X)
-                *op++ = LZO_BYTE(((m_len - 1) << 5) | ((m_off & 7) << 2));
-                *op++ = LZO_BYTE(m_off >> 3);
-#elif defined(LZO1Y)
-                *op++ = LZO_BYTE(((m_len + 1) << 4) | ((m_off & 3) << 2));
-                *op++ = LZO_BYTE(m_off >> 2);
-#endif
-            }
-            else if (m_off <= M3_MAX_OFFSET)
-            {
-                m_off -= 1;
-                *op++ = LZO_BYTE(M3_MARKER | (m_len - 2));
-                goto m3_m4_offset;
-            }
-            else
-#if defined(LZO1X)
-            {
-                m_off -= 0x4000;
-                assert(m_off > 0); assert(m_off <= 0x7fff);
-                *op++ = LZO_BYTE(M4_MARKER |
-                                 ((m_off & 0x4000) >> 11) | (m_len - 2));
-                goto m3_m4_offset;
-            }
-#elif defined(LZO1Y)
-                goto m4_match;
-#endif
-        }
-        else
-        {
-            {
-                const lzo_bytep end = in_end;
-                const lzo_bytep m = m_pos + M2_MAX_LEN + 1;
-                while (ip < end && *m == *ip)
-                    m++, ip++;
-                m_len = pd(ip, ii);
-            }
-            assert(m_len > M2_MAX_LEN);
-
-            if (m_off <= M3_MAX_OFFSET)
-            {
-                m_off -= 1;
-                if (m_len <= 33)
-                    *op++ = LZO_BYTE(M3_MARKER | (m_len - 2));
-                else
-                {
-                    m_len -= 33;
-                    *op++ = M3_MARKER | 0;
-                    goto m3_m4_len;
-                }
-            }
-            else
-            {
-#if defined(LZO1Y)
-m4_match:
-#endif
-                m_off -= 0x4000;
-                assert(m_off > 0); assert(m_off <= 0x7fff);
-                if (m_len <= M4_MAX_LEN)
-                    *op++ = LZO_BYTE(M4_MARKER |
-                                     ((m_off & 0x4000) >> 11) | (m_len - 2));
-                else
-                {
-                    m_len -= M4_MAX_LEN;
-                    *op++ = LZO_BYTE(M4_MARKER | ((m_off & 0x4000) >> 11));
-m3_m4_len:
-                    while (m_len > 255)
-                    {
-                        m_len -= 255;
-                        *op++ = 0;
-                    }
-                    assert(m_len > 0);
-                    *op++ = LZO_BYTE(m_len);
-                }
-            }
-
-m3_m4_offset:
-            *op++ = LZO_BYTE((m_off & 63) << 2);
-            *op++ = LZO_BYTE(m_off >> 6);
-        }
-
-#if 0
-match_done:
-#endif
-        ii = ip;
-        if __lzo_unlikely(ip >= ip_end)
-            break;
-    }
-
-    *out_len = pd(op, out);
-    return pd(in_end,ii);
-}
-
-LZO_PUBLIC(int)
-DO_COMPRESS      ( const lzo_bytep in , lzo_uint  in_len,
-                         lzo_bytep out, lzo_uintp out_len,
-                         lzo_voidp wrkmem )
-{
-    lzo_bytep op = out;
-    lzo_uint t;
-
-    if __lzo_unlikely(in_len <= M2_MAX_LEN + 5)
-        t = in_len;
-    else
-    {
-        t = do_compress(in,in_len,op,out_len,wrkmem);
-        op += *out_len;
-    }
-
-    if (t > 0)
-    {
-        const lzo_bytep ii = in + in_len - t;
-
-        if (op == out && t <= 238)
-            *op++ = LZO_BYTE(17 + t);
-        else if (t <= 3)
-            op[-2] |= LZO_BYTE(t);
-        else if (t <= 18)
-            *op++ = LZO_BYTE(t - 3);
-        else
-        {
-            lzo_uint tt = t - 18;
-
-            *op++ = 0;
-            while (tt > 255)
-            {
-                tt -= 255;
-                *op++ = 0;
-            }
-            assert(tt > 0);
-            *op++ = LZO_BYTE(tt);
-        }
-        do *op++ = *ii++; while (--t > 0);
-    }
-
-    *op++ = M4_MARKER | 1;
-    *op++ = 0;
-    *op++ = 0;
-
-    *out_len = pd(op, out);
-    return LZO_E_OK;
-}
-
-#endif
-
-#undef do_compress
-#undef DO_COMPRESS
-#undef LZO_HASH
-
-#undef LZO_TEST_OVERRUN
-#undef DO_DECOMPRESS
-#define DO_DECOMPRESS       lzo1x_decompress
-
-#if !defined(MINILZO_CFG_SKIP_LZO1X_DECOMPRESS)
-
-#if defined(LZO_TEST_OVERRUN)
-#  if !defined(LZO_TEST_OVERRUN_INPUT)
-#    define LZO_TEST_OVERRUN_INPUT       2
-#  endif
-#  if !defined(LZO_TEST_OVERRUN_OUTPUT)
-#    define LZO_TEST_OVERRUN_OUTPUT      2
-#  endif
-#  if !defined(LZO_TEST_OVERRUN_LOOKBEHIND)
-#    define LZO_TEST_OVERRUN_LOOKBEHIND  1
-#  endif
-#endif
-
-#undef TEST_IP
-#undef TEST_OP
-#undef TEST_LB
-#undef TEST_LBO
-#undef NEED_IP
-#undef NEED_OP
-#undef HAVE_TEST_IP
-#undef HAVE_TEST_OP
-#undef HAVE_NEED_IP
-#undef HAVE_NEED_OP
-#undef HAVE_ANY_IP
-#undef HAVE_ANY_OP
-
-#if defined(LZO_TEST_OVERRUN_INPUT)
-#  if (LZO_TEST_OVERRUN_INPUT >= 1)
-#    define TEST_IP             (ip < ip_end)
-#  endif
-#  if (LZO_TEST_OVERRUN_INPUT >= 2)
-#    define NEED_IP(x) \
-            if ((lzo_uint)(ip_end - ip) < (lzo_uint)(x))  goto input_overrun
-#  endif
-#endif
-
-#if defined(LZO_TEST_OVERRUN_OUTPUT)
-#  if (LZO_TEST_OVERRUN_OUTPUT >= 1)
-#    define TEST_OP             (op <= op_end)
-#  endif
-#  if (LZO_TEST_OVERRUN_OUTPUT >= 2)
-#    undef TEST_OP
-#    define NEED_OP(x) \
-            if ((lzo_uint)(op_end - op) < (lzo_uint)(x))  goto output_overrun
-#  endif
-#endif
-
-#if defined(LZO_TEST_OVERRUN_LOOKBEHIND)
-#  define TEST_LB(m_pos)        if (m_pos < out || m_pos >= op) goto lookbehind_overrun
-#  define TEST_LBO(m_pos,o)     if (m_pos < out || m_pos >= op - (o)) goto lookbehind_overrun
-#else
-#  define TEST_LB(m_pos)        ((void) 0)
-#  define TEST_LBO(m_pos,o)     ((void) 0)
-#endif
-
-#if !defined(LZO_EOF_CODE) && !defined(TEST_IP)
-#  define TEST_IP               (ip < ip_end)
-#endif
-
-#if defined(TEST_IP)
-#  define HAVE_TEST_IP 1
-#else
-#  define TEST_IP               1
-#endif
-#if defined(TEST_OP)
-#  define HAVE_TEST_OP 1
-#else
-#  define TEST_OP               1
-#endif
-
-#if defined(NEED_IP)
-#  define HAVE_NEED_IP 1
-#else
-#  define NEED_IP(x)            ((void) 0)
-#endif
-#if defined(NEED_OP)
-#  define HAVE_NEED_OP 1
-#else
-#  define NEED_OP(x)            ((void) 0)
-#endif
-
-#if defined(HAVE_TEST_IP) || defined(HAVE_NEED_IP)
-#  define HAVE_ANY_IP 1
-#endif
-#if defined(HAVE_TEST_OP) || defined(HAVE_NEED_OP)
-#  define HAVE_ANY_OP 1
-#endif
-
-#if defined(DO_DECOMPRESS)
-LZO_PUBLIC(int)
-DO_DECOMPRESS  ( const lzo_bytep in , lzo_uint  in_len,
-                       lzo_bytep out, lzo_uintp out_len,
-                       lzo_voidp wrkmem )
-#endif
-{
-    register lzo_bytep op;
-    register const lzo_bytep ip;
-    register lzo_uint t;
-#if defined(COPY_DICT)
-    lzo_uint m_off;
-    const lzo_bytep dict_end;
-#else
-    register const lzo_bytep m_pos;
-#endif
-
-    const lzo_bytep const ip_end = in + in_len;
-#if defined(HAVE_ANY_OP)
-    lzo_bytep const op_end = out + *out_len;
-#endif
-#if defined(LZO1Z)
-    lzo_uint last_m_off = 0;
-#endif
-
-    LZO_UNUSED(wrkmem);
-
-#if defined(COPY_DICT)
-    if (dict)
-    {
-        if (dict_len > M4_MAX_OFFSET)
-        {
-            dict += dict_len - M4_MAX_OFFSET;
-            dict_len = M4_MAX_OFFSET;
-        }
-        dict_end = dict + dict_len;
-    }
-    else
-    {
-        dict_len = 0;
-        dict_end = NULL;
-    }
-#endif
-
-    *out_len = 0;
-
-    op = out;
-    ip = in;
-
-    if (*ip > 17)
-    {
-        t = *ip++ - 17;
-        if (t < 4)
-            goto match_next;
-        assert(t > 0); NEED_OP(t); NEED_IP(t+1);
-        do *op++ = *ip++; while (--t > 0);
-        goto first_literal_run;
-    }
-
-    while (TEST_IP && TEST_OP)
-    {
-        t = *ip++;
-        if (t >= 16)
-            goto match;
-        if (t == 0)
-        {
-            NEED_IP(1);
-            while (*ip == 0)
-            {
-                t += 255;
-                ip++;
-                NEED_IP(1);
-            }
-            t += 15 + *ip++;
-        }
-        assert(t > 0); NEED_OP(t+3); NEED_IP(t+4);
-#if defined(LZO_UNALIGNED_OK_4) || defined(LZO_ALIGNED_OK_4)
-#if !defined(LZO_UNALIGNED_OK_4)
-        if (PTR_ALIGNED2_4(op,ip))
-        {
-#endif
-        COPY4(op,ip);
-        op += 4; ip += 4;
-        if (--t > 0)
-        {
-            if (t >= 4)
-            {
-                do {
-                    COPY4(op,ip);
-                    op += 4; ip += 4; t -= 4;
-                } while (t >= 4);
-                if (t > 0) do *op++ = *ip++; while (--t > 0);
-            }
-            else
-                do *op++ = *ip++; while (--t > 0);
-        }
-#if !defined(LZO_UNALIGNED_OK_4)
-        }
-        else
-#endif
-#endif
-#if !defined(LZO_UNALIGNED_OK_4)
-        {
-            *op++ = *ip++; *op++ = *ip++; *op++ = *ip++;
-            do *op++ = *ip++; while (--t > 0);
-        }
-#endif
-
-first_literal_run:
-
-        t = *ip++;
-        if (t >= 16)
-            goto match;
-#if defined(COPY_DICT)
-#if defined(LZO1Z)
-        m_off = (1 + M2_MAX_OFFSET) + (t << 6) + (*ip++ >> 2);
-        last_m_off = m_off;
-#else
-        m_off = (1 + M2_MAX_OFFSET) + (t >> 2) + (*ip++ << 2);
-#endif
-        NEED_OP(3);
-        t = 3; COPY_DICT(t,m_off)
-#else
-#if defined(LZO1Z)
-        t = (1 + M2_MAX_OFFSET) + (t << 6) + (*ip++ >> 2);
-        m_pos = op - t;
-        last_m_off = t;
-#else
-        m_pos = op - (1 + M2_MAX_OFFSET);
-        m_pos -= t >> 2;
-        m_pos -= *ip++ << 2;
-#endif
-        TEST_LB(m_pos); NEED_OP(3);
-        *op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;
-#endif
-        goto match_done;
-
-        do {
-match:
-            if (t >= 64)
-            {
-#if defined(COPY_DICT)
-#if defined(LZO1X)
-                m_off = 1 + ((t >> 2) & 7) + (*ip++ << 3);
-                t = (t >> 5) - 1;
-#elif defined(LZO1Y)
-                m_off = 1 + ((t >> 2) & 3) + (*ip++ << 2);
-                t = (t >> 4) - 3;
-#elif defined(LZO1Z)
-                m_off = t & 0x1f;
-                if (m_off >= 0x1c)
-                    m_off = last_m_off;
-                else
-                {
-                    m_off = 1 + (m_off << 6) + (*ip++ >> 2);
-                    last_m_off = m_off;
-                }
-                t = (t >> 5) - 1;
-#endif
-#else
-#if defined(LZO1X)
-                m_pos = op - 1;
-                m_pos -= (t >> 2) & 7;
-                m_pos -= *ip++ << 3;
-                t = (t >> 5) - 1;
-#elif defined(LZO1Y)
-                m_pos = op - 1;
-                m_pos -= (t >> 2) & 3;
-                m_pos -= *ip++ << 2;
-                t = (t >> 4) - 3;
-#elif defined(LZO1Z)
-                {
-                    lzo_uint off = t & 0x1f;
-                    m_pos = op;
-                    if (off >= 0x1c)
-                    {
-                        assert(last_m_off > 0);
-                        m_pos -= last_m_off;
-                    }
-                    else
-                    {
-                        off = 1 + (off << 6) + (*ip++ >> 2);
-                        m_pos -= off;
-                        last_m_off = off;
-                    }
-                }
-                t = (t >> 5) - 1;
-#endif
-                TEST_LB(m_pos); assert(t > 0); NEED_OP(t+3-1);
-                goto copy_match;
-#endif
-            }
-            else if (t >= 32)
-            {
-                t &= 31;
-                if (t == 0)
-                {
-                    NEED_IP(1);
-                    while (*ip == 0)
-                    {
-                        t += 255;
-                        ip++;
-                        NEED_IP(1);
-                    }
-                    t += 31 + *ip++;
-                }
-#if defined(COPY_DICT)
-#if defined(LZO1Z)
-                m_off = 1 + (ip[0] << 6) + (ip[1] >> 2);
-                last_m_off = m_off;
-#else
-                m_off = 1 + (ip[0] >> 2) + (ip[1] << 6);
-#endif
-#else
-#if defined(LZO1Z)
-                {
-                    lzo_uint off = 1 + (ip[0] << 6) + (ip[1] >> 2);
-                    m_pos = op - off;
-                    last_m_off = off;
-                }
-#elif defined(LZO_UNALIGNED_OK_2) && defined(LZO_ABI_LITTLE_ENDIAN)
-                m_pos = op - 1;
-                m_pos -= (* (const lzo_ushortp) (const lzo_voidp) ip) >> 2;
-#else
-                m_pos = op - 1;
-                m_pos -= (ip[0] >> 2) + (ip[1] << 6);
-#endif
-#endif
-                ip += 2;
-            }
-            else if (t >= 16)
-            {
-#if defined(COPY_DICT)
-                m_off = (t & 8) << 11;
-#else
-                m_pos = op;
-                m_pos -= (t & 8) << 11;
-#endif
-                t &= 7;
-                if (t == 0)
-                {
-                    NEED_IP(1);
-                    while (*ip == 0)
-                    {
-                        t += 255;
-                        ip++;
-                        NEED_IP(1);
-                    }
-                    t += 7 + *ip++;
-                }
-#if defined(COPY_DICT)
-#if defined(LZO1Z)
-                m_off += (ip[0] << 6) + (ip[1] >> 2);
-#else
-                m_off += (ip[0] >> 2) + (ip[1] << 6);
-#endif
-                ip += 2;
-                if (m_off == 0)
-                    goto eof_found;
-                m_off += 0x4000;
-#if defined(LZO1Z)
-                last_m_off = m_off;
-#endif
-#else
-#if defined(LZO1Z)
-                m_pos -= (ip[0] << 6) + (ip[1] >> 2);
-#elif defined(LZO_UNALIGNED_OK_2) && defined(LZO_ABI_LITTLE_ENDIAN)
-                m_pos -= (* (const lzo_ushortp) (const lzo_voidp) ip) >> 2;
-#else
-                m_pos -= (ip[0] >> 2) + (ip[1] << 6);
-#endif
-                ip += 2;
-                if (m_pos == op)
-                    goto eof_found;
-                m_pos -= 0x4000;
-#if defined(LZO1Z)
-                last_m_off = pd((const lzo_bytep)op, m_pos);
-#endif
-#endif
-            }
-            else
-            {
-#if defined(COPY_DICT)
-#if defined(LZO1Z)
-                m_off = 1 + (t << 6) + (*ip++ >> 2);
-                last_m_off = m_off;
-#else
-                m_off = 1 + (t >> 2) + (*ip++ << 2);
-#endif
-                NEED_OP(2);
-                t = 2; COPY_DICT(t,m_off)
-#else
-#if defined(LZO1Z)
-                t = 1 + (t << 6) + (*ip++ >> 2);
-                m_pos = op - t;
-                last_m_off = t;
-#else
-                m_pos = op - 1;
-                m_pos -= t >> 2;
-                m_pos -= *ip++ << 2;
-#endif
-                TEST_LB(m_pos); NEED_OP(2);
-                *op++ = *m_pos++; *op++ = *m_pos;
-#endif
-                goto match_done;
-            }
-
-#if defined(COPY_DICT)
-
-            NEED_OP(t+3-1);
-            t += 3-1; COPY_DICT(t,m_off)
-
-#else
-
-            TEST_LB(m_pos); assert(t > 0); NEED_OP(t+3-1);
-#if defined(LZO_UNALIGNED_OK_4) || defined(LZO_ALIGNED_OK_4)
-#if !defined(LZO_UNALIGNED_OK_4)
-            if (t >= 2 * 4 - (3 - 1) && PTR_ALIGNED2_4(op,m_pos))
-            {
-                assert((op - m_pos) >= 4);
-#else
-            if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4)
-            {
-#endif
-                COPY4(op,m_pos);
-                op += 4; m_pos += 4; t -= 4 - (3 - 1);
-                do {
-                    COPY4(op,m_pos);
-                    op += 4; m_pos += 4; t -= 4;
-                } while (t >= 4);
-                if (t > 0) do *op++ = *m_pos++; while (--t > 0);
-            }
-            else
-#endif
-            {
-copy_match:
-                *op++ = *m_pos++; *op++ = *m_pos++;
-                do *op++ = *m_pos++; while (--t > 0);
-            }
-
-#endif
-
-match_done:
-#if defined(LZO1Z)
-            t = ip[-1] & 3;
-#else
-            t = ip[-2] & 3;
-#endif
-            if (t == 0)
-                break;
-
-match_next:
-            assert(t > 0); assert(t < 4); NEED_OP(t); NEED_IP(t+1);
-#if 0
-            do *op++ = *ip++; while (--t > 0);
-#else
-            *op++ = *ip++;
-            if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }
-#endif
-            t = *ip++;
-        } while (TEST_IP && TEST_OP);
-    }
-
-#if defined(HAVE_TEST_IP) || defined(HAVE_TEST_OP)
-    *out_len = pd(op, out);
-    return LZO_E_EOF_NOT_FOUND;
-#endif
-
-eof_found:
-    assert(t == 1);
-    *out_len = pd(op, out);
-    return (ip == ip_end ? LZO_E_OK :
-           (ip < ip_end  ? LZO_E_INPUT_NOT_CONSUMED : LZO_E_INPUT_OVERRUN));
-
-#if defined(HAVE_NEED_IP)
-input_overrun:
-    *out_len = pd(op, out);
-    return LZO_E_INPUT_OVERRUN;
-#endif
-
-#if defined(HAVE_NEED_OP)
-output_overrun:
-    *out_len = pd(op, out);
-    return LZO_E_OUTPUT_OVERRUN;
-#endif
-
-#if defined(LZO_TEST_OVERRUN_LOOKBEHIND)
-lookbehind_overrun:
-    *out_len = pd(op, out);
-    return LZO_E_LOOKBEHIND_OVERRUN;
-#endif
-}
-
-#endif
-
-#define LZO_TEST_OVERRUN 1
-#undef DO_DECOMPRESS
-#define DO_DECOMPRESS       lzo1x_decompress_safe
-
-#if !defined(MINILZO_CFG_SKIP_LZO1X_DECOMPRESS_SAFE)
-
-#if defined(LZO_TEST_OVERRUN)
-#  if !defined(LZO_TEST_OVERRUN_INPUT)
-#    define LZO_TEST_OVERRUN_INPUT       2
-#  endif
-#  if !defined(LZO_TEST_OVERRUN_OUTPUT)
-#    define LZO_TEST_OVERRUN_OUTPUT      2
-#  endif
-#  if !defined(LZO_TEST_OVERRUN_LOOKBEHIND)
-#    define LZO_TEST_OVERRUN_LOOKBEHIND  1
-#  endif
-#endif
-
-#undef TEST_IP
-#undef TEST_OP
-#undef TEST_LB
-#undef TEST_LBO
-#undef NEED_IP
-#undef NEED_OP
-#undef HAVE_TEST_IP
-#undef HAVE_TEST_OP
-#undef HAVE_NEED_IP
-#undef HAVE_NEED_OP
-#undef HAVE_ANY_IP
-#undef HAVE_ANY_OP
-
-#if defined(LZO_TEST_OVERRUN_INPUT)
-#  if (LZO_TEST_OVERRUN_INPUT >= 1)
-#    define TEST_IP             (ip < ip_end)
-#  endif
-#  if (LZO_TEST_OVERRUN_INPUT >= 2)
-#    define NEED_IP(x) \
-            if ((lzo_uint)(ip_end - ip) < (lzo_uint)(x))  goto input_overrun
-#  endif
-#endif
-
-#if defined(LZO_TEST_OVERRUN_OUTPUT)
-#  if (LZO_TEST_OVERRUN_OUTPUT >= 1)
-#    define TEST_OP             (op <= op_end)
-#  endif
-#  if (LZO_TEST_OVERRUN_OUTPUT >= 2)
-#    undef TEST_OP
-#    define NEED_OP(x) \
-            if ((lzo_uint)(op_end - op) < (lzo_uint)(x))  goto output_overrun
-#  endif
-#endif
-
-#if defined(LZO_TEST_OVERRUN_LOOKBEHIND)
-#  define TEST_LB(m_pos)        if (m_pos < out || m_pos >= op) goto lookbehind_overrun
-#  define TEST_LBO(m_pos,o)     if (m_pos < out || m_pos >= op - (o)) goto lookbehind_overrun
-#else
-#  define TEST_LB(m_pos)        ((void) 0)
-#  define TEST_LBO(m_pos,o)     ((void) 0)
-#endif
-
-#if !defined(LZO_EOF_CODE) && !defined(TEST_IP)
-#  define TEST_IP               (ip < ip_end)
-#endif
-
-#if defined(TEST_IP)
-#  define HAVE_TEST_IP 1
-#else
-#  define TEST_IP               1
-#endif
-#if defined(TEST_OP)
-#  define HAVE_TEST_OP 1
-#else
-#  define TEST_OP               1
-#endif
-
-#if defined(NEED_IP)
-#  define HAVE_NEED_IP 1
-#else
-#  define NEED_IP(x)            ((void) 0)
-#endif
-#if defined(NEED_OP)
-#  define HAVE_NEED_OP 1
-#else
-#  define NEED_OP(x)            ((void) 0)
-#endif
-
-#if defined(HAVE_TEST_IP) || defined(HAVE_NEED_IP)
-#  define HAVE_ANY_IP 1
-#endif
-#if defined(HAVE_TEST_OP) || defined(HAVE_NEED_OP)
-#  define HAVE_ANY_OP 1
-#endif
-
-#if defined(DO_DECOMPRESS)
-LZO_PUBLIC(int)
-DO_DECOMPRESS  ( const lzo_bytep in , lzo_uint  in_len,
-                       lzo_bytep out, lzo_uintp out_len,
-                       lzo_voidp wrkmem )
-#endif
-{
-    register lzo_bytep op;
-    register const lzo_bytep ip;
-    register lzo_uint t;
-#if defined(COPY_DICT)
-    lzo_uint m_off;
-    const lzo_bytep dict_end;
-#else
-    register const lzo_bytep m_pos;
-#endif
-
-    const lzo_bytep const ip_end = in + in_len;
-#if defined(HAVE_ANY_OP)
-    lzo_bytep const op_end = out + *out_len;
-#endif
-#if defined(LZO1Z)
-    lzo_uint last_m_off = 0;
-#endif
-
-    LZO_UNUSED(wrkmem);
-
-#if defined(COPY_DICT)
-    if (dict)
-    {
-        if (dict_len > M4_MAX_OFFSET)
-        {
-            dict += dict_len - M4_MAX_OFFSET;
-            dict_len = M4_MAX_OFFSET;
-        }
-        dict_end = dict + dict_len;
-    }
-    else
-    {
-        dict_len = 0;
-        dict_end = NULL;
-    }
-#endif
-
-    *out_len = 0;
-
-    op = out;
-    ip = in;
-
-    if (*ip > 17)
-    {
-        t = *ip++ - 17;
-        if (t < 4)
-            goto match_next;
-        assert(t > 0); NEED_OP(t); NEED_IP(t+1);
-        do *op++ = *ip++; while (--t > 0);
-        goto first_literal_run;
-    }
-
-    while (TEST_IP && TEST_OP)
-    {
-        t = *ip++;
-        if (t >= 16)
-            goto match;
-        if (t == 0)
-        {
-            NEED_IP(1);
-            while (*ip == 0)
-            {
-                t += 255;
-                ip++;
-                NEED_IP(1);
-            }
-            t += 15 + *ip++;
-        }
-        assert(t > 0); NEED_OP(t+3); NEED_IP(t+4);
-#if defined(LZO_UNALIGNED_OK_4) || defined(LZO_ALIGNED_OK_4)
-#if !defined(LZO_UNALIGNED_OK_4)
-        if (PTR_ALIGNED2_4(op,ip))
-        {
-#endif
-        COPY4(op,ip);
-        op += 4; ip += 4;
-        if (--t > 0)
-        {
-            if (t >= 4)
-            {
-                do {
-                    COPY4(op,ip);
-                    op += 4; ip += 4; t -= 4;
-                } while (t >= 4);
-                if (t > 0) do *op++ = *ip++; while (--t > 0);
-            }
-            else
-                do *op++ = *ip++; while (--t > 0);
-        }
-#if !defined(LZO_UNALIGNED_OK_4)
-        }
-        else
-#endif
-#endif
-#if !defined(LZO_UNALIGNED_OK_4)
-        {
-            *op++ = *ip++; *op++ = *ip++; *op++ = *ip++;
-            do *op++ = *ip++; while (--t > 0);
-        }
-#endif
-
-first_literal_run:
-
-        t = *ip++;
-        if (t >= 16)
-            goto match;
-#if defined(COPY_DICT)
-#if defined(LZO1Z)
-        m_off = (1 + M2_MAX_OFFSET) + (t << 6) + (*ip++ >> 2);
-        last_m_off = m_off;
-#else
-        m_off = (1 + M2_MAX_OFFSET) + (t >> 2) + (*ip++ << 2);
-#endif
-        NEED_OP(3);
-        t = 3; COPY_DICT(t,m_off)
-#else
-#if defined(LZO1Z)
-        t = (1 + M2_MAX_OFFSET) + (t << 6) + (*ip++ >> 2);
-        m_pos = op - t;
-        last_m_off = t;
-#else
-        m_pos = op - (1 + M2_MAX_OFFSET);
-        m_pos -= t >> 2;
-        m_pos -= *ip++ << 2;
-#endif
-        TEST_LB(m_pos); NEED_OP(3);
-        *op++ = *m_pos++; *op++ = *m_pos++; *op++ = *m_pos;
-#endif
-        goto match_done;
-
-        do {
-match:
-            if (t >= 64)
-            {
-#if defined(COPY_DICT)
-#if defined(LZO1X)
-                m_off = 1 + ((t >> 2) & 7) + (*ip++ << 3);
-                t = (t >> 5) - 1;
-#elif defined(LZO1Y)
-                m_off = 1 + ((t >> 2) & 3) + (*ip++ << 2);
-                t = (t >> 4) - 3;
-#elif defined(LZO1Z)
-                m_off = t & 0x1f;
-                if (m_off >= 0x1c)
-                    m_off = last_m_off;
-                else
-                {
-                    m_off = 1 + (m_off << 6) + (*ip++ >> 2);
-                    last_m_off = m_off;
-                }
-                t = (t >> 5) - 1;
-#endif
-#else
-#if defined(LZO1X)
-                m_pos = op - 1;
-                m_pos -= (t >> 2) & 7;
-                m_pos -= *ip++ << 3;
-                t = (t >> 5) - 1;
-#elif defined(LZO1Y)
-                m_pos = op - 1;
-                m_pos -= (t >> 2) & 3;
-                m_pos -= *ip++ << 2;
-                t = (t >> 4) - 3;
-#elif defined(LZO1Z)
-                {
-                    lzo_uint off = t & 0x1f;
-                    m_pos = op;
-                    if (off >= 0x1c)
-                    {
-                        assert(last_m_off > 0);
-                        m_pos -= last_m_off;
-                    }
-                    else
-                    {
-                        off = 1 + (off << 6) + (*ip++ >> 2);
-                        m_pos -= off;
-                        last_m_off = off;
-                    }
-                }
-                t = (t >> 5) - 1;
-#endif
-                TEST_LB(m_pos); assert(t > 0); NEED_OP(t+3-1);
-                goto copy_match;
-#endif
-            }
-            else if (t >= 32)
-            {
-                t &= 31;
-                if (t == 0)
-                {
-                    NEED_IP(1);
-                    while (*ip == 0)
-                    {
-                        t += 255;
-                        ip++;
-                        NEED_IP(1);
-                    }
-                    t += 31 + *ip++;
-                }
-#if defined(COPY_DICT)
-#if defined(LZO1Z)
-                m_off = 1 + (ip[0] << 6) + (ip[1] >> 2);
-                last_m_off = m_off;
-#else
-                m_off = 1 + (ip[0] >> 2) + (ip[1] << 6);
-#endif
-#else
-#if defined(LZO1Z)
-                {
-                    lzo_uint off = 1 + (ip[0] << 6) + (ip[1] >> 2);
-                    m_pos = op - off;
-                    last_m_off = off;
-                }
-#elif defined(LZO_UNALIGNED_OK_2) && defined(LZO_ABI_LITTLE_ENDIAN)
-                m_pos = op - 1;
-                m_pos -= (* (const lzo_ushortp) (const lzo_voidp) ip) >> 2;
-#else
-                m_pos = op - 1;
-                m_pos -= (ip[0] >> 2) + (ip[1] << 6);
-#endif
-#endif
-                ip += 2;
-            }
-            else if (t >= 16)
-            {
-#if defined(COPY_DICT)
-                m_off = (t & 8) << 11;
-#else
-                m_pos = op;
-                m_pos -= (t & 8) << 11;
-#endif
-                t &= 7;
-                if (t == 0)
-                {
-                    NEED_IP(1);
-                    while (*ip == 0)
-                    {
-                        t += 255;
-                        ip++;
-                        NEED_IP(1);
-                    }
-                    t += 7 + *ip++;
-                }
-#if defined(COPY_DICT)
-#if defined(LZO1Z)
-                m_off += (ip[0] << 6) + (ip[1] >> 2);
-#else
-                m_off += (ip[0] >> 2) + (ip[1] << 6);
-#endif
-                ip += 2;
-                if (m_off == 0)
-                    goto eof_found;
-                m_off += 0x4000;
-#if defined(LZO1Z)
-                last_m_off = m_off;
-#endif
-#else
-#if defined(LZO1Z)
-                m_pos -= (ip[0] << 6) + (ip[1] >> 2);
-#elif defined(LZO_UNALIGNED_OK_2) && defined(LZO_ABI_LITTLE_ENDIAN)
-                m_pos -= (* (const lzo_ushortp) (const lzo_voidp) ip) >> 2;
-#else
-                m_pos -= (ip[0] >> 2) + (ip[1] << 6);
-#endif
-                ip += 2;
-                if (m_pos == op)
-                    goto eof_found;
-                m_pos -= 0x4000;
-#if defined(LZO1Z)
-                last_m_off = pd((const lzo_bytep)op, m_pos);
-#endif
-#endif
-            }
-            else
-            {
-#if defined(COPY_DICT)
-#if defined(LZO1Z)
-                m_off = 1 + (t << 6) + (*ip++ >> 2);
-                last_m_off = m_off;
-#else
-                m_off = 1 + (t >> 2) + (*ip++ << 2);
-#endif
-                NEED_OP(2);
-                t = 2; COPY_DICT(t,m_off)
-#else
-#if defined(LZO1Z)
-                t = 1 + (t << 6) + (*ip++ >> 2);
-                m_pos = op - t;
-                last_m_off = t;
-#else
-                m_pos = op - 1;
-                m_pos -= t >> 2;
-                m_pos -= *ip++ << 2;
-#endif
-                TEST_LB(m_pos); NEED_OP(2);
-                *op++ = *m_pos++; *op++ = *m_pos;
-#endif
-                goto match_done;
-            }
-
-#if defined(COPY_DICT)
-
-            NEED_OP(t+3-1);
-            t += 3-1; COPY_DICT(t,m_off)
-
-#else
-
-            TEST_LB(m_pos); assert(t > 0); NEED_OP(t+3-1);
-#if defined(LZO_UNALIGNED_OK_4) || defined(LZO_ALIGNED_OK_4)
-#if !defined(LZO_UNALIGNED_OK_4)
-            if (t >= 2 * 4 - (3 - 1) && PTR_ALIGNED2_4(op,m_pos))
-            {
-                assert((op - m_pos) >= 4);
-#else
-            if (t >= 2 * 4 - (3 - 1) && (op - m_pos) >= 4)
-            {
-#endif
-                COPY4(op,m_pos);
-                op += 4; m_pos += 4; t -= 4 - (3 - 1);
-                do {
-                    COPY4(op,m_pos);
-                    op += 4; m_pos += 4; t -= 4;
-                } while (t >= 4);
-                if (t > 0) do *op++ = *m_pos++; while (--t > 0);
-            }
-            else
-#endif
-            {
-copy_match:
-                *op++ = *m_pos++; *op++ = *m_pos++;
-                do *op++ = *m_pos++; while (--t > 0);
-            }
-
-#endif
-
-match_done:
-#if defined(LZO1Z)
-            t = ip[-1] & 3;
-#else
-            t = ip[-2] & 3;
-#endif
-            if (t == 0)
-                break;
-
-match_next:
-            assert(t > 0); assert(t < 4); NEED_OP(t); NEED_IP(t+1);
-#if 0
-            do *op++ = *ip++; while (--t > 0);
-#else
-            *op++ = *ip++;
-            if (t > 1) { *op++ = *ip++; if (t > 2) { *op++ = *ip++; } }
-#endif
-            t = *ip++;
-        } while (TEST_IP && TEST_OP);
-    }
-
-#if defined(HAVE_TEST_IP) || defined(HAVE_TEST_OP)
-    *out_len = pd(op, out);
-    return LZO_E_EOF_NOT_FOUND;
-#endif
-
-eof_found:
-    assert(t == 1);
-    *out_len = pd(op, out);
-    return (ip == ip_end ? LZO_E_OK :
-           (ip < ip_end  ? LZO_E_INPUT_NOT_CONSUMED : LZO_E_INPUT_OVERRUN));
-
-#if defined(HAVE_NEED_IP)
-input_overrun:
-    *out_len = pd(op, out);
-    return LZO_E_INPUT_OVERRUN;
-#endif
-
-#if defined(HAVE_NEED_OP)
-output_overrun:
-    *out_len = pd(op, out);
-    return LZO_E_OUTPUT_OVERRUN;
-#endif
-
-#if defined(LZO_TEST_OVERRUN_LOOKBEHIND)
-lookbehind_overrun:
-    *out_len = pd(op, out);
-    return LZO_E_LOOKBEHIND_OVERRUN;
-#endif
-}
-
-#endif
-
-/***** End of minilzo.c *****/
-
diff -urN remmina-plugins/vnc/libvncserver/common/minilzo.h remmina-plugins/vnc/libvncserver/common/minilzo.h
--- remmina-plugins/vnc/libvncserver/common/minilzo.h	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins/vnc/libvncserver/common/minilzo.h	1970-01-01 10:00:00.000000000 +1000
@@ -1,108 +0,0 @@
-/* minilzo.h -- mini subset of the LZO real-time data compression library
-
-   This file is part of the LZO real-time data compression library.
-
-   Copyright (C) 2010 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2009 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2008 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2007 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2006 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2005 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2004 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2003 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2002 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2001 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 2000 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1999 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1998 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1997 Markus Franz Xaver Johannes Oberhumer
-   Copyright (C) 1996 Markus Franz Xaver Johannes Oberhumer
-   All Rights Reserved.
-
-   The LZO library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU General Public License as
-   published by the Free Software Foundation; either version 2 of
-   the License, or (at your option) any later version.
-
-   The LZO library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with the LZO library; see the file COPYING.
-   If not, write to the Free Software Foundation, Inc.,
-   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
-
-   Markus F.X.J. Oberhumer
-   <markus@oberhumer.com>
-   http://www.oberhumer.com/opensource/lzo/
- */
-
-/*
- * NOTE:
- *   the full LZO package can be found at
- *   http://www.oberhumer.com/opensource/lzo/
- */
-
-
-#ifndef __MINILZO_H
-#define __MINILZO_H 1
-
-#define MINILZO_VERSION         0x2040
-
-#ifdef __LZOCONF_H
-#  error "you cannot use both LZO and miniLZO"
-#endif
-
-#undef LZO_HAVE_CONFIG_H
-#include "lzoconf.h"
-
-#if !defined(LZO_VERSION) || (LZO_VERSION != MINILZO_VERSION)
-#  error "version mismatch in header files"
-#endif
-
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-
-/***********************************************************************
-//
-************************************************************************/
-
-/* Memory required for the wrkmem parameter.
- * When the required size is 0, you can also pass a NULL pointer.
- */
-
-#define LZO1X_MEM_COMPRESS      LZO1X_1_MEM_COMPRESS
-#define LZO1X_1_MEM_COMPRESS    ((lzo_uint32) (16384L * lzo_sizeof_dict_t))
-#define LZO1X_MEM_DECOMPRESS    (0)
-
-
-/* compression */
-LZO_EXTERN(int)
-lzo1x_1_compress        ( const lzo_bytep src, lzo_uint  src_len,
-                                lzo_bytep dst, lzo_uintp dst_len,
-                                lzo_voidp wrkmem );
-
-/* decompression */
-LZO_EXTERN(int)
-lzo1x_decompress        ( const lzo_bytep src, lzo_uint  src_len,
-                                lzo_bytep dst, lzo_uintp dst_len,
-                                lzo_voidp wrkmem /* NOT USED */ );
-
-/* safe decompression with overrun testing */
-LZO_EXTERN(int)
-lzo1x_decompress_safe   ( const lzo_bytep src, lzo_uint  src_len,
-                                lzo_bytep dst, lzo_uintp dst_len,
-                                lzo_voidp wrkmem /* NOT USED */ );
-
-
-#ifdef __cplusplus
-} /* extern "C" */
-#endif
-
-#endif /* already included */
-
diff -urN remmina-plugins/vnc/libvncserver/common/vncauth.c remmina-plugins/vnc/libvncserver/common/vncauth.c
--- remmina-plugins/vnc/libvncserver/common/vncauth.c	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins/vnc/libvncserver/common/vncauth.c	1970-01-01 10:00:00.000000000 +1000
@@ -1,211 +0,0 @@
-/*
- *  Copyright (C) 1999 AT&T Laboratories Cambridge.  All Rights Reserved.
- *
- *  This is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This software is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
- *  USA.
- */
-
-/*
- * vncauth.c - Functions for VNC password management and authentication.
- */
-
-#ifdef __STRICT_ANSI__
-#define _BSD_SOURCE
-#define _POSIX_SOURCE
-#endif
-#ifdef LIBVNCSERVER_HAVE_SYS_TYPES_H
-#include <sys/types.h>
-#endif
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <rfb/rfbproto.h>
-#include "d3des.h"
-
-#include <string.h>
-#include <math.h>
-
-#ifdef LIBVNCSERVER_HAVE_SYS_STAT_H
-#include <sys/stat.h>
-#endif
-
-#include <time.h>
-
-#ifdef WIN32
-#define srandom srand
-#define random rand
-#else
-#include <sys/time.h>
-#endif
-
-
-/* libvncclient does not need this */
-#ifndef rfbEncryptBytes
-
-/*
- * We use a fixed key to store passwords, since we assume that our local
- * file system is secure but nonetheless don't want to store passwords
- * as plaintext.
- */
-
-static unsigned char fixedkey[8] = {23,82,107,6,35,78,88,7};
-
-
-/*
- * Encrypt a password and store it in a file.  Returns 0 if successful,
- * 1 if the file could not be written.
- */
-
-int
-rfbEncryptAndStorePasswd(char *passwd, char *fname)
-{
-    FILE *fp;
-    unsigned int i;
-    unsigned char encryptedPasswd[8];
-
-    if ((fp = fopen(fname,"w")) == NULL) return 1;
-
-	/* windows security sux */
-#ifndef WIN32
-    fchmod(fileno(fp), S_IRUSR|S_IWUSR);
-#endif
-
-    /* pad password with nulls */
-
-    for (i = 0; i < 8; i++) {
-	if (i < strlen(passwd)) {
-	    encryptedPasswd[i] = passwd[i];
-	} else {
-	    encryptedPasswd[i] = 0;
-	}
-    }
-
-    /* Do encryption in-place - this way we overwrite our copy of the plaintext
-       password */
-
-    rfbDesKey(fixedkey, EN0);
-    rfbDes(encryptedPasswd, encryptedPasswd);
-
-    for (i = 0; i < 8; i++) {
-	putc(encryptedPasswd[i], fp);
-    }
-
-    fclose(fp);
-    return 0;
-}
-
-
-/*
- * Decrypt a password from a file.  Returns a pointer to a newly allocated
- * string containing the password or a null pointer if the password could
- * not be retrieved for some reason.
- */
-
-char *
-rfbDecryptPasswdFromFile(char *fname)
-{
-    FILE *fp;
-    int i, ch;
-    unsigned char *passwd = (unsigned char *)malloc(9);
-
-    if ((fp = fopen(fname,"r")) == NULL) {
-	free(passwd);
-	return NULL;
-    }
-
-    for (i = 0; i < 8; i++) {
-	ch = getc(fp);
-	if (ch == EOF) {
-	    fclose(fp);
-	    free(passwd);
-	    return NULL;
-	}
-	passwd[i] = ch;
-    }
-
-    fclose(fp);
-
-    rfbDesKey(fixedkey, DE1);
-    rfbDes(passwd, passwd);
-
-    passwd[8] = 0;
-
-    return (char *)passwd;
-}
-
-
-/*
- * Generate CHALLENGESIZE random bytes for use in challenge-response
- * authentication.
- */
-
-void
-rfbRandomBytes(unsigned char *bytes)
-{
-    int i;
-    static rfbBool s_srandom_called = FALSE;
-
-    if (!s_srandom_called) {
-	srandom((unsigned int)time(NULL) ^ (unsigned int)getpid());
-	s_srandom_called = TRUE;
-    }
-
-    for (i = 0; i < CHALLENGESIZE; i++) {
-	bytes[i] = (unsigned char)(random() & 255);
-    }
-}
-
-#endif
-
-/*
- * Encrypt CHALLENGESIZE bytes in memory using a password.
- */
-
-void
-rfbEncryptBytes(unsigned char *bytes, char *passwd)
-{
-    unsigned char key[8];
-    unsigned int i;
-
-    /* key is simply password padded with nulls */
-
-    for (i = 0; i < 8; i++) {
-	if (i < strlen(passwd)) {
-	    key[i] = passwd[i];
-	} else {
-	    key[i] = 0;
-	}
-    }
-
-    rfbDesKey(key, EN0);
-
-    for (i = 0; i < CHALLENGESIZE; i += 8) {
-	rfbDes(bytes+i, bytes+i);
-    }
-}
-
-void
-rfbEncryptBytes2(unsigned char *where, const int length, unsigned char *key) {
-  int i, j;
-  rfbDesKey(key, EN0);
-  for (i = 0; i< 8; i++)
-    where[i] ^= key[i];
-  rfbDes(where, where);
-  for (i = 8; i < length; i += 8) {
-    for (j = 0; j < 8; j++)
-      where[i + j] ^= where[i + j - 8];
-      rfbDes(where + i, where + i);
-  }
-}
diff -urN remmina-plugins/vnc/libvncserver/common/zywrletemplate.c remmina-plugins/vnc/libvncserver/common/zywrletemplate.c
--- remmina-plugins/vnc/libvncserver/common/zywrletemplate.c	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins/vnc/libvncserver/common/zywrletemplate.c	1970-01-01 10:00:00.000000000 +1000
@@ -1,824 +0,0 @@
-
-/********************************************************************
- *                                                                  *
- * THIS FILE IS PART OF THE 'ZYWRLE' VNC CODEC SOURCE CODE.         *
- *                                                                  *
- * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
- * GOVERNED BY A FOLLOWING BSD-STYLE SOURCE LICENSE.                *
- * PLEASE READ THESE TERMS BEFORE DISTRIBUTING.                     *
- *                                                                  *
- * THE 'ZYWRLE' VNC CODEC SOURCE CODE IS (C) COPYRIGHT 2006         *
- * BY Hitachi Systems & Services, Ltd.                              *
- * (Noriaki Yamazaki, Research & Developement Center)               *                                                                 *
- *                                                                  *
- ********************************************************************
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions
-are met:
-
-- Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-
-- Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in the
-documentation and/or other materials provided with the distribution.
-
-- Neither the name of the Hitachi Systems & Services, Ltd. nor
-the names of its contributors may be used to endorse or promote
-products derived from this software without specific prior written
-permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION
-OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- ********************************************************************/
-
-/* Change Log:
-     V0.02 : 2008/02/04 : Fix mis encode/decode when width != scanline
-	                     (Thanks Johannes Schindelin, author of LibVNC
-						  Server/Client)
-     V0.01 : 2007/02/06 : Initial release
-*/
-
-/* #define ZYWRLE_ENCODE */
-/* #define ZYWRLE_DECODE */
-#define ZYWRLE_QUANTIZE
-
-/*
-[References]
- PLHarr:
-   Senecal, J. G., P. Lindstrom, M. A. Duchaineau, and K. I. Joy, "An Improved N-Bit to N-Bit Reversible Haar-Like Transform," Pacific Graphics 2004, October 2004, pp. 371-380.
- EZW:
-   Shapiro, JM: Embedded Image Coding Using Zerotrees of Wavelet Coefficients, IEEE Trans. Signal. Process., Vol.41, pp.3445-3462 (1993).
-*/
-
-
-/* Template Macro stuffs. */
-#undef ZYWRLE_ANALYZE
-#undef ZYWRLE_SYNTHESIZE
-#define ZYWRLE_ANALYZE __RFB_CONCAT3E(zywrleAnalyze,BPP,END_FIX)
-#define ZYWRLE_SYNTHESIZE __RFB_CONCAT3E(zywrleSynthesize,BPP,END_FIX)
-
-#define ZYWRLE_RGBYUV __RFB_CONCAT3E(zywrleRGBYUV,BPP,END_FIX)
-#define ZYWRLE_YUVRGB __RFB_CONCAT3E(zywrleYUVRGB,BPP,END_FIX)
-#define ZYWRLE_YMASK __RFB_CONCAT2E(ZYWRLE_YMASK,BPP)
-#define ZYWRLE_UVMASK __RFB_CONCAT2E(ZYWRLE_UVMASK,BPP)
-#define ZYWRLE_LOAD_PIXEL __RFB_CONCAT2E(ZYWRLE_LOAD_PIXEL,BPP)
-#define ZYWRLE_SAVE_PIXEL __RFB_CONCAT2E(ZYWRLE_SAVE_PIXEL,BPP)
-
-/* Packing/Unpacking pixel stuffs.
-   Endian conversion stuffs. */
-#undef S_0
-#undef S_1
-#undef L_0
-#undef L_1
-#undef L_2
-#if ZYWRLE_ENDIAN == ENDIAN_BIG
-#  define S_0	1
-#  define S_1	0
-#  define L_0	3
-#  define L_1	2
-#  define L_2	1
-#else
-#  define S_0	0
-#  define S_1	1
-#  define L_0	0
-#  define L_1	1
-#  define L_2	2
-#endif
-
-/*   Load/Save pixel stuffs. */
-#define ZYWRLE_YMASK15  0xFFFFFFF8
-#define ZYWRLE_UVMASK15 0xFFFFFFF8
-#define ZYWRLE_LOAD_PIXEL15(pSrc,R,G,B) { \
-	R =  (((unsigned char*)pSrc)[S_1]<< 1)& 0xF8;	\
-	G = ((((unsigned char*)pSrc)[S_1]<< 6)|(((unsigned char*)pSrc)[S_0]>> 2))& 0xF8;	\
-	B =  (((unsigned char*)pSrc)[S_0]<< 3)& 0xF8;	\
-}
-#define ZYWRLE_SAVE_PIXEL15(pDst,R,G,B) { \
-	R &= 0xF8;	\
-	G &= 0xF8;	\
-	B &= 0xF8;	\
-	((unsigned char*)pDst)[S_1] = (unsigned char)( (R>>1)|(G>>6)       );	\
-	((unsigned char*)pDst)[S_0] = (unsigned char)(((B>>3)|(G<<2))& 0xFF);	\
-}
-#define ZYWRLE_YMASK16  0xFFFFFFFC
-#define ZYWRLE_UVMASK16 0xFFFFFFF8
-#define ZYWRLE_LOAD_PIXEL16(pSrc,R,G,B) { \
-	R =   ((unsigned char*)pSrc)[S_1]     & 0xF8;	\
-	G = ((((unsigned char*)pSrc)[S_1]<< 5)|(((unsigned char*)pSrc)[S_0]>> 3))& 0xFC;	\
-	B =  (((unsigned char*)pSrc)[S_0]<< 3)& 0xF8;	\
-}
-#define ZYWRLE_SAVE_PIXEL16(pDst,R,G,B) { \
-	R &= 0xF8;	\
-	G &= 0xFC;	\
-	B &= 0xF8;	\
-	((unsigned char*)pDst)[S_1] = (unsigned char)(  R    |(G>>5)       );	\
-	((unsigned char*)pDst)[S_0] = (unsigned char)(((B>>3)|(G<<3))& 0xFF);	\
-}
-#define ZYWRLE_YMASK32  0xFFFFFFFF
-#define ZYWRLE_UVMASK32 0xFFFFFFFF
-#define ZYWRLE_LOAD_PIXEL32(pSrc,R,G,B) { \
-	R = ((unsigned char*)pSrc)[L_2];	\
-	G = ((unsigned char*)pSrc)[L_1];	\
-	B = ((unsigned char*)pSrc)[L_0];	\
-}
-#define ZYWRLE_SAVE_PIXEL32(pDst,R,G,B) { \
-	((unsigned char*)pDst)[L_2] = (unsigned char)R;	\
-	((unsigned char*)pDst)[L_1] = (unsigned char)G;	\
-	((unsigned char*)pDst)[L_0] = (unsigned char)B;	\
-}
-
-#ifndef ZYWRLE_ONCE
-#define ZYWRLE_ONCE
-
-#ifdef WIN32
-#define InlineX __inline
-#else
-#define InlineX inline
-#endif
-
-#ifdef ZYWRLE_ENCODE
-/* Tables for Coefficients filtering. */
-#  ifndef ZYWRLE_QUANTIZE
-/* Type A:lower bit omitting of EZW style. */
-const static unsigned int zywrleParam[3][3]={
-	{0x0000F000,0x00000000,0x00000000},
-	{0x0000C000,0x00F0F0F0,0x00000000},
-	{0x0000C000,0x00C0C0C0,0x00F0F0F0},
-/*	{0x0000FF00,0x00000000,0x00000000},
-	{0x0000FF00,0x00FFFFFF,0x00000000},
-	{0x0000FF00,0x00FFFFFF,0x00FFFFFF}, */
-};
-#  else
-/* Type B:Non liner quantization filter. */
-static const signed char zywrleConv[4][256]={
-{	/* bi=5, bo=5 r=0.0:PSNR=24.849 */
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-},
-{	/* bi=5, bo=5 r=2.0:PSNR=74.031 */
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 32,
-	32, 32, 32, 32, 32, 32, 32, 32,
-	32, 32, 32, 32, 32, 32, 32, 32,
-	48, 48, 48, 48, 48, 48, 48, 48,
-	48, 48, 48, 56, 56, 56, 56, 56,
-	56, 56, 56, 56, 64, 64, 64, 64,
-	64, 64, 64, 64, 72, 72, 72, 72,
-	72, 72, 72, 72, 80, 80, 80, 80,
-	80, 80, 88, 88, 88, 88, 88, 88,
-	88, 88, 88, 88, 88, 88, 96, 96,
-	96, 96, 96, 104, 104, 104, 104, 104,
-	104, 104, 104, 104, 104, 112, 112, 112,
-	112, 112, 112, 112, 112, 112, 120, 120,
-	120, 120, 120, 120, 120, 120, 120, 120,
-	0, -120, -120, -120, -120, -120, -120, -120,
-	-120, -120, -120, -112, -112, -112, -112, -112,
-	-112, -112, -112, -112, -104, -104, -104, -104,
-	-104, -104, -104, -104, -104, -104, -96, -96,
-	-96, -96, -96, -88, -88, -88, -88, -88,
-	-88, -88, -88, -88, -88, -88, -88, -80,
-	-80, -80, -80, -80, -80, -72, -72, -72,
-	-72, -72, -72, -72, -72, -64, -64, -64,
-	-64, -64, -64, -64, -64, -56, -56, -56,
-	-56, -56, -56, -56, -56, -56, -48, -48,
-	-48, -48, -48, -48, -48, -48, -48, -48,
-	-48, -32, -32, -32, -32, -32, -32, -32,
-	-32, -32, -32, -32, -32, -32, -32, -32,
-	-32, -32, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-},
-{	/* bi=5, bo=4 r=2.0:PSNR=64.441 */
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	48, 48, 48, 48, 48, 48, 48, 48,
-	48, 48, 48, 48, 48, 48, 48, 48,
-	48, 48, 48, 48, 48, 48, 48, 48,
-	64, 64, 64, 64, 64, 64, 64, 64,
-	64, 64, 64, 64, 64, 64, 64, 64,
-	80, 80, 80, 80, 80, 80, 80, 80,
-	80, 80, 80, 80, 80, 88, 88, 88,
-	88, 88, 88, 88, 88, 88, 88, 88,
-	104, 104, 104, 104, 104, 104, 104, 104,
-	104, 104, 104, 112, 112, 112, 112, 112,
-	112, 112, 112, 112, 120, 120, 120, 120,
-	120, 120, 120, 120, 120, 120, 120, 120,
-	0, -120, -120, -120, -120, -120, -120, -120,
-	-120, -120, -120, -120, -120, -112, -112, -112,
-	-112, -112, -112, -112, -112, -112, -104, -104,
-	-104, -104, -104, -104, -104, -104, -104, -104,
-	-104, -88, -88, -88, -88, -88, -88, -88,
-	-88, -88, -88, -88, -80, -80, -80, -80,
-	-80, -80, -80, -80, -80, -80, -80, -80,
-	-80, -64, -64, -64, -64, -64, -64, -64,
-	-64, -64, -64, -64, -64, -64, -64, -64,
-	-64, -48, -48, -48, -48, -48, -48, -48,
-	-48, -48, -48, -48, -48, -48, -48, -48,
-	-48, -48, -48, -48, -48, -48, -48, -48,
-	-48, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-},
-{	/* bi=5, bo=2 r=2.0:PSNR=43.175 */
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	88, 88, 88, 88, 88, 88, 88, 88,
-	88, 88, 88, 88, 88, 88, 88, 88,
-	88, 88, 88, 88, 88, 88, 88, 88,
-	88, 88, 88, 88, 88, 88, 88, 88,
-	88, 88, 88, 88, 88, 88, 88, 88,
-	88, 88, 88, 88, 88, 88, 88, 88,
-	88, 88, 88, 88, 88, 88, 88, 88,
-	88, 88, 88, 88, 88, 88, 88, 88,
-	0, -88, -88, -88, -88, -88, -88, -88,
-	-88, -88, -88, -88, -88, -88, -88, -88,
-	-88, -88, -88, -88, -88, -88, -88, -88,
-	-88, -88, -88, -88, -88, -88, -88, -88,
-	-88, -88, -88, -88, -88, -88, -88, -88,
-	-88, -88, -88, -88, -88, -88, -88, -88,
-	-88, -88, -88, -88, -88, -88, -88, -88,
-	-88, -88, -88, -88, -88, -88, -88, -88,
-	-88, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0,
-}
-};
-const static signed char* zywrleParam[3][3][3]={
-	{{zywrleConv[0],zywrleConv[2],zywrleConv[0]},{zywrleConv[0],zywrleConv[0],zywrleConv[0]},{zywrleConv[0],zywrleConv[0],zywrleConv[0]}},
-	{{zywrleConv[0],zywrleConv[3],zywrleConv[0]},{zywrleConv[1],zywrleConv[1],zywrleConv[1]},{zywrleConv[0],zywrleConv[0],zywrleConv[0]}},
-	{{zywrleConv[0],zywrleConv[3],zywrleConv[0]},{zywrleConv[2],zywrleConv[2],zywrleConv[2]},{zywrleConv[1],zywrleConv[1],zywrleConv[1]}},
-};
-#  endif
-#endif
-
-static InlineX void Harr(signed char* pX0, signed char* pX1)
-{
-	/* Piecewise-Linear Harr(PLHarr) */
-	int X0 = (int)*pX0, X1 = (int)*pX1;
-	int orgX0 = X0, orgX1 = X1;
-	if ((X0 ^ X1) & 0x80) {
-		/* differ sign */
-		X1 += X0;
-		if (((X1^orgX1)&0x80)==0) {
-			/* |X1| > |X0| */
-			X0 -= X1;	/* H = -B */
-		}
-	} else {
-		/* same sign */
-		X0 -= X1;
-		if (((X0 ^ orgX0) & 0x80) == 0) {
-			/* |X0| > |X1| */
-			X1 += X0;	/* L = A */
-		}
-	}
-	*pX0 = (signed char)X1;
-	*pX1 = (signed char)X0;
-}
-/*
- 1D-Wavelet transform.
-
- In coefficients array, the famous 'pyramid' decomposition is well used.
-
- 1D Model:
-   |L0L0L0L0|L0L0L0L0|H0H0H0H0|H0H0H0H0| : level 0
-   |L1L1L1L1|H1H1H1H1|H0H0H0H0|H0H0H0H0| : level 1
-
- But this method needs line buffer because H/L is different position from X0/X1.
- So, I used 'interleave' decomposition instead of it.
-
- 1D Model:
-   |L0H0L0H0|L0H0L0H0|L0H0L0H0|L0H0L0H0| : level 0
-   |L1H0H1H0|L1H0H1H0|L1H0H1H0|L1H0H1H0| : level 1
-
- In this method, H/L and X0/X1 is always same position.
- This lead us to more speed and less memory.
- Of cause, the result of both method is quite same
- because it's only difference that coefficient position.
-*/
-static InlineX void WaveletLevel(int* data, int size, int l, int SkipPixel)
-{
-	int s, ofs;
-	signed char* pX0;
-	signed char* end;
-
-	pX0 = (signed char*)data;
-	s = (8<<l)*SkipPixel;
-	end = pX0+(size>>(l+1))*s;
-	s -= 2;
-	ofs = (4<<l)*SkipPixel;
-	while (pX0 < end) {
-		Harr(pX0, pX0+ofs);
-		pX0++;
-		Harr(pX0, pX0+ofs);
-		pX0++;
-		Harr(pX0, pX0+ofs);
-		pX0 += s;
-	}
-}
-#define InvWaveletLevel(d,s,l,pix) WaveletLevel(d,s,l,pix)
-
-#ifdef ZYWRLE_ENCODE
-#  ifndef ZYWRLE_QUANTIZE
-/* Type A:lower bit omitting of EZW style. */
-static InlineX void FilterWaveletSquare(int* pBuf, int width, int height, int level, int l)
-{
-	int r, s;
-	int x, y;
-	int* pH;
-	const unsigned int* pM;
-
-	pM = &(zywrleParam[level-1][l]);
-	s = 2<<l;
-	for (r = 1; r < 4; r++) {
-		pH   = pBuf;
-		if (r & 0x01)
-			pH +=  s>>1;
-		if (r & 0x02)
-			pH += (s>>1)*width;
-		for (y = 0; y < height / s; y++) {
-			for (x = 0; x < width / s; x++) {
-				/*
-				 these are same following code.
-				     pH[x] = pH[x] / (~pM[x]+1) * (~pM[x]+1);
-				     ( round pH[x] with pM[x] bit )
-				 '&' operator isn't 'round' but is 'floor'.
-				 So, we must offset when pH[x] is negative.
-				*/
-				if (((signed char*)pH)[0] & 0x80)
-					((signed char*)pH)[0] += ~((signed char*)pM)[0];
-				if (((signed char*)pH)[1] & 0x80)
-					((signed char*)pH)[1] += ~((signed char*)pM)[1];
-				if (((signed char*)pH)[2] & 0x80)
-					((signed char*)pH)[2] += ~((signed char*)pM)[2];
-				*pH &= *pM;
-				pH += s;
-			}
-			pH += (s-1)*width;
-		}
-	}
-}
-#  else
-/*
- Type B:Non liner quantization filter.
-
- Coefficients have Gaussian curve and smaller value which is
- large part of coefficients isn't more important than larger value.
- So, I use filter of Non liner quantize/dequantize table.
- In general, Non liner quantize formula is explained as following.
-
-    y=f(x)   = sign(x)*round( ((abs(x)/(2^7))^ r   )* 2^(bo-1) )*2^(8-bo)
-    x=f-1(y) = sign(y)*round( ((abs(y)/(2^7))^(1/r))* 2^(bi-1) )*2^(8-bi)
- ( r:power coefficient  bi:effective MSB in input  bo:effective MSB in output )
-
-   r < 1.0 : Smaller value is more important than larger value.
-   r > 1.0 : Larger value is more important than smaller value.
-   r = 1.0 : Liner quantization which is same with EZW style.
-
- r = 0.75 is famous non liner quantization used in MP3 audio codec.
- In contrast to audio data, larger value is important in wavelet coefficients.
- So, I select r = 2.0 table( quantize is x^2, dequantize sqrt(x) ).
-
- As compared with EZW style liner quantization, this filter tended to be
- more sharp edge and be more compression rate but be more blocking noise and be less quality.
- Especially, the surface of graphic objects has distinguishable noise in middle quality mode.
-
- We need only quantized-dequantized(filtered) value rather than quantized value itself
- because all values are packed or palette-lized in later ZRLE section.
- This lead us not to need to modify client decoder when we change
- the filtering procedure in future.
- Client only decodes coefficients given by encoder.
-*/
-static InlineX void FilterWaveletSquare(int* pBuf, int width, int height, int level, int l)
-{
-	int r, s;
-	int x, y;
-	int* pH;
-	const signed char** pM;
-
-	pM = zywrleParam[level-1][l];
-	s = 2<<l;
-	for (r = 1; r < 4; r++) {
-		pH   = pBuf;
-		if (r & 0x01)
-			pH +=  s>>1;
-		if (r & 0x02)
-			pH += (s>>1)*width;
-		for (y = 0; y < height / s; y++) {
-			for (x = 0; x < width / s; x++) {
-				((signed char*)pH)[0] = pM[0][((unsigned char*)pH)[0]];
-				((signed char*)pH)[1] = pM[1][((unsigned char*)pH)[1]];
-				((signed char*)pH)[2] = pM[2][((unsigned char*)pH)[2]];
-				pH += s;
-			}
-			pH += (s-1)*width;
-		}
-	}
-}
-#  endif
-
-static InlineX void Wavelet(int* pBuf, int width, int height, int level)
-{
-	int l, s;
-	int* pTop;
-	int* pEnd;
-
-	for (l = 0; l < level; l++) {
-		pTop = pBuf;
-		pEnd = pBuf+height*width;
-		s = width<<l;
-		while (pTop < pEnd) {
-			WaveletLevel(pTop, width, l, 1);
-			pTop += s;
-		}
-		pTop = pBuf;
-		pEnd = pBuf+width;
-		s = 1<<l;
-		while (pTop < pEnd) {
-			WaveletLevel(pTop, height,l, width);
-			pTop += s;
-		}
-		FilterWaveletSquare(pBuf, width, height, level, l);
-	}
-}
-#endif
-#ifdef ZYWRLE_DECODE
-static InlineX void InvWavelet(int* pBuf, int width, int height, int level)
-{
-	int l, s;
-	int* pTop;
-	int* pEnd;
-
-	for (l = level - 1; l >= 0; l--) {
-		pTop = pBuf;
-		pEnd = pBuf+width;
-		s = 1<<l;
-		while (pTop < pEnd) {
-			InvWaveletLevel(pTop, height,l, width);
-			pTop += s;
-		}
-		pTop = pBuf;
-		pEnd = pBuf+height*width;
-		s = width<<l;
-		while (pTop < pEnd) {
-			InvWaveletLevel(pTop, width, l, 1);
-			pTop += s;
-		}
-	}
-}
-#endif
-
-/* Load/Save coefficients stuffs.
- Coefficients manages as 24 bits little-endian pixel. */
-#define ZYWRLE_LOAD_COEFF(pSrc,R,G,B) { \
-	R = ((signed char*)pSrc)[2];	\
-	G = ((signed char*)pSrc)[1];	\
-	B = ((signed char*)pSrc)[0];	\
-}
-#define ZYWRLE_SAVE_COEFF(pDst,R,G,B) { \
-	((signed char*)pDst)[2] = (signed char)R;	\
-	((signed char*)pDst)[1] = (signed char)G;	\
-	((signed char*)pDst)[0] = (signed char)B;	\
-}
-
-/*
- RGB <=> YUV conversion stuffs.
- YUV coversion is explained as following formula in strict meaning:
-   Y =  0.299R + 0.587G + 0.114B (   0<=Y<=255)
-   U = -0.169R - 0.331G + 0.500B (-128<=U<=127)
-   V =  0.500R - 0.419G - 0.081B (-128<=V<=127)
-
- I use simple conversion RCT(reversible color transform) which is described
- in JPEG-2000 specification.
-   Y = (R + 2G + B)/4 (   0<=Y<=255)
-   U = B-G (-256<=U<=255)
-   V = R-G (-256<=V<=255)
-*/
-#define ROUND(x) (((x)<0)?0:(((x)>255)?255:(x)))
-	/* RCT is N-bit RGB to N-bit Y and N+1-bit UV.
-	 For make Same N-bit, UV is lossy.
-	 More exact PLHarr, we reduce to odd range(-127<=x<=127). */
-#define ZYWRLE_RGBYUV1(R,G,B,Y,U,V,ymask,uvmask) { \
-	Y = (R+(G<<1)+B)>>2;	\
-	U =  B-G;	\
-	V =  R-G;	\
-	Y -= 128;	\
-	U >>= 1;	\
-	V >>= 1;	\
-	Y &= ymask;	\
-	U &= uvmask;	\
-	V &= uvmask;	\
-	if (Y == -128)	\
-		Y += (0xFFFFFFFF-ymask+1);	\
-	if (U == -128)	\
-		U += (0xFFFFFFFF-uvmask+1);	\
-	if (V == -128)	\
-		V += (0xFFFFFFFF-uvmask+1);	\
-}
-#define ZYWRLE_YUVRGB1(R,G,B,Y,U,V) { \
-	Y += 128;	\
-	U <<= 1;	\
-	V <<= 1;	\
-	G = Y-((U+V)>>2);	\
-	B = U+G;	\
-	R = V+G;	\
-	G = ROUND(G);	\
-	B = ROUND(B);	\
-	R = ROUND(R);	\
-}
-
-/*
- coefficient packing/unpacking stuffs.
- Wavelet transform makes 4 sub coefficient image from 1 original image.
-
- model with pyramid decomposition:
-   +------+------+
-   |      |      |
-   |  L   |  Hx  |
-   |      |      |
-   +------+------+
-   |      |      |
-   |  H   |  Hxy |
-   |      |      |
-   +------+------+
-
- So, we must transfer each sub images individually in strict meaning.
- But at least ZRLE meaning, following one decompositon image is same as
- avobe individual sub image. I use this format.
- (Strictly saying, transfer order is reverse(Hxy->Hy->Hx->L)
-  for simplified procedure for any wavelet level.)
-
-   +------+------+
-   |      L      |
-   +------+------+
-   |      Hx     |
-   +------+------+
-   |      Hy     |
-   +------+------+
-   |      Hxy    |
-   +------+------+
-*/
-#define INC_PTR(data) \
-	data++;	\
-	if( data-pData >= (w+uw) ){	\
-		data += scanline-(w+uw);	\
-		pData = data;	\
-	}
-
-#define ZYWRLE_TRANSFER_COEFF(pBuf,data,r,w,h,scanline,level,TRANS)	\
-	pH = pBuf;	\
-	s = 2<<level;	\
-	if (r & 0x01)	\
-		pH +=  s>>1;	\
-	if (r & 0x02)	\
-		pH += (s>>1)*w;	\
-	pEnd = pH+h*w;	\
-	while (pH < pEnd) {	\
-		pLine = pH+w;	\
-		while (pH < pLine) {	\
-			TRANS	\
-			INC_PTR(data)	\
-			pH += s;	\
-		}	\
-		pH += (s-1)*w;	\
-	}
-
-#define ZYWRLE_PACK_COEFF(pBuf,data,r,width,height,scanline,level)	\
-	ZYWRLE_TRANSFER_COEFF(pBuf,data,r,width,height,scanline,level,ZYWRLE_LOAD_COEFF(pH,R,G,B);ZYWRLE_SAVE_PIXEL(data,R,G,B);)
-
-#define ZYWRLE_UNPACK_COEFF(pBuf,data,r,width,height,scanline,level)	\
-	ZYWRLE_TRANSFER_COEFF(pBuf,data,r,width,height,scanline,level,ZYWRLE_LOAD_PIXEL(data,R,G,B);ZYWRLE_SAVE_COEFF(pH,R,G,B);)
-
-#define ZYWRLE_SAVE_UNALIGN(data,TRANS)	\
-	pTop = pBuf+w*h;	\
-	pEnd = pBuf + (w+uw)*(h+uh);	\
-	while (pTop < pEnd) {	\
-		TRANS	\
-		INC_PTR(data)	\
-		pTop++;	\
-	}
-
-#define ZYWRLE_LOAD_UNALIGN(data,TRANS)	\
-	pTop = pBuf+w*h;	\
-	if (uw) {	\
-		pData=         data + w;	\
-		pEnd = (int*)(pData+ h*scanline);	\
-		while (pData < (PIXEL_T*)pEnd) {	\
-			pLine = (int*)(pData + uw);	\
-			while (pData < (PIXEL_T*)pLine) {	\
-				TRANS	\
-				pData++;	\
-				pTop++;	\
-			}	\
-			pData += scanline-uw;	\
-		}	\
-	}	\
-	if (uh) {	\
-		pData=         data +  h*scanline;	\
-		pEnd = (int*)(pData+ uh*scanline);	\
-		while (pData < (PIXEL_T*)pEnd) {	\
-			pLine = (int*)(pData + w);	\
-			while (pData < (PIXEL_T*)pLine) {	\
-				TRANS	\
-				pData++;	\
-				pTop++;	\
-			}	\
-			pData += scanline-w;	\
-		}	\
-	}	\
-	if (uw && uh) {	\
-		pData=         data + w+ h*scanline;	\
-		pEnd = (int*)(pData+   uh*scanline);	\
-		while (pData < (PIXEL_T*)pEnd) {	\
-			pLine = (int*)(pData + uw);	\
-			while (pData < (PIXEL_T*)pLine) {	\
-				TRANS	\
-				pData++;	\
-				pTop++;	\
-			}	\
-			pData += scanline-uw;	\
-		}	\
-	}
-
-static InlineX void zywrleCalcSize(int* pW, int* pH, int level)
-{
-	*pW &= ~((1<<level)-1);
-	*pH &= ~((1<<level)-1);
-}
-
-#endif /* ZYWRLE_ONCE */
-
-#ifndef CPIXEL
-#ifdef ZYWRLE_ENCODE
-static InlineX void ZYWRLE_RGBYUV(int* pBuf, PIXEL_T* data, int width, int height, int scanline)
-{
-	int R, G, B;
-	int Y, U, V;
-	int* pLine;
-	int* pEnd;
-	pEnd = pBuf+height*width;
-	while (pBuf < pEnd) {
-		pLine = pBuf+width;
-		while (pBuf < pLine) {
-			ZYWRLE_LOAD_PIXEL(data,R,G,B);
-			ZYWRLE_RGBYUV1(R,G,B,Y,U,V,ZYWRLE_YMASK,ZYWRLE_UVMASK);
-			ZYWRLE_SAVE_COEFF(pBuf,V,Y,U);
-			pBuf++;
-			data++;
-		}
-		data += scanline-width;
-	}
-}
-#endif
-#ifdef ZYWRLE_DECODE
-static InlineX void ZYWRLE_YUVRGB(int* pBuf, PIXEL_T* data, int width, int height, int scanline) {
-	int R, G, B;
-	int Y, U, V;
-	int* pLine;
-	int* pEnd;
-	pEnd = pBuf+height*width;
-	while (pBuf < pEnd) {
-		pLine = pBuf+width;
-		while (pBuf < pLine) {
-			ZYWRLE_LOAD_COEFF(pBuf,V,Y,U);
-			ZYWRLE_YUVRGB1(R,G,B,Y,U,V);
-			ZYWRLE_SAVE_PIXEL(data,R,G,B);
-			pBuf++;
-			data++;
-		}
-		data += scanline-width;
-	}
-}
-#endif
-
-#ifdef ZYWRLE_ENCODE
-PIXEL_T* ZYWRLE_ANALYZE(PIXEL_T* dst, PIXEL_T* src, int w, int h, int scanline, int level, int* pBuf) {
-	int l;
-	int uw = w;
-	int uh = h;
-	int* pTop;
-	int* pEnd;
-	int* pLine;
-	PIXEL_T* pData;
-	int R, G, B;
-	int s;
-	int* pH;
-
-	zywrleCalcSize(&w, &h, level);
-	if (w == 0 || h == 0)
-		return NULL;
-	uw -= w;
-	uh -= h;
-
-	pData = dst;
-	ZYWRLE_LOAD_UNALIGN(src,*(PIXEL_T*)pTop=*pData;)
-	ZYWRLE_RGBYUV(pBuf, src, w, h, scanline);
-	Wavelet(pBuf, w, h, level);
-	for (l = 0; l < level; l++) {
-		ZYWRLE_PACK_COEFF(pBuf, dst, 3, w, h, scanline, l);
-		ZYWRLE_PACK_COEFF(pBuf, dst, 2, w, h, scanline, l);
-		ZYWRLE_PACK_COEFF(pBuf, dst, 1, w, h, scanline, l);
-		if (l == level - 1) {
-			ZYWRLE_PACK_COEFF(pBuf, dst, 0, w, h, scanline, l);
-		}
-	}
-	ZYWRLE_SAVE_UNALIGN(dst,*dst=*(PIXEL_T*)pTop;)
-	return dst;
-}
-#endif
-#ifdef ZYWRLE_DECODE
-PIXEL_T* ZYWRLE_SYNTHESIZE(PIXEL_T* dst, PIXEL_T* src, int w, int h, int scanline, int level, int* pBuf)
-{
-	int l;
-	int uw = w;
-	int uh = h;
-	int* pTop;
-	int* pEnd;
-	int* pLine;
-	PIXEL_T* pData;
-	int R, G, B;
-	int s;
-	int* pH;
-
-	zywrleCalcSize(&w, &h, level);
-	if (w == 0 || h == 0)
-		return NULL;
-	uw -= w;
-	uh -= h;
-
-	pData = src;
-	for (l = 0; l < level; l++) {
-		ZYWRLE_UNPACK_COEFF(pBuf, src, 3, w, h, scanline, l);
-		ZYWRLE_UNPACK_COEFF(pBuf, src, 2, w, h, scanline, l);
-		ZYWRLE_UNPACK_COEFF(pBuf, src, 1, w, h, scanline, l);
-		if (l == level - 1) {
-			ZYWRLE_UNPACK_COEFF(pBuf, src, 0, w, h, scanline, l);
-		}
-	}
-	ZYWRLE_SAVE_UNALIGN(src,*(PIXEL_T*)pTop=*src;)
-	InvWavelet(pBuf, w, h, level);
-	ZYWRLE_YUVRGB(pBuf, dst, w, h, scanline);
-	ZYWRLE_LOAD_UNALIGN(dst,*pData=*(PIXEL_T*)pTop;)
-	return src;
-}
-#endif
-#endif  /* CPIXEL */
-
-#undef ZYWRLE_RGBYUV
-#undef ZYWRLE_YUVRGB
-#undef ZYWRLE_LOAD_PIXEL
-#undef ZYWRLE_SAVE_PIXEL
diff -urN remmina-plugins/vnc/libvncserver/libvncclient/corre.c remmina-plugins/vnc/libvncserver/libvncclient/corre.c
--- remmina-plugins/vnc/libvncserver/libvncclient/corre.c	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins/vnc/libvncserver/libvncclient/corre.c	1970-01-01 10:00:00.000000000 +1000
@@ -1,70 +0,0 @@
-/*
- *  Copyright (C) 1999 AT&T Laboratories Cambridge.  All Rights Reserved.
- *
- *  This is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This software is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this software; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
- *  USA.
- */
-
-/*
- * corre.c - handle CoRRE encoding.
- *
- * This file shouldn't be compiled directly.  It is included multiple times by
- * rfbproto.c, each time with a different definition of the macro BPP.  For
- * each value of BPP, this file defines a function which handles a CoRRE
- * encoded rectangle with BPP bits per pixel.
- */
-
-#define HandleCoRREBPP CONCAT2E(HandleCoRRE,BPP)
-#define CARDBPP CONCAT3E(uint,BPP,_t)
-
-static rfbBool
-HandleCoRREBPP (rfbClient* client, int rx, int ry, int rw, int rh)
-{
-    rfbRREHeader hdr;
-    int i;
-    CARDBPP pix;
-    uint8_t *ptr;
-    int x, y, w, h;
-
-    if (!ReadFromRFBServer(client, (char *)&hdr, sz_rfbRREHeader))
-	return FALSE;
-
-    hdr.nSubrects = rfbClientSwap32IfLE(hdr.nSubrects);
-
-    if (!ReadFromRFBServer(client, (char *)&pix, sizeof(pix)))
-	return FALSE;
-
-    FillRectangle(client, rx, ry, rw, rh, pix);
-
-    if (!ReadFromRFBServer(client, client->buffer, hdr.nSubrects * (4 + (BPP / 8))))
-	return FALSE;
-
-    ptr = (uint8_t *)client->buffer;
-
-    for (i = 0; i < hdr.nSubrects; i++) {
-	pix = *(CARDBPP *)ptr;
-	ptr += BPP/8;
-	x = *ptr++;
-	y = *ptr++;
-	w = *ptr++;
-	h = *ptr++;
-
-	FillRectangle(client, rx+x, ry+y, w, h, pix);
-    }
-
-    return TRUE;
-}
-
-#undef CARDBPP
diff -urN remmina-plugins/vnc/libvncserver/libvncclient/cursor.c remmina-plugins/vnc/libvncserver/libvncclient/cursor.c
--- remmina-plugins/vnc/libvncserver/libvncclient/cursor.c	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins/vnc/libvncserver/libvncclient/cursor.c	1970-01-01 10:00:00.000000000 +1000
@@ -1,179 +0,0 @@
-/*
- *  Copyright (C) 2001,2002 Constantin Kaplinsky.  All Rights Reserved.
- *
- *  This is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This software is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this software; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
- *  USA.
- */
-
-/*
- * cursor.c - code to support cursor shape updates (XCursor and
- * RichCursor preudo-encodings).
- */
-
-#include <rfb/rfbclient.h>
-
-
-#define OPER_SAVE     0
-#define OPER_RESTORE  1
-
-#define RGB24_TO_PIXEL(bpp,r,g,b)                                       \
-   ((((uint##bpp##_t)(r) & 0xFF) * client->format.redMax + 127) / 255             \
-    << client->format.redShift |                                              \
-    (((uint##bpp##_t)(g) & 0xFF) * client->format.greenMax + 127) / 255           \
-    << client->format.greenShift |                                            \
-    (((uint##bpp##_t)(b) & 0xFF) * client->format.blueMax + 127) / 255            \
-    << client->format.blueShift)
-
-
-/*********************************************************************
- * HandleCursorShape(). Support for XCursor and RichCursor shape
- * updates. We emulate cursor operating on the frame buffer (that is
- * why we call it "software cursor").
- ********************************************************************/
-
-rfbBool HandleCursorShape(rfbClient* client,int xhot, int yhot, int width, int height, uint32_t enc)
-{
-  int bytesPerPixel;
-  size_t bytesPerRow, bytesMaskData;
-  rfbXCursorColors rgb;
-  uint32_t colors[2];
-  char *buf;
-  uint8_t *ptr;
-  int x, y, b;
-
-  bytesPerPixel = client->format.bitsPerPixel / 8;
-  bytesPerRow = (width + 7) / 8;
-  bytesMaskData = bytesPerRow * height;
-
-  if (width * height == 0)
-    return TRUE;
-
-  /* Allocate memory for pixel data and temporary mask data. */
-  if(client->rcSource)
-    free(client->rcSource);
-
-  client->rcSource = malloc(width * height * bytesPerPixel);
-  if (client->rcSource == NULL)
-    return FALSE;
-
-  buf = malloc(bytesMaskData);
-  if (buf == NULL) {
-    free(client->rcSource);
-    client->rcSource = NULL;
-    return FALSE;
-  }
-
-  /* Read and decode cursor pixel data, depending on the encoding type. */
-
-  if (enc == rfbEncodingXCursor) {
-    /* Read and convert background and foreground colors. */
-    if (!ReadFromRFBServer(client, (char *)&rgb, sz_rfbXCursorColors)) {
-      free(client->rcSource);
-      client->rcSource = NULL;
-      free(buf);
-      return FALSE;
-    }
-    colors[0] = RGB24_TO_PIXEL(32, rgb.backRed, rgb.backGreen, rgb.backBlue);
-    colors[1] = RGB24_TO_PIXEL(32, rgb.foreRed, rgb.foreGreen, rgb.foreBlue);
-
-    /* Read 1bpp pixel data into a temporary buffer. */
-    if (!ReadFromRFBServer(client, buf, bytesMaskData)) {
-      free(client->rcSource);
-      client->rcSource = NULL;
-      free(buf);
-      return FALSE;
-    }
-
-    /* Convert 1bpp data to byte-wide color indices. */
-    ptr = client->rcSource;
-    for (y = 0; y < height; y++) {
-      for (x = 0; x < width / 8; x++) {
-	for (b = 7; b >= 0; b--) {
-	  *ptr = buf[y * bytesPerRow + x] >> b & 1;
-	  ptr += bytesPerPixel;
-	}
-      }
-      for (b = 7; b > 7 - width % 8; b--) {
-	*ptr = buf[y * bytesPerRow + x] >> b & 1;
-	ptr += bytesPerPixel;
-      }
-    }
-
-    /* Convert indices into the actual pixel values. */
-    switch (bytesPerPixel) {
-    case 1:
-      for (x = 0; x < width * height; x++)
-	client->rcSource[x] = (uint8_t)colors[client->rcSource[x]];
-      break;
-    case 2:
-      for (x = 0; x < width * height; x++)
-	((uint16_t *)client->rcSource)[x] = (uint16_t)colors[client->rcSource[x * 2]];
-      break;
-    case 4:
-      for (x = 0; x < width * height; x++)
-	((uint32_t *)client->rcSource)[x] = colors[client->rcSource[x * 4]];
-      break;
-    }
-
-  } else {			/* enc == rfbEncodingRichCursor */
-
-    if (!ReadFromRFBServer(client, (char *)client->rcSource, width * height * bytesPerPixel)) {
-      free(client->rcSource);
-      client->rcSource = NULL;
-      free(buf);
-      return FALSE;
-    }
-
-  }
-
-  /* Read and decode mask data. */
-
-  if (!ReadFromRFBServer(client, buf, bytesMaskData)) {
-    free(client->rcSource);
-    client->rcSource = NULL;
-    free(buf);
-    return FALSE;
-  }
-
-  client->rcMask = malloc(width * height);
-  if (client->rcMask == NULL) {
-    free(client->rcSource);
-    client->rcSource = NULL;
-    free(buf);
-    return FALSE;
-  }
-
-  ptr = client->rcMask;
-  for (y = 0; y < height; y++) {
-    for (x = 0; x < width / 8; x++) {
-      for (b = 7; b >= 0; b--) {
-	*ptr++ = buf[y * bytesPerRow + x] >> b & 1;
-      }
-    }
-    for (b = 7; b > 7 - width % 8; b--) {
-      *ptr++ = buf[y * bytesPerRow + x] >> b & 1;
-    }
-  }
-
-  if (client->GotCursorShape != NULL) {
-     client->GotCursorShape(client, xhot, yhot, width, height, bytesPerPixel);
-  }
-
-  free(buf);
-
-  return TRUE;
-}
-
-
diff -urN remmina-plugins/vnc/libvncserver/libvncclient/hextile.c remmina-plugins/vnc/libvncserver/libvncclient/hextile.c
--- remmina-plugins/vnc/libvncserver/libvncclient/hextile.c	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins/vnc/libvncserver/libvncclient/hextile.c	1970-01-01 10:00:00.000000000 +1000
@@ -1,127 +0,0 @@
-/*
- *  Copyright (C) 1999 AT&T Laboratories Cambridge.  All Rights Reserved.
- *
- *  This is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This software is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this software; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
- *  USA.
- */
-
-/*
- * hextile.c - handle hextile encoding.
- *
- * This file shouldn't be compiled directly.  It is included multiple times by
- * rfbproto.c, each time with a different definition of the macro BPP.  For
- * each value of BPP, this file defines a function which handles a hextile
- * encoded rectangle with BPP bits per pixel.
- */
-
-#define HandleHextileBPP CONCAT2E(HandleHextile,BPP)
-#define CARDBPP CONCAT3E(uint,BPP,_t)
-
-static rfbBool
-HandleHextileBPP (rfbClient* client, int rx, int ry, int rw, int rh)
-{
-  CARDBPP bg, fg;
-  int i;
-  uint8_t *ptr;
-  int x, y, w, h;
-  int sx, sy, sw, sh;
-  uint8_t subencoding;
-  uint8_t nSubrects;
-
-  for (y = ry; y < ry+rh; y += 16) {
-    for (x = rx; x < rx+rw; x += 16) {
-      w = h = 16;
-      if (rx+rw - x < 16)
-	w = rx+rw - x;
-      if (ry+rh - y < 16)
-	h = ry+rh - y;
-
-      if (!ReadFromRFBServer(client, (char *)&subencoding, 1))
-	return FALSE;
-
-      if (subencoding & rfbHextileRaw) {
-	if (!ReadFromRFBServer(client, client->buffer, w * h * (BPP / 8)))
-	  return FALSE;
-
-	CopyRectangle(client, (uint8_t *)client->buffer, x, y, w, h);
-
-	continue;
-      }
-
-      if (subencoding & rfbHextileBackgroundSpecified)
-	if (!ReadFromRFBServer(client, (char *)&bg, sizeof(bg)))
-	  return FALSE;
-
-      FillRectangle(client, x, y, w, h, bg);
-
-      if (subencoding & rfbHextileForegroundSpecified)
-	if (!ReadFromRFBServer(client, (char *)&fg, sizeof(fg)))
-	  return FALSE;
-
-      if (!(subencoding & rfbHextileAnySubrects)) {
-	continue;
-      }
-
-      if (!ReadFromRFBServer(client, (char *)&nSubrects, 1))
-	return FALSE;
-
-      ptr = (uint8_t*)client->buffer;
-
-      if (subencoding & rfbHextileSubrectsColoured) {
-	if (!ReadFromRFBServer(client, client->buffer, nSubrects * (2 + (BPP / 8))))
-	  return FALSE;
-
-	for (i = 0; i < nSubrects; i++) {
-#if BPP==8
-	  GET_PIXEL8(fg, ptr);
-#elif BPP==16
-	  GET_PIXEL16(fg, ptr);
-#elif BPP==32
-	  GET_PIXEL32(fg, ptr);
-#else
-#error "Invalid BPP"
-#endif
-	  sx = rfbHextileExtractX(*ptr);
-	  sy = rfbHextileExtractY(*ptr);
-	  ptr++;
-	  sw = rfbHextileExtractW(*ptr);
-	  sh = rfbHextileExtractH(*ptr);
-	  ptr++;
-
-	  FillRectangle(client, x+sx, y+sy, sw, sh, fg);
-	}
-
-      } else {
-	if (!ReadFromRFBServer(client, client->buffer, nSubrects * 2))
-	  return FALSE;
-
-	for (i = 0; i < nSubrects; i++) {
-	  sx = rfbHextileExtractX(*ptr);
-	  sy = rfbHextileExtractY(*ptr);
-	  ptr++;
-	  sw = rfbHextileExtractW(*ptr);
-	  sh = rfbHextileExtractH(*ptr);
-	  ptr++;
-
-	  FillRectangle(client, x+sx, y+sy, sw, sh, fg);
-	}
-      }
-    }
-  }
-
-  return TRUE;
-}
-
-#undef CARDBPP
diff -urN remmina-plugins/vnc/libvncserver/libvncclient/listen.c remmina-plugins/vnc/libvncserver/libvncclient/listen.c
--- remmina-plugins/vnc/libvncserver/libvncclient/listen.c	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins/vnc/libvncserver/libvncclient/listen.c	1970-01-01 10:00:00.000000000 +1000
@@ -1,172 +0,0 @@
-/*
- *  Copyright (C) 1999 AT&T Laboratories Cambridge.  All Rights Reserved.
- *
- *  This is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This software is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this software; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
- *  USA.
- */
-
-/*
- * listen.c - listen for incoming connections
- */
-
-#ifdef __STRICT_ANSI__
-#define _BSD_SOURCE
-#endif
-#include <unistd.h>
-#include <sys/types.h>
-#ifdef __MINGW32__
-#define close closesocket
-#include <winsock2.h>
-#undef max
-#else
-#include <sys/wait.h>
-#include <sys/utsname.h>
-#endif
-#include <sys/time.h>
-#include <rfb/rfbclient.h>
-
-/*
- * listenForIncomingConnections() - listen for incoming connections from
- * servers, and fork a new process to deal with each connection.
- */
-
-void
-listenForIncomingConnections(rfbClient* client)
-{
-#ifdef __MINGW32__
-  /* FIXME */
-  rfbClientErr("listenForIncomingConnections on MinGW32 NOT IMPLEMENTED\n");
-  return;
-#else
-  int listenSocket;
-  fd_set fds;
-
-  client->listenSpecified = TRUE;
-
-  listenSocket = ListenAtTcpPort(client->listenPort);
-
-  if ((listenSocket < 0))
-    return;
-
-  rfbClientLog("%s -listen: Listening on port %d\n",
-	  client->programName,client->listenPort);
-  rfbClientLog("%s -listen: Command line errors are not reported until "
-	  "a connection comes in.\n", client->programName);
-
-  while (TRUE) {
-
-    /* reap any zombies */
-    int status, pid;
-    while ((pid= wait3(&status, WNOHANG, (struct rusage *)0))>0);
-
-    /* TODO: callback for discard any events (like X11 events) */
-
-    FD_ZERO(&fds); 
-
-    FD_SET(listenSocket, &fds);
-
-    select(listenSocket+1, &fds, NULL, NULL, NULL);
-
-    if (FD_ISSET(listenSocket, &fds)) {
-      client->sock = AcceptTcpConnection(listenSocket);
-      if (client->sock < 0)
-	return;
-      if (!SetNonBlocking(client->sock))
-	return;
-
-      /* Now fork off a new process to deal with it... */
-
-      switch (fork()) {
-
-      case -1: 
-	rfbClientErr("fork\n"); 
-	return;
-
-      case 0:
-	/* child - return to caller */
-	close(listenSocket);
-	return;
-
-      default:
-	/* parent - go round and listen again */
-	close(client->sock); 
-	break;
-      }
-    }
-  }
-#endif
-}
-
-
-
-/*
- * listenForIncomingConnectionsNoFork() - listen for incoming connections
- * from servers, but DON'T fork, instead just wait timeout microseconds.
- * If timeout is negative, block indefinitly.
- * Returns 1 on success (there was an incoming connection on the listen socket
- * and we accepted it successfully), -1 on error, 0 on timeout.
- */
-
-int
-listenForIncomingConnectionsNoFork(rfbClient* client, int timeout)
-{
-  fd_set fds;
-  struct timeval to;
-  int r;
-
-  to.tv_sec= timeout / 1000000;
-  to.tv_usec= timeout % 1000000;
-
-  client->listenSpecified = TRUE;
-
-  if (client->listenSock < 0)
-    {
-      client->listenSock = ListenAtTcpPort(client->listenPort);
-
-      if (client->listenSock < 0)
-	return -1;
-
-      rfbClientLog("%s -listennofork: Listening on port %d\n",
-		   client->programName,client->listenPort);
-      rfbClientLog("%s -listennofork: Command line errors are not reported until "
-		   "a connection comes in.\n", client->programName);
-    }
-
-  FD_ZERO(&fds);
-
-  FD_SET(client->listenSock, &fds);
-
-  if (timeout < 0)
-    r = select(client->listenSock+1, &fds, NULL, NULL, NULL);
-  else
-    r = select(client->listenSock+1, &fds, NULL, NULL, &to);
-
-  if (r > 0)
-    {
-      client->sock = AcceptTcpConnection(client->listenSock);
-      if (client->sock < 0)
-	return -1;
-      if (!SetNonBlocking(client->sock))
-	return -1;
-
-      close(client->listenSock);
-      return r;
-    }
-
-  /* r is now either 0 (timeout) or -1 (error) */
-  return r;
-}
-
-
diff -urN remmina-plugins/vnc/libvncserver/libvncclient/rfbproto.c remmina-plugins/vnc/libvncserver/libvncclient/rfbproto.c
--- remmina-plugins/vnc/libvncserver/libvncclient/rfbproto.c	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins/vnc/libvncserver/libvncclient/rfbproto.c	1970-01-01 10:00:00.000000000 +1000
@@ -1,2406 +0,0 @@
-/*
- *  Copyright (C) 2000-2002 Constantin Kaplinsky.  All Rights Reserved.
- *  Copyright (C) 2000 Tridia Corporation.  All Rights Reserved.
- *  Copyright (C) 1999 AT&T Laboratories Cambridge.  All Rights Reserved.
- *
- *  This is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This software is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this software; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
- *  USA.
- */
-
-/*
- * rfbproto.c - functions to deal with client side of RFB protocol.
- */
-
-#ifdef __STRICT_ANSI__
-#define _BSD_SOURCE
-#define _POSIX_SOURCE
-#endif
-#ifndef WIN32
-#include <unistd.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <pwd.h>
-#endif
-#include <errno.h>
-#include <rfb/rfbclient.h>
-#ifdef LIBVNCSERVER_HAVE_LIBZ
-#include <zlib.h>
-#ifdef __CHECKER__
-#undef Z_NULL
-#define Z_NULL NULL
-#endif
-#endif
-#ifdef LIBVNCSERVER_HAVE_LIBJPEG
-#ifdef _RPCNDR_H /* This Windows header typedefs 'boolean', jpeglib has to know */
-#define HAVE_BOOLEAN
-#endif
-#include <jpeglib.h>
-#endif
-#include <stdarg.h>
-#include <time.h>
-
-#ifdef LIBVNCSERVER_WITH_CLIENT_GCRYPT
-#ifdef WIN32
-#undef SOCKET
-#undef socklen_t
-#endif
-#include <gcrypt.h>
-#endif
-
-#include "minilzo.h"
-#include "tls.h"
-
-/*
- * rfbClientLog prints a time-stamped message to the log file (stderr).
- */
-
-rfbBool rfbEnableClientLogging=TRUE;
-
-static void
-rfbDefaultClientLog(const char *format, ...)
-{
-    va_list args;
-    char buf[256];
-    time_t log_clock;
-
-    if(!rfbEnableClientLogging)
-      return;
-
-    va_start(args, format);
-
-    time(&log_clock);
-    strftime(buf, 255, "%d/%m/%Y %X ", localtime(&log_clock));
-    fprintf(stderr, "%s", buf);
-
-    vfprintf(stderr, format, args);
-    fflush(stderr);
-
-    va_end(args);
-}
-
-rfbClientLogProc rfbClientLog=rfbDefaultClientLog;
-rfbClientLogProc rfbClientErr=rfbDefaultClientLog;
-
-/* extensions */
-
-rfbClientProtocolExtension* rfbClientExtensions = NULL;
-
-void rfbClientRegisterExtension(rfbClientProtocolExtension* e)
-{
-	e->next = rfbClientExtensions;
-	rfbClientExtensions = e;
-}
-
-/* client data */
-
-void rfbClientSetClientData(rfbClient* client, void* tag, void* data)
-{
-	rfbClientData* clientData = client->clientData;
-
-	while(clientData && clientData->tag != tag)
-		clientData = clientData->next;
-	if(clientData == NULL) {
-		clientData = calloc(sizeof(rfbClientData), 1);
-		clientData->next = client->clientData;
-		client->clientData = clientData;
-		clientData->tag = tag;
-	}
-
-	clientData->data = data;
-}
-
-void* rfbClientGetClientData(rfbClient* client, void* tag)
-{
-	rfbClientData* clientData = client->clientData;
-
-	while(clientData) {
-		if(clientData->tag == tag)
-			return clientData->data;
-		clientData = clientData->next;
-	}
-
-	return NULL;
-}
-
-/* messages */
-
-static void FillRectangle(rfbClient* client, int x, int y, int w, int h, uint32_t colour) {
-  int i,j;
-
-#define FILL_RECT(BPP) \
-    for(j=y*client->width;j<(y+h)*client->width;j+=client->width) \
-      for(i=x;i<x+w;i++) \
-	((uint##BPP##_t*)client->frameBuffer)[j+i]=colour;
-
-  switch(client->format.bitsPerPixel) {
-  case  8: FILL_RECT(8);  break;
-  case 16: FILL_RECT(16); break;
-  case 32: FILL_RECT(32); break;
-  default:
-    rfbClientLog("Unsupported bitsPerPixel: %d\n",client->format.bitsPerPixel);
-  }
-}
-
-static void CopyRectangle(rfbClient* client, uint8_t* buffer, int x, int y, int w, int h) {
-  int j;
-
-#define COPY_RECT(BPP) \
-  { \
-    int rs = w * BPP / 8, rs2 = client->width * BPP / 8; \
-    for (j = ((x * (BPP / 8)) + (y * rs2)); j < (y + h) * rs2; j += rs2) { \
-      memcpy(client->frameBuffer + j, buffer, rs); \
-      buffer += rs; \
-    } \
-  }
-
-  switch(client->format.bitsPerPixel) {
-  case  8: COPY_RECT(8);  break;
-  case 16: COPY_RECT(16); break;
-  case 32: COPY_RECT(32); break;
-  default:
-    rfbClientLog("Unsupported bitsPerPixel: %d\n",client->format.bitsPerPixel);
-  }
-}
-
-/* TODO: test */
-static void CopyRectangleFromRectangle(rfbClient* client, int src_x, int src_y, int w, int h, int dest_x, int dest_y) {
-  int i,j;
-
-#define COPY_RECT_FROM_RECT(BPP) \
-  { \
-    uint##BPP##_t* _buffer=((uint##BPP##_t*)client->frameBuffer)+(src_y-dest_y)*client->width+src_x-dest_x; \
-    if (dest_y < src_y) { \
-      for(j = dest_y*client->width; j < (dest_y+h)*client->width; j += client->width) { \
-        if (dest_x < src_x) { \
-          for(i = dest_x; i < dest_x+w; i++) { \
-            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \
-          } \
-        } else { \
-          for(i = dest_x+w-1; i >= dest_x; i--) { \
-            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \
-          } \
-        } \
-      } \
-    } else { \
-      for(j = (dest_y+h-1)*client->width; j >= dest_y*client->width; j-=client->width) { \
-        if (dest_x < src_x) { \
-          for(i = dest_x; i < dest_x+w; i++) { \
-            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \
-          } \
-        } else { \
-          for(i = dest_x+w-1; i >= dest_x; i--) { \
-            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \
-          } \
-        } \
-      } \
-    } \
-  }
-
-  switch(client->format.bitsPerPixel) {
-  case  8: COPY_RECT_FROM_RECT(8);  break;
-  case 16: COPY_RECT_FROM_RECT(16); break;
-  case 32: COPY_RECT_FROM_RECT(32); break;
-  default:
-    rfbClientLog("Unsupported bitsPerPixel: %d\n",client->format.bitsPerPixel);
-  }
-}
-
-static rfbBool HandleRRE8(rfbClient* client, int rx, int ry, int rw, int rh);
-static rfbBool HandleRRE16(rfbClient* client, int rx, int ry, int rw, int rh);
-static rfbBool HandleRRE32(rfbClient* client, int rx, int ry, int rw, int rh);
-static rfbBool HandleCoRRE8(rfbClient* client, int rx, int ry, int rw, int rh);
-static rfbBool HandleCoRRE16(rfbClient* client, int rx, int ry, int rw, int rh);
-static rfbBool HandleCoRRE32(rfbClient* client, int rx, int ry, int rw, int rh);
-static rfbBool HandleHextile8(rfbClient* client, int rx, int ry, int rw, int rh);
-static rfbBool HandleHextile16(rfbClient* client, int rx, int ry, int rw, int rh);
-static rfbBool HandleHextile32(rfbClient* client, int rx, int ry, int rw, int rh);
-static rfbBool HandleUltra8(rfbClient* client, int rx, int ry, int rw, int rh);
-static rfbBool HandleUltra16(rfbClient* client, int rx, int ry, int rw, int rh);
-static rfbBool HandleUltra32(rfbClient* client, int rx, int ry, int rw, int rh);
-static rfbBool HandleUltraZip8(rfbClient* client, int rx, int ry, int rw, int rh);
-static rfbBool HandleUltraZip16(rfbClient* client, int rx, int ry, int rw, int rh);
-static rfbBool HandleUltraZip32(rfbClient* client, int rx, int ry, int rw, int rh);
-#ifdef LIBVNCSERVER_HAVE_LIBZ
-static rfbBool HandleZlib8(rfbClient* client, int rx, int ry, int rw, int rh);
-static rfbBool HandleZlib16(rfbClient* client, int rx, int ry, int rw, int rh);
-static rfbBool HandleZlib32(rfbClient* client, int rx, int ry, int rw, int rh);
-#ifdef LIBVNCSERVER_HAVE_LIBJPEG
-static rfbBool HandleTight8(rfbClient* client, int rx, int ry, int rw, int rh);
-static rfbBool HandleTight16(rfbClient* client, int rx, int ry, int rw, int rh);
-static rfbBool HandleTight32(rfbClient* client, int rx, int ry, int rw, int rh);
-
-static long ReadCompactLen (rfbClient* client);
-
-static void JpegInitSource(j_decompress_ptr cinfo);
-static boolean JpegFillInputBuffer(j_decompress_ptr cinfo);
-static void JpegSkipInputData(j_decompress_ptr cinfo, long num_bytes);
-static void JpegTermSource(j_decompress_ptr cinfo);
-static void JpegSetSrcManager(j_decompress_ptr cinfo, uint8_t *compressedData,
-                              int compressedLen);
-#endif
-static rfbBool HandleZRLE8(rfbClient* client, int rx, int ry, int rw, int rh);
-static rfbBool HandleZRLE15(rfbClient* client, int rx, int ry, int rw, int rh);
-static rfbBool HandleZRLE16(rfbClient* client, int rx, int ry, int rw, int rh);
-static rfbBool HandleZRLE24(rfbClient* client, int rx, int ry, int rw, int rh);
-static rfbBool HandleZRLE24Up(rfbClient* client, int rx, int ry, int rw, int rh);
-static rfbBool HandleZRLE24Down(rfbClient* client, int rx, int ry, int rw, int rh);
-static rfbBool HandleZRLE32(rfbClient* client, int rx, int ry, int rw, int rh);
-#endif
-
-/*
- * Server Capability Functions
- */
-rfbBool
-SupportsClient2Server(rfbClient* client, int messageType)
-{
-    return (client->supportedMessages.client2server[((messageType & 0xFF)/8)] & (1<<(messageType % 8)) ? TRUE : FALSE);
-}
-
-rfbBool
-SupportsServer2Client(rfbClient* client, int messageType)
-{
-    return (client->supportedMessages.server2client[((messageType & 0xFF)/8)] & (1<<(messageType % 8)) ? TRUE : FALSE);
-}
-
-void
-SetClient2Server(rfbClient* client, int messageType)
-{
-  client->supportedMessages.client2server[((messageType & 0xFF)/8)] |= (1<<(messageType % 8));
-}
-
-void
-SetServer2Client(rfbClient* client, int messageType)
-{
-  client->supportedMessages.server2client[((messageType & 0xFF)/8)] |= (1<<(messageType % 8));
-}
-
-void
-ClearClient2Server(rfbClient* client, int messageType)
-{
-  client->supportedMessages.client2server[((messageType & 0xFF)/8)] &= (!(1<<(messageType % 8)));
-}
-
-void
-ClearServer2Client(rfbClient* client, int messageType)
-{
-  client->supportedMessages.server2client[((messageType & 0xFF)/8)] &= (!(1<<(messageType % 8)));
-}
-
-
-void
-DefaultSupportedMessages(rfbClient* client)
-{
-    memset((char *)&client->supportedMessages,0,sizeof(client->supportedMessages));
-
-    /* Default client supported messages (universal RFB 3.3 protocol) */
-    SetClient2Server(client, rfbSetPixelFormat);
-    /* SetClient2Server(client, rfbFixColourMapEntries); Not currently supported */
-    SetClient2Server(client, rfbSetEncodings);
-    SetClient2Server(client, rfbFramebufferUpdateRequest);
-    SetClient2Server(client, rfbKeyEvent);
-    SetClient2Server(client, rfbPointerEvent);
-    SetClient2Server(client, rfbClientCutText);
-    /* technically, we only care what we can *send* to the server
-     * but, we set Server2Client Just in case it ever becomes useful
-     */
-    SetServer2Client(client, rfbFramebufferUpdate);
-    SetServer2Client(client, rfbSetColourMapEntries);
-    SetServer2Client(client, rfbBell);
-    SetServer2Client(client, rfbServerCutText);
-}
-
-void
-DefaultSupportedMessagesUltraVNC(rfbClient* client)
-{
-    DefaultSupportedMessages(client);
-    SetClient2Server(client, rfbFileTransfer);
-    SetClient2Server(client, rfbSetScale);
-    SetClient2Server(client, rfbSetServerInput);
-    SetClient2Server(client, rfbSetSW);
-    SetClient2Server(client, rfbTextChat);
-    SetClient2Server(client, rfbPalmVNCSetScaleFactor);
-    /* technically, we only care what we can *send* to the server */
-    SetServer2Client(client, rfbResizeFrameBuffer);
-    SetServer2Client(client, rfbPalmVNCReSizeFrameBuffer);
-    SetServer2Client(client, rfbFileTransfer);
-    SetServer2Client(client, rfbTextChat);
-}
-
-
-void
-DefaultSupportedMessagesTightVNC(rfbClient* client)
-{
-    DefaultSupportedMessages(client);
-    SetClient2Server(client, rfbFileTransfer);
-    SetClient2Server(client, rfbSetServerInput);
-    SetClient2Server(client, rfbSetSW);
-    /* SetClient2Server(client, rfbTextChat); */
-    /* technically, we only care what we can *send* to the server */
-    SetServer2Client(client, rfbFileTransfer);
-    SetServer2Client(client, rfbTextChat);
-}
-
-#ifndef WIN32
-static rfbBool
-IsUnixSocket(const char *name)
-{
-  struct stat sb;
-  if(stat(name, &sb) == 0 && (sb.st_mode & S_IFMT) == S_IFSOCK)
-    return TRUE;
-  return FALSE;
-}
-#endif
-
-/*
- * ConnectToRFBServer.
- */
-
-rfbBool
-ConnectToRFBServer(rfbClient* client,const char *hostname, int port)
-{
-  if (client->serverPort==-1) {
-    /* serverHost is a file recorded by vncrec. */
-    const char* magic="vncLog0.0";
-    char buffer[10];
-    rfbVNCRec* rec = (rfbVNCRec*)malloc(sizeof(rfbVNCRec));
-    client->vncRec = rec;
-
-    rec->file = fopen(client->serverHost,"rb");
-    rec->tv.tv_sec = 0;
-    rec->readTimestamp = FALSE;
-    rec->doNotSleep = FALSE;
-    
-    if (!rec->file) {
-      rfbClientLog("Could not open %s.\n",client->serverHost);
-      return FALSE;
-    }
-    setbuf(rec->file,NULL);
-    fread(buffer,1,strlen(magic),rec->file);
-    if (strncmp(buffer,magic,strlen(magic))) {
-      rfbClientLog("File %s was not recorded by vncrec.\n",client->serverHost);
-      fclose(rec->file);
-      return FALSE;
-    }
-    client->sock = -1;
-    return TRUE;
-  }
-
-#ifndef WIN32
-  if(IsUnixSocket(hostname))
-    /* serverHost is a UNIX socket. */
-    client->sock = ConnectClientToUnixSock(hostname);
-  else
-#endif
-  {
-#ifdef LIBVNCSERVER_IPv6
-    client->sock = ConnectClientToTcpAddr6(hostname, port);
-    if (client->sock == -1)
-#endif
-    {
-      unsigned int host;
-
-      /* serverHost is a hostname */
-      if (!StringToIPAddr(hostname, &host)) {
-        rfbClientLog("Couldn't convert '%s' to host address\n", hostname);
-        return FALSE;
-      }
-      client->sock = ConnectClientToTcpAddr(host, port);
-    }
-  }
-
-  if (client->sock < 0) {
-    rfbClientLog("Unable to connect to VNC server\n");
-    return FALSE;
-  }
-
-  if(client->QoS_DSCP && !SetDSCP(client->sock, client->QoS_DSCP))
-     return FALSE;
-
-  return SetNonBlocking(client->sock);
-}
-
-/*
- * ConnectToRFBRepeater.
- */
-
-rfbBool ConnectToRFBRepeater(rfbClient* client,const char *repeaterHost, int repeaterPort, const char *destHost, int destPort)
-{
-  rfbProtocolVersionMsg pv;
-  int major,minor;
-  char tmphost[250];
-
-#ifdef LIBVNCSERVER_IPv6
-  client->sock = ConnectClientToTcpAddr6(repeaterHost, repeaterPort);
-  if (client->sock == -1)
-#endif
-  {
-    unsigned int host;
-    if (!StringToIPAddr(repeaterHost, &host)) {
-      rfbClientLog("Couldn't convert '%s' to host address\n", repeaterHost);
-      return FALSE;
-    }
-
-    client->sock = ConnectClientToTcpAddr(host, repeaterPort);
-  }
-
-  if (client->sock < 0) {
-    rfbClientLog("Unable to connect to VNC repeater\n");
-    return FALSE;
-  }
-
-  if (!SetNonBlocking(client->sock))
-    return FALSE;
-
-  if (!ReadFromRFBServer(client, pv, sz_rfbProtocolVersionMsg))
-    return FALSE;
-  pv[sz_rfbProtocolVersionMsg] = 0;
-
-  /* UltraVNC repeater always report version 000.000 to identify itself */
-  if (sscanf(pv,rfbProtocolVersionFormat,&major,&minor) != 2 || major != 0 || minor != 0) {
-    rfbClientLog("Not a valid VNC repeater (%s)\n",pv);
-    return FALSE;
-  }
-
-  rfbClientLog("Connected to VNC repeater, using protocol version %d.%d\n", major, minor);
-
-  snprintf(tmphost, sizeof(tmphost), "%s:%d", destHost, destPort);
-  if (!WriteToRFBServer(client, tmphost, sizeof(tmphost)))
-    return FALSE;
-
-  return TRUE;
-}
-
-extern void rfbClientEncryptBytes(unsigned char* bytes, char* passwd);
-extern void rfbClientEncryptBytes2(unsigned char *where, const int length, unsigned char *key);
-
-rfbBool
-rfbHandleAuthResult(rfbClient* client)
-{
-    uint32_t authResult=0, reasonLen=0;
-    char *reason=NULL;
-
-    if (!ReadFromRFBServer(client, (char *)&authResult, 4)) return FALSE;
-
-    authResult = rfbClientSwap32IfLE(authResult);
-
-    switch (authResult) {
-    case rfbVncAuthOK:
-      rfbClientLog("VNC authentication succeeded\n");
-      return TRUE;
-      break;
-    case rfbVncAuthFailed:
-      if (client->major==3 && client->minor>7)
-      {
-        /* we have an error following */
-        if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return FALSE;
-        reasonLen = rfbClientSwap32IfLE(reasonLen);
-        reason = malloc(reasonLen+1);
-        if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return FALSE; }
-        reason[reasonLen]=0;
-        rfbClientLog("VNC connection failed: %s\n",reason);
-        free(reason);
-        return FALSE;
-      }
-      rfbClientLog("VNC authentication failed\n");
-      return FALSE;
-    case rfbVncAuthTooMany:
-      rfbClientLog("VNC authentication failed - too many tries\n");
-      return FALSE;
-    }
-
-    rfbClientLog("Unknown VNC authentication result: %d\n",
-                 (int)authResult);
-    return FALSE;
-}
-
-static void
-ReadReason(rfbClient* client)
-{
-    uint32_t reasonLen;
-    char *reason;
-
-    /* we have an error following */
-    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;
-    reasonLen = rfbClientSwap32IfLE(reasonLen);
-    reason = malloc(reasonLen+1);
-    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }
-    reason[reasonLen]=0;
-    rfbClientLog("VNC connection failed: %s\n",reason);
-    free(reason);
-}
-
-static rfbBool
-ReadSupportedSecurityType(rfbClient* client, uint32_t *result, rfbBool subAuth)
-{
-    uint8_t count=0;
-    uint8_t loop=0;
-    uint8_t flag=0;
-    uint8_t tAuth[256];
-    char buf1[500],buf2[10];
-    uint32_t authScheme;
-
-    if (!ReadFromRFBServer(client, (char *)&count, 1)) return FALSE;
-
-    if (count==0)
-    {
-        rfbClientLog("List of security types is ZERO, expecting an error to follow\n");
-        ReadReason(client);
-        return FALSE;
-    }
-
-    rfbClientLog("We have %d security types to read\n", count);
-    authScheme=0;
-    /* now, we have a list of available security types to read ( uint8_t[] ) */
-    for (loop=0;loop<count;loop++)
-    {
-        if (!ReadFromRFBServer(client, (char *)&tAuth[loop], 1)) return FALSE;
-        rfbClientLog("%d) Received security type %d\n", loop, tAuth[loop]);
-        if (flag) continue;
-        if (tAuth[loop]==rfbVncAuth || tAuth[loop]==rfbNoAuth ||
-            (tAuth[loop]==rfbARD && client->GetCredential) ||
-            (!subAuth && (tAuth[loop]==rfbTLS || (tAuth[loop]==rfbVeNCrypt && client->GetCredential))))
-        {
-            if (!subAuth && client->clientAuthSchemes)
-            {
-                int i;
-                for (i=0;client->clientAuthSchemes[i];i++)
-                {
-                    if (client->clientAuthSchemes[i]==(uint32_t)tAuth[loop])
-                    {
-                        flag++;
-                        authScheme=tAuth[loop];
-                        break;
-                    }
-                }
-            }
-            else
-            {
-                flag++;
-                authScheme=tAuth[loop];
-            }
-            if (flag)
-            {
-                rfbClientLog("Selecting security type %d (%d/%d in the list)\n", authScheme, loop, count);
-                /* send back a single byte indicating which security type to use */
-                if (!WriteToRFBServer(client, (char *)&tAuth[loop], 1)) return FALSE;
-            }
-        }
-    }
-    if (authScheme==0)
-    {
-        memset(buf1, 0, sizeof(buf1));
-        for (loop=0;loop<count;loop++)
-        {
-            if (strlen(buf1)>=sizeof(buf1)-1) break;
-            snprintf(buf2, sizeof(buf2), (loop>0 ? ", %d" : "%d"), (int)tAuth[loop]);
-            strncat(buf1, buf2, sizeof(buf1)-strlen(buf1)-1);
-        }
-        rfbClientLog("Unknown authentication scheme from VNC server: %s\n",
-               buf1);
-        return FALSE;
-    }
-    *result = authScheme;
-    return TRUE;
-}
-
-static rfbBool
-HandleVncAuth(rfbClient *client)
-{
-    uint8_t challenge[CHALLENGESIZE];
-    char *passwd=NULL;
-    int i;
-
-    if (!ReadFromRFBServer(client, (char *)challenge, CHALLENGESIZE)) return FALSE;
-
-    if (client->serverPort!=-1) { /* if not playing a vncrec file */
-      if (client->GetPassword)
-        passwd = client->GetPassword(client);
-
-      if ((!passwd) || (strlen(passwd) == 0)) {
-        rfbClientLog("Reading password failed\n");
-        return FALSE;
-      }
-      if (strlen(passwd) > 8) {
-        passwd[8] = '\0';
-      }
-
-      rfbClientEncryptBytes(challenge, passwd);
-
-      /* Lose the password from memory */
-      for (i = strlen(passwd); i >= 0; i--) {
-        passwd[i] = '\0';
-      }
-      free(passwd);
-
-      if (!WriteToRFBServer(client, (char *)challenge, CHALLENGESIZE)) return FALSE;
-    }
-
-    /* Handle the SecurityResult message */
-    if (!rfbHandleAuthResult(client)) return FALSE;
-
-    return TRUE;
-}
-
-static void
-FreeUserCredential(rfbCredential *cred)
-{
-  if (cred->userCredential.username) free(cred->userCredential.username);
-  if (cred->userCredential.password) free(cred->userCredential.password);
-  free(cred);
-}
-
-static rfbBool
-HandlePlainAuth(rfbClient *client)
-{
-  uint32_t ulen, ulensw;
-  uint32_t plen, plensw;
-  rfbCredential *cred;
-
-  if (!client->GetCredential)
-  {
-    rfbClientLog("GetCredential callback is not set.\n");
-    return FALSE;
-  }
-  cred = client->GetCredential(client, rfbCredentialTypeUser);
-  if (!cred)
-  {
-    rfbClientLog("Reading credential failed\n");
-    return FALSE;
-  }
-
-  ulen = (cred->userCredential.username ? strlen(cred->userCredential.username) : 0);
-  ulensw = rfbClientSwap32IfLE(ulen);
-  plen = (cred->userCredential.password ? strlen(cred->userCredential.password) : 0);
-  plensw = rfbClientSwap32IfLE(plen);
-  if (!WriteToRFBServer(client, (char *)&ulensw, 4) ||
-      !WriteToRFBServer(client, (char *)&plensw, 4))
-  {
-    FreeUserCredential(cred);
-    return FALSE;
-  }
-  if (ulen > 0)
-  {
-    if (!WriteToRFBServer(client, cred->userCredential.username, ulen))
-    {
-      FreeUserCredential(cred);
-      return FALSE;
-    }
-  }
-  if (plen > 0)
-  {
-    if (!WriteToRFBServer(client, cred->userCredential.password, plen))
-    {
-      FreeUserCredential(cred);
-      return FALSE;
-    }
-  }
-
-  FreeUserCredential(cred);
-
-  /* Handle the SecurityResult message */
-  if (!rfbHandleAuthResult(client)) return FALSE;
-
-  return TRUE;
-}
-
-/* Simple 64bit big integer arithmetic implementation */
-/* (x + y) % m, works even if (x + y) > 64bit */
-#define rfbAddM64(x,y,m) ((x+y)%m+(x+y<x?(((uint64_t)-1)%m+1)%m:0))
-/* (x * y) % m */
-static uint64_t
-rfbMulM64(uint64_t x, uint64_t y, uint64_t m)
-{
-  uint64_t r;
-  for(r=0;x>0;x>>=1)
-  {
-    if (x&1) r=rfbAddM64(r,y,m);
-    y=rfbAddM64(y,y,m);
-  }
-  return r;
-}
-/* (x ^ y) % m */
-static uint64_t
-rfbPowM64(uint64_t b, uint64_t e, uint64_t m)
-{
-  uint64_t r;
-  for(r=1;e>0;e>>=1)
-  {
-    if(e&1) r=rfbMulM64(r,b,m);
-    b=rfbMulM64(b,b,m);
-  }
-  return r;
-}
-
-static rfbBool
-HandleMSLogonAuth(rfbClient *client)
-{
-  uint64_t gen, mod, resp, priv, pub, key;
-  uint8_t username[256], password[64];
-  rfbCredential *cred;
-
-  if (!ReadFromRFBServer(client, (char *)&gen, 8)) return FALSE;
-  if (!ReadFromRFBServer(client, (char *)&mod, 8)) return FALSE;
-  if (!ReadFromRFBServer(client, (char *)&resp, 8)) return FALSE;
-  gen = rfbClientSwap64IfLE(gen);
-  mod = rfbClientSwap64IfLE(mod);
-  resp = rfbClientSwap64IfLE(resp);
-
-  if (!client->GetCredential)
-  {
-    rfbClientLog("GetCredential callback is not set.\n");
-    return FALSE;
-  }
-  rfbClientLog("WARNING! MSLogon security type has very low password encryption! "\
-    "Use it only with SSH tunnel or trusted network.\n");
-  cred = client->GetCredential(client, rfbCredentialTypeUser);
-  if (!cred)
-  {
-    rfbClientLog("Reading credential failed\n");
-    return FALSE;
-  }
-
-  memset(username, 0, sizeof(username));
-  strncpy((char *)username, cred->userCredential.username, sizeof(username));
-  memset(password, 0, sizeof(password));
-  strncpy((char *)password, cred->userCredential.password, sizeof(password));
-  FreeUserCredential(cred);
-
-  srand(time(NULL));
-  priv = ((uint64_t)rand())<<32;
-  priv |= (uint64_t)rand();
-
-  pub = rfbPowM64(gen, priv, mod);
-  key = rfbPowM64(resp, priv, mod);
-  pub = rfbClientSwap64IfLE(pub);
-  key = rfbClientSwap64IfLE(key);
-
-  rfbClientEncryptBytes2(username, sizeof(username), (unsigned char *)&key);
-  rfbClientEncryptBytes2(password, sizeof(password), (unsigned char *)&key);
-
-  if (!WriteToRFBServer(client, (char *)&pub, 8)) return FALSE;
-  if (!WriteToRFBServer(client, (char *)username, sizeof(username))) return FALSE;
-  if (!WriteToRFBServer(client, (char *)password, sizeof(password))) return FALSE;
-
-  /* Handle the SecurityResult message */
-  if (!rfbHandleAuthResult(client)) return FALSE;
-
-  return TRUE;
-}
-
-#ifdef LIBVNCSERVER_WITH_CLIENT_GCRYPT
-static rfbBool
-rfbMpiToBytes(const gcry_mpi_t value, uint8_t *result, size_t size)
-{
-  gcry_error_t error;
-  size_t len;
-  int i;
-
-  error = gcry_mpi_print(GCRYMPI_FMT_USG, result, size, &len, value);
-  if (gcry_err_code(error) != GPG_ERR_NO_ERROR)
-  {
-    rfbClientLog("gcry_mpi_print error: %s\n", gcry_strerror(error));
-    return FALSE;
-  }
-  for (i=size-1;i>(int)size-1-(int)len;--i)
-    result[i] = result[i-size+len];
-  for (;i>=0;--i)
-    result[i] = 0;
-  return TRUE;
-}
-
-static rfbBool
-HandleARDAuth(rfbClient *client)
-{
-  uint8_t gen[2], len[2];
-  size_t keylen;
-  uint8_t *mod = NULL, *resp, *pub, *key, *shared;
-  gcry_mpi_t genmpi = NULL, modmpi = NULL, respmpi = NULL;
-  gcry_mpi_t privmpi = NULL, pubmpi = NULL, keympi = NULL;
-  gcry_md_hd_t md5 = NULL;
-  gcry_cipher_hd_t aes = NULL;
-  gcry_error_t error;
-  uint8_t userpass[128], ciphertext[128];
-  int passwordLen, usernameLen;
-  rfbCredential *cred = NULL;
-  rfbBool result = FALSE;
-
-  while (1)
-  {
-    if (!ReadFromRFBServer(client, (char *)gen, 2))
-      break;
-    if (!ReadFromRFBServer(client, (char *)len, 2))
-      break;
-
-    if (!client->GetCredential)
-    {
-      rfbClientLog("GetCredential callback is not set.\n");
-      break;
-    }
-    cred = client->GetCredential(client, rfbCredentialTypeUser);
-    if (!cred)
-    {
-      rfbClientLog("Reading credential failed\n");
-      break;
-    }
-
-    keylen = 256*len[0]+len[1];
-    mod = (uint8_t*)malloc(keylen*4);
-    if (!mod)
-    {
-      rfbClientLog("malloc out of memory\n");
-      break;
-    }
-    resp = mod+keylen;
-    pub = resp+keylen;
-    key = pub+keylen;
-
-    if (!ReadFromRFBServer(client, (char *)mod, keylen))
-      break;
-    if (!ReadFromRFBServer(client, (char *)resp, keylen))
-      break;
-
-    error = gcry_mpi_scan(&genmpi, GCRYMPI_FMT_USG, gen, 2, NULL);
-    if (gcry_err_code(error) != GPG_ERR_NO_ERROR)
-    {
-      rfbClientLog("gcry_mpi_scan error: %s\n", gcry_strerror(error));
-      break;
-    }
-    error = gcry_mpi_scan(&modmpi, GCRYMPI_FMT_USG, mod, keylen, NULL);
-    if (gcry_err_code(error) != GPG_ERR_NO_ERROR)
-    {
-      rfbClientLog("gcry_mpi_scan error: %s\n", gcry_strerror(error));
-      break;
-    }
-    error = gcry_mpi_scan(&respmpi, GCRYMPI_FMT_USG, resp, keylen, NULL);
-    if (gcry_err_code(error) != GPG_ERR_NO_ERROR)
-    {
-      rfbClientLog("gcry_mpi_scan error: %s\n", gcry_strerror(error));
-      break;
-    }
-
-    privmpi = gcry_mpi_new(keylen);
-    if (!privmpi)
-    {
-      rfbClientLog("gcry_mpi_new out of memory\n");
-      break;
-    }
-    gcry_mpi_randomize(privmpi, (keylen/8)*8, GCRY_STRONG_RANDOM);
-
-    pubmpi = gcry_mpi_new(keylen);
-    if (!pubmpi)
-    {
-      rfbClientLog("gcry_mpi_new out of memory\n");
-      break;
-    }
-    gcry_mpi_powm(pubmpi, genmpi, privmpi, modmpi);
-
-    keympi = gcry_mpi_new(keylen);
-    if (!keympi)
-    {
-      rfbClientLog("gcry_mpi_new out of memory\n");
-      break;
-    }
-    gcry_mpi_powm(keympi, respmpi, privmpi, modmpi);
-
-    if (!rfbMpiToBytes(pubmpi, pub, keylen))
-      break;
-    if (!rfbMpiToBytes(keympi, key, keylen))
-      break;
-
-    error = gcry_md_open(&md5, GCRY_MD_MD5, 0);
-    if (gcry_err_code(error) != GPG_ERR_NO_ERROR)
-    {
-      rfbClientLog("gcry_md_open error: %s\n", gcry_strerror(error));
-      break;
-    }
-    gcry_md_write(md5, key, keylen);
-    error = gcry_md_final(md5);
-    if (gcry_err_code(error) != GPG_ERR_NO_ERROR)
-    {
-      rfbClientLog("gcry_md_final error: %s\n", gcry_strerror(error));
-      break;
-    }
-    shared = gcry_md_read(md5, GCRY_MD_MD5);
-
-    passwordLen = strlen(cred->userCredential.password)+1;
-    usernameLen = strlen(cred->userCredential.username)+1;
-    if (passwordLen > sizeof(userpass)/2)
-      passwordLen = sizeof(userpass)/2;
-    if (usernameLen > sizeof(userpass)/2)
-      usernameLen = sizeof(userpass)/2;
-
-    gcry_randomize(userpass, sizeof(userpass), GCRY_STRONG_RANDOM);
-    memcpy(userpass, cred->userCredential.username, usernameLen);
-    memcpy(userpass+sizeof(userpass)/2, cred->userCredential.password, passwordLen);
-
-    error = gcry_cipher_open(&aes, GCRY_CIPHER_AES128, GCRY_CIPHER_MODE_ECB, 0);
-    if (gcry_err_code(error) != GPG_ERR_NO_ERROR)
-    {
-      rfbClientLog("gcry_cipher_open error: %s\n", gcry_strerror(error));
-      break;
-    }
-    error = gcry_cipher_setkey(aes, shared, 16);
-    if (gcry_err_code(error) != GPG_ERR_NO_ERROR)
-    {
-      rfbClientLog("gcry_cipher_setkey error: %s\n", gcry_strerror(error));
-      break;
-    }
-    error = gcry_cipher_encrypt(aes, ciphertext, sizeof(ciphertext), userpass, sizeof(userpass));
-    if (gcry_err_code(error) != GPG_ERR_NO_ERROR)
-    {
-      rfbClientLog("gcry_cipher_encrypt error: %s\n", gcry_strerror(error));
-      break;
-    }
-
-    if (!WriteToRFBServer(client, (char *)ciphertext, sizeof(ciphertext)))
-      break;
-    if (!WriteToRFBServer(client, (char *)pub, keylen))
-      break;
-
-    /* Handle the SecurityResult message */
-    if (!rfbHandleAuthResult(client))
-      break;
-
-    result = TRUE;
-    break;
-  }
-
-  if (cred)
-    FreeUserCredential(cred);
-  if (mod)
-    free(mod);
-  if (genmpi)
-    gcry_mpi_release(genmpi);
-  if (modmpi)
-    gcry_mpi_release(modmpi);
-  if (respmpi)
-    gcry_mpi_release(respmpi);
-  if (privmpi)
-    gcry_mpi_release(privmpi);
-  if (pubmpi)
-    gcry_mpi_release(pubmpi);
-  if (keympi)
-    gcry_mpi_release(keympi);
-  if (md5)
-    gcry_md_close(md5);
-  if (aes)
-    gcry_cipher_close(aes);
-  return result;
-}
-#endif
-
-/*
- * SetClientAuthSchemes.
- */
-
-void
-SetClientAuthSchemes(rfbClient* client,const uint32_t *authSchemes, int size)
-{
-  int i;
-
-  if (client->clientAuthSchemes)
-  {
-    free(client->clientAuthSchemes);
-    client->clientAuthSchemes = NULL;
-  }
-  if (authSchemes)
-  {
-    if (size<0)
-    {
-      /* If size<0 we assume the passed-in list is also 0-terminate, so we
-       * calculate the size here */
-      for (size=0;authSchemes[size];size++) ;
-    }
-    client->clientAuthSchemes = (uint32_t*)malloc(sizeof(uint32_t)*(size+1));
-    for (i=0;i<size;i++)
-      client->clientAuthSchemes[i] = authSchemes[i];
-    client->clientAuthSchemes[size] = 0;
-  }
-}
-
-/*
- * InitialiseRFBConnection.
- */
-
-rfbBool
-InitialiseRFBConnection(rfbClient* client)
-{
-  rfbProtocolVersionMsg pv;
-  int major,minor;
-  uint32_t authScheme;
-#ifdef LIBVNCSERVER_WITH_CLIENT_TLS
-  uint32_t subAuthScheme;
-#endif
-  rfbClientInitMsg ci;
-
-  /* if the connection is immediately closed, don't report anything, so
-       that pmw's monitor can make test connections */
-
-  if (client->listenSpecified)
-    errorMessageOnReadFailure = FALSE;
-
-  if (!ReadFromRFBServer(client, pv, sz_rfbProtocolVersionMsg)) return FALSE;
-  pv[sz_rfbProtocolVersionMsg]=0;
-
-  errorMessageOnReadFailure = TRUE;
-
-  pv[sz_rfbProtocolVersionMsg] = 0;
-
-  if (sscanf(pv,rfbProtocolVersionFormat,&major,&minor) != 2) {
-    rfbClientLog("Not a valid VNC server (%s)\n",pv);
-    return FALSE;
-  }
-
-
-  DefaultSupportedMessages(client);
-  client->major = major;
-  client->minor = minor;
-
-  /* fall back to viewer supported version */
-  if ((major==rfbProtocolMajorVersion) && (minor>rfbProtocolMinorVersion))
-    client->minor = rfbProtocolMinorVersion;
-
-  /* UltraVNC uses minor codes 4 and 6 for the server */
-  if (major==3 && (minor==4 || minor==6)) {
-      rfbClientLog("UltraVNC server detected, enabling UltraVNC specific messages\n",pv);
-      DefaultSupportedMessagesUltraVNC(client);
-  }
-
-  /* TightVNC uses minor codes 5 for the server */
-  if (major==3 && minor==5) {
-      rfbClientLog("TightVNC server detected, enabling TightVNC specific messages\n",pv);
-      DefaultSupportedMessagesTightVNC(client);
-  }
-
-  /* we do not support > RFB3.8 */
-  if ((major==3 && minor>8) || major>3)
-  {
-    client->major=3;
-    client->minor=8;
-  }
-
-  rfbClientLog("VNC server supports protocol version %d.%d (viewer %d.%d)\n",
-	  major, minor, rfbProtocolMajorVersion, rfbProtocolMinorVersion);
-
-  sprintf(pv,rfbProtocolVersionFormat,client->major,client->minor);
-
-  if (!WriteToRFBServer(client, pv, sz_rfbProtocolVersionMsg)) return FALSE;
-
-
-  /* 3.7 and onwards sends a # of security types first */
-  if (client->major==3 && client->minor > 6)
-  {
-    if (!ReadSupportedSecurityType(client, &authScheme, FALSE)) return FALSE;
-  }
-  else
-  {
-    if (!ReadFromRFBServer(client, (char *)&authScheme, 4)) return FALSE;
-    authScheme = rfbClientSwap32IfLE(authScheme);
-  }
-  
-  rfbClientLog("Selected Security Scheme %d\n", authScheme);
-  client->authScheme = authScheme;
-  
-  switch (authScheme) {
-
-  case rfbConnFailed:
-    ReadReason(client);
-    return FALSE;
-
-  case rfbNoAuth:
-    rfbClientLog("No authentication needed\n");
-
-    /* 3.8 and upwards sends a Security Result for rfbNoAuth */
-    if ((client->major==3 && client->minor > 7) || client->major>3)
-        if (!rfbHandleAuthResult(client)) return FALSE;        
-
-    break;
-
-  case rfbVncAuth:
-    if (!HandleVncAuth(client)) return FALSE;
-    break;
-
-  case rfbMSLogon:
-    if (!HandleMSLogonAuth(client)) return FALSE;
-    break;
-
-  case rfbARD:
-#ifndef LIBVNCSERVER_WITH_CLIENT_GCRYPT
-    rfbClientLog("GCrypt support was not compiled in\n");
-    return FALSE;
-#else
-    if (!HandleARDAuth(client)) return FALSE;
-#endif
-    break;
-
-  case rfbTLS:
-#ifndef LIBVNCSERVER_WITH_CLIENT_TLS
-    rfbClientLog("TLS support was not compiled in\n");
-    return FALSE;
-#else
-    if (!HandleAnonTLSAuth(client)) return FALSE;
-    /* After the TLS session is established, sub auth types are expected.
-     * Note that all following reading/writing are through the TLS session from here.
-     */
-    if (!ReadSupportedSecurityType(client, &subAuthScheme, TRUE)) return FALSE;
-    client->subAuthScheme = subAuthScheme;
-
-    switch (subAuthScheme) {
-
-      case rfbConnFailed:
-        ReadReason(client);
-        return FALSE;
-
-      case rfbNoAuth:
-        rfbClientLog("No sub authentication needed\n");
-        /* 3.8 and upwards sends a Security Result for rfbNoAuth */
-        if ((client->major==3 && client->minor > 7) || client->major>3)
-            if (!rfbHandleAuthResult(client)) return FALSE;
-        break;
-
-      case rfbVncAuth:
-        if (!HandleVncAuth(client)) return FALSE;
-        break;
-
-      default:
-        rfbClientLog("Unknown sub authentication scheme from VNC server: %d\n",
-            (int)subAuthScheme);
-        return FALSE;
-    }
-#endif
-
-    break;
-
-  case rfbVeNCrypt:
-#ifndef LIBVNCSERVER_WITH_CLIENT_TLS
-    rfbClientLog("TLS support was not compiled in\n");
-    return FALSE;
-#else
-    if (!HandleVeNCryptAuth(client)) return FALSE;
-
-    switch (client->subAuthScheme) {
-
-      case rfbVeNCryptTLSNone:
-      case rfbVeNCryptX509None:
-        rfbClientLog("No sub authentication needed\n");
-        if (!rfbHandleAuthResult(client)) return FALSE;
-        break;
-
-      case rfbVeNCryptTLSVNC:
-      case rfbVeNCryptX509VNC:
-        if (!HandleVncAuth(client)) return FALSE;
-        break;
-
-      case rfbVeNCryptTLSPlain:
-      case rfbVeNCryptX509Plain:
-        if (!HandlePlainAuth(client)) return FALSE;
-        break;
-
-      default:
-        rfbClientLog("Unknown sub authentication scheme from VNC server: %d\n",
-            client->subAuthScheme);
-        return FALSE;
-    }
-#endif
-    break;
-
-  default:
-    rfbClientLog("Unknown authentication scheme from VNC server: %d\n",
-	    (int)authScheme);
-    return FALSE;
-  }
-
-  ci.shared = (client->appData.shareDesktop ? 1 : 0);
-
-  if (!WriteToRFBServer(client,  (char *)&ci, sz_rfbClientInitMsg)) return FALSE;
-
-  if (!ReadFromRFBServer(client, (char *)&client->si, sz_rfbServerInitMsg)) return FALSE;
-
-  client->si.framebufferWidth = rfbClientSwap16IfLE(client->si.framebufferWidth);
-  client->si.framebufferHeight = rfbClientSwap16IfLE(client->si.framebufferHeight);
-  client->si.format.redMax = rfbClientSwap16IfLE(client->si.format.redMax);
-  client->si.format.greenMax = rfbClientSwap16IfLE(client->si.format.greenMax);
-  client->si.format.blueMax = rfbClientSwap16IfLE(client->si.format.blueMax);
-  client->si.nameLength = rfbClientSwap32IfLE(client->si.nameLength);
-
-  client->desktopName = malloc(client->si.nameLength + 1);
-  if (!client->desktopName) {
-    rfbClientLog("Error allocating memory for desktop name, %lu bytes\n",
-            (unsigned long)client->si.nameLength);
-    return FALSE;
-  }
-
-  if (!ReadFromRFBServer(client, client->desktopName, client->si.nameLength)) return FALSE;
-
-  client->desktopName[client->si.nameLength] = 0;
-
-  rfbClientLog("Desktop name \"%s\"\n",client->desktopName);
-
-  rfbClientLog("Connected to VNC server, using protocol version %d.%d\n",
-	  client->major, client->minor);
-
-  rfbClientLog("VNC server default format:\n");
-  PrintPixelFormat(&client->si.format);
-
-  return TRUE;
-}
-
-
-/*
- * SetFormatAndEncodings.
- */
-
-rfbBool
-SetFormatAndEncodings(rfbClient* client)
-{
-  rfbSetPixelFormatMsg spf;
-  char buf[sz_rfbSetEncodingsMsg + MAX_ENCODINGS * 4];
-
-  rfbSetEncodingsMsg *se = (rfbSetEncodingsMsg *)buf;
-  uint32_t *encs = (uint32_t *)(&buf[sz_rfbSetEncodingsMsg]);
-  int len = 0;
-  rfbBool requestCompressLevel = FALSE;
-  rfbBool requestQualityLevel = FALSE;
-  rfbBool requestLastRectEncoding = FALSE;
-  rfbClientProtocolExtension* e;
-
-  if (!SupportsClient2Server(client, rfbSetPixelFormat)) return TRUE;
-
-  spf.type = rfbSetPixelFormat;
-  spf.format = client->format;
-  spf.format.redMax = rfbClientSwap16IfLE(spf.format.redMax);
-  spf.format.greenMax = rfbClientSwap16IfLE(spf.format.greenMax);
-  spf.format.blueMax = rfbClientSwap16IfLE(spf.format.blueMax);
-
-  if (!WriteToRFBServer(client, (char *)&spf, sz_rfbSetPixelFormatMsg))
-    return FALSE;
-
-
-  if (!SupportsClient2Server(client, rfbSetEncodings)) return TRUE;
-
-  se->type = rfbSetEncodings;
-  se->nEncodings = 0;
-
-  if (client->appData.encodingsString) {
-    const char *encStr = client->appData.encodingsString;
-    int encStrLen;
-    do {
-      const char *nextEncStr = strchr(encStr, ' ');
-      if (nextEncStr) {
-	encStrLen = nextEncStr - encStr;
-	nextEncStr++;
-      } else {
-	encStrLen = strlen(encStr);
-      }
-
-      if (strncasecmp(encStr,"raw",encStrLen) == 0) {
-	encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingRaw);
-      } else if (strncasecmp(encStr,"copyrect",encStrLen) == 0) {
-	encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingCopyRect);
-#ifdef LIBVNCSERVER_HAVE_LIBZ
-#ifdef LIBVNCSERVER_HAVE_LIBJPEG
-      } else if (strncasecmp(encStr,"tight",encStrLen) == 0) {
-	encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingTight);
-	requestLastRectEncoding = TRUE;
-	if (client->appData.compressLevel >= 0 && client->appData.compressLevel <= 9)
-	  requestCompressLevel = TRUE;
-	if (client->appData.enableJPEG)
-	  requestQualityLevel = TRUE;
-#endif
-#endif
-      } else if (strncasecmp(encStr,"hextile",encStrLen) == 0) {
-	encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingHextile);
-#ifdef LIBVNCSERVER_HAVE_LIBZ
-      } else if (strncasecmp(encStr,"zlib",encStrLen) == 0) {
-	encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingZlib);
-	if (client->appData.compressLevel >= 0 && client->appData.compressLevel <= 9)
-	  requestCompressLevel = TRUE;
-      } else if (strncasecmp(encStr,"zlibhex",encStrLen) == 0) {
-	encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingZlibHex);
-	if (client->appData.compressLevel >= 0 && client->appData.compressLevel <= 9)
-	  requestCompressLevel = TRUE;
-      } else if (strncasecmp(encStr,"zrle",encStrLen) == 0) {
-	encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingZRLE);
-      } else if (strncasecmp(encStr,"zywrle",encStrLen) == 0) {
-	encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingZYWRLE);
-	requestQualityLevel = TRUE;
-#endif
-      } else if ((strncasecmp(encStr,"ultra",encStrLen) == 0) || (strncasecmp(encStr,"ultrazip",encStrLen) == 0)) {
-        /* There are 2 encodings used in 'ultra' */
-        encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingUltra);
-        encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingUltraZip);
-      } else if (strncasecmp(encStr,"corre",encStrLen) == 0) {
-	encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingCoRRE);
-      } else if (strncasecmp(encStr,"rre",encStrLen) == 0) {
-	encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingRRE);
-      } else {
-	rfbClientLog("Unknown encoding '%.*s'\n",encStrLen,encStr);
-      }
-
-      encStr = nextEncStr;
-    } while (encStr && se->nEncodings < MAX_ENCODINGS);
-
-    if (se->nEncodings < MAX_ENCODINGS && requestCompressLevel) {
-      encs[se->nEncodings++] = rfbClientSwap32IfLE(client->appData.compressLevel +
-					  rfbEncodingCompressLevel0);
-    }
-
-    if (se->nEncodings < MAX_ENCODINGS && requestQualityLevel) {
-      if (client->appData.qualityLevel < 0 || client->appData.qualityLevel > 9)
-        client->appData.qualityLevel = 5;
-      encs[se->nEncodings++] = rfbClientSwap32IfLE(client->appData.qualityLevel +
-					  rfbEncodingQualityLevel0);
-    }
-  }
-  else {
-    if (SameMachine(client->sock)) {
-      /* TODO:
-      if (!tunnelSpecified) {
-      */
-      rfbClientLog("Same machine: preferring raw encoding\n");
-      encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingRaw);
-      /*
-      } else {
-	rfbClientLog("Tunneling active: preferring tight encoding\n");
-      }
-      */
-    }
-
-    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingCopyRect);
-#ifdef LIBVNCSERVER_HAVE_LIBZ
-#ifdef LIBVNCSERVER_HAVE_LIBJPEG
-    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingTight);
-    requestLastRectEncoding = TRUE;
-#endif
-#endif
-    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingHextile);
-#ifdef LIBVNCSERVER_HAVE_LIBZ
-    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingZlib);
-    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingZRLE);
-    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingZYWRLE);
-#endif
-    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingUltra);
-    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingUltraZip);
-    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingCoRRE);
-    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingRRE);
-
-    if (client->appData.compressLevel >= 0 && client->appData.compressLevel <= 9) {
-      encs[se->nEncodings++] = rfbClientSwap32IfLE(client->appData.compressLevel +
-					  rfbEncodingCompressLevel0);
-    } else /* if (!tunnelSpecified) */ {
-      /* If -tunnel option was provided, we assume that server machine is
-	 not in the local network so we use default compression level for
-	 tight encoding instead of fast compression. Thus we are
-	 requesting level 1 compression only if tunneling is not used. */
-      encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingCompressLevel1);
-    }
-
-    if (client->appData.enableJPEG) {
-      if (client->appData.qualityLevel < 0 || client->appData.qualityLevel > 9)
-	client->appData.qualityLevel = 5;
-      encs[se->nEncodings++] = rfbClientSwap32IfLE(client->appData.qualityLevel +
-					  rfbEncodingQualityLevel0);
-    }
-  }
-
-
-
-  /* Remote Cursor Support (local to viewer) */
-  if (client->appData.useRemoteCursor) {
-    if (se->nEncodings < MAX_ENCODINGS)
-      encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingXCursor);
-    if (se->nEncodings < MAX_ENCODINGS)
-      encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingRichCursor);
-    if (se->nEncodings < MAX_ENCODINGS)
-      encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingPointerPos);
-  }
-
-  /* Keyboard State Encodings */
-  if (se->nEncodings < MAX_ENCODINGS)
-    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingKeyboardLedState);
-
-  /* New Frame Buffer Size */
-  if (se->nEncodings < MAX_ENCODINGS && client->canHandleNewFBSize)
-    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingNewFBSize);
-
-  /* Last Rect */
-  if (se->nEncodings < MAX_ENCODINGS && requestLastRectEncoding)
-    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingLastRect);
-
-  /* Server Capabilities */
-  if (se->nEncodings < MAX_ENCODINGS)
-    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingSupportedMessages);
-  if (se->nEncodings < MAX_ENCODINGS)
-    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingSupportedEncodings);
-  if (se->nEncodings < MAX_ENCODINGS)
-    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingServerIdentity);
-
-  /* xvp */
-  if (se->nEncodings < MAX_ENCODINGS)
-    encs[se->nEncodings++] = rfbClientSwap32IfLE(rfbEncodingXvp);
-
-  /* client extensions */
-  for(e = rfbClientExtensions; e; e = e->next)
-    if(e->encodings) {
-      int* enc;
-      for(enc = e->encodings; *enc; enc++)
-	encs[se->nEncodings++] = rfbClientSwap32IfLE(*enc);
-    }
-
-  len = sz_rfbSetEncodingsMsg + se->nEncodings * 4;
-
-  se->nEncodings = rfbClientSwap16IfLE(se->nEncodings);
-
-  if (!WriteToRFBServer(client, buf, len)) return FALSE;
-
-  return TRUE;
-}
-
-
-/*
- * SendIncrementalFramebufferUpdateRequest.
- */
-
-rfbBool
-SendIncrementalFramebufferUpdateRequest(rfbClient* client)
-{
-	return SendFramebufferUpdateRequest(client,
-			client->updateRect.x, client->updateRect.y,
-			client->updateRect.w, client->updateRect.h, TRUE);
-}
-
-
-/*
- * SendFramebufferUpdateRequest.
- */
-
-rfbBool
-SendFramebufferUpdateRequest(rfbClient* client, int x, int y, int w, int h, rfbBool incremental)
-{
-  rfbFramebufferUpdateRequestMsg fur;
-
-  if (!SupportsClient2Server(client, rfbFramebufferUpdateRequest)) return TRUE;
-  
-  fur.type = rfbFramebufferUpdateRequest;
-  fur.incremental = incremental ? 1 : 0;
-  fur.x = rfbClientSwap16IfLE(x);
-  fur.y = rfbClientSwap16IfLE(y);
-  fur.w = rfbClientSwap16IfLE(w);
-  fur.h = rfbClientSwap16IfLE(h);
-
-  if (!WriteToRFBServer(client, (char *)&fur, sz_rfbFramebufferUpdateRequestMsg))
-    return FALSE;
-
-  return TRUE;
-}
-
-
-/*
- * SendScaleSetting.
- */
-rfbBool
-SendScaleSetting(rfbClient* client,int scaleSetting)
-{
-  rfbSetScaleMsg ssm;
-
-  ssm.scale = scaleSetting;
-  ssm.pad = 0;
-  
-  /* favor UltraVNC SetScale if both are supported */
-  if (SupportsClient2Server(client, rfbSetScale)) {
-      ssm.type = rfbSetScale;
-      if (!WriteToRFBServer(client, (char *)&ssm, sz_rfbSetScaleMsg))
-          return FALSE;
-  }
-  
-  if (SupportsClient2Server(client, rfbPalmVNCSetScaleFactor)) {
-      ssm.type = rfbPalmVNCSetScaleFactor;
-      if (!WriteToRFBServer(client, (char *)&ssm, sz_rfbSetScaleMsg))
-          return FALSE;
-  }
-
-  return TRUE;
-}
-
-/*
- * TextChatFunctions (UltraVNC)
- * Extremely bandwidth friendly method of communicating with a user
- * (Think HelpDesk type applications)
- */
-
-rfbBool TextChatSend(rfbClient* client, char *text)
-{
-    rfbTextChatMsg chat;
-    int count = strlen(text);
-
-    if (!SupportsClient2Server(client, rfbTextChat)) return TRUE;
-    chat.type = rfbTextChat;
-    chat.pad1 = 0;
-    chat.pad2 = 0;
-    chat.length = (uint32_t)count;
-    chat.length = rfbClientSwap32IfLE(chat.length);
-
-    if (!WriteToRFBServer(client, (char *)&chat, sz_rfbTextChatMsg))
-        return FALSE;
-
-    if (count>0) {
-        if (!WriteToRFBServer(client, text, count))
-            return FALSE;
-    }
-    return TRUE;
-}
-
-rfbBool TextChatOpen(rfbClient* client)
-{
-    rfbTextChatMsg chat;
-
-    if (!SupportsClient2Server(client, rfbTextChat)) return TRUE;
-    chat.type = rfbTextChat;
-    chat.pad1 = 0;
-    chat.pad2 = 0;
-    chat.length = rfbClientSwap32IfLE(rfbTextChatOpen);
-    return  (WriteToRFBServer(client, (char *)&chat, sz_rfbTextChatMsg) ? TRUE : FALSE);
-}
-
-rfbBool TextChatClose(rfbClient* client)
-{
-    rfbTextChatMsg chat;
-    if (!SupportsClient2Server(client, rfbTextChat)) return TRUE;
-    chat.type = rfbTextChat;
-    chat.pad1 = 0;
-    chat.pad2 = 0;
-    chat.length = rfbClientSwap32IfLE(rfbTextChatClose);
-    return  (WriteToRFBServer(client, (char *)&chat, sz_rfbTextChatMsg) ? TRUE : FALSE);
-}
-
-rfbBool TextChatFinish(rfbClient* client)
-{
-    rfbTextChatMsg chat;
-    if (!SupportsClient2Server(client, rfbTextChat)) return TRUE;
-    chat.type = rfbTextChat;
-    chat.pad1 = 0;
-    chat.pad2 = 0;
-    chat.length = rfbClientSwap32IfLE(rfbTextChatFinished);
-    return  (WriteToRFBServer(client, (char *)&chat, sz_rfbTextChatMsg) ? TRUE : FALSE);
-}
-
-/*
- * UltraVNC Server Input Disable
- * Apparently, the remote client can *prevent* the local user from interacting with the display
- * I would think this is extremely helpful when used in a HelpDesk situation
- */
-rfbBool PermitServerInput(rfbClient* client, int enabled)
-{
-    rfbSetServerInputMsg msg;
-
-    if (!SupportsClient2Server(client, rfbSetServerInput)) return TRUE;
-    /* enabled==1, then server input from local keyboard is disabled */
-    msg.type = rfbSetServerInput;
-    msg.status = (enabled ? 1 : 0);
-    msg.pad = 0;
-    return  (WriteToRFBServer(client, (char *)&msg, sz_rfbSetServerInputMsg) ? TRUE : FALSE);
-}
-
-
-/*
- * send xvp client message
- * A client supporting the xvp extension sends this to request that the server initiate
- * a clean shutdown, clean reboot or abrupt reset of the system whose framebuffer the
- * client is displaying.
- *
- * only version 1 is defined in the protocol specs
- *
- * possible values for code are:
- *   rfbXvp_Shutdown
- *   rfbXvp_Reboot
- *   rfbXvp_Reset
- */
-
-rfbBool SendXvpMsg(rfbClient* client, uint8_t version, uint8_t code)
-{
-    rfbXvpMsg xvp;
-
-    if (!SupportsClient2Server(client, rfbXvp)) return TRUE;
-    xvp.type = rfbXvp;
-    xvp.pad = 0;
-    xvp.version = version;
-    xvp.code = code;
-
-    if (!WriteToRFBServer(client, (char *)&xvp, sz_rfbXvpMsg))
-        return FALSE;
-
-    return TRUE;
-}
-
-
-/*
- * SendPointerEvent.
- */
-
-rfbBool
-SendPointerEvent(rfbClient* client,int x, int y, int buttonMask)
-{
-  rfbPointerEventMsg pe;
-
-  if (!SupportsClient2Server(client, rfbPointerEvent)) return TRUE;
-
-  pe.type = rfbPointerEvent;
-  pe.buttonMask = buttonMask;
-  if (x < 0) x = 0;
-  if (y < 0) y = 0;
-
-  pe.x = rfbClientSwap16IfLE(x);
-  pe.y = rfbClientSwap16IfLE(y);
-  return WriteToRFBServer(client, (char *)&pe, sz_rfbPointerEventMsg);
-}
-
-
-/*
- * SendKeyEvent.
- */
-
-rfbBool
-SendKeyEvent(rfbClient* client, uint32_t key, rfbBool down)
-{
-  rfbKeyEventMsg ke;
-
-  if (!SupportsClient2Server(client, rfbKeyEvent)) return TRUE;
-
-  ke.type = rfbKeyEvent;
-  ke.down = down ? 1 : 0;
-  ke.key = rfbClientSwap32IfLE(key);
-  return WriteToRFBServer(client, (char *)&ke, sz_rfbKeyEventMsg);
-}
-
-
-/*
- * SendClientCutText.
- */
-
-rfbBool
-SendClientCutText(rfbClient* client, char *str, int len)
-{
-  rfbClientCutTextMsg cct;
-
-  if (!SupportsClient2Server(client, rfbClientCutText)) return TRUE;
-
-  cct.type = rfbClientCutText;
-  cct.length = rfbClientSwap32IfLE(len);
-  return  (WriteToRFBServer(client, (char *)&cct, sz_rfbClientCutTextMsg) &&
-	   WriteToRFBServer(client, str, len));
-}
-
-
-
-/*
- * HandleRFBServerMessage.
- */
-
-rfbBool
-HandleRFBServerMessage(rfbClient* client)
-{
-  rfbServerToClientMsg msg;
-
-  if (client->serverPort==-1)
-    client->vncRec->readTimestamp = TRUE;
-  if (!ReadFromRFBServer(client, (char *)&msg, 1))
-    return FALSE;
-
-  switch (msg.type) {
-
-  case rfbSetColourMapEntries:
-  {
-    /* TODO:
-    int i;
-    uint16_t rgb[3];
-    XColor xc;
-
-    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,
-			   sz_rfbSetColourMapEntriesMsg - 1))
-      return FALSE;
-
-    msg.scme.firstColour = rfbClientSwap16IfLE(msg.scme.firstColour);
-    msg.scme.nColours = rfbClientSwap16IfLE(msg.scme.nColours);
-
-    for (i = 0; i < msg.scme.nColours; i++) {
-      if (!ReadFromRFBServer(client, (char *)rgb, 6))
-	return FALSE;
-      xc.pixel = msg.scme.firstColour + i;
-      xc.red = rfbClientSwap16IfLE(rgb[0]);
-      xc.green = rfbClientSwap16IfLE(rgb[1]);
-      xc.blue = rfbClientSwap16IfLE(rgb[2]);
-      xc.flags = DoRed|DoGreen|DoBlue;
-      XStoreColor(dpy, cmap, &xc);
-    }
-    */
-
-    break;
-  }
-
-  case rfbFramebufferUpdate:
-  {
-    rfbFramebufferUpdateRectHeader rect;
-    int linesToRead;
-    int bytesPerLine;
-    int i;
-
-    if (!ReadFromRFBServer(client, ((char *)&msg.fu) + 1,
-			   sz_rfbFramebufferUpdateMsg - 1))
-      return FALSE;
-
-    msg.fu.nRects = rfbClientSwap16IfLE(msg.fu.nRects);
-
-    for (i = 0; i < msg.fu.nRects; i++) {
-      if (!ReadFromRFBServer(client, (char *)&rect, sz_rfbFramebufferUpdateRectHeader))
-	return FALSE;
-
-      rect.encoding = rfbClientSwap32IfLE(rect.encoding);
-      if (rect.encoding == rfbEncodingLastRect)
-	break;
-
-      rect.r.x = rfbClientSwap16IfLE(rect.r.x);
-      rect.r.y = rfbClientSwap16IfLE(rect.r.y);
-      rect.r.w = rfbClientSwap16IfLE(rect.r.w);
-      rect.r.h = rfbClientSwap16IfLE(rect.r.h);
-
-
-      if (rect.encoding == rfbEncodingXCursor ||
-	  rect.encoding == rfbEncodingRichCursor) {
-
-	if (!HandleCursorShape(client,
-			       rect.r.x, rect.r.y, rect.r.w, rect.r.h,
-			       rect.encoding)) {
-	  return FALSE;
-	}
-	continue;
-      }
-
-      if (rect.encoding == rfbEncodingPointerPos) {
-	if (!client->HandleCursorPos(client,rect.r.x, rect.r.y)) {
-	  return FALSE;
-	}
-	continue;
-      }
-      
-      if (rect.encoding == rfbEncodingKeyboardLedState) {
-          /* OK! We have received a keyboard state message!!! */
-          client->KeyboardLedStateEnabled = 1;
-          if (client->HandleKeyboardLedState!=NULL)
-              client->HandleKeyboardLedState(client, rect.r.x, 0);
-          /* stash it for the future */
-          client->CurrentKeyboardLedState = rect.r.x;
-          continue;
-      }
-
-      if (rect.encoding == rfbEncodingNewFBSize) {
-	client->width = rect.r.w;
-	client->height = rect.r.h;
-	client->updateRect.x = client->updateRect.y = 0;
-	client->updateRect.w = client->width;
-	client->updateRect.h = client->height;
-	client->MallocFrameBuffer(client);
-	SendFramebufferUpdateRequest(client, 0, 0, rect.r.w, rect.r.h, FALSE);
-	rfbClientLog("Got new framebuffer size: %dx%d\n", rect.r.w, rect.r.h);
-	continue;
-      }
-
-      /* rect.r.w=byte count */
-      if (rect.encoding == rfbEncodingSupportedMessages) {
-          int loop;
-          if (!ReadFromRFBServer(client, (char *)&client->supportedMessages, sz_rfbSupportedMessages))
-              return FALSE;
-
-          /* msgs is two sets of bit flags of supported messages client2server[] and server2client[] */
-          /* currently ignored by this library */
-
-          rfbClientLog("client2server supported messages (bit flags)\n");
-          for (loop=0;loop<32;loop+=8)
-            rfbClientLog("%02X: %04x %04x %04x %04x - %04x %04x %04x %04x\n", loop,
-                client->supportedMessages.client2server[loop],   client->supportedMessages.client2server[loop+1],
-                client->supportedMessages.client2server[loop+2], client->supportedMessages.client2server[loop+3],
-                client->supportedMessages.client2server[loop+4], client->supportedMessages.client2server[loop+5],
-                client->supportedMessages.client2server[loop+6], client->supportedMessages.client2server[loop+7]);
-
-          rfbClientLog("server2client supported messages (bit flags)\n");
-          for (loop=0;loop<32;loop+=8)
-            rfbClientLog("%02X: %04x %04x %04x %04x - %04x %04x %04x %04x\n", loop,
-                client->supportedMessages.server2client[loop],   client->supportedMessages.server2client[loop+1],
-                client->supportedMessages.server2client[loop+2], client->supportedMessages.server2client[loop+3],
-                client->supportedMessages.server2client[loop+4], client->supportedMessages.server2client[loop+5],
-                client->supportedMessages.server2client[loop+6], client->supportedMessages.server2client[loop+7]);
-          continue;
-      }
-
-      /* rect.r.w=byte count, rect.r.h=# of encodings */
-      if (rect.encoding == rfbEncodingSupportedEncodings) {
-          char *buffer;
-          buffer = malloc(rect.r.w);
-          if (!ReadFromRFBServer(client, buffer, rect.r.w))
-          {
-              free(buffer);
-              return FALSE;
-          }
-
-          /* buffer now contains rect.r.h # of uint32_t encodings that the server supports */
-          /* currently ignored by this library */
-          free(buffer);
-          continue;
-      }
-
-      /* rect.r.w=byte count */
-      if (rect.encoding == rfbEncodingServerIdentity) {
-          char *buffer;
-          buffer = malloc(rect.r.w+1);
-          if (!ReadFromRFBServer(client, buffer, rect.r.w))
-          {
-              free(buffer);
-              return FALSE;
-          }
-          buffer[rect.r.w]=0; /* null terminate, just in case */
-          rfbClientLog("Connected to Server \"%s\"\n", buffer);
-          free(buffer);
-          continue;
-      }
-
-      /* rfbEncodingUltraZip is a collection of subrects.   x = # of subrects, and h is always 0 */
-      if (rect.encoding != rfbEncodingUltraZip)
-      {
-        if ((rect.r.x + rect.r.w > client->width) ||
-	    (rect.r.y + rect.r.h > client->height))
-	    {
-	      rfbClientLog("Rect too large: %dx%d at (%d, %d)\n",
-	  	  rect.r.w, rect.r.h, rect.r.x, rect.r.y);
-	      return FALSE;
-            }
-
-        /* UltraVNC with scaling, will send rectangles with a zero W or H
-         *
-        if ((rect.encoding != rfbEncodingTight) && 
-            (rect.r.h * rect.r.w == 0))
-        {
-	  rfbClientLog("Zero size rect - ignoring (encoding=%d (0x%08x) %dx, %dy, %dw, %dh)\n", rect.encoding, rect.encoding, rect.r.x, rect.r.y, rect.r.w, rect.r.h);
-	  continue;
-        }
-        */
-        
-        /* If RichCursor encoding is used, we should prevent collisions
-	   between framebuffer updates and cursor drawing operations. */
-        client->SoftCursorLockArea(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h);
-      }
-
-      switch (rect.encoding) {
-
-      case rfbEncodingRaw: {
-	int y=rect.r.y, h=rect.r.h;
-
-	bytesPerLine = rect.r.w * client->format.bitsPerPixel / 8;
-	linesToRead = RFB_BUFFER_SIZE / bytesPerLine;
-
-	while (h > 0) {
-	  if (linesToRead > h)
-	    linesToRead = h;
-
-	  if (!ReadFromRFBServer(client, client->buffer,bytesPerLine * linesToRead))
-	    return FALSE;
-
-	  CopyRectangle(client, (uint8_t *)client->buffer,
-			   rect.r.x, y, rect.r.w,linesToRead);
-
-	  h -= linesToRead;
-	  y += linesToRead;
-
-	}
-      } break;
-
-      case rfbEncodingCopyRect:
-      {
-	rfbCopyRect cr;
-
-	if (!ReadFromRFBServer(client, (char *)&cr, sz_rfbCopyRect))
-	  return FALSE;
-
-	cr.srcX = rfbClientSwap16IfLE(cr.srcX);
-	cr.srcY = rfbClientSwap16IfLE(cr.srcY);
-
-	/* If RichCursor encoding is used, we should extend our
-	   "cursor lock area" (previously set to destination
-	   rectangle) to the source rectangle as well. */
-	client->SoftCursorLockArea(client,
-				   cr.srcX, cr.srcY, rect.r.w, rect.r.h);
-
-        if (client->GotCopyRect != NULL) {
-          client->GotCopyRect(client, cr.srcX, cr.srcY, rect.r.w, rect.r.h,
-              rect.r.x, rect.r.y);
-        } else
-		CopyRectangleFromRectangle(client,
-				   cr.srcX, cr.srcY, rect.r.w, rect.r.h,
-				   rect.r.x, rect.r.y);
-
-	break;
-      }
-
-      case rfbEncodingRRE:
-      {
-	switch (client->format.bitsPerPixel) {
-	case 8:
-	  if (!HandleRRE8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))
-	    return FALSE;
-	  break;
-	case 16:
-	  if (!HandleRRE16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))
-	    return FALSE;
-	  break;
-	case 32:
-	  if (!HandleRRE32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))
-	    return FALSE;
-	  break;
-	}
-	break;
-      }
-
-      case rfbEncodingCoRRE:
-      {
-	switch (client->format.bitsPerPixel) {
-	case 8:
-	  if (!HandleCoRRE8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))
-	    return FALSE;
-	  break;
-	case 16:
-	  if (!HandleCoRRE16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))
-	    return FALSE;
-	  break;
-	case 32:
-	  if (!HandleCoRRE32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))
-	    return FALSE;
-	  break;
-	}
-	break;
-      }
-
-      case rfbEncodingHextile:
-      {
-	switch (client->format.bitsPerPixel) {
-	case 8:
-	  if (!HandleHextile8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))
-	    return FALSE;
-	  break;
-	case 16:
-	  if (!HandleHextile16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))
-	    return FALSE;
-	  break;
-	case 32:
-	  if (!HandleHextile32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))
-	    return FALSE;
-	  break;
-	}
-	break;
-      }
-
-      case rfbEncodingUltra:
-      {
-        switch (client->format.bitsPerPixel) {
-        case 8:
-          if (!HandleUltra8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))
-            return FALSE;
-          break;
-        case 16:
-          if (!HandleUltra16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))
-            return FALSE;
-          break;
-        case 32:
-          if (!HandleUltra32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))
-            return FALSE;
-          break;
-        }
-        break;
-      }
-      case rfbEncodingUltraZip:
-      {
-        switch (client->format.bitsPerPixel) {
-        case 8:
-          if (!HandleUltraZip8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))
-            return FALSE;
-          break;
-        case 16:
-          if (!HandleUltraZip16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))
-            return FALSE;
-          break;
-        case 32:
-          if (!HandleUltraZip32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))
-            return FALSE;
-          break;
-        }
-        break;
-      }
-
-#ifdef LIBVNCSERVER_HAVE_LIBZ
-      case rfbEncodingZlib:
-      {
-	switch (client->format.bitsPerPixel) {
-	case 8:
-	  if (!HandleZlib8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))
-	    return FALSE;
-	  break;
-	case 16:
-	  if (!HandleZlib16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))
-	    return FALSE;
-	  break;
-	case 32:
-	  if (!HandleZlib32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))
-	    return FALSE;
-	  break;
-	}
-	break;
-     }
-
-#ifdef LIBVNCSERVER_HAVE_LIBJPEG
-      case rfbEncodingTight:
-      {
-	switch (client->format.bitsPerPixel) {
-	case 8:
-	  if (!HandleTight8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))
-	    return FALSE;
-	  break;
-	case 16:
-	  if (!HandleTight16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))
-	    return FALSE;
-	  break;
-	case 32:
-	  if (!HandleTight32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))
-	    return FALSE;
-	  break;
-	}
-	break;
-      }
-#endif
-      case rfbEncodingZRLE:
-	/* Fail safe for ZYWRLE unsupport VNC server. */
-	client->appData.qualityLevel = 9;
-	/* fall through */
-      case rfbEncodingZYWRLE:
-      {
-	switch (client->format.bitsPerPixel) {
-	case 8:
-	  if (!HandleZRLE8(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))
-	    return FALSE;
-	  break;
-	case 16:
-	  if (client->si.format.greenMax > 0x1F) {
-	    if (!HandleZRLE16(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))
-	      return FALSE;
-	  } else {
-	    if (!HandleZRLE15(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))
-	      return FALSE;
-	  }
-	  break;
-	case 32:
-	{
-	  uint32_t maxColor=(client->format.redMax<<client->format.redShift)|
-		(client->format.greenMax<<client->format.greenShift)|
-		(client->format.blueMax<<client->format.blueShift);
-	  if ((client->format.bigEndian && (maxColor&0xff)==0) ||
-	      (!client->format.bigEndian && (maxColor&0xff000000)==0)) {
-	    if (!HandleZRLE24(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))
-	      return FALSE;
-	  } else if (!client->format.bigEndian && (maxColor&0xff)==0) {
-	    if (!HandleZRLE24Up(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))
-	      return FALSE;
-	  } else if (client->format.bigEndian && (maxColor&0xff000000)==0) {
-	    if (!HandleZRLE24Down(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))
-	      return FALSE;
-	  } else if (!HandleZRLE32(client, rect.r.x,rect.r.y,rect.r.w,rect.r.h))
-	    return FALSE;
-	  break;
-	}
-	}
-	break;
-     }
-
-#endif
-
-      default:
-	 {
-	   rfbBool handled = FALSE;
-	   rfbClientProtocolExtension* e;
-
-	   for(e = rfbClientExtensions; !handled && e; e = e->next)
-	     if(e->handleEncoding && e->handleEncoding(client, &rect))
-	       handled = TRUE;
-
-	   if(!handled) {
-	     rfbClientLog("Unknown rect encoding %d\n",
-		 (int)rect.encoding);
-	     return FALSE;
-	   }
-	 }
-      }
-
-      /* Now we may discard "soft cursor locks". */
-      client->SoftCursorUnlockScreen(client);
-
-      client->GotFrameBufferUpdate(client, rect.r.x, rect.r.y, rect.r.w, rect.r.h);
-    }
-
-    if (!SendIncrementalFramebufferUpdateRequest(client))
-      return FALSE;
-
-    if (client->FinishedFrameBufferUpdate)
-      client->FinishedFrameBufferUpdate(client);
-
-    break;
-  }
-
-  case rfbBell:
-  {
-    client->Bell(client);
-
-    break;
-  }
-
-  case rfbServerCutText:
-  {
-    char *buffer;
-
-    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,
-			   sz_rfbServerCutTextMsg - 1))
-      return FALSE;
-
-    msg.sct.length = rfbClientSwap32IfLE(msg.sct.length);
-
-    buffer = malloc(msg.sct.length+1);
-
-    if (!ReadFromRFBServer(client, buffer, msg.sct.length))
-      return FALSE;
-
-    buffer[msg.sct.length] = 0;
-
-    if (client->GotXCutText)
-      client->GotXCutText(client, buffer, msg.sct.length);
-
-    free(buffer);
-
-    break;
-  }
-
-  case rfbTextChat:
-  {
-      char *buffer=NULL;
-      if (!ReadFromRFBServer(client, ((char *)&msg) + 1,
-                             sz_rfbTextChatMsg- 1))
-        return FALSE;
-      msg.tc.length = rfbClientSwap32IfLE(msg.sct.length);
-      switch(msg.tc.length) {
-      case rfbTextChatOpen:
-          rfbClientLog("Received TextChat Open\n");
-          if (client->HandleTextChat!=NULL)
-              client->HandleTextChat(client, (int)rfbTextChatOpen, NULL);
-          break;
-      case rfbTextChatClose:
-          rfbClientLog("Received TextChat Close\n");
-         if (client->HandleTextChat!=NULL)
-              client->HandleTextChat(client, (int)rfbTextChatClose, NULL);
-          break;
-      case rfbTextChatFinished:
-          rfbClientLog("Received TextChat Finished\n");
-         if (client->HandleTextChat!=NULL)
-              client->HandleTextChat(client, (int)rfbTextChatFinished, NULL);
-          break;
-      default:
-          buffer=malloc(msg.tc.length+1);
-          if (!ReadFromRFBServer(client, buffer, msg.tc.length))
-          {
-              free(buffer);
-              return FALSE;
-          }
-          /* Null Terminate <just in case> */
-          buffer[msg.tc.length]=0;
-          rfbClientLog("Received TextChat \"%s\"\n", buffer);
-          if (client->HandleTextChat!=NULL)
-              client->HandleTextChat(client, (int)msg.tc.length, buffer);
-          free(buffer);
-          break;
-      }
-      break;
-  }
-
-  case rfbXvp:
-  {
-    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,
-                           sz_rfbXvpMsg -1))
-      return FALSE;
-
-    SetClient2Server(client, rfbXvp);
-    /* technically, we only care what we can *send* to the server
-     * but, we set Server2Client Just in case it ever becomes useful
-     */
-    SetServer2Client(client, rfbXvp);
-
-    if(client->HandleXvpMsg)
-      client->HandleXvpMsg(client, msg.xvp.version, msg.xvp.code);
-
-    break;
-  }
-
-  case rfbResizeFrameBuffer:
-  {
-    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,
-                           sz_rfbResizeFrameBufferMsg -1))
-      return FALSE;
-    client->width = rfbClientSwap16IfLE(msg.rsfb.framebufferWidth);
-    client->height = rfbClientSwap16IfLE(msg.rsfb.framebufferHeigth);
-    client->updateRect.x = client->updateRect.y = 0;
-    client->updateRect.w = client->width;
-    client->updateRect.h = client->height;
-    client->MallocFrameBuffer(client);
-    SendFramebufferUpdateRequest(client, 0, 0, client->width, client->height, FALSE);
-    rfbClientLog("Got new framebuffer size: %dx%d\n", client->width, client->height);
-    break;
-  }
-
-  case rfbPalmVNCReSizeFrameBuffer:
-  {
-    if (!ReadFromRFBServer(client, ((char *)&msg) + 1,
-                           sz_rfbPalmVNCReSizeFrameBufferMsg -1))
-      return FALSE;
-    client->width = rfbClientSwap16IfLE(msg.prsfb.buffer_w);
-    client->height = rfbClientSwap16IfLE(msg.prsfb.buffer_h);
-    client->updateRect.x = client->updateRect.y = 0;
-    client->updateRect.w = client->width;
-    client->updateRect.h = client->height;
-    client->MallocFrameBuffer(client);
-    SendFramebufferUpdateRequest(client, 0, 0, client->width, client->height, FALSE);
-    rfbClientLog("Got new framebuffer size: %dx%d\n", client->width, client->height);
-    break;
-  }
-
-  default:
-    {
-      rfbBool handled = FALSE;
-      rfbClientProtocolExtension* e;
-
-      for(e = rfbClientExtensions; !handled && e; e = e->next)
-	if(e->handleMessage && e->handleMessage(client, &msg))
-	  handled = TRUE;
-
-      if(!handled) {
-	char buffer[256];
-	rfbClientLog("Unknown message type %d from VNC server\n",msg.type);
-	ReadFromRFBServer(client, buffer, 256);
-	return FALSE;
-      }
-    }
-  }
-
-  return TRUE;
-}
-
-
-#define GET_PIXEL8(pix, ptr) ((pix) = *(ptr)++)
-
-#define GET_PIXEL16(pix, ptr) (((uint8_t*)&(pix))[0] = *(ptr)++, \
-			       ((uint8_t*)&(pix))[1] = *(ptr)++)
-
-#define GET_PIXEL32(pix, ptr) (((uint8_t*)&(pix))[0] = *(ptr)++, \
-			       ((uint8_t*)&(pix))[1] = *(ptr)++, \
-			       ((uint8_t*)&(pix))[2] = *(ptr)++, \
-			       ((uint8_t*)&(pix))[3] = *(ptr)++)
-
-/* CONCAT2 concatenates its two arguments.  CONCAT2E does the same but also
-   expands its arguments if they are macros */
-
-#define CONCAT2(a,b) a##b
-#define CONCAT2E(a,b) CONCAT2(a,b)
-#define CONCAT3(a,b,c) a##b##c
-#define CONCAT3E(a,b,c) CONCAT3(a,b,c)
-
-#define BPP 8
-#include "rre.c"
-#include "corre.c"
-#include "hextile.c"
-#include "ultra.c"
-#include "zlib.c"
-#include "tight.c"
-#include "zrle.c"
-#undef BPP
-#define BPP 16
-#include "rre.c"
-#include "corre.c"
-#include "hextile.c"
-#include "ultra.c"
-#include "zlib.c"
-#include "tight.c"
-#include "zrle.c"
-#define REALBPP 15
-#include "zrle.c"
-#undef BPP
-#define BPP 32
-#include "rre.c"
-#include "corre.c"
-#include "hextile.c"
-#include "ultra.c"
-#include "zlib.c"
-#include "tight.c"
-#include "zrle.c"
-#define REALBPP 24
-#include "zrle.c"
-#define REALBPP 24
-#define UNCOMP 8
-#include "zrle.c"
-#define REALBPP 24
-#define UNCOMP -8
-#include "zrle.c"
-#undef BPP
-
-
-/*
- * PrintPixelFormat.
- */
-
-void
-PrintPixelFormat(rfbPixelFormat *format)
-{
-  if (format->bitsPerPixel == 1) {
-    rfbClientLog("  Single bit per pixel.\n");
-    rfbClientLog(
-	    "  %s significant bit in each byte is leftmost on the screen.\n",
-	    (format->bigEndian ? "Most" : "Least"));
-  } else {
-    rfbClientLog("  %d bits per pixel.\n",format->bitsPerPixel);
-    if (format->bitsPerPixel != 8) {
-      rfbClientLog("  %s significant byte first in each pixel.\n",
-	      (format->bigEndian ? "Most" : "Least"));
-    }
-    if (format->trueColour) {
-      rfbClientLog("  TRUE colour: max red %d green %d blue %d"
-		   ", shift red %d green %d blue %d\n",
-		   format->redMax, format->greenMax, format->blueMax,
-		   format->redShift, format->greenShift, format->blueShift);
-    } else {
-      rfbClientLog("  Colour map (not true colour).\n");
-    }
-  }
-}
-
-/* avoid name clashes with LibVNCServer */
-
-#define rfbEncryptBytes rfbClientEncryptBytes
-#define rfbEncryptBytes2 rfbClientEncryptBytes2
-#define rfbDes rfbClientDes
-#define rfbDesKey rfbClientDesKey
-#define rfbUseKey rfbClientUseKey
-#define rfbCPKey rfbClientCPKey
-
-#include "vncauth.c"
-#include "d3des.c"
diff -urN remmina-plugins/vnc/libvncserver/libvncclient/rre.c remmina-plugins/vnc/libvncserver/libvncclient/rre.c
--- remmina-plugins/vnc/libvncserver/libvncclient/rre.c	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins/vnc/libvncserver/libvncclient/rre.c	1970-01-01 10:00:00.000000000 +1000
@@ -1,68 +0,0 @@
-/*
- *  Copyright (C) 1999 AT&T Laboratories Cambridge.  All Rights Reserved.
- *
- *  This is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This software is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this software; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
- *  USA.
- */
-
-/*
- * rre.c - handle RRE encoding.
- *
- * This file shouldn't be compiled directly.  It is included multiple times by
- * rfbproto.c, each time with a different definition of the macro BPP.  For
- * each value of BPP, this file defines a function which handles an RRE
- * encoded rectangle with BPP bits per pixel.
- */
-
-#define HandleRREBPP CONCAT2E(HandleRRE,BPP)
-#define CARDBPP CONCAT3E(uint,BPP,_t)
-
-static rfbBool
-HandleRREBPP (rfbClient* client, int rx, int ry, int rw, int rh)
-{
-  rfbRREHeader hdr;
-  int i;
-  CARDBPP pix;
-  rfbRectangle subrect;
-
-  if (!ReadFromRFBServer(client, (char *)&hdr, sz_rfbRREHeader))
-    return FALSE;
-
-  hdr.nSubrects = rfbClientSwap32IfLE(hdr.nSubrects);
-
-  if (!ReadFromRFBServer(client, (char *)&pix, sizeof(pix)))
-    return FALSE;
-
-  FillRectangle(client, rx, ry, rw, rh, pix);
-
-  for (i = 0; i < hdr.nSubrects; i++) {
-    if (!ReadFromRFBServer(client, (char *)&pix, sizeof(pix)))
-      return FALSE;
-
-    if (!ReadFromRFBServer(client, (char *)&subrect, sz_rfbRectangle))
-      return FALSE;
-
-    subrect.x = rfbClientSwap16IfLE(subrect.x);
-    subrect.y = rfbClientSwap16IfLE(subrect.y);
-    subrect.w = rfbClientSwap16IfLE(subrect.w);
-    subrect.h = rfbClientSwap16IfLE(subrect.h);
-
-    FillRectangle(client, rx+subrect.x, ry+subrect.y, subrect.w, subrect.h, pix);
-  }
-
-  return TRUE;
-}
-
-#undef CARDBPP
diff -urN remmina-plugins/vnc/libvncserver/libvncclient/sockets.c remmina-plugins/vnc/libvncserver/libvncclient/sockets.c
--- remmina-plugins/vnc/libvncserver/libvncclient/sockets.c	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins/vnc/libvncserver/libvncclient/sockets.c	1970-01-01 10:00:00.000000000 +1000
@@ -1,743 +0,0 @@
-/*
- *  Copyright (C) 1999 AT&T Laboratories Cambridge.  All Rights Reserved.
- *
- *  This is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This software is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this software; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
- *  USA.
- */
-
-/*
- * sockets.c - functions to deal with sockets.
- */
-
-#ifdef __STRICT_ANSI__
-#define _BSD_SOURCE
-#endif
-#include <unistd.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <assert.h>
-#include <rfb/rfbclient.h>
-#ifdef WIN32
-#undef SOCKET
-#include <winsock2.h>
-#define EWOULDBLOCK WSAEWOULDBLOCK
-#define close closesocket
-#define read(sock,buf,len) recv(sock,buf,len,0)
-#define write(sock,buf,len) send(sock,buf,len,0)
-#define socklen_t int
-#ifdef LIBVNCSERVER_HAVE_WS2TCPIP_H
-#undef socklen_t
-#include <ws2tcpip.h>
-#endif
-#else
-#include <sys/socket.h>
-#include <netinet/in.h>
-#include <sys/un.h>
-#include <netinet/tcp.h>
-#include <arpa/inet.h>
-#include <netdb.h>
-#endif
-#include "tls.h"
-
-void PrintInHex(char *buf, int len);
-
-rfbBool errorMessageOnReadFailure = TRUE;
-
-/*
- * ReadFromRFBServer is called whenever we want to read some data from the RFB
- * server.  It is non-trivial for two reasons:
- *
- * 1. For efficiency it performs some intelligent buffering, avoiding invoking
- *    the read() system call too often.  For small chunks of data, it simply
- *    copies the data out of an internal buffer.  For large amounts of data it
- *    reads directly into the buffer provided by the caller.
- *
- * 2. Whenever read() would block, it invokes the Xt event dispatching
- *    mechanism to process X events.  In fact, this is the only place these
- *    events are processed, as there is no XtAppMainLoop in the program.
- */
-
-rfbBool
-ReadFromRFBServer(rfbClient* client, char *out, unsigned int n)
-{
-#undef DEBUG_READ_EXACT
-#ifdef DEBUG_READ_EXACT
-	char* oout=out;
-	int nn=n;
-	rfbClientLog("ReadFromRFBServer %d bytes\n",n);
-#endif
-  if (client->serverPort==-1) {
-    /* vncrec playing */
-    rfbVNCRec* rec = client->vncRec;
-    struct timeval tv;
-
-    if (rec->readTimestamp) {
-      rec->readTimestamp = FALSE;
-      if (!fread(&tv,sizeof(struct timeval),1,rec->file))
-        return FALSE;
-
-      tv.tv_sec = rfbClientSwap32IfLE (tv.tv_sec);
-      tv.tv_usec = rfbClientSwap32IfLE (tv.tv_usec);
-
-      if (rec->tv.tv_sec!=0 && !rec->doNotSleep) {
-        struct timeval diff;
-        diff.tv_sec = tv.tv_sec - rec->tv.tv_sec;
-        diff.tv_usec = tv.tv_usec - rec->tv.tv_usec;
-        if(diff.tv_usec<0) {
-	  diff.tv_sec--;
-	  diff.tv_usec+=1000000;
-        }
-#ifndef __MINGW32__
-        sleep (diff.tv_sec);
-        usleep (diff.tv_usec);
-#else
-	Sleep (diff.tv_sec * 1000 + diff.tv_usec/1000);
-#endif
-      }
-
-      rec->tv=tv;
-    }
-    
-    return (fread(out,1,n,rec->file)<0?FALSE:TRUE);
-  }
-  
-  if (n <= client->buffered) {
-    memcpy(out, client->bufoutptr, n);
-    client->bufoutptr += n;
-    client->buffered -= n;
-#ifdef DEBUG_READ_EXACT
-    goto hexdump;
-#endif
-    return TRUE;
-  }
-
-  memcpy(out, client->bufoutptr, client->buffered);
-
-  out += client->buffered;
-  n -= client->buffered;
-
-  client->bufoutptr = client->buf;
-  client->buffered = 0;
-
-  if (n <= RFB_BUF_SIZE) {
-
-    while (client->buffered < n) {
-      int i;
-#ifdef LIBVNCSERVER_WITH_CLIENT_TLS
-      if (client->tlsSession) {
-        i = ReadFromTLS(client, client->buf + client->buffered, RFB_BUF_SIZE - client->buffered);
-      } else {
-#endif
-        i = read(client->sock, client->buf + client->buffered, RFB_BUF_SIZE - client->buffered);
-#ifdef LIBVNCSERVER_WITH_CLIENT_TLS
-      }
-#endif
-      if (i <= 0) {
-	if (i < 0) {
-#ifdef WIN32
-	  errno=WSAGetLastError();
-#endif
-	  if (errno == EWOULDBLOCK || errno == EAGAIN) {
-	    /* TODO:
-	       ProcessXtEvents();
-	    */
-	    WaitForMessage(client, 100000);
-	    i = 0;
-	  } else {
-	    rfbClientErr("read (%d: %s)\n",errno,strerror(errno));
-	    return FALSE;
-	  }
-	} else {
-	  if (errorMessageOnReadFailure) {
-	    rfbClientLog("VNC server closed connection\n");
-	  }
-	  return FALSE;
-	}
-      }
-      client->buffered += i;
-    }
-
-    memcpy(out, client->bufoutptr, n);
-    client->bufoutptr += n;
-    client->buffered -= n;
-
-  } else {
-
-    while (n > 0) {
-      int i;
-#ifdef LIBVNCSERVER_WITH_CLIENT_TLS
-      if (client->tlsSession) {
-        i = ReadFromTLS(client, out, n);
-      } else {
-#endif
-        i = read(client->sock, out, n);
-#ifdef LIBVNCSERVER_WITH_CLIENT_TLS
-      }
-#endif
-      if (i <= 0) {
-	if (i < 0) {
-#ifdef WIN32
-	  errno=WSAGetLastError();
-#endif
-	  if (errno == EWOULDBLOCK || errno == EAGAIN) {
-	    /* TODO:
-	       ProcessXtEvents();
-	    */
-	    WaitForMessage(client, 100000);
-	    i = 0;
-	  } else {
-	    rfbClientErr("read (%s)\n",strerror(errno));
-	    return FALSE;
-	  }
-	} else {
-	  if (errorMessageOnReadFailure) {
-	    rfbClientLog("VNC server closed connection\n");
-	  }
-	  return FALSE;
-	}
-      }
-      out += i;
-      n -= i;
-    }
-  }
-
-#ifdef DEBUG_READ_EXACT
-hexdump:
-  { int ii;
-    for(ii=0;ii<nn;ii++)
-      fprintf(stderr,"%02x ",(unsigned char)oout[ii]);
-    fprintf(stderr,"\n");
-  }
-#endif
-
-  return TRUE;
-}
-
-
-/*
- * Write an exact number of bytes, and don't return until you've sent them.
- */
-
-rfbBool
-WriteToRFBServer(rfbClient* client, char *buf, int n)
-{
-  fd_set fds;
-  int i = 0;
-  int j;
-
-  if (client->serverPort==-1)
-    return TRUE; /* vncrec playing */
-
-#ifdef LIBVNCSERVER_WITH_CLIENT_TLS
-  if (client->tlsSession) {
-    /* WriteToTLS() will guarantee either everything is written, or error/eof returns */
-    i = WriteToTLS(client, buf, n);
-    if (i <= 0) return FALSE;
-
-    return TRUE;
-  }
-#endif
-
-  while (i < n) {
-    j = write(client->sock, buf + i, (n - i));
-    if (j <= 0) {
-      if (j < 0) {
-#ifdef WIN32
-	 errno=WSAGetLastError();
-#endif
-	if (errno == EWOULDBLOCK ||
-#ifdef LIBVNCSERVER_ENOENT_WORKAROUND
-		errno == ENOENT ||
-#endif
-		errno == EAGAIN) {
-	  FD_ZERO(&fds);
-	  FD_SET(client->sock,&fds);
-
-	  if (select(client->sock+1, NULL, &fds, NULL, NULL) <= 0) {
-	    rfbClientErr("select\n");
-	    return FALSE;
-	  }
-	  j = 0;
-	} else {
-	  rfbClientErr("write\n");
-	  return FALSE;
-	}
-      } else {
-	rfbClientLog("write failed\n");
-	return FALSE;
-      }
-    }
-    i += j;
-  }
-  return TRUE;
-}
-
-
-
-static int initSockets() {
-#ifdef WIN32
-  WSADATA trash;
-  static rfbBool WSAinitted=FALSE;
-  if(!WSAinitted) {
-    int i=WSAStartup(MAKEWORD(2,0),&trash);
-    if(i!=0) {
-      rfbClientErr("Couldn't init Windows Sockets\n");
-      return 0;
-    }
-    WSAinitted=TRUE;
-  }
-#endif
-  return 1;
-}
-
-/*
- * ConnectToTcpAddr connects to the given TCP port.
- */
-
-int
-ConnectClientToTcpAddr(unsigned int host, int port)
-{
-  int sock;
-  struct sockaddr_in addr;
-  int one = 1;
-
-  if (!initSockets())
-	  return -1;
-
-  addr.sin_family = AF_INET;
-  addr.sin_port = htons(port);
-  addr.sin_addr.s_addr = host;
-
-  sock = socket(AF_INET, SOCK_STREAM, 0);
-  if (sock < 0) {
-#ifdef WIN32
-    errno=WSAGetLastError();
-#endif
-    rfbClientErr("ConnectToTcpAddr: socket (%s)\n",strerror(errno));
-    return -1;
-  }
-
-  if (connect(sock, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
-    rfbClientErr("ConnectToTcpAddr: connect\n");
-    close(sock);
-    return -1;
-  }
-
-  if (setsockopt(sock, IPPROTO_TCP, TCP_NODELAY,
-		 (char *)&one, sizeof(one)) < 0) {
-    rfbClientErr("ConnectToTcpAddr: setsockopt\n");
-    close(sock);
-    return -1;
-  }
-
-  return sock;
-}
-
-int
-ConnectClientToTcpAddr6(const char *hostname, int port)
-{
-#ifdef LIBVNCSERVER_IPv6
-  int sock;
-  int n;
-  struct addrinfo hints, *res, *ressave;
-  char port_s[10];
-  int one = 1;
-
-  if (!initSockets())
-	  return -1;
-
-  snprintf(port_s, 10, "%d", port);
-  memset(&hints, 0, sizeof(struct addrinfo));
-  hints.ai_family = AF_UNSPEC;
-  hints.ai_socktype = SOCK_STREAM;
-  if ((n = getaddrinfo(hostname, port_s, &hints, &res)))
-  {
-    rfbClientErr("ConnectClientToTcpAddr6: getaddrinfo (%s)\n", gai_strerror(n));
-    return -1;
-  }
-
-  ressave = res;
-  sock = -1;
-  while (res)
-  {
-    sock = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
-    if (sock >= 0)
-    {
-      if (connect(sock, res->ai_addr, res->ai_addrlen) == 0)
-        break;
-      close(sock);
-      sock = -1;
-    }
-    res = res->ai_next;
-  }
-  freeaddrinfo(ressave);
-
-  if (sock == -1)
-  {
-    rfbClientErr("ConnectClientToTcpAddr6: connect\n");
-    return -1;
-  }
-
-  if (setsockopt(sock, IPPROTO_TCP, TCP_NODELAY,
-		 (char *)&one, sizeof(one)) < 0) {
-    rfbClientErr("ConnectToTcpAddr: setsockopt\n");
-    close(sock);
-    return -1;
-  }
-
-  return sock;
-
-#else
-
-  rfbClientErr("ConnectClientToTcpAddr6: IPv6 disabled\n");
-  return -1;
-
-#endif
-}
-
-int
-ConnectClientToUnixSock(const char *sockFile)
-{
-#ifdef WIN32
-  rfbClientErr("Windows doesn't support UNIX sockets\n");
-  return -1;
-#else
-  int sock;
-  struct sockaddr_un addr;
-  addr.sun_family = AF_UNIX;
-  strcpy(addr.sun_path, sockFile);
-
-  sock = socket(AF_UNIX, SOCK_STREAM, 0);
-  if (sock < 0) {
-    rfbClientErr("ConnectToUnixSock: socket (%s)\n",strerror(errno));
-    return -1;
-  }
-
-  if (connect(sock, (struct sockaddr *)&addr, sizeof(addr.sun_family) + strlen(addr.sun_path)) < 0) {
-    rfbClientErr("ConnectToUnixSock: connect\n");
-    close(sock);
-    return -1;
-  }
-
-  return sock;
-#endif
-}
-
-
-
-/*
- * FindFreeTcpPort tries to find unused TCP port in the range
- * (TUNNEL_PORT_OFFSET, TUNNEL_PORT_OFFSET + 99]. Returns 0 on failure.
- */
-
-int
-FindFreeTcpPort(void)
-{
-  int sock, port;
-  struct sockaddr_in addr;
-
-  addr.sin_family = AF_INET;
-  addr.sin_addr.s_addr = htonl(INADDR_ANY);
-
-  if (!initSockets())
-    return -1;
-
-  sock = socket(AF_INET, SOCK_STREAM, 0);
-  if (sock < 0) {
-    rfbClientErr(": FindFreeTcpPort: socket\n");
-    return 0;
-  }
-
-  for (port = TUNNEL_PORT_OFFSET + 99; port > TUNNEL_PORT_OFFSET; port--) {
-    addr.sin_port = htons((unsigned short)port);
-    if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) == 0) {
-      close(sock);
-      return port;
-    }
-  }
-
-  close(sock);
-  return 0;
-}
-
-
-/*
- * ListenAtTcpPort starts listening at the given TCP port.
- */
-
-int
-ListenAtTcpPort(int port)
-{
-  int sock;
-  struct sockaddr_in addr;
-  int one = 1;
-
-  addr.sin_family = AF_INET;
-  addr.sin_port = htons(port);
-  addr.sin_addr.s_addr = htonl(INADDR_ANY);
-
-  if (!initSockets())
-    return -1;
-
-  sock = socket(AF_INET, SOCK_STREAM, 0);
-  if (sock < 0) {
-    rfbClientErr("ListenAtTcpPort: socket\n");
-    return -1;
-  }
-
-  if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR,
-		 (const char *)&one, sizeof(one)) < 0) {
-    rfbClientErr("ListenAtTcpPort: setsockopt\n");
-    close(sock);
-    return -1;
-  }
-
-  if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
-    rfbClientErr("ListenAtTcpPort: bind\n");
-    close(sock);
-    return -1;
-  }
-
-  if (listen(sock, 5) < 0) {
-    rfbClientErr("ListenAtTcpPort: listen\n");
-    close(sock);
-    return -1;
-  }
-
-  return sock;
-}
-
-
-/*
- * AcceptTcpConnection accepts a TCP connection.
- */
-
-int
-AcceptTcpConnection(int listenSock)
-{
-  int sock;
-  struct sockaddr_in addr;
-  socklen_t addrlen = sizeof(addr);
-  int one = 1;
-
-  sock = accept(listenSock, (struct sockaddr *) &addr, &addrlen);
-  if (sock < 0) {
-    rfbClientErr("AcceptTcpConnection: accept\n");
-    return -1;
-  }
-
-  if (setsockopt(sock, IPPROTO_TCP, TCP_NODELAY,
-		 (char *)&one, sizeof(one)) < 0) {
-    rfbClientErr("AcceptTcpConnection: setsockopt\n");
-    close(sock);
-    return -1;
-  }
-
-  return sock;
-}
-
-
-/*
- * SetNonBlocking sets a socket into non-blocking mode.
- */
-
-rfbBool
-SetNonBlocking(int sock)
-{
-#ifdef WIN32
-  unsigned long block=1;
-  if(ioctlsocket(sock, FIONBIO, &block) == SOCKET_ERROR) {
-    errno=WSAGetLastError();
-#else
-  int flags = fcntl(sock, F_GETFL);
-  if(flags < 0 || fcntl(sock, F_SETFL, flags | O_NONBLOCK) < 0) {
-#endif
-    rfbClientErr("Setting socket to non-blocking failed: %s\n",strerror(errno));
-    return FALSE;
-  }
-  return TRUE;
-}
-
-
-
-/*
- * SetDSCP sets a socket's IP QoS parameters aka Differentiated Services Code Point field
- */
-
-rfbBool
-SetDSCP(int sock, int dscp)
-{
-#ifdef WIN32
-  rfbClientErr("Setting of QoS IP DSCP not implemented for Windows\n");
-  return TRUE;
-#else
-  int level, cmd;
-  struct sockaddr addr;
-  socklen_t addrlen = sizeof(addr);
-
-  if(getsockname(sock, &addr, &addrlen) != 0) {
-    rfbClientErr("Setting socket QoS failed while getting socket address: %s\n",strerror(errno));
-    return FALSE;
-  }
-
-  switch(addr.sa_family)
-    {
-#if defined LIBVNCSERVER_IPv6 && defined IPV6_TCLASS
-    case AF_INET6:
-      level = IPPROTO_IPV6;
-      cmd = IPV6_TCLASS;
-      break;
-#endif
-    case AF_INET:
-      level = IPPROTO_IP;
-      cmd = IP_TOS;
-      break;
-    default:
-      rfbClientErr("Setting socket QoS failed: Not bound to IP address");
-      return FALSE;
-    }
-
-  if(setsockopt(sock, level, cmd, (void*)&dscp, sizeof(dscp)) != 0) {
-    rfbClientErr("Setting socket QoS failed: %s\n", strerror(errno));
-    return FALSE;
-  }
-
-  return TRUE;
-#endif
-}
-
-
-
-/*
- * StringToIPAddr - convert a host string to an IP address.
- */
-
-rfbBool
-StringToIPAddr(const char *str, unsigned int *addr)
-{
-  struct hostent *hp;
-
-  if (strcmp(str,"") == 0) {
-    *addr = htonl(INADDR_LOOPBACK); /* local */
-    return TRUE;
-  }
-
-  *addr = inet_addr(str);
-
-  if (*addr != -1)
-    return TRUE;
-
-  if (!initSockets())
-	  return -1;
-
-  hp = gethostbyname(str);
-
-  if (hp) {
-    *addr = *(unsigned int *)hp->h_addr;
-    return TRUE;
-  }
-
-  return FALSE;
-}
-
-
-/*
- * Test if the other end of a socket is on the same machine.
- */
-
-rfbBool
-SameMachine(int sock)
-{
-  struct sockaddr_in peeraddr, myaddr;
-  socklen_t addrlen = sizeof(struct sockaddr_in);
-
-  getpeername(sock, (struct sockaddr *)&peeraddr, &addrlen);
-  getsockname(sock, (struct sockaddr *)&myaddr, &addrlen);
-
-  return (peeraddr.sin_addr.s_addr == myaddr.sin_addr.s_addr);
-}
-
-
-/*
- * Print out the contents of a packet for debugging.
- */
-
-void
-PrintInHex(char *buf, int len)
-{
-  int i, j;
-  char c, str[17];
-
-  str[16] = 0;
-
-  rfbClientLog("ReadExact: ");
-
-  for (i = 0; i < len; i++)
-    {
-      if ((i % 16 == 0) && (i != 0)) {
-	rfbClientLog("           ");
-      }
-      c = buf[i];
-      str[i % 16] = (((c > 31) && (c < 127)) ? c : '.');
-      rfbClientLog("%02x ",(unsigned char)c);
-      if ((i % 4) == 3)
-	rfbClientLog(" ");
-      if ((i % 16) == 15)
-	{
-	  rfbClientLog("%s\n",str);
-	}
-    }
-  if ((i % 16) != 0)
-    {
-      for (j = i % 16; j < 16; j++)
-	{
-	  rfbClientLog("   ");
-	  if ((j % 4) == 3) rfbClientLog(" ");
-	}
-      str[i % 16] = 0;
-      rfbClientLog("%s\n",str);
-    }
-
-  fflush(stderr);
-}
-
-int WaitForMessage(rfbClient* client,unsigned int usecs)
-{
-  fd_set fds;
-  struct timeval timeout;
-  int num;
-
-  if (client->serverPort==-1)
-    /* playing back vncrec file */
-    return 1;
-  
-  timeout.tv_sec=(usecs/1000000);
-  timeout.tv_usec=(usecs%1000000);
-
-  FD_ZERO(&fds);
-  FD_SET(client->sock,&fds);
-
-  num=select(client->sock+1, &fds, NULL, NULL, &timeout);
-  if(num<0) {
-#ifdef WIN32
-    errno=WSAGetLastError();
-#endif
-    rfbClientLog("Waiting for message failed: %d (%s)\n",errno,strerror(errno));
-  }
-
-  return num;
-}
-
-
diff -urN remmina-plugins/vnc/libvncserver/libvncclient/tight.c remmina-plugins/vnc/libvncserver/libvncclient/tight.c
--- remmina-plugins/vnc/libvncserver/libvncclient/tight.c	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins/vnc/libvncserver/libvncclient/tight.c	1970-01-01 10:00:00.000000000 +1000
@@ -1,688 +0,0 @@
-/*
- *  Copyright (C) 2000, 2001 Const Kaplinsky.  All Rights Reserved.
- *
- *  This is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This software is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this software; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
- *  USA.
- */
-
-#ifdef LIBVNCSERVER_HAVE_LIBZ
-#ifdef LIBVNCSERVER_HAVE_LIBJPEG
-
-/*
- * tight.c - handle ``tight'' encoding.
- *
- * This file shouldn't be compiled directly. It is included multiple
- * times by rfbproto.c, each time with a different definition of the
- * macro BPP. For each value of BPP, this file defines a function
- * which handles a tight-encoded rectangle with BPP bits per pixel.
- *
- */
-
-#define TIGHT_MIN_TO_COMPRESS 12
-
-#define CARDBPP CONCAT3E(uint,BPP,_t)
-#define filterPtrBPP CONCAT2E(filterPtr,BPP)
-
-#define HandleTightBPP CONCAT2E(HandleTight,BPP)
-#define InitFilterCopyBPP CONCAT2E(InitFilterCopy,BPP)
-#define InitFilterPaletteBPP CONCAT2E(InitFilterPalette,BPP)
-#define InitFilterGradientBPP CONCAT2E(InitFilterGradient,BPP)
-#define FilterCopyBPP CONCAT2E(FilterCopy,BPP)
-#define FilterPaletteBPP CONCAT2E(FilterPalette,BPP)
-#define FilterGradientBPP CONCAT2E(FilterGradient,BPP)
-
-#if BPP != 8
-#define DecompressJpegRectBPP CONCAT2E(DecompressJpegRect,BPP)
-#endif
-
-#ifndef RGB_TO_PIXEL
-
-#define RGB_TO_PIXEL(bpp,r,g,b)						\
-  (((CARD##bpp)(r) & client->format.redMax) << client->format.redShift |		\
-   ((CARD##bpp)(g) & client->format.greenMax) << client->format.greenShift |	\
-   ((CARD##bpp)(b) & client->format.blueMax) << client->format.blueShift)
-
-#define RGB24_TO_PIXEL(bpp,r,g,b)                                       \
-   ((((CARD##bpp)(r) & 0xFF) * client->format.redMax + 127) / 255             \
-    << client->format.redShift |                                              \
-    (((CARD##bpp)(g) & 0xFF) * client->format.greenMax + 127) / 255           \
-    << client->format.greenShift |                                            \
-    (((CARD##bpp)(b) & 0xFF) * client->format.blueMax + 127) / 255            \
-    << client->format.blueShift)
-
-#define RGB24_TO_PIXEL32(r,g,b)						\
-  (((uint32_t)(r) & 0xFF) << client->format.redShift |				\
-   ((uint32_t)(g) & 0xFF) << client->format.greenShift |			\
-   ((uint32_t)(b) & 0xFF) << client->format.blueShift)
-
-#endif
-
-/* Type declarations */
-
-typedef void (*filterPtrBPP)(rfbClient* client, int, CARDBPP *);
-
-/* Prototypes */
-
-static int InitFilterCopyBPP (rfbClient* client, int rw, int rh);
-static int InitFilterPaletteBPP (rfbClient* client, int rw, int rh);
-static int InitFilterGradientBPP (rfbClient* client, int rw, int rh);
-static void FilterCopyBPP (rfbClient* client, int numRows, CARDBPP *destBuffer);
-static void FilterPaletteBPP (rfbClient* client, int numRows, CARDBPP *destBuffer);
-static void FilterGradientBPP (rfbClient* client, int numRows, CARDBPP *destBuffer);
-
-#if BPP != 8
-static rfbBool DecompressJpegRectBPP(rfbClient* client, int x, int y, int w, int h);
-#endif
-
-/* Definitions */
-
-static rfbBool
-HandleTightBPP (rfbClient* client, int rx, int ry, int rw, int rh)
-{
-  CARDBPP fill_colour;
-  uint8_t comp_ctl;
-  uint8_t filter_id;
-  filterPtrBPP filterFn;
-  z_streamp zs;
-  char *buffer2;
-  int err, stream_id, compressedLen, bitsPixel;
-  int bufferSize, rowSize, numRows, portionLen, rowsProcessed, extraBytes;
-
-  if (!ReadFromRFBServer(client, (char *)&comp_ctl, 1))
-    return FALSE;
-
-  /* Flush zlib streams if we are told by the server to do so. */
-  for (stream_id = 0; stream_id < 4; stream_id++) {
-    if ((comp_ctl & 1) && client->zlibStreamActive[stream_id]) {
-      if (inflateEnd (&client->zlibStream[stream_id]) != Z_OK &&
-	  client->zlibStream[stream_id].msg != NULL)
-	rfbClientLog("inflateEnd: %s\n", client->zlibStream[stream_id].msg);
-      client->zlibStreamActive[stream_id] = FALSE;
-    }
-    comp_ctl >>= 1;
-  }
-
-  /* Handle solid rectangles. */
-  if (comp_ctl == rfbTightFill) {
-#if BPP == 32
-    if (client->format.depth == 24 && client->format.redMax == 0xFF &&
-	client->format.greenMax == 0xFF && client->format.blueMax == 0xFF) {
-      if (!ReadFromRFBServer(client, client->buffer, 3))
-	return FALSE;
-      fill_colour = RGB24_TO_PIXEL32(client->buffer[0], client->buffer[1], client->buffer[2]);
-    } else {
-      if (!ReadFromRFBServer(client, (char*)&fill_colour, sizeof(fill_colour)))
-	return FALSE;
-    }
-#else
-    if (!ReadFromRFBServer(client, (char*)&fill_colour, sizeof(fill_colour)))
-	return FALSE;
-#endif
-
-    FillRectangle(client, rx, ry, rw, rh, fill_colour);
-
-    return TRUE;
-  }
-
-#if BPP == 8
-  if (comp_ctl == rfbTightJpeg) {
-    rfbClientLog("Tight encoding: JPEG is not supported in 8 bpp mode.\n");
-    return FALSE;
-  }
-#else
-  if (comp_ctl == rfbTightJpeg) {
-    return DecompressJpegRectBPP(client, rx, ry, rw, rh);
-  }
-#endif
-
-  /* Quit on unsupported subencoding value. */
-  if (comp_ctl > rfbTightMaxSubencoding) {
-    rfbClientLog("Tight encoding: bad subencoding value received.\n");
-    return FALSE;
-  }
-
-  /*
-   * Here primary compression mode handling begins.
-   * Data was processed with optional filter + zlib compression.
-   */
-
-  /* First, we should identify a filter to use. */
-  if ((comp_ctl & rfbTightExplicitFilter) != 0) {
-    if (!ReadFromRFBServer(client, (char*)&filter_id, 1))
-      return FALSE;
-
-    switch (filter_id) {
-    case rfbTightFilterCopy:
-      filterFn = FilterCopyBPP;
-      bitsPixel = InitFilterCopyBPP(client, rw, rh);
-      break;
-    case rfbTightFilterPalette:
-      filterFn = FilterPaletteBPP;
-      bitsPixel = InitFilterPaletteBPP(client, rw, rh);
-      break;
-    case rfbTightFilterGradient:
-      filterFn = FilterGradientBPP;
-      bitsPixel = InitFilterGradientBPP(client, rw, rh);
-      break;
-    default:
-      rfbClientLog("Tight encoding: unknown filter code received.\n");
-      return FALSE;
-    }
-  } else {
-    filterFn = FilterCopyBPP;
-    bitsPixel = InitFilterCopyBPP(client, rw, rh);
-  }
-  if (bitsPixel == 0) {
-    rfbClientLog("Tight encoding: error receiving palette.\n");
-    return FALSE;
-  }
-
-  /* Determine if the data should be decompressed or just copied. */
-  rowSize = (rw * bitsPixel + 7) / 8;
-  if (rh * rowSize < TIGHT_MIN_TO_COMPRESS) {
-    if (!ReadFromRFBServer(client, (char*)client->buffer, rh * rowSize))
-      return FALSE;
-
-    buffer2 = &client->buffer[TIGHT_MIN_TO_COMPRESS * 4];
-    filterFn(client, rh, (CARDBPP *)buffer2);
-
-    CopyRectangle(client, (uint8_t *)buffer2, rx, ry, rw, rh);
-
-    return TRUE;
-  }
-
-  /* Read the length (1..3 bytes) of compressed data following. */
-  compressedLen = (int)ReadCompactLen(client);
-  if (compressedLen <= 0) {
-    rfbClientLog("Incorrect data received from the server.\n");
-    return FALSE;
-  }
-
-  /* Now let's initialize compression stream if needed. */
-  stream_id = comp_ctl & 0x03;
-  zs = &client->zlibStream[stream_id];
-  if (!client->zlibStreamActive[stream_id]) {
-    zs->zalloc = Z_NULL;
-    zs->zfree = Z_NULL;
-    zs->opaque = Z_NULL;
-    err = inflateInit(zs);
-    if (err != Z_OK) {
-      if (zs->msg != NULL)
-	rfbClientLog("InflateInit error: %s.\n", zs->msg);
-      return FALSE;
-    }
-    client->zlibStreamActive[stream_id] = TRUE;
-  }
-
-  /* Read, decode and draw actual pixel data in a loop. */
-
-  bufferSize = RFB_BUFFER_SIZE * bitsPixel / (bitsPixel + BPP) & 0xFFFFFFFC;
-  buffer2 = &client->buffer[bufferSize];
-  if (rowSize > bufferSize) {
-    /* Should be impossible when RFB_BUFFER_SIZE >= 16384 */
-    rfbClientLog("Internal error: incorrect buffer size.\n");
-    return FALSE;
-  }
-
-  rowsProcessed = 0;
-  extraBytes = 0;
-
-  while (compressedLen > 0) {
-    if (compressedLen > ZLIB_BUFFER_SIZE)
-      portionLen = ZLIB_BUFFER_SIZE;
-    else
-      portionLen = compressedLen;
-
-    if (!ReadFromRFBServer(client, (char*)client->zlib_buffer, portionLen))
-      return FALSE;
-
-    compressedLen -= portionLen;
-
-    zs->next_in = (Bytef *)client->zlib_buffer;
-    zs->avail_in = portionLen;
-
-    do {
-      zs->next_out = (Bytef *)&client->buffer[extraBytes];
-      zs->avail_out = bufferSize - extraBytes;
-
-      err = inflate(zs, Z_SYNC_FLUSH);
-      if (err == Z_BUF_ERROR)   /* Input exhausted -- no problem. */
-	break;
-      if (err != Z_OK && err != Z_STREAM_END) {
-	if (zs->msg != NULL) {
-	  rfbClientLog("Inflate error: %s.\n", zs->msg);
-	} else {
-	  rfbClientLog("Inflate error: %d.\n", err);
-	}
-	return FALSE;
-      }
-
-      numRows = (bufferSize - zs->avail_out) / rowSize;
-
-      filterFn(client, numRows, (CARDBPP *)buffer2);
-
-      extraBytes = bufferSize - zs->avail_out - numRows * rowSize;
-      if (extraBytes > 0)
-	memcpy(client->buffer, &client->buffer[numRows * rowSize], extraBytes);
-
-      CopyRectangle(client, (uint8_t *)buffer2, rx, ry+rowsProcessed, rw, numRows);
-
-      rowsProcessed += numRows;
-    }
-    while (zs->avail_out == 0);
-  }
-
-  if (rowsProcessed != rh) {
-    rfbClientLog("Incorrect number of scan lines after decompression.\n");
-    return FALSE;
-  }
-
-  return TRUE;
-}
-
-/*----------------------------------------------------------------------------
- *
- * Filter stuff.
- *
- */
-
-static int
-InitFilterCopyBPP (rfbClient* client, int rw, int rh)
-{
-  client->rectWidth = rw;
-
-#if BPP == 32
-  if (client->format.depth == 24 && client->format.redMax == 0xFF &&
-      client->format.greenMax == 0xFF && client->format.blueMax == 0xFF) {
-    client->cutZeros = TRUE;
-    return 24;
-  } else {
-    client->cutZeros = FALSE;
-  }
-#endif
-
-  return BPP;
-}
-
-static void
-FilterCopyBPP (rfbClient* client, int numRows, CARDBPP *dst)
-{
-
-#if BPP == 32
-  int x, y;
-
-  if (client->cutZeros) {
-    for (y = 0; y < numRows; y++) {
-      for (x = 0; x < client->rectWidth; x++) {
-	dst[y*client->rectWidth+x] =
-	  RGB24_TO_PIXEL32(client->buffer[(y*client->rectWidth+x)*3],
-			   client->buffer[(y*client->rectWidth+x)*3+1],
-			   client->buffer[(y*client->rectWidth+x)*3+2]);
-      }
-    }
-    return;
-  }
-#endif
-
-  memcpy (dst, client->buffer, numRows * client->rectWidth * (BPP / 8));
-}
-
-static int
-InitFilterGradientBPP (rfbClient* client, int rw, int rh)
-{
-  int bits;
-
-  bits = InitFilterCopyBPP(client, rw, rh);
-  if (client->cutZeros)
-    memset(client->tightPrevRow, 0, rw * 3);
-  else
-    memset(client->tightPrevRow, 0, rw * 3 * sizeof(uint16_t));
-
-  return bits;
-}
-
-#if BPP == 32
-
-static void
-FilterGradient24 (rfbClient* client, int numRows, uint32_t *dst)
-{
-  int x, y, c;
-  uint8_t thisRow[2048*3];
-  uint8_t pix[3];
-  int est[3];
-
-  for (y = 0; y < numRows; y++) {
-
-    /* First pixel in a row */
-    for (c = 0; c < 3; c++) {
-      pix[c] = client->tightPrevRow[c] + client->buffer[y*client->rectWidth*3+c];
-      thisRow[c] = pix[c];
-    }
-    dst[y*client->rectWidth] = RGB24_TO_PIXEL32(pix[0], pix[1], pix[2]);
-
-    /* Remaining pixels of a row */
-    for (x = 1; x < client->rectWidth; x++) {
-      for (c = 0; c < 3; c++) {
-	est[c] = (int)client->tightPrevRow[x*3+c] + (int)pix[c] -
-		 (int)client->tightPrevRow[(x-1)*3+c];
-	if (est[c] > 0xFF) {
-	  est[c] = 0xFF;
-	} else if (est[c] < 0x00) {
-	  est[c] = 0x00;
-	}
-	pix[c] = (uint8_t)est[c] + client->buffer[(y*client->rectWidth+x)*3+c];
-	thisRow[x*3+c] = pix[c];
-      }
-      dst[y*client->rectWidth+x] = RGB24_TO_PIXEL32(pix[0], pix[1], pix[2]);
-    }
-
-    memcpy(client->tightPrevRow, thisRow, client->rectWidth * 3);
-  }
-}
-
-#endif
-
-static void
-FilterGradientBPP (rfbClient* client, int numRows, CARDBPP *dst)
-{
-  int x, y, c;
-  CARDBPP *src = (CARDBPP *)client->buffer;
-  uint16_t *thatRow = (uint16_t *)client->tightPrevRow;
-  uint16_t thisRow[2048*3];
-  uint16_t pix[3];
-  uint16_t max[3];
-  int shift[3];
-  int est[3];
-
-#if BPP == 32
-  if (client->cutZeros) {
-    FilterGradient24(client, numRows, dst);
-    return;
-  }
-#endif
-
-  max[0] = client->format.redMax;
-  max[1] = client->format.greenMax;
-  max[2] = client->format.blueMax;
-
-  shift[0] = client->format.redShift;
-  shift[1] = client->format.greenShift;
-  shift[2] = client->format.blueShift;
-
-  for (y = 0; y < numRows; y++) {
-
-    /* First pixel in a row */
-    for (c = 0; c < 3; c++) {
-      pix[c] = (uint16_t)(((src[y*client->rectWidth] >> shift[c]) + thatRow[c]) & max[c]);
-      thisRow[c] = pix[c];
-    }
-    dst[y*client->rectWidth] = RGB_TO_PIXEL(BPP, pix[0], pix[1], pix[2]);
-
-    /* Remaining pixels of a row */
-    for (x = 1; x < client->rectWidth; x++) {
-      for (c = 0; c < 3; c++) {
-	est[c] = (int)thatRow[x*3+c] + (int)pix[c] - (int)thatRow[(x-1)*3+c];
-	if (est[c] > (int)max[c]) {
-	  est[c] = (int)max[c];
-	} else if (est[c] < 0) {
-	  est[c] = 0;
-	}
-	pix[c] = (uint16_t)(((src[y*client->rectWidth+x] >> shift[c]) + est[c]) & max[c]);
-	thisRow[x*3+c] = pix[c];
-      }
-      dst[y*client->rectWidth+x] = RGB_TO_PIXEL(BPP, pix[0], pix[1], pix[2]);
-    }
-    memcpy(thatRow, thisRow, client->rectWidth * 3 * sizeof(uint16_t));
-  }
-}
-
-static int
-InitFilterPaletteBPP (rfbClient* client, int rw, int rh)
-{
-  uint8_t numColors;
-#if BPP == 32
-  int i;
-  CARDBPP *palette = (CARDBPP *)client->tightPalette;
-#endif
-
-  client->rectWidth = rw;
-
-  if (!ReadFromRFBServer(client, (char*)&numColors, 1))
-    return 0;
-
-  client->rectColors = (int)numColors;
-  if (++client->rectColors < 2)
-    return 0;
-
-#if BPP == 32
-  if (client->format.depth == 24 && client->format.redMax == 0xFF &&
-      client->format.greenMax == 0xFF && client->format.blueMax == 0xFF) {
-    if (!ReadFromRFBServer(client, (char*)&client->tightPalette, client->rectColors * 3))
-      return 0;
-    for (i = client->rectColors - 1; i >= 0; i--) {
-      palette[i] = RGB24_TO_PIXEL32(client->tightPalette[i*3],
-				    client->tightPalette[i*3+1],
-				    client->tightPalette[i*3+2]);
-    }
-    return (client->rectColors == 2) ? 1 : 8;
-  }
-#endif
-
-  if (!ReadFromRFBServer(client, (char*)&client->tightPalette, client->rectColors * (BPP / 8)))
-    return 0;
-
-  return (client->rectColors == 2) ? 1 : 8;
-}
-
-static void
-FilterPaletteBPP (rfbClient* client, int numRows, CARDBPP *dst)
-{
-  int x, y, b, w;
-  uint8_t *src = (uint8_t *)client->buffer;
-  CARDBPP *palette = (CARDBPP *)client->tightPalette;
-
-  if (client->rectColors == 2) {
-    w = (client->rectWidth + 7) / 8;
-    for (y = 0; y < numRows; y++) {
-      for (x = 0; x < client->rectWidth / 8; x++) {
-	for (b = 7; b >= 0; b--)
-	  dst[y*client->rectWidth+x*8+7-b] = palette[src[y*w+x] >> b & 1];
-      }
-      for (b = 7; b >= 8 - client->rectWidth % 8; b--) {
-	dst[y*client->rectWidth+x*8+7-b] = palette[src[y*w+x] >> b & 1];
-      }
-    }
-  } else {
-    for (y = 0; y < numRows; y++)
-      for (x = 0; x < client->rectWidth; x++)
-	dst[y*client->rectWidth+x] = palette[(int)src[y*client->rectWidth+x]];
-  }
-}
-
-#if BPP != 8
-
-/*----------------------------------------------------------------------------
- *
- * JPEG decompression.
- *
- */
-
-static rfbBool
-DecompressJpegRectBPP(rfbClient* client, int x, int y, int w, int h)
-{
-  struct jpeg_decompress_struct cinfo;
-  struct jpeg_error_mgr jerr;
-  int compressedLen;
-  uint8_t *compressedData;
-  CARDBPP *pixelPtr;
-  JSAMPROW rowPointer[1];
-  int dx, dy;
-
-  compressedLen = (int)ReadCompactLen(client);
-  if (compressedLen <= 0) {
-    rfbClientLog("Incorrect data received from the server.\n");
-    return FALSE;
-  }
-
-  compressedData = malloc(compressedLen);
-  if (compressedData == NULL) {
-    rfbClientLog("Memory allocation error.\n");
-    return FALSE;
-  }
-
-  if (!ReadFromRFBServer(client, (char*)compressedData, compressedLen)) {
-    free(compressedData);
-    return FALSE;
-  }
-
-  cinfo.err = jpeg_std_error(&jerr);
-  cinfo.client_data = client;
-  jpeg_create_decompress(&cinfo);
-
-  JpegSetSrcManager(&cinfo, compressedData, compressedLen);
-
-  jpeg_read_header(&cinfo, TRUE);
-  cinfo.out_color_space = JCS_RGB;
-
-  jpeg_start_decompress(&cinfo);
-  if (cinfo.output_width != w || cinfo.output_height != h ||
-      cinfo.output_components != 3) {
-    rfbClientLog("Tight Encoding: Wrong JPEG data received.\n");
-    jpeg_destroy_decompress(&cinfo);
-    free(compressedData);
-    return FALSE;
-  }
-
-  rowPointer[0] = (JSAMPROW)client->buffer;
-  dy = 0;
-  while (cinfo.output_scanline < cinfo.output_height) {
-    jpeg_read_scanlines(&cinfo, rowPointer, 1);
-    if (client->jpegError) {
-      break;
-    }
-    pixelPtr = (CARDBPP *)&client->buffer[RFB_BUFFER_SIZE / 2];
-    for (dx = 0; dx < w; dx++) {
-      *pixelPtr++ =
-	RGB24_TO_PIXEL(BPP, client->buffer[dx*3], client->buffer[dx*3+1], client->buffer[dx*3+2]);
-    }
-    CopyRectangle(client, (uint8_t *)&client->buffer[RFB_BUFFER_SIZE / 2], x, y + dy, w, 1);
-    dy++;
-  }
-
-  if (!client->jpegError)
-    jpeg_finish_decompress(&cinfo);
-
-  jpeg_destroy_decompress(&cinfo);
-  free(compressedData);
-
-  return !client->jpegError;
-}
-
-#else
-
-static long
-ReadCompactLen (rfbClient* client)
-{
-  long len;
-  uint8_t b;
-
-  if (!ReadFromRFBServer(client, (char *)&b, 1))
-    return -1;
-  len = (int)b & 0x7F;
-  if (b & 0x80) {
-    if (!ReadFromRFBServer(client, (char *)&b, 1))
-      return -1;
-    len |= ((int)b & 0x7F) << 7;
-    if (b & 0x80) {
-      if (!ReadFromRFBServer(client, (char *)&b, 1))
-	return -1;
-      len |= ((int)b & 0xFF) << 14;
-    }
-  }
-  return len;
-}
-
-/*
- * JPEG source manager functions for JPEG decompression in Tight decoder.
- */
-
-static void
-JpegInitSource(j_decompress_ptr cinfo)
-{
-  rfbClient* client=(rfbClient*)cinfo->client_data;
-  client->jpegError = FALSE;
-}
-
-static boolean
-JpegFillInputBuffer(j_decompress_ptr cinfo)
-{
-  rfbClient* client=(rfbClient*)cinfo->client_data;
-  client->jpegError = TRUE;
-  client->jpegSrcManager->bytes_in_buffer = client->jpegBufferLen;
-  client->jpegSrcManager->next_input_byte = (JOCTET *)client->jpegBufferPtr;
-
-  return TRUE;
-}
-
-static void
-JpegSkipInputData(j_decompress_ptr cinfo, long num_bytes)
-{
-  rfbClient* client=(rfbClient*)cinfo->client_data;
-  if (num_bytes < 0 || num_bytes > client->jpegSrcManager->bytes_in_buffer) {
-    client->jpegError = TRUE;
-    client->jpegSrcManager->bytes_in_buffer = client->jpegBufferLen;
-    client->jpegSrcManager->next_input_byte = (JOCTET *)client->jpegBufferPtr;
-  } else {
-    client->jpegSrcManager->next_input_byte += (size_t) num_bytes;
-    client->jpegSrcManager->bytes_in_buffer -= (size_t) num_bytes;
-  }
-}
-
-static void
-JpegTermSource(j_decompress_ptr cinfo)
-{
-  /* nothing to do here. */
-}
-
-static void
-JpegSetSrcManager(j_decompress_ptr cinfo,
-		  uint8_t *compressedData,
-		  int compressedLen)
-{
-  rfbClient* client=(rfbClient*)cinfo->client_data;
-  client->jpegBufferPtr = compressedData;
-  client->jpegBufferLen = (size_t)compressedLen;
-
-  if(client->jpegSrcManager == NULL)
-    client->jpegSrcManager = malloc(sizeof(struct jpeg_source_mgr));
-  client->jpegSrcManager->init_source = JpegInitSource;
-  client->jpegSrcManager->fill_input_buffer = JpegFillInputBuffer;
-  client->jpegSrcManager->skip_input_data = JpegSkipInputData;
-  client->jpegSrcManager->resync_to_restart = jpeg_resync_to_restart;
-  client->jpegSrcManager->term_source = JpegTermSource;
-  client->jpegSrcManager->next_input_byte = (JOCTET*)client->jpegBufferPtr;
-  client->jpegSrcManager->bytes_in_buffer = client->jpegBufferLen;
-
-  cinfo->src = client->jpegSrcManager;
-}
-
-#endif
-
-#undef CARDBPP
-
-/* LIBVNCSERVER_HAVE_LIBZ and LIBVNCSERVER_HAVE_LIBJPEG */
-#endif
-#endif
-
diff -urN remmina-plugins/vnc/libvncserver/libvncclient/tls.c remmina-plugins/vnc/libvncserver/libvncclient/tls.c
--- remmina-plugins/vnc/libvncserver/libvncclient/tls.c	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins/vnc/libvncserver/libvncclient/tls.c	1970-01-01 10:00:00.000000000 +1000
@@ -1,536 +0,0 @@
-/*
- *  Copyright (C) 2009 Vic Lee.
- *
- *  This is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This software is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this software; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
- *  USA.
- */
-
-#include <rfb/rfbclient.h>
-#include <errno.h>
-#ifdef WIN32
-#undef SOCKET
-#include <windows.h>           /* for Sleep() */
-#define sleep(X) Sleep(1000*X) /* MinGW32 has no sleep() */
-#include <winsock2.h>
-#define read(sock,buf,len) recv(sock,buf,len,0)
-#define write(sock,buf,len) send(sock,buf,len,0)
-#endif
-#include "tls.h"
-
-#ifdef LIBVNCSERVER_WITH_CLIENT_TLS
-
-static const int rfbCertTypePriority[] = { GNUTLS_CRT_X509, 0 };
-static const int rfbProtoPriority[]= { GNUTLS_TLS1_1, GNUTLS_TLS1_0, GNUTLS_SSL3, 0 };
-static const int rfbKXPriority[] = {GNUTLS_KX_DHE_DSS, GNUTLS_KX_RSA, GNUTLS_KX_DHE_RSA, GNUTLS_KX_SRP, 0};
-static const int rfbKXAnon[] = {GNUTLS_KX_ANON_DH, 0};
-
-#define DH_BITS 1024
-static gnutls_dh_params_t rfbDHParams;
-
-static rfbBool rfbTLSInitialized = FALSE;
-
-static rfbBool
-InitializeTLS(void)
-{
-  int ret;
-
-  if (rfbTLSInitialized) return TRUE;
-  if ((ret = gnutls_global_init()) < 0 ||
-      (ret = gnutls_dh_params_init(&rfbDHParams)) < 0 ||
-      (ret = gnutls_dh_params_generate2(rfbDHParams, DH_BITS)) < 0)
-  {
-    rfbClientLog("Failed to initialized GnuTLS: %s.\n", gnutls_strerror(ret));
-    return FALSE;
-  }
-  rfbClientLog("GnuTLS initialized.\n");
-  rfbTLSInitialized = TRUE;
-  return TRUE;
-}
-
-/*
- * On Windows, translate WSAGetLastError() to errno values as GNU TLS does it
- * internally too. This is necessary because send() and recv() on Windows
- * don't set errno when they fail but GNUTLS expects a proper errno value.
- *
- * Use gnutls_transport_set_global_errno() like the GNU TLS documentation
- * suggests to avoid problems with different errno variables when GNU TLS and
- * libvncclient are linked to different versions of msvcrt.dll.
- */
-#ifdef WIN32
-static void WSAtoTLSErrno()
-{
-  switch(WSAGetLastError()) {
-  case WSAEWOULDBLOCK:
-    gnutls_transport_set_global_errno(EAGAIN);
-    break;
-  case WSAEINTR:
-    gnutls_transport_set_global_errno(EINTR);
-    break;
-  default:
-    gnutls_transport_set_global_errno(EIO);
-    break;
-  }
-}
-#endif
-
-
-static ssize_t
-PushTLS(gnutls_transport_ptr_t transport, const void *data, size_t len)
-{
-  rfbClient *client = (rfbClient*)transport;
-  int ret;
-
-  while (1)
-  {
-    ret = write(client->sock, data, len);
-    if (ret < 0)
-    {
-#ifdef WIN32
-      WSAtoTLSErrno();
-#endif
-      if (errno == EINTR) continue;
-      return -1;
-    }
-    return ret;
-  }
-}
-
-
-static ssize_t
-PullTLS(gnutls_transport_ptr_t transport, void *data, size_t len)
-{
-  rfbClient *client = (rfbClient*)transport;
-  int ret;
-
-  while (1)
-  {
-    ret = read(client->sock, data, len);
-    if (ret < 0)
-    {
-#ifdef WIN32
-      WSAtoTLSErrno();
-#endif
-      if (errno == EINTR) continue;
-      return -1;
-    }
-    return ret;
-  }
-}
-
-static rfbBool
-InitializeTLSSession(rfbClient* client, rfbBool anonTLS)
-{
-  int ret;
-
-  if (client->tlsSession) return TRUE;
-
-  if ((ret = gnutls_init(&client->tlsSession, GNUTLS_CLIENT)) < 0)
-  {
-    rfbClientLog("Failed to initialized TLS session: %s.\n", gnutls_strerror(ret));
-    return FALSE;
-  }
-
-  if ((ret = gnutls_set_default_priority(client->tlsSession)) < 0 ||
-      (ret = gnutls_kx_set_priority(client->tlsSession, anonTLS ? rfbKXAnon : rfbKXPriority)) < 0 ||
-      (ret = gnutls_certificate_type_set_priority(client->tlsSession, rfbCertTypePriority)) < 0 ||
-      (ret = gnutls_protocol_set_priority(client->tlsSession, rfbProtoPriority)) < 0)
-  {
-    rfbClientLog("Warning: Failed to set TLS priority: %s.\n", gnutls_strerror(ret));
-  }
-
-  gnutls_transport_set_ptr(client->tlsSession, (gnutls_transport_ptr_t)client);
-  gnutls_transport_set_push_function(client->tlsSession, PushTLS);
-  gnutls_transport_set_pull_function(client->tlsSession, PullTLS);
-
-  rfbClientLog("TLS session initialized.\n");
-
-  return TRUE;
-}
-
-static rfbBool
-SetTLSAnonCredential(rfbClient* client)
-{
-  gnutls_anon_client_credentials anonCred;
-  int ret;
-
-  if ((ret = gnutls_anon_allocate_client_credentials(&anonCred)) < 0 ||
-      (ret = gnutls_credentials_set(client->tlsSession, GNUTLS_CRD_ANON, anonCred)) < 0)
-  {
-    FreeTLS(client);
-    rfbClientLog("Failed to create anonymous credentials: %s", gnutls_strerror(ret));
-    return FALSE;
-  }
-  rfbClientLog("TLS anonymous credential created.\n");
-  return TRUE;
-}
-
-static rfbBool
-HandshakeTLS(rfbClient* client)
-{
-  int timeout = 15;
-  int ret;
-
-  while (timeout > 0 && (ret = gnutls_handshake(client->tlsSession)) < 0)
-  {
-    if (!gnutls_error_is_fatal(ret))
-    {
-      rfbClientLog("TLS handshake blocking.\n");
-      sleep(1);
-      timeout--;
-      continue;
-    }
-    rfbClientLog("TLS handshake failed: %s.\n", gnutls_strerror(ret));
-    FreeTLS(client);
-    return FALSE;
-  }
-
-  if (timeout <= 0)
-  {
-    rfbClientLog("TLS handshake timeout.\n");
-    FreeTLS(client);
-    return FALSE;
-  }
-
-  rfbClientLog("TLS handshake done.\n");
-  return TRUE;
-}
-
-/* VeNCrypt sub auth. 1 byte auth count, followed by count * 4 byte integers */
-static rfbBool
-ReadVeNCryptSecurityType(rfbClient* client, uint32_t *result)
-{
-    uint8_t count=0;
-    uint8_t loop=0;
-    uint8_t flag=0;
-    uint32_t tAuth[256], t;
-    char buf1[500],buf2[10];
-    uint32_t authScheme;
-
-    if (!ReadFromRFBServer(client, (char *)&count, 1)) return FALSE;
-
-    if (count==0)
-    {
-        rfbClientLog("List of security types is ZERO. Giving up.\n");
-        return FALSE;
-    }
-
-    if (count>sizeof(tAuth))
-    {
-        rfbClientLog("%d security types are too many; maximum is %d\n", count, sizeof(tAuth));
-        return FALSE;
-    }
-
-    rfbClientLog("We have %d security types to read\n", count);
-    authScheme=0;
-    /* now, we have a list of available security types to read ( uint8_t[] ) */
-    for (loop=0;loop<count;loop++)
-    {
-        if (!ReadFromRFBServer(client, (char *)&tAuth[loop], 4)) return FALSE;
-        t=rfbClientSwap32IfLE(tAuth[loop]);
-        rfbClientLog("%d) Received security type %d\n", loop, t);
-        if (flag) continue;
-        if (t==rfbVeNCryptTLSNone ||
-            t==rfbVeNCryptTLSVNC ||
-            t==rfbVeNCryptTLSPlain ||
-            t==rfbVeNCryptX509None ||
-            t==rfbVeNCryptX509VNC ||
-            t==rfbVeNCryptX509Plain)
-        {
-            flag++;
-            authScheme=t;
-            rfbClientLog("Selecting security type %d (%d/%d in the list)\n", authScheme, loop, count);
-            /* send back 4 bytes (in original byte order!) indicating which security type to use */
-            if (!WriteToRFBServer(client, (char *)&tAuth[loop], 4)) return FALSE;
-        }
-        tAuth[loop]=t;
-    }
-    if (authScheme==0)
-    {
-        memset(buf1, 0, sizeof(buf1));
-        for (loop=0;loop<count;loop++)
-        {
-            if (strlen(buf1)>=sizeof(buf1)-1) break;
-            snprintf(buf2, sizeof(buf2), (loop>0 ? ", %d" : "%d"), (int)tAuth[loop]);
-            strncat(buf1, buf2, sizeof(buf1)-strlen(buf1)-1);
-        }
-        rfbClientLog("Unknown VeNCrypt authentication scheme from VNC server: %s\n",
-               buf1);
-        return FALSE;
-    }
-    *result = authScheme;
-    return TRUE;
-}
-
-static void
-FreeX509Credential(rfbCredential *cred)
-{
-  if (cred->x509Credential.x509CACertFile) free(cred->x509Credential.x509CACertFile);
-  if (cred->x509Credential.x509CACrlFile) free(cred->x509Credential.x509CACrlFile);
-  if (cred->x509Credential.x509ClientCertFile) free(cred->x509Credential.x509ClientCertFile);
-  if (cred->x509Credential.x509ClientKeyFile) free(cred->x509Credential.x509ClientKeyFile);
-  free(cred);
-}
-
-static gnutls_certificate_credentials_t
-CreateX509CertCredential(rfbCredential *cred)
-{
-  gnutls_certificate_credentials_t x509_cred;
-  int ret;
-
-  if (!cred->x509Credential.x509CACertFile)
-  {
-    rfbClientLog("No CA certificate provided.\n");
-    return NULL;
-  }
-
-  if ((ret = gnutls_certificate_allocate_credentials(&x509_cred)) < 0)
-  {
-    rfbClientLog("Cannot allocate credentials: %s.\n", gnutls_strerror(ret));
-    return NULL;
-  }
-  if ((ret = gnutls_certificate_set_x509_trust_file(x509_cred,
-    cred->x509Credential.x509CACertFile, GNUTLS_X509_FMT_PEM)) < 0)
-  {
-    rfbClientLog("Cannot load CA credentials: %s.\n", gnutls_strerror(ret));
-    gnutls_certificate_free_credentials (x509_cred);
-    return NULL;
-  }
-  if (cred->x509Credential.x509ClientCertFile && cred->x509Credential.x509ClientKeyFile)
-  {
-    if ((ret = gnutls_certificate_set_x509_key_file(x509_cred,
-      cred->x509Credential.x509ClientCertFile, cred->x509Credential.x509ClientKeyFile,
-      GNUTLS_X509_FMT_PEM)) < 0)
-    {
-      rfbClientLog("Cannot load client certificate or key: %s.\n", gnutls_strerror(ret));
-      gnutls_certificate_free_credentials (x509_cred);
-      return NULL;
-    }
-  } else
-  {
-    rfbClientLog("No client certificate or key provided.\n");
-  }
-  if (cred->x509Credential.x509CACrlFile)
-  {
-    if ((ret = gnutls_certificate_set_x509_crl_file(x509_cred,
-      cred->x509Credential.x509CACrlFile, GNUTLS_X509_FMT_PEM)) < 0)
-    {
-      rfbClientLog("Cannot load CRL: %s.\n", gnutls_strerror(ret));
-      gnutls_certificate_free_credentials (x509_cred);
-      return NULL;
-    }
-  } else
-  {
-    rfbClientLog("No CRL provided.\n");
-  }
-  gnutls_certificate_set_dh_params (x509_cred, rfbDHParams);
-  return x509_cred;
-}
-
-#endif
-
-rfbBool
-HandleAnonTLSAuth(rfbClient* client)
-{
-#ifdef LIBVNCSERVER_WITH_CLIENT_TLS
-
-  if (!InitializeTLS() || !InitializeTLSSession(client, TRUE)) return FALSE;
-
-  if (!SetTLSAnonCredential(client)) return FALSE;
-
-  if (!HandshakeTLS(client)) return FALSE;
-
-  return TRUE;
-
-#else
-  rfbClientLog("TLS is not supported.\n");
-  return FALSE;
-#endif
-}
-
-rfbBool
-HandleVeNCryptAuth(rfbClient* client)
-{
-#ifdef LIBVNCSERVER_WITH_CLIENT_TLS
-  uint8_t major, minor, status;
-  uint32_t authScheme;
-  rfbBool anonTLS;
-  gnutls_certificate_credentials_t x509_cred = NULL;
-  int ret;
-
-  if (!InitializeTLS()) return FALSE;
-
-  /* Read VeNCrypt version */
-  if (!ReadFromRFBServer(client, (char *)&major, 1) ||
-      !ReadFromRFBServer(client, (char *)&minor, 1))
-  {
-    return FALSE;
-  }
-  rfbClientLog("Got VeNCrypt version %d.%d from server.\n", (int)major, (int)minor);
-
-  if (major != 0 && minor != 2)
-  {
-    rfbClientLog("Unsupported VeNCrypt version.\n");
-    return FALSE;
-  }
-
-  if (!WriteToRFBServer(client, (char *)&major, 1) ||
-      !WriteToRFBServer(client, (char *)&minor, 1) ||
-      !ReadFromRFBServer(client, (char *)&status, 1))
-  {
-    return FALSE;
-  }
-
-  if (status != 0)
-  {
-    rfbClientLog("Server refused VeNCrypt version %d.%d.\n", (int)major, (int)minor);
-    return FALSE;
-  }
-
-  if (!ReadVeNCryptSecurityType(client, &authScheme)) return FALSE;
-  if (!ReadFromRFBServer(client, (char *)&status, 1) || status != 1)
-  {
-    rfbClientLog("Server refused VeNCrypt authentication %d (%d).\n", authScheme, (int)status);
-    return FALSE;
-  }
-  client->subAuthScheme = authScheme;
-
-  /* Some VeNCrypt security types are anonymous TLS, others are X509 */
-  switch (authScheme)
-  {
-    case rfbVeNCryptTLSNone:
-    case rfbVeNCryptTLSVNC:
-    case rfbVeNCryptTLSPlain:
-      anonTLS = TRUE;
-      break;
-    default:
-      anonTLS = FALSE;
-      break;
-  }
-
-  /* Get X509 Credentials if it's not anonymous */
-  if (!anonTLS)
-  {
-    rfbCredential *cred;
-
-    if (!client->GetCredential)
-    {
-      rfbClientLog("GetCredential callback is not set.\n");
-      return FALSE;
-    }
-    cred = client->GetCredential(client, rfbCredentialTypeX509);
-    if (!cred)
-    {
-      rfbClientLog("Reading credential failed\n");
-      return FALSE;
-    }
-
-    x509_cred = CreateX509CertCredential(cred);
-    FreeX509Credential(cred);
-    if (!x509_cred) return FALSE;
-  }
-
-  /* Start up the TLS session */
-  if (!InitializeTLSSession(client, anonTLS)) return FALSE;
-
-  if (anonTLS)
-  {
-    if (!SetTLSAnonCredential(client)) return FALSE;
-  }
-  else
-  {
-    if ((ret = gnutls_credentials_set(client->tlsSession, GNUTLS_CRD_CERTIFICATE, x509_cred)) < 0)
-    {
-      rfbClientLog("Cannot set x509 credential: %s.\n", gnutls_strerror(ret));
-      FreeTLS(client);
-      return FALSE;
-    }
-  }
-
-  if (!HandshakeTLS(client)) return FALSE;
-
-  /* TODO: validate certificate */
-
-  /* We are done here. The caller should continue with client->subAuthScheme
-   * to do actual sub authentication.
-   */
-  return TRUE;
-
-#else
-  rfbClientLog("TLS is not supported.\n");
-  return FALSE;
-#endif
-}
-
-int
-ReadFromTLS(rfbClient* client, char *out, unsigned int n)
-{
-#ifdef LIBVNCSERVER_WITH_CLIENT_TLS
-  ssize_t ret;
-
-  ret = gnutls_record_recv(client->tlsSession, out, n);
-  if (ret >= 0) return ret;
-  if (ret == GNUTLS_E_REHANDSHAKE || ret == GNUTLS_E_AGAIN)
-  {
-    errno = EAGAIN;
-  } else
-  {
-    rfbClientLog("Error reading from TLS: %s.\n", gnutls_strerror(ret));
-    errno = EINTR;
-  }
-  return -1;
-#else
-  rfbClientLog("TLS is not supported.\n");
-  errno = EINTR;
-  return -1;
-#endif
-}
-
-int
-WriteToTLS(rfbClient* client, char *buf, unsigned int n)
-{
-#ifdef LIBVNCSERVER_WITH_CLIENT_TLS
-  unsigned int offset = 0;
-  ssize_t ret;
-
-  while (offset < n)
-  {
-    ret = gnutls_record_send(client->tlsSession, buf+offset, (size_t)(n-offset));
-    if (ret == 0) continue;
-    if (ret < 0)
-    {
-      if (ret == GNUTLS_E_AGAIN || ret == GNUTLS_E_INTERRUPTED) continue;
-      rfbClientLog("Error writing to TLS: %s.\n", gnutls_strerror(ret));
-      return -1;
-    }
-    offset += (unsigned int)ret;
-  }
-  return offset;
-#else
-  rfbClientLog("TLS is not supported.\n");
-  errno = EINTR;
-  return -1;
-#endif
-}
-
-void FreeTLS(rfbClient* client)
-{
-#ifdef LIBVNCSERVER_WITH_CLIENT_TLS
-  if (client->tlsSession)
-  {
-    gnutls_deinit(client->tlsSession);
-    client->tlsSession = NULL;
-  }
-#endif
-}
diff -urN remmina-plugins/vnc/libvncserver/libvncclient/tls.h remmina-plugins/vnc/libvncserver/libvncclient/tls.h
--- remmina-plugins/vnc/libvncserver/libvncclient/tls.h	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins/vnc/libvncserver/libvncclient/tls.h	1970-01-01 10:00:00.000000000 +1000
@@ -1,51 +0,0 @@
-#ifndef TLS_H
-#define TLS_H
-
-/*
- *  Copyright (C) 2009 Vic Lee.
- *
- *  This is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This software is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this software; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
- *  USA.
- */
-
-/* Handle Anonymous TLS Authentication (18) with the server.
- * After authentication, client->tlsSession will be set.
- */
-rfbBool HandleAnonTLSAuth(rfbClient* client);
-
-/* Handle VeNCrypt Authentication (19) with the server.
- * The callback function GetX509Credential will be called.
- * After authentication, client->tlsSession will be set.
- */
-rfbBool HandleVeNCryptAuth(rfbClient* client);
-
-/* Read desired bytes from TLS session.
- * It's a wrapper function over gnutls_record_recv() and return values
- * are same as read(), that is, >0 for actual bytes read, 0 for EOF,
- * or EAGAIN, EINTR.
- * This should be a non-blocking call. Blocking is handled in sockets.c.
- */
-int ReadFromTLS(rfbClient* client, char *out, unsigned int n);
-
-/* Write desired bytes to TLS session.
- * It's a wrapper function over gnutls_record_send() and it will be
- * blocking call, until all bytes are written or error returned.
- */
-int WriteToTLS(rfbClient* client, char *buf, unsigned int n);
-
-/* Free TLS resources */
-void FreeTLS(rfbClient* client);
-
-#endif /* TLS_H */
diff -urN remmina-plugins/vnc/libvncserver/libvncclient/ultra.c remmina-plugins/vnc/libvncserver/libvncclient/ultra.c
--- remmina-plugins/vnc/libvncserver/libvncclient/ultra.c	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins/vnc/libvncserver/libvncclient/ultra.c	1970-01-01 10:00:00.000000000 +1000
@@ -1,210 +0,0 @@
-/*
- *  Copyright (C) 2000 Tridia Corporation.  All Rights Reserved.
- *  Copyright (C) 1999 AT&T Laboratories Cambridge.  All Rights Reserved.
- *
- *  This is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This software is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this software; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
- *  USA.
- */
-
-/*
- * ultrazip.c - handle ultrazip encoding.
- *
- * This file shouldn't be compiled directly.  It is included multiple times by
- * rfbproto.c, each time with a different definition of the macro BPP.  For
- * each value of BPP, this file defines a function which handles an zlib
- * encoded rectangle with BPP bits per pixel.
- */
-
-#define HandleUltraZipBPP CONCAT2E(HandleUltraZip,BPP)
-#define HandleUltraBPP CONCAT2E(HandleUltra,BPP)
-#define CARDBPP CONCAT3E(uint,BPP,_t)
-
-static rfbBool
-HandleUltraBPP (rfbClient* client, int rx, int ry, int rw, int rh)
-{
-  rfbZlibHeader hdr;
-  int toRead=0;
-  int inflateResult=0;
-  lzo_uint uncompressedBytes = (( rw * rh ) * ( BPP / 8 ));
-
-  if (!ReadFromRFBServer(client, (char *)&hdr, sz_rfbZlibHeader))
-    return FALSE;
-
-  toRead = rfbClientSwap32IfLE(hdr.nBytes);
-  if (toRead==0) return TRUE;
-
-  if (uncompressedBytes==0)
-  {
-      rfbClientLog("ultra error: rectangle has 0 uncomressed bytes ((%dw * %dh) * (%d / 8))\n", rw, rh, BPP); 
-      return FALSE;
-  }
-
-  /* First make sure we have a large enough raw buffer to hold the
-   * decompressed data.  In practice, with a fixed BPP, fixed frame
-   * buffer size and the first update containing the entire frame
-   * buffer, this buffer allocation should only happen once, on the
-   * first update.
-   */
-  if ( client->raw_buffer_size < (int)uncompressedBytes) {
-    if ( client->raw_buffer != NULL ) {
-      free( client->raw_buffer );
-    }
-    client->raw_buffer_size = uncompressedBytes;
-    /* buffer needs to be aligned on 4-byte boundaries */
-    if ((client->raw_buffer_size % 4)!=0)
-      client->raw_buffer_size += (4-(client->raw_buffer_size % 4));
-    client->raw_buffer = (char*) malloc( client->raw_buffer_size );
-  }
-  
-  /* allocate enough space to store the incoming compressed packet */
-  if ( client->ultra_buffer_size < toRead ) {
-    if ( client->ultra_buffer != NULL ) {
-      free( client->ultra_buffer );
-    }
-    client->ultra_buffer_size = toRead;
-    /* buffer needs to be aligned on 4-byte boundaries */
-    if ((client->ultra_buffer_size % 4)!=0)
-      client->ultra_buffer_size += (4-(client->ultra_buffer_size % 4));
-    client->ultra_buffer = (char*) malloc( client->ultra_buffer_size );
-  }
-
-  /* Fill the buffer, obtaining data from the server. */
-  if (!ReadFromRFBServer(client, client->ultra_buffer, toRead))
-      return FALSE;
-
-  /* uncompress the data */
-  uncompressedBytes = client->raw_buffer_size;
-  inflateResult = lzo1x_decompress(
-              (lzo_byte *)client->ultra_buffer, toRead,
-              (lzo_byte *)client->raw_buffer, (lzo_uintp) &uncompressedBytes,
-              NULL);
-  
-  
-  if ((rw * rh * (BPP / 8)) != uncompressedBytes)
-      rfbClientLog("Ultra decompressed too little (%d < %d)", (rw * rh * (BPP / 8)), uncompressedBytes);
-  
-  /* Put the uncompressed contents of the update on the screen. */
-  if ( inflateResult == LZO_E_OK ) 
-  {
-    CopyRectangle(client, (unsigned char *)client->raw_buffer, rx, ry, rw, rh);
-  }
-  else
-  {
-    rfbClientLog("ultra decompress returned error: %d\n",
-            inflateResult);
-    return FALSE;
-  }
-  return TRUE;
-}
-
-
-/* UltraZip is like rre in that it is composed of subrects */
-static rfbBool
-HandleUltraZipBPP (rfbClient* client, int rx, int ry, int rw, int rh)
-{
-  rfbZlibHeader hdr;
-  int i=0;
-  int toRead=0;
-  int inflateResult=0;
-  unsigned char *ptr=NULL;
-  lzo_uint uncompressedBytes = ry + (rw * 65535);
-  unsigned int numCacheRects = rx;
-
-  if (!ReadFromRFBServer(client, (char *)&hdr, sz_rfbZlibHeader))
-    return FALSE;
-
-  toRead = rfbClientSwap32IfLE(hdr.nBytes);
-
-  if (toRead==0) return TRUE;
-
-  if (uncompressedBytes==0)
-  {
-      rfbClientLog("ultrazip error: rectangle has 0 uncomressed bytes (%dy + (%dw * 65535)) (%d rectangles)\n", ry, rw, rx); 
-      return FALSE;
-  }
-
-  /* First make sure we have a large enough raw buffer to hold the
-   * decompressed data.  In practice, with a fixed BPP, fixed frame
-   * buffer size and the first update containing the entire frame
-   * buffer, this buffer allocation should only happen once, on the
-   * first update.
-   */
-  if ( client->raw_buffer_size < (int)(uncompressedBytes + 500)) {
-    if ( client->raw_buffer != NULL ) {
-      free( client->raw_buffer );
-    }
-    client->raw_buffer_size = uncompressedBytes + 500;
-    /* buffer needs to be aligned on 4-byte boundaries */
-    if ((client->raw_buffer_size % 4)!=0)
-      client->raw_buffer_size += (4-(client->raw_buffer_size % 4));
-    client->raw_buffer = (char*) malloc( client->raw_buffer_size );
-  }
-
- 
-  /* allocate enough space to store the incoming compressed packet */
-  if ( client->ultra_buffer_size < toRead ) {
-    if ( client->ultra_buffer != NULL ) {
-      free( client->ultra_buffer );
-    }
-    client->ultra_buffer_size = toRead;
-    client->ultra_buffer = (char*) malloc( client->ultra_buffer_size );
-  }
-
-  /* Fill the buffer, obtaining data from the server. */
-  if (!ReadFromRFBServer(client, client->ultra_buffer, toRead))
-      return FALSE;
-
-  /* uncompress the data */
-  uncompressedBytes = client->raw_buffer_size;
-  inflateResult = lzo1x_decompress(
-              (lzo_byte *)client->ultra_buffer, toRead,
-              (lzo_byte *)client->raw_buffer, &uncompressedBytes, NULL);
-  if ( inflateResult != LZO_E_OK ) 
-  {
-    rfbClientLog("ultra decompress returned error: %d\n",
-            inflateResult);
-    return FALSE;
-  }
-  
-  /* Put the uncompressed contents of the update on the screen. */
-  ptr = (unsigned char *)client->raw_buffer;
-  for (i=0; i<numCacheRects; i++)
-  {
-    unsigned short sx, sy, sw, sh;
-    unsigned int se;
-
-    memcpy((char *)&sx, ptr, 2); ptr += 2;
-    memcpy((char *)&sy, ptr, 2); ptr += 2;
-    memcpy((char *)&sw, ptr, 2); ptr += 2;
-    memcpy((char *)&sh, ptr, 2); ptr += 2;
-    memcpy((char *)&se, ptr, 4); ptr += 4;
-
-    sx = rfbClientSwap16IfLE(sx);
-    sy = rfbClientSwap16IfLE(sy);
-    sw = rfbClientSwap16IfLE(sw);
-    sh = rfbClientSwap16IfLE(sh);
-    se = rfbClientSwap32IfLE(se);
-
-    if (se == rfbEncodingRaw)
-    {
-        CopyRectangle(client, (unsigned char *)ptr, sx, sy, sw, sh);
-        ptr += ((sw * sh) * (BPP / 8));
-    }
-  }  
-
-  return TRUE;
-}
-
-#undef CARDBPP
diff -urN remmina-plugins/vnc/libvncserver/libvncclient/vncviewer.c remmina-plugins/vnc/libvncserver/libvncclient/vncviewer.c
--- remmina-plugins/vnc/libvncserver/libvncclient/vncviewer.c	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins/vnc/libvncserver/libvncclient/vncviewer.c	1970-01-01 10:00:00.000000000 +1000
@@ -1,379 +0,0 @@
-/*
- *  Copyright (C) 1999 AT&T Laboratories Cambridge.  All Rights Reserved.
- *
- *  This is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This software is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this software; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
- *  USA.
- */
-
-/*
- * vncviewer.c - the Xt-based VNC viewer.
- */
-
-#ifdef __STRICT_ANSI__
-#define _BSD_SOURCE
-#define _POSIX_SOURCE
-#endif
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <time.h>
-#include <rfb/rfbclient.h>
-#include "tls.h"
-
-static void Dummy(rfbClient* client) {
-}
-static rfbBool DummyPoint(rfbClient* client, int x, int y) {
-  return TRUE;
-}
-static void DummyRect(rfbClient* client, int x, int y, int w, int h) {
-}
-
-#ifdef __MINGW32__
-static char* NoPassword(rfbClient* client) {
-  return strdup("");
-}
-#undef SOCKET
-#include <winsock2.h>
-#define close closesocket
-#else
-#include <stdio.h>
-#include <termios.h>
-#endif
-
-static char* ReadPassword(rfbClient* client) {
-#ifdef __MINGW32__
-	/* FIXME */
-	rfbClientErr("ReadPassword on MinGW32 NOT IMPLEMENTED\n");
-	return NoPassword(client);
-#else
-	int i;
-	char* p=malloc(9);
-	struct termios save,noecho;
-	p[0]=0;
-	if(tcgetattr(fileno(stdin),&save)!=0) return p;
-	noecho=save; noecho.c_lflag &= ~ECHO;
-	if(tcsetattr(fileno(stdin),TCSAFLUSH,&noecho)!=0) return p;
-	fprintf(stderr,"Password: ");
-	i=0;
-	while(1) {
-		int c=fgetc(stdin);
-		if(c=='\n')
-			break;
-		if(i<8) {
-			p[i]=c;
-			i++;
-			p[i]=0;
-		}
-	}
-	tcsetattr(fileno(stdin),TCSAFLUSH,&save);
-	return p;
-#endif
-}
-static rfbBool MallocFrameBuffer(rfbClient* client) {
-  if(client->frameBuffer)
-    free(client->frameBuffer);
-  client->frameBuffer=malloc(client->width*client->height*client->format.bitsPerPixel/8);
-  return client->frameBuffer?TRUE:FALSE;
-}
-
-static void initAppData(AppData* data) {
-	data->shareDesktop=TRUE;
-	data->viewOnly=FALSE;
-	data->encodingsString="tight zrle ultra copyrect hextile zlib corre rre raw";
-	data->useBGR233=FALSE;
-	data->nColours=0;
-	data->forceOwnCmap=FALSE;
-	data->forceTrueColour=FALSE;
-	data->requestedDepth=0;
-	data->compressLevel=3;
-	data->qualityLevel=5;
-#ifdef LIBVNCSERVER_HAVE_LIBJPEG
-	data->enableJPEG=TRUE;
-#else
-	data->enableJPEG=FALSE;
-#endif
-	data->useRemoteCursor=FALSE;
-}
-
-rfbClient* rfbGetClient(int bitsPerSample,int samplesPerPixel,
-			int bytesPerPixel) {
-  rfbClient* client=(rfbClient*)calloc(sizeof(rfbClient),1);
-  if(!client) {
-    rfbClientErr("Couldn't allocate client structure!\n");
-    return NULL;
-  }
-  initAppData(&client->appData);
-  client->endianTest = 1;
-  client->programName="";
-  client->serverHost=strdup("");
-  client->serverPort=5900;
-
-  client->destHost = NULL;
-  client->destPort = 5900;
-  
-  client->CurrentKeyboardLedState = 0;
-  client->HandleKeyboardLedState = (HandleKeyboardLedStateProc)DummyPoint;
-
-  /* default: use complete frame buffer */ 
-  client->updateRect.x = -1;
- 
-  client->format.bitsPerPixel = bytesPerPixel*8;
-  client->format.depth = bitsPerSample*samplesPerPixel;
-  client->appData.requestedDepth=client->format.depth;
-  client->format.bigEndian = *(char *)&client->endianTest?FALSE:TRUE;
-  client->format.trueColour = TRUE;
-
-  if (client->format.bitsPerPixel == 8) {
-    client->format.redMax = 7;
-    client->format.greenMax = 7;
-    client->format.blueMax = 3;
-    client->format.redShift = 0;
-    client->format.greenShift = 3;
-    client->format.blueShift = 6;
-  } else {
-    client->format.redMax = (1 << bitsPerSample) - 1;
-    client->format.greenMax = (1 << bitsPerSample) - 1;
-    client->format.blueMax = (1 << bitsPerSample) - 1;
-    if(!client->format.bigEndian) {
-      client->format.redShift = 0;
-      client->format.greenShift = bitsPerSample;
-      client->format.blueShift = bitsPerSample * 2;
-    } else {
-      if(client->format.bitsPerPixel==8*3) {
-	client->format.redShift = bitsPerSample*2;
-	client->format.greenShift = bitsPerSample*1;
-	client->format.blueShift = 0;
-      } else {
-	client->format.redShift = bitsPerSample*3;
-	client->format.greenShift = bitsPerSample*2;
-	client->format.blueShift = bitsPerSample;
-      }
-    }
-  }
-
-  client->bufoutptr=client->buf;
-  client->buffered=0;
-
-#ifdef LIBVNCSERVER_HAVE_LIBZ
-  client->raw_buffer_size = -1;
-  client->decompStreamInited = FALSE;
-
-#ifdef LIBVNCSERVER_HAVE_LIBJPEG
-  memset(client->zlibStreamActive,0,sizeof(rfbBool)*4);
-  client->jpegSrcManager = NULL;
-#endif
-#endif
-
-  client->HandleCursorPos = DummyPoint;
-  client->SoftCursorLockArea = DummyRect;
-  client->SoftCursorUnlockScreen = Dummy;
-  client->GotFrameBufferUpdate = DummyRect;
-  client->FinishedFrameBufferUpdate = NULL;
-  client->GetPassword = ReadPassword;
-  client->MallocFrameBuffer = MallocFrameBuffer;
-  client->Bell = Dummy;
-  client->CurrentKeyboardLedState = 0;
-  client->HandleKeyboardLedState = (HandleKeyboardLedStateProc)DummyPoint;
-  client->QoS_DSCP = 0;
-
-  client->authScheme = 0;
-  client->subAuthScheme = 0;
-  client->GetCredential = NULL;
-#ifdef LIBVNCSERVER_WITH_CLIENT_TLS
-  client->tlsSession = NULL;
-#endif
-  client->sock = -1;
-  client->listenSock = -1;
-  client->clientAuthSchemes = NULL;
-  return client;
-}
-
-static rfbBool rfbInitConnection(rfbClient* client)
-{
-  /* Unless we accepted an incoming connection, make a TCP connection to the
-     given VNC server */
-
-  if (!client->listenSpecified) {
-    if (!client->serverHost)
-      return FALSE;
-    if (client->destHost) {
-      if (!ConnectToRFBRepeater(client,client->serverHost,client->serverPort,client->destHost,client->destPort))
-        return FALSE;
-    } else {
-      if (!ConnectToRFBServer(client,client->serverHost,client->serverPort))
-        return FALSE;
-    }
-  }
-
-  /* Initialise the VNC connection, including reading the password */
-
-  if (!InitialiseRFBConnection(client))
-    return FALSE;
-
-  client->width=client->si.framebufferWidth;
-  client->height=client->si.framebufferHeight;
-  client->MallocFrameBuffer(client);
-
-  if (!SetFormatAndEncodings(client))
-    return FALSE;
-
-  if (client->updateRect.x < 0) {
-    client->updateRect.x = client->updateRect.y = 0;
-    client->updateRect.w = client->width;
-    client->updateRect.h = client->height;
-  }
-
-  if (client->appData.scaleSetting>1)
-  {
-      if (!SendScaleSetting(client, client->appData.scaleSetting))
-          return FALSE;
-      if (!SendFramebufferUpdateRequest(client,
-			      client->updateRect.x / client->appData.scaleSetting,
-			      client->updateRect.y / client->appData.scaleSetting,
-			      client->updateRect.w / client->appData.scaleSetting,
-			      client->updateRect.h / client->appData.scaleSetting,
-			      FALSE))
-	      return FALSE;
-  }
-  else
-  {
-      if (!SendFramebufferUpdateRequest(client,
-			      client->updateRect.x, client->updateRect.y,
-			      client->updateRect.w, client->updateRect.h,
-			      FALSE))
-      return FALSE;
-  }
-
-  return TRUE;
-}
-
-rfbBool rfbInitClient(rfbClient* client,int* argc,char** argv) {
-  int i,j;
-
-  if(argv && argc && *argc) {
-    if(client->programName==0)
-      client->programName=argv[0];
-
-    for (i = 1; i < *argc; i++) {
-      j = i;
-      if (strcmp(argv[i], "-listen") == 0) {
-	listenForIncomingConnections(client);
-	break;
-      } else if (strcmp(argv[i], "-listennofork") == 0) {
-	listenForIncomingConnectionsNoFork(client, -1);
-	break;
-      } else if (strcmp(argv[i], "-play") == 0) {
-	client->serverPort = -1;
-	j++;
-      } else if (i+1<*argc && strcmp(argv[i], "-encodings") == 0) {
-	client->appData.encodingsString = argv[i+1];
-	j+=2;
-      } else if (i+1<*argc && strcmp(argv[i], "-compress") == 0) {
-	client->appData.compressLevel = atoi(argv[i+1]);
-	j+=2;
-      } else if (i+1<*argc && strcmp(argv[i], "-quality") == 0) {
-	client->appData.qualityLevel = atoi(argv[i+1]);
-	j+=2;
-      } else if (i+1<*argc && strcmp(argv[i], "-scale") == 0) {
-        client->appData.scaleSetting = atoi(argv[i+1]);
-        j+=2;
-      } else if (i+1<*argc && strcmp(argv[i], "-qosdscp") == 0) {
-        client->QoS_DSCP = atoi(argv[i+1]);
-        j+=2;
-      } else if (i+1<*argc && strcmp(argv[i], "-repeaterdest") == 0) {
-	char* colon=strchr(argv[i+1],':');
-
-	if(client->destHost)
-	  free(client->destHost);
-        client->destPort = 5900;
-
-	client->destHost = strdup(argv[i+1]);
-	if(colon) {
-	  client->destHost[(int)(colon-argv[i+1])] = '\0';
-	  client->destPort = atoi(colon+1);
-	}
-        j+=2;
-      } else {
-	char* colon=strchr(argv[i],':');
-
-	if(client->serverHost)
-	  free(client->serverHost);
-
-	if(colon) {
-	  client->serverHost = strdup(argv[i]);
-	  client->serverHost[(int)(colon-argv[i])] = '\0';
-	  client->serverPort = atoi(colon+1);
-	} else {
-	  client->serverHost = strdup(argv[i]);
-	}
-	if(client->serverPort >= 0 && client->serverPort < 5900)
-	  client->serverPort += 5900;
-      }
-      /* purge arguments */
-      if (j>i) {
-	*argc-=j-i;
-	memmove(argv+i,argv+j,(*argc-i)*sizeof(char*));
-	i--;
-      }
-    }
-  }
-
-  if(!rfbInitConnection(client)) {
-    rfbClientCleanup(client);
-    return FALSE;
-  }
-
-  return TRUE;
-}
-
-void rfbClientCleanup(rfbClient* client) {
-#ifdef LIBVNCSERVER_HAVE_LIBZ
-#ifdef LIBVNCSERVER_HAVE_LIBJPEG
-  int i;
-
-  for ( i = 0; i < 4; i++ ) {
-    if (client->zlibStreamActive[i] == TRUE ) {
-      if (inflateEnd (&client->zlibStream[i]) != Z_OK &&
-	  client->zlibStream[i].msg != NULL)
-	rfbClientLog("inflateEnd: %s\n", client->zlibStream[i].msg);
-    }
-  }
-
-  if ( client->decompStreamInited == TRUE ) {
-    if (inflateEnd (&client->decompStream) != Z_OK &&
-	client->decompStream.msg != NULL)
-      rfbClientLog("inflateEnd: %s\n", client->decompStream.msg );
-  }
-
-  if (client->jpegSrcManager)
-    free(client->jpegSrcManager);
-#endif
-#endif
-
-#ifdef LIBVNCSERVER_WITH_CLIENT_TLS
-  FreeTLS(client);
-#endif
-  if (client->sock >= 0)
-    close(client->sock);
-  if (client->listenSock >= 0)
-    close(client->listenSock);
-  free(client->desktopName);
-  free(client->serverHost);
-  if (client->destHost)
-    free(client->destHost);
-  if (client->clientAuthSchemes)
-    free(client->clientAuthSchemes);
-  free(client);
-}
diff -urN remmina-plugins/vnc/libvncserver/libvncclient/zlib.c remmina-plugins/vnc/libvncserver/libvncclient/zlib.c
--- remmina-plugins/vnc/libvncserver/libvncclient/zlib.c	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins/vnc/libvncserver/libvncclient/zlib.c	1970-01-01 10:00:00.000000000 +1000
@@ -1,162 +0,0 @@
-/*
- *  Copyright (C) 2000 Tridia Corporation.  All Rights Reserved.
- *  Copyright (C) 1999 AT&T Laboratories Cambridge.  All Rights Reserved.
- *
- *  This is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This software is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this software; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
- *  USA.
- */
-
-#ifdef LIBVNCSERVER_HAVE_LIBZ
-
-/*
- * zlib.c - handle zlib encoding.
- *
- * This file shouldn't be compiled directly.  It is included multiple times by
- * rfbproto.c, each time with a different definition of the macro BPP.  For
- * each value of BPP, this file defines a function which handles an zlib
- * encoded rectangle with BPP bits per pixel.
- */
-
-#define HandleZlibBPP CONCAT2E(HandleZlib,BPP)
-#define CARDBPP CONCAT3E(uint,BPP,_t)
-
-static rfbBool
-HandleZlibBPP (rfbClient* client, int rx, int ry, int rw, int rh)
-{
-  rfbZlibHeader hdr;
-  int remaining;
-  int inflateResult;
-  int toRead;
-
-  /* First make sure we have a large enough raw buffer to hold the
-   * decompressed data.  In practice, with a fixed BPP, fixed frame
-   * buffer size and the first update containing the entire frame
-   * buffer, this buffer allocation should only happen once, on the
-   * first update.
-   */
-  if ( client->raw_buffer_size < (( rw * rh ) * ( BPP / 8 ))) {
-
-    if ( client->raw_buffer != NULL ) {
-
-      free( client->raw_buffer );
-
-    }
-
-    client->raw_buffer_size = (( rw * rh ) * ( BPP / 8 ));
-    client->raw_buffer = (char*) malloc( client->raw_buffer_size );
-
-  }
-
-  if (!ReadFromRFBServer(client, (char *)&hdr, sz_rfbZlibHeader))
-    return FALSE;
-
-  remaining = rfbClientSwap32IfLE(hdr.nBytes);
-
-  /* Need to initialize the decompressor state. */
-  client->decompStream.next_in   = ( Bytef * )client->buffer;
-  client->decompStream.avail_in  = 0;
-  client->decompStream.next_out  = ( Bytef * )client->raw_buffer;
-  client->decompStream.avail_out = client->raw_buffer_size;
-  client->decompStream.data_type = Z_BINARY;
-
-  /* Initialize the decompression stream structures on the first invocation. */
-  if ( client->decompStreamInited == FALSE ) {
-
-    inflateResult = inflateInit( &client->decompStream );
-
-    if ( inflateResult != Z_OK ) {
-      rfbClientLog(
-              "inflateInit returned error: %d, msg: %s\n",
-              inflateResult,
-              client->decompStream.msg);
-      return FALSE;
-    }
-
-    client->decompStreamInited = TRUE;
-
-  }
-
-  inflateResult = Z_OK;
-
-  /* Process buffer full of data until no more to process, or
-   * some type of inflater error, or Z_STREAM_END.
-   */
-  while (( remaining > 0 ) &&
-         ( inflateResult == Z_OK )) {
-  
-    if ( remaining > RFB_BUFFER_SIZE ) {
-      toRead = RFB_BUFFER_SIZE;
-    }
-    else {
-      toRead = remaining;
-    }
-
-    /* Fill the buffer, obtaining data from the server. */
-    if (!ReadFromRFBServer(client, client->buffer,toRead))
-      return FALSE;
-
-    client->decompStream.next_in  = ( Bytef * )client->buffer;
-    client->decompStream.avail_in = toRead;
-
-    /* Need to uncompress buffer full. */
-    inflateResult = inflate( &client->decompStream, Z_SYNC_FLUSH );
-
-    /* We never supply a dictionary for compression. */
-    if ( inflateResult == Z_NEED_DICT ) {
-      rfbClientLog("zlib inflate needs a dictionary!\n");
-      return FALSE;
-    }
-    if ( inflateResult < 0 ) {
-      rfbClientLog(
-              "zlib inflate returned error: %d, msg: %s\n",
-              inflateResult,
-              client->decompStream.msg);
-      return FALSE;
-    }
-
-    /* Result buffer allocated to be at least large enough.  We should
-     * never run out of space!
-     */
-    if (( client->decompStream.avail_in > 0 ) &&
-        ( client->decompStream.avail_out <= 0 )) {
-      rfbClientLog("zlib inflate ran out of space!\n");
-      return FALSE;
-    }
-
-    remaining -= toRead;
-
-  } /* while ( remaining > 0 ) */
-
-  if ( inflateResult == Z_OK ) {
-
-    /* Put the uncompressed contents of the update on the screen. */
-    CopyRectangle(client, (uint8_t *)client->raw_buffer, rx, ry, rw, rh);
-  }
-  else {
-
-    rfbClientLog(
-            "zlib inflate returned error: %d, msg: %s\n",
-            inflateResult,
-            client->decompStream.msg);
-    return FALSE;
-
-  }
-
-  return TRUE;
-}
-
-#undef CARDBPP
-
-#endif
diff -urN remmina-plugins/vnc/libvncserver/libvncclient/zrle.c remmina-plugins/vnc/libvncserver/libvncclient/zrle.c
--- remmina-plugins/vnc/libvncserver/libvncclient/zrle.c	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins/vnc/libvncserver/libvncclient/zrle.c	1970-01-01 10:00:00.000000000 +1000
@@ -1,427 +0,0 @@
-/*
- *  Copyright (C) 2005 Johannes E. Schindelin.  All Rights Reserved.
- *
- *  This is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This software is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this software; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
- *  USA.
- */
-
-#ifdef LIBVNCSERVER_HAVE_LIBZ
-
-/*
- * zrle.c - handle zrle encoding.
- *
- * This file shouldn't be compiled directly.  It is included multiple times by
- * rfbproto.c, each time with a different definition of the macro BPP.  For
- * each value of BPP, this file defines a function which handles an zrle
- * encoded rectangle with BPP bits per pixel.
- */
-
-#ifndef REALBPP
-#define REALBPP BPP
-#endif
-
-#if !defined(UNCOMP) || UNCOMP==0
-#define HandleZRLE CONCAT2E(HandleZRLE,REALBPP)
-#define HandleZRLETile CONCAT2E(HandleZRLETile,REALBPP)
-#elif UNCOMP>0
-#define HandleZRLE CONCAT3E(HandleZRLE,REALBPP,Down)
-#define HandleZRLETile CONCAT3E(HandleZRLETile,REALBPP,Down)
-#else
-#define HandleZRLE CONCAT3E(HandleZRLE,REALBPP,Up)
-#define HandleZRLETile CONCAT3E(HandleZRLETile,REALBPP,Up)
-#endif
-#define CARDBPP CONCAT3E(uint,BPP,_t)
-#define CARDREALBPP CONCAT3E(uint,REALBPP,_t)
-
-#define ENDIAN_LITTLE 0
-#define ENDIAN_BIG 1
-#define ENDIAN_NO 2
-#define ZYWRLE_ENDIAN ENDIAN_LITTLE
-#undef END_FIX
-#if ZYWRLE_ENDIAN == ENDIAN_LITTLE
-#  define END_FIX LE
-#elif ZYWRLE_ENDIAN == ENDIAN_BIG
-#  define END_FIX BE
-#else
-#  define END_FIX NE
-#endif
-#define __RFB_CONCAT3E(a,b,c) CONCAT3E(a,b,c)
-#define __RFB_CONCAT2E(a,b) CONCAT2E(a,b)
-#undef CPIXEL
-#if REALBPP != BPP
-#if UNCOMP == 0
-#define CPIXEL REALBPP
-#elif UNCOMP>0
-#define CPIXEL CONCAT2E(REALBPP,Down)
-#else
-#define CPIXEL CONCAT2E(REALBPP,Up)
-#endif
-#endif
-#define PIXEL_T __RFB_CONCAT3E(uint,BPP,_t)
-#if BPP!=8
-#define ZYWRLE_DECODE 1
-#include "zywrletemplate.c"
-#endif
-#undef CPIXEL
-
-static int HandleZRLETile(rfbClient* client,
-	uint8_t* buffer,size_t buffer_length,
-	int x,int y,int w,int h);
-
-static rfbBool
-HandleZRLE (rfbClient* client, int rx, int ry, int rw, int rh)
-{
-	rfbZRLEHeader header;
-	int remaining;
-	int inflateResult;
-	int toRead;
-	int min_buffer_size = rw * rh * (REALBPP / 8) * 2;
-
-	/* First make sure we have a large enough raw buffer to hold the
-	 * decompressed data.  In practice, with a fixed REALBPP, fixed frame
-	 * buffer size and the first update containing the entire frame
-	 * buffer, this buffer allocation should only happen once, on the
-	 * first update.
-	 */
-	if ( client->raw_buffer_size < min_buffer_size) {
-
-		if ( client->raw_buffer != NULL ) {
-
-			free( client->raw_buffer );
-
-		}
-
-		client->raw_buffer_size = min_buffer_size;
-		client->raw_buffer = (char*) malloc( client->raw_buffer_size );
-
-	}
-
-	if (!ReadFromRFBServer(client, (char *)&header, sz_rfbZRLEHeader))
-		return FALSE;
-
-	remaining = rfbClientSwap32IfLE(header.length);
-
-	/* Need to initialize the decompressor state. */
-	client->decompStream.next_in   = ( Bytef * )client->buffer;
-	client->decompStream.avail_in  = 0;
-	client->decompStream.next_out  = ( Bytef * )client->raw_buffer;
-	client->decompStream.avail_out = client->raw_buffer_size;
-	client->decompStream.data_type = Z_BINARY;
-
-	/* Initialize the decompression stream structures on the first invocation. */
-	if ( client->decompStreamInited == FALSE ) {
-
-		inflateResult = inflateInit( &client->decompStream );
-
-		if ( inflateResult != Z_OK ) {
-			rfbClientLog(
-					"inflateInit returned error: %d, msg: %s\n",
-					inflateResult,
-					client->decompStream.msg);
-			return FALSE;
-		}
-
-		client->decompStreamInited = TRUE;
-
-	}
-
-	inflateResult = Z_OK;
-
-	/* Process buffer full of data until no more to process, or
-	 * some type of inflater error, or Z_STREAM_END.
-	 */
-	while (( remaining > 0 ) &&
-			( inflateResult == Z_OK )) {
-
-		if ( remaining > RFB_BUFFER_SIZE ) {
-			toRead = RFB_BUFFER_SIZE;
-		}
-		else {
-			toRead = remaining;
-		}
-
-		/* Fill the buffer, obtaining data from the server. */
-		if (!ReadFromRFBServer(client, client->buffer,toRead))
-			return FALSE;
-
-		client->decompStream.next_in  = ( Bytef * )client->buffer;
-		client->decompStream.avail_in = toRead;
-
-		/* Need to uncompress buffer full. */
-		inflateResult = inflate( &client->decompStream, Z_SYNC_FLUSH );
-
-		/* We never supply a dictionary for compression. */
-		if ( inflateResult == Z_NEED_DICT ) {
-			rfbClientLog("zlib inflate needs a dictionary!\n");
-			return FALSE;
-		}
-		if ( inflateResult < 0 ) {
-			rfbClientLog(
-					"zlib inflate returned error: %d, msg: %s\n",
-					inflateResult,
-					client->decompStream.msg);
-			return FALSE;
-		}
-
-		/* Result buffer allocated to be at least large enough.  We should
-		 * never run out of space!
-		 */
-		if (( client->decompStream.avail_in > 0 ) &&
-				( client->decompStream.avail_out <= 0 )) {
-			rfbClientLog("zlib inflate ran out of space!\n");
-			return FALSE;
-		}
-
-		remaining -= toRead;
-
-	} /* while ( remaining > 0 ) */
-
-	if ( inflateResult == Z_OK ) {
-		void* buf=client->raw_buffer;
-		int i,j;
-
-		remaining = client->raw_buffer_size-client->decompStream.avail_out;
-
-		for(j=0; j<rh; j+=rfbZRLETileHeight)
-			for(i=0; i<rw; i+=rfbZRLETileWidth) {
-				int subWidth=(i+rfbZRLETileWidth>rw)?rw-i:rfbZRLETileWidth;
-				int subHeight=(j+rfbZRLETileHeight>rh)?rh-j:rfbZRLETileHeight;
-				int result=HandleZRLETile(client,buf,remaining,rx+i,ry+j,subWidth,subHeight);
-
-				if(result<0) {
-					rfbClientLog("ZRLE decoding failed (%d)\n",result);
-return TRUE;
-					return FALSE;
-				}
-
-				buf+=result;
-				remaining-=result;
-			}
-	}
-	else {
-
-		rfbClientLog(
-				"zlib inflate returned error: %d, msg: %s\n",
-				inflateResult,
-				client->decompStream.msg);
-		return FALSE;
-
-	}
-
-	return TRUE;
-}
-
-#if REALBPP!=BPP && defined(UNCOMP) && UNCOMP!=0
-#if UNCOMP>0
-#define UncompressCPixel(pointer) ((*(CARDBPP*)pointer)>>UNCOMP)
-#else
-#define UncompressCPixel(pointer) ((*(CARDBPP*)pointer)<<(-(UNCOMP)))
-#endif
-#else
-#define UncompressCPixel(pointer) (*(CARDBPP*)pointer)
-#endif
-
-static int HandleZRLETile(rfbClient* client,
-		uint8_t* buffer,size_t buffer_length,
-		int x,int y,int w,int h) {
-	uint8_t* buffer_copy = buffer;
-	uint8_t* buffer_end = buffer+buffer_length;
-	uint8_t type;
-#if BPP!=8
-	uint8_t zywrle_level = (client->appData.qualityLevel & 0x80) ?
-		0 : (3 - client->appData.qualityLevel / 3);
-#endif
-
-	if(buffer_length<1)
-		return -2;
-
-	type = *buffer;
-	buffer++;
-	{
-		if( type == 0 ) /* raw */
-#if BPP!=8
-          if( zywrle_level > 0 ){
-			CARDBPP* pFrame = (CARDBPP*)client->frameBuffer + y*client->width+x;
-			int ret;
-			client->appData.qualityLevel |= 0x80;
-			ret = HandleZRLETile(client, buffer, buffer_end-buffer, x, y, w, h);
-		    client->appData.qualityLevel &= 0x7F;
-			if( ret < 0 ){
-				return ret;
-			}
-			ZYWRLE_SYNTHESIZE( pFrame, pFrame, w, h, client->width, zywrle_level, (int*)client->zlib_buffer );
-			buffer += ret;
-		  }else
-#endif
-		{
-#if REALBPP!=BPP
-			int i,j;
-
-			if(1+w*h*REALBPP/8>buffer_length) {
-				rfbClientLog("expected %d bytes, got only %d (%dx%d)\n",1+w*h*REALBPP/8,buffer_length,w,h);
-				return -3;
-			}
-
-			for(j=y*client->width; j<(y+h)*client->width; j+=client->width)
-				for(i=x; i<x+w; i++,buffer+=REALBPP/8)
-					((CARDBPP*)client->frameBuffer)[j+i] = UncompressCPixel(buffer);
-#else
-			CopyRectangle(client, buffer, x, y, w, h);
-			buffer+=w*h*REALBPP/8;
-#endif
-		}
-		else if( type == 1 ) /* solid */
-		{
-			CARDBPP color = UncompressCPixel(buffer);
-
-			if(1+REALBPP/8>buffer_length)
-				return -4;
-				
-			FillRectangle(client, x, y, w, h, color);
-
-			buffer+=REALBPP/8;
-
-		}
-		else if( (type >= 2)&&(type <= 127) ) /* packed Palette */
-		{
-			CARDBPP palette[16];
-			int i,j,shift,
-				bpp=(type>4?(type>16?8:4):(type>2?2:1)),
-				mask=(1<<bpp)-1,
-				divider=(8/bpp);
-
-			if(1+type*REALBPP/8+((w+divider-1)/divider)*h>buffer_length)
-				return -5;
-
-			/* read palette */
-			for(i=0; i<type; i++,buffer+=REALBPP/8)
-				palette[i] = UncompressCPixel(buffer);
-
-			/* read palettized pixels */
-			for(j=y*client->width; j<(y+h)*client->width; j+=client->width) {
-				for(i=x,shift=8-bpp; i<x+w; i++) {
-					((CARDBPP*)client->frameBuffer)[j+i] = palette[((*buffer)>>shift)&mask];
-					shift-=bpp;
-					if(shift<0) {
-						shift=8-bpp;
-						buffer++;
-					}
-				}
-				if(shift<8-bpp)
-					buffer++;
-			}
-
-		}
-		/* case 17 ... 127: not used, but valid */
-		else if( type == 128 ) /* plain RLE */
-		{
-			int i=0,j=0;
-			while(j<h) {
-				int color,length;
-				/* read color */
-				if(buffer+REALBPP/8+1>buffer_end)
-					return -7;
-				color = UncompressCPixel(buffer);
-				buffer+=REALBPP/8;
-				/* read run length */
-				length=1;
-				while(*buffer==0xff) {
-					if(buffer+1>=buffer_end)
-						return -8;
-					length+=*buffer;
-					buffer++;
-				}
-				length+=*buffer;
-				buffer++;
-				while(j<h && length>0) {
-					((CARDBPP*)client->frameBuffer)[(y+j)*client->width+x+i] = color;
-					length--;
-					i++;
-					if(i>=w) {
-						i=0;
-						j++;
-					}
-				}
-				if(length>0)
-					rfbClientLog("Warning: possible ZRLE corruption\n");
-			}
-
-		}
-		else if( type == 129 ) /* unused */
-		{
-			return -8;
-		}
-		else if( type >= 130 ) /* palette RLE */
-		{
-			CARDBPP palette[128];
-			int i,j;
-
-			if(2+(type-128)*REALBPP/8>buffer_length)
-				return -9;
-
-			/* read palette */
-			for(i=0; i<type-128; i++,buffer+=REALBPP/8)
-				palette[i] = UncompressCPixel(buffer);
-			/* read palettized pixels */
-			i=j=0;
-			while(j<h) {
-				int color,length;
-				/* read color */
-				if(buffer>=buffer_end)
-					return -10;
-				color = palette[(*buffer)&0x7f];
-				length=1;
-				if(*buffer&0x80) {
-					if(buffer+1>=buffer_end)
-						return -11;
-					buffer++;
-					/* read run length */
-					while(*buffer==0xff) {
-						if(buffer+1>=buffer_end)
-							return -8;
-						length+=*buffer;
-						buffer++;
-					}
-					length+=*buffer;
-				}
-				buffer++;
-				while(j<h && length>0) {
-					((CARDBPP*)client->frameBuffer)[(y+j)*client->width+x+i] = color;
-					length--;
-					i++;
-					if(i>=w) {
-						i=0;
-						j++;
-					}
-				}
-				if(length>0)
-					rfbClientLog("Warning: possible ZRLE corruption\n");
-			}
-		}
-	}
-
-	return buffer-buffer_copy;	
-}
-
-#undef CARDBPP
-#undef CARDREALBPP
-#undef HandleZRLE
-#undef HandleZRLETile
-#undef UncompressCPixel
-#undef REALBPP
-
-#endif
-
-#undef UNCOMP
diff -urN remmina-plugins/vnc/libvncserver/libvncclient.pc.in remmina-plugins/vnc/libvncserver/libvncclient.pc.in
--- remmina-plugins/vnc/libvncserver/libvncclient.pc.in	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins/vnc/libvncserver/libvncclient.pc.in	1970-01-01 10:00:00.000000000 +1000
@@ -1,12 +0,0 @@
-prefix=@prefix@
-exec_prefix=@exec_prefix@
-libdir=@libdir@
-includedir=@includedir@
-
-Name: LibVNCClient
-Description: A library for easy implementation of a VNC client.
-Version: @VERSION@
-Requires:
-Libs: -L${libdir} -lvncclient @LIBS@ @WSOCKLIB@
-Cflags: -I${includedir}
-
diff -urN remmina-plugins/vnc/libvncserver/rfb/default8x16.h remmina-plugins/vnc/libvncserver/rfb/default8x16.h
--- remmina-plugins/vnc/libvncserver/rfb/default8x16.h	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins/vnc/libvncserver/rfb/default8x16.h	1970-01-01 10:00:00.000000000 +1000
@@ -1,261 +0,0 @@
-static unsigned char default8x16FontData[4096+1]={
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x7e,0x81,0xa5,0x81,0x81,0xbd,0x99,0x81,0x81,0x7e,0x00,0x00,0x00,0x00,
-0x00,0x00,0x7e,0xff,0xdb,0xff,0xff,0xc3,0xe7,0xff,0xff,0x7e,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x6c,0xfe,0xfe,0xfe,0xfe,0x7c,0x38,0x10,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x10,0x38,0x7c,0xfe,0x7c,0x38,0x10,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x18,0x3c,0x3c,0xe7,0xe7,0xe7,0x18,0x18,0x3c,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x18,0x3c,0x7e,0xff,0xff,0x7e,0x18,0x18,0x3c,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x3c,0x3c,0x18,0x00,0x00,0x00,0x00,0x00,0x00,
-0xff,0xff,0xff,0xff,0xff,0xff,0xe7,0xc3,0xc3,0xe7,0xff,0xff,0xff,0xff,0xff,0xff,
-0x00,0x00,0x00,0x00,0x00,0x3c,0x66,0x42,0x42,0x66,0x3c,0x00,0x00,0x00,0x00,0x00,
-0xff,0xff,0xff,0xff,0xff,0xc3,0x99,0xbd,0xbd,0x99,0xc3,0xff,0xff,0xff,0xff,0xff,
-0x00,0x00,0x1e,0x0e,0x1a,0x32,0x78,0xcc,0xcc,0xcc,0xcc,0x78,0x00,0x00,0x00,0x00,
-0x00,0x00,0x3c,0x66,0x66,0x66,0x66,0x3c,0x18,0x7e,0x18,0x18,0x00,0x00,0x00,0x00,
-0x00,0x00,0x3f,0x33,0x3f,0x30,0x30,0x30,0x30,0x70,0xf0,0xe0,0x00,0x00,0x00,0x00,
-0x00,0x00,0x7f,0x63,0x7f,0x63,0x63,0x63,0x63,0x67,0xe7,0xe6,0xc0,0x00,0x00,0x00,
-0x00,0x00,0x00,0x18,0x18,0xdb,0x3c,0xe7,0x3c,0xdb,0x18,0x18,0x00,0x00,0x00,0x00,
-0x00,0x80,0xc0,0xe0,0xf0,0xf8,0xfe,0xf8,0xf0,0xe0,0xc0,0x80,0x00,0x00,0x00,0x00,
-0x00,0x02,0x06,0x0e,0x1e,0x3e,0xfe,0x3e,0x1e,0x0e,0x06,0x02,0x00,0x00,0x00,0x00,
-0x00,0x00,0x18,0x3c,0x7e,0x18,0x18,0x18,0x7e,0x3c,0x18,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x00,0x66,0x66,0x00,0x00,0x00,0x00,
-0x00,0x00,0x7f,0xdb,0xdb,0xdb,0x7b,0x1b,0x1b,0x1b,0x1b,0x1b,0x00,0x00,0x00,0x00,
-0x00,0x7c,0xc6,0x60,0x38,0x6c,0xc6,0xc6,0x6c,0x38,0x0c,0xc6,0x7c,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfe,0xfe,0xfe,0xfe,0x00,0x00,0x00,0x00,
-0x00,0x00,0x18,0x3c,0x7e,0x18,0x18,0x18,0x7e,0x3c,0x18,0x7e,0x00,0x00,0x00,0x00,
-0x00,0x00,0x18,0x3c,0x7e,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00,
-0x00,0x00,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x7e,0x3c,0x18,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x18,0x0c,0xfe,0x0c,0x18,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x30,0x60,0xfe,0x60,0x30,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0xc0,0xc0,0xc0,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x24,0x66,0xff,0x66,0x24,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x10,0x38,0x38,0x7c,0x7c,0xfe,0xfe,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0xfe,0xfe,0x7c,0x7c,0x38,0x38,0x10,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x18,0x3c,0x3c,0x3c,0x18,0x18,0x18,0x00,0x18,0x18,0x00,0x00,0x00,0x00,
-0x00,0x66,0x66,0x66,0x24,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x6c,0x6c,0xfe,0x6c,0x6c,0x6c,0xfe,0x6c,0x6c,0x00,0x00,0x00,0x00,
-0x18,0x18,0x7c,0xc6,0xc2,0xc0,0x7c,0x06,0x06,0x86,0xc6,0x7c,0x18,0x18,0x00,0x00,
-0x00,0x00,0x00,0x00,0xc2,0xc6,0x0c,0x18,0x30,0x60,0xc6,0x86,0x00,0x00,0x00,0x00,
-0x00,0x00,0x38,0x6c,0x6c,0x38,0x76,0xdc,0xcc,0xcc,0xcc,0x76,0x00,0x00,0x00,0x00,
-0x00,0x30,0x30,0x30,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x0c,0x18,0x30,0x30,0x30,0x30,0x30,0x30,0x18,0x0c,0x00,0x00,0x00,0x00,
-0x00,0x00,0x30,0x18,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x18,0x30,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x66,0x3c,0xff,0x3c,0x66,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x7e,0x18,0x18,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x18,0x30,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7e,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x02,0x06,0x0c,0x18,0x30,0x60,0xc0,0x80,0x00,0x00,0x00,0x00,
-0x00,0x00,0x7c,0xc6,0xc6,0xce,0xde,0xf6,0xe6,0xc6,0xc6,0x7c,0x00,0x00,0x00,0x00,
-0x00,0x00,0x18,0x38,0x78,0x18,0x18,0x18,0x18,0x18,0x18,0x7e,0x00,0x00,0x00,0x00,
-0x00,0x00,0x7c,0xc6,0x06,0x0c,0x18,0x30,0x60,0xc0,0xc6,0xfe,0x00,0x00,0x00,0x00,
-0x00,0x00,0x7c,0xc6,0x06,0x06,0x3c,0x06,0x06,0x06,0xc6,0x7c,0x00,0x00,0x00,0x00,
-0x00,0x00,0x0c,0x1c,0x3c,0x6c,0xcc,0xfe,0x0c,0x0c,0x0c,0x1e,0x00,0x00,0x00,0x00,
-0x00,0x00,0xfe,0xc0,0xc0,0xc0,0xfc,0x06,0x06,0x06,0xc6,0x7c,0x00,0x00,0x00,0x00,
-0x00,0x00,0x38,0x60,0xc0,0xc0,0xfc,0xc6,0xc6,0xc6,0xc6,0x7c,0x00,0x00,0x00,0x00,
-0x00,0x00,0xfe,0xc6,0x06,0x06,0x0c,0x18,0x30,0x30,0x30,0x30,0x00,0x00,0x00,0x00,
-0x00,0x00,0x7c,0xc6,0xc6,0xc6,0x7c,0xc6,0xc6,0xc6,0xc6,0x7c,0x00,0x00,0x00,0x00,
-0x00,0x00,0x7c,0xc6,0xc6,0xc6,0x7e,0x06,0x06,0x06,0x0c,0x78,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x30,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x06,0x0c,0x18,0x30,0x60,0x30,0x18,0x0c,0x06,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x7e,0x00,0x00,0x7e,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x60,0x30,0x18,0x0c,0x06,0x0c,0x18,0x30,0x60,0x00,0x00,0x00,0x00,
-0x00,0x00,0x7c,0xc6,0xc6,0x0c,0x18,0x18,0x18,0x00,0x18,0x18,0x00,0x00,0x00,0x00,
-0x00,0x00,0x7c,0xc6,0xc6,0xc6,0xde,0xde,0xde,0xdc,0xc0,0x7c,0x00,0x00,0x00,0x00,
-0x00,0x00,0x10,0x38,0x6c,0xc6,0xc6,0xfe,0xc6,0xc6,0xc6,0xc6,0x00,0x00,0x00,0x00,
-0x00,0x00,0xfc,0x66,0x66,0x66,0x7c,0x66,0x66,0x66,0x66,0xfc,0x00,0x00,0x00,0x00,
-0x00,0x00,0x3c,0x66,0xc2,0xc0,0xc0,0xc0,0xc0,0xc2,0x66,0x3c,0x00,0x00,0x00,0x00,
-0x00,0x00,0xf8,0x6c,0x66,0x66,0x66,0x66,0x66,0x66,0x6c,0xf8,0x00,0x00,0x00,0x00,
-0x00,0x00,0xfe,0x66,0x62,0x68,0x78,0x68,0x60,0x62,0x66,0xfe,0x00,0x00,0x00,0x00,
-0x00,0x00,0xfe,0x66,0x62,0x68,0x78,0x68,0x60,0x60,0x60,0xf0,0x00,0x00,0x00,0x00,
-0x00,0x00,0x3c,0x66,0xc2,0xc0,0xc0,0xde,0xc6,0xc6,0x66,0x3a,0x00,0x00,0x00,0x00,
-0x00,0x00,0xc6,0xc6,0xc6,0xc6,0xfe,0xc6,0xc6,0xc6,0xc6,0xc6,0x00,0x00,0x00,0x00,
-0x00,0x00,0x3c,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x3c,0x00,0x00,0x00,0x00,
-0x00,0x00,0x1e,0x0c,0x0c,0x0c,0x0c,0x0c,0xcc,0xcc,0xcc,0x78,0x00,0x00,0x00,0x00,
-0x00,0x00,0xe6,0x66,0x66,0x6c,0x78,0x78,0x6c,0x66,0x66,0xe6,0x00,0x00,0x00,0x00,
-0x00,0x00,0xf0,0x60,0x60,0x60,0x60,0x60,0x60,0x62,0x66,0xfe,0x00,0x00,0x00,0x00,
-0x00,0x00,0xc3,0xe7,0xff,0xff,0xdb,0xc3,0xc3,0xc3,0xc3,0xc3,0x00,0x00,0x00,0x00,
-0x00,0x00,0xc6,0xe6,0xf6,0xfe,0xde,0xce,0xc6,0xc6,0xc6,0xc6,0x00,0x00,0x00,0x00,
-0x00,0x00,0x7c,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0x7c,0x00,0x00,0x00,0x00,
-0x00,0x00,0xfc,0x66,0x66,0x66,0x7c,0x60,0x60,0x60,0x60,0xf0,0x00,0x00,0x00,0x00,
-0x00,0x00,0x7c,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xd6,0xde,0x7c,0x0c,0x0e,0x00,0x00,
-0x00,0x00,0xfc,0x66,0x66,0x66,0x7c,0x6c,0x66,0x66,0x66,0xe6,0x00,0x00,0x00,0x00,
-0x00,0x00,0x7c,0xc6,0xc6,0x60,0x38,0x0c,0x06,0xc6,0xc6,0x7c,0x00,0x00,0x00,0x00,
-0x00,0x00,0xff,0xdb,0x99,0x18,0x18,0x18,0x18,0x18,0x18,0x3c,0x00,0x00,0x00,0x00,
-0x00,0x00,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0x7c,0x00,0x00,0x00,0x00,
-0x00,0x00,0xc3,0xc3,0xc3,0xc3,0xc3,0xc3,0xc3,0x66,0x3c,0x18,0x00,0x00,0x00,0x00,
-0x00,0x00,0xc3,0xc3,0xc3,0xc3,0xc3,0xdb,0xdb,0xff,0x66,0x66,0x00,0x00,0x00,0x00,
-0x00,0x00,0xc3,0xc3,0x66,0x3c,0x18,0x18,0x3c,0x66,0xc3,0xc3,0x00,0x00,0x00,0x00,
-0x00,0x00,0xc3,0xc3,0xc3,0x66,0x3c,0x18,0x18,0x18,0x18,0x3c,0x00,0x00,0x00,0x00,
-0x00,0x00,0xff,0xc3,0x86,0x0c,0x18,0x30,0x60,0xc1,0xc3,0xff,0x00,0x00,0x00,0x00,
-0x00,0x00,0x3c,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x3c,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x80,0xc0,0xe0,0x70,0x38,0x1c,0x0e,0x06,0x02,0x00,0x00,0x00,0x00,
-0x00,0x00,0x3c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x3c,0x00,0x00,0x00,0x00,
-0x10,0x38,0x6c,0xc6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x00,0x00,
-0x30,0x30,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x78,0x0c,0x7c,0xcc,0xcc,0xcc,0x76,0x00,0x00,0x00,0x00,
-0x00,0x00,0xe0,0x60,0x60,0x78,0x6c,0x66,0x66,0x66,0x66,0x7c,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x7c,0xc6,0xc0,0xc0,0xc0,0xc6,0x7c,0x00,0x00,0x00,0x00,
-0x00,0x00,0x1c,0x0c,0x0c,0x3c,0x6c,0xcc,0xcc,0xcc,0xcc,0x76,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x7c,0xc6,0xfe,0xc0,0xc0,0xc6,0x7c,0x00,0x00,0x00,0x00,
-0x00,0x00,0x38,0x6c,0x64,0x60,0xf0,0x60,0x60,0x60,0x60,0xf0,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x76,0xcc,0xcc,0xcc,0xcc,0xcc,0x7c,0x0c,0xcc,0x78,0x00,
-0x00,0x00,0xe0,0x60,0x60,0x6c,0x76,0x66,0x66,0x66,0x66,0xe6,0x00,0x00,0x00,0x00,
-0x00,0x00,0x18,0x18,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x3c,0x00,0x00,0x00,0x00,
-0x00,0x00,0x06,0x06,0x00,0x0e,0x06,0x06,0x06,0x06,0x06,0x06,0x66,0x66,0x3c,0x00,
-0x00,0x00,0xe0,0x60,0x60,0x66,0x6c,0x78,0x78,0x6c,0x66,0xe6,0x00,0x00,0x00,0x00,
-0x00,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x3c,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0xe6,0xff,0xdb,0xdb,0xdb,0xdb,0xdb,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0xdc,0x66,0x66,0x66,0x66,0x66,0x66,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x7c,0xc6,0xc6,0xc6,0xc6,0xc6,0x7c,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0xdc,0x66,0x66,0x66,0x66,0x66,0x7c,0x60,0x60,0xf0,0x00,
-0x00,0x00,0x00,0x00,0x00,0x76,0xcc,0xcc,0xcc,0xcc,0xcc,0x7c,0x0c,0x0c,0x1e,0x00,
-0x00,0x00,0x00,0x00,0x00,0xdc,0x76,0x66,0x60,0x60,0x60,0xf0,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x7c,0xc6,0x60,0x38,0x0c,0xc6,0x7c,0x00,0x00,0x00,0x00,
-0x00,0x00,0x10,0x30,0x30,0xfc,0x30,0x30,0x30,0x30,0x36,0x1c,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,0x76,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0xc3,0xc3,0xc3,0xc3,0x66,0x3c,0x18,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0xc3,0xc3,0xc3,0xdb,0xdb,0xff,0x66,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0xc3,0x66,0x3c,0x18,0x3c,0x66,0xc3,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0x7e,0x06,0x0c,0xf8,0x00,
-0x00,0x00,0x00,0x00,0x00,0xfe,0xcc,0x18,0x30,0x60,0xc6,0xfe,0x00,0x00,0x00,0x00,
-0x00,0x00,0x0e,0x18,0x18,0x18,0x70,0x18,0x18,0x18,0x18,0x0e,0x00,0x00,0x00,0x00,
-0x00,0x00,0x18,0x18,0x18,0x18,0x00,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00,
-0x00,0x00,0x70,0x18,0x18,0x18,0x0e,0x18,0x18,0x18,0x18,0x70,0x00,0x00,0x00,0x00,
-0x00,0x00,0x76,0xdc,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x10,0x38,0x6c,0xc6,0xc6,0xc6,0xfe,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x3c,0x66,0xc2,0xc0,0xc0,0xc0,0xc2,0x66,0x3c,0x0c,0x06,0x7c,0x00,0x00,
-0x00,0x00,0xcc,0x00,0x00,0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,0x76,0x00,0x00,0x00,0x00,
-0x00,0x0c,0x18,0x30,0x00,0x7c,0xc6,0xfe,0xc0,0xc0,0xc6,0x7c,0x00,0x00,0x00,0x00,
-0x00,0x10,0x38,0x6c,0x00,0x78,0x0c,0x7c,0xcc,0xcc,0xcc,0x76,0x00,0x00,0x00,0x00,
-0x00,0x00,0xcc,0x00,0x00,0x78,0x0c,0x7c,0xcc,0xcc,0xcc,0x76,0x00,0x00,0x00,0x00,
-0x00,0x60,0x30,0x18,0x00,0x78,0x0c,0x7c,0xcc,0xcc,0xcc,0x76,0x00,0x00,0x00,0x00,
-0x00,0x38,0x6c,0x38,0x00,0x78,0x0c,0x7c,0xcc,0xcc,0xcc,0x76,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x3c,0x66,0x60,0x60,0x66,0x3c,0x0c,0x06,0x3c,0x00,0x00,0x00,
-0x00,0x10,0x38,0x6c,0x00,0x7c,0xc6,0xfe,0xc0,0xc0,0xc6,0x7c,0x00,0x00,0x00,0x00,
-0x00,0x00,0xc6,0x00,0x00,0x7c,0xc6,0xfe,0xc0,0xc0,0xc6,0x7c,0x00,0x00,0x00,0x00,
-0x00,0x60,0x30,0x18,0x00,0x7c,0xc6,0xfe,0xc0,0xc0,0xc6,0x7c,0x00,0x00,0x00,0x00,
-0x00,0x00,0x66,0x00,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x3c,0x00,0x00,0x00,0x00,
-0x00,0x18,0x3c,0x66,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x3c,0x00,0x00,0x00,0x00,
-0x00,0x60,0x30,0x18,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x3c,0x00,0x00,0x00,0x00,
-0x00,0xc6,0x00,0x10,0x38,0x6c,0xc6,0xc6,0xfe,0xc6,0xc6,0xc6,0x00,0x00,0x00,0x00,
-0x38,0x6c,0x38,0x00,0x38,0x6c,0xc6,0xc6,0xfe,0xc6,0xc6,0xc6,0x00,0x00,0x00,0x00,
-0x18,0x30,0x60,0x00,0xfe,0x66,0x60,0x7c,0x60,0x60,0x66,0xfe,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x6e,0x3b,0x1b,0x7e,0xd8,0xdc,0x77,0x00,0x00,0x00,0x00,
-0x00,0x00,0x3e,0x6c,0xcc,0xcc,0xfe,0xcc,0xcc,0xcc,0xcc,0xce,0x00,0x00,0x00,0x00,
-0x00,0x10,0x38,0x6c,0x00,0x7c,0xc6,0xc6,0xc6,0xc6,0xc6,0x7c,0x00,0x00,0x00,0x00,
-0x00,0x00,0xc6,0x00,0x00,0x7c,0xc6,0xc6,0xc6,0xc6,0xc6,0x7c,0x00,0x00,0x00,0x00,
-0x00,0x60,0x30,0x18,0x00,0x7c,0xc6,0xc6,0xc6,0xc6,0xc6,0x7c,0x00,0x00,0x00,0x00,
-0x00,0x30,0x78,0xcc,0x00,0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,0x76,0x00,0x00,0x00,0x00,
-0x00,0x60,0x30,0x18,0x00,0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,0x76,0x00,0x00,0x00,0x00,
-0x00,0x00,0xc6,0x00,0x00,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0x7e,0x06,0x0c,0x78,0x00,
-0x00,0xc6,0x00,0x7c,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0x7c,0x00,0x00,0x00,0x00,
-0x00,0xc6,0x00,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0x7c,0x00,0x00,0x00,0x00,
-0x00,0x18,0x18,0x7e,0xc3,0xc0,0xc0,0xc0,0xc3,0x7e,0x18,0x18,0x00,0x00,0x00,0x00,
-0x00,0x38,0x6c,0x64,0x60,0xf0,0x60,0x60,0x60,0x60,0xe6,0xfc,0x00,0x00,0x00,0x00,
-0x00,0x00,0xc3,0x66,0x3c,0x18,0xff,0x18,0xff,0x18,0x18,0x18,0x00,0x00,0x00,0x00,
-0x00,0xfc,0x66,0x66,0x7c,0x62,0x66,0x6f,0x66,0x66,0x66,0xf3,0x00,0x00,0x00,0x00,
-0x00,0x0e,0x1b,0x18,0x18,0x18,0x7e,0x18,0x18,0x18,0x18,0x18,0xd8,0x70,0x00,0x00,
-0x00,0x18,0x30,0x60,0x00,0x78,0x0c,0x7c,0xcc,0xcc,0xcc,0x76,0x00,0x00,0x00,0x00,
-0x00,0x0c,0x18,0x30,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x3c,0x00,0x00,0x00,0x00,
-0x00,0x18,0x30,0x60,0x00,0x7c,0xc6,0xc6,0xc6,0xc6,0xc6,0x7c,0x00,0x00,0x00,0x00,
-0x00,0x18,0x30,0x60,0x00,0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,0x76,0x00,0x00,0x00,0x00,
-0x00,0x00,0x76,0xdc,0x00,0xdc,0x66,0x66,0x66,0x66,0x66,0x66,0x00,0x00,0x00,0x00,
-0x76,0xdc,0x00,0xc6,0xe6,0xf6,0xfe,0xde,0xce,0xc6,0xc6,0xc6,0x00,0x00,0x00,0x00,
-0x00,0x3c,0x6c,0x6c,0x3e,0x00,0x7e,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x38,0x6c,0x6c,0x38,0x00,0x7c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x30,0x30,0x00,0x30,0x30,0x60,0xc0,0xc6,0xc6,0x7c,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0xfe,0xc0,0xc0,0xc0,0xc0,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0xfe,0x06,0x06,0x06,0x06,0x00,0x00,0x00,0x00,0x00,
-0x00,0xc0,0xc0,0xc2,0xc6,0xcc,0x18,0x30,0x60,0xce,0x9b,0x06,0x0c,0x1f,0x00,0x00,
-0x00,0xc0,0xc0,0xc2,0xc6,0xcc,0x18,0x30,0x66,0xce,0x96,0x3e,0x06,0x06,0x00,0x00,
-0x00,0x00,0x18,0x18,0x00,0x18,0x18,0x18,0x3c,0x3c,0x3c,0x18,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x36,0x6c,0xd8,0x6c,0x36,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0xd8,0x6c,0x36,0x6c,0xd8,0x00,0x00,0x00,0x00,0x00,0x00,
-0x11,0x44,0x11,0x44,0x11,0x44,0x11,0x44,0x11,0x44,0x11,0x44,0x11,0x44,0x11,0x44,
-0x55,0xaa,0x55,0xaa,0x55,0xaa,0x55,0xaa,0x55,0xaa,0x55,0xaa,0x55,0xaa,0x55,0xaa,
-0xdd,0x77,0xdd,0x77,0xdd,0x77,0xdd,0x77,0xdd,0x77,0xdd,0x77,0xdd,0x77,0xdd,0x77,
-0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
-0x18,0x18,0x18,0x18,0x18,0x18,0x18,0xf8,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
-0x18,0x18,0x18,0x18,0x18,0xf8,0x18,0xf8,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
-0x36,0x36,0x36,0x36,0x36,0x36,0x36,0xf6,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfe,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
-0x00,0x00,0x00,0x00,0x00,0xf8,0x18,0xf8,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
-0x36,0x36,0x36,0x36,0x36,0xf6,0x06,0xf6,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
-0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
-0x00,0x00,0x00,0x00,0x00,0xfe,0x06,0xf6,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
-0x36,0x36,0x36,0x36,0x36,0xf6,0x06,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x36,0x36,0x36,0x36,0x36,0x36,0x36,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x18,0x18,0x18,0x18,0x18,0xf8,0x18,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf8,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
-0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x1f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x18,0x18,0x18,0x18,0x18,0x18,0x18,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
-0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x1f,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x18,0x18,0x18,0x18,0x18,0x18,0x18,0xff,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
-0x18,0x18,0x18,0x18,0x18,0x1f,0x18,0x1f,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
-0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x37,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
-0x36,0x36,0x36,0x36,0x36,0x37,0x30,0x3f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x3f,0x30,0x37,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
-0x36,0x36,0x36,0x36,0x36,0xf7,0x00,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0xff,0x00,0xf7,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
-0x36,0x36,0x36,0x36,0x36,0x37,0x30,0x37,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
-0x00,0x00,0x00,0x00,0x00,0xff,0x00,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x36,0x36,0x36,0x36,0x36,0xf7,0x00,0xf7,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
-0x18,0x18,0x18,0x18,0x18,0xff,0x00,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x36,0x36,0x36,0x36,0x36,0x36,0x36,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0xff,0x00,0xff,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
-0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x3f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x18,0x18,0x18,0x18,0x18,0x1f,0x18,0x1f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x1f,0x18,0x1f,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3f,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
-0x36,0x36,0x36,0x36,0x36,0x36,0x36,0xff,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
-0x18,0x18,0x18,0x18,0x18,0xff,0x18,0xff,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
-0x18,0x18,0x18,0x18,0x18,0x18,0x18,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1f,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
-0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
-0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,
-0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,
-0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x76,0xdc,0xd8,0xd8,0xd8,0xdc,0x76,0x00,0x00,0x00,0x00,
-0x00,0x00,0x78,0xcc,0xcc,0xcc,0xd8,0xcc,0xc6,0xc6,0xc6,0xcc,0x00,0x00,0x00,0x00,
-0x00,0x00,0xfe,0xc6,0xc6,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0xfe,0x6c,0x6c,0x6c,0x6c,0x6c,0x6c,0x6c,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0xfe,0xc6,0x60,0x30,0x18,0x30,0x60,0xc6,0xfe,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x7e,0xd8,0xd8,0xd8,0xd8,0xd8,0x70,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x66,0x66,0x66,0x66,0x66,0x7c,0x60,0x60,0xc0,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x76,0xdc,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x7e,0x18,0x3c,0x66,0x66,0x66,0x3c,0x18,0x7e,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x38,0x6c,0xc6,0xc6,0xfe,0xc6,0xc6,0x6c,0x38,0x00,0x00,0x00,0x00,
-0x00,0x00,0x38,0x6c,0xc6,0xc6,0xc6,0x6c,0x6c,0x6c,0x6c,0xee,0x00,0x00,0x00,0x00,
-0x00,0x00,0x1e,0x30,0x18,0x0c,0x3e,0x66,0x66,0x66,0x66,0x3c,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x7e,0xdb,0xdb,0xdb,0x7e,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x03,0x06,0x7e,0xdb,0xdb,0xf3,0x7e,0x60,0xc0,0x00,0x00,0x00,0x00,
-0x00,0x00,0x1c,0x30,0x60,0x60,0x7c,0x60,0x60,0x60,0x30,0x1c,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x7c,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0xfe,0x00,0x00,0xfe,0x00,0x00,0xfe,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x18,0x18,0x7e,0x18,0x18,0x00,0x00,0xff,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x30,0x18,0x0c,0x06,0x0c,0x18,0x30,0x00,0x7e,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x0c,0x18,0x30,0x60,0x30,0x18,0x0c,0x00,0x7e,0x00,0x00,0x00,0x00,
-0x00,0x00,0x0e,0x1b,0x1b,0x1b,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
-0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0xd8,0xd8,0xd8,0x70,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x7e,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x76,0xdc,0x00,0x76,0xdc,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x38,0x6c,0x6c,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x0f,0x0c,0x0c,0x0c,0x0c,0x0c,0xec,0x6c,0x6c,0x3c,0x1c,0x00,0x00,0x00,0x00,
-0x00,0xd8,0x6c,0x6c,0x6c,0x6c,0x6c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x70,0xd8,0x30,0x60,0xc8,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x7c,0x7c,0x7c,0x7c,0x7c,0x7c,0x7c,0x00,0x00,0x00,0x00,0x00,
-0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-};
-static int default8x16FontMetaData[256*5+1]={
-0,8,16,0,0,16,8,16,0,0,32,8,16,0,0,48,8,16,0,0,64,8,16,0,0,80,8,16,0,0,96,8,16,0,0,112,8,16,0,0,128,8,16,0,0,144,8,16,0,0,160,8,16,0,0,176,8,16,0,0,192,8,16,0,0,208,8,16,0,0,224,8,16,0,0,240,8,16,0,0,256,8,16,0,0,272,8,16,0,0,288,8,16,0,0,304,8,16,0,0,320,8,16,0,0,336,8,16,0,0,352,8,16,0,0,368,8,16,0,0,384,8,16,0,0,400,8,16,0,0,416,8,16,0,0,432,8,16,0,0,448,8,16,0,0,464,8,16,0,0,480,8,16,0,0,496,8,16,0,0,512,8,16,0,0,528,8,16,0,0,544,8,16,0,0,560,8,16,0,0,576,8,16,0,0,592,8,16,0,0,608,8,16,0,0,624,8,16,0,0,640,8,16,0,0,656,8,16,0,0,672,8,16,0,0,688,8,16,0,0,704,8,16,0,0,720,8,16,0,0,736,8,16,0,0,752,8,16,0,0,768,8,16,0,0,784,8,16,0,0,800,8,16,0,0,816,8,16,0,0,832,8,16,0,0,848,8,16,0,0,864,8,16,0,0,880,8,16,0,0,896,8,16,0,0,912,8,16,0,0,928,8,16,0,0,944,8,16,0,0,960,8,16,0,0,976,8,16,0,0,992,8,16,0,0,1008,8,16,0,0,1024,8,16,0,0,1040,8,16,0,0,1056,8,16,0,0,1072,8,16,0,0,1088,8,16,0,0,1104,8,16,0,0,1120,8,16,0,0,1136,8,16,0,0,1152,8,16,0,0,1168,8,16,0,0,1184,8,16,0,0,1200,8,16,0,0,1216,8,16,0,0,1232,8,16,0,0,1248,8,16,0,0,1264,8,16,0,0,1280,8,16,0,0,1296,8,16,0,0,1312,8,16,0,0,1328,8,16,0,0,1344,8,16,0,0,1360,8,16,0,0,1376,8,16,0,0,1392,8,16,0,0,1408,8,16,0,0,1424,8,16,0,0,1440,8,16,0,0,1456,8,16,0,0,1472,8,16,0,0,1488,8,16,0,0,1504,8,16,0,0,1520,8,16,0,0,1536,8,16,0,0,1552,8,16,0,0,1568,8,16,0,0,1584,8,16,0,0,1600,8,16,0,0,1616,8,16,0,0,1632,8,16,0,0,1648,8,16,0,0,1664,8,16,0,0,1680,8,16,0,0,1696,8,16,0,0,1712,8,16,0,0,1728,8,16,0,0,1744,8,16,0,0,1760,8,16,0,0,1776,8,16,0,0,1792,8,16,0,0,1808,8,16,0,0,1824,8,16,0,0,1840,8,16,0,0,1856,8,16,0,0,1872,8,16,0,0,1888,8,16,0,0,1904,8,16,0,0,1920,8,16,0,0,1936,8,16,0,0,1952,8,16,0,0,1968,8,16,0,0,1984,8,16,0,0,2000,8,16,0,0,2016,8,16,0,0,2032,8,16,0,0,2048,8,16,0,0,2064,8,16,0,0,2080,8,16,0,0,2096,8,16,0,0,2112,8,16,0,0,2128,8,16,0,0,2144,8,16,0,0,2160,8,16,0,0,2176,8,16,0,0,2192,8,16,0,0,2208,8,16,0,0,2224,8,16,0,0,2240,8,16,0,0,2256,8,16,0,0,2272,8,16,0,0,2288,8,16,0,0,2304,8,16,0,0,2320,8,16,0,0,2336,8,16,0,0,2352,8,16,0,0,2368,8,16,0,0,2384,8,16,0,0,2400,8,16,0,0,2416,8,16,0,0,2432,8,16,0,0,2448,8,16,0,0,2464,8,16,0,0,2480,8,16,0,0,2496,8,16,0,0,2512,8,16,0,0,2528,8,16,0,0,2544,8,16,0,0,2560,8,16,0,0,2576,8,16,0,0,2592,8,16,0,0,2608,8,16,0,0,2624,8,16,0,0,2640,8,16,0,0,2656,8,16,0,0,2672,8,16,0,0,2688,8,16,0,0,2704,8,16,0,0,2720,8,16,0,0,2736,8,16,0,0,2752,8,16,0,0,2768,8,16,0,0,2784,8,16,0,0,2800,8,16,0,0,2816,8,16,0,0,2832,8,16,0,0,2848,8,16,0,0,2864,8,16,0,0,2880,8,16,0,0,2896,8,16,0,0,2912,8,16,0,0,2928,8,16,0,0,2944,8,16,0,0,2960,8,16,0,0,2976,8,16,0,0,2992,8,16,0,0,3008,8,16,0,0,3024,8,16,0,0,3040,8,16,0,0,3056,8,16,0,0,3072,8,16,0,0,3088,8,16,0,0,3104,8,16,0,0,3120,8,16,0,0,3136,8,16,0,0,3152,8,16,0,0,3168,8,16,0,0,3184,8,16,0,0,3200,8,16,0,0,3216,8,16,0,0,3232,8,16,0,0,3248,8,16,0,0,3264,8,16,0,0,3280,8,16,0,0,3296,8,16,0,0,3312,8,16,0,0,3328,8,16,0,0,3344,8,16,0,0,3360,8,16,0,0,3376,8,16,0,0,3392,8,16,0,0,3408,8,16,0,0,3424,8,16,0,0,3440,8,16,0,0,3456,8,16,0,0,3472,8,16,0,0,3488,8,16,0,0,3504,8,16,0,0,3520,8,16,0,0,3536,8,16,0,0,3552,8,16,0,0,3568,8,16,0,0,3584,8,16,0,0,3600,8,16,0,0,3616,8,16,0,0,3632,8,16,0,0,3648,8,16,0,0,3664,8,16,0,0,3680,8,16,0,0,3696,8,16,0,0,3712,8,16,0,0,3728,8,16,0,0,3744,8,16,0,0,3760,8,16,0,0,3776,8,16,0,0,3792,8,16,0,0,3808,8,16,0,0,3824,8,16,0,0,3840,8,16,0,0,3856,8,16,0,0,3872,8,16,0,0,3888,8,16,0,0,3904,8,16,0,0,3920,8,16,0,0,3936,8,16,0,0,3952,8,16,0,0,3968,8,16,0,0,3984,8,16,0,0,4000,8,16,0,0,4016,8,16,0,0,4032,8,16,0,0,4048,8,16,0,0,4064,8,16,0,0,4080,8,16,0,0,};
-static rfbFontData default8x16Font = { default8x16FontData, default8x16FontMetaData };
diff -urN remmina-plugins/vnc/libvncserver/rfb/keysym.h remmina-plugins/vnc/libvncserver/rfb/keysym.h
--- remmina-plugins/vnc/libvncserver/rfb/keysym.h	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins/vnc/libvncserver/rfb/keysym.h	1970-01-01 10:00:00.000000000 +1000
@@ -1,1638 +0,0 @@
-#ifndef XK_0
-
-/* $XConsortium: keysym.h,v 1.15 94/04/17 20:10:55 rws Exp $ */
-
-/***********************************************************
-
-Copyright (c) 1987  X Consortium
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in
-all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
-X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
-CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-
-Except as contained in this notice, the name of the X Consortium shall not be
-used in advertising or otherwise to promote the sale, use or other dealings
-in this Software without prior written authorization from the X Consortium.
-
-
-Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
-
-                        All Rights Reserved
-
-Permission to use, copy, modify, and distribute this software and its 
-documentation for any purpose and without fee is hereby granted, 
-provided that the above copyright notice appear in all copies and that
-both that copyright notice and this permission notice appear in 
-supporting documentation, and that the name of Digital not be
-used in advertising or publicity pertaining to distribution of the
-software without specific, written prior permission.  
-
-DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
-ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
-DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
-ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
-WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
-ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-SOFTWARE.
-
-******************************************************************/
-
-/* default keysyms */
-#define XK_MISCELLANY
-#define XK_XKB_KEYS
-#define XK_LATIN1
-#define XK_LATIN2
-#define XK_LATIN3
-#define XK_LATIN4
-#define XK_GREEK
-
-/* $TOG: keysymdef.h /main/25 1997/06/21 10:54:51 kaleb $ */
-
-/***********************************************************
-Copyright (c) 1987, 1994  X Consortium
-
-Permission is hereby granted, free of charge, to any person obtaining
-a copy of this software and associated documentation files (the
-"Software"), to deal in the Software without restriction, including
-without limitation the rights to use, copy, modify, merge, publish,
-distribute, sublicense, and/or sell copies of the Software, and to
-permit persons to whom the Software is furnished to do so, subject to
-the following conditions:
-
-The above copyright notice and this permission notice shall be included
-in all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
-OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-IN NO EVENT SHALL THE X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR
-OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
-ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
-OTHER DEALINGS IN THE SOFTWARE.
-
-Except as contained in this notice, the name of the X Consortium shall
-not be used in advertising or otherwise to promote the sale, use or
-other dealings in this Software without prior written authorization
-from the X Consortium.
-
-
-Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts
-
-                        All Rights Reserved
-
-Permission to use, copy, modify, and distribute this software and its
-documentation for any purpose and without fee is hereby granted,
-provided that the above copyright notice appear in all copies and that
-both that copyright notice and this permission notice appear in
-supporting documentation, and that the name of Digital not be
-used in advertising or publicity pertaining to distribution of the
-software without specific, written prior permission.
-
-DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
-ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
-DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
-ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
-WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
-ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
-SOFTWARE.
-
-******************************************************************/
-
-#define XK_VoidSymbol		0xFFFFFF	/* void symbol */
-
-#ifdef XK_MISCELLANY
-/*
- * TTY Functions, cleverly chosen to map to ascii, for convenience of
- * programming, but could have been arbitrary (at the cost of lookup
- * tables in client code.
- */
-
-#define XK_BackSpace		0xFF08	/* back space, back char */
-#define XK_Tab			0xFF09
-#define XK_Linefeed		0xFF0A	/* Linefeed, LF */
-#define XK_Clear		0xFF0B
-#define XK_Return		0xFF0D	/* Return, enter */
-#define XK_Pause		0xFF13	/* Pause, hold */
-#define XK_Scroll_Lock		0xFF14
-#define XK_Sys_Req		0xFF15
-#define XK_Escape		0xFF1B
-#define XK_Delete		0xFFFF	/* Delete, rubout */
-
-
-
-/* International & multi-key character composition */
-
-#define XK_Multi_key		0xFF20  /* Multi-key character compose */
-#define XK_SingleCandidate	0xFF3C
-#define XK_MultipleCandidate	0xFF3D
-#define XK_PreviousCandidate	0xFF3E
-
-/* Japanese keyboard support */
-
-#define XK_Kanji		0xFF21	/* Kanji, Kanji convert */
-#define XK_Muhenkan		0xFF22  /* Cancel Conversion */
-#define XK_Henkan_Mode		0xFF23  /* Start/Stop Conversion */
-#define XK_Henkan		0xFF23  /* Alias for Henkan_Mode */
-#define XK_Romaji		0xFF24  /* to Romaji */
-#define XK_Hiragana		0xFF25  /* to Hiragana */
-#define XK_Katakana		0xFF26  /* to Katakana */
-#define XK_Hiragana_Katakana	0xFF27  /* Hiragana/Katakana toggle */
-#define XK_Zenkaku		0xFF28  /* to Zenkaku */
-#define XK_Hankaku		0xFF29  /* to Hankaku */
-#define XK_Zenkaku_Hankaku	0xFF2A  /* Zenkaku/Hankaku toggle */
-#define XK_Touroku		0xFF2B  /* Add to Dictionary */
-#define XK_Massyo		0xFF2C  /* Delete from Dictionary */
-#define XK_Kana_Lock		0xFF2D  /* Kana Lock */
-#define XK_Kana_Shift		0xFF2E  /* Kana Shift */
-#define XK_Eisu_Shift		0xFF2F  /* Alphanumeric Shift */
-#define XK_Eisu_toggle		0xFF30  /* Alphanumeric toggle */
-#define XK_Zen_Koho		0xFF3D	/* Multiple/All Candidate(s) */
-#define XK_Mae_Koho		0xFF3E	/* Previous Candidate */
-
-/* 0xFF31 thru 0xFF3F are under XK_KOREAN */
-
-/* Cursor control & motion */
-
-#define XK_Home			0xFF50
-#define XK_Left			0xFF51	/* Move left, left arrow */
-#define XK_Up			0xFF52	/* Move up, up arrow */
-#define XK_Right		0xFF53	/* Move right, right arrow */
-#define XK_Down			0xFF54	/* Move down, down arrow */
-#define XK_Prior		0xFF55	/* Prior, previous */
-#define XK_Page_Up		0xFF55
-#define XK_Next			0xFF56	/* Next */
-#define XK_Page_Down		0xFF56
-#define XK_End			0xFF57	/* EOL */
-#define XK_Begin		0xFF58	/* BOL */
-
-
-/* Misc Functions */
-
-#define XK_Select		0xFF60	/* Select, mark */
-#define XK_Print		0xFF61
-#define XK_Execute		0xFF62	/* Execute, run, do */
-#define XK_Insert		0xFF63	/* Insert, insert here */
-#define XK_Undo			0xFF65	/* Undo, oops */
-#define XK_Redo			0xFF66	/* redo, again */
-#define XK_Menu			0xFF67
-#define XK_Find			0xFF68	/* Find, search */
-#define XK_Cancel		0xFF69	/* Cancel, stop, abort, exit */
-#define XK_Help			0xFF6A	/* Help */
-#define XK_Break		0xFF6B
-#define XK_Mode_switch		0xFF7E	/* Character set switch */
-#define XK_script_switch        0xFF7E  /* Alias for mode_switch */
-#define XK_Num_Lock		0xFF7F
-
-/* Keypad Functions, keypad numbers cleverly chosen to map to ascii */
-
-#define XK_KP_Space		0xFF80	/* space */
-#define XK_KP_Tab		0xFF89
-#define XK_KP_Enter		0xFF8D	/* enter */
-#define XK_KP_F1		0xFF91	/* PF1, KP_A, ... */
-#define XK_KP_F2		0xFF92
-#define XK_KP_F3		0xFF93
-#define XK_KP_F4		0xFF94
-#define XK_KP_Home		0xFF95
-#define XK_KP_Left		0xFF96
-#define XK_KP_Up		0xFF97
-#define XK_KP_Right		0xFF98
-#define XK_KP_Down		0xFF99
-#define XK_KP_Prior		0xFF9A
-#define XK_KP_Page_Up		0xFF9A
-#define XK_KP_Next		0xFF9B
-#define XK_KP_Page_Down		0xFF9B
-#define XK_KP_End		0xFF9C
-#define XK_KP_Begin		0xFF9D
-#define XK_KP_Insert		0xFF9E
-#define XK_KP_Delete		0xFF9F
-#define XK_KP_Equal		0xFFBD	/* equals */
-#define XK_KP_Multiply		0xFFAA
-#define XK_KP_Add		0xFFAB
-#define XK_KP_Separator		0xFFAC	/* separator, often comma */
-#define XK_KP_Subtract		0xFFAD
-#define XK_KP_Decimal		0xFFAE
-#define XK_KP_Divide		0xFFAF
-
-#define XK_KP_0			0xFFB0
-#define XK_KP_1			0xFFB1
-#define XK_KP_2			0xFFB2
-#define XK_KP_3			0xFFB3
-#define XK_KP_4			0xFFB4
-#define XK_KP_5			0xFFB5
-#define XK_KP_6			0xFFB6
-#define XK_KP_7			0xFFB7
-#define XK_KP_8			0xFFB8
-#define XK_KP_9			0xFFB9
-
-
-
-/*
- * Auxilliary Functions; note the duplicate definitions for left and right
- * function keys;  Sun keyboards and a few other manufactures have such
- * function key groups on the left and/or right sides of the keyboard.
- * We've not found a keyboard with more than 35 function keys total.
- */
-
-#define XK_F1			0xFFBE
-#define XK_F2			0xFFBF
-#define XK_F3			0xFFC0
-#define XK_F4			0xFFC1
-#define XK_F5			0xFFC2
-#define XK_F6			0xFFC3
-#define XK_F7			0xFFC4
-#define XK_F8			0xFFC5
-#define XK_F9			0xFFC6
-#define XK_F10			0xFFC7
-#define XK_F11			0xFFC8
-#define XK_L1			0xFFC8
-#define XK_F12			0xFFC9
-#define XK_L2			0xFFC9
-#define XK_F13			0xFFCA
-#define XK_L3			0xFFCA
-#define XK_F14			0xFFCB
-#define XK_L4			0xFFCB
-#define XK_F15			0xFFCC
-#define XK_L5			0xFFCC
-#define XK_F16			0xFFCD
-#define XK_L6			0xFFCD
-#define XK_F17			0xFFCE
-#define XK_L7			0xFFCE
-#define XK_F18			0xFFCF
-#define XK_L8			0xFFCF
-#define XK_F19			0xFFD0
-#define XK_L9			0xFFD0
-#define XK_F20			0xFFD1
-#define XK_L10			0xFFD1
-#define XK_F21			0xFFD2
-#define XK_R1			0xFFD2
-#define XK_F22			0xFFD3
-#define XK_R2			0xFFD3
-#define XK_F23			0xFFD4
-#define XK_R3			0xFFD4
-#define XK_F24			0xFFD5
-#define XK_R4			0xFFD5
-#define XK_F25			0xFFD6
-#define XK_R5			0xFFD6
-#define XK_F26			0xFFD7
-#define XK_R6			0xFFD7
-#define XK_F27			0xFFD8
-#define XK_R7			0xFFD8
-#define XK_F28			0xFFD9
-#define XK_R8			0xFFD9
-#define XK_F29			0xFFDA
-#define XK_R9			0xFFDA
-#define XK_F30			0xFFDB
-#define XK_R10			0xFFDB
-#define XK_F31			0xFFDC
-#define XK_R11			0xFFDC
-#define XK_F32			0xFFDD
-#define XK_R12			0xFFDD
-#define XK_F33			0xFFDE
-#define XK_R13			0xFFDE
-#define XK_F34			0xFFDF
-#define XK_R14			0xFFDF
-#define XK_F35			0xFFE0
-#define XK_R15			0xFFE0
-
-/* Modifiers */
-
-#define XK_Shift_L		0xFFE1	/* Left shift */
-#define XK_Shift_R		0xFFE2	/* Right shift */
-#define XK_Control_L		0xFFE3	/* Left control */
-#define XK_Control_R		0xFFE4	/* Right control */
-#define XK_Caps_Lock		0xFFE5	/* Caps lock */
-#define XK_Shift_Lock		0xFFE6	/* Shift lock */
-
-#define XK_Meta_L		0xFFE7	/* Left meta */
-#define XK_Meta_R		0xFFE8	/* Right meta */
-#define XK_Alt_L		0xFFE9	/* Left alt */
-#define XK_Alt_R		0xFFEA	/* Right alt */
-#define XK_Super_L		0xFFEB	/* Left super */
-#define XK_Super_R		0xFFEC	/* Right super */
-#define XK_Hyper_L		0xFFED	/* Left hyper */
-#define XK_Hyper_R		0xFFEE	/* Right hyper */
-#endif /* XK_MISCELLANY */
-
-/*
- * ISO 9995 Function and Modifier Keys
- * Byte 3 = 0xFE
- */
-
-#ifdef XK_XKB_KEYS
-#define	XK_ISO_Lock					0xFE01
-#define	XK_ISO_Level2_Latch				0xFE02
-#define	XK_ISO_Level3_Shift				0xFE03
-#define	XK_ISO_Level3_Latch				0xFE04
-#define	XK_ISO_Level3_Lock				0xFE05
-#define	XK_ISO_Group_Shift		0xFF7E	/* Alias for mode_switch */
-#define	XK_ISO_Group_Latch				0xFE06
-#define	XK_ISO_Group_Lock				0xFE07
-#define	XK_ISO_Next_Group				0xFE08
-#define	XK_ISO_Next_Group_Lock				0xFE09
-#define	XK_ISO_Prev_Group				0xFE0A
-#define	XK_ISO_Prev_Group_Lock				0xFE0B
-#define	XK_ISO_First_Group				0xFE0C
-#define	XK_ISO_First_Group_Lock				0xFE0D
-#define	XK_ISO_Last_Group				0xFE0E
-#define	XK_ISO_Last_Group_Lock				0xFE0F
-
-#define	XK_ISO_Left_Tab					0xFE20
-#define	XK_ISO_Move_Line_Up				0xFE21
-#define	XK_ISO_Move_Line_Down				0xFE22
-#define	XK_ISO_Partial_Line_Up				0xFE23
-#define	XK_ISO_Partial_Line_Down			0xFE24
-#define	XK_ISO_Partial_Space_Left			0xFE25
-#define	XK_ISO_Partial_Space_Right			0xFE26
-#define	XK_ISO_Set_Margin_Left				0xFE27
-#define	XK_ISO_Set_Margin_Right				0xFE28
-#define	XK_ISO_Release_Margin_Left			0xFE29
-#define	XK_ISO_Release_Margin_Right			0xFE2A
-#define	XK_ISO_Release_Both_Margins			0xFE2B
-#define	XK_ISO_Fast_Cursor_Left				0xFE2C
-#define	XK_ISO_Fast_Cursor_Right			0xFE2D
-#define	XK_ISO_Fast_Cursor_Up				0xFE2E
-#define	XK_ISO_Fast_Cursor_Down				0xFE2F
-#define	XK_ISO_Continuous_Underline			0xFE30
-#define	XK_ISO_Discontinuous_Underline			0xFE31
-#define	XK_ISO_Emphasize				0xFE32
-#define	XK_ISO_Center_Object				0xFE33
-#define	XK_ISO_Enter					0xFE34
-
-#define	XK_dead_grave					0xFE50
-#define	XK_dead_acute					0xFE51
-#define	XK_dead_circumflex				0xFE52
-#define	XK_dead_tilde					0xFE53
-#define	XK_dead_macron					0xFE54
-#define	XK_dead_breve					0xFE55
-#define	XK_dead_abovedot				0xFE56
-#define	XK_dead_diaeresis				0xFE57
-#define	XK_dead_abovering				0xFE58
-#define	XK_dead_doubleacute				0xFE59
-#define	XK_dead_caron					0xFE5A
-#define	XK_dead_cedilla					0xFE5B
-#define	XK_dead_ogonek					0xFE5C
-#define	XK_dead_iota					0xFE5D
-#define	XK_dead_voiced_sound				0xFE5E
-#define	XK_dead_semivoiced_sound			0xFE5F
-#define	XK_dead_belowdot				0xFE60
-
-#define	XK_First_Virtual_Screen				0xFED0
-#define	XK_Prev_Virtual_Screen				0xFED1
-#define	XK_Next_Virtual_Screen				0xFED2
-#define	XK_Last_Virtual_Screen				0xFED4
-#define	XK_Terminate_Server				0xFED5
-
-#define	XK_AccessX_Enable				0xFE70
-#define	XK_AccessX_Feedback_Enable			0xFE71
-#define	XK_RepeatKeys_Enable				0xFE72
-#define	XK_SlowKeys_Enable				0xFE73
-#define	XK_BounceKeys_Enable				0xFE74
-#define	XK_StickyKeys_Enable				0xFE75
-#define	XK_MouseKeys_Enable				0xFE76
-#define	XK_MouseKeys_Accel_Enable			0xFE77
-#define	XK_Overlay1_Enable				0xFE78
-#define	XK_Overlay2_Enable				0xFE79
-#define	XK_AudibleBell_Enable				0xFE7A
-
-#define	XK_Pointer_Left					0xFEE0
-#define	XK_Pointer_Right				0xFEE1
-#define	XK_Pointer_Up					0xFEE2
-#define	XK_Pointer_Down					0xFEE3
-#define	XK_Pointer_UpLeft				0xFEE4
-#define	XK_Pointer_UpRight				0xFEE5
-#define	XK_Pointer_DownLeft				0xFEE6
-#define	XK_Pointer_DownRight				0xFEE7
-#define	XK_Pointer_Button_Dflt				0xFEE8
-#define	XK_Pointer_Button1				0xFEE9
-#define	XK_Pointer_Button2				0xFEEA
-#define	XK_Pointer_Button3				0xFEEB
-#define	XK_Pointer_Button4				0xFEEC
-#define	XK_Pointer_Button5				0xFEED
-#define	XK_Pointer_DblClick_Dflt			0xFEEE
-#define	XK_Pointer_DblClick1				0xFEEF
-#define	XK_Pointer_DblClick2				0xFEF0
-#define	XK_Pointer_DblClick3				0xFEF1
-#define	XK_Pointer_DblClick4				0xFEF2
-#define	XK_Pointer_DblClick5				0xFEF3
-#define	XK_Pointer_Drag_Dflt				0xFEF4
-#define	XK_Pointer_Drag1				0xFEF5
-#define	XK_Pointer_Drag2				0xFEF6
-#define	XK_Pointer_Drag3				0xFEF7
-#define	XK_Pointer_Drag4				0xFEF8
-#define	XK_Pointer_Drag5				0xFEFD
-
-#define	XK_Pointer_EnableKeys				0xFEF9
-#define	XK_Pointer_Accelerate				0xFEFA
-#define	XK_Pointer_DfltBtnNext				0xFEFB
-#define	XK_Pointer_DfltBtnPrev				0xFEFC
-
-#endif
-
-/*
- * 3270 Terminal Keys
- * Byte 3 = 0xFD
- */
-
-#ifdef XK_3270
-#define XK_3270_Duplicate      0xFD01
-#define XK_3270_FieldMark      0xFD02
-#define XK_3270_Right2         0xFD03
-#define XK_3270_Left2          0xFD04
-#define XK_3270_BackTab        0xFD05
-#define XK_3270_EraseEOF       0xFD06
-#define XK_3270_EraseInput     0xFD07
-#define XK_3270_Reset          0xFD08
-#define XK_3270_Quit           0xFD09
-#define XK_3270_PA1            0xFD0A
-#define XK_3270_PA2            0xFD0B
-#define XK_3270_PA3            0xFD0C
-#define XK_3270_Test           0xFD0D
-#define XK_3270_Attn           0xFD0E
-#define XK_3270_CursorBlink    0xFD0F
-#define XK_3270_AltCursor      0xFD10
-#define XK_3270_KeyClick       0xFD11
-#define XK_3270_Jump           0xFD12
-#define XK_3270_Ident          0xFD13
-#define XK_3270_Rule           0xFD14
-#define XK_3270_Copy           0xFD15
-#define XK_3270_Play           0xFD16
-#define XK_3270_Setup          0xFD17
-#define XK_3270_Record         0xFD18
-#define XK_3270_ChangeScreen   0xFD19
-#define XK_3270_DeleteWord     0xFD1A
-#define XK_3270_ExSelect       0xFD1B
-#define XK_3270_CursorSelect   0xFD1C
-#define XK_3270_PrintScreen    0xFD1D
-#define XK_3270_Enter          0xFD1E
-#endif
-
-/*
- *  Latin 1
- *  Byte 3 = 0
- */
-#ifdef XK_LATIN1
-#define XK_space               0x020
-#define XK_exclam              0x021
-#define XK_quotedbl            0x022
-#define XK_numbersign          0x023
-#define XK_dollar              0x024
-#define XK_percent             0x025
-#define XK_ampersand           0x026
-#define XK_apostrophe          0x027
-#define XK_quoteright          0x027	/* deprecated */
-#define XK_parenleft           0x028
-#define XK_parenright          0x029
-#define XK_asterisk            0x02a
-#define XK_plus                0x02b
-#define XK_comma               0x02c
-#define XK_minus               0x02d
-#define XK_period              0x02e
-#define XK_slash               0x02f
-#define XK_0                   0x030
-#define XK_1                   0x031
-#define XK_2                   0x032
-#define XK_3                   0x033
-#define XK_4                   0x034
-#define XK_5                   0x035
-#define XK_6                   0x036
-#define XK_7                   0x037
-#define XK_8                   0x038
-#define XK_9                   0x039
-#define XK_colon               0x03a
-#define XK_semicolon           0x03b
-#define XK_less                0x03c
-#define XK_equal               0x03d
-#define XK_greater             0x03e
-#define XK_question            0x03f
-#define XK_at                  0x040
-#define XK_A                   0x041
-#define XK_B                   0x042
-#define XK_C                   0x043
-#define XK_D                   0x044
-#define XK_E                   0x045
-#define XK_F                   0x046
-#define XK_G                   0x047
-#define XK_H                   0x048
-#define XK_I                   0x049
-#define XK_J                   0x04a
-#define XK_K                   0x04b
-#define XK_L                   0x04c
-#define XK_M                   0x04d
-#define XK_N                   0x04e
-#define XK_O                   0x04f
-#define XK_P                   0x050
-#define XK_Q                   0x051
-#define XK_R                   0x052
-#define XK_S                   0x053
-#define XK_T                   0x054
-#define XK_U                   0x055
-#define XK_V                   0x056
-#define XK_W                   0x057
-#define XK_X                   0x058
-#define XK_Y                   0x059
-#define XK_Z                   0x05a
-#define XK_bracketleft         0x05b
-#define XK_backslash           0x05c
-#define XK_bracketright        0x05d
-#define XK_asciicircum         0x05e
-#define XK_underscore          0x05f
-#define XK_grave               0x060
-#define XK_quoteleft           0x060	/* deprecated */
-#define XK_a                   0x061
-#define XK_b                   0x062
-#define XK_c                   0x063
-#define XK_d                   0x064
-#define XK_e                   0x065
-#define XK_f                   0x066
-#define XK_g                   0x067
-#define XK_h                   0x068
-#define XK_i                   0x069
-#define XK_j                   0x06a
-#define XK_k                   0x06b
-#define XK_l                   0x06c
-#define XK_m                   0x06d
-#define XK_n                   0x06e
-#define XK_o                   0x06f
-#define XK_p                   0x070
-#define XK_q                   0x071
-#define XK_r                   0x072
-#define XK_s                   0x073
-#define XK_t                   0x074
-#define XK_u                   0x075
-#define XK_v                   0x076
-#define XK_w                   0x077
-#define XK_x                   0x078
-#define XK_y                   0x079
-#define XK_z                   0x07a
-#define XK_braceleft           0x07b
-#define XK_bar                 0x07c
-#define XK_braceright          0x07d
-#define XK_asciitilde          0x07e
-
-#define XK_nobreakspace        0x0a0
-#define XK_exclamdown          0x0a1
-#define XK_cent        	       0x0a2
-#define XK_sterling            0x0a3
-#define XK_currency            0x0a4
-#define XK_yen                 0x0a5
-#define XK_brokenbar           0x0a6
-#define XK_section             0x0a7
-#define XK_diaeresis           0x0a8
-#define XK_copyright           0x0a9
-#define XK_ordfeminine         0x0aa
-#define XK_guillemotleft       0x0ab	/* left angle quotation mark */
-#define XK_notsign             0x0ac
-#define XK_hyphen              0x0ad
-#define XK_registered          0x0ae
-#define XK_macron              0x0af
-#define XK_degree              0x0b0
-#define XK_plusminus           0x0b1
-#define XK_twosuperior         0x0b2
-#define XK_threesuperior       0x0b3
-#define XK_acute               0x0b4
-#define XK_mu                  0x0b5
-#define XK_paragraph           0x0b6
-#define XK_periodcentered      0x0b7
-#define XK_cedilla             0x0b8
-#define XK_onesuperior         0x0b9
-#define XK_masculine           0x0ba
-#define XK_guillemotright      0x0bb	/* right angle quotation mark */
-#define XK_onequarter          0x0bc
-#define XK_onehalf             0x0bd
-#define XK_threequarters       0x0be
-#define XK_questiondown        0x0bf
-#define XK_Agrave              0x0c0
-#define XK_Aacute              0x0c1
-#define XK_Acircumflex         0x0c2
-#define XK_Atilde              0x0c3
-#define XK_Adiaeresis          0x0c4
-#define XK_Aring               0x0c5
-#define XK_AE                  0x0c6
-#define XK_Ccedilla            0x0c7
-#define XK_Egrave              0x0c8
-#define XK_Eacute              0x0c9
-#define XK_Ecircumflex         0x0ca
-#define XK_Ediaeresis          0x0cb
-#define XK_Igrave              0x0cc
-#define XK_Iacute              0x0cd
-#define XK_Icircumflex         0x0ce
-#define XK_Idiaeresis          0x0cf
-#define XK_ETH                 0x0d0
-#define XK_Eth                 0x0d0	/* deprecated */
-#define XK_Ntilde              0x0d1
-#define XK_Ograve              0x0d2
-#define XK_Oacute              0x0d3
-#define XK_Ocircumflex         0x0d4
-#define XK_Otilde              0x0d5
-#define XK_Odiaeresis          0x0d6
-#define XK_multiply            0x0d7
-#define XK_Ooblique            0x0d8
-#define XK_Ugrave              0x0d9
-#define XK_Uacute              0x0da
-#define XK_Ucircumflex         0x0db
-#define XK_Udiaeresis          0x0dc
-#define XK_Yacute              0x0dd
-#define XK_THORN               0x0de
-#define XK_Thorn               0x0de	/* deprecated */
-#define XK_ssharp              0x0df
-#define XK_agrave              0x0e0
-#define XK_aacute              0x0e1
-#define XK_acircumflex         0x0e2
-#define XK_atilde              0x0e3
-#define XK_adiaeresis          0x0e4
-#define XK_aring               0x0e5
-#define XK_ae                  0x0e6
-#define XK_ccedilla            0x0e7
-#define XK_egrave              0x0e8
-#define XK_eacute              0x0e9
-#define XK_ecircumflex         0x0ea
-#define XK_ediaeresis          0x0eb
-#define XK_igrave              0x0ec
-#define XK_iacute              0x0ed
-#define XK_icircumflex         0x0ee
-#define XK_idiaeresis          0x0ef
-#define XK_eth                 0x0f0
-#define XK_ntilde              0x0f1
-#define XK_ograve              0x0f2
-#define XK_oacute              0x0f3
-#define XK_ocircumflex         0x0f4
-#define XK_otilde              0x0f5
-#define XK_odiaeresis          0x0f6
-#define XK_division            0x0f7
-#define XK_oslash              0x0f8
-#define XK_ugrave              0x0f9
-#define XK_uacute              0x0fa
-#define XK_ucircumflex         0x0fb
-#define XK_udiaeresis          0x0fc
-#define XK_yacute              0x0fd
-#define XK_thorn               0x0fe
-#define XK_ydiaeresis          0x0ff
-#endif /* XK_LATIN1 */
-
-/*
- *   Latin 2
- *   Byte 3 = 1
- */
-
-#ifdef XK_LATIN2
-#define XK_Aogonek             0x1a1
-#define XK_breve               0x1a2
-#define XK_Lstroke             0x1a3
-#define XK_Lcaron              0x1a5
-#define XK_Sacute              0x1a6
-#define XK_Scaron              0x1a9
-#define XK_Scedilla            0x1aa
-#define XK_Tcaron              0x1ab
-#define XK_Zacute              0x1ac
-#define XK_Zcaron              0x1ae
-#define XK_Zabovedot           0x1af
-#define XK_aogonek             0x1b1
-#define XK_ogonek              0x1b2
-#define XK_lstroke             0x1b3
-#define XK_lcaron              0x1b5
-#define XK_sacute              0x1b6
-#define XK_caron               0x1b7
-#define XK_scaron              0x1b9
-#define XK_scedilla            0x1ba
-#define XK_tcaron              0x1bb
-#define XK_zacute              0x1bc
-#define XK_doubleacute         0x1bd
-#define XK_zcaron              0x1be
-#define XK_zabovedot           0x1bf
-#define XK_Racute              0x1c0
-#define XK_Abreve              0x1c3
-#define XK_Lacute              0x1c5
-#define XK_Cacute              0x1c6
-#define XK_Ccaron              0x1c8
-#define XK_Eogonek             0x1ca
-#define XK_Ecaron              0x1cc
-#define XK_Dcaron              0x1cf
-#define XK_Dstroke             0x1d0
-#define XK_Nacute              0x1d1
-#define XK_Ncaron              0x1d2
-#define XK_Odoubleacute        0x1d5
-#define XK_Rcaron              0x1d8
-#define XK_Uring               0x1d9
-#define XK_Udoubleacute        0x1db
-#define XK_Tcedilla            0x1de
-#define XK_racute              0x1e0
-#define XK_abreve              0x1e3
-#define XK_lacute              0x1e5
-#define XK_cacute              0x1e6
-#define XK_ccaron              0x1e8
-#define XK_eogonek             0x1ea
-#define XK_ecaron              0x1ec
-#define XK_dcaron              0x1ef
-#define XK_dstroke             0x1f0
-#define XK_nacute              0x1f1
-#define XK_ncaron              0x1f2
-#define XK_odoubleacute        0x1f5
-#define XK_udoubleacute        0x1fb
-#define XK_rcaron              0x1f8
-#define XK_uring               0x1f9
-#define XK_tcedilla            0x1fe
-#define XK_abovedot            0x1ff
-#endif /* XK_LATIN2 */
-
-/*
- *   Latin 3
- *   Byte 3 = 2
- */
-
-#ifdef XK_LATIN3
-#define XK_Hstroke             0x2a1
-#define XK_Hcircumflex         0x2a6
-#define XK_Iabovedot           0x2a9
-#define XK_Gbreve              0x2ab
-#define XK_Jcircumflex         0x2ac
-#define XK_hstroke             0x2b1
-#define XK_hcircumflex         0x2b6
-#define XK_idotless            0x2b9
-#define XK_gbreve              0x2bb
-#define XK_jcircumflex         0x2bc
-#define XK_Cabovedot           0x2c5
-#define XK_Ccircumflex         0x2c6
-#define XK_Gabovedot           0x2d5
-#define XK_Gcircumflex         0x2d8
-#define XK_Ubreve              0x2dd
-#define XK_Scircumflex         0x2de
-#define XK_cabovedot           0x2e5
-#define XK_ccircumflex         0x2e6
-#define XK_gabovedot           0x2f5
-#define XK_gcircumflex         0x2f8
-#define XK_ubreve              0x2fd
-#define XK_scircumflex         0x2fe
-#endif /* XK_LATIN3 */
-
-
-/*
- *   Latin 4
- *   Byte 3 = 3
- */
-
-#ifdef XK_LATIN4
-#define XK_kra                 0x3a2
-#define XK_kappa               0x3a2	/* deprecated */
-#define XK_Rcedilla            0x3a3
-#define XK_Itilde              0x3a5
-#define XK_Lcedilla            0x3a6
-#define XK_Emacron             0x3aa
-#define XK_Gcedilla            0x3ab
-#define XK_Tslash              0x3ac
-#define XK_rcedilla            0x3b3
-#define XK_itilde              0x3b5
-#define XK_lcedilla            0x3b6
-#define XK_emacron             0x3ba
-#define XK_gcedilla            0x3bb
-#define XK_tslash              0x3bc
-#define XK_ENG                 0x3bd
-#define XK_eng                 0x3bf
-#define XK_Amacron             0x3c0
-#define XK_Iogonek             0x3c7
-#define XK_Eabovedot           0x3cc
-#define XK_Imacron             0x3cf
-#define XK_Ncedilla            0x3d1
-#define XK_Omacron             0x3d2
-#define XK_Kcedilla            0x3d3
-#define XK_Uogonek             0x3d9
-#define XK_Utilde              0x3dd
-#define XK_Umacron             0x3de
-#define XK_amacron             0x3e0
-#define XK_iogonek             0x3e7
-#define XK_eabovedot           0x3ec
-#define XK_imacron             0x3ef
-#define XK_ncedilla            0x3f1
-#define XK_omacron             0x3f2
-#define XK_kcedilla            0x3f3
-#define XK_uogonek             0x3f9
-#define XK_utilde              0x3fd
-#define XK_umacron             0x3fe
-#endif /* XK_LATIN4 */
-
-/*
- * Katakana
- * Byte 3 = 4
- */
-
-#ifdef XK_KATAKANA
-#define XK_overline				       0x47e
-#define XK_kana_fullstop                               0x4a1
-#define XK_kana_openingbracket                         0x4a2
-#define XK_kana_closingbracket                         0x4a3
-#define XK_kana_comma                                  0x4a4
-#define XK_kana_conjunctive                            0x4a5
-#define XK_kana_middledot                              0x4a5  /* deprecated */
-#define XK_kana_WO                                     0x4a6
-#define XK_kana_a                                      0x4a7
-#define XK_kana_i                                      0x4a8
-#define XK_kana_u                                      0x4a9
-#define XK_kana_e                                      0x4aa
-#define XK_kana_o                                      0x4ab
-#define XK_kana_ya                                     0x4ac
-#define XK_kana_yu                                     0x4ad
-#define XK_kana_yo                                     0x4ae
-#define XK_kana_tsu                                    0x4af
-#define XK_kana_tu                                     0x4af  /* deprecated */
-#define XK_prolongedsound                              0x4b0
-#define XK_kana_A                                      0x4b1
-#define XK_kana_I                                      0x4b2
-#define XK_kana_U                                      0x4b3
-#define XK_kana_E                                      0x4b4
-#define XK_kana_O                                      0x4b5
-#define XK_kana_KA                                     0x4b6
-#define XK_kana_KI                                     0x4b7
-#define XK_kana_KU                                     0x4b8
-#define XK_kana_KE                                     0x4b9
-#define XK_kana_KO                                     0x4ba
-#define XK_kana_SA                                     0x4bb
-#define XK_kana_SHI                                    0x4bc
-#define XK_kana_SU                                     0x4bd
-#define XK_kana_SE                                     0x4be
-#define XK_kana_SO                                     0x4bf
-#define XK_kana_TA                                     0x4c0
-#define XK_kana_CHI                                    0x4c1
-#define XK_kana_TI                                     0x4c1  /* deprecated */
-#define XK_kana_TSU                                    0x4c2
-#define XK_kana_TU                                     0x4c2  /* deprecated */
-#define XK_kana_TE                                     0x4c3
-#define XK_kana_TO                                     0x4c4
-#define XK_kana_NA                                     0x4c5
-#define XK_kana_NI                                     0x4c6
-#define XK_kana_NU                                     0x4c7
-#define XK_kana_NE                                     0x4c8
-#define XK_kana_NO                                     0x4c9
-#define XK_kana_HA                                     0x4ca
-#define XK_kana_HI                                     0x4cb
-#define XK_kana_FU                                     0x4cc
-#define XK_kana_HU                                     0x4cc  /* deprecated */
-#define XK_kana_HE                                     0x4cd
-#define XK_kana_HO                                     0x4ce
-#define XK_kana_MA                                     0x4cf
-#define XK_kana_MI                                     0x4d0
-#define XK_kana_MU                                     0x4d1
-#define XK_kana_ME                                     0x4d2
-#define XK_kana_MO                                     0x4d3
-#define XK_kana_YA                                     0x4d4
-#define XK_kana_YU                                     0x4d5
-#define XK_kana_YO                                     0x4d6
-#define XK_kana_RA                                     0x4d7
-#define XK_kana_RI                                     0x4d8
-#define XK_kana_RU                                     0x4d9
-#define XK_kana_RE                                     0x4da
-#define XK_kana_RO                                     0x4db
-#define XK_kana_WA                                     0x4dc
-#define XK_kana_N                                      0x4dd
-#define XK_voicedsound                                 0x4de
-#define XK_semivoicedsound                             0x4df
-#define XK_kana_switch          0xFF7E  /* Alias for mode_switch */
-#endif /* XK_KATAKANA */
-
-/*
- *  Arabic
- *  Byte 3 = 5
- */
-
-#ifdef XK_ARABIC
-#define XK_Arabic_comma                                0x5ac
-#define XK_Arabic_semicolon                            0x5bb
-#define XK_Arabic_question_mark                        0x5bf
-#define XK_Arabic_hamza                                0x5c1
-#define XK_Arabic_maddaonalef                          0x5c2
-#define XK_Arabic_hamzaonalef                          0x5c3
-#define XK_Arabic_hamzaonwaw                           0x5c4
-#define XK_Arabic_hamzaunderalef                       0x5c5
-#define XK_Arabic_hamzaonyeh                           0x5c6
-#define XK_Arabic_alef                                 0x5c7
-#define XK_Arabic_beh                                  0x5c8
-#define XK_Arabic_tehmarbuta                           0x5c9
-#define XK_Arabic_teh                                  0x5ca
-#define XK_Arabic_theh                                 0x5cb
-#define XK_Arabic_jeem                                 0x5cc
-#define XK_Arabic_hah                                  0x5cd
-#define XK_Arabic_khah                                 0x5ce
-#define XK_Arabic_dal                                  0x5cf
-#define XK_Arabic_thal                                 0x5d0
-#define XK_Arabic_ra                                   0x5d1
-#define XK_Arabic_zain                                 0x5d2
-#define XK_Arabic_seen                                 0x5d3
-#define XK_Arabic_sheen                                0x5d4
-#define XK_Arabic_sad                                  0x5d5
-#define XK_Arabic_dad                                  0x5d6
-#define XK_Arabic_tah                                  0x5d7
-#define XK_Arabic_zah                                  0x5d8
-#define XK_Arabic_ain                                  0x5d9
-#define XK_Arabic_ghain                                0x5da
-#define XK_Arabic_tatweel                              0x5e0
-#define XK_Arabic_feh                                  0x5e1
-#define XK_Arabic_qaf                                  0x5e2
-#define XK_Arabic_kaf                                  0x5e3
-#define XK_Arabic_lam                                  0x5e4
-#define XK_Arabic_meem                                 0x5e5
-#define XK_Arabic_noon                                 0x5e6
-#define XK_Arabic_ha                                   0x5e7
-#define XK_Arabic_heh                                  0x5e7  /* deprecated */
-#define XK_Arabic_waw                                  0x5e8
-#define XK_Arabic_alefmaksura                          0x5e9
-#define XK_Arabic_yeh                                  0x5ea
-#define XK_Arabic_fathatan                             0x5eb
-#define XK_Arabic_dammatan                             0x5ec
-#define XK_Arabic_kasratan                             0x5ed
-#define XK_Arabic_fatha                                0x5ee
-#define XK_Arabic_damma                                0x5ef
-#define XK_Arabic_kasra                                0x5f0
-#define XK_Arabic_shadda                               0x5f1
-#define XK_Arabic_sukun                                0x5f2
-#define XK_Arabic_switch        0xFF7E  /* Alias for mode_switch */
-#endif /* XK_ARABIC */
-
-/*
- * Cyrillic
- * Byte 3 = 6
- */
-#ifdef XK_CYRILLIC
-#define XK_Serbian_dje                                 0x6a1
-#define XK_Macedonia_gje                               0x6a2
-#define XK_Cyrillic_io                                 0x6a3
-#define XK_Ukrainian_ie                                0x6a4
-#define XK_Ukranian_je                                 0x6a4  /* deprecated */
-#define XK_Macedonia_dse                               0x6a5
-#define XK_Ukrainian_i                                 0x6a6
-#define XK_Ukranian_i                                  0x6a6  /* deprecated */
-#define XK_Ukrainian_yi                                0x6a7
-#define XK_Ukranian_yi                                 0x6a7  /* deprecated */
-#define XK_Cyrillic_je                                 0x6a8
-#define XK_Serbian_je                                  0x6a8  /* deprecated */
-#define XK_Cyrillic_lje                                0x6a9
-#define XK_Serbian_lje                                 0x6a9  /* deprecated */
-#define XK_Cyrillic_nje                                0x6aa
-#define XK_Serbian_nje                                 0x6aa  /* deprecated */
-#define XK_Serbian_tshe                                0x6ab
-#define XK_Macedonia_kje                               0x6ac
-#define XK_Byelorussian_shortu                         0x6ae
-#define XK_Cyrillic_dzhe                               0x6af
-#define XK_Serbian_dze                                 0x6af  /* deprecated */
-#define XK_numerosign                                  0x6b0
-#define XK_Serbian_DJE                                 0x6b1
-#define XK_Macedonia_GJE                               0x6b2
-#define XK_Cyrillic_IO                                 0x6b3
-#define XK_Ukrainian_IE                                0x6b4
-#define XK_Ukranian_JE                                 0x6b4  /* deprecated */
-#define XK_Macedonia_DSE                               0x6b5
-#define XK_Ukrainian_I                                 0x6b6
-#define XK_Ukranian_I                                  0x6b6  /* deprecated */
-#define XK_Ukrainian_YI                                0x6b7
-#define XK_Ukranian_YI                                 0x6b7  /* deprecated */
-#define XK_Cyrillic_JE                                 0x6b8
-#define XK_Serbian_JE                                  0x6b8  /* deprecated */
-#define XK_Cyrillic_LJE                                0x6b9
-#define XK_Serbian_LJE                                 0x6b9  /* deprecated */
-#define XK_Cyrillic_NJE                                0x6ba
-#define XK_Serbian_NJE                                 0x6ba  /* deprecated */
-#define XK_Serbian_TSHE                                0x6bb
-#define XK_Macedonia_KJE                               0x6bc
-#define XK_Byelorussian_SHORTU                         0x6be
-#define XK_Cyrillic_DZHE                               0x6bf
-#define XK_Serbian_DZE                                 0x6bf  /* deprecated */
-#define XK_Cyrillic_yu                                 0x6c0
-#define XK_Cyrillic_a                                  0x6c1
-#define XK_Cyrillic_be                                 0x6c2
-#define XK_Cyrillic_tse                                0x6c3
-#define XK_Cyrillic_de                                 0x6c4
-#define XK_Cyrillic_ie                                 0x6c5
-#define XK_Cyrillic_ef                                 0x6c6
-#define XK_Cyrillic_ghe                                0x6c7
-#define XK_Cyrillic_ha                                 0x6c8
-#define XK_Cyrillic_i                                  0x6c9
-#define XK_Cyrillic_shorti                             0x6ca
-#define XK_Cyrillic_ka                                 0x6cb
-#define XK_Cyrillic_el                                 0x6cc
-#define XK_Cyrillic_em                                 0x6cd
-#define XK_Cyrillic_en                                 0x6ce
-#define XK_Cyrillic_o                                  0x6cf
-#define XK_Cyrillic_pe                                 0x6d0
-#define XK_Cyrillic_ya                                 0x6d1
-#define XK_Cyrillic_er                                 0x6d2
-#define XK_Cyrillic_es                                 0x6d3
-#define XK_Cyrillic_te                                 0x6d4
-#define XK_Cyrillic_u                                  0x6d5
-#define XK_Cyrillic_zhe                                0x6d6
-#define XK_Cyrillic_ve                                 0x6d7
-#define XK_Cyrillic_softsign                           0x6d8
-#define XK_Cyrillic_yeru                               0x6d9
-#define XK_Cyrillic_ze                                 0x6da
-#define XK_Cyrillic_sha                                0x6db
-#define XK_Cyrillic_e                                  0x6dc
-#define XK_Cyrillic_shcha                              0x6dd
-#define XK_Cyrillic_che                                0x6de
-#define XK_Cyrillic_hardsign                           0x6df
-#define XK_Cyrillic_YU                                 0x6e0
-#define XK_Cyrillic_A                                  0x6e1
-#define XK_Cyrillic_BE                                 0x6e2
-#define XK_Cyrillic_TSE                                0x6e3
-#define XK_Cyrillic_DE                                 0x6e4
-#define XK_Cyrillic_IE                                 0x6e5
-#define XK_Cyrillic_EF                                 0x6e6
-#define XK_Cyrillic_GHE                                0x6e7
-#define XK_Cyrillic_HA                                 0x6e8
-#define XK_Cyrillic_I                                  0x6e9
-#define XK_Cyrillic_SHORTI                             0x6ea
-#define XK_Cyrillic_KA                                 0x6eb
-#define XK_Cyrillic_EL                                 0x6ec
-#define XK_Cyrillic_EM                                 0x6ed
-#define XK_Cyrillic_EN                                 0x6ee
-#define XK_Cyrillic_O                                  0x6ef
-#define XK_Cyrillic_PE                                 0x6f0
-#define XK_Cyrillic_YA                                 0x6f1
-#define XK_Cyrillic_ER                                 0x6f2
-#define XK_Cyrillic_ES                                 0x6f3
-#define XK_Cyrillic_TE                                 0x6f4
-#define XK_Cyrillic_U                                  0x6f5
-#define XK_Cyrillic_ZHE                                0x6f6
-#define XK_Cyrillic_VE                                 0x6f7
-#define XK_Cyrillic_SOFTSIGN                           0x6f8
-#define XK_Cyrillic_YERU                               0x6f9
-#define XK_Cyrillic_ZE                                 0x6fa
-#define XK_Cyrillic_SHA                                0x6fb
-#define XK_Cyrillic_E                                  0x6fc
-#define XK_Cyrillic_SHCHA                              0x6fd
-#define XK_Cyrillic_CHE                                0x6fe
-#define XK_Cyrillic_HARDSIGN                           0x6ff
-#endif /* XK_CYRILLIC */
-
-/*
- * Greek
- * Byte 3 = 7
- */
-
-#ifdef XK_GREEK
-#define XK_Greek_ALPHAaccent                           0x7a1
-#define XK_Greek_EPSILONaccent                         0x7a2
-#define XK_Greek_ETAaccent                             0x7a3
-#define XK_Greek_IOTAaccent                            0x7a4
-#define XK_Greek_IOTAdieresis                          0x7a5
-#define XK_Greek_OMICRONaccent                         0x7a7
-#define XK_Greek_UPSILONaccent                         0x7a8
-#define XK_Greek_UPSILONdieresis                       0x7a9
-#define XK_Greek_OMEGAaccent                           0x7ab
-#define XK_Greek_accentdieresis                        0x7ae
-#define XK_Greek_horizbar                              0x7af
-#define XK_Greek_alphaaccent                           0x7b1
-#define XK_Greek_epsilonaccent                         0x7b2
-#define XK_Greek_etaaccent                             0x7b3
-#define XK_Greek_iotaaccent                            0x7b4
-#define XK_Greek_iotadieresis                          0x7b5
-#define XK_Greek_iotaaccentdieresis                    0x7b6
-#define XK_Greek_omicronaccent                         0x7b7
-#define XK_Greek_upsilonaccent                         0x7b8
-#define XK_Greek_upsilondieresis                       0x7b9
-#define XK_Greek_upsilonaccentdieresis                 0x7ba
-#define XK_Greek_omegaaccent                           0x7bb
-#define XK_Greek_ALPHA                                 0x7c1
-#define XK_Greek_BETA                                  0x7c2
-#define XK_Greek_GAMMA                                 0x7c3
-#define XK_Greek_DELTA                                 0x7c4
-#define XK_Greek_EPSILON                               0x7c5
-#define XK_Greek_ZETA                                  0x7c6
-#define XK_Greek_ETA                                   0x7c7
-#define XK_Greek_THETA                                 0x7c8
-#define XK_Greek_IOTA                                  0x7c9
-#define XK_Greek_KAPPA                                 0x7ca
-#define XK_Greek_LAMDA                                 0x7cb
-#define XK_Greek_LAMBDA                                0x7cb
-#define XK_Greek_MU                                    0x7cc
-#define XK_Greek_NU                                    0x7cd
-#define XK_Greek_XI                                    0x7ce
-#define XK_Greek_OMICRON                               0x7cf
-#define XK_Greek_PI                                    0x7d0
-#define XK_Greek_RHO                                   0x7d1
-#define XK_Greek_SIGMA                                 0x7d2
-#define XK_Greek_TAU                                   0x7d4
-#define XK_Greek_UPSILON                               0x7d5
-#define XK_Greek_PHI                                   0x7d6
-#define XK_Greek_CHI                                   0x7d7
-#define XK_Greek_PSI                                   0x7d8
-#define XK_Greek_OMEGA                                 0x7d9
-#define XK_Greek_alpha                                 0x7e1
-#define XK_Greek_beta                                  0x7e2
-#define XK_Greek_gamma                                 0x7e3
-#define XK_Greek_delta                                 0x7e4
-#define XK_Greek_epsilon                               0x7e5
-#define XK_Greek_zeta                                  0x7e6
-#define XK_Greek_eta                                   0x7e7
-#define XK_Greek_theta                                 0x7e8
-#define XK_Greek_iota                                  0x7e9
-#define XK_Greek_kappa                                 0x7ea
-#define XK_Greek_lamda                                 0x7eb
-#define XK_Greek_lambda                                0x7eb
-#define XK_Greek_mu                                    0x7ec
-#define XK_Greek_nu                                    0x7ed
-#define XK_Greek_xi                                    0x7ee
-#define XK_Greek_omicron                               0x7ef
-#define XK_Greek_pi                                    0x7f0
-#define XK_Greek_rho                                   0x7f1
-#define XK_Greek_sigma                                 0x7f2
-#define XK_Greek_finalsmallsigma                       0x7f3
-#define XK_Greek_tau                                   0x7f4
-#define XK_Greek_upsilon                               0x7f5
-#define XK_Greek_phi                                   0x7f6
-#define XK_Greek_chi                                   0x7f7
-#define XK_Greek_psi                                   0x7f8
-#define XK_Greek_omega                                 0x7f9
-#define XK_Greek_switch         0xFF7E  /* Alias for mode_switch */
-#endif /* XK_GREEK */
-
-/*
- * Technical
- * Byte 3 = 8
- */
-
-#ifdef XK_TECHNICAL
-#define XK_leftradical                                 0x8a1
-#define XK_topleftradical                              0x8a2
-#define XK_horizconnector                              0x8a3
-#define XK_topintegral                                 0x8a4
-#define XK_botintegral                                 0x8a5
-#define XK_vertconnector                               0x8a6
-#define XK_topleftsqbracket                            0x8a7
-#define XK_botleftsqbracket                            0x8a8
-#define XK_toprightsqbracket                           0x8a9
-#define XK_botrightsqbracket                           0x8aa
-#define XK_topleftparens                               0x8ab
-#define XK_botleftparens                               0x8ac
-#define XK_toprightparens                              0x8ad
-#define XK_botrightparens                              0x8ae
-#define XK_leftmiddlecurlybrace                        0x8af
-#define XK_rightmiddlecurlybrace                       0x8b0
-#define XK_topleftsummation                            0x8b1
-#define XK_botleftsummation                            0x8b2
-#define XK_topvertsummationconnector                   0x8b3
-#define XK_botvertsummationconnector                   0x8b4
-#define XK_toprightsummation                           0x8b5
-#define XK_botrightsummation                           0x8b6
-#define XK_rightmiddlesummation                        0x8b7
-#define XK_lessthanequal                               0x8bc
-#define XK_notequal                                    0x8bd
-#define XK_greaterthanequal                            0x8be
-#define XK_integral                                    0x8bf
-#define XK_therefore                                   0x8c0
-#define XK_variation                                   0x8c1
-#define XK_infinity                                    0x8c2
-#define XK_nabla                                       0x8c5
-#define XK_approximate                                 0x8c8
-#define XK_similarequal                                0x8c9
-#define XK_ifonlyif                                    0x8cd
-#define XK_implies                                     0x8ce
-#define XK_identical                                   0x8cf
-#define XK_radical                                     0x8d6
-#define XK_includedin                                  0x8da
-#define XK_includes                                    0x8db
-#define XK_intersection                                0x8dc
-#define XK_union                                       0x8dd
-#define XK_logicaland                                  0x8de
-#define XK_logicalor                                   0x8df
-#define XK_partialderivative                           0x8ef
-#define XK_function                                    0x8f6
-#define XK_leftarrow                                   0x8fb
-#define XK_uparrow                                     0x8fc
-#define XK_rightarrow                                  0x8fd
-#define XK_downarrow                                   0x8fe
-#endif /* XK_TECHNICAL */
-
-/*
- *  Special
- *  Byte 3 = 9
- */
-
-#ifdef XK_SPECIAL
-#define XK_blank                                       0x9df
-#define XK_soliddiamond                                0x9e0
-#define XK_checkerboard                                0x9e1
-#define XK_ht                                          0x9e2
-#define XK_ff                                          0x9e3
-#define XK_cr                                          0x9e4
-#define XK_lf                                          0x9e5
-#define XK_nl                                          0x9e8
-#define XK_vt                                          0x9e9
-#define XK_lowrightcorner                              0x9ea
-#define XK_uprightcorner                               0x9eb
-#define XK_upleftcorner                                0x9ec
-#define XK_lowleftcorner                               0x9ed
-#define XK_crossinglines                               0x9ee
-#define XK_horizlinescan1                              0x9ef
-#define XK_horizlinescan3                              0x9f0
-#define XK_horizlinescan5                              0x9f1
-#define XK_horizlinescan7                              0x9f2
-#define XK_horizlinescan9                              0x9f3
-#define XK_leftt                                       0x9f4
-#define XK_rightt                                      0x9f5
-#define XK_bott                                        0x9f6
-#define XK_topt                                        0x9f7
-#define XK_vertbar                                     0x9f8
-#endif /* XK_SPECIAL */
-
-/*
- *  Publishing
- *  Byte 3 = a
- */
-
-#ifdef XK_PUBLISHING
-#define XK_emspace                                     0xaa1
-#define XK_enspace                                     0xaa2
-#define XK_em3space                                    0xaa3
-#define XK_em4space                                    0xaa4
-#define XK_digitspace                                  0xaa5
-#define XK_punctspace                                  0xaa6
-#define XK_thinspace                                   0xaa7
-#define XK_hairspace                                   0xaa8
-#define XK_emdash                                      0xaa9
-#define XK_endash                                      0xaaa
-#define XK_signifblank                                 0xaac
-#define XK_ellipsis                                    0xaae
-#define XK_doubbaselinedot                             0xaaf
-#define XK_onethird                                    0xab0
-#define XK_twothirds                                   0xab1
-#define XK_onefifth                                    0xab2
-#define XK_twofifths                                   0xab3
-#define XK_threefifths                                 0xab4
-#define XK_fourfifths                                  0xab5
-#define XK_onesixth                                    0xab6
-#define XK_fivesixths                                  0xab7
-#define XK_careof                                      0xab8
-#define XK_figdash                                     0xabb
-#define XK_leftanglebracket                            0xabc
-#define XK_decimalpoint                                0xabd
-#define XK_rightanglebracket                           0xabe
-#define XK_marker                                      0xabf
-#define XK_oneeighth                                   0xac3
-#define XK_threeeighths                                0xac4
-#define XK_fiveeighths                                 0xac5
-#define XK_seveneighths                                0xac6
-#define XK_trademark                                   0xac9
-#define XK_signaturemark                               0xaca
-#define XK_trademarkincircle                           0xacb
-#define XK_leftopentriangle                            0xacc
-#define XK_rightopentriangle                           0xacd
-#define XK_emopencircle                                0xace
-#define XK_emopenrectangle                             0xacf
-#define XK_leftsinglequotemark                         0xad0
-#define XK_rightsinglequotemark                        0xad1
-#define XK_leftdoublequotemark                         0xad2
-#define XK_rightdoublequotemark                        0xad3
-#define XK_prescription                                0xad4
-#define XK_minutes                                     0xad6
-#define XK_seconds                                     0xad7
-#define XK_latincross                                  0xad9
-#define XK_hexagram                                    0xada
-#define XK_filledrectbullet                            0xadb
-#define XK_filledlefttribullet                         0xadc
-#define XK_filledrighttribullet                        0xadd
-#define XK_emfilledcircle                              0xade
-#define XK_emfilledrect                                0xadf
-#define XK_enopencircbullet                            0xae0
-#define XK_enopensquarebullet                          0xae1
-#define XK_openrectbullet                              0xae2
-#define XK_opentribulletup                             0xae3
-#define XK_opentribulletdown                           0xae4
-#define XK_openstar                                    0xae5
-#define XK_enfilledcircbullet                          0xae6
-#define XK_enfilledsqbullet                            0xae7
-#define XK_filledtribulletup                           0xae8
-#define XK_filledtribulletdown                         0xae9
-#define XK_leftpointer                                 0xaea
-#define XK_rightpointer                                0xaeb
-#define XK_club                                        0xaec
-#define XK_diamond                                     0xaed
-#define XK_heart                                       0xaee
-#define XK_maltesecross                                0xaf0
-#define XK_dagger                                      0xaf1
-#define XK_doubledagger                                0xaf2
-#define XK_checkmark                                   0xaf3
-#define XK_ballotcross                                 0xaf4
-#define XK_musicalsharp                                0xaf5
-#define XK_musicalflat                                 0xaf6
-#define XK_malesymbol                                  0xaf7
-#define XK_femalesymbol                                0xaf8
-#define XK_telephone                                   0xaf9
-#define XK_telephonerecorder                           0xafa
-#define XK_phonographcopyright                         0xafb
-#define XK_caret                                       0xafc
-#define XK_singlelowquotemark                          0xafd
-#define XK_doublelowquotemark                          0xafe
-#define XK_cursor                                      0xaff
-#endif /* XK_PUBLISHING */
-
-/*
- *  APL
- *  Byte 3 = b
- */
-
-#ifdef XK_APL
-#define XK_leftcaret                                   0xba3
-#define XK_rightcaret                                  0xba6
-#define XK_downcaret                                   0xba8
-#define XK_upcaret                                     0xba9
-#define XK_overbar                                     0xbc0
-#define XK_downtack                                    0xbc2
-#define XK_upshoe                                      0xbc3
-#define XK_downstile                                   0xbc4
-#define XK_underbar                                    0xbc6
-#define XK_jot                                         0xbca
-#define XK_quad                                        0xbcc
-#define XK_uptack                                      0xbce
-#define XK_circle                                      0xbcf
-#define XK_upstile                                     0xbd3
-#define XK_downshoe                                    0xbd6
-#define XK_rightshoe                                   0xbd8
-#define XK_leftshoe                                    0xbda
-#define XK_lefttack                                    0xbdc
-#define XK_righttack                                   0xbfc
-#endif /* XK_APL */
-
-/*
- * Hebrew
- * Byte 3 = c
- */
-
-#ifdef XK_HEBREW
-#define XK_hebrew_doublelowline                        0xcdf
-#define XK_hebrew_aleph                                0xce0
-#define XK_hebrew_bet                                  0xce1
-#define XK_hebrew_beth                                 0xce1  /* deprecated */
-#define XK_hebrew_gimel                                0xce2
-#define XK_hebrew_gimmel                               0xce2  /* deprecated */
-#define XK_hebrew_dalet                                0xce3
-#define XK_hebrew_daleth                               0xce3  /* deprecated */
-#define XK_hebrew_he                                   0xce4
-#define XK_hebrew_waw                                  0xce5
-#define XK_hebrew_zain                                 0xce6
-#define XK_hebrew_zayin                                0xce6  /* deprecated */
-#define XK_hebrew_chet                                 0xce7
-#define XK_hebrew_het                                  0xce7  /* deprecated */
-#define XK_hebrew_tet                                  0xce8
-#define XK_hebrew_teth                                 0xce8  /* deprecated */
-#define XK_hebrew_yod                                  0xce9
-#define XK_hebrew_finalkaph                            0xcea
-#define XK_hebrew_kaph                                 0xceb
-#define XK_hebrew_lamed                                0xcec
-#define XK_hebrew_finalmem                             0xced
-#define XK_hebrew_mem                                  0xcee
-#define XK_hebrew_finalnun                             0xcef
-#define XK_hebrew_nun                                  0xcf0
-#define XK_hebrew_samech                               0xcf1
-#define XK_hebrew_samekh                               0xcf1  /* deprecated */
-#define XK_hebrew_ayin                                 0xcf2
-#define XK_hebrew_finalpe                              0xcf3
-#define XK_hebrew_pe                                   0xcf4
-#define XK_hebrew_finalzade                            0xcf5
-#define XK_hebrew_finalzadi                            0xcf5  /* deprecated */
-#define XK_hebrew_zade                                 0xcf6
-#define XK_hebrew_zadi                                 0xcf6  /* deprecated */
-#define XK_hebrew_qoph                                 0xcf7
-#define XK_hebrew_kuf                                  0xcf7  /* deprecated */
-#define XK_hebrew_resh                                 0xcf8
-#define XK_hebrew_shin                                 0xcf9
-#define XK_hebrew_taw                                  0xcfa
-#define XK_hebrew_taf                                  0xcfa  /* deprecated */
-#define XK_Hebrew_switch        0xFF7E  /* Alias for mode_switch */
-#endif /* XK_HEBREW */
-
-/*
- * Thai
- * Byte 3 = d
- */
-
-#ifdef XK_THAI
-#define XK_Thai_kokai					0xda1
-#define XK_Thai_khokhai					0xda2
-#define XK_Thai_khokhuat				0xda3
-#define XK_Thai_khokhwai				0xda4
-#define XK_Thai_khokhon					0xda5
-#define XK_Thai_khorakhang			        0xda6  
-#define XK_Thai_ngongu					0xda7  
-#define XK_Thai_chochan					0xda8  
-#define XK_Thai_choching				0xda9   
-#define XK_Thai_chochang				0xdaa  
-#define XK_Thai_soso					0xdab
-#define XK_Thai_chochoe					0xdac
-#define XK_Thai_yoying					0xdad
-#define XK_Thai_dochada					0xdae
-#define XK_Thai_topatak					0xdaf
-#define XK_Thai_thothan					0xdb0
-#define XK_Thai_thonangmontho			        0xdb1
-#define XK_Thai_thophuthao			        0xdb2
-#define XK_Thai_nonen					0xdb3
-#define XK_Thai_dodek					0xdb4
-#define XK_Thai_totao					0xdb5
-#define XK_Thai_thothung				0xdb6
-#define XK_Thai_thothahan				0xdb7
-#define XK_Thai_thothong	 			0xdb8
-#define XK_Thai_nonu					0xdb9
-#define XK_Thai_bobaimai				0xdba
-#define XK_Thai_popla					0xdbb
-#define XK_Thai_phophung				0xdbc
-#define XK_Thai_fofa					0xdbd
-#define XK_Thai_phophan					0xdbe
-#define XK_Thai_fofan					0xdbf
-#define XK_Thai_phosamphao			        0xdc0
-#define XK_Thai_moma					0xdc1
-#define XK_Thai_yoyak					0xdc2
-#define XK_Thai_rorua					0xdc3
-#define XK_Thai_ru					0xdc4
-#define XK_Thai_loling					0xdc5
-#define XK_Thai_lu					0xdc6
-#define XK_Thai_wowaen					0xdc7
-#define XK_Thai_sosala					0xdc8
-#define XK_Thai_sorusi					0xdc9
-#define XK_Thai_sosua					0xdca
-#define XK_Thai_hohip					0xdcb
-#define XK_Thai_lochula					0xdcc
-#define XK_Thai_oang					0xdcd
-#define XK_Thai_honokhuk				0xdce
-#define XK_Thai_paiyannoi				0xdcf
-#define XK_Thai_saraa					0xdd0
-#define XK_Thai_maihanakat				0xdd1
-#define XK_Thai_saraaa					0xdd2
-#define XK_Thai_saraam					0xdd3
-#define XK_Thai_sarai					0xdd4   
-#define XK_Thai_saraii					0xdd5   
-#define XK_Thai_saraue					0xdd6    
-#define XK_Thai_sarauee					0xdd7    
-#define XK_Thai_sarau					0xdd8    
-#define XK_Thai_sarauu					0xdd9   
-#define XK_Thai_phinthu					0xdda
-#define XK_Thai_maihanakat_maitho   			0xdde
-#define XK_Thai_baht					0xddf
-#define XK_Thai_sarae					0xde0    
-#define XK_Thai_saraae					0xde1
-#define XK_Thai_sarao					0xde2
-#define XK_Thai_saraaimaimuan				0xde3   
-#define XK_Thai_saraaimaimalai				0xde4  
-#define XK_Thai_lakkhangyao				0xde5
-#define XK_Thai_maiyamok				0xde6
-#define XK_Thai_maitaikhu				0xde7
-#define XK_Thai_maiek					0xde8   
-#define XK_Thai_maitho					0xde9
-#define XK_Thai_maitri					0xdea
-#define XK_Thai_maichattawa				0xdeb
-#define XK_Thai_thanthakhat				0xdec
-#define XK_Thai_nikhahit				0xded
-#define XK_Thai_leksun					0xdf0 
-#define XK_Thai_leknung					0xdf1  
-#define XK_Thai_leksong					0xdf2 
-#define XK_Thai_leksam					0xdf3
-#define XK_Thai_leksi					0xdf4  
-#define XK_Thai_lekha					0xdf5  
-#define XK_Thai_lekhok					0xdf6  
-#define XK_Thai_lekchet					0xdf7  
-#define XK_Thai_lekpaet					0xdf8  
-#define XK_Thai_lekkao					0xdf9 
-#endif /* XK_THAI */
-
-/*
- *   Korean
- *   Byte 3 = e
- */
-
-#ifdef XK_KOREAN
-
-#define XK_Hangul		0xff31    /* Hangul start/stop(toggle) */
-#define XK_Hangul_Start		0xff32    /* Hangul start */
-#define XK_Hangul_End		0xff33    /* Hangul end, English start */
-#define XK_Hangul_Hanja		0xff34    /* Start Hangul->Hanja Conversion */
-#define XK_Hangul_Jamo		0xff35    /* Hangul Jamo mode */
-#define XK_Hangul_Romaja	0xff36    /* Hangul Romaja mode */
-#define XK_Hangul_Codeinput	0xff37    /* Hangul code input mode */
-#define XK_Hangul_Jeonja	0xff38    /* Jeonja mode */
-#define XK_Hangul_Banja		0xff39    /* Banja mode */
-#define XK_Hangul_PreHanja	0xff3a    /* Pre Hanja conversion */
-#define XK_Hangul_PostHanja	0xff3b    /* Post Hanja conversion */
-#define XK_Hangul_SingleCandidate	0xff3c    /* Single candidate */
-#define XK_Hangul_MultipleCandidate	0xff3d    /* Multiple candidate */
-#define XK_Hangul_PreviousCandidate	0xff3e    /* Previous candidate */
-#define XK_Hangul_Special	0xff3f    /* Special symbols */
-#define XK_Hangul_switch	0xFF7E    /* Alias for mode_switch */
-
-/* Hangul Consonant Characters */
-#define XK_Hangul_Kiyeog				0xea1
-#define XK_Hangul_SsangKiyeog				0xea2
-#define XK_Hangul_KiyeogSios				0xea3
-#define XK_Hangul_Nieun					0xea4
-#define XK_Hangul_NieunJieuj				0xea5
-#define XK_Hangul_NieunHieuh				0xea6
-#define XK_Hangul_Dikeud				0xea7
-#define XK_Hangul_SsangDikeud				0xea8
-#define XK_Hangul_Rieul					0xea9
-#define XK_Hangul_RieulKiyeog				0xeaa
-#define XK_Hangul_RieulMieum				0xeab
-#define XK_Hangul_RieulPieub				0xeac
-#define XK_Hangul_RieulSios				0xead
-#define XK_Hangul_RieulTieut				0xeae
-#define XK_Hangul_RieulPhieuf				0xeaf
-#define XK_Hangul_RieulHieuh				0xeb0
-#define XK_Hangul_Mieum					0xeb1
-#define XK_Hangul_Pieub					0xeb2
-#define XK_Hangul_SsangPieub				0xeb3
-#define XK_Hangul_PieubSios				0xeb4
-#define XK_Hangul_Sios					0xeb5
-#define XK_Hangul_SsangSios				0xeb6
-#define XK_Hangul_Ieung					0xeb7
-#define XK_Hangul_Jieuj					0xeb8
-#define XK_Hangul_SsangJieuj				0xeb9
-#define XK_Hangul_Cieuc					0xeba
-#define XK_Hangul_Khieuq				0xebb
-#define XK_Hangul_Tieut					0xebc
-#define XK_Hangul_Phieuf				0xebd
-#define XK_Hangul_Hieuh					0xebe
-
-/* Hangul Vowel Characters */
-#define XK_Hangul_A					0xebf
-#define XK_Hangul_AE					0xec0
-#define XK_Hangul_YA					0xec1
-#define XK_Hangul_YAE					0xec2
-#define XK_Hangul_EO					0xec3
-#define XK_Hangul_E					0xec4
-#define XK_Hangul_YEO					0xec5
-#define XK_Hangul_YE					0xec6
-#define XK_Hangul_O					0xec7
-#define XK_Hangul_WA					0xec8
-#define XK_Hangul_WAE					0xec9
-#define XK_Hangul_OE					0xeca
-#define XK_Hangul_YO					0xecb
-#define XK_Hangul_U					0xecc
-#define XK_Hangul_WEO					0xecd
-#define XK_Hangul_WE					0xece
-#define XK_Hangul_WI					0xecf
-#define XK_Hangul_YU					0xed0
-#define XK_Hangul_EU					0xed1
-#define XK_Hangul_YI					0xed2
-#define XK_Hangul_I					0xed3
-
-/* Hangul syllable-final (JongSeong) Characters */
-#define XK_Hangul_J_Kiyeog				0xed4
-#define XK_Hangul_J_SsangKiyeog				0xed5
-#define XK_Hangul_J_KiyeogSios				0xed6
-#define XK_Hangul_J_Nieun				0xed7
-#define XK_Hangul_J_NieunJieuj				0xed8
-#define XK_Hangul_J_NieunHieuh				0xed9
-#define XK_Hangul_J_Dikeud				0xeda
-#define XK_Hangul_J_Rieul				0xedb
-#define XK_Hangul_J_RieulKiyeog				0xedc
-#define XK_Hangul_J_RieulMieum				0xedd
-#define XK_Hangul_J_RieulPieub				0xede
-#define XK_Hangul_J_RieulSios				0xedf
-#define XK_Hangul_J_RieulTieut				0xee0
-#define XK_Hangul_J_RieulPhieuf				0xee1
-#define XK_Hangul_J_RieulHieuh				0xee2
-#define XK_Hangul_J_Mieum				0xee3
-#define XK_Hangul_J_Pieub				0xee4
-#define XK_Hangul_J_PieubSios				0xee5
-#define XK_Hangul_J_Sios				0xee6
-#define XK_Hangul_J_SsangSios				0xee7
-#define XK_Hangul_J_Ieung				0xee8
-#define XK_Hangul_J_Jieuj				0xee9
-#define XK_Hangul_J_Cieuc				0xeea
-#define XK_Hangul_J_Khieuq				0xeeb
-#define XK_Hangul_J_Tieut				0xeec
-#define XK_Hangul_J_Phieuf				0xeed
-#define XK_Hangul_J_Hieuh				0xeee
-
-/* Ancient Hangul Consonant Characters */
-#define XK_Hangul_RieulYeorinHieuh			0xeef
-#define XK_Hangul_SunkyeongeumMieum			0xef0
-#define XK_Hangul_SunkyeongeumPieub			0xef1
-#define XK_Hangul_PanSios				0xef2
-#define XK_Hangul_KkogjiDalrinIeung			0xef3
-#define XK_Hangul_SunkyeongeumPhieuf			0xef4
-#define XK_Hangul_YeorinHieuh				0xef5
-
-/* Ancient Hangul Vowel Characters */
-#define XK_Hangul_AraeA					0xef6
-#define XK_Hangul_AraeAE				0xef7
-
-/* Ancient Hangul syllable-final (JongSeong) Characters */
-#define XK_Hangul_J_PanSios				0xef8
-#define XK_Hangul_J_KkogjiDalrinIeung			0xef9
-#define XK_Hangul_J_YeorinHieuh				0xefa
-
-/* Korean currency symbol */
-#define XK_Korean_Won					0xeff
-
-#endif /* XK_KOREAN */
-
-/* Euro currency symbol */
-#define XK_EuroSign 0x20ac
-
-#endif
diff -urN remmina-plugins/vnc/libvncserver/rfb/rfb.h remmina-plugins/vnc/libvncserver/rfb/rfb.h
--- remmina-plugins/vnc/libvncserver/rfb/rfb.h	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins/vnc/libvncserver/rfb/rfb.h	1970-01-01 10:00:00.000000000 +1000
@@ -1,1182 +0,0 @@
-#ifndef RFB_H
-#define RFB_H
-/**
- * @defgroup libvncserver_api LibVNCServer API Reference
- * @{
- */
-
-/**
- * @file rfb.h
- */
-
-/*
- *  Copyright (C) 2005 Rohit Kumar <rokumar@novell.com>,
- *                     Johannes E. Schindelin <johannes.schindelin@gmx.de>
- *  Copyright (C) 2002 RealVNC Ltd.
- *  OSXvnc Copyright (C) 2001 Dan McGuirk <mcguirk@incompleteness.net>.
- *  Original Xvnc code Copyright (C) 1999 AT&T Laboratories Cambridge.  
- *  All Rights Reserved.
- *
- *  This is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This software is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this software; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
- *  USA.
- */
-
-#if(defined __cplusplus)
-extern "C"
-{
-#endif
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <rfb/rfbproto.h>
-
-#ifdef LIBVNCSERVER_HAVE_SYS_TYPES_H
-#include <sys/types.h>
-#endif
-
-#ifdef __MINGW32__
-#undef SOCKET
-#include <winsock2.h>
-#endif
-
-#ifdef LIBVNCSERVER_HAVE_LIBPTHREAD
-#include <pthread.h>
-#if 0 /* debugging */
-#define LOCK(mutex) (rfbLog("%s:%d LOCK(%s,0x%x)\n",__FILE__,__LINE__,#mutex,&(mutex)), pthread_mutex_lock(&(mutex)))
-#define UNLOCK(mutex) (rfbLog("%s:%d UNLOCK(%s,0x%x)\n",__FILE__,__LINE__,#mutex,&(mutex)), pthread_mutex_unlock(&(mutex)))
-#define MUTEX(mutex) pthread_mutex_t (mutex)
-#define INIT_MUTEX(mutex) (rfbLog("%s:%d INIT_MUTEX(%s,0x%x)\n",__FILE__,__LINE__,#mutex,&(mutex)), pthread_mutex_init(&(mutex),NULL))
-#define TINI_MUTEX(mutex) (rfbLog("%s:%d TINI_MUTEX(%s)\n",__FILE__,__LINE__,#mutex), pthread_mutex_destroy(&(mutex)))
-#define TSIGNAL(cond) (rfbLog("%s:%d TSIGNAL(%s)\n",__FILE__,__LINE__,#cond), pthread_cond_signal(&(cond)))
-#define WAIT(cond,mutex) (rfbLog("%s:%d WAIT(%s,%s)\n",__FILE__,__LINE__,#cond,#mutex), pthread_cond_wait(&(cond),&(mutex)))
-#define COND(cond) pthread_cond_t (cond)
-#define INIT_COND(cond) (rfbLog("%s:%d INIT_COND(%s)\n",__FILE__,__LINE__,#cond), pthread_cond_init(&(cond),NULL))
-#define TINI_COND(cond) (rfbLog("%s:%d TINI_COND(%s)\n",__FILE__,__LINE__,#cond), pthread_cond_destroy(&(cond)))
-#define IF_PTHREADS(x) x
-#else
-#if !NONETWORK
-#define LOCK(mutex) pthread_mutex_lock(&(mutex));
-#define UNLOCK(mutex) pthread_mutex_unlock(&(mutex));
-#endif
-#define MUTEX(mutex) pthread_mutex_t (mutex)
-#define INIT_MUTEX(mutex) pthread_mutex_init(&(mutex),NULL)
-#define TINI_MUTEX(mutex) pthread_mutex_destroy(&(mutex))
-#define TSIGNAL(cond) pthread_cond_signal(&(cond))
-#define WAIT(cond,mutex) pthread_cond_wait(&(cond),&(mutex))
-#define COND(cond) pthread_cond_t (cond)
-#define INIT_COND(cond) pthread_cond_init(&(cond),NULL)
-#define TINI_COND(cond) pthread_cond_destroy(&(cond))
-#define IF_PTHREADS(x) x
-#endif
-#else
-#define LOCK(mutex)
-#define UNLOCK(mutex)
-#define MUTEX(mutex)
-#define INIT_MUTEX(mutex)
-#define TINI_MUTEX(mutex)
-#define TSIGNAL(cond)
-#define WAIT(cond,mutex) this_is_unsupported
-#define COND(cond)
-#define INIT_COND(cond)
-#define TINI_COND(cond)
-#define IF_PTHREADS(x)
-#endif
-
-/* end of stuff for autoconf */
-
-/* if you use pthreads, but don't define LIBVNCSERVER_HAVE_LIBPTHREAD, the structs
-   get all mixed up. So this gives a linker error reminding you to compile
-   the library and your application (at least the parts including rfb.h)
-   with the same support for pthreads. */
-#ifdef LIBVNCSERVER_HAVE_LIBPTHREAD
-#ifdef LIBVNCSERVER_HAVE_LIBZ
-#define rfbInitServer rfbInitServerWithPthreadsAndZRLE
-#else
-#define rfbInitServer rfbInitServerWithPthreadsButWithoutZRLE
-#endif
-#else
-#ifdef LIBVNCSERVER_HAVE_LIBZ
-#define rfbInitServer rfbInitServerWithoutPthreadsButWithZRLE
-#else
-#define rfbInitServer rfbInitServerWithoutPthreadsAndZRLE
-#endif
-#endif
-
-struct _rfbClientRec;
-struct _rfbScreenInfo;
-struct rfbCursor;
-
-enum rfbNewClientAction {
-	RFB_CLIENT_ACCEPT,
-	RFB_CLIENT_ON_HOLD,
-	RFB_CLIENT_REFUSE
-};
-
-enum rfbSocketState {
-	RFB_SOCKET_INIT,
-	RFB_SOCKET_READY,
-	RFB_SOCKET_SHUTDOWN
-};
-
-typedef void (*rfbKbdAddEventProcPtr) (rfbBool down, rfbKeySym keySym, struct _rfbClientRec* cl);
-typedef void (*rfbKbdReleaseAllKeysProcPtr) (struct _rfbClientRec* cl);
-typedef void (*rfbPtrAddEventProcPtr) (int buttonMask, int x, int y, struct _rfbClientRec* cl);
-typedef void (*rfbSetXCutTextProcPtr) (char* str,int len, struct _rfbClientRec* cl);
-typedef struct rfbCursor* (*rfbGetCursorProcPtr) (struct _rfbClientRec* pScreen);
-typedef rfbBool (*rfbSetTranslateFunctionProcPtr)(struct _rfbClientRec* cl);
-typedef rfbBool (*rfbPasswordCheckProcPtr)(struct _rfbClientRec* cl,const char* encryptedPassWord,int len);
-typedef enum rfbNewClientAction (*rfbNewClientHookPtr)(struct _rfbClientRec* cl);
-typedef void (*rfbDisplayHookPtr)(struct _rfbClientRec* cl);
-typedef void (*rfbDisplayFinishedHookPtr)(struct _rfbClientRec* cl, int result);
-/** support the capability to view the caps/num/scroll states of the X server */
-typedef int  (*rfbGetKeyboardLedStateHookPtr)(struct _rfbScreenInfo* screen);
-typedef rfbBool (*rfbXvpHookPtr)(struct _rfbClientRec* cl, uint8_t, uint8_t);
-/**
- * If x==1 and y==1 then set the whole display
- * else find the window underneath x and y and set the framebuffer to the dimensions
- * of that window
- */
-typedef void (*rfbSetSingleWindowProcPtr) (struct _rfbClientRec* cl, int x, int y);
-/**
- * Status determines if the X11 server permits input from the local user
- * status==0 or 1
- */
-typedef void (*rfbSetServerInputProcPtr) (struct _rfbClientRec* cl, int status);
-/**
- * Permit the server to allow or deny filetransfers.   This is defaulted to deny
- * It is called when a client initiates a connection to determine if it is permitted.
- */
-typedef int  (*rfbFileTransferPermitted) (struct _rfbClientRec* cl);
-/** Handle the textchat messages */
-typedef void (*rfbSetTextChat) (struct _rfbClientRec* cl, int length, char *string);
-
-typedef struct {
-  uint32_t count;
-  rfbBool is16; /**< is the data format short? */
-  union {
-    uint8_t* bytes;
-    uint16_t* shorts;
-  } data; /**< there have to be count*3 entries */
-} rfbColourMap;
-
-/**
- * Security handling (RFB protocol version 3.7)
- */
-
-typedef struct _rfbSecurity {
-	uint8_t type;
-	void (*handler)(struct _rfbClientRec* cl);
-	struct _rfbSecurity* next;
-} rfbSecurityHandler;
-
-/**
- * Protocol extension handling.
- */
-
-typedef struct _rfbProtocolExtension {
-	/** returns FALSE if extension should be deactivated for client.
-	   if newClient == NULL, it is always deactivated. */
-	rfbBool (*newClient)(struct _rfbClientRec* client, void** data);
-	/** returns FALSE if extension should be deactivated for client.
-	   if init == NULL, it stays activated. */
-	rfbBool (*init)(struct _rfbClientRec* client, void* data);
-	/** if pseudoEncodings is not NULL, it contains a 0 terminated
-	   list of the pseudo encodings handled by this extension. */
-	int *pseudoEncodings;
-	/** returns TRUE if that pseudo encoding is handled by the extension.
-	   encodingNumber==0 means "reset encodings". */
-	rfbBool (*enablePseudoEncoding)(struct _rfbClientRec* client,
-			void** data, int encodingNumber);
-	/** returns TRUE if message was handled */
-	rfbBool (*handleMessage)(struct _rfbClientRec* client,
-				void* data,
-				const rfbClientToServerMsg* message);
-	void (*close)(struct _rfbClientRec* client, void* data);
-	void (*usage)(void);
-	/** processArguments returns the number of handled arguments */
-	int (*processArgument)(int argc, char *argv[]);
-	struct _rfbProtocolExtension* next;
-} rfbProtocolExtension;
-
-typedef struct _rfbExtensionData {
-	rfbProtocolExtension* extension;
-	void* data;
-	struct _rfbExtensionData* next;
-} rfbExtensionData;
-
-/**
- * Per-screen (framebuffer) structure.  There can be as many as you wish,
- * each serving different clients. However, you have to call
- * rfbProcessEvents for each of these.
- */
-
-typedef struct _rfbScreenInfo
-{
-    /** this structure has children that are scaled versions of this screen */
-    struct _rfbScreenInfo *scaledScreenNext;
-    int scaledScreenRefCount;
-
-    int width;
-    int paddedWidthInBytes;
-    int height;
-    int depth;
-    int bitsPerPixel;
-    int sizeInBytes;
-
-    rfbPixel blackPixel;
-    rfbPixel whitePixel;
-
-    /**
-     * some screen specific data can be put into a struct where screenData
-     * points to. You need this if you have more than one screen at the
-     * same time while using the same functions.
-     */
-    void* screenData;
-
-    /* additions by libvncserver */
-
-    rfbPixelFormat serverFormat;
-    rfbColourMap colourMap; /**< set this if rfbServerFormat.trueColour==FALSE */
-    const char* desktopName;
-    char thisHost[255];
-
-    rfbBool autoPort;
-    int port;
-    SOCKET listenSock;
-    int maxSock;
-    int maxFd;
-#ifdef __MINGW32__
-    struct fd_set allFds;
-#else
-    fd_set allFds;
-#endif
-
-    enum rfbSocketState socketState;
-    SOCKET inetdSock;
-    rfbBool inetdInitDone;
-
-    int udpPort;
-    SOCKET udpSock;
-    struct _rfbClientRec* udpClient;
-    rfbBool udpSockConnected;
-    struct sockaddr_in udpRemoteAddr;
-
-    int maxClientWait;
-
-    /* http stuff */
-    rfbBool httpInitDone;
-    rfbBool httpEnableProxyConnect;
-    int httpPort;
-    char* httpDir;
-    SOCKET httpListenSock;
-    SOCKET httpSock;
-
-    rfbPasswordCheckProcPtr passwordCheck;
-    void* authPasswdData;
-    /** If rfbAuthPasswdData is given a list, this is the first
-        view only password. */
-    int authPasswdFirstViewOnly;
-
-    /** send only this many rectangles in one update */
-    int maxRectsPerUpdate;
-    /** this is the amount of milliseconds to wait at least before sending
-     * an update. */
-    int deferUpdateTime;
-#ifdef TODELETE
-    char* screen;
-#endif
-    rfbBool alwaysShared;
-    rfbBool neverShared;
-    rfbBool dontDisconnect;
-    struct _rfbClientRec* clientHead;
-    struct _rfbClientRec* pointerClient;  /**< "Mutex" for pointer events */
-
-
-    /* cursor */
-    int cursorX, cursorY,underCursorBufferLen;
-    char* underCursorBuffer;
-    rfbBool dontConvertRichCursorToXCursor;
-    struct rfbCursor* cursor;
-
-    /**
-     * the frameBuffer has to be supplied by the serving process.
-     * The buffer will not be freed by
-     */
-    char* frameBuffer;
-    rfbKbdAddEventProcPtr kbdAddEvent;
-    rfbKbdReleaseAllKeysProcPtr kbdReleaseAllKeys;
-    rfbPtrAddEventProcPtr ptrAddEvent;
-    rfbSetXCutTextProcPtr setXCutText;
-    rfbGetCursorProcPtr getCursorPtr;
-    rfbSetTranslateFunctionProcPtr setTranslateFunction;
-    rfbSetSingleWindowProcPtr setSingleWindow;
-    rfbSetServerInputProcPtr  setServerInput;
-    rfbFileTransferPermitted  getFileTransferPermission;
-    rfbSetTextChat            setTextChat;
-
-    /** newClientHook is called just after a new client is created */
-    rfbNewClientHookPtr newClientHook;
-    /** displayHook is called just before a frame buffer update */
-    rfbDisplayHookPtr displayHook;
-
-    /** These hooks are called to pass keyboard state back to the client */
-    rfbGetKeyboardLedStateHookPtr getKeyboardLedStateHook;
-
-#ifdef LIBVNCSERVER_HAVE_LIBPTHREAD
-    MUTEX(cursorMutex);
-    rfbBool backgroundLoop;
-#endif
-
-    /** if TRUE, an ignoring signal handler is installed for SIGPIPE */
-    rfbBool ignoreSIGPIPE;
-
-    /** if not zero, only a slice of this height is processed every time
-     * an update should be sent. This should make working on a slow
-     * link more interactive. */
-    int progressiveSliceHeight;
-
-    in_addr_t listenInterface;
-    int deferPtrUpdateTime;
-
-    /** handle as many input events as possible (default off) */
-    rfbBool handleEventsEagerly;
-
-    /** rfbEncodingServerIdentity */
-    char *versionString;
-
-    /** What does the server tell the new clients which version it supports */
-    int protocolMajorVersion;
-    int protocolMinorVersion;
-
-    /** command line authorization of file transfers */
-    rfbBool permitFileTransfer;
-
-    /** displayFinishedHook is called just after a frame buffer update */
-    rfbDisplayFinishedHookPtr displayFinishedHook;
-    /** xvpHook is called to handle an xvp client message */
-    rfbXvpHookPtr xvpHook;
-} rfbScreenInfo, *rfbScreenInfoPtr;
-
-
-/**
- * rfbTranslateFnType is the type of translation functions.
- */
-
-typedef void (*rfbTranslateFnType)(char *table, rfbPixelFormat *in,
-                                   rfbPixelFormat *out,
-                                   char *iptr, char *optr,
-                                   int bytesBetweenInputLines,
-                                   int width, int height);
-
-
-/* region stuff */
-
-struct sraRegion;
-typedef struct sraRegion* sraRegionPtr;
-
-/*
- * Per-client structure.
- */
-
-typedef void (*ClientGoneHookPtr)(struct _rfbClientRec* cl);
-
-typedef struct _rfbFileTransferData {
-  int fd;
-  int compressionEnabled;
-  int fileSize;
-  int numPackets;
-  int receiving;
-  int sending;
-} rfbFileTransferData;
-
-
-typedef struct _rfbStatList {
-    uint32_t type;
-    uint32_t sentCount;
-    uint32_t bytesSent;
-    uint32_t bytesSentIfRaw;
-    uint32_t rcvdCount;
-    uint32_t bytesRcvd;
-    uint32_t bytesRcvdIfRaw;
-    struct _rfbStatList *Next;
-} rfbStatList;
-
-typedef struct _rfbClientRec {
-
-    /** back pointer to the screen */
-    rfbScreenInfoPtr screen;
-
-     /** points to a scaled version of the screen buffer in cl->scaledScreenList */
-     rfbScreenInfoPtr scaledScreen;
-     /** how did the client tell us it wanted the screen changed?  Ultra style or palm style? */
-     rfbBool PalmVNC;
-
-
-    /** private data. You should put any application client specific data
-     * into a struct and let clientData point to it. Don't forget to
-     * free the struct via clientGoneHook!
-     *
-     * This is useful if the IO functions have to behave client specific.
-     */
-    void* clientData;
-    ClientGoneHookPtr clientGoneHook;
-
-    SOCKET sock;
-    char *host;
-
-    /* RFB protocol minor version number */
-    int protocolMajorVersion;
-    int protocolMinorVersion;
-
-#ifdef LIBVNCSERVER_HAVE_LIBPTHREAD
-    pthread_t client_thread;
-#endif
-                                /** Possible client states: */
-    enum {
-        RFB_PROTOCOL_VERSION,   /**< establishing protocol version */
-	RFB_SECURITY_TYPE,      /**< negotiating security (RFB v.3.7) */
-        RFB_AUTHENTICATION,     /**< authenticating */
-        RFB_INITIALISATION,     /**< sending initialisation messages */
-        RFB_NORMAL              /**< normal protocol messages */
-    } state;
-
-    rfbBool reverseConnection;
-    rfbBool onHold;
-    rfbBool readyForSetColourMapEntries;
-    rfbBool useCopyRect;
-    int preferredEncoding;
-    int correMaxWidth, correMaxHeight;
-
-    rfbBool viewOnly;
-
-    /* The following member is only used during VNC authentication */
-    uint8_t authChallenge[CHALLENGESIZE];
-
-    /* The following members represent the update needed to get the client's
-       framebuffer from its present state to the current state of our
-       framebuffer.
-
-       If the client does not accept CopyRect encoding then the update is
-       simply represented as the region of the screen which has been modified
-       (modifiedRegion).
-
-       If the client does accept CopyRect encoding, then the update consists of
-       two parts.  First we have a single copy from one region of the screen to
-       another (the destination of the copy is copyRegion), and second we have
-       the region of the screen which has been modified in some other way
-       (modifiedRegion).
-
-       Although the copy is of a single region, this region may have many
-       rectangles.  When sending an update, the copyRegion is always sent
-       before the modifiedRegion.  This is because the modifiedRegion may
-       overlap parts of the screen which are in the source of the copy.
-
-       In fact during normal processing, the modifiedRegion may even overlap
-       the destination copyRegion.  Just before an update is sent we remove
-       from the copyRegion anything in the modifiedRegion. */
-
-    sraRegionPtr copyRegion;	/**< the destination region of the copy */
-    int copyDX, copyDY;		/**< the translation by which the copy happens */
-
-    sraRegionPtr modifiedRegion;
-
-    /** As part of the FramebufferUpdateRequest, a client can express interest
-       in a subrectangle of the whole framebuffer.  This is stored in the
-       requestedRegion member.  In the normal case this is the whole
-       framebuffer if the client is ready, empty if it's not. */
-
-    sraRegionPtr requestedRegion;
-
-    /** The following member represents the state of the "deferred update" timer
-       - when the framebuffer is modified and the client is ready, in most
-       cases it is more efficient to defer sending the update by a few
-       milliseconds so that several changes to the framebuffer can be combined
-       into a single update. */
-
-      struct timeval startDeferring;
-      struct timeval startPtrDeferring;
-      int lastPtrX;
-      int lastPtrY;
-      int lastPtrButtons;
-
-    /** translateFn points to the translation function which is used to copy
-       and translate a rectangle from the framebuffer to an output buffer. */
-
-    rfbTranslateFnType translateFn;
-    char *translateLookupTable;
-    rfbPixelFormat format;
-
-    /**
-     * UPDATE_BUF_SIZE must be big enough to send at least one whole line of the
-     * framebuffer.  So for a max screen width of say 2K with 32-bit pixels this
-     * means 8K minimum.
-     */
-
-#define UPDATE_BUF_SIZE 30000
-
-    char updateBuf[UPDATE_BUF_SIZE];
-    int ublen;
-
-    /* statistics */
-    struct _rfbStatList *statEncList;
-    struct _rfbStatList *statMsgList;
-    int rawBytesEquivalent;
-    int bytesSent;
-
-#ifdef LIBVNCSERVER_HAVE_LIBZ
-    /* zlib encoding -- necessary compression state info per client */
-
-    struct z_stream_s compStream;
-    rfbBool compStreamInited;
-    uint32_t zlibCompressLevel;
-    /** the quality level is also used by ZYWRLE */
-    int tightQualityLevel;
-
-#ifdef LIBVNCSERVER_HAVE_LIBJPEG
-    /* tight encoding -- preserve zlib streams' state for each client */
-    z_stream zsStruct[4];
-    rfbBool zsActive[4];
-    int zsLevel[4];
-    int tightCompressLevel;
-#endif
-#endif
-
-    /* Ultra Encoding support */
-    rfbBool compStreamInitedLZO;
-    char *lzoWrkMem;
-
-    rfbFileTransferData fileTransfer;
-
-    int     lastKeyboardLedState;     /**< keep track of last value so we can send *change* events */
-    rfbBool enableSupportedMessages;  /**< client supports SupportedMessages encoding */
-    rfbBool enableSupportedEncodings; /**< client supports SupportedEncodings encoding */
-    rfbBool enableServerIdentity;     /**< client supports ServerIdentity encoding */
-    rfbBool enableKeyboardLedState;   /**< client supports KeyboardState encoding */
-    rfbBool enableLastRectEncoding;   /**< client supports LastRect encoding */
-    rfbBool enableCursorShapeUpdates; /**< client supports cursor shape updates */
-    rfbBool enableCursorPosUpdates;   /**< client supports cursor position updates */
-    rfbBool useRichCursorEncoding;    /**< rfbEncodingRichCursor is preferred */
-    rfbBool cursorWasChanged;         /**< cursor shape update should be sent */
-    rfbBool cursorWasMoved;           /**< cursor position update should be sent */
-    int cursorX,cursorY;	      /**< the coordinates of the cursor,
-					 if enableCursorShapeUpdates = FALSE */
-
-    rfbBool useNewFBSize;             /**< client supports NewFBSize encoding */
-    rfbBool newFBSizePending;         /**< framebuffer size was changed */
-
-    struct _rfbClientRec *prev;
-    struct _rfbClientRec *next;
-
-#ifdef LIBVNCSERVER_HAVE_LIBPTHREAD
-    /** whenever a client is referenced, the refCount has to be incremented
-       and afterwards decremented, so that the client is not cleaned up
-       while being referenced.
-       Use the functions rfbIncrClientRef(cl) and rfbDecrClientRef(cl);
-    */
-    int refCount;
-    MUTEX(refCountMutex);
-    COND(deleteCond);
-
-    MUTEX(outputMutex);
-    MUTEX(updateMutex);
-    COND(updateCond);
-#endif
-
-#ifdef LIBVNCSERVER_HAVE_LIBZ
-    void* zrleData;
-    int zywrleLevel;
-    int zywrleBuf[rfbZRLETileWidth * rfbZRLETileHeight];
-#endif
-
-    /** if progressive updating is on, this variable holds the current
-     * y coordinate of the progressive slice. */
-    int progressiveSliceY;
-
-    rfbExtensionData* extensions;
-
-    /** for threaded zrle */
-    char *zrleBeforeBuf;
-    void *paletteHelper;
-
-    /** for thread safety for rfbSendFBUpdate() */
-#ifdef LIBVNCSERVER_HAVE_LIBPTHREAD
-#define LIBVNCSERVER_SEND_MUTEX
-    MUTEX(sendMutex);
-#endif
-
-  /* buffers to hold pixel data before and after encoding.
-     per-client for thread safety */
-  char *beforeEncBuf;
-  int beforeEncBufSize;
-  char *afterEncBuf;
-  int afterEncBufSize;
-  int afterEncBufLen;
-} rfbClientRec, *rfbClientPtr;
-
-/**
- * This macro is used to test whether there is a framebuffer update needing to
- * be sent to the client.
- */
-
-#define FB_UPDATE_PENDING(cl)                                              \
-     (((cl)->enableCursorShapeUpdates && (cl)->cursorWasChanged) ||        \
-     (((cl)->enableCursorShapeUpdates == FALSE &&                          \
-       ((cl)->cursorX != (cl)->screen->cursorX ||                          \
-	(cl)->cursorY != (cl)->screen->cursorY))) ||                       \
-     ((cl)->useNewFBSize && (cl)->newFBSizePending) ||                     \
-     ((cl)->enableCursorPosUpdates && (cl)->cursorWasMoved) ||             \
-     !sraRgnEmpty((cl)->copyRegion) || !sraRgnEmpty((cl)->modifiedRegion))
-
-/*
- * Macros for endian swapping.
- */
-
-#define Swap16(s) ((((s) & 0xff) << 8) | (((s) >> 8) & 0xff))
-
-#define Swap24(l) ((((l) & 0xff) << 16) | (((l) >> 16) & 0xff) | \
-                   (((l) & 0x00ff00)))
-
-#define Swap32(l) (((l) >> 24) | \
-                   (((l) & 0x00ff0000) >> 8)  | \
-                   (((l) & 0x0000ff00) << 8)  | \
-                   ((l) << 24))
-
-
-extern char rfbEndianTest;
-
-#define Swap16IfLE(s) (rfbEndianTest ? Swap16(s) : (s))
-#define Swap24IfLE(l) (rfbEndianTest ? Swap24(l) : (l))
-#define Swap32IfLE(l) (rfbEndianTest ? Swap32(l) : (l))
-
-/* UltraVNC uses some windows structures unmodified, so the viewer expects LittleEndian Data */
-#define Swap16IfBE(s) (rfbEndianTest ? (s) : Swap16(s))
-#define Swap24IfBE(l) (rfbEndianTest ? (l) : Swap24(l))
-#define Swap32IfBE(l) (rfbEndianTest ? (l) : Swap32(l))
-
-/* sockets.c */
-
-extern int rfbMaxClientWait;
-
-extern void rfbInitSockets(rfbScreenInfoPtr rfbScreen);
-extern void rfbShutdownSockets(rfbScreenInfoPtr rfbScreen);
-extern void rfbDisconnectUDPSock(rfbScreenInfoPtr rfbScreen);
-extern void rfbCloseClient(rfbClientPtr cl);
-extern int rfbReadExact(rfbClientPtr cl, char *buf, int len);
-extern int rfbReadExactTimeout(rfbClientPtr cl, char *buf, int len,int timeout);
-extern int rfbWriteExact(rfbClientPtr cl, const char *buf, int len);
-extern int rfbCheckFds(rfbScreenInfoPtr rfbScreen,long usec);
-extern int rfbConnect(rfbScreenInfoPtr rfbScreen, char* host, int port);
-extern int rfbConnectToTcpAddr(char* host, int port);
-extern int rfbListenOnTCPPort(int port, in_addr_t iface);
-extern int rfbListenOnUDPPort(int port, in_addr_t iface);
-extern int rfbStringToAddr(char* string,in_addr_t* addr);
-extern rfbBool rfbSetNonBlocking(int sock);
-
-/* rfbserver.c */
-
-/* Routines to iterate over the client list in a thread-safe way.
-   Only a single iterator can be in use at a time process-wide. */
-typedef struct rfbClientIterator *rfbClientIteratorPtr;
-
-extern void rfbClientListInit(rfbScreenInfoPtr rfbScreen);
-extern rfbClientIteratorPtr rfbGetClientIterator(rfbScreenInfoPtr rfbScreen);
-extern rfbClientPtr rfbClientIteratorNext(rfbClientIteratorPtr iterator);
-extern void rfbReleaseClientIterator(rfbClientIteratorPtr iterator);
-extern void rfbIncrClientRef(rfbClientPtr cl);
-extern void rfbDecrClientRef(rfbClientPtr cl);
-
-extern void rfbNewClientConnection(rfbScreenInfoPtr rfbScreen,int sock);
-extern rfbClientPtr rfbNewClient(rfbScreenInfoPtr rfbScreen,int sock);
-extern rfbClientPtr rfbNewUDPClient(rfbScreenInfoPtr rfbScreen);
-extern rfbClientPtr rfbReverseConnection(rfbScreenInfoPtr rfbScreen,char *host, int port);
-extern void rfbClientConnectionGone(rfbClientPtr cl);
-extern void rfbProcessClientMessage(rfbClientPtr cl);
-extern void rfbClientConnFailed(rfbClientPtr cl, char *reason);
-extern void rfbNewUDPConnection(rfbScreenInfoPtr rfbScreen,int sock);
-extern void rfbProcessUDPInput(rfbScreenInfoPtr rfbScreen);
-extern rfbBool rfbSendFramebufferUpdate(rfbClientPtr cl, sraRegionPtr updateRegion);
-extern rfbBool rfbSendRectEncodingRaw(rfbClientPtr cl, int x,int y,int w,int h);
-extern rfbBool rfbSendUpdateBuf(rfbClientPtr cl);
-extern void rfbSendServerCutText(rfbScreenInfoPtr rfbScreen,char *str, int len);
-extern rfbBool rfbSendCopyRegion(rfbClientPtr cl,sraRegionPtr reg,int dx,int dy);
-extern rfbBool rfbSendLastRectMarker(rfbClientPtr cl);
-extern rfbBool rfbSendNewFBSize(rfbClientPtr cl, int w, int h);
-extern rfbBool rfbSendSetColourMapEntries(rfbClientPtr cl, int firstColour, int nColours);
-extern void rfbSendBell(rfbScreenInfoPtr rfbScreen);
-
-extern char *rfbProcessFileTransferReadBuffer(rfbClientPtr cl, uint32_t length);
-extern rfbBool rfbSendFileTransferChunk(rfbClientPtr cl);
-extern rfbBool rfbSendDirContent(rfbClientPtr cl, int length, char *buffer);
-extern rfbBool rfbSendFileTransferMessage(rfbClientPtr cl, uint8_t contentType, uint8_t contentParam, uint32_t size, uint32_t length, char *buffer);
-extern char *rfbProcessFileTransferReadBuffer(rfbClientPtr cl, uint32_t length);
-extern rfbBool rfbProcessFileTransfer(rfbClientPtr cl, uint8_t contentType, uint8_t contentParam, uint32_t size, uint32_t length);
-
-void rfbGotXCutText(rfbScreenInfoPtr rfbScreen, char *str, int len);
-
-/* translate.c */
-
-extern rfbBool rfbEconomicTranslate;
-
-extern void rfbTranslateNone(char *table, rfbPixelFormat *in,
-                             rfbPixelFormat *out,
-                             char *iptr, char *optr,
-                             int bytesBetweenInputLines,
-                             int width, int height);
-extern rfbBool rfbSetTranslateFunction(rfbClientPtr cl);
-extern rfbBool rfbSetClientColourMap(rfbClientPtr cl, int firstColour, int nColours);
-extern void rfbSetClientColourMaps(rfbScreenInfoPtr rfbScreen, int firstColour, int nColours);
-
-/* httpd.c */
-
-extern void rfbHttpInitSockets(rfbScreenInfoPtr rfbScreen);
-extern void rfbHttpShutdownSockets(rfbScreenInfoPtr rfbScreen);
-extern void rfbHttpCheckFds(rfbScreenInfoPtr rfbScreen);
-
-
-
-/* auth.c */
-
-extern void rfbAuthNewClient(rfbClientPtr cl);
-extern void rfbProcessClientSecurityType(rfbClientPtr cl);
-extern void rfbAuthProcessClientMessage(rfbClientPtr cl);
-extern void rfbRegisterSecurityHandler(rfbSecurityHandler* handler);
-extern void rfbUnregisterSecurityHandler(rfbSecurityHandler* handler);
-
-/* rre.c */
-
-extern rfbBool rfbSendRectEncodingRRE(rfbClientPtr cl, int x,int y,int w,int h);
-
-
-/* corre.c */
-
-extern rfbBool rfbSendRectEncodingCoRRE(rfbClientPtr cl, int x,int y,int w,int h);
-
-
-/* hextile.c */
-
-extern rfbBool rfbSendRectEncodingHextile(rfbClientPtr cl, int x, int y, int w,
-                                       int h);
-
-/* ultra.c */
-
-/* Set maximum ultra rectangle size in pixels.  Always allow at least
- * two scan lines.
- */
-#define ULTRA_MAX_RECT_SIZE (128*256)
-#define ULTRA_MAX_SIZE(min) ((( min * 2 ) > ULTRA_MAX_RECT_SIZE ) ? \
-                            ( min * 2 ) : ULTRA_MAX_RECT_SIZE )
-
-extern rfbBool rfbSendRectEncodingUltra(rfbClientPtr cl, int x,int y,int w,int h);
-
-
-#ifdef LIBVNCSERVER_HAVE_LIBZ
-/* zlib.c */
-
-/** Minimum zlib rectangle size in bytes.  Anything smaller will
- * not compress well due to overhead.
- */
-#define VNC_ENCODE_ZLIB_MIN_COMP_SIZE (17)
-
-/* Set maximum zlib rectangle size in pixels.  Always allow at least
- * two scan lines.
- */
-#define ZLIB_MAX_RECT_SIZE (128*256)
-#define ZLIB_MAX_SIZE(min) ((( min * 2 ) > ZLIB_MAX_RECT_SIZE ) ? \
-			    ( min * 2 ) : ZLIB_MAX_RECT_SIZE )
-
-extern rfbBool rfbSendRectEncodingZlib(rfbClientPtr cl, int x, int y, int w,
-				    int h);
-
-#ifdef LIBVNCSERVER_HAVE_LIBJPEG
-/* tight.c */
-
-#define TIGHT_DEFAULT_COMPRESSION  6
-
-extern rfbBool rfbTightDisableGradient;
-
-extern int rfbNumCodedRectsTight(rfbClientPtr cl, int x,int y,int w,int h);
-extern rfbBool rfbSendRectEncodingTight(rfbClientPtr cl, int x,int y,int w,int h);
-
-#endif
-#endif
-
-
-/* cursor.c */
-
-typedef struct rfbCursor {
-    /** set this to true if LibVNCServer has to free this cursor */
-    rfbBool cleanup, cleanupSource, cleanupMask, cleanupRichSource;
-    unsigned char *source;			/**< points to bits */
-    unsigned char *mask;			/**< points to bits */
-    unsigned short width, height, xhot, yhot;	/**< metrics */
-    unsigned short foreRed, foreGreen, foreBlue; /**< device-independent colour */
-    unsigned short backRed, backGreen, backBlue; /**< device-independent colour */
-    unsigned char *richSource; /**< source bytes for a rich cursor */
-    unsigned char *alphaSource; /**< source for alpha blending info */
-    rfbBool alphaPreMultiplied; /**< if richSource already has alpha applied */
-} rfbCursor, *rfbCursorPtr;
-extern unsigned char rfbReverseByte[0x100];
-
-extern rfbBool rfbSendCursorShape(rfbClientPtr cl/*, rfbScreenInfoPtr pScreen*/);
-extern rfbBool rfbSendCursorPos(rfbClientPtr cl);
-extern void rfbConvertLSBCursorBitmapOrMask(int width,int height,unsigned char* bitmap);
-extern rfbCursorPtr rfbMakeXCursor(int width,int height,char* cursorString,char* maskString);
-extern char* rfbMakeMaskForXCursor(int width,int height,char* cursorString);
-extern char* rfbMakeMaskFromAlphaSource(int width,int height,unsigned char* alphaSource);
-extern void rfbMakeXCursorFromRichCursor(rfbScreenInfoPtr rfbScreen,rfbCursorPtr cursor);
-extern void rfbMakeRichCursorFromXCursor(rfbScreenInfoPtr rfbScreen,rfbCursorPtr cursor);
-extern void rfbFreeCursor(rfbCursorPtr cursor);
-extern void rfbSetCursor(rfbScreenInfoPtr rfbScreen,rfbCursorPtr c);
-
-/** cursor handling for the pointer */
-extern void rfbDefaultPtrAddEvent(int buttonMask,int x,int y,rfbClientPtr cl);
-
-/* zrle.c */
-#ifdef LIBVNCSERVER_HAVE_LIBZ
-extern rfbBool rfbSendRectEncodingZRLE(rfbClientPtr cl, int x, int y, int w,int h);
-#endif
-
-/* stats.c */
-
-extern void rfbResetStats(rfbClientPtr cl);
-extern void rfbPrintStats(rfbClientPtr cl);
-
-/* font.c */
-
-typedef struct rfbFontData {
-  unsigned char* data;
-  /**
-    metaData is a 256*5 array:
-    for each character
-    (offset,width,height,x,y)
-  */
-  int* metaData;
-} rfbFontData,* rfbFontDataPtr;
-
-int rfbDrawChar(rfbScreenInfoPtr rfbScreen,rfbFontDataPtr font,int x,int y,unsigned char c,rfbPixel colour);
-void rfbDrawString(rfbScreenInfoPtr rfbScreen,rfbFontDataPtr font,int x,int y,const char* string,rfbPixel colour);
-/** if colour==backColour, background is transparent */
-int rfbDrawCharWithClip(rfbScreenInfoPtr rfbScreen,rfbFontDataPtr font,int x,int y,unsigned char c,int x1,int y1,int x2,int y2,rfbPixel colour,rfbPixel backColour);
-void rfbDrawStringWithClip(rfbScreenInfoPtr rfbScreen,rfbFontDataPtr font,int x,int y,const char* string,int x1,int y1,int x2,int y2,rfbPixel colour,rfbPixel backColour);
-int rfbWidthOfString(rfbFontDataPtr font,const char* string);
-int rfbWidthOfChar(rfbFontDataPtr font,unsigned char c);
-void rfbFontBBox(rfbFontDataPtr font,unsigned char c,int* x1,int* y1,int* x2,int* y2);
-/** this returns the smallest box enclosing any character of font. */
-void rfbWholeFontBBox(rfbFontDataPtr font,int *x1, int *y1, int *x2, int *y2);
-
-/** dynamically load a linux console font (4096 bytes, 256 glyphs a 8x16 */
-rfbFontDataPtr rfbLoadConsoleFont(char *filename);
-/** free a dynamically loaded font */
-void rfbFreeFont(rfbFontDataPtr font);
-
-/* draw.c */
-
-void rfbFillRect(rfbScreenInfoPtr s,int x1,int y1,int x2,int y2,rfbPixel col);
-void rfbDrawPixel(rfbScreenInfoPtr s,int x,int y,rfbPixel col);
-void rfbDrawLine(rfbScreenInfoPtr s,int x1,int y1,int x2,int y2,rfbPixel col);
-
-/* selbox.c */
-
-/** this opens a modal select box. list is an array of strings, the end marked
-   with a NULL.
-   It returns the index in the list or -1 if cancelled or something else
-   wasn't kosher. */
-typedef void (*SelectionChangedHookPtr)(int _index);
-extern int rfbSelectBox(rfbScreenInfoPtr rfbScreen,
-			rfbFontDataPtr font, char** list,
-			int x1, int y1, int x2, int y2,
-			rfbPixel foreColour, rfbPixel backColour,
-			int border,SelectionChangedHookPtr selChangedHook);
-
-/* cargs.c */
-
-extern void rfbUsage(void);
-extern void rfbPurgeArguments(int* argc,int* position,int count,char *argv[]);
-extern rfbBool rfbProcessArguments(rfbScreenInfoPtr rfbScreen,int* argc, char *argv[]);
-extern rfbBool rfbProcessSizeArguments(int* width,int* height,int* bpp,int* argc, char *argv[]);
-
-/* main.c */
-
-extern void rfbLogEnable(int enabled);
-typedef void (*rfbLogProc)(const char *format, ...);
-extern rfbLogProc rfbLog, rfbErr;
-extern void rfbLogPerror(const char *str);
-
-void rfbScheduleCopyRect(rfbScreenInfoPtr rfbScreen,int x1,int y1,int x2,int y2,int dx,int dy);
-void rfbScheduleCopyRegion(rfbScreenInfoPtr rfbScreen,sraRegionPtr copyRegion,int dx,int dy);
-
-void rfbDoCopyRect(rfbScreenInfoPtr rfbScreen,int x1,int y1,int x2,int y2,int dx,int dy);
-void rfbDoCopyRegion(rfbScreenInfoPtr rfbScreen,sraRegionPtr copyRegion,int dx,int dy);
-
-void rfbMarkRectAsModified(rfbScreenInfoPtr rfbScreen,int x1,int y1,int x2,int y2);
-void rfbMarkRegionAsModified(rfbScreenInfoPtr rfbScreen,sraRegionPtr modRegion);
-void rfbDoNothingWithClient(rfbClientPtr cl);
-enum rfbNewClientAction defaultNewClientHook(rfbClientPtr cl);
-void rfbRegisterProtocolExtension(rfbProtocolExtension* extension);
-void rfbUnregisterProtocolExtension(rfbProtocolExtension* extension);
-struct _rfbProtocolExtension* rfbGetExtensionIterator();
-void rfbReleaseExtensionIterator();
-rfbBool rfbEnableExtension(rfbClientPtr cl, rfbProtocolExtension* extension,
-	void* data);
-rfbBool rfbDisableExtension(rfbClientPtr cl, rfbProtocolExtension* extension);
-void* rfbGetExtensionClientData(rfbClientPtr cl, rfbProtocolExtension* extension);
-
-/** to check against plain passwords */
-rfbBool rfbCheckPasswordByList(rfbClientPtr cl,const char* response,int len);
-
-/* functions to make a vnc server */
-extern rfbScreenInfoPtr rfbGetScreen(int* argc,char** argv,
- int width,int height,int bitsPerSample,int samplesPerPixel,
- int bytesPerPixel);
-extern void rfbInitServer(rfbScreenInfoPtr rfbScreen);
-extern void rfbShutdownServer(rfbScreenInfoPtr rfbScreen,rfbBool disconnectClients);
-extern void rfbNewFramebuffer(rfbScreenInfoPtr rfbScreen,char *framebuffer,
- int width,int height, int bitsPerSample,int samplesPerPixel,
- int bytesPerPixel);
-
-extern void rfbScreenCleanup(rfbScreenInfoPtr screenInfo);
-extern void rfbSetServerVersionIdentity(rfbScreenInfoPtr screen, char *fmt, ...);
-
-/* functions to accept/refuse a client that has been put on hold
-   by a NewClientHookPtr function. Must not be called in other
-   situations. */
-extern void rfbStartOnHoldClient(rfbClientPtr cl);
-extern void rfbRefuseOnHoldClient(rfbClientPtr cl);
-
-/* call one of these two functions to service the vnc clients.
- usec are the microseconds the select on the fds waits.
- if you are using the event loop, set this to some value > 0, so the
- server doesn't get a high load just by listening.
- rfbProcessEvents() returns TRUE if an update was pending. */
-
-extern void rfbRunEventLoop(rfbScreenInfoPtr screenInfo, long usec, rfbBool runInBackground);
-extern rfbBool rfbProcessEvents(rfbScreenInfoPtr screenInfo,long usec);
-extern rfbBool rfbIsActive(rfbScreenInfoPtr screenInfo);
-
-/* TightVNC file transfer extension */
-void rfbRegisterTightVNCFileTransferExtension();
-void rfbUnregisterTightVNCFileTransferExtension();
-
-/* Statistics */
-extern char *messageNameServer2Client(uint32_t type, char *buf, int len);
-extern char *messageNameClient2Server(uint32_t type, char *buf, int len);
-extern char *encodingName(uint32_t enc, char *buf, int len);
-
-extern rfbStatList *rfbStatLookupEncoding(rfbClientPtr cl, uint32_t type);
-extern rfbStatList *rfbStatLookupMessage(rfbClientPtr cl, uint32_t type);
-
-/* Each call to rfbStatRecord* adds one to the rect count for that type */
-extern void rfbStatRecordEncodingSent(rfbClientPtr cl, uint32_t type, int byteCount, int byteIfRaw);
-extern void rfbStatRecordEncodingSentAdd(rfbClientPtr cl, uint32_t type, int byteCount); /* Specifically for tight encoding */
-extern void rfbStatRecordEncodingRcvd(rfbClientPtr cl, uint32_t type, int byteCount, int byteIfRaw);
-extern void rfbStatRecordMessageSent(rfbClientPtr cl, uint32_t type, int byteCount, int byteIfRaw);
-extern void rfbStatRecordMessageRcvd(rfbClientPtr cl, uint32_t type, int byteCount, int byteIfRaw);
-extern void rfbResetStats(rfbClientPtr cl);
-extern void rfbPrintStats(rfbClientPtr cl);
-
-extern int rfbStatGetSentBytes(rfbClientPtr cl);
-extern int rfbStatGetSentBytesIfRaw(rfbClientPtr cl);
-extern int rfbStatGetRcvdBytes(rfbClientPtr cl);
-extern int rfbStatGetRcvdBytesIfRaw(rfbClientPtr cl);
-extern int rfbStatGetMessageCountSent(rfbClientPtr cl, uint32_t type);
-extern int rfbStatGetMessageCountRcvd(rfbClientPtr cl, uint32_t type);
-extern int rfbStatGetEncodingCountSent(rfbClientPtr cl, uint32_t type);
-extern int rfbStatGetEncodingCountRcvd(rfbClientPtr cl, uint32_t type);
-
-/** Set which version you want to advertise 3.3, 3.6, 3.7 and 3.8 are currently supported*/
-extern void rfbSetProtocolVersion(rfbScreenInfoPtr rfbScreen, int major_, int minor_);
-
-/** send a TextChat message to a client */
-extern rfbBool rfbSendTextChatMessage(rfbClientPtr cl, uint32_t length, char *buffer);
-
-
-
-
-#if(defined __cplusplus)
-}
-#endif
-
-/**
- * @}
- */
-
-
-/**
- @page libvncserver_doc LibVNCServer Documentation
- @section create_server Creating a server instance
- To make a server, you just have to initialise a server structure using the
- function rfbGetScreen(), like
- @code
-   rfbScreenInfoPtr screen =
-     rfbGetScreen(argc,argv,screenwidth,screenheight,8,3,bpp);
- @endcode
- where byte per pixel should be 1, 2 or 4. If performance doesn't matter,
- you may try bpp=3 (internally one cannot use native data types in this
- case; if you want to use this, look at pnmshow24.c).
-
- You then can set hooks and io functions (see @ref making_it_interactive) or other
- options (see @ref server_options).
-
- And you allocate the frame buffer like this:
- @code
-     screen->frameBuffer = (char*)malloc(screenwidth*screenheight*bpp);
- @endcode
- After that, you initialize the server, like
- @code
-   rfbInitServer(screen);
- @endcode
- You can use a blocking event loop, a background (pthread based) event loop,
- or implement your own using the rfbProcessEvents() function.
-
- @subsection server_options Optional Server Features
-
- These options have to be set between rfbGetScreen() and rfbInitServer().
-
- If you already have a socket to talk to, just set rfbScreenInfo::inetdSock
- (originally this is for inetd handling, but why not use it for your purpose?).
-
- To also start an HTTP server (running on port 5800+display_number), you have
- to set rfbScreenInfo::httpDir to a directory containing vncviewer.jar and
- index.vnc (like the included "classes" directory).
-
- @section making_it_interactive Making it interactive
-
- Whenever you draw something, you have to call
- @code
-  rfbMarkRectAsModified(screen,x1,y1,x2,y2).
- @endcode
- This tells LibVNCServer to send updates to all connected clients.
-
- There exist the following IO functions as members of rfbScreen:
- rfbScreenInfo::kbdAddEvent(), rfbScreenInfo::kbdReleaseAllKeys(), rfbScreenInfo::ptrAddEvent() and rfbScreenInfo::setXCutText()
-
- rfbScreenInfo::kbdAddEvent()
-   is called when a key is pressed.
- rfbScreenInfo::kbdReleaseAllKeys()
-   is not called at all (maybe in the future).
- rfbScreenInfo::ptrAddEvent()
-   is called when the mouse moves or a button is pressed.
-   WARNING: if you want to have proper cursor handling, call
-	rfbDefaultPtrAddEvent()
-   in your own function. This sets the coordinates of the cursor.
- rfbScreenInfo::setXCutText()
-   is called when the selection changes.
-
- There are only two hooks:
- rfbScreenInfo::newClientHook()
-   is called when a new client has connected.
- rfbScreenInfo::displayHook()
-   is called just before a frame buffer update is sent.
-
- You can also override the following methods:
- rfbScreenInfo::getCursorPtr()
-   This could be used to make an animated cursor (if you really want ...)
- rfbScreenInfo::setTranslateFunction()
-   If you insist on colour maps or something more obscure, you have to
-   implement this. Default is a trueColour mapping.
-
- @section cursor_handling Cursor handling
-
- The screen holds a pointer
-  rfbScreenInfo::cursor
- to the current cursor. Whenever you set it, remember that any dynamically
- created cursor (like return value from rfbMakeXCursor()) is not free'd!
-
- The rfbCursor structure consists mainly of a mask and a source. The rfbCursor::mask
- describes, which pixels are drawn for the cursor (a cursor needn't be
- rectangular). The rfbCursor::source describes, which colour those pixels should have.
-
- The standard is an XCursor: a cursor with a foreground and a background
- colour (stored in backRed,backGreen,backBlue and the same for foreground
- in a range from 0-0xffff). Therefore, the arrays "mask" and "source"
- contain pixels as single bits stored in bytes in MSB order. The rows are
- padded, such that each row begins with a new byte (i.e. a 10x4
- cursor's mask has 2x4 bytes, because 2 bytes are needed to hold 10 bits).
-
- It is however very easy to make a cursor like this:
- @code
- char* cur="    "
-           " xx "
-	   " x  "
-	   "    ";
- char* mask="xxxx"
-            "xxxx"
-            "xxxx"
-            "xxx ";
- rfbCursorPtr c=rfbMakeXCursor(4,4,cur,mask);
- @endcode
- You can even set rfbCursor::mask to NULL in this call and LibVNCServer will calculate
- a mask for you (dynamically, so you have to free it yourself).
-
- There is also an array named rfbCursor::richSource for colourful cursors. They have
- the same format as the frameBuffer (i.e. if the server is 32 bit,
- a 10x4 cursor has 4x10x4 bytes).
-
- @section screen_client_difference What is the difference between rfbScreenInfoPtr and rfbClientPtr?
-
- The rfbScreenInfoPtr is a pointer to a rfbScreenInfo structure, which
- holds information about the server, like pixel format, io functions,
- frame buffer etc. The rfbClientPtr is a pointer to an rfbClientRec structure, which holds
- information about a client, like pixel format, socket of the
- connection, etc. A server can have several clients, but needn't have any. So, if you
- have a server and three clients are connected, you have one instance
- of a rfbScreenInfo and three instances of rfbClientRec's.
-
- The rfbClientRec structure holds a member rfbClientRec::screen which points to the server.
- So, to access the server from the client structure, you use client->screen.
-
- To access all clients from a server be sure to use the provided iterator
-  rfbGetClientIterator()
- with
-  rfbClientIteratorNext()
- and
-  rfbReleaseClientIterator()
- to prevent thread clashes.
-
- @section example_code Example Code
-
- There are two documented examples included:
-  - example.c, a shared scribble sheet
-  - pnmshow.c, a program to show PNMs (pictures) over the net.
-
- The examples are not too well documented, but easy straight forward and a
- good starting point.
-
- Try example.c: it outputs on which port it listens (default: 5900), so it is
- display 0. To view, call @code	vncviewer :0 @endcode
- You should see a sheet with a gradient and "Hello World!" written on it. Try
- to paint something. Note that everytime you click, there is some bigger blot,
- whereas when you drag the mouse while clicked you draw a line. The size of the
- blot depends on the mouse button you click. Open a second vncviewer with
- the same parameters and watch it as you paint in the other window. This also
- works over internet. You just have to know either the name or the IP of your
- machine. Then it is @code vncviewer machine.where.example.runs.com:0 @endcode
- or similar for the remote client. Now you are ready to type something. Be sure
- that your mouse sits still, because everytime the mouse moves, the cursor is
- reset to the position of the pointer! If you are done with that demo, press
- the down or up arrows. If your viewer supports it, then the dimensions of the
- sheet change. Just press Escape in the viewer. Note that the server still
- runs, even if you closed both windows. When you reconnect now, everything you
- painted and wrote is still there. You can press "Page Up" for a blank page.
-
- The demo pnmshow.c is much simpler: you either provide a filename as argument
- or pipe a file through stdin. Note that the file has to be a raw pnm/ppm file,
- i.e. a truecolour graphics. Only the Escape key is implemented. This may be
- the best starting point if you want to learn how to use LibVNCServer. You
- are confronted with the fact that the bytes per pixel can only be 8, 16 or 32.
-*/
-
-#endif
diff -urN remmina-plugins/vnc/libvncserver/rfb/rfbclient.h remmina-plugins/vnc/libvncserver/rfb/rfbclient.h
--- remmina-plugins/vnc/libvncserver/rfb/rfbclient.h	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins/vnc/libvncserver/rfb/rfbclient.h	1970-01-01 10:00:00.000000000 +1000
@@ -1,431 +0,0 @@
-#ifndef RFBCLIENT_H
-#define RFBCLIENT_H
-
-/**
- * @defgroup libvncclient_api LibVNCClient API Reference
- * @{
- */
-
-/*
- *  Copyright (C) 2000, 2001 Const Kaplinsky.  All Rights Reserved.
- *  Copyright (C) 2000 Tridia Corporation.  All Rights Reserved.
- *  Copyright (C) 1999 AT&T Laboratories Cambridge.  All Rights Reserved.
- *
- *  This is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This software is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this software; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
- *  USA.
- */
-
-/**
- * @file rfbclient.h
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sys/time.h>
-#include <unistd.h>
-#include <rfb/rfbproto.h>
-#include <rfb/keysym.h>
-#ifdef LIBVNCSERVER_WITH_CLIENT_TLS
-#include <gnutls/gnutls.h>
-#endif
-
-#define rfbClientSwap16IfLE(s) \
-    (*(char *)&client->endianTest ? ((((s) & 0xff) << 8) | (((s) >> 8) & 0xff)) : (s))
-
-#define rfbClientSwap32IfLE(l) \
-    (*(char *)&client->endianTest ? ((((l) & 0xff000000) >> 24) | \
-			     (((l) & 0x00ff0000) >> 8)  | \
-			     (((l) & 0x0000ff00) << 8)  | \
-			     (((l) & 0x000000ff) << 24))  : (l))
-
-#define rfbClientSwap64IfLE(l) \
-    (*(char *)&client->endianTest ? ((((l) & 0xff00000000000000ULL) >> 56) | \
-			     (((l) & 0x00ff000000000000ULL) >> 40)  | \
-			     (((l) & 0x0000ff0000000000ULL) >> 24)  | \
-			     (((l) & 0x000000ff00000000ULL) >> 8)  | \
-			     (((l) & 0x00000000ff000000ULL) << 8)  | \
-			     (((l) & 0x0000000000ff0000ULL) << 24)  | \
-			     (((l) & 0x000000000000ff00ULL) << 40)  | \
-			     (((l) & 0x00000000000000ffULL) << 56))  : (l))
-
-#define FLASH_PORT_OFFSET 5400
-#define LISTEN_PORT_OFFSET 5500
-#define TUNNEL_PORT_OFFSET 5500
-#define SERVER_PORT_OFFSET 5900
-
-#define DEFAULT_SSH_CMD "/usr/bin/ssh"
-#define DEFAULT_TUNNEL_CMD  \
-  (DEFAULT_SSH_CMD " -f -L %L:localhost:%R %H sleep 20")
-#define DEFAULT_VIA_CMD     \
-  (DEFAULT_SSH_CMD " -f -L %L:%H:%R %G sleep 20")
-
-#if(defined __cplusplus)
-extern "C"
-{
-#endif
-
-/** vncrec */
-
-typedef struct {
-  FILE* file;
-  struct timeval tv;
-  rfbBool readTimestamp;
-  rfbBool doNotSleep;
-} rfbVNCRec;
-
-/** client data */
-
-typedef struct rfbClientData {
-	void* tag;
-	void* data;
-	struct rfbClientData* next;
-} rfbClientData;
-
-/** app data (belongs into rfbClient?) */
-
-typedef struct {
-  rfbBool shareDesktop;
-  rfbBool viewOnly;
-
-  const char* encodingsString;
-
-  rfbBool useBGR233;
-  int nColours;
-  rfbBool forceOwnCmap;
-  rfbBool forceTrueColour;
-  int requestedDepth;
-
-  int compressLevel;
-  int qualityLevel;
-  rfbBool enableJPEG;
-  rfbBool useRemoteCursor;
-  rfbBool palmVNC;  /**< use palmvnc specific SetScale (vs ultravnc) */
-  int scaleSetting; /**< 0 means no scale set, else 1/scaleSetting */
-} AppData;
-
-/** For GetCredentialProc callback function to return */
-typedef union _rfbCredential
-{
-  /** X509 (VeNCrypt) */
-  struct
-  {
-    char *x509CACertFile;
-    char *x509CACrlFile;
-    char *x509ClientCertFile;
-    char *x509ClientKeyFile;
-  } x509Credential;
-  /** Plain (VeNCrypt), MSLogon (UltraVNC) */
-  struct
-  {
-    char *username;
-    char *password;
-  } userCredential;
-} rfbCredential;
-
-#define rfbCredentialTypeX509 1
-#define rfbCredentialTypeUser 2
-
-struct _rfbClient;
-
-typedef void (*HandleTextChatProc)(struct _rfbClient* client, int value, char *text);
-typedef void (*HandleXvpMsgProc)(struct _rfbClient* client, uint8_t version, uint8_t opcode);
-typedef void (*HandleKeyboardLedStateProc)(struct _rfbClient* client, int value, int pad);
-typedef rfbBool (*HandleCursorPosProc)(struct _rfbClient* client, int x, int y);
-typedef void (*SoftCursorLockAreaProc)(struct _rfbClient* client, int x, int y, int w, int h);
-typedef void (*SoftCursorUnlockScreenProc)(struct _rfbClient* client);
-typedef void (*GotFrameBufferUpdateProc)(struct _rfbClient* client, int x, int y, int w, int h);
-typedef void (*FinishedFrameBufferUpdateProc)(struct _rfbClient* client);
-typedef char* (*GetPasswordProc)(struct _rfbClient* client);
-typedef rfbCredential* (*GetCredentialProc)(struct _rfbClient* client, int credentialType);
-typedef rfbBool (*MallocFrameBufferProc)(struct _rfbClient* client);
-typedef void (*GotXCutTextProc)(struct _rfbClient* client, const char *text, int textlen);
-typedef void (*BellProc)(struct _rfbClient* client);
-
-typedef void (*GotCursorShapeProc)(struct _rfbClient* client, int xhot, int yhot, int width, int height, int bytesPerPixel);
-typedef void (*GotCopyRectProc)(struct _rfbClient* client, int src_x, int src_y, int w, int h, int dest_x, int dest_y);
-
-typedef struct _rfbClient {
-	uint8_t* frameBuffer;
-	int width, height;
-
-	int endianTest;
-
-	AppData appData;
-
-	const char* programName;
-	char* serverHost;
-	int serverPort; /**< if -1, then use file recorded by vncrec */
-	rfbBool listenSpecified;
-	int listenPort, flashPort;
-
-	struct {
-		int x, y, w, h;
-	} updateRect;
-
-	/** Note that the CoRRE encoding uses this buffer and assumes it is big enough
-	   to hold 255 * 255 * 32 bits -> 260100 bytes.  640*480 = 307200 bytes.
-	   Hextile also assumes it is big enough to hold 16 * 16 * 32 bits.
-	   Tight encoding assumes BUFFER_SIZE is at least 16384 bytes. */
-
-#define RFB_BUFFER_SIZE (640*480)
-	char buffer[RFB_BUFFER_SIZE];
-
-	/* rfbproto.c */
-
-	int sock;
-	rfbBool canUseCoRRE;
-	rfbBool canUseHextile;
-	char *desktopName;
-	rfbPixelFormat format;
-	rfbServerInitMsg si;
-
-	/* sockets.c */
-#define RFB_BUF_SIZE 8192
-	char buf[RFB_BUF_SIZE];
-	char *bufoutptr;
-	int buffered;
-
-	/* The zlib encoding requires expansion/decompression/deflation of the
-	   compressed data in the "buffer" above into another, result buffer.
-	   However, the size of the result buffer can be determined precisely
-	   based on the bitsPerPixel, height and width of the rectangle.  We
-	   allocate this buffer one time to be the full size of the buffer. */
-
-	/* Ultra Encoding uses this buffer too */
-	
-	int ultra_buffer_size;
-	char *ultra_buffer;
-
-	int raw_buffer_size;
-	char *raw_buffer;
-
-#ifdef LIBVNCSERVER_HAVE_LIBZ
-	z_stream decompStream;
-	rfbBool decompStreamInited;
-#endif
-
-
-#ifdef LIBVNCSERVER_HAVE_LIBZ
-	/*
-	 * Variables for the ``tight'' encoding implementation.
-	 */
-
-	/** Separate buffer for compressed data. */
-#define ZLIB_BUFFER_SIZE 30000
-	char zlib_buffer[ZLIB_BUFFER_SIZE];
-
-	/* Four independent compression streams for zlib library. */
-	z_stream zlibStream[4];
-	rfbBool zlibStreamActive[4];
-
-	/* Filter stuff. Should be initialized by filter initialization code. */
-	rfbBool cutZeros;
-	int rectWidth, rectColors;
-	char tightPalette[256*4];
-	uint8_t tightPrevRow[2048*3*sizeof(uint16_t)];
-
-#ifdef LIBVNCSERVER_HAVE_LIBJPEG
-	/** JPEG decoder state. */
-	rfbBool jpegError;
-
-	struct jpeg_source_mgr* jpegSrcManager;
-	void* jpegBufferPtr;
-	size_t jpegBufferLen;
-
-#endif
-#endif
-
-
-	/* cursor.c */
-	uint8_t *rcSource, *rcMask;
-
-	/** private data pointer */
-	rfbClientData* clientData;
-
-	rfbVNCRec* vncRec;
-
-	/* Keyboard State support (is 'Caps Lock' set on the remote display???) */
-	int KeyboardLedStateEnabled;
-	int CurrentKeyboardLedState;
-
-	int canHandleNewFBSize;
-
-	/* hooks */
-	HandleTextChatProc         HandleTextChat;
-	HandleKeyboardLedStateProc HandleKeyboardLedState;
-	HandleCursorPosProc HandleCursorPos;
-	SoftCursorLockAreaProc SoftCursorLockArea;
-	SoftCursorUnlockScreenProc SoftCursorUnlockScreen;
-	GotFrameBufferUpdateProc GotFrameBufferUpdate;
-	/** the pointer returned by GetPassword will be freed after use! */
-	GetPasswordProc GetPassword;
-	MallocFrameBufferProc MallocFrameBuffer;
-	GotXCutTextProc GotXCutText;
-	BellProc Bell;
-
-	GotCursorShapeProc GotCursorShape;
-	GotCopyRectProc GotCopyRect;
-
-	/** Which messages are supported by the server
-	 * This is a *guess* for most servers.
-	 * (If we can even detect the type of server)
-	 *
-	 * If the server supports the "rfbEncodingSupportedMessages"
-	 * then this will be updated when the encoding is received to
-	 * accurately reflect the servers capabilities.
-	 */
-	rfbSupportedMessages supportedMessages;
-
-	/** negotiated protocol version */
-	int major, minor;
-
-	/** The selected security types */
-	uint32_t authScheme, subAuthScheme;
-
-#ifdef LIBVNCSERVER_WITH_CLIENT_TLS
-	/** The TLS session for Anonymous TLS and VeNCrypt */
-	gnutls_session_t tlsSession;
-#endif
-
-	/** To support security types that requires user input (except VNC password
-	 * authentication), for example VeNCrypt and MSLogon, this callback function
-	 * must be set before the authentication. Otherwise, it implicates that the
-	 * caller application does not support it and related security types should
-	 * be bypassed.
-	 */
-	GetCredentialProc GetCredential;
-
-	/** The 0-terminated security types supported by the client.
-	 * Set by function SetClientAuthSchemes() */
-	uint32_t *clientAuthSchemes;
-
-	/** When the server is a repeater, this specifies the final destination */
-	char *destHost;
-	int destPort;
-
-        /** the QoS IP DSCP for this client */
-        int QoS_DSCP;
-
-        /** hook to handle xvp server messages */
-	HandleXvpMsgProc           HandleXvpMsg;
-
-	/* listen.c */
-        int listenSock;
-
-	FinishedFrameBufferUpdateProc FinishedFrameBufferUpdate;
-} rfbClient;
-
-/* cursor.c */
-
-extern rfbBool HandleCursorShape(rfbClient* client,int xhot, int yhot, int width, int height, uint32_t enc);
-
-/* listen.c */
-
-extern void listenForIncomingConnections(rfbClient* viewer);
-extern int listenForIncomingConnectionsNoFork(rfbClient* viewer, int usec_timeout);
-
-/* rfbproto.c */
-
-extern rfbBool rfbEnableClientLogging;
-typedef void (*rfbClientLogProc)(const char *format, ...);
-extern rfbClientLogProc rfbClientLog,rfbClientErr;
-extern rfbBool ConnectToRFBServer(rfbClient* client,const char *hostname, int port);
-extern rfbBool ConnectToRFBRepeater(rfbClient* client,const char *repeaterHost, int repeaterPort, const char *destHost, int destPort);
-extern void SetClientAuthSchemes(rfbClient* client,const uint32_t *authSchemes, int size);
-extern rfbBool InitialiseRFBConnection(rfbClient* client);
-extern rfbBool SetFormatAndEncodings(rfbClient* client);
-extern rfbBool SendIncrementalFramebufferUpdateRequest(rfbClient* client);
-extern rfbBool SendFramebufferUpdateRequest(rfbClient* client,
-					 int x, int y, int w, int h,
-					 rfbBool incremental);
-extern rfbBool SendScaleSetting(rfbClient* client,int scaleSetting);
-extern rfbBool SendPointerEvent(rfbClient* client,int x, int y, int buttonMask);
-extern rfbBool SendKeyEvent(rfbClient* client,uint32_t key, rfbBool down);
-extern rfbBool SendClientCutText(rfbClient* client,char *str, int len);
-extern rfbBool HandleRFBServerMessage(rfbClient* client);
-
-extern rfbBool TextChatSend(rfbClient* client, char *text);
-extern rfbBool TextChatOpen(rfbClient* client);
-extern rfbBool TextChatClose(rfbClient* client);
-extern rfbBool TextChatFinish(rfbClient* client);
-extern rfbBool PermitServerInput(rfbClient* client, int enabled);
-extern rfbBool SendXvpMsg(rfbClient* client, uint8_t version, uint8_t code);
-
-extern void PrintPixelFormat(rfbPixelFormat *format);
-
-extern rfbBool SupportsClient2Server(rfbClient* client, int messageType);
-extern rfbBool SupportsServer2Client(rfbClient* client, int messageType);
-
-/* client data */
-
-void rfbClientSetClientData(rfbClient* client, void* tag, void* data);
-void* rfbClientGetClientData(rfbClient* client, void* tag);
-
-/* protocol extensions */
-
-typedef struct _rfbClientProtocolExtension {
-	int* encodings;
-	/** returns TRUE if the encoding was handled */
-	rfbBool (*handleEncoding)(rfbClient* cl,
-		rfbFramebufferUpdateRectHeader* rect);
-	/** returns TRUE if it handled the message */
-	rfbBool (*handleMessage)(rfbClient* cl,
-		 rfbServerToClientMsg* message);
-	struct _rfbClientProtocolExtension* next;
-} rfbClientProtocolExtension;
-
-void rfbClientRegisterExtension(rfbClientProtocolExtension* e);
-
-/* sockets.c */
-
-extern rfbBool errorMessageOnReadFailure;
-
-extern rfbBool ReadFromRFBServer(rfbClient* client, char *out, unsigned int n);
-extern rfbBool WriteToRFBServer(rfbClient* client, char *buf, int n);
-extern int FindFreeTcpPort(void);
-extern int ListenAtTcpPort(int port);
-extern int ConnectClientToTcpAddr(unsigned int host, int port);
-extern int ConnectClientToTcpAddr6(const char *hostname, int port);
-extern int ConnectClientToUnixSock(const char *sockFile);
-extern int AcceptTcpConnection(int listenSock);
-extern rfbBool SetNonBlocking(int sock);
-extern rfbBool SetDSCP(int sock, int dscp);
-
-extern rfbBool StringToIPAddr(const char *str, unsigned int *addr);
-extern rfbBool SameMachine(int sock);
-extern int WaitForMessage(rfbClient* client,unsigned int usecs);
-
-/* vncviewer.c */
-rfbClient* rfbGetClient(int bitsPerSample,int samplesPerPixel,int bytesPerPixel);
-rfbBool rfbInitClient(rfbClient* client,int* argc,char** argv);
-/** rfbClientCleanup() does not touch client->frameBuffer */
-void rfbClientCleanup(rfbClient* client);
-
-#if(defined __cplusplus)
-}
-#endif
-
-/**
- * @}
- */
-
-/**
- @page libvncclient_doc LibVNCClient Documentation
- @section example_code Example Code
- See SDLvncviewer.c for a rather complete client example.
-*/
-
-#endif
diff -urN remmina-plugins/vnc/libvncserver/rfb/rfbconfig.h remmina-plugins/vnc/libvncserver/rfb/rfbconfig.h
--- remmina-plugins/vnc/libvncserver/rfb/rfbconfig.h	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins/vnc/libvncserver/rfb/rfbconfig.h	1970-01-01 10:00:00.000000000 +1000
@@ -1,95 +0,0 @@
-#ifndef _RFB_RFBCONFIG_H
-/* #undef _RFB_RFBCONFIG_H */
- 
-/* rfb/rfbconfig.h. Generated automatically by cmake. */
-
-/* Enable 24 bit per pixel in native framebuffer */
-#define LIBVNCSERVER_ALLOW24BPP  1 
-
-/* work around when write() returns ENOENT but does not mean it */
-/* #undef LIBVNCSERVER_ENOENT_WORKAROUND */
-
-/* Define to 1 if you have the <fcntl.h> header file. */
-#define LIBVNCSERVER_HAVE_FCNTL_H  1 
-
-/* Define to 1 if you have the `gettimeofday' function. */
-#define LIBVNCSERVER_HAVE_GETTIMEOFDAY  1 
-
-/* Define to 1 if you have the `jpeg' library (-ljpeg). */
-#define LIBVNCSERVER_HAVE_LIBJPEG  1 
-
-/* Define to 1 if you have the `pthread' library (-lpthread). */
-#define LIBVNCSERVER_HAVE_LIBPTHREAD  1 
-
-/* Define to 1 if you have the `z' library (-lz). */
-#define LIBVNCSERVER_HAVE_LIBZ  1 
-
-/* Define to 1 if you have the <netinet/in.h> header file. */
-#define LIBVNCSERVER_HAVE_NETINET_IN_H  1 
-
-/* Define to 1 if you have the <sys/socket.h> header file. */
-#define LIBVNCSERVER_HAVE_SYS_SOCKET_H  1 
-
-/* Define to 1 if you have the <sys/stat.h> header file. */
-#define LIBVNCSERVER_HAVE_SYS_STAT_H  1 
-
-/* Define to 1 if you have the <sys/time.h> header file. */
-#define LIBVNCSERVER_HAVE_SYS_TIME_H  1 
-
-/* Define to 1 if you have the <sys/types.h> header file. */
-#define LIBVNCSERVER_HAVE_SYS_TYPES_H  1 
-
-/* Define to 1 if you have <sys/wait.h> that is POSIX.1 compatible. */
-#define LIBVNCSERVER_HAVE_SYS_WAIT_H  1 
-
-/* Define to 1 if you have the <unistd.h> header file. */
-#define LIBVNCSERVER_HAVE_UNISTD_H  1 
-
-/* Need a typedef for in_addr_t */
-/* #undef LIBVNCSERVER_NEED_INADDR_T */
-
-/* Define to the full name and version of this package. */
-#define LIBVNCSERVER_PACKAGE_STRING  " "
-
-/* Define to the version of this package. */
-#define LIBVNCSERVER_PACKAGE_VERSION  ""
-
-/* Define to 1 if libgcrypt is present */
-#define LIBVNCSERVER_WITH_CLIENT_GCRYPT 1
-
-/* Define to 1 if GnuTLS is present */
-#define LIBVNCSERVER_WITH_CLIENT_TLS 1
-
-/* Define to 1 if your processor stores words with the most significant byte
-   first (like Motorola and SPARC, unlike Intel and VAX). */
-/* #undef LIBVNCSERVER_WORDS_BIGENDIAN */
-
-/* Define to empty if `const' does not conform to ANSI C. */
-/* #undef const */
-
-/* Define to `__inline__' or `__inline' if that's what the C compiler
-   calls it, or to nothing if 'inline' is not supported under any name.  */
-//#ifndef __cplusplus
-/* #undef inline */
-//#endif
-
-/* Define to `int' if <sys/types.h> does not define. */
-#define HAVE_LIBVNCSERVER_PID_T 1
-#ifndef HAVE_LIBVNCSERVER_PID_T
-typedef int pid_t;
-#endif
-
-/* The type for size_t */
-#define HAVE_LIBVNCSERVER_SIZE_T 1
-#ifndef HAVE_LIBVNCSERVER_SIZE_T
-typedef int size_t;
-#endif
-
-/* The type for socklen */
-#define HAVE_LIBVNCSERVER_SOCKLEN_T 1
-#ifndef HAVE_LIBVNCSERVER_SOCKLEN_T
-typedef int socklen_t;
-#endif
-
-/* once: _RFB_RFBCONFIG_H */
-#endif
diff -urN remmina-plugins/vnc/libvncserver/rfb/rfbconfig.h.cmake remmina-plugins/vnc/libvncserver/rfb/rfbconfig.h.cmake
--- remmina-plugins/vnc/libvncserver/rfb/rfbconfig.h.cmake	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins/vnc/libvncserver/rfb/rfbconfig.h.cmake	1970-01-01 10:00:00.000000000 +1000
@@ -1,95 +0,0 @@
-#ifndef _RFB_RFBCONFIG_H
-#cmakedefine _RFB_RFBCONFIG_H 1
- 
-/* rfb/rfbconfig.h. Generated automatically by cmake. */
-
-/* Enable 24 bit per pixel in native framebuffer */
-#cmakedefine LIBVNCSERVER_ALLOW24BPP  1 
-
-/* work around when write() returns ENOENT but does not mean it */
-#cmakedefine LIBVNCSERVER_ENOENT_WORKAROUND 1
-
-/* Define to 1 if you have the <fcntl.h> header file. */
-#cmakedefine LIBVNCSERVER_HAVE_FCNTL_H  1 
-
-/* Define to 1 if you have the `gettimeofday' function. */
-#cmakedefine LIBVNCSERVER_HAVE_GETTIMEOFDAY  1 
-
-/* Define to 1 if you have the `jpeg' library (-ljpeg). */
-#cmakedefine LIBVNCSERVER_HAVE_LIBJPEG  1 
-
-/* Define to 1 if you have the `pthread' library (-lpthread). */
-#cmakedefine LIBVNCSERVER_HAVE_LIBPTHREAD  1 
-
-/* Define to 1 if you have the `z' library (-lz). */
-#cmakedefine LIBVNCSERVER_HAVE_LIBZ  1 
-
-/* Define to 1 if you have the <netinet/in.h> header file. */
-#cmakedefine LIBVNCSERVER_HAVE_NETINET_IN_H  1 
-
-/* Define to 1 if you have the <sys/socket.h> header file. */
-#cmakedefine LIBVNCSERVER_HAVE_SYS_SOCKET_H  1 
-
-/* Define to 1 if you have the <sys/stat.h> header file. */
-#cmakedefine LIBVNCSERVER_HAVE_SYS_STAT_H  1 
-
-/* Define to 1 if you have the <sys/time.h> header file. */
-#cmakedefine LIBVNCSERVER_HAVE_SYS_TIME_H  1 
-
-/* Define to 1 if you have the <sys/types.h> header file. */
-#cmakedefine LIBVNCSERVER_HAVE_SYS_TYPES_H  1 
-
-/* Define to 1 if you have <sys/wait.h> that is POSIX.1 compatible. */
-#cmakedefine LIBVNCSERVER_HAVE_SYS_WAIT_H  1 
-
-/* Define to 1 if you have the <unistd.h> header file. */
-#cmakedefine LIBVNCSERVER_HAVE_UNISTD_H  1 
-
-/* Need a typedef for in_addr_t */
-#cmakedefine LIBVNCSERVER_NEED_INADDR_T 1
-
-/* Define to the full name and version of this package. */
-#define LIBVNCSERVER_PACKAGE_STRING  "@FULL_PACKAGE_NAME@ @PACKAGE_VERSION@"
-
-/* Define to the version of this package. */
-#define LIBVNCSERVER_PACKAGE_VERSION  "@PACKAGE_VERSION@"
-
-/* Define to 1 if libgcrypt is present */
-#cmakedefine LIBVNCSERVER_WITH_CLIENT_GCRYPT 1
-
-/* Define to 1 if GnuTLS is present */
-#cmakedefine LIBVNCSERVER_WITH_CLIENT_TLS 1
-
-/* Define to 1 if your processor stores words with the most significant byte
-   first (like Motorola and SPARC, unlike Intel and VAX). */
-#cmakedefine LIBVNCSERVER_WORDS_BIGENDIAN 1
-
-/* Define to empty if `const' does not conform to ANSI C. */
-//#cmakedefine const @CMAKE_CONST@
-
-/* Define to `__inline__' or `__inline' if that's what the C compiler
-   calls it, or to nothing if 'inline' is not supported under any name.  */
-//#ifndef __cplusplus
-//#cmakedefine inline @CMAKE_INLINE@
-//#endif
-
-/* Define to `int' if <sys/types.h> does not define. */
-#cmakedefine HAVE_LIBVNCSERVER_PID_T 1
-#ifndef HAVE_LIBVNCSERVER_PID_T
-typedef int pid_t;
-#endif
-
-/* The type for size_t */
-#cmakedefine HAVE_LIBVNCSERVER_SIZE_T 1
-#ifndef HAVE_LIBVNCSERVER_SIZE_T
-typedef int size_t;
-#endif
-
-/* The type for socklen */
-#cmakedefine HAVE_LIBVNCSERVER_SOCKLEN_T 1
-#ifndef HAVE_LIBVNCSERVER_SOCKLEN_T
-typedef int socklen_t;
-#endif
-
-/* once: _RFB_RFBCONFIG_H */
-#endif
diff -urN remmina-plugins/vnc/libvncserver/rfb/rfbint.h.cmake remmina-plugins/vnc/libvncserver/rfb/rfbint.h.cmake
--- remmina-plugins/vnc/libvncserver/rfb/rfbint.h.cmake	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins/vnc/libvncserver/rfb/rfbint.h.cmake	1970-01-01 10:00:00.000000000 +1000
@@ -1,4 +0,0 @@
-#ifndef _RFB_RFBINT_H
-#define _RFB_RFBINT_H 1
-/* empty ... */
-#endif
diff -urN remmina-plugins/vnc/libvncserver/rfb/rfbproto.h remmina-plugins/vnc/libvncserver/rfb/rfbproto.h
--- remmina-plugins/vnc/libvncserver/rfb/rfbproto.h	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins/vnc/libvncserver/rfb/rfbproto.h	1970-01-01 10:00:00.000000000 +1000
@@ -1,1431 +0,0 @@
-#ifndef RFBPROTO_H
-#define RFBPROTO_H
-
-/**
- @mainpage
- @li @ref libvncserver_api
- @li @ref libvncserver_doc
-
-
- @li @ref libvncclient_api
- @li @ref libvncclient_doc
-
-*/
-
-/*
- *  Copyright (C) 2005 Rohit Kumar, Johannes E. Schindelin
- *  Copyright (C) 2000-2002 Constantin Kaplinsky.  All Rights Reserved.
- *  Copyright (C) 2000 Tridia Corporation.  All Rights Reserved.
- *  Copyright (C) 1999 AT&T Laboratories Cambridge.  All Rights Reserved.
- *
- *  This is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This software is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this software; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
- *  USA.
- */
-
-/*
- * rfbproto.h - header file for the RFB protocol version 3.3
- *
- * Uses types CARD<n> for an n-bit unsigned integer, INT<n> for an n-bit signed
- * integer (for n = 8, 16 and 32).
- *
- * All multiple byte integers are in big endian (network) order (most
- * significant byte first).  Unless noted otherwise there is no special
- * alignment of protocol structures.
- *
- *
- * Once the initial handshaking is done, all messages start with a type byte,
- * (usually) followed by message-specific data.  The order of definitions in
- * this file is as follows:
- *
- *  (1) Structures used in several types of message.
- *  (2) Structures used in the initial handshaking.
- *  (3) Message types.
- *  (4) Encoding types.
- *  (5) For each message type, the form of the data following the type byte.
- *      Sometimes this is defined by a single structure but the more complex
- *      messages have to be explained by comments.
- */
-
-
-#if defined(WIN32) && !defined(__MINGW32__)
-#define LIBVNCSERVER_WORDS_BIGENDIAN
-#define rfbBool int
-#include <sys/timeb.h>
-#include <winsock.h>
-#undef SOCKET
-#define SOCKET int
-#else
-#include <rfb/rfbconfig.h>
-#include <rfb/rfbint.h>
-#endif
-
-#ifdef LIBVNCSERVER_HAVE_LIBZ
-#include <zlib.h>
-#ifdef __CHECKER__
-#undef Z_NULL
-#define Z_NULL NULL
-#endif
-#endif
-
-/* some autotool versions do not properly prefix
-   WORDS_BIGENDIAN, so do that manually */
-#ifdef WORDS_BIGENDIAN
-#define LIBVNCSERVER_WORDS_BIGENDIAN
-#endif
-
-/* MS compilers don't have strncasecmp */
-#ifdef _MSC_VER
-#define strncasecmp _strnicmp
-#endif
-
-#if !defined(WIN32) || defined(__MINGW32__)
-#define max(a,b) (((a)>(b))?(a):(b))
-#ifdef LIBVNCSERVER_HAVE_SYS_TIME_H
-#include <sys/time.h>
-#endif
-#ifdef LIBVNCSERVER_HAVE_NETINET_IN_H
-#include <netinet/in.h>
-#endif
-#define SOCKET int
-typedef int8_t rfbBool;
-#undef FALSE
-#define FALSE 0
-#undef TRUE
-#define TRUE -1
-#endif
-
-typedef uint32_t rfbKeySym;
-typedef uint32_t rfbPixel;
-
-#ifdef LIBVNCSERVER_NEED_INADDR_T
-typedef uint32_t in_addr_t;
-#endif
-
-#ifndef INADDR_NONE
-#define                INADDR_NONE     ((in_addr_t) 0xffffffff)
-#endif
-
-#define MAX_ENCODINGS 21
-
-/*****************************************************************************
- *
- * Structures used in several messages
- *
- *****************************************************************************/
-
-/*-----------------------------------------------------------------------------
- * Structure used to specify a rectangle.  This structure is a multiple of 4
- * bytes so that it can be interspersed with 32-bit pixel data without
- * affecting alignment.
- */
-
-typedef struct {
-    uint16_t x;
-    uint16_t y;
-    uint16_t w;
-    uint16_t h;
-} rfbRectangle;
-
-#define sz_rfbRectangle 8
-
-
-/*-----------------------------------------------------------------------------
- * Structure used to specify pixel format.
- */
-
-typedef struct {
-
-    uint8_t bitsPerPixel;		/* 8,16,32 only */
-
-    uint8_t depth;		/* 8 to 32 */
-
-    uint8_t bigEndian;		/* True if multi-byte pixels are interpreted
-				   as big endian, or if single-bit-per-pixel
-				   has most significant bit of the byte
-				   corresponding to first (leftmost) pixel. Of
-				   course this is meaningless for 8 bits/pix */
-
-    uint8_t trueColour;		/* If false then we need a "colour map" to
-				   convert pixels to RGB.  If true, xxxMax and
-				   xxxShift specify bits used for red, green
-				   and blue */
-
-    /* the following fields are only meaningful if trueColour is true */
-
-    uint16_t redMax;		/* maximum red value (= 2^n - 1 where n is the
-				   number of bits used for red). Note this
-				   value is always in big endian order. */
-
-    uint16_t greenMax;		/* similar for green */
-
-    uint16_t blueMax;		/* and blue */
-
-    uint8_t redShift;		/* number of shifts needed to get the red
-				   value in a pixel to the least significant
-				   bit. To find the red value from a given
-				   pixel, do the following:
-				   1) Swap pixel value according to bigEndian
-				      (e.g. if bigEndian is false and host byte
-				      order is big endian, then swap).
-				   2) Shift right by redShift.
-				   3) AND with redMax (in host byte order).
-				   4) You now have the red value between 0 and
-				      redMax. */
-
-    uint8_t greenShift;		/* similar for green */
-
-    uint8_t blueShift;		/* and blue */
-
-    uint8_t pad1;
-    uint16_t pad2;
-
-} rfbPixelFormat;
-
-#define sz_rfbPixelFormat 16
-
-/* UltraVNC: Color settings values */
-#define rfbPFFullColors		0
-#define rfbPF256Colors		1
-#define rfbPF64Colors		2
-#define rfbPF8Colors		3
-#define rfbPF8GreyColors	4
-#define rfbPF4GreyColors	5
-#define rfbPF2GreyColors	6
-
-
-/*****************************************************************************
- *
- * Initial handshaking messages
- *
- *****************************************************************************/
-
-/*-----------------------------------------------------------------------------
- * Protocol Version
- *
- * The server always sends 12 bytes to start which identifies the latest RFB
- * protocol version number which it supports.  These bytes are interpreted
- * as a string of 12 ASCII characters in the format "RFB xxx.yyy\n" where
- * xxx and yyy are the major and minor version numbers (for version 3.3
- * this is "RFB 003.003\n").
- *
- * The client then replies with a similar 12-byte message giving the version
- * number of the protocol which should actually be used (which may be different
- * to that quoted by the server).
- *
- * It is intended that both clients and servers may provide some level of
- * backwards compatibility by this mechanism.  Servers in particular should
- * attempt to provide backwards compatibility, and even forwards compatibility
- * to some extent.  For example if a client demands version 3.1 of the
- * protocol, a 3.0 server can probably assume that by ignoring requests for
- * encoding types it doesn't understand, everything will still work OK.  This
- * will probably not be the case for changes in the major version number.
- *
- * The format string below can be used in sprintf or sscanf to generate or
- * decode the version string respectively.
- */
-
-#define rfbProtocolVersionFormat "RFB %03d.%03d\n"
-#define rfbProtocolMajorVersion 3
-#define rfbProtocolMinorVersion 8
-/* UltraVNC Viewer examines rfbProtocolMinorVersion number (4, and 6)
- * to identify if the server supports File Transfer
- */
-
-typedef char rfbProtocolVersionMsg[13];	/* allow extra byte for null */
-
-#define sz_rfbProtocolVersionMsg 12
-
-/*
- * Negotiation of the security type (protocol version 3.7)
- *
- * Once the protocol version has been decided, the server either sends a list
- * of supported security types, or informs the client about an error (when the
- * number of security types is 0).  Security type rfbSecTypeTight is used to
- * enable TightVNC-specific protocol extensions.  The value rfbSecTypeVncAuth
- * stands for classic VNC authentication.
- *
- * The client selects a particular security type from the list provided by the
- * server.
- */
-
-#define rfbSecTypeInvalid 0
-#define rfbSecTypeNone 1
-#define rfbSecTypeVncAuth 2
-
-
-/*-----------------------------------------------------------------------------
- * Authentication
- *
- * Once the protocol version has been decided, the server then sends a 32-bit
- * word indicating whether any authentication is needed on the connection.
- * The value of this word determines the authentication scheme in use.  For
- * version 3.0 of the protocol this may have one of the following values:
- */
-
-#define rfbConnFailed 0
-#define rfbNoAuth 1
-#define rfbVncAuth 2
-
-#define rfbRA2 5
-#define rfbRA2ne 6
-#define rfbSSPI 7
-#define rfbSSPIne 8
-#define rfbTight 16
-#define rfbUltra 17
-#define rfbTLS 18
-#define rfbVeNCrypt 19
-#define rfbARD 30
-#define rfbMSLogon 0xfffffffa
-
-#define rfbVeNCryptPlain 256
-#define rfbVeNCryptTLSNone 257
-#define rfbVeNCryptTLSVNC 258
-#define rfbVeNCryptTLSPlain 259
-#define rfbVeNCryptX509None 260
-#define rfbVeNCryptX509VNC 261
-#define rfbVeNCryptX509Plain 262
-#define rfbVeNCryptX509SASL 263
-#define rfbVeNCryptTLSSASL 264
-
-/*
- * rfbConnFailed:	For some reason the connection failed (e.g. the server
- *			cannot support the desired protocol version).  This is
- *			followed by a string describing the reason (where a
- *			string is specified as a 32-bit length followed by that
- *			many ASCII characters).
- *
- * rfbNoAuth:		No authentication is needed.
- *
- * rfbVncAuth:		The VNC authentication scheme is to be used.  A 16-byte
- *			challenge follows, which the client encrypts as
- *			appropriate using the password and sends the resulting
- *			16-byte response.  If the response is correct, the
- *			server sends the 32-bit word rfbVncAuthOK.  If a simple
- *			failure happens, the server sends rfbVncAuthFailed and
- *			closes the connection. If the server decides that too
- *			many failures have occurred, it sends rfbVncAuthTooMany
- *			and closes the connection.  In the latter case, the
- *			server should not allow an immediate reconnection by
- *			the client.
- */
-
-#define rfbVncAuthOK 0
-#define rfbVncAuthFailed 1
-#define rfbVncAuthTooMany 2
-
-
-/*-----------------------------------------------------------------------------
- * Client Initialisation Message
- *
- * Once the client and server are sure that they're happy to talk to one
- * another, the client sends an initialisation message.  At present this
- * message only consists of a boolean indicating whether the server should try
- * to share the desktop by leaving other clients connected, or give exclusive
- * access to this client by disconnecting all other clients.
- */
-
-typedef struct {
-    uint8_t shared;
-} rfbClientInitMsg;
-
-#define sz_rfbClientInitMsg 1
-
-
-/*-----------------------------------------------------------------------------
- * Server Initialisation Message
- *
- * After the client initialisation message, the server sends one of its own.
- * This tells the client the width and height of the server's framebuffer,
- * its pixel format and the name associated with the desktop.
- */
-
-typedef struct {
-    uint16_t framebufferWidth;
-    uint16_t framebufferHeight;
-    rfbPixelFormat format;	/* the server's preferred pixel format */
-    uint32_t nameLength;
-    /* followed by char name[nameLength] */
-} rfbServerInitMsg;
-
-#define sz_rfbServerInitMsg (8 + sz_rfbPixelFormat)
-
-
-/*
- * Following the server initialisation message it's up to the client to send
- * whichever protocol messages it wants.  Typically it will send a
- * SetPixelFormat message and a SetEncodings message, followed by a
- * FramebufferUpdateRequest.  From then on the server will send
- * FramebufferUpdate messages in response to the client's
- * FramebufferUpdateRequest messages.  The client should send
- * FramebufferUpdateRequest messages with incremental set to true when it has
- * finished processing one FramebufferUpdate and is ready to process another.
- * With a fast client, the rate at which FramebufferUpdateRequests are sent
- * should be regulated to avoid hogging the network.
- */
-
-
-
-/*****************************************************************************
- *
- * Message types
- *
- *****************************************************************************/
-
-/* server -> client */
-
-#define rfbFramebufferUpdate 0
-#define rfbSetColourMapEntries 1
-#define rfbBell 2
-#define rfbServerCutText 3
-/* Modif sf@2002 */
-#define rfbResizeFrameBuffer 4
-#define rfbPalmVNCReSizeFrameBuffer 0xF
-
-/* client -> server */
-
-#define rfbSetPixelFormat 0
-#define rfbFixColourMapEntries 1	/* not currently supported */
-#define rfbSetEncodings 2
-#define rfbFramebufferUpdateRequest 3
-#define rfbKeyEvent 4
-#define rfbPointerEvent 5
-#define rfbClientCutText 6
-/* Modif sf@2002 - actually bidirectionnal */
-#define rfbFileTransfer 7
-/* Modif sf@2002 */
-#define rfbSetScale 8
-/* Modif rdv@2002 */
-#define rfbSetServerInput	9
-/* Modif rdv@2002 */
-#define rfbSetSW	10
-/* Modif sf@2002 - TextChat - Bidirectionnal */
-#define rfbTextChat	11
-/* Modif cs@2005 */
-/* PalmVNC 1.4 & 2.0 SetScale Factor message */
-#define rfbPalmVNCSetScaleFactor 0xF
-/* Xvp message - bidirectional */
-#define rfbXvp 250
-
-
-
-
-/*****************************************************************************
- *
- * Encoding types
- *
- *****************************************************************************/
-
-#define rfbEncodingRaw 0
-#define rfbEncodingCopyRect 1
-#define rfbEncodingRRE 2
-#define rfbEncodingCoRRE 4
-#define rfbEncodingHextile 5
-#define rfbEncodingZlib 6
-#define rfbEncodingTight 7
-#define rfbEncodingZlibHex 8
-#define rfbEncodingUltra 9
-#define rfbEncodingZRLE 16
-#define rfbEncodingZYWRLE 17
-
-/* Cache & XOR-Zlib - rdv@2002 */
-#define rfbEncodingCache                 0xFFFF0000
-#define rfbEncodingCacheEnable           0xFFFF0001
-#define rfbEncodingXOR_Zlib              0xFFFF0002
-#define rfbEncodingXORMonoColor_Zlib     0xFFFF0003
-#define rfbEncodingXORMultiColor_Zlib    0xFFFF0004
-#define rfbEncodingSolidColor            0xFFFF0005
-#define rfbEncodingXOREnable             0xFFFF0006
-#define rfbEncodingCacheZip              0xFFFF0007
-#define rfbEncodingSolMonoZip            0xFFFF0008
-#define rfbEncodingUltraZip              0xFFFF0009
-
-/* Xvp pseudo-encoding */
-#define rfbEncodingXvp 			 0xFFFFFECB
-
-/*
- * Special encoding numbers:
- *   0xFFFFFF00 .. 0xFFFFFF0F -- encoding-specific compression levels;
- *   0xFFFFFF10 .. 0xFFFFFF1F -- mouse cursor shape data;
- *   0xFFFFFF20 .. 0xFFFFFF2F -- various protocol extensions;
- *   0xFFFFFF30 .. 0xFFFFFFDF -- not allocated yet;
- *   0xFFFFFFE0 .. 0xFFFFFFEF -- quality level for JPEG compressor;
- *   0xFFFFFFF0 .. 0xFFFFFFFF -- cross-encoding compression levels.
- */
-
-#define rfbEncodingCompressLevel0  0xFFFFFF00
-#define rfbEncodingCompressLevel1  0xFFFFFF01
-#define rfbEncodingCompressLevel2  0xFFFFFF02
-#define rfbEncodingCompressLevel3  0xFFFFFF03
-#define rfbEncodingCompressLevel4  0xFFFFFF04
-#define rfbEncodingCompressLevel5  0xFFFFFF05
-#define rfbEncodingCompressLevel6  0xFFFFFF06
-#define rfbEncodingCompressLevel7  0xFFFFFF07
-#define rfbEncodingCompressLevel8  0xFFFFFF08
-#define rfbEncodingCompressLevel9  0xFFFFFF09
-
-#define rfbEncodingXCursor         0xFFFFFF10
-#define rfbEncodingRichCursor      0xFFFFFF11
-#define rfbEncodingPointerPos      0xFFFFFF18
-
-#define rfbEncodingLastRect           0xFFFFFF20
-#define rfbEncodingNewFBSize          0xFFFFFF21
-
-#define rfbEncodingQualityLevel0   0xFFFFFFE0
-#define rfbEncodingQualityLevel1   0xFFFFFFE1
-#define rfbEncodingQualityLevel2   0xFFFFFFE2
-#define rfbEncodingQualityLevel3   0xFFFFFFE3
-#define rfbEncodingQualityLevel4   0xFFFFFFE4
-#define rfbEncodingQualityLevel5   0xFFFFFFE5
-#define rfbEncodingQualityLevel6   0xFFFFFFE6
-#define rfbEncodingQualityLevel7   0xFFFFFFE7
-#define rfbEncodingQualityLevel8   0xFFFFFFE8
-#define rfbEncodingQualityLevel9   0xFFFFFFE9
-
-
-/* LibVNCServer additions.   We claim 0xFFFE0000 - 0xFFFE00FF */
-#define rfbEncodingKeyboardLedState   0xFFFE0000
-#define rfbEncodingSupportedMessages  0xFFFE0001
-#define rfbEncodingSupportedEncodings 0xFFFE0002
-#define rfbEncodingServerIdentity     0xFFFE0003
-
-
-/*****************************************************************************
- *
- * Server -> client message definitions
- *
- *****************************************************************************/
-
-
-/*-----------------------------------------------------------------------------
- * FramebufferUpdate - a block of rectangles to be copied to the framebuffer.
- *
- * This message consists of a header giving the number of rectangles of pixel
- * data followed by the rectangles themselves.  The header is padded so that
- * together with the type byte it is an exact multiple of 4 bytes (to help
- * with alignment of 32-bit pixels):
- */
-
-typedef struct {
-    uint8_t type;			/* always rfbFramebufferUpdate */
-    uint8_t pad;
-    uint16_t nRects;
-    /* followed by nRects rectangles */
-} rfbFramebufferUpdateMsg;
-
-#define sz_rfbFramebufferUpdateMsg 4
-
-/*
- * Each rectangle of pixel data consists of a header describing the position
- * and size of the rectangle and a type word describing the encoding of the
- * pixel data, followed finally by the pixel data.  Note that if the client has
- * not sent a SetEncodings message then it will only receive raw pixel data.
- * Also note again that this structure is a multiple of 4 bytes.
- */
-
-typedef struct {
-    rfbRectangle r;
-    uint32_t encoding;	/* one of the encoding types rfbEncoding... */
-} rfbFramebufferUpdateRectHeader;
-
-#define sz_rfbFramebufferUpdateRectHeader (sz_rfbRectangle + 4)
-
-/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- * Supported Messages Encoding.  This encoding does not contain any pixel data.
- * Instead, it contains 2 sets of bitflags.  These bitflags indicate what messages
- * are supported by the server.
- * rect->w contains byte count
- */
-
-typedef struct {
-  uint8_t client2server[32]; /* maximum of 256 message types (256/8)=32 */
-  uint8_t server2client[32]; /* maximum of 256 message types (256/8)=32 */
-} rfbSupportedMessages;
-
-#define sz_rfbSupportedMessages 64
-
-/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- * Supported Encodings Encoding.  This encoding does not contain any pixel data.
- * Instead, it contains a list of (uint32_t) Encodings supported by this server.
- * rect->w contains byte count
- * rect->h contains encoding count
- */
-
-/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- * Server Identity Encoding.  This encoding does not contain any pixel data.
- * Instead, it contains a text string containing information about the server.
- * ie: "x11vnc: 0.8.1 lastmod: 2006-04-25 (libvncserver 0.9pre)\0"
- * rect->w contains byte count
- */
-
-
-/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- * Raw Encoding.  Pixels are sent in top-to-bottom scanline order,
- * left-to-right within a scanline with no padding in between.
- */
-
-/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- * KeyboardLedState Encoding.  The X coordinate contains the Locked Modifiers
- * so that a remote troubleshooter can identify that the users 'Caps Lock' 
- * is set...   (It helps a *lot* when the users are untrained)
- */
-#define rfbKeyboardMaskShift        1
-#define rfbKeyboardMaskCapsLock     2
-#define rfbKeyboardMaskControl      4
-#define rfbKeyboardMaskAlt          8
-#define rfbKeyboardMaskMeta        16
-#define rfbKeyboardMaskSuper       32
-#define rfbKeyboardMaskHyper       64
-#define rfbKeyboardMaskNumLock    128
-#define rfbKeyboardMaskScrollLock 256
-#define rfbKeyboardMaskAltGraph   512
-
-/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- * CopyRect Encoding.  The pixels are specified simply by the x and y position
- * of the source rectangle.
- */
-
-typedef struct {
-    uint16_t srcX;
-    uint16_t srcY;
-} rfbCopyRect;
-
-#define sz_rfbCopyRect 4
-
-
-/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- * RRE - Rise-and-Run-length Encoding.  We have an rfbRREHeader structure
- * giving the number of subrectangles following.  Finally the data follows in
- * the form [<bgpixel><subrect><subrect>...] where each <subrect> is
- * [<pixel><rfbRectangle>].
- */
-
-typedef struct {
-    uint32_t nSubrects;
-} rfbRREHeader;
-
-#define sz_rfbRREHeader 4
-
-
-/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- * CoRRE - Compact RRE Encoding.  We have an rfbRREHeader structure giving
- * the number of subrectangles following.  Finally the data follows in the form
- * [<bgpixel><subrect><subrect>...] where each <subrect> is
- * [<pixel><rfbCoRRERectangle>].  This means that
- * the whole rectangle must be at most 255x255 pixels.
- */
-
-typedef struct {
-    uint8_t x;
-    uint8_t y;
-    uint8_t w;
-    uint8_t h;
-} rfbCoRRERectangle;
-
-#define sz_rfbCoRRERectangle 4
-
-
-/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- * Hextile Encoding.  The rectangle is divided up into "tiles" of 16x16 pixels,
- * starting at the top left going in left-to-right, top-to-bottom order.  If
- * the width of the rectangle is not an exact multiple of 16 then the width of
- * the last tile in each row will be correspondingly smaller.  Similarly if the
- * height is not an exact multiple of 16 then the height of each tile in the
- * final row will also be smaller.  Each tile begins with a "subencoding" type
- * byte, which is a mask made up of a number of bits.  If the Raw bit is set
- * then the other bits are irrelevant; w*h pixel values follow (where w and h
- * are the width and height of the tile).  Otherwise the tile is encoded in a
- * similar way to RRE, except that the position and size of each subrectangle
- * can be specified in just two bytes.  The other bits in the mask are as
- * follows:
- *
- * BackgroundSpecified - if set, a pixel value follows which specifies
- *    the background colour for this tile.  The first non-raw tile in a
- *    rectangle must have this bit set.  If this bit isn't set then the
- *    background is the same as the last tile.
- *
- * ForegroundSpecified - if set, a pixel value follows which specifies
- *    the foreground colour to be used for all subrectangles in this tile.
- *    If this bit is set then the SubrectsColoured bit must be zero.
- *
- * AnySubrects - if set, a single byte follows giving the number of
- *    subrectangles following.  If not set, there are no subrectangles (i.e.
- *    the whole tile is just solid background colour).
- *
- * SubrectsColoured - if set then each subrectangle is preceded by a pixel
- *    value giving the colour of that subrectangle.  If not set, all
- *    subrectangles are the same colour, the foreground colour;  if the
- *    ForegroundSpecified bit wasn't set then the foreground is the same as
- *    the last tile.
- *
- * The position and size of each subrectangle is specified in two bytes.  The
- * Pack macros below can be used to generate the two bytes from x, y, w, h,
- * and the Extract macros can be used to extract the x, y, w, h values from
- * the two bytes.
- */
-
-#define rfbHextileRaw			(1 << 0)
-#define rfbHextileBackgroundSpecified	(1 << 1)
-#define rfbHextileForegroundSpecified	(1 << 2)
-#define rfbHextileAnySubrects		(1 << 3)
-#define rfbHextileSubrectsColoured	(1 << 4)
-
-#define rfbHextilePackXY(x,y) (((x) << 4) | (y))
-#define rfbHextilePackWH(w,h) ((((w)-1) << 4) | ((h)-1))
-#define rfbHextileExtractX(byte) ((byte) >> 4)
-#define rfbHextileExtractY(byte) ((byte) & 0xf)
-#define rfbHextileExtractW(byte) (((byte) >> 4) + 1)
-#define rfbHextileExtractH(byte) (((byte) & 0xf) + 1)
-
-/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- * zlib - zlib compressed Encoding.  We have an rfbZlibHeader structure
- * giving the number of bytes following.  Finally the data follows is
- * zlib compressed version of the raw pixel data as negotiated.
- * (NOTE: also used by Ultra Encoding)
- */
-
-typedef struct {
-    uint32_t nBytes;
-} rfbZlibHeader;
-
-#define sz_rfbZlibHeader 4
-
-#ifdef LIBVNCSERVER_HAVE_LIBZ
-
-/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- * Tight Encoding.
- *
- *-- The first byte of each Tight-encoded rectangle is a "compression control
- *   byte". Its format is as follows (bit 0 is the least significant one):
- *
- *   bit 0:    if 1, then compression stream 0 should be reset;
- *   bit 1:    if 1, then compression stream 1 should be reset;
- *   bit 2:    if 1, then compression stream 2 should be reset;
- *   bit 3:    if 1, then compression stream 3 should be reset;
- *   bits 7-4: if 1000 (0x08), then the compression type is "fill",
- *             if 1001 (0x09), then the compression type is "jpeg",
- *             if 0xxx, then the compression type is "basic",
- *             values greater than 1001 are not valid.
- *
- * If the compression type is "basic", then bits 6..4 of the
- * compression control byte (those xxx in 0xxx) specify the following:
- *
- *   bits 5-4:  decimal representation is the index of a particular zlib
- *              stream which should be used for decompressing the data;
- *   bit 6:     if 1, then a "filter id" byte is following this byte.
- *
- *-- The data that follows after the compression control byte described
- * above depends on the compression type ("fill", "jpeg" or "basic").
- *
- *-- If the compression type is "fill", then the only pixel value follows, in
- * client pixel format (see NOTE 1). This value applies to all pixels of the
- * rectangle.
- *
- *-- If the compression type is "jpeg", the following data stream looks like
- * this:
- *
- *   1..3 bytes:  data size (N) in compact representation;
- *   N bytes:     JPEG image.
- *
- * Data size is compactly represented in one, two or three bytes, according
- * to the following scheme:
- *
- *  0xxxxxxx                    (for values 0..127)
- *  1xxxxxxx 0yyyyyyy           (for values 128..16383)
- *  1xxxxxxx 1yyyyyyy zzzzzzzz  (for values 16384..4194303)
- *
- * Here each character denotes one bit, xxxxxxx are the least significant 7
- * bits of the value (bits 0-6), yyyyyyy are bits 7-13, and zzzzzzzz are the
- * most significant 8 bits (bits 14-21). For example, decimal value 10000
- * should be represented as two bytes: binary 10010000 01001110, or
- * hexadecimal 90 4E.
- *
- *-- If the compression type is "basic" and bit 6 of the compression control
- * byte was set to 1, then the next (second) byte specifies "filter id" which
- * tells the decoder what filter type was used by the encoder to pre-process
- * pixel data before the compression. The "filter id" byte can be one of the
- * following:
- *
- *   0:  no filter ("copy" filter);
- *   1:  "palette" filter;
- *   2:  "gradient" filter.
- *
- *-- If bit 6 of the compression control byte is set to 0 (no "filter id"
- * byte), or if the filter id is 0, then raw pixel values in the client
- * format (see NOTE 1) will be compressed. See below details on the
- * compression.
- *
- *-- The "gradient" filter pre-processes pixel data with a simple algorithm
- * which converts each color component to a difference between a "predicted"
- * intensity and the actual intensity. Such a technique does not affect
- * uncompressed data size, but helps to compress photo-like images better. 
- * Pseudo-code for converting intensities to differences is the following:
- *
- *   P[i,j] := V[i-1,j] + V[i,j-1] - V[i-1,j-1];
- *   if (P[i,j] < 0) then P[i,j] := 0;
- *   if (P[i,j] > MAX) then P[i,j] := MAX;
- *   D[i,j] := V[i,j] - P[i,j];
- *
- * Here V[i,j] is the intensity of a color component for a pixel at
- * coordinates (i,j). MAX is the maximum value of intensity for a color
- * component.
- *
- *-- The "palette" filter converts true-color pixel data to indexed colors
- * and a palette which can consist of 2..256 colors. If the number of colors
- * is 2, then each pixel is encoded in 1 bit, otherwise 8 bits is used to
- * encode one pixel. 1-bit encoding is performed such way that the most
- * significant bits correspond to the leftmost pixels, and each raw of pixels
- * is aligned to the byte boundary. When "palette" filter is used, the
- * palette is sent before the pixel data. The palette begins with an unsigned
- * byte which value is the number of colors in the palette minus 1 (i.e. 1
- * means 2 colors, 255 means 256 colors in the palette). Then follows the
- * palette itself which consist of pixel values in client pixel format (see
- * NOTE 1).
- *
- *-- The pixel data is compressed using the zlib library. But if the data
- * size after applying the filter but before the compression is less then 12,
- * then the data is sent as is, uncompressed. Four separate zlib streams
- * (0..3) can be used and the decoder should read the actual stream id from
- * the compression control byte (see NOTE 2).
- *
- * If the compression is not used, then the pixel data is sent as is,
- * otherwise the data stream looks like this:
- *
- *   1..3 bytes:  data size (N) in compact representation;
- *   N bytes:     zlib-compressed data.
- *
- * Data size is compactly represented in one, two or three bytes, just like
- * in the "jpeg" compression method (see above).
- *
- *-- NOTE 1. If the color depth is 24, and all three color components are
- * 8-bit wide, then one pixel in Tight encoding is always represented by
- * three bytes, where the first byte is red component, the second byte is
- * green component, and the third byte is blue component of the pixel color
- * value. This applies to colors in palettes as well.
- *
- *-- NOTE 2. The decoder must reset compression streams' states before
- * decoding the rectangle, if some of bits 0,1,2,3 in the compression control
- * byte are set to 1. Note that the decoder must reset zlib streams even if
- * the compression type is "fill" or "jpeg".
- *
- *-- NOTE 3. The "gradient" filter and "jpeg" compression may be used only
- * when bits-per-pixel value is either 16 or 32, not 8.
- *
- *-- NOTE 4. The width of any Tight-encoded rectangle cannot exceed 2048
- * pixels. If a rectangle is wider, it must be split into several rectangles
- * and each one should be encoded separately.
- *
- */
-
-#define rfbTightExplicitFilter         0x04
-#define rfbTightFill                   0x08
-#define rfbTightJpeg                   0x09
-#define rfbTightMaxSubencoding         0x09
-
-/* Filters to improve compression efficiency */
-#define rfbTightFilterCopy             0x00
-#define rfbTightFilterPalette          0x01
-#define rfbTightFilterGradient         0x02
-
-#endif
-
-/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- * XCursor encoding. This is a special encoding used to transmit X-style
- * cursor shapes from server to clients. Note that for this encoding,
- * coordinates in rfbFramebufferUpdateRectHeader structure hold hotspot
- * position (r.x, r.y) and cursor size (r.w, r.h). If (w * h != 0), two RGB
- * samples are sent after header in the rfbXCursorColors structure. They
- * denote foreground and background colors of the cursor. If a client
- * supports only black-and-white cursors, it should ignore these colors and
- * assume that foreground is black and background is white. Next, two bitmaps
- * (1 bits per pixel) follow: first one with actual data (value 0 denotes
- * background color, value 1 denotes foreground color), second one with
- * transparency data (bits with zero value mean that these pixels are
- * transparent). Both bitmaps represent cursor data in a byte stream, from
- * left to right, from top to bottom, and each row is byte-aligned. Most
- * significant bits correspond to leftmost pixels. The number of bytes in
- * each row can be calculated as ((w + 7) / 8). If (w * h == 0), cursor
- * should be hidden (or default local cursor should be set by the client).
- */
-
-typedef struct {
-    uint8_t foreRed;
-    uint8_t foreGreen;
-    uint8_t foreBlue;
-    uint8_t backRed;
-    uint8_t backGreen;
-    uint8_t backBlue;
-} rfbXCursorColors;
-
-#define sz_rfbXCursorColors 6
-
-
-/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- * RichCursor encoding. This is a special encoding used to transmit cursor
- * shapes from server to clients. It is similar to the XCursor encoding but
- * uses client pixel format instead of two RGB colors to represent cursor
- * image. For this encoding, coordinates in rfbFramebufferUpdateRectHeader
- * structure hold hotspot position (r.x, r.y) and cursor size (r.w, r.h).
- * After header, two pixmaps follow: first one with cursor image in current
- * client pixel format (like in raw encoding), second with transparency data
- * (1 bit per pixel, exactly the same format as used for transparency bitmap
- * in the XCursor encoding). If (w * h == 0), cursor should be hidden (or
- * default local cursor should be set by the client).
- */
-
-
-/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- * ZRLE - encoding combining Zlib compression, tiling, palettisation and
- * run-length encoding.
- */
-
-typedef struct {
-    uint32_t length;
-} rfbZRLEHeader;
-
-#define sz_rfbZRLEHeader 4
-
-#define rfbZRLETileWidth 64
-#define rfbZRLETileHeight 64
-
-
-/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- * ZLIBHEX - zlib compressed Hextile Encoding.  Essentially, this is the
- * hextile encoding with zlib compression on the tiles that can not be
- * efficiently encoded with one of the other hextile subencodings.  The
- * new zlib subencoding uses two bytes to specify the length of the
- * compressed tile and then the compressed data follows.  As with the
- * raw sub-encoding, the zlib subencoding invalidates the other
- * values, if they are also set.
- */
-
-#define rfbHextileZlibRaw		(1 << 5)
-#define rfbHextileZlibHex		(1 << 6)
-#define rfbHextileZlibMono		(1 << 7)
-
-
-/*-----------------------------------------------------------------------------
- * SetColourMapEntries - these messages are only sent if the pixel
- * format uses a "colour map" (i.e. trueColour false) and the client has not
- * fixed the entire colour map using FixColourMapEntries.  In addition they
- * will only start being sent after the client has sent its first
- * FramebufferUpdateRequest.  So if the client always tells the server to use
- * trueColour then it never needs to process this type of message.
- */
-
-typedef struct {
-    uint8_t type;			/* always rfbSetColourMapEntries */
-    uint8_t pad;
-    uint16_t firstColour;
-    uint16_t nColours;
-
-    /* Followed by nColours * 3 * uint16_t
-       r1, g1, b1, r2, g2, b2, r3, g3, b3, ..., rn, bn, gn */
-
-} rfbSetColourMapEntriesMsg;
-
-#define sz_rfbSetColourMapEntriesMsg 6
-
-
-
-/*-----------------------------------------------------------------------------
- * Bell - ring a bell on the client if it has one.
- */
-
-typedef struct {
-    uint8_t type;			/* always rfbBell */
-} rfbBellMsg;
-
-#define sz_rfbBellMsg 1
-
-
-
-/*-----------------------------------------------------------------------------
- * ServerCutText - the server has new text in its cut buffer.
- */
-
-typedef struct {
-    uint8_t type;			/* always rfbServerCutText */
-    uint8_t pad1;
-    uint16_t pad2;
-    uint32_t length;
-    /* followed by char text[length] */
-} rfbServerCutTextMsg;
-
-#define sz_rfbServerCutTextMsg 8
-
-
-/*-----------------------------------------------------------------------------
- * //  Modif sf@2002
- * FileTransferMsg - The client sends FileTransfer message.
- * Bidirectional message - Files can be sent from client to server & vice versa
- */
-
-typedef struct _rfbFileTransferMsg {
-    uint8_t type;			/* always rfbFileTransfer */
-    uint8_t contentType;  /*  See defines below */
-    uint8_t contentParam;/*  Other possible content classification (Dir or File name, etc..) */
-    uint8_t pad;         /* It appears that UltraVNC *forgot* to Swap16IfLE(contentParam) */
-    uint32_t size;		/*  FileSize or packet index or error or other  */
-/*  uint32_t sizeH;		 Additional 32Bits params to handle big values. Only for V2 (we want backward compatibility between all V1 versions) */
-    uint32_t length;
-    /* followed by data char text[length] */
-} rfbFileTransferMsg;
-
-#define sz_rfbFileTransferMsg	12
-
-#define rfbFileTransferVersion  2 /*  v1 is the old FT version ( <= 1.0.0 RC18 versions) */
-
-/*  FileTransfer Content types and Params defines */
-#define rfbDirContentRequest	1 /*  Client asks for the content of a given Server directory */
-#define rfbDirPacket			2 /*  Full directory name or full file name. */
-								  /*  Null content means end of Directory */
-#define rfbFileTransferRequest	3 /*  Client asks the server for the transfer of a given file */
-#define rfbFileHeader			4 /*  First packet of a file transfer, containing file's features */
-#define rfbFilePacket			5 /*  One chunk of the file */
-#define rfbEndOfFile			6 /*  End of file transfer (the file has been received or error) */
-#define rfbAbortFileTransfer	7 /*  The file transfer must be aborted, whatever the state */
-#define rfbFileTransferOffer	8 /*  The client offers to send a file to the server */
-#define rfbFileAcceptHeader		9 /*  The server accepts or rejects the file */
-#define rfbCommand				10 /*  The Client sends a simple command (File Delete, Dir create etc...) */
-#define rfbCommandReturn		11 /*  The Client receives the server's answer about a simple command */
-#define rfbFileChecksums		12 /*  The zipped checksums of the destination file (Delta Transfer) */
-#define rfbFileTransferAccess	14 /*  Request FileTransfer authorization */
-
-								/*  rfbDirContentRequest client Request - content params  */
-#define rfbRDirContent			1 /*  Request a Server Directory contents */
-#define rfbRDrivesList			2 /*  Request the server's drives list */
-#define rfbRDirRecursiveList	3 /*  Request a server directory content recursive sorted list */
-#define rfbRDirRecursiveSize	4 /*  Request a server directory content recursive size */
-
-								/*  rfbDirPacket & rfbCommandReturn  server Answer - content params */
-#define rfbADirectory			1 /*  Reception of a directory name */
-#define rfbAFile				2 /*  Reception of a file name  */
-#define rfbADrivesList			3 /*  Reception of a list of drives */
-#define rfbADirCreate			4 /*  Response to a create dir command  */
-#define rfbADirDelete			5 /*  Response to a delete dir command  */
-#define rfbAFileCreate			6 /*  Response to a create file command  */
-#define rfbAFileDelete			7 /*  Response to a delete file command  */
-#define rfbAFileRename			8 /*  Response to a rename file command  */
-#define rfbADirRename			9 /*  Response to a rename dir command  */
-#define rfbADirRecursiveListItem	10 
-#define rfbADirRecursiveSize		11 
-
-								/*  rfbCommand Command - content params */
-#define rfbCDirCreate			1 /*  Request the server to create the given directory */
-#define rfbCDirDelete			2 /*  Request the server to delete the given directory */
-#define rfbCFileCreate			3 /*  Request the server to create the given file */
-#define rfbCFileDelete			4 /*  Request the server to delete the given file */
-#define rfbCFileRename			5 /*  Request the server to rename the given file  */
-#define rfbCDirRename			6 /*  Request the server to rename the given directory */
-
-								/*  Errors - content params or "size" field */
-#define rfbRErrorUnknownCmd     1  /*  Unknown FileTransfer command. */
-#define rfbRErrorCmd			0xFFFFFFFF/*  Error when a command fails on remote side (ret in "size" field) */
-
-#define sz_rfbBlockSize			8192  /*  Size of a File Transfer packet (before compression) */
-#define rfbZipDirectoryPrefix   "!UVNCDIR-\0" /*  Transfered directory are zipped in a file with this prefix. Must end with "-" */
-#define sz_rfbZipDirectoryPrefix 9 
-#define rfbDirPrefix			"[ "
-#define rfbDirSuffix			" ]"		
-
-
-
-/*-----------------------------------------------------------------------------
- * Modif sf@2002
- * TextChatMsg - Utilized to order the TextChat mode on server or client
- * Bidirectional message
- */
-
-typedef struct _rfbTextChatMsg {
-    uint8_t type;			/* always rfbTextChat */
-    uint8_t pad1;         /*  Could be used later as an additionnal param */
-    uint16_t pad2;		/*  Could be used later as text offset, for instance */
-    uint32_t length;      /*  Specific values for Open, close, finished (-1, -2, -3) */
-    /* followed by char text[length] */
-} rfbTextChatMsg;
-
-#define sz_rfbTextChatMsg 8
-
-#define rfbTextMaxSize		4096
-#define rfbTextChatOpen		0xFFFFFFFF 
-#define rfbTextChatClose	0xFFFFFFFE  
-#define rfbTextChatFinished 0xFFFFFFFD  
-
-
-/*-----------------------------------------------------------------------------
- * Xvp Message
- * Bidirectional message
- * A server which supports the xvp extension declares this by sending a message
- * with an Xvp_INIT xvp-message-code when it receives a request from the client
- * to use the xvp Pseudo-encoding. The server must specify in this message the
- * highest xvp-extension-version it supports: the client may assume that the
- * server supports all versions from 1 up to this value. The client is then
- * free to use any supported version. Currently, only version 1 is defined.
- *
- * A server which subsequently receives an xvp Client Message requesting an
- * operation which it is unable to perform, informs the client of this by
- * sending a message with an Xvp_FAIL xvp-message-code, and the same
- * xvp-extension-version as included in the client's operation request.
- *
- * A client supporting the xvp extension sends this to request that the server
- * initiate a clean shutdown, clean reboot or abrupt reset of the system whose
- * framebuffer the client is displaying.
- */
-
-
-typedef struct {
-    uint8_t type;			/* always rfbXvp */
-	uint8_t pad;
-	uint8_t version;	/* xvp extension version */
-	uint8_t code;      	/* xvp message code */
-} rfbXvpMsg;
-
-#define sz_rfbXvpMsg (4)
-
-/* server message codes */
-#define rfbXvp_Fail 0
-#define rfbXvp_Init 1
-/* client message codes */
-#define rfbXvp_Shutdown 2
-#define rfbXvp_Reboot 3
-#define rfbXvp_Reset 4
-
-
-/*-----------------------------------------------------------------------------
- * Modif sf@2002
- * ResizeFrameBuffer - The Client must change the size of its framebuffer  
- */
-
-typedef struct _rfbResizeFrameBufferMsg {
-    uint8_t type;			/* always rfbResizeFrameBuffer */
-	uint8_t pad1;
-	uint16_t framebufferWidth;	/*  FrameBuffer width */
-	uint16_t framebufferHeigth;	/*  FrameBuffer height */
-} rfbResizeFrameBufferMsg;
-
-#define sz_rfbResizeFrameBufferMsg 6
-
-
-/*-----------------------------------------------------------------------------
- * Copyright (C) 2001 Harakan Software
- * PalmVNC 1.4 & 2.? ResizeFrameBuffer message
- * ReSizeFrameBuffer - tell the RFB client to alter its framebuffer, either
- * due to a resize of the server desktop or a client-requested scaling factor.
- * The pixel format remains unchanged.
- */
-
-typedef struct {
-    uint8_t type;			/* always rfbReSizeFrameBuffer */
-	uint8_t pad1;
-	uint16_t desktop_w;	/* Desktop width */
-	uint16_t desktop_h;	/* Desktop height */
-	uint16_t buffer_w;	/* FrameBuffer width */
-	uint16_t buffer_h;	/* Framebuffer height */
-    uint16_t pad2;
-
-} rfbPalmVNCReSizeFrameBufferMsg;
-
-#define sz_rfbPalmVNCReSizeFrameBufferMsg (12)
-
-
-
-
-/*-----------------------------------------------------------------------------
- * Union of all server->client messages.
- */
-
-typedef union {
-    uint8_t type;
-    rfbFramebufferUpdateMsg fu;
-    rfbSetColourMapEntriesMsg scme;
-    rfbBellMsg b;
-    rfbServerCutTextMsg sct;
-	rfbResizeFrameBufferMsg rsfb;
-	rfbPalmVNCReSizeFrameBufferMsg prsfb; 
-	rfbFileTransferMsg ft;
-	rfbTextChatMsg tc;
-        rfbXvpMsg xvp;
-} rfbServerToClientMsg;
-
-
-
-/*- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- * RDV Cache Encoding.  
- * special is not used at this point, can be used to reset cache or other specials
- * just put it to make sure we don't have to change the encoding again.  
- */
-
-typedef struct {
-    uint16_t special;
-} rfbCacheRect;
-
-#define sz_rfbCacheRect 2
-
-
-
-
-/*****************************************************************************
- *
- * Message definitions (client -> server)
- *
- *****************************************************************************/
-
-
-/*-----------------------------------------------------------------------------
- * SetPixelFormat - tell the RFB server the format in which the client wants
- * pixels sent.
- */
-
-typedef struct {
-    uint8_t type;			/* always rfbSetPixelFormat */
-    uint8_t pad1;
-    uint16_t pad2;
-    rfbPixelFormat format;
-} rfbSetPixelFormatMsg;
-
-#define sz_rfbSetPixelFormatMsg (sz_rfbPixelFormat + 4)
-
-
-/*-----------------------------------------------------------------------------
- * FixColourMapEntries - when the pixel format uses a "colour map", fix
- * read-only colour map entries.
- *
- *    ***************** NOT CURRENTLY SUPPORTED *****************
- */
-
-typedef struct {
-    uint8_t type;			/* always rfbFixColourMapEntries */
-    uint8_t pad;
-    uint16_t firstColour;
-    uint16_t nColours;
-
-    /* Followed by nColours * 3 * uint16_t
-       r1, g1, b1, r2, g2, b2, r3, g3, b3, ..., rn, bn, gn */
-
-} rfbFixColourMapEntriesMsg;
-
-#define sz_rfbFixColourMapEntriesMsg 6
-
-
-/*-----------------------------------------------------------------------------
- * SetEncodings - tell the RFB server which encoding types we accept.  Put them
- * in order of preference, if we have any.  We may always receive raw
- * encoding, even if we don't specify it here.
- */
-
-typedef struct {
-    uint8_t type;			/* always rfbSetEncodings */
-    uint8_t pad;
-    uint16_t nEncodings;
-    /* followed by nEncodings * uint32_t encoding types */
-} rfbSetEncodingsMsg;
-
-#define sz_rfbSetEncodingsMsg 4
-
-
-/*-----------------------------------------------------------------------------
- * FramebufferUpdateRequest - request for a framebuffer update.  If incremental
- * is true then the client just wants the changes since the last update.  If
- * false then it wants the whole of the specified rectangle.
- */
-
-typedef struct {
-    uint8_t type;			/* always rfbFramebufferUpdateRequest */
-    uint8_t incremental;
-    uint16_t x;
-    uint16_t y;
-    uint16_t w;
-    uint16_t h;
-} rfbFramebufferUpdateRequestMsg;
-
-#define sz_rfbFramebufferUpdateRequestMsg 10
-
-
-/*-----------------------------------------------------------------------------
- * KeyEvent - key press or release
- *
- * Keys are specified using the "keysym" values defined by the X Window System.
- * For most ordinary keys, the keysym is the same as the corresponding ASCII
- * value.  Other common keys are:
- *
- * BackSpace		0xff08
- * Tab			0xff09
- * Return or Enter	0xff0d
- * Escape		0xff1b
- * Insert		0xff63
- * Delete		0xffff
- * Home			0xff50
- * End			0xff57
- * Page Up		0xff55
- * Page Down		0xff56
- * Left			0xff51
- * Up			0xff52
- * Right		0xff53
- * Down			0xff54
- * F1			0xffbe
- * F2			0xffbf
- * ...			...
- * F12			0xffc9
- * Shift		0xffe1
- * Control		0xffe3
- * Meta			0xffe7
- * Alt			0xffe9
- */
-
-typedef struct {
-    uint8_t type;			/* always rfbKeyEvent */
-    uint8_t down;			/* true if down (press), false if up */
-    uint16_t pad;
-    uint32_t key;			/* key is specified as an X keysym */
-} rfbKeyEventMsg;
-
-#define sz_rfbKeyEventMsg 8
-
-
-/*-----------------------------------------------------------------------------
- * PointerEvent - mouse/pen move and/or button press.
- */
-
-typedef struct {
-    uint8_t type;			/* always rfbPointerEvent */
-    uint8_t buttonMask;		/* bits 0-7 are buttons 1-8, 0=up, 1=down */
-    uint16_t x;
-    uint16_t y;
-} rfbPointerEventMsg;
-
-#define rfbButton1Mask 1
-#define rfbButton2Mask 2
-#define rfbButton3Mask 4
-#define rfbButton4Mask 8
-#define rfbButton5Mask 16
-/* RealVNC 335 method */
-#define rfbWheelUpMask rfbButton4Mask
-#define rfbWheelDownMask rfbButton5Mask
-
-#define sz_rfbPointerEventMsg 6
-
-
-
-/*-----------------------------------------------------------------------------
- * ClientCutText - the client has new text in its cut buffer.
- */
-
-typedef struct {
-    uint8_t type;			/* always rfbClientCutText */
-    uint8_t pad1;
-    uint16_t pad2;
-    uint32_t length;
-    /* followed by char text[length] */
-} rfbClientCutTextMsg;
-
-#define sz_rfbClientCutTextMsg 8
-
-
-
-/*-----------------------------------------------------------------------------
- * sf@2002 - Set Server Scale
- * SetServerScale - Server must change the scale of the client buffer.
- */
-
-typedef struct _rfbSetScaleMsg {
-    uint8_t type;			/* always rfbSetScale */
-    uint8_t scale;		/* Scale value 1<sv<n */
-    uint16_t pad;
-} rfbSetScaleMsg;
-
-#define sz_rfbSetScaleMsg 4
-
-
-/*-----------------------------------------------------------------------------
- * Copyright (C) 2001 Harakan Software
- * PalmVNC 1.4 & 2.? SetScale Factor message 
- * SetScaleFactor - tell the RFB server to alter the scale factor for the
- * client buffer.
- */
-typedef struct {
-    uint8_t type;			/* always rfbPalmVNCSetScaleFactor */
-
-    uint8_t scale;		/* Scale factor (positive non-zero integer) */
-    uint16_t pad2;
-} rfbPalmVNCSetScaleFactorMsg;
-
-#define sz_rfbPalmVNCSetScaleFactorMsg (4)
-
-
-/*-----------------------------------------------------------------------------
- * rdv@2002 - Set input status
- * SetServerInput - Server input is dis/enabled
- */
-
-typedef struct _rfbSetServerInputMsg {
-    uint8_t type;			/* always rfbSetScale */
-    uint8_t status;		/* Scale value 1<sv<n */
-    uint16_t pad;
-} rfbSetServerInputMsg;
-
-#define sz_rfbSetServerInputMsg 4
-
-/*-----------------------------------------------------------------------------
- * rdv@2002 - Set SW
- * SetSW - Server SW/full desktop
- */
-
-typedef struct _rfbSetSWMsg {
-    uint8_t type;			/* always rfbSetSW */
-    uint8_t status;		
-    uint16_t x;
-    uint16_t y;
-} rfbSetSWMsg;
-
-#define sz_rfbSetSWMsg 6
-
-
-
-/*-----------------------------------------------------------------------------
- * Union of all client->server messages.
- */
-
-typedef union {
-    uint8_t type;
-    rfbSetPixelFormatMsg spf;
-    rfbFixColourMapEntriesMsg fcme;
-    rfbSetEncodingsMsg se;
-    rfbFramebufferUpdateRequestMsg fur;
-    rfbKeyEventMsg ke;
-    rfbPointerEventMsg pe;
-    rfbClientCutTextMsg cct;
-	rfbSetScaleMsg ssc;
-	rfbPalmVNCSetScaleFactorMsg pssf;
-	rfbSetServerInputMsg sim;
-	rfbFileTransferMsg ft;
-	rfbSetSWMsg sw;
-	rfbTextChatMsg tc;
-        rfbXvpMsg xvp;
-} rfbClientToServerMsg;
-
-/* 
- * vncauth.h - describes the functions provided by the vncauth library.
- */
-
-#define MAXPWLEN 8
-#define CHALLENGESIZE 16
-
-extern int rfbEncryptAndStorePasswd(char *passwd, char *fname);
-extern char *rfbDecryptPasswdFromFile(char *fname);
-extern void rfbRandomBytes(unsigned char *bytes);
-extern void rfbEncryptBytes(unsigned char *bytes, char *passwd);
-
-
-#endif
diff -urN remmina-plugins/vnc/libvncserver/rfb/rfbregion.h remmina-plugins/vnc/libvncserver/rfb/rfbregion.h
--- remmina-plugins/vnc/libvncserver/rfb/rfbregion.h	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins/vnc/libvncserver/rfb/rfbregion.h	1970-01-01 10:00:00.000000000 +1000
@@ -1,65 +0,0 @@
-#ifndef SRAREGION_H
-#define SRAREGION_H
-
-/* -=- SRA - Simple Region Algorithm
- * A simple rectangular region implementation.
- * Copyright (c) 2001 James "Wez" Weatherall, Johannes E. Schindelin
- */
-
-/* -=- sraRect */
-
-typedef struct _rect {
-	int x1;
-	int y1;
-	int x2;
-	int y2;
-} sraRect;
-
-typedef struct sraRegion sraRegion;
-
-/* -=- Region manipulation functions */
-
-extern sraRegion *sraRgnCreate();
-extern sraRegion *sraRgnCreateRect(int x1, int y1, int x2, int y2);
-extern sraRegion *sraRgnCreateRgn(const sraRegion *src);
-
-extern void sraRgnDestroy(sraRegion *rgn);
-extern void sraRgnMakeEmpty(sraRegion *rgn);
-extern rfbBool sraRgnAnd(sraRegion *dst, const sraRegion *src);
-extern void sraRgnOr(sraRegion *dst, const sraRegion *src);
-extern rfbBool sraRgnSubtract(sraRegion *dst, const sraRegion *src);
-
-extern void sraRgnOffset(sraRegion *dst, int dx, int dy);
-
-extern rfbBool sraRgnPopRect(sraRegion *region, sraRect *rect,
-			  unsigned long flags);
-
-extern unsigned long sraRgnCountRects(const sraRegion *rgn);
-extern rfbBool sraRgnEmpty(const sraRegion *rgn);
-
-extern sraRegion *sraRgnBBox(const sraRegion *src);
-
-/* -=- rectangle iterator */
-
-typedef struct sraRectangleIterator {
-  rfbBool reverseX,reverseY;
-  int ptrSize,ptrPos;
-  struct sraSpan** sPtrs;
-} sraRectangleIterator;
-
-extern sraRectangleIterator *sraRgnGetIterator(sraRegion *s);
-extern sraRectangleIterator *sraRgnGetReverseIterator(sraRegion *s,rfbBool reverseX,rfbBool reverseY);
-extern rfbBool sraRgnIteratorNext(sraRectangleIterator *i,sraRect *r);
-extern void sraRgnReleaseIterator(sraRectangleIterator *i);
-
-void sraRgnPrint(const sraRegion *s);
-
-/* -=- Rectangle clipper (for speed) */
-
-extern rfbBool sraClipRect(int *x, int *y, int *w, int *h,
-			int cx, int cy, int cw, int ch);
-
-extern rfbBool sraClipRect2(int *x, int *y, int *x2, int *y2,
-			int cx, int cy, int cx2, int cy2);
-
-#endif
diff -urN remmina-plugins/vnc/libvncserver/rfbconfig.h.in remmina-plugins/vnc/libvncserver/rfbconfig.h.in
--- remmina-plugins/vnc/libvncserver/rfbconfig.h.in	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins/vnc/libvncserver/rfbconfig.h.in	1970-01-01 10:00:00.000000000 +1000
@@ -1,420 +0,0 @@
-/* rfbconfig.h.in.  Generated from configure.ac by autoheader.  */
-
-/* Define if building universal (internal helper macro) */
-#undef AC_APPLE_UNIVERSAL_BUILD
-
-/* Enable 24 bit per pixel in native framebuffer */
-#undef ALLOW24BPP
-
-/* work around when write() returns ENOENT but does not mean it */
-#undef ENOENT_WORKAROUND
-
-/* Use ffmpeg (for vnc2mpg) */
-#undef FFMPEG
-
-/* Define to 1 if you have the <arpa/inet.h> header file. */
-#undef HAVE_ARPA_INET_H
-
-/* Avahi/mDNS client build environment present */
-#undef HAVE_AVAHI
-
-/* Define to 1 if you have the `crypt' function. */
-#undef HAVE_CRYPT
-
-/* Define to 1 if you have the <dlfcn.h> header file. */
-#undef HAVE_DLFCN_H
-
-/* Define to 1 if you don't have `vprintf' but do have `_doprnt.' */
-#undef HAVE_DOPRNT
-
-/* DPMS extension build environment present */
-#undef HAVE_DPMS
-
-/* FBPM extension build environment present */
-#undef HAVE_FBPM
-
-/* Define to 1 if you have the <fcntl.h> header file. */
-#undef HAVE_FCNTL_H
-
-/* Define to 1 if you have the `fork' function. */
-#undef HAVE_FORK
-
-/* Define to 1 if you have the `ftime' function. */
-#undef HAVE_FTIME
-
-/* Define to 1 if you have the `geteuid' function. */
-#undef HAVE_GETEUID
-
-/* Define to 1 if you have the `gethostbyname' function. */
-#undef HAVE_GETHOSTBYNAME
-
-/* Define to 1 if you have the `gethostname' function. */
-#undef HAVE_GETHOSTNAME
-
-/* Define to 1 if you have the `getpwnam' function. */
-#undef HAVE_GETPWNAM
-
-/* Define to 1 if you have the `getpwuid' function. */
-#undef HAVE_GETPWUID
-
-/* Define to 1 if you have the `getspnam' function. */
-#undef HAVE_GETSPNAM
-
-/* Define to 1 if you have the `gettimeofday' function. */
-#undef HAVE_GETTIMEOFDAY
-
-/* Define to 1 if you have the `getuid' function. */
-#undef HAVE_GETUID
-
-/* Define to 1 if you have the `grantpt' function. */
-#undef HAVE_GRANTPT
-
-/* Define to 1 if you have the `inet_ntoa' function. */
-#undef HAVE_INET_NTOA
-
-/* Define to 1 if you have the `initgroups' function. */
-#undef HAVE_INITGROUPS
-
-/* Define to 1 if you have the <inttypes.h> header file. */
-#undef HAVE_INTTYPES_H
-
-/* IRIX XReadDisplay available */
-#undef HAVE_IRIX_XREADDISPLAY
-
-/* libcrypt library present */
-#undef HAVE_LIBCRYPT
-
-/* openssl libcrypto library present */
-#undef HAVE_LIBCRYPTO
-
-/* Define to 1 if you have the `cygipc' library (-lcygipc). */
-#undef HAVE_LIBCYGIPC
-
-/* Define to 1 if you have the `jpeg' library (-ljpeg). */
-#undef HAVE_LIBJPEG
-
-/* Define to 1 if you have the `nsl' library (-lnsl). */
-#undef HAVE_LIBNSL
-
-/* Define to 1 if you have the `pthread' library (-lpthread). */
-#undef HAVE_LIBPTHREAD
-
-/* Define to 1 if you have the `socket' library (-lsocket). */
-#undef HAVE_LIBSOCKET
-
-/* openssl libssl library present */
-#undef HAVE_LIBSSL
-
-/* XDAMAGE extension build environment present */
-#undef HAVE_LIBXDAMAGE
-
-/* XFIXES extension build environment present */
-#undef HAVE_LIBXFIXES
-
-/* XINERAMA extension build environment present */
-#undef HAVE_LIBXINERAMA
-
-/* XRANDR extension build environment present */
-#undef HAVE_LIBXRANDR
-
-/* DEC-XTRAP extension build environment present */
-#undef HAVE_LIBXTRAP
-
-/* Define to 1 if you have the `z' library (-lz). */
-#undef HAVE_LIBZ
-
-/* linux fb device build environment present */
-#undef HAVE_LINUX_FB_H
-
-/* linux/input.h present */
-#undef HAVE_LINUX_INPUT_H
-
-/* linux uinput device build environment present */
-#undef HAVE_LINUX_UINPUT_H
-
-/* video4linux build environment present */
-#undef HAVE_LINUX_VIDEODEV_H
-
-/* build MacOS X native display support */
-#undef HAVE_MACOSX_NATIVE_DISPLAY
-
-/* MacOS X OpenGL present */
-#undef HAVE_MACOSX_OPENGL_H
-
-/* Define to 1 if you have the `memmove' function. */
-#undef HAVE_MEMMOVE
-
-/* Define to 1 if you have the <memory.h> header file. */
-#undef HAVE_MEMORY_H
-
-/* Define to 1 if you have the `memset' function. */
-#undef HAVE_MEMSET
-
-/* Define to 1 if you have the `mkfifo' function. */
-#undef HAVE_MKFIFO
-
-/* Define to 1 if you have the `mmap' function. */
-#undef HAVE_MMAP
-
-/* Define to 1 if you have the <netdb.h> header file. */
-#undef HAVE_NETDB_H
-
-/* Define to 1 if you have the <netinet/in.h> header file. */
-#undef HAVE_NETINET_IN_H
-
-/* Define to 1 if you have the <pwd.h> header file. */
-#undef HAVE_PWD_H
-
-/* RECORD extension build environment present */
-#undef HAVE_RECORD
-
-/* Define to 1 if you have the `select' function. */
-#undef HAVE_SELECT
-
-/* Define to 1 if you have the `setegid' function. */
-#undef HAVE_SETEGID
-
-/* Define to 1 if you have the `seteuid' function. */
-#undef HAVE_SETEUID
-
-/* Define to 1 if you have the `setgid' function. */
-#undef HAVE_SETGID
-
-/* Define to 1 if you have the `setpgrp' function. */
-#undef HAVE_SETPGRP
-
-/* Define to 1 if you have the `setsid' function. */
-#undef HAVE_SETSID
-
-/* Define to 1 if you have the `setuid' function. */
-#undef HAVE_SETUID
-
-/* Define to 1 if you have the `setutxent' function. */
-#undef HAVE_SETUTXENT
-
-/* Define to 1 if you have the `shmat' function. */
-#undef HAVE_SHMAT
-
-/* Define to 1 if you have the `socket' function. */
-#undef HAVE_SOCKET
-
-/* Solaris XReadScreen available */
-#undef HAVE_SOLARIS_XREADSCREEN
-
-/* Define to 1 if `stat' has the bug that it succeeds when given the
-   zero-length file name argument. */
-#undef HAVE_STAT_EMPTY_STRING_BUG
-
-/* Define to 1 if you have the <stdint.h> header file. */
-#undef HAVE_STDINT_H
-
-/* Define to 1 if you have the <stdlib.h> header file. */
-#undef HAVE_STDLIB_H
-
-/* Define to 1 if you have the `strchr' function. */
-#undef HAVE_STRCHR
-
-/* Define to 1 if you have the `strcspn' function. */
-#undef HAVE_STRCSPN
-
-/* Define to 1 if you have the `strdup' function. */
-#undef HAVE_STRDUP
-
-/* Define to 1 if you have the `strerror' function. */
-#undef HAVE_STRERROR
-
-/* Define to 1 if you have the `strftime' function. */
-#undef HAVE_STRFTIME
-
-/* Define to 1 if you have the <strings.h> header file. */
-#undef HAVE_STRINGS_H
-
-/* Define to 1 if you have the <string.h> header file. */
-#undef HAVE_STRING_H
-
-/* Define to 1 if you have the `strstr' function. */
-#undef HAVE_STRSTR
-
-/* Define to 1 if you have the <syslog.h> header file. */
-#undef HAVE_SYSLOG_H
-
-/* Use the system libvncserver build environment for x11vnc. */
-#undef HAVE_SYSTEM_LIBVNCSERVER
-
-/* Define to 1 if you have the <sys/ioctl.h> header file. */
-#undef HAVE_SYS_IOCTL_H
-
-/* Define to 1 if you have the <sys/socket.h> header file. */
-#undef HAVE_SYS_SOCKET_H
-
-/* Define to 1 if you have the <sys/stat.h> header file. */
-#undef HAVE_SYS_STAT_H
-
-/* Define to 1 if you have the <sys/stropts.h> header file. */
-#undef HAVE_SYS_STROPTS_H
-
-/* Define to 1 if you have the <sys/timeb.h> header file. */
-#undef HAVE_SYS_TIMEB_H
-
-/* Define to 1 if you have the <sys/time.h> header file. */
-#undef HAVE_SYS_TIME_H
-
-/* Define to 1 if you have the <sys/types.h> header file. */
-#undef HAVE_SYS_TYPES_H
-
-/* Define to 1 if you have <sys/wait.h> that is POSIX.1 compatible. */
-#undef HAVE_SYS_WAIT_H
-
-/* Define to 1 if you have the <termios.h> header file. */
-#undef HAVE_TERMIOS_H
-
-/* Define to 1 if compiler supports __thread */
-#undef HAVE_TLS
-
-/* Define to 1 if you have the <unistd.h> header file. */
-#undef HAVE_UNISTD_H
-
-/* Define to 1 if you have the <utmpx.h> header file. */
-#undef HAVE_UTMPX_H
-
-/* Define to 1 if you have the `vfork' function. */
-#undef HAVE_VFORK
-
-/* Define to 1 if you have the <vfork.h> header file. */
-#undef HAVE_VFORK_H
-
-/* Define to 1 if you have the `vprintf' function. */
-#undef HAVE_VPRINTF
-
-/* Define to 1 if you have the `waitpid' function. */
-#undef HAVE_WAITPID
-
-/* Define to 1 if `fork' works. */
-#undef HAVE_WORKING_FORK
-
-/* Define to 1 if `vfork' works. */
-#undef HAVE_WORKING_VFORK
-
-/* Define to 1 if you have the <ws2tcpip.h> header file. */
-#undef HAVE_WS2TCPIP_H
-
-/* X11 build environment present */
-#undef HAVE_X11
-
-/* open ssl X509_print_ex_fp available */
-#undef HAVE_X509_PRINT_EX_FP
-
-/* XKEYBOARD extension build environment present */
-#undef HAVE_XKEYBOARD
-
-/* MIT-SHM extension build environment present */
-#undef HAVE_XSHM
-
-/* XTEST extension build environment present */
-#undef HAVE_XTEST
-
-/* XTEST extension has XTestGrabControl */
-#undef HAVE_XTESTGRABCONTROL
-
-/* Enable IPv6 support */
-#undef IPv6
-
-/* Define to 1 if `lstat' dereferences a symlink specified with a trailing
-   slash. */
-#undef LSTAT_FOLLOWS_SLASHED_SYMLINK
-
-/* Need a typedef for in_addr_t */
-#undef NEED_INADDR_T
-
-/* Define to 1 if your C compiler doesn't accept -c and -o together. */
-#undef NO_MINUS_C_MINUS_O
-
-/* Name of package */
-#undef PACKAGE
-
-/* Define to the address where bug reports for this package should be sent. */
-#undef PACKAGE_BUGREPORT
-
-/* Define to the full name of this package. */
-#undef PACKAGE_NAME
-
-/* Define to the full name and version of this package. */
-#undef PACKAGE_STRING
-
-/* Define to the one symbol short name of this package. */
-#undef PACKAGE_TARNAME
-
-/* Define to the home page for this package. */
-#undef PACKAGE_URL
-
-/* Define to the version of this package. */
-#undef PACKAGE_VERSION
-
-/* The number of bytes in type char */
-#undef SIZEOF_CHAR
-
-/* The number of bytes in type int */
-#undef SIZEOF_INT
-
-/* The number of bytes in type long */
-#undef SIZEOF_LONG
-
-/* The number of bytes in type short */
-#undef SIZEOF_SHORT
-
-/* The number of bytes in type void* */
-#undef SIZEOF_VOIDP
-
-/* Define to 1 if you have the ANSI C header files. */
-#undef STDC_HEADERS
-
-/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
-#undef TIME_WITH_SYS_TIME
-
-/* Version number of package */
-#undef VERSION
-
-/* Enable support for libgcrypt in libvncclient */
-#undef WITH_CLIENT_GCRYPT
-
-/* Enable support for gnutls in libvncclient */
-#undef WITH_CLIENT_TLS
-
-/* Disable TightVNCFileTransfer protocol */
-#undef WITH_TIGHTVNC_FILETRANSFER
-
-/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
-   significant byte first (like Motorola and SPARC, unlike Intel). */
-#if defined AC_APPLE_UNIVERSAL_BUILD
-# if defined __BIG_ENDIAN__
-#  define WORDS_BIGENDIAN 1
-# endif
-#else
-# ifndef WORDS_BIGENDIAN
-#  undef WORDS_BIGENDIAN
-# endif
-#endif
-
-/* Define to 1 if the X Window System is missing or not being used. */
-#undef X_DISPLAY_MISSING
-
-/* Define to empty if `const' does not conform to ANSI C. */
-#undef const
-
-/* Define to `__inline__' or `__inline' if that's what the C compiler
-   calls it, or to nothing if 'inline' is not supported under any name.  */
-#ifndef __cplusplus
-#undef inline
-#endif
-
-/* Define to `int' if <sys/types.h> does not define. */
-#undef pid_t
-
-/* Define to `unsigned int' if <sys/types.h> does not define. */
-#undef size_t
-
-/* The type for socklen */
-#undef socklen_t
-
-/* Define as `fork' if `vfork' does not work. */
-#undef vfork
diff -urN remmina-plugins/vnc/vnc_plugin.c remmina-plugins/vnc/vnc_plugin.c
--- remmina-plugins/vnc/vnc_plugin.c	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins/vnc/vnc_plugin.c	2014-01-08 02:31:52.000000000 +1100
@@ -350,7 +350,7 @@
 		cur = gdk_cursor_new_from_pixbuf(gdk_display_get_default(), gpdata->queuecursor_pixbuf, gpdata->queuecursor_x,
 				gpdata->queuecursor_y);
 		gdk_window_set_cursor(gtk_widget_get_window(gpdata->drawing_area), cur);
-		gdk_cursor_unref(cur);
+		g_object_unref(cur);
 		g_object_unref(gpdata->queuecursor_pixbuf);
 		gpdata->queuecursor_pixbuf = NULL;
 	}
@@ -1426,6 +1426,20 @@
 		case GDK_SCROLL_RIGHT:
 			mask = (1 << 6);
 			break;
+#ifdef GDK_SCROLL_SMOOTH
+		case GDK_SCROLL_SMOOTH:
+			if (event->delta_y < 0)
+				mask = (1 << 3);
+			if (event->delta_y > 0)
+				mask = (1 << 4);
+			if (event->delta_x < 0)
+				mask = (1 << 5);
+			if (event->delta_x > 0)
+				mask = (1 << 6);
+			if (!mask)
+				return FALSE;
+			break;
+#endif
 		default:
 			return FALSE;
 	}
@@ -1568,9 +1582,9 @@
 		/* Hide local cursor (show a small dot instead) */
 		pixbuf = gdk_pixbuf_new_from_xpm_data(dot_cursor_xpm);
 		cursor = gdk_cursor_new_from_pixbuf(gdk_display_get_default(), pixbuf, dot_cursor_x_hot, dot_cursor_y_hot);
-		gdk_pixbuf_unref(pixbuf);
+		g_object_unref(pixbuf);
 		gdk_window_set_cursor(gtk_widget_get_window(GTK_WIDGET(gp)), cursor);
-		gdk_cursor_unref(cursor);
+		g_object_unref(cursor);
 	}
 }
 
@@ -1847,7 +1861,7 @@
 	gtk_widget_add_events(
 			gpdata->drawing_area,
 			GDK_POINTER_MOTION_MASK | GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK | GDK_KEY_PRESS_MASK
-					| GDK_KEY_RELEASE_MASK);
+					| GDK_KEY_RELEASE_MASK | GDK_SCROLL_MASK);
 	gtk_widget_set_can_focus(gpdata->drawing_area, TRUE);
 
 #if GTK_VERSION == 3
diff -urN remmina-plugins/xdmcp/CMakeLists.txt remmina-plugins/xdmcp/CMakeLists.txt
--- remmina-plugins/xdmcp/CMakeLists.txt	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins/xdmcp/CMakeLists.txt	2014-01-08 02:31:52.000000000 +1100
@@ -23,6 +23,7 @@
 
 add_library(remmina-plugin-xdmcp ${REMMINA_PLUGIN_XDMCP_SRCS})
 set_target_properties(remmina-plugin-xdmcp PROPERTIES PREFIX "")
+set_target_properties(remmina-plugin-xdmcp PROPERTIES NO_SONAME 1)
 
 include_directories(${REMMINA_COMMON_INCLUDE_DIRS})
 target_link_libraries(remmina-plugin-xdmcp ${REMMINA_COMMON_LIBRARIES})
diff -urN remmina-plugins-gnome/AUTHORS remmina-plugins-gnome/AUTHORS
--- remmina-plugins-gnome/AUTHORS	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins-gnome/AUTHORS	1970-01-01 10:00:00.000000000 +1000
@@ -1,4 +0,0 @@
-Please check the application About dialog or the official web site for a full list of authors.
-
-http://remmina.sourceforge.net/contact.shtml
-
diff -urN remmina-plugins-gnome/CMakeLists.txt remmina-plugins-gnome/CMakeLists.txt
--- remmina-plugins-gnome/CMakeLists.txt	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins-gnome/CMakeLists.txt	2014-01-08 02:31:52.000000000 +1100
@@ -17,21 +17,21 @@
 # Foundation, Inc., 59 Temple Place, Suite 330, 
 # Boston, MA 02111-1307, USA.
 
-set(REMMINA_PLUGINS_GNOME_SRCS
-	src/gkeyring_plugin.c
-	)
+find_suggested_package(GNOMEKEYRING)
+if(GNOMEKEYRING_FOUND)
+	set(REMMINA_PLUGINS_GNOME_SRCS
+		src/gkeyring_plugin.c
+		)
 
-add_library(remmina-plugins-gnome ${REMMINA_PLUGINS_GNOME_SRCS})
-set_target_properties(remmina-plugins-gnome PROPERTIES PREFIX "")
+	add_library(remmina-plugins-gnome ${REMMINA_PLUGINS_GNOME_SRCS})
+	set_target_properties(remmina-plugins-gnome PROPERTIES PREFIX "")
+	set_target_properties(remmina-plugins-gnome PROPERTIES NO_SONAME 1)
 
-include_directories(${GTK_INCLUDE_DIRS})
-target_link_libraries(remmina-plugins-gnome ${GTK_LIBRARY_DIRS})
+	include_directories(${GTK_INCLUDE_DIRS})
+	target_link_libraries(remmina-plugins-gnome ${GTK_LIBRARY_DIRS})
 
-find_required_package(GNOMEKEYRING)
-if(GNOMEKEYRING_FOUND)
-	include_directories(${GNOMEKEYRING_INCLUDE_DIRS})
-	target_link_libraries(remmina-plugins-gnome ${GNOMEKEYRING_LIBRARIES})
-endif()
-
-install(TARGETS remmina-plugins-gnome DESTINATION ${REMMINA_PLUGINDIR})
+		include_directories(${GNOMEKEYRING_INCLUDE_DIRS})
+		target_link_libraries(remmina-plugins-gnome ${GNOMEKEYRING_LIBRARIES})
 
+	install(TARGETS remmina-plugins-gnome DESTINATION ${REMMINA_PLUGINDIR})
+endif()
diff -urN remmina-plugins-gnome/COPYING remmina-plugins-gnome/COPYING
--- remmina-plugins-gnome/COPYING	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins-gnome/COPYING	1970-01-01 10:00:00.000000000 +1000
@@ -1,340 +0,0 @@
-		    GNU GENERAL PUBLIC LICENSE
-		       Version 2, June 1991
-
- Copyright (C) 1989, 1991 Free Software Foundation, Inc.
-     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-			    Preamble
-
-  The licenses for most software are designed to take away your
-freedom to share and change it.  By contrast, the GNU General Public
-License is intended to guarantee your freedom to share and change free
-software--to make sure the software is free for all its users.  This
-General Public License applies to most of the Free Software
-Foundation's software and to any other program whose authors commit to
-using it.  (Some other Free Software Foundation software is covered by
-the GNU Library General Public License instead.)  You can apply it to
-your programs, too.
-
-  When we speak of free software, we are referring to freedom, not
-price.  Our General Public Licenses are designed to make sure that you
-have the freedom to distribute copies of free software (and charge for
-this service if you wish), that you receive source code or can get it
-if you want it, that you can change the software or use pieces of it
-in new free programs; and that you know you can do these things.
-
-  To protect your rights, we need to make restrictions that forbid
-anyone to deny you these rights or to ask you to surrender the rights.
-These restrictions translate to certain responsibilities for you if you
-distribute copies of the software, or if you modify it.
-
-  For example, if you distribute copies of such a program, whether
-gratis or for a fee, you must give the recipients all the rights that
-you have.  You must make sure that they, too, receive or can get the
-source code.  And you must show them these terms so they know their
-rights.
-
-  We protect your rights with two steps: (1) copyright the software, and
-(2) offer you this license which gives you legal permission to copy,
-distribute and/or modify the software.
-
-  Also, for each author's protection and ours, we want to make certain
-that everyone understands that there is no warranty for this free
-software.  If the software is modified by someone else and passed on, we
-want its recipients to know that what they have is not the original, so
-that any problems introduced by others will not reflect on the original
-authors' reputations.
-
-  Finally, any free program is threatened constantly by software
-patents.  We wish to avoid the danger that redistributors of a free
-program will individually obtain patent licenses, in effect making the
-program proprietary.  To prevent this, we have made it clear that any
-patent must be licensed for everyone's free use or not licensed at all.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.
-
-		    GNU GENERAL PUBLIC LICENSE
-   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
-
-  0. This License applies to any program or other work which contains
-a notice placed by the copyright holder saying it may be distributed
-under the terms of this General Public License.  The "Program", below,
-refers to any such program or work, and a "work based on the Program"
-means either the Program or any derivative work under copyright law:
-that is to say, a work containing the Program or a portion of it,
-either verbatim or with modifications and/or translated into another
-language.  (Hereinafter, translation is included without limitation in
-the term "modification".)  Each licensee is addressed as "you".
-
-Activities other than copying, distribution and modification are not
-covered by this License; they are outside its scope.  The act of
-running the Program is not restricted, and the output from the Program
-is covered only if its contents constitute a work based on the
-Program (independent of having been made by running the Program).
-Whether that is true depends on what the Program does.
-
-  1. You may copy and distribute verbatim copies of the Program's
-source code as you receive it, in any medium, provided that you
-conspicuously and appropriately publish on each copy an appropriate
-copyright notice and disclaimer of warranty; keep intact all the
-notices that refer to this License and to the absence of any warranty;
-and give any other recipients of the Program a copy of this License
-along with the Program.
-
-You may charge a fee for the physical act of transferring a copy, and
-you may at your option offer warranty protection in exchange for a fee.
-
-  2. You may modify your copy or copies of the Program or any portion
-of it, thus forming a work based on the Program, and copy and
-distribute such modifications or work under the terms of Section 1
-above, provided that you also meet all of these conditions:
-
-    a) You must cause the modified files to carry prominent notices
-    stating that you changed the files and the date of any change.
-
-    b) You must cause any work that you distribute or publish, that in
-    whole or in part contains or is derived from the Program or any
-    part thereof, to be licensed as a whole at no charge to all third
-    parties under the terms of this License.
-
-    c) If the modified program normally reads commands interactively
-    when run, you must cause it, when started running for such
-    interactive use in the most ordinary way, to print or display an
-    announcement including an appropriate copyright notice and a
-    notice that there is no warranty (or else, saying that you provide
-    a warranty) and that users may redistribute the program under
-    these conditions, and telling the user how to view a copy of this
-    License.  (Exception: if the Program itself is interactive but
-    does not normally print such an announcement, your work based on
-    the Program is not required to print an announcement.)
-
-These requirements apply to the modified work as a whole.  If
-identifiable sections of that work are not derived from the Program,
-and can be reasonably considered independent and separate works in
-themselves, then this License, and its terms, do not apply to those
-sections when you distribute them as separate works.  But when you
-distribute the same sections as part of a whole which is a work based
-on the Program, the distribution of the whole must be on the terms of
-this License, whose permissions for other licensees extend to the
-entire whole, and thus to each and every part regardless of who wrote it.
-
-Thus, it is not the intent of this section to claim rights or contest
-your rights to work written entirely by you; rather, the intent is to
-exercise the right to control the distribution of derivative or
-collective works based on the Program.
-
-In addition, mere aggregation of another work not based on the Program
-with the Program (or with a work based on the Program) on a volume of
-a storage or distribution medium does not bring the other work under
-the scope of this License.
-
-  3. You may copy and distribute the Program (or a work based on it,
-under Section 2) in object code or executable form under the terms of
-Sections 1 and 2 above provided that you also do one of the following:
-
-    a) Accompany it with the complete corresponding machine-readable
-    source code, which must be distributed under the terms of Sections
-    1 and 2 above on a medium customarily used for software interchange; or,
-
-    b) Accompany it with a written offer, valid for at least three
-    years, to give any third party, for a charge no more than your
-    cost of physically performing source distribution, a complete
-    machine-readable copy of the corresponding source code, to be
-    distributed under the terms of Sections 1 and 2 above on a medium
-    customarily used for software interchange; or,
-
-    c) Accompany it with the information you received as to the offer
-    to distribute corresponding source code.  (This alternative is
-    allowed only for noncommercial distribution and only if you
-    received the program in object code or executable form with such
-    an offer, in accord with Subsection b above.)
-
-The source code for a work means the preferred form of the work for
-making modifications to it.  For an executable work, complete source
-code means all the source code for all modules it contains, plus any
-associated interface definition files, plus the scripts used to
-control compilation and installation of the executable.  However, as a
-special exception, the source code distributed need not include
-anything that is normally distributed (in either source or binary
-form) with the major components (compiler, kernel, and so on) of the
-operating system on which the executable runs, unless that component
-itself accompanies the executable.
-
-If distribution of executable or object code is made by offering
-access to copy from a designated place, then offering equivalent
-access to copy the source code from the same place counts as
-distribution of the source code, even though third parties are not
-compelled to copy the source along with the object code.
-
-  4. You may not copy, modify, sublicense, or distribute the Program
-except as expressly provided under this License.  Any attempt
-otherwise to copy, modify, sublicense or distribute the Program is
-void, and will automatically terminate your rights under this License.
-However, parties who have received copies, or rights, from you under
-this License will not have their licenses terminated so long as such
-parties remain in full compliance.
-
-  5. You are not required to accept this License, since you have not
-signed it.  However, nothing else grants you permission to modify or
-distribute the Program or its derivative works.  These actions are
-prohibited by law if you do not accept this License.  Therefore, by
-modifying or distributing the Program (or any work based on the
-Program), you indicate your acceptance of this License to do so, and
-all its terms and conditions for copying, distributing or modifying
-the Program or works based on it.
-
-  6. Each time you redistribute the Program (or any work based on the
-Program), the recipient automatically receives a license from the
-original licensor to copy, distribute or modify the Program subject to
-these terms and conditions.  You may not impose any further
-restrictions on the recipients' exercise of the rights granted herein.
-You are not responsible for enforcing compliance by third parties to
-this License.
-
-  7. If, as a consequence of a court judgment or allegation of patent
-infringement or for any other reason (not limited to patent issues),
-conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot
-distribute so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you
-may not distribute the Program at all.  For example, if a patent
-license would not permit royalty-free redistribution of the Program by
-all those who receive copies directly or indirectly through you, then
-the only way you could satisfy both it and this License would be to
-refrain entirely from distribution of the Program.
-
-If any portion of this section is held invalid or unenforceable under
-any particular circumstance, the balance of the section is intended to
-apply and the section as a whole is intended to apply in other
-circumstances.
-
-It is not the purpose of this section to induce you to infringe any
-patents or other property right claims or to contest validity of any
-such claims; this section has the sole purpose of protecting the
-integrity of the free software distribution system, which is
-implemented by public license practices.  Many people have made
-generous contributions to the wide range of software distributed
-through that system in reliance on consistent application of that
-system; it is up to the author/donor to decide if he or she is willing
-to distribute software through any other system and a licensee cannot
-impose that choice.
-
-This section is intended to make thoroughly clear what is believed to
-be a consequence of the rest of this License.
-
-  8. If the distribution and/or use of the Program is restricted in
-certain countries either by patents or by copyrighted interfaces, the
-original copyright holder who places the Program under this License
-may add an explicit geographical distribution limitation excluding
-those countries, so that distribution is permitted only in or among
-countries not thus excluded.  In such case, this License incorporates
-the limitation as if written in the body of this License.
-
-  9. The Free Software Foundation may publish revised and/or new versions
-of the General Public License from time to time.  Such new versions will
-be similar in spirit to the present version, but may differ in detail to
-address new problems or concerns.
-
-Each version is given a distinguishing version number.  If the Program
-specifies a version number of this License which applies to it and "any
-later version", you have the option of following the terms and conditions
-either of that version or of any later version published by the Free
-Software Foundation.  If the Program does not specify a version number of
-this License, you may choose any version ever published by the Free Software
-Foundation.
-
-  10. If you wish to incorporate parts of the Program into other free
-programs whose distribution conditions are different, write to the author
-to ask for permission.  For software which is copyrighted by the Free
-Software Foundation, write to the Free Software Foundation; we sometimes
-make exceptions for this.  Our decision will be guided by the two goals
-of preserving the free status of all derivatives of our free software and
-of promoting the sharing and reuse of software generally.
-
-			    NO WARRANTY
-
-  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
-FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
-OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
-PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
-OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
-TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
-PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
-REPAIR OR CORRECTION.
-
-  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
-WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
-REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
-INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
-OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
-TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
-YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
-PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGES.
-
-		     END OF TERMS AND CONDITIONS
-
-	    How to Apply These Terms to Your New Programs
-
-  If you develop a new program, and you want it to be of the greatest
-possible use to the public, the best way to achieve this is to make it
-free software which everyone can redistribute and change under these terms.
-
-  To do so, attach the following notices to the program.  It is safest
-to attach them to the start of each source file to most effectively
-convey the exclusion of warranty; and each file should have at least
-the "copyright" line and a pointer to where the full notice is found.
-
-    <one line to give the program's name and a brief idea of what it does.>
-    Copyright (C) <year>  <name of author>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-
-
-Also add information on how to contact you by electronic and paper mail.
-
-If the program is interactive, make it output a short notice like this
-when it starts in an interactive mode:
-
-    Gnomovision version 69, Copyright (C) year  name of author
-    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
-    This is free software, and you are welcome to redistribute it
-    under certain conditions; type `show c' for details.
-
-The hypothetical commands `show w' and `show c' should show the appropriate
-parts of the General Public License.  Of course, the commands you use may
-be called something other than `show w' and `show c'; they could even be
-mouse-clicks or menu items--whatever suits your program.
-
-You should also get your employer (if you work as a programmer) or your
-school, if any, to sign a "copyright disclaimer" for the program, if
-necessary.  Here is a sample; alter the names:
-
-  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
-  `Gnomovision' (which makes passes at compilers) written by James Hacker.
-
-  <signature of Ty Coon>, 1 April 1989
-  Ty Coon, President of Vice
-
-This General Public License does not permit incorporating your program into
-proprietary programs.  If your program is a subroutine library, you may
-consider it more useful to permit linking proprietary applications with the
-library.  If this is what you want to do, use the GNU Library General
-Public License instead of this License.
diff -urN remmina-plugins-gnome/INSTALL remmina-plugins-gnome/INSTALL
--- remmina-plugins-gnome/INSTALL	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins-gnome/INSTALL	1970-01-01 10:00:00.000000000 +1000
@@ -1,237 +0,0 @@
-Installation Instructions
-*************************
-
-Copyright (C) 1994, 1995, 1996, 1999, 2000, 2001, 2002, 2004, 2005,
-2006, 2007 Free Software Foundation, Inc.
-
-This file is free documentation; the Free Software Foundation gives
-unlimited permission to copy, distribute and modify it.
-
-Basic Installation
-==================
-
-Briefly, the shell commands `./configure; make; make install' should
-configure, build, and install this package.  The following
-more-detailed instructions are generic; see the `README' file for
-instructions specific to this package.
-
-   The `configure' shell script attempts to guess correct values for
-various system-dependent variables used during compilation.  It uses
-those values to create a `Makefile' in each directory of the package.
-It may also create one or more `.h' files containing system-dependent
-definitions.  Finally, it creates a shell script `config.status' that
-you can run in the future to recreate the current configuration, and a
-file `config.log' containing compiler output (useful mainly for
-debugging `configure').
-
-   It can also use an optional file (typically called `config.cache'
-and enabled with `--cache-file=config.cache' or simply `-C') that saves
-the results of its tests to speed up reconfiguring.  Caching is
-disabled by default to prevent problems with accidental use of stale
-cache files.
-
-   If you need to do unusual things to compile the package, please try
-to figure out how `configure' could check whether to do them, and mail
-diffs or instructions to the address given in the `README' so they can
-be considered for the next release.  If you are using the cache, and at
-some point `config.cache' contains results you don't want to keep, you
-may remove or edit it.
-
-   The file `configure.ac' (or `configure.in') is used to create
-`configure' by a program called `autoconf'.  You need `configure.ac' if
-you want to change it or regenerate `configure' using a newer version
-of `autoconf'.
-
-The simplest way to compile this package is:
-
-  1. `cd' to the directory containing the package's source code and type
-     `./configure' to configure the package for your system.
-
-     Running `configure' might take a while.  While running, it prints
-     some messages telling which features it is checking for.
-
-  2. Type `make' to compile the package.
-
-  3. Optionally, type `make check' to run any self-tests that come with
-     the package.
-
-  4. Type `make install' to install the programs and any data files and
-     documentation.
-
-  5. You can remove the program binaries and object files from the
-     source code directory by typing `make clean'.  To also remove the
-     files that `configure' created (so you can compile the package for
-     a different kind of computer), type `make distclean'.  There is
-     also a `make maintainer-clean' target, but that is intended mainly
-     for the package's developers.  If you use it, you may have to get
-     all sorts of other programs in order to regenerate files that came
-     with the distribution.
-
-  6. Often, you can also type `make uninstall' to remove the installed
-     files again.
-
-Compilers and Options
-=====================
-
-Some systems require unusual options for compilation or linking that the
-`configure' script does not know about.  Run `./configure --help' for
-details on some of the pertinent environment variables.
-
-   You can give `configure' initial values for configuration parameters
-by setting variables in the command line or in the environment.  Here
-is an example:
-
-     ./configure CC=c99 CFLAGS=-g LIBS=-lposix
-
-   *Note Defining Variables::, for more details.
-
-Compiling For Multiple Architectures
-====================================
-
-You can compile the package for more than one kind of computer at the
-same time, by placing the object files for each architecture in their
-own directory.  To do this, you can use GNU `make'.  `cd' to the
-directory where you want the object files and executables to go and run
-the `configure' script.  `configure' automatically checks for the
-source code in the directory that `configure' is in and in `..'.
-
-   With a non-GNU `make', it is safer to compile the package for one
-architecture at a time in the source code directory.  After you have
-installed the package for one architecture, use `make distclean' before
-reconfiguring for another architecture.
-
-Installation Names
-==================
-
-By default, `make install' installs the package's commands under
-`/usr/local/bin', include files under `/usr/local/include', etc.  You
-can specify an installation prefix other than `/usr/local' by giving
-`configure' the option `--prefix=PREFIX'.
-
-   You can specify separate installation prefixes for
-architecture-specific files and architecture-independent files.  If you
-pass the option `--exec-prefix=PREFIX' to `configure', the package uses
-PREFIX as the prefix for installing programs and libraries.
-Documentation and other data files still use the regular prefix.
-
-   In addition, if you use an unusual directory layout you can give
-options like `--bindir=DIR' to specify different values for particular
-kinds of files.  Run `configure --help' for a list of the directories
-you can set and what kinds of files go in them.
-
-   If the package supports it, you can cause programs to be installed
-with an extra prefix or suffix on their names by giving `configure' the
-option `--program-prefix=PREFIX' or `--program-suffix=SUFFIX'.
-
-Optional Features
-=================
-
-Some packages pay attention to `--enable-FEATURE' options to
-`configure', where FEATURE indicates an optional part of the package.
-They may also pay attention to `--with-PACKAGE' options, where PACKAGE
-is something like `gnu-as' or `x' (for the X Window System).  The
-`README' should mention any `--enable-' and `--with-' options that the
-package recognizes.
-
-   For packages that use the X Window System, `configure' can usually
-find the X include and library files automatically, but if it doesn't,
-you can use the `configure' options `--x-includes=DIR' and
-`--x-libraries=DIR' to specify their locations.
-
-Specifying the System Type
-==========================
-
-There may be some features `configure' cannot figure out automatically,
-but needs to determine by the type of machine the package will run on.
-Usually, assuming the package is built to be run on the _same_
-architectures, `configure' can figure that out, but if it prints a
-message saying it cannot guess the machine type, give it the
-`--build=TYPE' option.  TYPE can either be a short name for the system
-type, such as `sun4', or a canonical name which has the form:
-
-     CPU-COMPANY-SYSTEM
-
-where SYSTEM can have one of these forms:
-
-     OS KERNEL-OS
-
-   See the file `config.sub' for the possible values of each field.  If
-`config.sub' isn't included in this package, then this package doesn't
-need to know the machine type.
-
-   If you are _building_ compiler tools for cross-compiling, you should
-use the option `--target=TYPE' to select the type of system they will
-produce code for.
-
-   If you want to _use_ a cross compiler, that generates code for a
-platform different from the build platform, you should specify the
-"host" platform (i.e., that on which the generated programs will
-eventually be run) with `--host=TYPE'.
-
-Sharing Defaults
-================
-
-If you want to set default values for `configure' scripts to share, you
-can create a site shell script called `config.site' that gives default
-values for variables like `CC', `cache_file', and `prefix'.
-`configure' looks for `PREFIX/share/config.site' if it exists, then
-`PREFIX/etc/config.site' if it exists.  Or, you can set the
-`CONFIG_SITE' environment variable to the location of the site script.
-A warning: not all `configure' scripts look for a site script.
-
-Defining Variables
-==================
-
-Variables not defined in a site shell script can be set in the
-environment passed to `configure'.  However, some packages may run
-configure again during the build, and the customized values of these
-variables may be lost.  In order to avoid this problem, you should set
-them in the `configure' command line, using `VAR=value'.  For example:
-
-     ./configure CC=/usr/local2/bin/gcc
-
-causes the specified `gcc' to be used as the C compiler (unless it is
-overridden in the site shell script).
-
-Unfortunately, this technique does not work for `CONFIG_SHELL' due to
-an Autoconf bug.  Until the bug is fixed you can use this workaround:
-
-     CONFIG_SHELL=/bin/bash /bin/bash ./configure CONFIG_SHELL=/bin/bash
-
-`configure' Invocation
-======================
-
-`configure' recognizes the following options to control how it operates.
-
-`--help'
-`-h'
-     Print a summary of the options to `configure', and exit.
-
-`--version'
-`-V'
-     Print the version of Autoconf used to generate the `configure'
-     script, and exit.
-
-`--cache-file=FILE'
-     Enable the cache: use and save the results of the tests in FILE,
-     traditionally `config.cache'.  FILE defaults to `/dev/null' to
-     disable caching.
-
-`--config-cache'
-`-C'
-     Alias for `--cache-file=config.cache'.
-
-`--quiet'
-`--silent'
-`-q'
-     Do not print messages saying which checks are being made.  To
-     suppress all normal output, redirect it to `/dev/null' (any error
-     messages will still be shown).
-
-`--srcdir=DIR'
-     Look for the package's source code in directory DIR.  Usually
-     `configure' can determine that directory automatically.
-
-`configure' also accepts some other, not widely useful, options.  Run
-`configure --help' for more details.
-
diff -urN remmina-plugins-gnome/README remmina-plugins-gnome/README
--- remmina-plugins-gnome/README	2012-02-11 05:54:23.000000000 +1100
+++ remmina-plugins-gnome/README	1970-01-01 10:00:00.000000000 +1000
@@ -1,4 +0,0 @@
-Please visit the Remmina official web site for general information:
-
-http://remmina.sourceforge.net
-
