#
# Copy FIFOs and sockets
# https://bugzilla.samba.org/show_bug.cgi?id=1804
#
--- Makefile.in	12 Aug 2004 18:59:03 -0000	1.104
+++ Makefile.in	23 Sep 2004 06:22:00 -0000
@@ -41,7 +41,7 @@ popt_OBJS=popt/findme.o  popt/popt.o  po
 	popt/popthelp.o popt/poptparse.o
 OBJS=$(OBJS1) $(OBJS2) $(OBJS3) $(DAEMON_OBJ) $(LIBOBJ) $(ZLIBOBJ) @BUILD_POPT@
 
-TLS_OBJ = tls.o syscall.o lib/permstring.o
+TLS_OBJ = tls.o syscall.o lib/compat.o lib/permstring.o
 
 # Programs we must have to run the test cases
 CHECK_PROGS = rsync$(EXEEXT) tls$(EXEEXT) getgroups$(EXEEXT) getfsdev$(EXEEXT) \
@@ -83,7 +83,7 @@ getgroups$(EXEEXT): getgroups.o
 getfsdev$(EXEEXT): getfsdev.o
 	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ getfsdev.o $(LIBS)
 
-TRIMSLASH_OBJ = trimslash.o syscall.o
+TRIMSLASH_OBJ = trimslash.o syscall.o lib/compat.o
 trimslash$(EXEEXT): $(TRIMSLASH_OBJ)
 	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $(TRIMSLASH_OBJ) $(LIBS)
 
--- backup.c	20 Sep 2004 19:46:45 -0000	1.38
+++ backup.c	23 Sep 2004 06:22:00 -0000
@@ -176,7 +176,6 @@ static int keep_backup(char *fname)
 	if (!(buf = get_backup_name(fname)))
 		return 0;
 
-#ifdef HAVE_MKNOD
 	/* Check to see if this is a device file, or link */
 	if (IS_DEVICE(file->mode)) {
 		if (am_root && preserve_devices) {
@@ -194,7 +193,6 @@ static int keep_backup(char *fname)
 		kept = 1;
 		do_unlink(fname);
 	}
-#endif
 
 	if (!kept && S_ISDIR(file->mode)) {
 		/* make an empty directory */
--- config.h.in	2 Aug 2004 21:54:49 -0000	1.92
+++ config.h.in	23 Sep 2004 06:22:00 -0000
@@ -209,6 +209,9 @@
 /* Define if you have strct sockaddr_storage. */
 #undef HAVE_SOCKADDR_STORAGE
 
+/* Do we have sockaddr_un.sun_len? */
+#undef HAVE_SOCKADDR_UN_LEN
+
 /* */
 #undef HAVE_SOCKETPAIR
 
@@ -342,6 +345,12 @@
    <sysmacros.h>. */
 #undef MAJOR_IN_SYSMACROS
 
+/* */
+#undef MKNOD_CREATES_FIFOS
+
+/* */
+#undef MKNOD_CREATES_SOCKETS
+
 /* Define to the address where bug reports for this package should be sent. */
 #undef PACKAGE_BUGREPORT
 
--- configure	21 Sep 2004 16:10:35 -0000	1.192
+++ configure	23 Sep 2004 06:22:02 -0000
@@ -8523,6 +8523,124 @@ _ACEOF
 fi
 
 
+echo "$as_me:$LINENO: checking for struct sockaddr_un.sun_len" >&5
+echo $ECHO_N "checking for struct sockaddr_un.sun_len... $ECHO_C" >&6
+if test "${ac_cv_member_struct_sockaddr_un_sun_len+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+
+
+int
+main ()
+{
+static struct sockaddr_un ac_aggr;
+if (ac_aggr.sun_len)
+return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_member_struct_sockaddr_un_sun_len=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+
+
+int
+main ()
+{
+static struct sockaddr_un ac_aggr;
+if (sizeof ac_aggr.sun_len)
+return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_member_struct_sockaddr_un_sun_len=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_member_struct_sockaddr_un_sun_len=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_member_struct_sockaddr_un_sun_len" >&5
+echo "${ECHO_T}$ac_cv_member_struct_sockaddr_un_sun_len" >&6
+if test $ac_cv_member_struct_sockaddr_un_sun_len = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_SOCKADDR_UN_LEN 1
+_ACEOF
+
+fi
+
+
 echo "$as_me:$LINENO: checking struct sockaddr_storage" >&5
 echo $ECHO_N "checking struct sockaddr_storage... $ECHO_C" >&6
 cat >conftest.$ac_ext <<_ACEOF
@@ -10219,6 +10337,120 @@ _ACEOF
 
 fi
 
+echo "$as_me:$LINENO: checking if mknod creates FIFOs" >&5
+echo $ECHO_N "checking if mknod creates FIFOs... $ECHO_C" >&6
+if test "${rsync_cv_MKNOD_CREATES_FIFOS+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "$cross_compiling" = yes; then
+  rsync_cv_MKNOD_CREATES_FIFOS=cross
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#include <stdio.h>
+#include <sys/stat.h>
+#include <errno.h>
+main() { int rc, ec; char *fn = "fifo-test";
+unlink(fn); rc = mknod(fn,S_IFIFO,0600); ec = errno; unlink(fn);
+if (rc) {printf("%d %d\n",rc,ec); return ec;}
+return 0;}
+_ACEOF
+rm -f conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  rsync_cv_MKNOD_CREATES_FIFOS=yes
+else
+  echo "$as_me: program exited with status $ac_status" >&5
+echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+rsync_cv_MKNOD_CREATES_FIFOS=no
+fi
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+fi
+echo "$as_me:$LINENO: result: $rsync_cv_MKNOD_CREATES_FIFOS" >&5
+echo "${ECHO_T}$rsync_cv_MKNOD_CREATES_FIFOS" >&6
+if test x"$rsync_cv_MKNOD_CREATES_FIFOS" = x"yes"; then
+
+cat >>confdefs.h <<\_ACEOF
+#define MKNOD_CREATES_FIFOS 1
+_ACEOF
+
+fi
+
+echo "$as_me:$LINENO: checking if mknod creates sockets" >&5
+echo $ECHO_N "checking if mknod creates sockets... $ECHO_C" >&6
+if test "${rsync_cv_MKNOD_CREATES_SOCKETS+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+if test "$cross_compiling" = yes; then
+  rsync_cv_MKNOD_CREATES_SOCKETS=cross
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#include <stdio.h>
+#include <sys/stat.h>
+#include <errno.h>
+main() { int rc, ec; char *fn = "sock-test";
+unlink(fn); rc = mknod(fn,S_IFSOCK,0600); ec = errno; unlink(fn);
+if (rc) {printf("%d %d\n",rc,ec); return ec;}
+return 0;}
+_ACEOF
+rm -f conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  rsync_cv_MKNOD_CREATES_SOCKETS=yes
+else
+  echo "$as_me: program exited with status $ac_status" >&5
+echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+rsync_cv_MKNOD_CREATES_SOCKETS=no
+fi
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+fi
+echo "$as_me:$LINENO: result: $rsync_cv_MKNOD_CREATES_SOCKETS" >&5
+echo "${ECHO_T}$rsync_cv_MKNOD_CREATES_SOCKETS" >&6
+if test x"$rsync_cv_MKNOD_CREATES_SOCKETS" = x"yes"; then
+
+cat >>confdefs.h <<\_ACEOF
+#define MKNOD_CREATES_SOCKETS 1
+_ACEOF
+
+fi
+
 #
 # The following test was mostly taken from the tcl/tk plus patches
 #
--- configure.in	21 Sep 2004 16:10:35 -0000	1.200
+++ configure.in	23 Sep 2004 06:22:02 -0000
@@ -409,6 +409,15 @@ AC_CHECK_MEMBER([struct sockaddr_in.sin_
 #include <netinet/in.h>
 ])
 
+AC_CHECK_MEMBER([struct sockaddr_un.sun_len],
+		[ AC_DEFINE(HAVE_SOCKADDR_UN_LEN, 1, [Do we have sockaddr_un.sun_len?]) ],
+		[],
+		[
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+])
+
 AC_MSG_CHECKING(struct sockaddr_storage)
 AC_TRY_COMPILE([#include <sys/types.h>
 #include <sys/socket.h>],
@@ -625,6 +634,34 @@ if test x"$rsync_cv_REPLACE_INET_ATON" =
     AC_DEFINE(REPLACE_INET_ATON, 1, [ ])
 fi
 
+AC_CACHE_CHECK([if mknod creates FIFOs],rsync_cv_MKNOD_CREATES_FIFOS,[
+AC_TRY_RUN([
+#include <stdio.h>
+#include <sys/stat.h>
+#include <errno.h>
+main() { int rc, ec; char *fn = "fifo-test";
+unlink(fn); rc = mknod(fn,S_IFIFO,0600); ec = errno; unlink(fn);
+if (rc) {printf("%d %d\n",rc,ec); return ec;}
+return 0;}],
+           rsync_cv_MKNOD_CREATES_FIFOS=yes,rsync_cv_MKNOD_CREATES_FIFOS=no,rsync_cv_MKNOD_CREATES_FIFOS=cross)])
+if test x"$rsync_cv_MKNOD_CREATES_FIFOS" = x"yes"; then
+    AC_DEFINE(MKNOD_CREATES_FIFOS, 1, [ ])
+fi
+
+AC_CACHE_CHECK([if mknod creates sockets],rsync_cv_MKNOD_CREATES_SOCKETS,[
+AC_TRY_RUN([
+#include <stdio.h>
+#include <sys/stat.h>
+#include <errno.h>
+main() { int rc, ec; char *fn = "sock-test";
+unlink(fn); rc = mknod(fn,S_IFSOCK,0600); ec = errno; unlink(fn);
+if (rc) {printf("%d %d\n",rc,ec); return ec;}
+return 0;}],
+           rsync_cv_MKNOD_CREATES_SOCKETS=yes,rsync_cv_MKNOD_CREATES_SOCKETS=no,rsync_cv_MKNOD_CREATES_SOCKETS=cross)])
+if test x"$rsync_cv_MKNOD_CREATES_SOCKETS" = x"yes"; then
+    AC_DEFINE(MKNOD_CREATES_SOCKETS, 1, [ ])
+fi
+
 #
 # The following test was mostly taken from the tcl/tk plus patches
 #
--- generator.c	20 Sep 2004 19:47:59 -0000	1.114
+++ generator.c	23 Sep 2004 06:22:02 -0000
@@ -385,7 +385,6 @@ static void recv_generator(char *fname, 
 		return;
 	}
 
-#ifdef HAVE_MKNOD
 	if (am_root && preserve_devices && IS_DEVICE(file->mode)) {
 		if (statret != 0 ||
 		    st.st_mode != file->mode ||
@@ -411,7 +410,6 @@ static void recv_generator(char *fname, 
 		}
 		return;
 	}
-#endif
 
 	if (preserve_hard_links && hard_link_check(file, HL_CHECK_MASTER))
 		return;
--- syscall.c	2 Aug 2004 21:56:07 -0000	1.31
+++ syscall.c	23 Sep 2004 06:22:02 -0000
@@ -26,6 +26,10 @@
 
 #include "rsync.h"
 
+#if !MKNOD_CREATES_SOCKETS && HAVE_SYS_UN_H
+#include <sys/un.h>
+#endif
+
 extern int dry_run;
 extern int read_only;
 extern int list_only;
@@ -71,14 +75,41 @@ int do_lchown(const char *path, uid_t ow
 	return lchown(path, owner, group);
 }
 
-#if HAVE_MKNOD
 int do_mknod(char *pathname, mode_t mode, dev_t dev)
 {
 	if (dry_run) return 0;
 	RETURN_ERROR_IF_RO_OR_LO;
+#if !MKNOD_CREATES_FIFOS && HAVE_MKFIFO
+	if (S_ISFIFO(mode))
+		return mkfifo(pathname, mode);
+#endif
+#if !MKNOD_CREATES_SOCKETS && HAVE_SYS_UN_H
+	if (S_ISSOCK(mode)) {
+		int sock;
+		struct sockaddr_un saddr;
+		unsigned int len;
+
+		saddr.sun_family = AF_UNIX;
+		len = strlcpy(saddr.sun_path, pathname, sizeof saddr.sun_path);
+#if HAVE_SOCKADDR_UN_LEN
+		saddr.sun_len = len >= sizeof saddr.sun_path
+			      ? sizeof saddr.sun_path : len + 1;
+#endif
+
+		if ((sock = socket(PF_UNIX, SOCK_STREAM, 0)) < 0
+		    || (unlink(pathname) < 0 && errno != ENOENT)
+		    || (bind(sock, (struct sockaddr*)&saddr, sizeof saddr)) < 0)
+			return -1;
+		close(sock);
+		return do_chmod(pathname, mode);
+	}
+#endif
+#if HAVE_MKNOD
 	return mknod(pathname, mode, dev);
-}
+#else
+	return -1;
 #endif
+}
 
 int do_rmdir(char *pathname)
 {
