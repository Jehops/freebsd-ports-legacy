#
# patch to fix compile/build time problems with FreeBSD
# patches to actually make the thing boot a FreeBSD kernel
# are separate...
#
diff -rNu ../../../virgin/etherboot-4.1/src-32/3c905b.c ./3c905b.c
--- ../../../virgin/etherboot-4.1/src-32/3c905b.c	Fri Mar  5 08:00:48 1999
+++ ./3c905b.c	Tue Apr 13 16:31:18 1999
@@ -31,7 +31,7 @@
 
 #include "etherboot.h"
 #include "nic.h"
-#include <linux/pci.h>
+/*#include <linux/pci.h>*/
 
 #define TIME_OUT 	100
 #define	XCVR_MAGIC	(0x5A00)
diff -rNu ../../../virgin/etherboot-4.1/src-32/config.c ./config.c
--- ../../../virgin/etherboot-4.1/src-32/config.c	Wed Mar 31 23:27:42 1999
+++ ./config.c	Tue Apr 13 16:31:19 1999
@@ -10,7 +10,7 @@
 	/* || others later */
 #if	defined(ETHERBOOT32)		/* only for 32 bit machines */
 #define	INCLUDE_PCI
-#include	<linux/pci.h>
+/*#include	<linux/pci.h>*/
 #include	"pci.h"
 static unsigned short	pci_ioaddrs[16];
 
diff -rNu ../../../virgin/etherboot-4.1/src-32/eepro100.c ./eepro100.c
--- ../../../virgin/etherboot-4.1/src-32/eepro100.c	Thu Jan 14 06:18:20 1999
+++ ./eepro100.c	Tue Apr 13 16:31:19 1999
@@ -103,7 +103,7 @@
 
 #include "etherboot.h"
 #include "nic.h"
-#include <linux/pci.h>
+/*#include <linux/pci.h>*/
 
 #undef	virt_to_bus
 #define	virt_to_bus(x)	((unsigned long)x)
diff -rNu ../../../virgin/etherboot-4.1/src-32/epic100.c ./epic100.c
--- ../../../virgin/etherboot-4.1/src-32/epic100.c	Thu Jan 14 06:19:05 1999
+++ ./epic100.c	Tue Apr 13 16:31:19 1999
@@ -4,7 +4,7 @@
 
 #include "etherboot.h"
 #include "nic.h"
-#include <linux/pci.h>
+/*#include <linux/pci.h>*/
 #include "epic100.h"
 
 #undef	virt_to_bus
diff -rNu ../../../virgin/etherboot-4.1/src-32/linux-asm-io.h ./linux-asm-io.h
--- ../../../virgin/etherboot-4.1/src-32/linux-asm-io.h	Wed Dec 31 18:00:00 1969
+++ ./linux-asm-io.h	Tue Apr 13 16:31:19 1999
@@ -0,0 +1,213 @@
+#ifndef _ASM_IO_H
+#define _ASM_IO_H
+
+/*
+ * This file contains the definitions for the x86 IO instructions
+ * inb/inw/inl/outb/outw/outl and the "string versions" of the same
+ * (insb/insw/insl/outsb/outsw/outsl). You can also use "pausing"
+ * versions of the single-IO instructions (inb_p/inw_p/..).
+ *
+ * This file is not meant to be obfuscating: it's just complicated
+ * to (a) handle it all in a way that makes gcc able to optimize it
+ * as well as possible and (b) trying to avoid writing the same thing
+ * over and over again with slight variations and possibly making a
+ * mistake somewhere.
+ */
+
+/*
+ * Thanks to James van Artsdalen for a better timing-fix than
+ * the two short jumps: using outb's to a nonexistent port seems
+ * to guarantee better timings even on fast machines.
+ *
+ * On the other hand, I'd like to be sure of a non-existent port:
+ * I feel a bit unsafe about using 0x80 (should be safe, though)
+ *
+ *		Linus
+ */
+
+#ifdef SLOW_IO_BY_JUMPING
+#define __SLOW_DOWN_IO __asm__ __volatile__("jmp 1f\n1:\tjmp 1f\n1:")
+#else
+#define __SLOW_DOWN_IO __asm__ __volatile__("outb %al,$0x80")
+#endif
+
+#ifdef REALLY_SLOW_IO
+#define SLOW_DOWN_IO { __SLOW_DOWN_IO; __SLOW_DOWN_IO; __SLOW_DOWN_IO; __SLOW_DOWN_IO; }
+#else
+#define SLOW_DOWN_IO __SLOW_DOWN_IO
+#endif
+
+/*
+ * Change virtual addresses to physical addresses and vv.
+ * These are trivial on the 1:1 Linux/i386 mapping (but if we ever
+ * make the kernel segment mapped at 0, we need to do translation
+ * on the i386 as well)
+ */
+extern inline unsigned long virt_to_phys(volatile void * address)
+{
+	return (unsigned long) address;
+}
+
+extern inline void * phys_to_virt(unsigned long address)
+{
+	return (void *) address;
+}
+
+/*
+ * IO bus memory addresses are also 1:1 with the physical address
+ */
+#define virt_to_bus virt_to_phys
+#define bus_to_virt phys_to_virt
+
+/*
+ * readX/writeX() are used to access memory mapped devices. On some
+ * architectures the memory mapped IO stuff needs to be accessed
+ * differently. On the x86 architecture, we just read/write the
+ * memory location directly.
+ */
+#define readb(addr) (*(volatile unsigned char *) (addr))
+#define readw(addr) (*(volatile unsigned short *) (addr))
+#define readl(addr) (*(volatile unsigned int *) (addr))
+
+#define writeb(b,addr) ((*(volatile unsigned char *) (addr)) = (b))
+#define writew(b,addr) ((*(volatile unsigned short *) (addr)) = (b))
+#define writel(b,addr) ((*(volatile unsigned int *) (addr)) = (b))
+
+#define memset_io(a,b,c)	memset((void *)(a),(b),(c))
+#define memcpy_fromio(a,b,c)	memcpy((a),(void *)(b),(c))
+#define memcpy_toio(a,b,c)	memcpy((void *)(a),(b),(c))
+
+/*
+ * Again, i386 does not require mem IO specific function.
+ */
+
+#define eth_io_copy_and_sum(a,b,c,d)	eth_copy_and_sum((a),(void *)(b),(c),(d))
+
+/*
+ * Talk about misusing macros..
+ */
+
+#define __OUT1(s,x) \
+extern inline void __out##s(unsigned x value, unsigned short port) {
+
+#define __OUT2(s,s1,s2) \
+__asm__ __volatile__ ("out" #s " %" s1 "0,%" s2 "1"
+
+#define __OUT(s,s1,x) \
+__OUT1(s,x) __OUT2(s,s1,"w") : : "a" (value), "d" (port)); } \
+__OUT1(s##c,x) __OUT2(s,s1,"") : : "a" (value), "id" (port)); } \
+__OUT1(s##_p,x) __OUT2(s,s1,"w") : : "a" (value), "d" (port)); SLOW_DOWN_IO; } \
+__OUT1(s##c_p,x) __OUT2(s,s1,"") : : "a" (value), "id" (port)); SLOW_DOWN_IO; }
+
+#define __IN1(s) \
+extern inline RETURN_TYPE __in##s(unsigned short port) { RETURN_TYPE _v;
+
+#define __IN2(s,s1,s2) \
+__asm__ __volatile__ ("in" #s " %" s2 "1,%" s1 "0"
+
+#define __IN(s,s1,i...) \
+__IN1(s) __IN2(s,s1,"w") : "=a" (_v) : "d" (port) ,##i ); return _v; } \
+__IN1(s##c) __IN2(s,s1,"") : "=a" (_v) : "id" (port) ,##i ); return _v; } \
+__IN1(s##_p) __IN2(s,s1,"w") : "=a" (_v) : "d" (port) ,##i ); SLOW_DOWN_IO; return _v; } \
+__IN1(s##c_p) __IN2(s,s1,"") : "=a" (_v) : "id" (port) ,##i ); SLOW_DOWN_IO; return _v; }
+
+#define __INS(s) \
+extern inline void ins##s(unsigned short port, void * addr, unsigned long count) \
+{ __asm__ __volatile__ ("cld ; rep ; ins" #s \
+: "=D" (addr), "=c" (count) : "d" (port),"0" (addr),"1" (count)); }
+
+#define __OUTS(s) \
+extern inline void outs##s(unsigned short port, const void * addr, unsigned long count) \
+{ __asm__ __volatile__ ("cld ; rep ; outs" #s \
+: "=S" (addr), "=c" (count) : "d" (port),"0" (addr),"1" (count)); }
+
+#define RETURN_TYPE unsigned char
+/* __IN(b,"b","0" (0)) */
+__IN(b,"")
+#undef RETURN_TYPE
+#define RETURN_TYPE unsigned short
+/* __IN(w,"w","0" (0)) */
+__IN(w,"")
+#undef RETURN_TYPE
+#define RETURN_TYPE unsigned int
+__IN(l,"")
+#undef RETURN_TYPE
+
+__OUT(b,"b",char)
+__OUT(w,"w",short)
+__OUT(l,,int)
+
+__INS(b)
+__INS(w)
+__INS(l)
+
+__OUTS(b)
+__OUTS(w)
+__OUTS(l)
+
+/*
+ * Note that due to the way __builtin_constant_p() works, you
+ *  - can't use it inside a inline function (it will never be true)
+ *  - you don't have to worry about side effects within the __builtin..
+ */
+#define outb(val,port) \
+((__builtin_constant_p((port)) && (port) < 256) ? \
+	__outbc((val),(port)) : \
+	__outb((val),(port)))
+
+#define inb(port) \
+((__builtin_constant_p((port)) && (port) < 256) ? \
+	__inbc(port) : \
+	__inb(port))
+
+#define outb_p(val,port) \
+((__builtin_constant_p((port)) && (port) < 256) ? \
+	__outbc_p((val),(port)) : \
+	__outb_p((val),(port)))
+
+#define inb_p(port) \
+((__builtin_constant_p((port)) && (port) < 256) ? \
+	__inbc_p(port) : \
+	__inb_p(port))
+
+#define outw(val,port) \
+((__builtin_constant_p((port)) && (port) < 256) ? \
+	__outwc((val),(port)) : \
+	__outw((val),(port)))
+
+#define inw(port) \
+((__builtin_constant_p((port)) && (port) < 256) ? \
+	__inwc(port) : \
+	__inw(port))
+
+#define outw_p(val,port) \
+((__builtin_constant_p((port)) && (port) < 256) ? \
+	__outwc_p((val),(port)) : \
+	__outw_p((val),(port)))
+
+#define inw_p(port) \
+((__builtin_constant_p((port)) && (port) < 256) ? \
+	__inwc_p(port) : \
+	__inw_p(port))
+
+#define outl(val,port) \
+((__builtin_constant_p((port)) && (port) < 256) ? \
+	__outlc((val),(port)) : \
+	__outl((val),(port)))
+
+#define inl(port) \
+((__builtin_constant_p((port)) && (port) < 256) ? \
+	__inlc(port) : \
+	__inl(port))
+
+#define outl_p(val,port) \
+((__builtin_constant_p((port)) && (port) < 256) ? \
+	__outlc_p((val),(port)) : \
+	__outl_p((val),(port)))
+
+#define inl_p(port) \
+((__builtin_constant_p((port)) && (port) < 256) ? \
+	__inlc_p(port) : \
+	__inl_p(port))
+
+#endif
diff -rNu ../../../virgin/etherboot-4.1/src-32/linuxdef.h ./linuxdef.h
--- ../../../virgin/etherboot-4.1/src-32/linuxdef.h	Fri Nov  6 04:53:58 1998
+++ ./linuxdef.h	Tue Apr 13 16:31:19 1999
@@ -1,7 +1,7 @@
 #ifndef __LINUXDEF_H__
 #define __LINUXDEF_H__
 
-#ifdef	__linux
+#if defined(__linux)
 #define	ETHERBOOT32
 #include <asm/byteorder.h>
 #include <asm/io.h>
@@ -9,6 +9,10 @@
    Someday I'll fix all the files. */
 #define	_edata	edata			/* ELF does not prepend a _ */
 #define	_end	end
+#else
+#define ETHERBOOT32
+#include <sys/types.h>
+#include "linux-asm-io.h"
 #endif
 
 #ifdef	__BCC__
diff -rNu ../../../virgin/etherboot-4.1/src-32/makerom.c ./makerom.c
--- ../../../virgin/etherboot-4.1/src-32/makerom.c	Sat Sep 19 07:54:00 1998
+++ ./makerom.c	Tue Apr 13 16:31:19 1999
@@ -79,6 +79,7 @@
 		memcpy(&rom[romsize-len-2], identstring, len);
 }
 
+
 /* Accepts a spec of the form vendorid,deviceid where the ids are
    numeric strings accepted by strtoul */
 void getpciids(char *spec)
@@ -155,13 +156,14 @@
 	/* If that is 0, choose the right size */
 	if (romsize == 0)
 		romsize = MAXROMSIZE;
-	if ((rom = malloc(romsize)) == 0) {
+	if ((rom = malloc(romsize+1)) == 0) {
 		fprintf(stderr, "Cannot malloc memory for ROM buffer\n");
 		exit(1);
 	}
 	/* fill with FFs, slightly less work for PROM burner
 	   and allows limited patching */
 	memset(rom, 0xFF, romsize);
+	rom[romsize]=0;
 	if ((fs = fread(rom, sizeof(char), romsize, fd)) < 0) {
 		perror("fread");
 		exit(1);
*** pci.h.orig	Wed Apr 21 05:24:33 1999
--- pci.h	Mon Jul 26 12:45:20 1999
***************
*** 89,96 ****
  #define PCI_DEVICE_ID_KTI_ET32P2        0x3000
  #define PCI_VENDOR_ID_NETVIN            0x4a14
  #define PCI_DEVICE_ID_NETVIN_NV5000SC   0x5000
  
! /*#define PCI_VENDOR_ID_SMC		0x10B8*/
  #ifndef PCI_DEVICE_ID_SMC_EPIC100
  # define PCI_DEVICE_ID_SMC_EPIC100	0x0005
  #endif
--- 89,107 ----
  #define PCI_DEVICE_ID_KTI_ET32P2        0x3000
  #define PCI_VENDOR_ID_NETVIN            0x4a14
  #define PCI_DEVICE_ID_NETVIN_NV5000SC   0x5000
+ #define PCI_VENDOR_ID_3COM		0x10b7
+ #define PCI_DEVICE_ID_3COM_3C905B_TX	0x9055
+ #define PCI_VENDOR_ID_INTEL		0x8086
+ #define PCI_DEVICE_ID_INTEL_82557	0x1229
+ #define PCI_VENDOR_ID_AMD		0x1022
+ #define PCI_DEVICE_ID_AMD_LANCE		0x2000
+ #define PCI_VENDOR_ID_DEC		0x1011
+ #define PCI_DEVICE_ID_DEC_TULIP		0x0002
+ #define PCI_DEVICE_ID_DEC_TULIP_FAST	0x0009
+ #define PCI_DEVICE_ID_DEC_TULIP_PLUS	0x0014
+ #define PCI_DEVICE_ID_DEC_21142		0x0019
  
! #define PCI_VENDOR_ID_SMC		0x10B8
  #ifndef PCI_DEVICE_ID_SMC_EPIC100
  # define PCI_DEVICE_ID_SMC_EPIC100	0x0005
  #endif
*** Makefile.orig	Mon Jul 26 13:45:33 1999
--- Makefile	Mon Jul 26 13:45:40 1999
***************
*** 74,79 ****
--- 74,80 ----
  VERSION=	4.2.4
  CFLAGS+=	-DVERSION=\"$(VERSION)\"
  CFLAGS+=	-DRELOC=$(RELOCADDR)
+ AS=		`echo ../../bin*/gas/as-new`
  # Stack must be below 640kb so we have real memory there
  # In 32 bit version, stack is automatically set using BIOS call 
  # to avoid trampling on extended BIOS area at top of 640kB
***************
*** 166,173 ****
  .S.s:
  	$(CC) $(LCONFIG) $(CFLAGS) $(ASFLAGS) -E $< > $@
  
  .S.o:
! 	$(CC) $(LCONFIG) $(CFLAGS) $(ASFLAGS) -c -o $@ $<
  
  # general rule for .roms, may be overriden
  .o.rom:	config-$*.o $(RLOADER) $(START)
--- 166,177 ----
  .S.s:
  	$(CC) $(LCONFIG) $(CFLAGS) $(ASFLAGS) -E $< > $@
  
+ #.S.o:
+ #	$(CC) $(LCONFIG) $(CFLAGS) $(ASFLAGS) -c -o $@ $<
+ 
  .S.o:
! 	$(CC) -E $(LCONFIG) $(CFLAGS) $(ASFLAGS) $< | \
!                 $(AS) $(ASFLAGS) -o $@
  
  # general rule for .roms, may be overriden
  .o.rom:	config-$*.o $(RLOADER) $(START)
--- Makefile.orig	Wed Jul 28 13:10:28 1999
+++ Makefile	Wed Jul 28 13:10:40 1999
@@ -110,7 +110,7 @@
 # If you have made changes to the *.asm files
 # and you want to rebuild *loader.bin and floppyload.bin and you have nasm
 # (not most people)
-#AS86=		nasm
+AS86=		nasm
 
 # if your as has trouble with .code16, .code32, or data32, uncomment this
 # but note that the premade start*.o will be larger than necessary because it
